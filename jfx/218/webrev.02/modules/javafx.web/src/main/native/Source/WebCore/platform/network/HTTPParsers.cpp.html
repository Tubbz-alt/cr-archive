<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   3  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   4  * Copyright (C) 2009 Torch Mobile Inc. http://www.torchmobile.com/
   5  * Copyright (C) 2009 Google Inc. All rights reserved.
   6  * Copyright (C) 2011 Apple Inc. All Rights Reserved.
   7  *
   8  * Redistribution and use in source and binary forms, with or without
   9  * modification, are permitted provided that the following conditions
  10  * are met:
  11  *
  12  * 1.  Redistributions of source code must retain the above copyright
  13  *     notice, this list of conditions and the following disclaimer.
  14  * 2.  Redistributions in binary form must reproduce the above copyright
  15  *     notice, this list of conditions and the following disclaimer in the
  16  *     documentation and/or other materials provided with the distribution.
  17  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  18  *     its contributors may be used to endorse or promote products derived
  19  *     from this software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  22  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  23  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  25  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  26  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  27  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  28  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  30  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;HTTPParsers.h&quot;
  35 
  36 #include &quot;HTTPHeaderField.h&quot;
  37 #include &quot;HTTPHeaderNames.h&quot;
  38 #include &quot;ParsedContentType.h&quot;
  39 #include &lt;wtf/DateMath.h&gt;
  40 #include &lt;wtf/Language.h&gt;
  41 #include &lt;wtf/NeverDestroyed.h&gt;
  42 #include &lt;wtf/Optional.h&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 #include &lt;wtf/unicode/CharacterNames.h&gt;
  45 
  46 
  47 namespace WebCore {
  48 
  49 // True if characters which satisfy the predicate are present, incrementing
  50 // &quot;pos&quot; to the next character which does not satisfy the predicate.
  51 // Note: might return pos == str.length().
  52 static inline bool skipWhile(const String&amp; str, unsigned&amp; pos, const WTF::Function&lt;bool(const UChar)&gt;&amp; predicate)
  53 {
  54     const unsigned start = pos;
  55     const unsigned len = str.length();
  56     while (pos &lt; len &amp;&amp; predicate(str[pos]))
  57         ++pos;
  58     return pos != start;
  59 }
  60 
  61 // true if there is more to parse, after incrementing pos past whitespace.
  62 // Note: Might return pos == str.length()
  63 static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  64 {
  65     skipWhile(str, pos, RFC7230::isWhitespace);
  66     return pos &lt; str.length();
  67 }
  68 
  69 // Returns true if the function can match the whole token (case insensitive)
  70 // incrementing pos on match, otherwise leaving pos unchanged.
  71 // Note: Might return pos == str.length()
  72 static inline bool skipToken(const String&amp; str, unsigned&amp; pos, const char* token)
  73 {
  74     unsigned len = str.length();
  75     unsigned current = pos;
  76 
  77     while (current &lt; len &amp;&amp; *token) {
  78         if (toASCIILower(str[current]) != *token++)
  79             return false;
  80         ++current;
  81     }
  82 
  83     if (*token)
  84         return false;
  85 
  86     pos = current;
  87     return true;
  88 }
  89 
  90 // True if the expected equals sign is seen and there is more to follow.
  91 static inline bool skipEquals(const String&amp; str, unsigned &amp;pos)
  92 {
  93     return skipWhiteSpace(str, pos) &amp;&amp; str[pos++] == &#39;=&#39; &amp;&amp; skipWhiteSpace(str, pos);
  94 }
  95 
  96 // True if a value present, incrementing pos to next space or semicolon, if any.
  97 // Note: might return pos == str.length().
  98 static inline bool skipValue(const String&amp; str, unsigned&amp; pos)
  99 {
 100     unsigned start = pos;
 101     unsigned len = str.length();
 102     while (pos &lt; len) {
 103         if (str[pos] == &#39; &#39; || str[pos] == &#39;\t&#39; || str[pos] == &#39;;&#39;)
 104             break;
 105         ++pos;
 106     }
 107     return pos != start;
 108 }
 109 
 110 // See RFC 7230, Section 3.1.2.
 111 bool isValidReasonPhrase(const String&amp; value)
 112 {
 113     for (unsigned i = 0; i &lt; value.length(); ++i) {
 114         UChar c = value[i];
 115         if (c == 0x7F || !isLatin1(c) || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 116             return false;
 117     }
 118     return true;
 119 }
 120 
 121 // See https://fetch.spec.whatwg.org/#concept-header
 122 bool isValidHTTPHeaderValue(const String&amp; value)
 123 {
 124     UChar c = value[0];
 125     if (c == &#39; &#39; || c == &#39;\t&#39;)
 126         return false;
 127     c = value[value.length() - 1];
 128     if (c == &#39; &#39; || c == &#39;\t&#39;)
 129         return false;
 130     for (unsigned i = 0; i &lt; value.length(); ++i) {
 131         c = value[i];
 132         ASSERT(isLatin1(c));
 133         if (c == 0x00 || c == 0x0A || c == 0x0D)
 134             return false;
 135     }
 136     return true;
 137 }
 138 
 139 // See RFC 7231, Section 5.3.2.
 140 bool isValidAcceptHeaderValue(const String&amp; value)
 141 {
 142     for (unsigned i = 0; i &lt; value.length(); ++i) {
 143         UChar c = value[i];
 144 
 145         // First check for alphanumeric for performance reasons then whitelist four delimiter characters.
 146         if (isASCIIAlphanumeric(c) || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 147             continue;
 148 
 149         ASSERT(isLatin1(c));
 150         if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 151             return false;
 152 
 153         if (RFC7230::isDelimiter(c))
 154             return false;
 155     }
 156 
 157     return true;
 158 }
 159 
 160 static bool containsCORSUnsafeRequestHeaderBytes(const String&amp; value)
 161 {
 162     for (unsigned i = 0; i &lt; value.length(); ++i) {
 163         UChar c = value[i];
 164         // https://fetch.spec.whatwg.org/#cors-unsafe-request-header-byte
 165         if ((c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;) || (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;:&#39; || c == &#39;&lt;&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39;
 166             || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39; || c == &#39;]&#39; || c == 0x7B || c == &#39;{&#39; || c == &#39;}&#39; || c == 0x7F))
 167             return true;
 168     }
 169 
 170     return false;
 171 }
 172 
 173 // See RFC 7231, Section 5.3.5 and 3.1.3.2.
 174 bool isValidLanguageHeaderValue(const String&amp; value)
 175 {
 176     for (unsigned i = 0; i &lt; value.length(); ++i) {
 177         UChar c = value[i];
 178         if (isASCIIAlphanumeric(c) || c == &#39; &#39; || c == &#39;*&#39; || c == &#39;,&#39; || c == &#39;-&#39; || c == &#39;.&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 179             continue;
 180         return false;
 181     }
 182 
 183     // FIXME: Validate further by splitting into language tags and optional quality
 184     // values (q=) and then check each language tag.
 185     // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
 186     // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
 187     return true;
 188 }
 189 
 190 // See RFC 7230, Section 3.2.6.
 191 bool isValidHTTPToken(const String&amp; value)
 192 {
 193     if (value.isEmpty())
 194         return false;
 195     auto valueStringView = StringView(value);
 196     for (UChar c : valueStringView.codeUnits()) {
 197         if (!RFC7230::isTokenCharacter(c))
 198             return false;
 199     }
 200     return true;
 201 }
 202 
 203 #if USE(GLIB)
 204 // True if the character at the given position satisifies a predicate, incrementing &quot;pos&quot; by one.
 205 // Note: Might return pos == str.length()
 206 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, WTF::Function&lt;bool(const UChar)&gt;&amp;&amp; predicate)
 207 {
 208     if (pos &lt; value.length() &amp;&amp; predicate(value[pos])) {
 209         ++pos;
 210         return true;
 211     }
 212     return false;
 213 }
 214 
 215 // True if the &quot;expected&quot; character is at the given position, incrementing &quot;pos&quot; by one.
 216 // Note: Might return pos == str.length()
 217 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, const UChar expected)
 218 {
 219     return skipCharacter(value, pos, [expected](const UChar c) {
 220         return c == expected;
 221     });
 222 }
 223 
 224 // True if a quoted pair is present, incrementing &quot;pos&quot; to the position after the quoted pair.
 225 // Note: Might return pos == str.length()
 226 // See RFC 7230, Section 3.2.6.
 227 static constexpr auto QuotedPairStartCharacter = &#39;\\&#39;;
 228 static bool skipQuotedPair(const String&amp; value, unsigned&amp; pos)
 229 {
 230     // quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )
 231     return skipCharacter(value, pos, QuotedPairStartCharacter)
 232         &amp;&amp; skipCharacter(value, pos, RFC7230::isQuotedPairSecondOctet);
 233 }
 234 
 235 // True if a comment is present, incrementing &quot;pos&quot; to the position after the comment.
 236 // Note: Might return pos == str.length()
 237 // See RFC 7230, Section 3.2.6.
 238 static constexpr auto CommentStartCharacter = &#39;(&#39;;
 239 static constexpr auto CommentEndCharacter = &#39;)&#39;;
 240 static bool skipComment(const String&amp; value, unsigned&amp; pos)
 241 {
 242     // comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
 243     // ctext   = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
 244     if (!skipCharacter(value, pos, CommentStartCharacter))
 245         return false;
 246 
 247     const unsigned end = value.length();
 248     while (pos &lt; end &amp;&amp; value[pos] != CommentEndCharacter) {
 249         switch (value[pos]) {
 250         case CommentStartCharacter:
 251             if (!skipComment(value, pos))
 252                 return false;
 253             break;
 254         case QuotedPairStartCharacter:
 255             if (!skipQuotedPair(value, pos))
 256                 return false;
 257             break;
 258         default:
 259             if (!skipWhile(value, pos, RFC7230::isCommentText))
 260                 return false;
 261         }
 262     }
 263     return skipCharacter(value, pos, CommentEndCharacter);
 264 }
 265 
 266 // True if an HTTP header token is present, incrementing &quot;pos&quot; to the position after it.
 267 // Note: Might return pos == str.length()
 268 // See RFC 7230, Section 3.2.6.
 269 static bool skipHTTPToken(const String&amp; value, unsigned&amp; pos)
 270 {
 271     return skipWhile(value, pos, RFC7230::isTokenCharacter);
 272 }
 273 
 274 // True if a product specifier (as in an User-Agent header) is present, incrementing &quot;pos&quot; to the position after it.
 275 // Note: Might return pos == str.length()
 276 // See RFC 7231, Section 5.5.3.
 277 static bool skipUserAgentProduct(const String&amp; value, unsigned&amp; pos)
 278 {
 279     // product         = token [&quot;/&quot; product-version]
 280     // product-version = token
 281     if (!skipHTTPToken(value, pos))
 282         return false;
 283     if (skipCharacter(value, pos, &#39;/&#39;))
 284         return skipHTTPToken(value, pos);
 285     return true;
 286 }
 287 
 288 // See RFC 7231, Section 5.5.3
 289 bool isValidUserAgentHeaderValue(const String&amp; value)
 290 {
 291     // User-Agent = product *( RWS ( product / comment ) )
 292     unsigned pos = 0;
 293     if (!skipUserAgentProduct(value, pos))
 294         return false;
 295 
 296     while (pos &lt; value.length()) {
 297         if (!skipWhiteSpace(value, pos))
 298             return false;
 299         if (value[pos] == CommentStartCharacter) {
 300             if (!skipComment(value, pos))
 301                 return false;
 302         } else {
 303             if (!skipUserAgentProduct(value, pos))
 304                 return false;
 305         }
 306     }
 307 
 308     return pos == value.length();
 309 }
 310 #endif
 311 
 312 static const size_t maxInputSampleSize = 128;
 313 static String trimInputSample(const char* p, size_t length)
 314 {
 315     String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
 316     if (length &gt; maxInputSampleSize)
 317         s.append(horizontalEllipsis);
 318     return s;
 319 }
 320 
 321 Optional&lt;WallTime&gt; parseHTTPDate(const String&amp; value)
 322 {
 323     double dateInMillisecondsSinceEpoch = parseDateFromNullTerminatedCharacters(value.utf8().data());
 324     if (!std::isfinite(dateInMillisecondsSinceEpoch))
 325         return WTF::nullopt;
 326     // This assumes system_clock epoch equals Unix epoch which is true for all implementations but unspecified.
 327     // FIXME: The parsing function should be switched to WallTime too.
 328     return WallTime::fromRawSeconds(dateInMillisecondsSinceEpoch / 1000.0);
 329 }
 330 
 331 // FIXME: This function doesn&#39;t comply with RFC 6266.
 332 // For example, this function doesn&#39;t handle the interaction between &quot; and ;
 333 // that arises from quoted-string, nor does this function properly unquote
 334 // attribute values. Further this function appears to process parameter names
 335 // in a case-sensitive manner. (There are likely other bugs as well.)
 336 String filenameFromHTTPContentDisposition(const String&amp; value)
 337 {
 338     for (auto&amp; keyValuePair : value.split(&#39;;&#39;)) {
 339         size_t valueStartPos = keyValuePair.find(&#39;=&#39;);
 340         if (valueStartPos == notFound)
 341             continue;
 342 
 343         String key = keyValuePair.left(valueStartPos).stripWhiteSpace();
 344 
 345         if (key.isEmpty() || key != &quot;filename&quot;)
 346             continue;
 347 
 348         String value = keyValuePair.substring(valueStartPos + 1).stripWhiteSpace();
 349 
 350         // Remove quotes if there are any
 351         if (value[0] == &#39;\&quot;&#39;)
 352             value = value.substring(1, value.length() - 2);
 353 
 354         return value;
 355     }
 356 
 357     return String();
 358 }
 359 
 360 String extractMIMETypeFromMediaType(const String&amp; mediaType)
 361 {
 362     unsigned position = 0;
 363     unsigned length = mediaType.length();
 364 
 365     for (; position &lt; length; ++position) {
 366         UChar c = mediaType[position];
 367         if (c != &#39;\t&#39; &amp;&amp; c != &#39; &#39;)
 368             break;
 369     }
 370 
 371     if (position == length)
 372         return mediaType;
 373 
 374     unsigned typeStart = position;
 375 
 376     unsigned typeEnd = position;
 377     for (; position &lt; length; ++position) {
 378         UChar c = mediaType[position];
 379 
 380         // While RFC 2616 does not allow it, other browsers allow multiple values in the HTTP media
 381         // type header field, Content-Type. In such cases, the media type string passed here may contain
 382         // the multiple values separated by commas. For now, this code ignores text after the first comma,
 383         // which prevents it from simply failing to parse such types altogether. Later for better
 384         // compatibility we could consider using the first or last valid MIME type instead.
 385         // See https://bugs.webkit.org/show_bug.cgi?id=25352 for more discussion.
 386         if (c == &#39;,&#39;)
 387             break;
 388 
 389         if (c == &#39;\t&#39; || c == &#39; &#39; || c == &#39;;&#39;)
 390             break;
 391 
 392         typeEnd = position + 1;
 393     }
 394 
 395     return mediaType.substring(typeStart, typeEnd - typeStart);
 396 }
 397 
 398 String extractCharsetFromMediaType(const String&amp; mediaType)
 399 {
 400     unsigned int pos, len;
 401     findCharsetInMediaType(mediaType, pos, len);
 402     return mediaType.substring(pos, len);
 403 }
 404 
 405 void findCharsetInMediaType(const String&amp; mediaType, unsigned int&amp; charsetPos, unsigned int&amp; charsetLen, unsigned int start)
 406 {
 407     charsetPos = start;
 408     charsetLen = 0;
 409 
 410     size_t pos = start;
 411     unsigned length = mediaType.length();
 412 
 413     while (pos &lt; length) {
 414         pos = mediaType.findIgnoringASCIICase(&quot;charset&quot;, pos);
 415         if (pos == notFound || pos == 0) {
 416             charsetLen = 0;
 417             return;
 418         }
 419 
 420         // is what we found a beginning of a word?
 421         if (mediaType[pos-1] &gt; &#39; &#39; &amp;&amp; mediaType[pos-1] != &#39;;&#39;) {
 422             pos += 7;
 423             continue;
 424         }
 425 
 426         pos += 7;
 427 
 428         // skip whitespace
 429         while (pos != length &amp;&amp; mediaType[pos] &lt;= &#39; &#39;)
 430             ++pos;
 431 
 432         if (mediaType[pos++] != &#39;=&#39;) // this &quot;charset&quot; substring wasn&#39;t a parameter name, but there may be others
 433             continue;
 434 
 435         while (pos != length &amp;&amp; (mediaType[pos] &lt;= &#39; &#39; || mediaType[pos] == &#39;&quot;&#39; || mediaType[pos] == &#39;\&#39;&#39;))
 436             ++pos;
 437 
 438         // we don&#39;t handle spaces within quoted parameter values, because charset names cannot have any
 439         unsigned endpos = pos;
 440         while (pos != length &amp;&amp; mediaType[endpos] &gt; &#39; &#39; &amp;&amp; mediaType[endpos] != &#39;&quot;&#39; &amp;&amp; mediaType[endpos] != &#39;\&#39;&#39; &amp;&amp; mediaType[endpos] != &#39;;&#39;)
 441             ++endpos;
 442 
 443         charsetPos = pos;
 444         charsetLen = endpos - pos;
 445         return;
 446     }
 447 }
 448 
 449 XSSProtectionDisposition parseXSSProtectionHeader(const String&amp; header, String&amp; failureReason, unsigned&amp; failurePosition, String&amp; reportURL)
 450 {
 451     static NeverDestroyed&lt;String&gt; failureReasonInvalidToggle(MAKE_STATIC_STRING_IMPL(&quot;expected 0 or 1&quot;));
 452     static NeverDestroyed&lt;String&gt; failureReasonInvalidSeparator(MAKE_STATIC_STRING_IMPL(&quot;expected semicolon&quot;));
 453     static NeverDestroyed&lt;String&gt; failureReasonInvalidEquals(MAKE_STATIC_STRING_IMPL(&quot;expected equals sign&quot;));
 454     static NeverDestroyed&lt;String&gt; failureReasonInvalidMode(MAKE_STATIC_STRING_IMPL(&quot;invalid mode directive&quot;));
 455     static NeverDestroyed&lt;String&gt; failureReasonInvalidReport(MAKE_STATIC_STRING_IMPL(&quot;invalid report directive&quot;));
 456     static NeverDestroyed&lt;String&gt; failureReasonDuplicateMode(MAKE_STATIC_STRING_IMPL(&quot;duplicate mode directive&quot;));
 457     static NeverDestroyed&lt;String&gt; failureReasonDuplicateReport(MAKE_STATIC_STRING_IMPL(&quot;duplicate report directive&quot;));
 458     static NeverDestroyed&lt;String&gt; failureReasonInvalidDirective(MAKE_STATIC_STRING_IMPL(&quot;unrecognized directive&quot;));
 459 
 460     unsigned pos = 0;
 461 
 462     if (!skipWhiteSpace(header, pos))
 463         return XSSProtectionDisposition::Enabled;
 464 
 465     if (header[pos] == &#39;0&#39;)
 466         return XSSProtectionDisposition::Disabled;
 467 
 468     if (header[pos++] != &#39;1&#39;) {
 469         failureReason = failureReasonInvalidToggle;
 470         return XSSProtectionDisposition::Invalid;
 471     }
 472 
 473     XSSProtectionDisposition result = XSSProtectionDisposition::Enabled;
 474     bool modeDirectiveSeen = false;
 475     bool reportDirectiveSeen = false;
 476 
 477     while (1) {
 478         // At end of previous directive: consume whitespace, semicolon, and whitespace.
 479         if (!skipWhiteSpace(header, pos))
 480             return result;
 481 
 482         if (header[pos++] != &#39;;&#39;) {
 483             failureReason = failureReasonInvalidSeparator;
 484             failurePosition = pos;
 485             return XSSProtectionDisposition::Invalid;
 486         }
 487 
 488         if (!skipWhiteSpace(header, pos))
 489             return result;
 490 
 491         // At start of next directive.
 492         if (skipToken(header, pos, &quot;mode&quot;)) {
 493             if (modeDirectiveSeen) {
 494                 failureReason = failureReasonDuplicateMode;
 495                 failurePosition = pos;
 496                 return XSSProtectionDisposition::Invalid;
 497             }
 498             modeDirectiveSeen = true;
 499             if (!skipEquals(header, pos)) {
 500                 failureReason = failureReasonInvalidEquals;
 501                 failurePosition = pos;
 502                 return XSSProtectionDisposition::Invalid;
 503             }
 504             if (!skipToken(header, pos, &quot;block&quot;)) {
 505                 failureReason = failureReasonInvalidMode;
 506                 failurePosition = pos;
 507                 return XSSProtectionDisposition::Invalid;
 508             }
 509             result = XSSProtectionDisposition::BlockEnabled;
 510         } else if (skipToken(header, pos, &quot;report&quot;)) {
 511             if (reportDirectiveSeen) {
 512                 failureReason = failureReasonDuplicateReport;
 513                 failurePosition = pos;
 514                 return XSSProtectionDisposition::Invalid;
 515             }
 516             reportDirectiveSeen = true;
 517             if (!skipEquals(header, pos)) {
 518                 failureReason = failureReasonInvalidEquals;
 519                 failurePosition = pos;
 520                 return XSSProtectionDisposition::Invalid;
 521             }
 522             size_t startPos = pos;
 523             if (!skipValue(header, pos)) {
 524                 failureReason = failureReasonInvalidReport;
 525                 failurePosition = pos;
 526                 return XSSProtectionDisposition::Invalid;
 527             }
 528             reportURL = header.substring(startPos, pos - startPos);
 529             failurePosition = startPos; // If later semantic check deems unacceptable.
 530         } else {
 531             failureReason = failureReasonInvalidDirective;
 532             failurePosition = pos;
 533             return XSSProtectionDisposition::Invalid;
 534         }
 535     }
 536 }
 537 
 538 ContentTypeOptionsDisposition parseContentTypeOptionsHeader(StringView header)
 539 {
 540     StringView leftToken = header.left(header.find(&#39;,&#39;));
 541     if (equalLettersIgnoringASCIICase(stripLeadingAndTrailingHTTPSpaces(leftToken), &quot;nosniff&quot;))
 542         return ContentTypeOptionsNosniff;
 543     return ContentTypeOptionsNone;
 544 }
 545 
 546 // For example: &quot;HTTP/1.1 200 OK&quot; =&gt; &quot;OK&quot;.
 547 // Note that HTTP/2 does not include a reason phrase, so we return the empty atom.
 548 AtomString extractReasonPhraseFromHTTPStatusLine(const String&amp; statusLine)
 549 {
 550     StringView view = statusLine;
 551     size_t spacePos = view.find(&#39; &#39;);
 552 
 553     // Remove status code from the status line.
 554     spacePos = view.find(&#39; &#39;, spacePos + 1);
 555     if (spacePos == notFound)
 556         return emptyAtom();
 557 
 558     return view.substring(spacePos + 1).toAtomString();
 559 }
 560 
 561 XFrameOptionsDisposition parseXFrameOptionsHeader(const String&amp; header)
 562 {
 563     XFrameOptionsDisposition result = XFrameOptionsNone;
 564 
 565     if (header.isEmpty())
 566         return result;
 567 
 568     for (auto&amp; currentHeader : header.split(&#39;,&#39;)) {
 569         currentHeader = currentHeader.stripWhiteSpace();
 570         XFrameOptionsDisposition currentValue = XFrameOptionsNone;
 571         if (equalLettersIgnoringASCIICase(currentHeader, &quot;deny&quot;))
 572             currentValue = XFrameOptionsDeny;
 573         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;sameorigin&quot;))
 574             currentValue = XFrameOptionsSameOrigin;
 575         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;allowall&quot;))
 576             currentValue = XFrameOptionsAllowAll;
 577         else
 578             currentValue = XFrameOptionsInvalid;
 579 
 580         if (result == XFrameOptionsNone)
 581             result = currentValue;
 582         else if (result != currentValue)
 583             return XFrameOptionsConflict;
 584     }
 585     return result;
 586 }
 587 
 588 bool parseRange(const String&amp; range, long long&amp; rangeOffset, long long&amp; rangeEnd, long long&amp; rangeSuffixLength)
 589 {
 590     // The format of &quot;Range&quot; header is defined in RFC 2616 Section 14.35.1.
 591     // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1
 592     // We don&#39;t support multiple range requests.
 593 
 594     rangeOffset = rangeEnd = rangeSuffixLength = -1;
 595 
 596     // The &quot;bytes&quot; unit identifier should be present.
 597     static const unsigned bytesLength = 6;
 598     if (!startsWithLettersIgnoringASCIICase(range, &quot;bytes=&quot;))
 599         return false;
 600     // FIXME: The rest of this should use StringView.
 601     String byteRange = range.substring(bytesLength);
 602 
 603     // The &#39;-&#39; character needs to be present.
 604     int index = byteRange.find(&#39;-&#39;);
 605     if (index == -1)
 606         return false;
 607 
 608     // If the &#39;-&#39; character is at the beginning, the suffix length, which specifies the last N bytes, is provided.
 609     // Example:
 610     //     -500
 611     if (!index) {
 612         String suffixLengthString = byteRange.substring(index + 1).stripWhiteSpace();
 613         bool ok;
 614         long long value = suffixLengthString.toInt64Strict(&amp;ok);
 615         if (ok)
 616             rangeSuffixLength = value;
 617         return true;
 618     }
 619 
 620     // Otherwise, the first-byte-position and the last-byte-position are provied.
 621     // Examples:
 622     //     0-499
 623     //     500-
 624     String firstBytePosStr = byteRange.left(index).stripWhiteSpace();
 625     bool ok;
 626     long long firstBytePos = firstBytePosStr.toInt64Strict(&amp;ok);
 627     if (!ok)
 628         return false;
 629 
 630     String lastBytePosStr = byteRange.substring(index + 1).stripWhiteSpace();
 631     long long lastBytePos = -1;
 632     if (!lastBytePosStr.isEmpty()) {
 633         lastBytePos = lastBytePosStr.toInt64Strict(&amp;ok);
 634         if (!ok)
 635             return false;
 636     }
 637 
 638     if (firstBytePos &lt; 0 || !(lastBytePos == -1 || lastBytePos &gt;= firstBytePos))
 639         return false;
 640 
 641     rangeOffset = firstBytePos;
 642     rangeEnd = lastBytePos;
 643     return true;
 644 }
 645 
 646 // HTTP/1.1 - RFC 2616
 647 // http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1
 648 // Request-Line = Method SP Request-URI SP HTTP-Version CRLF
 649 size_t parseHTTPRequestLine(const char* data, size_t length, String&amp; failureReason, String&amp; method, String&amp; url, HTTPVersion&amp; httpVersion)
 650 {
 651     method = String();
 652     url = String();
 653     httpVersion = Unknown;
 654 
 655     const char* space1 = 0;
 656     const char* space2 = 0;
 657     const char* p;
 658     size_t consumedLength;
 659 
 660     for (p = data, consumedLength = 0; consumedLength &lt; length; p++, consumedLength++) {
 661         if (*p == &#39; &#39;) {
 662             if (!space1)
 663                 space1 = p;
 664             else if (!space2)
 665                 space2 = p;
 666         } else if (*p == &#39;\n&#39;)
 667             break;
 668     }
 669 
 670     // Haven&#39;t finished header line.
 671     if (consumedLength == length) {
 672         failureReason = &quot;Incomplete Request Line&quot;_s;
 673         return 0;
 674     }
 675 
 676     // RequestLine does not contain 3 parts.
 677     if (!space1 || !space2) {
 678         failureReason = &quot;Request Line does not appear to contain: &lt;Method&gt; &lt;Url&gt; &lt;HTTPVersion&gt;.&quot;_s;
 679         return 0;
 680     }
 681 
 682     // The line must end with &quot;\r\n&quot;.
 683     const char* end = p + 1;
 684     if (*(end - 2) != &#39;\r&#39;) {
 685         failureReason = &quot;Request line does not end with CRLF&quot;_s;
 686         return 0;
 687     }
 688 
 689     // Request Method.
 690     method = String(data, space1 - data); // For length subtract 1 for space, but add 1 for data being the first character.
 691 
 692     // Request URI.
 693     url = String(space1 + 1, space2 - space1 - 1); // For length subtract 1 for space.
 694 
 695     // HTTP Version.
 696     String httpVersionString(space2 + 1, end - space2 - 3); // For length subtract 1 for space, and 2 for &quot;\r\n&quot;.
 697     if (httpVersionString.length() != 8 || !httpVersionString.startsWith(&quot;HTTP/1.&quot;))
 698         httpVersion = Unknown;
 699     else if (httpVersionString[7] == &#39;0&#39;)
 700         httpVersion = HTTP_1_0;
 701     else if (httpVersionString[7] == &#39;1&#39;)
 702         httpVersion = HTTP_1_1;
 703     else
 704         httpVersion = Unknown;
 705 
 706     return end - data;
 707 }
 708 
 709 static inline bool isValidHeaderNameCharacter(const char* character)
 710 {
 711     // https://tools.ietf.org/html/rfc7230#section-3.2
 712     // A header name should only contain one or more of
 713     // alphanumeric or ! # $ % &amp; &#39; * + - . ^ _ ` | ~
 714     if (isASCIIAlphanumeric(*character))
 715         return true;
 716     switch (*character) {
 717     case &#39;!&#39;:
 718     case &#39;#&#39;:
 719     case &#39;$&#39;:
 720     case &#39;%&#39;:
 721     case &#39;&amp;&#39;:
 722     case &#39;\&#39;&#39;:
 723     case &#39;*&#39;:
 724     case &#39;+&#39;:
 725     case &#39;-&#39;:
 726     case &#39;.&#39;:
 727     case &#39;^&#39;:
 728     case &#39;_&#39;:
 729     case &#39;`&#39;:
 730     case &#39;|&#39;:
 731     case &#39;~&#39;:
 732         return true;
 733     default:
 734         return false;
 735     }
 736 }
 737 
 738 size_t parseHTTPHeader(const char* start, size_t length, String&amp; failureReason, StringView&amp; nameStr, String&amp; valueStr, bool strict)
 739 {
 740     const char* p = start;
 741     const char* end = start + length;
 742 
 743     Vector&lt;char&gt; name;
 744     Vector&lt;char&gt; value;
 745 
 746     bool foundFirstNameChar = false;
 747     const char* namePtr = nullptr;
 748     size_t nameSize = 0;
 749 
 750     nameStr = StringView();
 751     valueStr = String();
 752 
 753     for (; p &lt; end; p++) {
 754         switch (*p) {
 755         case &#39;\r&#39;:
 756             if (name.isEmpty()) {
 757                 if (p + 1 &lt; end &amp;&amp; *(p + 1) == &#39;\n&#39;)
 758                     return (p + 2) - start;
 759                 failureReason = makeString(&quot;CR doesn&#39;t follow LF in header name at &quot;, trimInputSample(p, end - p));
 760                 return 0;
 761             }
 762             failureReason = makeString(&quot;Unexpected CR in header name at &quot;, trimInputSample(name.data(), name.size()));
 763             return 0;
 764         case &#39;\n&#39;:
 765             failureReason = makeString(&quot;Unexpected LF in header name at &quot;, trimInputSample(name.data(), name.size()));
 766             return 0;
 767         case &#39;:&#39;:
 768             break;
 769         default:
 770             if (!isValidHeaderNameCharacter(p)) {
 771                 if (name.size() &lt; 1)
 772                     failureReason = &quot;Unexpected start character in header name&quot;;
 773                 else
 774                     failureReason = makeString(&quot;Unexpected character in header name at &quot;, trimInputSample(name.data(), name.size()));
 775                 return 0;
 776             }
 777             name.append(*p);
 778             if (!foundFirstNameChar) {
 779                 namePtr = p;
 780                 foundFirstNameChar = true;
 781             }
 782             continue;
 783         }
 784         if (*p == &#39;:&#39;) {
 785             ++p;
 786             break;
 787         }
 788     }
 789 
 790     nameSize = name.size();
 791     nameStr = StringView(namePtr, nameSize);
 792 
 793     for (; p &lt; end &amp;&amp; *p == 0x20; p++) { }
 794 
 795     for (; p &lt; end; p++) {
 796         switch (*p) {
 797         case &#39;\r&#39;:
 798             break;
 799         case &#39;\n&#39;:
 800             if (strict) {
 801                 failureReason = makeString(&quot;Unexpected LF in header value at &quot;, trimInputSample(value.data(), value.size()));
 802                 return 0;
 803             }
 804             break;
 805         default:
 806             value.append(*p);
 807         }
 808         if (*p == &#39;\r&#39; || (!strict &amp;&amp; *p == &#39;\n&#39;)) {
 809             ++p;
 810             break;
 811         }
 812     }
 813     if (p &gt;= end || (strict &amp;&amp; *p != &#39;\n&#39;)) {
 814         failureReason = makeString(&quot;CR doesn&#39;t follow LF after header value at &quot;, trimInputSample(p, end - p));
 815         return 0;
 816     }
 817     valueStr = String::fromUTF8(value.data(), value.size());
 818     if (valueStr.isNull()) {
 819         failureReason = &quot;Invalid UTF-8 sequence in header value&quot;_s;
 820         return 0;
 821     }
 822     return p - start;
 823 }
 824 
 825 size_t parseHTTPRequestBody(const char* data, size_t length, Vector&lt;unsigned char&gt;&amp; body)
 826 {
 827     body.clear();
 828     body.append(data, length);
 829 
 830     return length;
 831 }
 832 
 833 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-header-name&gt;.
 834 bool isForbiddenHeaderName(const String&amp; name)
 835 {
 836     HTTPHeaderName headerName;
 837     if (findHTTPHeaderName(name, headerName)) {
 838         switch (headerName) {
 839         case HTTPHeaderName::AcceptCharset:
 840         case HTTPHeaderName::AcceptEncoding:
 841         case HTTPHeaderName::AccessControlRequestHeaders:
 842         case HTTPHeaderName::AccessControlRequestMethod:
 843         case HTTPHeaderName::Connection:
 844         case HTTPHeaderName::ContentLength:
 845         case HTTPHeaderName::Cookie:
 846         case HTTPHeaderName::Cookie2:
 847         case HTTPHeaderName::Date:
 848         case HTTPHeaderName::DNT:
 849         case HTTPHeaderName::Expect:
 850         case HTTPHeaderName::Host:
 851         case HTTPHeaderName::KeepAlive:
 852         case HTTPHeaderName::Origin:
 853         case HTTPHeaderName::Referer:
 854         case HTTPHeaderName::TE:
 855         case HTTPHeaderName::Trailer:
 856         case HTTPHeaderName::TransferEncoding:
 857         case HTTPHeaderName::Upgrade:
 858         case HTTPHeaderName::Via:
 859             return true;
 860         default:
 861             break;
 862         }
 863     }
 864     return startsWithLettersIgnoringASCIICase(name, &quot;sec-&quot;) || startsWithLettersIgnoringASCIICase(name, &quot;proxy-&quot;);
 865 }
 866 
 867 // Implements &lt;https://fetch.spec.whatwg.org/#no-cors-safelisted-request-header-name&gt;.
 868 bool isNoCORSSafelistedRequestHeaderName(const String&amp; name)
 869 {
 870     HTTPHeaderName headerName;
 871     if (findHTTPHeaderName(name, headerName)) {
 872         switch (headerName) {
 873         case HTTPHeaderName::Accept:
 874         case HTTPHeaderName::AcceptLanguage:
 875         case HTTPHeaderName::ContentLanguage:
 876         case HTTPHeaderName::ContentType:
 877             return true;
 878         default:
 879             break;
 880         }
 881     }
 882     return false;
 883 }
 884 
 885 // Implements &lt;https://fetch.spec.whatwg.org/#privileged-no-cors-request-header-name&gt;.
 886 bool isPriviledgedNoCORSRequestHeaderName(const String&amp; name)
 887 {
 888     return equalLettersIgnoringASCIICase(name, &quot;range&quot;);
 889 }
 890 
 891 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-response-header-name&gt;.
 892 bool isForbiddenResponseHeaderName(const String&amp; name)
 893 {
 894     return equalLettersIgnoringASCIICase(name, &quot;set-cookie&quot;) || equalLettersIgnoringASCIICase(name, &quot;set-cookie2&quot;);
 895 }
 896 
 897 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-method&gt;.
 898 bool isForbiddenMethod(const String&amp; name)
 899 {
 900     return equalLettersIgnoringASCIICase(name, &quot;connect&quot;) || equalLettersIgnoringASCIICase(name, &quot;trace&quot;) || equalLettersIgnoringASCIICase(name, &quot;track&quot;);
 901 }
 902 
 903 bool isSimpleHeader(const String&amp; name, const String&amp; value)
 904 {
 905     HTTPHeaderName headerName;
 906     if (!findHTTPHeaderName(name, headerName))
 907         return false;
 908     return isCrossOriginSafeRequestHeader(headerName, value);
 909 }
 910 
 911 bool isCrossOriginSafeHeader(HTTPHeaderName name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
 912 {
 913     switch (name) {
 914     case HTTPHeaderName::CacheControl:
 915     case HTTPHeaderName::ContentLanguage:
 916     case HTTPHeaderName::ContentLength:
 917     case HTTPHeaderName::ContentType:
 918     case HTTPHeaderName::Expires:
 919     case HTTPHeaderName::LastModified:
 920     case HTTPHeaderName::Pragma:
 921     case HTTPHeaderName::Accept:
 922         return true;
 923     case HTTPHeaderName::SetCookie:
 924     case HTTPHeaderName::SetCookie2:
 925         return false;
 926     default:
 927         break;
 928     }
 929     return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
 930 }
 931 
 932 bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
 933 {
 934 #if ASSERT_ENABLED
 935     HTTPHeaderName headerName;
 936     ASSERT(!findHTTPHeaderName(name, headerName));
 937 #endif
 938     return accessControlExposeHeaderSet.contains(name);
 939 }
 940 
 941 // Implements https://fetch.spec.whatwg.org/#cors-safelisted-request-header
 942 bool isCrossOriginSafeRequestHeader(HTTPHeaderName name, const String&amp; value)
 943 {
 944     switch (name) {
 945     case HTTPHeaderName::Accept:
 946         if (!isValidAcceptHeaderValue(value))
 947             return false;
 948         break;
 949     case HTTPHeaderName::AcceptLanguage:
 950     case HTTPHeaderName::ContentLanguage:
 951         if (!isValidLanguageHeaderValue(value))
 952             return false;
 953         break;
 954     case HTTPHeaderName::ContentType: {
 955         // Preflight is required for MIME types that can not be sent via form submission.
 956         if (containsCORSUnsafeRequestHeaderBytes(value))
 957             return false;
 958         auto parsedContentType = ParsedContentType::create(value);
 959         if (!parsedContentType)
 960             return false;
 961         String mimeType = parsedContentType-&gt;mimeType();
 962         if (!(equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;)))
 963             return false;
 964         break;
 965     }
 966     default:
 967         // FIXME: Should we also make safe other headers (DPR, Downlink, Save-Data...)? That would require validating their values.
 968         return false;
 969     }
 970     return value.length() &lt;= 128;
 971 }
 972 
 973 // Implements &lt;https://fetch.spec.whatwg.org/#concept-method-normalize&gt;.
 974 String normalizeHTTPMethod(const String&amp; method)
 975 {
 976     const ASCIILiteral methods[] = { &quot;DELETE&quot;_s, &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;POST&quot;_s, &quot;PUT&quot;_s };
 977     for (auto value : methods) {
 978         if (equalIgnoringASCIICase(method, value.characters())) {
 979             // Don&#39;t bother allocating a new string if it&#39;s already all uppercase.
 980             if (method == value)
 981                 break;
 982             return value;
 983         }
 984     }
 985     return method;
 986 }
 987 
 988 // Defined by https://tools.ietf.org/html/rfc7231#section-4.2.1
 989 bool isSafeMethod(const String&amp; method)
 990 {
 991     const ASCIILiteral safeMethods[] = { &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;TRACE&quot;_s };
 992     for (auto value : safeMethods) {
 993         if (equalIgnoringASCIICase(method, value.characters()))
 994             return true;
 995     }
 996     return false;
 997 }
 998 
 999 CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView header)
1000 {
1001     auto strippedHeader = stripLeadingAndTrailingHTTPSpaces(header);
1002 
1003     if (strippedHeader.isEmpty())
1004         return CrossOriginResourcePolicy::None;
1005 
1006     if (strippedHeader == &quot;same-origin&quot;)
1007         return CrossOriginResourcePolicy::SameOrigin;
1008 
1009     if (strippedHeader == &quot;same-site&quot;)
1010         return CrossOriginResourcePolicy::SameSite;
1011 
1012     return CrossOriginResourcePolicy::Invalid;
1013 }
1014 
1015 }
    </pre>
  </body>
</html>
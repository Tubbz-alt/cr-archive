<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) Canon Inc. 2016
  3  * Copyright (C) 2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;AnimationTimeline.h&quot;
 29 
 30 #include &quot;Animation.h&quot;
 31 #include &quot;AnimationEffect.h&quot;
 32 #include &quot;AnimationList.h&quot;
 33 #include &quot;CSSAnimation.h&quot;
 34 #include &quot;CSSPropertyAnimation.h&quot;
 35 #include &quot;CSSTransition.h&quot;
 36 #include &quot;DocumentTimeline.h&quot;
 37 #include &quot;Element.h&quot;
 38 #include &quot;KeyframeEffect.h&quot;
 39 #include &quot;KeyframeEffectStack.h&quot;
 40 #include &quot;RenderStyle.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;StylePropertyShorthand.h&quot;
 43 #include &quot;StyleResolver.h&quot;
 44 #include &quot;WebAnimationUtilities.h&quot;
 45 #include &lt;wtf/text/TextStream.h&gt;
 46 #include &lt;wtf/text/WTFString.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 AnimationTimeline::AnimationTimeline()
 51 {
 52 }
 53 
 54 AnimationTimeline::~AnimationTimeline()
 55 {
 56 }
 57 
 58 void AnimationTimeline::forgetAnimation(WebAnimation* animation)
 59 {
 60     m_allAnimations.removeFirst(animation);
 61 }
 62 
 63 void AnimationTimeline::animationTimingDidChange(WebAnimation&amp; animation)
 64 {
 65     updateGlobalPosition(animation);
 66 
 67     if (m_animations.add(&amp;animation)) {
 68         m_allAnimations.append(makeWeakPtr(&amp;animation));
 69         auto* timeline = animation.timeline();
 70         if (timeline &amp;&amp; timeline != this)
 71             timeline-&gt;removeAnimation(animation);
 72     }
 73 }
 74 
 75 void AnimationTimeline::updateGlobalPosition(WebAnimation&amp; animation)
 76 {
 77     static uint64_t s_globalPosition = 0;
 78     if (!animation.globalPosition() &amp;&amp; animation.canHaveGlobalPosition())
 79         animation.setGlobalPosition(++s_globalPosition);
 80 }
 81 
 82 void AnimationTimeline::removeAnimation(WebAnimation&amp; animation)
 83 {
 84     ASSERT(!animation.timeline() || animation.timeline() == this);
 85     m_animations.remove(&amp;animation);
 86     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
 87         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target()) {
 88             animationWasRemovedFromElement(animation, *target);
 89             target-&gt;ensureKeyframeEffectStack().removeEffect(*downcast&lt;KeyframeEffect&gt;(animation.effect()));
 90         }
 91     }
 92 }
 93 
 94 Optional&lt;double&gt; AnimationTimeline::bindingsCurrentTime()
 95 {
 96     auto time = currentTime();
 97     if (!time)
 98         return WTF::nullopt;
 99     return secondsToWebAnimationsAPITime(*time);
100 }
101 
102 void AnimationTimeline::animationWasAddedToElement(WebAnimation&amp; animation, Element&amp; element)
103 {
104     [&amp;] () -&gt; ElementToAnimationsMap&amp; {
105         if (is&lt;CSSTransition&gt;(animation) &amp;&amp; downcast&lt;CSSTransition&gt;(animation).owningElement())
106             return m_elementToCSSTransitionsMap;
107         if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation).owningElement())
108             return m_elementToCSSAnimationsMap;
109         return m_elementToAnimationsMap;
110     }().ensure(&amp;element, [] {
111         return AnimationCollection { };
112     }).iterator-&gt;value.add(&amp;animation);
113 }
114 
115 static inline bool removeCSSTransitionFromMap(CSSTransition&amp; transition, Element&amp; element, HashMap&lt;Element*, AnimationTimeline::PropertyToTransitionMap&gt;&amp; map)
116 {
117     auto iterator = map.find(&amp;element);
118     if (iterator == map.end())
119         return false;
120 
121     auto&amp; cssTransitionsByProperty = iterator-&gt;value;
122 
123     auto transitionIterator = cssTransitionsByProperty.find(transition.property());
124     if (transitionIterator == cssTransitionsByProperty.end() || transitionIterator-&gt;value != &amp;transition)
125         return false;
126 
127     cssTransitionsByProperty.remove(transitionIterator);
128 
129     if (cssTransitionsByProperty.isEmpty())
130         map.remove(&amp;element);
131     return true;
132 }
133 
134 static inline void removeAnimationFromMapForElement(WebAnimation&amp; animation, AnimationTimeline::ElementToAnimationsMap&amp; map, Element&amp; element)
135 {
136     auto iterator = map.find(&amp;element);
137     if (iterator == map.end())
138         return;
139 
140     auto&amp; animations = iterator-&gt;value;
141     animations.remove(&amp;animation);
142     if (!animations.size())
143         map.remove(iterator);
144 }
145 
146 void AnimationTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
147 {
148     removeAnimationFromMapForElement(animation, m_elementToCSSTransitionsMap, element);
149     removeAnimationFromMapForElement(animation, m_elementToCSSAnimationsMap, element);
150     removeAnimationFromMapForElement(animation, m_elementToAnimationsMap, element);
151 
152     // Now, if we&#39;re dealing with a CSS Transition, we remove it from the m_elementToRunningCSSTransitionByCSSPropertyID map.
153     // We don&#39;t need to do this for CSS Animations because their timing can be set via CSS to end, which would cause this
154     // function to be called, but they should remain associated with their owning element until this is changed via a call
155     // to the JS API or changing the target element&#39;s animation-name property.
156     if (is&lt;CSSTransition&gt;(animation))
157         removeDeclarativeAnimationFromListsForOwningElement(animation, element);
158 }
159 
160 void AnimationTimeline::removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&amp; animation, Element&amp; element)
161 {
162     ASSERT(is&lt;DeclarativeAnimation&gt;(animation));
163 
164     if (is&lt;CSSTransition&gt;(animation)) {
165         auto&amp; transition = downcast&lt;CSSTransition&gt;(animation);
166         if (!removeCSSTransitionFromMap(transition, element, m_elementToRunningCSSTransitionByCSSPropertyID))
167             removeCSSTransitionFromMap(transition, element, m_elementToCompletedCSSTransitionByCSSPropertyID);
168     }
169 }
170 
171 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; AnimationTimeline::animationsForElement(Element&amp; element, Ordering ordering) const
172 {
173     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
174 
175     if (ordering == Ordering::Sorted) {
176         if (element.hasKeyframeEffects()) {
177             for (auto&amp; effect : element.ensureKeyframeEffectStack().sortedEffects())
178                 animations.append(effect-&gt;animation());
179         }
180     } else {
181         if (m_elementToCSSTransitionsMap.contains(&amp;element)) {
182             const auto&amp; cssTransitions = m_elementToCSSTransitionsMap.get(&amp;element);
183             animations.appendRange(cssTransitions.begin(), cssTransitions.end());
184         }
185         if (m_elementToCSSAnimationsMap.contains(&amp;element)) {
186             const auto&amp; cssAnimations = m_elementToCSSAnimationsMap.get(&amp;element);
187             animations.appendRange(cssAnimations.begin(), cssAnimations.end());
188         }
189         if (m_elementToAnimationsMap.contains(&amp;element)) {
190             const auto&amp; webAnimations = m_elementToAnimationsMap.get(&amp;element);
191             animations.appendRange(webAnimations.begin(), webAnimations.end());
192         }
193     }
194 
195     return animations;
196 }
197 
198 void AnimationTimeline::removeCSSAnimationCreatedByMarkup(Element&amp; element, CSSAnimation&amp; cssAnimation)
199 {
200     auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);
201     if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {
202         auto&amp; cssAnimations = iterator-&gt;value;
203         cssAnimations.remove(&amp;cssAnimation);
204         if (!cssAnimations.size())
205             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);
206     }
207 
208     if (!element.hasKeyframeEffects())
209         return;
210 
211     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();
212     auto* cssAnimationList = keyframeEffectStack.cssAnimationList();
213     if (!cssAnimationList || cssAnimationList-&gt;isEmpty())
214         return;
215 
216     auto&amp; backingAnimation = cssAnimation.backingAnimation();
217     for (size_t i = 0; i &lt; cssAnimationList-&gt;size(); ++i) {
218         if (cssAnimationList-&gt;animation(i) == backingAnimation) {
219             auto newAnimationList = cssAnimationList-&gt;copy();
220             newAnimationList-&gt;remove(i);
221             keyframeEffectStack.setCSSAnimationList(WTFMove(newAnimationList));
222             return;
223         }
224     }
225 }
226 
227 void AnimationTimeline::willDestroyRendererForElement(Element&amp; element)
228 {
229     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
230         cssTransition-&gt;cancel(WebAnimation::Silently::Yes);
231 
232     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {
233         if (is&lt;CSSAnimation&gt;(cssAnimation))
234             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));
235         cssAnimation-&gt;cancel(WebAnimation::Silently::Yes);
236     }
237 }
238 
239 void AnimationTimeline::elementWasRemoved(Element&amp; element)
240 {
241     willDestroyRendererForElement(element);
242 
243     m_elementToAnimationsMap.remove(&amp;element);
244     m_elementToCSSAnimationsMap.remove(&amp;element);
245     m_elementToCSSTransitionsMap.remove(&amp;element);
246     m_elementToRunningCSSTransitionByCSSPropertyID.remove(&amp;element);
247     m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);
248 }
249 
250 void AnimationTimeline::removeAnimationsForElement(Element&amp; element)
251 {
252     for (auto&amp; animation : animationsForElement(element))
253         animation-&gt;remove();
254 }
255 
256 void AnimationTimeline::willChangeRendererForElement(Element&amp; element)
257 {
258     for (auto&amp; animation : animationsForElement(element))
259         animation-&gt;willChangeRenderer();
260 }
261 
262 void AnimationTimeline::cancelDeclarativeAnimationsForElement(Element&amp; element)
263 {
264     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
265         cssTransition-&gt;cancel();
266     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {
267         if (is&lt;CSSAnimation&gt;(cssAnimation))
268             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));
269         cssAnimation-&gt;cancel();
270     }
271 }
272 
273 static bool shouldConsiderAnimation(Element&amp; element, const Animation&amp; animation)
274 {
275     if (!animation.isValidAnimation())
276         return false;
277 
278     static NeverDestroyed&lt;const String&gt; animationNameNone(MAKE_STATIC_STRING_IMPL(&quot;none&quot;));
279 
280     auto&amp; name = animation.name();
281     if (name == animationNameNone || name.isEmpty())
282         return false;
283 
284     if (auto* styleScope = Style::Scope::forOrdinal(element, animation.nameStyleScopeOrdinal()))
285         return styleScope-&gt;resolver().isAnimationNameValid(name);
286 
287     return false;
288 }
289 
290 void AnimationTimeline::updateCSSAnimationsForElement(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; afterChangeStyle)
291 {
292     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();
293 
294     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its animations and disregard new ones.
295     if (currentStyle &amp;&amp; currentStyle-&gt;display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {
296         auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);
297         if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {
298             auto&amp; cssAnimations = iterator-&gt;value;
299             for (auto&amp; cssAnimation : cssAnimations)
300                 cssAnimation-&gt;cancelFromStyle();
301             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);
302         }
303         keyframeEffectStack.setCSSAnimationList(nullptr);
304         return;
305     }
306 
307     auto* currentAnimationList = afterChangeStyle.animations();
308     auto* previousAnimationList = keyframeEffectStack.cssAnimationList();
309     if (previousAnimationList &amp;&amp; !previousAnimationList-&gt;isEmpty() &amp;&amp; afterChangeStyle.hasAnimations() &amp;&amp; *(previousAnimationList) == *(afterChangeStyle.animations()))
310         return;
311 
312     CSSAnimationCollection newAnimations;
313     auto&amp; previousAnimations = m_elementToCSSAnimationsCreatedByMarkupMap.ensure(&amp;element, [] {
314         return CSSAnimationCollection { };
315     }).iterator-&gt;value;
316 
317     // https://www.w3.org/TR/css-animations-1/#animations
318     // The same @keyframes rule name may be repeated within an animation-name. Changes to the animation-name update existing
319     // animations by iterating over the new list of animations from last to first, and, for each animation, finding the last
320     // matching animation in the list of existing animations. If a match is found, the existing animation is updated using the
321     // animation properties corresponding to its position in the new list of animations, whilst maintaining its current playback
322     // time as described above. The matching animation is removed from the existing list of animations such that it will not match
323     // twice. If a match is not found, a new animation is created. As a result, updating animation-name from ‘a’ to ‘a, a’ will
324     // cause the existing animation for ‘a’ to become the second animation in the list and a new animation will be created for the
325     // first item in the list.
326     if (currentAnimationList) {
327         for (size_t i = currentAnimationList-&gt;size(); i &gt; 0; --i) {
328             auto&amp; currentAnimation = currentAnimationList-&gt;animation(i - 1);
329             if (!shouldConsiderAnimation(element, currentAnimation))
330                 continue;
331 
332             bool foundMatchingAnimation = false;
333             for (auto&amp; previousAnimation : previousAnimations) {
334                 if (previousAnimation-&gt;animationName() == currentAnimation.name()) {
335                     // Timing properties or play state may have changed so we need to update the backing animation with
336                     // the Animation found in the current style.
337                     previousAnimation-&gt;setBackingAnimation(currentAnimation);
338                     newAnimations.add(previousAnimation);
339                     // Remove the matched animation from the list of previous animations so we may not match it again.
340                     previousAnimations.remove(previousAnimation);
341                     foundMatchingAnimation = true;
342                     break;
343                 }
344             }
345 
346             if (!foundMatchingAnimation)
347                 newAnimations.add(CSSAnimation::create(element, currentAnimation, currentStyle, afterChangeStyle));
348         }
349     }
350 
351     // Any animation found in previousAnimations but not found in newAnimations is not longer current and should be canceled.
352     for (auto&amp; previousAnimation : previousAnimations) {
353         if (!newAnimations.contains(previousAnimation)) {
354             if (previousAnimation-&gt;owningElement())
355                 previousAnimation-&gt;cancelFromStyle();
356         }
357     }
358 
359     if (newAnimations.isEmpty())
360         m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);
361     else
362         m_elementToCSSAnimationsCreatedByMarkupMap.set(&amp;element, WTFMove(newAnimations));
363 
364     keyframeEffectStack.setCSSAnimationList(currentAnimationList);
365 }
366 
367 static KeyframeEffect* keyframeEffectForElementAndProperty(Element&amp; element, CSSPropertyID property)
368 {
369     if (auto* keyframeEffectStack = element.keyframeEffectStack()) {
370         auto effects = keyframeEffectStack-&gt;sortedEffects();
371         for (const auto&amp; effect : makeReversedRange(effects)) {
372             if (effect-&gt;animatesProperty(property))
373                 return effect.get();
374         }
375     }
376 
377     return nullptr;
378 }
379 
380 static bool propertyInStyleMatchesValueForTransitionInMap(CSSPropertyID property, const RenderStyle&amp; style, AnimationTimeline::PropertyToTransitionMap&amp; transitions)
381 {
382     if (auto* transition = transitions.get(property)) {
383         if (CSSPropertyAnimation::propertiesEqual(property, &amp;style, &amp;transition-&gt;targetStyle()))
384             return true;
385     }
386     return false;
387 }
388 
389 static double transitionCombinedDuration(const Animation* transition)
390 {
391     return std::max(0.0, transition-&gt;duration()) + transition-&gt;delay();
392 }
393 
394 static bool transitionMatchesProperty(const Animation&amp; transition, CSSPropertyID property)
395 {
396     auto mode = transition.animationMode();
397     if (mode == Animation::AnimateNone || mode == Animation::AnimateUnknownProperty)
398         return false;
399     if (mode == Animation::AnimateSingleProperty) {
400         auto transitionProperty = transition.property();
401         if (transitionProperty != property) {
402             auto shorthand = shorthandForProperty(transitionProperty);
403             for (size_t i = 0; i &lt; shorthand.length(); ++i) {
404                 if (shorthand.properties()[i] == property)
405                     return true;
406             }
407             return false;
408         }
409     }
410     return true;
411 }
412 
413 AnimationTimeline::PropertyToTransitionMap&amp; AnimationTimeline::ensureRunningTransitionsByProperty(Element&amp; element)
414 {
415     return m_elementToRunningCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
416         return PropertyToTransitionMap { };
417     }).iterator-&gt;value;
418 }
419 
420 static void compileTransitionPropertiesInStyle(const RenderStyle&amp; style, HashSet&lt;CSSPropertyID&gt;&amp; transitionProperties, bool&amp; transitionPropertiesContainAll)
421 {
422     if (transitionPropertiesContainAll)
423         return;
424 
425     auto* transitions = style.transitions();
426     if (!transitions)
427         return;
428 
429     for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {
430         const auto&amp; animation = transitions-&gt;animation(i);
431         auto mode = animation.animationMode();
432         if (mode == Animation::AnimateSingleProperty) {
433             auto property = animation.property();
434             if (isShorthandCSSProperty(property)) {
435                 auto shorthand = shorthandForProperty(property);
436                 for (size_t j = 0; j &lt; shorthand.length(); ++j)
437                     transitionProperties.add(shorthand.properties()[j]);
438             } else if (property != CSSPropertyInvalid)
439                 transitionProperties.add(property);
440         } else if (mode == Animation::AnimateAll) {
441             transitionPropertiesContainAll = true;
442             return;
443         }
444     }
445 }
446 
447 void AnimationTimeline::updateCSSTransitionsForElementAndProperty(Element&amp; element, CSSPropertyID property, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle, AnimationTimeline::PropertyToTransitionMap&amp; runningTransitionsByProperty, PropertyToTransitionMap&amp; completedTransitionsByProperty, const MonotonicTime generationTime)
448 {
449     const Animation* matchingBackingAnimation = nullptr;
450     if (auto* transitions = afterChangeStyle.transitions()) {
451         for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {
452             auto&amp; backingAnimation = transitions-&gt;animation(i);
453             if (transitionMatchesProperty(backingAnimation, property))
454                 matchingBackingAnimation = &amp;backingAnimation;
455         }
456     }
457 
458     // https://drafts.csswg.org/css-transitions-1/#before-change-style
459     // Define the before-change style as the computed values of all properties on the element as of the previous style change event, except with
460     // any styles derived from declarative animations such as CSS Transitions, CSS Animations, and SMIL Animations updated to the current time.
461     bool hasRunningTransition = runningTransitionsByProperty.contains(property);
462     auto beforeChangeStyle = [&amp;]() {
463         if (hasRunningTransition &amp;&amp; CSSPropertyAnimation::animationOfPropertyIsAccelerated(property)) {
464             // In case we have an accelerated transition running for this element, we need to get its computed style as the before-change style
465             // since otherwise the animated value for that property won&#39;t be visible.
466             auto* runningTransition = runningTransitionsByProperty.get(property);
467             if (is&lt;KeyframeEffect&gt;(runningTransition-&gt;effect())) {
468                 auto&amp; keyframeEffect = *downcast&lt;KeyframeEffect&gt;(runningTransition-&gt;effect());
469                 if (keyframeEffect.isRunningAccelerated()) {
470                     auto animatedStyle = RenderStyle::clone(currentStyle);
471                     runningTransition-&gt;resolve(animatedStyle);
472                     return animatedStyle;
473                 }
474             }
475         }
476 
477         if (auto* keyframeEffect = keyframeEffectForElementAndProperty(element, property)) {
478             // If we already have a keyframe effect targeting this property, we should use its unanimated style to determine what the potential
479             // start value of the transition shoud be to make sure that we don&#39;t account for animated values that would have been blended onto
480             // the style applied during the last style resolution.
481             if (auto* unanimatedStyle = keyframeEffect-&gt;unanimatedStyle())
482                 return RenderStyle::clone(*unanimatedStyle);
483 
484             // If we have a keyframe effect targeting this property, but it doesn&#39;t yet have an unanimated style, this is because it has not
485             // had a chance to apply itself with a non-null progress. In this case, the before-change and after-change styles should be the
486             // same in order to prevent a transition from being triggered as the unanimated style for this keyframe effect will most likely
487             // be this after-change style, or any future style change that may happen before the keyframe effect starts blending animated values.
488             return RenderStyle::clone(afterChangeStyle);
489         }
490 
491         // In any other scenario, the before-change style should be the previously resolved style for this element.
492         return RenderStyle::clone(currentStyle);
493     }();
494 
495     if (!hasRunningTransition
496         &amp;&amp; !CSSPropertyAnimation::propertiesEqual(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)
497         &amp;&amp; CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)
498         &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)
499         &amp;&amp; matchingBackingAnimation &amp;&amp; transitionCombinedDuration(matchingBackingAnimation) &gt; 0) {
500         // 1. If all of the following are true:
501         //   - the element does not have a running transition for the property,
502         //   - the before-change style is different from and can be interpolated with the after-change style for that property,
503         //   - the element does not have a completed transition for the property or the end value of the completed transition is different from the after-change style for the property,
504         //   - there is a matching transition-property value, and
505         //   - the combined duration is greater than 0s,
506 
507         // then implementations must remove the completed transition (if present) from the set of completed transitions
508         completedTransitionsByProperty.remove(property);
509 
510         // and start a transition whose:
511         //   - start time is the time of the style change event plus the matching transition delay,
512         //   - end time is the start time plus the matching transition duration,
513         //   - start value is the value of the transitioning property in the before-change style,
514         //   - end value is the value of the transitioning property in the after-change style,
515         //   - reversing-adjusted start value is the same as the start value, and
516         //   - reversing shortening factor is 1.
517         auto delay = Seconds(matchingBackingAnimation-&gt;delay());
518         auto duration = Seconds(matchingBackingAnimation-&gt;duration());
519         auto&amp; reversingAdjustedStartStyle = beforeChangeStyle;
520         auto reversingShorteningFactor = 1;
521         runningTransitionsByProperty.set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;beforeChangeStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));
522     } else if (completedTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)) {
523         // 2. Otherwise, if the element has a completed transition for the property and the end value of the completed transition is different from
524         //    the after-change style for the property, then implementations must remove the completed transition from the set of completed transitions.
525         completedTransitionsByProperty.remove(property);
526     }
527 
528     hasRunningTransition = runningTransitionsByProperty.contains(property);
529     if ((hasRunningTransition || completedTransitionsByProperty.contains(property)) &amp;&amp; !matchingBackingAnimation) {
530         // 3. If the element has a running transition or completed transition for the property, and there is not a matching transition-property
531         //    value, then implementations must cancel the running transition or remove the completed transition from the set of completed transitions.
532         if (hasRunningTransition)
533             runningTransitionsByProperty.take(property)-&gt;cancel();
534         else
535             completedTransitionsByProperty.remove(property);
536     }
537 
538     if (matchingBackingAnimation &amp;&amp; runningTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, runningTransitionsByProperty)) {
539         auto previouslyRunningTransition = runningTransitionsByProperty.take(property);
540         auto&amp; previouslyRunningTransitionCurrentStyle = previouslyRunningTransition-&gt;currentStyle();
541         // 4. If the element has a running transition for the property, there is a matching transition-property value, and the end value of the running
542         //    transition is not equal to the value of the property in the after-change style, then:
543         if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;currentStyle, &amp;afterChangeStyle)) {
544             // 1. If the current value of the property in the running transition is equal to the value of the property in the after-change style,
545             //    or if these two values cannot be interpolated, then implementations must cancel the running transition.
546             previouslyRunningTransition-&gt;cancelFromStyle();
547         } else if (transitionCombinedDuration(matchingBackingAnimation) &lt;= 0.0 || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle)) {
548             // 2. Otherwise, if the combined duration is less than or equal to 0s, or if the current value of the property in the running transition
549             //    cannot be interpolated with the value of the property in the after-change style, then implementations must cancel the running transition.
550             previouslyRunningTransition-&gt;cancelFromStyle();
551         } else if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransition-&gt;reversingAdjustedStartStyle(), &amp;afterChangeStyle)) {
552             // 3. Otherwise, if the reversing-adjusted start value of the running transition is the same as the value of the property in the after-change
553             //    style (see the section on reversing of transitions for why these case exists), implementations must cancel the running transition
554             previouslyRunningTransition-&gt;cancelFromStyle();
555 
556             // and start a new transition whose:
557             //   - reversing-adjusted start value is the end value of the running transition,
558             //   - reversing shortening factor is the absolute value, clamped to the range [0, 1], of the sum of:
559             //       1. the output of the timing function of the old transition at the time of the style change event, times the reversing shortening factor of the old transition
560             //       2. 1 minus the reversing shortening factor of the old transition.
561             //   - start time is the time of the style change event plus:
562             //       1. if the matching transition delay is nonnegative, the matching transition delay, or
563             //       2. if the matching transition delay is negative, the product of the new transition’s reversing shortening factor and the matching transition delay,
564             //   - end time is the start time plus the product of the matching transition duration and the new transition’s reversing shortening factor,
565             //   - start value is the current value of the property in the running transition,
566             //   - end value is the value of the property in the after-change style
567             auto&amp; reversingAdjustedStartStyle = previouslyRunningTransition-&gt;targetStyle();
568             double transformedProgress = 1;
569             if (auto* effect = previouslyRunningTransition-&gt;effect()) {
570                 if (auto computedTimingProgress = effect-&gt;getComputedTiming().progress)
571                     transformedProgress = *computedTimingProgress;
572             }
573             auto reversingShorteningFactor = std::max(std::min(((transformedProgress * previouslyRunningTransition-&gt;reversingShorteningFactor()) + (1 - previouslyRunningTransition-&gt;reversingShorteningFactor())), 1.0), 0.0);
574             auto delay = matchingBackingAnimation-&gt;delay() &lt; 0 ? Seconds(matchingBackingAnimation-&gt;delay()) * reversingShorteningFactor : Seconds(matchingBackingAnimation-&gt;delay());
575             auto duration = Seconds(matchingBackingAnimation-&gt;duration()) * reversingShorteningFactor;
576 
577             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));
578         } else {
579             // 4. Otherwise, implementations must cancel the running transition
580             previouslyRunningTransition-&gt;cancelFromStyle();
581 
582             // and start a new transition whose:
583             //   - start time is the time of the style change event plus the matching transition delay,
584             //   - end time is the start time plus the matching transition duration,
585             //   - start value is the current value of the property in the running transition,
586             //   - end value is the value of the property in the after-change style,
587             //   - reversing-adjusted start value is the same as the start value, and
588             //   - reversing shortening factor is 1.
589             auto delay = Seconds(matchingBackingAnimation-&gt;delay());
590             auto duration = Seconds(matchingBackingAnimation-&gt;duration());
591             auto&amp; reversingAdjustedStartStyle = currentStyle;
592             auto reversingShorteningFactor = 1;
593             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));
594         }
595     }
596 }
597 
598 void AnimationTimeline::updateCSSTransitionsForElement(Element&amp; element, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle)
599 {
600     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its transitions and disregard new ones.
601     if (currentStyle.hasTransitions() &amp;&amp; currentStyle.display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {
602         if (m_elementToRunningCSSTransitionByCSSPropertyID.contains(&amp;element)) {
603             for (const auto&amp; cssTransitionsByCSSPropertyIDMapItem : m_elementToRunningCSSTransitionByCSSPropertyID.take(&amp;element))
604                 cssTransitionsByCSSPropertyIDMapItem.value-&gt;cancelFromStyle();
605         }
606         return;
607     }
608 
609     // Section 3 &quot;Starting of transitions&quot; from the CSS Transitions Level 1 specification.
610     // https://drafts.csswg.org/css-transitions-1/#starting
611 
612     auto&amp; runningTransitionsByProperty = ensureRunningTransitionsByProperty(element);
613 
614     auto&amp; completedTransitionsByProperty = m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
615         return PropertyToTransitionMap { };
616     }).iterator-&gt;value;
617 
618     auto generationTime = MonotonicTime::now();
619 
620     // First, let&#39;s compile the list of all CSS properties found in the current style and the after-change style.
621     bool transitionPropertiesContainAll = false;
622     HashSet&lt;CSSPropertyID&gt; transitionProperties;
623     compileTransitionPropertiesInStyle(currentStyle, transitionProperties, transitionPropertiesContainAll);
624     compileTransitionPropertiesInStyle(afterChangeStyle, transitionProperties, transitionPropertiesContainAll);
625 
626     if (transitionPropertiesContainAll) {
627         auto numberOfProperties = CSSPropertyAnimation::getNumProperties();
628         for (int propertyIndex = 0; propertyIndex &lt; numberOfProperties; ++propertyIndex) {
629             Optional&lt;bool&gt; isShorthand;
630             auto property = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);
631             if (isShorthand &amp;&amp; *isShorthand)
632                 continue;
633             updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);
634         }
635         return;
636     }
637 
638     for (auto property : transitionProperties)
639         updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);
640 }
641 
642 } // namespace WebCore
    </pre>
  </body>
</html>
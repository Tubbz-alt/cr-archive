<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Autocapitalize.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CanvasBase.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,28 +29,95 @@</span>
  #include &quot;CSSCanvasValue.h&quot;
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;FloatRect.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
<span class="udiff-line-added">+ #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;JavaScriptCore/JSLock.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;atomic&gt;</span>
  #include &lt;wtf/Vector.h&gt;
  
<span class="udiff-line-added">+ static std::atomic&lt;size_t&gt; s_activePixelMemory { 0 };</span>
<span class="udiff-line-added">+ </span>
  namespace WebCore {
  
<span class="udiff-line-modified-removed">- CanvasBase::CanvasBase()</span>
<span class="udiff-line-modified-added">+ #if USE(CG)</span>
<span class="udiff-line-added">+ // FIXME: It seems strange that the default quality is not the one that is literally named &quot;default&quot;.</span>
<span class="udiff-line-added">+ // Should fix names to make this easier to understand, or write an excellent comment here explaining why not.</span>
<span class="udiff-line-added">+ const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Low;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Default;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ CanvasBase::CanvasBase(IntSize size)</span>
<span class="udiff-line-added">+     : m_size(size)</span>
  {
  }
  
  CanvasBase::~CanvasBase()
  {
<span class="udiff-line-removed">-     ASSERT(!m_context); // Should have been set to null by base class.</span>
      ASSERT(m_didNotifyObserversCanvasDestroyed);
      ASSERT(m_observers.isEmpty());
<span class="udiff-line-added">+     ASSERT(!m_imageBuffer);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ GraphicsContext* CanvasBase::drawingContext() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto* context = renderingContext();</span>
<span class="udiff-line-added">+     if (context &amp;&amp; !context-&gt;is2d() &amp;&amp; !context-&gt;isOffscreen2d())</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return buffer() ? &amp;m_imageBuffer-&gt;context() : nullptr;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ GraphicsContext* CanvasBase::existingDrawingContext() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!hasCreatedImageBuffer())</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return drawingContext();</span>
  }
  
<span class="udiff-line-modified-removed">- CanvasRenderingContext* CanvasBase::renderingContext() const</span>
<span class="udiff-line-modified-added">+ ImageBuffer* CanvasBase::buffer() const</span>
  {
<span class="udiff-line-modified-removed">-     return m_context.get();</span>
<span class="udiff-line-modified-added">+     if (!hasCreatedImageBuffer())</span>
<span class="udiff-line-added">+         createImageBuffer();</span>
<span class="udiff-line-added">+     return m_imageBuffer.get();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ AffineTransform CanvasBase::baseTransform() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(hasCreatedImageBuffer());</span>
<span class="udiff-line-added">+     return m_imageBuffer-&gt;baseTransform();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void CanvasBase::makeRenderingResultsAvailable()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (auto* context = renderingContext())</span>
<span class="udiff-line-added">+         context-&gt;paintRenderingResultsToCanvas();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t CanvasBase::memoryCost() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="udiff-line-added">+     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="udiff-line-added">+     // from being changed while we access it.</span>
<span class="udiff-line-added">+     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="udiff-line-added">+     if (!m_imageBuffer)</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+     return m_imageBuffer-&gt;memoryCost();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t CanvasBase::externalMemoryCost() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // externalMemoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="udiff-line-added">+     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="udiff-line-added">+     // from being changed while we access it.</span>
<span class="udiff-line-added">+     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="udiff-line-added">+     if (!m_imageBuffer)</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+     return m_imageBuffer-&gt;externalMemoryCost();</span>
  }
  
  void CanvasBase::addObserver(CanvasObserver&amp; observer)
  {
      m_observers.add(&amp;observer);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,11 +153,11 @@</span>
      for (auto&amp; observer : copyToVector(m_observers))
          observer-&gt;canvasDestroyed(*this);
  
      m_observers.clear();
  
<span class="udiff-line-modified-removed">- #ifndef NDEBUG</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      m_didNotifyObserversCanvasDestroyed = true;
  #endif
  }
  
  HashSet&lt;Element*&gt; CanvasBase::cssCanvasClients() const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,9 +176,57 @@</span>
      return cssCanvasClients;
  }
  
  bool CanvasBase::callTracingActive() const
  {
<span class="udiff-line-modified-removed">-     return m_context &amp;&amp; m_context-&gt;callTracingActive();</span>
<span class="udiff-line-modified-added">+     auto* context = renderingContext();</span>
<span class="udiff-line-added">+     return context &amp;&amp; context-&gt;callTracingActive();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ std::unique_ptr&lt;ImageBuffer&gt; CanvasBase::setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     std::unique_ptr&lt;ImageBuffer&gt; returnBuffer;</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="udiff-line-added">+         m_contextStateSaver = nullptr;</span>
<span class="udiff-line-added">+         returnBuffer = std::exchange(m_imageBuffer, WTFMove(buffer));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())</span>
<span class="udiff-line-added">+         m_size = m_imageBuffer-&gt;internalSize();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t previousMemoryCost = m_imageBufferCost;</span>
<span class="udiff-line-added">+     m_imageBufferCost = memoryCost();</span>
<span class="udiff-line-added">+     s_activePixelMemory += m_imageBufferCost - previousMemoryCost;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* context = renderingContext();</span>
<span class="udiff-line-added">+     if (context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != m_imageBufferCost)</span>
<span class="udiff-line-added">+         InspectorInstrumentation::didChangeCanvasMemory(*context);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (m_imageBuffer) {</span>
<span class="udiff-line-added">+         m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);</span>
<span class="udiff-line-added">+         m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);</span>
<span class="udiff-line-added">+         m_imageBuffer-&gt;context().setStrokeThickness(1);</span>
<span class="udiff-line-added">+         m_contextStateSaver = makeUnique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         JSC::JSLockHolder lock(scriptExecutionContext()-&gt;vm());</span>
<span class="udiff-line-added">+         scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return returnBuffer;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t CanvasBase::activePixelMemory()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return s_activePixelMemory.load();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void CanvasBase::resetGraphicsContextState() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (m_contextStateSaver) {</span>
<span class="udiff-line-added">+         // Reset to the initial graphics context state.</span>
<span class="udiff-line-added">+         m_contextStateSaver-&gt;restore();</span>
<span class="udiff-line-added">+         m_contextStateSaver-&gt;save();</span>
<span class="udiff-line-added">+     }</span>
  }
  
  }
</pre>
<center><a href="Autocapitalize.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CanvasBase.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
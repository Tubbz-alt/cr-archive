<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/CSSToStyleMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  *
 12  * This library is free software; you can redistribute it and/or
 13  * modify it under the terms of the GNU Library General Public
 14  * License as published by the Free Software Foundation; either
 15  * version 2 of the License, or (at your option) any later version.
 16  *
 17  * This library is distributed in the hope that it will be useful,
 18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 20  * Library General Public License for more details.
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;CSSToStyleMap.h&quot;
 30 
 31 #include &quot;Animation.h&quot;
 32 #include &quot;CSSBorderImageSliceValue.h&quot;
 33 #include &quot;CSSImageGeneratorValue.h&quot;
 34 #include &quot;CSSImageSetValue.h&quot;
 35 #include &quot;CSSImageValue.h&quot;
 36 #include &quot;CSSPrimitiveValue.h&quot;
 37 #include &quot;CSSPrimitiveValueMappings.h&quot;
 38 #include &quot;CSSTimingFunctionValue.h&quot;
 39 #include &quot;CSSValueKeywords.h&quot;
 40 #include &quot;FillLayer.h&quot;
 41 #include &quot;Pair.h&quot;
 42 #include &quot;Rect.h&quot;
 43 #include &quot;StyleBuilderConverter.h&quot;
 44 #include &quot;StyleResolver.h&quot;
 45 
 46 namespace WebCore {
 47 
<a name="1" id="anc1"></a><span class="line-modified"> 48 CSSToStyleMap::CSSToStyleMap(Style::BuilderState&amp; builderState)</span>
<span class="line-modified"> 49     : m_builderState(builderState)</span>
 50 {
 51 }
 52 
 53 RenderStyle* CSSToStyleMap::style() const
 54 {
<a name="2" id="anc2"></a><span class="line-modified"> 55     return &amp;m_builderState.style();</span>





 56 }
 57 
 58 bool CSSToStyleMap::useSVGZoomRules() const
 59 {
<a name="3" id="anc3"></a><span class="line-modified"> 60     return m_builderState.useSVGZoomRules();</span>
 61 }
 62 
 63 RefPtr&lt;StyleImage&gt; CSSToStyleMap::styleImage(CSSValue&amp; value)
 64 {
<a name="4" id="anc4"></a><span class="line-modified"> 65     return m_builderState.createStyleImage(value);</span>
 66 }
 67 
 68 void CSSToStyleMap::mapFillAttachment(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
 69 {
 70     if (value.treatAsInitialValue(propertyID)) {
 71         layer.setAttachment(FillLayer::initialFillAttachment(layer.type()));
 72         return;
 73     }
 74 
 75     if (!is&lt;CSSPrimitiveValue&gt;(value))
 76         return;
 77 
 78     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
 79     case CSSValueFixed:
 80         layer.setAttachment(FillAttachment::FixedBackground);
 81         break;
 82     case CSSValueScroll:
 83         layer.setAttachment(FillAttachment::ScrollBackground);
 84         break;
 85     case CSSValueLocal:
 86         layer.setAttachment(FillAttachment::LocalBackground);
 87         break;
 88     default:
 89         return;
 90     }
 91 }
 92 
 93 void CSSToStyleMap::mapFillClip(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
 94 {
 95     if (value.treatAsInitialValue(propertyID)) {
 96         layer.setClip(FillLayer::initialFillClip(layer.type()));
 97         return;
 98     }
 99 
100     if (!is&lt;CSSPrimitiveValue&gt;(value))
101         return;
102 
103     layer.setClip(downcast&lt;CSSPrimitiveValue&gt;(value));
104 }
105 
106 void CSSToStyleMap::mapFillComposite(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
107 {
108     if (value.treatAsInitialValue(propertyID)) {
109         layer.setComposite(FillLayer::initialFillComposite(layer.type()));
110         return;
111     }
112 
113     if (!is&lt;CSSPrimitiveValue&gt;(value))
114         return;
115 
116     layer.setComposite(downcast&lt;CSSPrimitiveValue&gt;(value));
117 }
118 
119 void CSSToStyleMap::mapFillBlendMode(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
120 {
121     if (value.treatAsInitialValue(propertyID)) {
122         layer.setBlendMode(FillLayer::initialFillBlendMode(layer.type()));
123         return;
124     }
125 
126     if (!is&lt;CSSPrimitiveValue&gt;(value))
127         return;
128 
129     layer.setBlendMode(downcast&lt;CSSPrimitiveValue&gt;(value));
130 }
131 
132 void CSSToStyleMap::mapFillOrigin(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
133 {
134     if (value.treatAsInitialValue(propertyID)) {
135         layer.setOrigin(FillLayer::initialFillOrigin(layer.type()));
136         return;
137     }
138 
139     if (!is&lt;CSSPrimitiveValue&gt;(value))
140         return;
141 
142     layer.setOrigin(downcast&lt;CSSPrimitiveValue&gt;(value));
143 }
144 
145 void CSSToStyleMap::mapFillImage(CSSPropertyID propertyID, FillLayer&amp; layer, CSSValue&amp; value)
146 {
147     if (value.treatAsInitialValue(propertyID)) {
148         layer.setImage(FillLayer::initialFillImage(layer.type()));
149         return;
150     }
151 
152     layer.setImage(styleImage(value));
153 }
154 
155 void CSSToStyleMap::mapFillRepeatX(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
156 {
157     if (value.treatAsInitialValue(propertyID)) {
158         layer.setRepeatX(FillLayer::initialFillRepeatX(layer.type()));
159         return;
160     }
161 
162     if (!is&lt;CSSPrimitiveValue&gt;(value))
163         return;
164 
165     layer.setRepeatX(downcast&lt;CSSPrimitiveValue&gt;(value));
166 }
167 
168 void CSSToStyleMap::mapFillRepeatY(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
169 {
170     if (value.treatAsInitialValue(propertyID)) {
171         layer.setRepeatY(FillLayer::initialFillRepeatY(layer.type()));
172         return;
173     }
174 
175     if (!is&lt;CSSPrimitiveValue&gt;(value))
176         return;
177 
178     layer.setRepeatY(downcast&lt;CSSPrimitiveValue&gt;(value));
179 }
180 
181 static inline bool convertToLengthSize(const CSSPrimitiveValue&amp; primitiveValue, CSSToLengthConversionData conversionData, LengthSize&amp; size)
182 {
183     if (auto* pair = primitiveValue.pairValue()) {
184         size.width = pair-&gt;first()-&gt;convertToLength&lt;AnyConversion&gt;(conversionData);
185         size.height = pair-&gt;second()-&gt;convertToLength&lt;AnyConversion&gt;(conversionData);
186     } else
187         size.width = primitiveValue.convertToLength&lt;AnyConversion&gt;(conversionData);
188     return !size.width.isUndefined() &amp;&amp; !size.height.isUndefined();
189 }
190 
191 void CSSToStyleMap::mapFillSize(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
192 {
193     if (value.treatAsInitialValue(propertyID)) {
194         layer.setSize(FillLayer::initialFillSize(layer.type()));
195         return;
196     }
197 
198     if (!is&lt;CSSPrimitiveValue&gt;(value))
199         return;
200 
201     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
202     FillSize fillSize;
203     switch (primitiveValue.valueID()) {
204     case CSSValueContain:
205         fillSize.type = FillSizeType::Contain;
206         break;
207     case CSSValueCover:
208         fillSize.type = FillSizeType::Cover;
209         break;
210     default:
211         ASSERT(fillSize.type == FillSizeType::Size);
<a name="5" id="anc5"></a><span class="line-modified">212         if (!convertToLengthSize(primitiveValue, m_builderState.cssToLengthConversionData(), fillSize.size))</span>
213             return;
214         break;
215     }
216     layer.setSize(fillSize);
217 }
218 
219 void CSSToStyleMap::mapFillXPosition(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
220 {
221     if (value.treatAsInitialValue(propertyID)) {
222         layer.setXPosition(FillLayer::initialFillXPosition(layer.type()));
223         return;
224     }
225 
226     if (!is&lt;CSSPrimitiveValue&gt;(value))
227         return;
228 
229     auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
230     Pair* pair = primitiveValue-&gt;pairValue();
231     Length length;
232     if (pair) {
233         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionX || propertyID == CSSPropertyWebkitMaskPositionX);
<a name="6" id="anc6"></a><span class="line-modified">234         length = Style::BuilderConverter::convertLength(m_builderState, *pair-&gt;second());</span>
235     } else
<a name="7" id="anc7"></a><span class="line-modified">236         length = Style::BuilderConverter::convertPositionComponentX(m_builderState, value);</span>
237 
238     layer.setXPosition(length);
239     if (pair)
240         layer.setBackgroundXOrigin(*pair-&gt;first());
241 }
242 
243 void CSSToStyleMap::mapFillYPosition(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
244 {
245     if (value.treatAsInitialValue(propertyID)) {
246         layer.setYPosition(FillLayer::initialFillYPosition(layer.type()));
247         return;
248     }
249 
250     if (!is&lt;CSSPrimitiveValue&gt;(value))
251         return;
252 
253     auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
254     Pair* pair = primitiveValue-&gt;pairValue();
255     Length length;
256     if (pair) {
257         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionY || propertyID == CSSPropertyWebkitMaskPositionY);
<a name="8" id="anc8"></a><span class="line-modified">258         length = Style::BuilderConverter::convertLength(m_builderState, *pair-&gt;second());</span>
259     } else
<a name="9" id="anc9"></a><span class="line-modified">260         length = Style::BuilderConverter::convertPositionComponentY(m_builderState, value);</span>
261 
262     layer.setYPosition(length);
263     if (pair)
264         layer.setBackgroundYOrigin(*pair-&gt;first());
265 }
266 
267 void CSSToStyleMap::mapFillMaskSourceType(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
268 {
269     MaskSourceType type = FillLayer::initialFillMaskSourceType(layer.type());
270     if (value.treatAsInitialValue(propertyID)) {
271         layer.setMaskSourceType(type);
272         return;
273     }
274 
275     if (!is&lt;CSSPrimitiveValue&gt;(value))
276         return;
277 
278     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
279     case CSSValueAlpha:
280         type = MaskSourceType::Alpha;
281         break;
282     case CSSValueLuminance:
283         type = MaskSourceType::Luminance;
284         break;
285     case CSSValueAuto:
286         break;
287     default:
288         ASSERT_NOT_REACHED();
289     }
290 
291     layer.setMaskSourceType(type);
292 }
293 
294 void CSSToStyleMap::mapAnimationDelay(Animation&amp; animation, const CSSValue&amp; value)
295 {
296     if (value.treatAsInitialValue(CSSPropertyAnimationDelay)) {
297         animation.setDelay(Animation::initialDelay());
298         return;
299     }
300 
301     if (!is&lt;CSSPrimitiveValue&gt;(value))
302         return;
303 
304     animation.setDelay(downcast&lt;CSSPrimitiveValue&gt;(value).computeTime&lt;double, CSSPrimitiveValue::Seconds&gt;());
305 }
306 
307 void CSSToStyleMap::mapAnimationDirection(Animation&amp; layer, const CSSValue&amp; value)
308 {
309     if (value.treatAsInitialValue(CSSPropertyAnimationDirection)) {
310         layer.setDirection(Animation::initialDirection());
311         return;
312     }
313 
314     if (!is&lt;CSSPrimitiveValue&gt;(value))
315         return;
316 
317     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
318     case CSSValueNormal:
319         layer.setDirection(Animation::AnimationDirectionNormal);
320         break;
321     case CSSValueAlternate:
322         layer.setDirection(Animation::AnimationDirectionAlternate);
323         break;
324     case CSSValueReverse:
325         layer.setDirection(Animation::AnimationDirectionReverse);
326         break;
327     case CSSValueAlternateReverse:
328         layer.setDirection(Animation::AnimationDirectionAlternateReverse);
329         break;
330     default:
331         break;
332     }
333 }
334 
335 void CSSToStyleMap::mapAnimationDuration(Animation&amp; animation, const CSSValue&amp; value)
336 {
337     if (value.treatAsInitialValue(CSSPropertyAnimationDuration)) {
338         animation.setDuration(Animation::initialDuration());
339         return;
340     }
341 
342     if (!is&lt;CSSPrimitiveValue&gt;(value))
343         return;
344 
345     animation.setDuration(downcast&lt;CSSPrimitiveValue&gt;(value).computeTime&lt;double, CSSPrimitiveValue::Seconds&gt;());
346 }
347 
348 void CSSToStyleMap::mapAnimationFillMode(Animation&amp; layer, const CSSValue&amp; value)
349 {
350     if (value.treatAsInitialValue(CSSPropertyAnimationFillMode)) {
351         layer.setFillMode(Animation::initialFillMode());
352         return;
353     }
354 
355     if (!is&lt;CSSPrimitiveValue&gt;(value))
356         return;
357 
358     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
359     case CSSValueNone:
360         layer.setFillMode(AnimationFillMode::None);
361         break;
362     case CSSValueForwards:
363         layer.setFillMode(AnimationFillMode::Forwards);
364         break;
365     case CSSValueBackwards:
366         layer.setFillMode(AnimationFillMode::Backwards);
367         break;
368     case CSSValueBoth:
369         layer.setFillMode(AnimationFillMode::Both);
370         break;
371     default:
372         break;
373     }
374 }
375 
376 void CSSToStyleMap::mapAnimationIterationCount(Animation&amp; animation, const CSSValue&amp; value)
377 {
378     if (value.treatAsInitialValue(CSSPropertyAnimationIterationCount)) {
379         animation.setIterationCount(Animation::initialIterationCount());
380         return;
381     }
382 
383     if (!is&lt;CSSPrimitiveValue&gt;(value))
384         return;
385 
386     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
387     if (primitiveValue.valueID() == CSSValueInfinite)
388         animation.setIterationCount(Animation::IterationCountInfinite);
389     else
390         animation.setIterationCount(primitiveValue.floatValue());
391 }
392 
393 void CSSToStyleMap::mapAnimationName(Animation&amp; layer, const CSSValue&amp; value)
394 {
395     if (value.treatAsInitialValue(CSSPropertyAnimationName)) {
396         layer.setName(Animation::initialName());
397         return;
398     }
399 
400     if (!is&lt;CSSPrimitiveValue&gt;(value))
401         return;
402 
403     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
404     if (primitiveValue.valueID() == CSSValueNone)
405         layer.setIsNoneAnimation(true);
406     else
<a name="10" id="anc10"></a><span class="line-modified">407         layer.setName(primitiveValue.stringValue(), m_builderState.styleScopeOrdinal());</span>
408 }
409 
410 void CSSToStyleMap::mapAnimationPlayState(Animation&amp; layer, const CSSValue&amp; value)
411 {
412     if (value.treatAsInitialValue(CSSPropertyAnimationPlayState)) {
413         layer.setPlayState(Animation::initialPlayState());
414         return;
415     }
416 
417     if (!is&lt;CSSPrimitiveValue&gt;(value))
418         return;
419 
420     AnimationPlayState playState = (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValuePaused) ? AnimationPlayState::Paused : AnimationPlayState::Playing;
421     layer.setPlayState(playState);
422 }
423 
424 void CSSToStyleMap::mapAnimationProperty(Animation&amp; animation, const CSSValue&amp; value)
425 {
426     if (value.treatAsInitialValue(CSSPropertyAnimation)) {
427         animation.setAnimationMode(Animation::AnimateAll);
428         animation.setProperty(CSSPropertyInvalid);
429         return;
430     }
431 
432     if (!is&lt;CSSPrimitiveValue&gt;(value))
433         return;
434 
435     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
436     if (primitiveValue.valueID() == CSSValueAll) {
437         animation.setAnimationMode(Animation::AnimateAll);
438         animation.setProperty(CSSPropertyInvalid);
439         return;
440     }
441     if (primitiveValue.valueID() == CSSValueNone) {
442         animation.setAnimationMode(Animation::AnimateNone);
443         animation.setProperty(CSSPropertyInvalid);
444         return;
445     }
446     if (primitiveValue.propertyID() == CSSPropertyInvalid) {
447         animation.setAnimationMode(Animation::AnimateUnknownProperty);
448         animation.setProperty(CSSPropertyInvalid);
449         animation.setUnknownProperty(primitiveValue.stringValue());
450         return;
451     }
452     animation.setAnimationMode(Animation::AnimateSingleProperty);
453     animation.setProperty(primitiveValue.propertyID());
454 }
455 
456 void CSSToStyleMap::mapAnimationTimingFunction(Animation&amp; animation, const CSSValue&amp; value)
457 {
458     if (value.treatAsInitialValue(CSSPropertyAnimationTimingFunction)) {
459         animation.setTimingFunction(Animation::initialTimingFunction());
460         return;
461     }
462 
463     if (is&lt;CSSPrimitiveValue&gt;(value)) {
464         switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
465         case CSSValueLinear:
466             animation.setTimingFunction(LinearTimingFunction::create());
467             break;
468         case CSSValueEase:
469             animation.setTimingFunction(CubicBezierTimingFunction::create());
470             break;
471         case CSSValueEaseIn:
472             animation.setTimingFunction(CubicBezierTimingFunction::create(CubicBezierTimingFunction::EaseIn));
473             break;
474         case CSSValueEaseOut:
475             animation.setTimingFunction(CubicBezierTimingFunction::create(CubicBezierTimingFunction::EaseOut));
476             break;
477         case CSSValueEaseInOut:
478             animation.setTimingFunction(CubicBezierTimingFunction::create(CubicBezierTimingFunction::EaseInOut));
479             break;
480         case CSSValueStepStart:
481             animation.setTimingFunction(StepsTimingFunction::create(1, true));
482             break;
483         case CSSValueStepEnd:
484             animation.setTimingFunction(StepsTimingFunction::create(1, false));
485             break;
486         default:
487             break;
488         }
489         return;
490     }
491 
492     if (is&lt;CSSCubicBezierTimingFunctionValue&gt;(value)) {
493         auto&amp; cubicTimingFunction = downcast&lt;CSSCubicBezierTimingFunctionValue&gt;(value);
494         animation.setTimingFunction(CubicBezierTimingFunction::create(cubicTimingFunction.x1(), cubicTimingFunction.y1(), cubicTimingFunction.x2(), cubicTimingFunction.y2()));
495     } else if (is&lt;CSSStepsTimingFunctionValue&gt;(value)) {
496         auto&amp; stepsTimingFunction = downcast&lt;CSSStepsTimingFunctionValue&gt;(value);
497         animation.setTimingFunction(StepsTimingFunction::create(stepsTimingFunction.numberOfSteps(), stepsTimingFunction.stepAtStart()));
498     } else if (is&lt;CSSSpringTimingFunctionValue&gt;(value)) {
499         auto&amp; springTimingFunction = downcast&lt;CSSSpringTimingFunctionValue&gt;(value);
500         animation.setTimingFunction(SpringTimingFunction::create(springTimingFunction.mass(), springTimingFunction.stiffness(), springTimingFunction.damping(), springTimingFunction.initialVelocity()));
501     }
502 }
503 
504 void CSSToStyleMap::mapNinePieceImage(CSSPropertyID property, CSSValue* value, NinePieceImage&amp; image)
505 {
506     // If we&#39;re not a value list, then we are &quot;none&quot; and don&#39;t need to alter the empty image at all.
507     if (!is&lt;CSSValueList&gt;(value))
508         return;
509 
510     // Retrieve the border image value.
511     CSSValueList&amp; borderImage = downcast&lt;CSSValueList&gt;(*value);
512 
513     for (auto&amp; current : borderImage) {
514         if (is&lt;CSSImageValue&gt;(current) || is&lt;CSSImageGeneratorValue&gt;(current) || is&lt;CSSImageSetValue&gt;(current))
515             image.setImage(styleImage(current.get()));
516         else if (is&lt;CSSBorderImageSliceValue&gt;(current))
517             mapNinePieceImageSlice(current, image);
518         else if (is&lt;CSSValueList&gt;(current)) {
519             CSSValueList&amp; slashList = downcast&lt;CSSValueList&gt;(current.get());
520             // Map in the image slices.
521             if (is&lt;CSSBorderImageSliceValue&gt;(slashList.item(0)))
522                 mapNinePieceImageSlice(*slashList.item(0), image);
523 
524             // Map in the border slices.
525             if (slashList.item(1))
526                 image.setBorderSlices(mapNinePieceImageQuad(*slashList.item(1)));
527 
528             // Map in the outset.
529             if (slashList.item(2))
530                 image.setOutset(mapNinePieceImageQuad(*slashList.item(2)));
531         } else if (is&lt;CSSPrimitiveValue&gt;(current)) {
532             // Set the appropriate rules for stretch/round/repeat of the slices.
533             mapNinePieceImageRepeat(current, image);
534         }
535     }
536 
537     if (property == CSSPropertyWebkitBorderImage) {
538         // We have to preserve the legacy behavior of -webkit-border-image and make the border slices
539         // also set the border widths. We don&#39;t need to worry about percentages, since we don&#39;t even support
540         // those on real borders yet.
541         if (image.borderSlices().top().isFixed())
542             style()-&gt;setBorderTopWidth(image.borderSlices().top().value());
543         if (image.borderSlices().right().isFixed())
544             style()-&gt;setBorderRightWidth(image.borderSlices().right().value());
545         if (image.borderSlices().bottom().isFixed())
546             style()-&gt;setBorderBottomWidth(image.borderSlices().bottom().value());
547         if (image.borderSlices().left().isFixed())
548             style()-&gt;setBorderLeftWidth(image.borderSlices().left().value());
549     }
550 }
551 
552 void CSSToStyleMap::mapNinePieceImageSlice(CSSValue&amp; value, NinePieceImage&amp; image)
553 {
554     if (!is&lt;CSSBorderImageSliceValue&gt;(value))
555         return;
556 
557     // Retrieve the border image value.
558     auto&amp; borderImageSlice = downcast&lt;CSSBorderImageSliceValue&gt;(value);
559 
560     // Set up a length box to represent our image slices.
561     LengthBox box;
562     Quad* slices = borderImageSlice.slices();
563     if (slices-&gt;top()-&gt;isPercentage())
564         box.top() = Length(slices-&gt;top()-&gt;doubleValue(), Percent);
565     else
<a name="11" id="anc11"></a><span class="line-modified">566         box.top() = Length(slices-&gt;top()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
567     if (slices-&gt;bottom()-&gt;isPercentage())
568         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(), Percent);
569     else
<a name="12" id="anc12"></a><span class="line-modified">570         box.bottom() = Length((int)slices-&gt;bottom()-&gt;floatValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
571     if (slices-&gt;left()-&gt;isPercentage())
572         box.left() = Length(slices-&gt;left()-&gt;doubleValue(), Percent);
573     else
<a name="13" id="anc13"></a><span class="line-modified">574         box.left() = Length(slices-&gt;left()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
575     if (slices-&gt;right()-&gt;isPercentage())
576         box.right() = Length(slices-&gt;right()-&gt;doubleValue(), Percent);
577     else
<a name="14" id="anc14"></a><span class="line-modified">578         box.right() = Length(slices-&gt;right()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
579     image.setImageSlices(box);
580 
581     // Set our fill mode.
582     image.setFill(borderImageSlice.m_fill);
583 }
584 
585 LengthBox CSSToStyleMap::mapNinePieceImageQuad(CSSValue&amp; value)
586 {
587     if (!is&lt;CSSPrimitiveValue&gt;(value))
588         return LengthBox();
589 
590     // Get our zoom value.
<a name="15" id="anc15"></a><span class="line-modified">591     CSSToLengthConversionData conversionData = useSVGZoomRules() ? m_builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f) : m_builderState.cssToLengthConversionData();</span>
592 
593     // Retrieve the primitive value.
594     auto&amp; borderWidths = downcast&lt;CSSPrimitiveValue&gt;(value);
595 
596     // Set up a length box to represent our image slices.
597     LengthBox box; // Defaults to &#39;auto&#39; so we don&#39;t have to handle that explicitly below.
598     Quad* slices = borderWidths.quadValue();
599     if (slices-&gt;top()-&gt;isNumber())
600         box.top() = Length(slices-&gt;top()-&gt;intValue(), Relative);
601     else if (slices-&gt;top()-&gt;isPercentage())
<a name="16" id="anc16"></a><span class="line-modified">602         box.top() = Length(slices-&gt;top()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
603     else if (slices-&gt;top()-&gt;valueID() != CSSValueAuto)
604         box.top() = slices-&gt;top()-&gt;computeLength&lt;Length&gt;(conversionData);
605 
606     if (slices-&gt;right()-&gt;isNumber())
607         box.right() = Length(slices-&gt;right()-&gt;intValue(), Relative);
608     else if (slices-&gt;right()-&gt;isPercentage())
<a name="17" id="anc17"></a><span class="line-modified">609         box.right() = Length(slices-&gt;right()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
610     else if (slices-&gt;right()-&gt;valueID() != CSSValueAuto)
611         box.right() = slices-&gt;right()-&gt;computeLength&lt;Length&gt;(conversionData);
612 
613     if (slices-&gt;bottom()-&gt;isNumber())
614         box.bottom() = Length(slices-&gt;bottom()-&gt;intValue(), Relative);
615     else if (slices-&gt;bottom()-&gt;isPercentage())
<a name="18" id="anc18"></a><span class="line-modified">616         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
617     else if (slices-&gt;bottom()-&gt;valueID() != CSSValueAuto)
618         box.bottom() = slices-&gt;bottom()-&gt;computeLength&lt;Length&gt;(conversionData);
619 
620     if (slices-&gt;left()-&gt;isNumber())
621         box.left() = Length(slices-&gt;left()-&gt;intValue(), Relative);
622     else if (slices-&gt;left()-&gt;isPercentage())
<a name="19" id="anc19"></a><span class="line-modified">623         box.left() = Length(slices-&gt;left()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
624     else if (slices-&gt;left()-&gt;valueID() != CSSValueAuto)
625         box.left() = slices-&gt;left()-&gt;computeLength&lt;Length&gt;(conversionData);
626 
627     return box;
628 }
629 
630 void CSSToStyleMap::mapNinePieceImageRepeat(CSSValue&amp; value, NinePieceImage&amp; image)
631 {
632     if (!is&lt;CSSPrimitiveValue&gt;(value))
633         return;
634 
635     CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
636     Pair* pair = primitiveValue.pairValue();
637     if (!pair || !pair-&gt;first() || !pair-&gt;second())
638         return;
639 
640     CSSValueID firstIdentifier = pair-&gt;first()-&gt;valueID();
641     CSSValueID secondIdentifier = pair-&gt;second()-&gt;valueID();
642 
<a name="20" id="anc20"></a><span class="line-modified">643     NinePieceImageRule horizontalRule;</span>
644     switch (firstIdentifier) {
645     case CSSValueStretch:
<a name="21" id="anc21"></a><span class="line-modified">646         horizontalRule = NinePieceImageRule::Stretch;</span>
647         break;
648     case CSSValueRound:
<a name="22" id="anc22"></a><span class="line-modified">649         horizontalRule = NinePieceImageRule::Round;</span>
650         break;
651     case CSSValueSpace:
<a name="23" id="anc23"></a><span class="line-modified">652         horizontalRule = NinePieceImageRule::Space;</span>
653         break;
654     default: // CSSValueRepeat
<a name="24" id="anc24"></a><span class="line-modified">655         horizontalRule = NinePieceImageRule::Repeat;</span>
656         break;
657     }
658     image.setHorizontalRule(horizontalRule);
659 
<a name="25" id="anc25"></a><span class="line-modified">660     NinePieceImageRule verticalRule;</span>
661     switch (secondIdentifier) {
662     case CSSValueStretch:
<a name="26" id="anc26"></a><span class="line-modified">663         verticalRule = NinePieceImageRule::Stretch;</span>
664         break;
665     case CSSValueRound:
<a name="27" id="anc27"></a><span class="line-modified">666         verticalRule = NinePieceImageRule::Round;</span>
667         break;
668     case CSSValueSpace:
<a name="28" id="anc28"></a><span class="line-modified">669         verticalRule = NinePieceImageRule::Space;</span>
670         break;
671     default: // CSSValueRepeat
<a name="29" id="anc29"></a><span class="line-modified">672         verticalRule = NinePieceImageRule::Repeat;</span>
673         break;
674     }
675     image.setVerticalRule(verticalRule);
676 }
677 
678 };
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
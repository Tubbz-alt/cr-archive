<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmSignatureInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmStreamingParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmStreamingParser.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<span class="line-modified"> 31 #include &quot;WasmModuleParser.h&quot;</span>
 32 #include &quot;WasmSectionParser.h&quot;

 33 #include &lt;wtf/Optional.h&gt;
 34 #include &lt;wtf/UnalignedAccess.h&gt;
 35 
 36 namespace JSC { namespace Wasm {
 37 
 38 namespace WasmStreamingParserInternal {
 39 static constexpr bool verbose = false;
 40 }
 41 
 42 #define WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(helper) \
 43     do { \
 44         auto helperResult = helper; \
 45         if (UNLIKELY(!helperResult)) { \
 46             m_errorMessage = helperResult.error(); \
 47             return State::FatalError; \
 48         } \
 49     } while (0)
 50 
 51 ALWAYS_INLINE Optional&lt;uint8_t&gt; parseUInt7(const uint8_t* data, size_t&amp; offset, size_t size)
 52 {
 53     if (offset &gt;= size)
 54         return false;
 55     uint8_t result = data[offset++];
 56     if (result &lt; 0x80)
 57         return result;
 58     return WTF::nullopt;
 59 }
 60 
 61 template &lt;typename ...Args&gt;
 62 NEVER_INLINE auto WARN_UNUSED_RETURN StreamingParser::fail(Args... args) -&gt; State
 63 {
 64     using namespace FailureHelper; // See ADL comment in namespace above.
 65     m_errorMessage = makeString(&quot;WebAssembly.Module doesn&#39;t parse at byte &quot;_s, String::number(m_offset), &quot;: &quot;_s, makeString(args)...);
 66     dataLogLnIf(WasmStreamingParserInternal::verbose, m_errorMessage);
 67     return State::FatalError;
 68 }
 69 
<span class="line-modified"> 70 StreamingParser::StreamingParser(ModuleInformation&amp; info)</span>
 71     : m_info(info)

 72 {
 73     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;starting validation&quot;);
 74 }
 75 
 76 auto StreamingParser::parseModuleHeader(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
 77 {
 78     ASSERT(data.size() == moduleHeaderSize);
 79     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;header validation&quot;);
 80     WASM_PARSER_FAIL_IF(data[0] != &#39;\0&#39; || data[1] != &#39;a&#39; || data[2] != &#39;s&#39; || data[3] != &#39;m&#39;, &quot;modules doesn&#39;t start with &#39;\\0asm&#39;&quot;);
 81     uint32_t versionNumber = WTF::unalignedLoad&lt;uint32_t&gt;(data.data() + 4);
 82     WASM_PARSER_FAIL_IF(versionNumber != expectedVersionNumber, &quot;unexpected version number &quot;, versionNumber, &quot; expected &quot;, expectedVersionNumber);
 83     return State::SectionID;
 84 }
 85 
 86 auto StreamingParser::parseSectionID(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
 87 {
 88     ASSERT(data.size() == sectionIDSize);
 89     size_t offset = 0;
 90     auto result = parseUInt7(data.data(), offset, data.size());
 91     WASM_PARSER_FAIL_IF(!result, &quot;can&#39;t get section byte&quot;);
</pre>
<hr />
<pre>
103 auto StreamingParser::parseSectionSize(uint32_t sectionLength) -&gt; State
104 {
105     m_sectionLength = sectionLength;
106     if (m_section == Section::Code)
107         return State::CodeSectionSize;
108     return State::SectionPayload;
109 }
110 
111 auto StreamingParser::parseCodeSectionSize(uint32_t functionCount) -&gt; State
112 {
113     m_info-&gt;codeSectionSize = m_sectionLength;
114     m_functionCount = functionCount;
115     m_functionIndex = 0;
116     m_codeOffset = m_offset;
117 
118     WASM_PARSER_FAIL_IF(functionCount == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, functionCount);
119     WASM_PARSER_FAIL_IF(functionCount != m_info-&gt;functions.size(), &quot;Code section count &quot;, functionCount, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());
120 
121     if (m_functionIndex == m_functionCount) {
122         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != m_nextOffset, &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);


123         return State::SectionID;
124     }
125     return State::FunctionSize;
126 }
127 
128 auto StreamingParser::parseFunctionSize(uint32_t functionSize) -&gt; State
129 {
130     m_functionSize = functionSize;
131     WASM_PARSER_FAIL_IF(functionSize &gt; maxFunctionSize, &quot;Code function&#39;s size &quot;, functionSize, &quot; is too big&quot;);
132     return State::FunctionPayload;
133 }
134 
135 auto StreamingParser::parseFunctionPayload(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
136 {
137     auto&amp; function = m_info-&gt;functions[m_functionIndex];
138     function.start = m_offset;
139     function.end = m_offset + m_functionSize;
140     function.data = WTFMove(data);
141     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;Processing function starting at: &quot;, function.start, &quot; and ending at: &quot;, function.end);


142     ++m_functionIndex;

143     if (m_functionIndex == m_functionCount) {
144         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != (m_offset + m_functionSize), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);


145         return State::SectionID;
146     }
147     return State::FunctionSize;
148 }
149 
150 auto StreamingParser::parseSectionPayload(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
151 {
152     SectionParser parser(data.data(), data.size(), m_offset, m_info.get());
153     switch (m_section) {
154 #define WASM_SECTION_PARSE(NAME, ID, DESCRIPTION) \
155     case Section::NAME: { \
156         WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(parser.parse ## NAME()); \
157         break; \
158     }
159     FOR_EACH_KNOWN_WASM_SECTION(WASM_SECTION_PARSE)
160 #undef WASM_SECTION_PARSE
161 
162     case Section::Custom: {
163         WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(parser.parseCustom());
164         break;
165     }
166 
167     case Section::Begin: {
168         RELEASE_ASSERT_NOT_REACHED();
169         break;
170     }
171     }
172 
173     WASM_PARSER_FAIL_IF(parser.length() != parser.offset(), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
174 


175     return State::SectionID;
176 }
177 
178 auto StreamingParser::consume(const uint8_t* bytes, size_t bytesSize, size_t&amp; offsetInBytes, size_t requiredSize) -&gt; Optional&lt;Vector&lt;uint8_t&gt;&gt;
179 {
180     if (m_remaining.size() == requiredSize) {
181         Vector&lt;uint8_t&gt; result = WTFMove(m_remaining);
182         m_nextOffset += requiredSize;
183         return result;
184     }
185 
186     if (m_remaining.size() &gt; requiredSize) {
187         Vector&lt;uint8_t&gt; result(requiredSize);
188         memcpy(result.data(), m_remaining.data(), requiredSize);
189         m_remaining.remove(0, requiredSize);
190         m_nextOffset += requiredSize;
191         return result;
192     }
193 
194     ASSERT(m_remaining.size() &lt; requiredSize);
</pre>
<hr />
<pre>
361 }
362 
363 auto StreamingParser::finalize() -&gt; State
364 {
365     addBytes(nullptr, 0, IsEndOfStream::Yes);
366     switch (m_state) {
367     case State::ModuleHeader:
368     case State::SectionSize:
369     case State::SectionPayload:
370     case State::CodeSectionSize:
371     case State::FunctionSize:
372     case State::FunctionPayload:
373         m_state = failOnState(m_state);
374         break;
375 
376     case State::Finished:
377     case State::FatalError:
378         break;
379 
380     case State::SectionID:




381         if (m_remaining.isEmpty()) {
382             if (UNLIKELY(Options::useEagerWebAssemblyModuleHashing()))
383                 m_info-&gt;nameSection-&gt;setHash(m_hasher.computeHexDigest());
384             m_state = State::Finished;

385         } else
386             m_state = failOnState(State::SectionID);
387         break;
388     }
389     return m_state;
390 }
391 
392 } } // namespace JSC::Wasm
393 
394 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmStreamingParser.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<span class="line-modified"> 31 #include &quot;WasmOps.h&quot;</span>
 32 #include &quot;WasmSectionParser.h&quot;
<span class="line-added"> 33 #include &quot;WasmSignatureInlines.h&quot;</span>
 34 #include &lt;wtf/Optional.h&gt;
 35 #include &lt;wtf/UnalignedAccess.h&gt;
 36 
 37 namespace JSC { namespace Wasm {
 38 
 39 namespace WasmStreamingParserInternal {
 40 static constexpr bool verbose = false;
 41 }
 42 
 43 #define WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(helper) \
 44     do { \
 45         auto helperResult = helper; \
 46         if (UNLIKELY(!helperResult)) { \
 47             m_errorMessage = helperResult.error(); \
 48             return State::FatalError; \
 49         } \
 50     } while (0)
 51 
 52 ALWAYS_INLINE Optional&lt;uint8_t&gt; parseUInt7(const uint8_t* data, size_t&amp; offset, size_t size)
 53 {
 54     if (offset &gt;= size)
 55         return false;
 56     uint8_t result = data[offset++];
 57     if (result &lt; 0x80)
 58         return result;
 59     return WTF::nullopt;
 60 }
 61 
 62 template &lt;typename ...Args&gt;
 63 NEVER_INLINE auto WARN_UNUSED_RETURN StreamingParser::fail(Args... args) -&gt; State
 64 {
 65     using namespace FailureHelper; // See ADL comment in namespace above.
 66     m_errorMessage = makeString(&quot;WebAssembly.Module doesn&#39;t parse at byte &quot;_s, String::number(m_offset), &quot;: &quot;_s, makeString(args)...);
 67     dataLogLnIf(WasmStreamingParserInternal::verbose, m_errorMessage);
 68     return State::FatalError;
 69 }
 70 
<span class="line-modified"> 71 StreamingParser::StreamingParser(ModuleInformation&amp; info, StreamingParserClient&amp; client)</span>
 72     : m_info(info)
<span class="line-added"> 73     , m_client(client)</span>
 74 {
 75     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;starting validation&quot;);
 76 }
 77 
 78 auto StreamingParser::parseModuleHeader(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
 79 {
 80     ASSERT(data.size() == moduleHeaderSize);
 81     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;header validation&quot;);
 82     WASM_PARSER_FAIL_IF(data[0] != &#39;\0&#39; || data[1] != &#39;a&#39; || data[2] != &#39;s&#39; || data[3] != &#39;m&#39;, &quot;modules doesn&#39;t start with &#39;\\0asm&#39;&quot;);
 83     uint32_t versionNumber = WTF::unalignedLoad&lt;uint32_t&gt;(data.data() + 4);
 84     WASM_PARSER_FAIL_IF(versionNumber != expectedVersionNumber, &quot;unexpected version number &quot;, versionNumber, &quot; expected &quot;, expectedVersionNumber);
 85     return State::SectionID;
 86 }
 87 
 88 auto StreamingParser::parseSectionID(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
 89 {
 90     ASSERT(data.size() == sectionIDSize);
 91     size_t offset = 0;
 92     auto result = parseUInt7(data.data(), offset, data.size());
 93     WASM_PARSER_FAIL_IF(!result, &quot;can&#39;t get section byte&quot;);
</pre>
<hr />
<pre>
105 auto StreamingParser::parseSectionSize(uint32_t sectionLength) -&gt; State
106 {
107     m_sectionLength = sectionLength;
108     if (m_section == Section::Code)
109         return State::CodeSectionSize;
110     return State::SectionPayload;
111 }
112 
113 auto StreamingParser::parseCodeSectionSize(uint32_t functionCount) -&gt; State
114 {
115     m_info-&gt;codeSectionSize = m_sectionLength;
116     m_functionCount = functionCount;
117     m_functionIndex = 0;
118     m_codeOffset = m_offset;
119 
120     WASM_PARSER_FAIL_IF(functionCount == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, functionCount);
121     WASM_PARSER_FAIL_IF(functionCount != m_info-&gt;functions.size(), &quot;Code section count &quot;, functionCount, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());
122 
123     if (m_functionIndex == m_functionCount) {
124         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != m_nextOffset, &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
<span class="line-added">125         if (!m_client.didReceiveSectionData(m_section))</span>
<span class="line-added">126             return State::FatalError;</span>
127         return State::SectionID;
128     }
129     return State::FunctionSize;
130 }
131 
132 auto StreamingParser::parseFunctionSize(uint32_t functionSize) -&gt; State
133 {
134     m_functionSize = functionSize;
135     WASM_PARSER_FAIL_IF(functionSize &gt; maxFunctionSize, &quot;Code function&#39;s size &quot;, functionSize, &quot; is too big&quot;);
136     return State::FunctionPayload;
137 }
138 
139 auto StreamingParser::parseFunctionPayload(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
140 {
141     auto&amp; function = m_info-&gt;functions[m_functionIndex];
142     function.start = m_offset;
143     function.end = m_offset + m_functionSize;
144     function.data = WTFMove(data);
145     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;Processing function starting at: &quot;, function.start, &quot; and ending at: &quot;, function.end);
<span class="line-added">146     if (!m_client.didReceiveFunctionData(m_functionIndex, function))</span>
<span class="line-added">147         return State::FatalError;</span>
148     ++m_functionIndex;
<span class="line-added">149 </span>
150     if (m_functionIndex == m_functionCount) {
151         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != (m_offset + m_functionSize), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
<span class="line-added">152         if (!m_client.didReceiveSectionData(m_section))</span>
<span class="line-added">153             return State::FatalError;</span>
154         return State::SectionID;
155     }
156     return State::FunctionSize;
157 }
158 
159 auto StreamingParser::parseSectionPayload(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
160 {
161     SectionParser parser(data.data(), data.size(), m_offset, m_info.get());
162     switch (m_section) {
163 #define WASM_SECTION_PARSE(NAME, ID, DESCRIPTION) \
164     case Section::NAME: { \
165         WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(parser.parse ## NAME()); \
166         break; \
167     }
168     FOR_EACH_KNOWN_WASM_SECTION(WASM_SECTION_PARSE)
169 #undef WASM_SECTION_PARSE
170 
171     case Section::Custom: {
172         WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(parser.parseCustom());
173         break;
174     }
175 
176     case Section::Begin: {
177         RELEASE_ASSERT_NOT_REACHED();
178         break;
179     }
180     }
181 
182     WASM_PARSER_FAIL_IF(parser.length() != parser.offset(), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
183 
<span class="line-added">184     if (!m_client.didReceiveSectionData(m_section))</span>
<span class="line-added">185         return State::FatalError;</span>
186     return State::SectionID;
187 }
188 
189 auto StreamingParser::consume(const uint8_t* bytes, size_t bytesSize, size_t&amp; offsetInBytes, size_t requiredSize) -&gt; Optional&lt;Vector&lt;uint8_t&gt;&gt;
190 {
191     if (m_remaining.size() == requiredSize) {
192         Vector&lt;uint8_t&gt; result = WTFMove(m_remaining);
193         m_nextOffset += requiredSize;
194         return result;
195     }
196 
197     if (m_remaining.size() &gt; requiredSize) {
198         Vector&lt;uint8_t&gt; result(requiredSize);
199         memcpy(result.data(), m_remaining.data(), requiredSize);
200         m_remaining.remove(0, requiredSize);
201         m_nextOffset += requiredSize;
202         return result;
203     }
204 
205     ASSERT(m_remaining.size() &lt; requiredSize);
</pre>
<hr />
<pre>
372 }
373 
374 auto StreamingParser::finalize() -&gt; State
375 {
376     addBytes(nullptr, 0, IsEndOfStream::Yes);
377     switch (m_state) {
378     case State::ModuleHeader:
379     case State::SectionSize:
380     case State::SectionPayload:
381     case State::CodeSectionSize:
382     case State::FunctionSize:
383     case State::FunctionPayload:
384         m_state = failOnState(m_state);
385         break;
386 
387     case State::Finished:
388     case State::FatalError:
389         break;
390 
391     case State::SectionID:
<span class="line-added">392         if (m_functionIndex != m_info-&gt;functions.size()) {</span>
<span class="line-added">393             m_state = fail(&quot;Number of functions parsed (&quot;, m_functionCount, &quot;) does not match the number of declared functions (&quot;, m_info-&gt;functions.size(), &quot;)&quot;);</span>
<span class="line-added">394             break;</span>
<span class="line-added">395         }</span>
396         if (m_remaining.isEmpty()) {
397             if (UNLIKELY(Options::useEagerWebAssemblyModuleHashing()))
398                 m_info-&gt;nameSection-&gt;setHash(m_hasher.computeHexDigest());
399             m_state = State::Finished;
<span class="line-added">400             m_client.didFinishParsing();</span>
401         } else
402             m_state = failOnState(State::SectionID);
403         break;
404     }
405     return m_state;
406 }
407 
408 } } // namespace JSC::Wasm
409 
410 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmSignatureInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmStreamingParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
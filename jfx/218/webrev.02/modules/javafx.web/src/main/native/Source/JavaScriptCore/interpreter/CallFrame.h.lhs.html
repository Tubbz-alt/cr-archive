<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<a name="1" id="anc1"></a><span class="line-modified">  4  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;AbstractPC.h&quot;
 26 #include &quot;CalleeBits.h&quot;
 27 #include &quot;MacroAssemblerCodeRef.h&quot;
 28 #include &quot;Register.h&quot;
 29 #include &quot;StackVisitor.h&quot;
 30 #include &quot;VM.h&quot;
 31 #include &quot;VMEntryRecord.h&quot;
<a name="2" id="anc2"></a>
 32 
 33 namespace JSC  {
 34 
 35     class Arguments;
<a name="3" id="anc3"></a><span class="line-modified"> 36     class ExecState;</span>
 37     class Interpreter;
 38     class JSCallee;
 39     class JSScope;
 40     class SourceOrigin;
 41 
 42     struct Instruction;
 43 
<a name="4" id="anc4"></a><span class="line-removed"> 44     typedef ExecState CallFrame;</span>
<span class="line-removed"> 45 </span>
 46     class CallSiteIndex {
 47     public:
 48         CallSiteIndex() = default;
 49 
<a name="5" id="anc5"></a>




 50         explicit CallSiteIndex(uint32_t bits)
 51             : m_bits(bits)
 52         { }
<a name="6" id="anc6"></a><span class="line-removed"> 53 #if USE(JSVALUE32_64)</span>
<span class="line-removed"> 54         explicit CallSiteIndex(const Instruction* instruction)</span>
<span class="line-removed"> 55             : m_bits(bitwise_cast&lt;uint32_t&gt;(instruction))</span>
<span class="line-removed"> 56         { }</span>
<span class="line-removed"> 57 #endif</span>
 58 
<a name="7" id="anc7"></a><span class="line-modified"> 59         explicit operator bool() const { return m_bits != UINT_MAX; }</span>
 60         bool operator==(const CallSiteIndex&amp; other) const { return m_bits == other.m_bits; }
 61 
<a name="8" id="anc8"></a><span class="line-modified"> 62         inline uint32_t bits() const { return m_bits; }</span>



 63 
 64     private:
<a name="9" id="anc9"></a><span class="line-modified"> 65         uint32_t m_bits { UINT_MAX };</span>
 66     };
 67 
 68     class DisposableCallSiteIndex : public CallSiteIndex {
 69     public:
 70         DisposableCallSiteIndex() = default;
 71 
 72         explicit DisposableCallSiteIndex(uint32_t bits)
 73             : CallSiteIndex(bits)
 74         {
 75         }
 76 
 77         static DisposableCallSiteIndex fromCallSiteIndex(CallSiteIndex callSiteIndex)
 78         {
 79             return DisposableCallSiteIndex(callSiteIndex.bits());
 80         }
 81     };
 82 
 83     // arm64_32 expects caller frame and return pc to use 8 bytes
 84     struct CallerFrameAndPC {
 85         alignas(CPURegister) CallFrame* callerFrame;
<a name="10" id="anc10"></a><span class="line-modified"> 86         alignas(CPURegister) const Instruction* returnPC;</span>
<span class="line-modified"> 87         static const int sizeInRegisters = 2 * sizeof(CPURegister) / sizeof(Register);</span>
 88     };
 89     static_assert(CallerFrameAndPC::sizeInRegisters == sizeof(CallerFrameAndPC) / sizeof(Register), &quot;CallerFrameAndPC::sizeInRegisters is incorrect.&quot;);
 90 
<a name="11" id="anc11"></a><span class="line-modified"> 91     struct CallFrameSlot {</span>
<span class="line-modified"> 92         static const int codeBlock = CallerFrameAndPC::sizeInRegisters;</span>
<span class="line-modified"> 93         static const int callee = codeBlock + 1;</span>
<span class="line-modified"> 94         static const int argumentCount = callee + 1;</span>
<span class="line-modified"> 95         static const int thisArgument = argumentCount + 1;</span>
<span class="line-modified"> 96         static const int firstArgument = thisArgument + 1;</span>
 97     };
 98 
<a name="12" id="anc12"></a>


 99     // Represents the current state of script execution.
100     // Passed as the first argument to most functions.
<a name="13" id="anc13"></a><span class="line-modified">101     class ExecState : private Register {</span>
102     public:
<a name="14" id="anc14"></a><span class="line-modified">103         static const int headerSizeInRegisters = CallFrameSlot::argumentCount + 1;</span>
104 
105         // This function should only be called in very specific circumstances
106         // when you&#39;ve guaranteed the callee can&#39;t be a Wasm callee, and can
107         // be an arbitrary JSValue. This function should basically never be used.
108         // Its only use right now is when we are making a call, and we&#39;re not
109         // yet sure if the callee is a cell. In general, a JS callee is guaranteed
110         // to be a cell, however, there is a brief window where we need to check
111         // to see if it&#39;s a cell, and if it&#39;s not, we throw an exception.
<a name="15" id="anc15"></a><span class="line-modified">112         JSValue guaranteedJSValueCallee() const</span>
<span class="line-modified">113         {</span>
<span class="line-modified">114             ASSERT(!callee().isWasm());</span>
<span class="line-modified">115             return this[CallFrameSlot::callee].jsValue();</span>
<span class="line-modified">116         }</span>
<span class="line-modified">117         JSObject* jsCallee() const</span>
<span class="line-modified">118         {</span>
<span class="line-modified">119             ASSERT(!callee().isWasm());</span>
<span class="line-removed">120             return this[CallFrameSlot::callee].object();</span>
<span class="line-removed">121         }</span>
<span class="line-removed">122         CalleeBits callee() const { return CalleeBits(this[CallFrameSlot::callee].pointer()); }</span>
<span class="line-removed">123         SUPPRESS_ASAN CalleeBits unsafeCallee() const { return CalleeBits(this[CallFrameSlot::callee].asanUnsafePointer()); }</span>
<span class="line-removed">124         CodeBlock* codeBlock() const { return this[CallFrameSlot::codeBlock].Register::codeBlock(); }</span>
<span class="line-removed">125         CodeBlock** addressOfCodeBlock() const { return bitwise_cast&lt;CodeBlock**&gt;(this + CallFrameSlot::codeBlock); }</span>
<span class="line-removed">126         SUPPRESS_ASAN CodeBlock* unsafeCodeBlock() const { return this[CallFrameSlot::codeBlock].Register::asanUnsafeCodeBlock(); }</span>
<span class="line-removed">127         JSScope* scope(int scopeRegisterOffset) const</span>
<span class="line-removed">128         {</span>
<span class="line-removed">129             ASSERT(this[scopeRegisterOffset].Register::scope());</span>
<span class="line-removed">130             return this[scopeRegisterOffset].Register::scope();</span>
<span class="line-removed">131         }</span>
<span class="line-removed">132 </span>
<span class="line-removed">133         JSGlobalObject* wasmAwareLexicalGlobalObject(VM&amp;);</span>
134 
<a name="16" id="anc16"></a><span class="line-modified">135         bool isAnyWasmCallee();</span>
136 
137         // Global object in which the currently executing code was defined.
<a name="17" id="anc17"></a><span class="line-modified">138         // Differs from VM::vmEntryGlobalObject() during function calls across web browser frames.</span>
<span class="line-modified">139         JSGlobalObject* lexicalGlobalObject() const;</span>
140 
<a name="18" id="anc18"></a><span class="line-modified">141         // Differs from lexicalGlobalObject because this will have DOM window shell rather than</span>
<span class="line-modified">142         // the actual DOM window, which can&#39;t be &quot;this&quot; for security reasons.</span>
<span class="line-modified">143         JSObject* globalThisValue() const;</span>
<span class="line-removed">144 </span>
<span class="line-removed">145         VM&amp; vm() const;</span>
146 
147         static CallFrame* create(Register* callFrameBase) { return static_cast&lt;CallFrame*&gt;(callFrameBase); }
148         Register* registers() { return this; }
149         const Register* registers() const { return this; }
150 
151         CallFrame&amp; operator=(const Register&amp; r) { *static_cast&lt;Register*&gt;(this) = r; return *this; }
152 
153         CallFrame* callerFrame() const { return static_cast&lt;CallFrame*&gt;(callerFrameOrEntryFrame()); }
154         void* callerFrameOrEntryFrame() const { return callerFrameAndPC().callerFrame; }
155         SUPPRESS_ASAN void* unsafeCallerFrameOrEntryFrame() const { return unsafeCallerFrameAndPC().callerFrame; }
156 
157         CallFrame* unsafeCallerFrame(EntryFrame*&amp;) const;
158         JS_EXPORT_PRIVATE CallFrame* callerFrame(EntryFrame*&amp;) const;
159 
<a name="19" id="anc19"></a><span class="line-modified">160         JS_EXPORT_PRIVATE SourceOrigin callerSourceOrigin();</span>
161 
162         static ptrdiff_t callerFrameOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, callerFrame); }
163 
164         ReturnAddressPtr returnPC() const { return ReturnAddressPtr(callerFrameAndPC().returnPC); }
165         bool hasReturnPC() const { return !!callerFrameAndPC().returnPC; }
166         void clearReturnPC() { callerFrameAndPC().returnPC = 0; }
167         static ptrdiff_t returnPCOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, returnPC); }
168         AbstractPC abstractReturnPC(VM&amp; vm) { return AbstractPC(vm, this); }
169 
170         bool callSiteBitsAreBytecodeOffset() const;
171         bool callSiteBitsAreCodeOriginIndex() const;
172 
173         unsigned callSiteAsRawBits() const;
174         unsigned unsafeCallSiteAsRawBits() const;
175         CallSiteIndex callSiteIndex() const;
176         CallSiteIndex unsafeCallSiteIndex() const;
177     private:
178         unsigned callSiteBitsAsBytecodeOffset() const;
<a name="20" id="anc20"></a>


179     public:
180 
181         // This will try to get you the bytecode offset, but you should be aware that
182         // this bytecode offset may be bogus in the presence of inlining. This will
183         // also return 0 if the call frame has no notion of bytecode offsets (for
184         // example if it&#39;s native code).
185         // https://bugs.webkit.org/show_bug.cgi?id=121754
<a name="21" id="anc21"></a><span class="line-modified">186         unsigned bytecodeOffset();</span>
187 
188         // This will get you a CodeOrigin. It will always succeed. May return
<a name="22" id="anc22"></a><span class="line-modified">189         // CodeOrigin(0) if we&#39;re in native code.</span>
190         JS_EXPORT_PRIVATE CodeOrigin codeOrigin();
191 
<a name="23" id="anc23"></a><span class="line-modified">192         Register* topOfFrame()</span>
<span class="line-removed">193         {</span>
<span class="line-removed">194             if (!codeBlock())</span>
<span class="line-removed">195                 return registers();</span>
<span class="line-removed">196             return topOfFrameInternal();</span>
<span class="line-removed">197         }</span>
198 
199         const Instruction* currentVPC() const; // This only makes sense in the LLInt and baseline.
200         void setCurrentVPC(const Instruction*);
201 
202         void setCallerFrame(CallFrame* frame) { callerFrameAndPC().callerFrame = frame; }
<a name="24" id="anc24"></a><span class="line-modified">203         void setScope(int scopeRegisterOffset, JSScope* scope) { static_cast&lt;Register*&gt;(this)[scopeRegisterOffset] = scope; }</span>
204 
<a name="25" id="anc25"></a><span class="line-modified">205         static void initGlobalExec(ExecState* globalExec, JSCallee* globalCallee);</span>
206 
207         // Read a register from the codeframe (or constant from the CodeBlock).
<a name="26" id="anc26"></a><span class="line-removed">208         Register&amp; r(int);</span>
209         Register&amp; r(VirtualRegister);
<a name="27" id="anc27"></a><span class="line-modified">210         // Read a register for a non-constant</span>
<span class="line-removed">211         Register&amp; uncheckedR(int);</span>
212         Register&amp; uncheckedR(VirtualRegister);
213 
214         // Access to arguments as passed. (After capture, arguments may move to a different location.)
215         size_t argumentCount() const { return argumentCountIncludingThis() - 1; }
<a name="28" id="anc28"></a><span class="line-modified">216         size_t argumentCountIncludingThis() const { return this[CallFrameSlot::argumentCount].payload(); }</span>
217         static int argumentOffset(int argument) { return (CallFrameSlot::firstArgument + argument); }
218         static int argumentOffsetIncludingThis(int argument) { return (CallFrameSlot::thisArgument + argument); }
219 
220         // In the following (argument() and setArgument()), the &#39;argument&#39;
221         // parameter is the index of the arguments of the target function of
222         // this frame. The index starts at 0 for the first arg, 1 for the
223         // second, etc.
224         //
225         // The arguments (in this case) do not include the &#39;this&#39; value.
226         // arguments(0) will not fetch the &#39;this&#39; value. To get/set &#39;this&#39;,
227         // use thisValue() and setThisValue() below.
228 
229         JSValue* addressOfArgumentsStart() const { return bitwise_cast&lt;JSValue*&gt;(this + argumentOffset(0)); }
230         JSValue argument(size_t argument)
231         {
232             if (argument &gt;= argumentCount())
233                  return jsUndefined();
234             return getArgumentUnsafe(argument);
235         }
236         JSValue uncheckedArgument(size_t argument)
237         {
238             ASSERT(argument &lt; argumentCount());
239             return getArgumentUnsafe(argument);
240         }
241         void setArgument(size_t argument, JSValue value)
242         {
243             this[argumentOffset(argument)] = value;
244         }
245 
246         JSValue getArgumentUnsafe(size_t argIndex)
247         {
248             // User beware! This method does not verify that there is a valid
249             // argument at the specified argIndex. This is used for debugging
250             // and verification code only. The caller is expected to know what
251             // he/she is doing when calling this method.
252             return this[argumentOffset(argIndex)].jsValue();
253         }
254 
255         static int thisArgumentOffset() { return argumentOffsetIncludingThis(0); }
256         JSValue thisValue() { return this[thisArgumentOffset()].jsValue(); }
257         void setThisValue(JSValue value) { this[thisArgumentOffset()] = value; }
258 
259         // Under the constructor implemented in C++, thisValue holds the newTarget instead of the automatically constructed value.
260         // The result of this function is only effective under the &quot;construct&quot; context.
261         JSValue newTarget() { return thisValue(); }
262 
263         JSValue argumentAfterCapture(size_t argument);
264 
<a name="29" id="anc29"></a><span class="line-modified">265         static int offsetFor(size_t argumentCountIncludingThis) { return argumentCountIncludingThis + CallFrameSlot::thisArgument - 1; }</span>
266 
267         static CallFrame* noCaller() { return nullptr; }
<a name="30" id="anc30"></a><span class="line-modified">268         bool isGlobalExec() const</span>
269         {
270             return callerFrameAndPC().callerFrame == noCaller() &amp;&amp; callerFrameAndPC().returnPC == nullptr;
271         }
272 
273         void convertToStackOverflowFrame(VM&amp;, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound);
274         bool isStackOverflowFrame() const;
275         bool isWasmFrame() const;
276 
<a name="31" id="anc31"></a><span class="line-modified">277         void setArgumentCountIncludingThis(int count) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::argumentCount].payload() = count; }</span>
<span class="line-modified">278         void setCallee(JSObject* callee) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::callee] = callee; }</span>
<span class="line-modified">279         void setCodeBlock(CodeBlock* codeBlock) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::codeBlock] = codeBlock; }</span>
<span class="line-modified">280         void setReturnPC(void* value) { callerFrameAndPC().returnPC = reinterpret_cast&lt;const Instruction*&gt;(value); }</span>
281 
282         String friendlyFunctionName();
283 
284         // CallFrame::iterate() expects a Functor that implements the following method:
285         //     StackVisitor::Status operator()(StackVisitor&amp;) const;
286         // FIXME: This method is improper. We rely on the fact that we can call it with a null
287         // receiver. We should always be using StackVisitor directly.
288         // It&#39;s only valid to call this from a non-wasm top frame.
<a name="32" id="anc32"></a><span class="line-modified">289         template &lt;StackVisitor::EmptyEntryFrameAction action = StackVisitor::ContinueIfTopEntryFrameIsEmpty, typename Functor&gt; void iterate(const Functor&amp; functor)</span>
290         {
<a name="33" id="anc33"></a><span class="line-removed">291             VM* vm;</span>
292             void* rawThis = this;
<a name="34" id="anc34"></a><span class="line-modified">293             if (!!rawThis) {</span>
294                 RELEASE_ASSERT(callee().isCell());
<a name="35" id="anc35"></a><span class="line-removed">295                 vm = &amp;this-&gt;vm();</span>
<span class="line-removed">296             } else</span>
<span class="line-removed">297                 vm = nullptr;</span>
298             StackVisitor::visit&lt;action, Functor&gt;(this, vm, functor);
299         }
300 
301         void dump(PrintStream&amp;);
302         JS_EXPORT_PRIVATE const char* describeFrame();
303 
304     private:
305 
<a name="36" id="anc36"></a><span class="line-modified">306         ExecState();</span>
<span class="line-modified">307         ~ExecState();</span>
308 
309         Register* topOfFrameInternal();
310 
311         // The following are for internal use in debugging and verification
312         // code only and not meant as an API for general usage:
313 
314         size_t argIndexForRegister(Register* reg)
315         {
316             // The register at &#39;offset&#39; number of slots from the frame pointer
317             // i.e.
318             //       reg = frame[offset];
319             //   ==&gt; reg = frame + offset;
320             //   ==&gt; offset = reg - frame;
321             int offset = reg - this-&gt;registers();
322 
323             // The offset is defined (based on argumentOffset()) to be:
324             //       offset = CallFrameSlot::firstArgument - argIndex;
325             // Hence:
326             //       argIndex = CallFrameSlot::firstArgument - offset;
327             size_t argIndex = offset - CallFrameSlot::firstArgument;
328             return argIndex;
329         }
330 
331         CallerFrameAndPC&amp; callerFrameAndPC() { return *reinterpret_cast&lt;CallerFrameAndPC*&gt;(this); }
332         const CallerFrameAndPC&amp; callerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
333         SUPPRESS_ASAN const CallerFrameAndPC&amp; unsafeCallerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
334     };
335 
<a name="37" id="anc37"></a>












336 } // namespace JSC
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/SubresourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SubresourceLoader.h&quot;
 31 
 32 #include &quot;CachedRawResource.h&quot;
 33 #include &quot;CachedResourceLoader.h&quot;
 34 #include &quot;CrossOriginAccessControl.h&quot;
 35 #include &quot;CustomHeaderFields.h&quot;
 36 #include &quot;DiagnosticLoggingClient.h&quot;
 37 #include &quot;DiagnosticLoggingKeys.h&quot;
 38 #include &quot;Document.h&quot;
 39 #include &quot;DocumentLoader.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;HTTPParsers.h&quot;
 43 #include &quot;LinkLoader.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;MemoryCache.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;ResourceLoadObserver.h&quot;
 48 #include &quot;ResourceTiming.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &lt;wtf/CompletionHandler.h&gt;
 52 #include &lt;wtf/Ref.h&gt;
 53 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 54 #include &lt;wtf/StdLibExtras.h&gt;
 55 #include &lt;wtf/SystemTracing.h&gt;
 56 #include &lt;wtf/text/CString.h&gt;
 57 
 58 #if PLATFORM(IOS_FAMILY)
 59 #include &lt;RuntimeApplicationChecks.h&gt;
 60 #endif
 61 
 62 #if ENABLE(CONTENT_EXTENSIONS)
 63 #include &quot;ResourceLoadInfo.h&quot;
 64 #endif
 65 
 66 #if USE(QUICK_LOOK)
 67 #include &quot;LegacyPreviewLoader.h&quot;
 68 #include &quot;PreviewConverter.h&quot;
 69 #endif
 70 
 71 #undef RELEASE_LOG_IF_ALLOWED
 72 #undef RELEASE_LOG_ERROR_IF_ALLOWED
 73 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 74 #define RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 75 
 76 namespace WebCore {
 77 
 78 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, subresourceLoaderCounter, (&quot;SubresourceLoader&quot;));
 79 
 80 SubresourceLoader::RequestCountTracker::RequestCountTracker(CachedResourceLoader&amp; cachedResourceLoader, const CachedResource&amp; resource)
 81     : m_cachedResourceLoader(cachedResourceLoader)
 82     , m_resource(resource)
 83 {
 84     m_cachedResourceLoader.incrementRequestCount(m_resource);
 85 }
 86 
 87 SubresourceLoader::RequestCountTracker::~RequestCountTracker()
 88 {
 89     m_cachedResourceLoader.decrementRequestCount(m_resource);
 90 }
 91 
 92 SubresourceLoader::SubresourceLoader(Frame&amp; frame, CachedResource&amp; resource, const ResourceLoaderOptions&amp; options)
 93     : ResourceLoader(frame, options)
 94     , m_resource(&amp;resource)
 95     , m_state(Uninitialized)
 96     , m_requestCountTracker(std::in_place, frame.document()-&gt;cachedResourceLoader(), resource)
 97 {
 98 #ifndef NDEBUG
 99     subresourceLoaderCounter.increment();
100 #endif
101 #if ENABLE(CONTENT_EXTENSIONS)
102     m_resourceType = ContentExtensions::toResourceType(resource.type());
103 #endif
104     m_canCrossOriginRequestsAskUserForCredentials = resource.type() == CachedResource::Type::MainResource || frame.settings().allowCrossOriginSubresourcesToAskForCredentials();
105 }
106 
107 SubresourceLoader::~SubresourceLoader()
108 {
109     ASSERT(m_state != Initialized);
110     ASSERT(reachedTerminalState());
111 #ifndef NDEBUG
112     subresourceLoaderCounter.decrement();
113 #endif
114 }
115 
116 void SubresourceLoader::create(Frame&amp; frame, CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceLoaderOptions&amp; options, CompletionHandler&lt;void(RefPtr&lt;SubresourceLoader&gt;&amp;&amp;)&gt;&amp;&amp; completionHandler)
117 {
118     auto subloader(adoptRef(*new SubresourceLoader(frame, resource, options)));
119 #if PLATFORM(IOS_FAMILY)
120     if (!IOSApplication::isWebProcess()) {
121         // On iOS, do not invoke synchronous resource load delegates while resource load scheduling
122         // is disabled to avoid re-entering style selection from a different thread (see &lt;rdar://problem/9121719&gt;).
123         // FIXME: This should be fixed for all ports in &lt;https://bugs.webkit.org/show_bug.cgi?id=56647&gt;.
124         subloader-&gt;m_iOSOriginalRequest = request;
125         return completionHandler(WTFMove(subloader));
126     }
127 #endif
128     subloader-&gt;init(WTFMove(request), [subloader = subloader.copyRef(), completionHandler = WTFMove(completionHandler)] (bool initialized) mutable {
129         if (!initialized)
130             return completionHandler(nullptr);
131         completionHandler(WTFMove(subloader));
132     });
133 }
134 
135 #if PLATFORM(IOS_FAMILY)
136 void SubresourceLoader::startLoading()
137 {
138     // FIXME: this should probably be removed.
139     ASSERT(!IOSApplication::isWebProcess());
140     init(ResourceRequest(m_iOSOriginalRequest), [this, protectedThis = makeRef(*this)] (bool success) {
141         if (!success)
142             return;
143         m_iOSOriginalRequest = ResourceRequest();
144         start();
145     });
146 }
147 #endif
148 
149 CachedResource* SubresourceLoader::cachedResource()
150 {
151     return m_resource;
152 }
153 
154 void SubresourceLoader::cancelIfNotFinishing()
155 {
156     if (m_state != Initialized)
157         return;
158 
159     ResourceLoader::cancel();
160 }
161 
162 void SubresourceLoader::init(ResourceRequest&amp;&amp; request, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler)
163 {
164     ResourceLoader::init(WTFMove(request), [this, protectedThis = makeRef(*this), completionHandler = WTFMove(completionHandler)] (bool initialized) mutable {
165         if (!initialized)
166             return completionHandler(false);
167         if (!m_documentLoader) {
168             ASSERT_NOT_REACHED();
169             RELEASE_LOG_ERROR(ResourceLoading, &quot;SubresourceLoader::init: resource load canceled because document loader is null (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
170             return completionHandler(false);
171         }
172         ASSERT(!reachedTerminalState());
173         m_state = Initialized;
174         m_documentLoader-&gt;addSubresourceLoader(this);
175         m_origin = m_resource-&gt;origin();
176         completionHandler(true);
177     });
178 }
179 
180 bool SubresourceLoader::isSubresourceLoader() const
181 {
182     return true;
183 }
184 
185 void SubresourceLoader::willSendRequestInternal(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
186 {
187     // Store the previous URL because the call to ResourceLoader::willSendRequest will modify it.
188     URL previousURL = request().url();
189     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
190 
191     if (!newRequest.url().isValid()) {
192         cancel(cannotShowURLError());
193         return completionHandler(WTFMove(newRequest));
194     }
195 
196     if (newRequest.requester() != ResourceRequestBase::Requester::Main) {
197         tracePoint(SubresourceLoadWillStart);
198         ResourceLoadObserver::shared().logSubresourceLoading(m_frame.get(), newRequest, redirectResponse,
199             (isScriptLikeDestination(options().destination) ? ResourceLoadObserver::FetchDestinationIsScriptLike::Yes : ResourceLoadObserver::FetchDestinationIsScriptLike::No));
200     }
201 
202     auto continueWillSendRequest = [this, protectedThis = makeRef(*this), redirectResponse] (CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler, ResourceRequest&amp;&amp; newRequest) mutable {
203         if (newRequest.isNull() || reachedTerminalState())
204             return completionHandler(WTFMove(newRequest));
205 
206         ResourceLoader::willSendRequestInternal(WTFMove(newRequest), redirectResponse, [this, protectedThis = WTFMove(protectedThis), completionHandler = WTFMove(completionHandler), redirectResponse] (ResourceRequest&amp;&amp; request) mutable {
207             if (reachedTerminalState())
208                 return completionHandler(WTFMove(request));
209 
210             if (request.isNull()) {
211                 cancel();
212                 return completionHandler(WTFMove(request));
213             }
214 
215             if (m_resource-&gt;type() == CachedResource::Type::MainResource &amp;&amp; !redirectResponse.isNull())
216                 m_documentLoader-&gt;willContinueMainResourceLoadAfterRedirect(request);
217             completionHandler(WTFMove(request));
218         });
219     };
220 
221     ASSERT(!newRequest.isNull());
222     if (!redirectResponse.isNull()) {
223         if (options().redirect != FetchOptions::Redirect::Follow) {
224             if (options().redirect == FetchOptions::Redirect::Error) {
225                 ResourceError error { errorDomainWebKitInternal, 0, request().url(), makeString(&quot;Not allowed to follow a redirection while loading &quot;, request().url().string()), ResourceError::Type::AccessControl };
226 
227                 if (m_frame &amp;&amp; m_frame-&gt;document())
228                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
229 
230                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because not allowed to follow a redirect (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
231 
232                 cancel(error);
233                 return completionHandler(WTFMove(newRequest));
234             }
235 
236             ResourceResponse opaqueRedirectedResponse = redirectResponse;
237             opaqueRedirectedResponse.setType(ResourceResponse::Type::Opaqueredirect);
238             opaqueRedirectedResponse.setTainting(ResourceResponse::Tainting::Opaqueredirect);
239             m_resource-&gt;responseReceived(opaqueRedirectedResponse);
240             if (reachedTerminalState()) {
241                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
242                 return completionHandler(WTFMove(newRequest));
243             }
244 
245             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load completed (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
246 
247             NetworkLoadMetrics emptyMetrics;
248             didFinishLoading(emptyMetrics);
249             return completionHandler(WTFMove(newRequest));
250         } else if (m_redirectCount++ &gt;= options().maxRedirectCount) {
251             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because too many redirects (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
252             cancel(ResourceError(String(), 0, request().url(), &quot;Too many redirections&quot;_s, ResourceError::Type::General));
253             return completionHandler(WTFMove(newRequest));
254         }
255 
256         // CachedResources are keyed off their original request URL.
257         // Requesting the same original URL a second time can redirect to a unique second resource.
258         // Therefore, if a redirect to a different destination URL occurs, we should no longer consider this a revalidation of the first resource.
259         // Doing so would have us reusing the resource from the first request if the second request&#39;s revalidation succeeds.
260         if (newRequest.isConditional() &amp;&amp; m_resource-&gt;resourceToRevalidate() &amp;&amp; newRequest.url() != m_resource-&gt;resourceToRevalidate()-&gt;response().url()) {
261             newRequest.makeUnconditional();
262             MemoryCache::singleton().revalidationFailed(*m_resource);
263             if (m_frame &amp;&amp; m_frame-&gt;page())
264                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
265         }
266 
267         if (!m_documentLoader-&gt;cachedResourceLoader().updateRequestAfterRedirection(m_resource-&gt;type(), newRequest, options())) {
268             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because something about updateRequestAfterRedirection (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
269             cancel();
270             return completionHandler(WTFMove(newRequest));
271         }
272 
273         String errorDescription;
274         if (!checkRedirectionCrossOriginAccessControl(request(), redirectResponse, newRequest, errorDescription)) {
275             String errorMessage = &quot;Cross-origin redirection to &quot; + newRequest.url().string() + &quot; denied by Cross-Origin Resource Sharing policy: &quot; + errorDescription;
276             if (m_frame &amp;&amp; m_frame-&gt;document())
277                 m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorMessage);
278             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because crosss-origin redirection denied by CORS policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
279             cancel(ResourceError(String(), 0, request().url(), errorMessage, ResourceError::Type::AccessControl));
280             return completionHandler(WTFMove(newRequest));
281         }
282 
283         if (m_resource-&gt;isImage() &amp;&amp; m_documentLoader-&gt;cachedResourceLoader().shouldDeferImageLoad(newRequest.url())) {
284             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because it&#39;s an image that should be defered (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
285             cancel();
286             return completionHandler(WTFMove(newRequest));
287         }
288         m_loadTiming.addRedirect(redirectResponse.url(), newRequest.url());
289         m_resource-&gt;redirectReceived(WTFMove(newRequest), redirectResponse, [completionHandler = WTFMove(completionHandler), continueWillSendRequest = WTFMove(continueWillSendRequest)] (ResourceRequest&amp;&amp; request) mutable {
290             continueWillSendRequest(WTFMove(completionHandler), WTFMove(request));
291         });
292         return;
293     }
294 
295     continueWillSendRequest(WTFMove(completionHandler), WTFMove(newRequest));
296 }
297 
298 void SubresourceLoader::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
299 {
300     ASSERT(m_state == Initialized);
301     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
302     m_resource-&gt;didSendData(bytesSent, totalBytesToBeSent);
303 }
304 
305 #if USE(QUICK_LOOK)
306 
307 bool SubresourceLoader::shouldCreatePreviewLoaderForResponse(const ResourceResponse&amp; response) const
308 {
309     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
310         return false;
311 
312     if (m_previewLoader)
313         return false;
314 
315     return PreviewConverter::supportsMIMEType(response.mimeType());
316 }
317 
318 void SubresourceLoader::didReceivePreviewResponse(const ResourceResponse&amp; response)
319 {
320     ASSERT(m_state == Initialized);
321     ASSERT(!response.isNull());
322     ASSERT(m_resource);
323     m_resource-&gt;previewResponseReceived(response);
324     ResourceLoader::didReceivePreviewResponse(response);
325 }
326 
327 #endif
328 
329 static bool isLocationURLFailure(const ResourceResponse&amp; response)
330 {
331     auto locationString = response.httpHeaderField(HTTPHeaderName::Location);
332     return !locationString.isNull() &amp;&amp; locationString.isEmpty();
333 }
334 
335 void SubresourceLoader::didReceiveResponse(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler)
336 {
337     ASSERT(!response.isNull());
338     ASSERT(m_state == Initialized);
339 
340     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(policyCompletionHandler));
341 
342 #if USE(QUICK_LOOK)
343     if (shouldCreatePreviewLoaderForResponse(response)) {
344         m_previewLoader = makeUnique&lt;LegacyPreviewLoader&gt;(*this, response);
345         if (m_previewLoader-&gt;didReceiveResponse(response))
346             return;
347     }
348 #endif
349 #if ENABLE(SERVICE_WORKER)
350     // Implementing step 10 of https://fetch.spec.whatwg.org/#main-fetch for service worker responses.
351     if (response.source() == ResourceResponse::Source::ServiceWorker &amp;&amp; response.url() != request().url()) {
352         auto&amp; loader = m_documentLoader-&gt;cachedResourceLoader();
353         if (!loader.allowedByContentSecurityPolicy(m_resource-&gt;type(), response.url(), options(), ContentSecurityPolicy::RedirectResponseReceived::Yes)) {
354             RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because not allowed by content policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
355             cancel(ResourceError({ }, 0, response.url(), { }, ResourceError::Type::General));
356             return;
357         }
358     }
359 #endif
360 
361     if (auto error = validateRangeRequestedFlag(request(), response)) {
362         RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because receiving a range requested response for a non-range request (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
363         cancel(WTFMove(*error));
364         return;
365     }
366 
367     // We want redirect responses to be processed through willSendRequestInternal. Exceptions are
368     // redirection with no Location headers and fetch in manual redirect mode. Or in rare circumstances,
369     // cases of too many redirects from CFNetwork (&lt;rdar://problem/30610988&gt;).
370 #if !PLATFORM(COCOA)
371     ASSERT(response.httpStatusCode() &lt; 300 || response.httpStatusCode() &gt;= 400 || response.httpStatusCode() == 304 || !response.httpHeaderField(HTTPHeaderName::Location) || response.type() == ResourceResponse::Type::Opaqueredirect);
372 #endif
373 
374     // Reference the object in this method since the additional processing can do
375     // anything including removing the last reference to this object; one example of this is 3266216.
376     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
377 
378     if (shouldIncludeCertificateInfo())
379         response.includeCertificateInfo();
380 
381     if (m_resource-&gt;resourceToRevalidate()) {
382         if (response.httpStatusCode() == 304) {
383             // 304 Not modified / Use local copy
384             // Existing resource is ok, just use it updating the expiration time.
385             ResourceResponse revalidationResponse = response;
386             revalidationResponse.setSource(ResourceResponse::Source::MemoryCacheAfterValidation);
387             m_resource-&gt;setResponse(revalidationResponse);
388             MemoryCache::singleton().revalidationSucceeded(*m_resource, revalidationResponse);
389             if (m_frame &amp;&amp; m_frame-&gt;page())
390                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultPass, ShouldSample::Yes);
391             if (!reachedTerminalState())
392                 ResourceLoader::didReceiveResponse(revalidationResponse, [completionHandlerCaller = WTFMove(completionHandlerCaller)] { });
393             return;
394         }
395         // Did not get 304 response, continue as a regular resource load.
396         MemoryCache::singleton().revalidationFailed(*m_resource);
397         if (m_frame &amp;&amp; m_frame-&gt;page())
398             m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
399     }
400 
401     String errorDescription;
402     if (!checkResponseCrossOriginAccessControl(response, errorDescription)) {
403         if (m_frame &amp;&amp; m_frame-&gt;document())
404             m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorDescription);
405         RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because of cross origin access control (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
406         cancel(ResourceError(String(), 0, request().url(), errorDescription, ResourceError::Type::AccessControl));
407         return;
408     }
409 
410     if (response.isRedirection()) {
411         if (options().redirect == FetchOptions::Redirect::Follow &amp;&amp; isLocationURLFailure(response)) {
412             // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 3
413             cancel();
414             return;
415         }
416         if (options().redirect == FetchOptions::Redirect::Manual) {
417             ResourceResponse opaqueRedirectedResponse = response;
418             opaqueRedirectedResponse.setType(ResourceResponse::Type::Opaqueredirect);
419             opaqueRedirectedResponse.setTainting(ResourceResponse::Tainting::Opaqueredirect);
420             m_resource-&gt;responseReceived(opaqueRedirectedResponse);
421             if (!reachedTerminalState())
422                 ResourceLoader::didReceiveResponse(opaqueRedirectedResponse, [completionHandlerCaller = WTFMove(completionHandlerCaller)] { });
423             return;
424         }
425     }
426     m_resource-&gt;responseReceived(response);
427     if (reachedTerminalState())
428         return;
429 
430     bool isResponseMultipart = response.isMultipart();
431     if (options().mode != FetchOptions::Mode::Navigate)
432         LinkLoader::loadLinksFromHeader(response.httpHeaderField(HTTPHeaderName::Link), m_documentLoader-&gt;url(), *m_frame-&gt;document(), LinkLoader::MediaAttributeCheck::SkipMediaAttributeCheck);
433     ResourceLoader::didReceiveResponse(response, [this, protectedThis = WTFMove(protectedThis), isResponseMultipart, completionHandlerCaller = WTFMove(completionHandlerCaller)]() mutable {
434         if (reachedTerminalState())
435             return;
436 
437         // FIXME: Main resources have a different set of rules for multipart than images do.
438         // Hopefully we can merge those 2 paths.
439         if (isResponseMultipart &amp;&amp; m_resource-&gt;type() != CachedResource::Type::MainResource) {
440             m_loadingMultipartContent = true;
441 
442             // We don&#39;t count multiParts in a CachedResourceLoader&#39;s request count
443             m_requestCountTracker = WTF::nullopt;
444             if (!m_resource-&gt;isImage()) {
445                 RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because something about a multi-part non-image (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
446                 cancel();
447                 return;
448             }
449         }
450 
451         auto* buffer = resourceData();
452         if (m_loadingMultipartContent &amp;&amp; buffer &amp;&amp; buffer-&gt;size()) {
453             // The resource data will change as the next part is loaded, so we need to make a copy.
454             m_resource-&gt;finishLoading(buffer-&gt;copy().ptr());
455             clearResourceData();
456             // Since a subresource loader does not load multipart sections progressively, data was delivered to the loader all at once.
457             // After the first multipart section is complete, signal to delegates that this load is &quot;finished&quot;
458             NetworkLoadMetrics emptyMetrics;
459             m_documentLoader-&gt;subresourceLoaderFinishedLoadingOnePart(this);
460             didFinishLoadingOnePart(emptyMetrics);
461         }
462 
463         checkForHTTPStatusCodeError();
464 
465         if (m_inAsyncResponsePolicyCheck)
466             m_policyForResponseCompletionHandler = completionHandlerCaller.release();
467     });
468 }
469 
470 void SubresourceLoader::didReceiveResponsePolicy()
471 {
472     ASSERT(m_inAsyncResponsePolicyCheck);
473     m_inAsyncResponsePolicyCheck = false;
474     if (auto completionHandler = WTFMove(m_policyForResponseCompletionHandler))
475         completionHandler();
476 }
477 
478 void SubresourceLoader::didReceiveData(const char* data, unsigned length, long long encodedDataLength, DataPayloadType dataPayloadType)
479 {
480 #if USE(QUICK_LOOK)
481     if (auto previewLoader = m_previewLoader.get()) {
482         if (previewLoader-&gt;didReceiveData(data, length))
483             return;
484     }
485 #endif
486 
487     didReceiveDataOrBuffer(data, length, nullptr, encodedDataLength, dataPayloadType);
488 }
489 
490 void SubresourceLoader::didReceiveBuffer(Ref&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
491 {
492 #if USE(QUICK_LOOK)
493     if (auto previewLoader = m_previewLoader.get()) {
494         if (previewLoader-&gt;didReceiveBuffer(buffer.get()))
495             return;
496     }
497 #endif
498 
499     didReceiveDataOrBuffer(nullptr, 0, WTFMove(buffer), encodedDataLength, dataPayloadType);
500 }
501 
502 void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
503 {
504     ASSERT(m_resource);
505 
506     if (m_resource-&gt;response().httpStatusCode() &gt;= 400 &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())
507         return;
508     ASSERT(!m_resource-&gt;resourceToRevalidate());
509     ASSERT(!m_resource-&gt;errorOccurred());
510     ASSERT(m_state == Initialized);
511     // Reference the object in this method since the additional processing can do
512     // anything including removing the last reference to this object; one example of this is 3266216.
513     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
514 
515     ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);
516 
517     if (!m_loadingMultipartContent) {
518         if (auto* resourceData = this-&gt;resourceData())
519             m_resource-&gt;updateBuffer(*resourceData);
520         else
521             m_resource-&gt;updateData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);
522     }
523 }
524 
525 bool SubresourceLoader::checkForHTTPStatusCodeError()
526 {
527     if (m_resource-&gt;response().httpStatusCode() &lt; 400 || m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())
528         return false;
529 
530     m_state = Finishing;
531     m_resource-&gt;error(CachedResource::LoadError);
532     cancel();
533     return true;
534 }
535 
536 static void logResourceLoaded(Frame* frame, CachedResource::Type type)
537 {
538     if (!frame || !frame-&gt;page())
539         return;
540 
541     String resourceType;
542     switch (type) {
543     case CachedResource::Type::MainResource:
544         resourceType = DiagnosticLoggingKeys::mainResourceKey();
545         break;
546     case CachedResource::Type::ImageResource:
547         resourceType = DiagnosticLoggingKeys::imageKey();
548         break;
549 #if ENABLE(XSLT)
550     case CachedResource::Type::XSLStyleSheet:
551 #endif
552     case CachedResource::Type::CSSStyleSheet:
553         resourceType = DiagnosticLoggingKeys::styleSheetKey();
554         break;
555     case CachedResource::Type::Script:
556         resourceType = DiagnosticLoggingKeys::scriptKey();
557         break;
558     case CachedResource::Type::FontResource:
559 #if ENABLE(SVG_FONTS)
560     case CachedResource::Type::SVGFontResource:
561 #endif
562         resourceType = DiagnosticLoggingKeys::fontKey();
563         break;
564     case CachedResource::Type::Beacon:
565     case CachedResource::Type::Ping:
566     case CachedResource::Type::MediaResource:
567     case CachedResource::Type::Icon:
568     case CachedResource::Type::RawResource:
569         resourceType = DiagnosticLoggingKeys::rawKey();
570         break;
571     case CachedResource::Type::SVGDocumentResource:
572         resourceType = DiagnosticLoggingKeys::svgDocumentKey();
573         break;
574 #if ENABLE(APPLICATION_MANIFEST)
575     case CachedResource::Type::ApplicationManifest:
576         resourceType = DiagnosticLoggingKeys::applicationManifestKey();
577         break;
578 #endif
579     case CachedResource::Type::LinkPrefetch:
580 #if ENABLE(VIDEO_TRACK)
581     case CachedResource::Type::TextTrackResource:
582 #endif
583         resourceType = DiagnosticLoggingKeys::otherKey();
584         break;
585     }
586 
587     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::resourceLoadedKey(), resourceType, ShouldSample::Yes);
588 }
589 
590 bool SubresourceLoader::checkResponseCrossOriginAccessControl(const ResourceResponse&amp; response, String&amp; errorDescription)
591 {
592     if (!m_resource-&gt;isCrossOrigin() || options().mode != FetchOptions::Mode::Cors)
593         return true;
594 
595 #if ENABLE(SERVICE_WORKER)
596     if (response.source() == ResourceResponse::Source::ServiceWorker)
597         return response.tainting() != ResourceResponse::Tainting::Opaque;
598 #endif
599 
600     ASSERT(m_origin);
601 
602     return passesAccessControlCheck(response, options().credentials == FetchOptions::Credentials::Include ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse, *m_origin, errorDescription);
603 }
604 
605 bool SubresourceLoader::checkRedirectionCrossOriginAccessControl(const ResourceRequest&amp; previousRequest, const ResourceResponse&amp; redirectResponse, ResourceRequest&amp; newRequest, String&amp; errorMessage)
606 {
607     bool crossOriginFlag = m_resource-&gt;isCrossOrigin();
608     bool isNextRequestCrossOrigin = m_origin &amp;&amp; !m_origin-&gt;canRequest(newRequest.url());
609 
610     if (isNextRequestCrossOrigin)
611         m_resource-&gt;setCrossOrigin();
612 
613     ASSERT(options().mode != FetchOptions::Mode::SameOrigin || !m_resource-&gt;isCrossOrigin());
614 
615     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 7 &amp; 8.
616     if (options().mode == FetchOptions::Mode::Cors) {
617         if (m_resource-&gt;isCrossOrigin()) {
618             auto locationString = redirectResponse.httpHeaderField(HTTPHeaderName::Location);
619             errorMessage = validateCrossOriginRedirectionURL(URL(redirectResponse.url(), locationString));
620             if (!errorMessage.isNull())
621                 return false;
622         }
623 
624         ASSERT(m_origin);
625         if (crossOriginFlag &amp;&amp; !passesAccessControlCheck(redirectResponse, options().storedCredentialsPolicy, *m_origin, errorMessage))
626             return false;
627     }
628 
629     bool redirectingToNewOrigin = false;
630     if (m_resource-&gt;isCrossOrigin()) {
631         if (!crossOriginFlag &amp;&amp; isNextRequestCrossOrigin)
632             redirectingToNewOrigin = true;
633         else
634             redirectingToNewOrigin = !protocolHostAndPortAreEqual(previousRequest.url(), newRequest.url());
635     }
636 
637     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 10.
638     if (crossOriginFlag &amp;&amp; redirectingToNewOrigin)
639         m_origin = SecurityOrigin::createUnique();
640 
641     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 14.
642     updateReferrerPolicy(redirectResponse.httpHeaderField(HTTPHeaderName::ReferrerPolicy));
643 
644     if (options().mode == FetchOptions::Mode::Cors &amp;&amp; redirectingToNewOrigin) {
645         cleanHTTPRequestHeadersForAccessControl(newRequest, options().httpHeadersToKeep);
646         updateRequestForAccessControl(newRequest, *m_origin, options().storedCredentialsPolicy);
647     }
648 
649     updateRequestReferrer(newRequest, referrerPolicy(), previousRequest.httpReferrer());
650 
651     return true;
652 }
653 
654 void SubresourceLoader::updateReferrerPolicy(const String&amp; referrerPolicyValue)
655 {
656     if (auto referrerPolicy = parseReferrerPolicy(referrerPolicyValue, ReferrerPolicySource::HTTPHeader)) {
657         ASSERT(*referrerPolicy != ReferrerPolicy::EmptyString);
658         setReferrerPolicy(*referrerPolicy);
659     }
660 }
661 
662 void SubresourceLoader::didFinishLoading(const NetworkLoadMetrics&amp; networkLoadMetrics)
663 {
664     RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
665 
666 #if USE(QUICK_LOOK)
667     if (auto previewLoader = m_previewLoader.get()) {
668         if (previewLoader-&gt;didFinishLoading())
669             return;
670     }
671 #endif
672 
673     if (m_state != Initialized)
674         return;
675     ASSERT(!reachedTerminalState());
676     ASSERT(!m_resource-&gt;resourceToRevalidate());
677     // FIXME (129394): We should cancel the load when a decode error occurs instead of continuing the load to completion.
678     ASSERT(!m_resource-&gt;errorOccurred() || m_resource-&gt;status() == CachedResource::DecodeError || !m_resource-&gt;isLoading());
679     LOG(ResourceLoading, &quot;Received &#39;%s&#39;.&quot;, m_resource-&gt;url().string().latin1().data());
680     logResourceLoaded(m_frame.get(), m_resource-&gt;type());
681 
682     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
683     CachedResourceHandle&lt;CachedResource&gt; protectResource(m_resource);
684 
685     // FIXME: Remove this with deprecatedNetworkLoadMetrics.
686     m_loadTiming.setResponseEnd(MonotonicTime::now());
687 
688     if (networkLoadMetrics.isComplete())
689         reportResourceTiming(networkLoadMetrics);
690     else {
691         // This is the legacy path for platforms (and ResourceHandle paths) that do not provide
692         // complete load metrics in didFinishLoad. In those cases, fall back to the possibility
693         // that they populated partial load timing information on the ResourceResponse.
694         reportResourceTiming(m_resource-&gt;response().deprecatedNetworkLoadMetrics());
695     }
696 
697     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
698         tracePoint(SubresourceLoadDidEnd);
699 
700     m_state = Finishing;
701     m_resource-&gt;finishLoading(resourceData());
702 
703     if (wasCancelled()) {
704         RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: was canceled (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
705         return;
706     }
707 
708     m_resource-&gt;finish();
709     ASSERT(!reachedTerminalState());
710     didFinishLoadingOnePart(networkLoadMetrics);
711     notifyDone(LoadCompletionType::Finish);
712 
713     if (reachedTerminalState()) {
714         RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
715         return;
716     }
717     releaseResources();
718 }
719 
720 void SubresourceLoader::didFail(const ResourceError&amp; error)
721 {
722     RELEASE_LOG_IF_ALLOWED(&quot;didFail: (frame = %p, frameLoader = %p, resourceID = %lu, type = %d, code = %d)&quot;, frame(), frameLoader(), identifier(), static_cast&lt;int&gt;(error.type()), error.errorCode());
723 
724 #if USE(QUICK_LOOK)
725     if (auto previewLoader = m_previewLoader.get())
726         previewLoader-&gt;didFail();
727 #endif
728 
729     if (m_state != Initialized)
730         return;
731 
732     ASSERT(!reachedTerminalState());
733     LOG(ResourceLoading, &quot;Failed to load &#39;%s&#39;.\n&quot;, m_resource-&gt;url().string().latin1().data());
734 
735     if (m_frame-&gt;document() &amp;&amp; error.isAccessControl() &amp;&amp; m_resource-&gt;type() != CachedResource::Type::Ping)
736         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
737 
738     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
739     CachedResourceHandle&lt;CachedResource&gt; protectResource(m_resource);
740     m_state = Finishing;
741 
742     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
743         tracePoint(SubresourceLoadDidEnd);
744 
745     if (m_resource-&gt;resourceToRevalidate())
746         MemoryCache::singleton().revalidationFailed(*m_resource);
747     m_resource-&gt;setResourceError(error);
748     if (!m_resource-&gt;isPreloaded())
749         MemoryCache::singleton().remove(*m_resource);
750     m_resource-&gt;error(CachedResource::LoadError);
751     cleanupForError(error);
752     notifyDone(LoadCompletionType::Cancel);
753     if (reachedTerminalState())
754         return;
755     releaseResources();
756 }
757 
758 void SubresourceLoader::willCancel(const ResourceError&amp; error)
759 {
760     RELEASE_LOG_IF_ALLOWED(&quot;willCancel: (frame = %p, frameLoader = %p, resourceID = %lu, type = %d, code = %d)&quot;, frame(), frameLoader(), identifier(), static_cast&lt;int&gt;(error.type()), error.errorCode());
761 
762 #if PLATFORM(IOS_FAMILY)
763     // Since we defer initialization to scheduling time on iOS but
764     // CachedResourceLoader stores resources in the memory cache immediately,
765     // m_resource might be cached despite its loader not being initialized.
766     if (m_state != Initialized &amp;&amp; m_state != Uninitialized)
767 #else
768     if (m_state != Initialized)
769 #endif
770         return;
771 
772     ASSERT(!reachedTerminalState());
773     LOG(ResourceLoading, &quot;Cancelled load of &#39;%s&#39;.\n&quot;, m_resource-&gt;url().string().latin1().data());
774 
775     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
776 #if PLATFORM(IOS_FAMILY)
777     m_state = m_state == Uninitialized ? CancelledWhileInitializing : Finishing;
778 #else
779     m_state = Finishing;
780 #endif
781     auto&amp; memoryCache = MemoryCache::singleton();
782     if (m_resource-&gt;resourceToRevalidate())
783         memoryCache.revalidationFailed(*m_resource);
784     m_resource-&gt;setResourceError(error);
785     memoryCache.remove(*m_resource);
786 }
787 
788 void SubresourceLoader::didCancel(const ResourceError&amp;)
789 {
790     if (m_state == Uninitialized)
791         return;
792 
793     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
794         tracePoint(SubresourceLoadDidEnd);
795 
796     m_resource-&gt;cancelLoad();
797     notifyDone(LoadCompletionType::Cancel);
798 }
799 
800 void SubresourceLoader::notifyDone(LoadCompletionType type)
801 {
802     if (reachedTerminalState())
803         return;
804 
805     m_requestCountTracker = WTF::nullopt;
806     bool shouldPerformPostLoadActions = true;
807 #if PLATFORM(IOS_FAMILY)
808     if (m_state == CancelledWhileInitializing)
809         shouldPerformPostLoadActions = false;
810 #endif
811     m_documentLoader-&gt;cachedResourceLoader().loadDone(type, shouldPerformPostLoadActions);
812     if (reachedTerminalState())
813         return;
814     m_documentLoader-&gt;removeSubresourceLoader(type, this);
815 }
816 
817 void SubresourceLoader::releaseResources()
818 {
819     ASSERT(!reachedTerminalState());
820 #if PLATFORM(IOS_FAMILY)
821     if (m_state != Uninitialized &amp;&amp; m_state != CancelledWhileInitializing)
822 #else
823     if (m_state != Uninitialized)
824 #endif
825         m_resource-&gt;clearLoader();
826     m_resource = nullptr;
827     ResourceLoader::releaseResources();
828 }
829 
830 void SubresourceLoader::reportResourceTiming(const NetworkLoadMetrics&amp; networkLoadMetrics)
831 {
832     if (!RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
833         return;
834 
835     if (!ResourceTimingInformation::shouldAddResourceTiming(*m_resource))
836         return;
837 
838     Document* document = m_documentLoader-&gt;cachedResourceLoader().document();
839     if (!document)
840         return;
841 
842     SecurityOrigin&amp; origin = m_origin ? *m_origin : document-&gt;securityOrigin();
843     auto resourceTiming = ResourceTiming::fromLoad(*m_resource, m_resource-&gt;initiatorName(), m_loadTiming, networkLoadMetrics, origin);
844 
845     // Worker resources loaded here are all CachedRawResources loaded through WorkerThreadableLoader.
846     // Pass the ResourceTiming information on so that WorkerThreadableLoader may add them to the
847     // Worker&#39;s Performance object.
848     if (options().initiatorContext == InitiatorContext::Worker) {
849         ASSERT(m_origin);
850         ASSERT(is&lt;CachedRawResource&gt;(m_resource));
851         downcast&lt;CachedRawResource&gt;(*m_resource).finishedTimingForWorkerLoad(WTFMove(resourceTiming));
852         return;
853     }
854 
855     ASSERT(options().initiatorContext == InitiatorContext::Document);
856     m_documentLoader-&gt;cachedResourceLoader().resourceTimingInformation().addResourceTiming(*m_resource, *document, WTFMove(resourceTiming));
857 }
858 
859 const HTTPHeaderMap* SubresourceLoader::originalHeaders() const
860 {
861     return (m_resource  &amp;&amp; m_resource-&gt;originalRequest()) ? &amp;m_resource-&gt;originalRequest()-&gt;httpHeaderFields() : nullptr;
862 }
863 
864 }
865 
866 #undef RELEASE_LOG_IF_ALLOWED
867 #undef RELEASE_LOG_ERROR_IF_ALLOWED
    </pre>
  </body>
</html>
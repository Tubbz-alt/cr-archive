diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSJavaScriptCallFrame.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSJavaScriptCallFrame.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSJavaScriptCallFrame.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSJavaScriptCallFrame.cpp
@@ -31,14 +31,14 @@
 #include "IdentifierInlines.h"
 #include "JSCInlines.h"
 #include "JSJavaScriptCallFramePrototype.h"
 #include "ObjectConstructor.h"
 
-using namespace JSC;
-
 namespace Inspector {
 
+using namespace JSC;
+
 const ClassInfo JSJavaScriptCallFrame::s_info = { "JavaScriptCallFrame", &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSJavaScriptCallFrame) };
 
 JSJavaScriptCallFrame::JSJavaScriptCallFrame(VM& vm, Structure* structure, Ref<JavaScriptCallFrame>&& impl)
     : JSDestructibleObject(vm, structure)
     , m_impl(&impl.leakRef())
@@ -71,27 +71,27 @@
 JSJavaScriptCallFrame::~JSJavaScriptCallFrame()
 {
     releaseImpl();
 }
 
-JSValue JSJavaScriptCallFrame::evaluateWithScopeExtension(ExecState* exec)
+JSValue JSJavaScriptCallFrame::evaluateWithScopeExtension(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue scriptValue = exec->argument(0);
+    JSValue scriptValue = callFrame->argument(0);
     if (!scriptValue.isString())
-        return throwTypeError(exec, scope, "JSJavaScriptCallFrame.evaluateWithScopeExtension first argument must be a string."_s);
+        return throwTypeError(globalObject, scope, "JSJavaScriptCallFrame.evaluateWithScopeExtension first argument must be a string."_s);
 
-    String script = asString(scriptValue)->value(exec);
+    String script = asString(scriptValue)->value(globalObject);
     RETURN_IF_EXCEPTION(scope, JSValue());
 
     NakedPtr<Exception> exception;
-    JSObject* scopeExtension = exec->argument(1).getObject();
+    JSObject* scopeExtension = callFrame->argument(1).getObject();
     JSValue result = impl().evaluateWithScopeExtension(script, scopeExtension, exception);
     if (exception)
-        throwException(exec, scope, exception);
+        throwException(globalObject, scope, exception);
 
     return result;
 }
 
 static JSValue valueForScopeType(DebuggerScope* scope)
@@ -111,78 +111,78 @@
 
     ASSERT(scope->isClosureScope());
     return jsNumber(JSJavaScriptCallFrame::CLOSURE_SCOPE);
 }
 
-static JSValue valueForScopeLocation(ExecState* exec, const DebuggerLocation& location)
+static JSValue valueForScopeLocation(JSGlobalObject* globalObject, const DebuggerLocation& location)
 {
     if (location.sourceID == noSourceID)
         return jsNull();
 
     // Debugger.Location protocol object.
-    VM& vm = exec->vm();
-    JSObject* result = constructEmptyObject(exec);
+    VM& vm = globalObject->vm();
+    JSObject* result = constructEmptyObject(globalObject);
     result->putDirect(vm, Identifier::fromString(vm, "scriptId"), jsString(vm, String::number(location.sourceID)));
     result->putDirect(vm, Identifier::fromString(vm, "lineNumber"), jsNumber(location.line));
     result->putDirect(vm, Identifier::fromString(vm, "columnNumber"), jsNumber(location.column));
     return result;
 }
 
-JSValue JSJavaScriptCallFrame::scopeDescriptions(ExecState* exec)
+JSValue JSJavaScriptCallFrame::scopeDescriptions(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
     DebuggerScope* scopeChain = impl().scopeChain();
     if (!scopeChain)
         return jsUndefined();
 
     int index = 0;
-    JSArray* array = constructEmptyArray(exec, nullptr);
+    JSArray* array = constructEmptyArray(globalObject, nullptr);
 
     DebuggerScope::iterator end = scopeChain->end();
     for (DebuggerScope::iterator iter = scopeChain->begin(); iter != end; ++iter) {
         DebuggerScope* scope = iter.get();
-        JSObject* description = constructEmptyObject(exec);
+        JSObject* description = constructEmptyObject(globalObject);
         description->putDirect(vm, Identifier::fromString(vm, "type"), valueForScopeType(scope));
         description->putDirect(vm, Identifier::fromString(vm, "name"), jsString(vm, scope->name()));
-        description->putDirect(vm, Identifier::fromString(vm, "location"), valueForScopeLocation(exec, scope->location()));
-        array->putDirectIndex(exec, index++, description);
+        description->putDirect(vm, Identifier::fromString(vm, "location"), valueForScopeLocation(globalObject, scope->location()));
+        array->putDirectIndex(globalObject, index++, description);
         RETURN_IF_EXCEPTION(throwScope, JSValue());
     }
 
     return array;
 }
 
-JSValue JSJavaScriptCallFrame::caller(ExecState* exec) const
+JSValue JSJavaScriptCallFrame::caller(JSGlobalObject* lexicalGlobalObject) const
 {
-    return toJS(exec, globalObject(exec->vm()), impl().caller());
+    return toJS(lexicalGlobalObject, this->globalObject(lexicalGlobalObject->vm()), impl().caller());
 }
 
-JSValue JSJavaScriptCallFrame::sourceID(ExecState*) const
+JSValue JSJavaScriptCallFrame::sourceID(JSGlobalObject*) const
 {
     return jsNumber(impl().sourceID());
 }
 
-JSValue JSJavaScriptCallFrame::line(ExecState*) const
+JSValue JSJavaScriptCallFrame::line(JSGlobalObject*) const
 {
     return jsNumber(impl().line());
 }
 
-JSValue JSJavaScriptCallFrame::column(ExecState*) const
+JSValue JSJavaScriptCallFrame::column(JSGlobalObject*) const
 {
     return jsNumber(impl().column());
 }
 
-JSValue JSJavaScriptCallFrame::functionName(ExecState* exec) const
+JSValue JSJavaScriptCallFrame::functionName(JSGlobalObject* globalObject) const
 {
-    return jsString(exec->vm(), impl().functionName());
+    return jsString(globalObject->vm(), impl().functionName());
 }
 
-JSValue JSJavaScriptCallFrame::scopeChain(ExecState* exec) const
+JSValue JSJavaScriptCallFrame::scopeChain(JSGlobalObject* globalObject) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!impl().scopeChain())
         return jsNull();
 
@@ -197,30 +197,30 @@
     do {
         list.append(iter.get());
         ++iter;
     } while (iter != end);
     if (UNLIKELY(list.hasOverflowed())) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return { };
     }
 
-    return constructArray(exec, nullptr, globalObject(vm), list);
+    return constructArray(this->globalObject(vm), static_cast<ArrayAllocationProfile*>(nullptr), list);
 }
 
-JSValue JSJavaScriptCallFrame::thisObject(ExecState*) const
+JSValue JSJavaScriptCallFrame::thisObject(JSGlobalObject* globalObject) const
 {
-    return impl().thisValue();
+    return impl().thisValue(globalObject->vm());
 }
 
-JSValue JSJavaScriptCallFrame::isTailDeleted(JSC::ExecState*) const
+JSValue JSJavaScriptCallFrame::isTailDeleted(JSC::JSGlobalObject*) const
 {
     return jsBoolean(impl().isTailDeleted());
 }
 
-JSValue JSJavaScriptCallFrame::type(ExecState* exec) const
+JSValue JSJavaScriptCallFrame::type(JSGlobalObject* globalObject) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     switch (impl().type()) {
     case DebuggerCallFrame::FunctionType:
         return jsNontrivialString(vm, "function"_s);
     case DebuggerCallFrame::ProgramType:
         return jsNontrivialString(vm, "program"_s);
@@ -228,16 +228,16 @@
 
     ASSERT_NOT_REACHED();
     return jsNull();
 }
 
-JSValue toJS(ExecState* exec, JSGlobalObject* globalObject, JavaScriptCallFrame* impl)
+JSValue toJS(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, JavaScriptCallFrame* impl)
 {
     if (!impl)
         return jsNull();
 
-    VM& vm = exec->vm();
+    VM& vm = lexicalGlobalObject->vm();
     JSObject* prototype = JSJavaScriptCallFrame::createPrototype(vm, globalObject);
     Structure* structure = JSJavaScriptCallFrame::createStructure(vm, globalObject, prototype);
     JSJavaScriptCallFrame* javaScriptCallFrame = JSJavaScriptCallFrame::create(vm, structure, *impl);
 
     return javaScriptCallFrame;

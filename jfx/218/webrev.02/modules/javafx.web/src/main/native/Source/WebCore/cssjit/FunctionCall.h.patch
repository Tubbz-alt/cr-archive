diff a/modules/javafx.web/src/main/native/Source/WebCore/cssjit/FunctionCall.h b/modules/javafx.web/src/main/native/Source/WebCore/cssjit/FunctionCall.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/cssjit/FunctionCall.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/cssjit/FunctionCall.h
@@ -72,11 +72,11 @@
         cleanupPostCall();
     }
 
     JSC::MacroAssembler::Jump callAndBranchOnBooleanReturnValue(JSC::MacroAssembler::ResultCondition condition)
     {
-#if CPU(X86) || CPU(X86_64)
+#if CPU(X86_64)
         return callAndBranchOnCondition(condition, JSC::MacroAssembler::TrustedImm32(0xff));
 #elif CPU(ARM64) || CPU(ARM)
         return callAndBranchOnCondition(condition, JSC::MacroAssembler::TrustedImm32(-1));
 #else
 #error Missing implementationg for matching boolean return values.
@@ -95,11 +95,11 @@
     void swapArguments()
     {
         JSC::MacroAssembler::RegisterID a = m_firstArgument;
         JSC::MacroAssembler::RegisterID b = m_secondArgument;
         // x86 can swap without a temporary register. On other architectures, we need allocate a temporary register to switch the values.
-#if CPU(X86) || CPU(X86_64)
+#if CPU(X86_64)
         m_assembler.swap(a, b);
 #elif CPU(ARM64) || CPU(ARM_THUMB2)
         m_assembler.move(a, tempRegister);
         m_assembler.move(b, a);
         m_assembler.move(tempRegister, b);

diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.cpp
@@ -30,10 +30,11 @@
 #include "PageGroup.h"
 #include "RemoteFrame.h"
 #include "ScriptController.h"
 #include "runtime_root.h"
 #include <JavaScriptCore/JSLock.h>
+#include <JavaScriptCore/StrongInlines.h>
 #include <JavaScriptCore/WeakGCMapInlines.h>
 #include <wtf/MemoryPressureHandler.h>
 
 namespace WebCore {
 
@@ -51,62 +52,63 @@
         GCController::singleton().garbageCollectSoon();
 }
 
 WindowProxy::WindowProxy(AbstractFrame& frame)
     : m_frame(&frame)
+    , m_jsWindowProxies(makeUniqueRef<ProxyMap>())
 {
 }
 
 WindowProxy::~WindowProxy()
 {
     ASSERT(!m_frame);
-    ASSERT(m_jsWindowProxies.isEmpty());
+    ASSERT(m_jsWindowProxies->isEmpty());
 }
 
 void WindowProxy::detachFromFrame()
 {
     ASSERT(m_frame);
 
     m_frame = nullptr;
 
     // It's likely that destroying windowProxies will create a lot of garbage.
-    if (!m_jsWindowProxies.isEmpty()) {
-        while (!m_jsWindowProxies.isEmpty()) {
-            auto it = m_jsWindowProxies.begin();
+    if (!m_jsWindowProxies->isEmpty()) {
+        while (!m_jsWindowProxies->isEmpty()) {
+            auto it = m_jsWindowProxies->begin();
             it->value->window()->setConsoleClient(nullptr);
             destroyJSWindowProxy(*it->key);
         }
         collectGarbageAfterWindowProxyDestruction();
     }
 }
 
 void WindowProxy::destroyJSWindowProxy(DOMWrapperWorld& world)
 {
-    ASSERT(m_jsWindowProxies.contains(&world));
-    m_jsWindowProxies.remove(&world);
+    ASSERT(m_jsWindowProxies->contains(&world));
+    m_jsWindowProxies->remove(&world);
     world.didDestroyWindowProxy(this);
 }
 
 JSWindowProxy& WindowProxy::createJSWindowProxy(DOMWrapperWorld& world)
 {
     ASSERT(m_frame);
 
-    ASSERT(!m_jsWindowProxies.contains(&world));
+    ASSERT(!m_jsWindowProxies->contains(&world));
     ASSERT(m_frame->window());
 
     VM& vm = world.vm();
 
     Strong<JSWindowProxy> jsWindowProxy(vm, &JSWindowProxy::create(vm, *m_frame->window(), world));
     Strong<JSWindowProxy> jsWindowProxy2(jsWindowProxy);
-    m_jsWindowProxies.add(&world, jsWindowProxy);
+    m_jsWindowProxies->add(&world, jsWindowProxy);
     world.didCreateWindowProxy(this);
     return *jsWindowProxy.get();
 }
 
 Vector<JSC::Strong<JSWindowProxy>> WindowProxy::jsWindowProxiesAsVector() const
 {
-    return copyToVector(m_jsWindowProxies.values());
+    return copyToVector(m_jsWindowProxies->values());
 }
 
 JSDOMGlobalObject* WindowProxy::globalObject(DOMWrapperWorld& world)
 {
     if (auto* windowProxy = jsWindowProxy(world))
@@ -123,13 +125,13 @@
     if (is<Frame>(*m_frame))
         downcast<Frame>(*m_frame).script().initScriptForWindowProxy(windowProxy);
     return windowProxy;
 }
 
-void WindowProxy::clearJSWindowProxiesNotMatchingDOMWindow(AbstractDOMWindow* newDOMWindow, bool goingIntoPageCache)
+void WindowProxy::clearJSWindowProxiesNotMatchingDOMWindow(AbstractDOMWindow* newDOMWindow, bool goingIntoBackForwardCache)
 {
-    if (m_jsWindowProxies.isEmpty())
+    if (m_jsWindowProxies->isEmpty())
         return;
 
     JSLockHolder lock(commonVM());
 
     for (auto& windowProxy : jsWindowProxiesAsVector()) {
@@ -143,19 +145,19 @@
             jsDOMWindow->willRemoveFromWindowProxy();
     }
 
     // It's likely that resetting our windows created a lot of garbage, unless
     // it went in a back/forward cache.
-    if (!goingIntoPageCache)
+    if (!goingIntoBackForwardCache)
         collectGarbageAfterWindowProxyDestruction();
 }
 
 void WindowProxy::setDOMWindow(AbstractDOMWindow* newDOMWindow)
 {
     ASSERT(newDOMWindow);
 
-    if (m_jsWindowProxies.isEmpty())
+    if (m_jsWindowProxies->isEmpty())
         return;
 
     ASSERT(m_frame);
 
     JSLockHolder lock(commonVM());
@@ -186,15 +188,30 @@
     }
 }
 
 void WindowProxy::attachDebugger(JSC::Debugger* debugger)
 {
-    for (auto& windowProxy : m_jsWindowProxies.values())
+    for (auto& windowProxy : m_jsWindowProxies->values())
         windowProxy->attachDebugger(debugger);
 }
 
 AbstractDOMWindow* WindowProxy::window() const
 {
     return m_frame ? m_frame->window() : nullptr;
 }
 
+WindowProxy::ProxyMap::ValuesConstIteratorRange WindowProxy::jsWindowProxies() const
+{
+    return m_jsWindowProxies->values();
+}
+
+WindowProxy::ProxyMap WindowProxy::releaseJSWindowProxies()
+{
+    return std::exchange(m_jsWindowProxies, makeUniqueRef<ProxyMap>());
+}
+
+void WindowProxy::setJSWindowProxies(ProxyMap&& windowProxies)
+{
+    m_jsWindowProxies = makeUniqueRef<ProxyMap>(WTFMove(windowProxies));
+}
+
 } // namespace WebCore

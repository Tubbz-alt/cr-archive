<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/markup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008, 2009, 2010, 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2011 Igalia S.L.
   5  * Copyright (C) 2011 Motorola Mobility. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;markup.h&quot;
  31 
  32 #include &quot;ArchiveResource.h&quot;
  33 #include &quot;CSSPrimitiveValue.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValue.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;CacheStorageProvider.h&quot;
  38 #include &quot;ChildListMutationScope.h&quot;
  39 #include &quot;Comment.h&quot;
  40 #include &quot;ComposedTreeIterator.h&quot;
  41 #include &quot;CustomHeaderFields.h&quot;
  42 #include &quot;DocumentFragment.h&quot;
  43 #include &quot;DocumentLoader.h&quot;
  44 #include &quot;DocumentType.h&quot;
  45 #include &quot;Editing.h&quot;
  46 #include &quot;Editor.h&quot;
  47 #include &quot;EditorClient.h&quot;
  48 #include &quot;ElementIterator.h&quot;
  49 #include &quot;EmptyClients.h&quot;
  50 #include &quot;File.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;HTMLAttachmentElement.h&quot;
  54 #include &quot;HTMLBRElement.h&quot;
  55 #include &quot;HTMLBodyElement.h&quot;
  56 #include &quot;HTMLDivElement.h&quot;
  57 #include &quot;HTMLHeadElement.h&quot;
  58 #include &quot;HTMLHtmlElement.h&quot;
  59 #include &quot;HTMLImageElement.h&quot;
  60 #include &quot;HTMLNames.h&quot;
  61 #include &quot;HTMLStyleElement.h&quot;
  62 #include &quot;HTMLTableElement.h&quot;
  63 #include &quot;HTMLTextAreaElement.h&quot;
  64 #include &quot;HTMLTextFormControlElement.h&quot;
  65 #include &quot;LibWebRTCProvider.h&quot;
  66 #include &quot;MarkupAccumulator.h&quot;
  67 #include &quot;NodeList.h&quot;
  68 #include &quot;Page.h&quot;
  69 #include &quot;PageConfiguration.h&quot;
  70 #include &quot;PasteboardItemInfo.h&quot;
  71 #include &quot;Range.h&quot;
  72 #include &quot;RenderBlock.h&quot;
  73 #include &quot;RuntimeEnabledFeatures.h&quot;
  74 #include &quot;Settings.h&quot;
  75 #include &quot;SocketProvider.h&quot;
  76 #include &quot;StyleProperties.h&quot;
  77 #include &quot;TextIterator.h&quot;
  78 #include &quot;TypedElementDescendantIterator.h&quot;
  79 #include &quot;VisibleSelection.h&quot;
  80 #include &quot;VisibleUnits.h&quot;
  81 #include &lt;wtf/StdLibExtras.h&gt;
  82 #include &lt;wtf/URL.h&gt;
  83 #include &lt;wtf/URLParser.h&gt;
  84 #include &lt;wtf/text/StringBuilder.h&gt;
  85 
  86 namespace WebCore {
  87 
  88 using namespace HTMLNames;
  89 
  90 static bool propertyMissingOrEqualToNone(StyleProperties*, CSSPropertyID);
  91 
  92 class AttributeChange {
  93 public:
  94     AttributeChange()
  95         : m_name(nullAtom(), nullAtom(), nullAtom())
  96     {
  97     }
  98 
  99     AttributeChange(Element* element, const QualifiedName&amp; name, const String&amp; value)
 100         : m_element(element), m_name(name), m_value(value)
 101     {
 102     }
 103 
 104     void apply()
 105     {
 106         m_element-&gt;setAttribute(m_name, m_value);
 107     }
 108 
 109 private:
 110     RefPtr&lt;Element&gt; m_element;
 111     QualifiedName m_name;
 112     String m_value;
 113 };
 114 
 115 static void completeURLs(DocumentFragment* fragment, const String&amp; baseURL)
 116 {
 117     Vector&lt;AttributeChange&gt; changes;
 118 
 119     URL parsedBaseURL({ }, baseURL);
 120 
 121     for (auto&amp; element : descendantsOfType&lt;Element&gt;(*fragment)) {
 122         if (!element.hasAttributes())
 123             continue;
 124         for (const Attribute&amp; attribute : element.attributesIterator()) {
 125             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty())
 126                 changes.append(AttributeChange(&amp;element, attribute.name(), element.completeURLsInAttributeValue(parsedBaseURL, attribute)));
 127         }
 128     }
 129 
 130     for (auto&amp; change : changes)
 131         change.apply();
 132 }
 133 
 134 void replaceSubresourceURLs(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, HashMap&lt;AtomString, AtomString&gt;&amp;&amp; replacementMap)
 135 {
 136     Vector&lt;AttributeChange&gt; changes;
 137     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 138         if (!element.hasAttributes())
 139             continue;
 140         for (const Attribute&amp; attribute : element.attributesIterator()) {
 141             // FIXME: This won&#39;t work for srcset.
 142             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 143                 auto replacement = replacementMap.get(attribute.value());
 144                 if (!replacement.isNull())
 145                     changes.append({ &amp;element, attribute.name(), replacement });
 146             }
 147         }
 148     }
 149     for (auto&amp; change : changes)
 150         change.apply();
 151 }
 152 
 153 struct ElementAttribute {
 154     Ref&lt;Element&gt; element;
 155     QualifiedName attributeName;
 156 };
 157 
 158 void removeSubresourceURLAttributes(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, WTF::Function&lt;bool(const URL&amp;)&gt; shouldRemoveURL)
 159 {
 160     Vector&lt;ElementAttribute&gt; attributesToRemove;
 161     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 162         if (!element.hasAttributes())
 163             continue;
 164         for (const Attribute&amp; attribute : element.attributesIterator()) {
 165             // FIXME: This won&#39;t work for srcset.
 166             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 167                 URL url({ }, attribute.value());
 168                 if (shouldRemoveURL(url))
 169                     attributesToRemove.append({ element, attribute.name() });
 170             }
 171         }
 172     }
 173     for (auto&amp; item : attributesToRemove)
 174         item.element-&gt;removeAttribute(item.attributeName);
 175 }
 176 
 177 std::unique_ptr&lt;Page&gt; createPageForSanitizingWebContent()
 178 {
<a name="1" id="anc1"></a><span class="line-modified"> 179     auto pageConfiguration = pageConfigurationWithEmptyClients(PAL::SessionID::defaultSessionID());</span>
 180 
 181     auto page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));
<a name="2" id="anc2"></a>
 182     page-&gt;settings().setMediaEnabled(false);
 183     page-&gt;settings().setScriptEnabled(false);
<a name="3" id="anc3"></a><span class="line-added"> 184     page-&gt;settings().setParserScriptingFlagPolicy(SettingsBase::ParserScriptingFlagPolicy::Enabled);</span>
 185     page-&gt;settings().setPluginsEnabled(false);
 186     page-&gt;settings().setAcceleratedCompositingEnabled(false);
 187 
 188     Frame&amp; frame = page-&gt;mainFrame();
 189     frame.setView(FrameView::create(frame, IntSize { 800, 600 }));
 190     frame.init();
 191 
 192     FrameLoader&amp; loader = frame.loader();
 193     static char markup[] = &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 194     ASSERT(loader.activeDocumentLoader());
 195     auto&amp; writer = loader.activeDocumentLoader()-&gt;writer();
 196     writer.setMIMEType(&quot;text/html&quot;);
 197     writer.begin();
 198     writer.insertDataSynchronously(String(markup));
 199     writer.end();
 200     RELEASE_ASSERT(page-&gt;mainFrame().document()-&gt;body());
 201 
 202     return page;
 203 }
 204 
 205 String sanitizeMarkup(const String&amp; rawHTML, MSOListQuirks msoListQuirks, Optional&lt;WTF::Function&lt;void(DocumentFragment&amp;)&gt;&gt; fragmentSanitizer)
 206 {
 207     auto page = createPageForSanitizingWebContent();
 208     Document* stagingDocument = page-&gt;mainFrame().document();
 209     ASSERT(stagingDocument);
 210 
 211     auto fragment = createFragmentFromMarkup(*stagingDocument, rawHTML, emptyString(), DisallowScriptingAndPluginContent);
 212 
 213     if (fragmentSanitizer)
 214         (*fragmentSanitizer)(fragment);
 215 
 216     return sanitizedMarkupForFragmentInDocument(WTFMove(fragment), *stagingDocument, msoListQuirks, rawHTML);
 217 }
 218 
 219 enum class MSOListMode { Preserve, DoNotPreserve };
 220 class StyledMarkupAccumulator final : public MarkupAccumulator {
 221 public:
 222     enum RangeFullySelectsNode { DoesFullySelectNode, DoesNotFullySelectNode };
 223 
 224     StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs, SerializeComposedTree,
<a name="4" id="anc4"></a><span class="line-modified"> 225         AnnotateForInterchange, StandardFontFamilySerializationMode, MSOListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized = nullptr);</span>
 226 
 227     Node* serializeNodes(const Position&amp; start, const Position&amp; end);
 228     void wrapWithNode(Node&amp;, bool convertBlocksToInlines = false, RangeFullySelectsNode = DoesFullySelectNode);
 229     void wrapWithStyleNode(StyleProperties*, Document&amp;, bool isBlock = false);
 230     String takeResults();
 231 
 232     bool needRelativeStyleWrapper() const { return m_needRelativeStyleWrapper; }
 233     bool needClearingDiv() const { return m_needClearingDiv; }
 234 
 235     using MarkupAccumulator::appendString;
 236 
 237     ContainerNode* parentNode(Node&amp; node)
 238     {
 239         if (UNLIKELY(m_useComposedTree))
 240             return node.parentInComposedTree();
 241         return node.parentOrShadowHostNode();
 242     }
 243 
 244 private:
 245     void appendStyleNodeOpenTag(StringBuilder&amp;, StyleProperties*, Document&amp;, bool isBlock = false);
 246     const String&amp; styleNodeCloseTag(bool isBlock = false);
 247 
 248     String renderedTextRespectingRange(const Text&amp;);
 249     String textContentRespectingRange(const Text&amp;);
 250 
 251     bool shouldPreserveMSOListStyleForElement(const Element&amp;);
 252 
 253     void appendStartTag(StringBuilder&amp; out, const Element&amp;, bool addDisplayInline, RangeFullySelectsNode);
 254     void appendEndTag(StringBuilder&amp; out, const Element&amp;) override;
 255     void appendCustomAttributes(StringBuilder&amp;, const Element&amp;, Namespaces*) override;
 256 
 257     void appendText(StringBuilder&amp; out, const Text&amp;) override;
 258     void appendStartTag(StringBuilder&amp; out, const Element&amp; element, Namespaces*) override
 259     {
 260         appendStartTag(out, element, false, DoesFullySelectNode);
 261     }
 262 
 263     Node* firstChild(Node&amp; node)
 264     {
 265         if (UNLIKELY(m_useComposedTree))
 266             return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 267         return node.firstChild();
 268     }
 269 
 270     Node* nextSibling(Node&amp; node)
 271     {
 272         if (UNLIKELY(m_useComposedTree))
 273             return nextSiblingInComposedTreeIgnoringUserAgentShadow(node);
 274         return node.nextSibling();
 275     }
 276 
 277     Node* nextSkippingChildren(Node&amp; node)
 278     {
 279         if (UNLIKELY(m_useComposedTree))
 280             return nextSkippingChildrenInComposedTreeIgnoringUserAgentShadow(node);
 281         return NodeTraversal::nextSkippingChildren(node);
 282     }
 283 
 284     bool hasChildNodes(Node&amp; node)
 285     {
 286         if (UNLIKELY(m_useComposedTree))
 287             return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 288         return node.hasChildNodes();
 289     }
 290 
 291     bool isDescendantOf(Node&amp; node, Node&amp; possibleAncestor)
 292     {
 293         if (UNLIKELY(m_useComposedTree))
 294             return node.isDescendantOrShadowDescendantOf(&amp;possibleAncestor);
 295         return node.isDescendantOf(&amp;possibleAncestor);
 296     }
 297 
 298     enum class NodeTraversalMode { EmitString, DoNotEmitString };
 299     Node* traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode);
 300 
 301     bool appendNodeToPreserveMSOList(Node&amp;);
 302 
 303     bool shouldAnnotate()
 304     {
 305         return m_annotate == AnnotateForInterchange::Yes;
 306     }
 307 
 308     bool shouldApplyWrappingStyle(const Node&amp; node) const
 309     {
 310         return m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode() == node.parentNode() &amp;&amp; m_wrappingStyle &amp;&amp; m_wrappingStyle-&gt;style();
 311     }
 312 
 313     Position m_start;
 314     Position m_end;
 315     Vector&lt;String&gt; m_reversedPrecedingMarkup;
 316     const AnnotateForInterchange m_annotate;
 317     RefPtr&lt;Node&gt; m_highestNodeToBeSerialized;
 318     RefPtr&lt;EditingStyle&gt; m_wrappingStyle;
 319     bool m_useComposedTree;
 320     bool m_needsPositionStyleConversion;
<a name="5" id="anc5"></a><span class="line-added"> 321     StandardFontFamilySerializationMode m_standardFontFamilySerializationMode;</span>
<span class="line-added"> 322     bool m_shouldPreserveMSOList;</span>
 323     bool m_needRelativeStyleWrapper { false };
 324     bool m_needClearingDiv { false };
<a name="6" id="anc6"></a>
 325     bool m_inMSOList { false };
 326 };
 327 
 328 inline StyledMarkupAccumulator::StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<a name="7" id="anc7"></a><span class="line-modified"> 329     AnnotateForInterchange annotate, StandardFontFamilySerializationMode standardFontFamilySerializationMode, MSOListMode msoListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized)</span>
 330     : MarkupAccumulator(nodes, urlsToResolve)
 331     , m_start(start)
 332     , m_end(end)
 333     , m_annotate(annotate)
 334     , m_highestNodeToBeSerialized(highestNodeToBeSerialized)
 335     , m_useComposedTree(serializeComposedTree == SerializeComposedTree::Yes)
 336     , m_needsPositionStyleConversion(needsPositionStyleConversion)
<a name="8" id="anc8"></a><span class="line-added"> 337     , m_standardFontFamilySerializationMode(standardFontFamilySerializationMode)</span>
 338     , m_shouldPreserveMSOList(msoListMode == MSOListMode::Preserve)
 339 {
 340 }
 341 
 342 void StyledMarkupAccumulator::wrapWithNode(Node&amp; node, bool convertBlocksToInlines, RangeFullySelectsNode rangeFullySelectsNode)
 343 {
 344     StringBuilder markup;
 345     if (is&lt;Element&gt;(node))
 346         appendStartTag(markup, downcast&lt;Element&gt;(node), convertBlocksToInlines &amp;&amp; isBlock(&amp;node), rangeFullySelectsNode);
 347     else
 348         appendNonElementNode(markup, node, nullptr);
 349     m_reversedPrecedingMarkup.append(markup.toString());
 350     endAppendingNode(node);
 351     if (m_nodes)
 352         m_nodes-&gt;append(&amp;node);
 353 }
 354 
 355 void StyledMarkupAccumulator::wrapWithStyleNode(StyleProperties* style, Document&amp; document, bool isBlock)
 356 {
 357     StringBuilder openTag;
 358     appendStyleNodeOpenTag(openTag, style, document, isBlock);
 359     m_reversedPrecedingMarkup.append(openTag.toString());
 360     appendString(styleNodeCloseTag(isBlock));
 361 }
 362 
 363 void StyledMarkupAccumulator::appendStyleNodeOpenTag(StringBuilder&amp; out, StyleProperties* style, Document&amp; document, bool isBlock)
 364 {
 365     // wrappingStyleForSerialization should have removed -webkit-text-decorations-in-effect
 366     ASSERT(propertyMissingOrEqualToNone(style, CSSPropertyWebkitTextDecorationsInEffect));
 367     if (isBlock)
 368         out.appendLiteral(&quot;&lt;div style=\&quot;&quot;);
 369     else
 370         out.appendLiteral(&quot;&lt;span style=\&quot;&quot;);
 371     appendAttributeValue(out, style-&gt;asText(), document.isHTMLDocument());
 372     out.appendLiteral(&quot;\&quot;&gt;&quot;);
 373 }
 374 
 375 const String&amp; StyledMarkupAccumulator::styleNodeCloseTag(bool isBlock)
 376 {
 377     static NeverDestroyed&lt;const String&gt; divClose(MAKE_STATIC_STRING_IMPL(&quot;&lt;/div&gt;&quot;));
 378     static NeverDestroyed&lt;const String&gt; styleSpanClose(MAKE_STATIC_STRING_IMPL(&quot;&lt;/span&gt;&quot;));
 379     return isBlock ? divClose : styleSpanClose;
 380 }
 381 
 382 String StyledMarkupAccumulator::takeResults()
 383 {
 384     StringBuilder result;
 385     result.reserveCapacity(totalLength(m_reversedPrecedingMarkup) + length());
 386 
 387     for (size_t i = m_reversedPrecedingMarkup.size(); i &gt; 0; --i)
 388         result.append(m_reversedPrecedingMarkup[i - 1]);
 389 
 390     concatenateMarkup(result);
 391 
 392     // We remove &#39;\0&#39; characters because they are not visibly rendered to the user.
 393     return result.toString().replaceWithLiteral(&#39;\0&#39;, &quot;&quot;);
 394 }
 395 
 396 void StyledMarkupAccumulator::appendText(StringBuilder&amp; out, const Text&amp; text)
 397 {
 398     const bool parentIsTextarea = is&lt;HTMLTextAreaElement&gt;(text.parentElement());
 399     const bool wrappingSpan = shouldApplyWrappingStyle(text) &amp;&amp; !parentIsTextarea;
 400     if (wrappingSpan) {
 401         RefPtr&lt;EditingStyle&gt; wrappingStyle = m_wrappingStyle-&gt;copy();
 402         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 403         // Make sure spans are inline style in paste side e.g. span { display: block }.
 404         wrappingStyle-&gt;forceInline();
 405         // FIXME: Should this be included in forceInline?
 406         wrappingStyle-&gt;style()-&gt;setProperty(CSSPropertyFloat, CSSValueNone);
 407 
 408         appendStyleNodeOpenTag(out, wrappingStyle-&gt;style(), text.document());
 409     }
 410 
 411     if (!shouldAnnotate() || parentIsTextarea) {
 412         auto content = textContentRespectingRange(text);
 413         appendCharactersReplacingEntities(out, content, 0, content.length(), entityMaskForText(text));
 414     } else {
 415         const bool useRenderedText = !enclosingElementWithTag(firstPositionInNode(const_cast&lt;Text*&gt;(&amp;text)), selectTag);
 416         String content = useRenderedText ? renderedTextRespectingRange(text) : textContentRespectingRange(text);
 417         StringBuilder buffer;
 418         appendCharactersReplacingEntities(buffer, content, 0, content.length(), EntityMaskInPCDATA);
 419         out.append(convertHTMLTextToInterchangeFormat(buffer.toString(), &amp;text));
 420     }
 421 
 422     if (wrappingSpan)
 423         out.append(styleNodeCloseTag());
 424 }
 425 
 426 String StyledMarkupAccumulator::renderedTextRespectingRange(const Text&amp; text)
 427 {
 428     TextIteratorBehavior behavior = TextIteratorDefaultBehavior;
 429     Position start = &amp;text == m_start.containerNode() ? m_start : firstPositionInNode(const_cast&lt;Text*&gt;(&amp;text));
 430     Position end;
 431     if (&amp;text == m_end.containerNode())
 432         end = m_end;
 433     else {
 434         end = lastPositionInNode(const_cast&lt;Text*&gt;(&amp;text));
 435         if (!m_end.isNull())
 436             behavior = TextIteratorBehavesAsIfNodesFollowing;
 437     }
 438 
 439     return plainText(Range::create(text.document(), start, end).ptr(), behavior);
 440 }
 441 
 442 String StyledMarkupAccumulator::textContentRespectingRange(const Text&amp; text)
 443 {
 444     if (m_start.isNull() &amp;&amp; m_end.isNull())
 445         return text.data();
 446 
 447     unsigned start = 0;
 448     unsigned end = std::numeric_limits&lt;unsigned&gt;::max();
 449     if (&amp;text == m_start.containerNode())
 450         start = m_start.offsetInContainerNode();
 451     if (&amp;text == m_end.containerNode())
 452         end = m_end.offsetInContainerNode();
 453     ASSERT(start &lt; end);
 454     return text.data().substring(start, end - start);
 455 }
 456 
 457 void StyledMarkupAccumulator::appendCustomAttributes(StringBuilder&amp; out, const Element&amp; element, Namespaces* namespaces)
 458 {
 459 #if ENABLE(ATTACHMENT_ELEMENT)
 460     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 461         return;
 462 
 463     if (is&lt;HTMLAttachmentElement&gt;(element)) {
 464         auto&amp; attachment = downcast&lt;HTMLAttachmentElement&gt;(element);
 465         appendAttribute(out, element, { webkitattachmentidAttr, attachment.uniqueIdentifier() }, namespaces);
 466         if (auto* file = attachment.file()) {
 467             // These attributes are only intended for File deserialization, and are removed from the generated attachment
 468             // element after we&#39;ve deserialized and set its backing File, in restoreAttachmentElementsInFragment.
 469             appendAttribute(out, element, { webkitattachmentpathAttr, file-&gt;path() }, namespaces);
 470             appendAttribute(out, element, { webkitattachmentbloburlAttr, file-&gt;url().string() }, namespaces);
 471         }
 472     } else if (is&lt;HTMLImageElement&gt;(element)) {
 473         if (auto attachment = downcast&lt;HTMLImageElement&gt;(element).attachmentElement())
 474             appendAttribute(out, element, { webkitattachmentidAttr, attachment-&gt;uniqueIdentifier() }, namespaces);
 475     }
 476 #else
 477     UNUSED_PARAM(out);
 478     UNUSED_PARAM(element);
 479     UNUSED_PARAM(namespaces);
 480 #endif
 481 }
 482 
 483 bool StyledMarkupAccumulator::shouldPreserveMSOListStyleForElement(const Element&amp; element)
 484 {
 485     if (m_inMSOList)
 486         return true;
 487     if (m_shouldPreserveMSOList) {
 488         auto style = element.getAttribute(styleAttr);
 489         return style.startsWith(&quot;mso-list:&quot;) || style.contains(&quot;;mso-list:&quot;) || style.contains(&quot;\nmso-list:&quot;);
 490     }
 491     return false;
 492 }
 493 
 494 void StyledMarkupAccumulator::appendStartTag(StringBuilder&amp; out, const Element&amp; element, bool addDisplayInline, RangeFullySelectsNode rangeFullySelectsNode)
 495 {
 496     const bool documentIsHTML = element.document().isHTMLDocument();
 497     const bool isSlotElement = is&lt;HTMLSlotElement&gt;(element);
 498     if (UNLIKELY(isSlotElement))
 499         out.append(&quot;&lt;span&quot;);
 500     else
 501         appendOpenTag(out, element, nullptr);
 502 
 503     appendCustomAttributes(out, element, nullptr);
 504 
 505     const bool shouldAnnotateOrForceInline = element.isHTMLElement() &amp;&amp; (shouldAnnotate() || addDisplayInline);
 506     bool shouldOverrideStyleAttr = (shouldAnnotateOrForceInline || shouldApplyWrappingStyle(element) || isSlotElement) &amp;&amp; !shouldPreserveMSOListStyleForElement(element);
 507     if (element.hasAttributes()) {
 508         for (const Attribute&amp; attribute : element.attributesIterator()) {
 509             // We&#39;ll handle the style attribute separately, below.
 510             if (attribute.name() == styleAttr &amp;&amp; shouldOverrideStyleAttr)
 511                 continue;
 512             if (element.isEventHandlerAttribute(attribute) || element.isJavaScriptURLAttribute(attribute))
 513                 continue;
 514             appendAttribute(out, element, attribute, 0);
 515         }
 516     }
 517 
 518     if (shouldOverrideStyleAttr) {
 519         RefPtr&lt;EditingStyle&gt; newInlineStyle;
 520 
 521         if (shouldApplyWrappingStyle(element)) {
 522             newInlineStyle = m_wrappingStyle-&gt;copy();
 523             newInlineStyle-&gt;removePropertiesInElementDefaultStyle(*const_cast&lt;Element*&gt;(&amp;element));
 524             newInlineStyle-&gt;removeStyleConflictingWithStyleOfNode(*const_cast&lt;Element*&gt;(&amp;element));
 525         } else
 526             newInlineStyle = EditingStyle::create();
 527 
 528         if (isSlotElement)
 529             newInlineStyle-&gt;addDisplayContents();
 530 
 531         if (is&lt;StyledElement&gt;(element) &amp;&amp; downcast&lt;StyledElement&gt;(element).inlineStyle())
 532             newInlineStyle-&gt;overrideWithStyle(*downcast&lt;StyledElement&gt;(element).inlineStyle());
 533 
 534         if (shouldAnnotateOrForceInline) {
 535             if (shouldAnnotate())
<a name="9" id="anc9"></a><span class="line-modified"> 536                 newInlineStyle-&gt;mergeStyleFromRulesForSerialization(downcast&lt;HTMLElement&gt;(*const_cast&lt;Element*&gt;(&amp;element)), m_standardFontFamilySerializationMode);</span>
 537 
 538             if (addDisplayInline)
 539                 newInlineStyle-&gt;forceInline();
 540 
 541             if (m_needsPositionStyleConversion) {
 542                 m_needRelativeStyleWrapper |= newInlineStyle-&gt;convertPositionStyle();
 543                 m_needClearingDiv |= newInlineStyle-&gt;isFloating();
 544             }
 545 
 546             // If the node is not fully selected by the range, then we don&#39;t want to keep styles that affect its relationship to the nodes around it
 547             // only the ones that affect it and the nodes within it.
 548             if (rangeFullySelectsNode == DoesNotFullySelectNode &amp;&amp; newInlineStyle-&gt;style())
 549                 newInlineStyle-&gt;style()-&gt;removeProperty(CSSPropertyFloat);
 550         }
 551 
 552         if (!newInlineStyle-&gt;isEmpty()) {
 553             out.appendLiteral(&quot; style=\&quot;&quot;);
 554             appendAttributeValue(out, newInlineStyle-&gt;style()-&gt;asText(), documentIsHTML);
 555             out.append(&#39;\&quot;&#39;);
 556         }
 557     }
 558 
 559     appendCloseTag(out, element);
 560 }
 561 
 562 void StyledMarkupAccumulator::appendEndTag(StringBuilder&amp; out, const Element&amp; element)
 563 {
 564     if (UNLIKELY(is&lt;HTMLSlotElement&gt;(element)))
 565         out.append(&quot;&lt;/span&gt;&quot;);
 566     else
 567         MarkupAccumulator::appendEndTag(out, element);
 568 }
 569 
 570 Node* StyledMarkupAccumulator::serializeNodes(const Position&amp; start, const Position&amp; end)
 571 {
 572     ASSERT(comparePositions(start, end) &lt;= 0);
 573     auto startNode = start.firstNode();
 574     Node* pastEnd = end.computeNodeAfterPosition();
 575     if (!pastEnd &amp;&amp; end.containerNode())
 576         pastEnd = nextSkippingChildren(*end.containerNode());
 577 
 578     if (!m_highestNodeToBeSerialized) {
 579         Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);
 580         m_highestNodeToBeSerialized = lastClosed;
 581     }
 582 
 583     if (m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode())
<a name="10" id="anc10"></a><span class="line-modified"> 584         m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(*m_highestNodeToBeSerialized-&gt;parentNode(), shouldAnnotate(), m_standardFontFamilySerializationMode);</span>
 585 
 586     return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);
 587 }
 588 
 589 Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)
 590 {
 591     const bool shouldEmit = traversalMode == NodeTraversalMode::EmitString;
 592 
 593     m_inMSOList = false;
 594 
 595     unsigned depth = 0;
 596     auto enterNode = [&amp;] (Node&amp; node) {
 597         if (UNLIKELY(m_shouldPreserveMSOList) &amp;&amp; shouldEmit) {
 598             if (appendNodeToPreserveMSOList(node))
 599                 return false;
 600         }
 601 
 602         bool isDisplayContents = is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents();
 603         if (!node.renderer() &amp;&amp; !isDisplayContents &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(&amp;node), selectTag))
 604             return false;
 605 
 606         ++depth;
 607         if (shouldEmit)
 608             startAppendingNode(node);
 609 
 610         return true;
 611     };
 612 
 613     Node* lastClosed = nullptr;
 614     auto exitNode = [&amp;] (Node&amp; node) {
 615         bool closing = depth;
 616         if (depth)
 617             --depth;
 618         if (shouldEmit) {
 619             if (closing)
 620                 endAppendingNode(node);
 621             else
 622                 wrapWithNode(node);
 623         }
 624         lastClosed = &amp;node;
 625     };
 626 
 627     Node* lastNode = nullptr;
 628     Node* next = nullptr;
 629     for (auto* n = startNode; n != pastEnd; lastNode = n, n = next) {
 630 
 631         Vector&lt;Node*, 8&gt; exitedAncestors;
 632         next = nullptr;
 633         if (auto* child = firstChild(*n))
 634             next = child;
 635         else if (auto* sibling = nextSibling(*n))
 636             next = sibling;
 637         else {
 638             for (auto* ancestor = parentNode(*n); ancestor; ancestor = parentNode(*ancestor)) {
 639                 exitedAncestors.append(ancestor);
 640                 if (auto* sibling = nextSibling(*ancestor)) {
 641                     next = sibling;
 642                     break;
 643                 }
 644             }
 645         }
 646         ASSERT(next || !pastEnd);
 647 
 648         if (isBlock(n) &amp;&amp; canHaveChildrenForEditing(*n) &amp;&amp; next == pastEnd) {
 649             // Don&#39;t write out empty block containers that aren&#39;t fully selected.
 650             continue;
 651         }
 652 
 653         if (!enterNode(*n)) {
 654             next = nextSkippingChildren(*n);
 655             // Don&#39;t skip over pastEnd.
 656             if (pastEnd &amp;&amp; isDescendantOf(*pastEnd, *n))
 657                 next = pastEnd;
 658             ASSERT(next || !pastEnd);
 659         } else {
 660             if (!hasChildNodes(*n))
 661                 exitNode(*n);
 662         }
 663 
 664         for (auto* ancestor : exitedAncestors) {
 665             if (!depth &amp;&amp; next == pastEnd)
 666                 break;
 667             exitNode(*ancestor);
 668         }
 669     }
 670 
 671     ASSERT(lastNode || !depth);
 672     if (depth) {
 673         for (auto* ancestor = parentNode(pastEnd ? *pastEnd : *lastNode); ancestor &amp;&amp; depth; ancestor = parentNode(*ancestor))
 674             exitNode(*ancestor);
 675     }
 676 
 677     return lastClosed;
 678 }
 679 
 680 bool StyledMarkupAccumulator::appendNodeToPreserveMSOList(Node&amp; node)
 681 {
 682     if (is&lt;Comment&gt;(node)) {
 683         auto&amp; commentNode = downcast&lt;Comment&gt;(node);
 684         if (!m_inMSOList &amp;&amp; commentNode.data() == &quot;[if !supportLists]&quot;)
 685             m_inMSOList = true;
 686         else if (m_inMSOList &amp;&amp; commentNode.data() == &quot;[endif]&quot;)
 687             m_inMSOList = false;
 688         else
 689             return false;
 690         startAppendingNode(commentNode);
 691         return true;
 692     }
 693     if (is&lt;HTMLStyleElement&gt;(node)) {
 694         auto* firstChild = node.firstChild();
 695         if (!is&lt;Text&gt;(firstChild))
 696             return false;
 697 
 698         auto&amp; textChild = downcast&lt;Text&gt;(*firstChild);
 699         auto&amp; styleContent = textChild.data();
 700 
 701         const auto msoStyleDefinitionsStart = styleContent.find(&quot;/* Style Definitions */&quot;);
 702         const auto msoListDefinitionsStart = styleContent.find(&quot;/* List Definitions */&quot;);
 703         const auto lastListItem = styleContent.reverseFind(&quot;\n@list&quot;);
 704         if (msoListDefinitionsStart == notFound || lastListItem == notFound)
 705             return false;
 706         const auto start = msoStyleDefinitionsStart != notFound &amp;&amp; msoStyleDefinitionsStart &lt; msoListDefinitionsStart ? msoStyleDefinitionsStart : msoListDefinitionsStart;
 707 
 708         const auto msoListDefinitionsEnd = styleContent.find(&quot;;}\n&quot;, lastListItem);
 709         if (msoListDefinitionsEnd == notFound || start &gt;= msoListDefinitionsEnd)
 710             return false;
 711 
 712         appendString(&quot;&lt;head&gt;&lt;style class=\&quot;&quot; WebKitMSOListQuirksStyle &quot;\&quot;&gt;\n&lt;!--\n&quot;);
 713         appendStringView(StringView(textChild.data()).substring(start, msoListDefinitionsEnd - start + 3));
 714         appendString(&quot;\n--&gt;\n&lt;/style&gt;&lt;/head&gt;&quot;);
 715 
 716         return true;
 717     }
 718     return false;
 719 }
 720 
 721 static Node* ancestorToRetainStructureAndAppearanceForBlock(Node* commonAncestorBlock)
 722 {
 723     if (!commonAncestorBlock)
 724         return nullptr;
 725 
 726     if (commonAncestorBlock-&gt;hasTagName(tbodyTag) || commonAncestorBlock-&gt;hasTagName(trTag)) {
 727         ContainerNode* table = commonAncestorBlock-&gt;parentNode();
 728         while (table &amp;&amp; !is&lt;HTMLTableElement&gt;(*table))
 729             table = table-&gt;parentNode();
 730 
 731         return table;
 732     }
 733 
 734     if (isNonTableCellHTMLBlockElement(commonAncestorBlock))
 735         return commonAncestorBlock;
 736 
 737     return nullptr;
 738 }
 739 
 740 static inline Node* ancestorToRetainStructureAndAppearance(Node* commonAncestor)
 741 {
 742     return ancestorToRetainStructureAndAppearanceForBlock(enclosingBlock(commonAncestor));
 743 }
 744 
 745 static bool propertyMissingOrEqualToNone(StyleProperties* style, CSSPropertyID propertyID)
 746 {
 747     if (!style)
 748         return false;
 749     RefPtr&lt;CSSValue&gt; value = style-&gt;getPropertyCSSValue(propertyID);
 750     if (!value)
 751         return true;
 752     if (!is&lt;CSSPrimitiveValue&gt;(*value))
 753         return false;
 754     return downcast&lt;CSSPrimitiveValue&gt;(*value).valueID() == CSSValueNone;
 755 }
 756 
 757 static bool needInterchangeNewlineAfter(const VisiblePosition&amp; v)
 758 {
 759     VisiblePosition next = v.next();
 760     Node* upstreamNode = next.deepEquivalent().upstream().deprecatedNode();
 761     Node* downstreamNode = v.deepEquivalent().downstream().deprecatedNode();
 762     // Add an interchange newline if a paragraph break is selected and a br won&#39;t already be added to the markup to represent it.
 763     return isEndOfParagraph(v) &amp;&amp; isStartOfParagraph(next) &amp;&amp; !(upstreamNode-&gt;hasTagName(brTag) &amp;&amp; upstreamNode == downstreamNode);
 764 }
 765 
 766 static RefPtr&lt;EditingStyle&gt; styleFromMatchedRulesAndInlineDecl(Node&amp; node)
 767 {
 768     if (!is&lt;HTMLElement&gt;(node))
 769         return nullptr;
 770 
 771     auto&amp; element = downcast&lt;HTMLElement&gt;(node);
 772     auto style = EditingStyle::create(element.inlineStyle());
 773     style-&gt;mergeStyleFromRules(element);
 774     return style;
 775 }
 776 
 777 static bool isElementPresentational(const Node* node)
 778 {
 779     return node-&gt;hasTagName(uTag) || node-&gt;hasTagName(sTag) || node-&gt;hasTagName(strikeTag)
 780         || node-&gt;hasTagName(iTag) || node-&gt;hasTagName(emTag) || node-&gt;hasTagName(bTag) || node-&gt;hasTagName(strongTag);
 781 }
 782 
 783 static Node* highestAncestorToWrapMarkup(const Position&amp; start, const Position&amp; end, Node&amp; commonAncestor, AnnotateForInterchange annotate)
 784 {
 785     Node* specialCommonAncestor = nullptr;
 786     if (annotate == AnnotateForInterchange::Yes) {
 787         // Include ancestors that aren&#39;t completely inside the range but are required to retain
 788         // the structure and appearance of the copied markup.
 789         specialCommonAncestor = ancestorToRetainStructureAndAppearance(&amp;commonAncestor);
 790 
 791         if (auto* parentListNode = enclosingNodeOfType(start, isListItem)) {
 792             if (!editingIgnoresContent(*parentListNode) &amp;&amp; VisibleSelection::selectionFromContentsOfNode(parentListNode) == VisibleSelection(start, end)) {
 793                 specialCommonAncestor = parentListNode-&gt;parentNode();
 794                 while (specialCommonAncestor &amp;&amp; !isListHTMLElement(specialCommonAncestor))
 795                     specialCommonAncestor = specialCommonAncestor-&gt;parentNode();
 796             }
 797         }
 798 
 799         // Retain the Mail quote level by including all ancestor mail block quotes.
 800         if (Node* highestMailBlockquote = highestEnclosingNodeOfType(start, isMailBlockquote, CanCrossEditingBoundary))
 801             specialCommonAncestor = highestMailBlockquote;
 802     }
 803 
 804     auto* checkAncestor = specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor;
 805     if (checkAncestor-&gt;renderer() &amp;&amp; checkAncestor-&gt;renderer()-&gt;containingBlock()) {
 806         Node* newSpecialCommonAncestor = highestEnclosingNodeOfType(firstPositionInNode(checkAncestor), &amp;isElementPresentational, CanCrossEditingBoundary, checkAncestor-&gt;renderer()-&gt;containingBlock()-&gt;element());
 807         if (newSpecialCommonAncestor)
 808             specialCommonAncestor = newSpecialCommonAncestor;
 809     }
 810 
 811     // If a single tab is selected, commonAncestor will be a text node inside a tab span.
 812     // If two or more tabs are selected, commonAncestor will be the tab span.
 813     // In either case, if there is a specialCommonAncestor already, it will necessarily be above
 814     // any tab span that needs to be included.
 815     if (!specialCommonAncestor &amp;&amp; isTabSpanTextNode(&amp;commonAncestor))
 816         specialCommonAncestor = commonAncestor.parentNode();
 817     if (!specialCommonAncestor &amp;&amp; isTabSpanNode(&amp;commonAncestor))
 818         specialCommonAncestor = &amp;commonAncestor;
 819 
 820     if (auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor), aTag))
 821         specialCommonAncestor = enclosingAnchor;
 822 
 823     return specialCommonAncestor;
 824 }
 825 
 826 static String serializePreservingVisualAppearanceInternal(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<a name="11" id="anc11"></a><span class="line-modified"> 827     AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, StandardFontFamilySerializationMode standardFontFamilySerializationMode, MSOListMode msoListMode)</span>
 828 {
 829     static NeverDestroyed&lt;const String&gt; interchangeNewlineString(MAKE_STATIC_STRING_IMPL(&quot;&lt;br class=\&quot;&quot; AppleInterchangeNewline &quot;\&quot;&gt;&quot;));
 830 
 831     if (!comparePositions(start, end))
 832         return emptyString();
 833 
 834     RefPtr&lt;Node&gt; commonAncestor = commonShadowIncludingAncestor(start, end);
 835     if (!commonAncestor)
 836         return emptyString();
 837 
 838     auto&amp; document = *start.document();
 839     document.updateLayoutIgnorePendingStylesheets();
 840 
 841     VisiblePosition visibleStart { start };
 842     VisiblePosition visibleEnd { end };
 843 
 844     auto body = makeRefPtr(enclosingElementWithTag(firstPositionInNode(commonAncestor.get()), bodyTag));
 845     RefPtr&lt;Element&gt; fullySelectedRoot;
 846     // FIXME: Do this for all fully selected blocks, not just the body.
 847     if (body &amp;&amp; VisiblePosition(firstPositionInNode(body.get())) == visibleStart &amp;&amp; VisiblePosition(lastPositionInNode(body.get())) == visibleEnd)
 848         fullySelectedRoot = body;
 849     bool needsPositionStyleConversion = body &amp;&amp; fullySelectedRoot == body &amp;&amp; document.settings().shouldConvertPositionStyleOnCopy();
 850 
 851     Node* specialCommonAncestor = highestAncestorToWrapMarkup(start, end, *commonAncestor, annotate);
 852 
<a name="12" id="anc12"></a><span class="line-modified"> 853     StyledMarkupAccumulator accumulator(start, end, nodes, urlsToResolve, serializeComposedTree, annotate, standardFontFamilySerializationMode, msoListMode, needsPositionStyleConversion, specialCommonAncestor);</span>
 854 
 855     Position startAdjustedForInterchangeNewline = start;
 856     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleStart)) {
 857         if (visibleStart == visibleEnd.previous())
 858             return interchangeNewlineString;
 859 
 860         accumulator.appendString(interchangeNewlineString);
 861         startAdjustedForInterchangeNewline = visibleStart.next().deepEquivalent();
 862 
 863         if (comparePositions(startAdjustedForInterchangeNewline, end) &gt;= 0)
 864             return interchangeNewlineString;
 865     }
 866 
 867     Node* lastClosed = accumulator.serializeNodes(startAdjustedForInterchangeNewline, end);
 868 
 869     if (specialCommonAncestor &amp;&amp; lastClosed) {
 870         // Also include all of the ancestors of lastClosed up to this special ancestor.
 871         for (ContainerNode* ancestor = accumulator.parentNode(*lastClosed); ancestor; ancestor = accumulator.parentNode(*ancestor)) {
 872             if (ancestor == fullySelectedRoot &amp;&amp; convertBlocksToInlines == ConvertBlocksToInlines::No) {
 873                 RefPtr&lt;EditingStyle&gt; fullySelectedRootStyle = styleFromMatchedRulesAndInlineDecl(*fullySelectedRoot);
 874 
 875                 // Bring the background attribute over, but not as an attribute because a background attribute on a div
 876                 // appears to have no effect.
 877                 if ((!fullySelectedRootStyle || !fullySelectedRootStyle-&gt;style() || !fullySelectedRootStyle-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyBackgroundImage))
 878                     &amp;&amp; fullySelectedRoot-&gt;hasAttributeWithoutSynchronization(backgroundAttr))
 879                     fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyBackgroundImage, &quot;url(&#39;&quot; + fullySelectedRoot-&gt;getAttribute(backgroundAttr) + &quot;&#39;)&quot;);
 880 
 881                 if (fullySelectedRootStyle-&gt;style()) {
 882                     // Reset the CSS properties to avoid an assertion error in addStyleMarkup().
 883                     // This assertion is caused at least when we select all text of a &lt;body&gt; element whose
 884                     // &#39;text-decoration&#39; property is &quot;inherit&quot;, and copy it.
 885                     if (!propertyMissingOrEqualToNone(fullySelectedRootStyle-&gt;style(), CSSPropertyTextDecoration))
 886                         fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyTextDecoration, CSSValueNone);
 887                     if (!propertyMissingOrEqualToNone(fullySelectedRootStyle-&gt;style(), CSSPropertyWebkitTextDecorationsInEffect))
 888                         fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyWebkitTextDecorationsInEffect, CSSValueNone);
 889                     accumulator.wrapWithStyleNode(fullySelectedRootStyle-&gt;style(), document, true);
 890                 }
 891             } else {
 892                 // Since this node and all the other ancestors are not in the selection we want to set RangeFullySelectsNode to DoesNotFullySelectNode
 893                 // so that styles that affect the exterior of the node are not included.
 894                 accumulator.wrapWithNode(*ancestor, convertBlocksToInlines == ConvertBlocksToInlines::Yes, StyledMarkupAccumulator::DoesNotFullySelectNode);
 895             }
 896             if (nodes)
 897                 nodes-&gt;append(ancestor);
 898 
 899             if (ancestor == specialCommonAncestor)
 900                 break;
 901         }
 902     }
 903 
 904     if (accumulator.needRelativeStyleWrapper() &amp;&amp; needsPositionStyleConversion) {
 905         if (accumulator.needClearingDiv())
 906             accumulator.appendString(&quot;&lt;div style=\&quot;clear: both;\&quot;&gt;&lt;/div&gt;&quot;);
 907         RefPtr&lt;EditingStyle&gt; positionRelativeStyle = styleFromMatchedRulesAndInlineDecl(*body);
 908         positionRelativeStyle-&gt;style()-&gt;setProperty(CSSPropertyPosition, CSSValueRelative);
 909         accumulator.wrapWithStyleNode(positionRelativeStyle-&gt;style(), document, true);
 910     }
 911 
 912     // FIXME: The interchange newline should be placed in the block that it&#39;s in, not after all of the content, unconditionally.
 913     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleEnd.previous()))
 914         accumulator.appendString(interchangeNewlineString);
 915 
 916     return accumulator.takeResults();
 917 }
 918 
 919 String serializePreservingVisualAppearance(const Range&amp; range, Vector&lt;Node*&gt;* nodes, AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, ResolveURLs urlsToReslve)
 920 {
 921     return serializePreservingVisualAppearanceInternal(range.startPosition(), range.endPosition(), nodes, urlsToReslve, SerializeComposedTree::No,
<a name="13" id="anc13"></a><span class="line-modified"> 922         annotate, convertBlocksToInlines, StandardFontFamilySerializationMode::Keep, MSOListMode::DoNotPreserve);</span>
 923 }
 924 
 925 String serializePreservingVisualAppearance(const VisibleSelection&amp; selection, ResolveURLs resolveURLs, SerializeComposedTree serializeComposedTree, Vector&lt;Node*&gt;* nodes)
 926 {
 927     return serializePreservingVisualAppearanceInternal(selection.start(), selection.end(), nodes, resolveURLs, serializeComposedTree,
<a name="14" id="anc14"></a><span class="line-modified"> 928         AnnotateForInterchange::Yes, ConvertBlocksToInlines::No, StandardFontFamilySerializationMode::Keep, MSOListMode::DoNotPreserve);</span>
 929 }
 930 
 931 
 932 static bool shouldPreserveMSOLists(const String&amp; markup)
 933 {
 934     if (!markup.startsWith(&quot;&lt;html xmlns:&quot;))
 935         return false;
 936     auto tagClose = markup.find(&#39;&gt;&#39;);
 937     if (tagClose == notFound)
 938         return false;
 939     auto htmlTag = markup.substring(0, tagClose);
 940     return htmlTag.contains(&quot;xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;&quot;)
 941         &amp;&amp; htmlTag.contains(&quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;&quot;);
 942 }
 943 
 944 String sanitizedMarkupForFragmentInDocument(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, Document&amp; document, MSOListQuirks msoListQuirks, const String&amp; originalMarkup)
 945 {
 946     MSOListMode msoListMode = msoListQuirks == MSOListQuirks::CheckIfNeeded &amp;&amp; shouldPreserveMSOLists(originalMarkup)
 947         ? MSOListMode::Preserve : MSOListMode::DoNotPreserve;
 948 
 949     auto bodyElement = makeRefPtr(document.body());
 950     ASSERT(bodyElement);
 951     bodyElement-&gt;appendChild(fragment.get());
 952 
 953     // SerializeComposedTree::No because there can&#39;t be a shadow tree in the pasted fragment.
 954     auto result = serializePreservingVisualAppearanceInternal(firstPositionInNode(bodyElement.get()), lastPositionInNode(bodyElement.get()), nullptr,
<a name="15" id="anc15"></a><span class="line-modified"> 955         ResolveURLs::YesExcludingLocalFileURLsForPrivacy, SerializeComposedTree::No, AnnotateForInterchange::Yes, ConvertBlocksToInlines::No,  StandardFontFamilySerializationMode::Strip, msoListMode);</span>
 956 
 957     if (msoListMode == MSOListMode::Preserve) {
 958         StringBuilder builder;
 959         builder.appendLiteral(&quot;&lt;html xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;\n&quot;
 960             &quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;\n&quot;
 961             &quot;xmlns:m=\&quot;http://schemas.microsoft.com/office/2004/12/omml\&quot;\n&quot;
 962             &quot;xmlns=\&quot;http://www.w3.org/TR/REC-html40\&quot;&gt;&quot;);
 963         builder.append(result);
 964         builder.appendLiteral(&quot;&lt;/html&gt;&quot;);
 965         return builder.toString();
 966     }
 967 
 968     return result;
 969 }
 970 
 971 static void restoreAttachmentElementsInFragment(DocumentFragment&amp; fragment)
 972 {
 973 #if ENABLE(ATTACHMENT_ELEMENT)
 974     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 975         return;
 976 
 977     // When creating a fragment we must strip the webkit-attachment-path attribute after restoring the File object.
 978     Vector&lt;Ref&lt;HTMLAttachmentElement&gt;&gt; attachments;
 979     for (auto&amp; attachment : descendantsOfType&lt;HTMLAttachmentElement&gt;(fragment))
 980         attachments.append(attachment);
 981 
 982     for (auto&amp; attachment : attachments) {
 983         attachment-&gt;setUniqueIdentifier(attachment-&gt;attributeWithoutSynchronization(webkitattachmentidAttr));
 984 
 985         auto attachmentPath = attachment-&gt;attachmentPath();
 986         auto blobURL = attachment-&gt;blobURL();
 987         if (!attachmentPath.isEmpty())
<a name="16" id="anc16"></a><span class="line-modified"> 988             attachment-&gt;setFile(File::create(attachmentPath));</span>
 989         else if (!blobURL.isEmpty())
<a name="17" id="anc17"></a><span class="line-modified"> 990             attachment-&gt;setFile(File::deserialize({ }, blobURL, attachment-&gt;attachmentType(), attachment-&gt;attachmentTitle()));</span>
 991 
 992         // Remove temporary attributes that were previously added in StyledMarkupAccumulator::appendCustomAttributes.
 993         attachment-&gt;removeAttribute(webkitattachmentidAttr);
 994         attachment-&gt;removeAttribute(webkitattachmentpathAttr);
 995         attachment-&gt;removeAttribute(webkitattachmentbloburlAttr);
 996     }
 997 
 998     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;
 999     for (auto&amp; image : descendantsOfType&lt;HTMLImageElement&gt;(fragment))
1000         images.append(image);
1001 
1002     for (auto&amp; image : images) {
1003         auto attachmentIdentifier = image-&gt;attributeWithoutSynchronization(webkitattachmentidAttr);
1004         if (attachmentIdentifier.isEmpty())
1005             continue;
1006 
1007         auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, *fragment.ownerDocument());
1008         attachment-&gt;setUniqueIdentifier(attachmentIdentifier);
1009         image-&gt;setAttachmentElement(WTFMove(attachment));
1010         image-&gt;removeAttribute(webkitattachmentidAttr);
1011     }
1012 #else
1013     UNUSED_PARAM(fragment);
1014 #endif
1015 }
1016 
1017 Ref&lt;DocumentFragment&gt; createFragmentFromMarkup(Document&amp; document, const String&amp; markup, const String&amp; baseURL, ParserContentPolicy parserContentPolicy)
1018 {
1019     // We use a fake body element here to trick the HTML parser into using the InBody insertion mode.
1020     auto fakeBody = HTMLBodyElement::create(document);
1021     auto fragment = DocumentFragment::create(document);
1022 
1023     fragment-&gt;parseHTML(markup, fakeBody.ptr(), parserContentPolicy);
1024     restoreAttachmentElementsInFragment(fragment);
1025     if (!baseURL.isEmpty() &amp;&amp; baseURL != WTF::blankURL() &amp;&amp; baseURL != document.baseURL())
1026         completeURLs(fragment.ptr(), baseURL);
1027 
1028     return fragment;
1029 }
1030 
1031 String serializeFragment(const Node&amp; node, SerializedNodes root, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, Vector&lt;QualifiedName&gt;* tagNamesToSkip, SerializationSyntax serializationSyntax)
1032 {
1033     MarkupAccumulator accumulator(nodes, urlsToResolve, serializationSyntax);
1034     return accumulator.serializeNodes(const_cast&lt;Node&amp;&gt;(node), root, tagNamesToSkip);
1035 }
1036 
1037 static void fillContainerFromString(ContainerNode&amp; paragraph, const String&amp; string)
1038 {
1039     Document&amp; document = paragraph.document();
1040 
1041     if (string.isEmpty()) {
1042         paragraph.appendChild(createBlockPlaceholderElement(document));
1043         return;
1044     }
1045 
1046     ASSERT(string.find(&#39;\n&#39;) == notFound);
1047 
1048     Vector&lt;String&gt; tabList = string.splitAllowingEmptyEntries(&#39;\t&#39;);
1049     String tabText = emptyString();
1050     bool first = true;
1051     size_t numEntries = tabList.size();
1052     for (size_t i = 0; i &lt; numEntries; ++i) {
1053         const String&amp; s = tabList[i];
1054 
1055         // append the non-tab textual part
1056         if (!s.isEmpty()) {
1057             if (!tabText.isEmpty()) {
1058                 paragraph.appendChild(createTabSpanElement(document, tabText));
1059                 tabText = emptyString();
1060             }
1061             Ref&lt;Node&gt; textNode = document.createTextNode(stringWithRebalancedWhitespace(s, first, i + 1 == numEntries));
1062             paragraph.appendChild(textNode);
1063         }
1064 
1065         // there is a tab after every entry, except the last entry
1066         // (if the last character is a tab, the list gets an extra empty entry)
1067         if (i + 1 != numEntries)
1068             tabText.append(&#39;\t&#39;);
1069         else if (!tabText.isEmpty())
1070             paragraph.appendChild(createTabSpanElement(document, tabText));
1071 
1072         first = false;
1073     }
1074 }
1075 
1076 bool isPlainTextMarkup(Node* node)
1077 {
1078     ASSERT(node);
1079     if (!is&lt;HTMLDivElement&gt;(*node))
1080         return false;
1081 
1082     HTMLDivElement&amp; element = downcast&lt;HTMLDivElement&gt;(*node);
1083     if (element.hasAttributes())
1084         return false;
1085 
1086     Node* firstChild = element.firstChild();
1087     if (!firstChild)
1088         return false;
1089 
1090     Node* secondChild = firstChild-&gt;nextSibling();
1091     if (!secondChild)
1092         return firstChild-&gt;isTextNode() || firstChild-&gt;firstChild();
1093 
1094     if (secondChild-&gt;nextSibling())
1095         return false;
1096 
1097     return isTabSpanTextNode(firstChild-&gt;firstChild()) &amp;&amp; secondChild-&gt;isTextNode();
1098 }
1099 
1100 static bool contextPreservesNewline(const Range&amp; context)
1101 {
1102     VisiblePosition position(context.startPosition());
1103     Node* container = position.deepEquivalent().containerNode();
1104     if (!container || !container-&gt;renderer())
1105         return false;
1106 
1107     return container-&gt;renderer()-&gt;style().preserveNewline();
1108 }
1109 
1110 Ref&lt;DocumentFragment&gt; createFragmentFromText(Range&amp; context, const String&amp; text)
1111 {
1112     Document&amp; document = context.ownerDocument();
1113     Ref&lt;DocumentFragment&gt; fragment = document.createDocumentFragment();
1114 
1115     if (text.isEmpty())
1116         return fragment;
1117 
1118     String string = text;
1119     string.replace(&quot;\r\n&quot;, &quot;\n&quot;);
1120     string.replace(&#39;\r&#39;, &#39;\n&#39;);
1121 
1122     auto createHTMLBRElement = [&amp;document]() {
1123         auto element = HTMLBRElement::create(document);
1124         element-&gt;setAttributeWithoutSynchronization(classAttr, AppleInterchangeNewline);
1125         return element;
1126     };
1127 
1128     if (contextPreservesNewline(context)) {
1129         fragment-&gt;appendChild(document.createTextNode(string));
1130         if (string.endsWith(&#39;\n&#39;)) {
1131             fragment-&gt;appendChild(createHTMLBRElement());
1132         }
1133         return fragment;
1134     }
1135 
1136     // A string with no newlines gets added inline, rather than being put into a paragraph.
1137     if (string.find(&#39;\n&#39;) == notFound) {
1138         fillContainerFromString(fragment, string);
1139         return fragment;
1140     }
1141 
1142     if (string.length() == 1 &amp;&amp; string[0] == &#39;\n&#39;) {
1143         // This is a single newline char, thus just create one HTMLBRElement.
1144         fragment-&gt;appendChild(createHTMLBRElement());
1145         return fragment;
1146     }
1147 
1148     // Break string into paragraphs. Extra line breaks turn into empty paragraphs.
1149     Node* blockNode = enclosingBlock(context.firstNode());
1150     Element* block = downcast&lt;Element&gt;(blockNode);
1151     bool useClonesOfEnclosingBlock = blockNode
1152         &amp;&amp; blockNode-&gt;isElementNode()
1153         &amp;&amp; !block-&gt;hasTagName(bodyTag)
1154         &amp;&amp; !block-&gt;hasTagName(htmlTag)
1155         &amp;&amp; block != editableRootForPosition(context.startPosition());
1156     bool useLineBreak = enclosingTextFormControl(context.startPosition());
1157 
1158     Vector&lt;String&gt; list = string.splitAllowingEmptyEntries(&#39;\n&#39;);
1159     size_t numLines = list.size();
1160     for (size_t i = 0; i &lt; numLines; ++i) {
1161         const String&amp; s = list[i];
1162 
1163         RefPtr&lt;Element&gt; element;
1164         if (s.isEmpty() &amp;&amp; i + 1 == numLines) {
1165             // For last line, use the &quot;magic BR&quot; rather than a P.
1166             element = createHTMLBRElement();
1167         } else if (useLineBreak) {
1168             element = HTMLBRElement::create(document);
1169             fillContainerFromString(fragment, s);
1170         } else {
1171             if (useClonesOfEnclosingBlock)
1172                 element = block-&gt;cloneElementWithoutChildren(document);
1173             else
1174                 element = createDefaultParagraphElement(document);
1175             fillContainerFromString(*element, s);
1176         }
1177         fragment-&gt;appendChild(*element);
1178     }
1179     return fragment;
1180 }
1181 
1182 String documentTypeString(const Document&amp; document)
1183 {
1184     DocumentType* documentType = document.doctype();
1185     if (!documentType)
1186         return emptyString();
1187     return serializeFragment(*documentType, SerializedNodes::SubtreeIncludingNode);
1188 }
1189 
1190 String urlToMarkup(const URL&amp; url, const String&amp; title)
1191 {
1192     StringBuilder markup;
1193     markup.appendLiteral(&quot;&lt;a href=\&quot;&quot;);
1194     markup.append(url.string());
1195     markup.appendLiteral(&quot;\&quot;&gt;&quot;);
1196     MarkupAccumulator::appendCharactersReplacingEntities(markup, title, 0, title.length(), EntityMaskInPCDATA);
1197     markup.appendLiteral(&quot;&lt;/a&gt;&quot;);
1198     return markup.toString();
1199 }
1200 
1201 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; createFragmentForInnerOuterHTML(Element&amp; contextElement, const String&amp; markup, ParserContentPolicy parserContentPolicy)
1202 {
1203     auto* document = &amp;contextElement.document();
1204     if (contextElement.hasTagName(templateTag))
1205         document = &amp;document-&gt;ensureTemplateDocument();
1206     auto fragment = DocumentFragment::create(*document);
1207 
1208     if (document-&gt;isHTMLDocument()) {
1209         fragment-&gt;parseHTML(markup, &amp;contextElement, parserContentPolicy);
1210         return fragment;
1211     }
1212 
1213     bool wasValid = fragment-&gt;parseXML(markup, &amp;contextElement, parserContentPolicy);
1214     if (!wasValid)
1215         return Exception { SyntaxError };
1216     return fragment;
1217 }
1218 
1219 RefPtr&lt;DocumentFragment&gt; createFragmentForTransformToFragment(Document&amp; outputDoc, const String&amp; sourceString, const String&amp; sourceMIMEType)
1220 {
1221     RefPtr&lt;DocumentFragment&gt; fragment = outputDoc.createDocumentFragment();
1222 
1223     if (sourceMIMEType == &quot;text/html&quot;) {
1224         // As far as I can tell, there isn&#39;t a spec for how transformToFragment is supposed to work.
1225         // Based on the documentation I can find, it looks like we want to start parsing the fragment in the InBody insertion mode.
1226         // Unfortunately, that&#39;s an implementation detail of the parser.
1227         // We achieve that effect here by passing in a fake body element as context for the fragment.
1228         auto fakeBody = HTMLBodyElement::create(outputDoc);
1229         fragment-&gt;parseHTML(sourceString, fakeBody.ptr());
1230     } else if (sourceMIMEType == &quot;text/plain&quot;)
1231         fragment-&gt;parserAppendChild(Text::create(outputDoc, sourceString));
1232     else {
1233         bool successfulParse = fragment-&gt;parseXML(sourceString, 0);
1234         if (!successfulParse)
1235             return nullptr;
1236     }
1237 
1238     // FIXME: Do we need to mess with URLs here?
1239 
1240     return fragment;
1241 }
1242 
1243 Ref&lt;DocumentFragment&gt; createFragmentForImageAndURL(Document&amp; document, const String&amp; url, PresentationSize preferredSize)
1244 {
1245     auto imageElement = HTMLImageElement::create(document);
1246     imageElement-&gt;setAttributeWithoutSynchronization(HTMLNames::srcAttr, url);
1247     if (preferredSize.width)
1248         imageElement-&gt;setAttributeWithoutSynchronization(HTMLNames::widthAttr, AtomString::number(*preferredSize.width));
1249     if (preferredSize.height)
1250         imageElement-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(*preferredSize.height));
1251     auto fragment = document.createDocumentFragment();
1252     fragment-&gt;appendChild(imageElement);
1253 
1254     return fragment;
1255 }
1256 
1257 static Vector&lt;Ref&lt;HTMLElement&gt;&gt; collectElementsToRemoveFromFragment(ContainerNode&amp; container)
1258 {
1259     Vector&lt;Ref&lt;HTMLElement&gt;&gt; toRemove;
1260     for (auto&amp; element : childrenOfType&lt;HTMLElement&gt;(container)) {
1261         if (is&lt;HTMLHtmlElement&gt;(element)) {
1262             toRemove.append(element);
1263             collectElementsToRemoveFromFragment(element);
1264             continue;
1265         }
1266         if (is&lt;HTMLHeadElement&gt;(element) || is&lt;HTMLBodyElement&gt;(element))
1267             toRemove.append(element);
1268     }
1269     return toRemove;
1270 }
1271 
1272 static void removeElementFromFragmentPreservingChildren(DocumentFragment&amp; fragment, HTMLElement&amp; element)
1273 {
1274     RefPtr&lt;Node&gt; nextChild;
1275     for (RefPtr&lt;Node&gt; child = element.firstChild(); child; child = nextChild) {
1276         nextChild = child-&gt;nextSibling();
1277         element.removeChild(*child);
1278         fragment.insertBefore(*child, &amp;element);
1279     }
1280     fragment.removeChild(element);
1281 }
1282 
1283 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; createContextualFragment(Element&amp; element, const String&amp; markup, ParserContentPolicy parserContentPolicy)
1284 {
1285     auto result = createFragmentForInnerOuterHTML(element, markup, parserContentPolicy);
1286     if (result.hasException())
1287         return result.releaseException();
1288 
1289     auto fragment = result.releaseReturnValue();
1290 
1291     // We need to pop &lt;html&gt; and &lt;body&gt; elements and remove &lt;head&gt; to
1292     // accommodate folks passing complete HTML documents to make the
1293     // child of an element.
1294     auto toRemove = collectElementsToRemoveFromFragment(fragment);
1295     for (auto&amp; element : toRemove)
1296         removeElementFromFragmentPreservingChildren(fragment, element);
1297 
1298     return fragment;
1299 }
1300 
1301 static inline bool hasOneChild(ContainerNode&amp; node)
1302 {
1303     Node* firstChild = node.firstChild();
1304     return firstChild &amp;&amp; !firstChild-&gt;nextSibling();
1305 }
1306 
1307 static inline bool hasOneTextChild(ContainerNode&amp; node)
1308 {
1309     return hasOneChild(node) &amp;&amp; node.firstChild()-&gt;isTextNode();
1310 }
1311 
1312 static inline bool hasMutationEventListeners(const Document&amp; document)
1313 {
1314     return document.hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER)
1315         || document.hasListenerType(Document::DOMNODEINSERTED_LISTENER)
1316         || document.hasListenerType(Document::DOMNODEREMOVED_LISTENER)
1317         || document.hasListenerType(Document::DOMNODEREMOVEDFROMDOCUMENT_LISTENER)
1318         || document.hasListenerType(Document::DOMCHARACTERDATAMODIFIED_LISTENER);
1319 }
1320 
1321 // We can use setData instead of replacing Text node as long as script can&#39;t observe the difference.
1322 static inline bool canUseSetDataOptimization(const Text&amp; containerChild, const ChildListMutationScope&amp; mutationScope)
1323 {
1324     bool authorScriptMayHaveReference = containerChild.refCount();
1325     return !authorScriptMayHaveReference &amp;&amp; !mutationScope.canObserve() &amp;&amp; !hasMutationEventListeners(containerChild.document());
1326 }
1327 
1328 ExceptionOr&lt;void&gt; replaceChildrenWithFragment(ContainerNode&amp; container, Ref&lt;DocumentFragment&gt;&amp;&amp; fragment)
1329 {
1330     Ref&lt;ContainerNode&gt; containerNode(container);
1331     ChildListMutationScope mutation(containerNode);
1332 
1333     if (!fragment-&gt;firstChild()) {
1334         containerNode-&gt;removeChildren();
1335         return { };
1336     }
1337 
1338     auto* containerChild = containerNode-&gt;firstChild();
1339     if (containerChild &amp;&amp; !containerChild-&gt;nextSibling()) {
1340         if (is&lt;Text&gt;(*containerChild) &amp;&amp; hasOneTextChild(fragment) &amp;&amp; canUseSetDataOptimization(downcast&lt;Text&gt;(*containerChild), mutation)) {
1341             ASSERT(!fragment-&gt;firstChild()-&gt;refCount());
1342             downcast&lt;Text&gt;(*containerChild).setData(downcast&lt;Text&gt;(*fragment-&gt;firstChild()).data());
1343             return { };
1344         }
1345 
1346         return containerNode-&gt;replaceChild(fragment, *containerChild);
1347     }
1348 
1349     containerNode-&gt;removeChildren();
1350     return containerNode-&gt;appendChild(fragment);
1351 }
1352 
1353 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderScrollbar.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTable.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 416 {
 417     StackStats::LayoutCheckPoint layoutCheckPoint;
 418     ASSERT(needsLayout());
 419 
 420     if (simplifiedLayout())
 421         return;
 422 
 423     recalcSectionsIfNeeded();
 424     // FIXME: We should do this recalc lazily in borderStart/borderEnd so that we don&#39;t have to make sure
 425     // to call this before we call borderStart/borderEnd to avoid getting a stale value.
 426     recalcBordersInRowDirection();
 427     bool sectionMoved = false;
 428     LayoutUnit movedSectionLogicalTop;
 429 
 430     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 431     {
 432         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 433 
 434         LayoutUnit oldLogicalWidth = logicalWidth();
 435         LayoutUnit oldLogicalHeight = logicalHeight();
<span class="line-modified"> 436         setLogicalHeight(0);</span>
 437         updateLogicalWidth();
 438 
 439         if (logicalWidth() != oldLogicalWidth) {
 440             for (unsigned i = 0; i &lt; m_captions.size(); i++)
 441                 m_captions[i]-&gt;setNeedsLayout(MarkOnlyThis);
 442         }
 443         // FIXME: The optimisation below doesn&#39;t work since the internal table
 444         // layout could have changed. We need to add a flag to the table
 445         // layout that tells us if something has changed in the min max
 446         // calculations to do it correctly.
 447         //     if ( oldWidth != width() || columns.size() + 1 != columnPos.size() )
 448         m_tableLayout-&gt;layout();
 449 
 450         LayoutUnit totalSectionLogicalHeight;
 451         LayoutUnit oldTableLogicalTop;
 452         for (unsigned i = 0; i &lt; m_captions.size(); i++) {
 453             if (m_captions[i]-&gt;style().captionSide() == CaptionSide::Bottom)
 454                 continue;
 455             oldTableLogicalTop += m_captions[i]-&gt;logicalHeight() + m_captions[i]-&gt;marginBefore() + m_captions[i]-&gt;marginAfter();
 456         }
</pre>
<hr />
<pre>
 542 
 543         if (isOutOfFlowPositioned())
 544             updateLogicalHeight();
 545 
 546         // table can be containing block of positioned elements.
 547         bool dimensionChanged = oldLogicalWidth != logicalWidth() || oldLogicalHeight != logicalHeight();
 548         layoutPositionedObjects(dimensionChanged);
 549 
 550         updateLayerTransform();
 551 
 552         // Layout was changed, so probably borders too.
 553         invalidateCollapsedBorders();
 554 
 555         // The location or height of one or more sections may have changed.
 556         invalidateCachedColumnOffsets();
 557 
 558         computeOverflow(clientLogicalBottom());
 559     }
 560 
 561     auto* layoutState = view().frameView().layoutContext().layoutState();
<span class="line-modified"> 562     if (layoutState-&gt;pageLogicalHeight())</span>
 563         setPageLogicalOffset(layoutState-&gt;pageLogicalOffset(this, logicalTop()));
 564 
 565     bool didFullRepaint = repainter.repaintAfterLayout();
 566     // Repaint with our new bounds if they are different from our old bounds.
 567     if (!didFullRepaint &amp;&amp; sectionMoved) {
 568         if (style().isHorizontalWritingMode())
 569             repaintRectangle(LayoutRect(visualOverflowRect().x(), movedSectionLogicalTop, visualOverflowRect().width(), visualOverflowRect().maxY() - movedSectionLogicalTop));
 570         else
 571             repaintRectangle(LayoutRect(movedSectionLogicalTop, visualOverflowRect().y(), visualOverflowRect().maxX() - movedSectionLogicalTop, visualOverflowRect().height()));
 572     }
 573 
 574     bool paginated = layoutState &amp;&amp; layoutState-&gt;isPaginated();
 575     if (sectionMoved &amp;&amp; paginated) {
 576         // FIXME: Table layout should always stabilize even when section moves (see webkit.org/b/174412).
 577         if (!m_inRecursiveSectionMovedWithPagination) {
 578             SetForScope&lt;bool&gt; paginatedSectionMoved(m_inRecursiveSectionMovedWithPagination, true);
 579             markForPaginationRelayoutIfNeeded();
 580             layoutIfNeeded();
 581         } else
 582             ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
 753         } else {
 754             rect.setWidth(rect.width() - captionLogicalHeight);
 755             if (captionIsBefore)
 756                 rect.move(captionLogicalHeight, 0_lu);
 757         }
 758     }
 759 
 760     RenderBlock::adjustBorderBoxRectForPainting(rect);
 761 }
 762 
 763 void RenderTable::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 764 {
 765     if (!paintInfo.shouldPaintWithinRoot(*this))
 766         return;
 767 
 768     LayoutRect rect(paintOffset, size());
 769     adjustBorderBoxRectForPainting(rect);
 770 
 771     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
 772     if (!boxShadowShouldBeAppliedToBackground(rect.location(), bleedAvoidance))
<span class="line-modified"> 773         paintBoxShadow(paintInfo, rect, style(), Normal);</span>
 774     paintBackground(paintInfo, rect, bleedAvoidance);
<span class="line-modified"> 775     paintBoxShadow(paintInfo, rect, style(), Inset);</span>
 776 
 777     if (style().hasVisibleBorderDecoration() &amp;&amp; !collapseBorders())
 778         paintBorder(paintInfo, rect, style());
 779 }
 780 
 781 void RenderTable::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 782 {
 783     if (style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask)
 784         return;
 785 
 786     LayoutRect rect(paintOffset, size());
 787     adjustBorderBoxRectForPainting(rect);
 788 
 789     paintMaskImages(paintInfo, rect);
 790 }
 791 
 792 void RenderTable::computeIntrinsicLogicalWidths(LayoutUnit&amp; minWidth, LayoutUnit&amp; maxWidth) const
 793 {
 794     recalcSectionsIfNeeded();
 795     // FIXME: Do the recalc in borderStart/borderEnd and make those const_cast this call.
</pre>
<hr />
<pre>
1567 {
1568     ASSERT(cell.isFirstOrLastCellInRow());
1569     if (isDirectionSame(this, cell.row()))
1570         return style().borderStart();
1571 
1572     return style().borderEnd();
1573 }
1574 
1575 const BorderValue&amp; RenderTable::tableEndBorderAdjoiningCell(const RenderTableCell&amp; cell) const
1576 {
1577     ASSERT(cell.isFirstOrLastCellInRow());
1578     if (isDirectionSame(this, cell.row()))
1579         return style().borderEnd();
1580 
1581     return style().borderStart();
1582 }
1583 
1584 void RenderTable::markForPaginationRelayoutIfNeeded()
1585 {
1586     auto* layoutState = view().frameView().layoutContext().layoutState();
<span class="line-modified">1587     if (!layoutState-&gt;isPaginated() || (!layoutState-&gt;pageLogicalHeightChanged() &amp;&amp; (!layoutState-&gt;pageLogicalHeight() || layoutState-&gt;pageLogicalOffset(this, logicalTop()) == pageLogicalOffset())))</span>
1588         return;
1589 
1590     // When a table moves, we have to dirty all of the sections too.
1591     if (!needsLayout())
1592         setChildNeedsLayout(MarkOnlyThis);
1593     for (auto&amp; child : childrenOfType&lt;RenderTableSection&gt;(*this)) {
1594         if (!child.needsLayout())
1595             child.setChildNeedsLayout(MarkOnlyThis);
1596     }
1597 }
1598 
1599 }
</pre>
</td>
<td>
<hr />
<pre>
 416 {
 417     StackStats::LayoutCheckPoint layoutCheckPoint;
 418     ASSERT(needsLayout());
 419 
 420     if (simplifiedLayout())
 421         return;
 422 
 423     recalcSectionsIfNeeded();
 424     // FIXME: We should do this recalc lazily in borderStart/borderEnd so that we don&#39;t have to make sure
 425     // to call this before we call borderStart/borderEnd to avoid getting a stale value.
 426     recalcBordersInRowDirection();
 427     bool sectionMoved = false;
 428     LayoutUnit movedSectionLogicalTop;
 429 
 430     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 431     {
 432         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 433 
 434         LayoutUnit oldLogicalWidth = logicalWidth();
 435         LayoutUnit oldLogicalHeight = logicalHeight();
<span class="line-modified"> 436         resetLogicalHeightBeforeLayoutIfNeeded();</span>
 437         updateLogicalWidth();
 438 
 439         if (logicalWidth() != oldLogicalWidth) {
 440             for (unsigned i = 0; i &lt; m_captions.size(); i++)
 441                 m_captions[i]-&gt;setNeedsLayout(MarkOnlyThis);
 442         }
 443         // FIXME: The optimisation below doesn&#39;t work since the internal table
 444         // layout could have changed. We need to add a flag to the table
 445         // layout that tells us if something has changed in the min max
 446         // calculations to do it correctly.
 447         //     if ( oldWidth != width() || columns.size() + 1 != columnPos.size() )
 448         m_tableLayout-&gt;layout();
 449 
 450         LayoutUnit totalSectionLogicalHeight;
 451         LayoutUnit oldTableLogicalTop;
 452         for (unsigned i = 0; i &lt; m_captions.size(); i++) {
 453             if (m_captions[i]-&gt;style().captionSide() == CaptionSide::Bottom)
 454                 continue;
 455             oldTableLogicalTop += m_captions[i]-&gt;logicalHeight() + m_captions[i]-&gt;marginBefore() + m_captions[i]-&gt;marginAfter();
 456         }
</pre>
<hr />
<pre>
 542 
 543         if (isOutOfFlowPositioned())
 544             updateLogicalHeight();
 545 
 546         // table can be containing block of positioned elements.
 547         bool dimensionChanged = oldLogicalWidth != logicalWidth() || oldLogicalHeight != logicalHeight();
 548         layoutPositionedObjects(dimensionChanged);
 549 
 550         updateLayerTransform();
 551 
 552         // Layout was changed, so probably borders too.
 553         invalidateCollapsedBorders();
 554 
 555         // The location or height of one or more sections may have changed.
 556         invalidateCachedColumnOffsets();
 557 
 558         computeOverflow(clientLogicalBottom());
 559     }
 560 
 561     auto* layoutState = view().frameView().layoutContext().layoutState();
<span class="line-modified"> 562     if (layoutState &amp;&amp; layoutState-&gt;pageLogicalHeight())</span>
 563         setPageLogicalOffset(layoutState-&gt;pageLogicalOffset(this, logicalTop()));
 564 
 565     bool didFullRepaint = repainter.repaintAfterLayout();
 566     // Repaint with our new bounds if they are different from our old bounds.
 567     if (!didFullRepaint &amp;&amp; sectionMoved) {
 568         if (style().isHorizontalWritingMode())
 569             repaintRectangle(LayoutRect(visualOverflowRect().x(), movedSectionLogicalTop, visualOverflowRect().width(), visualOverflowRect().maxY() - movedSectionLogicalTop));
 570         else
 571             repaintRectangle(LayoutRect(movedSectionLogicalTop, visualOverflowRect().y(), visualOverflowRect().maxX() - movedSectionLogicalTop, visualOverflowRect().height()));
 572     }
 573 
 574     bool paginated = layoutState &amp;&amp; layoutState-&gt;isPaginated();
 575     if (sectionMoved &amp;&amp; paginated) {
 576         // FIXME: Table layout should always stabilize even when section moves (see webkit.org/b/174412).
 577         if (!m_inRecursiveSectionMovedWithPagination) {
 578             SetForScope&lt;bool&gt; paginatedSectionMoved(m_inRecursiveSectionMovedWithPagination, true);
 579             markForPaginationRelayoutIfNeeded();
 580             layoutIfNeeded();
 581         } else
 582             ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
 753         } else {
 754             rect.setWidth(rect.width() - captionLogicalHeight);
 755             if (captionIsBefore)
 756                 rect.move(captionLogicalHeight, 0_lu);
 757         }
 758     }
 759 
 760     RenderBlock::adjustBorderBoxRectForPainting(rect);
 761 }
 762 
 763 void RenderTable::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 764 {
 765     if (!paintInfo.shouldPaintWithinRoot(*this))
 766         return;
 767 
 768     LayoutRect rect(paintOffset, size());
 769     adjustBorderBoxRectForPainting(rect);
 770 
 771     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
 772     if (!boxShadowShouldBeAppliedToBackground(rect.location(), bleedAvoidance))
<span class="line-modified"> 773         paintBoxShadow(paintInfo, rect, style(), ShadowStyle::Normal);</span>
 774     paintBackground(paintInfo, rect, bleedAvoidance);
<span class="line-modified"> 775     paintBoxShadow(paintInfo, rect, style(), ShadowStyle::Inset);</span>
 776 
 777     if (style().hasVisibleBorderDecoration() &amp;&amp; !collapseBorders())
 778         paintBorder(paintInfo, rect, style());
 779 }
 780 
 781 void RenderTable::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 782 {
 783     if (style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask)
 784         return;
 785 
 786     LayoutRect rect(paintOffset, size());
 787     adjustBorderBoxRectForPainting(rect);
 788 
 789     paintMaskImages(paintInfo, rect);
 790 }
 791 
 792 void RenderTable::computeIntrinsicLogicalWidths(LayoutUnit&amp; minWidth, LayoutUnit&amp; maxWidth) const
 793 {
 794     recalcSectionsIfNeeded();
 795     // FIXME: Do the recalc in borderStart/borderEnd and make those const_cast this call.
</pre>
<hr />
<pre>
1567 {
1568     ASSERT(cell.isFirstOrLastCellInRow());
1569     if (isDirectionSame(this, cell.row()))
1570         return style().borderStart();
1571 
1572     return style().borderEnd();
1573 }
1574 
1575 const BorderValue&amp; RenderTable::tableEndBorderAdjoiningCell(const RenderTableCell&amp; cell) const
1576 {
1577     ASSERT(cell.isFirstOrLastCellInRow());
1578     if (isDirectionSame(this, cell.row()))
1579         return style().borderEnd();
1580 
1581     return style().borderStart();
1582 }
1583 
1584 void RenderTable::markForPaginationRelayoutIfNeeded()
1585 {
1586     auto* layoutState = view().frameView().layoutContext().layoutState();
<span class="line-modified">1587     if (!layoutState || !layoutState-&gt;isPaginated() || (!layoutState-&gt;pageLogicalHeightChanged() &amp;&amp; (!layoutState-&gt;pageLogicalHeight() || layoutState-&gt;pageLogicalOffset(this, logicalTop()) == pageLogicalOffset())))</span>
1588         return;
1589 
1590     // When a table moves, we have to dirty all of the sections too.
1591     if (!needsLayout())
1592         setChildNeedsLayout(MarkOnlyThis);
1593     for (auto&amp; child : childrenOfType&lt;RenderTableSection&gt;(*this)) {
1594         if (!child.needsLayout())
1595             child.setChildNeedsLayout(MarkOnlyThis);
1596     }
1597 }
1598 
1599 }
</pre>
</td>
</tr>
</table>
<center><a href="RenderScrollbar.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTable.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.cpp
@@ -26,11 +26,10 @@
  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include "config.h"
-
 #include "BasicShapes.h"
 
 #include "BasicShapeFunctions.h"
 #include "CalculationValue.h"
 #include "FloatRect.h"
@@ -38,13 +37,14 @@
 #include "LengthFunctions.h"
 #include "Path.h"
 #include "RenderBox.h"
 #include "SVGPathByteStream.h"
 #include "SVGPathUtilities.h"
-
+#include <wtf/MathExtras.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/TinyLRUCache.h>
+#include <wtf/text/TextStream.h>
 
 namespace WebCore {
 
 void BasicShapeCenterCoordinate::updateComputedLength()
 {
@@ -156,11 +156,11 @@
 }
 
 float BasicShapeCircle::floatValueForRadiusInBox(float boxWidth, float boxHeight) const
 {
     if (m_radius.type() == BasicShapeRadius::Value)
-        return floatValueForLength(m_radius.value(), sqrtf((boxWidth * boxWidth + boxHeight * boxHeight) / 2));
+        return floatValueForLength(m_radius.value(), std::hypot(boxWidth, boxHeight) / sqrtOfTwoFloat);
 
     float centerX = floatValueForCenterCoordinate(m_centerX, boxWidth);
     float centerY = floatValueForCenterCoordinate(m_centerY, boxHeight);
 
     float widthDelta = std::abs(boxWidth - centerX);
@@ -199,10 +199,17 @@
     result->setCenterY(m_centerY.blend(otherCircle.centerY(), progress));
     result->setRadius(m_radius.blend(otherCircle.radius(), progress));
     return result;
 }
 
+void BasicShapeCircle::dump(TextStream& ts) const
+{
+    ts.dumpProperty("center-x", centerX());
+    ts.dumpProperty("center-y", centerY());
+    ts.dumpProperty("radius", radius());
+}
+
 bool BasicShapeEllipse::operator==(const BasicShape& other) const
 {
     if (type() != other.type())
         return false;
 
@@ -265,10 +272,18 @@
     result->setRadiusX(m_radiusX.blend(otherEllipse.radiusX(), progress));
     result->setRadiusY(m_radiusY.blend(otherEllipse.radiusY(), progress));
     return result;
 }
 
+void BasicShapeEllipse::dump(TextStream& ts) const
+{
+    ts.dumpProperty("center-x", centerX());
+    ts.dumpProperty("center-y", centerY());
+    ts.dumpProperty("radius-x", radiusX());
+    ts.dumpProperty("radius-y", radiusY());
+}
+
 bool BasicShapePolygon::operator==(const BasicShape& other) const
 {
     if (type() != other.type())
         return false;
 
@@ -322,10 +337,16 @@
     }
 
     return result;
 }
 
+void BasicShapePolygon::dump(TextStream& ts) const
+{
+    ts.dumpProperty("wind-rule", windRule());
+    ts.dumpProperty("path", values());
+}
+
 BasicShapePath::BasicShapePath(std::unique_ptr<SVGPathByteStream>&& byteStream)
     : m_byteStream(WTFMove(byteStream))
 {
 }
 
@@ -364,10 +385,16 @@
     auto result = BasicShapePath::create(WTFMove(resultingPathBytes));
     result->setWindRule(windRule());
     return result;
 }
 
+void BasicShapePath::dump(TextStream& ts) const
+{
+    ts.dumpProperty("wind-rule", windRule());
+    // FIXME: print the byte stream?
+}
+
 bool BasicShapeInset::operator==(const BasicShape& other) const
 {
     if (type() != other.type())
         return false;
 
@@ -425,6 +452,50 @@
     result->setBottomRightRadius(WebCore::blend(fromInset.bottomRightRadius(), bottomRightRadius(), progress));
     result->setBottomLeftRadius(WebCore::blend(fromInset.bottomLeftRadius(), bottomLeftRadius(), progress));
 
     return result;
 }
+
+void BasicShapeInset::dump(TextStream& ts) const
+{
+    ts.dumpProperty("top", top());
+    ts.dumpProperty("right", right());
+    ts.dumpProperty("bottom", bottom());
+    ts.dumpProperty("left", left());
+
+    ts.dumpProperty("top-left-radius", topLeftRadius());
+    ts.dumpProperty("top-right-radius", topRightRadius());
+    ts.dumpProperty("bottom-right-radius", bottomRightRadius());
+    ts.dumpProperty("bottom-left-radius", bottomLeftRadius());
+}
+
+static TextStream& operator<<(TextStream& ts, BasicShapeRadius::Type radiusType)
+{
+    switch (radiusType) {
+    case BasicShapeRadius::Value: ts << "value"; break;
+    case BasicShapeRadius::ClosestSide: ts << "closest-side"; break;
+    case BasicShapeRadius::FarthestSide: ts << "farthest-side"; break;
+    }
+    return ts;
+}
+
+TextStream& operator<<(TextStream& ts, const BasicShapeRadius& radius)
+{
+    ts.dumpProperty("value", radius.value());
+    ts.dumpProperty("type", radius.type());
+    return ts;
 }
+
+TextStream& operator<<(TextStream& ts, const BasicShapeCenterCoordinate& coordinate)
+{
+    ts.dumpProperty("direction", coordinate.direction() == BasicShapeCenterCoordinate::TopLeft ? "top left" : "bottom right");
+    ts.dumpProperty("length", coordinate.length());
+    return ts;
+}
+
+TextStream& operator<<(TextStream& ts, const BasicShape& shape)
+{
+    shape.dump(ts);
+    return ts;
+}
+
+} // namespace WebCore

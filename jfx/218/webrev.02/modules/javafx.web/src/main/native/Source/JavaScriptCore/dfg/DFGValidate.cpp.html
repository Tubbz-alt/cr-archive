<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012-2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGValidate.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;CodeBlockWithJITType.h&quot;
  32 #include &quot;DFGClobberize.h&quot;
  33 #include &quot;DFGClobbersExitState.h&quot;
  34 #include &quot;DFGDominators.h&quot;
  35 #include &quot;DFGMayExit.h&quot;
  36 #include &quot;JSCInlines.h&quot;
  37 #include &lt;wtf/Assertions.h&gt;
  38 
  39 namespace JSC { namespace DFG {
  40 
  41 namespace {
  42 
  43 class Validate {
  44 public:
  45     Validate(Graph&amp; graph, GraphDumpMode graphDumpMode, CString graphDumpBeforePhase)
  46         : m_graph(graph)
  47         , m_graphDumpMode(graphDumpMode)
  48         , m_graphDumpBeforePhase(graphDumpBeforePhase)
  49     {
  50     }
  51 
  52     #define VALIDATE(context, assertion) do { \
  53         if (!(assertion)) { \
  54             startCrashing(); \
  55             dataLogF(&quot;\n\n\nAt &quot;); \
  56             reportValidationContext context; \
  57             dataLogF(&quot;: validation failed: %s (%s:%d).\n&quot;, #assertion, __FILE__, __LINE__); \
  58             dumpGraphIfAppropriate(); \
  59             WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
  60             CRASH(); \
  61         } \
  62     } while (0)
  63 
  64     #define V_EQUAL(context, left, right) do { \
  65         if (left != right) { \
  66             startCrashing(); \
  67             dataLogF(&quot;\n\n\nAt &quot;); \
  68             reportValidationContext context; \
  69             dataLogF(&quot;: validation failed: (%s = &quot;, #left); \
  70             dataLog(left); \
  71             dataLogF(&quot;) == (%s = &quot;, #right); \
  72             dataLog(right); \
  73             dataLogF(&quot;) (%s:%d).\n&quot;, __FILE__, __LINE__); \
  74             dumpGraphIfAppropriate(); \
  75             WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #left &quot; == &quot; #right); \
  76             CRASH(); \
  77         } \
  78     } while (0)
  79 
  80     #define notSet (static_cast&lt;size_t&gt;(-1))
  81 
  82     void validate()
  83     {
  84         // NB. This code is not written for performance, since it is not intended to run
  85         // in release builds.
  86 
  87         VALIDATE((m_graph.block(0)), m_graph.isRoot(m_graph.block(0)));
  88         VALIDATE((m_graph.block(0)), m_graph.block(0) == m_graph.m_roots[0]);
  89 
  90         for (BasicBlock* block : m_graph.m_roots)
  91             VALIDATE((block), block-&gt;predecessors.isEmpty());
  92 
  93         // Validate that all local variables at the head of all entrypoints are dead.
  94         for (BasicBlock* entrypoint : m_graph.m_roots) {
  95             for (unsigned i = 0; i &lt; entrypoint-&gt;variablesAtHead.numberOfLocals(); ++i)
  96                 V_EQUAL((virtualRegisterForLocal(i), entrypoint), static_cast&lt;Node*&gt;(nullptr), entrypoint-&gt;variablesAtHead.local(i));
  97         }
  98 
  99         // Validate ref counts and uses.
 100         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 101             BasicBlock* block = m_graph.block(blockIndex);
 102             if (!block)
 103                 continue;
 104             VALIDATE((block), block-&gt;isReachable);
 105             for (size_t i = 0; i &lt; block-&gt;numNodes(); ++i)
 106                 m_myRefCounts.add(block-&gt;node(i), 0);
 107         }
 108         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 109             BasicBlock* block = m_graph.block(blockIndex);
 110             if (!block)
 111                 continue;
 112             for (size_t i = 0; i &lt; block-&gt;numNodes(); ++i) {
 113                 Node* node = block-&gt;node(i);
 114                 m_acceptableNodes.add(node);
 115                 if (!node-&gt;shouldGenerate())
 116                     continue;
 117                 if (node-&gt;op() == Upsilon) {
 118                     VALIDATE((node), m_graph.m_form == SSA);
 119                     if (node-&gt;phi()-&gt;shouldGenerate())
 120                         m_myRefCounts.find(node)-&gt;value++;
 121                 }
 122                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 123                     // Phi children in LoadStore form are invalid.
 124                     if (m_graph.m_form == LoadStore &amp;&amp; block-&gt;isPhiIndex(i))
 125                         continue;
 126 
 127                     Edge edge = m_graph.child(node, j);
 128                     if (!edge)
 129                         continue;
 130 
 131                     m_myRefCounts.find(edge.node())-&gt;value++;
 132 
 133                     validateEdgeWithDoubleResultIfNecessary(node, edge);
 134                     VALIDATE((node, edge), edge-&gt;hasInt52Result() == (edge.useKind() == Int52RepUse));
 135 
 136                     if (m_graph.m_form == SSA) {
 137                         // In SSA, all edges must hasResult().
 138                         VALIDATE((node, edge), edge-&gt;hasResult());
 139                         continue;
 140                     }
 141 
 142                     // Unless I&#39;m a Flush, Phantom, GetLocal, or Phi, my children should hasResult().
 143                     switch (node-&gt;op()) {
 144                     case Flush:
 145                     case GetLocal:
 146                         VALIDATE((node, edge), edge-&gt;hasVariableAccessData(m_graph));
 147                         VALIDATE((node, edge), edge-&gt;variableAccessData() == node-&gt;variableAccessData());
 148                         break;
 149                     case PhantomLocal:
 150                         VALIDATE((node, edge), edge-&gt;hasVariableAccessData(m_graph));
 151                         VALIDATE((node, edge), edge-&gt;variableAccessData() == node-&gt;variableAccessData());
 152                         VALIDATE((node, edge), edge-&gt;op() != SetLocal);
 153                         break;
 154                     case Phi:
 155                         VALIDATE((node, edge), edge-&gt;hasVariableAccessData(m_graph));
 156                         if (m_graph.m_unificationState == LocallyUnified)
 157                             break;
 158                         VALIDATE((node, edge), edge-&gt;variableAccessData() == node-&gt;variableAccessData());
 159                         break;
 160                     default:
 161                         VALIDATE((node, edge), edge-&gt;hasResult());
 162                         break;
 163                     }
 164                 }
 165             }
 166         }
 167 
 168         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 169             BasicBlock* block = m_graph.block(blockIndex);
 170             if (!block)
 171                 continue;
 172             for (size_t i = 0; i &lt; block-&gt;numNodes(); ++i) {
 173                 Node* node = block-&gt;node(i);
 174                 if (m_graph.m_refCountState == ExactRefCount)
 175                     V_EQUAL((node), m_myRefCounts.get(node), node-&gt;adjustedRefCount());
 176             }
 177 
 178             bool foundTerminal = false;
 179             for (size_t i = 0 ; i &lt; block-&gt;size(); ++i) {
 180                 Node* node = block-&gt;at(i);
 181                 if (node-&gt;isTerminal()) {
 182                     foundTerminal = true;
 183                     for (size_t j = i + 1; j &lt; block-&gt;size(); ++j) {
 184                         node = block-&gt;at(j);
 185                         VALIDATE((node), node-&gt;op() == Phantom || node-&gt;op() == PhantomLocal || node-&gt;op() == Flush || node-&gt;op() == Check);
 186                         m_graph.doToChildren(
 187                             node,
 188                             [&amp;] (Edge edge) {
 189                                 VALIDATE((node, edge), shouldNotHaveTypeCheck(edge.useKind()));
 190                             });
 191                     }
 192                     break;
 193                 }
 194             }
 195             VALIDATE((block), foundTerminal);
 196 
 197             for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
 198                 Node* node = block-&gt;at(i);
 199 
 200                 VALIDATE((node), node-&gt;origin.isSet());
 201                 VALIDATE((node), node-&gt;origin.semantic.isSet() == node-&gt;origin.forExit.isSet());
 202                 VALIDATE((node), !(!node-&gt;origin.forExit.isSet() &amp;&amp; node-&gt;origin.exitOK));
 203                 VALIDATE((node), !(mayExit(m_graph, node) == Exits &amp;&amp; !node-&gt;origin.exitOK));
 204 
 205                 if (i) {
 206                     Node* previousNode = block-&gt;at(i - 1);
 207                     VALIDATE(
 208                         (node),
 209                         !clobbersExitState(m_graph, previousNode)
 210                         || !node-&gt;origin.exitOK
 211                         || node-&gt;op() == ExitOK
 212                         || node-&gt;origin.forExit != previousNode-&gt;origin.forExit);
 213                     VALIDATE(
 214                         (node),
 215                         !(!previousNode-&gt;origin.exitOK &amp;&amp; node-&gt;origin.exitOK)
 216                         || node-&gt;op() == ExitOK
 217                         || node-&gt;origin.forExit != previousNode-&gt;origin.forExit);
 218                 }
 219 
 220                 VALIDATE((node), !node-&gt;hasStructure() || !!node-&gt;structure().get());
 221                 VALIDATE((node), !node-&gt;hasCellOperand() || node-&gt;cellOperand()-&gt;value().isCell());
 222                 VALIDATE((node), !node-&gt;hasCellOperand() || !!node-&gt;cellOperand()-&gt;value());
 223 
 224                 if (!(node-&gt;flags() &amp; NodeHasVarArgs)) {
 225                     if (!node-&gt;child2())
 226                         VALIDATE((node), !node-&gt;child3());
 227                     if (!node-&gt;child1())
 228                         VALIDATE((node), !node-&gt;child2());
 229                 }
 230 
 231                 switch (node-&gt;op()) {
 232                 case Identity:
 233                 case IdentityWithProfile:
 234                     VALIDATE((node), canonicalResultRepresentation(node-&gt;result()) == canonicalResultRepresentation(node-&gt;child1()-&gt;result()));
 235                     break;
 236                 case SetLocal:
 237                 case PutStack:
 238                 case Upsilon:
 239                     VALIDATE((node), !!node-&gt;child1());
 240                     switch (node-&gt;child1().useKind()) {
 241                     case UntypedUse:
 242                     case CellUse:
 243                     case KnownCellUse:
 244                     case Int32Use:
 245                     case KnownInt32Use:
 246                     case Int52RepUse:
 247                     case DoubleRepUse:
 248                     case BooleanUse:
 249                     case KnownBooleanUse:
 250                         break;
 251                     default:
 252                         VALIDATE((node), !&quot;Bad use kind&quot;);
 253                         break;
 254                     }
 255                     break;
 256                 case MakeRope:
 257                 case ValueAdd:
 258                 case ValueSub:
 259                 case ValueMul:
 260                 case ValueDiv:
 261                 case ValueMod:
 262                 case ValuePow:
 263                 case ArithAdd:
 264                 case ArithSub:
 265                 case ArithMul:
 266                 case ArithIMul:
 267                 case ArithDiv:
 268                 case ArithMod:
 269                 case ArithMin:
 270                 case ArithMax:
 271                 case ArithPow:
 272                 case CompareLess:
 273                 case CompareLessEq:
 274                 case CompareGreater:
 275                 case CompareGreaterEq:
 276                 case CompareBelow:
 277                 case CompareBelowEq:
 278                 case CompareEq:
 279                 case CompareStrictEq:
 280                 case SameValue:
 281                 case StrCat:
 282                     VALIDATE((node), !!node-&gt;child1());
 283                     VALIDATE((node), !!node-&gt;child2());
 284                     break;
 285                 case CompareEqPtr:
 286                     VALIDATE((node), !!node-&gt;child1());
 287                     VALIDATE((node), !!node-&gt;cellOperand()-&gt;value() &amp;&amp; node-&gt;cellOperand()-&gt;value().isCell());
 288                     break;
 289                 case CheckArrayOrEmpty:
 290                     VALIDATE((node), is64Bit());
 291                     VALIDATE((node), !!node-&gt;child1());
 292                     VALIDATE((node), node-&gt;child1().useKind() == CellUse);
 293                     break;
 294                 case CheckStructureOrEmpty:
 295                     VALIDATE((node), is64Bit());
 296                     VALIDATE((node), !!node-&gt;child1());
 297                     VALIDATE((node), node-&gt;child1().useKind() == CellUse);
 298                     break;
 299                 case CheckStructure:
 300                 case StringFromCharCode:
 301                     VALIDATE((node), !!node-&gt;child1());
 302                     break;
 303                 case PutStructure:
 304                     VALIDATE((node), !node-&gt;transition()-&gt;previous-&gt;dfgShouldWatch());
 305                     break;
 306                 case MultiPutByOffset:
 307                     for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
 308                         const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
 309                         if (variant.kind() != PutByIdVariant::Transition)
 310                             continue;
 311                         VALIDATE((node), !variant.oldStructureForTransition()-&gt;dfgShouldWatch());
 312                     }
 313                     break;
 314                 case MaterializeNewObject:
 315                     for (RegisteredStructure structure : node-&gt;structureSet()) {
 316                         // This only supports structures that are JSFinalObject or JSArray.
 317                         VALIDATE(
 318                             (node),
 319                             structure-&gt;classInfo() == JSFinalObject::info()
 320                             || structure-&gt;classInfo() == JSArray::info());
 321 
 322                         // We only support certain indexing shapes.
 323                         VALIDATE((node), !hasAnyArrayStorage(structure-&gt;indexingType()));
 324                     }
 325                     break;
 326                 case DoubleConstant:
 327                 case Int52Constant:
 328                     VALIDATE((node), node-&gt;isNumberConstant());
 329                     break;
 330                 case GetByOffset:
 331                 case PutByOffset:
 332                     // FIXME: We should be able to validate that GetByOffset and PutByOffset are
 333                     // using the same object for storage and base. I think this means finally
 334                     // splitting these nodes into two node types, one for inline and one for
 335                     // out-of-line. The out-of-line one will require that the first node is storage,
 336                     // while the inline one will not take a storage child at all.
 337                     // https://bugs.webkit.org/show_bug.cgi?id=159602
 338                     break;
 339                 case HasOwnProperty: {
 340                     VALIDATE((node), !!m_graph.m_vm.hasOwnPropertyCache());
 341                     break;
 342                 }
 343                 case GetVectorLength: {
 344                     Array::Type type = node-&gt;arrayMode().type();
 345                     VALIDATE((node), type == Array::ArrayStorage || type == Array::SlowPutArrayStorage);
 346                     break;
 347                 }
 348                 case CPUIntrinsic: {
 349                     switch (node-&gt;intrinsic()) {
 350                     case CPUMfenceIntrinsic:
 351                     case CPURdtscIntrinsic:
 352                     case CPUCpuidIntrinsic:
 353                     case CPUPauseIntrinsic:
 354                         break;
 355                     default:
 356                         VALIDATE((node), false);
 357                         break;
 358                     }
 359                     break;
 360                 }
 361                 case GetArgumentCountIncludingThis: {
 362                     if (InlineCallFrame* inlineCallFrame = node-&gt;argumentsInlineCallFrame())
 363                         VALIDATE((node), inlineCallFrame-&gt;isVarargs());
 364                     break;
 365                 }
 366                 case NewArray:
 367                     VALIDATE((node), node-&gt;vectorLengthHint() &gt;= node-&gt;numChildren());
 368                     break;
 369                 case NewArrayBuffer:
 370                     VALIDATE((node), node-&gt;vectorLengthHint() &gt;= node-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length());
 371                     break;
 372                 default:
 373                     break;
 374                 }
 375             }
 376         }
 377 
 378         switch (m_graph.m_form) {
 379         case LoadStore:
 380         case ThreadedCPS:
 381             validateCPS();
 382             break;
 383 
 384         case SSA:
 385             validateSSA();
 386             break;
 387         }
 388 
 389         // Validate clobbered states.
 390         struct DefLambdaAdaptor {
 391             Function&lt;void(PureValue)&gt; pureValue;
 392             Function&lt;void(HeapLocation, LazyNode)&gt; locationAndNode;
 393 
 394             void operator()(PureValue value) const
 395             {
 396                 pureValue(value);
 397             }
 398 
 399             void operator()(HeapLocation location, LazyNode node) const
 400             {
 401                 locationAndNode(location, node);
 402             }
 403         };
 404         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 405             for (Node* node : *block) {
 406                 clobberize(m_graph, node,
 407                     [&amp;] (AbstractHeap) { },
 408                     [&amp;] (AbstractHeap heap)
 409                     {
 410                         // CSE assumes that HEAP TOP is never written.
 411                         // If this assumption is weakened, you need to update clobbering
 412                         // in CSE accordingly.
 413                         if (heap.kind() == Stack)
 414                             VALIDATE((node), !heap.payload().isTop());
 415                     },
 416                     DefLambdaAdaptor {
 417                         [&amp;] (PureValue) { },
 418                         [&amp;] (HeapLocation location, LazyNode)
 419                         {
 420                             VALIDATE((node), location.heap().kind() != SideState);
 421 
 422                             // More specific kinds should be used instead.
 423                             VALIDATE((node), location.heap().kind() != World);
 424                             VALIDATE((node), location.heap().kind() != Heap);
 425                         }
 426                 });
 427             }
 428         }
 429 
 430         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 431             // We expect the predecessor list to be de-duplicated.
 432             HashSet&lt;BasicBlock*&gt; predecessors;
 433             for (BasicBlock* predecessor : block-&gt;predecessors)
 434                 predecessors.add(predecessor);
 435             VALIDATE((block), predecessors.size() == block-&gt;predecessors.size());
 436         }
 437     }
 438 
 439 private:
 440     Graph&amp; m_graph;
 441     GraphDumpMode m_graphDumpMode;
 442     CString m_graphDumpBeforePhase;
 443 
 444     HashMap&lt;Node*, unsigned&gt; m_myRefCounts;
 445     HashSet&lt;Node*&gt; m_acceptableNodes;
 446 
 447     void validateCPS()
 448     {
 449         VALIDATE((), !m_graph.m_rootToArguments.isEmpty()); // We should have at least one root.
 450         VALIDATE((), m_graph.m_rootToArguments.size() == m_graph.m_roots.size());
 451         for (BasicBlock* root : m_graph.m_rootToArguments.keys())
 452             VALIDATE((), m_graph.m_roots.contains(root));
 453 
 454         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 455             BasicBlock* block = m_graph.block(blockIndex);
 456             if (!block)
 457                 continue;
 458 
 459             HashSet&lt;Node*&gt; phisInThisBlock;
 460             HashSet&lt;Node*&gt; nodesInThisBlock;
 461 
 462             for (size_t i = 0; i &lt; block-&gt;numNodes(); ++i) {
 463                 Node* node = block-&gt;node(i);
 464                 nodesInThisBlock.add(node);
 465                 if (block-&gt;isPhiIndex(i))
 466                     phisInThisBlock.add(node);
 467                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 468                     Edge edge = m_graph.child(node, j);
 469                     if (!edge)
 470                         continue;
 471                     VALIDATE((node, edge), m_acceptableNodes.contains(edge.node()));
 472                 }
 473             }
 474 
 475             {
 476                 HashSet&lt;Node*&gt; seenNodes;
 477                 for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
 478                     Node* node = block-&gt;at(i);
 479                     m_graph.doToChildren(node, [&amp;] (const Edge&amp; edge) {
 480                         Node* child = edge.node();
 481                         VALIDATE((node, edge), block-&gt;isInPhis(child) || seenNodes.contains(child));
 482                     });
 483                     seenNodes.add(node);
 484                 }
 485             }
 486 
 487             for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 488                 Node* node = block-&gt;phis[i];
 489                 ASSERT(phisInThisBlock.contains(node));
 490                 VALIDATE((node), node-&gt;op() == Phi);
 491                 Operand operand = node-&gt;operand();
 492                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 493                     // Phi children in LoadStore form are invalid.
 494                     if (m_graph.m_form == LoadStore &amp;&amp; block-&gt;isPhiIndex(i))
 495                         continue;
 496 
 497                     Edge edge = m_graph.child(node, j);
 498                     if (!edge)
 499                         continue;
 500 
 501                     VALIDATE(
 502                         (node, edge),
 503                         edge-&gt;op() == SetLocal
 504                         || edge-&gt;op() == SetArgumentDefinitely
 505                         || edge-&gt;op() == SetArgumentMaybe
 506                         || edge-&gt;op() == Phi);
 507 
 508                     if (phisInThisBlock.contains(edge.node()))
 509                         continue;
 510 
 511                     if (nodesInThisBlock.contains(edge.node())) {
 512                         VALIDATE(
 513                             (node, edge),
 514                             edge-&gt;op() == SetLocal
 515                             || edge-&gt;op() == SetArgumentDefinitely
 516                             || edge-&gt;op() == SetArgumentMaybe);
 517 
 518                         continue;
 519                     }
 520 
 521                     // There must exist a predecessor block that has this node index in
 522                     // its tail variables.
 523                     bool found = false;
 524                     for (unsigned k = 0; k &lt; block-&gt;predecessors.size(); ++k) {
 525                         BasicBlock* prevBlock = block-&gt;predecessors[k];
 526                         VALIDATE((block-&gt;predecessors[k]), prevBlock);
 527                         Node* prevNode = prevBlock-&gt;variablesAtTail.operand(operand);
 528                         // If we have a Phi that is not referring to *this* block then all predecessors
 529                         // must have that local available.
 530                         VALIDATE((operand, block, block-&gt;predecessors[k]), prevNode);
 531                         switch (prevNode-&gt;op()) {
 532                         case GetLocal:
 533                         case Flush:
 534                         case PhantomLocal:
 535                             prevNode = prevNode-&gt;child1().node();
 536                             break;
 537                         default:
 538                             break;
 539                         }
 540                         if (node-&gt;shouldGenerate()) {
 541                             VALIDATE((operand, block-&gt;predecessors[k], prevNode),
 542                                      prevNode-&gt;shouldGenerate());
 543                         }
 544                         VALIDATE(
 545                             (operand, block-&gt;predecessors[k], prevNode),
 546                             prevNode-&gt;op() == SetLocal
 547                             || prevNode-&gt;op() == SetArgumentDefinitely
 548                             || prevNode-&gt;op() == SetArgumentMaybe
 549                             || prevNode-&gt;op() == Phi);
 550                         if (prevNode == edge.node()) {
 551                             found = true;
 552                             break;
 553                         }
 554                         // At this point it cannot refer into this block.
 555                         VALIDATE((operand, block-&gt;predecessors[k], prevNode), !prevBlock-&gt;isInBlock(edge.node()));
 556                     }
 557 
 558                     VALIDATE((node, edge), found);
 559                 }
 560             }
 561 
 562             Operands&lt;size_t&gt; getLocalPositions(OperandsLike, block-&gt;variablesAtHead);
 563             Operands&lt;size_t&gt; setLocalPositions(OperandsLike, block-&gt;variablesAtHead);
 564 
 565             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
 566                 VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block-&gt;variablesAtHead.argument(i) || block-&gt;variablesAtHead.argument(i)-&gt;accessesStack(m_graph));
 567                 if (m_graph.m_form == ThreadedCPS)
 568                     VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block-&gt;variablesAtTail.argument(i) || block-&gt;variablesAtTail.argument(i)-&gt;accessesStack(m_graph));
 569 
 570                 getLocalPositions.argument(i) = notSet;
 571                 setLocalPositions.argument(i) = notSet;
 572             }
 573             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 574                 VALIDATE((virtualRegisterForLocal(i), block), !block-&gt;variablesAtHead.local(i) || block-&gt;variablesAtHead.local(i)-&gt;accessesStack(m_graph));
 575                 if (m_graph.m_form == ThreadedCPS)
 576                     VALIDATE((virtualRegisterForLocal(i), block), !block-&gt;variablesAtTail.local(i) || block-&gt;variablesAtTail.local(i)-&gt;accessesStack(m_graph));
 577 
 578                 getLocalPositions.local(i) = notSet;
 579                 setLocalPositions.local(i) = notSet;
 580             }
 581 
 582             for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
 583                 Node* node = block-&gt;at(i);
 584                 ASSERT(nodesInThisBlock.contains(node));
 585                 VALIDATE((node), node-&gt;op() != Phi);
 586                 VALIDATE((node), node-&gt;origin.forExit.isSet());
 587                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 588                     Edge edge = m_graph.child(node, j);
 589                     if (!edge)
 590                         continue;
 591                     VALIDATE((node, edge), nodesInThisBlock.contains(edge.node()));
 592                     switch (node-&gt;op()) {
 593                     case PhantomLocal:
 594                     case GetLocal:
 595                     case Flush:
 596                         break;
 597                     default:
 598                         VALIDATE((node, edge), !phisInThisBlock.contains(edge.node()));
 599                         break;
 600                     }
 601                 }
 602 
 603                 switch (node-&gt;op()) {
 604                 case Phi:
 605                 case Upsilon:
 606                 case CheckInBounds:
 607                 case PhantomNewObject:
 608                 case PhantomNewFunction:
 609                 case PhantomNewGeneratorFunction:
 610                 case PhantomNewAsyncFunction:
 611                 case PhantomNewAsyncGeneratorFunction:
 612                 case PhantomCreateActivation:
 613                 case PhantomNewRegexp:
 614                 case GetMyArgumentByVal:
 615                 case GetMyArgumentByValOutOfBounds:
 616                 case PutHint:
 617                 case CheckStructureImmediate:
 618                 case MaterializeCreateActivation:
 619                 case PutStack:
 620                 case KillStack:
 621                 case GetStack:
 622                 case EntrySwitch:
 623                 case InitializeEntrypointArguments:
 624                     VALIDATE((node), !&quot;unexpected node type in CPS&quot;);
 625                     break;
 626                 case MaterializeNewObject: {
 627                     // CPS only allows array lengths to be constant. This constraint only exists
 628                     // because we don&#39;t have DFG support for anything more and we don&#39;t need any
 629                     // other kind of support for now.
 630                     ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
 631                     for (unsigned i = data.m_properties.size(); i--;) {
 632                         PromotedLocationDescriptor descriptor = data.m_properties[i];
 633                         Edge edge = m_graph.varArgChild(node, 1 + i);
 634                         switch (descriptor.kind()) {
 635                         case PublicLengthPLoc:
 636                         case VectorLengthPLoc:
 637                             VALIDATE((node, edge), edge-&gt;isInt32Constant());
 638                             break;
 639                         default:
 640                             break;
 641                         }
 642                     }
 643 
 644                     // CPS only allows one structure.
 645                     VALIDATE((node), node-&gt;structureSet().size() == 1);
 646 
 647                     // CPS disallows int32 and double arrays. Those require weird type checks and
 648                     // conversions. They are not needed in the DFG right now. We should add support
 649                     // for these if the DFG ever needs it.
 650                     for (RegisteredStructure structure : node-&gt;structureSet()) {
 651                         VALIDATE((node), !hasInt32(structure-&gt;indexingType()));
 652                         VALIDATE((node), !hasDouble(structure-&gt;indexingType()));
 653                     }
 654                     break;
 655                 }
 656                 case Phantom:
 657                     VALIDATE((node), m_graph.m_fixpointState != FixpointNotConverged);
 658                     break;
 659                 default:
 660                     break;
 661                 }
 662 
 663                 if (!node-&gt;shouldGenerate())
 664                     continue;
 665                 switch (node-&gt;op()) {
 666                 case GetLocal:
 667                     // Ignore GetLocal&#39;s that we know to be dead, but that the graph
 668                     // doesn&#39;t yet know to be dead.
 669                     if (!m_myRefCounts.get(node))
 670                         break;
 671                     if (m_graph.m_form == ThreadedCPS) {
 672                         VALIDATE((node, block), getLocalPositions.operand(node-&gt;operand()) == notSet);
 673                         VALIDATE((node, block), !!node-&gt;child1());
 674                         VALIDATE((node, block), node-&gt;child1()-&gt;op() == SetArgumentDefinitely || node-&gt;child1()-&gt;op() == Phi);
 675                     }
 676                     getLocalPositions.operand(node-&gt;operand()) = i;
 677                     break;
 678                 case SetLocal:
 679                     // Only record the first SetLocal. There may be multiple SetLocals
 680                     // because of flushing.
 681                     if (setLocalPositions.operand(node-&gt;operand()) != notSet)
 682                         break;
 683                     setLocalPositions.operand(node-&gt;operand()) = i;
 684                     break;
 685                 case SetArgumentDefinitely:
 686                     // This acts like a reset. It&#39;s ok to have a second GetLocal for a local in the same
 687                     // block if we had a SetArgumentDefinitely for that local.
 688                     getLocalPositions.operand(node-&gt;operand()) = notSet;
 689                     setLocalPositions.operand(node-&gt;operand()) = notSet;
 690                     break;
 691                 case SetArgumentMaybe:
 692                     break;
 693                 case Flush:
 694                 case PhantomLocal:
 695                     if (m_graph.m_form == ThreadedCPS) {
 696                         VALIDATE((node, block),
 697                             node-&gt;child1()-&gt;op() == Phi
 698                             || node-&gt;child1()-&gt;op() == SetLocal
 699                             || node-&gt;child1()-&gt;op() == SetArgumentDefinitely
 700                             || node-&gt;child1()-&gt;op() == SetArgumentMaybe);
 701                         if (node-&gt;op() == PhantomLocal)
 702                             VALIDATE((node, block), node-&gt;child1()-&gt;op() != SetArgumentMaybe);
 703                     }
 704                     break;
 705                 default:
 706                     break;
 707                 }
 708             }
 709 
 710             if (m_graph.m_form == LoadStore)
 711                 continue;
 712 
 713             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
 714                 checkOperand(
 715                     block, getLocalPositions, setLocalPositions, virtualRegisterForArgumentIncludingThis(i));
 716             }
 717             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 718                 checkOperand(
 719                     block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
 720             }
 721         }
 722 
 723         if (m_graph.m_form == ThreadedCPS) {
 724             Vector&lt;Node*&gt; worklist;
 725             HashSet&lt;Node*&gt; seen;
 726             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 727                 for (Node* node : *block) {
 728                     if (node-&gt;op() == GetLocal || node-&gt;op() == PhantomLocal) {
 729                         worklist.append(node);
 730                         auto addResult = seen.add(node);
 731                         VALIDATE((node, block), addResult.isNewEntry);
 732                     }
 733                 }
 734             }
 735 
 736             while (worklist.size()) {
 737                 Node* node = worklist.takeLast();
 738                 switch (node-&gt;op()) {
 739                 case PhantomLocal:
 740                 case GetLocal: {
 741                     Node* child = node-&gt;child1().node();
 742                     if (seen.add(child).isNewEntry)
 743                         worklist.append(child);
 744                     break;
 745                 }
 746                 case Phi: {
 747                     for (unsigned i = 0; i &lt; m_graph.numChildren(node); ++i) {
 748                         Edge edge = m_graph.child(node, i);
 749                         if (!edge)
 750                             continue;
 751                         if (seen.add(edge.node()).isNewEntry)
 752                             worklist.append(edge.node());
 753                     }
 754                     break;
 755                 }
 756                 case SetLocal:
 757                 case SetArgumentDefinitely:
 758                     break;
 759                 case SetArgumentMaybe:
 760                     VALIDATE((node), !&quot;Should not reach SetArgumentMaybe. GetLocal that has data flow that reaches a SetArgumentMaybe is invalid IR.&quot;);
 761                     break;
 762                 default:
 763                     VALIDATE((node), !&quot;Unexpected node type.&quot;);
 764                     break;
 765                 }
 766             }
 767         }
 768     }
 769 
 770     void validateSSA()
 771     {
 772         // FIXME: Add more things here.
 773         // https://bugs.webkit.org/show_bug.cgi?id=123471
 774 
 775         VALIDATE((), m_graph.m_roots.size() == 1);
 776         VALIDATE((), m_graph.m_roots[0] == m_graph.block(0));
 777         VALIDATE((), !m_graph.m_argumentFormats.isEmpty()); // We always have at least one entrypoint.
 778         VALIDATE((), m_graph.m_rootToArguments.isEmpty()); // This is only used in CPS.
 779 
 780         m_graph.initializeNodeOwners();
 781 
 782         auto&amp; dominators = m_graph.ensureSSADominators();
 783 
 784         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeIndex.keys())
 785             VALIDATE((), entrypointIndex &gt; 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 786 
 787         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 788             BasicBlock* block = m_graph.block(blockIndex);
 789             if (!block)
 790                 continue;
 791 
 792             VALIDATE((block), block-&gt;phis.isEmpty());
 793 
 794             bool didSeeExitOK = false;
 795             bool isOSRExited = false;
 796 
 797             HashSet&lt;Node*&gt; nodesInThisBlock;
 798 
 799             for (auto* node : *block) {
 800                 didSeeExitOK |= node-&gt;origin.exitOK;
 801                 switch (node-&gt;op()) {
 802                 case Phi:
 803                     // Phi cannot exit, and it would be wrong to hoist anything to the Phi that could
 804                     // exit.
 805                     VALIDATE((node), !node-&gt;origin.exitOK);
 806 
 807                     // It never makes sense to have exitOK anywhere in the block before a Phi. It&#39;s only
 808                     // OK to exit after all Phis are done.
 809                     VALIDATE((node), !didSeeExitOK);
 810                     break;
 811 
 812                 case GetLocal:
 813                 case SetLocal:
 814                 case SetArgumentDefinitely:
 815                 case SetArgumentMaybe:
 816                 case Phantom:
 817                     VALIDATE((node), !&quot;bad node type for SSA&quot;);
 818                     break;
 819 
 820                 default:
 821                     // FIXME: Add more things here.
 822                     // https://bugs.webkit.org/show_bug.cgi?id=123471
 823                     break;
 824                 }
 825 
 826                 if (isOSRExited)
 827                     continue;
 828                 switch (node-&gt;op()) {
 829                 case PhantomNewObject:
 830                 case PhantomNewFunction:
 831                 case PhantomNewGeneratorFunction:
 832                 case PhantomNewAsyncFunction:
 833                 case PhantomNewAsyncGeneratorFunction:
 834                 case PhantomCreateActivation:
 835                 case PhantomDirectArguments:
 836                 case PhantomCreateRest:
 837                 case PhantomClonedArguments:
 838                 case PhantomNewRegexp:
 839                 case MovHint:
 840                 case Upsilon:
 841                 case ForwardVarargs:
 842                 case CallForwardVarargs:
 843                 case TailCallForwardVarargs:
 844                 case TailCallForwardVarargsInlinedCaller:
 845                 case ConstructForwardVarargs:
 846                 case GetMyArgumentByVal:
 847                 case GetMyArgumentByValOutOfBounds:
 848                     break;
 849 
 850                 case Check:
 851                 case CheckVarargs:
 852                     // FIXME: This is probably not correct.
 853                     break;
 854 
 855                 case PutHint:
 856                     VALIDATE((node), node-&gt;child1()-&gt;isPhantomAllocation());
 857                     break;
 858 
 859                 case PhantomSpread:
 860                     VALIDATE((node), m_graph.m_form == SSA);
 861                     // We currently support PhantomSpread over PhantomCreateRest and PhantomNewArrayBuffer.
 862                     VALIDATE((node), node-&gt;child1()-&gt;op() == PhantomCreateRest || node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer);
 863                     break;
 864 
 865                 case PhantomNewArrayWithSpread: {
 866                     VALIDATE((node), m_graph.m_form == SSA);
 867                     BitVector* bitVector = node-&gt;bitVector();
 868                     for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
 869                         Node* child = m_graph.varArgChild(node, i).node();
 870                         if (bitVector-&gt;get(i)) {
 871                             // We currently support PhantomSpread over PhantomCreateRest and PhantomNewArrayBuffer.
 872                             VALIDATE((node), child-&gt;op() == PhantomSpread);
 873                         } else
 874                             VALIDATE((node), !child-&gt;isPhantomAllocation());
 875                     }
 876                     break;
 877                 }
 878 
 879                 case PhantomNewArrayBuffer:
 880                     VALIDATE((node), m_graph.m_form == SSA);
 881                     VALIDATE((node), node-&gt;vectorLengthHint() &gt;= node-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length());
 882                     break;
 883 
 884                 case NewArrayWithSpread: {
 885                     BitVector* bitVector = node-&gt;bitVector();
 886                     for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
 887                         Node* child = m_graph.varArgChild(node, i).node();
 888                         if (child-&gt;isPhantomAllocation()) {
 889                             VALIDATE((node), bitVector-&gt;get(i));
 890                             VALIDATE((node), m_graph.m_form == SSA);
 891                             VALIDATE((node), child-&gt;op() == PhantomSpread);
 892                         }
 893                     }
 894                     break;
 895                 }
 896 
 897                 case Spread:
 898                     VALIDATE((node), !node-&gt;child1()-&gt;isPhantomAllocation() || node-&gt;child1()-&gt;op() == PhantomCreateRest || node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer);
 899                     break;
 900 
 901                 case EntrySwitch:
 902                     VALIDATE((node), node-&gt;entrySwitchData()-&gt;cases.size() == m_graph.m_numberOfEntrypoints);
 903                     break;
 904 
 905                 case InitializeEntrypointArguments:
 906                     VALIDATE((node), node-&gt;entrypointIndex() &lt; m_graph.m_numberOfEntrypoints);
 907                     break;
 908 
 909                 default:
 910                     m_graph.doToChildren(
 911                         node,
 912                         [&amp;] (const Edge&amp; edge) {
 913                             VALIDATE((node), !edge-&gt;isPhantomAllocation());
 914                         });
 915                     break;
 916                 }
 917 
 918                 isOSRExited |= node-&gt;isPseudoTerminal();
 919 
 920                 m_graph.doToChildren(node, [&amp;] (Edge child) {
 921                     VALIDATE((node), dominators.strictlyDominates(child-&gt;owner, block) || nodesInThisBlock.contains(child.node()));
 922                 });
 923                 nodesInThisBlock.add(node);
 924             }
 925         }
 926     }
 927 
 928     void validateEdgeWithDoubleResultIfNecessary(Node* node, Edge edge)
 929     {
 930         if (!edge-&gt;hasDoubleResult())
 931             return;
 932 
 933         if (m_graph.m_planStage &lt; PlanStage::AfterFixup)
 934             return;
 935 
 936         VALIDATE((node, edge), edge.useKind() == DoubleRepUse || edge.useKind() == DoubleRepRealUse || edge.useKind() == DoubleRepAnyIntUse);
 937     }
 938 
 939     void checkOperand(
 940         BasicBlock* block, Operands&lt;size_t&gt;&amp; getLocalPositions,
 941         Operands&lt;size_t&gt;&amp; setLocalPositions, VirtualRegister operand)
 942     {
 943         if (getLocalPositions.operand(operand) == notSet)
 944             return;
 945         if (setLocalPositions.operand(operand) == notSet)
 946             return;
 947 
 948         VALIDATE(
 949             (block-&gt;at(getLocalPositions.operand(operand)),
 950              block-&gt;at(setLocalPositions.operand(operand)),
 951              block),
 952             getLocalPositions.operand(operand) &lt; setLocalPositions.operand(operand));
 953     }
 954 
 955     void reportValidationContext() { }
 956 
 957     void reportValidationContext(Node* node)
 958     {
 959         dataLogF(&quot;@%u&quot;, node-&gt;index());
 960     }
 961 
 962     void reportValidationContext(BasicBlock* block)
 963     {
 964         dataLog(&quot;Block &quot;, *block);
 965     }
 966 
 967     void reportValidationContext(Node* node, Edge edge)
 968     {
 969         dataLog(node, &quot; -&gt; &quot;, edge);
 970     }
 971 
 972     void reportValidationContext(Operand operand, BasicBlock* block)
 973     {
 974         if (!block) {
 975             dataLog(operand, &quot; in null Block &quot;);
 976             return;
 977         }
 978 
 979         dataLog(operand, &quot; in Block &quot;, *block);
 980     }
 981 
 982     void reportValidationContext(
 983         Operand operand, BasicBlock* sourceBlock, BasicBlock* destinationBlock)
 984     {
 985         dataLog(operand, &quot; in Block &quot;, *sourceBlock, &quot; -&gt; &quot;, *destinationBlock);
 986     }
 987 
 988     void reportValidationContext(
 989         Operand operand, BasicBlock* sourceBlock, Node* prevNode)
 990     {
 991         dataLog(prevNode, &quot; for &quot;, operand, &quot; in Block &quot;, *sourceBlock);
 992     }
 993 
 994     void reportValidationContext(Node* node, BasicBlock* block)
 995     {
 996         dataLog(node, &quot; in Block &quot;, *block);
 997     }
 998 
 999     void reportValidationContext(Node* node, Node* node2, BasicBlock* block)
1000     {
1001         dataLog(node, &quot; and &quot;, node2, &quot; in Block &quot;, *block);
1002     }
1003 
1004     void reportValidationContext(
1005         Node* node, BasicBlock* block, Node* expectedNode, Edge incomingEdge)
1006     {
1007         dataLog(node, &quot; in Block &quot;, *block, &quot;, searching for &quot;, expectedNode, &quot; from &quot;, incomingEdge);
1008     }
1009 
1010     void dumpGraphIfAppropriate()
1011     {
1012         if (m_graphDumpMode == DontDumpGraph)
1013             return;
1014         dataLog(&quot;\n&quot;);
1015         if (!m_graphDumpBeforePhase.isNull()) {
1016             dataLog(&quot;Before phase:\n&quot;);
1017             dataLog(m_graphDumpBeforePhase);
1018         }
1019         dataLog(&quot;At time of failure:\n&quot;);
1020         m_graph.dump();
1021     }
1022 };
1023 
1024 } // End anonymous namespace.
1025 
1026 void validate(Graph&amp; graph, GraphDumpMode graphDumpMode, CString graphDumpBeforePhase)
1027 {
1028     Validate validationObject(graph, graphDumpMode, graphDumpBeforePhase);
1029     validationObject.validate();
1030 }
1031 
1032 } } // namespace JSC::DFG
1033 
1034 #endif // ENABLE(DFG_JIT)
1035 
    </pre>
  </body>
</html>
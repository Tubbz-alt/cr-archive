<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008, 2010 Nokia Corporation and/or its subsidiary(-ies)
  4  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
  5  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
  6  * Copyright (C) 2008 Dirk Schulze &lt;krit@webkit.org&gt;
  7  * Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
  8  * Copyright (C) 2012 Intel Corporation. All rights reserved.
  9  * Copyright (C) 2013, 2014 Adobe Systems Incorporated. All rights reserved.
 10  *
 11  * Redistribution and use in source and binary forms, with or without
 12  * modification, are permitted provided that the following conditions
 13  * are met:
 14  * 1. Redistributions of source code must retain the above copyright
 15  *    notice, this list of conditions and the following disclaimer.
 16  * 2. Redistributions in binary form must reproduce the above copyright
 17  *    notice, this list of conditions and the following disclaimer in the
 18  *    documentation and/or other materials provided with the distribution.
 19  *
 20  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 21  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 22  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 23  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 24  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 25  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 26  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 27  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 28  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;CanvasRenderingContext2D.h&quot;
 35 
 36 #include &quot;CSSFontSelector.h&quot;
 37 #include &quot;CSSParser.h&quot;
 38 #include &quot;CSSPropertyNames.h&quot;
 39 #include &quot;ImageBuffer.h&quot;
 40 #include &quot;ImageData.h&quot;
 41 #include &quot;InspectorInstrumentation.h&quot;
 42 #include &quot;Path2D.h&quot;
 43 #include &quot;RenderTheme.h&quot;
 44 #include &quot;ResourceLoadObserver.h&quot;
 45 #include &quot;RuntimeEnabledFeatures.h&quot;
 46 #include &quot;StyleBuilder.h&quot;
 47 #include &quot;StyleProperties.h&quot;
 48 #include &quot;TextMetrics.h&quot;
 49 #include &quot;TextRun.h&quot;
 50 #include &lt;wtf/CheckedArithmetic.h&gt;
 51 #include &lt;wtf/IsoMallocInlines.h&gt;
 52 #include &lt;wtf/MathExtras.h&gt;
 53 #include &lt;wtf/text/StringBuilder.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 using namespace HTMLNames;
 58 
 59 WTF_MAKE_ISO_ALLOCATED_IMPL(CanvasRenderingContext2D);
 60 
 61 std::unique_ptr&lt;CanvasRenderingContext2D&gt; CanvasRenderingContext2D::create(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode)
 62 {
 63     auto renderingContext = std::unique_ptr&lt;CanvasRenderingContext2D&gt;(new CanvasRenderingContext2D(canvas, usesCSSCompatibilityParseMode));
 64 
 65     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 66 
 67     return renderingContext;
 68 }
 69 
 70 CanvasRenderingContext2D::CanvasRenderingContext2D(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode)
 71     : CanvasRenderingContext2DBase(canvas, usesCSSCompatibilityParseMode)
 72 {
 73 }
 74 
 75 CanvasRenderingContext2D::~CanvasRenderingContext2D() = default;
 76 
 77 void CanvasRenderingContext2D::drawFocusIfNeeded(Element&amp; element)
 78 {
 79     drawFocusIfNeededInternal(m_path, element);
 80 }
 81 
 82 void CanvasRenderingContext2D::drawFocusIfNeeded(Path2D&amp; path, Element&amp; element)
 83 {
 84     drawFocusIfNeededInternal(path.path(), element);
 85 }
 86 
 87 void CanvasRenderingContext2D::drawFocusIfNeededInternal(const Path&amp; path, Element&amp; element)
 88 {
 89     auto* context = drawingContext();
 90     if (!element.focused() || !state().hasInvertibleTransform || path.isEmpty() || !element.isDescendantOf(canvas()) || !context)
 91         return;
 92     context-&gt;drawFocusRing(path, 1, 1, RenderTheme::singleton().focusRingColor(element.document().styleColorOptions(canvas().computedStyle())));
 93 }
 94 
 95 String CanvasRenderingContext2D::font() const
 96 {
 97     if (!state().font.realized())
 98         return DefaultFont;
 99 
100     StringBuilder serializedFont;
101     const auto&amp; fontDescription = state().font.fontDescription();
102 
103     if (fontDescription.italic())
104         serializedFont.appendLiteral(&quot;italic &quot;);
105     if (fontDescription.variantCaps() == FontVariantCaps::Small)
106         serializedFont.appendLiteral(&quot;small-caps &quot;);
107 
108     serializedFont.appendNumber(fontDescription.computedPixelSize());
109     serializedFont.appendLiteral(&quot;px&quot;);
110 
111     for (unsigned i = 0; i &lt; fontDescription.familyCount(); ++i) {
112         if (i)
113             serializedFont.append(&#39;,&#39;);
114 
115         // FIXME: We should append family directly to serializedFont rather than building a temporary string.
116         String family = fontDescription.familyAt(i);
117         if (family.startsWith(&quot;-webkit-&quot;))
118             family = family.substring(8);
119         if (family.contains(&#39; &#39;))
120             family = makeString(&#39;&quot;&#39;, family, &#39;&quot;&#39;);
121 
122         serializedFont.append(&#39; &#39;, family);
123     }
124 
125     return serializedFont.toString();
126 }
127 
128 void CanvasRenderingContext2D::setFont(const String&amp; newFont)
129 {
130     if (newFont.isEmpty())
131         return;
132 
133     if (newFont == state().unparsedFont &amp;&amp; state().font.realized())
134         return;
135 
136     auto parsedStyle = MutableStyleProperties::create();
137     CSSParser::parseValue(parsedStyle, CSSPropertyFont, newFont, true, strictToCSSParserMode(!m_usesCSSCompatibilityParseMode));
138     if (parsedStyle-&gt;isEmpty())
139         return;
140 
141     String fontValue = parsedStyle-&gt;getPropertyValue(CSSPropertyFont);
142 
143     // According to http://lists.w3.org/Archives/Public/public-html/2009Jul/0947.html,
144     // the &quot;inherit&quot; and &quot;initial&quot; values must be ignored.
145     if (fontValue == &quot;inherit&quot; || fontValue == &quot;initial&quot;)
146         return;
147 
148     // The parse succeeded.
149     String newFontSafeCopy(newFont); // Create a string copy since newFont can be deleted inside realizeSaves.
150     realizeSaves();
151     modifiableState().unparsedFont = newFontSafeCopy;
152 
153     // Map the &lt;canvas&gt; font into the text style. If the font uses keywords like larger/smaller, these will work
154     // relative to the canvas.
155     auto newStyle = RenderStyle::createPtr();
156 
157     Document&amp; document = canvas().document();
158     document.updateStyleIfNeeded();
159 
160     if (auto* computedStyle = canvas().computedStyle())
161         newStyle-&gt;setFontDescription(FontCascadeDescription { computedStyle-&gt;fontDescription() });
162     else {
163         FontCascadeDescription defaultFontDescription;
164         defaultFontDescription.setOneFamily(DefaultFontFamily);
165         defaultFontDescription.setSpecifiedSize(DefaultFontSize);
166         defaultFontDescription.setComputedSize(DefaultFontSize);
167 
168         newStyle-&gt;setFontDescription(WTFMove(defaultFontDescription));
169     }
170 
171     newStyle-&gt;fontCascade().update(&amp;document.fontSelector());
172 
173     // Now map the font property longhands into the style.
174 
175     Style::MatchResult matchResult;
176     auto parentStyle = RenderStyle::clone(*newStyle);
177     Style::Builder styleBuilder(*newStyle, { document, parentStyle }, matchResult, { });
178 
179     styleBuilder.applyPropertyValue(CSSPropertyFontFamily, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontFamily).get());
180     styleBuilder.applyPropertyValue(CSSPropertyFontStyle, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontStyle).get());
181     styleBuilder.applyPropertyValue(CSSPropertyFontVariantCaps, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontVariantCaps).get());
182     styleBuilder.applyPropertyValue(CSSPropertyFontWeight, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontWeight).get());
183     styleBuilder.applyPropertyValue(CSSPropertyFontSize, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize).get());
184     styleBuilder.applyPropertyValue(CSSPropertyLineHeight, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyLineHeight).get());
185 
186     modifiableState().font.initialize(document.fontSelector(), *newStyle);
187 }
188 
189 static CanvasTextAlign toCanvasTextAlign(TextAlign textAlign)
190 {
191     switch (textAlign) {
192     case StartTextAlign:
193         return CanvasTextAlign::Start;
194     case EndTextAlign:
195         return CanvasTextAlign::End;
196     case LeftTextAlign:
197         return CanvasTextAlign::Left;
198     case RightTextAlign:
199         return CanvasTextAlign::Right;
200     case CenterTextAlign:
201         return CanvasTextAlign::Center;
202     }
203 
204     ASSERT_NOT_REACHED();
205     return CanvasTextAlign::Start;
206 }
207 
208 static TextAlign fromCanvasTextAlign(CanvasTextAlign canvasTextAlign)
209 {
210     switch (canvasTextAlign) {
211     case CanvasTextAlign::Start:
212         return StartTextAlign;
213     case CanvasTextAlign::End:
214         return EndTextAlign;
215     case CanvasTextAlign::Left:
216         return LeftTextAlign;
217     case CanvasTextAlign::Right:
218         return RightTextAlign;
219     case CanvasTextAlign::Center:
220         return CenterTextAlign;
221     }
222 
223     ASSERT_NOT_REACHED();
224     return StartTextAlign;
225 }
226 
227 CanvasTextAlign CanvasRenderingContext2D::textAlign() const
228 {
229     return toCanvasTextAlign(state().textAlign);
230 }
231 
232 void CanvasRenderingContext2D::setTextAlign(CanvasTextAlign canvasTextAlign)
233 {
234     auto textAlign = fromCanvasTextAlign(canvasTextAlign);
235     if (state().textAlign == textAlign)
236         return;
237     realizeSaves();
238     modifiableState().textAlign = textAlign;
239 }
240 
241 static CanvasTextBaseline toCanvasTextBaseline(TextBaseline textBaseline)
242 {
243     switch (textBaseline) {
244     case TopTextBaseline:
245         return CanvasTextBaseline::Top;
246     case HangingTextBaseline:
247         return CanvasTextBaseline::Hanging;
248     case MiddleTextBaseline:
249         return CanvasTextBaseline::Middle;
250     case AlphabeticTextBaseline:
251         return CanvasTextBaseline::Alphabetic;
252     case IdeographicTextBaseline:
253         return CanvasTextBaseline::Ideographic;
254     case BottomTextBaseline:
255         return CanvasTextBaseline::Bottom;
256     }
257 
258     ASSERT_NOT_REACHED();
259     return CanvasTextBaseline::Top;
260 }
261 
262 static TextBaseline fromCanvasTextBaseline(CanvasTextBaseline canvasTextBaseline)
263 {
264     switch (canvasTextBaseline) {
265     case CanvasTextBaseline::Top:
266         return TopTextBaseline;
267     case CanvasTextBaseline::Hanging:
268         return HangingTextBaseline;
269     case CanvasTextBaseline::Middle:
270         return MiddleTextBaseline;
271     case CanvasTextBaseline::Alphabetic:
272         return AlphabeticTextBaseline;
273     case CanvasTextBaseline::Ideographic:
274         return IdeographicTextBaseline;
275     case CanvasTextBaseline::Bottom:
276         return BottomTextBaseline;
277     }
278 
279     ASSERT_NOT_REACHED();
280     return TopTextBaseline;
281 }
282 
283 CanvasTextBaseline CanvasRenderingContext2D::textBaseline() const
284 {
285     return toCanvasTextBaseline(state().textBaseline);
286 }
287 
288 void CanvasRenderingContext2D::setTextBaseline(CanvasTextBaseline canvasTextBaseline)
289 {
290     auto textBaseline = fromCanvasTextBaseline(canvasTextBaseline);
291     if (state().textBaseline == textBaseline)
292         return;
293     realizeSaves();
294     modifiableState().textBaseline = textBaseline;
295 }
296 
297 inline TextDirection CanvasRenderingContext2D::toTextDirection(Direction direction, const RenderStyle** computedStyle) const
298 {
299     auto* style = (computedStyle || direction == Direction::Inherit) ? canvas().computedStyle() : nullptr;
300     if (computedStyle)
301         *computedStyle = style;
302     switch (direction) {
303     case Direction::Inherit:
304         return style ? style-&gt;direction() : TextDirection::LTR;
305     case Direction::Rtl:
306         return TextDirection::RTL;
307     case Direction::Ltr:
308         return TextDirection::LTR;
309     }
310     ASSERT_NOT_REACHED();
311     return TextDirection::LTR;
312 }
313 
314 CanvasDirection CanvasRenderingContext2D::direction() const
315 {
316     if (state().direction == Direction::Inherit)
317         canvas().document().updateStyleIfNeeded();
318     return toTextDirection(state().direction) == TextDirection::RTL ? CanvasDirection::Rtl : CanvasDirection::Ltr;
319 }
320 
321 void CanvasRenderingContext2D::setDirection(CanvasDirection direction)
322 {
323     if (state().direction == direction)
324         return;
325 
326     realizeSaves();
327     modifiableState().direction = direction;
328 }
329 
330 void CanvasRenderingContext2D::fillText(const String&amp; text, float x, float y, Optional&lt;float&gt; maxWidth)
331 {
332     drawTextInternal(text, x, y, true, maxWidth);
333 }
334 
335 void CanvasRenderingContext2D::strokeText(const String&amp; text, float x, float y, Optional&lt;float&gt; maxWidth)
336 {
337     drawTextInternal(text, x, y, false, maxWidth);
338 }
339 
340 static inline bool isSpaceThatNeedsReplacing(UChar c)
341 {
342     // According to specification all space characters should be replaced with 0x0020 space character.
343     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-preparation-algorithm
344     // The space characters according to specification are : U+0020, U+0009, U+000A, U+000C, and U+000D.
345     // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#space-character
346     // This function returns true for 0x000B also, so that this is backward compatible.
347     // Otherwise, the test LayoutTests/canvas/philip/tests/2d.text.draw.space.collapse.space.html will fail
348     return c == 0x0009 || c == 0x000A || c == 0x000B || c == 0x000C || c == 0x000D;
349 }
350 
351 static void normalizeSpaces(String&amp; text)
352 {
353     size_t i = text.find(isSpaceThatNeedsReplacing);
354     if (i == notFound)
355         return;
356 
357     unsigned textLength = text.length();
358     Vector&lt;UChar&gt; charVector(textLength);
359     StringView(text).getCharactersWithUpconvert(charVector.data());
360 
361     charVector[i++] = &#39; &#39;;
362 
363     for (; i &lt; textLength; ++i) {
364         if (isSpaceThatNeedsReplacing(charVector[i]))
365             charVector[i] = &#39; &#39;;
366     }
367     text = String::adopt(WTFMove(charVector));
368 }
369 
370 Ref&lt;TextMetrics&gt; CanvasRenderingContext2D::measureText(const String&amp; text)
371 {
372     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled()) {
373         auto&amp; canvas = this-&gt;canvas();
374         ResourceLoadObserver::shared().logCanvasWriteOrMeasure(canvas.document(), text);
375         ResourceLoadObserver::shared().logCanvasRead(canvas.document());
376     }
377 
378     Ref&lt;TextMetrics&gt; metrics = TextMetrics::create();
379 
380     String normalizedText = text;
381     normalizeSpaces(normalizedText);
382 
383     const RenderStyle* computedStyle;
384     auto direction = toTextDirection(state().direction, &amp;computedStyle);
385     bool override = computedStyle ? isOverride(computedStyle-&gt;unicodeBidi()) : false;
386 
387     TextRun textRun(normalizedText, 0, 0, AllowTrailingExpansion, direction, override, true);
388     auto&amp; font = fontProxy();
389     auto&amp; fontMetrics = font.fontMetrics();
390 
391     GlyphOverflow glyphOverflow;
392     glyphOverflow.computeBounds = true;
393     float fontWidth = font.width(textRun, &amp;glyphOverflow);
394     metrics-&gt;setWidth(fontWidth);
395 
396     FloatPoint offset = textOffset(fontWidth, direction);
397 
398     metrics-&gt;setActualBoundingBoxAscent(glyphOverflow.top - offset.y());
399     metrics-&gt;setActualBoundingBoxDescent(glyphOverflow.bottom + offset.y());
400     metrics-&gt;setFontBoundingBoxAscent(fontMetrics.ascent() - offset.y());
401     metrics-&gt;setFontBoundingBoxDescent(fontMetrics.descent() + offset.y());
402     metrics-&gt;setEmHeightAscent(fontMetrics.ascent() - offset.y());
403     metrics-&gt;setEmHeightDescent(fontMetrics.descent() + offset.y());
404     metrics-&gt;setHangingBaseline(fontMetrics.ascent() - offset.y());
405     metrics-&gt;setAlphabeticBaseline(-offset.y());
406     metrics-&gt;setIdeographicBaseline(-fontMetrics.descent() - offset.y());
407 
408     metrics-&gt;setActualBoundingBoxLeft(glyphOverflow.left - offset.x());
409     metrics-&gt;setActualBoundingBoxRight(fontWidth + glyphOverflow.right + offset.x());
410 
411     return metrics;
412 }
413 
414 auto CanvasRenderingContext2D::fontProxy() -&gt; const FontProxy&amp; {
415     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
416     canvas.document().updateStyleIfNeeded();
417     if (!state().font.realized())
418         setFont(state().unparsedFont);
419     return state().font;
420 }
421 
422 FloatPoint CanvasRenderingContext2D::textOffset(float width, TextDirection direction)
423 {
424     auto&amp; fontMetrics = fontProxy().fontMetrics();
425     FloatPoint offset;
426 
427     switch (state().textBaseline) {
428     case TopTextBaseline:
429     case HangingTextBaseline:
430         offset.setY(fontMetrics.ascent());
431         break;
432     case BottomTextBaseline:
433     case IdeographicTextBaseline:
434         offset.setY(-fontMetrics.descent());
435         break;
436     case MiddleTextBaseline:
437         offset.setY(fontMetrics.height() / 2 - fontMetrics.descent());
438         break;
439     case AlphabeticTextBaseline:
440     default:
441         break;
442     }
443 
444     bool isRTL = direction == TextDirection::RTL;
445     auto align = state().textAlign;
446     if (align == StartTextAlign)
447         align = isRTL ? RightTextAlign : LeftTextAlign;
448     else if (align == EndTextAlign)
449         align = isRTL ? LeftTextAlign : RightTextAlign;
450 
451     switch (align) {
452     case CenterTextAlign:
453         offset.setX(-width / 2);
454         break;
455     case RightTextAlign:
456         offset.setX(-width);
457         break;
458     default:
459         break;
460     }
461     return offset;
462 }
463 
464 void CanvasRenderingContext2D::drawTextInternal(const String&amp; text, float x, float y, bool fill, Optional&lt;float&gt; maxWidth)
465 {
466     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
467         ResourceLoadObserver::shared().logCanvasWriteOrMeasure(this-&gt;canvas().document(), text);
468 
469     auto&amp; fontProxy = this-&gt;fontProxy();
470     const auto&amp; fontMetrics = fontProxy.fontMetrics();
471 
472     auto* c = drawingContext();
473     if (!c)
474         return;
475     if (!state().hasInvertibleTransform)
476         return;
477     if (!std::isfinite(x) | !std::isfinite(y))
478         return;
479     if (maxWidth &amp;&amp; (!std::isfinite(maxWidth.value()) || maxWidth.value() &lt;= 0))
480         return;
481 
482     // If gradient size is zero, then paint nothing.
483     auto gradient = c-&gt;strokeGradient();
484     if (!fill &amp;&amp; gradient &amp;&amp; gradient-&gt;isZeroSize())
485         return;
486 
487     gradient = c-&gt;fillGradient();
488     if (fill &amp;&amp; gradient &amp;&amp; gradient-&gt;isZeroSize())
489         return;
490 
491     String normalizedText = text;
492     normalizeSpaces(normalizedText);
493 
494     // FIXME: Need to turn off font smoothing.
495 
496     const RenderStyle* computedStyle;
497     auto direction = toTextDirection(state().direction, &amp;computedStyle);
498     bool override = computedStyle ? isOverride(computedStyle-&gt;unicodeBidi()) : false;
499 
500     TextRun textRun(normalizedText, 0, 0, AllowTrailingExpansion, direction, override, true);
501     float fontWidth = fontProxy.width(textRun);
502     bool useMaxWidth = maxWidth &amp;&amp; maxWidth.value() &lt; fontWidth;
503     float width = useMaxWidth ? maxWidth.value() : fontWidth;
504     FloatPoint location(x, y);
505     location += textOffset(width, direction);
506 
507     // The slop built in to this mask rect matches the heuristic used in FontCGWin.cpp for GDI text.
508     FloatRect textRect = FloatRect(location.x() - fontMetrics.height() / 2, location.y() - fontMetrics.ascent() - fontMetrics.lineGap(),
509         width + fontMetrics.height(), fontMetrics.lineSpacing());
510     if (!fill)
511         inflateStrokeRect(textRect);
512 
513 #if USE(CG)
514     const CanvasStyle&amp; drawStyle = fill ? state().fillStyle : state().strokeStyle;
515     if (drawStyle.canvasGradient() || drawStyle.canvasPattern()) {
516         IntRect maskRect = enclosingIntRect(textRect);
517 
518         // If we have a shadow, we need to draw it before the mask operation.
519         // Follow a procedure similar to paintTextWithShadows in TextPainter.
520 
521         if (shouldDrawShadows()) {
522             GraphicsContextStateSaver stateSaver(*c);
523 
524             FloatSize offset(0, 2 * maskRect.height());
525 
526             FloatSize shadowOffset;
527             float shadowRadius;
528             Color shadowColor;
529             c-&gt;getShadow(shadowOffset, shadowRadius, shadowColor);
530 
531             FloatRect shadowRect(maskRect);
532             shadowRect.inflate(shadowRadius * 1.4);
533             shadowRect.move(shadowOffset * -1);
534             c-&gt;clip(shadowRect);
535 
536             shadowOffset += offset;
537 
538             c-&gt;setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
539 
540             if (fill)
541                 c-&gt;setFillColor(Color::black);
542             else
543                 c-&gt;setStrokeColor(Color::black);
544 
545             fontProxy.drawBidiText(*c, textRun, location + offset, FontCascade::UseFallbackIfFontNotReady);
546         }
547 
548         auto maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpace::SRGB, *c);
549         if (!maskImage)
550             return;
551 
552         auto&amp; maskImageContext = maskImage-&gt;context();
553 
554         if (fill)
555             maskImageContext.setFillColor(Color::black);
556         else {
557             maskImageContext.setStrokeColor(Color::black);
558             maskImageContext.setStrokeThickness(c-&gt;strokeThickness());
559         }
560 
561         maskImageContext.setTextDrawingMode(fill ? TextModeFill : TextModeStroke);
562 
563         if (useMaxWidth) {
564             maskImageContext.translate(location - maskRect.location());
565             // We draw when fontWidth is 0 so compositing operations (eg, a &quot;copy&quot; op) still work.
566             maskImageContext.scale(FloatSize((fontWidth &gt; 0 ? (width / fontWidth) : 0), 1));
567             fontProxy.drawBidiText(maskImageContext, textRun, FloatPoint(0, 0), FontCascade::UseFallbackIfFontNotReady);
568         } else {
569             maskImageContext.translate(-maskRect.location());
570             fontProxy.drawBidiText(maskImageContext, textRun, location, FontCascade::UseFallbackIfFontNotReady);
571         }
572 
573         GraphicsContextStateSaver stateSaver(*c);
574         c-&gt;clipToImageBuffer(*maskImage, maskRect);
575         drawStyle.applyFillColor(*c);
576         c-&gt;fillRect(maskRect);
577         return;
578     }
579 #endif
580 
581     c-&gt;setTextDrawingMode(fill ? TextModeFill : TextModeStroke);
582 
583     GraphicsContextStateSaver stateSaver(*c);
584     if (useMaxWidth) {
585         c-&gt;translate(location);
586         // We draw when fontWidth is 0 so compositing operations (eg, a &quot;copy&quot; op) still work.
587         c-&gt;scale(FloatSize((fontWidth &gt; 0 ? (width / fontWidth) : 0), 1));
588         location = FloatPoint();
589     }
590 
591     if (isFullCanvasCompositeMode(state().globalComposite)) {
592         beginCompositeLayer();
593         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
594         endCompositeLayer();
595         didDrawEntireCanvas();
596     } else if (state().globalComposite == CompositeOperator::Copy) {
597         clearCanvas();
598         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
599         didDrawEntireCanvas();
600     } else {
601         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
602         didDraw(textRect);
603     }
604 }
605 
606 } // namespace WebCore
    </pre>
  </body>
</html>
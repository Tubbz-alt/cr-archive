<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # Copyright (C) 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3 # Copyright (C) 2006 Anders Carlsson &lt;andersca@mac.com&gt;
   4 # Copyright (C) 2006, 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   5 # Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   6 # Copyright (C) 2006-2020 Apple Inc. All rights reserved.
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10 # Copyright (C) 2011 Patrick Gansterer &lt;paroga@webkit.org&gt;
  11 # Copyright (C) 2012 Ericsson AB. All rights reserved.
  12 # Copyright (C) 2007, 2008, 2009, 2012 Google Inc.
  13 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  14 # Copyright (C) 2015, 2016 Canon Inc. All rights reserved.
  15 #
  16 # This library is free software; you can redistribute it and/or
  17 # modify it under the terms of the GNU Library General Public
  18 # License as published by the Free Software Foundation; either
  19 # version 2 of the License, or (at your option) any later version.
  20 #
  21 # This library is distributed in the hope that it will be useful,
  22 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  23 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24 # Library General Public License for more details.
  25 #
  26 # You should have received a copy of the GNU Library General Public License
  27 # along with this library; see the file COPYING.LIB.  If not, write to
  28 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  29 # Boston, MA 02110-1301, USA.
  30 
  31 
  32 package CodeGeneratorJS;
  33 
  34 use strict;
  35 use constant FileNamePrefix =&gt; &quot;JS&quot;;
  36 use Carp qw&lt;longmess&gt;;
  37 use Data::Dumper;
  38 use Hasher;
  39 
  40 my $codeGenerator;
  41 my $writeDependencies;
  42 
  43 my @headerContentHeader = ();
  44 my @headerContent = ();
  45 my %headerIncludes = ();
  46 my %headerTrailingIncludes = ();
  47 
  48 my @implContentHeader = ();
  49 my @implContent = ();
  50 my %implIncludes = ();
  51 my @depsContent = ();
  52 my $numCachedAttributes = 0;
  53 
  54 my $beginAppleCopyrightForHeaderFiles = &lt;&lt;END;
  55 // ------- Begin Apple Copyright -------
  56 /*
  57  * Copyright (C) 2008 Apple Inc. All rights reserved.
  58  *
  59  * Permission is granted by Apple to use this file to the extent
  60  * necessary to relink with LGPL WebKit files.
  61  *
  62  * No license or rights are granted by Apple expressly or by
  63  * implication, estoppel, or otherwise, to Apple patents and
  64  * trademarks. For the sake of clarity, no license or rights are
  65  * granted by Apple expressly or by implication, estoppel, or otherwise,
  66  * under any Apple patents, copyrights and trademarks to underlying
  67  * implementations of any application programming interfaces (APIs)
  68  * or to any functionality that is invoked by calling any API.
  69  */
  70 
  71 END
  72 my $beginAppleCopyrightForSourceFiles = &lt;&lt;END;
  73 // ------- Begin Apple Copyright -------
  74 /*
  75  * Copyright (C) 2008 Apple Inc. All rights reserved.
  76  *
  77  * No license or rights are granted by Apple expressly or by implication,
  78  * estoppel, or otherwise, to Apple copyrights, patents, trademarks, trade
  79  * secrets or other rights.
  80  */
  81 
  82 END
  83 my $endAppleCopyright   = &lt;&lt;END;
  84 // ------- End Apple Copyright   -------
  85 
  86 END
  87 
  88 # Default .h template
  89 my $headerTemplate = &lt;&lt; &quot;EOF&quot;;
  90 /*
  91     This file is part of the WebKit open source project.
  92     This file has been generated by generate-bindings.pl. DO NOT MODIFY!
  93 
  94     This library is free software; you can redistribute it and/or
  95     modify it under the terms of the GNU Library General Public
  96     License as published by the Free Software Foundation; either
  97     version 2 of the License, or (at your option) any later version.
  98 
  99     This library is distributed in the hope that it will be useful,
 100     but WITHOUT ANY WARRANTY; without even the implied warranty of
 101     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 102     Library General Public License for more details.
 103 
 104     You should have received a copy of the GNU Library General Public License
 105     along with this library; see the file COPYING.LIB.  If not, write to
 106     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 107     Boston, MA 02110-1301, USA.
 108 */
 109 EOF
 110 
 111 sub assert
 112 {
 113     my $message = shift;
 114 
 115     my $mess = longmess();
 116     print Dumper($mess);
 117 
 118     die $message;
 119 }
 120 
 121 # Default constructor
 122 sub new
 123 {
 124     my $object = shift;
 125     my $reference = { };
 126 
 127     $codeGenerator = shift;
 128     $writeDependencies = shift;
 129 
 130     bless($reference, $object);
 131     return $reference;
 132 }
 133 
 134 sub GenerateEnumeration
 135 {
 136     my ($object, $enumeration) = @_;
 137 
 138     my $className = GetEnumerationClassName($enumeration-&gt;type);
 139     $object-&gt;GenerateEnumerationHeader($enumeration, $className);
 140     $object-&gt;GenerateEnumerationImplementation($enumeration, $className);
 141 }
 142 
 143 sub GenerateDictionary
 144 {
 145     my ($object, $dictionary, $enumerations, $otherDictionaries) = @_;
 146 
 147     my $className = GetDictionaryClassName($dictionary-&gt;type);
 148     $object-&gt;GenerateDictionaryHeader($dictionary, $className, $enumerations, $otherDictionaries);
 149     $object-&gt;GenerateDictionaryImplementation($dictionary, $className, $enumerations, $otherDictionaries);
 150 }
 151 
 152 sub GenerateCallbackFunction
 153 {
 154     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
 155 
 156     $object-&gt;GenerateCallbackFunctionHeader($callbackFunction, $enumerations, $dictionaries);
 157     $object-&gt;GenerateCallbackFunctionImplementation($callbackFunction, $enumerations, $dictionaries);
 158 }
 159 
 160 sub GenerateInterface
 161 {
 162     my ($object, $interface, $defines, $enumerations, $dictionaries) = @_;
 163 
 164     $codeGenerator-&gt;LinkOverloadedOperations($interface);
 165 
 166     AddStringifierOperationIfNeeded($interface);
 167     AddLegacyCallerOperationIfNeeded($interface);
 168 
 169     if ($interface-&gt;isCallback) {
 170         $object-&gt;GenerateCallbackInterfaceHeader($interface, $enumerations, $dictionaries);
 171         $object-&gt;GenerateCallbackInterfaceImplementation($interface, $enumerations, $dictionaries);
 172     } else {
 173         $object-&gt;GenerateHeader($interface, $enumerations, $dictionaries);
 174         $object-&gt;GenerateImplementation($interface, $enumerations, $dictionaries);
 175     }
 176 }
 177 
 178 sub AddStringifierOperationIfNeeded
 179 {
 180     my $interface = shift;
 181 
 182     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 183         next unless $property-&gt;isStringifier;
 184 
 185         if (ref($property) eq &quot;IDLAttribute&quot;) {
 186             assert(&quot;stringifier can only be used on attributes with type DOMString or USVString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot; || $property-&gt;type-&gt;name eq &quot;USVString&quot;;
 187         }
 188 
 189         if (ref($property) eq &quot;IDLOperation&quot;) {
 190             assert(&quot;stringifier can only be used on operations with a return type of DOMString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot;;
 191             assert(&quot;stringifier can only be used on operations with zero arguments&quot;) unless scalar(@{$property-&gt;arguments}) == 0;
 192 
 193             # Don&#39;t duplicate the operation if it was declared with the name &#39;toString&#39;.
 194             return if $property-&gt;name eq &quot;toString&quot;;
 195         }
 196 
 197         my $stringifier = IDLOperation-&gt;new();
 198         $stringifier-&gt;name(&quot;toString&quot;);
 199         $stringifier-&gt;type(IDLParser::cloneType($property-&gt;type));
 200         $stringifier-&gt;isStringifier(1);
 201 
 202         IDLParser::copyExtendedAttributes($stringifier-&gt;extendedAttributes, $property-&gt;extendedAttributes);
 203 
 204         if ($property-&gt;name &amp;&amp; !$stringifier-&gt;extendedAttributes-&gt;{ImplementedAs}) {
 205             $stringifier-&gt;extendedAttributes-&gt;{ImplementedAs} = $property-&gt;name;
 206         }
 207 
 208         # If the stringifier was declared as read-write attribute and had [CEReactions], we need to remove
 209         # it from the operation, as the operation should act like attribute getter, which doesn&#39;t respect
 210         # [CEReactions].
 211         if (ref($property) eq &quot;IDLAttribute&quot; &amp;&amp; !$property-&gt;isReadOnly &amp;&amp; $stringifier-&gt;extendedAttributes-&gt;{CEReactions}) {
 212              delete $stringifier-&gt;extendedAttributes-&gt;{CEReactions};
 213         }
 214 
 215         push(@{$interface-&gt;operations}, $stringifier);
 216         return;
 217     }
 218 }
 219 
 220 sub AddLegacyCallerOperationIfNeeded
 221 {
 222     my $interface = shift;
 223 
 224     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 225         my $isLegacyCaller = grep { $_ eq &quot;legacycaller&quot; } @{$operation-&gt;specials};
 226         if ($isLegacyCaller) {
 227             $interface-&gt;{LegacyCallers} = [] if !exists $interface-&gt;{LegacyCallers};
 228 
 229             my $clonedOperation = IDLParser::cloneOperation($operation);
 230             push(@{$interface-&gt;{LegacyCallers}}, $clonedOperation);
 231     
 232             $clonedOperation-&gt;{overloads} = $interface-&gt;{LegacyCallers};
 233             $clonedOperation-&gt;{overloadIndex} = @{$interface-&gt;{LegacyCallers}};
 234         }
 235     }
 236 }
 237 
 238 sub EventHandlerAttributeEventName
 239 {
 240     my $attribute = shift;
 241     my $eventType = $attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name;
 242 
 243     # Remove the &quot;on&quot; prefix.
 244     $eventType = substr($eventType, 2);
 245 
 246     return &quot;eventNames().${eventType}Event&quot;;
 247 }
 248 
 249 sub GetParentClassName
 250 {
 251     my $interface = shift;
 252 
 253     return $interface-&gt;extendedAttributes-&gt;{JSLegacyParent} if $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
 254     return &quot;JSDOMObject&quot; unless NeedsImplementationClass($interface);
 255     return &quot;JSDOMWrapper&lt;&quot; . GetImplClassName($interface) . &quot;&gt;&quot; unless $interface-&gt;parentType;
 256     return &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
 257 }
 258 
 259 sub GetCallbackClassName
 260 {
 261     my $className = shift;
 262 
 263     return &quot;JS$className&quot;;
 264 }
 265 
 266 sub GetExportMacroForJSClass
 267 {
 268     my $interface = shift;
 269 
 270     return $interface-&gt;extendedAttributes-&gt;{ExportMacro} . &quot; &quot; if $interface-&gt;extendedAttributes-&gt;{ExportMacro};
 271     return &quot;&quot;;
 272 }
 273 
 274 sub AddIncludesForImplementationTypeInImpl
 275 {
 276     my $implementationType = shift;
 277     
 278     AddIncludesForImplementationType($implementationType, \%implIncludes);
 279 }
 280 
 281 sub AddIncludesForImplementationTypeInHeader
 282 {
 283     my $implementationType = shift;
 284     
 285     AddIncludesForImplementationType($implementationType, \%headerIncludes);
 286 }
 287 
 288 sub AddIncludesForImplementationType
 289 {
 290     my ($implementationType, $includesRef) = @_;
 291 
 292     $includesRef-&gt;{&quot;${implementationType}.h&quot;} = 1;
 293 }
 294 
 295 sub AddToImplIncludesForIDLType
 296 {
 297     my ($type, $conditional) = @_;
 298 
 299     return AddToIncludesForIDLType($type, \%implIncludes, $conditional)
 300 }
 301 
 302 sub AddToIncludesForIDLType
 303 {
 304     my ($type, $includesRef, $conditional) = @_;
 305 
 306     if ($type-&gt;isNullable) {
 307         AddToIncludes(&quot;JSDOMConvertNullable.h&quot;, $includesRef, $conditional);
 308     }
 309 
 310     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
 311         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
 312         if ($overrideTypeName eq &quot;IDLIDBKey&quot;) {
 313             AddToIncludes(&quot;JSDOMConvertIndexedDB.h&quot;, $includesRef, $conditional);
 314             return;
 315         }
 316 
 317         if ($overrideTypeName eq &quot;IDLWebGLAny&quot; || $overrideTypeName eq &quot;IDLWebGLExtension&quot;) {
 318             AddToIncludes(&quot;JSDOMConvertWebGL.h&quot;, $includesRef, $conditional);
 319             return;
 320         }
 321     }
 322 
 323     if ($type-&gt;name eq &quot;any&quot;) {
 324         AddToIncludes(&quot;JSDOMConvertAny.h&quot;, $includesRef, $conditional);
 325         return;
 326     }
 327 
 328     if ($type-&gt;name eq &quot;boolean&quot;) {
 329         AddToIncludes(&quot;JSDOMConvertBoolean.h&quot;, $includesRef, $conditional);
 330         return;
 331     }
 332 
 333     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
 334         AddToIncludes(&quot;JSDOMConvertBufferSource.h&quot;, $includesRef, $conditional);
 335         return;
 336     }
 337 
 338     if ($codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsCallbackInterface($type)) {
 339         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 340         AddToIncludes(&quot;JSDOMConvertCallbacks.h&quot;, $includesRef, $conditional);
 341         return;
 342     }
 343 
 344     if ($type-&gt;name eq &quot;Date&quot;) {
 345         AddToIncludes(&quot;JSDOMConvertDate.h&quot;, $includesRef, $conditional);
 346         return;
 347     }
 348 
 349     if ($codeGenerator-&gt;IsExternalDictionaryType($type)) {
 350         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 351         AddToIncludes(&quot;JSDOMConvertDictionary.h&quot;, $includesRef, $conditional);
 352         return;
 353     }
 354 
 355     if ($codeGenerator-&gt;IsExternalEnumType($type)) {
 356         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 357         AddToIncludes(&quot;JSDOMConvertEnumeration.h&quot;, $includesRef, $conditional);
 358         return;
 359     }
 360 
 361     if ($type-&gt;name eq &quot;EventListener&quot;) {
 362         AddToIncludes(&quot;JSEventListener.h&quot;, $includesRef, $conditional);
 363         AddToIncludes(&quot;JSDOMConvertEventListener.h&quot;, $includesRef, $conditional);
 364         return;
 365     }
 366 
 367     if ($codeGenerator-&gt;IsInterfaceType($type)) {
 368         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 369         AddToIncludes(&quot;JSDOMConvertInterface.h&quot;, $includesRef, $conditional);
 370         return;
 371     }
 372 
 373     if ($type-&gt;name eq &quot;JSON&quot;) {
 374         AddToIncludes(&quot;JSDOMConvertJSON.h&quot;, $includesRef, $conditional);
 375         return;
 376     }
 377 
 378     if ($codeGenerator-&gt;IsNumericType($type)) {
 379         AddToIncludes(&quot;JSDOMConvertNumbers.h&quot;, $includesRef, $conditional);
 380         return;
 381     }
 382 
 383     if ($type-&gt;name eq &quot;object&quot;) {
 384         AddToIncludes(&quot;JSDOMConvertObject.h&quot;, $includesRef, $conditional);
 385         return;
 386     }
 387 
 388     if ($codeGenerator-&gt;IsPromiseType($type)) {
 389         AddToIncludes(&quot;DOMPromiseProxy.h&quot;, $includesRef, $conditional);
 390         AddToIncludes(&quot;JSDOMConvertPromise.h&quot;, $includesRef, $conditional);
 391 
 392         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 393         return;
 394     }
 395 
 396     if ($codeGenerator-&gt;IsRecordType($type)) {
 397         AddToIncludes(&quot;&lt;wtf/Vector.h&gt;&quot;, $includesRef, $conditional);
 398         AddToIncludes(&quot;JSDOMConvertRecord.h&quot;, $includesRef, $conditional);
 399 
 400         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 401         AddToIncludesForIDLType(@{$type-&gt;subtypes}[1], $includesRef, $conditional);
 402         return;
 403     }
 404 
 405     if ($codeGenerator-&gt;IsSequenceOrFrozenArrayType($type)) {
 406         AddToIncludes(&quot;&lt;JavaScriptCore/JSArray.h&gt;&quot;, $includesRef, $conditional);
 407         AddToIncludes(&quot;JSDOMConvertSequences.h&quot;, $includesRef, $conditional);
 408 
 409         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 410         return;
 411     }
 412 
 413     if ($type-&gt;name eq &quot;ScheduledAction&quot;) {
 414         AddToIncludes(&quot;JSDOMConvertScheduledAction.h&quot;, $includesRef, $conditional);
 415         return;
 416     }
 417 
 418     if ($type-&gt;name eq &quot;SerializedScriptValue&quot;) {
 419         AddToIncludes(&quot;SerializedScriptValue.h&quot;, $includesRef, $conditional);
 420         AddToIncludes(&quot;JSDOMConvertSerializedScriptValue.h&quot;, $includesRef, $conditional);
 421         return;
 422     }
 423 
 424     if ($codeGenerator-&gt;IsStringType($type)) {
 425         AddToIncludes(&quot;JSDOMConvertStrings.h&quot;, $includesRef, $conditional);
 426         return;
 427     }
 428 
 429     if ($type-&gt;isUnion) {
 430         AddToIncludes(&quot;&lt;wtf/Variant.h&gt;&quot;, $includesRef, $conditional);
 431         AddToIncludes(&quot;JSDOMConvertUnion.h&quot;, $includesRef, $conditional);
 432 
 433         foreach my $memberType (@{$type-&gt;subtypes}) {
 434             AddToIncludesForIDLType($memberType, $includesRef, $conditional);
 435         }
 436 
 437         return;
 438     }
 439 
 440     if ($type-&gt;name eq &quot;XPathNSResolver&quot;) {
 441         AddToIncludes(&quot;JSXPathNSResolver.h&quot;, $includesRef, $conditional);
 442         AddToIncludes(&quot;JSDOMConvertXPathNSResolver.h&quot;, $includesRef, $conditional);
 443         return;
 444     }
 445 }
 446 
 447 sub AddToImplIncludes
 448 {
 449     my ($header, $conditional) = @_;
 450 
 451     AddToIncludes($header, \%implIncludes, $conditional);
 452 }
 453 
 454 sub AddToIncludes
 455 {
 456     my ($header, $includesRef, $conditional) = @_;
 457 
 458     if (not $conditional) {
 459         $includesRef-&gt;{$header} = 1;
 460     } elsif (not exists($includesRef-&gt;{$header})) {
 461         $includesRef-&gt;{$header} = $conditional;
 462     } else {
 463         my $oldValue = $includesRef-&gt;{$header};
 464         $includesRef-&gt;{$header} = &quot;$oldValue|$conditional&quot; if $oldValue ne 1;
 465     }
 466 }
 467 
 468 sub IsReadonly
 469 {
 470     my $attribute = shift;
 471     return $attribute-&gt;isReadOnly &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{Replaceable} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{PutForwards};
 472 }
 473 
 474 sub AddClassForwardIfNeeded
 475 {
 476     my $type = shift;
 477 
 478     # SVGAnimatedLength/Number/etc. are not classes so they can&#39;t be forward declared as classes.
 479     return if $codeGenerator-&gt;IsSVGAnimatedType($type);
 480     return if $codeGenerator-&gt;IsBufferSourceType($type);
 481 
 482     push(@headerContent, &quot;class &quot; . $type-&gt;name . &quot;;\n\n&quot;);
 483 }
 484 
 485 sub GetGenerateIsReachable
 486 {
 487     my $interface = shift;
 488     return $interface-&gt;extendedAttributes-&gt;{GenerateIsReachable};
 489 }
 490 
 491 sub GetCustomIsReachable
 492 {
 493     my $interface = shift;
 494     return $interface-&gt;extendedAttributes-&gt;{CustomIsReachable};
 495 }
 496 
 497 sub IsDOMGlobalObject
 498 {
 499     my $interface = shift;
 500     return $interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; || $interface-&gt;type-&gt;name eq &quot;RemoteDOMWindow&quot; || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;) || $interface-&gt;type-&gt;name eq &quot;TestGlobalObject&quot;;
 501 }
 502 
 503 sub ShouldUseGlobalObjectPrototype
 504 {
 505     my $interface = shift;
 506 
 507     # For workers, the global object is a DedicatedWorkerGlobalScope.
 508     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;;
 509     # For worklets, the global object is a PaintWorkletGlobalScope.
 510     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkletGlobalScope&quot;;
 511 
 512     return IsDOMGlobalObject($interface);
 513 }
 514 
 515 sub GenerateIndexedGetter
 516 {
 517     my ($interface, $indexedGetterOperation, $indexExpression) = @_;
 518     
 519     # NOTE: This abstractly implements steps 1.2.1 - 1.2.8 of the LegacyPlatformObjectGetOwnProperty
 520     #       algorithm. Returing the conversion expression and attributes expression for use
 521     #       by the caller.
 522     
 523     # 1.2.1 Let operation be the operation used to declare the indexed property getter.
 524     # 1.2.2 Let value be an uninitialized variable.
 525     # 1.2.3 If operation was defined without an identifier, then set value to the result
 526     #       of performing the steps listed in the interface description to determine the
 527     #       value of an indexed property with index as the index.
 528     # 1.2.4 Otherwise, operation was defined with an identifier. Set value to the result
 529     #       of performing the steps listed in the description of operation with index as
 530     #       the only argument value.
 531     # 1.2.5 Let desc be a newly created Property Descriptor with no fields.
 532     # 1.2.6 Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 533     # 1.2.7 If O implements an interface with an indexed property setter, then set
 534     #       desc.[[Writable]] to true, otherwise set it to false.
 535     # 1.2.8 Return desc.
 536     
 537     my @attributes = ();
 538     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetIndexedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 539     
 540     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 541 
 542     my $indexedGetterFunctionName = $indexedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $indexedGetterOperation-&gt;name || &quot;item&quot;;
 543     my $nativeToJSConversion = NativeToJSValueUsingPointers($indexedGetterOperation, $interface, &quot;thisObject-&gt;wrapped().${indexedGetterFunctionName}(${indexExpression})&quot;, &quot;*thisObject-&gt;globalObject()&quot;);
 544     
 545     return ($nativeToJSConversion, $attributeString);
 546 }
 547 
 548 sub GenerateNamedGetter
 549 {
 550     my ($interface, $namedGetterOperation, $namedPropertyExpression) = @_;
 551     
 552     # NOTE: This abstractly implements steps 2.1 - 2.10 of the LegacyPlatformObjectGetOwnProperty
 553     #       algorithm. Returing the conversion expression and attributes expression for use
 554     #       by the caller.
 555     
 556     # 2.1  Let operation be the operation used to declare the named property getter.
 557     # 2.2  Let value be an uninitialized variable.
 558     # 2.3  If operation was defined without an identifier, then set value to the result
 559     #      of performing the steps listed in the interface description to determine the
 560     #      value of a named property with P as the name.
 561     # 2.4  Otherwise, operation was defined with an identifier. Set value to the result
 562     #      of performing the steps listed in the description of operation with P as the
 563     #      only argument value..
 564     # 2.5  Let desc be a newly created Property Descriptor with no fields.
 565     # 2.6  Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 566     # 2.7  If O implements an interface with a named property setter, then set desc.[[Writable]]
 567     #      to true, otherwise set it to false.
 568     # 2.8  If O implements an interface with the [LegacyUnenumerableNamedProperties]
 569     #      extended attribute, then set desc.[[Enumerable]] to false, otherwise set it
 570     #      to true.
 571     # 2.9  Set desc.[[Configurable]] to true.
 572     # 2.10 Return desc.
 573     
 574     my @attributes = ();
 575     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetNamedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 576     push(@attributes, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties};
 577     
 578     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 579     my $nativeToJSConversion = NativeToJSValueUsingPointers($namedGetterOperation, $interface, $namedPropertyExpression, &quot;*thisObject-&gt;globalObject()&quot;);
 580     
 581     return ($nativeToJSConversion, $attributeString);
 582 }
 583 
 584 sub GenerateNamedGetterLambda
 585 {
 586     my ($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, $IDLType) = @_;
 587     
 588     # NOTE: Named getters are little odd. To avoid doing duplicate lookups (once when checking if
 589     #       the property name is a &#39;supported property name&#39; and once to get the value) we signal
 590     #       that a property is supported by whether or not it is &#39;null&#39; (where what null means is
 591     #       dependant on the IDL type). This is based on the assumption that no named getter will
 592     #       ever actually want to return null as an actual return value, which seems like an ok
 593     #       assumption to make (should it turn out this doesn&#39;t hold in the future, we have lots
 594     #       of options; do two lookups, add an extra layer of Optional, etc.).
 595     
 596     my $resultType = &quot;typename ${IDLType}::ImplementationType&quot;;
 597     $resultType = &quot;ExceptionOr&lt;&quot; . $resultType . &quot;&gt;&quot; if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 598     my $returnType = &quot;Optional&lt;&quot; . $resultType . &quot;&gt;&quot;;
 599 
 600     push(@$outputArray, &quot;    auto getterFunctor = [] (auto&amp; thisObject, auto propertyName) -&gt; ${returnType} {\n&quot;);
 601 
 602     my @arguments = GenerateCallWithUsingReferences($namedGetterOperation-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;WTF::nullopt&quot;, &quot;thisObject&quot;, &quot;        &quot;);
 603     push(@arguments, &quot;propertyNameToAtomString(propertyName)&quot;);
 604 
 605     push(@$outputArray, &quot;        auto result = thisObject.wrapped().${namedGetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;);\n&quot;);
 606     
 607     if ($namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) {
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
 624     my ($outputArray, $interface, $className) = @_;
 625     
 626     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 627     
 628     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);
 629     push(@$outputArray, &quot;{\n&quot;);
 630     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 631     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 632     
 633     my $namedGetterOperation = GetNamedGetterOperation($interface);
 634     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 635     
 636     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 637         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
 638     }
 639     
 640     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 641     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 642     
 643     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 644     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 645     
 646     # 1. If O supports indexed properties and P is an array index property name, then:
 647     if ($indexedGetterOperation) {
 648         # 1.1. Let index be the result of calling ToUint32(P).
 649         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 650         
 651         # 1.2. If index is a supported property index, then:
 652         # FIXME: This should support non-contiguous indices.
 653         push(@$outputArray, &quot;        if (index.value() &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 654         
 655         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 656         
 657         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index.value()&quot;);
 658         
 659         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 660         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 661         
 662         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 663         push(@$outputArray, &quot;            return true;\n&quot;);
 664         
 665         push(@$outputArray, &quot;        }\n&quot;);
 666         
 667         # 1.3. Set ignoreNamedProps to true.
 668         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 669         #       rather than going through the paces of having an actual ignoreNamedProps update.
 670         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 671             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);
 672         }
 673         push(@$outputArray, &quot;    }\n&quot;);
 674     }
 675     
 676     # 2. If O supports named properties, the result of running the named property visibility
 677     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 678     if ($namedGetterOperation) {
 679         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 680         #       to true, due to the early return in step 1.3
 681         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 682                 
 683         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 684         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 685         
 686         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 687         
 688         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 689         
 690         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 691         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 692         
 693         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 694         
 695         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 696         
 697         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 698         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 699         
 700         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 701         push(@$outputArray, &quot;        return true;\n&quot;);
 702         push(@$outputArray, &quot;    }\n&quot;);
 703     }
 704 
 705     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 706         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 707         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);
 708         push(@$outputArray, &quot;        return true;\n&quot;);
 709     }
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
 731         $didGeneratePropertyName = 1;
 732     };
 733     
 734     my $namedGetterOperation = GetNamedGetterOperation($interface);
 735     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 736     
 737     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* lexicalGlobalObject, unsigned index, PropertySlot&amp; slot)\n&quot;);
 738     push(@$outputArray, &quot;{\n&quot;);
 739     if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin} || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 740         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
 741     }
 742     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 743     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 744     
 745     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 746         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
 747     }
 748     
 749     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 750     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 751     
 752     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 753     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 754     
 755     # 1. If O supports indexed properties and P is an array index property name, then:
 756     if ($indexedGetterOperation) {
 757         # 1.1. Let index be the result of calling ToUint32(P).
 758         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 759         
 760         # 1.2. If index is a supported property index, then:
 761         # FIXME: This should support non-contiguous indices.
 762         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 763         
 764         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 765         
 766         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
 767         
 768         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 769         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 770         
 771         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 772         push(@$outputArray, &quot;            return true;\n&quot;);
 773         
 774         push(@$outputArray, &quot;        }\n&quot;);
 775         
 776         # 1.3. Set ignoreNamedProps to true.
 777         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 778         #       rather than going through the paces of having an actual ignoreNamedProps update.
 779         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 780             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);
 781         }
 782         push(@$outputArray, &quot;    }\n&quot;);
 783     }
 784     
 785     # 2. If O supports named properties, the result of running the named property visibility
 786     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 787     if ($namedGetterOperation) {
 788         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 789         #       to true, due to the early return in step 1.3
 790         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 791                 
 792         &amp;$propertyNameGeneration();
 793         
 794         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 795         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 796         
 797         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 798         
 799         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 800         
 801         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 802         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 803         
 804         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 805         
 806         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 807 
 808         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 809         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 810         
 811         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 812         push(@$outputArray, &quot;        return true;\n&quot;);
 813         push(@$outputArray, &quot;    }\n&quot;);
 814     }
 815     
 816     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 817         &amp;$propertyNameGeneration();
 818 
 819         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 820         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);
 821         push(@$outputArray, &quot;        return true;\n&quot;);
 822     }
 823 
 824     # 3. Return OrdinaryGetOwnProperty(O, P).
 825     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);
 826     
 827     push(@$outputArray, &quot;}\n\n&quot;);
 828 }
 829 
 830 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 831 sub GenerateGetOwnPropertyNames
 832 {
 833     my ($outputArray, $interface, $className) = @_;
 834     
 835     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 836     
 837     my $namedGetterOperation = GetNamedGetterOperation($interface);
 838     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 839     
 840     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);
 841     push(@$outputArray, &quot;{\n&quot;);
 842     if ($indexedGetterOperation || $namedGetterOperation) {
 843         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
 844     }
 845     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 846     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 847     
 848     # 1. If the object supports indexed properties, then the object’s supported
 849     #    property indices are enumerated first, in numerical order.
 850     # FIXME: This should support non-contiguous indices.
 851     if ($indexedGetterOperation) {
 852         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
 853         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(vm, i));\n&quot;);
 854     }
 855 
 856     # 2. If the object supports named properties and doesn’t implement an interface
 857     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 858     #    object’s supported property names that are visible according to the named
 859     #    property visibility algorithm are enumerated next, in the order given in
 860     #    the definition of the set of supported property names.
 861     if ($namedGetterOperation) {
 862         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 863             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 864             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 865         } else {
 866             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 867             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 868             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 869             push(@$outputArray, &quot;    }\n&quot;);
 870         }
 871     }
 872     
 873     # 3. Finally, any enumerable own properties or properties from the object’s
 874     #    prototype chain are then enumerated, in no defined order.
 875     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, lexicalGlobalObject, propertyNames, mode);\n&quot;);
 876     push(@$outputArray, &quot;}\n\n&quot;);
 877 }
 878 
 879 # https://heycam.github.io/webidl/#invoke-indexed-setter
 880 sub GenerateInvokeIndexedPropertySetter
 881 {
 882     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 883     
 884     # The second argument of the indexed setter operation is the argument being converted.
 885     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
 886     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 887     
 888     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
 889     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 890     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 891     
 892     my $indexedSetterFunctionName = $indexedSetterOperation-&gt;name || &quot;setItem&quot;;
 893     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 894     my $functionString = &quot;thisObject-&gt;wrapped().${indexedSetterFunctionName}(${indexExpression}, ${nativeValuePassExpression})&quot;;
 895     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);
 896     
 897     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 898 }
 899 
 900 # https://heycam.github.io/webidl/#invoke-named-setter
 901 sub GenerateInvokeNamedPropertySetter
 902 {
 903     my ($outputArray, $indent, $interface, $namedSetterOperation, $value) = @_;
 904     
 905     my $argument = @{$namedSetterOperation-&gt;arguments}[1];
 906     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 907     
 908     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
 909     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 910     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 911 
 912     push(@$outputArray, $indent . &quot;bool isPropertySupported = true;\n&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 913 
 914     my $namedSetterFunctionName = $namedSetterOperation-&gt;name || &quot;setNamedItem&quot;;
 915     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 916 
 917     my @arguments = ();
 918     push(@arguments, &quot;propertyNameToString(propertyName)&quot;);
 919     push(@arguments, $nativeValuePassExpression);
 920     push(@arguments, &quot;isPropertySupported&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 921 
 922     my $functionString = &quot;thisObject-&gt;wrapped().${namedSetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
 923     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);
 924 
 925     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 926 }
 927 
 928 sub GeneratePut
 929 {
 930     my ($outputArray, $interface, $className) = @_;
 931     
 932     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
 933     
 934     my $namedSetterOperation = GetNamedSetterOperation($interface);
 935     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
 936     
 937     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);
 938     push(@$outputArray, &quot;{\n&quot;);
 939     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
 940     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
 941 
 942     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
 943         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
 944     if ($namedSetterOperation) {
 945         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);
 946     }
 947     if ($indexedSetterOperation) {
 948         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);
 949     }
 950     
 951     if ($indexedSetterOperation) {
 952         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 953         
 954         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;value&quot;);
 955         
 956         push(@$outputArray, &quot;        return true;\n&quot;);
 957         push(@$outputArray, &quot;    }\n\n&quot;);
 958     }
 959     
 960     if ($namedSetterOperation) {
 961         # FIMXE: We need a more comprehensive story for Symbols.
 962         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
 963         
 964         my $additionalIndent = &quot;&quot;;
 965         
 966         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
 967         if (!$overrideBuiltins) {
 968             push(@$outputArray, &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
 969             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(JSC::getVM(lexicalGlobalObject));\n&quot;);
 970             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);
 971             $additionalIndent .= &quot;    &quot;;
 972         }
 973 
 974         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
 975         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
 976             push(@$outputArray, $additionalIndent . &quot;        if (!isPropertySupported)\n&quot;);
 977             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);
 978         }
 979         push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
 980 
 981         if (!$overrideBuiltins) {
 982             push(@$outputArray, &quot;        }\n&quot;);
 983         }
 984         
 985         push(@$outputArray, &quot;    }\n\n&quot;);
 986     }
 987     
 988     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
 989     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 990         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 991 
 992         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
 993         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);
 994         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
 995     }
 996 
 997     push(@$outputArray, &quot;    return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);
 998     push(@$outputArray, &quot;}\n\n&quot;);
 999 }
1000 
1001 sub GeneratePutByIndex
1002 {
1003     my ($outputArray, $interface, $className) = @_;
1004     
1005     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1006 
1007     my $namedSetterOperation = GetNamedSetterOperation($interface);
1008     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1009     
1010     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1011     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1012     
1013     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);
1014     push(@$outputArray, &quot;{\n&quot;);
1015     if ($namedSetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
1016         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
1017     }
1018     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1019     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1020 
1021     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1022         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1023     if ($namedSetterOperation) {
1024         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1025     }
1026     if ($indexedSetterOperation) {
1027         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1028     }
1029     
1030     if ($indexedSetterOperation) {
1031         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1032         
1033         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1034         
1035         push(@$outputArray, &quot;        return true;\n&quot;);
1036         push(@$outputArray, &quot;    }\n\n&quot;);
1037     }
1038     
1039     if ($namedSetterOperation) {
1040         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1041                 
1042         my $additionalIndent = &quot;&quot;;
1043         if (!$overrideBuiltins) {
1044             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1045             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(vm);\n&quot;);
1046             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);
1047             $additionalIndent .= &quot;    &quot;;
1048         }
1049         
1050         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1051         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1052             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1053             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);
1054         }
1055         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1056         
1057         if (!$overrideBuiltins) {
1058             push(@$outputArray, &quot;    }\n\n&quot;);
1059         }
1060     }
1061 
1062     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1063     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1064         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
1065         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1066         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1067         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
1068         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);
1069         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1070     }
1071 
1072     if (!$ellidesCallsToBase) {
1073         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);
1074     }
1075     
1076     push(@$outputArray, &quot;}\n\n&quot;);
1077 }
1078 
1079 sub GenerateIsUnforgeablePropertyName
1080 {
1081     my ($outputArray, $interface) = @_;
1082     
1083     my @unforgeablePropertyNames = ();
1084     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1085         next if $property-&gt;isStatic;
1086         
1087         if (IsUnforgeable($interface, $property)) {
1088             push(@unforgeablePropertyNames, $property-&gt;name);
1089         }
1090     }
1091     
1092     return 0 if (scalar(@unforgeablePropertyNames) == 0);
1093     
1094     my $condition = join(&quot; || &quot;, map { &quot;propertyName == \&quot;&quot; . $_ . &quot;\&quot;&quot; } @unforgeablePropertyNames);
1095     
1096     push(@$outputArray, &quot;static bool isUnforgeablePropertyName(PropertyName propertyName)\n&quot;);
1097     push(@$outputArray, &quot;{\n&quot;);
1098     push(@$outputArray, &quot;    return ${condition};\n&quot;);
1099     push(@$outputArray, &quot;}\n\n&quot;);
1100     
1101     return 1;
1102 }
1103 
1104 # https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
1105 sub GenerateDefineOwnProperty
1106 {
1107     my ($outputArray, $interface, $className) = @_;
1108     
1109     return if $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty};
1110     
1111     my $namedSetterOperation = GetNamedSetterOperation($interface);
1112     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1113     
1114     return if !$namedSetterOperation &amp;&amp; !$indexedSetterOperation;
1115     
1116     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);
1117     push(@$outputArray, &quot;{\n&quot;);
1118     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
1119     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1120 
1121     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1122         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1123     if ($namedSetterOperation) {
1124         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1125     }
1126     if ($indexedSetterOperation) {
1127         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1128     }
1129     
1130     # 1. If O supports indexed properties and P is an array index property name, then:
1131     if (GetIndexedGetterOperation($interface)) {
1132         # NOTE: The numbers are out of order because there is no reason doing steps 1, 3, and 4 if there
1133         # is no indexed property setter.
1134 
1135         if (!$indexedSetterOperation) {
1136             # 2. If O does not implement an interface with an indexed property setter, then return false.
1137             push(@$outputArray, &quot;    if (parseIndex(propertyName))\n&quot;);
1138             push(@$outputArray, &quot;        return false;\n\n&quot;);
1139         } else {
1140             push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
1141 
1142             # 1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1143             push(@$outputArray, &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1144             push(@$outputArray, &quot;            return false;\n&quot;);
1145             
1146             # 3. Invoke the indexed property setter with P and Desc.[[Value]].
1147             GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;propertyDescriptor.value()&quot;);
1148             
1149             # 4. Return true.
1150             push(@$outputArray, &quot;        return true;\n&quot;);
1151             push(@$outputArray, &quot;    }\n\n&quot;);
1152         }
1153     }
1154     
1155     # 2. If O supports named properties, O does not implement an interface with the [Global]
1156     #    extended attribute and P is not an unforgeable property name of O, then:
1157     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalInterface($interface)) {
1158         # FIMXE: We need a more comprehensive story for Symbols.
1159         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
1160         
1161         my $additionalIndent = &quot;&quot;;
1162         
1163         my $hasUnforgableProperties = GenerateIsUnforgeablePropertyName($outputArray, $interface);
1164         if ($hasUnforgableProperties) {
1165             push(@$outputArray, &quot;        if (!isUnforgeablePropertyName(propertyName)) {\n&quot;);
1166             $additionalIndent .= &quot;    &quot;;
1167         }
1168         
1169         # 1. Let creating be true if P is not a supported property name, and false otherwise.
1170         # NOTE: This step is strength reduced into the only use of &#39;creating&#39; in step 2.2.1
1171         
1172         # 2. If O implements an interface with the [OverrideBuiltins] extended attribute or O
1173         #    does not have an own property named P, then:
1174         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1175         if (!$overrideBuiltins) {
1176             # FIXME: Is JSObject::getOwnPropertySlot the right function to call? Is there a function that will
1177             #        only look at the actual properties, and not call into our implementation of the
1178             #        [[GetOwnProperty]] hook?
1179             push(@$outputArray, $additionalIndent. &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1180             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot)) {\n&quot;);
1181             $additionalIndent .= &quot;    &quot;;
1182         }
1183         if (!$namedSetterOperation) {
1184             # 2.1. If creating is false and O does not implement an interface with a named property setter, then return false.
1185             push(@$outputArray, $additionalIndent . &quot;        if (thisObject-&gt;wrapped().isSupportedPropertyName(propertyNameToString(propertyName)))\n&quot;);
1186             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1187         } else {
1188             # 2.2. If O implements an interface with a named property setter, then:
1189             
1190             # 2.2.1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1191             push(@$outputArray, $additionalIndent . &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1192             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1193             
1194             # 2.2.2. Invoke the named property setter with P and Desc.[[Value]].
1195             GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;propertyDescriptor.value()&quot;);
1196             if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1197                 push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1198                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, propertyDescriptor, shouldThrow);\n&quot;);
1199             }
1200             # 2.2.3. Return true.
1201             push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
1202         }
1203         
1204         if (!$overrideBuiltins) {
1205             push(@$outputArray, $additionalIndent . &quot;    }\n&quot;);
1206         }
1207         
1208         if ($hasUnforgableProperties) {
1209             push(@$outputArray, &quot;        }\n&quot;);
1210         }
1211         
1212         # Close the !propertyName.isSymbol() condition.
1213         push(@$outputArray, &quot;    }\n\n&quot;);
1214     }
1215     
1216     push(@$outputArray, &quot;    PropertyDescriptor newPropertyDescriptor = propertyDescriptor;\n&quot;);
1217         
1218     # 3. If O does not implement an interface with the [Global] extended attribute,
1219     #    then set Desc.[[Configurable]] to true.
1220     if (!IsGlobalInterface($interface)) {
1221         push(@$outputArray, &quot;    newPropertyDescriptor.setConfigurable(true);\n&quot;);
1222     }
1223     
1224     # 4. Return OrdinaryDefineOwnProperty(O, P, Desc).
1225     # FIXME: Does this do the same thing?
1226     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);
1227     
1228     push(@$outputArray, &quot;}\n\n&quot;);
1229 }
1230 
1231 sub GenerateDeletePropertyCommon
1232 {
1233     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1234     
1235     # This implements step 2 of https://heycam.github.io/webidl/#legacy-platform-object-delete
1236     # so it can be shared between the generation of deleteProperty and deletePropertyByIndex.
1237 
1238     # 2. If O supports named properties, O does not implement an interface with the
1239     #    [Global] extended attribute and the result of calling the named
1240     #    property visibility algorithm with property name P and object O is true, then:
1241     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1242     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);
1243 
1244     AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;, $conditional);
1245     my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
1246     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, thisObject, propertyName)) {\n&quot;);
1247 
1248     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;);
1249 
1250     # 2.1. If O does not implement an interface with a named property deleter, then return false.
1251     # 2.2. Let operation be the operation used to declare the named property deleter.
1252     # NOTE: We only add a deleteProperty implementation of we have a named property deleter.
1253 
1254     # 2.3. If operation was defined without an identifier, then:
1255     #      1. Perform the steps listed in the interface description to delete an existing named
1256     #         property with P as the name.
1257     #      2. If the steps indicated that the deletion failed, then return false.
1258     # 2.4. Otherwise, operation was defined with an identifier:
1259     #      1. Perform the steps listed in the description of operation with P as the only argument
1260     #         value.
1261     #      2. If operation was declared with a return type of boolean and the steps returned false,
1262     #         then return false.
1263 
1264     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;deleteNamedProperty&quot;;
1265     my $functionCall = &quot;impl.&quot; . $functionImplementationName . &quot;(propertyNameToString(propertyName))&quot;;
1266 
1267     # NOTE: We expect the implementation function of named deleters without an identifier to
1268     #       return either bool or ExceptionOr&lt;bool&gt;. the implementation function of named deleters
1269     #       with an identifier have no restriction, but if the return value of the operation is
1270     #       boolean, we return that value, otherwise it is ignored (as per section 4.2).
1271 
1272     if ($operation-&gt;extendedAttributes-&gt;{MayThrowException}) {
1273         push(@$outputArray, &quot;        auto result = ${functionCall};\n&quot;);
1274         push(@$outputArray, &quot;        if (result.hasException()) {\n&quot;);
1275         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
1276         push(@$outputArray, &quot;            propagateException(*lexicalGlobalObject, throwScope, result.releaseException());\n&quot;);
1277         push(@$outputArray, &quot;            return true;\n&quot;);
1278         push(@$outputArray, &quot;        }\n\n&quot;);
1279 
1280         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1281             push(@$outputArray, &quot;        return result.releaseReturnValue();\n&quot;);
1282         } else {
1283             push(@$outputArray, &quot;        return true;\n&quot;);
1284         }
1285     } else {
1286         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1287             push(@$outputArray, &quot;        return ${functionCall};\n&quot;);
1288         } else {
1289             push(@$outputArray, &quot;        ${functionCall};\n&quot;);
1290             push(@$outputArray, &quot;        return true;\n&quot;);
1291         }
1292     }
1293 
1294     push(@$outputArray, &quot;    }\n&quot;);
1295 }
1296 
1297 sub GenerateDeleteProperty
1298 {
1299     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1300 
1301     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1302     # for the deleteProperty override hook.
1303 
1304     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName)\n&quot;);
1305     push(@$outputArray, &quot;{\n&quot;);
1306 
1307     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1308     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1309 
1310     # 1. If O supports indexed properties and P is an array index property name, then:
1311     #    1. Let index be the result of calling ToUint32(P).
1312     #    2. If index is not a supported property index, then return true.
1313     #    3. Return false.
1314     if (GetIndexedGetterOperation($interface)) {
1315         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName))\n&quot;);
1316         push(@$outputArray, &quot;        return !impl.isSupportedPropertyIndex(index.value());\n&quot;);
1317     }
1318 
1319     # GenerateDeletePropertyCommon implements step 2.
1320     GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1321 
1322     # FIXME: Instead of calling down JSObject::deleteProperty, perhaps we should implement
1323     # the remained of the algorithm ourselves.
1324     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, lexicalGlobalObject, propertyName);\n&quot;);
1325     push(@$outputArray, &quot;}\n\n&quot;);
1326 }
1327 
1328 sub GenerateDeletePropertyByIndex
1329 {
1330     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1331 
1332     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1333     # for the deletePropertyByIndex override hook.
1334 
1335     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index)\n&quot;);
1336     push(@$outputArray, &quot;{\n&quot;);
1337 
1338     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1339     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1340 
1341     # 1. If O supports indexed properties and P is an array index property name, then:
1342     #    1. Let index be the result of calling ToUint32(P).
1343     #    2. If index is not a supported property index, then return true.
1344     #    3. Return false.
1345 
1346     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1347     #       is all that needs to be done, no need to generate the .
1348 
1349     if (GetIndexedGetterOperation($interface)) {
1350         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1351     } else {
1352         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
1353         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1354 
1355         # GenerateDeletePropertyCommon implements step 2.
1356         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1357 
1358         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1359         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1360         
1361         # 3. If O has an own property with name P, then:
1362         #    1. If the property is not configurable, then return false.
1363         #    2. Otherwise, remove the property from O.
1364         # 3. Return true.
1365         
1366         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, lexicalGlobalObject, index);\n&quot;);
1367     }
1368 
1369     push(@$outputArray, &quot;}\n\n&quot;);
1370 }
1371 
1372 
1373 sub GenerateNamedDeleterDefinition
1374 {
1375     my ($outputArray, $interface, $className) = @_;
1376     
1377     return if $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty};
1378 
1379     my $namedDeleterOperation = GetNamedDeleterOperation($interface);
1380     
1381     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete using
1382     # the deleteProperty and deletePropertyByIndex override hooks.
1383 
1384     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1385     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);
1386 
1387     my $conditional = $namedDeleterOperation-&gt;extendedAttributes-&gt;{Conditional};
1388     if ($conditional) {
1389         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1390         push(@$outputArray, &quot;#if ${conditionalString}\n\n&quot;);;
1391     }
1392 
1393     GenerateDeleteProperty($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1394     GenerateDeletePropertyByIndex($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1395 
1396     push(@implContent, &quot;#endif\n\n&quot;) if $conditional;
1397 }
1398 
1399 sub GenerateHeaderContentHeader
1400 {
1401     my $interface = shift;
1402     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1403 
1404     my @headerContentHeader;
1405     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1406         @headerContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForHeaderFiles);
1407     } else {
1408         @headerContentHeader = split(&quot;\r&quot;, $headerTemplate);
1409     }
1410 
1411     push(@headerContentHeader, &quot;\n#pragma once\n\n&quot;);
1412 
1413     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1414     push(@headerContentHeader, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
1415     return @headerContentHeader;
1416 }
1417 
1418 sub GenerateImplementationContentHeader
1419 {
1420     my $interface = shift;
1421     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1422 
1423     my @implContentHeader;
1424     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1425         @implContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForSourceFiles);
1426     } else {
1427         @implContentHeader = split(&quot;\r&quot;, $headerTemplate);
1428     }
1429 
1430     push(@implContentHeader, &quot;\n#include \&quot;config.h\&quot;\n&quot;);
1431     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1432     push(@implContentHeader, &quot;\n#if ${conditionalString}\n\n&quot;) if $conditionalString;
1433     push(@implContentHeader, &quot;#include \&quot;$className.h\&quot;\n\n&quot;);
1434     return @implContentHeader;
1435 }
1436 
1437 sub NeedsImplementationClass
1438 {
1439     my ($interface) = @_;
1440 
1441     return 0 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
1442     return 1;
1443 }
1444 
1445 sub ShouldGenerateToWrapped
1446 {
1447     my ($hasParent, $interface) = @_;
1448 
1449     return 0 if not NeedsImplementationClass($interface);
1450     return 1 if !$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};
1451     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1452     return 0;
1453 }
1454 
1455 sub ShouldGenerateWrapperOwnerCode
1456 {
1457     my ($hasParent, $interface) = @_;
1458 
1459     return 0 if not NeedsImplementationClass($interface);
1460     return 1 if !$hasParent;
1461     return 1 if GetGenerateIsReachable($interface);
1462     return 1 if GetCustomIsReachable($interface);
1463     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomFinalize};
1464     return 1 if $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;);
1465     return 0;
1466 }
1467 
1468 sub ShouldGenerateToJSDeclaration
1469 {
1470     my ($hasParent, $interface) = @_;
1471 
1472     return 0 if ($interface-&gt;extendedAttributes-&gt;{SuppressToJSObject});
1473     return 0 if not NeedsImplementationClass($interface);
1474     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1475     return 1 if (!$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToJSObject} or $interface-&gt;extendedAttributes-&gt;{CustomToJSObject});
1476     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1477     return 1 if $interface-&gt;extendedAttributes-&gt;{Constructor} or $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
1478     return 0;
1479 }
1480 
1481 sub ShouldGenerateToJSImplementation
1482 {
1483     my ($hasParent, $interface) = @_;
1484 
1485     return 0 if not ShouldGenerateToJSDeclaration($hasParent, $interface);
1486     return 1 if not $interface-&gt;extendedAttributes-&gt;{CustomToJSObject};
1487     return 0;
1488 }
1489 
1490 sub GetTypeNameForDisplayInException
1491 {
1492     my ($type) = @_;
1493 
1494     # FIXME: Add more type specializations.
1495     return &quot;(&quot; . join(&quot; or &quot;, map { $_-&gt;name } GetFlattenedMemberTypes($type)) . &quot;)&quot; if $type-&gt;isUnion;
1496     return $type-&gt;name;
1497 }
1498 
1499 sub GetArgumentExceptionFunction
1500 {
1501     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1502 
1503     my $name = $argument-&gt;name;
1504     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1505     my $typeName = GetTypeNameForDisplayInException($argument-&gt;type);
1506 
1507     if ($codeGenerator-&gt;IsCallbackInterface($argument-&gt;type) || $codeGenerator-&gt;IsCallbackFunction($argument-&gt;type)) {
1508         # FIXME: We should have specialized messages for callback interfaces vs. callback functions.
1509         return &quot;throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;
1510     }
1511 
1512     if ($codeGenerator-&gt;IsWrapperType($argument-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($argument-&gt;type)) {
1513         return &quot;throwArgumentTypeError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;
1514     }
1515 
1516     if ($codeGenerator-&gt;IsEnumType($argument-&gt;type)) {
1517         my $className = GetEnumerationClassName($argument-&gt;type, $interface);
1518         return &quot;throwArgumentMustBeEnumError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;
1519     }
1520 
1521     return undef;
1522 }
1523 
1524 sub GetArgumentExceptionThrower
1525 {
1526     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1527 
1528     my $functionCall = GetArgumentExceptionFunction($interface, $argument, $argumentIndex, $quotedFunctionName);
1529     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1530 }
1531 
1532 sub GetAttributeExceptionFunction
1533 {
1534     my ($interface, $attribute) = @_;
1535     
1536     my $name = $attribute-&gt;name;
1537     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1538     my $typeName = GetTypeNameForDisplayInException($attribute-&gt;type);
1539 
1540     if ($codeGenerator-&gt;IsWrapperType($attribute-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($attribute-&gt;type)) {
1541         return &quot;throwAttributeTypeError(lexicalGlobalObject, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;
1542     }
1543 }
1544 
1545 sub GetAttributeExceptionThrower
1546 {
1547     my ($interface, $attribute) = @_;
1548 
1549     my $functionCall = GetAttributeExceptionFunction($interface, $attribute);
1550     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1551 
1552 }
1553 
1554 sub PassArgumentExpression
1555 {
1556     my ($name, $context) = @_;
1557 
1558     my $type = $context-&gt;type;
1559 
1560     return &quot;WTFMove(${name})&quot; if $type-&gt;isNullable;
1561 
1562     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
1563         return &quot;*${name}&quot; if $type-&gt;name eq &quot;ArrayBuffer&quot;;
1564         return &quot;${name}.releaseNonNull()&quot;;
1565     }
1566 
1567     return &quot;${name}.releaseNonNull()&quot; if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type) || ($codeGenerator-&gt;IsPromiseType($type) &amp;&amp; (ref($context) ne &quot;IDLArgument&quot; || !$context-&gt;isOptional));
1568     return &quot;*${name}&quot; if $codeGenerator-&gt;IsWrapperType($type);
1569     return &quot;WTFMove(${name})&quot;;
1570 }
1571 
1572 sub GetAttributeGetterName
1573 {
1574     my ($interface, $className, $attribute) = @_;
1575 
1576     return $codeGenerator-&gt;WK_lcfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1577     return GetJSBuiltinFunctionName($className, $attribute) if IsJSBuiltin($interface, $attribute);
1578     return &quot;js&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1579 }
1580 
1581 sub GetAttributeSetterName
1582 {
1583     my ($interface, $className, $attribute) = @_;
1584 
1585     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1586     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst(GetJSBuiltinFunctionName($className, $attribute)) if IsJSBuiltin($interface, $attribute);
1587     return &quot;setJS&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1588 }
1589 
1590 sub GetFunctionName
1591 {
1592     my ($interface, $className, $operation) = @_;
1593 
1594     return GetJSBuiltinFunctionName($className, $operation) if IsJSBuiltin($interface, $operation);
1595 
1596     my $functionName = $operation-&gt;name;
1597     $functionName = &quot;SymbolIterator&quot; if $functionName eq &quot;[Symbol.Iterator]&quot;;
1598 
1599     my $kind = $operation-&gt;isStatic ? &quot;Constructor&quot; : (OperationShouldBeOnInstance($interface, $operation) ? &quot;Instance&quot; : &quot;Prototype&quot;);
1600     return $codeGenerator-&gt;WK_lcfirst($className) . $kind . &quot;Function&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);
1601 }
1602 
1603 sub GetFullyQualifiedImplementationCallName
1604 {
1605     my ($interface, $property, $implementationName, $implExpression, $conditional) = @_;
1606     
1607     my $implementedBy = $property-&gt;extendedAttributes-&gt;{ImplementedBy};
1608     if ($implementedBy) {
1609         AddToImplIncludes(&quot;${implementedBy}.h&quot;, $conditional);
1610         return &quot;WebCore::${implementedBy}::${implementationName}&quot;;
1611     }
1612     
1613     if ($property-&gt;isStatic || $property-&gt;extendedAttributes-&gt;{Constructor} || $property-&gt;extendedAttributes-&gt;{NamedConstructor}) {
1614         return $interface-&gt;type-&gt;name . &quot;::${implementationName}&quot;;
1615     }
1616     
1617     if ($property-&gt;isMapLike) {
1618         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToMapLike&quot;;
1619     }
1620     
1621     if ($property-&gt;isSetLike) {
1622         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToSetLike&quot;;
1623     }
1624 
1625     return &quot;${implExpression}.${implementationName}&quot;;
1626 }
1627 
1628 sub AddAdditionalArgumentsForImplementationCall
1629 {
1630     my ($arguments, $interface, $property, $implExpression, $globalObject, $callFrame, $thisObjectExpression) = @_;
1631     
1632     if ($property-&gt;extendedAttributes-&gt;{ImplementedBy} &amp;&amp; !$property-&gt;isStatic) {
1633         unshift(@$arguments, $implExpression);
1634     }
1635     
1636     if ($property-&gt;isMapLike or $property-&gt;isSetLike) {
1637         push(@$arguments, $globalObject);
1638         if (ref($property) eq &quot;IDLOperation&quot;) {
1639             push(@$arguments, $callFrame);
1640         }
1641         push(@$arguments, $thisObjectExpression);
1642     }
1643 }
1644 
1645 sub GetSpecialAccessorOperationForType
1646 {
1647     my ($interface, $special, $firstParameterType, $numberOfParameters) = @_;
1648 
1649     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
1650         my $specials = $operation-&gt;specials;
1651         my $specialExists = grep { $_ eq $special } @$specials;
1652         my $arguments = $operation-&gt;arguments;
1653         if ($specialExists and scalar(@$arguments) == $numberOfParameters and $arguments-&gt;[0]-&gt;type-&gt;name eq $firstParameterType) {
1654             return $operation;
1655         }
1656     }
1657 
1658     return 0;
1659 }
1660 
1661 sub IsGlobalInterface
1662 {
1663     my $interface = shift;
1664 
1665     return $interface-&gt;extendedAttributes-&gt;{Global};
1666 }
1667 
1668 sub AttributeShouldBeOnInstance
1669 {
1670     my $interface = shift;
1671     my $attribute = shift;
1672 
1673     return 1 if IsGlobalInterface($interface);
1674     return 1 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1675 
1676     # [Unforgeable] attributes should be on the instance.
1677     # https://heycam.github.io/webidl/#Unforgeable
1678     return 1 if IsUnforgeable($interface, $attribute);
1679 
1680     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
1681         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity};
1682         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter};
1683         return 1;
1684     }
1685 
1686     return 0;
1687 }
1688 
1689 sub IsAlwaysExposedOnInterface
1690 {
1691     my ($interfaceExposures, $contextExposures) = @_;
1692 
1693     my %contextExposureSet = ();
1694 
1695     if (ref($contextExposures) eq &quot;ARRAY&quot;) {
1696         foreach my $contextExposure (@$contextExposures) {
1697             $contextExposureSet{$contextExposure} = 1;
1698         }
1699     } else {
1700         $contextExposureSet{$contextExposures} = 1;
1701     }
1702 
1703     if (ref($interfaceExposures) ne &quot;ARRAY&quot;) {
1704         $interfaceExposures = [$interfaceExposures];
1705     }
1706 
1707     foreach my $interfaceExposure (@$interfaceExposures) {
1708         return 0 unless exists $contextExposureSet{$interfaceExposure};
1709     }
1710 
1711     return 1;
1712 }
1713 
1714 sub NeedsRuntimeCheck
1715 {
1716     my ($interface, $context) = @_;
1717 
1718     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1719         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1720         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1721     }
1722 
1723     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}
1724         || $context-&gt;extendedAttributes-&gt;{EnabledForContext}
1725         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1726         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1727         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1728         || $context-&gt;extendedAttributes-&gt;{SecureContext}
1729         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}
1730         || $context-&gt;extendedAttributes-&gt;{CustomEnabled};
1731 }
1732 
1733 # https://heycam.github.io/webidl/#es-operations
1734 sub OperationShouldBeOnInstance
1735 {
1736     my ($interface, $operation) = @_;
1737 
1738     return 1 if IsGlobalInterface($interface);
1739 
1740     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1741     if (IsUnforgeable($interface, $operation)) {
1742         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1743         return 1;
1744     }
1745 
1746     return 0;
1747 }
1748 
1749 sub OperationHasForcedReturnValue
1750 {
1751     my ($operation) = @_;
1752 
1753     foreach my $argument (@{$operation-&gt;arguments}) {
1754         return 1 if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
1755     }
1756     return 0;
1757 }
1758 
1759 sub IsAcceleratedDOMAttribute
1760 {
1761     my ($interface, $attribute) = @_;
1762 
1763     # If we use CustomGetterSetter in IDL code generator we cannot skip type check.
1764     return 0 if NeedsRuntimeCheck($interface, $attribute) and AttributeShouldBeOnInstance($interface, $attribute);
1765     return 0 if $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and AttributeShouldBeOnInstance($interface, $attribute);
1766 
1767     # If the interface has special logic for casting we cannot hoist type check to JSC.
1768     return 0 if $interface-&gt;extendedAttributes-&gt;{ImplicitThis};
1769     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1770 
1771     return 0 if $attribute-&gt;isStatic;
1772     return 0 if $attribute-&gt;isMapLike;
1773     return 0 if $attribute-&gt;isSetLike;
1774     return 0 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1775     return 0 if IsJSBuiltin($interface, $attribute);
1776     return 0 if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
1777     return 0 if $codeGenerator-&gt;IsPromiseType($attribute-&gt;type);
1778     return 0 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1779     return 1;
1780 }
1781 
1782 sub GetJSCAttributesForAttribute
1783 {
1784     my $interface = shift;
1785     my $attribute = shift;
1786 
1787     my @specials = ();
1788     push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
1789 
1790     # As per Web IDL specification, constructor properties on the ECMAScript global object should not be enumerable.
1791     my $isGlobalConstructor = $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1792     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if ($attribute-&gt;extendedAttributes-&gt;{NotEnumerable} || $isGlobalConstructor);
1793     push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
1794     push(@specials, &quot;JSC::PropertyAttribute::CustomAccessor&quot;) unless $isGlobalConstructor or IsJSBuiltin($interface, $attribute);
1795     push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
1796     push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1797     push(@specials, &quot;JSC::PropertyAttribute::Accessor | JSC::PropertyAttribute::Builtin&quot;) if  IsJSBuiltin($interface, $attribute);
1798     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
1799 }
1800 
1801 sub GetIndexedGetterOperation
1802 {
1803     my $interface = shift;
1804     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;unsigned long&quot;, 1);
1805 }
1806 
1807 sub GetIndexedSetterOperation
1808 {
1809     my $interface = shift;
1810     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;unsigned long&quot;, 2);
1811 }
1812 
1813 sub GetNamedGetterOperation
1814 {
1815     my $interface = shift;
1816     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;DOMString&quot;, 1);
1817 }
1818 
1819 sub GetNamedSetterOperation
1820 {
1821     my $interface = shift;
1822     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;DOMString&quot;, 2);
1823 }
1824 
1825 sub GetNamedDeleterOperation
1826 {
1827     my $interface = shift;
1828     return GetSpecialAccessorOperationForType($interface, &quot;deleter&quot;, &quot;DOMString&quot;, 1);
1829 }
1830 
1831 sub InstanceOperationCount
1832 {
1833     my $interface = shift;
1834     my $count = 0;
1835 
1836     foreach my $operation (@{$interface-&gt;operations}) {
1837         $count++ if OperationShouldBeOnInstance($interface, $operation);
1838     }
1839 
1840     return $count;
1841 }
1842 
1843 sub PrototypeOperationCount
1844 {
1845     my $interface = shift;
1846     my $count = 0;
1847 
1848     foreach my $operation (@{$interface-&gt;operations}) {
1849         $count++ if !$operation-&gt;isStatic &amp;&amp; !OperationShouldBeOnInstance($interface, $operation);
1850     }
1851 
1852     $count += scalar @{$interface-&gt;iterable-&gt;operations} if $interface-&gt;iterable;
1853     $count += scalar @{$interface-&gt;mapLike-&gt;operations} if $interface-&gt;mapLike;
1854     $count += scalar @{$interface-&gt;setLike-&gt;operations} if $interface-&gt;setLike;
1855     $count += scalar @{$interface-&gt;serializable-&gt;operations} if $interface-&gt;serializable;
1856 
1857     return $count;
1858 }
1859 
1860 sub InstancePropertyCount
1861 {
1862     my $interface = shift;
1863     my $count = 0;
1864     foreach my $attribute (@{$interface-&gt;attributes}) {
1865         $count++ if AttributeShouldBeOnInstance($interface, $attribute);
1866     }
1867     $count += InstanceOperationCount($interface);
1868     return $count;
1869 }
1870 
1871 sub PrototypePropertyCount
1872 {
1873     my $interface = shift;
1874     my $count = 0;
1875     foreach my $attribute (@{$interface-&gt;attributes}) {
1876         $count++ if !AttributeShouldBeOnInstance($interface, $attribute);
1877     }
1878     $count += PrototypeOperationCount($interface);
1879     $count++ if NeedsConstructorProperty($interface);
1880     return $count;
1881 }
1882 
1883 sub InstanceOverridesGetOwnPropertySlot
1884 {
1885     my $interface = shift;
1886     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot}
1887         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1888         || GetIndexedGetterOperation($interface)
1889         || GetNamedGetterOperation($interface);
1890 }
1891 
1892 sub InstanceOverridesGetOwnPropertyNames
1893 {
1894     my $interface = shift;
1895     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames}
1896         || GetIndexedGetterOperation($interface)
1897         || GetNamedGetterOperation($interface);
1898 }
1899 
1900 sub InstanceOverridesPut
1901 {
1902     my $interface = shift;
1903     return $interface-&gt;extendedAttributes-&gt;{CustomPut}
1904         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1905         || GetIndexedSetterOperation($interface)
1906         || GetNamedSetterOperation($interface);
1907 }
1908 
1909 sub InstanceOverridesDefineOwnProperty
1910 {
1911     my $interface = shift;
1912 
1913     return 0 if $interface-&gt;extendedAttributes-&gt;{DefaultDefineOwnProperty};
1914 
1915     return $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty}
1916         || GetIndexedSetterOperation($interface)
1917         || GetNamedSetterOperation($interface);
1918 }
1919 
1920 sub InstanceOverridesDeleteProperty
1921 {
1922     my $interface = shift;
1923     return $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty}
1924         || GetNamedDeleterOperation($interface);
1925 }
1926 
1927 sub PrototypeHasStaticPropertyTable
1928 {
1929     my $interface = shift;
1930     my $numConstants = @{$interface-&gt;constants};
1931     return $numConstants &gt; 0 || PrototypePropertyCount($interface) &gt; 0;
1932 }
1933 
1934 sub InstanceNeedsVisitChildren
1935 {
1936     my $interface = shift;
1937     
1938     foreach my $attribute (@{$interface-&gt;attributes}) {
1939         return 1 if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
1940     }
1941 
1942     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
1943     return 1 if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1944     return 0;
1945 }
1946 
1947 sub InstanceNeedsEstimatedSize
1948 {
1949     my $interface = shift;
1950     return $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1951 }
1952 
1953 sub GetImplClassName
1954 {
1955     my $interface = shift;
1956 
1957     return $interface-&gt;type-&gt;name;
1958 }
1959 
1960 sub IsClassNameWordBoundary
1961 {
1962     my ($name, $i) = @_;
1963 
1964     # Interpret negative numbers as distance from end of string, just as the substr function does.
1965     $i += length($name) if $i &lt; 0;
1966 
1967     return 0 if $i &lt; 0;
1968     return 1 if $i == 0;
1969     return 1 if $i == length($name);
1970     return 0 if $i &gt; length($name);
1971 
1972     my $checkString = substr($name, $i - 1);
1973     return $checkString =~ /^[^A-Z][A-Z]/ || $checkString =~ /^[A-Z][A-Z][^A-Z]/;
1974 }
1975 
1976 sub IsPrefixRemovable
1977 {
1978     my ($class, $name, $i) = @_;
1979 
1980     return IsClassNameWordBoundary($name, $i)
1981         &amp;&amp; (IsClassNameWordBoundary($class, $i) &amp;&amp; substr($class, 0, $i) eq substr($name, 0, $i)
1982             || IsClassNameWordBoundary($class, -$i) &amp;&amp; substr($class, -$i) eq substr($name, 0, $i));
1983 }
1984 
1985 sub GetNestedClassName
1986 {
1987     my ($interface, $name) = @_;
1988 
1989     my $class = GetImplClassName($interface);
1990     my $member = $codeGenerator-&gt;WK_ucfirst($name);
1991 
1992     # Since the enumeration name will be nested in the class name&#39;s namespace, remove any words
1993     # that happen to match the start or end of the class name. If an enumeration is named TrackType or
1994     # TextTrackType, and the class is named TextTrack, then we will get a name like TextTrack::Type.
1995     my $memberLength = length($member);
1996     my $longestPrefixLength = 0;
1997     if ($member =~ /^[A-Z]./) {
1998         for (my $i = 2; $i &lt; $memberLength - 1; $i++) {
1999             $longestPrefixLength = $i if IsPrefixRemovable($class, $member, $i);
2000         }
2001     }
2002     $member = substr($member, $longestPrefixLength);
2003 
2004     return &quot;${class}::$member&quot;;
2005 }
2006 
2007 sub GetEnumerationClassName
2008 {
2009     my ($type, $interface) = @_;
2010 
2011     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
2012 
2013     if ($codeGenerator-&gt;HasEnumImplementationNameOverride($type)) {
2014         return $codeGenerator-&gt;GetEnumImplementationNameOverride($type);
2015     }
2016 
2017     my $name = $type-&gt;name;
2018 
2019     return $name if $codeGenerator-&gt;IsExternalEnumType($type);
2020     return $name unless defined($interface);
2021 
2022     return GetNestedClassName($interface, $name);
2023 }
2024 
2025 sub GetEnumerationValueName
2026 {
2027     my ($name) = @_;
2028 
2029     return &quot;EmptyString&quot; if $name eq &quot;&quot;;
2030     $name = join(&quot;&quot;, map { $codeGenerator-&gt;WK_ucfirst($_) } split(&quot;-&quot;, $name));
2031     $name = &quot;_$name&quot; if $name =~ /^\d/;
2032     return $name;
2033 }
2034 
2035 sub GenerateEnumerationHeader
2036 {
2037     my ($object, $enumeration, $className) = @_;
2038  
2039     # - Add default header template and header protection.
2040     push(@headerContentHeader, GenerateHeaderContentHeader($enumeration));
2041 
2042     $headerIncludes{&quot;${className}.h&quot;} = 1;
2043 
2044     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2045     push(@headerContent, GenerateEnumerationHeaderContent($enumeration, $className));
2046     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
2047      
2048     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2049     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2050 }
2051  
2052 sub GenerateEnumerationImplementation
2053 {
2054     my ($object, $enumeration, $className) = @_;
2055  
2056     # - Add default header template
2057     push(@implContentHeader, GenerateImplementationContentHeader($enumeration));
2058 
2059     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
2060     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
2061     push(@implContent, GenerateEnumerationImplementationContent($enumeration, $className));
2062     push(@implContent, &quot;} // namespace WebCore\n&quot;);
2063      
2064     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2065     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2066 }
2067 
2068 sub GenerateEnumerationImplementationContent
2069 {
2070     my ($enumeration, $className, $interface, $conditionalString) = @_;
2071 
2072     # FIXME: A little ugly to have this be a side effect instead of a return value.
2073     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSString.h&gt;&quot;);
2074     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2075     AddToImplIncludes(&quot;JSDOMConvertEnumeration.h&quot;);
2076 
2077     my $result = &quot;&quot;;
2078     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2079 
2080 
2081     $result .= &quot;String convertEnumerationToString($className enumerationValue)\n&quot;;
2082     $result .= &quot;{\n&quot;;
2083     AddToImplIncludes(&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;);
2084     $result .= &quot;    static const NeverDestroyed&lt;String&gt; values[] = {\n&quot;;
2085     foreach my $value (@{$enumeration-&gt;values}) {
2086         if ($value eq &quot;&quot;) {
2087             $result .= &quot;        emptyString(),\n&quot;;
2088         } else {
2089             $result .= &quot;        MAKE_STATIC_STRING_IMPL(\&quot;$value\&quot;),\n&quot;;
2090         }
2091     }
2092     $result .= &quot;    };\n&quot;;
2093     my $index = 0;
2094     foreach my $value (@{$enumeration-&gt;values}) {
2095         my $enumerationValueName = GetEnumerationValueName($value);
2096         $result .= &quot;    static_assert(static_cast&lt;size_t&gt;(${className}::$enumerationValueName) == $index, \&quot;${className}::$enumerationValueName is not $index as expected\&quot;);\n&quot;;
2097         $index++;
2098     }
2099     $result .= &quot;    ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));\n&quot;;
2100     $result .= &quot;    return values[static_cast&lt;size_t&gt;(enumerationValue)];\n&quot;;
2101     $result .= &quot;}\n\n&quot;;
2102 
2103 
2104     # FIXME: Change to take VM&amp; instead of JSGlobalObject*.
2105     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(JSGlobalObject&amp; lexicalGlobalObject, $className enumerationValue)\n&quot;;
2106     $result .= &quot;{\n&quot;;
2107     $result .= &quot;    return jsStringWithCache(&amp;lexicalGlobalObject, convertEnumerationToString(enumerationValue));\n&quot;;
2108     $result .= &quot;}\n\n&quot;;
2109 
2110     # FIXME: Change to take VM&amp; instead of JSGlobalObject&amp;.
2111     # FIXME: Consider using toStringOrNull to make exception checking faster.
2112     # FIXME: Consider finding a more efficient way to match against all the strings quickly.
2113     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;
2114     $result .= &quot;{\n&quot;;
2115     $result .= &quot;    auto stringValue = value.toWTFString(&amp;lexicalGlobalObject);\n&quot;;
2116     foreach my $value (@{$enumeration-&gt;values}) {
2117         my $enumerationValueName = GetEnumerationValueName($value);
2118         if ($value eq &quot;&quot;) {
2119             $result .= &quot;    if (stringValue.isEmpty())\n&quot;;
2120         } else {
2121             $result .= &quot;    if (stringValue == \&quot;$value\&quot;)\n&quot;;
2122         }
2123         $result .= &quot;        return ${className}::${enumerationValueName};\n&quot;;
2124     }
2125     $result .= &quot;    return WTF::nullopt;\n&quot;;
2126     $result .= &quot;}\n\n&quot;;
2127 
2128     $result .= &quot;template&lt;&gt; const char* expectedEnumerationValues&lt;$className&gt;()\n&quot;;
2129     $result .= &quot;{\n&quot;;
2130     $result .= &quot;    return \&quot;\\\&quot;&quot; . join (&quot;\\\&quot;, \\\&quot;&quot;, @{$enumeration-&gt;values}) . &quot;\\\&quot;\&quot;;\n&quot;;
2131     $result .= &quot;}\n\n&quot;;
2132 
2133     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2134 
2135     return $result;
2136 }
2137 
2138 sub GenerateEnumerationsImplementationContent
2139 {
2140     my ($interface, $enumerations) = @_;
2141 
2142     return &quot;&quot; unless @$enumerations;
2143 
2144     my $result = &quot;&quot;;
2145     foreach my $enumeration (@$enumerations) {
2146         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2147         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2148         $result .= GenerateEnumerationImplementationContent($enumeration, $className, $interface, $conditionalString);
2149     }
2150     return $result;
2151 }
2152 
2153 sub GenerateEnumerationHeaderContent
2154 {
2155     my ($enumeration, $className, $conditionalString) = @_;
2156 
2157     $headerIncludes{&quot;JSDOMConvertEnumeration.h&quot;} = 1;
2158 
2159     my $result = &quot;&quot;;
2160     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2161 
2162     my $exportMacro = GetExportMacroForJSClass($enumeration);
2163 
2164     $result .= &quot;${exportMacro}String convertEnumerationToString($className);\n&quot;;
2165     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::JSGlobalObject&amp;, $className);\n\n&quot;;
2166     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;;
2167     $result .= &quot;template&lt;&gt; ${exportMacro}const char* expectedEnumerationValues&lt;$className&gt;();\n\n&quot;;
2168     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2169     
2170     return $result;
2171 }
2172 
2173 sub GenerateEnumerationsHeaderContent
2174 {
2175     my ($interface, $enumerations) = @_;
2176 
2177     return &quot;&quot; unless @$enumerations;
2178 
2179     # FIXME: Could optimize this to only generate the parts of each enumeration that are actually
2180     # used, which would require iterating over everything in the interface.
2181 
2182     my $result = &quot;&quot;;
2183     foreach my $enumeration (@$enumerations) {
2184         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2185         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2186         $result .= GenerateEnumerationHeaderContent($enumeration, $className, $conditionalString);
2187     }
2188     return $result;
2189 }
2190 
2191 sub GetDictionaryClassName
2192 {
2193     my ($type, $interface) = @_;
2194 
2195     if ($codeGenerator-&gt;HasDictionaryImplementationNameOverride($type)) {
2196         return $codeGenerator-&gt;GetDictionaryImplementationNameOverride($type);
2197     }
2198 
2199     my $name = $type-&gt;name;
2200     return $name if $codeGenerator-&gt;IsExternalDictionaryType($type);
2201     return $name unless defined($interface);
2202     return GetNestedClassName($interface, $name);
2203 }
2204 
2205 sub GenerateDefaultValue
2206 {
2207     my ($typeScope, $context, $type, $defaultValue) = @_;
2208 
2209     if ($codeGenerator-&gt;IsStringType($type)) {
2210         my $useAtomString = $type-&gt;extendedAttributes-&gt;{AtomString};
2211         if ($defaultValue eq &quot;null&quot;) {
2212             return $useAtomString ? &quot;nullAtom()&quot; : &quot;String()&quot;;
2213         } elsif ($defaultValue eq &quot;\&quot;\&quot;&quot;) {
2214             return $useAtomString ? &quot;emptyAtom()&quot; : &quot;emptyString()&quot;;
2215         } else {
2216             return $useAtomString ? &quot;AtomString(${defaultValue}, AtomString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;
2217         }
2218     }
2219 
2220     if ($codeGenerator-&gt;IsEnumType($type)) {
2221         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2222         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2223         if ($defaultValue eq &quot;null&quot;) {
2224             die if !$type-&gt;isNullable;
2225             return &quot;WTF::nullopt&quot;;
2226         }
2227         my $className = GetEnumerationClassName($type, $typeScope);
2228         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2229         return $className . &quot;::&quot; . $enumerationValueName;
2230     }
2231     if ($defaultValue eq &quot;null&quot;) {
2232         if ($type-&gt;isUnion) {
2233             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2234 
2235             my $IDLType = GetIDLType($typeScope, $type);
2236             return &quot;convert&lt;${IDLType}&gt;(lexicalGlobalObject, jsNull());&quot;;
2237         }
2238 
2239         return &quot;jsNull()&quot; if $type-&gt;name eq &quot;any&quot;;
2240         return &quot;nullptr&quot; if $codeGenerator-&gt;IsWrapperType($type) || $codeGenerator-&gt;IsBufferSourceType($type);
2241         return &quot;String()&quot; if $codeGenerator-&gt;IsStringType($type);
2242         return &quot;WTF::nullopt&quot;;
2243     }
2244 
2245     if ($defaultValue eq &quot;[]&quot;) {
2246         my $IDLType = GetIDLType($typeScope, $type);
2247         return &quot;Converter&lt;${IDLType}&gt;::ReturnType{ }&quot;;
2248     }
2249 
2250     return &quot;jsUndefined()&quot; if $defaultValue eq &quot;undefined&quot;;
2251     return &quot;PNaN&quot; if $defaultValue eq &quot;NaN&quot;;
2252 
2253     return $defaultValue;
2254 }
2255 
2256 sub GenerateDictionaryHeaderContent
2257 {
2258     my ($dictionary, $className, $conditionalString) = @_;
2259 
2260     $headerIncludes{&quot;JSDOMConvertDictionary.h&quot;} = 1;
2261 
2262     my $exportMacro = GetExportMacroForJSClass($dictionary);
2263 
2264     my $result = &quot;&quot;;
2265     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2266     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n\n&quot;;
2267 
2268     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2269         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;
2270     }
2271 
2272     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2273     return $result;
2274 }
2275 
2276 sub GenerateDictionariesHeaderContent
2277 {
2278     my ($typeScope, $allDictionaries) = @_;
2279 
2280     return &quot;&quot; unless @$allDictionaries;
2281 
2282     my $result = &quot;&quot;;
2283     foreach my $dictionary (@$allDictionaries) {
2284         $headerIncludes{$typeScope-&gt;type-&gt;name . &quot;.h&quot;} = 1 if $typeScope;
2285         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2286         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
2287         $result .= GenerateDictionaryHeaderContent($dictionary, $className, $conditionalString);
2288     }
2289     return $result;
2290 }
2291 
2292 sub GenerateDictionaryImplementationContent
2293 {
2294     my ($dictionary, $className, $interface) = @_;
2295 
2296     my $result = &quot;&quot;;
2297 
2298     my $name = $dictionary-&gt;type-&gt;name;
2299     my $typeScope = $interface || $dictionary;
2300 
2301     my $conditional = $dictionary-&gt;extendedAttributes-&gt;{Conditional};
2302     if ($conditional) {
2303         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2304         $result .= &quot;#if ${conditionalString}\n\n&quot;;
2305     }
2306 
2307     # FIXME: A little ugly to have this be a side effect instead of a return value.
2308     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2309     AddToImplIncludes(&quot;JSDOMConvertDictionary.h&quot;);
2310 
2311     # https://heycam.github.io/webidl/#es-dictionary
2312     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;
2313     $result .= &quot;{\n&quot;;
2314     $result .= &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;;
2315     $result .= &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;;
2316     $result .= &quot;    bool isNullOrUndefined = value.isUndefinedOrNull();\n&quot;;
2317     $result .= &quot;    auto* object = isNullOrUndefined ? nullptr : value.getObject();\n&quot;;
2318 
2319     # 1. If Type(V) is not Undefined, Null or Object, then throw a TypeError.
2320     $result .= &quot;    if (UNLIKELY(!isNullOrUndefined &amp;&amp; !object)) {\n&quot;;
2321     $result .= &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;;
2322     $result .= &quot;        return { };\n&quot;;
2323     $result .= &quot;    }\n&quot;;
2324 
2325     # 2. Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
2326 
2327     # 3. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
2328     my @dictionaries;
2329     push(@dictionaries, $dictionary);
2330     my $parentType = $dictionary-&gt;parentType;
2331     while (defined($parentType)) {
2332         my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
2333         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2334         unshift(@dictionaries, $parentDictionary);
2335         $parentType = $parentDictionary-&gt;parentType;
2336     }
2337 
2338     my $arguments = &quot;&quot;;
2339     my $comma = &quot;&quot;;
2340 
2341     $result .= &quot;    $className result;\n&quot;;
2342 
2343     # 4. For each dictionary dictionary in dictionaries, in order:
2344     foreach my $dictionary (@dictionaries) {
2345         # For each dictionary member member declared on dictionary, in lexicographical order:
2346         my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2347         foreach my $member (@sortedMembers) {
2348             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2349 
2350             my $type = $member-&gt;type;
2351             AddToImplIncludesForIDLType($type);
2352 
2353             my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2354             if ($conditional) {
2355                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2356                 $result .= &quot;#if ${conditionalString}\n&quot;;
2357             }
2358 
2359             # 4.1. Let key be the identifier of member.
2360             my $key = $member-&gt;name;
2361             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2362 
2363             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2364             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2365             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2366             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2367             $result .= &quot;    else {\n&quot;;
2368             $result .= &quot;        ${key}Value = object-&gt;get(&amp;lexicalGlobalObject, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;
2369             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2370             $result .= &quot;    }\n&quot;;
2371 
2372             my $IDLType = GetIDLType($typeScope, $type);
2373 
2374             # 4.3. If value is not undefined, then:
2375             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2376 
2377             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;);
2378             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2379             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2380 
2381             # Value is undefined.
2382             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2383             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2384                 $result .= &quot;    } else\n&quot;;
2385                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2386             } elsif ($member-&gt;isRequired) {
2387                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2388                 $result .= &quot;    } else {\n&quot;;
2389                 $result .= &quot;        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;
2390                 $result .= &quot;        return { };\n&quot;;
2391                 $result .= &quot;    }\n&quot;;
2392             } else {
2393                 $result .= &quot;    }\n&quot;;
2394             }
2395 
2396             $result .= &quot;#endif\n&quot; if $conditional;
2397         }
2398     }
2399 
2400     # 5. Return dict.
2401     $result .= &quot;    return result;\n&quot;;
2402     $result .= &quot;}\n\n&quot;;
2403 
2404     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2405         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2406         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2407 
2408         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;
2409         $result .= &quot;{\n&quot;;
2410         $result .= &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n\n&quot;;
2411 
2412         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
2413         $result .= &quot;    auto result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n\n&quot;;
2414 
2415         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2416         #    in order from least to most derived.
2417         #    NOTE: This was done above.
2418 
2419         # 3. For each dictionary dictionary in dictionaries, in order:
2420         foreach my $dictionary (@dictionaries) {
2421             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2422             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2423             foreach my $member (@sortedMembers) {
2424                 my $key = $member-&gt;name;
2425                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2426                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2427 
2428                 my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2429                 if ($conditional) {
2430                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2431                     $result .= &quot;#if ${conditionalString}\n&quot;;
2432                 }
2433 
2434                 # 1. Let key be the identifier of member.
2435                 # 2. If the dictionary member named key is present in V, then:
2436                     # 1. Let idlValue be the value of member on V.
2437                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2438                     # 3. Perform ! CreateDataProperty(O, key, value).
2439 
2440                 my $needsRuntimeCheck = NeedsRuntimeCheck($dictionary, $member);
2441                 my $indent = &quot;&quot;;
2442                 if ($needsRuntimeCheck) {
2443                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;&amp;globalObject&quot;);
2444                     $result .= &quot;    if (${runtimeEnableConditionalString}) {\n&quot;;
2445                     $indent = &quot;    &quot;;
2446                 }
2447 
2448                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2449                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2450                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2451 
2452                     $result .= &quot;${indent}    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;
2453                     $result .= &quot;${indent}        auto ${key}Value = ${conversionExpression};\n&quot;;
2454                     $result .= &quot;${indent}        result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2455                     $result .= &quot;${indent}    }\n&quot;;
2456                 } else {
2457                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2458 
2459                     $result .= &quot;${indent}    auto ${key}Value = ${conversionExpression};\n&quot;;
2460                     $result .= &quot;${indent}    result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2461                 }
2462                 if ($needsRuntimeCheck) {
2463                     $result .= &quot;    }\n&quot;;
2464                 }
2465 
2466                 $result .= &quot;#endif\n&quot; if $conditional;
2467             }
2468         }
2469 
2470         $result .= &quot;    return result;\n&quot;;
2471         $result .= &quot;}\n\n&quot;;
2472     }
2473 
2474     $result .= &quot;#endif\n\n&quot; if $conditional;
2475 
2476     return $result;
2477 }
2478 
2479 sub GenerateDictionariesImplementationContent
2480 {
2481     my ($typeScope, $allDictionaries) = @_;
2482 
2483     my $result = &quot;&quot;;
2484     foreach my $dictionary (@$allDictionaries) {
2485         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2486         $result .= GenerateDictionaryImplementationContent($dictionary, $className, $typeScope);
2487     }
2488     return $result;
2489 }
2490 
2491 sub GetJSTypeForNode
2492 {
2493     my ($interface) = @_;
2494 
2495     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Document&quot;)) {
2496         return &quot;JSDocumentWrapperType&quot;;
2497     }
2498     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentFragment&quot;)) {
2499         return &quot;JSDocumentFragmentNodeType&quot;;
2500     }
2501     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentType&quot;)) {
2502         return &quot;JSDocumentTypeNodeType&quot;;
2503     }
2504     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;ProcessingInstruction&quot;)) {
2505         return &quot;JSProcessingInstructionNodeType&quot;;
2506     }
2507     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;CDATASection&quot;)) {
2508         return &quot;JSCDATASectionNodeType&quot;;
2509     }
2510     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Attr&quot;)) {
2511         return &quot;JSAttrNodeType&quot;;
2512     }
2513     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Comment&quot;)) {
2514         return &quot;JSCommentNodeType&quot;;
2515     }
2516     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Text&quot;)) {
2517         return &quot;JSTextNodeType&quot;;
2518     }
2519     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Element&quot;)) {
2520         return &quot;JSElementType&quot;;
2521     }
2522     return &quot;JSNodeType&quot;;
2523 }
2524 
2525 sub GenerateHeader
2526 {
2527     my ($object, $interface, $enumerations, $dictionaries) = @_;
2528 
2529     my $interfaceName = $interface-&gt;type-&gt;name;
2530     my $className = &quot;JS$interfaceName&quot;;
2531     my %structureFlags = ();
2532 
2533     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
2534     my $parentClassName = GetParentClassName($interface);
2535     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
2536 
2537     # - Add default header template and header protection
2538     push(@headerContentHeader, GenerateHeaderContentHeader($interface));
2539 
2540     if ($hasParent) {
2541         $headerIncludes{&quot;$parentClassName.h&quot;} = 1;
2542     } else {
2543         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
2544         if ($interface-&gt;isException) {
2545             $headerIncludes{&quot;&lt;JavaScriptCore/ErrorPrototype.h&gt;&quot;} = 1;
2546         }
2547     }
2548 
2549     $headerIncludes{&quot;SVGElement.h&quot;} = 1 if $className =~ /^JSSVG/;
2550 
2551     my $implType = GetImplClassName($interface);
2552 
2553     my $numConstants = @{$interface-&gt;constants};
2554     my $numAttributes = @{$interface-&gt;attributes};
2555     my $numOperations = @{$interface-&gt;operations};
2556 
2557     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2558 
2559     if ($codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type)) {
2560         $headerIncludes{&quot;SVGAnimatedPropertyImpl.h&quot;} = 1;
2561     } elsif ($codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {
2562         $headerIncludes{&quot;SVGPathSegImpl.h&quot;} = 1;
2563     } else {
2564         $headerIncludes{&quot;$interfaceName.h&quot;} = 1 if $hasParent &amp;&amp; $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};
2565         # Implementation class forward declaration
2566         if (IsDOMGlobalObject($interface)) {
2567             AddClassForwardIfNeeded($interface-&gt;type);
2568         }
2569     }
2570 
2571     push(@headerContent, &quot;class JSWindowProxy;\n\n&quot;) if $interfaceName eq &quot;DOMWindow&quot; or $interfaceName eq &quot;RemoteDOMWindow&quot;;
2572 
2573     my $exportMacro = GetExportMacroForJSClass($interface);
2574 
2575     # Class declaration
2576     push(@headerContent, &quot;class $exportMacro$className : public $parentClassName {\n&quot;);
2577 
2578     # Static create methods
2579     push(@headerContent, &quot;public:\n&quot;);
2580     push(@headerContent, &quot;    using Base = $parentClassName;\n&quot;);
2581     push(@headerContent, &quot;    using DOMWrapped = $implType;\n&quot;) if $hasParent;
2582 
2583     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2584         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
2585         push(@headerContent, &quot;    {\n&quot;);
2586         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl), proxy);\n&quot;);
2587         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2588         push(@headerContent, &quot;        return ptr;\n&quot;);
2589         push(@headerContent, &quot;    }\n\n&quot;);
2590     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2591         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSC::JSProxy* proxy)\n&quot;);
2592         push(@headerContent, &quot;    {\n&quot;);
2593         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl));\n&quot;);
2594         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2595         push(@headerContent, &quot;        return ptr;\n&quot;);
2596         push(@headerContent, &quot;    }\n\n&quot;);
2597     } elsif ($interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined}) {
2598         AddIncludesForImplementationTypeInHeader($implType);
2599         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2600         push(@headerContent, &quot;    {\n&quot;);
2601         push(@headerContent, &quot;        globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), \&quot;Allocated masquerading object\&quot;);\n&quot;);
2602         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2603         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2604         push(@headerContent, &quot;        return ptr;\n&quot;);
2605         push(@headerContent, &quot;    }\n\n&quot;);
2606     } elsif (!NeedsImplementationClass($interface)) {
2607         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2608         push(@headerContent, &quot;    {\n&quot;);
2609         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2610         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2611         push(@headerContent, &quot;        return ptr;\n&quot;);
2612         push(@headerContent, &quot;    }\n\n&quot;);  
2613     } else {
2614         if (!$codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type) &amp;&amp; !$codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {
2615             AddIncludesForImplementationTypeInHeader($implType);
2616         }
2617         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2618         push(@headerContent, &quot;    {\n&quot;);
2619         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2620         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2621         push(@headerContent, &quot;        return ptr;\n&quot;);
2622         push(@headerContent, &quot;    }\n\n&quot;);
2623     }
2624 
2625     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2626     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2627     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2628     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2629     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2630         
2631     # Prototype
2632     unless (ShouldUseGlobalObjectPrototype($interface)) {
2633         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2634         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2635     }
2636 
2637     # JSValue to implementation type
2638     if (ShouldGenerateToWrapped($hasParent, $interface)) {
2639         # FIXME: Add extended attribute for this.
2640         my @toWrappedArguments = ();
2641         push(@toWrappedArguments, &quot;JSC::VM&amp;&quot;);
2642         push(@toWrappedArguments, &quot;JSC::JSGlobalObject&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;
2643         push(@toWrappedArguments, &quot;JSC::JSValue&quot;);
2644 
2645         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
2646 
2647         my $export = &quot;&quot;;
2648         $export = &quot;WEBCORE_EXPORT &quot; if $interface-&gt;extendedAttributes-&gt;{ExportToWrappedFunction};
2649         push(@headerContent, &quot;    static ${export}${toWrappedType} toWrapped(&quot; . join(&quot;, &quot;, @toWrappedArguments) . &quot;);\n&quot;);
2650     }
2651 
2652     $headerTrailingIncludes{&quot;${className}Custom.h&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomHeader};
2653 
2654     my $namedGetterOperation = GetNamedGetterOperation($interface);
2655     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2656 
2657     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2658     if ($namedGetterOperation) {
2659         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2660             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2661         } else {
2662             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2663         }
2664     }
2665     
2666     # ClassInfo MethodTable declarations.
2667     
2668     if (InstanceOverridesGetOwnPropertySlot($interface)) {
2669         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);
2670         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
2671         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::JSGlobalObject*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);
2672         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2673     }
2674 
2675     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
2676         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);
2677         $structureFlags{&quot;JSC::HasPutPropertySecurityCheck&quot;} = 1;
2678     }
2679 
2680     if ($interface-&gt;extendedAttributes-&gt;{Plugin} || GetNamedSetterOperation($interface)) {
2681         $structureFlags{&quot;JSC::ProhibitsPropertyCaching&quot;} = 1;
2682     }
2683     
2684     if (InstanceOverridesGetOwnPropertyNames($interface)) {
2685         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);
2686         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2687     }
2688     
2689     if (InstanceOverridesPut($interface)) {
2690         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
2691         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);
2692     }
2693     
2694     if (InstanceOverridesDefineOwnProperty($interface)) {
2695         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
2696     }
2697 
2698     if (InstanceOverridesDeleteProperty($interface)) {
2699         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName);\n&quot;);
2700         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned);\n&quot;);
2701     }
2702 
2703     if (InstanceOverridesGetCallData($interface)) {
2704         push(@headerContent, &quot;    static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&amp;);\n\n&quot;);
2705         $headerIncludes{&quot;&lt;JavaScriptCore/CallData.h&gt;&quot;} = 1;
2706         $structureFlags{&quot;JSC::OverridesGetCallData&quot;} = 1;
2707     }
2708     
2709     if ($interface-&gt;extendedAttributes-&gt;{CustomGetPrototype}) {
2710         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);
2711     }
2712     
2713     if ($interface-&gt;extendedAttributes-&gt;{CustomToStringName}) {
2714         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);
2715     }
2716     
2717     if ($interface-&gt;extendedAttributes-&gt;{CustomPreventExtensions}) {
2718         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);
2719     }
2720 
2721     if (InstanceNeedsEstimatedSize($interface)) {
2722         push(@headerContent, &quot;    static size_t estimatedSize(JSCell*, JSC::VM&amp;);\n&quot;);
2723     }
2724     
2725     if (!$hasParent) {
2726         push(@headerContent, &quot;    static void destroy(JSC::JSCell*);\n&quot;);
2727     }
2728 
2729     # Class info
2730     if ($interfaceName eq &quot;Node&quot;) {
2731         push(@headerContent, &quot;\n&quot;);
2732         push(@headerContent, &quot;protected:\n&quot;);
2733         push(@headerContent, &quot;    static const JSC::ClassInfo s_info;\n&quot;);
2734         push(@headerContent, &quot;public:\n&quot;);
2735         push(@headerContent, &quot;    static constexpr const JSC::ClassInfo* info() { return &amp;s_info; }\n\n&quot;);
2736     } else {
2737         push(@headerContent, &quot;\n&quot;);
2738         push(@headerContent, &quot;    DECLARE_INFO;\n\n&quot;);
2739     }
2740 
2741     # Structure ID
2742     push(@headerContent, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
2743     push(@headerContent, &quot;    {\n&quot;);
2744     if (IsDOMGlobalObject($interface)) {
2745         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());\n&quot;);
2746     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2747         my $type = GetJSTypeForNode($interface);
2748         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info());\n&quot;);
2749     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Event&quot;)) {
2750         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info());\n&quot;);
2751     } else {
2752         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
2753     }
2754     push(@headerContent, &quot;    }\n\n&quot;);
2755 
2756     # Custom pushEventHandlerScope function
2757     if ($interface-&gt;extendedAttributes-&gt;{CustomPushEventHandlerScope}) {
2758         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::JSGlobalObject*, JSC::JSScope*) const;\n\n&quot;);
2759     }
2760     
2761     # Constructor object getter
2762     unless ($interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
2763         push(@headerContent, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;);
2764         push(@headerContent, &quot;    static JSC::JSValue getNamedConstructor(JSC::VM&amp;, JSC::JSGlobalObject*);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
2765     }
2766 
2767     # Serializer function.
2768     if ($interface-&gt;serializable) {
2769         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::JSGlobalObject&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);
2770     }
2771     
2772     my $numCustomOperations = 0;
2773     my $numCustomAttributes = 0;
2774 
2775     my $hasForwardDeclaringOperations = 0;
2776     my $hasForwardDeclaringAttributes = 0;
2777 
2778     my $hasDOMJITAttributes = 0;
2779 
2780     # Attribute and function enums
2781     if ($numAttributes &gt; 0) {
2782         foreach my $attribute (@{$interface-&gt;attributes}) {
2783             $numCustomAttributes++ if HasCustomGetter($attribute);
2784             $numCustomAttributes++ if HasCustomSetter($attribute);
2785             if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
2786                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2787                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2788                 push(@headerContent, &quot;    mutable JSC::WriteBarrier&lt;JSC::Unknown&gt; m_&quot; . $attribute-&gt;name . &quot;;\n&quot;);
2789                 $numCachedAttributes++;
2790                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2791             }
2792             $hasDOMJITAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
2793 
2794             $hasForwardDeclaringAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2795         }
2796     }
2797 
2798     # FIXME: We put this unconditionally to put all the WebCore JS wrappers in each IsoSubspace.
2799     # https://bugs.webkit.org/show_bug.cgi?id=205107
2800     if (IsDOMGlobalObject($interface)) {
2801         push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::IsoSubspace* subspaceFor(JSC::VM&amp; vm) { return subspaceForImpl(vm); }\n&quot;);
2802         push(@headerContent, &quot;    static JSC::IsoSubspace* subspaceForImpl(JSC::VM&amp; vm);\n&quot;);
2803     }
2804 
2805     # visit function
2806     if ($needsVisitChildren) {
2807         push(@headerContent, &quot;    static void visitChildren(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2808         push(@headerContent, &quot;    void visitAdditionalChildren(JSC::SlotVisitor&amp;);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
2809         push(@headerContent, &quot;\n&quot;);
2810 
2811         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2812             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2813             # concurrent GC or in between eden GCs something may happen that would lead to this
2814             # logic behaving differently. Since this could mark objects or add opaque roots, this
2815             # means that after any increment of mutator resumption in a concurrent GC and at least
2816             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2817             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2818             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2819             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2820             # that the GC calls to ask an object is it would like to mark anything else after the
2821             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2822             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2823             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2824             if (!IsDOMGlobalObject($interface)) {
2825                 push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return outputConstraintSubspaceFor(vm); }\n&quot;);
2826             }
2827         }
2828     }
2829 
2830     if (NeedsImplementationClass($interface)) {
2831         push(@headerContent, &quot;    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&amp;);\n&quot;);
2832     }
2833     
2834     if ($numCustomAttributes &gt; 0) {
2835         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2836 
2837         foreach my $attribute (@{$interface-&gt;attributes}) {
2838             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2839             if (HasCustomGetter($attribute)) {
2840                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2841                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
2842                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::JSGlobalObject&amp;) const;\n&quot;);
2843                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2844             }
2845             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2846                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2847                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;);
2848                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2849             }
2850         }
2851     }
2852 
2853     foreach my $operation (@{$interface-&gt;operations}) {
2854         $numCustomOperations++ if HasCustomMethod($operation);
2855         $hasForwardDeclaringOperations = 1 if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2856     }
2857 
2858     if ($numCustomOperations &gt; 0) {
2859         my $inAppleCopyright = 0;
2860         push(@headerContent, &quot;\n    // Custom functions\n&quot;);
2861         foreach my $operation (@{$interface-&gt;operations}) {
2862             next unless HasCustomMethod($operation);
2863             next if $operation-&gt;{overloads} &amp;&amp; $operation-&gt;{overloadIndex} != 1;
2864 
2865             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2866                 if (!$inAppleCopyright) {
2867                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2868                     $inAppleCopyright = 1;
2869                 }
2870             } elsif ($inAppleCopyright) {
2871                 push(@headerContent, $endAppleCopyright);
2872                 $inAppleCopyright = 0;
2873             }
2874 
2875             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
2876             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2877 
2878             my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
2879 
2880             my @functionArguments = ();
2881             push(@functionArguments, &quot;JSC::JSGlobalObject&amp;&quot;);
2882             push(@functionArguments, &quot;JSC::CallFrame&amp;&quot;);
2883             push(@functionArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp;&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
2884 
2885             push(@headerContent, &quot;    &quot; . ($operation-&gt;isStatic ? &quot;static &quot; : &quot;&quot;) . &quot;JSC::JSValue &quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @functionArguments) . &quot;);\n&quot;);
2886 
2887             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2888         }
2889         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2890     }
2891 
2892     if (NeedsImplementationClass($interface)) {
2893         if ($hasParent) {
2894             push(@headerContent, &quot;    $interfaceName&amp; wrapped() const\n&quot;);
2895             push(@headerContent, &quot;    {\n&quot;);
2896             push(@headerContent, &quot;        return static_cast&lt;$interfaceName&amp;&gt;(Base::wrapped());\n&quot;);
2897             push(@headerContent, &quot;    }\n&quot;);
2898         }
2899     }
2900 
2901     # structure flags
2902     if (%structureFlags) {
2903         push(@headerContent, &quot;public:\n&quot;);
2904         push(@headerContent, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);
2905         foreach my $structureFlag (sort (keys %structureFlags)) {
2906             push(@headerContent, &quot; | &quot; . $structureFlag);
2907         }
2908         push(@headerContent, &quot;;\n&quot;);
2909     }
2910 
2911     push(@headerContent, &quot;protected:\n&quot;);
2912 
2913     # Constructor
2914     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2915         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;, JSWindowProxy*);\n&quot;);
2916     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2917         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2918     } elsif (!NeedsImplementationClass($interface)) {
2919         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;);\n\n&quot;);
2920      } else {
2921         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;, Ref&lt;$implType&gt;&amp;&amp;);\n\n&quot;);
2922     }
2923 
2924     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2925         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSWindowProxy*);\n&quot;);
2926     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2927         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSC::JSProxy*);\n&quot;);
2928     } else {
2929         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
2930     }
2931 
2932     push(@headerContent, &quot;};\n\n&quot;);
2933 
2934     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface)) {
2935         if ($interfaceName ne &quot;Node&quot; &amp;&amp; $codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2936             $headerIncludes{&quot;JSNode.h&quot;} = 1;
2937             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSNodeOwner {\n&quot;);
2938         } else {
2939             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSC::WeakHandleOwner {\n&quot;);
2940         }
2941         $headerIncludes{&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;} = 1;
2942         push(@headerContent, &quot;public:\n&quot;);
2943         push(@headerContent, &quot;    virtual bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt;, void* context, JSC::SlotVisitor&amp;, const char**);\n&quot;);
2944         push(@headerContent, &quot;    virtual void finalize(JSC::Handle&lt;JSC::Unknown&gt;, void* context);\n&quot;);
2945         push(@headerContent, &quot;};\n&quot;);
2946         push(@headerContent, &quot;\n&quot;);
2947         push(@headerContent, &quot;inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, $implType*)\n&quot;);
2948         push(@headerContent, &quot;{\n&quot;);
2949         push(@headerContent, &quot;    static NeverDestroyed&lt;JS${interfaceName}Owner&gt; owner;\n&quot;);
2950         push(@headerContent, &quot;    return &amp;owner.get();\n&quot;);
2951         push(@headerContent, &quot;}\n&quot;);
2952         push(@headerContent, &quot;\n&quot;);
2953         push(@headerContent, &quot;inline void* wrapperKey($implType* wrappableObject)\n&quot;);
2954         push(@headerContent, &quot;{\n&quot;);
2955         push(@headerContent, &quot;    return wrappableObject;\n&quot;);
2956         push(@headerContent, &quot;}\n&quot;);
2957         push(@headerContent, &quot;\n&quot;);
2958     }
2959     if (ShouldGenerateToJSDeclaration($hasParent, $interface)) {
2960         # Node and NodeList have custom inline implementations which thus cannot be exported.
2961         # FIXME: The special case for Node and NodeList should probably be implemented via an IDL attribute.
2962         if ($implType eq &quot;Node&quot; or $implType eq &quot;NodeList&quot;) {
2963             push(@headerContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2964         } else {
2965             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2966         }
2967         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(lexicalGlobalObject, globalObject, *impl) : JSC::jsNull(); }\n&quot;);
2968 
2969         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2970         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(lexicalGlobalObject, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);
2971    }
2972 
2973     push(@headerContent, &quot;\n&quot;);
2974 
2975     GeneratePrototypeDeclaration(\@headerContent, $className, $interface) if HeaderNeedsPrototypeDeclaration($interface);
2976 
2977     if ($hasForwardDeclaringOperations) {
2978         my $inAppleCopyright = 0;
2979         push(@headerContent,&quot;// Functions\n\n&quot;);
2980         foreach my $operation (@{$interface-&gt;operations}) {
2981             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
2982             next unless $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2983 
2984             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2985                 if (!$inAppleCopyright) {
2986                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2987                     $inAppleCopyright = 1;
2988                 }
2989             } elsif ($inAppleCopyright) {
2990                 push(@headerContent, $endAppleCopyright);
2991                 $inAppleCopyright = 0;
2992             }
2993 
2994             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
2995             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
2996             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2997             my $functionName = GetFunctionName($interface, $className, $operation);
2998             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);
2999             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3000         }
3001 
3002         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
3003         push(@headerContent,&quot;\n&quot;);
3004     }
3005 
3006     if ($hasForwardDeclaringAttributes) {
3007         push(@headerContent,&quot;// Attributes\n\n&quot;);
3008         foreach my $attribute (@{$interface-&gt;attributes}) {
3009             next unless $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3010 
3011             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
3012             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3013             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3014             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
3015             if (!IsReadonly($attribute)) {
3016                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
3017                 push(@headerContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
3018             }
3019             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3020         }
3021     }
3022 
3023     # CheckSubClass Snippet function.
3024     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
3025         $headerIncludes{&quot;&lt;JavaScriptCore/Snippet.h&gt;&quot;} = 1;
3026         push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3027         push(@headerContent, &quot;Ref&lt;JSC::Snippet&gt; checkSubClassSnippetFor${className}();\n&quot;);
3028         push(@headerContent, &quot;#endif\n&quot;);
3029     }
3030 
3031     if ($hasDOMJITAttributes) {
3032         $headerIncludes{&quot;&lt;JavaScriptCore/DOMJITGetterSetter.h&gt;&quot;} = 1;
3033         push(@headerContent,&quot;// DOM JIT Attributes\n\n&quot;);
3034         foreach my $attribute (@{$interface-&gt;attributes}) {
3035             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
3036             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
3037 
3038             my $interfaceName = $interface-&gt;type-&gt;name;
3039             my $className = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
3040             my $domJITClassName = $className . &quot;Attribute&quot;;
3041 
3042             push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3043             push(@headerContent, &quot;Ref&lt;JSC::DOMJIT::CallDOMGetterSnippet&gt; compile${domJITClassName}();\n&quot;);
3044             push(@headerContent, &quot;#endif\n\n&quot;);
3045         }
3046     }
3047 
3048     if (HasCustomConstructor($interface)) {
3049         push(@headerContent, &quot;// Custom constructor\n&quot;);
3050         push(@headerContent, &quot;JSC::EncodedJSValue construct${className}(JSC::JSGlobalObject*, JSC::CallFrame&amp;);\n\n&quot;);
3051     }
3052 
3053     if (NeedsImplementationClass($interface)) {
3054         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
3055         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
3056 
3057         push(@headerContent, &quot;template&lt;&gt; struct JSDOMWrapperConverterTraits&lt;${implType}&gt; {\n&quot;);
3058         push(@headerContent, &quot;    using WrapperClass = ${className};\n&quot;);
3059         push(@headerContent, &quot;    using ToWrappedReturnType = ${toWrappedType};\n&quot;);
3060         push(@headerContent, &quot;};\n&quot;);
3061     }
3062 
3063     push(@headerContent, GenerateEnumerationsHeaderContent($interface, $enumerations));
3064     push(@headerContent, GenerateDictionariesHeaderContent($interface, $dictionaries));
3065 
3066     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
3067     push(@headerContent, &quot;\n} // namespace WebCore\n&quot;);
3068     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
3069 
3070     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3071         push(@headerContent, &quot;\n&quot;);
3072         push(@headerContent, split(&quot;\r&quot;, $endAppleCopyright));
3073     }
3074 
3075     # - Generate dependencies.
3076     if ($writeDependencies) {
3077         my @ancestors;
3078         $codeGenerator-&gt;ForAllParents($interface, sub {
3079             my $currentInterface = shift;
3080             push(@ancestors, $currentInterface-&gt;type-&gt;name);
3081         }, 0);
3082         for my $dictionary (@$dictionaries) {
3083             my $parentType = $dictionary-&gt;parentType;
3084             while (defined($parentType)) {
3085                 push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
3086                 my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
3087                 assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
3088                 $parentType = $parentDictionary-&gt;parentType;
3089             }
3090         }
3091         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
3092         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
3093     }
3094 }
3095 
3096 sub GeneratePropertiesHashTable
3097 {
3098     my ($object, $interface, $isInstance, $hashKeys, $hashSpecials, $hashValue1, $hashValue2, $conditionals, $readWriteConditionals, $runtimeEnabledOperations, $runtimeEnabledAttributes) = @_;
3099 
3100     # FIXME: These should be functions on $interface.
3101     my $interfaceName = $interface-&gt;type-&gt;name;
3102     my $className = &quot;JS$interfaceName&quot;;
3103     
3104     # - Add all properties in a hashtable definition
3105     my $propertyCount = $isInstance ? InstancePropertyCount($interface) : PrototypePropertyCount($interface);
3106 
3107     if (!$isInstance &amp;&amp; NeedsConstructorProperty($interface)) {
3108         die if !$propertyCount;
3109         push(@$hashKeys, &quot;constructor&quot;);
3110         my $getter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3111         push(@$hashValue1, $getter);
3112 
3113         my $setter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3114         push(@$hashValue2, $setter);
3115         push(@$hashSpecials, &quot;static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum)&quot;);
3116     }
3117 
3118     return 0 if !$propertyCount;
3119 
3120     my @attributes = @{$interface-&gt;attributes};
3121     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3122     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;
3123 
3124     foreach my $attribute (@attributes) {
3125         next if ($attribute-&gt;isStatic);
3126         next if AttributeShouldBeOnInstance($interface, $attribute) != $isInstance;
3127         next if ($attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $attribute-&gt;extendedAttributes-&gt;{PublicIdentifier});
3128 
3129         # Global objects add RuntimeEnabled attributes after creation so do not add them to the static table.
3130         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $attribute)) {
3131             $propertyCount -= 1;
3132             next;
3133         }
3134 
3135         my $name = $attribute-&gt;name;
3136         push(@$hashKeys, $name);
3137 
3138         my $special = GetJSCAttributesForAttribute($interface, $attribute);
3139         push(@$hashSpecials, $special);
3140 
3141         if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
3142             push(@$hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
3143         } else {
3144             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3145             push(@$hashValue1, $getter);
3146         }
3147 
3148         if (IsReadonly($attribute)) {
3149             push(@$hashValue2, &quot;0&quot;);
3150         } else {
3151             my $setter = GetAttributeSetterName($interface, $className, $attribute);
3152             push(@$hashValue2, $setter);
3153         }
3154 
3155         my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
3156         $conditionals-&gt;{$name} = $conditional if $conditional;
3157         my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
3158         $readWriteConditionals-&gt;{$name} = $readWriteConditional if $readWriteConditional;
3159 
3160         my $needsRuntimeCheck = NeedsRuntimeCheck($interface, $attribute);
3161         my $needsRuntimeReadWriteCheck = $attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite};
3162 
3163         if ($needsRuntimeCheck &amp;&amp; $needsRuntimeReadWriteCheck) {
3164             die &quot;Being both runtime enabled and runtime conditionally read-write is not yet supported (used on the &#39;${name}&#39; attribute of &#39;${interfaceName}&#39;).\n&quot;;
3165         }
3166 
3167         if ($needsRuntimeCheck || $needsRuntimeReadWriteCheck) {
3168             push(@$runtimeEnabledAttributes, $attribute);
3169         }
3170     }
3171 
3172     my @operations = @{$interface-&gt;operations};
3173     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3174     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3175     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;
3176     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3177     foreach my $operation (@operations) {
3178         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
3179         next if ($operation-&gt;isStatic);
3180         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3181         next if OperationShouldBeOnInstance($interface, $operation) != $isInstance;
3182         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
3183 
3184         # Global objects add RuntimeEnabled operations after creation so do not add them to the static table.
3185         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $operation)) {
3186             $propertyCount -= 1;
3187             next;
3188         }
3189 
3190         my $name = $operation-&gt;name;
3191         push(@$hashKeys, $name);
3192 
3193         my $functionName = GetFunctionName($interface, $className, $operation);
3194         push(@$hashValue1, $functionName);
3195 
3196         my $functionLength = GetFunctionLength($operation);
3197 
3198         if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3199             push(@$hashValue2, &quot;&amp;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
3200         } else {
3201             push(@$hashValue2, $functionLength);
3202         }
3203 
3204         push(@$hashSpecials, ComputeFunctionSpecial($interface, $operation));
3205 
3206         my $conditional = GetConditionalForOperationConsideringOverloads($operation);
3207         $conditionals-&gt;{$name} = $conditional if $conditional;
3208 
3209         if (NeedsRuntimeCheck($interface, $operation)) {
3210             push(@$runtimeEnabledOperations, $operation);
3211         }
3212     }
3213 
3214     return $propertyCount;
3215 }
3216 
3217 # This computes an effective overload set for a given operation / constructor,
3218 # which represents the allowable invocations.This set is used as input for
3219 # the Web IDL overload resolution algorithm.
3220 # http://heycam.github.io/webidl/#dfn-effective-overload-set
3221 sub ComputeEffectiveOverloadSet
3222 {
3223     my ($overloads) = @_;
3224 
3225     my %allSets;
3226     my $addTuple = sub {
3227         my $tuple = shift;
3228         # The Web IDL specification uses a flat set of tuples but we use a hash where the key is the
3229         # number of parameters and the value is the set of tuples for the given number of parameters.
3230         my $length = scalar(@{@$tuple[1]});
3231         if (!exists($allSets{$length})) {
3232             $allSets{$length} = [ $tuple ];
3233         } else {
3234             push(@{$allSets{$length}}, $tuple);
3235         }
3236     };
3237 
3238     my $m = LengthOfLongestOperationParameterList($overloads);
3239     foreach my $overload (@{$overloads}) {
3240         my $n = @{$overload-&gt;arguments};
3241         my @t;
3242         my @o;
3243         my $isVariadic = 0;
3244         foreach my $argument (@{$overload-&gt;arguments}) {
3245             push(@t, $argument-&gt;type);
3246             if ($argument-&gt;isOptional) {
3247                 push(@o, &quot;optional&quot;);
3248             } elsif ($argument-&gt;isVariadic) {
3249                 push(@o, &quot;variadic&quot;);
3250                 $isVariadic = 1;
3251             } else {
3252                 push(@o, &quot;required&quot;);
3253             }
3254         }
3255         &amp;$addTuple([$overload, [@t], [@o]]);
3256         if ($isVariadic) {
3257             my @newT = @t;
3258             my @newO = @o;
3259             for (my $i = $n; $i &lt; $m; $i++) {
3260                 push(@newT, $t[-1]);
3261                 push(@newO, &quot;variadic&quot;);
3262                 &amp;$addTuple([$overload, [@newT], [@newO]]);
3263             }
3264         }
3265         for (my $i = $n - 1; $i &gt;= 0; $i--) {
3266             my $argument = @{$overload-&gt;arguments}[$i];
3267             last unless ($argument-&gt;isOptional || $argument-&gt;isVariadic);
3268             pop(@t);
3269             pop(@o);
3270             &amp;$addTuple([$overload, [@t], [@o]]);
3271         }
3272     }
3273     return %allSets;
3274 }
3275 
3276 sub IsIDLTypeDistinguishableWithUnionForOverloadResolution
3277 {
3278     my ($type, $unionSubtypes) = @_;
3279 
3280     assert(&quot;First type should not be a union&quot;) if $type-&gt;isUnion;
3281     for my $unionSubType (@$unionSubtypes) {
3282         return 0 unless AreTypesDistinguishableForOverloadResolution($type, $unionSubType);
3283     }
3284     return 1;
3285 }
3286 
3287 # Determines if two types are distinguishable in the context of overload resolution,
3288 # according to the Web IDL specification:
3289 # http://heycam.github.io/webidl/#dfn-distinguishable
3290 sub AreTypesDistinguishableForOverloadResolution
3291 {
3292     my ($typeA, $typeB) = @_;
3293 
3294     my $isCallbackFunctionOrDictionary = sub {
3295         my $type = shift;
3296         return $codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsDictionaryType($type);
3297     };
3298 
3299     # Two types are distinguishable for overload resolution if at most one of the two includes a nullable type.
3300     return 0 if $typeA-&gt;isNullable &amp;&amp; $typeB-&gt;isNullable;
3301 
3302     # Union types: typeA and typeB  are distinguishable if:
3303     # - Both types are either a union type or nullable union type, and each member type of the one is
3304     #   distinguishable with each member type of the other.
3305     # - One type is a union type or nullable union type, the other is neither a union type nor a nullable
3306     #   union type, and each member type of the first is distinguishable with the second.
3307     if ($typeA-&gt;isUnion &amp;&amp; $typeB-&gt;isUnion) {
3308         for my $unionASubType (@{$typeA-&gt;subtypes}) {
3309             return 0 unless IsIDLTypeDistinguishableWithUnionForOverloadResolution($unionASubType, $typeB-&gt;subtypes);
3310         }
3311         return 1;
3312     } elsif ($typeA-&gt;isUnion) {
3313         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeB, $typeA-&gt;subtypes);
3314     } elsif ($typeB-&gt;isUnion) {
3315         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeA, $typeB-&gt;subtypes);
3316     }
3317 
3318     return 0 if $typeA-&gt;name eq $typeB-&gt;name;
3319     return 0 if $typeA-&gt;name eq &quot;object&quot; or $typeB-&gt;name eq &quot;object&quot;;
3320     return 0 if $codeGenerator-&gt;IsNumericType($typeA) &amp;&amp; $codeGenerator-&gt;IsNumericType($typeB);
3321     return 0 if $codeGenerator-&gt;IsStringOrEnumType($typeA) &amp;&amp; $codeGenerator-&gt;IsStringOrEnumType($typeB);
3322     return 0 if $codeGenerator-&gt;IsDictionaryType($typeA) &amp;&amp; $codeGenerator-&gt;IsDictionaryType($typeB);
3323     return 0 if $codeGenerator-&gt;IsCallbackInterface($typeA) &amp;&amp; $codeGenerator-&gt;IsCallbackInterface($typeB);
3324     return 0 if &amp;$isCallbackFunctionOrDictionary($typeA) &amp;&amp; &amp;$isCallbackFunctionOrDictionary($typeB);
3325     return 0 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeA) &amp;&amp; $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeB);
3326     # FIXME: return 0 if $typeA and $typeB are both exception types.
3327     return 1;
3328 }
3329 
3330 # If there is more than one entry in an effective overload set that has a given type list length,
3331 # then for those entries there must be an index i such that for each pair of entries the types
3332 # at index i are distinguishable. The lowest such index is termed the distinguishing argument index.
3333 # http://heycam.github.io/webidl/#dfn-distinguishing-argument-index
3334 sub GetDistinguishingArgumentIndex
3335 {
3336     my ($operation, $S) = @_;
3337 
3338     # FIXME: Consider all the tuples, not just the 2 first ones?
3339     my $firstTupleTypes = @{@{$S}[0]}[1];
3340     my $secondTupleTypes = @{@{$S}[1]}[1];
3341     for (my $index = 0; $index &lt; scalar(@$firstTupleTypes); $index++) {
3342         return $index if AreTypesDistinguishableForOverloadResolution(@{$firstTupleTypes}[$index], @{$secondTupleTypes}[$index]);
3343     }
3344     die &quot;Undistinguishable overloads for operation &quot; . $operation-&gt;name . &quot; with length: &quot; . scalar(@$firstTupleTypes);
3345 }
3346 
3347 sub GetOverloadThatMatches
3348 {
3349     my ($S, $parameterIndex, $matches) = @_;
3350 
3351     for my $tuple (@{$S}) {
3352         my $type = @{@{$tuple}[1]}[$parameterIndex];
3353         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3354         if ($type-&gt;isUnion) {
3355             for my $subtype (GetFlattenedMemberTypes($type)) {
3356                 return @{$tuple}[0] if $matches-&gt;($subtype, $optionality);
3357             }
3358         } else {
3359             return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3360         }
3361     }
3362 }
3363 
3364 sub GetOverloadThatMatchesIgnoringUnionSubtypes
3365 {
3366     my ($S, $parameterIndex, $matches) = @_;
3367 
3368     for my $tuple (@{$S}) {
3369         my $type = @{@{$tuple}[1]}[$parameterIndex];
3370         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3371         return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3372     }
3373 }
3374 
3375 sub GetConditionalForOperationConsideringOverloads
3376 {
3377     my $operation = shift;
3378 
3379     return $operation-&gt;extendedAttributes-&gt;{Conditional} unless $operation-&gt;{overloads};
3380 
3381     my %conditions;
3382     foreach my $overload (@{$operation-&gt;{overloads}}) {
3383         my $conditional = $overload-&gt;extendedAttributes-&gt;{Conditional};
3384         return unless $conditional;
3385         $conditions{$conditional} = 1;
3386     }
3387     return join(&quot;|&quot;, keys %conditions);
3388 }
3389 
3390 # Implements the overload resolution algorithm, as defined in the Web IDL specification:
3391 # http://heycam.github.io/webidl/#es-overloads
3392 sub GenerateOverloadDispatcher
3393 {
3394     my ($operation, $interface, $overloadFunctionPrefix, $overloadFunctionSuffix, $parametersToForward) = @_;
3395     
3396     my %allSets = ComputeEffectiveOverloadSet($operation-&gt;{overloads});
3397 
3398     my $generateOverloadCallIfNecessary = sub {
3399         my ($overload, $condition, $include) = @_;
3400         return unless $overload;
3401         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($overload);
3402         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3403         push(@implContent, &quot;        if ($condition)\n    &quot;) if $condition;
3404         push(@implContent, &quot;        return &quot; . $overloadFunctionPrefix . $overload-&gt;{overloadIndex} . $overloadFunctionSuffix . &quot;(${parametersToForward});\n&quot;);
3405         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3406         AddToImplIncludes($include, $overload-&gt;extendedAttributes-&gt;{Conditional}) if $include;
3407     };
3408     my $isOptionalParameter = sub {
3409         my ($type, $optionality) = @_;
3410         return $optionality eq &quot;optional&quot;;
3411     };
3412     my $isDictionaryOrRecordParameter = sub {
3413         my ($type, $optionality) = @_;
3414         return $codeGenerator-&gt;IsDictionaryType($type) || $codeGenerator-&gt;IsRecordType($type);
3415     };
3416     my $isNullableOrDictionaryOrRecordOrUnionContainingOne = sub {
3417         my ($type, $optionality) = @_;
3418         return 1 if $type-&gt;isNullable;
3419         if ($type-&gt;isUnion) {
3420             for my $subtype (GetFlattenedMemberTypes($type)) {
3421                 return 1 if $type-&gt;isNullable || &amp;$isDictionaryOrRecordParameter($subtype, $optionality);
3422             }
3423             return 0;
3424         } else {
3425             return &amp;$isDictionaryOrRecordParameter($type, $optionality);
3426         }
3427     };
3428     my $isObjectOrErrorParameter = sub {
3429         my ($type, $optionality) = @_;
3430         return $type-&gt;name eq &quot;object&quot; || $type-&gt;name eq &quot;Error&quot;;
3431     };
3432     my $isObjectOrErrorOrDOMExceptionParameter = sub {
3433         my ($type, $optionality) = @_;
3434         return 1 if &amp;$isObjectOrErrorParameter($type, $optionality);
3435         return $type-&gt;name eq &quot;DOMException&quot;;
3436     };
3437     my $isObjectOrCallbackFunctionParameter = sub {
3438         my ($type, $optionality) = @_;
3439         return $type-&gt;name eq &quot;object&quot; || $codeGenerator-&gt;IsCallbackFunction($type);
3440     };
3441     my $isSequenceOrFrozenArrayParameter = sub {
3442         my ($type, $optionality) = @_;
3443         return $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
3444     };
3445     my $isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter = sub {
3446         my ($type, $optionality) = @_;
3447         return 1 if &amp;$isDictionaryOrRecordParameter($type, $optionality);
3448         return 1 if $type-&gt;name eq &quot;object&quot;;
3449         return 1 if $codeGenerator-&gt;IsCallbackInterface($type) &amp;&amp; !$codeGenerator-&gt;IsCallbackFunction($type);
3450         return 0;
3451     };
3452     my $isBooleanParameter = sub {
3453         my ($type, $optionality) = @_;
3454         return $type-&gt;name eq &quot;boolean&quot;;
3455     };
3456     my $isNumericParameter = sub {
3457         my ($type, $optionality) = @_;
3458         return $codeGenerator-&gt;IsNumericType($type);
3459     };
3460     my $isStringOrEnumParameter = sub {
3461         my ($type, $optionality) = @_;
3462         return $codeGenerator-&gt;IsStringOrEnumType($type);
3463     };
3464     my $isAnyParameter = sub {
3465         my ($type, $optionality) = @_;
3466         return $type-&gt;name eq &quot;any&quot;;
3467     };
3468 
3469     my $maxArgCount = LengthOfLongestOperationParameterList($operation-&gt;{overloads});
3470 
3471     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, callFrame-&gt;argumentCount());\n&quot;);
3472 
3473     for my $length ( sort keys %allSets ) {
3474         push(@implContent, &quot;    if (argsCount == ${length}) {\n&quot;);
3475 
3476         my $S = $allSets{$length};
3477         if (scalar(@$S) &gt; 1) {
3478             my $d = GetDistinguishingArgumentIndex($operation, $S);
3479             push(@implContent, &quot;        JSValue distinguishingArg = callFrame-&gt;uncheckedArgument($d);\n&quot;);
3480 
3481             my $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isOptionalParameter);
3482             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefined()&quot;);
3483 
3484             $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isNullableOrDictionaryOrRecordOrUnionContainingOne);
3485             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefinedOrNull()&quot;);
3486 
3487             for my $tuple (@{$S}) {
3488                 my $overload = @{$tuple}[0];
3489                 my $type = @{@{$tuple}[1]}[$d];
3490 
3491                 my @subtypes = $type-&gt;isUnion ? GetFlattenedMemberTypes($type) : ( $type );
3492                 for my $subtype (@subtypes) {
3493                     if ($codeGenerator-&gt;IsWrapperType($subtype) || $codeGenerator-&gt;IsBufferSourceType($subtype)) {
3494                         if ($subtype-&gt;name eq &quot;DOMWindow&quot;) {
3495                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3496                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSDOMWindow&gt;(vm))&quot;);
3497                         } elsif ($subtype-&gt;name eq &quot;RemoteDOMWindow&quot;) {
3498                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3499                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSRemoteDOMWindow&gt;(vm))&quot;);
3500                         } else {
3501                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JS&quot; . $subtype-&gt;name . &quot;&gt;(vm)&quot;);
3502                         }
3503                     }
3504                 }
3505             }
3506 
3507             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorOrDOMExceptionParameter);
3508             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JSDOMException&gt;(vm)&quot;);
3509 
3510             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorParameter);
3511             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;type() == ErrorInstanceType&quot;);
3512 
3513             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrCallbackFunctionParameter);
3514             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isFunction(vm)&quot;);
3515 
3516             # FIXME: Avoid invoking GetMethod(object, Symbol.iterator) again in convert&lt;IDLSequence&lt;T&gt;&gt;(...).
3517             $overload = GetOverloadThatMatches($S, $d, \&amp;$isSequenceOrFrozenArrayParameter);
3518             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(lexicalGlobalObject, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);
3519 
3520             $overload = GetOverloadThatMatches($S, $d, \&amp;$isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter);
3521             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject()&quot;);
3522 
3523             my $booleanOverload = GetOverloadThatMatches($S, $d, \&amp;$isBooleanParameter);
3524             &amp;$generateOverloadCallIfNecessary($booleanOverload, &quot;distinguishingArg.isBoolean()&quot;);
3525 
3526             my $numericOverload = GetOverloadThatMatches($S, $d, \&amp;$isNumericParameter);
3527             &amp;$generateOverloadCallIfNecessary($numericOverload, &quot;distinguishingArg.isNumber()&quot;);
3528 
3529             # Fallbacks.
3530             $overload = GetOverloadThatMatches($S, $d, \&amp;$isStringOrEnumParameter);
3531             if ($overload) {
3532                 &amp;$generateOverloadCallIfNecessary($overload);
3533             } elsif ($numericOverload) {
3534                 &amp;$generateOverloadCallIfNecessary($numericOverload);
3535             } elsif ($booleanOverload) {
3536                 &amp;$generateOverloadCallIfNecessary($booleanOverload);
3537             } else {
3538                 $overload = GetOverloadThatMatches($S, $d, \&amp;$isAnyParameter);
3539                 &amp;$generateOverloadCallIfNecessary($overload);
3540             }
3541         } else {
3542             # Only 1 overload with this number of parameters.
3543             my $overload = @{@{$S}[0]}[0];
3544             &amp;$generateOverloadCallIfNecessary($overload);
3545         }
3546         push(@implContent, &lt;&lt;END);
3547     }
3548 END
3549     }
3550     my $minArgCount = GetFunctionLength($operation);
3551     if ($minArgCount &gt; 0) {
3552         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)
3553     } else {
3554         push(@implContent, &quot;    return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)
3555     }
3556 }
3557 
3558 # As per Web IDL specification, the length of a function Object is its number of mandatory parameters.
3559 sub GetFunctionLength
3560 {
3561     my $operation = shift;
3562 
3563     my $getOverloadLength = sub {
3564         my $operation = shift;
3565 
3566         my $length = 0;
3567         foreach my $argument (@{$operation-&gt;arguments}) {
3568             last if $argument-&gt;isOptional || $argument-&gt;isVariadic;
3569             $length++;
3570         }
3571         return $length;
3572     };
3573 
3574     my $length = &amp;$getOverloadLength($operation);
3575     foreach my $overload (@{$operation-&gt;{overloads}}) {
3576         my $newLength = &amp;$getOverloadLength($overload);
3577         $length = $newLength if $newLength &lt; $length;
3578     }
3579     return $length;
3580 }
3581 
3582 sub LengthOfLongestOperationParameterList
3583 {
3584     my ($overloads) = @_;
3585     my $result = 0;
3586     foreach my $overload (@{$overloads}) {
3587         my @arguments = @{$overload-&gt;arguments};
3588         $result = @arguments if $result &lt; @arguments;
3589     }
3590     return $result;
3591 }
3592 
3593 # See http://refspecs.linux-foundation.org/cxxabi-1.83.html.
3594 sub GetGnuVTableRefForInterface
3595 {
3596     my $interface = shift;
3597     my $vtableName = GetGnuVTableNameForInterface($interface);
3598     if (!$vtableName) {
3599         return &quot;0&quot;;
3600     }
3601     my $typename = $interface-&gt;type-&gt;name;
3602     my $offset = GetGnuVTableOffsetForType($typename);
3603     return &quot;&amp;&quot; . $vtableName . &quot;[&quot; . $offset . &quot;]&quot;;
3604 }
3605 
3606 sub GetGnuVTableNameForInterface
3607 {
3608     my $interface = shift;
3609     my $typename = $interface-&gt;type-&gt;name;
3610     my $templatePosition = index($typename, &quot;&lt;&quot;);
3611     return &quot;&quot; if $templatePosition != -1;
3612     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3613     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3614     return &quot;_ZTV&quot; . GetGnuMangledNameForInterface($interface);
3615 }
3616 
3617 sub GetGnuMangledNameForInterface
3618 {
3619     my $interface = shift;
3620     my $typename = $interface-&gt;type-&gt;name;
3621     my $templatePosition = index($typename, &quot;&lt;&quot;);
3622     if ($templatePosition != -1) {
3623         return &quot;&quot;;
3624     }
3625     my $mangledType = length($typename) . $typename;
3626     my $namespace = &quot;WebCore&quot;;
3627     my $mangledNamespace =  &quot;N&quot; . length($namespace) . $namespace;
3628     return $mangledNamespace . $mangledType . &quot;E&quot;;
3629 }
3630 
3631 sub GetGnuVTableOffsetForType
3632 {
3633     my $typename = shift;
3634     if ($typename eq &quot;ApplePaySession&quot;
3635         || $typename eq &quot;SVGAElement&quot;
3636         || $typename eq &quot;SVGCircleElement&quot;
3637         || $typename eq &quot;SVGClipPathElement&quot;
3638         || $typename eq &quot;SVGDefsElement&quot;
3639         || $typename eq &quot;SVGEllipseElement&quot;
3640         || $typename eq &quot;SVGForeignObjectElement&quot;
3641         || $typename eq &quot;SVGGElement&quot;
3642         || $typename eq &quot;SVGImageElement&quot;
3643         || $typename eq &quot;SVGLineElement&quot;
3644         || $typename eq &quot;SVGPathElement&quot;
3645         || $typename eq &quot;SVGPolyElement&quot;
3646         || $typename eq &quot;SVGPolygonElement&quot;
3647         || $typename eq &quot;SVGPolylineElement&quot;
3648         || $typename eq &quot;SVGRectElement&quot;
3649         || $typename eq &quot;SVGSVGElement&quot;
3650         || $typename eq &quot;SVGGeometryElement&quot;
3651         || $typename eq &quot;SVGGraphicsElement&quot;
3652         || $typename eq &quot;SVGSwitchElement&quot;
3653         || $typename eq &quot;SVGTextElement&quot;
3654         || $typename eq &quot;SVGUseElement&quot;) {
3655         return &quot;3&quot;;
3656     }
3657     return &quot;2&quot;;
3658 }
3659 
3660 # See http://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B_Name_Mangling.
3661 sub GetWinVTableRefForInterface
3662 {
3663     my $interface = shift;
3664     my $vtableName = GetWinVTableNameForInterface($interface);
3665     return 0 if !$vtableName;
3666     return &quot;__identifier(\&quot;&quot; . $vtableName . &quot;\&quot;)&quot;;
3667 }
3668 
3669 sub GetWinVTableNameForInterface
3670 {
3671     my $interface = shift;
3672     my $typename = $interface-&gt;type-&gt;name;
3673     my $templatePosition = index($typename, &quot;&lt;&quot;);
3674     return &quot;&quot; if $templatePosition != -1;
3675     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3676     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3677     return &quot;??_7&quot; . GetWinMangledNameForInterface($interface) . &quot;6B@&quot;;
3678 }
3679 
3680 sub GetWinMangledNameForInterface
3681 {
3682     my $interface = shift;
3683     my $typename = $interface-&gt;type-&gt;name;
3684     my $namespace = &quot;WebCore&quot;;
3685     return $typename . &quot;@&quot; . $namespace . &quot;@@&quot;;
3686 }
3687 
3688 sub GetImplementationLacksVTableForInterface
3689 {
3690     my $interface = shift;
3691     return $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
3692 }
3693 
3694 sub GetSkipVTableValidationForInterface
3695 {
3696     my $interface = shift;
3697     return $interface-&gt;extendedAttributes-&gt;{SkipVTableValidation};
3698 }
3699 
3700 # URL becomes url, but SetURL becomes setURL.
3701 sub ToMethodName
3702 {
3703     my $param = shift;
3704     my $ret = lcfirst($param);
3705     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
3706     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
3707     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
3708     $ret =~ s/hDR/hdr/ if $ret =~ /^hDR/;
3709     $ret =~ s/jS/js/ if $ret =~ /^jS/;
3710     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
3711     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
3712     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
3713 
3714     # For HTML5 FileSystem API Flags attributes.
3715     # (create is widely used to instantiate an object and must be avoided.)
3716     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
3717     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
3718 
3719     return $ret;
3720 }
3721 
3722 sub GenerateRuntimeEnableConditionalStringForExposed
3723 {
3724     my ($interface, $context, $conjuncts, $globalObjectIsParam) = @_;
3725 
3726     assert(&quot;Must specify value for Exposed.&quot;) if $context-&gt;extendedAttributes-&gt;{Exposed} eq &quot;VALUE_IS_MISSING&quot;;
3727 
3728     AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3729 
3730     my $exposed = $context-&gt;extendedAttributes-&gt;{Exposed};
3731     if (ref($exposed) eq &#39;ARRAY&#39;) {
3732         if (scalar(@$exposed) &gt; 1) {
3733             return;
3734         }
3735         $exposed = @$exposed[0];
3736     }
3737 
3738     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;
3739 
3740     if ($exposed eq &quot;Window&quot;) {
3741         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isDocument()&quot;);
3742     } elsif ($exposed eq &quot;Worker&quot;) {
3743         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkerGlobalScope()&quot;);
3744     } elsif ($exposed eq &quot;Worklet&quot;) {
3745         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkletGlobalScope()&quot;);
3746     } else {
3747         assert(&quot;Unrecognized value &#39;&quot; . Dumper($context-&gt;extendedAttributes-&gt;{Exposed}) . &quot;&#39; for the Exposed extended attribute on &#39;&quot; . ref($context) . &quot;&#39;.&quot;);
3748     }
3749 }
3750 
3751 # Returns the conditional string that determines whether a method/attribute is enabled at runtime.
3752 # A method/attribute is enabled at runtime if either its RuntimeEnabledFeatures function returns
3753 # true or its EnabledForWorld function returns true (or both).
3754 # NOTE: Parameter passed in must have an &#39;extendedAttributes&#39; property.
3755 # (e.g. IDLInterface, IDLAttribute, IDLOperation, IDLIterable, etc.)
3756 sub GenerateRuntimeEnableConditionalString
3757 {
3758     my ($interface, $context, $globalObjectIsParam) = @_;
3759 
3760     my @conjuncts;
3761     my $globalObjectPtr = $globalObjectIsParam ? $globalObjectIsParam : &quot;globalObject()&quot;;
3762     
3763     if ($context-&gt;extendedAttributes-&gt;{SecureContext}) {
3764         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3765 
3766         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3767             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3768                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme())&quot;);
3769         } elsif ($context-&gt;extendedAttributes-&gt;{ContextAllowsMediaDevices}) {
3770             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3771                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;allowsMediaDevices())&quot;);
3772         } else {
3773             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(globalObject())-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;);
3774         }
3775     } else {
3776         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3777             AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3778 
3779             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme()&quot;);
3780         }
3781     }
3782 
3783     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
3784         GenerateRuntimeEnableConditionalStringForExposed($interface, $context, \@conjuncts);
3785     }
3786 
3787     if ($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) {
3788         assert(&quot;Must specify value for EnabledForWorld.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledForWorld} eq &quot;VALUE_IS_MISSING&quot;;
3789 
3790         AddToImplIncludes(&quot;DOMWrapperWorld.h&quot;);
3791 
3792         push(@conjuncts, &quot;worldForDOMObject(*this).&quot; . ToMethodName($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) . &quot;()&quot;);
3793     }
3794 
3795     if ($context-&gt;extendedAttributes-&gt;{EnabledBySetting}) {
3796         assert(&quot;Must specify value for EnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3797 
3798         AddToImplIncludes(&quot;Document.h&quot;);
3799         AddToImplIncludes(&quot;Settings.h&quot;);
3800 
3801         assert(&quot;EnabledBySetting can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3802 
3803         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledBySetting});
3804         foreach my $flag (@flags) {
3805             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3806         }
3807     }
3808 
3809     if ($context-&gt;extendedAttributes-&gt;{CustomEnabled}) {
3810         assert(&quot;CustomEnabled can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3811 
3812         my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
3813         push(@conjuncts, &quot;${className}&quot; . $codeGenerator-&gt;WK_ucfirst($context-&gt;name) . &quot;IsEnabled()&quot;);
3814     }
3815 
3816     if ($context-&gt;extendedAttributes-&gt;{DisabledByQuirk}) {
3817         assert(&quot;Must specify value for DisabledByQuirk.&quot;) if $context-&gt;extendedAttributes-&gt;{DisabledByQuirk} eq &quot;VALUE_IS_MISSING&quot;;
3818 
3819         AddToImplIncludes(&quot;Document.h&quot;);
3820         AddToImplIncludes(&quot;Quirks.h&quot;);
3821 
3822         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3823 
3824         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3825         foreach my $flag (@flags) {
3826             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3827         }
3828     }
3829 
3830     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3831         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3832 
3833         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3834 
3835         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3836         foreach my $flag (@flags) {
3837             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3838         }
3839     }
3840 
3841     if ($context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {
3842         assert(&quot;Must specify value for RuntimeConditionallyReadWrite.&quot;) if $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite} eq &quot;VALUE_IS_MISSING&quot;;
3843 
3844         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3845 
3846         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite});
3847         foreach my $flag (@flags) {
3848             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3849         }
3850     }
3851 
3852     if ($context-&gt;extendedAttributes-&gt;{EnabledForContext}) {
3853         assert(&quot;Must not specify value for EnabledForContext.&quot;) unless $context-&gt;extendedAttributes-&gt;{EnabledForContext} eq &quot;VALUE_IS_MISSING&quot;;
3854         assert(&quot;EnabledForContext must be an interface or constructor attribute.&quot;) unless $codeGenerator-&gt;IsConstructorType($context-&gt;type);
3855 
3856         my $contextRef = &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()&quot;;
3857         my $name = $context-&gt;name;
3858         push(@conjuncts,  &quot;${name}::enabledForContext(&quot; . $contextRef . &quot;)&quot;);
3859     }
3860 
3861     if ($context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {
3862         assert(&quot;Must specify value for ConstructorEnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3863 
3864         my @settings = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting});
3865         foreach my $setting (@settings) {
3866             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($setting) . &quot;Enabled()&quot;);
3867         }
3868     }
3869 
3870     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3871     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3872     return $result;
3873 }
3874 
3875 sub GetCastingHelperForThisObject
3876 {
3877     my $interface = shift;
3878     my $interfaceName = $interface-&gt;type-&gt;name;
3879     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3880 }
3881 
3882 # http://heycam.github.io/webidl/#Unscopable
3883 sub addUnscopableProperties
3884 {
3885     my $interface = shift;
3886 
3887     my @unscopables;
3888     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3889         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3890     }
3891     return if scalar(@unscopables) == 0;
3892 
3893     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
3894     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;vm(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);
3895     foreach my $unscopable (@unscopables) {
3896         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);
3897     }
3898     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3899 }
3900 
3901 sub GetArgumentTypeForFunctionWithoutTypeCheck
3902 {
3903     my ($interface, $type) = @_;
3904 
3905     my $IDLType = GetIDLType($interface, $type);
3906     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3907 }
3908 
3909 sub GetArgumentTypeFilter
3910 {
3911     my ($interface, $type) = @_;
3912 
3913     my $IDLType = GetIDLType($interface, $type);
3914     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
3915 }
3916 
3917 sub GetResultTypeFilter
3918 {
3919     my ($interface, $type) = @_;
3920 
3921     my $IDLType = GetIDLType($interface, $type);
3922     return &quot;DOMJIT::IDLResultTypeFilter&lt;${IDLType}&gt;::value&quot;;
3923 }
3924 
3925 sub GetAttributeWithName
3926 {
3927     my ($interface, $attributeName) = @_;
3928     
3929     foreach my $attribute (@{$interface-&gt;attributes}) {
3930         return $attribute if $attribute-&gt;name eq $attributeName;
3931     }
3932 }
3933 
3934 # https://heycam.github.io/webidl/#es-iterator
3935 sub InterfaceNeedsIterator
3936 {
3937     my ($interface) = @_;
3938 
3939     return 1 if $interface-&gt;setLike;
3940     return 1 if $interface-&gt;mapLike;
3941     return 1 if $interface-&gt;iterable;
3942 
3943     if (GetIndexedGetterOperation($interface)) {
3944         my $lengthAttribute = GetAttributeWithName($interface, &quot;length&quot;);
3945         return 1 if $lengthAttribute and $codeGenerator-&gt;IsIntegerType($lengthAttribute-&gt;type);
3946     }
3947     return 0;
3948 }
3949 
3950 sub GenerateImplementation
3951 {
3952     my ($object, $interface, $enumerations, $dictionaries) = @_;
3953 
3954     my $interfaceName = $interface-&gt;type-&gt;name;
3955     my $className = &quot;JS$interfaceName&quot;;
3956 
3957     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
3958     my $parentClassName = GetParentClassName($interface);
3959     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
3960     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
3961 
3962     my $namedGetterOperation = GetNamedGetterOperation($interface);
3963     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
3964 
3965     # - Add default header template
3966     push(@implContentHeader, GenerateImplementationContentHeader($interface));
3967 
3968     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
3969     AddToImplIncludes(&quot;JSDOMBinding.h&quot;);
3970     AddToImplIncludes(&quot;JSDOMExceptionHandling.h&quot;);
3971     AddToImplIncludes(&quot;JSDOMWrapperCache.h&quot;);
3972     AddToImplIncludes(&quot;&lt;wtf/GetPtr.h&gt;&quot;);
3973     AddToImplIncludes(&quot;&lt;wtf/PointerPreparations.h&gt;&quot;);
3974     AddToImplIncludes(&quot;&lt;JavaScriptCore/PropertyNameArray.h&gt;&quot;) if $indexedGetterOperation;
3975     AddToImplIncludes(&quot;JSDOMMapLike.h&quot;) if $interface-&gt;mapLike;
3976     AddToImplIncludes(&quot;JSDOMSetLike.h&quot;) if $interface-&gt;setLike;
3977     AddJSBuiltinIncludesIfNeeded($interface);
3978 
3979     my $implType = GetImplClassName($interface);
3980 
3981     @implContent = ();
3982 
3983     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
3984     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
3985 
3986     push(@implContent, GenerateEnumerationsImplementationContent($interface, $enumerations));
3987     push(@implContent, GenerateDictionariesImplementationContent($interface, $dictionaries));
3988 
3989     my @operations = @{$interface-&gt;operations};
3990     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3991     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3992     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;
3993     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3994 
3995     my @attributes = @{$interface-&gt;attributes};
3996     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3997     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;
3998 
3999     my $numConstants = @{$interface-&gt;constants};
4000     my $numOperations = @operations;
4001     my $numAttributes = @attributes;
4002 
4003     if ($numOperations &gt; 0) {
4004         my $inAppleCopyright = 0;
4005         push(@implContent,&quot;// Functions\n\n&quot;);
4006         foreach my $operation (@operations) {
4007             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4008             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4009             next if IsJSBuiltin($interface, $operation);
4010 
4011             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
4012                 if (!$inAppleCopyright) {
4013                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
4014                     $inAppleCopyright = 1;
4015                 }
4016             } elsif ($inAppleCopyright) {
4017                 push(@implContent, $endAppleCopyright);
4018                 $inAppleCopyright = 0;
4019             }
4020 
4021             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
4022             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
4023             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4024             my $functionName = GetFunctionName($interface, $className, $operation);
4025             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);
4026             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
4027                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
4028                 my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
4029                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject*, $className*&quot;;
4030                 foreach my $argument (@{$operation-&gt;arguments}) {
4031                     my $type = $argument-&gt;type;
4032                     my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
4033                     $functionSignature .= &quot;, ${argumentType}&quot;;
4034                 }
4035                 push(@implContent, $functionSignature . &quot;);\n&quot;);
4036             }
4037             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4038         }
4039 
4040         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
4041         push(@implContent, &quot;\n&quot;);
4042     }
4043 
4044     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
4045         push(@implContent, &quot;// Attributes\n\n&quot;);
4046 
4047         if (NeedsConstructorProperty($interface)) {
4048             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4049             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
4050 
4051             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4052             push(@implContent, &quot;bool ${constructorSetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
4053         }
4054 
4055         foreach my $attribute (@attributes) {
4056             next if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4057             next if IsJSBuiltin($interface, $attribute);
4058 
4059             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4060             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4061             my $getter = GetAttributeGetterName($interface, $className, $attribute);
4062             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
4063             if (!IsReadonly($attribute)) {
4064                 my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4065                 if ($readWriteConditional) {
4066                     my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
4067                     push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
4068                 }
4069                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
4070                 push(@implContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
4071                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
4072             }
4073             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4074         }
4075 
4076         push(@implContent, &quot;\n&quot;);
4077     }
4078 
4079     if ($numOperations &gt; 0) {
4080         foreach my $operation (@operations) {
4081             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
4082             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
4083             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
4084 
4085             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
4086             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
4087             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
4088 
4089             my $interfaceName = $interface-&gt;type-&gt;name;
4090             my $functionName = GetFunctionName($interface, $className, $operation);
4091             my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
4092             my $domJITSignatureName = &quot;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name);
4093             my $classInfo = &quot;JS&quot; . $interface-&gt;type-&gt;name . &quot;::info()&quot;;
4094             my $resultType = GetResultTypeFilter($interface, $operation-&gt;type);
4095             my $domJITSignatureHeader = &quot;static const JSC::DOMJIT::Signature ${domJITSignatureName}(${nameOfFunctionWithoutTypeCheck},&quot;;
4096             my $domJITSignatureFooter = &quot;$classInfo, JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), ${resultType}&quot;;
4097             foreach my $argument (@{$operation-&gt;arguments}) {
4098                 my $type = $argument-&gt;type;
4099                 my $argumentType = GetArgumentTypeFilter($interface, $type);
4100                 $domJITSignatureFooter .= &quot;, ${argumentType}&quot;;
4101             }
4102             $domJITSignatureFooter .= &quot;);&quot;;
4103             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4104             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4105             push(@implContent, &quot;$domJITSignatureHeader $domJITSignatureFooter\n&quot;);
4106             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4107             push(@implContent, &quot;\n&quot;);
4108         }
4109     }
4110 
4111     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
4112         foreach my $attribute (@attributes) {
4113             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4114             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
4115 
4116             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4117             push(@implContent, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
4118             AddToImplIncludes(&quot;DOMJITIDLTypeFilter.h&quot;, $conditionalString);
4119             my $interfaceName = $interface-&gt;type-&gt;name;
4120             my $generatorName = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
4121             my $domJITClassName = $generatorName . &quot;Attribute&quot;;
4122             my $getter = GetAttributeGetterName($interface, $generatorName, $attribute);
4123             my $resultType = &quot;JSC::SpecBytecodeTop&quot;;
4124             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4125                 $resultType = GetResultTypeFilter($interface, $attribute-&gt;type);
4126             }
4127             push(@implContent, &quot;static const JSC::DOMJIT::GetterSetter DOMJITAttributeFor${generatorName} {\n&quot;);
4128             push(@implContent, &quot;    $getter,\n&quot;);
4129             push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4130             push(@implContent, &quot;    &amp;compile${domJITClassName},\n&quot;);
4131             push(@implContent, &quot;#else\n&quot;);
4132             push(@implContent, &quot;    nullptr,\n&quot;);
4133             push(@implContent, &quot;#endif\n&quot;);
4134             push(@implContent, &quot;    $resultType\n&quot;);
4135             push(@implContent, &quot;};\n\n&quot;);
4136             push(@implContent, &quot;#endif\n\n&quot;) if $conditionalString;
4137         }
4138     }
4139 
4140     GeneratePrototypeDeclaration(\@implContent, $className, $interface) if !HeaderNeedsPrototypeDeclaration($interface);
4141 
4142     GenerateConstructorDeclaration(\@implContent, $className, $interface) if NeedsConstructorProperty($interface);
4143 
4144     my @hashKeys = ();
4145     my @hashValue1 = ();
4146     my @hashValue2 = ();
4147     my @hashSpecials = ();
4148     my %conditionals = ();
4149     my %readWriteConditionals = ();
4150     my $hashName = $className . &quot;Table&quot;;
4151     my @runtimeEnabledOperations = ();
4152     my @runtimeEnabledAttributes = ();
4153 
4154     # Generate hash table for properties on the instance.
4155     my $numInstanceProperties = GeneratePropertiesHashTable($object, $interface, 1, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4156     $object-&gt;GenerateHashTable($className, $hashName, $numInstanceProperties, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 0) if $numInstanceProperties &gt; 0;
4157 
4158     # - Add all interface object (aka constructor) properties (constants, static attributes, static operations).
4159     if (NeedsConstructorProperty($interface)) {
4160         my $hashSize = 0;
4161         my $hashName = $className . &quot;ConstructorTable&quot;;
4162 
4163         my @hashKeys = ();
4164         my @hashValue1 = ();
4165         my @hashValue2 = ();
4166         my @hashSpecials = ();
4167         my %conditionals = ();
4168         my %readWriteConditionals = ();
4169 
4170         my $needsConstructorTable = 0;
4171 
4172         foreach my $constant (@{$interface-&gt;constants}) {
4173             my $name = $constant-&gt;name;
4174             push(@hashKeys, $name);
4175             push(@hashValue1, $constant-&gt;value);
4176             push(@hashValue2, &quot;0&quot;);
4177             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4178 
4179             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
4180             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
4181 
4182             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4183             $conditionals{$name} = $conditional if $conditional;
4184 
4185             $hashSize++;
4186         }
4187 
4188         foreach my $attribute (@{$interface-&gt;attributes}) {
4189             next unless ($attribute-&gt;isStatic);
4190             my $name = $attribute-&gt;name;
4191             push(@hashKeys, $name);
4192 
4193             my @specials = ();
4194             push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
4195             push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
4196             push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
4197             push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4198             my $special = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
4199             push(@hashSpecials, $special);
4200 
4201             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4202                 push(@hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
4203             } else {
4204                 my $getter = GetAttributeGetterName($interface, $className, $attribute);
4205                 push(@hashValue1, $getter);
4206             }
4207 
4208             if (IsReadonly($attribute)) {
4209                 push(@hashValue2, &quot;0&quot;);
4210             } else {
4211                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
4212                 push(@hashValue2, $setter);
4213             }
4214 
4215             my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
4216             $conditionals{$name} = $conditional if $conditional;
4217 
4218             my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4219             $readWriteConditionals{$name} = $readWriteConditional if $readWriteConditional;
4220 
4221             $hashSize++;
4222         }
4223 
4224         foreach my $operation (@{$interface-&gt;operations}) {
4225             next unless ($operation-&gt;isStatic);
4226             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4227             my $name = $operation-&gt;name;
4228             push(@hashKeys, $name);
4229 
4230             my $functionName = GetFunctionName($interface, $className, $operation);
4231             push(@hashValue1, $functionName);
4232 
4233             my $functionLength = GetFunctionLength($operation);
4234             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
4235                 push(@hashValue2, &quot;DOMJITFunctionFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
4236             } else {
4237                 push(@hashValue2, $functionLength);
4238             }
4239 
4240             push(@hashSpecials, ComputeFunctionSpecial($interface, $operation));
4241 
4242             my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
4243             $conditionals{$name} = $conditional if $conditional;
4244 
4245             $hashSize++;
4246         }
4247 
4248         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
4249 
4250         push(@implContent, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interface));
4251 
4252         my $protoClassName = &quot;${className}Prototype&quot;;
4253         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $visibleInterfaceName, $interface);
4254 
4255         my $namedConstructor = $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
4256         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $namedConstructor, $interface, &quot;GeneratingNamedConstructor&quot;) if $namedConstructor;
4257     }
4258 
4259     # - Add functions and constants to a hashtable definition
4260 
4261     $hashName = $className . &quot;PrototypeTable&quot;;
4262 
4263     @hashKeys = ();
4264     @hashValue1 = ();
4265     @hashValue2 = ();
4266     @hashSpecials = ();
4267     %conditionals = ();
4268     %readWriteConditionals = ();
4269     @runtimeEnabledOperations = ();
4270     @runtimeEnabledAttributes = ();
4271 
4272     # Generate hash table for properties on the prototype.
4273     my $numPrototypeProperties = GeneratePropertiesHashTable($object, $interface, 0,
4274         \@hashKeys, \@hashSpecials,
4275         \@hashValue1, \@hashValue2,
4276         \%conditionals, \%readWriteConditionals,
4277         \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4278 
4279     my $hashSize = $numPrototypeProperties;
4280 
4281     foreach my $constant (@{$interface-&gt;constants}) {
4282         my $name = $constant-&gt;name;
4283 
4284         push(@hashKeys, $name);
4285         push(@hashValue1, $constant-&gt;value);
4286         push(@hashValue2, &quot;0&quot;);
4287         push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4288 
4289         my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4290         $conditionals{$name} = $conditional if $conditional;
4291 
4292         $hashSize++;
4293     }
4294 
4295     my $justGenerateValueArray = !IsDOMGlobalObject($interface);
4296 
4297     $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, $justGenerateValueArray);
4298 
4299     if ($justGenerateValueArray) {
4300         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4301     } else {
4302         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, &amp;${className}PrototypeTable, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4303     }
4304 
4305     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalInterface($interface)) {
4306         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4307         push(@implContent, &quot;{\n&quot;);
4308         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4309         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4310 
4311         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4312         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4313 
4314         if (@runtimeEnabledProperties) {
4315             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4316         }
4317 
4318         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4319             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4320             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4321             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4322             my $name = $operationOrAttribute-&gt;name;
4323             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4324             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
4325             push(@implContent, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
4326             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
4327             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject(), propertyName);\n&quot;);
4328             push(@implContent, &quot;    }\n&quot;);
4329             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4330         }
4331 
4332         foreach my $attribute (@runtimeEnabledAttributes) {
4333             if ($attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {
4334                 AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4335                 my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4336 
4337                 my $attributeName = $attribute-&gt;name;
4338                 my $getter = GetAttributeGetterName($interface, $className, $attribute);
4339                 my $setter = &quot;nullptr&quot;;
4340                 my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4341 
4342                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4343                 push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4344                 push(@implContent, &quot;    // Adding back attribute, but as readonly, after removing the read-write variant above. \n&quot;);
4345                 push(@implContent, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);
4346                 push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4347                 push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4348             }
4349         }
4350 
4351         if (@runtimeEnabledProperties) {
4352             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4353             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4354         }
4355 
4356         foreach my $operation (@{$interface-&gt;operations}) {
4357             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4358             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4359             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4360             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4361             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4362             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4363         }
4364 
4365         if (InterfaceNeedsIterator($interface)) {
4366             AddToImplIncludes(&quot;&lt;JavaScriptCore/BuiltinNames.h&gt;&quot;);
4367             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike or $interface-&gt;setLike) {
4368                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4369             } else {
4370                 AddToImplIncludes(&quot;&lt;JavaScriptCore/ArrayPrototype.h&gt;&quot;);
4371                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject()-&gt;arrayPrototype()-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4372             }
4373         }
4374         push(@implContent, &quot;    addValueIterableMethods(*globalObject(), *this);\n&quot;) if $interface-&gt;iterable and !IsKeyValueIterableInterface($interface);
4375 
4376         addUnscopableProperties($interface);
4377 
4378         push(@implContent, &quot;}\n\n&quot;);
4379     }
4380 
4381     # - Initialize static ClassInfo object
4382     push(@implContent, &quot;const ClassInfo $className&quot; . &quot;::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, &quot;);
4383 
4384     if ($numInstanceProperties &gt; 0) {
4385         push(@implContent, &quot;&amp;${className}Table&quot;);
4386     } else {
4387         push(@implContent, &quot;nullptr&quot;);
4388     }
4389     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
4390         push(@implContent, &quot;\n&quot;);
4391         push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4392         push(@implContent, &quot;, &amp;checkSubClassSnippetFor${className}\n&quot;);
4393         push(@implContent, &quot;#else\n&quot;);
4394         push(@implContent, &quot;, nullptr\n&quot;);
4395         push(@implContent, &quot;#endif\n&quot;);
4396     } else {
4397         push(@implContent, &quot;, nullptr&quot;);
4398     }
4399     push(@implContent, &quot;, CREATE_METHOD_TABLE($className) };\n\n&quot;);
4400 
4401     # Constructor
4402     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4403         AddIncludesForImplementationTypeInImpl(&quot;JSWindowProxy&quot;);
4404         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
4405         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl), proxy)\n&quot;);
4406         push(@implContent, &quot;{\n&quot;);
4407         push(@implContent, &quot;}\n\n&quot;);
4408     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4409         AddIncludesForImplementationTypeInImpl($interfaceName);
4410         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4411         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl))\n&quot;);
4412         push(@implContent, &quot;{\n&quot;);
4413         push(@implContent, &quot;}\n\n&quot;);
4414     } elsif (!NeedsImplementationClass($interface)) {
4415         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4416         push(@implContent, &quot;    : $parentClassName(structure, globalObject) { }\n\n&quot;);
4417     } else {
4418         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4419         push(@implContent, &quot;    : $parentClassName(structure, globalObject, WTFMove(impl))\n&quot;);
4420         push(@implContent, &quot;{\n&quot;);
4421         push(@implContent, &quot;}\n\n&quot;);
4422     }
4423 
4424     # Finish Creation
4425     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4426         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSWindowProxy* proxy)\n&quot;);
4427         push(@implContent, &quot;{\n&quot;);
4428         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4429     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4430         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSProxy* proxy)\n&quot;);
4431         push(@implContent, &quot;{\n&quot;);
4432         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4433     } else {
4434         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm)\n&quot;);
4435         push(@implContent, &quot;{\n&quot;);
4436         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4437         push(@implContent, &quot;    ASSERT(inherits(vm, info()));\n\n&quot;);
4438     }
4439 
4440     if (!$codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;JSBuiltin&quot;)) {
4441         AddToImplIncludes(&quot;ActiveDOMObject.h&quot;);
4442         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {
4443             push(@implContent, &quot;    static_assert(std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is marked as [ActiveDOMObject] but implementation class does not subclass ActiveDOMObject.\&quot;);\n\n&quot;);
4444         } else {
4445             push(@implContent, &quot;    static_assert(!std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is not marked as [ActiveDOMObject] even though implementation class subclasses ActiveDOMObject.\&quot;);\n\n&quot;);
4446         }
4447     }
4448 
4449     if ($interfaceName eq &quot;Location&quot;) {
4450         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;valueOf, globalObject()-&gt;objectProtoValueOfFunction(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4451         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;toPrimitiveSymbol, jsUndefined(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4452     }
4453 
4454     # Support for RuntimeEnabled attributes on instances.
4455     foreach my $attribute (@{$interface-&gt;attributes}) {
4456         next unless NeedsRuntimeCheck($interface, $attribute);
4457         next unless AttributeShouldBeOnInstance($interface, $attribute);
4458 
4459         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4460         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4461         my $attributeName = $attribute-&gt;name;
4462         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4463         my $setter = IsReadonly($attribute) ? &quot;nullptr&quot; : GetAttributeSetterName($interface, $className, $attribute);
4464         my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4465 
4466         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4467         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4468         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4469         push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4470         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4471     }
4472 
4473     # Support PrivateIdentifier attributes on instances.
4474     foreach my $attribute (@{$interface-&gt;attributes}) {
4475         next unless $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier};
4476         next unless AttributeShouldBeOnInstance($interface, $attribute);
4477 
4478         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4479         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4480         my $attributeName = $attribute-&gt;name;
4481         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4482 
4483         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4484         push(@implContent, &quot;    putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PrivateName(), CustomGetterSetter::create(vm, $getter, nullptr), attributesForStructure(JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly));\n&quot;);
4485         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4486     }
4487 
4488     # Support for RuntimeEnabled operations on instances.
4489     foreach my $operation (@{$interface-&gt;operations}) {
4490         next unless NeedsRuntimeCheck($interface, $operation);
4491         next unless OperationShouldBeOnInstance($interface, $operation);
4492         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4493 
4494         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4495         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation);
4496         my $functionName = $operation-&gt;name;
4497         my $implementationFunction = GetFunctionName($interface, $className, $operation);
4498         my $functionLength = GetFunctionLength($operation);
4499         my $jsAttributes = ComputeFunctionSpecial($interface, $operation);
4500 
4501         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4502         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4503         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4504         my $propertyName = &quot;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $functionName . ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} ? &quot;PrivateName()&quot; : &quot;PublicName()&quot;);
4505         if (IsJSBuiltin($interface, $operation)) {
4506             push(@implContent, &quot;        putDirectBuiltinFunction(vm, this, $propertyName, $implementationFunction(vm), attributesForStructure($jsAttributes));\n&quot;);
4507         } else {
4508             push(@implContent, &quot;        putDirectNativeFunction(vm, this, $propertyName, $functionLength, $implementationFunction, NoIntrinsic, attributesForStructure($jsAttributes));\n&quot;);
4509         }
4510         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4511     }
4512     push(@implContent, &quot;}\n\n&quot;);
4513 
4514     unless (ShouldUseGlobalObjectPrototype($interface)) {
4515         push(@implContent, &quot;JSObject* ${className}::createPrototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4516         push(@implContent, &quot;{\n&quot;);
4517         if ($interface-&gt;parentType) {
4518             my $parentClassNameForPrototype = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
4519             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, ${parentClassNameForPrototype}::prototype(vm, globalObject)));\n&quot;);
4520         } else {
4521             my $prototype = $interface-&gt;isException ? &quot;errorPrototype&quot; : &quot;objectPrototype&quot;;
4522             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, globalObject.${prototype}()));\n&quot;);
4523         }
4524         push(@implContent, &quot;}\n\n&quot;);
4525 
4526         push(@implContent, &quot;JSObject* ${className}::prototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4527         push(@implContent, &quot;{\n&quot;);
4528         push(@implContent, &quot;    return getDOMPrototype&lt;${className}&gt;(vm, globalObject);\n&quot;);
4529         push(@implContent, &quot;}\n\n&quot;);
4530     }
4531 
4532     if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4533         push(@implContent, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
4534         push(@implContent, &quot;{\n&quot;);
4535         push(@implContent, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4536         push(@implContent, &quot;}\n\n&quot;);
4537 
4538         if ($interface-&gt;extendedAttributes-&gt;{NamedConstructor}) {
4539             push(@implContent, &quot;JSValue ${className}::getNamedConstructor(VM&amp; vm, JSGlobalObject* globalObject)\n&quot;);
4540             push(@implContent, &quot;{\n&quot;);
4541             push(@implContent, &quot;    return getDOMConstructor&lt;${className}NamedConstructor&gt;(vm, *jsCast&lt;JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4542             push(@implContent, &quot;}\n\n&quot;);
4543         }
4544     }
4545 
4546     if (!$hasParent) {
4547         push(@implContent, &quot;void ${className}::destroy(JSC::JSCell* cell)\n&quot;);
4548         push(@implContent, &quot;{\n&quot;);
4549         push(@implContent, &quot;    ${className}* thisObject = static_cast&lt;${className}*&gt;(cell);\n&quot;);
4550         push(@implContent, &quot;    thisObject-&gt;${className}::~${className}();\n&quot;);
4551         push(@implContent, &quot;}\n\n&quot;);
4552     }
4553 
4554     if (InstanceOverridesGetOwnPropertySlot($interface)) {
4555         GenerateGetOwnPropertySlot(\@implContent, $interface, $className);
4556         GenerateGetOwnPropertySlotByIndex(\@implContent, $interface, $className);
4557     }
4558     
4559     if (InstanceOverridesGetOwnPropertyNames($interface)) {
4560         GenerateGetOwnPropertyNames(\@implContent, $interface, $className);
4561     }
4562     
4563     if (InstanceOverridesPut($interface)) {
4564         GeneratePut(\@implContent, $interface, $className);
4565         GeneratePutByIndex(\@implContent, $interface, $className);
4566     }
4567     
4568     if (InstanceOverridesDefineOwnProperty($interface)) {
4569         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4570     }
4571 
4572     if (InstanceOverridesDeleteProperty($interface)) {
4573         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4574     }
4575     
4576     if (InstanceOverridesGetCallData($interface)) {
4577         GenerateGetCallData(\@implContent, $interface, $className);
4578     }
4579     
4580     if ($numAttributes &gt; 0) {
4581         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4582 
4583         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4584         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4585         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
4586             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);
4587             push(@implContent, &quot;{\n&quot;);
4588             push(@implContent, &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);
4589             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4590             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
4591             push(@implContent, &quot;        decodedThisValue = JSValue(&amp;lexicalGlobalObject).toThis(&amp;lexicalGlobalObject, NotStrictMode);\n&quot;);
4592             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);\n&quot;);
4593             push(@implContent, &quot;}\n\n&quot;);
4594         } else {
4595             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);
4596             push(@implContent, &quot;{\n&quot;);
4597             push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), JSValue::decode(thisValue));\n&quot;);
4598             push(@implContent, &quot;}\n\n&quot;);
4599         }
4600     }
4601 
4602     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4603         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4604 
4605         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4606         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4607         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;callFrame.thisValue().toThis(&amp;lexicalGlobalObject, NotStrictMode)&quot; : &quot;callFrame.thisValue()&quot;;
4608         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)\n&quot;);
4609         push(@implContent, &quot;{\n&quot;);
4610         push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), $thisValue);\n&quot;);
4611         push(@implContent, &quot;}\n\n&quot;);
4612     }
4613 
4614     if (NeedsConstructorProperty($interface)) {
4615         my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4616 
4617         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);
4618         push(@implContent, &quot;{\n&quot;);
4619         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
4620         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4621         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4622         push(@implContent, &quot;    if (UNLIKELY(!prototype))\n&quot;);
4623         push(@implContent, &quot;        return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);
4624 
4625         if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4626             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(JSC::getVM(lexicalGlobalObject), prototype-&gt;globalObject()));\n&quot;);
4627         } else {
4628             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(JSC::getVM(lexicalGlobalObject), ${className}Constructor::createStructure(JSC::getVM(lexicalGlobalObject), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);
4629             push(@implContent, &quot;    // Shadowing constructor property to ensure reusing the same constructor object\n&quot;);
4630             push(@implContent, &quot;    prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, constructor, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4631             push(@implContent, &quot;    return JSValue::encode(constructor);\n&quot;);
4632         }
4633         push(@implContent, &quot;}\n\n&quot;);
4634 
4635         my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4636 
4637         push(@implContent, &quot;bool ${constructorSetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
4638         push(@implContent, &quot;{\n&quot;);
4639         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
4640         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4641         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4642         push(@implContent, &quot;    if (UNLIKELY(!prototype)) {\n&quot;);
4643         push(@implContent, &quot;        throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);
4644         push(@implContent, &quot;        return false;\n&quot;);
4645         push(@implContent, &quot;    }\n&quot;);
4646         push(@implContent, &quot;    // Shadowing a built-in constructor\n&quot;);
4647         push(@implContent, &quot;    return prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, JSValue::decode(encodedValue));\n&quot;);
4648         push(@implContent, &quot;}\n\n&quot;);
4649 
4650     }
4651 
4652     foreach my $attribute (@attributes) {
4653         GenerateAttributeGetterDefinition(\@implContent, $interface, $className, $attribute);
4654         GenerateAttributeSetterDefinition(\@implContent, $interface, $className, $attribute);
4655     }
4656 
4657     foreach my $operation (@operations) {
4658         GenerateOperationDefinition(\@implContent, $interface, $className, $operation);
4659     }
4660     
4661     GenerateIterableDefinition($interface) if $interface-&gt;iterable;
4662     GenerateSerializerDefinition($interface, $className) if $interface-&gt;serializable;
4663 
4664     if (IsDOMGlobalObject($interface)) {
4665         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4666         push(@implContent, &quot;JSC::IsoSubspace* ${className}::subspaceForImpl(JSC::VM&amp; vm)\n&quot;);
4667         push(@implContent, &quot;{\n&quot;);
4668         push(@implContent, &quot;    return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;subspaceFor${className}();\n&quot;);
4669         push(@implContent, &quot;}\n\n&quot;);
4670     }
4671 
4672     if ($needsVisitChildren) {
4673         push(@implContent, &quot;void ${className}::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4674         push(@implContent, &quot;{\n&quot;);
4675         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4676         push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4677         push(@implContent, &quot;    Base::visitChildren(thisObject, visitor);\n&quot;);
4678         push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
4679         if ($interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost}) {
4680             push(@implContent, &quot;    visitor.reportExtraMemoryVisited(thisObject-&gt;wrapped().memoryCost());\n&quot;);
4681             if ($interface-&gt;extendedAttributes-&gt;{ReportExternalMemoryCost}) {;
4682                 push(@implContent, &quot;#if ENABLE(RESOURCE_USAGE)\n&quot;);
4683                 push(@implContent, &quot;    visitor.reportExternalMemoryVisited(thisObject-&gt;wrapped().externalMemoryCost());\n&quot;);
4684                 push(@implContent, &quot;#endif\n&quot;);
4685             }
4686         }
4687         if ($numCachedAttributes &gt; 0) {
4688             foreach my $attribute (@{$interface-&gt;attributes}) {
4689                 if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4690                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4691                     push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4692                     push(@implContent, &quot;    visitor.append(thisObject-&gt;m_&quot; . $attribute-&gt;name . &quot;);\n&quot;);
4693                     push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4694                 }
4695             }
4696         }
4697         push(@implContent, &quot;}\n\n&quot;);
4698         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
4699             push(@implContent, &quot;void ${className}::visitOutputConstraints(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4700             push(@implContent, &quot;{\n&quot;);
4701             push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4702             push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4703             push(@implContent, &quot;    Base::visitOutputConstraints(thisObject, visitor);\n&quot;);
4704             push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;);
4705             push(@implContent, &quot;}\n\n&quot;);
4706         }
4707     }
4708 
4709     if (InstanceNeedsEstimatedSize($interface)) {
4710         push(@implContent, &quot;size_t ${className}::estimatedSize(JSCell* cell, VM&amp; vm)\n&quot;);
4711         push(@implContent, &quot;{\n&quot;);
4712         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4713         push(@implContent, &quot;    return Base::estimatedSize(thisObject, vm) + thisObject-&gt;wrapped().memoryCost();\n&quot;);
4714         push(@implContent, &quot;}\n\n&quot;);
4715     }
4716 
4717     if (NeedsImplementationClass($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{CustomHeapSnapshot}) {
4718         AddToImplIncludes(&quot;&lt;JavaScriptCore/HeapAnalyzer.h&gt;&quot;);
4719         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
4720         AddToImplIncludes(&quot;&lt;wtf/URL.h&gt;&quot;);
4721         push(@implContent, &quot;void ${className}::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)\n&quot;);
4722         push(@implContent, &quot;{\n&quot;);
4723         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4724         push(@implContent, &quot;    analyzer.setWrappedObjectForCell(cell, &amp;thisObject-&gt;wrapped());\n&quot;);
4725         push(@implContent, &quot;    if (thisObject-&gt;scriptExecutionContext())\n&quot;);
4726         push(@implContent, &quot;        analyzer.setLabelForCell(cell, \&quot;url \&quot; + thisObject-&gt;scriptExecutionContext()-&gt;url().string());\n&quot;);
4727         push(@implContent, &quot;    Base::analyzeHeap(cell, analyzer);\n&quot;);
4728         push(@implContent, &quot;}\n\n&quot;);
4729     }
4730 
4731     if ($indexedGetterOperation) {
4732         $implIncludes{&quot;&lt;wtf/URL.h&gt;&quot;} = 1 if $indexedGetterOperation-&gt;type-&gt;name eq &quot;DOMString&quot;;
4733         if ($interfaceName =~ /^HTML\w*Collection$/ or $interfaceName eq &quot;RadioNodeList&quot;) {
4734             $implIncludes{&quot;JSNode.h&quot;} = 1;
4735             $implIncludes{&quot;Node.h&quot;} = 1;
4736         }
4737     }
4738 
4739     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !GetCustomIsReachable($interface)) {
4740         push(@implContent, &quot;bool JS${interfaceName}Owner::isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason)\n&quot;);
4741         push(@implContent, &quot;{\n&quot;);
4742         # All ActiveDOMObjects implement hasPendingActivity(), but not all of them
4743         # increment their C++ reference counts when hasPendingActivity() becomes
4744         # true. As a result, ActiveDOMObjects can be prematurely destroyed before
4745         # their pending activities complete. To wallpaper over this bug, JavaScript
4746         # wrappers unconditionally keep ActiveDOMObjects with pending activity alive.
4747         # FIXME: Fix this lifetime issue in the DOM, and move this hasPendingActivity
4748         # check just above the (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) check below.
4749         my $emittedJSCast = 0;
4750         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {
4751             push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4752             $emittedJSCast = 1;
4753             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().hasPendingActivity()) {\n&quot;);
4754             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4755             push(@implContent, &quot;            *reason = \&quot;ActiveDOMObject with pending activity\&quot;;\n&quot;);
4756             push(@implContent, &quot;        return true;\n&quot;);
4757             push(@implContent, &quot;     }\n&quot;);
4758         }
4759         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;EventTarget&quot;)) {
4760             if (!$emittedJSCast) {
4761                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4762                 $emittedJSCast = 1;
4763             }
4764             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().isFiringEventListeners()) {\n&quot;);
4765             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4766             push(@implContent, &quot;            *reason = \&quot;EventTarget firing event listeners\&quot;;\n&quot;);
4767             push(@implContent, &quot;        return true;\n&quot;);
4768             push(@implContent, &quot;    }\n&quot;);
4769         }
4770         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
4771             if (!$emittedJSCast) {
4772                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4773                 $emittedJSCast = 1;
4774             }
4775             push(@implContent, &quot;    if (JSNodeOwner::isReachableFromOpaqueRoots(handle, 0, visitor, reason))\n&quot;);
4776             push(@implContent, &quot;        return true;\n&quot;);
4777         }
4778         if (GetGenerateIsReachable($interface)) {
4779             if (!$emittedJSCast) {
4780                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4781                 $emittedJSCast = 1;
4782             }
4783 
4784             my $rootString;
4785             if (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) {
4786                 $rootString  = &quot;    ${implType}* root = &amp;js${interfaceName}-&gt;wrapped();\n&quot;;
4787                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4788                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4789             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplWebGLRenderingContext&quot;) {
4790                 $rootString  = &quot;    WebGLRenderingContextBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().context());\n&quot;;
4791                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4792                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4793             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromDOMWindow&quot;) {
4794                 $rootString  = &quot;    auto* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().window());\n&quot;;
4795                 $rootString .= &quot;    if (!root)\n&quot;;
4796                 $rootString .= &quot;        return false;\n&quot;;
4797                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4798                 $rootString .= &quot;        *reason = \&quot;Reachable from Window\&quot;;\n&quot;;
4799             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromNavigator&quot;) {
4800                 $implIncludes{&quot;Navigator.h&quot;} = 1;
4801                 $implIncludes{&quot;WorkerNavigator.h&quot;} = 1;
4802                 $rootString  = &quot;    NavigatorBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().navigator());\n&quot;;
4803                 $rootString .= &quot;    if (!root)\n&quot;;
4804                 $rootString .= &quot;        return false;\n&quot;;
4805                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4806                 $rootString .= &quot;        *reason = \&quot;Reachable from Navigator\&quot;;\n&quot;;
4807             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplDocument&quot;) {
4808                 $rootString  = &quot;    Document* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().document());\n&quot;;
4809                 $rootString .= &quot;    if (!root)\n&quot;;
4810                 $rootString .= &quot;        return false;\n&quot;;
4811                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4812                 $rootString .= &quot;        *reason = \&quot;Reachable from Document\&quot;;\n&quot;;
4813             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplElementRoot&quot;) {
4814                 $implIncludes{&quot;Element.h&quot;} = 1;
4815                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4816                 $rootString  = &quot;    Element* element = WTF::getPtr(js${interfaceName}-&gt;wrapped().element());\n&quot;;
4817                 $rootString .= &quot;    if (!element)\n&quot;;
4818                 $rootString .= &quot;        return false;\n&quot;;
4819                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4820                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}Owner\&quot;;\n&quot;;
4821                 $rootString .= &quot;    void* root = WebCore::root(element);\n&quot;;
4822             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplOwnerNodeRoot&quot;) {
4823                 $implIncludes{&quot;Element.h&quot;} = 1;
4824                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4825                 $rootString  = &quot;    void* root = WebCore::root(js${interfaceName}-&gt;wrapped().ownerNode());\n&quot;;
4826                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4827                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName} ownerNode\&quot;;\n&quot;;
4828             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplScriptExecutionContext&quot;) {
4829                 $rootString  = &quot;    ScriptExecutionContext* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().scriptExecutionContext());\n&quot;;
4830                 $rootString .= &quot;    if (!root)\n&quot;;
4831                 $rootString .= &quot;        return false;\n&quot;;
4832                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4833                 $rootString .= &quot;        *reason = \&quot;Reachable from ScriptExecutionContext\&quot;;\n&quot;;
4834             } else {
4835                 $rootString  = &quot;    void* root = WebCore::root(&amp;js${interfaceName}-&gt;wrapped());\n&quot;;
4836                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4837                 $rootString .= &quot;        *reason = \&quot;Reachable from js${interfaceName}\&quot;;\n&quot;;
4838             }
4839 
4840             push(@implContent, $rootString);
4841             push(@implContent, &quot;    return visitor.containsOpaqueRoot(root);\n&quot;);
4842         } else {
4843             if (!$emittedJSCast) {
4844                 push(@implContent, &quot;    UNUSED_PARAM(handle);\n&quot;);
4845             }
4846             push(@implContent, &quot;    UNUSED_PARAM(visitor);\n&quot;);
4847             push(@implContent, &quot;    UNUSED_PARAM(reason);\n&quot;);
4848             push(@implContent, &quot;    return false;\n&quot;);
4849         }
4850         push(@implContent, &quot;}\n\n&quot;);
4851     }
4852 
4853     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{JSCustomFinalize}) {
4854         push(@implContent, &quot;void JS${interfaceName}Owner::finalize(JSC::Handle&lt;JSC::Unknown&gt; handle, void* context)\n&quot;);
4855         push(@implContent, &quot;{\n&quot;);
4856         push(@implContent, &quot;    auto* js${interfaceName} = static_cast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4857         push(@implContent, &quot;    auto&amp; world = *static_cast&lt;DOMWrapperWorld*&gt;(context);\n&quot;);
4858         push(@implContent, &quot;    uncacheWrapper(world, &amp;js${interfaceName}-&gt;wrapped(), js${interfaceName});\n&quot;);
4859         push(@implContent, &quot;}\n\n&quot;);
4860     }
4861 
4862     if (ShouldGenerateToJSImplementation($hasParent, $interface)) {
4863         my $vtableNameGnu = GetGnuVTableNameForInterface($interface);
4864         my $vtableRefGnu = GetGnuVTableRefForInterface($interface);
4865         my $vtableRefWin = GetWinVTableRefForInterface($interface);
4866 
4867         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4868 #if ENABLE(BINDING_INTEGRITY)
4869 #if PLATFORM(WIN)
4870 #pragma warning(disable: 4483)
4871 extern &quot;C&quot; { extern void (*const ${vtableRefWin}[])(); }
4872 #else
4873 extern &quot;C&quot; { extern void* ${vtableNameGnu}[]; }
4874 #endif
4875 #endif
4876 
4877 END
4878 
4879         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4880         push(@implContent, &quot;{\n&quot;);
4881         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4882 
4883 #if ENABLE(BINDING_INTEGRITY)
4884     void* actualVTablePointer = getVTablePointer(impl.ptr());
4885 #if PLATFORM(WIN)
4886     void* expectedVTablePointer = ${vtableRefWin};
4887 #else
4888     void* expectedVTablePointer = ${vtableRefGnu};
4889 #endif
4890 
4891     // If this fails ${implType} does not have a vtable, so you need to add the
4892     // ImplementationLacksVTable attribute to the interface definition
4893     static_assert(std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is not polymorphic&quot;);
4894 
4895     // If you hit this assertion you either have a use after free bug, or
4896     // ${implType} has subclasses. If ${implType} has subclasses that get passed
4897     // to toJS() we currently require $interfaceName you to opt out of binding hardening
4898     // by adding the SkipVTableValidation attribute to the interface IDL definition
4899     RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
4900 #endif
4901 END
4902         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
4903     // If you hit this failure the interface definition has the ImplementationLacksVTable
4904     // attribute. You should remove that attribute. If the class has subclasses
4905     // that may be passed through this toJS() function you should use the SkipVTableValidation
4906     // attribute to $interfaceName.
4907     static_assert(!std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is polymorphic but the IDL claims it is not&quot;);
4908 END
4909         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
4910     globalObject-&gt;vm().heap.reportExtraMemoryAllocated(impl-&gt;memoryCost());
4911 END
4912 
4913         push(@implContent, &quot;    return createWrapper&lt;${implType}&gt;(globalObject, WTFMove(impl));\n&quot;);
4914         push(@implContent, &quot;}\n\n&quot;);
4915 
4916         push(@implContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);
4917         push(@implContent, &quot;{\n&quot;);
4918         push(@implContent, &quot;    return wrap(lexicalGlobalObject, globalObject, impl);\n&quot;);
4919         push(@implContent, &quot;}\n\n&quot;);
4920     }
4921 
4922     if (ShouldGenerateToWrapped($hasParent, $interface) and !$interface-&gt;extendedAttributes-&gt;{JSCustomToNativeObject}) {
4923         push(@implContent, &quot;${implType}* ${className}::toWrapped(JSC::VM&amp; vm, JSC::JSValue value)\n&quot;);
4924         push(@implContent, &quot;{\n&quot;);
4925         push(@implContent, &quot;    if (auto* wrapper = &quot; . GetCastingHelperForThisObject($interface) . &quot;(vm, value))\n&quot;);
4926         push(@implContent, &quot;        return &amp;wrapper-&gt;wrapped();\n&quot;);
4927         push(@implContent, &quot;    return nullptr;\n&quot;);
4928         push(@implContent, &quot;}\n&quot;);
4929     }
4930 
4931     push(@implContent, &quot;\n}\n&quot;);
4932 
4933     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
4934     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
4935 }
4936 
4937 sub GenerateAttributeGetterBodyDefinition
4938 {
4939     my ($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional) = @_;
4940     
4941     my @signatureArguments = ();
4942     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);
4943     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4944     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4945     
4946     push(@$outputArray, &quot;static inline JSValue ${attributeGetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4947     push(@$outputArray, &quot;{\n&quot;);
4948     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
4949     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
4950 
4951     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp;
4952         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp;
4953         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter}) {
4954         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4955         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4956             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
4957         } else {
4958             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
4959         }
4960         push(@$outputArray, &quot;        return jsUndefined();\n&quot;);
4961     }
4962     
4963     if (HasCustomGetter($attribute)) {
4964         my $implGetterFunctionName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name);
4965         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(lexicalGlobalObject);\n&quot;);
4966     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4967         $implIncludes{&quot;EventNames.h&quot;} = 1;
4968         my $getter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;windowEventHandlerAttribute&quot;
4969             : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;documentEventHandlerAttribute&quot;
4970             : &quot;eventHandlerAttribute&quot;;
4971         my $eventName = EventHandlerAttributeEventName($attribute);
4972         push(@$outputArray, &quot;    return $getter(thisObject.wrapped(), $eventName, worldForDOMObject(thisObject));\n&quot;);
4973     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4974         my $constructorType = $attribute-&gt;type-&gt;name;
4975         $constructorType =~ s/Constructor$//;
4976         # When Constructor attribute is used by DOMWindow.idl, it&#39;s correct to pass thisObject as the global object
4977         # When JSDOMWrappers have a back-pointer to the globalObject we can pass thisObject-&gt;globalObject()
4978         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4979             my $named = ($constructorType =~ /Named$/) ? &quot;Named&quot; : &quot;&quot;;
4980             $constructorType =~ s/Named$//;
4981             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject);\n&quot;);
4982         } else {
4983             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
4984             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(JSC::getVM(&amp;lexicalGlobalObject), thisObject.globalObject());\n&quot;);
4985         }
4986     } else {
4987         if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4988             push(@$outputArray, &quot;    if (JSValue cachedValue = thisObject.m_&quot; . $attribute-&gt;name . &quot;.get())\n&quot;);
4989             push(@$outputArray, &quot;        return cachedValue;\n&quot;);
4990         }
4991         
4992         my @callWithArgs = GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;jsUndefined()&quot;, &quot;thisObject&quot;);
4993         
4994         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;GetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
4995         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
4996         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);
4997         
4998         unshift(@arguments, @callWithArgs);
4999 
5000         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;
5001         my $toJSExpression = NativeToJSValueUsingReferences($attribute, $interface, &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;, $globalObjectReference);
5002         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike or $attribute-&gt;isSetLike;
5003 
5004         if (!IsReadonly($attribute)) {
5005             my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5006             if ($callTracingCallback) {
5007                 my @callTracerArguments = ();
5008                 GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, &quot;    &quot;);
5009             }
5010         }
5011 
5012         push(@$outputArray, &quot;    JSValue result = ${toJSExpression};\n&quot;);
5013         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
5014         push(@$outputArray, &quot;    return result;\n&quot;);
5015     }
5016     push(@$outputArray, &quot;}\n\n&quot;);
5017 }
5018 
5019 sub GenerateAttributeGetterTrampolineDefinition
5020 {
5021     my ($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional) = @_;
5022     
5023     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5024     
5025     my $callAttributeGetterName = &quot;get&quot;;
5026     $callAttributeGetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5027     
5028     my @templateParameters = ();
5029     push(@templateParameters, $attributeGetterBodyName);
5030     if ($attribute-&gt;extendedAttributes-&gt;{LenientThis}) {
5031         push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;)
5032     } elsif ($codeGenerator-&gt;IsPromiseType($attribute-&gt;type)) {
5033         push(@templateParameters, &quot;CastedThisErrorBehavior::RejectPromise&quot;)
5034     } elsif (IsAcceleratedDOMAttribute($interface, $attribute)) {
5035         push(@templateParameters, &quot;CastedThisErrorBehavior::Assert&quot;);
5036     }
5037     
5038     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);
5039     push(@$outputArray, &quot;{\n&quot;);
5040     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);
5041     push(@$outputArray, &quot;}\n\n&quot;);
5042 }
5043 
5044 sub GenerateAttributeGetterDefinition
5045 {
5046     my ($outputArray, $interface, $className, $attribute) = @_;
5047 
5048     return if IsJSBuiltin($interface, $attribute);
5049 
5050     my $attributeGetterName = GetAttributeGetterName($interface, $className, $attribute);
5051     my $attributeGetterBodyName = $attributeGetterName . &quot;Getter&quot;;
5052     
5053     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5054     if ($conditional) {
5055         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5056         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5057     }
5058     
5059     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
5060     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
5061     
5062     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5063 }
5064 
5065 sub GenerateAttributeSetterBodyDefinition
5066 {
5067     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
5068 
5069     my @signatureArguments = ();
5070     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);
5071     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
5072     push(@signatureArguments, &quot;JSValue value&quot;);
5073     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
5074     
5075     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5076     push(@$outputArray, &quot;{\n&quot;);
5077     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
5078     if ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) || $attribute-&gt;extendedAttributes-&gt;{Replaceable} || $attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5079         push(@$outputArray, &quot;    VM&amp; vm = throwScope.vm();\n&quot;);
5080     } else {
5081         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5082     }
5083 
5084     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;lexicalGlobalObject&quot;);
5085 
5086     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
5087         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5088         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5089             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
5090         } else {
5091             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
5092         }
5093         push(@$outputArray, &quot;        return false;\n&quot;);
5094     }
5095     
5096     if (HasCustomSetter($attribute)) {
5097         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
5098         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(lexicalGlobalObject, value);\n&quot;);
5099         push(@$outputArray, &quot;    return true;\n&quot;);
5100     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
5101         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5102         my $eventName = EventHandlerAttributeEventName($attribute);
5103         # FIXME: Find a way to do this special case without hardcoding the class and attribute names here.
5104         if (($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; or $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;) and $attribute-&gt;name eq &quot;onerror&quot;) {
5105             AddToImplIncludes(&quot;JSErrorHandler.h&quot;, $conditional);
5106             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(lexicalGlobalObject, value, thisObject), worldForDOMObject(thisObject));\n&quot;);
5107         } else {
5108             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5109             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
5110                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
5111                 : &quot;setEventHandlerAttribute&quot;;
5112             push(@$outputArray, &quot;    $setter(lexicalGlobalObject, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);
5113         }
5114         push(@$outputArray, &quot;    return true;\n&quot;);
5115     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
5116         my $constructorType = $attribute-&gt;type-&gt;name;
5117         $constructorType =~ s/Constructor$//;
5118         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
5119         # We do not generate the header file for NamedConstructor of class XXXX,
5120         # since we generate the NamedConstructor declaration into the header file of class XXXX.
5121         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
5122             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
5123         }
5124         my $id = $attribute-&gt;name;
5125         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
5126         push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5127     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
5128         my $id = $attribute-&gt;name;
5129         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
5130         if (AttributeShouldBeOnInstance($interface, $attribute)) {
5131             push(@$outputArray, &quot;    return replaceStaticPropertySlot(vm, &amp;thisObject, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5132         } else {
5133             push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5134         }
5135     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5136         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
5137         
5138         # 3.5.9.1. Let Q be ? Get(O, id).
5139         my $id = $attribute-&gt;name;
5140         push(@$outputArray, &quot;    auto id = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);
5141         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;lexicalGlobalObject, id);\n&quot;);
5142         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5143         
5144         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
5145         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
5146         push(@$outputArray, &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;);
5147         push(@$outputArray, &quot;        return false;\n&quot;);
5148         push(@$outputArray, &quot;    }\n&quot;);
5149         
5150         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
5151         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
5152         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);
5153         
5154         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
5155         # FIXME: What should the second value to the PutPropertySlot be?
5156         # (https://github.com/heycam/webidl/issues/368)
5157         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
5158         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;lexicalGlobalObject, forwardId, value, slot);\n&quot;);
5159         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5160         
5161         push(@$outputArray, &quot;    return true;\n&quot;);
5162     } else {
5163         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5164        
5165         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5166             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5167             # the standard conversion, but rather silently fail on invalid enumeration values.
5168             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(lexicalGlobalObject, value);\n&quot;);
5169             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5170             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5171             push(@$outputArray, &quot;        return false;\n&quot;);
5172             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5173         } else {
5174             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;
5175             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5176 
5177             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);
5178             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5179             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5180         }
5181 
5182         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5183 
5184         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5185 
5186         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
5187         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);
5188 
5189         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5190         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5191 
5192         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5193         if ($callTracingCallback) {
5194             my $indent = &quot;    &quot;;
5195             my @callTracerArguments = (&quot;nativeValue&quot;);
5196             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5197         }
5198 
5199         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5200         push(@$outputArray, &quot;    AttributeSetter::call(lexicalGlobalObject, throwScope, [&amp;] {\n&quot;);
5201         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5202         push(@$outputArray, &quot;    });\n&quot;);
5203         push(@$outputArray, &quot;    return true;\n&quot;);
5204     }
5205     push(@$outputArray, &quot;}\n\n&quot;);
5206 }
5207 
5208 sub GenerateAttributeSetterTrampolineDefinition
5209 {
5210     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5211     
5212     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5213     
5214     my $callAttributeSetterName = &quot;set&quot;;
5215     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5216     
5217     my @templateParameters = ();
5218     push(@templateParameters, $attributeSetterBodyName);
5219     push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;) if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
5220     
5221     push(@$outputArray, &quot;bool ${attributeSetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
5222     push(@$outputArray, &quot;{\n&quot;);
5223     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);
5224     push(@$outputArray, &quot;}\n\n&quot;);
5225 }
5226 
5227 sub GenerateAttributeSetterDefinition
5228 {
5229     my ($outputArray, $interface, $className, $attribute) = @_;
5230     
5231     return if IsReadonly($attribute);
5232     return if IsJSBuiltin($interface, $attribute);
5233     
5234     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5235     if ($conditional) {
5236         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5237         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5238     }
5239 
5240     my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
5241     if ($readWriteConditional) {
5242         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
5243         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5244     }
5245 
5246     my $attributeSetterName = GetAttributeSetterName($interface, $className, $attribute);
5247     my $attributeSetterBodyName = $attributeSetterName . &quot;Setter&quot;;
5248     
5249     GenerateAttributeSetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional);
5250     GenerateAttributeSetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional);
5251 
5252     push(@$outputArray, &quot;#endif\n\n&quot;) if $readWriteConditional;
5253     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5254 }
5255 
5256 sub GenerateOperationTrampolineDefinition
5257 {
5258     my ($outputArray, $interface, $className, $operation, $functionName, $functionBodyName) = @_;
5259 
5260     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5261     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5262     my $exposureScope = $interface-&gt;extendedAttributes-&gt;{Exposed} ? &quot;WindowOrWorker&quot; : &quot;WindowOnly&quot;;
5263 
5264     my $callFunctionName = &quot;call&quot;;
5265     $callFunctionName .= &quot;Static&quot; if $operation-&gt;isStatic;
5266     $callFunctionName .= &quot;ReturningOwnPromise&quot; if $hasPromiseReturnType &amp;&amp; $operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5267 
5268     my @callFunctionTemplateArguments = ();
5269     push(@callFunctionTemplateArguments, $functionBodyName);
5270     push(@callFunctionTemplateArguments, &quot;CastedThisErrorBehavior::Assert&quot;) if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
5271 
5272     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5273     push(@$outputArray, &quot;{\n&quot;);
5274     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*lexicalGlobalObject, *callFrame, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);
5275     push(@$outputArray, &quot;}\n\n&quot;);
5276 }
5277 
5278 sub GenerateOperationBodyDefinition
5279 {
5280     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded, $generatingOverloadDispatcher) = @_;
5281 
5282     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5283     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5284     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5285 
5286     my @signatureArguments = ();
5287     push(@signatureArguments, &quot;JSC::JSGlobalObject* lexicalGlobalObject&quot;);
5288     push(@signatureArguments, &quot;JSC::CallFrame* callFrame&quot;);
5289     push(@signatureArguments, &quot;typename ${idlOperationType}&lt;${className}&gt;::ClassParameter castedThis&quot;) if !$operation-&gt;isStatic;
5290     push(@signatureArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp; promise&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5291     push(@signatureArguments, &quot;JSC::ThrowScope&amp; throwScope&quot;);
5292 
5293     push(@$outputArray, &quot;static inline JSC::EncodedJSValue ${functionBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5294     push(@$outputArray, &quot;{\n&quot;);
5295     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
5296     push(@$outputArray, &quot;    UNUSED_PARAM(callFrame);\n&quot;);
5297     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5298 
5299     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;) unless $generatingOverloadDispatcher;
5300 
5301     # For overloads, we generate the security check in the overload dispatcher, instead of the body of each overload, as per specification:
5302     # https://heycam.github.io/webidl/#dfn-create-operation-function
5303     if (!$isOverloaded || $generatingOverloadDispatcher) {
5304         if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} and !$operation-&gt;extendedAttributes-&gt;{DoNotCheckSecurity}) {
5305             assert(&quot;Security checks are not supported for static operations.&quot;) if $operation-&gt;isStatic;
5306             
5307             AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5308             if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5309                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);
5310                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5311             } else {
5312                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);
5313                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5314             }
5315         }
5316     }
5317 
5318     my $indent = &quot;    &quot;;
5319 
5320     if ($generatingOverloadDispatcher) {
5321         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
5322         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
5323 
5324         my @argumentsToForward = ();
5325         push(@argumentsToForward, &quot;lexicalGlobalObject&quot;);
5326         push(@argumentsToForward, &quot;callFrame&quot;);
5327         push(@argumentsToForward, &quot;castedThis&quot;) if !$operation-&gt;isStatic;
5328         push(@argumentsToForward, &quot;WTFMove(promise)&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5329         push(@argumentsToForward, &quot;throwScope&quot;);
5330 
5331         GenerateOverloadDispatcher($operation, $interface, $functionName, &quot;Body&quot;, join(&quot;, &quot;, @argumentsToForward));
5332     } elsif (HasCustomMethod($operation)) {
5333         GenerateImplementationCustomFunctionCall($outputArray, $operation, $interface, $className, $functionImplementationName, $indent);
5334     } else {
5335         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isSetLike &amp;&amp; !$operation-&gt;isStatic) {
5336             push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5337         }
5338 
5339         GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5340         my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5341 
5342         if ($operation-&gt;extendedAttributes-&gt;{ResultField}) {
5343             my $resultName = $operation-&gt;extendedAttributes-&gt;{ResultField};
5344             push(@$outputArray, &quot;    auto implResult = $functionString;\n&quot;);
5345             GenerateImplementationFunctionCall($outputArray, $operation, $interface, &quot;WTFMove(implResult.$resultName)&quot;, $indent);
5346         } else {
5347             GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5348         }
5349     }
5350 
5351     push(@$outputArray, &quot;}\n\n&quot;);
5352 }
5353 
5354 sub GenerateOperationDefinition
5355 {
5356     my ($outputArray, $interface, $className, $operation) = @_;
5357 
5358     return if IsJSBuiltin($interface, $operation);
5359     return if $operation-&gt;isIterable;
5360     return if $operation-&gt;isSerializer;
5361 
5362     my $isCustom = HasCustomMethod($operation);
5363     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5364 
5365     assert(&quot;[Custom] is not supported for overloaded operations.&quot;) if $isCustom &amp;&amp; $isOverloaded;
5366 
5367     my $inAppleCopyright = 0;
5368 
5369     if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
5370         if (!$inAppleCopyright) {
5371             push(@$outputArray, $beginAppleCopyrightForSourceFiles);
5372             $inAppleCopyright = 1;
5373         }
5374     } elsif ($inAppleCopyright) {
5375         push(@$outputArray, $endAppleCopyright);
5376         $inAppleCopyright = 0;
5377     }
5378 
5379     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5380     if ($conditional) {
5381         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5382         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5383     }
5384 
5385     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5386 
5387     AddToImplIncludesForIDLType($operation-&gt;type, $conditional) unless $isCustom or $hasPromiseReturnType;
5388     AddToImplIncludes(&quot;JSDOMOperation.h&quot;, $conditional) if !$hasPromiseReturnType;
5389     AddToImplIncludes(&quot;JSDOMOperationReturningPromise.h&quot;, $conditional) if $hasPromiseReturnType;
5390 
5391     my $functionName = GetFunctionName($interface, $className, $operation);
5392     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
5393     my $functionBodyName = ($isOverloaded ? $functionName . $operation-&gt;{overloadIndex} : $functionName) . &quot;Body&quot;;
5394 
5395     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded);
5396 
5397     # Overloaded operations don&#39;t generate a trampoline for each overload, and instead have a single dispatch trampoline
5398     # that gets generated after the last overload body has been generated.
5399     unless ($isOverloaded) {
5400         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $functionBodyName);
5401     }
5402 
5403     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5404 
5405     # Generate a function dispatching call to the rest of the overloads.
5406     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5407         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5408         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5409         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5410 
5411         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
5412         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, $isOverloaded, 1);
5413         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5414     
5415         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5416     }
5417 
5418 
5419     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5420         if ($conditional) {
5421             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5422             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5423         }
5424 
5425         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
5426         my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
5427         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject* lexicalGlobalObject, $className* castedThis&quot;);
5428         foreach my $argument (@{$operation-&gt;arguments}) {
5429             my $type = $argument-&gt;type;
5430             my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
5431             my $name = $argument-&gt;name;
5432             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5433             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5434         }
5435         push(@$outputArray, &quot;)\n&quot;);
5436         push(@$outputArray, &quot;{\n&quot;);
5437         push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
5438         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
5439         push(@$outputArray, &quot;    IGNORE_WARNINGS_BEGIN(\&quot;frame-address\&quot;)\n&quot;);
5440         push(@$outputArray, &quot;    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);\n&quot;);
5441         push(@$outputArray, &quot;    IGNORE_WARNINGS_END\n&quot;);
5442         push(@$outputArray, &quot;    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);\n&quot;);
5443         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5444         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5445         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5446         
5447         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5448         
5449         my @arguments = ();
5450         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);
5451         
5452         foreach my $argument (@{$operation-&gt;arguments}) {
5453             my $value = &quot;&quot;;
5454             my $type = $argument-&gt;type;
5455             my $name = $argument-&gt;name;
5456             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5457             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5458 
5459             my ($nativeValue, $mayThrowException) = ToNativeForFunctionWithoutTypeCheck($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});
5460             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5461             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5462             $value = &quot;WTFMove($name)&quot;;
5463 
5464             if ($shouldPassByReference) {
5465                 $value = &quot;*$name&quot;;
5466             }
5467             push(@arguments, $value);
5468         }
5469         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5470         $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5471         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5472         push(@$outputArray, &quot;}\n\n&quot;);
5473 
5474         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5475     }
5476 
5477     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5478 }
5479 
5480 sub GenerateSerializerDefinition
5481 {
5482     my ($interface, $className) = @_;
5483 
5484     my $interfaceName = $interface-&gt;type-&gt;name;
5485 
5486     my $parentSerializerInterface = 0;
5487     if ($interface-&gt;serializable-&gt;hasInherit) {
5488         $codeGenerator-&gt;ForAllParents($interface, sub {
5489             my $parentInterface = shift;
5490             if ($parentInterface-&gt;serializable &amp;&amp; !$parentSerializerInterface) {
5491                 $parentSerializerInterface = $parentInterface;
5492             }
5493         }, 0);
5494         die &quot;Failed to find parent interface with \&quot;serializer\&quot; for \&quot;inherit\&quot; serializer in $interfaceName\n&quot; if !$parentSerializerInterface;
5495     }
5496 
5497     my @serializedAttributes = ();
5498 
5499     foreach my $attributeName (@{$interface-&gt;serializable-&gt;attributes}) {
5500         my $foundAttribute = 0;
5501         foreach my $attribute (@{$interface-&gt;attributes}) {
5502             if ($attributeName eq $attribute-&gt;name) {
5503                 $foundAttribute = 1;
5504                 if ($codeGenerator-&gt;IsSerializableAttribute($interface, $attribute)) {
5505                     push(@serializedAttributes, $attribute);                
5506                     last;
5507                 }                    
5508                 die &quot;Explicit \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; is not serializable\n&quot; if !$interface-&gt;serializable-&gt;hasAttribute;
5509                 last;
5510             }
5511         }
5512         die &quot;Failed to find \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; in $interfaceName\n&quot; if !$foundAttribute;
5513     }
5514 
5515     my $serializerFunctionName = &quot;toJSON&quot;;
5516     my $serializerNativeFunctionName = $codeGenerator-&gt;WK_lcfirst($className) . &quot;PrototypeFunction&quot; . $codeGenerator-&gt;WK_ucfirst($serializerFunctionName);
5517 
5518     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
5519 
5520     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(JSGlobalObject&amp; lexicalGlobalObject, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);
5521     push(@implContent, &quot;{\n&quot;);
5522     push(@implContent, &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);
5523 
5524     if ($interface-&gt;serializable-&gt;hasInherit) {
5525         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
5526         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(lexicalGlobalObject, thisObject, globalObject, throwScope);\n&quot;);
5527     } else {
5528         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n&quot;);
5529     }
5530     push(@implContent, &quot;\n&quot;);
5531 
5532     foreach my $attribute (@serializedAttributes) {
5533         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5534 
5535         my $name = $attribute-&gt;name;
5536         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
5537         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(lexicalGlobalObject, thisObject, throwScope);\n&quot;);
5538         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5539 
5540         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5541             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5542             if ($attribute-&gt;type-&gt;isNullable) {
5543                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
5544                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
5545                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5546                 push(@implContent, &quot;    } else\n&quot;);
5547                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5548             } else {
5549                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
5550                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5551             }
5552         } else {
5553             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5554         }
5555 
5556         push(@implContent, &quot;\n&quot;);
5557     }
5558 
5559     push(@implContent, &quot;    return result;\n&quot;);
5560     push(@implContent, &quot;}\n&quot;);
5561     push(@implContent, &quot;\n&quot;);
5562 
5563     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(JSGlobalObject* lexicalGlobalObject, CallFrame*, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);
5564     push(@implContent, &quot;{\n&quot;);
5565     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*lexicalGlobalObject, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);
5566     push(@implContent, &quot;}\n&quot;);
5567     push(@implContent, &quot;\n&quot;);
5568     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5569     push(@implContent, &quot;{\n&quot;);
5570     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*lexicalGlobalObject, *callFrame, \&quot;${serializerFunctionName}\&quot;);\n&quot;);
5571     push(@implContent, &quot;}\n&quot;);
5572     push(@implContent, &quot;\n&quot;);
5573 }
5574 
5575 sub GenerateGetCallData
5576 {
5577     my ($outputArray, $interface, $className) = @_;
5578 
5579     return if $interface-&gt;extendedAttributes-&gt;{CustomGetCallData};
5580 
5581     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
5582         GeneratePluginCall($outputArray, $interface, $className);
5583     } else {
5584         GenerateLegacyCallerDefinitions($outputArray, $interface, $className);
5585     }
5586 }
5587 
5588 sub GeneratePluginCall
5589 {
5590     my ($outputArray, $interface, $className) = @_;
5591 
5592     AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
5593 
5594     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell* cell, CallData&amp; callData)\n&quot;);
5595     push(@$outputArray, &quot;{\n&quot;);
5596     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
5597     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
5598 
5599     push(@$outputArray, &quot;    return pluginElementCustomGetCallData(thisObject, callData);\n&quot;);
5600     push(@$outputArray, &quot;}\n&quot;);
5601     push(@$outputArray, &quot;\n&quot;);
5602 }
5603 
5604 sub GenerateLegacyCallerDefinitions
5605 {
5606     my ($outputArray, $interface, $className) = @_;
5607 
5608     my @legacyCallers = @{$interface-&gt;{LegacyCallers}};
5609     if (@legacyCallers &gt; 1) {
5610         foreach my $legacyCaller (@legacyCallers) {
5611             GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCaller);
5612         }
5613 
5614         my $overloadFunctionPrefix = &quot;call${className}&quot;;
5615 
5616         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5617         push(@$outputArray, &quot;{\n&quot;);
5618         push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
5619         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5620         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5621 
5622         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);
5623 
5624         push(@$outputArray, &quot;}\n\n&quot;);
5625     } else {
5626         GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCallers[0]);
5627     }
5628 
5629     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell*, CallData&amp; callData)\n&quot;);
5630     push(@$outputArray, &quot;{\n&quot;);
5631     push(@$outputArray, &quot;    callData.native.function = call${className};\n&quot;);
5632     push(@$outputArray, &quot;    return CallType::Host;\n&quot;);
5633     push(@$outputArray, &quot;}\n&quot;);
5634     push(@$outputArray, &quot;\n&quot;);
5635 }
5636 
5637 sub GenerateLegacyCallerDefinition
5638 {
5639     my ($outputArray, $interface, $className, $operation) = @_;
5640 
5641     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5642     if ($isOverloaded) {
5643         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5644     } else {
5645         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5646     }
5647 
5648     push(@$outputArray, &quot;{\n&quot;);
5649     push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
5650     push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5651     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5652 
5653     my $indent = &quot;    &quot;;
5654     GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5655 
5656     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(callFrame-&gt;jsCallee());\n&quot;);
5657     push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
5658     push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5659 
5660     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;legacyCallerOperationFromBindings&quot;;
5661     my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5662 
5663     GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5664 
5665     push(@$outputArray, &quot;}\n\n&quot;);
5666 }
5667 
5668 sub GenerateCallWithUsingReferences
5669 {
5670     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5671 
5672     my $callFramePointer = &quot;callFrame&quot;;
5673     my $callFrameReference = &quot;*callFrame&quot;;
5674     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;;
5675 
5676     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);
5677 }
5678 
5679 # FIXME: We should remove GenerateCallWithUsingPointers and combine GenerateCallWithUsingReferences and GenerateCallWith
5680 sub GenerateCallWithUsingPointers
5681 {
5682     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5683 
5684     my $callFramePointer = &quot;callFrame&quot;;
5685     my $callFrameReference = &quot;*callFrame&quot;;
5686     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot;;
5687 
5688     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);
5689 }
5690 
5691 sub GenerateConstructorCallWithUsingPointers
5692 {
5693     my ($callWith, $outputArray, $visibleInterfaceName, $thisReference, $indent) = @_;
5694 
5695     my $callFramePointer = &quot;callFrame&quot;;
5696     my $callFrameReference = &quot;*callFrame&quot;;
5697     my $globalObject = &quot;castedThis-&gt;globalObject()&quot;;
5698     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*lexicalGlobalObject, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;
5699     my $scriptExecutionContextAccessor = &quot;castedThis&quot;;
5700 
5701     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);
5702 }
5703 
5704 sub GenerateCallWith
5705 {
5706     my ($callWith, $outputArray, $returnValue, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;
5707 
5708     return () unless $callWith;
5709 
5710     $indent ||= &quot;    &quot;;
5711 
5712     my @callWithArgs;
5713     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;)) {
5714         push(@callWithArgs, &quot;*${globalObject}&quot;);
5715         push(@callWithArgs, $callFrameReference);
5716     }
5717     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;)) {
5718         push(@callWithArgs, &quot;*${globalObject}&quot;);
5719     }
5720     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ScriptExecutionContext&quot;)) {
5721         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5722         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5723         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5724         push(@callWithArgs, &quot;*context&quot;);
5725     }
5726     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;Document&quot;)) {
5727         AddToImplIncludes(&quot;Document.h&quot;);
5728         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5729         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5730         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5731         push(@$outputArray, $indent . &quot;ASSERT(context-&gt;isDocument());\n&quot;);
5732         push(@$outputArray, $indent . &quot;auto&amp; document = downcast&lt;Document&gt;(*context);\n&quot;);
5733         push(@callWithArgs, &quot;document&quot;);
5734     }
5735     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentDocument&quot;)) {
5736         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5737         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5738         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow(*$globalObject, $callFrameReference).document();\n&quot;);
5739         push(@$outputArray, $indent . &quot;if (!incumbentDocument)\n&quot;);
5740         push(@$outputArray, $indent . &quot;    return&quot; . ($returnValue ? &quot; &quot; . $returnValue : &quot;&quot;) . &quot;;\n&quot;);
5741         push(@callWithArgs, &quot;*incumbentDocument&quot;);
5742     }
5743     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ResponsibleDocument&quot;)) {
5744         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5745         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5746         push(@callWithArgs, &quot;responsibleDocument(${globalObject}-&gt;vm(), $callFrameReference)&quot;);
5747     }
5748     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ActiveWindow&quot;)) {
5749         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5750         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5751         push(@callWithArgs, &quot;activeDOMWindow(*$globalObject)&quot;);
5752     }
5753     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;FirstWindow&quot;)) {
5754         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5755         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5756         push(@callWithArgs, &quot;firstDOMWindow(*$globalObject)&quot;);
5757     }
5758     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentWindow&quot;)) {
5759         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5760         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5761         push(@callWithArgs, &quot;incumbentDOMWindow(*$globalObject, $callFrameReference)&quot;);
5762     }
5763     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;RuntimeFlags&quot;)) {
5764         push(@callWithArgs, &quot;${globalObject}-&gt;runtimeFlags()&quot;);
5765     }
5766     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;World&quot;)) {
5767         push(@callWithArgs, &quot;worldForDOMObject(${thisReference})&quot;);
5768     }
5769 
5770     return @callWithArgs;
5771 }
5772 
5773 sub GenerateArgumentsCountCheck
5774 {
5775     my ($outputArray, $operation, $interface, $indent) = @_;
5776 
5777     # Overloaded operations don&#39;t need to check the argument count since the 
5778     # dispatch function does for them.
5779     return if $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5780 
5781     my $numMandatoryArguments = @{$operation-&gt;arguments};
5782     foreach my $argument (reverse(@{$operation-&gt;arguments})) {
5783         if ($argument-&gt;isOptional or $argument-&gt;isVariadic) {
5784             $numMandatoryArguments--;
5785         } else {
5786             last;
5787         }
5788     }
5789     if ($numMandatoryArguments &gt;= 1) {
5790         push(@$outputArray, $indent . &quot;if (UNLIKELY(callFrame-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);
5791         push(@$outputArray, $indent . &quot;    return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));\n&quot;);
5792     }
5793 }
5794 
5795 my %automaticallyGeneratedDefaultValues = (
5796     &quot;any&quot; =&gt; &quot;undefined&quot;,
5797 
5798     # toString() will convert undefined to the string &quot;undefined&quot;;
5799     # (note that this optimizes a behavior that is almost never useful)
5800     &quot;DOMString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5801     &quot;USVString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5802 
5803     # JSValue::toBoolean() will convert undefined to false.
5804     &quot;boolean&quot; =&gt; &quot;false&quot;,
5805 
5806     # JSValue::toInt*() / JSValue::toUint*() will convert undefined to 0.
5807     &quot;byte&quot; =&gt; &quot;0&quot;,
5808     &quot;long long&quot; =&gt; &quot;0&quot;,
5809     &quot;long&quot; =&gt; &quot;0&quot;,
5810     &quot;octet&quot; =&gt; &quot;0&quot;,
5811     &quot;short&quot; =&gt; &quot;0&quot;,
5812     &quot;unsigned long long&quot; =&gt; &quot;0&quot;,
5813     &quot;unsigned long&quot; =&gt; &quot;0&quot;,
5814     &quot;unsigned short&quot; =&gt; &quot;0&quot;,
5815 
5816     # toNumber() / toFloat() convert undefined to NaN.
5817     &quot;double&quot; =&gt; &quot;NaN&quot;,
5818     &quot;float&quot; =&gt; &quot;NaN&quot;,
5819     &quot;unrestricted double&quot; =&gt; &quot;NaN&quot;,
5820     &quot;unrestricted float&quot; =&gt; &quot;NaN&quot;,
5821 );
5822 
5823 sub WillConvertUndefinedToDefaultParameterValue
5824 {
5825     my ($parameterType, $defaultValue) = @_;
5826 
5827     my $automaticallyGeneratedDefaultValue = $automaticallyGeneratedDefaultValues{$parameterType-&gt;name};
5828     return 1 if defined $automaticallyGeneratedDefaultValue &amp;&amp; $automaticallyGeneratedDefaultValue eq $defaultValue;
5829 
5830     return 1 if $defaultValue eq &quot;null&quot; &amp;&amp; $codeGenerator-&gt;IsWrapperType($parameterType);
5831     return 1 if $defaultValue eq &quot;[]&quot; &amp;&amp; $codeGenerator-&gt;IsDictionaryType($parameterType);
5832 
5833     return 0;
5834 }
5835 
5836 sub NeedsExplicitPropagateExceptionCall
5837 {
5838     my ($operation) = @_;
5839 
5840     return 0 unless $operation-&gt;extendedAttributes-&gt;{MayThrowException};
5841 
5842     return $operation-&gt;type &amp;&amp; ($operation-&gt;type-&gt;name eq &quot;void&quot; || $codeGenerator-&gt;IsPromiseType($operation-&gt;type) || OperationHasForcedReturnValue($operation));
5843 }
5844 
5845 sub GenerateParametersCheck
5846 {
5847     my ($outputArray, $operation, $interface, $functionImplementationName, $indent) = @_;
5848 
5849     my $interfaceName = $interface-&gt;type-&gt;name;
5850     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
5851     my $numArguments = @{$operation-&gt;arguments};
5852     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5853     my $isConstructor = $operation-&gt;extendedAttributes-&gt;{Constructor} || $operation-&gt;extendedAttributes-&gt;{NamedConstructor};
5854 
5855     my $functionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5856     
5857     my @arguments = ();
5858     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);
5859     
5860     my $quotedFunctionName;
5861     if (!$isConstructor) {
5862         my $name = $operation-&gt;name;
5863         $quotedFunctionName = &quot;\&quot;$name\&quot;&quot;;
5864         push(@arguments, GenerateCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{CallWith}, \@$outputArray, &quot;JSValue::encode(jsUndefined())&quot;, &quot;*castedThis&quot;));
5865     } else {
5866         $quotedFunctionName = &quot;nullptr&quot;;
5867         push(@arguments, GenerateConstructorCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{ConstructorCallWith}, \@$outputArray, $visibleInterfaceName, &quot;*castedThis&quot;));
5868     }
5869 
5870     my $argumentIndex = 0;
5871     foreach my $argument (@{$operation-&gt;arguments}) {
5872         my $type = $argument-&gt;type;
5873 
5874         assert &quot;Optional arguments of non-nullable wrapper types are not supported (&quot; . $operation-&gt;name . &quot;)&quot; if $argument-&gt;isOptional &amp;&amp; !$type-&gt;isNullable &amp;&amp; $codeGenerator-&gt;IsWrapperType($type);
5875 
5876         if ($argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default)) {
5877             # As per Web IDL, optional dictionary arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
5878             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsDictionaryType($type);
5879 
5880             # Treat undefined the same as an empty sequence Or frozen array.
5881             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
5882 
5883             # We use undefined as default value for optional arguments of type &#39;any&#39; unless specified otherwise.
5884             $argument-&gt;default(&quot;undefined&quot;) if $type-&gt;name eq &quot;any&quot;;
5885 
5886             # We use the null string as default value for arguments of type DOMString unless specified otherwise.
5887             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsStringType($type);
5888 
5889             # As per Web IDL, passing undefined for a nullable argument is treated as null. Therefore, use null as
5890             # default value for nullable arguments unless otherwise specified.
5891             $argument-&gt;default(&quot;null&quot;) if $type-&gt;isNullable;
5892 
5893             # For callback arguments, the generated bindings treat undefined as null, so use null as implicit default value.
5894             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type);
5895         }
5896 
5897         my $name = $argument-&gt;name;
5898         my $value = $name;
5899 
5900         if ($argument-&gt;isVariadic) {
5901             AddToImplIncludes(&quot;JSDOMConvertVariadic.h&quot;, $conditional);
5902             AddToImplIncludesForIDLType($type, $conditional);
5903         
5904             my $IDLType = GetIDLType($interface, $type);
5905 
5906             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*lexicalGlobalObject, *callFrame, ${argumentIndex});\n&quot;);
5907             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5908 
5909             $value = &quot;WTFMove(${name})&quot;;
5910         } else {
5911             my $argumentLookupForConversion;
5912             my $optionalCheck;
5913             my $nativeValueCastFunction;
5914 
5915             if ($argument-&gt;isOptional) {
5916                 assert(&quot;[ReturnValue] is not supported for optional arguments&quot;) if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
5917 
5918                 if (defined($argument-&gt;default)) {
5919                     if (WillConvertUndefinedToDefaultParameterValue($type, $argument-&gt;default)) {
5920                         $argumentLookupForConversion = &quot;callFrame-&gt;argument($argumentIndex)&quot;;
5921                     } else {
5922                         my $defaultValue = GenerateDefaultValue($interface, $argument, $argument-&gt;type, $argument-&gt;default);
5923                         $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5924                         $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;
5925                     }
5926                 } else {
5927                     my $argumentIDLType = GetIDLType($interface, $argument-&gt;type);
5928 
5929                     my $defaultValue;
5930                     if ($codeGenerator-&gt;IsPromiseType($argument-&gt;type)) {
5931                         $defaultValue = &quot;nullptr&quot;;
5932                     } else {
5933                         $defaultValue = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;()&quot;;
5934                         $nativeValueCastFunction = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;&quot;;
5935                     }
5936 
5937                     $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5938                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;
5939                 }
5940             } else {
5941                 if ($argument-&gt;extendedAttributes-&gt;{ReturnValue}) {
5942                     push(@$outputArray, $indent . &quot;auto returnValue = callFrame-&gt;uncheckedArgument($argumentIndex);\n&quot;);
5943                     $argumentLookupForConversion = &quot;returnValue&quot;;
5944                 } else {
5945                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;
5946                 }
5947             }
5948 
5949             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
5950             my $argumentExceptionThrower = GetArgumentExceptionThrower($interface, $argument, $argumentIndex, $quotedFunctionName);
5951 
5952             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);
5953 
5954             $nativeValue = &quot;${nativeValueCastFunction}(&quot; . $nativeValue . &quot;)&quot; if defined $nativeValueCastFunction;
5955             $nativeValue = $optionalCheck . $nativeValue if defined $optionalCheck;
5956 
5957             push(@$outputArray, $indent . &quot;auto $name = ${nativeValue};\n&quot;);
5958             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5959 
5960             $value = PassArgumentExpression($name, $argument);
5961         }
5962 
5963         push(@arguments, $value);
5964         $argumentIndex++;
5965     }
5966 
5967     push(@arguments, &quot;WTFMove(promise)&quot;) if $operation-&gt;type &amp;&amp; $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy};
5968 
5969     my $functionString = &quot;$functionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5970     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5971 
5972     return $functionString;
5973 }
5974 
5975 sub GenerateDictionaryHeader
5976 {
5977     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5978 
5979     # - Add default header template and header protection.
5980     push(@headerContentHeader, GenerateHeaderContentHeader($dictionary));
5981 
5982     $headerIncludes{&quot;${className}.h&quot;} = 1;
5983 
5984     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5985     push(@headerContent, GenerateDictionaryHeaderContent($dictionary, $className));
5986     push(@headerContent, GenerateEnumerationsHeaderContent($dictionary, $enumerations));
5987     push(@headerContent, GenerateDictionariesHeaderContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5988     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5989 
5990     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
5991     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5992     
5993     # - Generate dependencies.
5994     if ($writeDependencies) {
5995         my @ancestors;
5996         my $parentType = $dictionary-&gt;parentType;
5997         while (defined($parentType)) {
5998             push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
5999             my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
6000             assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless $parentDictionary;
6001             $parentType = $parentDictionary-&gt;parentType;
6002         }
6003         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
6004         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
6005     }
6006 }
6007 
6008 sub GenerateDictionaryImplementation
6009 {
6010     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
6011 
6012     # - Add default header template
6013     push(@implContentHeader, GenerateImplementationContentHeader($dictionary));
6014 
6015     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
6016     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
6017     push(@implContent, GenerateDictionaryImplementationContent($dictionary, $className));
6018     push(@implContent, GenerateEnumerationsImplementationContent($dictionary, $enumerations));
6019     push(@implContent, GenerateDictionariesImplementationContent($dictionary, $otherDictionaries)) if $otherDictionaries;
6020     push(@implContent, &quot;} // namespace WebCore\n&quot;);
6021 
6022     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
6023     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6024 }
6025 
6026 sub GenerateCallbackFunctionHeader
6027 {
6028     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
6029 
6030     push(@headerContentHeader, GenerateHeaderContentHeader($callbackFunction));
6031 
6032     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
6033 
6034     my @operations = ();
6035     push(@operations, $callbackFunction-&gt;operation);
6036     my @constants = ();
6037 
6038     $object-&gt;GenerateCallbackHeaderContent($callbackFunction, \@operations, \@constants, \@headerContent, \%headerIncludes);
6039 
6040     push(@headerContent, GenerateEnumerationsHeaderContent($callbackFunction, $enumerations));
6041     push(@headerContent, GenerateDictionariesHeaderContent($callbackFunction, $dictionaries));
6042 
6043     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
6044 
6045     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
6046     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6047 }
6048 
6049 sub GenerateCallbackFunctionImplementation
6050 {
6051     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
6052 
6053     push(@implContentHeader, GenerateImplementationContentHeader($callbackFunction));
6054 
6055     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
6056     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
6057 
6058     push(@implContent, GenerateEnumerationsImplementationContent($callbackFunction, $enumerations));
6059     push(@implContent, GenerateDictionariesImplementationContent($callbackFunction, $dictionaries));
6060 
6061     my @operations = ();
6062     push(@operations, $callbackFunction-&gt;operation);
6063     my @constants = ();
6064 
6065     $object-&gt;GenerateCallbackImplementationContent($callbackFunction, \@operations, \@constants, \@implContent, \%implIncludes);
6066 
6067     push(@implContent, &quot;} // namespace WebCore\n&quot;);
6068 
6069     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
6070     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6071 }
6072 
6073 sub GenerateCallbackInterfaceHeader
6074 {
6075     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
6076 
6077     push(@headerContentHeader, GenerateHeaderContentHeader($callbackInterface));
6078 
6079     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
6080     
6081     $object-&gt;GenerateCallbackHeaderContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@headerContent, \%headerIncludes);
6082 
6083     push(@headerContent, GenerateEnumerationsHeaderContent($callbackInterface, $enumerations));
6084     push(@headerContent, GenerateDictionariesHeaderContent($callbackInterface, $dictionaries));
6085 
6086     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
6087 
6088     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
6089     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6090 }
6091 
6092 sub GenerateCallbackInterfaceImplementation
6093 {
6094     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
6095 
6096     push(@implContentHeader, GenerateImplementationContentHeader($callbackInterface));
6097 
6098     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
6099     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
6100 
6101     push(@implContent, GenerateEnumerationsImplementationContent($callbackInterface, $enumerations));
6102     push(@implContent, GenerateDictionariesImplementationContent($callbackInterface, $dictionaries));
6103 
6104     $object-&gt;GenerateCallbackImplementationContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@implContent, \%implIncludes);
6105 
6106     push(@implContent, &quot;} // namespace WebCore\n&quot;);
6107 
6108     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
6109     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6110 }
6111 
6112 sub GenerateCallbackHeaderContent
6113 {
6114     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
6115 
6116     my $name = $interfaceOrCallback-&gt;type-&gt;name;
6117     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
6118     my $className = &quot;JS${name}&quot;;
6119 
6120     $includesRef-&gt;{&quot;IDLTypes.h&quot;} = 1;
6121     $includesRef-&gt;{&quot;JSCallbackData.h&quot;} = 1;
6122     $includesRef-&gt;{&quot;&lt;wtf/Forward.h&gt;&quot;} = 1;
6123     $includesRef-&gt;{&quot;${name}.h&quot;} = 1;
6124 
6125     my $exportMacro = GetExportMacroForJSClass($interfaceOrCallback);
6126 
6127     push(@$contentRef, &quot;class $exportMacro$className final : public ${name} {\n&quot;);
6128     push(@$contentRef, &quot;public:\n&quot;);
6129 
6130     # The static create() method.
6131     push(@$contentRef, &quot;    static Ref&lt;$className&gt; create(JSC::JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
6132     push(@$contentRef, &quot;    {\n&quot;);
6133     push(@$contentRef, &quot;        return adoptRef(*new ${className}(callback, globalObject));\n&quot;);
6134     push(@$contentRef, &quot;    }\n\n&quot;);
6135 
6136     push(@$contentRef, &quot;    virtual ScriptExecutionContext* scriptExecutionContext() const { return ContextDestructionObserver::scriptExecutionContext(); }\n\n&quot;);
6137 
6138     push(@$contentRef, &quot;    virtual ~$className();\n&quot;);
6139 
6140     push(@$contentRef, &quot;    ${callbackDataType}* callbackData() { return m_data; }\n&quot;);
6141 
6142     push(@$contentRef, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;) if @{$constants};
6143 
6144     push(@$contentRef, &quot;    virtual bool operator==(const ${name}&amp;) const override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual};
6145 
6146     # Operations
6147     my $numOperations = @{$operations};
6148     if ($numOperations &gt; 0) {
6149         push(@$contentRef, &quot;\n    // Functions\n&quot;);
6150         foreach my $operation (@{$operations}) {
6151             my @arguments = ();
6152 
6153             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
6154             if ($callbackThisObject) {
6155                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
6156                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
6157                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
6158             }
6159 
6160             foreach my $argument (@{$operation-&gt;arguments}) {
6161                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6162                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6163             }
6164 
6165             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
6166             
6167             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
6168             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
6169 
6170             push(@$contentRef, &quot;    ${nativeReturnType} ${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;) override;\n&quot;);
6171         }
6172     }
6173 
6174     push(@$contentRef, &quot;\nprivate:\n&quot;);
6175 
6176     push(@$contentRef, &quot;    ${className}(JSC::JSObject*, JSDOMGlobalObject*);\n\n&quot;);
6177 
6178     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6179         push(@$contentRef, &quot;    bool hasCallback() const final { return m_data &amp;&amp; m_data-&gt;callback(); }\n\n&quot;);
6180     }
6181 
6182     push(@$contentRef, &quot;    void visitJSFunction(JSC::SlotVisitor&amp;) override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback};
6183 
6184     push(@$contentRef, &quot;    ${callbackDataType}* m_data;\n&quot;);
6185     push(@$contentRef, &quot;};\n\n&quot;);
6186 
6187     # toJS().
6188     push(@$contentRef, $exportMacro . &quot;JSC::JSValue toJS(${name}&amp;);\n&quot;);
6189     push(@$contentRef, &quot;inline JSC::JSValue toJS(${name}* impl) { return impl ? toJS(*impl) : JSC::jsNull(); }\n\n&quot;);
6190 }
6191 
6192 sub GenerateCallbackImplementationContent
6193 {
6194     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
6195 
6196     my $name = $interfaceOrCallback-&gt;type-&gt;name;
6197     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
6198     my $visibleName = $codeGenerator-&gt;GetVisibleInterfaceName($interfaceOrCallback);
6199     my $className = &quot;JS${name}&quot;;
6200 
6201     $includesRef-&gt;{&quot;ScriptExecutionContext.h&quot;} = 1;
6202 
6203     # Constructor
6204     push(@$contentRef, &quot;${className}::${className}(JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
6205     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6206         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext(), ${className}Type)\n&quot;);
6207     } else {
6208         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext())\n&quot;);
6209     }
6210     push(@$contentRef, &quot;    , m_data(new ${callbackDataType}(callback, globalObject, this))\n&quot;);
6211     push(@$contentRef, &quot;{\n&quot;);
6212     push(@$contentRef, &quot;}\n\n&quot;);
6213 
6214     # Destructor
6215     push(@$contentRef, &quot;${className}::~${className}()\n&quot;);
6216     push(@$contentRef, &quot;{\n&quot;);
6217     push(@$contentRef, &quot;    ScriptExecutionContext* context = scriptExecutionContext();\n&quot;);
6218     push(@$contentRef, &quot;    // When the context is destroyed, all tasks with a reference to a callback\n&quot;);
6219     push(@$contentRef, &quot;    // should be deleted. So if the context is 0, we are on the context thread.\n&quot;);
6220     push(@$contentRef, &quot;    if (!context || context-&gt;isContextThread())\n&quot;);
6221     push(@$contentRef, &quot;        delete m_data;\n&quot;);
6222     push(@$contentRef, &quot;    else\n&quot;);
6223     push(@$contentRef, &quot;        context-&gt;postTask(DeleteCallbackDataTask(m_data));\n&quot;);
6224     push(@$contentRef, &quot;#ifndef NDEBUG\n&quot;);
6225     push(@$contentRef, &quot;    m_data = nullptr;\n&quot;);
6226     push(@$contentRef, &quot;#endif\n&quot;);
6227     push(@$contentRef, &quot;}\n\n&quot;);
6228 
6229     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6230         push(@$contentRef, &quot;bool ${className}::operator==(const ${name}&amp; other) const\n&quot;);
6231         push(@$contentRef, &quot;{\n&quot;);
6232         push(@$contentRef, &quot;    if (other.type() != type())\n&quot;);
6233         push(@$contentRef, &quot;        return false;\n&quot;);
6234         push(@$contentRef, &quot;    return static_cast&lt;const ${className}*&gt;(&amp;other)-&gt;m_data-&gt;callback() == m_data-&gt;callback();\n&quot;);
6235         push(@$contentRef, &quot;}\n\n&quot;);
6236     }
6237 
6238     # Constants.
6239     my $numConstants = @{$constants};
6240     if ($numConstants &gt; 0) {
6241         GenerateConstructorDeclaration($contentRef, $className, $interfaceOrCallback, $name);
6242 
6243         my $hashSize = 0;
6244         my $hashName = $className . &quot;ConstructorTable&quot;;
6245 
6246         my @hashKeys = ();
6247         my @hashValue1 = ();
6248         my @hashValue2 = ();
6249         my @hashSpecials = ();
6250         my %conditionals = ();
6251         my %readWriteConditionals = ();
6252 
6253         foreach my $constant (@{$constants}) {
6254             my $name = $constant-&gt;name;
6255             push(@hashKeys, $name);
6256             push(@hashValue1, $constant-&gt;value);
6257             push(@hashValue2, &quot;0&quot;);
6258             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
6259 
6260             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
6261             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
6262 
6263             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
6264             $conditionals{$name} = $conditional if $conditional;
6265 
6266             $hashSize++;
6267         }
6268         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
6269 
6270         push(@$contentRef, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interfaceOrCallback));
6271 
6272         GenerateConstructorDefinitions($contentRef, $className, &quot;&quot;, $visibleName, $interfaceOrCallback);
6273 
6274         push(@$contentRef, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
6275         push(@$contentRef, &quot;{\n&quot;);
6276         push(@$contentRef, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
6277         push(@$contentRef, &quot;}\n\n&quot;);
6278     }
6279 
6280     # Operations
6281     my $numOperations = @{$operations};
6282     if ($numOperations &gt; 0) {
6283         foreach my $operation (@{$operations}) {
6284             next if $operation-&gt;extendedAttributes-&gt;{Custom};
6285         
6286             AddToIncludesForIDLType($operation-&gt;type, $includesRef);
6287 
6288             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
6289             
6290             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
6291             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
6292 
6293             my @arguments = ();
6294 
6295             my $thisValue = &quot;jsUndefined()&quot;;
6296 
6297             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
6298             if ($callbackThisObject) {
6299                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
6300 
6301                 AddToIncludesForIDLType($thisObjectType, $includesRef, 1);
6302                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
6303                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
6304 
6305                 my $thisObjectArgument = IDLArgument-&gt;new();
6306                 $thisObjectArgument-&gt;type($thisObjectType);
6307 
6308                 $thisValue = NativeToJSValueUsingReferences($thisObjectArgument, $interfaceOrCallback, &quot;thisObject&quot;, &quot;globalObject&quot;);
6309             }
6310 
6311             foreach my $argument (@{$operation-&gt;arguments}) {
6312                 AddToIncludesForIDLType($argument-&gt;type, $includesRef, 1);
6313                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6314                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6315             }
6316             
6317             push(@$contentRef, &quot;${nativeReturnType} ${className}::${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)\n&quot;);
6318             push(@$contentRef, &quot;{\n&quot;);
6319 
6320             # FIXME: This is needed for NodeFilter, which works even for disconnected iframes. We should investigate
6321             # if that behavior is needed for other callbacks.
6322             if (!$operation-&gt;extendedAttributes-&gt;{SkipCallbackInvokeCheck}) {
6323                 push(@$contentRef, &quot;    if (!canInvokeCallback())\n&quot;);
6324                 push(@$contentRef, &quot;        return CallbackResultType::UnableToExecute;\n\n&quot;);
6325             }
6326 
6327             push(@$contentRef, &quot;    Ref&lt;$className&gt; protectedThis(*this);\n\n&quot;);
6328             push(@$contentRef, &quot;    auto&amp; globalObject = *m_data-&gt;globalObject();\n&quot;);
6329             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6330             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6331 
6332             push(@$contentRef, &quot;    auto&amp; lexicalGlobalObject = globalObject;\n&quot;);
6333 
6334             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6335             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6336 
6337             foreach my $argument (@{$operation-&gt;arguments}) {
6338                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6339             }
6340             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6341 
6342             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6343 
6344             my $callbackInvocation;
6345             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6346                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6347             } else {
6348                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
6349                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(vm, \&quot;${functionName}\&quot;), returnedException)&quot;;
6350             }
6351 
6352             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6353                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6354             } else {
6355                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6356             }
6357 
6358             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6359             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6360             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6361                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6362                 push(@$contentRef, &quot;        throwException(&amp;lexicalGlobalObject, throwScope, returnedException);\n&quot;);
6363             } else {
6364                 push(@$contentRef, &quot;        reportException(&amp;lexicalGlobalObject, returnedException);\n&quot;);
6365             }
6366             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6367             push(@$contentRef, &quot;     }\n\n&quot;);
6368 
6369             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6370                 push(@$contentRef, &quot;    return { };\n&quot;);
6371             } else {
6372                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;);
6373             
6374                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6375                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6376                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
6377                 push(@$contentRef, &quot;    return returnValue;\n&quot;);
6378             }
6379 
6380             push(@$contentRef, &quot;}\n\n&quot;);
6381         }
6382     }
6383 
6384     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6385         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6386         push(@$contentRef, &quot;{\n&quot;);
6387         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6388         push(@$contentRef, &quot;}\n\n&quot;);
6389     }
6390 
6391     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6392     push(@$contentRef, &quot;{\n&quot;);
6393     push(@$contentRef, &quot;    if (!static_cast&lt;${className}&amp;&gt;(impl).callbackData())\n&quot;);
6394     push(@$contentRef, &quot;        return jsNull();\n\n&quot;);
6395     push(@$contentRef, &quot;    return static_cast&lt;${className}&amp;&gt;(impl).callbackData()-&gt;callback();\n&quot;);
6396     push(@$contentRef, &quot;}\n\n&quot;);
6397 }
6398 
6399 sub GenerateImplementationFunctionCall
6400 {
6401     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6402 
6403     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6404     if ($callTracingCallback) {
6405         my @callTracerArguments = map { $_-&gt;name } @{$operation-&gt;arguments};
6406         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6407     }
6408 
6409     if (OperationHasForcedReturnValue($operation)) {
6410         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6411         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6412     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6413         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6414         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6415     } else {
6416         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
6417         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6418     }
6419 }
6420 
6421 sub GenerateImplementationCustomFunctionCall
6422 {
6423     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6424 
6425     my @customFunctionArguments = ();
6426     push(@customFunctionArguments, &quot;*lexicalGlobalObject&quot;);
6427     push(@customFunctionArguments, &quot;*callFrame&quot;);
6428     push(@customFunctionArguments, &quot;WTFMove(promise)&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
6429 
6430     if ($operation-&gt;isStatic) {
6431         push(@$outputArray, $indent . &quot;return JSValue::encode(${className}::&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6432     } else {
6433         push(@$outputArray, $indent . &quot;return JSValue::encode(castedThis-&gt;&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6434     }
6435 }
6436 
6437 sub IsValueIterableInterface
6438 {
6439     my $interface = shift;
6440     return 0 unless $interface-&gt;iterable;
6441     return 0 if length $interface-&gt;iterable-&gt;keyType;
6442     # FIXME: See https://webkit.org/b/159140, we should die if the next check is false.
6443     return 0 unless GetIndexedGetterOperation($interface);
6444     return 1;
6445 }
6446 
6447 sub IsKeyValueIterableInterface
6448 {
6449     my $interface = shift;
6450     return 0 unless $interface-&gt;iterable;
6451     return 0 if IsValueIterableInterface($interface);
6452     return 1;
6453 }
6454 
6455 sub GenerateIterableDefinition
6456 {
6457     my $interface = shift;
6458 
6459     my $interfaceName = $interface-&gt;type-&gt;name;
6460     my $className = &quot;JS$interfaceName&quot;;
6461     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
6462 
6463     AddToImplIncludes(&quot;JSDOMIterator.h&quot;);
6464 
6465     return unless IsKeyValueIterableInterface($interface);
6466 
6467     my $iteratorName = &quot;${interfaceName}Iterator&quot;;
6468     my $iteratorPrototypeName = &quot;${interfaceName}IteratorPrototype&quot;;
6469 
6470     my $iteratorTraitsName = &quot;${interfaceName}IteratorTraits&quot;;
6471     my $iteratorTraitsType = $interface-&gt;iterable-&gt;isKeyValue ? &quot;JSDOMIteratorType::Map&quot; : &quot;JSDOMIteratorType::Set&quot;;
6472     my $iteratorTraitsKeyType = $interface-&gt;iterable-&gt;isKeyValue ? GetIDLType($interface, $interface-&gt;iterable-&gt;keyType) : &quot;void&quot;;
6473     my $iteratorTraitsValueType = GetIDLType($interface, $interface-&gt;iterable-&gt;valueType);
6474 
6475     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;keyType) if $interface-&gt;iterable-&gt;isKeyValue;
6476     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;valueType);
6477 
6478     push(@implContent,  &lt;&lt;END);
6479 struct ${iteratorTraitsName} {
6480     static constexpr JSDOMIteratorType type = ${iteratorTraitsType};
6481     using KeyType = ${iteratorTraitsKeyType};
6482     using ValueType = ${iteratorTraitsValueType};
6483 };
6484 
6485 using ${iteratorName} = JSDOMIterator&lt;${className}, ${iteratorTraitsName}&gt;;
6486 using ${iteratorPrototypeName} = JSDOMIteratorPrototype&lt;${className}, ${iteratorTraitsName}&gt;;
6487 
6488 template&lt;&gt;
6489 const JSC::ClassInfo ${iteratorName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorName}) };
6490 
6491 template&lt;&gt;
6492 const JSC::ClassInfo ${iteratorPrototypeName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorPrototypeName}) };
6493 
6494 END
6495 
6496     foreach my $operation (@{$interface-&gt;iterable-&gt;operations}) {
6497         my $propertyName = $operation-&gt;name;
6498         my $functionName = GetFunctionName($interface, $className, $operation);
6499 
6500         next if $propertyName eq &quot;[Symbol.Iterator]&quot;;
6501 
6502         if ($propertyName eq &quot;forEach&quot;) {
6503             push(@implContent,  &lt;&lt;END);
6504 static inline EncodedJSValue ${functionName}Caller(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)
6505 {
6506     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*lexicalGlobalObject, *callFrame, *thisObject, throwScope));
6507 }
6508 
6509 END
6510         } else {
6511             my $iterationKind = &quot;Entries&quot;;
6512             $iterationKind = &quot;Keys&quot; if $propertyName eq &quot;keys&quot;;
6513             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;values&quot;;
6514             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;
6515 
6516             push(@implContent,  &lt;&lt;END);
6517 static inline EncodedJSValue ${functionName}Caller(JSGlobalObject*, CallFrame*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)
6518 {
6519     return JSValue::encode(iteratorCreate&lt;${iteratorName}&gt;(*thisObject, IterationKind::${iterationKind}));
6520 }
6521 
6522 END
6523         }
6524 
6525         push(@implContent,  &lt;&lt;END);
6526 JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
6527 {
6528     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*lexicalGlobalObject, *callFrame, &quot;${propertyName}&quot;);
6529 }
6530 
6531 END
6532     }
6533 }
6534 
6535 # http://heycam.github.io/webidl/#dfn-flattened-union-member-types
6536 sub GetFlattenedMemberTypes
6537 {
6538     my ($idlUnionType) = @_;
6539 
6540     my @flattenedMemberTypes = ();
6541 
6542     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6543         if ($memberType-&gt;isUnion) {
6544             push(@flattenedMemberTypes, GetFlattenedMemberTypes($memberType));
6545         } else {
6546             push(@flattenedMemberTypes, $memberType);
6547         }
6548     }
6549 
6550     return @flattenedMemberTypes;
6551 }
6552 
6553 # http://heycam.github.io/webidl/#dfn-number-of-nullable-member-types
6554 sub GetNumberOfNullableMemberTypes
6555 {
6556     my ($idlUnionType) = @_;
6557 
6558     my $count = 0;
6559 
6560     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6561         $count++ if $memberType-&gt;isNullable;
6562         $count += GetNumberOfNullableMemberTypes($memberType) if $memberType-&gt;isUnion;
6563     }
6564 
6565     return $count;
6566 }
6567 
6568 sub GetIDLUnionMemberTypes
6569 {
6570     my ($interface, $idlUnionType) = @_;
6571 
6572     my $numberOfNullableMembers = GetNumberOfNullableMemberTypes($idlUnionType);
6573     assert(&quot;Union types must only have 0 or 1 nullable types.&quot;) if $numberOfNullableMembers &gt; 1;
6574 
6575     my @idlUnionMemberTypes = ();
6576 
6577     push(@idlUnionMemberTypes, &quot;IDLNull&quot;) if $numberOfNullableMembers == 1;
6578 
6579     foreach my $memberType (GetFlattenedMemberTypes($idlUnionType)) {
6580         push(@idlUnionMemberTypes, GetIDLTypeExcludingNullability($interface, $memberType));
6581     }
6582 
6583     return @idlUnionMemberTypes;
6584 }
6585 
6586 sub IsAnnotatedType
6587 {
6588     my ($type) = @_;
6589 
6590     return 1 if $type-&gt;extendedAttributes-&gt;{Clamp};
6591     return 1 if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6592     return 1 if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
6593     return 1 if $type-&gt;extendedAttributes-&gt;{AtomString};
6594     return 1 if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};
6595 }
6596 
6597 sub GetAnnotatedIDLType
6598 {
6599     my ($type) = @_;
6600 
6601     return &quot;IDLClampAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{Clamp};
6602     return &quot;IDLEnforceRangeAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6603     return &quot;IDLTreatNullAsEmptyAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
6604     return &quot;IDLAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{AtomString};
6605     return &quot;IDLRequiresExistingAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};
6606 }
6607 
6608 sub GetBaseIDLType
6609 {
6610     my ($interface, $type) = @_;
6611 
6612     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6613         return $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6614     }
6615 
6616     my %IDLTypes = (
6617         &quot;void&quot; =&gt; &quot;IDLVoid&quot;,
6618         &quot;any&quot; =&gt; &quot;IDLAny&quot;,
6619         &quot;boolean&quot; =&gt; &quot;IDLBoolean&quot;,
6620         &quot;byte&quot; =&gt; &quot;IDLByte&quot;,
6621         &quot;octet&quot; =&gt; &quot;IDLOctet&quot;,
6622         &quot;short&quot; =&gt; &quot;IDLShort&quot;,
6623         &quot;unsigned short&quot; =&gt; &quot;IDLUnsignedShort&quot;,
6624         &quot;long&quot; =&gt; &quot;IDLLong&quot;,
6625         &quot;unsigned long&quot; =&gt; &quot;IDLUnsignedLong&quot;,
6626         &quot;long long&quot; =&gt; &quot;IDLLongLong&quot;,
6627         &quot;unsigned long long&quot; =&gt; &quot;IDLUnsignedLongLong&quot;,
6628         &quot;float&quot; =&gt; &quot;IDLFloat&quot;,
6629         &quot;unrestricted float&quot; =&gt; &quot;IDLUnrestrictedFloat&quot;,
6630         &quot;double&quot; =&gt; &quot;IDLDouble&quot;,
6631         &quot;unrestricted double&quot; =&gt; &quot;IDLUnrestrictedDouble&quot;,
6632         &quot;DOMString&quot; =&gt; &quot;IDLDOMString&quot;,
6633         &quot;ByteString&quot; =&gt; &quot;IDLByteString&quot;,
6634         &quot;USVString&quot; =&gt; &quot;IDLUSVString&quot;,
6635         &quot;object&quot; =&gt; &quot;IDLObject&quot;,
6636         &quot;ArrayBuffer&quot; =&gt; &quot;IDLArrayBuffer&quot;,
6637         &quot;ArrayBufferView&quot; =&gt; &quot;IDLArrayBufferView&quot;,
6638         &quot;DataView&quot; =&gt; &quot;IDLDataView&quot;,
6639         &quot;Int8Array&quot; =&gt; &quot;IDLInt8Array&quot;,
6640         &quot;Int16Array&quot; =&gt; &quot;IDLInt16Array&quot;,
6641         &quot;Int32Array&quot; =&gt; &quot;IDLInt32Array&quot;,
6642         &quot;Uint8Array&quot; =&gt; &quot;IDLUint8Array&quot;,
6643         &quot;Uint16Array&quot; =&gt; &quot;IDLUint16Array&quot;,
6644         &quot;Uint32Array&quot; =&gt; &quot;IDLUint32Array&quot;,
6645         &quot;Uint8ClampedArray&quot; =&gt; &quot;IDLUint8ClampedArray&quot;,
6646         &quot;Float32Array&quot; =&gt; &quot;IDLFloat32Array&quot;,
6647         &quot;Float64Array&quot; =&gt; &quot;IDLFloat64Array&quot;,
6648 
6649         # Non-WebIDL extensions
6650         &quot;Date&quot; =&gt; &quot;IDLDate&quot;,
6651         &quot;EventListener&quot; =&gt; &quot;IDLEventListener&lt;JSEventListener&gt;&quot;,
6652         &quot;JSON&quot; =&gt; &quot;IDLJSON&quot;,
6653         &quot;ScheduledAction&quot; =&gt; &quot;IDLScheduledAction&quot;,
6654         &quot;SerializedScriptValue&quot; =&gt; &quot;IDLSerializedScriptValue&lt;SerializedScriptValue&gt;&quot;,
6655         &quot;XPathNSResolver&quot; =&gt; &quot;IDLXPathNSResolver&lt;XPathNSResolver&gt;&quot;,
6656     );
6657 
6658     return $IDLTypes{$type-&gt;name} if exists $IDLTypes{$type-&gt;name};
6659     return &quot;IDLEnumeration&lt;&quot; . GetEnumerationClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsEnumType($type);
6660     return &quot;IDLDictionary&lt;&quot; . GetDictionaryClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsDictionaryType($type);
6661     return &quot;IDLSequence&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsSequenceType($type);
6662     return &quot;IDLFrozenArray&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsFrozenArrayType($type);
6663     return &quot;IDLRecord&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;, &quot; . GetIDLType($interface, @{$type-&gt;subtypes}[1]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsRecordType($type);
6664     return &quot;IDLPromise&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsPromiseType($type);
6665     return &quot;IDLUnion&lt;&quot; . join(&quot;, &quot;, GetIDLUnionMemberTypes($interface, $type)) . &quot;&gt;&quot; if $type-&gt;isUnion;
6666     return &quot;IDLCallbackFunction&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackFunction($type);
6667     return &quot;IDLCallbackInterface&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackInterface($type);
6668 
6669     assert(&quot;Unknown type &#39;&quot; . $type-&gt;name . &quot;&#39;.\n&quot;) unless $codeGenerator-&gt;IsInterfaceType($type);
6670     return &quot;IDLInterface&lt;&quot; . $type-&gt;name . &quot;&gt;&quot;;
6671 }
6672 
6673 sub GetIDLTypeExcludingNullability
6674 {
6675     my ($interface, $type) = @_;
6676 
6677     my $baseIDLType = GetBaseIDLType($interface, $type);
6678     $baseIDLType = GetAnnotatedIDLType($type) . &quot;&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if IsAnnotatedType($type);
6679     return $baseIDLType;
6680 }
6681 
6682 sub GetIDLType
6683 {
6684     my ($interface, $type) = @_;
6685 
6686     my $baseIDLType = GetIDLTypeExcludingNullability($interface, $type);
6687     $baseIDLType = &quot;IDLNullable&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if $type-&gt;isNullable;
6688     return $baseIDLType;
6689 }
6690 
6691 sub ShouldPassArgumentByReference
6692 {
6693     my ($argument) = @_;
6694 
6695     my $type = $argument-&gt;type;
6696 
6697     return 0 if $type-&gt;isNullable;
6698     return 0 if $codeGenerator-&gt;IsCallbackInterface($type);
6699     return 0 if $codeGenerator-&gt;IsCallbackFunction($type);
6700     return 0 if !$codeGenerator-&gt;IsWrapperType($type) &amp;&amp; !$codeGenerator-&gt;IsBufferSourceType($type);
6701 
6702     return 1;
6703 }
6704 
6705 sub JSValueToNativeDOMConvertNeedsThisObject
6706 {
6707     my $type = shift;
6708 
6709     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
6710     return 0;
6711 }
6712 
6713 sub JSValueToNativeDOMConvertNeedsGlobalObject
6714 {
6715     my $type = shift;
6716 
6717     return 1 if $codeGenerator-&gt;IsCallbackInterface($type);
6718     return 1 if $codeGenerator-&gt;IsCallbackFunction($type);
6719     return JSValueToNativeDOMConvertNeedsGlobalObject(@{$type-&gt;subtypes}[1]) if $codeGenerator-&gt;IsRecordType($type);
6720     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
6721     return 0;
6722 }
6723 
6724 sub IsValidContextForJSValueToNative
6725 {
6726     my $context = shift;
6727     return (ref($context) eq &quot;IDLAttribute&quot; &amp;&amp; !$codeGenerator-&gt;IsEnumType($context-&gt;type)) || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6728 }
6729 
6730 sub JSValueToNative
6731 {
6732     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;
6733 
6734     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6735 
6736     my $type = $context-&gt;type;
6737 
6738     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6739     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;
6740     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;
6741     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6742 
6743     AddToImplIncludesForIDLType($type, $conditional);
6744     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6745 
6746     my $IDLType = GetIDLType($interface, $type);
6747 
6748     my @conversionArguments = ();
6749     push(@conversionArguments, $lexicalGlobalObjectReference);
6750     push(@conversionArguments, $value);
6751     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6752     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6753     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6754 
6755     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6756 }
6757 
6758 sub ToNativeForFunctionWithoutTypeCheck
6759 {
6760     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference) = @_;
6761 
6762     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6763 
6764     my $type = $context-&gt;type;
6765 
6766     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6767     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;
6768     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;
6769     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6770 
6771     AddToImplIncludesForIDLType($type, $conditional);
6772 
6773     # FIXME: Support more types.
6774 
6775     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6776 
6777     my $IDLType = GetIDLType($interface, $type);
6778 
6779     my @conversionArguments = ();
6780     push(@conversionArguments, &quot;$lexicalGlobalObjectReference&quot;);
6781     push(@conversionArguments, &quot;$value&quot;);
6782 
6783     return (&quot;DOMJIT::DirectConverter&lt;$IDLType&gt;::directConvert(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;, 1);
6784 }
6785 
6786 sub NativeToJSValueDOMConvertNeedsState
6787 {
6788     my ($type) = @_;
6789 
6790     # FIXME: We need a more robust way to specify this requirement so as not
6791     # to require specializing each type. Perhaps just requiring all override
6792     # types to take both lexicalGlobalObject and the global object would work?
6793     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6794         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6795         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6796         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6797         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6798 
6799         return 0;
6800     }
6801 
6802     # FIXME: This should actually check if all the sub-objects of the union need the lexicalGlobalObject.
6803     return 1 if $type-&gt;isUnion;
6804     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6805     return 1 if $codeGenerator-&gt;IsRecordType($type);
6806     return 1 if $codeGenerator-&gt;IsStringType($type);
6807     return 1 if $codeGenerator-&gt;IsEnumType($type);
6808     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6809     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6810     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6811     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6812     return 1 if $type-&gt;name eq &quot;Date&quot;;
6813     return 1 if $type-&gt;name eq &quot;JSON&quot;;
6814     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6815     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6816     
6817     return 0;
6818 }
6819 
6820 sub NativeToJSValueDOMConvertNeedsGlobalObject
6821 {
6822     my ($type) = @_;
6823     
6824     # FIXME: We need a more robust way to specify this requirement so as not
6825     # to require specializing each type. Perhaps just requiring all override
6826     # types to take both lexicalGlobalObject and the global object would work?
6827     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6828         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6829         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6830         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6831         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6832 
6833         return 0;
6834     }
6835 
6836     # FIXME: This should actually check if all the sub-objects of the union need the global object.
6837     return 1 if $type-&gt;isUnion;
6838     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6839     return 1 if $codeGenerator-&gt;IsRecordType($type);
6840     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6841     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6842     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6843     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6844     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6845     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6846 
6847     return 0;
6848 }
6849 
6850 sub NativeToJSValueUsingReferences
6851 {
6852     my ($context, $interface, $value, $globalObjectReference) = @_;
6853 
6854     return NativeToJSValue($context, $interface, $value, &quot;lexicalGlobalObject&quot;, $globalObjectReference);
6855 }
6856 
6857 # FIXME: We should remove NativeToJSValueUsingPointers and combine NativeToJSValueUsingReferences and NativeToJSValue
6858 sub NativeToJSValueUsingPointers
6859 {
6860     my ($context, $interface, $value, $globalObjectReference) = @_;
6861 
6862     return NativeToJSValue($context, $interface, $value, &quot;*lexicalGlobalObject&quot;, $globalObjectReference);
6863 }
6864 
6865 sub IsValidContextForNativeToJSValue
6866 {
6867     my $context = shift;
6868     
6869     return ref($context) eq &quot;IDLAttribute&quot; || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6870 }
6871 
6872 sub NativeToJSValue
6873 {
6874     my ($context, $interface, $value, $lexicalGlobalObjectReference, $globalObjectReference) = @_;
6875 
6876     assert(&quot;Invalid context type&quot;) if !IsValidContextForNativeToJSValue($context);
6877 
6878     my $conditional = $context-&gt;extendedAttributes-&gt;{Conditional};
6879     my $type = $context-&gt;type;
6880     my $mayThrowException = ref($context) eq &quot;IDLAttribute&quot; || $context-&gt;extendedAttributes-&gt;{MayThrowException};
6881 
6882     # We could instead overload a function to work with optional as well as non-optional numbers, but this
6883     # is slightly better because it guarantees we will fail to compile if the IDL file doesn&#39;t match the C++.
6884     if ($context-&gt;extendedAttributes-&gt;{Reflect} and ($type-&gt;name eq &quot;unsigned long&quot; or $type-&gt;name eq &quot;unsigned short&quot;)) {
6885         $value =~ s/getUnsignedIntegralAttribute/getIntegralAttribute/g;
6886         $value = &quot;std::max(0, $value)&quot;;
6887     }
6888 
6889     AddToImplIncludesForIDLType($type, $conditional);
6890     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6891 
6892     if ($context-&gt;extendedAttributes-&gt;{CheckSecurityForNode}) {
6893         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
6894         $value = &quot;BindingSecurity::checkSecurityForNode($lexicalGlobalObjectReference, $value)&quot;;
6895     }
6896 
6897     my $IDLType = GetIDLType($interface, $type);
6898 
6899     my @conversionArguments = ();
6900     push(@conversionArguments, $lexicalGlobalObjectReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;
6901     push(@conversionArguments, $globalObjectReference) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6902     push(@conversionArguments, &quot;throwScope&quot;) if $mayThrowException;
6903     push(@conversionArguments, $value);
6904 
6905     my $functionName = $context-&gt;extendedAttributes-&gt;{NewObject} ? &quot;toJSNewlyCreated&quot; : &quot;toJS&quot;;
6906 
6907     return &quot;${functionName}&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6908 }
6909 
6910 sub ceilingToPowerOf2
6911 {
6912     my ($size) = @_;
6913 
6914     my $powerOf2 = 1;
6915     while ($size &gt; $powerOf2) {
6916         $powerOf2 &lt;&lt;= 1;
6917     }
6918 
6919     return $powerOf2;
6920 }
6921 
6922 # Internal Helper
6923 sub GenerateHashTableValueArray
6924 {
6925     my $keys = shift;
6926     my $specials = shift;
6927     my $value1 = shift;
6928     my $value2 = shift;
6929     my $conditionals = shift;
6930     my $readWriteConditionals = shift;
6931     my $nameEntries = shift;
6932 
6933     my $packedSize = scalar @{$keys};
6934     push(@implContent, &quot;\nstatic const HashTableValue $nameEntries\[\] =\n\{\n&quot;);
6935 
6936     my $hasSetter = &quot;false&quot;;
6937 
6938     my $i = 0;
6939     foreach my $key (@{$keys}) {
6940         my $firstTargetType;
6941         my $secondTargetType = &quot;&quot;;
6942         my $conditional;
6943 
6944         if ($conditionals) {
6945             $conditional = $conditionals-&gt;{$key};
6946         }
6947         if ($conditional) {
6948             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
6949             push(@implContent, &quot;#if ${conditionalString}\n&quot;);
6950         }
6951 
6952         if (&quot;@$specials[$i]&quot; =~ m/DOMJITFunction/) {
6953             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6954             $secondTargetType = &quot;static_cast&lt;const JSC::DOMJIT::Signature*&gt;&quot;;
6955         } elsif (&quot;@$specials[$i]&quot; =~ m/Function/) {
6956             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6957         } elsif (&quot;@$specials[$i]&quot; =~ m/Builtin/) {
6958             $firstTargetType = &quot;static_cast&lt;BuiltinGenerator&gt;&quot;;
6959         } elsif (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6960             $firstTargetType = &quot;&quot;;
6961         } elsif (&quot;@$specials[$i]&quot; =~ m/DOMJITAttribute/) {
6962             $firstTargetType = &quot;static_cast&lt;const JSC::DOMJIT::GetterSetter*&gt;&quot;;
6963         } else {
6964             $firstTargetType = &quot;static_cast&lt;PropertySlot::GetValueFunc&gt;&quot;;
6965             $secondTargetType = &quot;static_cast&lt;PutPropertySlot::PutValueFunc&gt;&quot;;
6966             $hasSetter = &quot;true&quot;;
6967         }
6968         if (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6969             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (long long)&quot; . $firstTargetType . &quot;(@$value1[$i]) } },\n&quot;);
6970         } else {
6971             my $readWriteConditional = $readWriteConditionals ? $readWriteConditionals-&gt;{$key} : undef;
6972             if ($readWriteConditional) {
6973                 my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
6974                 push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
6975             }
6976 
6977             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) &quot; . $secondTargetType . &quot;(@$value2[$i]) } },\n&quot;);
6978 
6979             if ($readWriteConditional) {
6980                 push(@implContent, &quot;#else\n&quot;) ;
6981                 push(@implContent, &quot;    { \&quot;$key\&quot;, JSC::PropertyAttribute::ReadOnly | @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) static_cast&lt;PutPropertySlot::PutValueFunc&gt;(0) } },\n&quot;);
6982                 push(@implContent, &quot;#endif\n&quot;);
6983             }
6984         }
6985         if ($conditional) {
6986             push(@implContent, &quot;#else\n&quot;);
6987             push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } },\n&quot;);
6988             push(@implContent, &quot;#endif\n&quot;);
6989         }
6990         ++$i;
6991     }
6992 
6993     push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } }\n&quot;) if (!$packedSize);
6994     push(@implContent, &quot;};\n\n&quot;);
6995 
6996     return $hasSetter;
6997 }
6998 
6999 sub GenerateHashTable
7000 {
7001     my $object = shift;
7002 
7003     my $className = shift;
7004     my $name = shift;
7005     my $size = shift;
7006     my $keys = shift;
7007     my $specials = shift;
7008     my $value1 = shift;
7009     my $value2 = shift;
7010     my $conditionals = shift;
7011     my $readWriteConditionals = shift;
7012     my $justGenerateValueArray = shift;
7013 
7014     my $nameEntries = &quot;${name}Values&quot;;
7015     $nameEntries =~ s/:/_/g;
7016     my $nameIndex = &quot;${name}Index&quot;;
7017     $nameIndex =~ s/:/_/g;
7018 
7019     if (($name =~ /Prototype/) or ($name =~ /Constructor/)) {
7020         my $type = $name;
7021         my $implClass;
7022 
7023         if ($name =~ /Prototype/) {
7024             $type =~ s/Prototype.*//;
7025             $implClass = $type; $implClass =~ s/Wrapper$//;
7026             push(@implContent, &quot;/* Hash table for prototype */\n&quot;);
7027         } else {
7028             $type =~ s/Constructor.*//;
7029             $implClass = $type; $implClass =~ s/Constructor$//;
7030             push(@implContent, &quot;/* Hash table for constructor */\n&quot;);
7031         }
7032     } else {
7033         push(@implContent, &quot;/* Hash table */\n&quot;);
7034     }
7035 
7036     if ($justGenerateValueArray) {
7037         GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries) if $size;
7038         return;
7039     }
7040 
7041     # Generate size data for compact&#39; size hash table
7042 
7043     my @table = ();
7044     my @links = ();
7045 
7046     my $compactSize = ceilingToPowerOf2($size * 2);
7047 
7048     my $maxDepth = 0;
7049     my $collisions = 0;
7050     my $numEntries = $compactSize;
7051 
7052     my $i = 0;
7053     foreach (@{$keys}) {
7054         my $depth = 0;
7055         my $h = Hasher::GenerateHashValue($_) % $numEntries;
7056 
7057         while (defined($table[$h])) {
7058             if (defined($links[$h])) {
7059                 $h = $links[$h];
7060                 $depth++;
7061             } else {
7062                 $collisions++;
7063                 $links[$h] = $compactSize;
7064                 $h = $compactSize;
7065                 $compactSize++;
7066             }
7067         }
7068 
7069         $table[$h] = $i;
7070 
7071         $i++;
7072         $maxDepth = $depth if ($depth &gt; $maxDepth);
7073     }
7074 
7075     push(@implContent, &quot;\nstatic const struct CompactHashIndex ${nameIndex}\[$compactSize\] = {\n&quot;);
7076     for (my $i = 0; $i &lt; $compactSize; $i++) {
7077         my $T = -1;
7078         if (defined($table[$i])) { $T = $table[$i]; }
7079         my $L = -1;
7080         if (defined($links[$i])) { $L = $links[$i]; }
7081         push(@implContent, &quot;    { $T, $L },\n&quot;);
7082     }
7083     push(@implContent, &quot;};\n\n&quot;);
7084 
7085     # Dump the hash table
7086     my $hasSetter = GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries);
7087     my $packedSize = scalar @{$keys};
7088 
7089     my $compactSizeMask = $numEntries - 1;
7090     push(@implContent, &quot;static const HashTable $name = { $packedSize, $compactSizeMask, $hasSetter, ${className}::info(), $nameEntries, $nameIndex };\n&quot;);
7091 }
7092 
7093 sub WriteData
7094 {
7095     my $object = shift;
7096     my $interface = shift;
7097     my $outputDir = shift;
7098 
7099     my $name = $interface-&gt;type-&gt;name;
7100     my $headerFileName = &quot;$outputDir/JS$name.h&quot;;
7101     my $implFileName = &quot;$outputDir/JS$name.cpp&quot;;
7102     my $depsFileName = &quot;$outputDir/JS$name.dep&quot;;
7103 
7104     # Update a .cpp file if the contents are changed.
7105     my $contents = join &quot;&quot;, @implContentHeader;
7106 
7107     my @includes = ();
7108     my %implIncludeConditions = ();
7109     foreach my $include (keys %implIncludes) {
7110         next if $headerIncludes{$include};
7111         next if $headerTrailingIncludes{$include};
7112 
7113         my $condition = $implIncludes{$include};
7114 
7115         my $checkType = $include;
7116         $checkType =~ s/\.h//;
7117         next if $codeGenerator-&gt;IsSVGAnimatedTypeName($checkType);
7118 
7119         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7120 
7121         if ($condition eq 1) {
7122             push @includes, $include;
7123         } else {
7124             push @{$implIncludeConditions{$codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($condition)}}, $include;
7125         }
7126     }
7127     foreach my $include (sort @includes) {
7128         $contents .= &quot;#include $include\n&quot;;
7129     }
7130     foreach my $condition (sort keys %implIncludeConditions) {
7131         $contents .= &quot;\n#if &quot; . $condition . &quot;\n&quot;;
7132         foreach my $include (sort @{$implIncludeConditions{$condition}}) {
7133             $contents .= &quot;#include $include\n&quot;;
7134         }
7135         $contents .= &quot;#endif\n&quot;;
7136     }
7137 
7138     $contents .= join &quot;&quot;, @implContent;
7139     $codeGenerator-&gt;UpdateFile($implFileName, $contents);
7140 
7141     @implContentHeader = ();
7142     @implContent = ();
7143     %implIncludes = ();
7144 
7145     # Update a .h file if the contents are changed.
7146     $contents = join &quot;&quot;, @headerContentHeader;
7147 
7148     @includes = ();
7149     foreach my $include (keys %headerIncludes) {
7150         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7151         push @includes, $include;
7152     }
7153     foreach my $include (sort @includes) {
7154         # &quot;JSClassName.h&quot; is already included right after config.h.
7155         next if $include eq &quot;\&quot;JS$name.h\&quot;&quot;;
7156         $contents .= &quot;#include $include\n&quot;;
7157     }
7158 
7159     $contents .= join &quot;&quot;, @headerContent;
7160 
7161     @includes = ();
7162     foreach my $include (keys %headerTrailingIncludes) {
7163         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7164         push @includes, $include;
7165     }
7166     foreach my $include (sort @includes) {
7167         $contents .= &quot;#include $include\n&quot;;
7168     }
7169     $codeGenerator-&gt;UpdateFile($headerFileName, $contents);
7170 
7171     @headerContentHeader = ();
7172     @headerContent = ();
7173     %headerIncludes = ();
7174     %headerTrailingIncludes = ();
7175 
7176     if (@depsContent) {
7177         # Update a .dep file if the contents are changed.
7178         $contents = join &quot;&quot;, @depsContent;
7179         $codeGenerator-&gt;UpdateFile($depsFileName, $contents);
7180 
7181         @depsContent = ();
7182     }
7183 }
7184 
7185 sub GeneratePrototypeDeclaration
7186 {
7187     my ($outputArray, $className, $interface) = @_;
7188 
7189     my $prototypeClassName = &quot;${className}Prototype&quot;;
7190 
7191     my %structureFlags = ();
7192     push(@$outputArray, &quot;class ${prototypeClassName} : public JSC::JSNonFinalObject {\n&quot;);
7193     push(@$outputArray, &quot;public:\n&quot;);
7194     push(@$outputArray, &quot;    using Base = JSC::JSNonFinalObject;\n&quot;);
7195 
7196     push(@$outputArray, &quot;    static ${prototypeClassName}* create(JSC::VM&amp; vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)\n&quot;);
7197     push(@$outputArray, &quot;    {\n&quot;);
7198     push(@$outputArray, &quot;        ${className}Prototype* ptr = new (NotNull, JSC::allocateCell&lt;${className}Prototype&gt;(vm.heap)) ${className}Prototype(vm, globalObject, structure);\n&quot;);
7199     push(@$outputArray, &quot;        ptr-&gt;finishCreation(vm);\n&quot;);
7200     push(@$outputArray, &quot;        return ptr;\n&quot;);
7201     push(@$outputArray, &quot;    }\n\n&quot;);
7202 
7203     push(@$outputArray, &quot;    DECLARE_INFO;\n&quot;);
7204 
7205     push(@$outputArray, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
7206     push(@$outputArray, &quot;    {\n&quot;);
7207     push(@$outputArray, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
7208     push(@$outputArray, &quot;    }\n&quot;);
7209 
7210     push(@$outputArray, &quot;\nprivate:\n&quot;);
7211     push(@$outputArray, &quot;    ${prototypeClassName}(JSC::VM&amp; vm, JSC::JSGlobalObject*, JSC::Structure* structure)\n&quot;);
7212     push(@$outputArray, &quot;        : JSC::JSNonFinalObject(vm, structure)\n&quot;);
7213     push(@$outputArray, &quot;    {\n&quot;);
7214     push(@$outputArray, &quot;    }\n&quot;);
7215 
7216     if (PrototypeHasStaticPropertyTable($interface)) {
7217         if (IsGlobalInterface($interface)) {
7218             $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1;
7219         } else {
7220             push(@$outputArray, &quot;\n&quot;);
7221             push(@$outputArray, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
7222         }
7223     }
7224 
7225     # FIXME: Should this override putByIndex as well?
7226     if ($interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}) {
7227         push(@$outputArray, &quot;\n&quot;);
7228         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
7229     }
7230 
7231     if ($interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype}) {
7232         push(@$outputArray, &quot;\n&quot;);
7233         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
7234     }
7235 
7236     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObjectOnPrototype};
7237 
7238     # structure flags
7239     if (%structureFlags) {
7240         push(@$outputArray, &quot;public:\n&quot;);
7241         push(@$outputArray, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);
7242         foreach my $structureFlag (sort (keys %structureFlags)) {
7243             push(@$outputArray, &quot; | &quot; . $structureFlag);
7244         }
7245         push(@$outputArray, &quot;;\n&quot;);
7246     }
7247 
7248     push(@$outputArray, &quot;};\n&quot;);
7249     push(@$outputArray, &quot;STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(${prototypeClassName}, ${prototypeClassName}::Base);\n\n&quot;);
7250 }
7251 
7252 sub GetConstructorTemplateClassName
7253 {
7254     my $interface = shift;
7255     return &quot;JSDOMConstructorNotConstructable&quot; if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7256     return &quot;JSDOMConstructorNotConstructable&quot; unless IsConstructable($interface);
7257     return &quot;JSDOMBuiltinConstructor&quot; if IsJSBuiltinConstructor($interface);
7258     return &quot;JSDOMConstructor&quot;;
7259 }
7260 
7261 sub GenerateConstructorDeclaration
7262 {
7263     my ($outputArray, $className, $interface) = @_;
7264 
7265     my $interfaceName = $interface-&gt;type-&gt;name;
7266     my $constructorClassName = &quot;${className}Constructor&quot;;
7267     my $templateClassName = GetConstructorTemplateClassName($interface);
7268 
7269     AddToImplIncludes(&quot;${templateClassName}.h&quot;);
7270     AddToImplIncludes(&quot;JSDOMNamedConstructor.h&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7271 
7272     push(@$outputArray, &quot;using $constructorClassName = $templateClassName&lt;$className&gt;;\n&quot;);
7273     push(@$outputArray, &quot;using JS${interfaceName}NamedConstructor = JSDOMNamedConstructor&lt;$className&gt;;\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7274     push(@$outputArray, &quot;\n&quot;);
7275 }
7276 
7277 sub GenerateConstructorDefinitions
7278 {
7279     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7280 
7281     if (IsConstructable($interface)) {
7282         my @constructors = @{$interface-&gt;constructors};
7283         if (@constructors &gt; 1) {
7284             foreach my $constructor (@constructors) {
7285                 GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructor);
7286             }
7287 
7288             my $overloadFunctionPrefix = &quot;construct${className}&quot;;
7289 
7290             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
7291             push(@implContent, &quot;{\n&quot;);
7292             push(@implContent, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
7293             push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7294             push(@implContent, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7295 
7296             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);
7297 
7298             push(@implContent, &quot;}\n\n&quot;);
7299         } elsif (@constructors == 1) {
7300             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructors[0]);
7301         } else {
7302             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7303         }
7304     }
7305 
7306     GenerateConstructorHelperMethods($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7307 }
7308 
7309 sub GenerateConstructorDefinition
7310 {
7311     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $operation) = @_;
7312 
7313     return if IsJSBuiltinConstructor($interface);
7314 
7315     my $interfaceName = $interface-&gt;type-&gt;name;
7316     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7317 
7318     if (IsConstructable($interface)) {
7319         if ($interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7320             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)\n&quot;);
7321             push(@$outputArray, &quot;{\n&quot;);
7322             push(@$outputArray, &quot;    ASSERT(callFrame);\n&quot;);
7323             push(@$outputArray, &quot;    return construct${className}(lexicalGlobalObject, *callFrame);\n&quot;);
7324             push(@$outputArray, &quot;}\n\n&quot;);
7325          } elsif (!HasCustomConstructor($interface) &amp;&amp; (!$interface-&gt;extendedAttributes-&gt;{NamedConstructor} || $generatingNamedConstructor)) {
7326             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
7327             if ($isOverloaded) {
7328                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
7329             } else {
7330                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
7331             }
7332 
7333             push(@$outputArray, &quot;{\n&quot;);
7334             push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
7335             push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7336             push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7337             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(callFrame-&gt;jsCallee());\n&quot;);
7338             push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
7339 
7340              if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {
7341                  my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation, &quot;lexicalGlobalObject&quot;);
7342                  push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
7343                  push(@$outputArray, &quot;        throwTypeError(lexicalGlobalObject, throwScope, \&quot;Illegal constructor\&quot;_s);\n&quot;);
7344                  push(@$outputArray, &quot;        return JSValue::encode(jsNull());\n&quot;);
7345                  push(@$outputArray, &quot;    }\n&quot;);
7346              }
7347 
7348             GenerateArgumentsCountCheck($outputArray, $operation, $interface, &quot;    &quot;);
7349 
7350             my $functionImplementationName = $generatingNamedConstructor ? &quot;createForJSConstructor&quot; : &quot;create&quot;;
7351             my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, &quot;    &quot;);
7352 
7353             push(@$outputArray, &quot;    auto object = ${functionString};\n&quot;);
7354             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($interface-&gt;extendedAttributes-&gt;{ConstructorCallWith}, &quot;ExecState&quot;);
7355 
7356             my $IDLType = GetIDLType($interface, $interface-&gt;type);
7357 
7358             AddToImplIncludes(&quot;JSDOMConvertInterface.h&quot;);
7359 
7360             my @constructionConversionArguments = ();
7361             push(@constructionConversionArguments, &quot;*lexicalGlobalObject&quot;);
7362             push(@constructionConversionArguments, &quot;*castedThis-&gt;globalObject()&quot;);
7363             push(@constructionConversionArguments, &quot;throwScope&quot;) if $interface-&gt;extendedAttributes-&gt;{ConstructorMayThrowException};
7364             push(@constructionConversionArguments, &quot;WTFMove(object)&quot;);
7365 
7366             push(@$outputArray, &quot;    return JSValue::encode(toJSNewlyCreated&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @constructionConversionArguments) . &quot;));\n&quot;);
7367             push(@$outputArray, &quot;}\n\n&quot;);
7368         }
7369     }
7370 }
7371 
7372 sub ConstructorHasProperties
7373 {
7374     my $interface = shift;
7375 
7376     foreach my $constant (@{$interface-&gt;constants}) {
7377         return 1;
7378     }
7379 
7380     foreach my $attribute (@{$interface-&gt;attributes}) {
7381         next unless ($attribute-&gt;isStatic);
7382         return 1;
7383     }
7384 
7385     foreach my $operation (@{$interface-&gt;operations}) {
7386         next unless ($operation-&gt;isStatic);
7387         return 1;
7388     }
7389 
7390     return 0;
7391 }
7392 
7393 sub GetRuntimeEnabledStaticProperties
7394 {
7395     my ($interface) = @_;
7396 
7397     my @runtimeEnabledProperties = ();
7398 
7399     my @attributes = @{$interface-&gt;attributes};
7400     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
7401     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;
7402 
7403     foreach my $attribute (@attributes) {
7404         next if AttributeShouldBeOnInstance($interface, $attribute) != 0;
7405         next if not $attribute-&gt;isStatic;
7406 
7407         if (NeedsRuntimeCheck($interface, $attribute)) {
7408             push(@runtimeEnabledProperties, $attribute);
7409         }
7410     }
7411 
7412     my @operations = @{$interface-&gt;operations};
7413     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
7414     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
7415     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;
7416     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
7417     foreach my $operation (@operations) {
7418         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
7419         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
7420         next if OperationShouldBeOnInstance($interface, $operation) != 0;
7421         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
7422         next if not $operation-&gt;isStatic;
7423 
7424         if (NeedsRuntimeCheck($interface, $operation)) {
7425             push(@runtimeEnabledProperties, $operation);
7426         }
7427     }
7428 
7429     return @runtimeEnabledProperties;
7430 }
7431 
7432 sub GenerateConstructorHelperMethods
7433 {
7434     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7435 
7436     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7437     my $leastConstructorLength = 0;
7438     if ($interface-&gt;extendedAttributes-&gt;{Constructor} || $interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7439         my @constructors = @{$interface-&gt;constructors};
7440         my @customConstructors = @{$interface-&gt;customConstructors};
7441         $leastConstructorLength = 255;
7442         foreach my $constructor (@constructors, @customConstructors) {
7443             my $constructorLength = GetFunctionLength($constructor);
7444             $leastConstructorLength = $constructorLength if ($constructorLength &lt; $leastConstructorLength);
7445         }
7446     } else {
7447         $leastConstructorLength = 0;
7448     }
7449 
7450     # If the interface has a parent interface which does not have [NoInterfaceObject], then use its interface object as prototype,
7451     # otherwise use FunctionPrototype: http://heycam.github.io/webidl/#interface-object
7452     push(@$outputArray, &quot;template&lt;&gt; JSValue ${constructorClassName}::prototypeForStructure(JSC::VM&amp; vm, const JSDOMGlobalObject&amp; globalObject)\n&quot;);
7453     push(@$outputArray, &quot;{\n&quot;);
7454 
7455     assert(&quot;An interface cannot inherit from another interface that is marked as [NoInterfaceObject]&quot;) if $interface-&gt;parentType &amp;&amp; $codeGenerator-&gt;GetInterfaceExtendedAttributesFromName($interface-&gt;parentType-&gt;name)-&gt;{NoInterfaceObject};
7456 
7457     if (!$generatingNamedConstructor and $interface-&gt;parentType) {
7458         my $parentClassName = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
7459         push(@$outputArray, &quot;    return ${parentClassName}::getConstructor(vm, &amp;globalObject);\n&quot;);
7460     } else {
7461         AddToImplIncludes(&quot;&lt;JavaScriptCore/FunctionPrototype.h&gt;&quot;);
7462         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
7463         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7464     }
7465     push(@$outputArray, &quot;}\n\n&quot;);
7466 
7467 
7468     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7469     push(@$outputArray, &quot;{\n&quot;);
7470 
7471     # There must exist an interface prototype object for every non-callback interface defined, regardless
7472     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7473     # https://heycam.github.io/webidl/#interface-prototype-object
7474     if (ShouldUseGlobalObjectPrototype($interface)) {
7475         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7476     } elsif ($interface-&gt;isCallback) {
7477         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7478     } else {
7479         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7480     }
7481 
7482     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7483 
7484     if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {
7485         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $interface, &quot;&amp;globalObject&quot;);
7486         push(@$outputArray, &quot;    int constructorLength = ${leastConstructorLength};\n&quot;);
7487         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);
7488         push(@$outputArray, &quot;        constructorLength = 0;\n&quot;);
7489         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(constructorLength), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7490     } else {
7491         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7492     }
7493 
7494     my $classForThis = &quot;${className}::info()&quot;;
7495     if ($interface-&gt;isCallback) {
7496         $classForThis = &quot;nullptr&quot;;
7497     }
7498     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7499 
7500     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7501 
7502     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7503         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7504         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
7505         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;&amp;globalObject&quot;);
7506         my $name = $operationOrAttribute-&gt;name;
7507         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
7508         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
7509         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
7510         push(@$outputArray, &quot;        JSObject::deleteProperty(this, &amp;globalObject, propertyName);\n&quot;);
7511         push(@$outputArray, &quot;    }\n&quot;);
7512         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7513     }
7514 
7515     push(@$outputArray, &quot;}\n\n&quot;);
7516 
7517     if (IsJSBuiltinConstructor($interface)) {
7518         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7519         push(@$outputArray, &quot;{\n&quot;);
7520         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7521         push(@$outputArray, &quot;}\n&quot;);
7522         push(@$outputArray, &quot;\n&quot;);
7523     }
7524     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7525 }
7526 
7527 sub HasCustomConstructor
7528 {
7529     my $interface = shift;
7530     return $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7531 }
7532 
7533 sub HasCustomGetter
7534 {
7535     my $attribute = shift;
7536     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomGetter};
7537 }
7538 
7539 sub HasCustomSetter
7540 {
7541     my $attribute = shift;
7542     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomSetter};
7543 }
7544 
7545 sub HasCustomMethod
7546 {
7547     my $operation = shift;
7548     return $operation-&gt;extendedAttributes-&gt;{Custom};
7549 }
7550 
7551 sub NeedsConstructorProperty
7552 {
7553     my $interface = shift;
7554     
7555     return !$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject};
7556 }
7557 
7558 sub IsConstructable
7559 {
7560     my $interface = shift;
7561     return HasCustomConstructor($interface)
7562         || $interface-&gt;extendedAttributes-&gt;{Constructor}
7563         || $interface-&gt;extendedAttributes-&gt;{NamedConstructor}
7564         || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7565 }
7566 
7567 sub InstanceOverridesGetCallData
7568 {
7569     my $interface = shift;
7570     return $interface-&gt;{LegacyCallers} || $interface-&gt;extendedAttributes-&gt;{CustomGetCallData} || $interface-&gt;extendedAttributes-&gt;{Plugin};
7571 }
7572 
7573 sub HeaderNeedsPrototypeDeclaration
7574 {
7575     my $interface = shift;
7576     return IsDOMGlobalObject($interface)
7577         || $interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}
7578         || $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype};
7579 }
7580 
7581 sub IsUnforgeable
7582 {
7583     my ($interface, $property) = @_;
7584 
7585     return $property-&gt;extendedAttributes-&gt;{Unforgeable} || $interface-&gt;extendedAttributes-&gt;{Unforgeable};
7586 }
7587 
7588 sub ComputeFunctionSpecial
7589 {
7590     my ($interface, $operation) = @_;
7591 
7592     my @specials = ();
7593     push(@specials, (&quot;JSC::PropertyAttribute::DontDelete&quot;, &quot;JSC::PropertyAttribute::ReadOnly&quot;)) if IsUnforgeable($interface, $operation);
7594     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $operation-&gt;extendedAttributes-&gt;{NotEnumerable};
7595     if (IsJSBuiltin($interface, $operation)) {
7596         push(@specials, &quot;JSC::PropertyAttribute::Builtin&quot;);
7597     } else {
7598         push(@specials, &quot;JSC::PropertyAttribute::Function&quot;);
7599     }
7600     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
7601         push(@specials, &quot;JSC::PropertyAttribute::DOMJITFunction&quot;) if $operation-&gt;extendedAttributes-&gt;{DOMJIT};
7602     }
7603     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
7604 }
7605 
7606 sub IsJSBuiltin
7607 {
7608     my ($interface, $object) = @_;
7609 
7610     return 0 if $object-&gt;extendedAttributes-&gt;{Custom};
7611     return 0 if $object-&gt;extendedAttributes-&gt;{CustomGetter};
7612     return 0 if $object-&gt;extendedAttributes-&gt;{CustomSetter};
7613 
7614     return 1 if $object-&gt;extendedAttributes-&gt;{JSBuiltin};
7615     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7616 
7617     return 0;
7618 }
7619 
7620 sub IsJSBuiltinConstructor
7621 {
7622     my ($interface) = @_;
7623 
7624     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7625     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7626     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7627     return 0;
7628 }
7629 
7630 sub GetJSBuiltinFunctionName
7631 {
7632     my ($className, $operation) = @_;
7633 
7634     my $scopeName = $operation-&gt;extendedAttributes-&gt;{ImplementedBy};
7635     $scopeName = substr $className, 2 unless $scopeName;
7636     return GetJSBuiltinFunctionNameFromString($scopeName, $operation-&gt;name);
7637 }
7638 
7639 sub GetJSBuiltinFunctionNameFromString
7640 {
7641     my ($scopeName, $functionName) = @_;
7642 
7643     return $codeGenerator-&gt;WK_lcfirst($scopeName) . $codeGenerator-&gt;WK_ucfirst($functionName) . &quot;CodeGenerator&quot;;
7644 }
7645 
7646 sub GetJSBuiltinScopeName
7647 {
7648     my ($interface, $object) = @_;
7649     return $object-&gt;extendedAttributes-&gt;{ImplementedBy} || $interface-&gt;type-&gt;name;
7650 }
7651 
7652 sub AddJSBuiltinIncludesIfNeeded()
7653 {
7654     my $interface = shift;
7655 
7656     if ($interface-&gt;extendedAttributes-&gt;{JSBuiltin} || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor}) {
7657         AddToImplIncludes($interface-&gt;type-&gt;name . &quot;Builtins.h&quot;);
7658         return;
7659     }
7660 
7661     foreach my $operation (@{$interface-&gt;operations}) {
7662         AddToImplIncludes(GetJSBuiltinScopeName($interface, $operation) . &quot;Builtins.h&quot;, $operation-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $operation);
7663     }
7664 
7665     foreach my $attribute (@{$interface-&gt;attributes}) {
7666         AddToImplIncludes(GetJSBuiltinScopeName($interface, $attribute) . &quot;Builtins.h&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $attribute);
7667     }
7668 }
7669 
7670 sub GenerateCallTracer()
7671 {
7672     my ($outputArray, $callTracingCallback, $name, $arguments, $indent) = @_;
7673 
7674     AddToImplIncludes(&quot;CallTracer.h&quot;);
7675 
7676     push(@$outputArray, $indent . &quot;if (UNLIKELY(impl.callTracingActive()))\n&quot;);
7677     push(@$outputArray, $indent . &quot;    CallTracer::&quot; . $callTracingCallback . &quot;(impl, \&quot;&quot; . $name . &quot;\&quot;_s&quot;);
7678     if (scalar(@$arguments)) {
7679         push(@$outputArray, &quot;, { &quot; . join(&quot;, &quot;, @$arguments) . &quot; }&quot;);
7680     }
7681     push(@$outputArray, &quot;);\n&quot;);
7682 }
7683 
7684 sub GenerateCustomElementReactionsStackIfNeeded
7685 {
7686     my ($outputArray, $context, $stateVariable) = @_;
7687 
7688     my $CEReactions = $context-&gt;extendedAttributes-&gt;{CEReactions};
7689 
7690     return if !$CEReactions;
7691 
7692     AddToImplIncludes(&quot;CustomElementReactionQueue.h&quot;);
7693 
7694     if ($CEReactions eq &quot;NotNeeded&quot;) {
7695         push(@$outputArray, &quot;    CustomElementReactionDisallowedScope customElementReactionDisallowedScope;\n&quot;);
7696     } else {
7697         push(@$outputArray, &quot;    CustomElementReactionStack customElementReactionStack($stateVariable);\n&quot;);
7698     }
7699 }
7700 
7701 1;
    </pre>
  </body>
</html>
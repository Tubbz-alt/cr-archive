<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderText.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextLineBoxes.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 144,41 ***</span>
      // we are now in the correct text run
      position = (offset &gt; currentOffset ? current-&gt;len() : current-&gt;len() - (currentOffset - offset));
      return current;
  }
  
<span class="line-removed">- IntRect RenderTextLineBoxes::boundingBox(const RenderText&amp; renderer) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_first)</span>
<span class="line-removed">-         return IntRect();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Return the width of the minimal left side and the maximal right side.</span>
<span class="line-removed">-     float logicalLeftSide = 0;</span>
<span class="line-removed">-     float logicalRightSide = 0;</span>
<span class="line-removed">-     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {</span>
<span class="line-removed">-         if (current == m_first || current-&gt;logicalLeft() &lt; logicalLeftSide)</span>
<span class="line-removed">-             logicalLeftSide = current-&gt;logicalLeft();</span>
<span class="line-removed">-         if (current == m_first || current-&gt;logicalRight() &gt; logicalRightSide)</span>
<span class="line-removed">-             logicalRightSide = current-&gt;logicalRight();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool isHorizontal = renderer.style().isHorizontalWritingMode();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     float x = isHorizontal ? logicalLeftSide : m_first-&gt;x();</span>
<span class="line-removed">-     float y = isHorizontal ? m_first-&gt;y() : logicalLeftSide;</span>
<span class="line-removed">-     float width = isHorizontal ? logicalRightSide - logicalLeftSide : m_last-&gt;logicalBottom() - x;</span>
<span class="line-removed">-     float height = isHorizontal ? m_last-&gt;logicalBottom() - y : logicalRightSide - logicalLeftSide;</span>
<span class="line-removed">-     return enclosingIntRect(FloatRect(x, y, width, height));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- IntPoint RenderTextLineBoxes::firstRunLocation() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_first)</span>
<span class="line-removed">-         return IntPoint();</span>
<span class="line-removed">-     return IntPoint(m_first-&gt;topLeft());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  LayoutRect RenderTextLineBoxes::visualOverflowBoundingBox(const RenderText&amp; renderer) const
  {
      if (!m_first)
          return LayoutRect();
  
<span class="line-new-header">--- 144,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,86 ***</span>
      if (!renderer.style().isHorizontalWritingMode())
          rect = rect.transposedRect();
      return rect;
  }
  
<span class="line-removed">- bool RenderTextLineBoxes::hasRenderedText() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">-         if (box-&gt;len())</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int RenderTextLineBoxes::caretMinOffset() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto box = m_first;</span>
<span class="line-removed">-     if (!box)</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     int minOffset = box-&gt;start();</span>
<span class="line-removed">-     for (box = box-&gt;nextTextBox(); box; box = box-&gt;nextTextBox())</span>
<span class="line-removed">-         minOffset = std::min&lt;int&gt;(minOffset, box-&gt;start());</span>
<span class="line-removed">-     return minOffset;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int RenderTextLineBoxes::caretMaxOffset(const RenderText&amp; renderer) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto box = m_last;</span>
<span class="line-removed">-     if (!box)</span>
<span class="line-removed">-         return renderer.text().length();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int maxOffset = box-&gt;start() + box-&gt;len();</span>
<span class="line-removed">-     for (box = box-&gt;prevTextBox(); box; box = box-&gt;prevTextBox())</span>
<span class="line-removed">-         maxOffset = std::max&lt;int&gt;(maxOffset, box-&gt;start() + box-&gt;len());</span>
<span class="line-removed">-     return maxOffset;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool RenderTextLineBoxes::containsOffset(const RenderText&amp; renderer, unsigned offset, OffsetType type) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">-         if (offset &lt; box-&gt;start() &amp;&amp; !renderer.containsReversedText())</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         unsigned boxEnd = box-&gt;start() + box-&gt;len();</span>
<span class="line-removed">-         if (offset &gt;= box-&gt;start() &amp;&amp; offset &lt;= boxEnd) {</span>
<span class="line-removed">-             if (offset == boxEnd &amp;&amp; (type == CharacterOffset || box-&gt;isLineBreak()))</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             if (type == CharacterOffset)</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-             // Return false for offsets inside composed characters.</span>
<span class="line-removed">-             return !offset || offset == static_cast&lt;unsigned&gt;(renderer.nextOffset(renderer.previousOffset(offset)));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- unsigned RenderTextLineBoxes::countCharacterOffsetsUntil(unsigned offset) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     unsigned result = 0;</span>
<span class="line-removed">-     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">-         if (offset &lt; box-&gt;start())</span>
<span class="line-removed">-             return result;</span>
<span class="line-removed">-         if (offset &lt;= box-&gt;start() + box-&gt;len()) {</span>
<span class="line-removed">-             result += offset - box-&gt;start();</span>
<span class="line-removed">-             return result;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         result += box-&gt;len();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  enum ShouldAffinityBeDownstream { AlwaysDownstream, AlwaysUpstream, UpstreamIfPositionIsNotAtStart };
  
  static bool lineDirectionPointFitsInBox(int pointLineDirection, const InlineTextBox&amp; box, ShouldAffinityBeDownstream&amp; shouldAffinityBeDownstream)
  {
      shouldAffinityBeDownstream = AlwaysDownstream;
  
      // the x coordinate is equal to the left edge of this box
      // the affinity must be downstream so the position doesn&#39;t jump back to the previous line
      // except when box is the first box in the line
      if (pointLineDirection &lt;= box.logicalLeft()) {
<span class="line-modified">!         shouldAffinityBeDownstream = !box.prevLeafChild() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;</span>
          return true;
      }
  
  #if !PLATFORM(IOS_FAMILY)
      // and the x coordinate is to the left of the right edge of this box
<span class="line-new-header">--- 167,21 ---</span>
      if (!renderer.style().isHorizontalWritingMode())
          rect = rect.transposedRect();
      return rect;
  }
  
  enum ShouldAffinityBeDownstream { AlwaysDownstream, AlwaysUpstream, UpstreamIfPositionIsNotAtStart };
  
  static bool lineDirectionPointFitsInBox(int pointLineDirection, const InlineTextBox&amp; box, ShouldAffinityBeDownstream&amp; shouldAffinityBeDownstream)
  {
      shouldAffinityBeDownstream = AlwaysDownstream;
  
      // the x coordinate is equal to the left edge of this box
      // the affinity must be downstream so the position doesn&#39;t jump back to the previous line
      // except when box is the first box in the line
      if (pointLineDirection &lt;= box.logicalLeft()) {
<span class="line-modified">!         shouldAffinityBeDownstream = !box.previousLeafOnLine() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;</span>
          return true;
      }
  
  #if !PLATFORM(IOS_FAMILY)
      // and the x coordinate is to the left of the right edge of this box
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,14 ***</span>
      }
  #endif
  
      // box is first on line
      // and the x coordinate is to the left of the first text box left edge
<span class="line-modified">!     if (!box.prevLeafChildIgnoringLineBreak() &amp;&amp; pointLineDirection &lt; box.logicalLeft())</span>
          return true;
  
<span class="line-modified">!     if (!box.nextLeafChildIgnoringLineBreak()) {</span>
          // box is last on line
          // and the x coordinate is to the right of the last text box right edge
          // generate VisiblePosition, use UPSTREAM affinity if possible
          shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
          return true;
<span class="line-new-header">--- 192,14 ---</span>
      }
  #endif
  
      // box is first on line
      // and the x coordinate is to the left of the first text box left edge
<span class="line-modified">!     if (!box.previousLeafOnLineIgnoringLineBreak() &amp;&amp; pointLineDirection &lt; box.logicalLeft())</span>
          return true;
  
<span class="line-modified">!     if (!box.nextLeafOnLineIgnoringLineBreak()) {</span>
          // box is last on line
          // and the x coordinate is to the right of the last text box right edge
          // generate VisiblePosition, use UPSTREAM affinity if possible
          shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,63 ***</span>
  
      bool positionIsAtStartOfBox = !offset;
      if (positionIsAtStartOfBox == box.isLeftToRightDirection()) {
          // offset is on the left edge
  
<span class="line-modified">!         const InlineBox* prevBox = box.prevLeafChildIgnoringLineBreak();</span>
          if ((prevBox &amp;&amp; prevBox-&gt;bidiLevel() == box.bidiLevel())
              || box.renderer().containingBlock()-&gt;style().direction() == box.direction()) // FIXME: left on 12CBA
              return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
  
          if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
              // e.g. left of B in aDC12BAb
              const InlineBox* leftmostBox;
              do {
                  leftmostBox = prevBox;
<span class="line-modified">!                 prevBox = leftmostBox-&gt;prevLeafChildIgnoringLineBreak();</span>
              } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel());
              return createVisiblePositionForBox(*leftmostBox, leftmostBox-&gt;caretRightmostOffset(), shouldAffinityBeDownstream);
          }
  
          if (!prevBox || prevBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
              // e.g. left of D in aDC12BAb
              const InlineBox* rightmostBox;
              const InlineBox* nextBox = &amp;box;
              do {
                  rightmostBox = nextBox;
<span class="line-modified">!                 nextBox = rightmostBox-&gt;nextLeafChildIgnoringLineBreak();</span>
              } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt;= box.bidiLevel());
              return createVisiblePositionForBox(*rightmostBox,
                  box.isLeftToRightDirection() ? rightmostBox-&gt;caretMaxOffset() : rightmostBox-&gt;caretMinOffset(), shouldAffinityBeDownstream);
          }
  
          return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
      }
  
<span class="line-modified">!     const InlineBox* nextBox = box.nextLeafChildIgnoringLineBreak();</span>
      if ((nextBox &amp;&amp; nextBox-&gt;bidiLevel() == box.bidiLevel())
          || box.renderer().containingBlock()-&gt;style().direction() == box.direction())
          return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
  
      // offset is on the right edge
      if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
          // e.g. right of C in aDC12BAb
          const InlineBox* rightmostBox;
          do {
              rightmostBox = nextBox;
<span class="line-modified">!             nextBox = rightmostBox-&gt;nextLeafChildIgnoringLineBreak();</span>
          } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel());
          return createVisiblePositionForBox(*rightmostBox, rightmostBox-&gt;caretLeftmostOffset(), shouldAffinityBeDownstream);
      }
  
      if (!nextBox || nextBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
          // e.g. right of A in aDC12BAb
          const InlineBox* leftmostBox;
          const InlineBox* prevBox = &amp;box;
          do {
              leftmostBox = prevBox;
<span class="line-modified">!             prevBox = leftmostBox-&gt;prevLeafChildIgnoringLineBreak();</span>
          } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt;= box.bidiLevel());
          return createVisiblePositionForBox(*leftmostBox,
              box.isLeftToRightDirection() ? leftmostBox-&gt;caretMinOffset() : leftmostBox-&gt;caretMaxOffset(), shouldAffinityBeDownstream);
      }
  
<span class="line-new-header">--- 234,63 ---</span>
  
      bool positionIsAtStartOfBox = !offset;
      if (positionIsAtStartOfBox == box.isLeftToRightDirection()) {
          // offset is on the left edge
  
<span class="line-modified">!         const InlineBox* prevBox = box.previousLeafOnLineIgnoringLineBreak();</span>
          if ((prevBox &amp;&amp; prevBox-&gt;bidiLevel() == box.bidiLevel())
              || box.renderer().containingBlock()-&gt;style().direction() == box.direction()) // FIXME: left on 12CBA
              return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
  
          if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
              // e.g. left of B in aDC12BAb
              const InlineBox* leftmostBox;
              do {
                  leftmostBox = prevBox;
<span class="line-modified">!                 prevBox = leftmostBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
              } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel());
              return createVisiblePositionForBox(*leftmostBox, leftmostBox-&gt;caretRightmostOffset(), shouldAffinityBeDownstream);
          }
  
          if (!prevBox || prevBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
              // e.g. left of D in aDC12BAb
              const InlineBox* rightmostBox;
              const InlineBox* nextBox = &amp;box;
              do {
                  rightmostBox = nextBox;
<span class="line-modified">!                 nextBox = rightmostBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
              } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt;= box.bidiLevel());
              return createVisiblePositionForBox(*rightmostBox,
                  box.isLeftToRightDirection() ? rightmostBox-&gt;caretMaxOffset() : rightmostBox-&gt;caretMinOffset(), shouldAffinityBeDownstream);
          }
  
          return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
      }
  
<span class="line-modified">!     const InlineBox* nextBox = box.nextLeafOnLineIgnoringLineBreak();</span>
      if ((nextBox &amp;&amp; nextBox-&gt;bidiLevel() == box.bidiLevel())
          || box.renderer().containingBlock()-&gt;style().direction() == box.direction())
          return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
  
      // offset is on the right edge
      if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
          // e.g. right of C in aDC12BAb
          const InlineBox* rightmostBox;
          do {
              rightmostBox = nextBox;
<span class="line-modified">!             nextBox = rightmostBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
          } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel());
          return createVisiblePositionForBox(*rightmostBox, rightmostBox-&gt;caretLeftmostOffset(), shouldAffinityBeDownstream);
      }
  
      if (!nextBox || nextBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
          // e.g. right of A in aDC12BAb
          const InlineBox* leftmostBox;
          const InlineBox* prevBox = &amp;box;
          do {
              leftmostBox = prevBox;
<span class="line-modified">!             prevBox = leftmostBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
          } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt;= box.bidiLevel());
          return createVisiblePositionForBox(*leftmostBox,
              box.isLeftToRightDirection() ? leftmostBox-&gt;caretMinOffset() : leftmostBox-&gt;caretMaxOffset(), shouldAffinityBeDownstream);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,11 ***</span>
      LayoutUnit pointBlockDirection = m_first-&gt;isHorizontal() ? point.y() : point.x();
      bool blocksAreFlipped = renderer.style().isFlippedBlocksWritingMode();
  
      InlineTextBox* lastBox = nullptr;
      for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">!         if (box-&gt;isLineBreak() &amp;&amp; !box-&gt;prevLeafChild() &amp;&amp; box-&gt;nextLeafChild() &amp;&amp; !box-&gt;nextLeafChild()-&gt;isLineBreak())</span>
              box = box-&gt;nextTextBox();
  
          auto&amp; rootBox = box-&gt;root();
          LayoutUnit top = std::min(rootBox.selectionTop(), rootBox.lineTop());
          if (pointBlockDirection &gt; top || (!blocksAreFlipped &amp;&amp; pointBlockDirection == top)) {
<span class="line-new-header">--- 306,11 ---</span>
      LayoutUnit pointBlockDirection = m_first-&gt;isHorizontal() ? point.y() : point.x();
      bool blocksAreFlipped = renderer.style().isFlippedBlocksWritingMode();
  
      InlineTextBox* lastBox = nullptr;
      for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">!         if (box-&gt;isLineBreak() &amp;&amp; !box-&gt;previousLeafOnLine() &amp;&amp; box-&gt;nextLeafOnLine() &amp;&amp; !box-&gt;nextLeafOnLine()-&gt;isLineBreak())</span>
              box = box-&gt;nextTextBox();
  
          auto&amp; rootBox = box-&gt;root();
          LayoutUnit top = std::min(rootBox.selectionTop(), rootBox.lineTop());
          if (pointBlockDirection &gt; top || (!blocksAreFlipped &amp;&amp; pointBlockDirection == top)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,12 ***</span>
          for (auto* box = m_first; box; box = box-&gt;nextTextBox())
              box-&gt;root().setHasSelectedChildren(state == RenderObject::SelectionInside);
          return;
      }
  
<span class="line-modified">!     auto start = renderer.view().selection().startPosition();</span>
<span class="line-modified">!     auto end = renderer.view().selection().endPosition();</span>
      if (state == RenderObject::SelectionStart) {
          end = renderer.text().length();
          // to handle selection from end of text to end of line
          if (start &amp;&amp; start == end)
              start = end - 1;
<span class="line-new-header">--- 348,12 ---</span>
          for (auto* box = m_first; box; box = box-&gt;nextTextBox())
              box-&gt;root().setHasSelectedChildren(state == RenderObject::SelectionInside);
          return;
      }
  
<span class="line-modified">!     auto start = renderer.view().selection().startOffset();</span>
<span class="line-modified">!     auto end = renderer.view().selection().endOffset();</span>
      if (state == RenderObject::SelectionStart) {
          end = renderer.text().length();
          // to handle selection from end of text to end of line
          if (start &amp;&amp; start == end)
              start = end - 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,21 ***</span>
          if (!rect.size().isEmpty())
              rects.append(rect);
      }
  }
  
<span class="line-removed">- Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRects(const LayoutPoint&amp; accumulatedOffset) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Vector&lt;IntRect&gt; rects;</span>
<span class="line-removed">-     for (auto* box = m_first; box; box = box-&gt;nextTextBox())</span>
<span class="line-removed">-         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + box-&gt;topLeft(), box-&gt;size())));</span>
<span class="line-removed">-     return rects;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static FloatRect localQuadForTextBox(const InlineTextBox&amp; box, unsigned start, unsigned end, bool useSelectionHeight)
  {
<span class="line-modified">!     unsigned realEnd = std::min(box.end() + 1, end);</span>
      LayoutRect boxSelectionRect = box.localSelectionRect(start, realEnd);
      if (!boxSelectionRect.height())
          return FloatRect();
      if (useSelectionHeight)
          return boxSelectionRect;
<span class="line-new-header">--- 407,13 ---</span>
          if (!rect.size().isEmpty())
              rects.append(rect);
      }
  }
  
  static FloatRect localQuadForTextBox(const InlineTextBox&amp; box, unsigned start, unsigned end, bool useSelectionHeight)
  {
<span class="line-modified">!     unsigned realEnd = std::min(box.end(), end);</span>
      LayoutRect boxSelectionRect = box.localSelectionRect(start, realEnd);
      if (!boxSelectionRect.height())
          return FloatRect();
      if (useSelectionHeight)
          return boxSelectionRect;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 531,16 ***</span>
          boxSelectionRect.setX(box.x());
      }
      return boxSelectionRect;
  }
  
<span class="line-modified">! Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRectsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
  {
<span class="line-modified">!     Vector&lt;IntRect&gt; rects;</span>
      for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">!         // Note: box-&gt;end() returns the index of the last character, not the index past it</span>
<span class="line-modified">!         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end) {</span>
              FloatRect boundaries = box-&gt;calculateBoundaries();
              if (useSelectionHeight) {
                  LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);
                  if (box-&gt;isHorizontal()) {
                      boundaries.setHeight(selectionRect.height());
<span class="line-new-header">--- 427,17 ---</span>
          boxSelectionRect.setX(box.x());
      }
      return boxSelectionRect;
  }
  
<span class="line-modified">! Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuadsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool ignoreEmptyTextSelections, bool* wasFixed) const</span>
  {
<span class="line-modified">!     Vector&lt;FloatQuad&gt; quads;</span>
      for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">!         if (ignoreEmptyTextSelections &amp;&amp; !box-&gt;isSelected(start, end))</span>
<span class="line-modified">!             continue;</span>
<span class="line-added">+         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt;= end) {</span>
              FloatRect boundaries = box-&gt;calculateBoundaries();
              if (useSelectionHeight) {
                  LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);
                  if (box-&gt;isHorizontal()) {
                      boundaries.setHeight(selectionRect.height());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,18 ***</span>
                  } else {
                      boundaries.setWidth(selectionRect.width());
                      boundaries.setX(selectionRect.x());
                  }
              }
<span class="line-modified">!             rects.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed).enclosingBoundingBox());</span>
              continue;
          }
          FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
          if (!rect.isZero())
<span class="line-modified">!             rects.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed).enclosingBoundingBox());</span>
      }
<span class="line-modified">!     return rects;</span>
  }
  
  Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuads(const RenderText&amp; renderer, bool* wasFixed, ClippingOption option) const
  {
      Vector&lt;FloatQuad&gt; quads;
<span class="line-new-header">--- 445,23 ---</span>
                  } else {
                      boundaries.setWidth(selectionRect.width());
                      boundaries.setX(selectionRect.x());
                  }
              }
<span class="line-modified">!             quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));</span>
              continue;
          }
          FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
          if (!rect.isZero())
<span class="line-modified">!             quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));</span>
      }
<span class="line-modified">!     return quads;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRectsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return absoluteQuadsForRange(renderer, start, end, useSelectionHeight, false /* ignoreEmptyTextSelections */, wasFixed).map([](auto&amp; quad) { return quad.enclosingBoundingBox(); });</span>
  }
  
  Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuads(const RenderText&amp; renderer, bool* wasFixed, ClippingOption option) const
  {
      Vector&lt;FloatQuad&gt; quads;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,37 ***</span>
          quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
      }
      return quads;
  }
  
<span class="line-removed">- Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuadsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Vector&lt;FloatQuad&gt; quads;</span>
<span class="line-removed">-     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">-         // Note: box-&gt;end() returns the index of the last character, not the index past it</span>
<span class="line-removed">-         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end) {</span>
<span class="line-removed">-             FloatRect boundaries = box-&gt;calculateBoundaries();</span>
<span class="line-removed">-             if (useSelectionHeight) {</span>
<span class="line-removed">-                 LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);</span>
<span class="line-removed">-                 if (box-&gt;isHorizontal()) {</span>
<span class="line-removed">-                     boundaries.setHeight(selectionRect.height());</span>
<span class="line-removed">-                     boundaries.setY(selectionRect.y());</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     boundaries.setWidth(selectionRect.width());</span>
<span class="line-removed">-                     boundaries.setX(selectionRect.x());</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);</span>
<span class="line-removed">-         if (!rect.isZero())</span>
<span class="line-removed">-             quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return quads;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void RenderTextLineBoxes::dirtyAll()
  {
      for (auto* box = m_first; box; box = box-&gt;nextTextBox())
          box-&gt;dirtyLineBoxes();
  }
<span class="line-new-header">--- 480,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 621,14 ***</span>
      // Dirty all text boxes that include characters in between offset and offset+len.
      bool dirtiedLines = false;
      for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
          // FIXME: This shouldn&#39;t rely on the end of a dirty line box. See https://bugs.webkit.org/show_bug.cgi?id=97264
          // Text run is entirely before the affected range.
<span class="line-modified">!         if (current-&gt;end() &lt; start)</span>
              continue;
          // Text run is entirely after the affected range.
<span class="line-modified">!         if (current-&gt;start() &gt; end) {</span>
              current-&gt;offsetRun(lengthDelta);
              auto&amp; rootBox = current-&gt;root();
              if (!firstRootBox) {
                  firstRootBox = &amp;rootBox;
                  if (!dirtiedLines) {
<span class="line-new-header">--- 496,14 ---</span>
      // Dirty all text boxes that include characters in between offset and offset+len.
      bool dirtiedLines = false;
      for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
          // FIXME: This shouldn&#39;t rely on the end of a dirty line box. See https://bugs.webkit.org/show_bug.cgi?id=97264
          // Text run is entirely before the affected range.
<span class="line-modified">!         if (current-&gt;end() &lt;= start)</span>
              continue;
          // Text run is entirely after the affected range.
<span class="line-modified">!         if (current-&gt;start() &gt;= end) {</span>
              current-&gt;offsetRun(lengthDelta);
              auto&amp; rootBox = current-&gt;root();
              if (!firstRootBox) {
                  firstRootBox = &amp;rootBox;
                  if (!dirtiedLines) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,11 ***</span>
                  }
              }
              lastRootBox = &amp;rootBox;
              continue;
          }
<span class="line-modified">!         if (current-&gt;end() &gt;= start &amp;&amp; current-&gt;end() &lt;= end) {</span>
              // Text run overlaps with the left end of the affected range.
              current-&gt;dirtyLineBoxes();
              dirtiedLines = true;
              continue;
          }
<span class="line-new-header">--- 513,11 ---</span>
                  }
              }
              lastRootBox = &amp;rootBox;
              continue;
          }
<span class="line-modified">!         if (current-&gt;end() &gt; start &amp;&amp; current-&gt;end() &lt;= end) {</span>
              // Text run overlaps with the left end of the affected range.
              current-&gt;dirtyLineBoxes();
              dirtiedLines = true;
              continue;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,11 ***</span>
              // Text run subsumes the affected range.
              current-&gt;dirtyLineBoxes();
              dirtiedLines = true;
              continue;
          }
<span class="line-modified">!         if (current-&gt;start() &lt;= end &amp;&amp; current-&gt;end() &gt;= end) {</span>
              // Text run overlaps with right end of the affected range.
              current-&gt;dirtyLineBoxes();
              dirtiedLines = true;
              continue;
          }
<span class="line-new-header">--- 525,11 ---</span>
              // Text run subsumes the affected range.
              current-&gt;dirtyLineBoxes();
              dirtiedLines = true;
              continue;
          }
<span class="line-modified">!         if (current-&gt;start() &lt; end &amp;&amp; current-&gt;end() &gt;= end) {</span>
              // Text run overlaps with right end of the affected range.
              current-&gt;dirtyLineBoxes();
              dirtiedLines = true;
              continue;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,24 ***</span>
      return dirtiedLines;
  }
  
  inline void RenderTextLineBoxes::checkConsistency() const
  {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  #ifdef CHECK_CONSISTENCY
      const InlineTextBox* prev = nullptr;
      for (auto* child = m_first; child; child = child-&gt;nextTextBox()) {
          ASSERT(child-&gt;renderer() == this);
          ASSERT(child-&gt;prevTextBox() == prev);
          prev = child;
      }
      ASSERT(prev == m_last);
  #endif
<span class="line-modified">! #endif</span>
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  RenderTextLineBoxes::~RenderTextLineBoxes()
  {
      ASSERT(!m_first);
      ASSERT(!m_last);
  }
<span class="line-new-header">--- 562,24 ---</span>
      return dirtiedLines;
  }
  
  inline void RenderTextLineBoxes::checkConsistency() const
  {
<span class="line-modified">! #if ASSERT_ENABLED</span>
  #ifdef CHECK_CONSISTENCY
      const InlineTextBox* prev = nullptr;
      for (auto* child = m_first; child; child = child-&gt;nextTextBox()) {
          ASSERT(child-&gt;renderer() == this);
          ASSERT(child-&gt;prevTextBox() == prev);
          prev = child;
      }
      ASSERT(prev == m_last);
  #endif
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  RenderTextLineBoxes::~RenderTextLineBoxes()
  {
      ASSERT(!m_first);
      ASSERT(!m_last);
  }
</pre>
<center><a href="RenderText.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextLineBoxes.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ShadowChicken.h&quot;
 28 
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;ShadowChickenInlines.h&quot;
 32 #include &lt;wtf/ListDump.h&gt;
 33 
 34 namespace JSC {
 35 
 36 namespace ShadowChickenInternal {
<a name="2" id="anc2"></a><span class="line-modified"> 37 static constexpr bool verbose = false;</span>
 38 }
 39 
 40 void ShadowChicken::Packet::dump(PrintStream&amp; out) const
 41 {
 42     if (!*this) {
 43         out.print(&quot;empty&quot;);
 44         return;
 45     }
 46 
 47     if (isPrologue()) {
<a name="3" id="anc3"></a><span class="line-added"> 48         String name = &quot;?&quot;_s;</span>
<span class="line-added"> 49         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee)) {</span>
<span class="line-added"> 50             name = function-&gt;name(callee-&gt;vm());</span>
<span class="line-added"> 51             if (name.isEmpty())</span>
<span class="line-added"> 52                 name = &quot;?&quot;_s;</span>
<span class="line-added"> 53         }</span>
<span class="line-added"> 54 </span>
 55         out.print(
 56             &quot;{callee = &quot;, RawPointer(callee), &quot;, frame = &quot;, RawPointer(frame), &quot;, callerFrame = &quot;,
<a name="4" id="anc4"></a><span class="line-modified"> 57             RawPointer(callerFrame), &quot;, name = &quot;, name, &quot;}&quot;);</span>
 58         return;
 59     }
 60 
 61     if (isTail()) {
 62         out.print(&quot;tail-packet:{frame = &quot;, RawPointer(frame), &quot;}&quot;);
 63         return;
 64     }
 65 
 66     ASSERT(isThrow());
 67     out.print(&quot;throw&quot;);
 68 }
 69 
 70 void ShadowChicken::Frame::dump(PrintStream&amp; out) const
 71 {
<a name="5" id="anc5"></a><span class="line-added"> 72     String name = &quot;?&quot;_s;</span>
<span class="line-added"> 73     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee)) {</span>
<span class="line-added"> 74         name = function-&gt;name(callee-&gt;vm());</span>
<span class="line-added"> 75         if (name.isEmpty())</span>
<span class="line-added"> 76             name = &quot;?&quot;_s;</span>
<span class="line-added"> 77     }</span>
<span class="line-added"> 78 </span>
 79     out.print(
<a name="6" id="anc6"></a><span class="line-modified"> 80         &quot;{callee = &quot;, *callee, &quot;, frame = &quot;, RawPointer(frame), &quot;, isTailDeleted = &quot;,</span>
<span class="line-modified"> 81         isTailDeleted, &quot;, name = &quot;, name, &quot;}&quot;);</span>
 82 }
 83 
 84 ShadowChicken::ShadowChicken()
 85     : m_logSize(Options::shadowChickenLogSize())
 86 {
<a name="7" id="anc7"></a><span class="line-modified"> 87     // Allow one additional packet beyond m_logEnd. This is useful for the moment we</span>
<span class="line-added"> 88     // log a packet when the log is full and force an update. At that moment the packet</span>
<span class="line-added"> 89     // that is being logged should be included in the update because it may be</span>
<span class="line-added"> 90     // a critical prologue needed to rationalize the current machine stack with the</span>
<span class="line-added"> 91     // shadow stack.</span>
<span class="line-added"> 92     m_log = static_cast&lt;Packet*&gt;(fastZeroedMalloc(sizeof(Packet) * (m_logSize + 1)));</span>
 93     m_logCursor = m_log;
 94     m_logEnd = m_log + m_logSize;
 95 }
 96 
 97 ShadowChicken::~ShadowChicken()
 98 {
 99     fastFree(m_log);
100 }
101 
<a name="8" id="anc8"></a><span class="line-modified">102 void ShadowChicken::log(VM&amp; vm, CallFrame* callFrame, const Packet&amp; packet)</span>
103 {
<a name="9" id="anc9"></a><span class="line-modified">104     // This write is allowed because we construct the log with space for 1 additional packet.</span>
105     *m_logCursor++ = packet;
<a name="10" id="anc10"></a><span class="line-added">106     update(vm, callFrame);</span>
107 }
108 
<a name="11" id="anc11"></a><span class="line-modified">109 void ShadowChicken::update(VM&amp; vm, CallFrame* callFrame)</span>
110 {
111     if (ShadowChickenInternal::verbose) {
112         dataLog(&quot;Running update on: &quot;, *this, &quot;\n&quot;);
113         WTFReportBacktrace();
114     }
115 
116     const unsigned logCursorIndex = m_logCursor - m_log;
117 
118     // We need to figure out how to reconcile the current machine stack with our shadow stack. We do
119     // that by figuring out how much of the shadow stack to pop. We apply three different rules. The
120     // precise rule relies on the log. The log contains caller frames, which means that we know
121     // where we bottomed out after making any call. If we bottomed out but made no calls then &#39;exec&#39;
122     // will tell us. That&#39;s why &quot;highestPointSinceLastTime&quot; will go no lower than exec. The third
123     // rule, based on comparing to the current real stack, is executed in a later loop.
<a name="12" id="anc12"></a><span class="line-modified">124     CallFrame* highestPointSinceLastTime = callFrame;</span>
125     for (unsigned i = logCursorIndex; i--;) {
126         Packet packet = m_log[i];
127         if (packet.isPrologue()) {
128             CallFrame* watermark;
129             if (i &amp;&amp; m_log[i - 1].isTail())
130                 watermark = packet.frame;
131             else
132                 watermark = packet.callerFrame;
133             highestPointSinceLastTime = std::max(highestPointSinceLastTime, watermark);
134         }
135     }
136 
137     if (ShadowChickenInternal::verbose)
138         dataLog(&quot;Highest point since last time: &quot;, RawPointer(highestPointSinceLastTime), &quot;\n&quot;);
139 
140     while (!m_stack.isEmpty() &amp;&amp; (m_stack.last().frame &lt; highestPointSinceLastTime || m_stack.last().isTailDeleted))
141         m_stack.removeLast();
142 
143     if (ShadowChickenInternal::verbose)
144         dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
145 
146     // It&#39;s possible that the top of stack is now tail-deleted. The stack no longer contains any
147     // frames below the log&#39;s high watermark. That means that we just need to look for the first
148     // occurence of a tail packet for the current stack top.
149     if (!m_stack.isEmpty()) {
150         ASSERT(!m_stack.last().isTailDeleted);
151         for (unsigned i = 0; i &lt; logCursorIndex; ++i) {
152             Packet&amp; packet = m_log[i];
153             if (packet.isTail() &amp;&amp; packet.frame == m_stack.last().frame) {
154                 Frame&amp; frame = m_stack.last();
155                 frame.thisValue = packet.thisValue;
156                 frame.scope = packet.scope;
157                 frame.codeBlock = packet.codeBlock;
158                 frame.callSiteIndex = packet.callSiteIndex;
159                 frame.isTailDeleted = true;
160                 break;
161             }
162         }
163     }
164 
<a name="13" id="anc13"></a>
165     if (ShadowChickenInternal::verbose)
166         dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
167 
<a name="14" id="anc14"></a><span class="line-modified">168     // The log-based and callFrame-based rules require that ShadowChicken was enabled. The point of</span>
169     // ShadowChicken is to give sensible-looking results even if we had not logged. This means that
170     // we need to reconcile the shadow stack and the real stack by actually looking at the real
171     // stack. This reconciliation allows the shadow stack to have extra tail-deleted frames, but it
172     // forbids it from diverging from the real stack on normal frames.
173     if (!m_stack.isEmpty()) {
174         Vector&lt;Frame&gt; stackRightNow;
175         StackVisitor::visit(
<a name="15" id="anc15"></a><span class="line-modified">176             callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
177                 if (visitor-&gt;isInlinedFrame())
178                     return StackVisitor::Continue;
179                 if (visitor-&gt;isWasmFrame()) {
180                     // FIXME: Make shadow chicken work with Wasm.
181                     // https://bugs.webkit.org/show_bug.cgi?id=165441
182                     return StackVisitor::Continue;
183                 }
184 
185                 bool isTailDeleted = false;
186                 // FIXME: Make shadow chicken work with Wasm.
187                 // https://bugs.webkit.org/show_bug.cgi?id=165441
188                 stackRightNow.append(Frame(jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()), visitor-&gt;callFrame(), isTailDeleted));
189                 return StackVisitor::Continue;
190             });
191         stackRightNow.reverse();
192 
193         if (ShadowChickenInternal::verbose)
194             dataLog(&quot;    Stack right now: &quot;, listDump(stackRightNow), &quot;\n&quot;);
195 
196         unsigned shadowIndex = 0;
197         unsigned rightNowIndex = 0;
198         while (shadowIndex &lt; m_stack.size() &amp;&amp; rightNowIndex &lt; stackRightNow.size()) {
199             if (m_stack[shadowIndex].isTailDeleted) {
200                 shadowIndex++;
201                 continue;
202             }
203 
204             // We specifically don&#39;t use operator== here because we are using a less
205             // strict filter on equality of frames. For example, the scope pointer
206             // could change, but we wouldn&#39;t want to consider the frames different entities
207             // because of that because it&#39;s natural for the program to change scopes.
208             if (m_stack[shadowIndex].frame == stackRightNow[rightNowIndex].frame
209                 &amp;&amp; m_stack[shadowIndex].callee == stackRightNow[rightNowIndex].callee) {
210                 shadowIndex++;
211                 rightNowIndex++;
212                 continue;
213             }
214             break;
215         }
216         m_stack.resize(shadowIndex);
217 
218         if (ShadowChickenInternal::verbose)
219             dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
220     }
221 
222     // It&#39;s possible that the top stack frame is actually lower than highestPointSinceLastTime.
223     // Account for that here.
224     highestPointSinceLastTime = nullptr;
225     for (unsigned i = m_stack.size(); i--;) {
226         if (!m_stack[i].isTailDeleted) {
227             highestPointSinceLastTime = m_stack[i].frame;
228             break;
229         }
230     }
231 
232     if (ShadowChickenInternal::verbose)
233         dataLog(&quot;    Highest point since last time: &quot;, RawPointer(highestPointSinceLastTime), &quot;\n&quot;);
234 
235     // Set everything up so that we know where the top frame is in the log.
236     unsigned indexInLog = logCursorIndex;
237 
238     auto advanceIndexInLogTo = [&amp;] (CallFrame* frame, JSObject* callee, CallFrame* callerFrame) -&gt; bool {
239         if (ShadowChickenInternal::verbose)
240             dataLog(&quot;    Advancing to frame = &quot;, RawPointer(frame), &quot; from indexInLog = &quot;, indexInLog, &quot;\n&quot;);
241         if (indexInLog &gt; logCursorIndex) {
242             if (ShadowChickenInternal::verbose)
243                 dataLog(&quot;    Bailing.\n&quot;);
244             return false;
245         }
246 
247         unsigned oldIndexInLog = indexInLog;
248 
249         while (indexInLog--) {
250             Packet packet = m_log[indexInLog];
251 
252             // If all callees opt into ShadowChicken, then this search will rapidly terminate when
253             // we find our frame. But if our frame&#39;s callee didn&#39;t emit a prologue packet because it
254             // didn&#39;t opt in, then we will keep looking backwards until we *might* find a different
255             // frame. If we&#39;ve been given the callee and callerFrame as a filter, then it&#39;s unlikely
256             // that we will hit the wrong frame. But we don&#39;t always have that information.
257             //
258             // This means it&#39;s worth adding other filters. For example, we could track changes in
259             // stack size. Once we&#39;ve seen a frame at some height, we&#39;re no longer interested in
260             // frames below that height. Also, we can break as soon as we see a frame higher than
261             // the one we&#39;re looking for.
262             // FIXME: Add more filters.
263             // https://bugs.webkit.org/show_bug.cgi?id=155685
264 
265             if (packet.isPrologue() &amp;&amp; packet.frame == frame
266                 &amp;&amp; (!callee || packet.callee == callee)
267                 &amp;&amp; (!callerFrame || packet.callerFrame == callerFrame)) {
268                 if (ShadowChickenInternal::verbose)
269                     dataLog(&quot;    Found at indexInLog = &quot;, indexInLog, &quot;\n&quot;);
270                 return true;
271             }
272         }
273 
274         // This is an interesting eventuality. We will see this if ShadowChicken was not
275         // consistently enabled. We have a choice between:
276         //
277         // - Leaving the log index at -1, which will prevent the log from being considered. This is
278         //   the most conservative. It means that we will not be able to recover tail-deleted frames
279         //   from anything that sits above a frame that didn&#39;t log a prologue packet. This means
280         //   that everyone who creates prologues must log prologue packets.
281         //
282         // - Restoring the log index to what it was before. This prevents us from considering
283         //   whether this frame has tail-deleted frames behind it, but that&#39;s about it. The problem
284         //   with this approach is that it might recover tail-deleted frames that aren&#39;t relevant.
285         //   I haven&#39;t thought about this too deeply, though.
286         //
287         // It seems like the latter option is less harmful, so that&#39;s what we do.
288         indexInLog = oldIndexInLog;
289 
290         if (ShadowChickenInternal::verbose)
291             dataLog(&quot;    Didn&#39;t find it.\n&quot;);
292         return false;
293     };
294 
295     Vector&lt;Frame&gt; toPush;
296     StackVisitor::visit(
<a name="16" id="anc16"></a><span class="line-modified">297         callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
298             if (visitor-&gt;isInlinedFrame()) {
299                 // FIXME: Handle inlining.
300                 // https://bugs.webkit.org/show_bug.cgi?id=155686
301                 return StackVisitor::Continue;
302             }
303 
304             if (visitor-&gt;isWasmFrame()) {
305                 // FIXME: Make shadow chicken work with Wasm.
306                 return StackVisitor::Continue;
307             }
308 
309             CallFrame* callFrame = visitor-&gt;callFrame();
<a name="17" id="anc17"></a><span class="line-modified">310             if (ShadowChickenInternal::verbose) {</span>
<span class="line-modified">311                 dataLog(&quot;    Examining callFrame:&quot;, RawPointer(callFrame), &quot;, callee:&quot;, RawPointer(callFrame-&gt;jsCallee()), &quot;, callerFrame:&quot;, RawPointer(callFrame-&gt;callerFrame()), &quot;\n&quot;);</span>
<span class="line-added">312                 JSObject* callee = callFrame-&gt;jsCallee();</span>
<span class="line-added">313                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee))</span>
<span class="line-added">314                     dataLog(&quot;      Function = &quot;, function-&gt;name(callee-&gt;vm()), &quot;\n&quot;);</span>
<span class="line-added">315             }</span>
<span class="line-added">316 </span>
317             if (callFrame == highestPointSinceLastTime) {
318                 if (ShadowChickenInternal::verbose)
<a name="18" id="anc18"></a><span class="line-modified">319                     dataLog(&quot;    Bailing at &quot;, RawPointer(callFrame), &quot; because it&#39;s the highest point since last time\n&quot;);</span>
<span class="line-added">320 </span>
<span class="line-added">321                 // FIXME: At this point the shadow stack may still have tail deleted frames</span>
<span class="line-added">322                 // that do not run into the current call frame but are left in the shadow stack.</span>
<span class="line-added">323                 // Those tail deleted frames should be validated somehow.</span>
<span class="line-added">324 </span>
325                 return StackVisitor::Done;
326             }
327 
328             bool foundFrame = advanceIndexInLogTo(callFrame, callFrame-&gt;jsCallee(), callFrame-&gt;callerFrame());
329             bool isTailDeleted = false;
330             JSScope* scope = nullptr;
331             CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<a name="19" id="anc19"></a><span class="line-modified">332             JSValue scopeValue = callFrame-&gt;bytecodeIndex() &amp;&amp; codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid()</span>
333                 ? callFrame-&gt;registers()[codeBlock-&gt;scopeRegister().offset()].jsValue()
334                 : jsUndefined();
335             if (!scopeValue.isUndefined() &amp;&amp; codeBlock-&gt;wasCompiledWithDebuggingOpcodes()) {
336                 scope = jsCast&lt;JSScope*&gt;(scopeValue.asCell());
337                 RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
338             } else if (foundFrame) {
339                 scope = m_log[indexInLog].scope;
340                 if (scope)
341                     RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
342             }
343             toPush.append(Frame(jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()), callFrame, isTailDeleted, callFrame-&gt;thisValue(), scope, codeBlock, callFrame-&gt;callSiteIndex()));
344 
345             if (indexInLog &lt; logCursorIndex
346                 // This condition protects us from the case where advanceIndexInLogTo didn&#39;t find
347                 // anything.
348                 &amp;&amp; m_log[indexInLog].frame == toPush.last().frame) {
349                 if (ShadowChickenInternal::verbose)
<a name="20" id="anc20"></a><span class="line-modified">350                     dataLog(&quot;    Going to loop through to find tail deleted frames using &quot;, RawPointer(callFrame), &quot; with indexInLog = &quot;, indexInLog, &quot; and push-stack top = &quot;, toPush.last(), &quot;\n&quot;);</span>
351                 for (;;) {
352                     ASSERT(m_log[indexInLog].frame == toPush.last().frame);
353 
354                     // Right now the index is pointing at a prologue packet of the last frame that
355                     // we pushed. Peek behind that packet to see if there is a tail packet. If there
356                     // is one then we know that there is a corresponding prologue packet that will
357                     // tell us about a tail-deleted frame.
358 
359                     if (!indexInLog)
360                         break;
361                     Packet tailPacket = m_log[indexInLog - 1];
362                     if (!tailPacket.isTail()) {
363                         // Last frame that we recorded was not the outcome of a tail call. So, there
364                         // will not be any more deleted frames.
365                         // FIXME: We might want to have a filter here. Consider that this was a tail
366                         // marker for a tail call to something that didn&#39;t log anything. It should
367                         // be sufficient to give the tail marker a copy of the caller frame.
368                         // https://bugs.webkit.org/show_bug.cgi?id=155687
369                         break;
370                     }
371                     indexInLog--; // Skip over the tail packet.
372 
<a name="21" id="anc21"></a><span class="line-added">373                     // FIXME: After a few iterations the tail packet referenced frame may not be the</span>
<span class="line-added">374                     // same as the original callFrame for the real stack frame we started with.</span>
<span class="line-added">375                     // It is unclear when we should break.</span>
<span class="line-added">376 </span>
377                     if (!advanceIndexInLogTo(tailPacket.frame, nullptr, nullptr)) {
378                         if (ShadowChickenInternal::verbose)
379                             dataLog(&quot;Can&#39;t find prologue packet for tail: &quot;, RawPointer(tailPacket.frame), &quot;\n&quot;);
380                         // We were unable to locate the prologue packet for this tail packet.
381                         // This is rare but can happen in a situation like:
382                         // function foo() {
383                         //     ... call some deeply tail-recursive function, causing a random number of log processings.
384                         //     return bar(); // tail call
385                         // }
386                         break;
387                     }
388                     Packet packet = m_log[indexInLog];
389                     bool isTailDeleted = true;
390                     RELEASE_ASSERT(tailPacket.scope-&gt;inherits&lt;JSScope&gt;(vm));
391                     toPush.append(Frame(packet.callee, packet.frame, isTailDeleted, tailPacket.thisValue, tailPacket.scope, tailPacket.codeBlock, tailPacket.callSiteIndex));
392                 }
393             }
394 
395             return StackVisitor::Continue;
396         });
397 
398     if (ShadowChickenInternal::verbose)
399         dataLog(&quot;    Pushing: &quot;, listDump(toPush), &quot;\n&quot;);
400 
401     for (unsigned i = toPush.size(); i--;)
402         m_stack.append(toPush[i]);
403 
404     // We want to reset the log. There is a fun corner-case: there could be a tail marker at the end
405     // of this log. We could make that work by setting isTailDeleted on the top of stack, but that
406     // would require more corner cases in the complicated reconciliation code above. That code
407     // already knows how to handle a tail packet at the beginning, so we just leverage that here.
408     if (logCursorIndex &amp;&amp; m_log[logCursorIndex - 1].isTail()) {
409         m_log[0] = m_log[logCursorIndex - 1];
410         m_logCursor = m_log + 1;
411     } else
412         m_logCursor = m_log;
413 
414     if (ShadowChickenInternal::verbose)
<a name="22" id="anc22"></a><span class="line-modified">415         dataLog(&quot;    After pushing: &quot;, listDump(m_stack), &quot;\n&quot;);</span>
416 
417     // Remove tail frames until the number of tail deleted frames is small enough.
418     const unsigned maxTailDeletedFrames = Options::shadowChickenMaxTailDeletedFramesSize();
419     if (m_stack.size() &gt; maxTailDeletedFrames) {
420         unsigned numberOfTailDeletedFrames = 0;
421         for (const Frame&amp; frame : m_stack) {
422             if (frame.isTailDeleted)
423                 numberOfTailDeletedFrames++;
424         }
425         if (numberOfTailDeletedFrames &gt; maxTailDeletedFrames) {
426             unsigned dstIndex = 0;
427             unsigned srcIndex = 0;
428             while (srcIndex &lt; m_stack.size()) {
429                 Frame frame = m_stack[srcIndex++];
430                 if (numberOfTailDeletedFrames &gt; maxTailDeletedFrames &amp;&amp; frame.isTailDeleted) {
431                     numberOfTailDeletedFrames--;
432                     continue;
433                 }
434                 m_stack[dstIndex++] = frame;
435             }
436             m_stack.shrink(dstIndex);
437         }
438     }
439 
440     if (ShadowChickenInternal::verbose)
441         dataLog(&quot;    After clean-up: &quot;, *this, &quot;\n&quot;);
442 }
443 
444 void ShadowChicken::visitChildren(SlotVisitor&amp; visitor)
445 {
446     for (unsigned i = m_logCursor - m_log; i--;) {
447         JSObject* callee = m_log[i].callee;
448         if (callee != Packet::tailMarker() &amp;&amp; callee != Packet::throwMarker())
449             visitor.appendUnbarriered(callee);
450         if (callee != Packet::throwMarker())
451             visitor.appendUnbarriered(m_log[i].scope);
452         if (callee == Packet::tailMarker()) {
453             visitor.appendUnbarriered(m_log[i].thisValue);
454             visitor.appendUnbarriered(m_log[i].codeBlock);
455         }
456     }
457 
458     for (unsigned i = m_stack.size(); i--; ) {
459         Frame&amp; frame = m_stack[i];
460         visitor.appendUnbarriered(frame.thisValue);
461         visitor.appendUnbarriered(frame.callee);
462         if (frame.scope)
463             visitor.appendUnbarriered(frame.scope);
464         if (frame.codeBlock)
465             visitor.appendUnbarriered(frame.codeBlock);
466     }
467 }
468 
469 void ShadowChicken::reset()
470 {
471     m_logCursor = m_log;
472     m_stack.clear();
473 }
474 
475 void ShadowChicken::dump(PrintStream&amp; out) const
476 {
477     out.print(&quot;{stack = [&quot;, listDump(m_stack), &quot;], log = [&quot;);
478 
479     CommaPrinter comma;
480     unsigned limit = static_cast&lt;unsigned&gt;(m_logCursor - m_log);
481     out.print(&quot;\n&quot;);
482     for (unsigned i = 0; i &lt; limit; ++i)
<a name="23" id="anc23"></a><span class="line-modified">483         out.print(&quot;\t&quot;, comma, &quot;[&quot;, i, &quot;] &quot;, m_log[i], &quot;\n&quot;);</span>
484     out.print(&quot;]}&quot;);
485 }
486 
<a name="24" id="anc24"></a><span class="line-modified">487 JSArray* ShadowChicken::functionsOnStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
488 {
<a name="25" id="anc25"></a><span class="line-modified">489     VM&amp; vm = globalObject-&gt;vm();</span>
490     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="26" id="anc26"></a><span class="line-modified">491     JSArray* result = constructEmptyArray(globalObject, nullptr);</span>
492     RETURN_IF_EXCEPTION(scope, nullptr);
493 
494     iterate(
<a name="27" id="anc27"></a><span class="line-modified">495         vm, callFrame,</span>
496         [&amp;] (const Frame&amp; frame) -&gt; bool {
<a name="28" id="anc28"></a><span class="line-modified">497             result-&gt;push(globalObject, frame.callee);</span>
498             scope.releaseAssertNoException(); // This function is only called from tests.
499             return true;
500         });
501 
502     return result;
503 }
504 
505 } // namespace JSC
506 
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
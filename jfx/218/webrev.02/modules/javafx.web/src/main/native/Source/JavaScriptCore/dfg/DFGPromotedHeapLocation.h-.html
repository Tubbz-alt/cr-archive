<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPromotedHeapLocation.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGEdge.h&quot;
 31 #include &quot;DFGNodeOrigin.h&quot;
 32 #include &lt;wtf/HashTable.h&gt;
 33 #include &lt;wtf/PrintStream.h&gt;
 34 
 35 namespace JSC { namespace DFG {
 36 
 37 struct Node;
 38 
 39 // Promoted locations are like heap locations but are meant to be more precise. A heap location is
 40 // applicable to CSE scenarios, where it makes sense to speak of a location very abstractly. A
 41 // promoted heap location is for cases where we speak of a specific object and the compiler knows
 42 // this object&#39;s identity - for example, the object allocation has been eliminated and we turned the
 43 // fields into local variables. Because these two cases have subtly different needs, we use subtly
 44 // different structures. One of the really significant differences is that promoted locations can be
 45 // spoken of using either a descriptor which does not refer to any Node*&#39;s or with a heap location,
 46 // which is a descriptor with a Node* base.
 47 
 48 enum PromotedLocationKind {
 49     InvalidPromotedLocationKind,
 50 
 51     ActivationScopePLoc,
 52     ActivationSymbolTablePLoc,
 53     ArgumentCountPLoc,
 54     ArgumentPLoc,
 55     ArgumentsCalleePLoc,
 56     ClosureVarPLoc,
 57     FunctionActivationPLoc,
 58     FunctionExecutablePLoc,
 59     IndexedPropertyPLoc,
 60     NamedPropertyPLoc,
 61     PublicLengthPLoc,
 62     StructurePLoc,
 63     VectorLengthPLoc,
 64     SpreadPLoc,
 65     NewArrayWithSpreadArgumentPLoc,
 66     NewArrayBufferPLoc,
 67     RegExpObjectRegExpPLoc,
 68     RegExpObjectLastIndexPLoc,
 69 };
 70 
 71 class PromotedLocationDescriptor {
 72 public:
 73     PromotedLocationDescriptor(
 74         PromotedLocationKind kind = InvalidPromotedLocationKind, unsigned info = 0)
 75         : m_kind(kind)
 76         , m_info(info)
 77     {
 78     }
 79 
 80     PromotedLocationDescriptor(WTF::HashTableDeletedValueType)
 81         : m_kind(InvalidPromotedLocationKind)
 82         , m_info(1)
 83     {
 84     }
 85 
 86     bool operator!() const { return m_kind == InvalidPromotedLocationKind; }
 87 
 88     explicit operator bool() const { return !!*this; }
 89 
 90     PromotedLocationKind kind() const { return m_kind; }
 91     unsigned info() const { return m_info; }
 92 
 93     unsigned imm1() const { return static_cast&lt;uint32_t&gt;(m_kind); }
 94     unsigned imm2() const { return static_cast&lt;uint32_t&gt;(m_info); }
 95 
 96     unsigned hash() const
 97     {
 98         return m_kind + m_info;
 99     }
100 
101     bool operator==(const PromotedLocationDescriptor&amp; other) const
102     {
103         return m_kind == other.m_kind
104             &amp;&amp; m_info == other.m_info;
105     }
106 
107     bool operator!=(const PromotedLocationDescriptor&amp; other) const
108     {
109         return !(*this == other);
110     }
111 
112     bool isHashTableDeletedValue() const
113     {
114         return m_kind == InvalidPromotedLocationKind &amp;&amp; m_info;
115     }
116 
117     bool neededForMaterialization() const
118     {
119         switch (kind()) {
120         case NamedPropertyPLoc:
121         case ClosureVarPLoc:
122         case RegExpObjectLastIndexPLoc:
123             return false;
124 
125         default:
126             return true;
127         }
128     }
129 
130     void dump(PrintStream&amp; out) const;
131 
132 private:
133     PromotedLocationKind m_kind;
134     unsigned m_info;
135 };
136 
137 struct PromotedLocationDescriptorHash {
138     static unsigned hash(const PromotedLocationDescriptor&amp; key) { return key.hash(); }
139     static bool equal(const PromotedLocationDescriptor&amp; a, const PromotedLocationDescriptor&amp; b) { return a == b; }
140     static const bool safeToCompareToEmptyOrDeleted = true;
141 };
142 
143 class PromotedHeapLocation {
144 public:
145     PromotedHeapLocation(
146         PromotedLocationKind kind = InvalidPromotedLocationKind,
147         Node* base = nullptr, unsigned info = 0)
148         : m_base(base)
149         , m_meta(kind, info)
150     {
151     }
152 
153     PromotedHeapLocation(
154         PromotedLocationKind kind, Edge base, unsigned info = 0)
155         : PromotedHeapLocation(kind, base.node(), info)
156     {
157     }
158 
159     PromotedHeapLocation(Node* base, PromotedLocationDescriptor meta)
160         : m_base(base)
161         , m_meta(meta)
162     {
163     }
164 
165     PromotedHeapLocation(WTF::HashTableDeletedValueType)
166         : m_base(nullptr)
167         , m_meta(InvalidPromotedLocationKind, 1)
168     {
169     }
170 
171     Node* createHint(Graph&amp;, NodeOrigin, Node* value);
172 
173     bool operator!() const { return kind() == InvalidPromotedLocationKind; }
174 
175     PromotedLocationKind kind() const { return m_meta.kind(); }
176     Node* base() const { return m_base; }
177     unsigned info() const { return m_meta.info(); }
178     PromotedLocationDescriptor descriptor() const { return m_meta; }
179 
180     unsigned hash() const
181     {
182         return m_meta.hash() + WTF::PtrHash&lt;Node*&gt;::hash(m_base);
183     }
184 
185     bool operator==(const PromotedHeapLocation&amp; other) const
186     {
187         return m_base == other.m_base
188             &amp;&amp; m_meta == other.m_meta;
189     }
190 
191     bool isHashTableDeletedValue() const
192     {
193         return m_meta.isHashTableDeletedValue();
194     }
195 
196     void dump(PrintStream&amp; out) const;
197 
198 private:
199     Node* m_base;
200     PromotedLocationDescriptor m_meta;
201 };
202 
203 struct PromotedHeapLocationHash {
204     static unsigned hash(const PromotedHeapLocation&amp; key) { return key.hash(); }
205     static bool equal(const PromotedHeapLocation&amp; a, const PromotedHeapLocation&amp; b) { return a == b; }
206     static const bool safeToCompareToEmptyOrDeleted = true;
207 };
208 
209 } } // namespace JSC::DFG
210 
211 namespace WTF {
212 
213 void printInternal(PrintStream&amp;, JSC::DFG::PromotedLocationKind);
214 
215 template&lt;typename T&gt; struct DefaultHash;
216 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedHeapLocation&gt; {
217     typedef JSC::DFG::PromotedHeapLocationHash Hash;
218 };
219 
220 template&lt;typename T&gt; struct HashTraits;
221 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; {
222     static const bool emptyValueIsZero = false;
223 };
224 
225 template&lt;typename T&gt; struct DefaultHash;
226 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
227     typedef JSC::DFG::PromotedLocationDescriptorHash Hash;
228 };
229 
230 template&lt;typename T&gt; struct HashTraits;
231 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
232     static const bool emptyValueIsZero = false;
233 };
234 
235 } // namespace WTF
236 
237 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
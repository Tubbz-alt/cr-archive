<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGHeapLocation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGInPlaceAbstractState.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGInPlaceAbstractState.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;DFGBasicBlock.h&quot;
<span class="line-modified"> 33 #include &quot;GetByIdStatus.h&quot;</span>
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;PutByIdStatus.h&quot;
 36 #include &quot;StringObject.h&quot;
 37 #include &quot;SuperSampler.h&quot;
 38 
 39 namespace JSC { namespace DFG {
 40 
 41 namespace DFGInPlaceAbstractStateInternal {
<span class="line-modified"> 42 static const bool verbose = false;</span>
 43 }
 44 
 45 InPlaceAbstractState::InPlaceAbstractState(Graph&amp; graph)
 46     : m_graph(graph)
 47     , m_abstractValues(*graph.m_abstractValuesCache)
<span class="line-modified"> 48     , m_variables(m_graph.m_codeBlock-&gt;numParameters(), graph.m_localVars)</span>
<span class="line-modified"> 49     , m_block(0)</span>
 50 {
 51 }
 52 
 53 InPlaceAbstractState::~InPlaceAbstractState() { }
 54 
 55 void InPlaceAbstractState::beginBasicBlock(BasicBlock* basicBlock)
 56 {
 57     ASSERT(!m_block);
 58 
 59     ASSERT(basicBlock-&gt;variablesAtHead.numberOfLocals() == basicBlock-&gt;valuesAtHead.numberOfLocals());
 60     ASSERT(basicBlock-&gt;variablesAtTail.numberOfLocals() == basicBlock-&gt;valuesAtTail.numberOfLocals());
 61     ASSERT(basicBlock-&gt;variablesAtHead.numberOfLocals() == basicBlock-&gt;variablesAtTail.numberOfLocals());
 62 
 63     m_abstractValues.resize();
 64 
 65     AbstractValueClobberEpoch epoch = AbstractValueClobberEpoch::first(basicBlock-&gt;cfaStructureClobberStateAtHead);
 66     m_epochAtHead = epoch;
 67     m_effectEpoch = epoch;
 68 
 69     m_block = basicBlock;
 70 
 71     m_activeVariables.clearRange(0, std::min(m_variables.size(), m_activeVariables.size()));
 72     if (m_variables.size() &gt; m_activeVariables.size())
 73         m_activeVariables.resize(m_variables.size());
 74 
 75     if (m_graph.m_form == SSA) {
 76         for (NodeAbstractValuePair&amp; entry : basicBlock-&gt;ssa-&gt;valuesAtHead) {
 77             if (entry.node.isStillValid()) {
 78                 AbstractValue&amp; value = m_abstractValues.at(entry.node);
 79                 value = entry.value;
 80                 value.m_effectEpoch = epoch;
 81             }
 82         }
 83     }
 84     basicBlock-&gt;cfaShouldRevisit = false;
 85     basicBlock-&gt;cfaHasVisited = true;
 86     m_isValid = true;
<span class="line-modified"> 87     m_foundConstants = false;</span>
 88     m_branchDirection = InvalidBranchDirection;
 89     m_structureClobberState = basicBlock-&gt;cfaStructureClobberStateAtHead;
 90 }
 91 
 92 static void setLiveValues(Vector&lt;NodeAbstractValuePair&gt;&amp; values, const Vector&lt;NodeFlowProjection&gt;&amp; live)
 93 {
 94     values.shrink(0);
 95     values.reserveCapacity(live.size());
 96     for (NodeFlowProjection node : live)
 97         values.uncheckedAppend(NodeAbstractValuePair { node, AbstractValue() });
 98 }
 99 
100 Operands&lt;AbstractValue&gt;&amp; InPlaceAbstractState::variablesForDebugging()
101 {
102     activateAllVariables();
103     return m_variables;
104 }
105 
106 void InPlaceAbstractState::activateAllVariables()
107 {
108     for (size_t i = m_variables.size(); i--;)
109         activateVariableIfNecessary(i);
110 }
111 
112 void InPlaceAbstractState::initialize()
113 {
114     for (BasicBlock* entrypoint : m_graph.m_roots) {
115         entrypoint-&gt;cfaShouldRevisit = true;
116         entrypoint-&gt;cfaHasVisited = false;
<span class="line-modified">117         entrypoint-&gt;cfaFoundConstants = false;</span>
118         entrypoint-&gt;cfaStructureClobberStateAtHead = StructuresAreWatched;
119         entrypoint-&gt;cfaStructureClobberStateAtTail = StructuresAreWatched;
120 
121         if (m_graph.m_form == SSA)  {
122             for (size_t i = 0; i &lt; entrypoint-&gt;valuesAtHead.numberOfArguments(); ++i) {
123                 entrypoint-&gt;valuesAtHead.argument(i).clear();
124                 entrypoint-&gt;valuesAtTail.argument(i).clear();
125             }
126         } else {
127             const ArgumentsVector&amp; arguments = m_graph.m_rootToArguments.find(entrypoint)-&gt;value;
128             for (size_t i = 0; i &lt; entrypoint-&gt;valuesAtHead.numberOfArguments(); ++i) {
129                 entrypoint-&gt;valuesAtTail.argument(i).clear();
130 
131                 FlushFormat format;
132                 Node* node = arguments[i];
133                 if (!node)
134                     format = FlushedJSValue;
135                 else {
136                     ASSERT(node-&gt;op() == SetArgumentDefinitely);
137                     format = node-&gt;variableAccessData()-&gt;flushFormat();
</pre>
<hr />
<pre>
155                     break;
156                 }
157             }
158         }
159 
160         for (size_t i = 0; i &lt; entrypoint-&gt;valuesAtHead.numberOfLocals(); ++i) {
161             entrypoint-&gt;valuesAtHead.local(i).clear();
162             entrypoint-&gt;valuesAtTail.local(i).clear();
163         }
164     }
165 
166     for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
167         if (m_graph.isRoot(block)) {
168             // We bootstrapped the CFG roots above.
169             continue;
170         }
171 
172         ASSERT(block-&gt;isReachable);
173         block-&gt;cfaShouldRevisit = false;
174         block-&gt;cfaHasVisited = false;
<span class="line-modified">175         block-&gt;cfaFoundConstants = false;</span>
176         block-&gt;cfaStructureClobberStateAtHead = StructuresAreWatched;
177         block-&gt;cfaStructureClobberStateAtTail = StructuresAreWatched;
178         for (size_t i = 0; i &lt; block-&gt;valuesAtHead.numberOfArguments(); ++i) {
179             block-&gt;valuesAtHead.argument(i).clear();
180             block-&gt;valuesAtTail.argument(i).clear();
181         }
182         for (size_t i = 0; i &lt; block-&gt;valuesAtHead.numberOfLocals(); ++i) {
183             block-&gt;valuesAtHead.local(i).clear();
184             block-&gt;valuesAtTail.local(i).clear();
185         }
186     }
187 
188     if (m_graph.m_form == SSA) {
189         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
190             BasicBlock* block = m_graph.block(blockIndex);
191             if (!block)
192                 continue;
193             setLiveValues(block-&gt;ssa-&gt;valuesAtHead, block-&gt;ssa-&gt;liveAtHead);
194             setLiveValues(block-&gt;ssa-&gt;valuesAtTail, block-&gt;ssa-&gt;liveAtTail);
195         }
196     }
197 }
198 
199 bool InPlaceAbstractState::endBasicBlock()
200 {
201     ASSERT(m_block);
202 
203     BasicBlock* block = m_block; // Save the block for successor merging.
204 
<span class="line-modified">205     block-&gt;cfaFoundConstants = m_foundConstants;</span>
206     block-&gt;cfaDidFinish = m_isValid;
207     block-&gt;cfaBranchDirection = m_branchDirection;
208 
209     if (!m_isValid) {
210         reset();
211         return false;
212     }
213 
214     AbstractValueClobberEpoch epochAtHead = m_epochAtHead;
215     AbstractValueClobberEpoch currentEpoch = m_effectEpoch;
216 
217     block-&gt;cfaStructureClobberStateAtTail = m_structureClobberState;
218 
219     switch (m_graph.m_form) {
220     case ThreadedCPS: {
221         ASSERT(block-&gt;variablesAtTail.size() == block-&gt;valuesAtTail.size());
222         ASSERT(block-&gt;variablesAtTail.size() == m_variables.size());
223         for (size_t index = m_variables.size(); index--;) {
224             Node* node = block-&gt;variablesAtTail[index];
225             if (!node)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGInPlaceAbstractState.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;DFGBasicBlock.h&quot;
<span class="line-modified"> 33 #include &quot;GetByStatus.h&quot;</span>
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;PutByIdStatus.h&quot;
 36 #include &quot;StringObject.h&quot;
 37 #include &quot;SuperSampler.h&quot;
 38 
 39 namespace JSC { namespace DFG {
 40 
 41 namespace DFGInPlaceAbstractStateInternal {
<span class="line-modified"> 42 static constexpr bool verbose = false;</span>
 43 }
 44 
 45 InPlaceAbstractState::InPlaceAbstractState(Graph&amp; graph)
 46     : m_graph(graph)
 47     , m_abstractValues(*graph.m_abstractValuesCache)
<span class="line-modified"> 48     , m_variables(OperandsLike, graph.block(0)-&gt;variablesAtHead)</span>
<span class="line-modified"> 49     , m_block(nullptr)</span>
 50 {
 51 }
 52 
 53 InPlaceAbstractState::~InPlaceAbstractState() { }
 54 
 55 void InPlaceAbstractState::beginBasicBlock(BasicBlock* basicBlock)
 56 {
 57     ASSERT(!m_block);
 58 
 59     ASSERT(basicBlock-&gt;variablesAtHead.numberOfLocals() == basicBlock-&gt;valuesAtHead.numberOfLocals());
 60     ASSERT(basicBlock-&gt;variablesAtTail.numberOfLocals() == basicBlock-&gt;valuesAtTail.numberOfLocals());
 61     ASSERT(basicBlock-&gt;variablesAtHead.numberOfLocals() == basicBlock-&gt;variablesAtTail.numberOfLocals());
 62 
 63     m_abstractValues.resize();
 64 
 65     AbstractValueClobberEpoch epoch = AbstractValueClobberEpoch::first(basicBlock-&gt;cfaStructureClobberStateAtHead);
 66     m_epochAtHead = epoch;
 67     m_effectEpoch = epoch;
 68 
 69     m_block = basicBlock;
 70 
 71     m_activeVariables.clearRange(0, std::min(m_variables.size(), m_activeVariables.size()));
 72     if (m_variables.size() &gt; m_activeVariables.size())
 73         m_activeVariables.resize(m_variables.size());
 74 
 75     if (m_graph.m_form == SSA) {
 76         for (NodeAbstractValuePair&amp; entry : basicBlock-&gt;ssa-&gt;valuesAtHead) {
 77             if (entry.node.isStillValid()) {
 78                 AbstractValue&amp; value = m_abstractValues.at(entry.node);
 79                 value = entry.value;
 80                 value.m_effectEpoch = epoch;
 81             }
 82         }
 83     }
 84     basicBlock-&gt;cfaShouldRevisit = false;
 85     basicBlock-&gt;cfaHasVisited = true;
 86     m_isValid = true;
<span class="line-modified"> 87     m_shouldTryConstantFolding = false;</span>
 88     m_branchDirection = InvalidBranchDirection;
 89     m_structureClobberState = basicBlock-&gt;cfaStructureClobberStateAtHead;
 90 }
 91 
 92 static void setLiveValues(Vector&lt;NodeAbstractValuePair&gt;&amp; values, const Vector&lt;NodeFlowProjection&gt;&amp; live)
 93 {
 94     values.shrink(0);
 95     values.reserveCapacity(live.size());
 96     for (NodeFlowProjection node : live)
 97         values.uncheckedAppend(NodeAbstractValuePair { node, AbstractValue() });
 98 }
 99 
100 Operands&lt;AbstractValue&gt;&amp; InPlaceAbstractState::variablesForDebugging()
101 {
102     activateAllVariables();
103     return m_variables;
104 }
105 
106 void InPlaceAbstractState::activateAllVariables()
107 {
108     for (size_t i = m_variables.size(); i--;)
109         activateVariableIfNecessary(i);
110 }
111 
112 void InPlaceAbstractState::initialize()
113 {
114     for (BasicBlock* entrypoint : m_graph.m_roots) {
115         entrypoint-&gt;cfaShouldRevisit = true;
116         entrypoint-&gt;cfaHasVisited = false;
<span class="line-modified">117         entrypoint-&gt;cfaThinksShouldTryConstantFolding = false;</span>
118         entrypoint-&gt;cfaStructureClobberStateAtHead = StructuresAreWatched;
119         entrypoint-&gt;cfaStructureClobberStateAtTail = StructuresAreWatched;
120 
121         if (m_graph.m_form == SSA)  {
122             for (size_t i = 0; i &lt; entrypoint-&gt;valuesAtHead.numberOfArguments(); ++i) {
123                 entrypoint-&gt;valuesAtHead.argument(i).clear();
124                 entrypoint-&gt;valuesAtTail.argument(i).clear();
125             }
126         } else {
127             const ArgumentsVector&amp; arguments = m_graph.m_rootToArguments.find(entrypoint)-&gt;value;
128             for (size_t i = 0; i &lt; entrypoint-&gt;valuesAtHead.numberOfArguments(); ++i) {
129                 entrypoint-&gt;valuesAtTail.argument(i).clear();
130 
131                 FlushFormat format;
132                 Node* node = arguments[i];
133                 if (!node)
134                     format = FlushedJSValue;
135                 else {
136                     ASSERT(node-&gt;op() == SetArgumentDefinitely);
137                     format = node-&gt;variableAccessData()-&gt;flushFormat();
</pre>
<hr />
<pre>
155                     break;
156                 }
157             }
158         }
159 
160         for (size_t i = 0; i &lt; entrypoint-&gt;valuesAtHead.numberOfLocals(); ++i) {
161             entrypoint-&gt;valuesAtHead.local(i).clear();
162             entrypoint-&gt;valuesAtTail.local(i).clear();
163         }
164     }
165 
166     for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
167         if (m_graph.isRoot(block)) {
168             // We bootstrapped the CFG roots above.
169             continue;
170         }
171 
172         ASSERT(block-&gt;isReachable);
173         block-&gt;cfaShouldRevisit = false;
174         block-&gt;cfaHasVisited = false;
<span class="line-modified">175         block-&gt;cfaThinksShouldTryConstantFolding = false;</span>
176         block-&gt;cfaStructureClobberStateAtHead = StructuresAreWatched;
177         block-&gt;cfaStructureClobberStateAtTail = StructuresAreWatched;
178         for (size_t i = 0; i &lt; block-&gt;valuesAtHead.numberOfArguments(); ++i) {
179             block-&gt;valuesAtHead.argument(i).clear();
180             block-&gt;valuesAtTail.argument(i).clear();
181         }
182         for (size_t i = 0; i &lt; block-&gt;valuesAtHead.numberOfLocals(); ++i) {
183             block-&gt;valuesAtHead.local(i).clear();
184             block-&gt;valuesAtTail.local(i).clear();
185         }
186     }
187 
188     if (m_graph.m_form == SSA) {
189         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
190             BasicBlock* block = m_graph.block(blockIndex);
191             if (!block)
192                 continue;
193             setLiveValues(block-&gt;ssa-&gt;valuesAtHead, block-&gt;ssa-&gt;liveAtHead);
194             setLiveValues(block-&gt;ssa-&gt;valuesAtTail, block-&gt;ssa-&gt;liveAtTail);
195         }
196     }
197 }
198 
199 bool InPlaceAbstractState::endBasicBlock()
200 {
201     ASSERT(m_block);
202 
203     BasicBlock* block = m_block; // Save the block for successor merging.
204 
<span class="line-modified">205     block-&gt;cfaThinksShouldTryConstantFolding = m_shouldTryConstantFolding;</span>
206     block-&gt;cfaDidFinish = m_isValid;
207     block-&gt;cfaBranchDirection = m_branchDirection;
208 
209     if (!m_isValid) {
210         reset();
211         return false;
212     }
213 
214     AbstractValueClobberEpoch epochAtHead = m_epochAtHead;
215     AbstractValueClobberEpoch currentEpoch = m_effectEpoch;
216 
217     block-&gt;cfaStructureClobberStateAtTail = m_structureClobberState;
218 
219     switch (m_graph.m_form) {
220     case ThreadedCPS: {
221         ASSERT(block-&gt;variablesAtTail.size() == block-&gt;valuesAtTail.size());
222         ASSERT(block-&gt;variablesAtTail.size() == m_variables.size());
223         for (size_t index = m_variables.size(); index--;) {
224             Node* node = block-&gt;variablesAtTail[index];
225             if (!node)
</pre>
</td>
</tr>
</table>
<center><a href="DFGHeapLocation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGInPlaceAbstractState.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
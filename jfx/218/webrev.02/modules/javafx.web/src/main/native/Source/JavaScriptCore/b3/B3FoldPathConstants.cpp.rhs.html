<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3FoldPathConstants.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;B3FoldPathConstants.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;B3BasicBlockInlines.h&quot;
 32 #include &quot;B3CaseCollectionInlines.h&quot;
 33 #include &quot;B3Dominators.h&quot;
 34 #include &quot;B3InsertionSetInlines.h&quot;
 35 #include &quot;B3PhaseScope.h&quot;
 36 #include &quot;B3ProcedureInlines.h&quot;
 37 #include &quot;B3SwitchValue.h&quot;
 38 #include &quot;B3ValueInlines.h&quot;
 39 
 40 namespace JSC { namespace B3 {
 41 
 42 namespace {
 43 
 44 namespace B3FoldPathConstantsInternal {
<a name="2" id="anc2"></a><span class="line-modified"> 45 static constexpr bool verbose = false;</span>
 46 }
 47 
 48 class FoldPathConstants {
 49 public:
 50     FoldPathConstants(Procedure&amp; proc)
 51         : m_proc(proc)
 52         , m_insertionSet(proc)
 53     {
 54     }
 55 
 56     void run()
 57     {
 58         bool changed = false;
 59 
 60         if (B3FoldPathConstantsInternal::verbose)
 61             dataLog(&quot;B3 before folding path constants: \n&quot;, m_proc, &quot;\n&quot;);
 62 
 63         // Find all of the values that are the subject of a branch or switch. For any successor
 64         // that we dominate, install a value override at that block.
 65 
 66         HashMap&lt;Value*, Vector&lt;Override&gt;&gt; overrides;
 67 
 68         Dominators&amp; dominators = m_proc.dominators();
 69 
 70         auto addOverride = [&amp;] (
 71             BasicBlock* from, Value* value, const Override&amp; override) {
 72 
 73             if (override.block-&gt;numPredecessors() != 1)
 74                 return;
 75             ASSERT(override.block-&gt;predecessor(0) == from);
 76 
 77             Vector&lt;Override&gt;&amp; forValue =
 78                 overrides.add(value, Vector&lt;Override&gt;()).iterator-&gt;value;
 79 
<a name="3" id="anc3"></a><span class="line-modified"> 80             if (ASSERT_ENABLED) {</span>
 81                 for (const Override&amp; otherOverride : forValue)
 82                     ASSERT_UNUSED(otherOverride, otherOverride.block != override.block);
 83             }
 84 
 85             if (B3FoldPathConstantsInternal::verbose)
 86                 dataLog(&quot;Overriding &quot;, *value, &quot; from &quot;, *from, &quot;: &quot;, override, &quot;\n&quot;);
 87 
 88             forValue.append(override);
 89         };
 90 
 91         for (BasicBlock* block : m_proc) {
 92             Value* branch = block-&gt;last();
 93             switch (branch-&gt;opcode()) {
 94             case Branch:
 95                 if (block-&gt;successorBlock(0) == block-&gt;successorBlock(1))
 96                     continue;
 97                 addOverride(
 98                     block, branch-&gt;child(0),
 99                     Override::nonZero(block-&gt;successorBlock(0)));
100                 addOverride(
101                     block, branch-&gt;child(0),
102                     Override::constant(block-&gt;successorBlock(1), 0));
103                 break;
104             case Switch: {
105                 SwitchValue* switchValue = branch-&gt;as&lt;SwitchValue&gt;();
106 
107                 HashMap&lt;BasicBlock*, unsigned&gt; targetUses;
108                 for (SwitchCase switchCase : switchValue-&gt;cases(block))
109                     targetUses.add(switchCase.targetBlock(), 0).iterator-&gt;value++;
110                 targetUses.add(switchValue-&gt;fallThrough(block), 0).iterator-&gt;value++;
111 
112                 for (SwitchCase switchCase : switchValue-&gt;cases(block)) {
113                     if (targetUses.find(switchCase.targetBlock())-&gt;value != 1)
114                         continue;
115 
116                     addOverride(
117                         block, branch-&gt;child(0),
118                         Override::constant(switchCase.targetBlock(), switchCase.caseValue()));
119                 }
120                 break;
121             }
122             default:
123                 break;
124             }
125         }
126 
127         // Install the constants in the override blocks. We use one-shot insertion sets because
128         // each block will get at most one thing inserted into it anyway.
129         for (auto&amp; entry : overrides) {
130             for (Override&amp; override : entry.value) {
131                 if (!override.hasValue)
132                     continue;
133                 override.valueNode =
134                     m_insertionSet.insertIntConstant(0, entry.key, override.value);
135                 m_insertionSet.execute(override.block);
136             }
137         }
138 
139         // Replace all uses of a value that has an override with that override, if appropriate.
140         // Certain instructions get special treatment.
141         auto getOverride = [&amp;] (BasicBlock* block, Value* value) -&gt; Override {
142             auto iter = overrides.find(value);
143             if (iter == overrides.end())
144                 return Override();
145 
146             Vector&lt;Override&gt;&amp; forValue = iter-&gt;value;
147             Override result;
148             for (Override&amp; override : forValue) {
149                 if (dominators.dominates(override.block, block)
150                     &amp;&amp; override.isBetterThan(result))
151                     result = override;
152             }
153 
154             if (B3FoldPathConstantsInternal::verbose)
155                 dataLog(&quot;In block &quot;, *block, &quot; getting override for &quot;, *value, &quot;: &quot;, result, &quot;\n&quot;);
156 
157             return result;
158         };
159 
160         for (BasicBlock* block : m_proc) {
161             for (unsigned valueIndex = 0; valueIndex &lt; block-&gt;size(); ++valueIndex) {
162                 Value* value = block-&gt;at(valueIndex);
163 
164                 switch (value-&gt;opcode()) {
165                 case Branch: {
166                     if (getOverride(block, value-&gt;child(0)).isNonZero) {
167                         value-&gt;replaceWithJump(block, block-&gt;taken());
168                         changed = true;
169                     }
170                     break;
171                 }
172 
173                 case Equal: {
174                     if (value-&gt;child(1)-&gt;isInt(0)
175                         &amp;&amp; getOverride(block, value-&gt;child(0)).isNonZero) {
176                         value-&gt;replaceWithIdentity(
177                             m_insertionSet.insertIntConstant(valueIndex, value, 0));
178                     }
179                     break;
180                 }
181 
182                 case NotEqual: {
183                     if (value-&gt;child(1)-&gt;isInt(0)
184                         &amp;&amp; getOverride(block, value-&gt;child(0)).isNonZero) {
185                         value-&gt;replaceWithIdentity(
186                             m_insertionSet.insertIntConstant(valueIndex, value, 1));
187                     }
188                     break;
189                 }
190 
191                 default:
192                     break;
193                 }
194 
195                 for (Value*&amp; child : value-&gt;children()) {
196                     Override override = getOverride(block, child);
197                     if (override.valueNode)
198                         child = override.valueNode;
199                 }
200             }
201             m_insertionSet.execute(block);
202         }
203 
204         if (changed) {
205             m_proc.resetReachability();
206             m_proc.invalidateCFG();
207         }
208     }
209 
210 private:
211     struct Override {
212         Override()
213         {
214         }
215 
216         static Override constant(BasicBlock* block, int64_t value)
217         {
218             Override result;
219             result.block = block;
220             result.hasValue = true;
221             result.value = value;
222             if (value)
223                 result.isNonZero = true;
224             return result;
225         }
226 
227         static Override nonZero(BasicBlock* block)
228         {
229             Override result;
230             result.block = block;
231             result.isNonZero = true;
232             return result;
233         }
234 
235         bool isBetterThan(const Override&amp; override)
236         {
237             if (hasValue &amp;&amp; !override.hasValue)
238                 return true;
239             if (isNonZero &amp;&amp; !override.isNonZero)
240                 return true;
241             return false;
242         }
243 
244         void dump(PrintStream&amp; out) const
245         {
246             out.print(&quot;{block = &quot;, pointerDump(block), &quot;, value = &quot;);
247             if (hasValue)
248                 out.print(value);
249             else
250                 out.print(&quot;&lt;none&gt;&quot;);
251             out.print(&quot;, isNonZero = &quot;, isNonZero);
252             if (valueNode)
253                 out.print(&quot;, valueNode = &quot;, *valueNode);
254             out.print(&quot;}&quot;);
255         }
256 
257         BasicBlock* block { nullptr };
258         bool hasValue { false };
259         bool isNonZero { false };
260         int64_t value { 0 };
261         Value* valueNode { nullptr };
262     };
263 
264     Procedure&amp; m_proc;
265     InsertionSet m_insertionSet;
266 };
267 
268 } // anonymous namespace
269 
270 void foldPathConstants(Procedure&amp; proc)
271 {
272     PhaseScope phaseScope(proc, &quot;foldPathConstants&quot;);
273     FoldPathConstants foldPathConstants(proc);
274     foldPathConstants.run();
275 }
276 
277 } } // namespace JSC::B3
278 
279 #endif // ENABLE(B3_JIT)
280 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
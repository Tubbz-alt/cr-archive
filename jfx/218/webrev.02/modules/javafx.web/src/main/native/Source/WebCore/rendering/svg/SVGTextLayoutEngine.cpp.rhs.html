<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGTextLayoutEngine.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) Research In Motion Limited 2010-2012. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;SVGTextLayoutEngine.h&quot;
 22 
 23 #include &quot;PathTraversalState.h&quot;
 24 #include &quot;RenderSVGTextPath.h&quot;
 25 #include &quot;SVGElement.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 26 #include &quot;SVGGeometryElement.h&quot;</span>
 27 #include &quot;SVGInlineTextBox.h&quot;
 28 #include &quot;SVGLengthContext.h&quot;
 29 #include &quot;SVGTextContentElement.h&quot;
 30 #include &quot;SVGTextLayoutEngineBaseline.h&quot;
 31 #include &quot;SVGTextLayoutEngineSpacing.h&quot;
 32 
 33 // Set to a value &gt; 0 to dump the text fragments
 34 #define DUMP_TEXT_FRAGMENTS 0
 35 
 36 namespace WebCore {
 37 
 38 SVGTextLayoutEngine::SVGTextLayoutEngine(Vector&lt;SVGTextLayoutAttributes*&gt;&amp; layoutAttributes)
 39     : m_layoutAttributes(layoutAttributes)
 40     , m_layoutAttributesPosition(0)
 41     , m_logicalCharacterOffset(0)
 42     , m_logicalMetricsListOffset(0)
 43     , m_visualCharacterOffset(0)
 44     , m_visualMetricsListOffset(0)
 45     , m_x(0)
 46     , m_y(0)
 47     , m_dx(0)
 48     , m_dy(0)
 49     , m_isVerticalText(false)
 50     , m_inPathLayout(false)
 51     , m_textPathLength(0)
 52     , m_textPathCurrentOffset(0)
 53     , m_textPathSpacing(0)
 54     , m_textPathScaling(1)
 55 {
 56     ASSERT(!m_layoutAttributes.isEmpty());
 57 }
 58 
 59 void SVGTextLayoutEngine::updateCharacerPositionIfNeeded(float&amp; x, float&amp; y)
 60 {
 61     if (m_inPathLayout)
 62         return;
 63 
 64     // Replace characters x/y position, with the current text position plus any
 65     // relative adjustments, if it doesn&#39;t specify an absolute position itself.
 66     if (x == SVGTextLayoutAttributes::emptyValue())
 67         x = m_x + m_dx;
 68 
 69     if (y == SVGTextLayoutAttributes::emptyValue())
 70         y = m_y + m_dy;
 71 
 72     m_dx = 0;
 73     m_dy = 0;
 74 }
 75 
 76 void SVGTextLayoutEngine::updateCurrentTextPosition(float x, float y, float glyphAdvance)
 77 {
 78     // Update current text position after processing the character.
 79     if (m_isVerticalText) {
 80         m_x = x;
 81         m_y = y + glyphAdvance;
 82     } else {
 83         m_x = x + glyphAdvance;
 84         m_y = y;
 85     }
 86 }
 87 
 88 void SVGTextLayoutEngine::updateRelativePositionAdjustmentsIfNeeded(float dx, float dy)
 89 {
 90     // Update relative positioning information.
 91     if (dx == SVGTextLayoutAttributes::emptyValue() &amp;&amp; dy == SVGTextLayoutAttributes::emptyValue())
 92         return;
 93 
 94     if (dx == SVGTextLayoutAttributes::emptyValue())
 95         dx = 0;
 96     if (dy == SVGTextLayoutAttributes::emptyValue())
 97         dy = 0;
 98 
 99     if (m_inPathLayout) {
100         if (m_isVerticalText) {
101             m_dx += dx;
102             m_dy = dy;
103         } else {
104             m_dx = dx;
105             m_dy += dy;
106         }
107 
108         return;
109     }
110 
111     m_dx = dx;
112     m_dy = dy;
113 }
114 
115 void SVGTextLayoutEngine::recordTextFragment(SVGInlineTextBox&amp; textBox, Vector&lt;SVGTextMetrics&gt;&amp; textMetricsValues)
116 {
117     ASSERT(!m_currentTextFragment.length);
118     ASSERT(m_visualMetricsListOffset &gt; 0);
119 
120     // Figure out length of fragment.
121     m_currentTextFragment.length = m_visualCharacterOffset - m_currentTextFragment.characterOffset;
122 
123     // Figure out fragment metrics.
124     SVGTextMetrics&amp; lastCharacterMetrics = textMetricsValues.at(m_visualMetricsListOffset - 1);
125     m_currentTextFragment.width = lastCharacterMetrics.width();
126     m_currentTextFragment.height = lastCharacterMetrics.height();
127 
128     if (m_currentTextFragment.length &gt; 1) {
129         // SVGTextLayoutAttributesBuilder assures that the length of the range is equal to the sum of the individual lengths of the glyphs.
130         float length = 0;
131         if (m_isVerticalText) {
132             for (unsigned i = m_currentTextFragment.metricsListOffset; i &lt; m_visualMetricsListOffset; ++i)
133                 length += textMetricsValues.at(i).height();
134             m_currentTextFragment.height = length;
135         } else {
136             for (unsigned i = m_currentTextFragment.metricsListOffset; i &lt; m_visualMetricsListOffset; ++i)
137                 length += textMetricsValues.at(i).width();
138             m_currentTextFragment.width = length;
139         }
140     }
141 
142     textBox.textFragments().append(m_currentTextFragment);
143     m_currentTextFragment = SVGTextFragment();
144 }
145 
146 bool SVGTextLayoutEngine::parentDefinesTextLength(RenderObject* parent) const
147 {
148     RenderObject* currentParent = parent;
149     while (currentParent) {
150         if (SVGTextContentElement* textContentElement = SVGTextContentElement::elementFromRenderer(currentParent)) {
151             SVGLengthContext lengthContext(textContentElement);
152             if (textContentElement-&gt;lengthAdjust() == SVGLengthAdjustSpacing &amp;&amp; textContentElement-&gt;specifiedTextLength().value(lengthContext) &gt; 0)
153                 return true;
154         }
155 
156         if (currentParent-&gt;isSVGText())
157             return false;
158 
159         currentParent = currentParent-&gt;parent();
160     }
161 
162     ASSERT_NOT_REACHED();
163     return false;
164 }
165 
166 void SVGTextLayoutEngine::beginTextPathLayout(RenderSVGTextPath&amp; textPath, SVGTextLayoutEngine&amp; lineLayout)
167 {
168     m_inPathLayout = true;
169 
170     m_textPath = textPath.layoutPath();
171     if (m_textPath.isEmpty())
172         return;
173 
<a name="2" id="anc2"></a><span class="line-modified">174     const auto&amp; startOffset = textPath.startOffset();</span>
175     m_textPathLength = m_textPath.length();
<a name="3" id="anc3"></a><span class="line-modified">176 </span>
<span class="line-modified">177     if (textPath.startOffset().lengthType() == SVGLengthType::Percentage)</span>
<span class="line-added">178         m_textPathStartOffset = startOffset.valueAsPercentage() * m_textPathLength;</span>
<span class="line-added">179     else {</span>
<span class="line-added">180         m_textPathStartOffset = startOffset.valueInSpecifiedUnits();</span>
<span class="line-added">181         if (auto* tragetElement = textPath.targetElement()) {</span>
<span class="line-added">182             // FIXME: A value of zero is valid. Need to differentiate this case from being unspecified.</span>
<span class="line-added">183             if (float pathLength = tragetElement-&gt;pathLength())</span>
<span class="line-added">184                 m_textPathStartOffset *= m_textPathLength / pathLength;</span>
<span class="line-added">185         }</span>
<span class="line-added">186     }</span>
187 
188     lineLayout.m_chunkLayoutBuilder.buildTextChunks(lineLayout.m_lineLayoutBoxes);
189 
190     // Handle text-anchor as additional start offset for text paths.
191     m_textPathStartOffset += lineLayout.m_chunkLayoutBuilder.totalAnchorShift();
192     m_textPathCurrentOffset = m_textPathStartOffset;
193 
194     // Eventually handle textLength adjustments.
195     auto* textContentElement = SVGTextContentElement::elementFromRenderer(&amp;textPath);
196     if (!textContentElement)
197         return;
198 
199     SVGLengthContext lengthContext(textContentElement);
200     float desiredTextLength = textContentElement-&gt;specifiedTextLength().value(lengthContext);
201     if (!desiredTextLength)
202         return;
203 
204     float totalLength = lineLayout.m_chunkLayoutBuilder.totalLength();
205     unsigned totalCharacters = lineLayout.m_chunkLayoutBuilder.totalCharacters();
206 
207     if (textContentElement-&gt;lengthAdjust() == SVGLengthAdjustSpacing)
208         m_textPathSpacing = (desiredTextLength - totalLength) / totalCharacters;
209     else
210         m_textPathScaling = desiredTextLength / totalLength;
211 }
212 
213 void SVGTextLayoutEngine::endTextPathLayout()
214 {
215     m_inPathLayout = false;
216     m_textPath = Path();
217     m_textPathLength = 0;
218     m_textPathStartOffset = 0;
219     m_textPathCurrentOffset = 0;
220     m_textPathSpacing = 0;
221     m_textPathScaling = 1;
222 }
223 
224 void SVGTextLayoutEngine::layoutInlineTextBox(SVGInlineTextBox&amp; textBox)
225 {
226     RenderSVGInlineText&amp; text = textBox.renderer();
227     ASSERT(text.parent());
228     ASSERT(text.parent()-&gt;element());
229     ASSERT(text.parent()-&gt;element()-&gt;isSVGElement());
230 
231     const RenderStyle&amp; style = text.style();
232 
233     textBox.clearTextFragments();
234     m_isVerticalText = style.isVerticalWritingMode();
235     layoutTextOnLineOrPath(textBox, text, style);
236 
237     if (m_inPathLayout) {
238         m_pathLayoutBoxes.append(&amp;textBox);
239         return;
240     }
241 
242     m_lineLayoutBoxes.append(&amp;textBox);
243 }
244 
245 #if DUMP_TEXT_FRAGMENTS &gt; 0
246 static inline void dumpTextBoxes(Vector&lt;SVGInlineTextBox*&gt;&amp; boxes)
247 {
248     unsigned boxCount = boxes.size();
249     fprintf(stderr, &quot;Dumping all text fragments in text sub tree, %i boxes\n&quot;, boxCount);
250 
251     for (unsigned boxPosition = 0; boxPosition &lt; boxCount; ++boxPosition) {
252         SVGInlineTextBox* textBox = boxes.at(boxPosition);
253         Vector&lt;SVGTextFragment&gt;&amp; fragments = textBox-&gt;textFragments();
254         fprintf(stderr, &quot;-&gt; Box %i: Dumping text fragments for SVGInlineTextBox, textBox=%p, textRenderer=%p\n&quot;, boxPosition, textBox, textBox-&gt;renderer());
255         fprintf(stderr, &quot;        textBox properties, start=%i, len=%i, box direction=%i\n&quot;, textBox-&gt;start(), textBox-&gt;len(), textBox-&gt;direction());
256         fprintf(stderr, &quot;   textRenderer properties, textLength=%i\n&quot;, textBox-&gt;renderer()-&gt;textLength());
257 
258         const UChar* characters = textBox-&gt;renderer()-&gt;characters();
259 
260         unsigned fragmentCount = fragments.size();
261         for (unsigned i = 0; i &lt; fragmentCount; ++i) {
262             SVGTextFragment&amp; fragment = fragments.at(i);
263             String fragmentString(characters + fragment.characterOffset, fragment.length);
264             fprintf(stderr, &quot;    -&gt; Fragment %i, x=%lf, y=%lf, width=%lf, height=%lf, characterOffset=%i, length=%i, characters=&#39;%s&#39;\n&quot;
265                           , i, fragment.x, fragment.y, fragment.width, fragment.height, fragment.characterOffset, fragment.length, fragmentString.utf8().data());
266         }
267     }
268 }
269 #endif
270 
271 void SVGTextLayoutEngine::finalizeTransformMatrices(Vector&lt;SVGInlineTextBox*&gt;&amp; boxes)
272 {
273     unsigned boxCount = boxes.size();
274     if (!boxCount)
275         return;
276 
277     AffineTransform textBoxTransformation;
278     for (unsigned boxPosition = 0; boxPosition &lt; boxCount; ++boxPosition) {
279         SVGInlineTextBox* textBox = boxes.at(boxPosition);
280         Vector&lt;SVGTextFragment&gt;&amp; fragments = textBox-&gt;textFragments();
281 
282         unsigned fragmentCount = fragments.size();
283         for (unsigned i = 0; i &lt; fragmentCount; ++i) {
284             textBoxTransformation = m_chunkLayoutBuilder.transformationForTextBox(textBox);
285             if (textBoxTransformation.isIdentity())
286                 continue;
287             ASSERT(fragments[i].lengthAdjustTransform.isIdentity());
288             fragments[i].lengthAdjustTransform = textBoxTransformation;
289         }
290     }
291 
292     boxes.clear();
293 }
294 
295 void SVGTextLayoutEngine::finishLayout()
296 {
297     // After all text fragments are stored in their correpsonding SVGInlineTextBoxes, we can layout individual text chunks.
298     // Chunk layouting is only performed for line layout boxes, not for path layout, where it has already been done.
299     m_chunkLayoutBuilder.layoutTextChunks(m_lineLayoutBoxes);
300 
301     // Finalize transform matrices, after the chunk layout corrections have been applied, and all fragment x/y positions are finalized.
302     if (!m_lineLayoutBoxes.isEmpty()) {
303 #if DUMP_TEXT_FRAGMENTS &gt; 0
304         fprintf(stderr, &quot;Line layout: &quot;);
305         dumpTextBoxes(m_lineLayoutBoxes);
306 #endif
307 
308         finalizeTransformMatrices(m_lineLayoutBoxes);
309     }
310 
311     if (!m_pathLayoutBoxes.isEmpty()) {
312 #if DUMP_TEXT_FRAGMENTS &gt; 0
313         fprintf(stderr, &quot;Path layout: &quot;);
314         dumpTextBoxes(m_pathLayoutBoxes);
315 #endif
316 
317         finalizeTransformMatrices(m_pathLayoutBoxes);
318     }
319 }
320 
321 bool SVGTextLayoutEngine::currentLogicalCharacterAttributes(SVGTextLayoutAttributes*&amp; logicalAttributes)
322 {
323     if (m_layoutAttributesPosition == m_layoutAttributes.size())
324         return false;
325 
326     logicalAttributes = m_layoutAttributes[m_layoutAttributesPosition];
327     ASSERT(logicalAttributes);
328 
329     if (m_logicalCharacterOffset != logicalAttributes-&gt;context().text().length())
330         return true;
331 
332     ++m_layoutAttributesPosition;
333     if (m_layoutAttributesPosition == m_layoutAttributes.size())
334         return false;
335 
336     logicalAttributes = m_layoutAttributes[m_layoutAttributesPosition];
337     m_logicalMetricsListOffset = 0;
338     m_logicalCharacterOffset = 0;
339     return true;
340 }
341 
342 bool SVGTextLayoutEngine::currentLogicalCharacterMetrics(SVGTextLayoutAttributes*&amp; logicalAttributes, SVGTextMetrics&amp; logicalMetrics)
343 {
344     Vector&lt;SVGTextMetrics&gt;* textMetricsValues = &amp;logicalAttributes-&gt;textMetricsValues();
345     unsigned textMetricsSize = textMetricsValues-&gt;size();
346     while (true) {
347         if (m_logicalMetricsListOffset == textMetricsSize) {
348             if (!currentLogicalCharacterAttributes(logicalAttributes))
349                 return false;
350 
351             textMetricsValues = &amp;logicalAttributes-&gt;textMetricsValues();
352             textMetricsSize = textMetricsValues-&gt;size();
353             continue;
354         }
355 
356         ASSERT(textMetricsSize);
357         ASSERT_WITH_SECURITY_IMPLICATION(m_logicalMetricsListOffset &lt; textMetricsSize);
358         logicalMetrics = textMetricsValues-&gt;at(m_logicalMetricsListOffset);
359         if (logicalMetrics.isEmpty() || (!logicalMetrics.width() &amp;&amp; !logicalMetrics.height())) {
360             advanceToNextLogicalCharacter(logicalMetrics);
361             continue;
362         }
363 
364         // Stop if we found the next valid logical text metrics object.
365         return true;
366     }
367 
368     ASSERT_NOT_REACHED();
369     return true;
370 }
371 
372 bool SVGTextLayoutEngine::currentVisualCharacterMetrics(const SVGInlineTextBox&amp; textBox, Vector&lt;SVGTextMetrics&gt;&amp; visualMetricsValues, SVGTextMetrics&amp; visualMetrics)
373 {
374     ASSERT(!visualMetricsValues.isEmpty());
375     unsigned textMetricsSize = visualMetricsValues.size();
376     unsigned boxStart = textBox.start();
377     unsigned boxLength = textBox.len();
378 
379     if (m_visualMetricsListOffset == textMetricsSize)
380         return false;
381 
382     while (m_visualMetricsListOffset &lt; textMetricsSize) {
383         // Advance to text box start location.
384         if (m_visualCharacterOffset &lt; boxStart) {
385             advanceToNextVisualCharacter(visualMetricsValues[m_visualMetricsListOffset]);
386             continue;
387         }
388 
389         // Stop if we&#39;ve finished processing this text box.
390         if (m_visualCharacterOffset &gt;= boxStart + boxLength)
391             return false;
392 
393         visualMetrics = visualMetricsValues[m_visualMetricsListOffset];
394         return true;
395     }
396 
397     return false;
398 }
399 
400 void SVGTextLayoutEngine::advanceToNextLogicalCharacter(const SVGTextMetrics&amp; logicalMetrics)
401 {
402     ++m_logicalMetricsListOffset;
403     m_logicalCharacterOffset += logicalMetrics.length();
404 }
405 
406 void SVGTextLayoutEngine::advanceToNextVisualCharacter(const SVGTextMetrics&amp; visualMetrics)
407 {
408     ++m_visualMetricsListOffset;
409     m_visualCharacterOffset += visualMetrics.length();
410 }
411 
412 void SVGTextLayoutEngine::layoutTextOnLineOrPath(SVGInlineTextBox&amp; textBox, RenderSVGInlineText&amp; text, const RenderStyle&amp; style)
413 {
414     if (m_inPathLayout &amp;&amp; m_textPath.isEmpty())
415         return;
416 
417     RenderElement* textParent = text.parent();
418     ASSERT(textParent);
419     SVGElement* lengthContext = downcast&lt;SVGElement&gt;(textParent-&gt;element());
420 
421     bool definesTextLength = parentDefinesTextLength(textParent);
422 
423     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
424 
425     m_visualMetricsListOffset = 0;
426     m_visualCharacterOffset = 0;
427 
428     Vector&lt;SVGTextMetrics&gt;&amp; visualMetricsValues = text.layoutAttributes()-&gt;textMetricsValues();
429     ASSERT(!visualMetricsValues.isEmpty());
430 
431     auto upconvertedCharacters = StringView(text.text()).upconvertedCharacters();
432     const UChar* characters = upconvertedCharacters;
433     const FontCascade&amp; font = style.fontCascade();
434 
435     SVGTextLayoutEngineSpacing spacingLayout(font);
436     SVGTextLayoutEngineBaseline baselineLayout(font);
437 
438     bool didStartTextFragment = false;
439     bool applySpacingToNextCharacter = false;
440 
441     float lastAngle = 0;
442     float baselineShift = baselineLayout.calculateBaselineShift(svgStyle, lengthContext);
443     baselineShift -= baselineLayout.calculateAlignmentBaselineShift(m_isVerticalText, text);
444 
445     // Main layout algorithm.
446     while (true) {
447         // Find the start of the current text box in this list, respecting ligatures.
448         SVGTextMetrics visualMetrics(SVGTextMetrics::SkippedSpaceMetrics);
449         if (!currentVisualCharacterMetrics(textBox, visualMetricsValues, visualMetrics))
450             break;
451 
452         if (visualMetrics.isEmpty()) {
453             advanceToNextVisualCharacter(visualMetrics);
454             continue;
455         }
456 
457         SVGTextLayoutAttributes* logicalAttributes = 0;
458         if (!currentLogicalCharacterAttributes(logicalAttributes))
459             break;
460 
461         ASSERT(logicalAttributes);
462         SVGTextMetrics logicalMetrics(SVGTextMetrics::SkippedSpaceMetrics);
463         if (!currentLogicalCharacterMetrics(logicalAttributes, logicalMetrics))
464             break;
465 
466         SVGCharacterDataMap&amp; characterDataMap = logicalAttributes-&gt;characterDataMap();
467         SVGCharacterData data;
468         SVGCharacterDataMap::iterator it = characterDataMap.find(m_logicalCharacterOffset + 1);
469         if (it != characterDataMap.end())
470             data = it-&gt;value;
471 
472         float x = data.x;
473         float y = data.y;
474 
475         // When we&#39;ve advanced to the box start offset, determine using the original x/y values
476         // whether this character starts a new text chunk before doing any further processing.
477         if (m_visualCharacterOffset == textBox.start())
478             textBox.setStartsNewTextChunk(logicalAttributes-&gt;context().characterStartsNewTextChunk(m_logicalCharacterOffset));
479 
480         float angle = data.rotate == SVGTextLayoutAttributes::emptyValue() ? 0 : data.rotate;
481 
482         // Calculate glyph orientation angle.
483         const UChar* currentCharacter = characters + m_visualCharacterOffset;
484         float orientationAngle = baselineLayout.calculateGlyphOrientationAngle(m_isVerticalText, svgStyle, *currentCharacter);
485 
486         // Calculate glyph advance &amp; x/y orientation shifts.
487         float xOrientationShift = 0;
488         float yOrientationShift = 0;
489         float glyphAdvance = baselineLayout.calculateGlyphAdvanceAndOrientation(m_isVerticalText, visualMetrics, orientationAngle, xOrientationShift, yOrientationShift);
490 
491         // Assign current text position to x/y values, if needed.
492         updateCharacerPositionIfNeeded(x, y);
493 
494         // Apply dx/dy value adjustments to current text position, if needed.
495         updateRelativePositionAdjustmentsIfNeeded(data.dx, data.dy);
496 
497         // Calculate CSS &#39;kerning&#39;, &#39;letter-spacing&#39; and &#39;word-spacing&#39; for next character, if needed.
498         float spacing = spacingLayout.calculateCSSKerningAndSpacing(&amp;svgStyle, lengthContext, currentCharacter);
499 
500         float textPathOffset = 0;
501         if (m_inPathLayout) {
502             float scaledGlyphAdvance = glyphAdvance * m_textPathScaling;
503             if (m_isVerticalText) {
504                 // If there&#39;s an absolute y position available, it marks the beginning of a new position along the path.
505                 if (y != SVGTextLayoutAttributes::emptyValue())
506                     m_textPathCurrentOffset = y + m_textPathStartOffset;
507 
508                 m_textPathCurrentOffset += m_dy;
509                 m_dy = 0;
510 
511                 // Apply dx/dy correction and setup translations that move to the glyph midpoint.
512                 xOrientationShift += m_dx + baselineShift;
513                 yOrientationShift -= scaledGlyphAdvance / 2;
514             } else {
515                 // If there&#39;s an absolute x position available, it marks the beginning of a new position along the path.
516                 if (x != SVGTextLayoutAttributes::emptyValue())
517                     m_textPathCurrentOffset = x + m_textPathStartOffset;
518 
519                 m_textPathCurrentOffset += m_dx;
520                 m_dx = 0;
521 
522                 // Apply dx/dy correction and setup translations that move to the glyph midpoint.
523                 xOrientationShift -= scaledGlyphAdvance / 2;
524                 yOrientationShift += m_dy - baselineShift;
525             }
526 
527             // Calculate current offset along path.
528             textPathOffset = m_textPathCurrentOffset + scaledGlyphAdvance / 2;
529 
530             // Move to next character.
531             m_textPathCurrentOffset += scaledGlyphAdvance + m_textPathSpacing + spacing * m_textPathScaling;
532 
533             // Skip character, if we&#39;re before the path.
534             if (textPathOffset &lt; 0) {
535                 advanceToNextLogicalCharacter(logicalMetrics);
536                 advanceToNextVisualCharacter(visualMetrics);
537                 continue;
538             }
539 
540             // Stop processing, if the next character lies behind the path.
541             if (textPathOffset &gt; m_textPathLength)
542                 break;
543 
<a name="4" id="anc4"></a><span class="line-modified">544             auto traversalState(m_textPath.traversalStateAtLength(textPathOffset));</span>
<span class="line-modified">545             ASSERT(traversalState.success());</span>

546 
547             FloatPoint point = traversalState.current();
548             x = point.x();
549             y = point.y();
550 
551             angle = traversalState.normalAngle();
552 
553             // For vertical text on path, the actual angle has to be rotated 90 degrees anti-clockwise, not the orientation angle!
554             if (m_isVerticalText)
555                 angle -= 90;
556         } else {
557             // Apply all previously calculated shift values.
558             if (m_isVerticalText)
559                 x += baselineShift;
560             else
561                 y -= baselineShift;
562 
563             x += m_dx;
564             y += m_dy;
565         }
566 
567         // Determine whether we have to start a new fragment.
568         bool shouldStartNewFragment = m_dx || m_dy || m_isVerticalText || m_inPathLayout || angle || angle != lastAngle
569             || orientationAngle || applySpacingToNextCharacter || definesTextLength;
570 
571         // If we already started a fragment, close it now.
572         if (didStartTextFragment &amp;&amp; shouldStartNewFragment) {
573             applySpacingToNextCharacter = false;
574             recordTextFragment(textBox, visualMetricsValues);
575         }
576 
577         // Eventually start a new fragment, if not yet done.
578         if (!didStartTextFragment || shouldStartNewFragment) {
579             ASSERT(!m_currentTextFragment.characterOffset);
580             ASSERT(!m_currentTextFragment.length);
581 
582             didStartTextFragment = true;
583             m_currentTextFragment.characterOffset = m_visualCharacterOffset;
584             m_currentTextFragment.metricsListOffset = m_visualMetricsListOffset;
585             m_currentTextFragment.x = x;
586             m_currentTextFragment.y = y;
587 
588             // Build fragment transformation.
589             if (angle)
590                 m_currentTextFragment.transform.rotate(angle);
591 
592             if (xOrientationShift || yOrientationShift)
593                 m_currentTextFragment.transform.translate(xOrientationShift, yOrientationShift);
594 
595             if (orientationAngle)
596                 m_currentTextFragment.transform.rotate(orientationAngle);
597 
598             m_currentTextFragment.isTextOnPath = m_inPathLayout &amp;&amp; m_textPathScaling != 1;
599             if (m_currentTextFragment.isTextOnPath) {
600                 if (m_isVerticalText)
601                     m_currentTextFragment.lengthAdjustTransform.scaleNonUniform(1, m_textPathScaling);
602                 else
603                     m_currentTextFragment.lengthAdjustTransform.scaleNonUniform(m_textPathScaling, 1);
604             }
605         }
606 
607         // Update current text position, after processing of the current character finished.
608         if (m_inPathLayout)
609             updateCurrentTextPosition(x, y, glyphAdvance);
610         else {
611             // Apply CSS &#39;kerning&#39;, &#39;letter-spacing&#39; and &#39;word-spacing&#39; to next character, if needed.
612             if (spacing)
613                 applySpacingToNextCharacter = true;
614 
615             float xNew = x - m_dx;
616             float yNew = y - m_dy;
617 
618             if (m_isVerticalText)
619                 xNew -= baselineShift;
620             else
621                 yNew += baselineShift;
622 
623             updateCurrentTextPosition(xNew, yNew, glyphAdvance + spacing);
624         }
625 
626         advanceToNextLogicalCharacter(logicalMetrics);
627         advanceToNextVisualCharacter(visualMetrics);
628         lastAngle = angle;
629     }
630 
631     if (!didStartTextFragment)
632         return;
633 
634     // Close last open fragment, if needed.
635     recordTextFragment(textBox, visualMetricsValues);
636 }
637 
638 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
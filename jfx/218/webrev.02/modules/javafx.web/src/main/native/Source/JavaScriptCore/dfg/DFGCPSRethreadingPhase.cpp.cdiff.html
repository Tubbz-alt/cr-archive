<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCPSRethreadingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCFGSimplificationPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCSEPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCPSRethreadingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 52,12 ***</span>
          clearIsLoadedFrom();
          freeUnnecessaryNodes();
          m_graph.clearReplacements();
          canonicalizeLocalsInBlocks();
          specialCaseArguments();
<span class="line-modified">!         propagatePhis&lt;LocalOperand&gt;();</span>
<span class="line-modified">!         propagatePhis&lt;ArgumentOperand&gt;();</span>
          computeIsFlushed();
  
          m_graph.m_form = ThreadedCPS;
          return true;
      }
<span class="line-new-header">--- 52,13 ---</span>
          clearIsLoadedFrom();
          freeUnnecessaryNodes();
          m_graph.clearReplacements();
          canonicalizeLocalsInBlocks();
          specialCaseArguments();
<span class="line-modified">!         propagatePhis&lt;OperandKind::Local&gt;();</span>
<span class="line-modified">!         propagatePhis&lt;OperandKind::Argument&gt;();</span>
<span class="line-added">+         propagatePhis&lt;OperandKind::Tmp&gt;();</span>
          computeIsFlushed();
  
          m_graph.m_form = ThreadedCPS;
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,14 ***</span>
      }
  
      void canonicalizeGetLocal(Node* node)
      {
          VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!         if (variable-&gt;local().isArgument())</span>
<span class="line-modified">!             canonicalizeGetLocalFor&lt;ArgumentOperand&gt;(node, variable, variable-&gt;local().toArgument());</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             canonicalizeGetLocalFor&lt;LocalOperand&gt;(node, variable, variable-&gt;local().toLocal());</span>
      }
  
      template&lt;NodeType nodeType, OperandKind operandKind&gt;
      void canonicalizeFlushOrPhantomLocalFor(Node* node, VariableAccessData* variable, size_t idx)
      {
<span class="line-new-header">--- 210,24 ---</span>
      }
  
      void canonicalizeGetLocal(Node* node)
      {
          VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!         switch (variable-&gt;operand().kind()) {</span>
<span class="line-modified">!         case OperandKind::Argument: {</span>
<span class="line-modified">!             canonicalizeGetLocalFor&lt;OperandKind::Argument&gt;(node, variable, variable-&gt;operand().toArgument());</span>
<span class="line-modified">!             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case OperandKind::Local: {</span>
<span class="line-added">+             canonicalizeGetLocalFor&lt;OperandKind::Local&gt;(node, variable, variable-&gt;operand().toLocal());</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case OperandKind::Tmp: {</span>
<span class="line-added">+             canonicalizeGetLocalFor&lt;OperandKind::Tmp&gt;(node, variable, variable-&gt;operand().value());</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         }</span>
      }
  
      template&lt;NodeType nodeType, OperandKind operandKind&gt;
      void canonicalizeFlushOrPhantomLocalFor(Node* node, VariableAccessData* variable, size_t idx)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,10 ***</span>
<span class="line-new-header">--- 238,11 ---</span>
  
              switch (otherNode-&gt;op()) {
              case Flush:
              case PhantomLocal:
              case GetLocal:
<span class="line-added">+                 ASSERT(otherNode-&gt;child1().node());</span>
                  otherNode = otherNode-&gt;child1().node();
                  break;
              default:
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,29 ***</span>
  
      template&lt;NodeType nodeType&gt;
      void canonicalizeFlushOrPhantomLocal(Node* node)
      {
          VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!         if (variable-&gt;local().isArgument())</span>
<span class="line-modified">!             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, ArgumentOperand&gt;(node, variable, variable-&gt;local().toArgument());</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, LocalOperand&gt;(node, variable, variable-&gt;local().toLocal());</span>
      }
  
      void canonicalizeSet(Node* node)
      {
<span class="line-modified">!         m_block-&gt;variablesAtTail.setOperand(node-&gt;local(), node);</span>
      }
  
      void canonicalizeLocalsInBlock()
      {
          if (!m_block)
              return;
          ASSERT(m_block-&gt;isReachable);
  
<span class="line-modified">!         clearVariables&lt;ArgumentOperand&gt;();</span>
<span class="line-modified">!         clearVariables&lt;LocalOperand&gt;();</span>
  
          // Assumes that all phi references have been removed. Assumes that things that
          // should be live have a non-zero ref count, but doesn&#39;t assume that the ref
          // counts are correct beyond that (more formally !!logicalRefCount == !!actualRefCount
          // but not logicalRefCount == actualRefCount). Assumes that it can break ref
<span class="line-new-header">--- 280,40 ---</span>
  
      template&lt;NodeType nodeType&gt;
      void canonicalizeFlushOrPhantomLocal(Node* node)
      {
          VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!         switch (variable-&gt;operand().kind()) {</span>
<span class="line-modified">!         case OperandKind::Argument: {</span>
<span class="line-modified">!             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Argument&gt;(node, variable, variable-&gt;operand().toArgument());</span>
<span class="line-modified">!             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case OperandKind::Local: {</span>
<span class="line-added">+             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Local&gt;(node, variable, variable-&gt;operand().toLocal());</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case OperandKind::Tmp: {</span>
<span class="line-added">+             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Tmp&gt;(node, variable, variable-&gt;operand().value());</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         }</span>
      }
  
      void canonicalizeSet(Node* node)
      {
<span class="line-modified">!         m_block-&gt;variablesAtTail.setOperand(node-&gt;operand(), node);</span>
      }
  
      void canonicalizeLocalsInBlock()
      {
          if (!m_block)
              return;
          ASSERT(m_block-&gt;isReachable);
  
<span class="line-modified">!         clearVariables&lt;OperandKind::Argument&gt;();</span>
<span class="line-modified">!         clearVariables&lt;OperandKind::Local&gt;();</span>
<span class="line-added">+         clearVariables&lt;OperandKind::Tmp&gt;();</span>
  
          // Assumes that all phi references have been removed. Assumes that things that
          // should be live have a non-zero ref count, but doesn&#39;t assume that the ref
          // counts are correct beyond that (more formally !!logicalRefCount == !!actualRefCount
          // but not logicalRefCount == actualRefCount). Assumes that it can break ref
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,11 ***</span>
      }
  
      template&lt;OperandKind operandKind&gt;
      void propagatePhis()
      {
<span class="line-modified">!         Vector&lt;PhiStackEntry, 128&gt;&amp; phiStack = operandKind == ArgumentOperand ? m_argumentPhiStack : m_localPhiStack;</span>
  
          // Ensure that attempts to use this fail instantly.
          m_block = 0;
  
          while (!phiStack.isEmpty()) {
<span class="line-new-header">--- 409,11 ---</span>
      }
  
      template&lt;OperandKind operandKind&gt;
      void propagatePhis()
      {
<span class="line-modified">!         Vector&lt;PhiStackEntry, 128&gt;&amp; phiStack = phiStackFor&lt;operandKind&gt;();</span>
  
          // Ensure that attempts to use this fail instantly.
          m_block = 0;
  
          while (!phiStack.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,13 ***</span>
      };
  
      template&lt;OperandKind operandKind&gt;
      Vector&lt;PhiStackEntry, 128&gt;&amp; phiStackFor()
      {
<span class="line-modified">!         if (operandKind == ArgumentOperand)</span>
<span class="line-modified">!             return m_argumentPhiStack;</span>
<span class="line-modified">!         return m_localPhiStack;</span>
      }
  
      void computeIsFlushed()
      {
          m_graph.clearFlagsOnAllNodes(NodeIsFlushed);
<span class="line-new-header">--- 487,16 ---</span>
      };
  
      template&lt;OperandKind operandKind&gt;
      Vector&lt;PhiStackEntry, 128&gt;&amp; phiStackFor()
      {
<span class="line-modified">!         switch (operandKind) {</span>
<span class="line-modified">!         case OperandKind::Argument: return m_argumentPhiStack;</span>
<span class="line-modified">!         case OperandKind::Local: return m_localPhiStack;</span>
<span class="line-added">+         case OperandKind::Tmp: return m_tmpPhiStack;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
      }
  
      void computeIsFlushed()
      {
          m_graph.clearFlagsOnAllNodes(NodeIsFlushed);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,10 ***</span>
<span class="line-new-header">--- 545,11 ---</span>
      }
  
      BasicBlock* m_block;
      Vector&lt;PhiStackEntry, 128&gt; m_argumentPhiStack;
      Vector&lt;PhiStackEntry, 128&gt; m_localPhiStack;
<span class="line-added">+     Vector&lt;PhiStackEntry, 128&gt; m_tmpPhiStack;</span>
      Vector&lt;Node*, 128&gt; m_flushedLocalOpWorklist;
  };
  
  bool performCPSRethreading(Graph&amp; graph)
  {
</pre>
<center><a href="DFGCFGSimplificationPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCSEPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
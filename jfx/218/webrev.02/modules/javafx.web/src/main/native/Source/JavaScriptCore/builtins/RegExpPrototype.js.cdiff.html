<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/RegExpPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PromisePrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpStringIteratorPrototype.js.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/RegExpPrototype.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,15 ***</span>
          return index + 1;
  
      if (index + 1 &gt;= string.length)
          return index + 1;
  
<span class="line-modified">!     let first = string.@charCodeAt(index);</span>
      if (first &lt; 0xD800 || first &gt; 0xDBFF)
          return index + 1;
  
<span class="line-modified">!     let second = string.@charCodeAt(index + 1);</span>
      if (second &lt; 0xDC00 || second &gt; 0xDFFF)
          return index + 1;
  
      return index + 2;
  }
<span class="line-new-header">--- 46,15 ---</span>
          return index + 1;
  
      if (index + 1 &gt;= string.length)
          return index + 1;
  
<span class="line-modified">!     var first = string.@charCodeAt(index);</span>
      if (first &lt; 0xD800 || first &gt; 0xDBFF)
          return index + 1;
  
<span class="line-modified">!     var second = string.@charCodeAt(index + 1);</span>
      if (second &lt; 0xDC00 || second &gt; 0xDFFF)
          return index + 1;
  
      return index + 2;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,14 ***</span>
  @globalPrivate
  function regExpExec(regexp, str)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     let exec = regexp.exec;</span>
<span class="line-modified">!     let builtinExec = @regExpBuiltinExec;</span>
      if (exec !== builtinExec &amp;&amp; typeof exec === &quot;function&quot;) {
<span class="line-modified">!         let result = exec.@call(regexp, str);</span>
          if (result !== null &amp;&amp; !@isObject(result))
              @throwTypeError(&quot;The result of a RegExp exec must be null or an object&quot;);
          return result;
      }
      return builtinExec.@call(regexp, str);
<span class="line-new-header">--- 62,14 ---</span>
  @globalPrivate
  function regExpExec(regexp, str)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var exec = regexp.exec;</span>
<span class="line-modified">!     var builtinExec = @regExpBuiltinExec;</span>
      if (exec !== builtinExec &amp;&amp; typeof exec === &quot;function&quot;) {
<span class="line-modified">!         var result = exec.@call(regexp, str);</span>
          if (result !== null &amp;&amp; !@isObject(result))
              @throwTypeError(&quot;The result of a RegExp exec must be null or an object&quot;);
          return result;
      }
      return builtinExec.@call(regexp, str);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,18 ***</span>
  
      if (!@isRegExpObject(regexp))
          return true;
  
      // This is accessed by the RegExpExec internal function.
<span class="line-modified">!     let regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
      if (regexpExec !== @regExpBuiltinExec)
          return true;
  
<span class="line-modified">!     let regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
      if (regexpGlobal !== @regExpProtoGlobalGetter)
          return true;
<span class="line-modified">!     let regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
      if (regexpUnicode !== @regExpProtoUnicodeGetter)
          return true;
  
      return typeof regexp.lastIndex !== &quot;number&quot;;
  }
<span class="line-new-header">--- 82,18 ---</span>
  
      if (!@isRegExpObject(regexp))
          return true;
  
      // This is accessed by the RegExpExec internal function.
<span class="line-modified">!     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
      if (regexpExec !== @regExpBuiltinExec)
          return true;
  
<span class="line-modified">!     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
      if (regexpGlobal !== @regExpProtoGlobalGetter)
          return true;
<span class="line-modified">!     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
      if (regexpUnicode !== @regExpProtoUnicodeGetter)
          return true;
  
      return typeof regexp.lastIndex !== &quot;number&quot;;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,32 ***</span>
      &quot;use strict&quot;;
  
      if (!regexp.global)
          return @regExpExec(regexp, str);
      
<span class="line-modified">!     let unicode = regexp.unicode;</span>
      regexp.lastIndex = 0;
<span class="line-modified">!     let resultList = [];</span>
  
      // FIXME: It would be great to implement a solution similar to what we do in
      // RegExpObject::matchGlobal(). It&#39;s not clear if this is possible, since this loop has
      // effects. https://bugs.webkit.org/show_bug.cgi?id=158145
<span class="line-modified">!     const maximumReasonableMatchSize = 100000000;</span>
  
      while (true) {
<span class="line-modified">!         let result = @regExpExec(regexp, str);</span>
          
          if (result === null) {
              if (resultList.length === 0)
                  return null;
              return resultList;
          }
  
          if (resultList.length &gt; maximumReasonableMatchSize)
              @throwOutOfMemoryError();
  
<span class="line-modified">!         let resultString = @toString(result[0]);</span>
  
          if (!resultString.length)
              regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
  
          resultList.@push(resultString);
<span class="line-new-header">--- 104,32 ---</span>
      &quot;use strict&quot;;
  
      if (!regexp.global)
          return @regExpExec(regexp, str);
      
<span class="line-modified">!     var unicode = regexp.unicode;</span>
      regexp.lastIndex = 0;
<span class="line-modified">!     var resultList = [];</span>
  
      // FIXME: It would be great to implement a solution similar to what we do in
      // RegExpObject::matchGlobal(). It&#39;s not clear if this is possible, since this loop has
      // effects. https://bugs.webkit.org/show_bug.cgi?id=158145
<span class="line-modified">!     var maximumReasonableMatchSize = 100000000;</span>
  
      while (true) {
<span class="line-modified">!         var result = @regExpExec(regexp, str);</span>
          
          if (result === null) {
              if (resultList.length === 0)
                  return null;
              return resultList;
          }
  
          if (resultList.length &gt; maximumReasonableMatchSize)
              @throwOutOfMemoryError();
  
<span class="line-modified">!         var resultString = @toString(result[0]);</span>
  
          if (!resultString.length)
              regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
  
          resultList.@push(resultString);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,11 ***</span>
      &quot;use strict&quot;;
  
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@match requires that |this| be an Object&quot;);
  
<span class="line-modified">!     let str = @toString(strArg);</span>
  
      // Check for observable side effects and call the fast path if there aren&#39;t any.
      if (!@hasObservableSideEffectsForRegExpMatch(this))
          return @regExpMatchFast.@call(this, str);
      return @matchSlow(this, str);
<span class="line-new-header">--- 142,11 ---</span>
      &quot;use strict&quot;;
  
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@match requires that |this| be an Object&quot;);
  
<span class="line-modified">!     var str = @toString(strArg);</span>
  
      // Check for observable side effects and call the fast path if there aren&#39;t any.
      if (!@hasObservableSideEffectsForRegExpMatch(this))
          return @regExpMatchFast.@call(this, str);
      return @matchSlow(this, str);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,49 ***</span>
  @overriddenName=&quot;[Symbol.matchAll]&quot;
  function matchAll(strArg)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     let regExp = this;</span>
      if (!@isObject(regExp))
          @throwTypeError(&quot;RegExp.prototype.@@matchAll requires |this| to be an Object&quot;);
  
<span class="line-modified">!     let string = @toString(strArg);</span>
<span class="line-modified">!     let Matcher = @speciesConstructor(regExp, @RegExp);</span>
  
<span class="line-modified">!     let flags = @toString(regExp.flags);</span>
<span class="line-modified">!     let matcher = new Matcher(regExp, flags);</span>
      matcher.lastIndex = @toLength(regExp.lastIndex);
  
<span class="line-modified">!     let global = @stringIncludesInternal.@call(flags, &quot;g&quot;);</span>
<span class="line-modified">!     let fullUnicode = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
  
      return new @RegExpStringIterator(matcher, string, global, fullUnicode);
  }
  
  @overriddenName=&quot;[Symbol.replace]&quot;
  function replace(strArg, replace)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     function getSubstitution(matched, str, position, captures, replacement)</span>
      {
          &quot;use strict&quot;;
  
<span class="line-modified">!         let matchLength = matched.length;</span>
<span class="line-modified">!         let stringLength = str.length;</span>
<span class="line-modified">!         let tailPos = position + matchLength;</span>
<span class="line-modified">!         let m = captures.length;</span>
<span class="line-modified">!         let replacementLength = replacement.length;</span>
<span class="line-modified">!         let result = &quot;&quot;;</span>
<span class="line-modified">!         let lastStart = 0;</span>
  
<span class="line-modified">!         for (let start = 0; start = replacement.indexOf(&quot;$&quot;, lastStart), start !== -1; lastStart = start) {</span>
              if (start - lastStart &gt; 0)
                  result = result + replacement.substring(lastStart, start);
              start++;
<span class="line-modified">!             let ch = replacement.charAt(start);</span>
              if (ch === &quot;&quot;)
                  result = result + &quot;$&quot;;
              else {
                  switch (ch)
                  {
<span class="line-new-header">--- 155,49 ---</span>
  @overriddenName=&quot;[Symbol.matchAll]&quot;
  function matchAll(strArg)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var regExp = this;</span>
      if (!@isObject(regExp))
          @throwTypeError(&quot;RegExp.prototype.@@matchAll requires |this| to be an Object&quot;);
  
<span class="line-modified">!     var string = @toString(strArg);</span>
<span class="line-modified">!     var Matcher = @speciesConstructor(regExp, @RegExp);</span>
  
<span class="line-modified">!     var flags = @toString(regExp.flags);</span>
<span class="line-modified">!     var matcher = new Matcher(regExp, flags);</span>
      matcher.lastIndex = @toLength(regExp.lastIndex);
  
<span class="line-modified">!     var global = @stringIncludesInternal.@call(flags, &quot;g&quot;);</span>
<span class="line-modified">!     var fullUnicode = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
  
      return new @RegExpStringIterator(matcher, string, global, fullUnicode);
  }
  
  @overriddenName=&quot;[Symbol.replace]&quot;
  function replace(strArg, replace)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     function getSubstitution(matched, str, position, captures, namedCaptures, replacement)</span>
      {
          &quot;use strict&quot;;
  
<span class="line-modified">!         var matchLength = matched.length;</span>
<span class="line-modified">!         var stringLength = str.length;</span>
<span class="line-modified">!         var tailPos = position + matchLength;</span>
<span class="line-modified">!         var m = captures.length;</span>
<span class="line-modified">!         var replacementLength = replacement.length;</span>
<span class="line-modified">!         var result = &quot;&quot;;</span>
<span class="line-modified">!         var lastStart = 0;</span>
  
<span class="line-modified">!         for (var start = 0; start = replacement.indexOf(&quot;$&quot;, lastStart), start !== -1; lastStart = start) {</span>
              if (start - lastStart &gt; 0)
                  result = result + replacement.substring(lastStart, start);
              start++;
<span class="line-modified">!             var ch = replacement.charAt(start);</span>
              if (ch === &quot;&quot;)
                  result = result + &quot;$&quot;;
              else {
                  switch (ch)
                  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,33 ***</span>
                  case &quot;&#39;&quot;:
                      if (tailPos &lt; stringLength)
                          result = result + str.substring(tailPos);
                      start++;
                      break;
                  default:
<span class="line-modified">!                     let chCode = ch.charCodeAt(0);</span>
                      if (chCode &gt;= 0x30 &amp;&amp; chCode &lt;= 0x39) {
                          start++;
<span class="line-modified">!                         let n = chCode - 0x30;</span>
<span class="line-modified">!                         if (n &gt; m)</span>
                              break;
                          if (start &lt; replacementLength) {
<span class="line-modified">!                             let nextChCode = replacement.charCodeAt(start);</span>
                              if (nextChCode &gt;= 0x30 &amp;&amp; nextChCode &lt;= 0x39) {
<span class="line-modified">!                                 let nn = 10 * n + nextChCode - 0x30;</span>
                                  if (nn &lt;= m) {
                                      n = nn;
                                      start++;
                                  }
                              }
                          }
  
<span class="line-modified">!                         if (n == 0)</span>
                              break;
  
<span class="line-modified">!                         if (captures[n] != @undefined)</span>
<span class="line-modified">!                             result = result + captures[n];</span>
                      } else
                          result = result + &quot;$&quot;;
                      break;
                  }
              }
<span class="line-new-header">--- 217,59 ---</span>
                  case &quot;&#39;&quot;:
                      if (tailPos &lt; stringLength)
                          result = result + str.substring(tailPos);
                      start++;
                      break;
<span class="line-added">+                 case &quot;&lt;&quot;:</span>
<span class="line-added">+                     if (namedCaptures !== @undefined) {</span>
<span class="line-added">+                         var groupNameStartIndex = start + 1;</span>
<span class="line-added">+                         var groupNameEndIndex = replacement.indexOf(&quot;&gt;&quot;, groupNameStartIndex);</span>
<span class="line-added">+                         if (groupNameEndIndex !== -1) {</span>
<span class="line-added">+                             var groupName = replacement.substring(groupNameStartIndex, groupNameEndIndex);</span>
<span class="line-added">+                             var capture = namedCaptures[groupName];</span>
<span class="line-added">+                             if (capture !== @undefined)</span>
<span class="line-added">+                                 result = result + @toString(capture);</span>
<span class="line-added">+ </span>
<span class="line-added">+                             start = groupNameEndIndex + 1;</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     result = result + &quot;$&lt;&quot;;</span>
<span class="line-added">+                     start++;</span>
<span class="line-added">+                     break;</span>
                  default:
<span class="line-modified">!                     var chCode = ch.charCodeAt(0);</span>
                      if (chCode &gt;= 0x30 &amp;&amp; chCode &lt;= 0x39) {
<span class="line-added">+                         var originalStart = start - 1;</span>
                          start++;
<span class="line-modified">! </span>
<span class="line-modified">!                         var n = chCode - 0x30;</span>
<span class="line-added">+                         if (n &gt; m) {</span>
<span class="line-added">+                             result = result + replacement.substring(originalStart, start);</span>
                              break;
<span class="line-added">+                         }</span>
<span class="line-added">+ </span>
                          if (start &lt; replacementLength) {
<span class="line-modified">!                             var nextChCode = replacement.charCodeAt(start);</span>
                              if (nextChCode &gt;= 0x30 &amp;&amp; nextChCode &lt;= 0x39) {
<span class="line-modified">!                                 var nn = 10 * n + nextChCode - 0x30;</span>
                                  if (nn &lt;= m) {
                                      n = nn;
                                      start++;
                                  }
                              }
                          }
  
<span class="line-modified">!                         if (n == 0) {</span>
<span class="line-added">+                             result = result + replacement.substring(originalStart, start);</span>
                              break;
<span class="line-added">+                         }</span>
  
<span class="line-modified">!                         var capture = captures[n - 1];</span>
<span class="line-modified">!                         if (capture !== @undefined)</span>
<span class="line-added">+                             result = result + capture;</span>
                      } else
                          result = result + &quot;$&quot;;
                      break;
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,82 ***</span>
      }
  
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@replace requires that |this| be an Object&quot;);
  
<span class="line-modified">!     let regexp = this;</span>
  
<span class="line-modified">!     let str = @toString(strArg);</span>
<span class="line-modified">!     let stringLength = str.length;</span>
<span class="line-modified">!     let functionalReplace = typeof replace === &#39;function&#39;;</span>
  
      if (!functionalReplace)
          replace = @toString(replace);
  
<span class="line-modified">!     let global = regexp.global;</span>
<span class="line-modified">!     let unicode = false;</span>
  
      if (global) {
          unicode = regexp.unicode;
          regexp.lastIndex = 0;
      }
  
<span class="line-modified">!     let resultList = [];</span>
<span class="line-modified">!     let result;</span>
<span class="line-modified">!     let done = false;</span>
      while (!done) {
          result = @regExpExec(regexp, str);
  
          if (result === null)
              done = true;
          else {
              resultList.@push(result);
              if (!global)
                  done = true;
              else {
<span class="line-modified">!                 let matchStr = @toString(result[0]);</span>
  
                  if (!matchStr.length)
                      regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
              }
          }
      }
  
<span class="line-modified">!     let accumulatedResult = &quot;&quot;;</span>
<span class="line-modified">!     let nextSourcePosition = 0;</span>
<span class="line-modified">!     let lastPosition = 0;</span>
  
<span class="line-modified">!     for (let i = 0, resultListLength = resultList.length; i &lt; resultListLength; ++i) {</span>
<span class="line-modified">!         let result = resultList[i];</span>
<span class="line-modified">!         let nCaptures = result.length - 1;</span>
          if (nCaptures &lt; 0)
              nCaptures = 0;
<span class="line-modified">!         let matched = @toString(result[0]);</span>
<span class="line-modified">!         let matchLength = matched.length;</span>
<span class="line-modified">!         let position = result.index;</span>
          position = (position &gt; stringLength) ? stringLength : position;
          position = (position &lt; 0) ? 0 : position;
  
<span class="line-modified">!         let captures = [];</span>
<span class="line-modified">!         for (let n = 1; n &lt;= nCaptures; n++) {</span>
<span class="line-modified">!             let capN = result[n];</span>
              if (capN !== @undefined)
                  capN = @toString(capN);
<span class="line-modified">!             captures[n] = capN;</span>
          }
  
<span class="line-modified">!         let replacement;</span>
  
          if (functionalReplace) {
<span class="line-modified">!             let replacerArgs = [ matched ].concat(captures.slice(1));</span>
              replacerArgs.@push(position);
              replacerArgs.@push(str);
  
<span class="line-modified">!             let replValue = replace.@apply(@undefined, replacerArgs);</span>
              replacement = @toString(replValue);
<span class="line-modified">!         } else</span>
<span class="line-modified">!             replacement = getSubstitution(matched, str, position, captures, replace);</span>
  
          if (position &gt;= nextSourcePosition &amp;&amp; position &gt;= lastPosition) {
              accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matchLength;
              lastPosition = position;
<span class="line-new-header">--- 279,90 ---</span>
      }
  
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@replace requires that |this| be an Object&quot;);
  
<span class="line-modified">!     var regexp = this;</span>
  
<span class="line-modified">!     var str = @toString(strArg);</span>
<span class="line-modified">!     var stringLength = str.length;</span>
<span class="line-modified">!     var functionalReplace = typeof replace === &#39;function&#39;;</span>
  
      if (!functionalReplace)
          replace = @toString(replace);
  
<span class="line-modified">!     var global = regexp.global;</span>
<span class="line-modified">!     var unicode = false;</span>
  
      if (global) {
          unicode = regexp.unicode;
          regexp.lastIndex = 0;
      }
  
<span class="line-modified">!     var resultList = [];</span>
<span class="line-modified">!     var result;</span>
<span class="line-modified">!     var done = false;</span>
      while (!done) {
          result = @regExpExec(regexp, str);
  
          if (result === null)
              done = true;
          else {
              resultList.@push(result);
              if (!global)
                  done = true;
              else {
<span class="line-modified">!                 var matchStr = @toString(result[0]);</span>
  
                  if (!matchStr.length)
                      regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
              }
          }
      }
  
<span class="line-modified">!     var accumulatedResult = &quot;&quot;;</span>
<span class="line-modified">!     var nextSourcePosition = 0;</span>
<span class="line-modified">!     var lastPosition = 0;</span>
  
<span class="line-modified">!     for (var i = 0, resultListLength = resultList.length; i &lt; resultListLength; ++i) {</span>
<span class="line-modified">!         var result = resultList[i];</span>
<span class="line-modified">!         var nCaptures = result.length - 1;</span>
          if (nCaptures &lt; 0)
              nCaptures = 0;
<span class="line-modified">!         var matched = @toString(result[0]);</span>
<span class="line-modified">!         var matchLength = matched.length;</span>
<span class="line-modified">!         var position = result.index;</span>
          position = (position &gt; stringLength) ? stringLength : position;
          position = (position &lt; 0) ? 0 : position;
  
<span class="line-modified">!         var captures = [];</span>
<span class="line-modified">!         for (var n = 1; n &lt;= nCaptures; n++) {</span>
<span class="line-modified">!             var capN = result[n];</span>
              if (capN !== @undefined)
                  capN = @toString(capN);
<span class="line-modified">!             captures.@push(capN);</span>
          }
  
<span class="line-modified">!         var replacement;</span>
<span class="line-added">+         var namedCaptures = result.groups;</span>
  
          if (functionalReplace) {
<span class="line-modified">!             var replacerArgs = [ matched ].concat(captures);</span>
              replacerArgs.@push(position);
              replacerArgs.@push(str);
  
<span class="line-modified">!             if (namedCaptures !== @undefined)</span>
<span class="line-added">+                 replacerArgs.@push(namedCaptures);</span>
<span class="line-added">+ </span>
<span class="line-added">+             var replValue = replace.@apply(@undefined, replacerArgs);</span>
              replacement = @toString(replValue);
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             if (namedCaptures !== @undefined)</span>
<span class="line-added">+                 namedCaptures = @toObject(namedCaptures, &quot;RegExp.prototype[Symbol.replace] requires &#39;groups&#39; property of a match not be null&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             replacement = getSubstitution(matched, str, position, captures, namedCaptures, replace);</span>
<span class="line-added">+         }</span>
  
          if (position &gt;= nextSourcePosition &amp;&amp; position &gt;= lastPosition) {
              accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matchLength;
              lastPosition = position;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,11 ***</span>
  @overriddenName=&quot;[Symbol.search]&quot;
  function search(strArg)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     let regexp = this;</span>
  
      // Check for observable side effects and call the fast path if there aren&#39;t any.
      if (@isRegExpObject(regexp)
          &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
          &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
<span class="line-new-header">--- 379,11 ---</span>
  @overriddenName=&quot;[Symbol.search]&quot;
  function search(strArg)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var regexp = this;</span>
  
      // Check for observable side effects and call the fast path if there aren&#39;t any.
      if (@isRegExpObject(regexp)
          &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
          &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,23 ***</span>
      // 2. If Type(rx) is not Object, throw a TypeError exception.
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@search requires that |this| be an Object&quot;);
  
      // 3. Let S be ? ToString(string).
<span class="line-modified">!     let str = @toString(strArg)</span>
  
      // 4. Let previousLastIndex be ? Get(rx, &quot;lastIndex&quot;).
<span class="line-modified">!     let previousLastIndex = regexp.lastIndex;</span>
  
      // 5.If SameValue(previousLastIndex, 0) is false, then
      // 5.a. Perform ? Set(rx, &quot;lastIndex&quot;, 0, true).
      // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
      if (previousLastIndex !== 0)
          regexp.lastIndex = 0;
  
      // 6. Let result be ? RegExpExec(rx, S).
<span class="line-modified">!     let result = @regExpExec(regexp, str);</span>
  
      // 7. Let currentLastIndex be ? Get(rx, &quot;lastIndex&quot;).
      // 8. If SameValue(currentLastIndex, previousLastIndex) is false, then
      // 8.a. Perform ? Set(rx, &quot;lastIndex&quot;, previousLastIndex, true).
      // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
<span class="line-new-header">--- 393,23 ---</span>
      // 2. If Type(rx) is not Object, throw a TypeError exception.
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@search requires that |this| be an Object&quot;);
  
      // 3. Let S be ? ToString(string).
<span class="line-modified">!     var str = @toString(strArg)</span>
  
      // 4. Let previousLastIndex be ? Get(rx, &quot;lastIndex&quot;).
<span class="line-modified">!     var previousLastIndex = regexp.lastIndex;</span>
  
      // 5.If SameValue(previousLastIndex, 0) is false, then
      // 5.a. Perform ? Set(rx, &quot;lastIndex&quot;, 0, true).
      // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
      if (previousLastIndex !== 0)
          regexp.lastIndex = 0;
  
      // 6. Let result be ? RegExpExec(rx, S).
<span class="line-modified">!     var result = @regExpExec(regexp, str);</span>
  
      // 7. Let currentLastIndex be ? Get(rx, &quot;lastIndex&quot;).
      // 8. If SameValue(currentLastIndex, previousLastIndex) is false, then
      // 8.a. Perform ? Set(rx, &quot;lastIndex&quot;, previousLastIndex, true).
      // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,38 ***</span>
  
      if (!@isRegExpObject(regexp))
          return true;
  
      // This is accessed by the RegExpExec internal function.
<span class="line-modified">!     let regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
      if (regexpExec !== @regExpBuiltinExec)
          return true;
      
      // This is accessed by step 5 below.
<span class="line-modified">!     let regexpFlags = @tryGetById(regexp, &quot;flags&quot;);</span>
      if (regexpFlags !== @regExpProtoFlagsGetter)
          return true;
      
      // These are accessed by the builtin flags getter.
<span class="line-modified">!     let regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
      if (regexpGlobal !== @regExpProtoGlobalGetter)
          return true;
<span class="line-modified">!     let regexpIgnoreCase = @tryGetById(regexp, &quot;ignoreCase&quot;);</span>
      if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)
          return true;
<span class="line-modified">!     let regexpMultiline = @tryGetById(regexp, &quot;multiline&quot;);</span>
      if (regexpMultiline !== @regExpProtoMultilineGetter)
          return true;
<span class="line-modified">!     let regexpSticky = @tryGetById(regexp, &quot;sticky&quot;);</span>
      if (regexpSticky !== @regExpProtoStickyGetter)
          return true;
<span class="line-modified">!     let regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
      if (regexpUnicode !== @regExpProtoUnicodeGetter)
          return true;
      
      // This is accessed by the RegExp species constructor.
<span class="line-modified">!     let regexpSource = @tryGetById(regexp, &quot;source&quot;);</span>
      if (regexpSource !== @regExpProtoSourceGetter)
          return true;
  
      return typeof regexp.lastIndex !== &quot;number&quot;;
  }
<span class="line-new-header">--- 431,38 ---</span>
  
      if (!@isRegExpObject(regexp))
          return true;
  
      // This is accessed by the RegExpExec internal function.
<span class="line-modified">!     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
      if (regexpExec !== @regExpBuiltinExec)
          return true;
      
      // This is accessed by step 5 below.
<span class="line-modified">!     var regexpFlags = @tryGetById(regexp, &quot;flags&quot;);</span>
      if (regexpFlags !== @regExpProtoFlagsGetter)
          return true;
      
      // These are accessed by the builtin flags getter.
<span class="line-modified">!     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
      if (regexpGlobal !== @regExpProtoGlobalGetter)
          return true;
<span class="line-modified">!     var regexpIgnoreCase = @tryGetById(regexp, &quot;ignoreCase&quot;);</span>
      if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)
          return true;
<span class="line-modified">!     var regexpMultiline = @tryGetById(regexp, &quot;multiline&quot;);</span>
      if (regexpMultiline !== @regExpProtoMultilineGetter)
          return true;
<span class="line-modified">!     var regexpSticky = @tryGetById(regexp, &quot;sticky&quot;);</span>
      if (regexpSticky !== @regExpProtoStickyGetter)
          return true;
<span class="line-modified">!     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
      if (regexpUnicode !== @regExpProtoUnicodeGetter)
          return true;
      
      // This is accessed by the RegExp species constructor.
<span class="line-modified">!     var regexpSource = @tryGetById(regexp, &quot;source&quot;);</span>
      if (regexpSource !== @regExpProtoSourceGetter)
          return true;
  
      return typeof regexp.lastIndex !== &quot;number&quot;;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,93 ***</span>
  
      // 1. Let rx be the this value.
      // 2. If Type(rx) is not Object, throw a TypeError exception.
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@split requires that |this| be an Object&quot;);
<span class="line-modified">!     let regexp = this;</span>
  
      // 3. Let S be ? ToString(string).
<span class="line-modified">!     let str = @toString(string);</span>
  
      // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
<span class="line-modified">!     let speciesConstructor = @speciesConstructor(regexp, @RegExp);</span>
  
      if (speciesConstructor === @RegExp &amp;&amp; !@hasObservableSideEffectsForRegExpSplit(regexp))
          return @regExpSplitFast.@call(regexp, str, limit);
  
      // 5. Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
<span class="line-modified">!     let flags = @toString(regexp.flags);</span>
  
<span class="line-modified">!     // 6. If flags contains &quot;u&quot;, let unicodeMatching be true.</span>
      // 7. Else, let unicodeMatching be false.
<span class="line-modified">!     let unicodeMatching = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
<span class="line-modified">!     // 8. If flags contains &quot;y&quot;, let newFlags be flags.</span>
      // 9. Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
<span class="line-modified">!     let newFlags = @stringIncludesInternal.@call(flags, &quot;y&quot;) ? flags : flags + &quot;y&quot;;</span>
  
      // 10. Let splitter be ? Construct(C, « rx, newFlags »).
<span class="line-modified">!     let splitter = new speciesConstructor(regexp, newFlags);</span>
  
      // We need to check again for RegExp subclasses that will fail the speciesConstructor test
      // but can still use the fast path after we invoke the constructor above.
      if (!@hasObservableSideEffectsForRegExpSplit(splitter))
          return @regExpSplitFast.@call(splitter, str, limit);
  
      // 11. Let A be ArrayCreate(0).
      // 12. Let lengthA be 0.
<span class="line-modified">!     let result = [];</span>
  
<span class="line-modified">!     // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).</span>
      limit = (limit === @undefined) ? 0xffffffff : limit &gt;&gt;&gt; 0;
  
      // 16. If lim = 0, return A.
      if (!limit)
          return result;
  
      // 14. [Defered from above] Let size be the number of elements in S.
<span class="line-modified">!     let size = str.length;</span>
  
      // 17. If size = 0, then
      if (!size) {
          // a. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">!         let z = @regExpExec(splitter, str);</span>
          // b. If z is not null, return A.
          if (z != null)
              return result;
          // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
          @putByValDirect(result, 0, str);
          // d. Return A.
          return result;
      }
  
      // 15. [Defered from above] Let p be 0.
<span class="line-modified">!     let position = 0;</span>
      // 18. Let q be p.
<span class="line-modified">!     let matchPosition = 0;</span>
  
      // 19. Repeat, while q &lt; size
      while (matchPosition &lt; size) {
          // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
          splitter.lastIndex = matchPosition;
          // b. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">!         let matches = @regExpExec(splitter, str);</span>
          // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
          if (matches === null)
              matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
          // d. Else z is not null,
          else {
              // i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
<span class="line-modified">!             let endPosition = @toLength(splitter.lastIndex);</span>
              // ii. Let e be min(e, size).
              endPosition = (endPosition &lt;= size) ? endPosition : size;
              // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
              if (endPosition === position)
                  matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
              // iv. Else e != p,
              else {
                  // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
<span class="line-modified">!                 let subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);</span>
                  // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
                  // 3. Let lengthA be lengthA + 1.
                  @putByValDirect(result, result.length, subStr);
                  // 4. If lengthA = lim, return A.
                  if (result.length == limit)
<span class="line-new-header">--- 475,93 ---</span>
  
      // 1. Let rx be the this value.
      // 2. If Type(rx) is not Object, throw a TypeError exception.
      if (!@isObject(this))
          @throwTypeError(&quot;RegExp.prototype.@@split requires that |this| be an Object&quot;);
<span class="line-modified">!     var regexp = this;</span>
  
      // 3. Let S be ? ToString(string).
<span class="line-modified">!     var str = @toString(string);</span>
  
      // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
<span class="line-modified">!     var speciesConstructor = @speciesConstructor(regexp, @RegExp);</span>
  
      if (speciesConstructor === @RegExp &amp;&amp; !@hasObservableSideEffectsForRegExpSplit(regexp))
          return @regExpSplitFast.@call(regexp, str, limit);
  
      // 5. Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
<span class="line-modified">!     var flags = @toString(regexp.flags);</span>
  
<span class="line-modified">!     // 6. If flags contains &quot;u&quot;, var unicodeMatching be true.</span>
      // 7. Else, let unicodeMatching be false.
<span class="line-modified">!     var unicodeMatching = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
<span class="line-modified">!     // 8. If flags contains &quot;y&quot;, var newFlags be flags.</span>
      // 9. Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
<span class="line-modified">!     var newFlags = @stringIncludesInternal.@call(flags, &quot;y&quot;) ? flags : flags + &quot;y&quot;;</span>
  
      // 10. Let splitter be ? Construct(C, « rx, newFlags »).
<span class="line-modified">!     var splitter = new speciesConstructor(regexp, newFlags);</span>
  
      // We need to check again for RegExp subclasses that will fail the speciesConstructor test
      // but can still use the fast path after we invoke the constructor above.
      if (!@hasObservableSideEffectsForRegExpSplit(splitter))
          return @regExpSplitFast.@call(splitter, str, limit);
  
      // 11. Let A be ArrayCreate(0).
      // 12. Let lengthA be 0.
<span class="line-modified">!     var result = [];</span>
  
<span class="line-modified">!     // 13. If limit is undefined, let lim be 2^32-1; else var lim be ? ToUint32(limit).</span>
      limit = (limit === @undefined) ? 0xffffffff : limit &gt;&gt;&gt; 0;
  
      // 16. If lim = 0, return A.
      if (!limit)
          return result;
  
      // 14. [Defered from above] Let size be the number of elements in S.
<span class="line-modified">!     var size = str.length;</span>
  
      // 17. If size = 0, then
      if (!size) {
          // a. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">!         var z = @regExpExec(splitter, str);</span>
          // b. If z is not null, return A.
          if (z != null)
              return result;
          // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
          @putByValDirect(result, 0, str);
          // d. Return A.
          return result;
      }
  
      // 15. [Defered from above] Let p be 0.
<span class="line-modified">!     var position = 0;</span>
      // 18. Let q be p.
<span class="line-modified">!     var matchPosition = 0;</span>
  
      // 19. Repeat, while q &lt; size
      while (matchPosition &lt; size) {
          // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
          splitter.lastIndex = matchPosition;
          // b. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">!         var matches = @regExpExec(splitter, str);</span>
          // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
          if (matches === null)
              matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
          // d. Else z is not null,
          else {
              // i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
<span class="line-modified">!             var endPosition = @toLength(splitter.lastIndex);</span>
              // ii. Let e be min(e, size).
              endPosition = (endPosition &lt;= size) ? endPosition : size;
              // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
              if (endPosition === position)
                  matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
              // iv. Else e != p,
              else {
                  // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
<span class="line-modified">!                 var subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);</span>
                  // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
                  // 3. Let lengthA be lengthA + 1.
                  @putByValDirect(result, result.length, subStr);
                  // 4. If lengthA = lim, return A.
                  if (result.length == limit)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 535,18 ***</span>
  
                  // 5. Let p be e.
                  position = endPosition;
                  // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
                  // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
<span class="line-modified">!                 let numberOfCaptures = matches.length &gt; 1 ? matches.length - 1 : 0;</span>
  
                  // 8. Let i be 1.
<span class="line-modified">!                 let i = 1;</span>
                  // 9. Repeat, while i &lt;= numberOfCaptures,
                  while (i &lt;= numberOfCaptures) {
                      // a. Let nextCapture be ? Get(z, ! ToString(i)).
<span class="line-modified">!                     let nextCapture = matches[i];</span>
                      // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
                      // d. Let lengthA be lengthA + 1.
                      @putByValDirect(result, result.length, nextCapture);
                      // e. If lengthA = lim, return A.
                      if (result.length == limit)
<span class="line-new-header">--- 569,18 ---</span>
  
                  // 5. Let p be e.
                  position = endPosition;
                  // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
                  // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
<span class="line-modified">!                 var numberOfCaptures = matches.length &gt; 1 ? matches.length - 1 : 0;</span>
  
                  // 8. Let i be 1.
<span class="line-modified">!                 var i = 1;</span>
                  // 9. Repeat, while i &lt;= numberOfCaptures,
                  while (i &lt;= numberOfCaptures) {
                      // a. Let nextCapture be ? Get(z, ! ToString(i)).
<span class="line-modified">!                     var nextCapture = matches[i];</span>
                      // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
                      // d. Let lengthA be lengthA + 1.
                      @putByValDirect(result, result.length, nextCapture);
                      // e. If lengthA = lim, return A.
                      if (result.length == limit)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,11 ***</span>
                  matchPosition = position;
              }
          }
      }
      // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
<span class="line-modified">!     let remainingStr = @stringSubstrInternal.@call(str, position, size);</span>
      // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
      @putByValDirect(result, result.length, remainingStr);
      // 22. Return A.
      return result;
  }
<span class="line-new-header">--- 592,11 ---</span>
                  matchPosition = position;
              }
          }
      }
      // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
<span class="line-modified">!     var remainingStr = @stringSubstrInternal.@call(str, position, size);</span>
      // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
      @putByValDirect(result, result.length, remainingStr);
      // 22. Return A.
      return result;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,11 ***</span>
  @intrinsic=RegExpTestIntrinsic
  function test(strArg)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     let regexp = this;</span>
  
      // Check for observable side effects and call the fast path if there aren&#39;t any.
      if (@isRegExpObject(regexp)
          &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
          &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
<span class="line-new-header">--- 605,11 ---</span>
  @intrinsic=RegExpTestIntrinsic
  function test(strArg)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var regexp = this;</span>
  
      // Check for observable side effects and call the fast path if there aren&#39;t any.
      if (@isRegExpObject(regexp)
          &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
          &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,14 ***</span>
      // 2. If Type(R) is not Object, throw a TypeError exception.
      if (!@isObject(regexp))
          @throwTypeError(&quot;RegExp.prototype.test requires that |this| be an Object&quot;);
  
      // 3. Let string be ? ToString(S).
<span class="line-modified">!     let str = @toString(strArg);</span>
  
      // 4. Let match be ? RegExpExec(R, string).
<span class="line-modified">!     let match = @regExpExec(regexp, str);</span>
  
      // 5. If match is not null, return true; else return false.
      if (match !== null)
          return true;
      return false;
<span class="line-new-header">--- 619,14 ---</span>
      // 2. If Type(R) is not Object, throw a TypeError exception.
      if (!@isObject(regexp))
          @throwTypeError(&quot;RegExp.prototype.test requires that |this| be an Object&quot;);
  
      // 3. Let string be ? ToString(S).
<span class="line-modified">!     var str = @toString(strArg);</span>
  
      // 4. Let match be ? RegExpExec(R, string).
<span class="line-modified">!     var match = @regExpExec(regexp, str);</span>
  
      // 5. If match is not null, return true; else return false.
      if (match !== null)
          return true;
      return false;
</pre>
<center><a href="PromisePrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpStringIteratorPrototype.js.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
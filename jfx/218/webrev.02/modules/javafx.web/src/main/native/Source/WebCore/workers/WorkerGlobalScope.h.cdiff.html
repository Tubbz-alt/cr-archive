<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WorkerGlobalScope.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerGlobalScopeProxy.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,27 ***</span>
  #include &quot;ImageBitmap.h&quot;
  #include &quot;ScriptExecutionContext.h&quot;
  #include &quot;Supplementable.h&quot;
  #include &lt;wtf/URL.h&gt;
  #include &quot;WorkerCacheStorageConnection.h&quot;
<span class="line-modified">! #include &quot;WorkerEventQueue.h&quot;</span>
  #include &quot;WorkerScriptController.h&quot;
  #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  #include &lt;memory&gt;
<span class="line-removed">- #include &lt;pal/SessionID.h&gt;</span>
  
  namespace WebCore {
  
  class ContentSecurityPolicyResponseHeaders;
  class Crypto;
<span class="line-modified">! class MicrotaskQueue;</span>
  class Performance;
  class ScheduledAction;
  class WorkerInspectorController;
  class WorkerLocation;
  class WorkerNavigator;
  class WorkerThread;
  
  namespace IDBClient {
  class IDBConnectionProxy;
  }
  
<span class="line-new-header">--- 32,30 ---</span>
  #include &quot;ImageBitmap.h&quot;
  #include &quot;ScriptExecutionContext.h&quot;
  #include &quot;Supplementable.h&quot;
  #include &lt;wtf/URL.h&gt;
  #include &quot;WorkerCacheStorageConnection.h&quot;
<span class="line-modified">! #include &quot;WorkerMessagePortChannelProvider.h&quot;</span>
  #include &quot;WorkerScriptController.h&quot;
  #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  #include &lt;memory&gt;
  
  namespace WebCore {
  
<span class="line-added">+ class CSSValuePool;</span>
  class ContentSecurityPolicyResponseHeaders;
  class Crypto;
<span class="line-modified">! class EventLoopTaskGroup;</span>
  class Performance;
  class ScheduledAction;
<span class="line-added">+ class WorkerEventLoop;</span>
  class WorkerInspectorController;
  class WorkerLocation;
  class WorkerNavigator;
<span class="line-added">+ class WorkerSWClientConnection;</span>
  class WorkerThread;
<span class="line-added">+ struct WorkerParameters;</span>
  
  namespace IDBClient {
  class IDBConnectionProxy;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,27 ***</span>
      virtual ~WorkerGlobalScope();
  
      virtual bool isDedicatedWorkerGlobalScope() const { return false; }
      virtual bool isServiceWorkerGlobalScope() const { return false; }
  
      const URL&amp; url() const final { return m_url; }
<span class="line-modified">!     String origin() const final;</span>
      const String&amp; identifier() const { return m_identifier; }
  
  #if ENABLE(INDEXED_DATABASE)
      IDBClient::IDBConnectionProxy* idbConnectionProxy() final;
  #endif
  
      WorkerCacheStorageConnection&amp; cacheStorageConnection();
  
      WorkerScriptController* script() { return m_script.get(); }
      void clearScript() { m_script = nullptr; }
  
      WorkerInspectorController&amp; inspectorController() const { return *m_inspectorController; }
  
<span class="line-removed">-     MicrotaskQueue&amp; microtaskQueue() const { return *m_microtaskQueue; }</span>
<span class="line-removed">- </span>
      WorkerThread&amp; thread() const { return m_thread; }
  
      using ScriptExecutionContext::hasPendingActivity;
  
      void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
<span class="line-new-header">--- 65,33 ---</span>
      virtual ~WorkerGlobalScope();
  
      virtual bool isDedicatedWorkerGlobalScope() const { return false; }
      virtual bool isServiceWorkerGlobalScope() const { return false; }
  
<span class="line-added">+     EventLoopTaskGroup&amp; eventLoop() final;</span>
<span class="line-added">+ </span>
      const URL&amp; url() const final { return m_url; }
<span class="line-modified">!     String origin() const;</span>
      const String&amp; identifier() const { return m_identifier; }
  
  #if ENABLE(INDEXED_DATABASE)
      IDBClient::IDBConnectionProxy* idbConnectionProxy() final;
<span class="line-added">+     void suspend();</span>
<span class="line-added">+     void resume();</span>
  #endif
  
      WorkerCacheStorageConnection&amp; cacheStorageConnection();
<span class="line-added">+     MessagePortChannelProvider&amp; messagePortChannelProvider();</span>
<span class="line-added">+ #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">+     WorkerSWClientConnection&amp; swClientConnection();</span>
<span class="line-added">+ #endif</span>
  
      WorkerScriptController* script() { return m_script.get(); }
      void clearScript() { m_script = nullptr; }
  
      WorkerInspectorController&amp; inspectorController() const { return *m_inspectorController; }
  
      WorkerThread&amp; thread() const { return m_thread; }
  
      using ScriptExecutionContext::hasPendingActivity;
  
      void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,13 ***</span>
      virtual ExceptionOr&lt;void&gt; importScripts(const Vector&lt;String&gt;&amp; urls);
      WorkerNavigator&amp; navigator();
  
      void setIsOnline(bool);
  
<span class="line-modified">!     ExceptionOr&lt;int&gt; setTimeout(JSC::ExecState&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
      void clearTimeout(int timeoutId);
<span class="line-modified">!     ExceptionOr&lt;int&gt; setInterval(JSC::ExecState&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
      void clearInterval(int timeoutId);
  
      bool isContextThread() const final;
      bool isSecureContext() const final;
  
<span class="line-new-header">--- 103,13 ---</span>
      virtual ExceptionOr&lt;void&gt; importScripts(const Vector&lt;String&gt;&amp; urls);
      WorkerNavigator&amp; navigator();
  
      void setIsOnline(bool);
  
<span class="line-modified">!     ExceptionOr&lt;int&gt; setTimeout(JSC::JSGlobalObject&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
      void clearTimeout(int timeoutId);
<span class="line-modified">!     ExceptionOr&lt;int&gt; setInterval(JSC::JSGlobalObject&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
      void clearInterval(int timeoutId);
  
      bool isContextThread() const final;
      bool isSecureContext() const final;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,10 ***</span>
<span class="line-new-header">--- 121,12 ---</span>
  
      bool isClosing() { return m_closing; }
  
      void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
  
<span class="line-added">+     SecurityOrigin&amp; topOrigin() const final { return m_topOrigin.get(); }</span>
<span class="line-added">+ </span>
      Crypto&amp; crypto();
      Performance&amp; performance() const;
  
      void prepareForTermination();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,14 ***</span>
      void createImageBitmap(ImageBitmap::Source&amp;&amp;, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
      void createImageBitmap(ImageBitmap::Source&amp;&amp;, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
  
      unsigned long createUniqueIdentifier() { return m_uniqueIdentifier++; }
  
<span class="line-modified">!     PAL::SessionID sessionID() const final { return m_sessionID; }</span>
  
  protected:
<span class="line-modified">!     WorkerGlobalScope(const URL&amp;, Ref&lt;SecurityOrigin&gt;&amp;&amp;, const String&amp; identifier, const String&amp; userAgent, bool isOnline, WorkerThread&amp;, bool shouldBypassMainWorldContentSecurityPolicy, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy*, SocketProvider*, PAL::SessionID);</span>
  
      void applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp;);
  
  private:
      void refScriptExecutionContext() final { ref(); }
<span class="line-new-header">--- 135,16 ---</span>
      void createImageBitmap(ImageBitmap::Source&amp;&amp;, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
      void createImageBitmap(ImageBitmap::Source&amp;&amp;, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
  
      unsigned long createUniqueIdentifier() { return m_uniqueIdentifier++; }
  
<span class="line-modified">!     CSSValuePool&amp; cssValuePool();</span>
<span class="line-added">+ </span>
<span class="line-added">+     ReferrerPolicy referrerPolicy() const final;</span>
  
  protected:
<span class="line-modified">!     WorkerGlobalScope(const WorkerParameters&amp;, Ref&lt;SecurityOrigin&gt;&amp;&amp;, WorkerThread&amp;, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy*, SocketProvider*);</span>
  
      void applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp;);
  
  private:
      void refScriptExecutionContext() final { ref(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,37 ***</span>
  
      void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
  
      // The following addMessage and addConsoleMessage functions are deprecated.
      // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">!     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState*, unsigned long requestIdentifier) final;</span>
      void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier) final;
  
      bool isWorkerGlobalScope() const final { return true; }
  
      ScriptExecutionContext* scriptExecutionContext() const final { return const_cast&lt;WorkerGlobalScope*&gt;(this); }
<span class="line-modified">!     URL completeURL(const String&amp;) const final;</span>
      String userAgent(const URL&amp;) const final;
      void disableEval(const String&amp; errorMessage) final;
      void disableWebAssembly(const String&amp; errorMessage) final;
      EventTarget* errorEventTarget() final;
<span class="line-removed">-     WorkerEventQueue&amp; eventQueue() const final;</span>
      String resourceRequestIdentifier() const final { return m_identifier; }
      SocketProvider* socketProvider() final;
  
      bool shouldBypassMainWorldContentSecurityPolicy() const final { return m_shouldBypassMainWorldContentSecurityPolicy; }
      bool isJSExecutionForbidden() const final;
<span class="line-removed">-     SecurityOrigin&amp; topOrigin() const final { return m_topOrigin.get(); }</span>
  
  #if ENABLE(WEB_CRYPTO)
<span class="line-removed">-     // The following two functions are side effects of providing extra protection to serialized</span>
<span class="line-removed">-     // CryptoKey data that went through the structured clone algorithm to local storage such as</span>
<span class="line-removed">-     // IndexedDB. They don&#39;t provide any proctection against communications between mainThread</span>
<span class="line-removed">-     // and workerThreads. In fact, they cause extra expense as workerThreads cannot talk to clients</span>
<span class="line-removed">-     // to unwrap/wrap crypto keys. Hence, workerThreads must always ask mainThread to unwrap/wrap</span>
<span class="line-removed">-     // keys, which results in a second communication and plain keys being transferred between</span>
<span class="line-removed">-     // workerThreads and the mainThread.</span>
      bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) final;
      bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) final;
  #endif
  
  #if ENABLE(INDEXED_DATABASE)
<span class="line-new-header">--- 155,28 ---</span>
  
      void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
  
      // The following addMessage and addConsoleMessage functions are deprecated.
      // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">!     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::JSGlobalObject*, unsigned long requestIdentifier) final;</span>
      void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier) final;
  
      bool isWorkerGlobalScope() const final { return true; }
  
      ScriptExecutionContext* scriptExecutionContext() const final { return const_cast&lt;WorkerGlobalScope*&gt;(this); }
<span class="line-modified">!     URL completeURL(const String&amp;, ForceUTF8 = ForceUTF8::No) const final;</span>
      String userAgent(const URL&amp;) const final;
      void disableEval(const String&amp; errorMessage) final;
      void disableWebAssembly(const String&amp; errorMessage) final;
      EventTarget* errorEventTarget() final;
      String resourceRequestIdentifier() const final { return m_identifier; }
      SocketProvider* socketProvider() final;
  
      bool shouldBypassMainWorldContentSecurityPolicy() const final { return m_shouldBypassMainWorldContentSecurityPolicy; }
      bool isJSExecutionForbidden() const final;
  
  #if ENABLE(WEB_CRYPTO)
      bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) final;
      bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) final;
  #endif
  
  #if ENABLE(INDEXED_DATABASE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,17 ***</span>
      mutable RefPtr&lt;WorkerNavigator&gt; m_navigator;
  
      WorkerThread&amp; m_thread;
      std::unique_ptr&lt;WorkerScriptController&gt; m_script;
      std::unique_ptr&lt;WorkerInspectorController&gt; m_inspectorController;
<span class="line-removed">-     std::unique_ptr&lt;MicrotaskQueue&gt; m_microtaskQueue;</span>
  
      bool m_closing { false };
      bool m_isOnline;
      bool m_shouldBypassMainWorldContentSecurityPolicy;
  
<span class="line-modified">!     mutable WorkerEventQueue m_eventQueue;</span>
  
      Ref&lt;SecurityOrigin&gt; m_topOrigin;
  
  #if ENABLE(INDEXED_DATABASE)
      RefPtr&lt;IDBClient::IDBConnectionProxy&gt; m_connectionProxy;
<span class="line-new-header">--- 191,17 ---</span>
      mutable RefPtr&lt;WorkerNavigator&gt; m_navigator;
  
      WorkerThread&amp; m_thread;
      std::unique_ptr&lt;WorkerScriptController&gt; m_script;
      std::unique_ptr&lt;WorkerInspectorController&gt; m_inspectorController;
  
      bool m_closing { false };
      bool m_isOnline;
      bool m_shouldBypassMainWorldContentSecurityPolicy;
  
<span class="line-modified">!     RefPtr&lt;WorkerEventLoop&gt; m_eventLoop;</span>
<span class="line-added">+     std::unique_ptr&lt;EventLoopTaskGroup&gt; m_defaultTaskGroup;</span>
  
      Ref&lt;SecurityOrigin&gt; m_topOrigin;
  
  #if ENABLE(INDEXED_DATABASE)
      RefPtr&lt;IDBClient::IDBConnectionProxy&gt; m_connectionProxy;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,14 ***</span>
      RefPtr&lt;SocketProvider&gt; m_socketProvider;
  
      RefPtr&lt;Performance&gt; m_performance;
      mutable RefPtr&lt;Crypto&gt; m_crypto;
  
<span class="line-removed">-     PAL::SessionID m_sessionID;</span>
      RefPtr&lt;WorkerCacheStorageConnection&gt; m_cacheStorageConnection;
<span class="line-modified">! </span>
      unsigned long m_uniqueIdentifier { 1 };
  };
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::WorkerGlobalScope)
<span class="line-new-header">--- 210,18 ---</span>
      RefPtr&lt;SocketProvider&gt; m_socketProvider;
  
      RefPtr&lt;Performance&gt; m_performance;
      mutable RefPtr&lt;Crypto&gt; m_crypto;
  
      RefPtr&lt;WorkerCacheStorageConnection&gt; m_cacheStorageConnection;
<span class="line-modified">!     std::unique_ptr&lt;WorkerMessagePortChannelProvider&gt; m_messagePortChannelProvider;</span>
      unsigned long m_uniqueIdentifier { 1 };
<span class="line-added">+ #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">+     RefPtr&lt;WorkerSWClientConnection&gt; m_swClientConnection;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     std::unique_ptr&lt;CSSValuePool&gt; m_cssValuePool;</span>
<span class="line-added">+     ReferrerPolicy m_referrerPolicy;</span>
  };
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::WorkerGlobalScope)
</pre>
<center><a href="WorkerGlobalScope.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerGlobalScopeProxy.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 # Copyright (C) 2011-2018 Apple Inc. All rights reserved.
  2 # Copyright (C) 2013 University of Szeged. All rights reserved.
  3 #
  4 # Redistribution and use in source and binary forms, with or without
  5 # modification, are permitted provided that the following conditions
  6 # are met:
  7 # 1. Redistributions of source code must retain the above copyright
  8 #    notice, this list of conditions and the following disclaimer.
  9 # 2. Redistributions in binary form must reproduce the above copyright
 10 #    notice, this list of conditions and the following disclaimer in the
 11 #    documentation and/or other materials provided with the distribution.
 12 #
 13 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23 # THE POSSIBILITY OF SUCH DAMAGE.
 24 
 25 require &quot;config&quot;
 26 require &quot;ast&quot;
 27 require &quot;opt&quot;
 28 require &quot;risc&quot;
 29 
 30 # GPR conventions, to match the baseline JIT
 31 #
 32 #  x0 =&gt; t0, a0, r0
 33 #  x1 =&gt; t1, a1, r1
 34 #  x2 =&gt; t2, a2, r2
 35 #  x3 =&gt; t3, a3, r3
 36 #  x6 =&gt;            (callee-save scratch)
 37 #  x7 =&gt; cfr
 38 #  x8 =&gt; t4         (callee-save)
 39 #  x9 =&gt; t5         (callee-save)
<a name="1" id="anc1"></a><span class="line-modified"> 40 # x10 =&gt; csr1       (callee-save, PB)</span>
 41 # x11 =&gt; cfr, csr0  (callee-save, metadataTable)
 42 # x12 =&gt;            (callee-save scratch)
 43 #  lr =&gt; lr
 44 #  sp =&gt; sp
 45 #  pc =&gt; pc
 46 #
 47 # FPR conventions, to match the baseline JIT
 48 #
 49 # d0 =&gt; ft0, fa0, fr
 50 # d1 =&gt; ft1, fa1
 51 # d2 =&gt; ft2
 52 # d3 =&gt; ft3
 53 # d4 =&gt; ft4
 54 # d5 =&gt; ft5
 55 # d6 =&gt;              (scratch)
 56 # d7 =&gt;              (scratch)
 57 
 58 class Node
 59     def armSingle
 60         doubleOperand = armOperand
 61         raise &quot;Bogus register name #{doubleOperand}&quot; unless doubleOperand =~ /^d/
 62         &quot;s&quot; + ($~.post_match.to_i * 2).to_s
 63     end
 64 end
 65 
 66 class SpecialRegister
 67     def armOperand
 68         @name
 69     end
 70 end
 71 
<a name="2" id="anc2"></a><span class="line-modified"> 72 ARM_EXTRA_GPRS = [SpecialRegister.new(&quot;r6&quot;), SpecialRegister.new(&quot;r4&quot;), SpecialRegister.new(&quot;r12&quot;)]</span>
 73 ARM_EXTRA_FPRS = [SpecialRegister.new(&quot;d7&quot;)]
 74 ARM_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
 75 OS_DARWIN = ((RUBY_PLATFORM =~ /darwin/i) != nil)
 76 
 77 def armMoveImmediate(value, register)
 78     # Currently we only handle the simple cases, and fall back to mov/movt for the complex ones.
 79     if value.is_a? String
 80       $asm.puts &quot;mov #{register.armOperand}, (#{value})&quot;
 81     elsif value &gt;= 0 &amp;&amp; value &lt; 256
 82         $asm.puts &quot;mov #{register.armOperand}, \##{value}&quot;
 83     elsif (~value) &gt;= 0 &amp;&amp; (~value) &lt; 256
 84         $asm.puts &quot;mvn #{register.armOperand}, \##{~value}&quot;
 85     else
 86         $asm.puts &quot;movw #{register.armOperand}, \##{value &amp; 0xffff}&quot;
 87         if (value &amp; 0xffff0000) != 0
 88             $asm.puts &quot;movt #{register.armOperand}, \##{(value &gt;&gt; 16) &amp; 0xffff}&quot;
 89         end
 90     end
 91 end
 92 
 93 class RegisterID
 94     def armOperand
 95         case name
 96         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
 97             &quot;r0&quot;
 98         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
 99             &quot;r1&quot;
100         when &quot;t2&quot;, &quot;a2&quot;
101             &quot;r2&quot;
102         when &quot;a3&quot;
103             &quot;r3&quot;
104         when &quot;t3&quot;
<a name="3" id="anc3"></a><span class="line-modified">105             &quot;r3&quot;</span>
106         when &quot;t4&quot;
107             &quot;r8&quot;
108         when &quot;t5&quot;
109             &quot;r9&quot;
110         when &quot;cfr&quot;
111             &quot;r7&quot;
112         when &quot;csr0&quot;
113             &quot;r11&quot;
<a name="4" id="anc4"></a><span class="line-added">114         when &quot;csr1&quot;</span>
<span class="line-added">115             &quot;r10&quot;</span>
116         when &quot;lr&quot;
117             &quot;lr&quot;
118         when &quot;sp&quot;
119             &quot;sp&quot;
120         when &quot;pc&quot;
121             &quot;pc&quot;
122         else
123             raise &quot;Bad register #{name} for ARM at #{codeOriginString}&quot;
124         end
125     end
126 end
127 
128 class FPRegisterID
129     def armOperand
130         case name
131         when &quot;ft0&quot;, &quot;fr&quot;, &quot;fa0&quot;
132             &quot;d0&quot;
133         when &quot;ft1&quot;, &quot;fa1&quot;
134             &quot;d1&quot;
135         when &quot;ft2&quot;
136             &quot;d2&quot;
137         when &quot;ft3&quot;
138             &quot;d3&quot;
139         when &quot;ft4&quot;
140             &quot;d4&quot;
141         when &quot;ft5&quot;
142             &quot;d5&quot;
143         else
144             raise &quot;Bad register #{name} for ARM at #{codeOriginString}&quot;
145         end
146     end
147 end
148 
149 class Immediate
150     def armOperand
151         raise &quot;Invalid immediate #{value} at #{codeOriginString}&quot; if value &lt; 0 or value &gt; 255
152         &quot;\##{value}&quot;
153     end
154 end
155 
156 class Address
157     def armOperand
158         raise &quot;Bad offset at #{codeOriginString}&quot; if offset.value &lt; -0xff or offset.value &gt; 0xfff
159         &quot;[#{base.armOperand}, \##{offset.value}]&quot;
160     end
161 end
162 
163 class BaseIndex
164     def armOperand
165         raise &quot;Bad offset at #{codeOriginString}&quot; if offset.value != 0
166         &quot;[#{base.armOperand}, #{index.armOperand}, lsl \##{scaleShift}]&quot;
167     end
168 end
169 
170 class AbsoluteAddress
171     def armOperand
172         raise &quot;Unconverted absolute address at #{codeOriginString}&quot;
173     end
174 end
175 
176 #
177 # Lea support.
178 #
179 
180 class Address
181     def armEmitLea(destination)
182         if destination == base
183             $asm.puts &quot;adds #{destination.armOperand}, \##{offset.value}&quot;
184         else
185             $asm.puts &quot;adds #{destination.armOperand}, #{base.armOperand}, \##{offset.value}&quot;
186         end
187     end
188 end
189 
190 class BaseIndex
191     def armEmitLea(destination)
192         raise &quot;Malformed BaseIndex, offset should be zero at #{codeOriginString}&quot; unless offset.value == 0
193         $asm.puts &quot;add #{destination.armOperand}, #{base.armOperand}, #{index.armOperand}, lsl \##{scaleShift}&quot;
194     end
195 end
196 
197 # FIXME: we could support AbsoluteAddress for lea, but we don&#39;t.
198 
199 #
200 # Actual lowering code follows.
201 #
202 
203 def armOpcodeReversedOperands(opcode)
204     m = /\Ab[ipb]/.match(opcode)
205 
206     operation =
207         case m.post_match
208         when &quot;eq&quot; then &quot;eq&quot;
209         when &quot;neq&quot; then &quot;neq&quot;
210         when &quot;a&quot; then &quot;b&quot;
211         when &quot;aeq&quot; then &quot;beq&quot;
212         when &quot;b&quot; then &quot;a&quot;
213         when &quot;beq&quot; then &quot;aeq&quot;
214         when &quot;gt&quot; then &quot;lt&quot;
215         when &quot;gteq&quot; then &quot;lteq&quot;
216         when &quot;lt&quot; then &quot;gt&quot;
217         when &quot;lteq&quot; then &quot;gteq&quot;
218         else
219             raise &quot;unknown operation #{m.post_match}&quot;
220         end
221 
222     &quot;#{m[0]}#{operation}&quot;
223 end
224 
225 def armLowerStackPointerInComparison(list)
226     newList = []
227     list.each {
228         | node |
229         if node.is_a? Instruction
230             case node.opcode
231             when &quot;bieq&quot;, &quot;bpeq&quot;, &quot;bbeq&quot;,
232                 &quot;bineq&quot;, &quot;bpneq&quot;, &quot;bbneq&quot;,
233                 &quot;bia&quot;, &quot;bpa&quot;, &quot;bba&quot;,
234                 &quot;biaeq&quot;, &quot;bpaeq&quot;, &quot;bbaeq&quot;,
235                 &quot;bib&quot;, &quot;bpb&quot;, &quot;bbb&quot;,
236                 &quot;bibeq&quot;, &quot;bpbeq&quot;, &quot;bbbeq&quot;,
237                 &quot;bigt&quot;, &quot;bpgt&quot;, &quot;bbgt&quot;,
238                 &quot;bigteq&quot;, &quot;bpgteq&quot;, &quot;bbgteq&quot;,
239                 &quot;bilt&quot;, &quot;bplt&quot;, &quot;bblt&quot;,
240                 &quot;bilteq&quot;, &quot;bplteq&quot;, &quot;bblteq&quot;
241                 if node.operands[1].is_a?(RegisterID) &amp;&amp; node.operands[1].name == &quot;sp&quot;
242                     newList &lt;&lt; Instruction.new(codeOrigin, armOpcodeReversedOperands(node.opcode), [node.operands[1], node.operands[0]] + node.operands[2..-1])
243                 else
244                     newList &lt;&lt; node
245                 end
246             else
247                 newList &lt;&lt; node
248             end
249         else
250             newList &lt;&lt; node
251         end
252     }
253     newList
254 end
255 
256 def armLowerLabelReferences(list)
257     newList = []
258     list.each {
259         | node |
260         if node.is_a? Instruction
261             case node.opcode
262             when &quot;leai&quot;, &quot;leap&quot;, &quot;leaq&quot;
263                 labelRef = node.operands[0]
264                 if labelRef.is_a? LabelReference
265                     raise unless labelRef.offset == 0
266                     tmp = Tmp.new(node.codeOrigin, :gpr)
267                     newList &lt;&lt; Instruction.new(codeOrigin, &quot;globaladdr&quot;, [LabelReference.new(node.codeOrigin, labelRef.label), node.operands[1], tmp])
268                 else
269                     newList &lt;&lt; node
270                 end
271             else
272                 newList &lt;&lt; node
273             end
274         else
275             newList &lt;&lt; node
276         end
277     }
278     newList
279 end
280 
281 class Sequence
282     def getModifiedListARMv7
283         raise unless $activeBackend == &quot;ARMv7&quot;
284         getModifiedListARMCommon
285     end
286 
287     def getModifiedListARMCommon
288         result = @list
289         result = riscLowerSimpleBranchOps(result)
290         result = riscLowerHardBranchOps(result)
291         result = riscLowerShiftOps(result)
292         result = armLowerLabelReferences(result)
293         result = riscLowerMalformedAddresses(result) {
294             | node, address |
295             if address.is_a? BaseIndex
296                 address.offset.value == 0
297             elsif address.is_a? Address
298                 (-0xff..0xfff).include? address.offset.value
299             else
300                 false
301             end
302         }
303         result = riscLowerMalformedAddressesDouble(result)
<a name="5" id="anc5"></a><span class="line-modified">304         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storeh&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])</span>
<span class="line-modified">305         result = riscLowerMalformedImmediates(result, 0..0xff, 0..0x0ff)</span>
306         result = riscLowerMisplacedAddresses(result)
307         result = riscLowerRegisterReuse(result)
308         result = assignRegistersToTemporaries(result, :gpr, ARM_EXTRA_GPRS)
309         result = assignRegistersToTemporaries(result, :fpr, ARM_EXTRA_FPRS)
310         result = armLowerStackPointerInComparison(result)
311         return result
312     end
313 end
314 
315 def armOperands(operands)
316     operands.map{|v| v.armOperand}.join(&quot;, &quot;)
317 end
318 
319 def armFlippedOperands(operands)
320     armOperands([operands[-1]] + operands[0..-2])
321 end
322 
323 def emitArmCompact(opcode2, opcode3, operands)
324     if operands.size == 3
325         $asm.puts &quot;#{opcode3} #{armFlippedOperands(operands)}&quot;
326     else
327         raise unless operands.size == 2
328         raise unless operands[1].register?
329         if operands[0].immediate?
330             $asm.puts &quot;#{opcode3} #{operands[1].armOperand}, #{operands[1].armOperand}, #{operands[0].armOperand}&quot;
331         else
332             $asm.puts &quot;#{opcode2} #{armFlippedOperands(operands)}&quot;
333         end
334     end
335 end
336 
337 def emitArm(opcode, operands)
338     if operands.size == 3
339         $asm.puts &quot;#{opcode} #{armFlippedOperands(operands)}&quot;
340     else
341         raise unless operands.size == 2
342         $asm.puts &quot;#{opcode} #{operands[1].armOperand}, #{operands[1].armOperand}, #{operands[0].armOperand}&quot;
343     end
344 end
345 
346 def emitArmDoubleBranch(branchOpcode, operands)
347     $asm.puts &quot;vcmpe.f64 #{armOperands(operands[0..1])}&quot;
348     $asm.puts &quot;vmrs apsr_nzcv, fpscr&quot;
349     $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
350 end
351 
352 def emitArmTest(operands)
353     value = operands[0]
354     case operands.size
355     when 2
356         mask = Immediate.new(codeOrigin, -1)
357     when 3
358         mask = operands[1]
359     else
360         raise &quot;Expected 2 or 3 operands but got #{operands.size} at #{codeOriginString}&quot;
361     end
362     
363     if mask.immediate? and mask.value == -1
364         $asm.puts &quot;tst #{value.armOperand}, #{value.armOperand}&quot;
365     else
366         $asm.puts &quot;tst #{value.armOperand}, #{mask.armOperand}&quot;
367     end
368 end
369 
370 def emitArmCompare(operands, code)
371     $asm.puts &quot;movs #{operands[2].armOperand}, \#0&quot;
372     $asm.puts &quot;cmp #{operands[0].armOperand}, #{operands[1].armOperand}&quot;
373     $asm.puts &quot;it #{code}&quot;
374     $asm.puts &quot;mov#{code} #{operands[2].armOperand}, \#1&quot;
375 end
376 
377 def emitArmTestSet(operands, code)
378     $asm.puts &quot;movs #{operands[-1].armOperand}, \#0&quot;
379     emitArmTest(operands)
380     $asm.puts &quot;it #{code}&quot;
381     $asm.puts &quot;mov#{code} #{operands[-1].armOperand}, \#1&quot;
382 end
383 
384 class Instruction
385     def lowerARMv7
386         raise unless $activeBackend == &quot;ARMv7&quot;
387         lowerARMCommon
388     end
389 
390     def lowerARMCommon
391         case opcode
392         when &quot;addi&quot;, &quot;addp&quot;, &quot;addis&quot;, &quot;addps&quot;
393             if opcode == &quot;addis&quot; or opcode == &quot;addps&quot;
394                 suffix = &quot;s&quot;
395             else
396                 suffix = &quot;&quot;
397             end
398             if operands.size == 3 and operands[0].immediate?
399                 raise unless operands[1].register?
400                 raise unless operands[2].register?
401                 if operands[0].value == 0 and suffix.empty?
402                     unless operands[1] == operands[2]
403                         $asm.puts &quot;mov #{operands[2].armOperand}, #{operands[1].armOperand}&quot;
404                     end
405                 else
406                     $asm.puts &quot;adds #{operands[2].armOperand}, #{operands[1].armOperand}, #{operands[0].armOperand}&quot;
407                 end
408             elsif operands.size == 3 and operands[0].register?
409                 raise unless operands[1].register?
410                 raise unless operands[2].register?
411                 $asm.puts &quot;adds #{armFlippedOperands(operands)}&quot;
412             else
413                 if operands[0].immediate?
414                     unless Immediate.new(nil, 0) == operands[0]
415                         $asm.puts &quot;adds #{armFlippedOperands(operands)}&quot;
416                     end
417                 else
418                     $asm.puts &quot;add#{suffix} #{armFlippedOperands(operands)}&quot;
419                 end
420             end
421         when &quot;andi&quot;, &quot;andp&quot;
422             emitArmCompact(&quot;ands&quot;, &quot;and&quot;, operands)
<a name="6" id="anc6"></a><span class="line-modified">423         when &quot;ori&quot;, &quot;orp&quot;, &quot;orh&quot;</span>
424             emitArmCompact(&quot;orrs&quot;, &quot;orr&quot;, operands)
425         when &quot;oris&quot;
426             emitArmCompact(&quot;orrs&quot;, &quot;orrs&quot;, operands)
427         when &quot;xori&quot;, &quot;xorp&quot;
428             emitArmCompact(&quot;eors&quot;, &quot;eor&quot;, operands)
429         when &quot;lshifti&quot;, &quot;lshiftp&quot;
430             emitArmCompact(&quot;lsls&quot;, &quot;lsls&quot;, operands)
431         when &quot;rshifti&quot;, &quot;rshiftp&quot;
432             emitArmCompact(&quot;asrs&quot;, &quot;asrs&quot;, operands)
433         when &quot;urshifti&quot;, &quot;urshiftp&quot;
434             emitArmCompact(&quot;lsrs&quot;, &quot;lsrs&quot;, operands)
435         when &quot;muli&quot;, &quot;mulp&quot;
436             emitArm(&quot;mul&quot;, operands)
437         when &quot;subi&quot;, &quot;subp&quot;, &quot;subis&quot;
438             emitArmCompact(&quot;subs&quot;, &quot;subs&quot;, operands)
439         when &quot;negi&quot;, &quot;negp&quot;
440             $asm.puts &quot;rsbs #{operands[0].armOperand}, #{operands[0].armOperand}, \#0&quot;
441         when &quot;noti&quot;
442             $asm.puts &quot;mvns #{operands[0].armOperand}, #{operands[0].armOperand}&quot;
443         when &quot;loadi&quot;, &quot;loadis&quot;, &quot;loadp&quot;
444             $asm.puts &quot;ldr #{armFlippedOperands(operands)}&quot;
445         when &quot;storei&quot;, &quot;storep&quot;
446             $asm.puts &quot;str #{armOperands(operands)}&quot;
447         when &quot;loadb&quot;
448             $asm.puts &quot;ldrb #{armFlippedOperands(operands)}&quot;
449         when &quot;loadbsi&quot;
450             $asm.puts &quot;ldrsb.w #{armFlippedOperands(operands)}&quot;
451         when &quot;storeb&quot;
452             $asm.puts &quot;strb #{armOperands(operands)}&quot;
453         when &quot;loadh&quot;
454             $asm.puts &quot;ldrh #{armFlippedOperands(operands)}&quot;
455         when &quot;loadhsi&quot;
456             $asm.puts &quot;ldrsh.w #{armFlippedOperands(operands)}&quot;
457         when &quot;storeh&quot;
458             $asm.puts &quot;strh #{armOperands(operands)}&quot;
459         when &quot;loadd&quot;
460             $asm.puts &quot;vldr.64 #{armFlippedOperands(operands)}&quot;
461         when &quot;stored&quot;
462             $asm.puts &quot;vstr.64 #{armOperands(operands)}&quot;
463         when &quot;addd&quot;
464             emitArm(&quot;vadd.f64&quot;, operands)
465         when &quot;divd&quot;
466             emitArm(&quot;vdiv.f64&quot;, operands)
467         when &quot;subd&quot;
468             emitArm(&quot;vsub.f64&quot;, operands)
469         when &quot;muld&quot;
470             emitArm(&quot;vmul.f64&quot;, operands)
471         when &quot;sqrtd&quot;
472             $asm.puts &quot;vsqrt.f64 #{armFlippedOperands(operands)}&quot;
<a name="7" id="anc7"></a><span class="line-modified">473         when &quot;ci2ds&quot;</span>
474             $asm.puts &quot;vmov #{operands[1].armSingle}, #{operands[0].armOperand}&quot;
475             $asm.puts &quot;vcvt.f64.s32 #{operands[1].armOperand}, #{operands[1].armSingle}&quot;
476         when &quot;bdeq&quot;
477             emitArmDoubleBranch(&quot;beq&quot;, operands)
478         when &quot;bdneq&quot;
479             $asm.puts &quot;vcmpe.f64 #{armOperands(operands[0..1])}&quot;
480             $asm.puts &quot;vmrs apsr_nzcv, fpscr&quot;
481             isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
482             $asm.puts &quot;bvs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
483             $asm.puts &quot;bne #{operands[2].asmLabel}&quot;
484             isUnordered.lower(&quot;ARM&quot;)
485         when &quot;bdgt&quot;
486             emitArmDoubleBranch(&quot;bgt&quot;, operands)
487         when &quot;bdgteq&quot;
488             emitArmDoubleBranch(&quot;bge&quot;, operands)
489         when &quot;bdlt&quot;
490             emitArmDoubleBranch(&quot;bmi&quot;, operands)
491         when &quot;bdlteq&quot;
492             emitArmDoubleBranch(&quot;bls&quot;, operands)
493         when &quot;bdequn&quot;
494             $asm.puts &quot;vcmpe.f64 #{armOperands(operands[0..1])}&quot;
495             $asm.puts &quot;vmrs apsr_nzcv, fpscr&quot;
496             $asm.puts &quot;bvs #{operands[2].asmLabel}&quot;
497             $asm.puts &quot;beq #{operands[2].asmLabel}&quot;
498         when &quot;bdnequn&quot;
499             emitArmDoubleBranch(&quot;bne&quot;, operands)
500         when &quot;bdgtun&quot;
501             emitArmDoubleBranch(&quot;bhi&quot;, operands)
502         when &quot;bdgtequn&quot;
503             emitArmDoubleBranch(&quot;bpl&quot;, operands)
504         when &quot;bdltun&quot;
505             emitArmDoubleBranch(&quot;blt&quot;, operands)
506         when &quot;bdltequn&quot;
507             emitArmDoubleBranch(&quot;ble&quot;, operands)
508         when &quot;btd2i&quot;
509             # FIXME: may be a good idea to just get rid of this instruction, since the interpreter
510             # currently does not use it.
511             raise &quot;ARM does not support this opcode yet, #{codeOrigin}&quot;
512         when &quot;td2i&quot;
513             $asm.puts &quot;vcvt.s32.f64 #{ARM_SCRATCH_FPR.armSingle}, #{operands[0].armOperand}&quot;
514             $asm.puts &quot;vmov #{operands[1].armOperand}, #{ARM_SCRATCH_FPR.armSingle}&quot;
515         when &quot;bcd2i&quot;
516             $asm.puts &quot;vcvt.s32.f64 #{ARM_SCRATCH_FPR.armSingle}, #{operands[0].armOperand}&quot;
517             $asm.puts &quot;vmov #{operands[1].armOperand}, #{ARM_SCRATCH_FPR.armSingle}&quot;
518             $asm.puts &quot;vcvt.f64.s32 #{ARM_SCRATCH_FPR.armOperand}, #{ARM_SCRATCH_FPR.armSingle}&quot;
519             emitArmDoubleBranch(&quot;bne&quot;, [ARM_SCRATCH_FPR, operands[0], operands[2]])
520             $asm.puts &quot;tst #{operands[1].armOperand}, #{operands[1].armOperand}&quot;
521             $asm.puts &quot;beq #{operands[2].asmLabel}&quot;
522         when &quot;movdz&quot;
523             # FIXME: either support this or remove it.
524             raise &quot;ARM does not support this opcode yet, #{codeOrigin}&quot;
525         when &quot;pop&quot;
526             operands.each {
527                 | op |
528                 $asm.puts &quot;pop { #{op.armOperand} }&quot;
529             }
530         when &quot;push&quot;
531             operands.each {
532                 | op |
533                 $asm.puts &quot;push { #{op.armOperand} }&quot;
534             }
535         when &quot;move&quot;
536             if operands[0].immediate?
537                 armMoveImmediate(operands[0].value, operands[1])
538             else
539                 $asm.puts &quot;mov #{armFlippedOperands(operands)}&quot;
540             end
541         when &quot;mvlbl&quot;
542                 $asm.puts &quot;movw #{operands[1].armOperand}, \#:lower16:#{operands[0].value}&quot;
543                 $asm.puts &quot;movt #{operands[1].armOperand}, \#:upper16:#{operands[0].value}&quot;
544         when &quot;nop&quot;
545             $asm.puts &quot;nop&quot;
546         when &quot;bieq&quot;, &quot;bpeq&quot;, &quot;bbeq&quot;
547             if Immediate.new(nil, 0) == operands[0]
548                 $asm.puts &quot;tst #{operands[1].armOperand}, #{operands[1].armOperand}&quot;
549             elsif Immediate.new(nil, 0) == operands[1]
550                 $asm.puts &quot;tst #{operands[0].armOperand}, #{operands[0].armOperand}&quot;
551             else
552                 $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
553             end
554             $asm.puts &quot;beq #{operands[2].asmLabel}&quot;
555         when &quot;bineq&quot;, &quot;bpneq&quot;, &quot;bbneq&quot;
556             if Immediate.new(nil, 0) == operands[0]
557                 $asm.puts &quot;tst #{operands[1].armOperand}, #{operands[1].armOperand}&quot;
558             elsif Immediate.new(nil, 0) == operands[1]
559                 $asm.puts &quot;tst #{operands[0].armOperand}, #{operands[0].armOperand}&quot;
560             else
561                 $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
562             end
563             $asm.puts &quot;bne #{operands[2].asmLabel}&quot;
564         when &quot;bia&quot;, &quot;bpa&quot;, &quot;bba&quot;
565             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
566             $asm.puts &quot;bhi #{operands[2].asmLabel}&quot;
567         when &quot;biaeq&quot;, &quot;bpaeq&quot;, &quot;bbaeq&quot;
568             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
569             $asm.puts &quot;bhs #{operands[2].asmLabel}&quot;
570         when &quot;bib&quot;, &quot;bpb&quot;, &quot;bbb&quot;
571             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
572             $asm.puts &quot;blo #{operands[2].asmLabel}&quot;
573         when &quot;bibeq&quot;, &quot;bpbeq&quot;, &quot;bbbeq&quot;
574             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
575             $asm.puts &quot;bls #{operands[2].asmLabel}&quot;
576         when &quot;bigt&quot;, &quot;bpgt&quot;, &quot;bbgt&quot;
577             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
578             $asm.puts &quot;bgt #{operands[2].asmLabel}&quot;
579         when &quot;bigteq&quot;, &quot;bpgteq&quot;, &quot;bbgteq&quot;
580             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
581             $asm.puts &quot;bge #{operands[2].asmLabel}&quot;
582         when &quot;bilt&quot;, &quot;bplt&quot;, &quot;bblt&quot;
583             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
584             $asm.puts &quot;blt #{operands[2].asmLabel}&quot;
585         when &quot;bilteq&quot;, &quot;bplteq&quot;, &quot;bblteq&quot;
586             $asm.puts &quot;cmp #{armOperands(operands[0..1])}&quot;
587             $asm.puts &quot;ble #{operands[2].asmLabel}&quot;
588         when &quot;btiz&quot;, &quot;btpz&quot;, &quot;btbz&quot;
589             emitArmTest(operands)
590             $asm.puts &quot;beq #{operands[-1].asmLabel}&quot;
591         when &quot;btinz&quot;, &quot;btpnz&quot;, &quot;btbnz&quot;
592             emitArmTest(operands)
593             $asm.puts &quot;bne #{operands[-1].asmLabel}&quot;
594         when &quot;btis&quot;, &quot;btps&quot;, &quot;btbs&quot;
595             emitArmTest(operands)
596             $asm.puts &quot;bmi #{operands[-1].asmLabel}&quot;
597         when &quot;jmp&quot;
598             if operands[0].label?
599                 $asm.puts &quot;b #{operands[0].asmLabel}&quot;
600             else
601                 $asm.puts &quot;mov pc, #{operands[0].armOperand}&quot;
602             end
603         when &quot;call&quot;
604             if operands[0].label?
605                 if OS_DARWIN
606                     $asm.puts &quot;blx #{operands[0].asmLabel}&quot;
607                 else
608                     $asm.puts &quot;bl #{operands[0].asmLabel}&quot;
609                 end
610             else
611                 $asm.puts &quot;blx #{operands[0].armOperand}&quot;
612             end
613         when &quot;break&quot;
614             $asm.puts &quot;bkpt #0&quot;
615         when &quot;ret&quot;
616             $asm.puts &quot;bx lr&quot;
617         when &quot;cieq&quot;, &quot;cpeq&quot;, &quot;cbeq&quot;
618             emitArmCompare(operands, &quot;eq&quot;)
619         when &quot;cineq&quot;, &quot;cpneq&quot;, &quot;cbneq&quot;
620             emitArmCompare(operands, &quot;ne&quot;)
621         when &quot;cia&quot;, &quot;cpa&quot;, &quot;cba&quot;
622             emitArmCompare(operands, &quot;hi&quot;)
623         when &quot;ciaeq&quot;, &quot;cpaeq&quot;, &quot;cbaeq&quot;
624             emitArmCompare(operands, &quot;hs&quot;)
625         when &quot;cib&quot;, &quot;cpb&quot;, &quot;cbb&quot;
626             emitArmCompare(operands, &quot;lo&quot;)
627         when &quot;cibeq&quot;, &quot;cpbeq&quot;, &quot;cbbeq&quot;
628             emitArmCompare(operands, &quot;ls&quot;)
629         when &quot;cigt&quot;, &quot;cpgt&quot;, &quot;cbgt&quot;
630             emitArmCompare(operands, &quot;gt&quot;)
631         when &quot;cigteq&quot;, &quot;cpgteq&quot;, &quot;cbgteq&quot;
632             emitArmCompare(operands, &quot;ge&quot;)
633         when &quot;cilt&quot;, &quot;cplt&quot;, &quot;cblt&quot;
634             emitArmCompare(operands, &quot;lt&quot;)
635         when &quot;cilteq&quot;, &quot;cplteq&quot;, &quot;cblteq&quot;
636             emitArmCompare(operands, &quot;le&quot;)
637         when &quot;tis&quot;, &quot;tbs&quot;, &quot;tps&quot;
638             emitArmTestSet(operands, &quot;mi&quot;)
639         when &quot;tiz&quot;, &quot;tbz&quot;, &quot;tpz&quot;
640             emitArmTestSet(operands, &quot;eq&quot;)
641         when &quot;tinz&quot;, &quot;tbnz&quot;, &quot;tpnz&quot;
642             emitArmTestSet(operands, &quot;ne&quot;)
643         when &quot;peek&quot;
644             $asm.puts &quot;ldr #{operands[1].armOperand}, [sp, \##{operands[0].value * 4}]&quot;
645         when &quot;poke&quot;
646             $asm.puts &quot;str #{operands[1].armOperand}, [sp, \##{operands[0].value * 4}]&quot;
647         when &quot;fii2d&quot;
648             $asm.puts &quot;vmov #{operands[2].armOperand}, #{operands[0].armOperand}, #{operands[1].armOperand}&quot;
649         when &quot;fd2ii&quot;
650             $asm.puts &quot;vmov #{operands[1].armOperand}, #{operands[2].armOperand}, #{operands[0].armOperand}&quot;
651         when &quot;bo&quot;
652             $asm.puts &quot;bvs #{operands[0].asmLabel}&quot;
653         when &quot;bs&quot;
654             $asm.puts &quot;bmi #{operands[0].asmLabel}&quot;
655         when &quot;bz&quot;
656             $asm.puts &quot;beq #{operands[0].asmLabel}&quot;
657         when &quot;bnz&quot;
658             $asm.puts &quot;bne #{operands[0].asmLabel}&quot;
659         when &quot;leai&quot;, &quot;leap&quot;
660             operands[0].armEmitLea(operands[1])
661         when &quot;smulli&quot;
662             raise &quot;Wrong number of arguments to smull in #{self.inspect} at #{codeOriginString}&quot; unless operands.length == 4
663             $asm.puts &quot;smull #{operands[2].armOperand}, #{operands[3].armOperand}, #{operands[0].armOperand}, #{operands[1].armOperand}&quot;
664         when &quot;memfence&quot;
665             $asm.puts &quot;dmb sy&quot;
666         when &quot;clrbp&quot;
667             $asm.puts &quot;bic #{operands[2].armOperand}, #{operands[0].armOperand}, #{operands[1].armOperand}&quot;
668         when &quot;globaladdr&quot;
669             labelRef = operands[0]
670             dest = operands[1]
671             temp = operands[2]
672 
673             uid = $asm.newUID
674             gotLabel = Assembler.localLabelReference(&quot;offlineasm_arm_got_#{uid}&quot;)
675             offsetLabel = Assembler.localLabelReference(&quot;offlineasm_arm_got_offset_#{uid}&quot;)
676 
677             $asm.puts &quot;ldr #{dest.armOperand}, #{gotLabel}&quot;
678             $asm.puts &quot;ldr #{temp.armOperand}, #{gotLabel}+4&quot;
679             $asm.puts &quot;#{offsetLabel}:&quot;
680             $asm.puts &quot;add #{dest.armOperand}, pc, #{dest.armOperand}&quot;
681             $asm.puts &quot;ldr #{dest.armOperand}, [#{dest.armOperand}, #{temp.armOperand}]&quot;
682 
683             offset = 4
684 
685             $asm.deferNextLabelAction {
686                 $asm.puts &quot;#{gotLabel}:&quot;
687                 $asm.puts &quot;.word _GLOBAL_OFFSET_TABLE_-(#{offsetLabel}+#{offset})&quot;
688                 $asm.puts &quot;.word #{labelRef.asmLabel}(GOT)&quot;
689             }
690         else
691             lowerDefault
692         end
693     end
694 end
695 
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
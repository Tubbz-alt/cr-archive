<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/AsyncGeneratorPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AsyncFunctionPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BuiltinExecutableCreator.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/AsyncGeneratorPrototype.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2017 Oleksandr Skachkov &lt;gskachkov@gmail.com&gt;.
<span class="line-added">+  * Copyright (C) 2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,107 ***</span>
  @globalPrivate
  function asyncGeneratorQueueIsEmpty(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     return @getByIdDirectPrivate(generator, &quot;asyncGeneratorQueueLast&quot;) === null;</span>
  }
  
  @globalPrivate
  function asyncGeneratorQueueEnqueue(generator, item)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@getByIdDirectPrivate(item, &quot;asyncGeneratorQueueItemNext&quot;) === null &amp;&amp; @getByIdDirectPrivate(item, &quot;asyncGeneratorQueueItemPrevious&quot;) === null);</span>
  
<span class="line-modified">!     if (@getByIdDirectPrivate(generator, &quot;asyncGeneratorQueueFirst&quot;) === null) {</span>
<span class="line-modified">!         @assert(@getByIdDirectPrivate(generator, &quot;asyncGeneratorQueueLast&quot;) === null);</span>
  
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;asyncGeneratorQueueFirst&quot;, item);</span>
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;asyncGeneratorQueueLast&quot;, item);</span>
      } else {
<span class="line-modified">!         var last = @getByIdDirectPrivate(generator, &quot;asyncGeneratorQueueLast&quot;);</span>
<span class="line-removed">-         @putByIdDirectPrivate(item, &quot;asyncGeneratorQueueItemPrevious&quot;, last);</span>
          @putByIdDirectPrivate(last, &quot;asyncGeneratorQueueItemNext&quot;, item);
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;asyncGeneratorQueueLast&quot;, item);</span>
      }
  }
  
  @globalPrivate
  function asyncGeneratorQueueDequeue(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     const result = @getByIdDirectPrivate(generator, &quot;asyncGeneratorQueueFirst&quot;);</span>
<span class="line-modified">!     if (result === null)</span>
<span class="line-modified">!         return null;</span>
  
      var updatedFirst = @getByIdDirectPrivate(result, &quot;asyncGeneratorQueueItemNext&quot;);
<span class="line-modified">!     @putByIdDirectPrivate(generator, &quot;asyncGeneratorQueueFirst&quot;, updatedFirst);</span>
  
      if (updatedFirst === null)
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;asyncGeneratorQueueLast&quot;, null);</span>
  
      return result;
  }
  
<span class="line-removed">- @globalPrivate</span>
<span class="line-removed">- function asyncGeneratorDequeue(generator)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     &quot;use strict&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const queue = @getByIdDirectPrivate(generator, &quot;asyncGeneratorQueue&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @assert(!@asyncGeneratorQueueIsEmpty(generator), &quot;Async genetator&#39;s Queue is an empty List.&quot;);</span>
<span class="line-removed">-     </span>
<span class="line-removed">-     return @asyncGeneratorQueueDequeue(generator);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  @globalPrivate
  function isExecutionState(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var state = @getByIdDirectPrivate(generator, &quot;generatorState&quot;);</span>
<span class="line-modified">!     var reason = @getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;);</span>
      return (state &gt; 0 &amp;&amp; reason === @AsyncGeneratorSuspendReasonNone)
          || state === @AsyncGeneratorStateExecuting
          || reason === @AsyncGeneratorSuspendReasonAwait;
  }
  
  @globalPrivate
  function isSuspendYieldState(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var state = @getByIdDirectPrivate(generator, &quot;generatorState&quot;);</span>
<span class="line-modified">!     return (state &gt; 0 &amp;&amp; @getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;) === @AsyncGeneratorSuspendReasonYield)</span>
          || state === @AsyncGeneratorStateSuspendedYield;
  }
  
  @globalPrivate
  function asyncGeneratorReject(generator, exception)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(typeof @getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;) === &quot;number&quot;, &quot;Generator is not an AsyncGenerator instance.&quot;);</span>
  
<span class="line-modified">!     const { promiseCapability } = @asyncGeneratorDequeue(generator);</span>
<span class="line-modified">!     promiseCapability.@reject.@call(@undefined, exception);</span>
  
      return @asyncGeneratorResumeNext(generator);
  }
  
  @globalPrivate
  function asyncGeneratorResolve(generator, value, done)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(typeof @getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;) === &quot;number&quot;, &quot;Generator is not an AsyncGenerator instance.&quot;);</span>
  
<span class="line-modified">!     const { promiseCapability } = @asyncGeneratorDequeue(generator);</span>
<span class="line-modified">!     promiseCapability.@resolve.@call(@undefined, { value, done });</span>
  
      return @asyncGeneratorResumeNext(generator);
  }
  
  @globalPrivate
<span class="line-new-header">--- 27,96 ---</span>
  @globalPrivate
  function asyncGeneratorQueueIsEmpty(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     return @getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueFirst) === null;</span>
  }
  
  @globalPrivate
  function asyncGeneratorQueueEnqueue(generator, item)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@getByIdDirectPrivate(item, &quot;asyncGeneratorQueueItemNext&quot;) === null);</span>
  
<span class="line-modified">!     if (@getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueFirst) === null) {</span>
<span class="line-modified">!         @assert(@getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueLast) === null);</span>
  
<span class="line-modified">!         @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueFirst, item);</span>
<span class="line-modified">!         @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueLast, item);</span>
      } else {
<span class="line-modified">!         var last = @getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueLast);</span>
          @putByIdDirectPrivate(last, &quot;asyncGeneratorQueueItemNext&quot;, item);
<span class="line-modified">!         @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueLast, item);</span>
      }
  }
  
  @globalPrivate
  function asyncGeneratorQueueDequeue(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(!@asyncGeneratorQueueIsEmpty(generator), &quot;Async genetator&#39;s Queue is an empty List.&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     var result = @getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueFirst);</span>
  
      var updatedFirst = @getByIdDirectPrivate(result, &quot;asyncGeneratorQueueItemNext&quot;);
<span class="line-modified">!     @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueFirst, updatedFirst);</span>
  
      if (updatedFirst === null)
<span class="line-modified">!         @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueLast, null);</span>
  
      return result;
  }
  
  @globalPrivate
  function isExecutionState(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var state = @getAsyncGeneratorInternalField(generator, @generatorFieldState);</span>
<span class="line-modified">!     var reason = @getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason);</span>
      return (state &gt; 0 &amp;&amp; reason === @AsyncGeneratorSuspendReasonNone)
          || state === @AsyncGeneratorStateExecuting
          || reason === @AsyncGeneratorSuspendReasonAwait;
  }
  
  @globalPrivate
  function isSuspendYieldState(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var state = @getAsyncGeneratorInternalField(generator, @generatorFieldState);</span>
<span class="line-modified">!     return (state &gt; 0 &amp;&amp; @getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason) === @AsyncGeneratorSuspendReasonYield)</span>
          || state === @AsyncGeneratorStateSuspendedYield;
  }
  
  @globalPrivate
  function asyncGeneratorReject(generator, exception)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@isAsyncGenerator(generator), &quot;Generator is not an AsyncGenerator instance.&quot;);</span>
  
<span class="line-modified">!     var promise = @asyncGeneratorQueueDequeue(generator).promise;</span>
<span class="line-modified">!     @assert(@isPromise(promise));</span>
<span class="line-added">+     @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, exception);</span>
  
      return @asyncGeneratorResumeNext(generator);
  }
  
  @globalPrivate
  function asyncGeneratorResolve(generator, value, done)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@isAsyncGenerator(generator), &quot;Generator is not an AsyncGenerator instance.&quot;);</span>
  
<span class="line-modified">!     var promise = @asyncGeneratorQueueDequeue(generator).promise;</span>
<span class="line-modified">!     @assert(@isPromise(promise));</span>
<span class="line-added">+     @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value, done });</span>
  
      return @asyncGeneratorResumeNext(generator);
  }
  
  @globalPrivate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,116 ***</span>
  {
      &quot;use strict&quot;;
  
      function asyncGeneratorYieldAwaited(result)
      {
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;, @AsyncGeneratorSuspendReasonYield);</span>
          @asyncGeneratorResolve(generator, result, false);
      }
  
<span class="line-modified">!     @putByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;, @AsyncGeneratorSuspendReasonAwait);</span>
  
      @awaitValue(generator, value, asyncGeneratorYieldAwaited);
<span class="line-removed">- </span>
<span class="line-removed">-     return @undefined;</span>
  }
  
  @globalPrivate
<span class="line-modified">! function awaitValue(generator, value, onFullfiled)</span>
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     const wrappedValue = @newPromiseCapability(@Promise);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     const onRejected = function (result) { @doAsyncGeneratorBodyCall(generator, result, @GeneratorResumeModeThrow); };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     wrappedValue.@resolve.@call(@undefined, value);</span>
<span class="line-removed">-     wrappedValue.@promise.@then(onFullfiled, onRejected);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return wrappedValue;</span>
  }
  
  @globalPrivate
  function doAsyncGeneratorBodyCall(generator, resumeValue, resumeMode)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     let value = @undefined;</span>
<span class="line-modified">!     let state = @getByIdDirectPrivate(generator, &quot;generatorState&quot;);</span>
  
<span class="line-modified">!     @putByIdDirectPrivate(generator, &quot;generatorState&quot;, @AsyncGeneratorStateExecuting);</span>
<span class="line-modified">!     @putByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;, @AsyncGeneratorSuspendReasonNone);</span>
  
      try {
<span class="line-modified">!         value = @getByIdDirectPrivate(generator, &quot;generatorNext&quot;).@call(@getByIdDirectPrivate(generator, &quot;generatorThis&quot;), generator, state, resumeValue, resumeMode, @getByIdDirectPrivate(generator, &quot;generatorFrame&quot;));</span>
<span class="line-modified">!         if (@getByIdDirectPrivate(generator, &quot;generatorState&quot;) === @AsyncGeneratorStateExecuting)</span>
<span class="line-modified">!             @putByIdDirectPrivate(generator, &quot;generatorState&quot;, @AsyncGeneratorStateCompleted);</span>
      } catch (error) {
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;generatorState&quot;, @AsyncGeneratorStateCompleted);</span>
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;, @AsyncGeneratorSuspendReasonNone);</span>
  
          return @asyncGeneratorReject(generator, error);
      }
  
<span class="line-modified">!     if (@getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;) === @AsyncGeneratorSuspendReasonAwait) {</span>
<span class="line-modified">!         const onFulfilled = function(result) { @doAsyncGeneratorBodyCall(generator, result, @GeneratorResumeModeNormal); };</span>
  
          @awaitValue(generator, value, onFulfilled);
<span class="line-modified">! </span>
<span class="line-removed">-         return @undefined;</span>
      }
  
<span class="line-modified">!     if (@getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;) === @AsyncGeneratorSuspendReasonYield)</span>
          return @asyncGeneratorYield(generator, value, resumeMode);
  
<span class="line-modified">!     if (@getByIdDirectPrivate(generator, &quot;generatorState&quot;) === @AsyncGeneratorStateCompleted) {</span>
<span class="line-modified">!         @putByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;, @AsyncGeneratorSuspendReasonNone);</span>
          return @asyncGeneratorResolve(generator, value, true);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     return @undefined;</span>
  }
  
  @globalPrivate
  function asyncGeneratorResumeNext(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(typeof @getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;) === &quot;number&quot;, &quot;Generator is not an AsyncGenerator instance.&quot;);</span>
  
<span class="line-modified">!     let state = @getByIdDirectPrivate(generator, &quot;generatorState&quot;);</span>
  
      @assert(state !== @AsyncGeneratorStateExecuting, &quot;Async generator should not be in executing state&quot;);
  
      if (state === @AsyncGeneratorStateAwaitingReturn)
<span class="line-modified">!         return @undefined;</span>
  
      if (@asyncGeneratorQueueIsEmpty(generator))
<span class="line-modified">!         return @undefined;</span>
  
<span class="line-modified">!     const next = @getByIdDirectPrivate(generator, &quot;asyncGeneratorQueueFirst&quot;);</span>
  
      if (next.resumeMode !== @GeneratorResumeModeNormal) {
          if (state === @AsyncGeneratorStateSuspendedStart) {
<span class="line-modified">!             @putByIdDirectPrivate(generator, &quot;generatorState&quot;, @AsyncGeneratorStateCompleted);</span>
              state = @AsyncGeneratorStateCompleted;
          }
  
          if (state === @AsyncGeneratorStateCompleted) {
              if (next.resumeMode === @GeneratorResumeModeReturn) {
<span class="line-modified">!                 @putByIdDirectPrivate(generator, &quot;generatorState&quot;, @AsyncGeneratorStateAwaitingReturn);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 const promiseCapability = @newPromiseCapability(@Promise);</span>
<span class="line-modified">!                 promiseCapability.@resolve.@call(@undefined, next.value);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 const throwawayCapabilityPromise = promiseCapability.@promise.@then(</span>
<span class="line-modified">!                     function (result) { generator.@generatorState = @AsyncGeneratorStateCompleted; @asyncGeneratorResolve(generator, result, true); },</span>
<span class="line-modified">!                     function (error) { generator.@generatorState = @AsyncGeneratorStateCompleted; @asyncGeneratorReject(generator, error); });</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 @putByIdDirectPrivate(throwawayCapabilityPromise, &quot;promiseIsHandled&quot;, true);</span>
<span class="line-modified">! </span>
<span class="line-removed">-                 return @undefined;</span>
              }
  
              @assert(next.resumeMode === @GeneratorResumeModeThrow, &quot;Async generator has wrong mode&quot;);
  
              return @asyncGeneratorReject(generator, next.value);;
<span class="line-new-header">--- 124,109 ---</span>
  {
      &quot;use strict&quot;;
  
      function asyncGeneratorYieldAwaited(result)
      {
<span class="line-modified">!         @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason, @AsyncGeneratorSuspendReasonYield);</span>
          @asyncGeneratorResolve(generator, result, false);
      }
  
<span class="line-modified">!     @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason, @AsyncGeneratorSuspendReasonAwait);</span>
  
      @awaitValue(generator, value, asyncGeneratorYieldAwaited);
  }
  
  @globalPrivate
<span class="line-modified">! function awaitValue(generator, value, onFulfilled)</span>
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var onRejected = function (result) { @doAsyncGeneratorBodyCall(generator, result, @GeneratorResumeModeThrow); };</span>
<span class="line-modified">!     @resolveWithoutPromise(value, onFulfilled, onRejected);</span>
  }
  
  @globalPrivate
  function doAsyncGeneratorBodyCall(generator, resumeValue, resumeMode)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var value = @undefined;</span>
<span class="line-modified">!     var state = @getAsyncGeneratorInternalField(generator, @generatorFieldState);</span>
  
<span class="line-modified">!     @putAsyncGeneratorInternalField(generator, @generatorFieldState, @AsyncGeneratorStateExecuting);</span>
<span class="line-modified">!     @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason, @AsyncGeneratorSuspendReasonNone);</span>
  
      try {
<span class="line-modified">!         value = @getAsyncGeneratorInternalField(generator, @generatorFieldNext).@call(@getAsyncGeneratorInternalField(generator, @generatorFieldThis), generator, state, resumeValue, resumeMode, @getAsyncGeneratorInternalField(generator, @generatorFieldFrame));</span>
<span class="line-modified">!         state = @getAsyncGeneratorInternalField(generator, @generatorFieldState);</span>
<span class="line-modified">!         if (state === @AsyncGeneratorStateExecuting) {</span>
<span class="line-added">+             @putAsyncGeneratorInternalField(generator, @generatorFieldState, @AsyncGeneratorStateCompleted);</span>
<span class="line-added">+             state = @AsyncGeneratorStateCompleted;</span>
<span class="line-added">+         }</span>
      } catch (error) {
<span class="line-modified">!         @putAsyncGeneratorInternalField(generator, @generatorFieldState, @AsyncGeneratorStateCompleted);</span>
<span class="line-modified">!         @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason, @AsyncGeneratorSuspendReasonNone);</span>
  
          return @asyncGeneratorReject(generator, error);
      }
  
<span class="line-modified">!     var reason = @getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason);</span>
<span class="line-modified">!     if (reason === @AsyncGeneratorSuspendReasonAwait) {</span>
<span class="line-added">+         var onFulfilled = function(result) { @doAsyncGeneratorBodyCall(generator, result, @GeneratorResumeModeNormal); };</span>
  
          @awaitValue(generator, value, onFulfilled);
<span class="line-modified">!         return;</span>
      }
  
<span class="line-modified">!     if (reason === @AsyncGeneratorSuspendReasonYield)</span>
          return @asyncGeneratorYield(generator, value, resumeMode);
  
<span class="line-modified">!     if (state === @AsyncGeneratorStateCompleted) {</span>
<span class="line-modified">!         @assert(@getAsyncGeneratorInternalField(generator, @generatorFieldState) == @AsyncGeneratorStateCompleted);</span>
<span class="line-added">+         @putAsyncGeneratorInternalField(generator, @asyncGeneratorFieldSuspendReason, @AsyncGeneratorSuspendReasonNone);</span>
          return @asyncGeneratorResolve(generator, value, true);
      }
  }
  
  @globalPrivate
  function asyncGeneratorResumeNext(generator)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@isAsyncGenerator(generator), &quot;Generator is not an AsyncGenerator instance.&quot;);</span>
  
<span class="line-modified">!     var state = @getAsyncGeneratorInternalField(generator, @generatorFieldState);</span>
  
      @assert(state !== @AsyncGeneratorStateExecuting, &quot;Async generator should not be in executing state&quot;);
  
      if (state === @AsyncGeneratorStateAwaitingReturn)
<span class="line-modified">!         return;</span>
  
      if (@asyncGeneratorQueueIsEmpty(generator))
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     var next = @getAsyncGeneratorInternalField(generator, @asyncGeneratorFieldQueueFirst);</span>
  
      if (next.resumeMode !== @GeneratorResumeModeNormal) {
          if (state === @AsyncGeneratorStateSuspendedStart) {
<span class="line-modified">!             @putAsyncGeneratorInternalField(generator, @generatorFieldState, @AsyncGeneratorStateCompleted);</span>
              state = @AsyncGeneratorStateCompleted;
          }
  
          if (state === @AsyncGeneratorStateCompleted) {
              if (next.resumeMode === @GeneratorResumeModeReturn) {
<span class="line-modified">!                 @putAsyncGeneratorInternalField(generator, @generatorFieldState, @AsyncGeneratorStateAwaitingReturn);</span>
<span class="line-modified">!                 @resolveWithoutPromise(next.value,</span>
<span class="line-modified">!                     function (result) {</span>
<span class="line-modified">!                         @putAsyncGeneratorInternalField(generator, @generatorFieldState, @AsyncGeneratorStateCompleted);</span>
<span class="line-modified">!                         @asyncGeneratorResolve(generator, result, true);</span>
<span class="line-modified">!                     },</span>
<span class="line-modified">!                     function (error) {</span>
<span class="line-modified">!                         @putAsyncGeneratorInternalField(generator, @generatorFieldState, @AsyncGeneratorStateCompleted);</span>
<span class="line-modified">!                         @asyncGeneratorReject(generator, error);</span>
<span class="line-modified">!                     });</span>
<span class="line-modified">!                 return;</span>
              }
  
              @assert(next.resumeMode === @GeneratorResumeModeThrow, &quot;Async generator has wrong mode&quot;);
  
              return @asyncGeneratorReject(generator, next.value);;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,31 ***</span>
          return @asyncGeneratorResolve(generator, @undefined, true);
  
      @assert(state === @AsyncGeneratorStateSuspendedStart || @isSuspendYieldState(generator), &quot;Async generator has wrong state&quot;);
  
      @doAsyncGeneratorBodyCall(generator, next.value, next.resumeMode);
<span class="line-removed">- </span>
<span class="line-removed">-     return @undefined;</span>
  }
  
  @globalPrivate
  function asyncGeneratorEnqueue(generator, value, resumeMode)
  {
      &quot;use strict&quot;;
<span class="line-modified">!     </span>
<span class="line-modified">!     const promiseCapability = @newPromiseCapability(@Promise);</span>
<span class="line-modified">!     if (!@isObject(generator) || typeof @getByIdDirectPrivate(generator, &quot;asyncGeneratorSuspendReason&quot;) !== &#39;number&#39;) {</span>
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;|this| should be an async generator&#39;));</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
  
<span class="line-modified">!     @asyncGeneratorQueueEnqueue(generator, {resumeMode, value, promiseCapability, @asyncGeneratorQueueItemNext: null, @asyncGeneratorQueueItemPrevious: null});</span>
  
      if (!@isExecutionState(generator))
          @asyncGeneratorResumeNext(generator);
  
<span class="line-modified">!     return promiseCapability.@promise;</span>
  }
  
  function next(value)
  {
      &quot;use strict&quot;;
<span class="line-new-header">--- 235,29 ---</span>
          return @asyncGeneratorResolve(generator, @undefined, true);
  
      @assert(state === @AsyncGeneratorStateSuspendedStart || @isSuspendYieldState(generator), &quot;Async generator has wrong state&quot;);
  
      @doAsyncGeneratorBodyCall(generator, next.value, next.resumeMode);
  }
  
  @globalPrivate
  function asyncGeneratorEnqueue(generator, value, resumeMode)
  {
      &quot;use strict&quot;;
<span class="line-modified">! </span>
<span class="line-modified">!     var promise = @newPromise();</span>
<span class="line-modified">!     if (!@isAsyncGenerator(generator)) {</span>
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;|this| should be an async generator&#39;));</span>
<span class="line-modified">!         return promise;</span>
      }
  
<span class="line-modified">!     @asyncGeneratorQueueEnqueue(generator, {resumeMode, value, promise, @asyncGeneratorQueueItemNext: null});</span>
  
      if (!@isExecutionState(generator))
          @asyncGeneratorResumeNext(generator);
  
<span class="line-modified">!     return promise;</span>
  }
  
  function next(value)
  {
      &quot;use strict&quot;;
</pre>
<center><a href="AsyncFunctionPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BuiltinExecutableCreator.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
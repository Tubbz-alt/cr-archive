<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) Canon Inc. 2016
  3  * Copyright (C) 2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;AnimationTimeline.h&quot;
 29 
 30 #include &quot;Animation.h&quot;
 31 #include &quot;AnimationEffect.h&quot;
 32 #include &quot;AnimationList.h&quot;
 33 #include &quot;CSSAnimation.h&quot;
 34 #include &quot;CSSPropertyAnimation.h&quot;
 35 #include &quot;CSSTransition.h&quot;
 36 #include &quot;DocumentTimeline.h&quot;
 37 #include &quot;Element.h&quot;
 38 #include &quot;KeyframeEffect.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 39 #include &quot;KeyframeEffectStack.h&quot;</span>
 40 #include &quot;RenderStyle.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;StylePropertyShorthand.h&quot;
 43 #include &quot;StyleResolver.h&quot;
 44 #include &quot;WebAnimationUtilities.h&quot;
 45 #include &lt;wtf/text/TextStream.h&gt;
 46 #include &lt;wtf/text/WTFString.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 AnimationTimeline::AnimationTimeline()
 51 {
 52 }
 53 
 54 AnimationTimeline::~AnimationTimeline()
 55 {
 56 }
 57 
 58 void AnimationTimeline::forgetAnimation(WebAnimation* animation)
 59 {
 60     m_allAnimations.removeFirst(animation);
 61 }
 62 
 63 void AnimationTimeline::animationTimingDidChange(WebAnimation&amp; animation)
 64 {
<a name="2" id="anc2"></a><span class="line-added"> 65     updateGlobalPosition(animation);</span>
<span class="line-added"> 66 </span>
 67     if (m_animations.add(&amp;animation)) {
 68         m_allAnimations.append(makeWeakPtr(&amp;animation));
 69         auto* timeline = animation.timeline();
 70         if (timeline &amp;&amp; timeline != this)
 71             timeline-&gt;removeAnimation(animation);
 72     }
 73 }
 74 
<a name="3" id="anc3"></a><span class="line-added"> 75 void AnimationTimeline::updateGlobalPosition(WebAnimation&amp; animation)</span>
<span class="line-added"> 76 {</span>
<span class="line-added"> 77     static uint64_t s_globalPosition = 0;</span>
<span class="line-added"> 78     if (!animation.globalPosition() &amp;&amp; animation.canHaveGlobalPosition())</span>
<span class="line-added"> 79         animation.setGlobalPosition(++s_globalPosition);</span>
<span class="line-added"> 80 }</span>
<span class="line-added"> 81 </span>
 82 void AnimationTimeline::removeAnimation(WebAnimation&amp; animation)
 83 {
 84     ASSERT(!animation.timeline() || animation.timeline() == this);
 85     m_animations.remove(&amp;animation);
 86     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
<a name="4" id="anc4"></a><span class="line-modified"> 87         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target()) {</span>
 88             animationWasRemovedFromElement(animation, *target);
<a name="5" id="anc5"></a><span class="line-added"> 89             target-&gt;ensureKeyframeEffectStack().removeEffect(*downcast&lt;KeyframeEffect&gt;(animation.effect()));</span>
<span class="line-added"> 90         }</span>
 91     }
 92 }
 93 
 94 Optional&lt;double&gt; AnimationTimeline::bindingsCurrentTime()
 95 {
 96     auto time = currentTime();
 97     if (!time)
 98         return WTF::nullopt;
 99     return secondsToWebAnimationsAPITime(*time);
100 }
101 
102 void AnimationTimeline::animationWasAddedToElement(WebAnimation&amp; animation, Element&amp; element)
103 {
104     [&amp;] () -&gt; ElementToAnimationsMap&amp; {
105         if (is&lt;CSSTransition&gt;(animation) &amp;&amp; downcast&lt;CSSTransition&gt;(animation).owningElement())
106             return m_elementToCSSTransitionsMap;
107         if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation).owningElement())
108             return m_elementToCSSAnimationsMap;
109         return m_elementToAnimationsMap;
110     }().ensure(&amp;element, [] {
<a name="6" id="anc6"></a><span class="line-modified">111         return AnimationCollection { };</span>
112     }).iterator-&gt;value.add(&amp;animation);
113 }
114 
115 static inline bool removeCSSTransitionFromMap(CSSTransition&amp; transition, Element&amp; element, HashMap&lt;Element*, AnimationTimeline::PropertyToTransitionMap&gt;&amp; map)
116 {
117     auto iterator = map.find(&amp;element);
118     if (iterator == map.end())
119         return false;
120 
121     auto&amp; cssTransitionsByProperty = iterator-&gt;value;
122 
123     auto transitionIterator = cssTransitionsByProperty.find(transition.property());
124     if (transitionIterator == cssTransitionsByProperty.end() || transitionIterator-&gt;value != &amp;transition)
125         return false;
126 
127     cssTransitionsByProperty.remove(transitionIterator);
128 
129     if (cssTransitionsByProperty.isEmpty())
130         map.remove(&amp;element);
131     return true;
132 }
133 
134 static inline void removeAnimationFromMapForElement(WebAnimation&amp; animation, AnimationTimeline::ElementToAnimationsMap&amp; map, Element&amp; element)
135 {
136     auto iterator = map.find(&amp;element);
137     if (iterator == map.end())
138         return;
139 
140     auto&amp; animations = iterator-&gt;value;
141     animations.remove(&amp;animation);
142     if (!animations.size())
143         map.remove(iterator);
144 }
145 
146 void AnimationTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
147 {
148     removeAnimationFromMapForElement(animation, m_elementToCSSTransitionsMap, element);
149     removeAnimationFromMapForElement(animation, m_elementToCSSAnimationsMap, element);
150     removeAnimationFromMapForElement(animation, m_elementToAnimationsMap, element);
151 
<a name="7" id="anc7"></a><span class="line-modified">152     // Now, if we&#39;re dealing with a CSS Transition, we remove it from the m_elementToRunningCSSTransitionByCSSPropertyID map.</span>
<span class="line-modified">153     // We don&#39;t need to do this for CSS Animations because their timing can be set via CSS to end, which would cause this</span>
<span class="line-modified">154     // function to be called, but they should remain associated with their owning element until this is changed via a call</span>
<span class="line-added">155     // to the JS API or changing the target element&#39;s animation-name property.</span>
<span class="line-added">156     if (is&lt;CSSTransition&gt;(animation))</span>
157         removeDeclarativeAnimationFromListsForOwningElement(animation, element);
158 }
159 
160 void AnimationTimeline::removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&amp; animation, Element&amp; element)
161 {
162     ASSERT(is&lt;DeclarativeAnimation&gt;(animation));
163 
<a name="8" id="anc8"></a><span class="line-modified">164     if (is&lt;CSSTransition&gt;(animation)) {</span>









165         auto&amp; transition = downcast&lt;CSSTransition&gt;(animation);
166         if (!removeCSSTransitionFromMap(transition, element, m_elementToRunningCSSTransitionByCSSPropertyID))
167             removeCSSTransitionFromMap(transition, element, m_elementToCompletedCSSTransitionByCSSPropertyID);
168     }
169 }
170 
171 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; AnimationTimeline::animationsForElement(Element&amp; element, Ordering ordering) const
172 {
173     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
<a name="9" id="anc9"></a><span class="line-modified">174 </span>
<span class="line-modified">175     if (ordering == Ordering::Sorted) {</span>
<span class="line-modified">176         if (element.hasKeyframeEffects()) {</span>
<span class="line-modified">177             for (auto&amp; effect : element.ensureKeyframeEffectStack().sortedEffects())</span>
<span class="line-modified">178                 animations.append(effect-&gt;animation());</span>
<span class="line-modified">179         }</span>
<span class="line-modified">180     } else {</span>
<span class="line-modified">181         if (m_elementToCSSTransitionsMap.contains(&amp;element)) {</span>
<span class="line-modified">182             const auto&amp; cssTransitions = m_elementToCSSTransitionsMap.get(&amp;element);</span>







183             animations.appendRange(cssTransitions.begin(), cssTransitions.end());
<a name="10" id="anc10"></a><span class="line-added">184         }</span>
<span class="line-added">185         if (m_elementToCSSAnimationsMap.contains(&amp;element)) {</span>
<span class="line-added">186             const auto&amp; cssAnimations = m_elementToCSSAnimationsMap.get(&amp;element);</span>
<span class="line-added">187             animations.appendRange(cssAnimations.begin(), cssAnimations.end());</span>
<span class="line-added">188         }</span>
<span class="line-added">189         if (m_elementToAnimationsMap.contains(&amp;element)) {</span>
<span class="line-added">190             const auto&amp; webAnimations = m_elementToAnimationsMap.get(&amp;element);</span>
<span class="line-added">191             animations.appendRange(webAnimations.begin(), webAnimations.end());</span>
<span class="line-added">192         }</span>
193     }
<a name="11" id="anc11"></a><span class="line-modified">194 </span>
<span class="line-modified">195     return animations;</span>
<span class="line-modified">196 }</span>
<span class="line-added">197 </span>
<span class="line-added">198 void AnimationTimeline::removeCSSAnimationCreatedByMarkup(Element&amp; element, CSSAnimation&amp; cssAnimation)</span>
<span class="line-added">199 {</span>
<span class="line-added">200     auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);</span>
<span class="line-added">201     if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {</span>
<span class="line-added">202         auto&amp; cssAnimations = iterator-&gt;value;</span>
<span class="line-added">203         cssAnimations.remove(&amp;cssAnimation);</span>
<span class="line-added">204         if (!cssAnimations.size())</span>
<span class="line-added">205             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);</span>
206     }
<a name="12" id="anc12"></a><span class="line-modified">207 </span>
<span class="line-modified">208     if (!element.hasKeyframeEffects())</span>
<span class="line-modified">209         return;</span>
<span class="line-added">210 </span>
<span class="line-added">211     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();</span>
<span class="line-added">212     auto* cssAnimationList = keyframeEffectStack.cssAnimationList();</span>
<span class="line-added">213     if (!cssAnimationList || cssAnimationList-&gt;isEmpty())</span>
<span class="line-added">214         return;</span>
<span class="line-added">215 </span>
<span class="line-added">216     auto&amp; backingAnimation = cssAnimation.backingAnimation();</span>
<span class="line-added">217     for (size_t i = 0; i &lt; cssAnimationList-&gt;size(); ++i) {</span>
<span class="line-added">218         if (cssAnimationList-&gt;animation(i) == backingAnimation) {</span>
<span class="line-added">219             auto newAnimationList = cssAnimationList-&gt;copy();</span>
<span class="line-added">220             newAnimationList-&gt;remove(i);</span>
<span class="line-added">221             keyframeEffectStack.setCSSAnimationList(WTFMove(newAnimationList));</span>
<span class="line-added">222             return;</span>
<span class="line-added">223         }</span>
<span class="line-added">224     }</span>
<span class="line-added">225 }</span>
<span class="line-added">226 </span>
<span class="line-added">227 void AnimationTimeline::willDestroyRendererForElement(Element&amp; element)</span>
<span class="line-added">228 {</span>
<span class="line-added">229     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))</span>
<span class="line-added">230         cssTransition-&gt;cancel(WebAnimation::Silently::Yes);</span>
<span class="line-added">231 </span>
<span class="line-added">232     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-added">233         if (is&lt;CSSAnimation&gt;(cssAnimation))</span>
<span class="line-added">234             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));</span>
<span class="line-added">235         cssAnimation-&gt;cancel(WebAnimation::Silently::Yes);</span>
236     }
<a name="13" id="anc13"></a>
237 }
238 
239 void AnimationTimeline::elementWasRemoved(Element&amp; element)
240 {
<a name="14" id="anc14"></a><span class="line-modified">241     willDestroyRendererForElement(element);</span>
<span class="line-modified">242 </span>
<span class="line-added">243     m_elementToAnimationsMap.remove(&amp;element);</span>
<span class="line-added">244     m_elementToCSSAnimationsMap.remove(&amp;element);</span>
<span class="line-added">245     m_elementToCSSTransitionsMap.remove(&amp;element);</span>
<span class="line-added">246     m_elementToRunningCSSTransitionByCSSPropertyID.remove(&amp;element);</span>
<span class="line-added">247     m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);</span>
248 }
249 
250 void AnimationTimeline::removeAnimationsForElement(Element&amp; element)
251 {
252     for (auto&amp; animation : animationsForElement(element))
253         animation-&gt;remove();
254 }
255 
<a name="15" id="anc15"></a><span class="line-added">256 void AnimationTimeline::willChangeRendererForElement(Element&amp; element)</span>
<span class="line-added">257 {</span>
<span class="line-added">258     for (auto&amp; animation : animationsForElement(element))</span>
<span class="line-added">259         animation-&gt;willChangeRenderer();</span>
<span class="line-added">260 }</span>
<span class="line-added">261 </span>
262 void AnimationTimeline::cancelDeclarativeAnimationsForElement(Element&amp; element)
263 {
264     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
265         cssTransition-&gt;cancel();
<a name="16" id="anc16"></a><span class="line-modified">266     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-added">267         if (is&lt;CSSAnimation&gt;(cssAnimation))</span>
<span class="line-added">268             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));</span>
269         cssAnimation-&gt;cancel();
<a name="17" id="anc17"></a><span class="line-added">270     }</span>
271 }
272 
273 static bool shouldConsiderAnimation(Element&amp; element, const Animation&amp; animation)
274 {
275     if (!animation.isValidAnimation())
276         return false;
277 
278     static NeverDestroyed&lt;const String&gt; animationNameNone(MAKE_STATIC_STRING_IMPL(&quot;none&quot;));
279 
280     auto&amp; name = animation.name();
281     if (name == animationNameNone || name.isEmpty())
282         return false;
283 
284     if (auto* styleScope = Style::Scope::forOrdinal(element, animation.nameStyleScopeOrdinal()))
285         return styleScope-&gt;resolver().isAnimationNameValid(name);
286 
287     return false;
288 }
289 
290 void AnimationTimeline::updateCSSAnimationsForElement(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; afterChangeStyle)
291 {
<a name="18" id="anc18"></a><span class="line-added">292     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();</span>
<span class="line-added">293 </span>
294     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its animations and disregard new ones.
<a name="19" id="anc19"></a><span class="line-modified">295     if (currentStyle &amp;&amp; currentStyle-&gt;display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">296         auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);</span>
<span class="line-modified">297         if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {</span>
<span class="line-modified">298             auto&amp; cssAnimations = iterator-&gt;value;</span>
<span class="line-added">299             for (auto&amp; cssAnimation : cssAnimations)</span>
<span class="line-added">300                 cssAnimation-&gt;cancelFromStyle();</span>
<span class="line-added">301             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);</span>
302         }
<a name="20" id="anc20"></a><span class="line-added">303         keyframeEffectStack.setCSSAnimationList(nullptr);</span>
304         return;
305     }
306 
<a name="21" id="anc21"></a><span class="line-modified">307     auto* currentAnimationList = afterChangeStyle.animations();</span>
<span class="line-added">308     auto* previousAnimationList = keyframeEffectStack.cssAnimationList();</span>
<span class="line-added">309     if (previousAnimationList &amp;&amp; !previousAnimationList-&gt;isEmpty() &amp;&amp; afterChangeStyle.hasAnimations() &amp;&amp; *(previousAnimationList) == *(afterChangeStyle.animations()))</span>
310         return;
311 
<a name="22" id="anc22"></a><span class="line-modified">312     CSSAnimationCollection newAnimations;</span>
<span class="line-modified">313     auto&amp; previousAnimations = m_elementToCSSAnimationsCreatedByMarkupMap.ensure(&amp;element, [] {</span>
<span class="line-modified">314         return CSSAnimationCollection { };</span>











315     }).iterator-&gt;value;
316 
<a name="23" id="anc23"></a><span class="line-modified">317     // https://www.w3.org/TR/css-animations-1/#animations</span>
<span class="line-modified">318     // The same @keyframes rule name may be repeated within an animation-name. Changes to the animation-name update existing</span>
<span class="line-modified">319     // animations by iterating over the new list of animations from last to first, and, for each animation, finding the last</span>
<span class="line-modified">320     // matching animation in the list of existing animations. If a match is found, the existing animation is updated using the</span>
<span class="line-modified">321     // animation properties corresponding to its position in the new list of animations, whilst maintaining its current playback</span>
<span class="line-modified">322     // time as described above. The matching animation is removed from the existing list of animations such that it will not match</span>
<span class="line-modified">323     // twice. If a match is not found, a new animation is created. As a result, updating animation-name from ‘a’ to ‘a, a’ will</span>
<span class="line-modified">324     // cause the existing animation for ‘a’ to become the second animation in the list and a new animation will be created for the</span>
<span class="line-modified">325     // first item in the list.</span>
<span class="line-modified">326     if (currentAnimationList) {</span>
<span class="line-modified">327         for (size_t i = currentAnimationList-&gt;size(); i &gt; 0; --i) {</span>
<span class="line-modified">328             auto&amp; currentAnimation = currentAnimationList-&gt;animation(i - 1);</span>
<span class="line-modified">329             if (!shouldConsiderAnimation(element, currentAnimation))</span>
<span class="line-added">330                 continue;</span>
<span class="line-added">331 </span>
<span class="line-added">332             bool foundMatchingAnimation = false;</span>
<span class="line-added">333             for (auto&amp; previousAnimation : previousAnimations) {</span>
<span class="line-added">334                 if (previousAnimation-&gt;animationName() == currentAnimation.name()) {</span>
<span class="line-added">335                     // Timing properties or play state may have changed so we need to update the backing animation with</span>
<span class="line-added">336                     // the Animation found in the current style.</span>
<span class="line-added">337                     previousAnimation-&gt;setBackingAnimation(currentAnimation);</span>
<span class="line-added">338                     newAnimations.add(previousAnimation);</span>
<span class="line-added">339                     // Remove the matched animation from the list of previous animations so we may not match it again.</span>
<span class="line-added">340                     previousAnimations.remove(previousAnimation);</span>
<span class="line-added">341                     foundMatchingAnimation = true;</span>
<span class="line-added">342                     break;</span>
<span class="line-added">343                 }</span>
344             }
<a name="24" id="anc24"></a><span class="line-modified">345 </span>
<span class="line-modified">346             if (!foundMatchingAnimation)</span>
<span class="line-added">347                 newAnimations.add(CSSAnimation::create(element, currentAnimation, currentStyle, afterChangeStyle));</span>
348         }
349     }
350 
<a name="25" id="anc25"></a><span class="line-modified">351     // Any animation found in previousAnimations but not found in newAnimations is not longer current and should be canceled.</span>
<span class="line-modified">352     for (auto&amp; previousAnimation : previousAnimations) {</span>
<span class="line-modified">353         if (!newAnimations.contains(previousAnimation)) {</span>
<span class="line-modified">354             if (previousAnimation-&gt;owningElement())</span>
<span class="line-modified">355                 previousAnimation-&gt;cancelFromStyle();</span>
<span class="line-added">356         }</span>
357     }
<a name="26" id="anc26"></a><span class="line-added">358 </span>
<span class="line-added">359     if (newAnimations.isEmpty())</span>
<span class="line-added">360         m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);</span>
<span class="line-added">361     else</span>
<span class="line-added">362         m_elementToCSSAnimationsCreatedByMarkupMap.set(&amp;element, WTFMove(newAnimations));</span>
<span class="line-added">363 </span>
<span class="line-added">364     keyframeEffectStack.setCSSAnimationList(currentAnimationList);</span>
365 }
366 
<a name="27" id="anc27"></a><span class="line-modified">367 static KeyframeEffect* keyframeEffectForElementAndProperty(Element&amp; element, CSSPropertyID property)</span>
368 {
<a name="28" id="anc28"></a><span class="line-modified">369     if (auto* keyframeEffectStack = element.keyframeEffectStack()) {</span>
<span class="line-modified">370         auto effects = keyframeEffectStack-&gt;sortedEffects();</span>
<span class="line-modified">371         for (const auto&amp; effect : makeReversedRange(effects)) {</span>
<span class="line-modified">372             if (effect-&gt;animatesProperty(property))</span>
<span class="line-modified">373                 return effect.get();</span>
<span class="line-added">374         }</span>
375     }
<a name="29" id="anc29"></a><span class="line-modified">376 </span>
<span class="line-added">377     return nullptr;</span>
378 }
379 
380 static bool propertyInStyleMatchesValueForTransitionInMap(CSSPropertyID property, const RenderStyle&amp; style, AnimationTimeline::PropertyToTransitionMap&amp; transitions)
381 {
382     if (auto* transition = transitions.get(property)) {
383         if (CSSPropertyAnimation::propertiesEqual(property, &amp;style, &amp;transition-&gt;targetStyle()))
384             return true;
385     }
386     return false;
387 }
388 
389 static double transitionCombinedDuration(const Animation* transition)
390 {
391     return std::max(0.0, transition-&gt;duration()) + transition-&gt;delay();
392 }
393 
394 static bool transitionMatchesProperty(const Animation&amp; transition, CSSPropertyID property)
395 {
396     auto mode = transition.animationMode();
397     if (mode == Animation::AnimateNone || mode == Animation::AnimateUnknownProperty)
398         return false;
399     if (mode == Animation::AnimateSingleProperty) {
400         auto transitionProperty = transition.property();
401         if (transitionProperty != property) {
402             auto shorthand = shorthandForProperty(transitionProperty);
403             for (size_t i = 0; i &lt; shorthand.length(); ++i) {
404                 if (shorthand.properties()[i] == property)
405                     return true;
406             }
407             return false;
408         }
409     }
410     return true;
411 }
412 
413 AnimationTimeline::PropertyToTransitionMap&amp; AnimationTimeline::ensureRunningTransitionsByProperty(Element&amp; element)
414 {
415     return m_elementToRunningCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
416         return PropertyToTransitionMap { };
417     }).iterator-&gt;value;
418 }
419 
<a name="30" id="anc30"></a><span class="line-modified">420 static void compileTransitionPropertiesInStyle(const RenderStyle&amp; style, HashSet&lt;CSSPropertyID&gt;&amp; transitionProperties, bool&amp; transitionPropertiesContainAll)</span>
421 {
<a name="31" id="anc31"></a><span class="line-modified">422     if (transitionPropertiesContainAll)</span>





423         return;
<a name="32" id="anc32"></a>



424 
<a name="33" id="anc33"></a><span class="line-modified">425     auto* transitions = style.transitions();</span>
<span class="line-added">426     if (!transitions)</span>
<span class="line-added">427         return;</span>
428 
<a name="34" id="anc34"></a><span class="line-modified">429     for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-modified">430         const auto&amp; animation = transitions-&gt;animation(i);</span>
<span class="line-modified">431         auto mode = animation.animationMode();</span>
<span class="line-added">432         if (mode == Animation::AnimateSingleProperty) {</span>
<span class="line-added">433             auto property = animation.property();</span>
<span class="line-added">434             if (isShorthandCSSProperty(property)) {</span>
<span class="line-added">435                 auto shorthand = shorthandForProperty(property);</span>
<span class="line-added">436                 for (size_t j = 0; j &lt; shorthand.length(); ++j)</span>
<span class="line-added">437                     transitionProperties.add(shorthand.properties()[j]);</span>
<span class="line-added">438             } else if (property != CSSPropertyInvalid)</span>
<span class="line-added">439                 transitionProperties.add(property);</span>
<span class="line-added">440         } else if (mode == Animation::AnimateAll) {</span>
<span class="line-added">441             transitionPropertiesContainAll = true;</span>
<span class="line-added">442             return;</span>
<span class="line-added">443         }</span>
<span class="line-added">444     }</span>
<span class="line-added">445 }</span>
446 
<a name="35" id="anc35"></a><span class="line-modified">447 void AnimationTimeline::updateCSSTransitionsForElementAndProperty(Element&amp; element, CSSPropertyID property, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle, AnimationTimeline::PropertyToTransitionMap&amp; runningTransitionsByProperty, PropertyToTransitionMap&amp; completedTransitionsByProperty, const MonotonicTime generationTime)</span>
<span class="line-added">448 {</span>
<span class="line-added">449     const Animation* matchingBackingAnimation = nullptr;</span>
<span class="line-added">450     if (auto* transitions = afterChangeStyle.transitions()) {</span>
<span class="line-added">451         for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-added">452             auto&amp; backingAnimation = transitions-&gt;animation(i);</span>
<span class="line-added">453             if (transitionMatchesProperty(backingAnimation, property))</span>
<span class="line-added">454                 matchingBackingAnimation = &amp;backingAnimation;</span>
<span class="line-added">455         }</span>
<span class="line-added">456     }</span>
457 
<a name="36" id="anc36"></a><span class="line-modified">458     // https://drafts.csswg.org/css-transitions-1/#before-change-style</span>
<span class="line-modified">459     // Define the before-change style as the computed values of all properties on the element as of the previous style change event, except with</span>
<span class="line-modified">460     // any styles derived from declarative animations such as CSS Transitions, CSS Animations, and SMIL Animations updated to the current time.</span>
<span class="line-modified">461     bool hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-modified">462     auto beforeChangeStyle = [&amp;]() {</span>
<span class="line-modified">463         if (hasRunningTransition &amp;&amp; CSSPropertyAnimation::animationOfPropertyIsAccelerated(property)) {</span>
<span class="line-modified">464             // In case we have an accelerated transition running for this element, we need to get its computed style as the before-change style</span>
<span class="line-modified">465             // since otherwise the animated value for that property won&#39;t be visible.</span>
<span class="line-modified">466             auto* runningTransition = runningTransitionsByProperty.get(property);</span>
<span class="line-modified">467             if (is&lt;KeyframeEffect&gt;(runningTransition-&gt;effect())) {</span>
<span class="line-modified">468                 auto&amp; keyframeEffect = *downcast&lt;KeyframeEffect&gt;(runningTransition-&gt;effect());</span>
<span class="line-modified">469                 if (keyframeEffect.isRunningAccelerated()) {</span>
<span class="line-modified">470                     auto animatedStyle = RenderStyle::clone(currentStyle);</span>
<span class="line-added">471                     runningTransition-&gt;resolve(animatedStyle);</span>
<span class="line-added">472                     return animatedStyle;</span>
<span class="line-added">473                 }</span>
474             }
475         }
476 
<a name="37" id="anc37"></a><span class="line-modified">477         if (auto* keyframeEffect = keyframeEffectForElementAndProperty(element, property)) {</span>
<span class="line-modified">478             // If we already have a keyframe effect targeting this property, we should use its unanimated style to determine what the potential</span>
<span class="line-modified">479             // start value of the transition shoud be to make sure that we don&#39;t account for animated values that would have been blended onto</span>
<span class="line-modified">480             // the style applied during the last style resolution.</span>
<span class="line-modified">481             if (auto* unanimatedStyle = keyframeEffect-&gt;unanimatedStyle())</span>
<span class="line-modified">482                 return RenderStyle::clone(*unanimatedStyle);</span>
<span class="line-modified">483 </span>
<span class="line-modified">484             // If we have a keyframe effect targeting this property, but it doesn&#39;t yet have an unanimated style, this is because it has not</span>
<span class="line-modified">485             // had a chance to apply itself with a non-null progress. In this case, the before-change and after-change styles should be the</span>
<span class="line-modified">486             // same in order to prevent a transition from being triggered as the unanimated style for this keyframe effect will most likely</span>
<span class="line-modified">487             // be this after-change style, or any future style change that may happen before the keyframe effect starts blending animated values.</span>
<span class="line-modified">488             return RenderStyle::clone(afterChangeStyle);</span>
<span class="line-modified">489         }</span>
<span class="line-modified">490 </span>
<span class="line-modified">491         // In any other scenario, the before-change style should be the previously resolved style for this element.</span>
<span class="line-modified">492         return RenderStyle::clone(currentStyle);</span>
<span class="line-modified">493     }();</span>
<span class="line-modified">494 </span>
<span class="line-modified">495     if (!hasRunningTransition</span>
<span class="line-added">496         &amp;&amp; !CSSPropertyAnimation::propertiesEqual(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-added">497         &amp;&amp; CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-added">498         &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)</span>
<span class="line-added">499         &amp;&amp; matchingBackingAnimation &amp;&amp; transitionCombinedDuration(matchingBackingAnimation) &gt; 0) {</span>
<span class="line-added">500         // 1. If all of the following are true:</span>
<span class="line-added">501         //   - the element does not have a running transition for the property,</span>
<span class="line-added">502         //   - the before-change style is different from and can be interpolated with the after-change style for that property,</span>
<span class="line-added">503         //   - the element does not have a completed transition for the property or the end value of the completed transition is different from the after-change style for the property,</span>
<span class="line-added">504         //   - there is a matching transition-property value, and</span>
<span class="line-added">505         //   - the combined duration is greater than 0s,</span>
<span class="line-added">506 </span>
<span class="line-added">507         // then implementations must remove the completed transition (if present) from the set of completed transitions</span>
<span class="line-added">508         completedTransitionsByProperty.remove(property);</span>
<span class="line-added">509 </span>
<span class="line-added">510         // and start a transition whose:</span>
<span class="line-added">511         //   - start time is the time of the style change event plus the matching transition delay,</span>
<span class="line-added">512         //   - end time is the start time plus the matching transition duration,</span>
<span class="line-added">513         //   - start value is the value of the transitioning property in the before-change style,</span>
<span class="line-added">514         //   - end value is the value of the transitioning property in the after-change style,</span>
<span class="line-added">515         //   - reversing-adjusted start value is the same as the start value, and</span>
<span class="line-added">516         //   - reversing shortening factor is 1.</span>
<span class="line-added">517         auto delay = Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-added">518         auto duration = Seconds(matchingBackingAnimation-&gt;duration());</span>
<span class="line-added">519         auto&amp; reversingAdjustedStartStyle = beforeChangeStyle;</span>
<span class="line-added">520         auto reversingShorteningFactor = 1;</span>
<span class="line-added">521         runningTransitionsByProperty.set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;beforeChangeStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-added">522     } else if (completedTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)) {</span>
<span class="line-added">523         // 2. Otherwise, if the element has a completed transition for the property and the end value of the completed transition is different from</span>
<span class="line-added">524         //    the after-change style for the property, then implementations must remove the completed transition from the set of completed transitions.</span>
<span class="line-added">525         completedTransitionsByProperty.remove(property);</span>
<span class="line-added">526     }</span>
<span class="line-added">527 </span>
<span class="line-added">528     hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-added">529     if ((hasRunningTransition || completedTransitionsByProperty.contains(property)) &amp;&amp; !matchingBackingAnimation) {</span>
<span class="line-added">530         // 3. If the element has a running transition or completed transition for the property, and there is not a matching transition-property</span>
<span class="line-added">531         //    value, then implementations must cancel the running transition or remove the completed transition from the set of completed transitions.</span>
<span class="line-added">532         if (hasRunningTransition)</span>
<span class="line-added">533             runningTransitionsByProperty.take(property)-&gt;cancel();</span>
<span class="line-added">534         else</span>
535             completedTransitionsByProperty.remove(property);
<a name="38" id="anc38"></a><span class="line-added">536     }</span>
<span class="line-added">537 </span>
<span class="line-added">538     if (matchingBackingAnimation &amp;&amp; runningTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, runningTransitionsByProperty)) {</span>
<span class="line-added">539         auto previouslyRunningTransition = runningTransitionsByProperty.take(property);</span>
<span class="line-added">540         auto&amp; previouslyRunningTransitionCurrentStyle = previouslyRunningTransition-&gt;currentStyle();</span>
<span class="line-added">541         // 4. If the element has a running transition for the property, there is a matching transition-property value, and the end value of the running</span>
<span class="line-added">542         //    transition is not equal to the value of the property in the after-change style, then:</span>
<span class="line-added">543         if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;currentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-added">544             // 1. If the current value of the property in the running transition is equal to the value of the property in the after-change style,</span>
<span class="line-added">545             //    or if these two values cannot be interpolated, then implementations must cancel the running transition.</span>
<span class="line-added">546             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">547         } else if (transitionCombinedDuration(matchingBackingAnimation) &lt;= 0.0 || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-added">548             // 2. Otherwise, if the combined duration is less than or equal to 0s, or if the current value of the property in the running transition</span>
<span class="line-added">549             //    cannot be interpolated with the value of the property in the after-change style, then implementations must cancel the running transition.</span>
<span class="line-added">550             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">551         } else if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransition-&gt;reversingAdjustedStartStyle(), &amp;afterChangeStyle)) {</span>
<span class="line-added">552             // 3. Otherwise, if the reversing-adjusted start value of the running transition is the same as the value of the property in the after-change</span>
<span class="line-added">553             //    style (see the section on reversing of transitions for why these case exists), implementations must cancel the running transition</span>
<span class="line-added">554             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">555 </span>
<span class="line-added">556             // and start a new transition whose:</span>
<span class="line-added">557             //   - reversing-adjusted start value is the end value of the running transition,</span>
<span class="line-added">558             //   - reversing shortening factor is the absolute value, clamped to the range [0, 1], of the sum of:</span>
<span class="line-added">559             //       1. the output of the timing function of the old transition at the time of the style change event, times the reversing shortening factor of the old transition</span>
<span class="line-added">560             //       2. 1 minus the reversing shortening factor of the old transition.</span>
<span class="line-added">561             //   - start time is the time of the style change event plus:</span>
<span class="line-added">562             //       1. if the matching transition delay is nonnegative, the matching transition delay, or</span>
<span class="line-added">563             //       2. if the matching transition delay is negative, the product of the new transition’s reversing shortening factor and the matching transition delay,</span>
<span class="line-added">564             //   - end time is the start time plus the product of the matching transition duration and the new transition’s reversing shortening factor,</span>
<span class="line-added">565             //   - start value is the current value of the property in the running transition,</span>
<span class="line-added">566             //   - end value is the value of the property in the after-change style</span>
<span class="line-added">567             auto&amp; reversingAdjustedStartStyle = previouslyRunningTransition-&gt;targetStyle();</span>
<span class="line-added">568             double transformedProgress = 1;</span>
<span class="line-added">569             if (auto* effect = previouslyRunningTransition-&gt;effect()) {</span>
<span class="line-added">570                 if (auto computedTimingProgress = effect-&gt;getComputedTiming().progress)</span>
<span class="line-added">571                     transformedProgress = *computedTimingProgress;</span>
<span class="line-added">572             }</span>
<span class="line-added">573             auto reversingShorteningFactor = std::max(std::min(((transformedProgress * previouslyRunningTransition-&gt;reversingShorteningFactor()) + (1 - previouslyRunningTransition-&gt;reversingShorteningFactor())), 1.0), 0.0);</span>
<span class="line-added">574             auto delay = matchingBackingAnimation-&gt;delay() &lt; 0 ? Seconds(matchingBackingAnimation-&gt;delay()) * reversingShorteningFactor : Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-added">575             auto duration = Seconds(matchingBackingAnimation-&gt;duration()) * reversingShorteningFactor;</span>
<span class="line-added">576 </span>
<span class="line-added">577             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-added">578         } else {</span>
<span class="line-added">579             // 4. Otherwise, implementations must cancel the running transition</span>
<span class="line-added">580             previouslyRunningTransition-&gt;cancelFromStyle();</span>
581 
<a name="39" id="anc39"></a><span class="line-modified">582             // and start a new transition whose:</span>
583             //   - start time is the time of the style change event plus the matching transition delay,
584             //   - end time is the start time plus the matching transition duration,
<a name="40" id="anc40"></a><span class="line-modified">585             //   - start value is the current value of the property in the running transition,</span>
<span class="line-modified">586             //   - end value is the value of the property in the after-change style,</span>
587             //   - reversing-adjusted start value is the same as the start value, and
588             //   - reversing shortening factor is 1.
589             auto delay = Seconds(matchingBackingAnimation-&gt;delay());
590             auto duration = Seconds(matchingBackingAnimation-&gt;duration());
<a name="41" id="anc41"></a><span class="line-modified">591             auto&amp; reversingAdjustedStartStyle = currentStyle;</span>
592             auto reversingShorteningFactor = 1;
<a name="42" id="anc42"></a><span class="line-modified">593             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>




594         }
<a name="43" id="anc43"></a><span class="line-added">595     }</span>
<span class="line-added">596 }</span>
597 
<a name="44" id="anc44"></a><span class="line-modified">598 void AnimationTimeline::updateCSSTransitionsForElement(Element&amp; element, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle)</span>
<span class="line-modified">599 {</span>
<span class="line-modified">600     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its transitions and disregard new ones.</span>
<span class="line-modified">601     if (currentStyle.hasTransitions() &amp;&amp; currentStyle.display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">602         if (m_elementToRunningCSSTransitionByCSSPropertyID.contains(&amp;element)) {</span>
<span class="line-modified">603             for (const auto&amp; cssTransitionsByCSSPropertyIDMapItem : m_elementToRunningCSSTransitionByCSSPropertyID.take(&amp;element))</span>
<span class="line-modified">604                 cssTransitionsByCSSPropertyIDMapItem.value-&gt;cancelFromStyle();</span>

605         }
<a name="45" id="anc45"></a><span class="line-added">606         return;</span>
<span class="line-added">607     }</span>
608 
<a name="46" id="anc46"></a><span class="line-modified">609     // Section 3 &quot;Starting of transitions&quot; from the CSS Transitions Level 1 specification.</span>
<span class="line-modified">610     // https://drafts.csswg.org/css-transitions-1/#starting</span>
<span class="line-modified">611 </span>
<span class="line-modified">612     auto&amp; runningTransitionsByProperty = ensureRunningTransitionsByProperty(element);</span>
<span class="line-modified">613 </span>
<span class="line-modified">614     auto&amp; completedTransitionsByProperty = m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {</span>
<span class="line-modified">615         return PropertyToTransitionMap { };</span>
<span class="line-modified">616     }).iterator-&gt;value;</span>
<span class="line-modified">617 </span>
<span class="line-modified">618     auto generationTime = MonotonicTime::now();</span>
<span class="line-modified">619 </span>
<span class="line-modified">620     // First, let&#39;s compile the list of all CSS properties found in the current style and the after-change style.</span>
<span class="line-modified">621     bool transitionPropertiesContainAll = false;</span>
<span class="line-modified">622     HashSet&lt;CSSPropertyID&gt; transitionProperties;</span>
<span class="line-modified">623     compileTransitionPropertiesInStyle(currentStyle, transitionProperties, transitionPropertiesContainAll);</span>
<span class="line-modified">624     compileTransitionPropertiesInStyle(afterChangeStyle, transitionProperties, transitionPropertiesContainAll);</span>
<span class="line-modified">625 </span>
<span class="line-modified">626     if (transitionPropertiesContainAll) {</span>
<span class="line-modified">627         auto numberOfProperties = CSSPropertyAnimation::getNumProperties();</span>
<span class="line-modified">628         for (int propertyIndex = 0; propertyIndex &lt; numberOfProperties; ++propertyIndex) {</span>
<span class="line-modified">629             Optional&lt;bool&gt; isShorthand;</span>
<span class="line-modified">630             auto property = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);</span>
<span class="line-modified">631             if (isShorthand &amp;&amp; *isShorthand)</span>
<span class="line-modified">632                 continue;</span>
<span class="line-modified">633             updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);</span>
































634         }
<a name="47" id="anc47"></a><span class="line-added">635         return;</span>
636     }
<a name="48" id="anc48"></a>
637 
<a name="49" id="anc49"></a><span class="line-modified">638     for (auto property : transitionProperties)</span>
<span class="line-modified">639         updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);</span>



640 }
641 
642 } // namespace WebCore
<a name="50" id="anc50"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="50" type="hidden" />
</body>
</html>
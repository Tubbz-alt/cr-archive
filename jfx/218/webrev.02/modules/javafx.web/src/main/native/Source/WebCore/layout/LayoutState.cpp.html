<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/LayoutState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutState.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;BlockFormattingState.h&quot;
 32 #include &quot;DisplayBox.h&quot;
 33 #include &quot;FloatingState.h&quot;
 34 #include &quot;InlineFormattingState.h&quot;
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;
 37 #include &quot;RenderBox.h&quot;
 38 #include &quot;RuntimeEnabledFeatures.h&quot;
 39 #include &quot;TableFormattingState.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 namespace Layout {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(LayoutState);
 46 
 47 LayoutState::LayoutState(const Document&amp; document, const Container&amp; rootContainer)
 48     : m_rootContainer(makeWeakPtr(rootContainer))
 49 {
 50     // It makes absolutely no sense to construct a dedicated layout state for a non-formatting context root (layout would be a no-op).
 51     ASSERT(root().establishesFormattingContext());
 52 
 53     auto quirksMode = [&amp;] {
 54         if (document.inLimitedQuirksMode())
 55             return LayoutState::QuirksMode::Limited;
 56         if (document.inQuirksMode())
 57             return LayoutState::QuirksMode::Yes;
 58         return LayoutState::QuirksMode::No;
 59     };
 60     setQuirksMode(quirksMode());
 61 }
 62 
 63 LayoutState::~LayoutState() = default;
 64 
 65 Display::Box&amp; LayoutState::displayBoxForRootLayoutBox()
 66 {
 67     return ensureDisplayBoxForLayoutBox(root());
 68 }
 69 
 70 Display::Box&amp; LayoutState::ensureDisplayBoxForLayoutBoxSlow(const Box&amp; layoutBox)
 71 {
 72     if (layoutBox.canCacheForLayoutState(*this)) {
 73         ASSERT(!layoutBox.cachedDisplayBoxForLayoutState(*this));
 74         auto newBox = makeUnique&lt;Display::Box&gt;();
 75         auto&amp; newBoxPtr = *newBox;
 76         layoutBox.setCachedDisplayBoxForLayoutState(*this, WTFMove(newBox));
 77         return newBoxPtr;
 78     }
 79 
 80     return *m_layoutToDisplayBox.ensure(&amp;layoutBox, [] {
 81         return makeUnique&lt;Display::Box&gt;();
 82     }).iterator-&gt;value;
 83 }
 84 
 85 FormattingState&amp; LayoutState::formattingStateForBox(const Box&amp; layoutBox) const
 86 {
 87     return establishedFormattingState(layoutBox.formattingContextRoot());
 88 }
 89 
 90 FormattingState&amp; LayoutState::establishedFormattingState(const Container&amp; formattingContextRoot) const
 91 {
 92     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
 93         ASSERT(&amp;formattingContextRoot == m_rootContainer.get());
 94         return *m_rootInlineFormattingStateForIntegration;
 95     }
 96 
 97     if (auto* formattingState = m_inlineFormattingStates.get(&amp;formattingContextRoot))
 98         return *formattingState;
 99 
100     if (auto* formattingState = m_blockFormattingStates.get(&amp;formattingContextRoot))
101         return *formattingState;
102 
103     ASSERT(m_tableFormattingStates.contains(&amp;formattingContextRoot));
104     return *m_tableFormattingStates.get(&amp;formattingContextRoot);
105 }
106 
107 InlineFormattingState&amp; LayoutState::establishedInlineFormattingState(const Container&amp; formattingContextRoot) const
108 {
109     ASSERT(formattingContextRoot.establishesInlineFormattingContext());
110 
111     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
112         ASSERT(&amp;formattingContextRoot == m_rootContainer.get());
113         return *m_rootInlineFormattingStateForIntegration;
114     }
115 
116     return *m_inlineFormattingStates.get(&amp;formattingContextRoot);
117 }
118 
119 BlockFormattingState&amp; LayoutState::establishedBlockFormattingState(const Container&amp; formattingContextRoot) const
120 {
121     ASSERT(formattingContextRoot.establishesBlockFormattingContext());
122     return *m_blockFormattingStates.get(&amp;formattingContextRoot);
123 }
124 
125 TableFormattingState&amp; LayoutState::establishedTableFormattingState(const Container&amp; formattingContextRoot) const
126 {
127     ASSERT(formattingContextRoot.establishesTableFormattingContext());
128     return *m_tableFormattingStates.get(&amp;formattingContextRoot);
129 }
130 
131 FormattingState&amp; LayoutState::ensureFormattingState(const Container&amp; formattingContextRoot)
132 {
133     if (formattingContextRoot.establishesInlineFormattingContext())
134         return ensureInlineFormattingState(formattingContextRoot);
135 
136     if (formattingContextRoot.establishesBlockFormattingContext())
137         return ensureBlockFormattingState(formattingContextRoot);
138 
139     return ensureTableFormattingState(formattingContextRoot);
140 }
141 
142 InlineFormattingState&amp; LayoutState::ensureInlineFormattingState(const Container&amp; formattingContextRoot)
143 {
144     ASSERT(formattingContextRoot.establishesInlineFormattingContext());
145 
146     auto create = [&amp;] {
147         // If the block container box that initiates this inline formatting context also establishes a block context, the floats outside of the formatting root
148         // should not interfere with the content inside.
149         // &lt;div style=&quot;float: left&quot;&gt;&lt;/div&gt;&lt;div style=&quot;overflow: hidden&quot;&gt; &lt;- is a non-intrusive float, because overflow: hidden triggers new block formatting context.&lt;/div&gt;
150         if (formattingContextRoot.establishesBlockFormattingContext())
151             return makeUnique&lt;InlineFormattingState&gt;(FloatingState::create(*this, formattingContextRoot), *this);
152 
153         // Otherwise, the formatting context inherits the floats from the parent formatting context.
154         // Find the formatting state in which this formatting root lives, not the one it creates and use its floating state.
155         auto&amp; parentFormattingState = ensureFormattingState(formattingContextRoot.formattingContextRoot());
156         auto&amp; parentFloatingState = parentFormattingState.floatingState();
157         return makeUnique&lt;InlineFormattingState&gt;(parentFloatingState, *this);
158     };
159 
160     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
161         if (!m_rootInlineFormattingStateForIntegration) {
162             ASSERT(&amp;formattingContextRoot == m_rootContainer.get());
163             m_rootInlineFormattingStateForIntegration = create();
164         }
165         return *m_rootInlineFormattingStateForIntegration;
166     }
167 
168     return *m_inlineFormattingStates.ensure(&amp;formattingContextRoot, create).iterator-&gt;value;
169 }
170 
171 BlockFormattingState&amp; LayoutState::ensureBlockFormattingState(const Container&amp; formattingContextRoot)
172 {
173     ASSERT(formattingContextRoot.establishesBlockFormattingContext());
174 
175     auto create = [&amp;] {
176         return makeUnique&lt;BlockFormattingState&gt;(FloatingState::create(*this, formattingContextRoot), *this);
177     };
178 
179     return *m_blockFormattingStates.ensure(&amp;formattingContextRoot, create).iterator-&gt;value;
180 }
181 
182 TableFormattingState&amp; LayoutState::ensureTableFormattingState(const Container&amp; formattingContextRoot)
183 {
184     ASSERT(formattingContextRoot.establishesTableFormattingContext());
185 
186     auto create = [&amp;] {
187         // Table formatting context always establishes a new floating state -and it stays empty.
188         return makeUnique&lt;TableFormattingState&gt;(FloatingState::create(*this, formattingContextRoot), *this);
189     };
190 
191     return *m_tableFormattingStates.ensure(&amp;formattingContextRoot, create).iterator-&gt;value;
192 }
193 
194 void LayoutState::setViewportSize(const LayoutSize&amp; viewportSize)
195 {
196     ASSERT(RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled());
197     m_viewportSize = viewportSize;
198 }
199 
200 LayoutSize LayoutState::viewportSize() const
201 {
202     ASSERT(RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled());
203     return m_viewportSize;
204 }
205 
206 void LayoutState::setIsIntegratedRootBoxFirstChild(bool value)
207 {
208     ASSERT(RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled());
209     m_isIntegratedRootBoxFirstChild = value;
210 }
211 
212 }
213 }
214 
215 #endif
    </pre>
  </body>
</html>
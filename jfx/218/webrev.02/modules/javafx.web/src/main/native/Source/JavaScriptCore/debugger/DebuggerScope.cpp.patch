diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp
@@ -75,22 +75,22 @@
         return String();
     JSObject* thisObject = JSScope::objectAtScope(scope->jsScope());
     return thisObject->methodTable(vm)->className(thisObject, vm);
 }
 
-String DebuggerScope::toStringName(const JSObject* object, ExecState* exec)
+String DebuggerScope::toStringName(const JSObject* object, JSGlobalObject* globalObject)
 {
     const DebuggerScope* scope = jsCast<const DebuggerScope*>(object);
     // We cannot assert that scope->isValid() because the TypeProfiler may encounter an invalidated
     // DebuggerScope in its log entries. We just need to handle it appropriately as below.
     if (!scope->isValid())
         return String();
     JSObject* thisObject = JSScope::objectAtScope(scope->jsScope());
-    return thisObject->methodTable(exec->vm())->toStringName(thisObject, exec);
+    return thisObject->methodTable(globalObject->vm())->toStringName(thisObject, globalObject);
 }
 
-bool DebuggerScope::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
+bool DebuggerScope::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot& slot)
 {
     DebuggerScope* scope = jsCast<DebuggerScope*>(object);
     if (!scope->isValid())
         return false;
     JSObject* thisObject = JSScope::objectAtScope(scope->jsScope());
@@ -103,12 +103,12 @@
     // Instead, we'll treat all properties in the wrapped scope and its prototype chain as
     // the own properties of the DebuggerScope. This is fine because the WebInspector
     // does not presently need to distinguish between what's owned at each level in the
     // prototype chain. Hence, we'll invoke getPropertySlot() on the wrapped scope here
     // instead of getOwnPropertySlot().
-    bool result = thisObject->getPropertySlot(exec, propertyName, slot);
-    if (result && slot.isValue() && slot.getValue(exec, propertyName) == jsTDZValue()) {
+    bool result = thisObject->getPropertySlot(globalObject, propertyName, slot);
+    if (result && slot.isValue() && slot.getValue(globalObject, propertyName) == jsTDZValue()) {
         // FIXME:
         // We hit a scope property that has the TDZ empty value.
         // Currently, we just lie to the inspector and claim that this property is undefined.
         // This is not ideal and we should fix it.
         // https://bugs.webkit.org/show_bug.cgi?id=144977
@@ -116,49 +116,49 @@
         return true;
     }
     return result;
 }
 
-bool DebuggerScope::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+bool DebuggerScope::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
     DebuggerScope* scope = jsCast<DebuggerScope*>(cell);
     ASSERT(scope->isValid());
     if (!scope->isValid())
         return false;
     JSObject* thisObject = JSScope::objectAtScope(scope->jsScope());
     slot.setThisValue(JSValue(thisObject));
-    return thisObject->methodTable(exec->vm())->put(thisObject, exec, propertyName, value, slot);
+    return thisObject->methodTable(globalObject->vm())->put(thisObject, globalObject, propertyName, value, slot);
 }
 
-bool DebuggerScope::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
+bool DebuggerScope::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
 {
     DebuggerScope* scope = jsCast<DebuggerScope*>(cell);
     ASSERT(scope->isValid());
     if (!scope->isValid())
         return false;
     JSObject* thisObject = JSScope::objectAtScope(scope->jsScope());
-    return thisObject->methodTable(exec->vm())->deleteProperty(thisObject, exec, propertyName);
+    return thisObject->methodTable(globalObject->vm())->deleteProperty(thisObject, globalObject, propertyName);
 }
 
-void DebuggerScope::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray& propertyNames, EnumerationMode mode)
+void DebuggerScope::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& propertyNames, EnumerationMode mode)
 {
     DebuggerScope* scope = jsCast<DebuggerScope*>(object);
     ASSERT(scope->isValid());
     if (!scope->isValid())
         return;
     JSObject* thisObject = JSScope::objectAtScope(scope->jsScope());
-    thisObject->methodTable(exec->vm())->getPropertyNames(thisObject, exec, propertyNames, mode);
+    thisObject->methodTable(globalObject->vm())->getPropertyNames(thisObject, globalObject, propertyNames, mode);
 }
 
-bool DebuggerScope::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor& descriptor, bool shouldThrow)
+bool DebuggerScope::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor& descriptor, bool shouldThrow)
 {
     DebuggerScope* scope = jsCast<DebuggerScope*>(object);
     ASSERT(scope->isValid());
     if (!scope->isValid())
         return false;
     JSObject* thisObject = JSScope::objectAtScope(scope->jsScope());
-    return thisObject->methodTable(exec->vm())->defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);
+    return thisObject->methodTable(globalObject->vm())->defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);
 }
 
 DebuggerScope* DebuggerScope::next()
 {
     ASSERT(isValid());
@@ -247,19 +247,19 @@
 
     ScriptExecutable* executable = codeBlock->ownerExecutable();
     return DebuggerLocation(executable);
 }
 
-JSValue DebuggerScope::caughtValue(ExecState* exec) const
+JSValue DebuggerScope::caughtValue(JSGlobalObject* globalObject) const
 {
     ASSERT(isCatchScope());
     JSLexicalEnvironment* catchEnvironment = jsCast<JSLexicalEnvironment*>(m_scope.get());
     SymbolTable* catchSymbolTable = catchEnvironment->symbolTable();
     RELEASE_ASSERT(catchSymbolTable->size() == 1);
     PropertyName errorName(catchSymbolTable->begin(catchSymbolTable->m_lock)->key.get());
     PropertySlot slot(m_scope.get(), PropertySlot::InternalMethodType::Get);
-    bool success = catchEnvironment->getOwnPropertySlot(catchEnvironment, exec, errorName, slot);
+    bool success = catchEnvironment->getOwnPropertySlot(catchEnvironment, globalObject, errorName, slot);
     RELEASE_ASSERT(success && slot.isValue());
-    return slot.getValue(exec, errorName);
+    return slot.getValue(globalObject, errorName);
 }
 
 } // namespace JSC

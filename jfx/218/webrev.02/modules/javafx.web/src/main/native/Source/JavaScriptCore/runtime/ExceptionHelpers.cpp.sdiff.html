<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ExceptionHelpers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ExceptionFuzz.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExceptionHelpers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ExceptionHelpers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
</pre>
<hr />
<pre>
 30 #include &quot;ExceptionHelpers.h&quot;
 31 
 32 #include &quot;CallFrame.h&quot;
 33 #include &quot;CatchScope.h&quot;
 34 #include &quot;CodeBlock.h&quot;
 35 #include &quot;ErrorHandlingScope.h&quot;
 36 #include &quot;Exception.h&quot;
 37 #include &quot;Interpreter.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;JSGlobalObjectFunctions.h&quot;
 40 #include &quot;RuntimeType.h&quot;
 41 #include &lt;wtf/text/StringBuilder.h&gt;
 42 #include &lt;wtf/text/StringView.h&gt;
 43 
 44 namespace JSC {
 45 
 46 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(TerminatedExecutionError);
 47 
 48 const ClassInfo TerminatedExecutionError::s_info = { &quot;TerminatedExecutionError&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(TerminatedExecutionError) };
 49 
<span class="line-modified"> 50 JSValue TerminatedExecutionError::defaultValue(const JSObject*, ExecState* exec, PreferredPrimitiveType hint)</span>
 51 {
 52     if (hint == PreferString)
<span class="line-modified"> 53         return jsNontrivialString(exec-&gt;vm(), String(&quot;JavaScript execution terminated.&quot;_s));</span>
 54     return JSValue(PNaN);
 55 }
 56 
 57 JSObject* createTerminatedExecutionException(VM* vm)
 58 {
 59     return TerminatedExecutionError::create(*vm);
 60 }
 61 
 62 bool isTerminatedExecutionException(VM&amp; vm, Exception* exception)
 63 {
 64     if (!exception-&gt;value().isObject())
 65         return false;
 66 
 67     return exception-&gt;value().inherits&lt;TerminatedExecutionError&gt;(vm);
 68 }
 69 
<span class="line-modified"> 70 JSObject* createStackOverflowError(ExecState* exec)</span>
 71 {
<span class="line-modified"> 72     return createStackOverflowError(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed"> 73 }</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75 JSObject* createStackOverflowError(ExecState* exec, JSGlobalObject* globalObject)</span>
<span class="line-removed"> 76 {</span>
<span class="line-removed"> 77     auto* error = createRangeError(exec, globalObject, &quot;Maximum call stack size exceeded.&quot;_s);</span>
 78     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setStackOverflowError();
 79     return error;
 80 }
 81 
<span class="line-modified"> 82 JSObject* createUndefinedVariableError(ExecState* exec, const Identifier&amp; ident)</span>
 83 {
 84     if (ident.isPrivateName())
<span class="line-modified"> 85         return createReferenceError(exec, makeString(&quot;Can&#39;t find private variable: PrivateSymbol.&quot;, ident.string()));</span>
<span class="line-modified"> 86     return createReferenceError(exec, makeString(&quot;Can&#39;t find variable: &quot;, ident.string()));</span>
 87 }
 88 
<span class="line-modified"> 89 String errorDescriptionForValue(ExecState* exec, JSValue v)</span>
 90 {
 91     if (v.isString()) {
<span class="line-modified"> 92         String string = asString(v)-&gt;value(exec);</span>
 93         if (!string)
 94             return string;
 95         return tryMakeString(&#39;&quot;&#39;, string, &#39;&quot;&#39;);
 96     }
 97 
 98     if (v.isSymbol())
 99         return asSymbol(v)-&gt;descriptiveString();
100     if (v.isObject()) {
<span class="line-modified">101         VM&amp; vm = exec-&gt;vm();</span>
102         CallData callData;
103         JSObject* object = asObject(v);
104         if (object-&gt;methodTable(vm)-&gt;getCallData(object, callData) != CallType::None)
<span class="line-modified">105             return vm.smallStrings.functionString()-&gt;value(exec);</span>
106         return JSObject::calculatedClassName(object);
107     }
<span class="line-modified">108     return v.toString(exec)-&gt;value(exec);</span>
109 }
110 
111 static String defaultApproximateSourceError(const String&amp; originalMessage, const String&amp; sourceText)
112 {
113     return makeString(originalMessage, &quot; (near &#39;...&quot;, sourceText, &quot;...&#39;)&quot;);
114 }
115 
116 String defaultSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
117 {
118     if (occurrence == ErrorInstance::FoundApproximateSource)
119         return defaultApproximateSourceError(originalMessage, sourceText);
120 
121     ASSERT(occurrence == ErrorInstance::FoundExactSource);
122     return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
123 }
124 
125 static String functionCallBase(const String&amp; sourceText)
126 {
127     // This function retrieves the &#39;foo.bar&#39; substring from &#39;foo.bar(baz)&#39;.
128     // FIXME: This function has simple processing of /* */ style comments.
129     // It doesn&#39;t properly handle embedded comments of string literals that contain
130     // parenthesis or comment constructs, e.g. foo.bar(&quot;/abc\)*/&quot;).
131     // https://bugs.webkit.org/show_bug.cgi?id=146304
132 
133     unsigned sourceLength = sourceText.length();
134     unsigned idx = sourceLength - 1;
135     if (sourceLength &lt; 2 || sourceText[idx] != &#39;)&#39;) {
136         // For function calls that have many new lines in between their open parenthesis
137         // and their closing parenthesis, the text range passed into the message appender
<span class="line-modified">138         // will not inlcude the text in between these parentheses, it will just be the desired</span>
139         // text that precedes the parentheses.
140         return String();
141     }
142 
143     unsigned parenStack = 1;
144     bool isInMultiLineComment = false;
145     idx -= 1;
146     // Note that we&#39;re scanning text right to left instead of the more common left to right,
147     // so syntax detection is backwards.
148     while (parenStack &amp;&amp; idx) {
149         UChar curChar = sourceText[idx];
150         if (isInMultiLineComment) {
151             if (curChar == &#39;*&#39; &amp;&amp; sourceText[idx - 1] == &#39;/&#39;) {
152                 isInMultiLineComment = false;
153                 --idx;
154             }
155         } else if (curChar == &#39;(&#39;)
156             --parenStack;
157         else if (curChar == &#39;)&#39;)
158             ++parenStack;
</pre>
<hr />
<pre>
217 }
218 
219 static String invalidParameterInSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType type, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
220 {
221     ASSERT_UNUSED(type, type != TypeObject);
222 
223     if (occurrence == ErrorInstance::FoundApproximateSource)
224         return defaultApproximateSourceError(originalMessage, sourceText);
225 
226     ASSERT(occurrence == ErrorInstance::FoundExactSource);
227     auto inIndex = sourceText.reverseFind(&quot;in&quot;);
228     if (inIndex == notFound) {
229         // This should basically never happen, since JS code must use the literal
230         // text &quot;in&quot; for the `in` operation. However, if we fail to find &quot;in&quot;
231         // for any reason, just fail gracefully.
232         return originalMessage;
233     }
234     if (sourceText.find(&quot;in&quot;) != inIndex)
235         return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
236 
<span class="line-modified">237     static const unsigned inLength = 2;</span>
238     String rightHandSide = sourceText.substring(inIndex + inLength).simplifyWhiteSpace();
239     return makeString(rightHandSide, &quot; is not an Object. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
240 }
241 
242 inline String invalidParameterInstanceofSourceAppender(const String&amp; content, const String&amp; originalMessage, const String&amp; sourceText, RuntimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
243 {
244     if (occurrence == ErrorInstance::FoundApproximateSource)
245         return defaultApproximateSourceError(originalMessage, sourceText);
246 
247     ASSERT(occurrence == ErrorInstance::FoundExactSource);
248     auto instanceofIndex = sourceText.reverseFind(&quot;instanceof&quot;);
249     RELEASE_ASSERT(instanceofIndex != notFound);
250     if (sourceText.find(&quot;instanceof&quot;) != instanceofIndex)
251         return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
252 
<span class="line-modified">253     static const unsigned instanceofLength = 10;</span>
254     String rightHandSide = sourceText.substring(instanceofIndex + instanceofLength).simplifyWhiteSpace();
255     return makeString(rightHandSide, content, &quot;. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
256 }
257 
258 static String invalidParameterInstanceofNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
259 {
260     return invalidParameterInstanceofSourceAppender(&quot; is not a function&quot;_s, originalMessage, sourceText, runtimeType, occurrence);
261 }
262 
263 static String invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
264 {
265     return invalidParameterInstanceofSourceAppender(&quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, originalMessage, sourceText, runtimeType, occurrence);
266 }
267 
<span class="line-modified">268 JSObject* createError(ExecState* exec, JSValue value, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
269 {
<span class="line-modified">270     VM&amp; vm = exec-&gt;vm();</span>
271     auto scope = DECLARE_CATCH_SCOPE(vm);
272 
<span class="line-modified">273     String valueDescription = errorDescriptionForValue(exec, value);</span>
<span class="line-modified">274     ASSERT(scope.exception() || !!valueDescription);</span>
<span class="line-modified">275     if (!valueDescription) {</span>



276         scope.clearException();
<span class="line-modified">277         return createOutOfMemoryError(exec);</span>
278     }
279     String errorMessage = tryMakeString(valueDescription, &#39; &#39;, message);
280     if (!errorMessage)
<span class="line-modified">281         return createOutOfMemoryError(exec);</span>
282     scope.assertNoException();
<span class="line-modified">283     JSObject* exception = createTypeError(exec, errorMessage, appender, runtimeTypeForValue(vm, value));</span>
284     ASSERT(exception-&gt;isErrorInstance());
285 
286     return exception;
287 }
288 
<span class="line-modified">289 JSObject* createInvalidFunctionApplyParameterError(ExecState* exec, JSValue value)</span>
290 {
<span class="line-modified">291     return createTypeError(exec, &quot;second argument to Function.prototype.apply must be an Array-like object&quot;_s, defaultSourceAppender, runtimeTypeForValue(exec-&gt;vm(), value));</span>
292 }
293 
<span class="line-modified">294 JSObject* createInvalidInParameterError(ExecState* exec, JSValue value)</span>
295 {
<span class="line-modified">296     return createError(exec, value, &quot;is not an Object.&quot;_s, invalidParameterInSourceAppender);</span>
297 }
298 
<span class="line-modified">299 JSObject* createInvalidInstanceofParameterErrorNotFunction(ExecState* exec, JSValue value)</span>
300 {
<span class="line-modified">301     return createError(exec, value, &quot; is not a function&quot;_s, invalidParameterInstanceofNotFunctionSourceAppender);</span>
302 }
303 
<span class="line-modified">304 JSObject* createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(ExecState* exec, JSValue value)</span>
305 {
<span class="line-modified">306     return createError(exec, value, &quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender);</span>
307 }
308 
<span class="line-modified">309 JSObject* createNotAConstructorError(ExecState* exec, JSValue value)</span>
310 {
<span class="line-modified">311     return createError(exec, value, &quot;is not a constructor&quot;_s, defaultSourceAppender);</span>
312 }
313 
<span class="line-modified">314 JSObject* createNotAFunctionError(ExecState* exec, JSValue value)</span>
315 {
<span class="line-modified">316     return createError(exec, value, &quot;is not a function&quot;_s, notAFunctionSourceAppender);</span>
317 }
318 
<span class="line-modified">319 JSObject* createNotAnObjectError(ExecState* exec, JSValue value)</span>
320 {
<span class="line-modified">321     return createError(exec, value, &quot;is not an object&quot;_s, defaultSourceAppender);</span>
322 }
323 
<span class="line-modified">324 JSObject* createErrorForInvalidGlobalAssignment(ExecState* exec, const String&amp; propertyName)</span>
325 {
<span class="line-modified">326     return createReferenceError(exec, makeString(&quot;Strict mode forbids implicit creation of global property &#39;&quot;, propertyName, &#39;\&#39;&#39;));</span>
327 }
328 
<span class="line-modified">329 JSObject* createTDZError(ExecState* exec)</span>
330 {
<span class="line-modified">331     return createReferenceError(exec, &quot;Cannot access uninitialized variable.&quot;);</span>
332 }
333 
<span class="line-modified">334 Exception* throwOutOfMemoryError(ExecState* exec, ThrowScope&amp; scope)</span>
335 {
<span class="line-modified">336     return throwException(exec, scope, createOutOfMemoryError(exec));</span>
337 }
338 
<span class="line-modified">339 Exception* throwStackOverflowError(ExecState* exec, ThrowScope&amp; scope)</span>
340 {
<span class="line-modified">341     VM&amp; vm = exec-&gt;vm();</span>
342     ErrorHandlingScope errorScope(vm);
<span class="line-modified">343     return throwException(exec, scope, createStackOverflowError(exec));</span>
344 }
345 
<span class="line-modified">346 Exception* throwTerminatedExecutionException(ExecState* exec, ThrowScope&amp; scope)</span>
347 {
<span class="line-modified">348     VM&amp; vm = exec-&gt;vm();</span>
349     ErrorHandlingScope errorScope(vm);
<span class="line-modified">350     return throwException(exec, scope, createTerminatedExecutionException(&amp;vm));</span>
351 }
352 
353 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
</pre>
<hr />
<pre>
 30 #include &quot;ExceptionHelpers.h&quot;
 31 
 32 #include &quot;CallFrame.h&quot;
 33 #include &quot;CatchScope.h&quot;
 34 #include &quot;CodeBlock.h&quot;
 35 #include &quot;ErrorHandlingScope.h&quot;
 36 #include &quot;Exception.h&quot;
 37 #include &quot;Interpreter.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;JSGlobalObjectFunctions.h&quot;
 40 #include &quot;RuntimeType.h&quot;
 41 #include &lt;wtf/text/StringBuilder.h&gt;
 42 #include &lt;wtf/text/StringView.h&gt;
 43 
 44 namespace JSC {
 45 
 46 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(TerminatedExecutionError);
 47 
 48 const ClassInfo TerminatedExecutionError::s_info = { &quot;TerminatedExecutionError&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(TerminatedExecutionError) };
 49 
<span class="line-modified"> 50 JSValue TerminatedExecutionError::defaultValue(const JSObject*, JSGlobalObject* globalObject, PreferredPrimitiveType hint)</span>
 51 {
 52     if (hint == PreferString)
<span class="line-modified"> 53         return jsNontrivialString(globalObject-&gt;vm(), String(&quot;JavaScript execution terminated.&quot;_s));</span>
 54     return JSValue(PNaN);
 55 }
 56 
 57 JSObject* createTerminatedExecutionException(VM* vm)
 58 {
 59     return TerminatedExecutionError::create(*vm);
 60 }
 61 
 62 bool isTerminatedExecutionException(VM&amp; vm, Exception* exception)
 63 {
 64     if (!exception-&gt;value().isObject())
 65         return false;
 66 
 67     return exception-&gt;value().inherits&lt;TerminatedExecutionError&gt;(vm);
 68 }
 69 
<span class="line-modified"> 70 JSObject* createStackOverflowError(JSGlobalObject* globalObject)</span>
 71 {
<span class="line-modified"> 72     auto* error = createRangeError(globalObject, &quot;Maximum call stack size exceeded.&quot;_s);</span>





 73     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setStackOverflowError();
 74     return error;
 75 }
 76 
<span class="line-modified"> 77 JSObject* createUndefinedVariableError(JSGlobalObject* globalObject, const Identifier&amp; ident)</span>
 78 {
 79     if (ident.isPrivateName())
<span class="line-modified"> 80         return createReferenceError(globalObject, makeString(&quot;Can&#39;t find private variable: PrivateSymbol.&quot;, ident.string()));</span>
<span class="line-modified"> 81     return createReferenceError(globalObject, makeString(&quot;Can&#39;t find variable: &quot;, ident.string()));</span>
 82 }
 83 
<span class="line-modified"> 84 String errorDescriptionForValue(JSGlobalObject* globalObject, JSValue v)</span>
 85 {
 86     if (v.isString()) {
<span class="line-modified"> 87         String string = asString(v)-&gt;value(globalObject);</span>
 88         if (!string)
 89             return string;
 90         return tryMakeString(&#39;&quot;&#39;, string, &#39;&quot;&#39;);
 91     }
 92 
 93     if (v.isSymbol())
 94         return asSymbol(v)-&gt;descriptiveString();
 95     if (v.isObject()) {
<span class="line-modified"> 96         VM&amp; vm = globalObject-&gt;vm();</span>
 97         CallData callData;
 98         JSObject* object = asObject(v);
 99         if (object-&gt;methodTable(vm)-&gt;getCallData(object, callData) != CallType::None)
<span class="line-modified">100             return vm.smallStrings.functionString()-&gt;value(globalObject);</span>
101         return JSObject::calculatedClassName(object);
102     }
<span class="line-modified">103     return v.toString(globalObject)-&gt;value(globalObject);</span>
104 }
105 
106 static String defaultApproximateSourceError(const String&amp; originalMessage, const String&amp; sourceText)
107 {
108     return makeString(originalMessage, &quot; (near &#39;...&quot;, sourceText, &quot;...&#39;)&quot;);
109 }
110 
111 String defaultSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
112 {
113     if (occurrence == ErrorInstance::FoundApproximateSource)
114         return defaultApproximateSourceError(originalMessage, sourceText);
115 
116     ASSERT(occurrence == ErrorInstance::FoundExactSource);
117     return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
118 }
119 
120 static String functionCallBase(const String&amp; sourceText)
121 {
122     // This function retrieves the &#39;foo.bar&#39; substring from &#39;foo.bar(baz)&#39;.
123     // FIXME: This function has simple processing of /* */ style comments.
124     // It doesn&#39;t properly handle embedded comments of string literals that contain
125     // parenthesis or comment constructs, e.g. foo.bar(&quot;/abc\)*/&quot;).
126     // https://bugs.webkit.org/show_bug.cgi?id=146304
127 
128     unsigned sourceLength = sourceText.length();
129     unsigned idx = sourceLength - 1;
130     if (sourceLength &lt; 2 || sourceText[idx] != &#39;)&#39;) {
131         // For function calls that have many new lines in between their open parenthesis
132         // and their closing parenthesis, the text range passed into the message appender
<span class="line-modified">133         // will not include the text in between these parentheses, it will just be the desired</span>
134         // text that precedes the parentheses.
135         return String();
136     }
137 
138     unsigned parenStack = 1;
139     bool isInMultiLineComment = false;
140     idx -= 1;
141     // Note that we&#39;re scanning text right to left instead of the more common left to right,
142     // so syntax detection is backwards.
143     while (parenStack &amp;&amp; idx) {
144         UChar curChar = sourceText[idx];
145         if (isInMultiLineComment) {
146             if (curChar == &#39;*&#39; &amp;&amp; sourceText[idx - 1] == &#39;/&#39;) {
147                 isInMultiLineComment = false;
148                 --idx;
149             }
150         } else if (curChar == &#39;(&#39;)
151             --parenStack;
152         else if (curChar == &#39;)&#39;)
153             ++parenStack;
</pre>
<hr />
<pre>
212 }
213 
214 static String invalidParameterInSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType type, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
215 {
216     ASSERT_UNUSED(type, type != TypeObject);
217 
218     if (occurrence == ErrorInstance::FoundApproximateSource)
219         return defaultApproximateSourceError(originalMessage, sourceText);
220 
221     ASSERT(occurrence == ErrorInstance::FoundExactSource);
222     auto inIndex = sourceText.reverseFind(&quot;in&quot;);
223     if (inIndex == notFound) {
224         // This should basically never happen, since JS code must use the literal
225         // text &quot;in&quot; for the `in` operation. However, if we fail to find &quot;in&quot;
226         // for any reason, just fail gracefully.
227         return originalMessage;
228     }
229     if (sourceText.find(&quot;in&quot;) != inIndex)
230         return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
231 
<span class="line-modified">232     static constexpr unsigned inLength = 2;</span>
233     String rightHandSide = sourceText.substring(inIndex + inLength).simplifyWhiteSpace();
234     return makeString(rightHandSide, &quot; is not an Object. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
235 }
236 
237 inline String invalidParameterInstanceofSourceAppender(const String&amp; content, const String&amp; originalMessage, const String&amp; sourceText, RuntimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
238 {
239     if (occurrence == ErrorInstance::FoundApproximateSource)
240         return defaultApproximateSourceError(originalMessage, sourceText);
241 
242     ASSERT(occurrence == ErrorInstance::FoundExactSource);
243     auto instanceofIndex = sourceText.reverseFind(&quot;instanceof&quot;);
244     RELEASE_ASSERT(instanceofIndex != notFound);
245     if (sourceText.find(&quot;instanceof&quot;) != instanceofIndex)
246         return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
247 
<span class="line-modified">248     static constexpr unsigned instanceofLength = 10;</span>
249     String rightHandSide = sourceText.substring(instanceofIndex + instanceofLength).simplifyWhiteSpace();
250     return makeString(rightHandSide, content, &quot;. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
251 }
252 
253 static String invalidParameterInstanceofNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
254 {
255     return invalidParameterInstanceofSourceAppender(&quot; is not a function&quot;_s, originalMessage, sourceText, runtimeType, occurrence);
256 }
257 
258 static String invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
259 {
260     return invalidParameterInstanceofSourceAppender(&quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, originalMessage, sourceText, runtimeType, occurrence);
261 }
262 
<span class="line-modified">263 JSObject* createError(JSGlobalObject* globalObject, JSValue value, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
264 {
<span class="line-modified">265     VM&amp; vm = globalObject-&gt;vm();</span>
266     auto scope = DECLARE_CATCH_SCOPE(vm);
267 
<span class="line-modified">268     String valueDescription = errorDescriptionForValue(globalObject, value);</span>
<span class="line-modified">269     if (scope.exception() || !valueDescription) {</span>
<span class="line-modified">270         // When we see an exception, we&#39;re not returning immediately because</span>
<span class="line-added">271         // we&#39;re in a CatchScope, i.e. no exceptions are thrown past this scope.</span>
<span class="line-added">272         // We&#39;re using a CatchScope because the contract for createError() is</span>
<span class="line-added">273         // that it only creates an error object; it doesn&#39;t throw it.</span>
274         scope.clearException();
<span class="line-modified">275         return createOutOfMemoryError(globalObject);</span>
276     }
277     String errorMessage = tryMakeString(valueDescription, &#39; &#39;, message);
278     if (!errorMessage)
<span class="line-modified">279         return createOutOfMemoryError(globalObject);</span>
280     scope.assertNoException();
<span class="line-modified">281     JSObject* exception = createTypeError(globalObject, errorMessage, appender, runtimeTypeForValue(vm, value));</span>
282     ASSERT(exception-&gt;isErrorInstance());
283 
284     return exception;
285 }
286 
<span class="line-modified">287 JSObject* createInvalidFunctionApplyParameterError(JSGlobalObject* globalObject, JSValue value)</span>
288 {
<span class="line-modified">289     return createTypeError(globalObject, &quot;second argument to Function.prototype.apply must be an Array-like object&quot;_s, defaultSourceAppender, runtimeTypeForValue(globalObject-&gt;vm(), value));</span>
290 }
291 
<span class="line-modified">292 JSObject* createInvalidInParameterError(JSGlobalObject* globalObject, JSValue value)</span>
293 {
<span class="line-modified">294     return createError(globalObject, value, &quot;is not an Object.&quot;_s, invalidParameterInSourceAppender);</span>
295 }
296 
<span class="line-modified">297 JSObject* createInvalidInstanceofParameterErrorNotFunction(JSGlobalObject* globalObject, JSValue value)</span>
298 {
<span class="line-modified">299     return createError(globalObject, value, &quot; is not a function&quot;_s, invalidParameterInstanceofNotFunctionSourceAppender);</span>
300 }
301 
<span class="line-modified">302 JSObject* createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(JSGlobalObject* globalObject, JSValue value)</span>
303 {
<span class="line-modified">304     return createError(globalObject, value, &quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender);</span>
305 }
306 
<span class="line-modified">307 JSObject* createNotAConstructorError(JSGlobalObject* globalObject, JSValue value)</span>
308 {
<span class="line-modified">309     return createError(globalObject, value, &quot;is not a constructor&quot;_s, defaultSourceAppender);</span>
310 }
311 
<span class="line-modified">312 JSObject* createNotAFunctionError(JSGlobalObject* globalObject, JSValue value)</span>
313 {
<span class="line-modified">314     return createError(globalObject, value, &quot;is not a function&quot;_s, notAFunctionSourceAppender);</span>
315 }
316 
<span class="line-modified">317 JSObject* createNotAnObjectError(JSGlobalObject* globalObject, JSValue value)</span>
318 {
<span class="line-modified">319     return createError(globalObject, value, &quot;is not an object&quot;_s, defaultSourceAppender);</span>
320 }
321 
<span class="line-modified">322 JSObject* createErrorForInvalidGlobalAssignment(JSGlobalObject* globalObject, const String&amp; propertyName)</span>
323 {
<span class="line-modified">324     return createReferenceError(globalObject, makeString(&quot;Strict mode forbids implicit creation of global property &#39;&quot;, propertyName, &#39;\&#39;&#39;));</span>
325 }
326 
<span class="line-modified">327 JSObject* createTDZError(JSGlobalObject* globalObject)</span>
328 {
<span class="line-modified">329     return createReferenceError(globalObject, &quot;Cannot access uninitialized variable.&quot;);</span>
330 }
331 
<span class="line-modified">332 Exception* throwOutOfMemoryError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
333 {
<span class="line-modified">334     return throwException(globalObject, scope, createOutOfMemoryError(globalObject));</span>
335 }
336 
<span class="line-modified">337 Exception* throwStackOverflowError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
338 {
<span class="line-modified">339     VM&amp; vm = globalObject-&gt;vm();</span>
340     ErrorHandlingScope errorScope(vm);
<span class="line-modified">341     return throwException(globalObject, scope, createStackOverflowError(globalObject));</span>
342 }
343 
<span class="line-modified">344 Exception* throwTerminatedExecutionException(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
345 {
<span class="line-modified">346     VM&amp; vm = globalObject-&gt;vm();</span>
347     ErrorHandlingScope errorScope(vm);
<span class="line-modified">348     return throwException(globalObject, scope, createTerminatedExecutionException(&amp;vm));</span>
349 }
350 
351 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ExceptionFuzz.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExceptionHelpers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
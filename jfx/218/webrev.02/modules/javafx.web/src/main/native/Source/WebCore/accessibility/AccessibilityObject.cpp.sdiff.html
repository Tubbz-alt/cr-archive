<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityNodeObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  46 #include &quot;FloatRect.h&quot;
  47 #include &quot;FocusController.h&quot;
  48 #include &quot;Frame.h&quot;
  49 #include &quot;FrameLoader.h&quot;
  50 #include &quot;FrameSelection.h&quot;
  51 #include &quot;HTMLDataListElement.h&quot;
  52 #include &quot;HTMLDetailsElement.h&quot;
  53 #include &quot;HTMLFormControlElement.h&quot;
  54 #include &quot;HTMLInputElement.h&quot;
  55 #include &quot;HTMLMediaElement.h&quot;
  56 #include &quot;HTMLNames.h&quot;
  57 #include &quot;HTMLParserIdioms.h&quot;
  58 #include &quot;HTMLTextAreaElement.h&quot;
  59 #include &quot;HitTestResult.h&quot;
  60 #include &quot;LocalizedStrings.h&quot;
  61 #include &quot;MathMLNames.h&quot;
  62 #include &quot;NodeList.h&quot;
  63 #include &quot;NodeTraversal.h&quot;
  64 #include &quot;Page.h&quot;
  65 #include &quot;RenderImage.h&quot;

  66 #include &quot;RenderLayer.h&quot;
  67 #include &quot;RenderListItem.h&quot;
  68 #include &quot;RenderListMarker.h&quot;
  69 #include &quot;RenderMenuList.h&quot;
  70 #include &quot;RenderText.h&quot;
  71 #include &quot;RenderTextControl.h&quot;
  72 #include &quot;RenderTheme.h&quot;
  73 #include &quot;RenderView.h&quot;
  74 #include &quot;RenderWidget.h&quot;
  75 #include &quot;RenderedPosition.h&quot;
<span class="line-removed">  76 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  77 #include &quot;Settings.h&quot;
  78 #include &quot;TextCheckerClient.h&quot;
  79 #include &quot;TextCheckingHelper.h&quot;
  80 #include &quot;TextIterator.h&quot;
  81 #include &quot;UserGestureIndicator.h&quot;
  82 #include &quot;VisibleUnits.h&quot;
  83 #include &lt;wtf/NeverDestroyed.h&gt;
  84 #include &lt;wtf/StdLibExtras.h&gt;
  85 #include &lt;wtf/text/StringBuilder.h&gt;
  86 #include &lt;wtf/text/StringView.h&gt;
  87 #include &lt;wtf/text/WTFString.h&gt;
  88 #include &lt;wtf/unicode/CharacterNames.h&gt;
  89 
  90 namespace WebCore {
  91 
  92 using namespace HTMLNames;
  93 
  94 AccessibilityObject::~AccessibilityObject()
  95 {
  96     ASSERT(isDetached());
  97 }
  98 
<span class="line-modified">  99 void AccessibilityObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)</span>
 100 {
 101     // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
<span class="line-modified"> 102     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu &amp;&amp; cache)</span>
<span class="line-modified"> 103         cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);</span>


 104 
 105     // Clear any children and call detachFromParent on them so that
 106     // no children are left with dangling pointers to their parent.
 107     clearChildren();
<span class="line-removed"> 108 </span>
<span class="line-removed"> 109 #if ENABLE(ACCESSIBILITY)</span>
<span class="line-removed"> 110     setWrapper(nullptr);</span>
<span class="line-removed"> 111 #endif</span>
 112 }
 113 
 114 bool AccessibilityObject::isDetached() const
 115 {
 116 #if ENABLE(ACCESSIBILITY)
 117     return !wrapper();
 118 #else
 119     return true;
 120 #endif
 121 }
 122 
<span class="line-removed"> 123 bool AccessibilityObject::isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria, size_t index)</span>
<span class="line-removed"> 124 {</span>
<span class="line-removed"> 125     switch (criteria-&gt;searchKeys[index]) {</span>
<span class="line-removed"> 126     // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.</span>
<span class="line-removed"> 127     case AccessibilitySearchKey::AnyType:</span>
<span class="line-removed"> 128         return true;</span>
<span class="line-removed"> 129 </span>
<span class="line-removed"> 130     case AccessibilitySearchKey::Article:</span>
<span class="line-removed"> 131         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;</span>
<span class="line-removed"> 132 </span>
<span class="line-removed"> 133     case AccessibilitySearchKey::BlockquoteSameLevel:</span>
<span class="line-removed"> 134         return criteria-&gt;startObject</span>
<span class="line-removed"> 135             &amp;&amp; axObject-&gt;isBlockquote()</span>
<span class="line-removed"> 136             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria-&gt;startObject-&gt;blockquoteLevel();</span>
<span class="line-removed"> 137 </span>
<span class="line-removed"> 138     case AccessibilitySearchKey::Blockquote:</span>
<span class="line-removed"> 139         return axObject-&gt;isBlockquote();</span>
<span class="line-removed"> 140 </span>
<span class="line-removed"> 141     case AccessibilitySearchKey::BoldFont:</span>
<span class="line-removed"> 142         return axObject-&gt;hasBoldFont();</span>
<span class="line-removed"> 143 </span>
<span class="line-removed"> 144     case AccessibilitySearchKey::Button:</span>
<span class="line-removed"> 145         return axObject-&gt;isButton();</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147     case AccessibilitySearchKey::CheckBox:</span>
<span class="line-removed"> 148         return axObject-&gt;isCheckbox();</span>
<span class="line-removed"> 149 </span>
<span class="line-removed"> 150     case AccessibilitySearchKey::Control:</span>
<span class="line-removed"> 151         return axObject-&gt;isControl();</span>
<span class="line-removed"> 152 </span>
<span class="line-removed"> 153     case AccessibilitySearchKey::DifferentType:</span>
<span class="line-removed"> 154         return criteria-&gt;startObject</span>
<span class="line-removed"> 155             &amp;&amp; axObject-&gt;roleValue() != criteria-&gt;startObject-&gt;roleValue();</span>
<span class="line-removed"> 156 </span>
<span class="line-removed"> 157     case AccessibilitySearchKey::FontChange:</span>
<span class="line-removed"> 158         return criteria-&gt;startObject</span>
<span class="line-removed"> 159             &amp;&amp; !axObject-&gt;hasSameFont(criteria-&gt;startObject-&gt;renderer());</span>
<span class="line-removed"> 160 </span>
<span class="line-removed"> 161     case AccessibilitySearchKey::FontColorChange:</span>
<span class="line-removed"> 162         return criteria-&gt;startObject</span>
<span class="line-removed"> 163             &amp;&amp; !axObject-&gt;hasSameFontColor(criteria-&gt;startObject-&gt;renderer());</span>
<span class="line-removed"> 164 </span>
<span class="line-removed"> 165     case AccessibilitySearchKey::Frame:</span>
<span class="line-removed"> 166         return axObject-&gt;isWebArea();</span>
<span class="line-removed"> 167 </span>
<span class="line-removed"> 168     case AccessibilitySearchKey::Graphic:</span>
<span class="line-removed"> 169         return axObject-&gt;isImage();</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171     case AccessibilitySearchKey::HeadingLevel1:</span>
<span class="line-removed"> 172         return axObject-&gt;headingLevel() == 1;</span>
<span class="line-removed"> 173 </span>
<span class="line-removed"> 174     case AccessibilitySearchKey::HeadingLevel2:</span>
<span class="line-removed"> 175         return axObject-&gt;headingLevel() == 2;</span>
<span class="line-removed"> 176 </span>
<span class="line-removed"> 177     case AccessibilitySearchKey::HeadingLevel3:</span>
<span class="line-removed"> 178         return axObject-&gt;headingLevel() == 3;</span>
<span class="line-removed"> 179 </span>
<span class="line-removed"> 180     case AccessibilitySearchKey::HeadingLevel4:</span>
<span class="line-removed"> 181         return axObject-&gt;headingLevel() == 4;</span>
<span class="line-removed"> 182 </span>
<span class="line-removed"> 183     case AccessibilitySearchKey::HeadingLevel5:</span>
<span class="line-removed"> 184         return axObject-&gt;headingLevel() == 5;</span>
<span class="line-removed"> 185 </span>
<span class="line-removed"> 186     case AccessibilitySearchKey::HeadingLevel6:</span>
<span class="line-removed"> 187         return axObject-&gt;headingLevel() == 6;</span>
<span class="line-removed"> 188 </span>
<span class="line-removed"> 189     case AccessibilitySearchKey::HeadingSameLevel:</span>
<span class="line-removed"> 190         return criteria-&gt;startObject</span>
<span class="line-removed"> 191             &amp;&amp; axObject-&gt;isHeading()</span>
<span class="line-removed"> 192             &amp;&amp; axObject-&gt;headingLevel() == criteria-&gt;startObject-&gt;headingLevel();</span>
<span class="line-removed"> 193 </span>
<span class="line-removed"> 194     case AccessibilitySearchKey::Heading:</span>
<span class="line-removed"> 195         return axObject-&gt;isHeading();</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197     case AccessibilitySearchKey::Highlighted:</span>
<span class="line-removed"> 198         return axObject-&gt;hasHighlighting();</span>
<span class="line-removed"> 199 </span>
<span class="line-removed"> 200     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-removed"> 201         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-removed"> 202 </span>
<span class="line-removed"> 203     case AccessibilitySearchKey::ItalicFont:</span>
<span class="line-removed"> 204         return axObject-&gt;hasItalicFont();</span>
<span class="line-removed"> 205 </span>
<span class="line-removed"> 206     case AccessibilitySearchKey::Landmark:</span>
<span class="line-removed"> 207         return axObject-&gt;isLandmark();</span>
<span class="line-removed"> 208 </span>
<span class="line-removed"> 209     case AccessibilitySearchKey::Link: {</span>
<span class="line-removed"> 210         bool isLink = axObject-&gt;isLink();</span>
<span class="line-removed"> 211 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 212         if (!isLink)</span>
<span class="line-removed"> 213             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);</span>
<span class="line-removed"> 214 #endif</span>
<span class="line-removed"> 215         return isLink;</span>
<span class="line-removed"> 216     }</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218     case AccessibilitySearchKey::List:</span>
<span class="line-removed"> 219         return axObject-&gt;isList();</span>
<span class="line-removed"> 220 </span>
<span class="line-removed"> 221     case AccessibilitySearchKey::LiveRegion:</span>
<span class="line-removed"> 222         return axObject-&gt;supportsLiveRegion();</span>
<span class="line-removed"> 223 </span>
<span class="line-removed"> 224     case AccessibilitySearchKey::MisspelledWord:</span>
<span class="line-removed"> 225         return axObject-&gt;hasMisspelling();</span>
<span class="line-removed"> 226 </span>
<span class="line-removed"> 227     case AccessibilitySearchKey::Outline:</span>
<span class="line-removed"> 228         return axObject-&gt;isTree();</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230     case AccessibilitySearchKey::PlainText:</span>
<span class="line-removed"> 231         return axObject-&gt;hasPlainText();</span>
<span class="line-removed"> 232 </span>
<span class="line-removed"> 233     case AccessibilitySearchKey::RadioGroup:</span>
<span class="line-removed"> 234         return axObject-&gt;isRadioGroup();</span>
<span class="line-removed"> 235 </span>
<span class="line-removed"> 236     case AccessibilitySearchKey::SameType:</span>
<span class="line-removed"> 237         return criteria-&gt;startObject</span>
<span class="line-removed"> 238             &amp;&amp; axObject-&gt;roleValue() == criteria-&gt;startObject-&gt;roleValue();</span>
<span class="line-removed"> 239 </span>
<span class="line-removed"> 240     case AccessibilitySearchKey::StaticText:</span>
<span class="line-removed"> 241         return axObject-&gt;isStaticText();</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243     case AccessibilitySearchKey::StyleChange:</span>
<span class="line-removed"> 244         return criteria-&gt;startObject</span>
<span class="line-removed"> 245             &amp;&amp; !axObject-&gt;hasSameStyle(criteria-&gt;startObject-&gt;renderer());</span>
<span class="line-removed"> 246 </span>
<span class="line-removed"> 247     case AccessibilitySearchKey::TableSameLevel:</span>
<span class="line-removed"> 248         return criteria-&gt;startObject</span>
<span class="line-removed"> 249             &amp;&amp; is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility()</span>
<span class="line-removed"> 250             &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).tableLevel() == criteria-&gt;startObject-&gt;tableLevel();</span>
<span class="line-removed"> 251 </span>
<span class="line-removed"> 252     case AccessibilitySearchKey::Table:</span>
<span class="line-removed"> 253         return is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility();</span>
<span class="line-removed"> 254 </span>
<span class="line-removed"> 255     case AccessibilitySearchKey::TextField:</span>
<span class="line-removed"> 256         return axObject-&gt;isTextControl();</span>
<span class="line-removed"> 257 </span>
<span class="line-removed"> 258     case AccessibilitySearchKey::Underline:</span>
<span class="line-removed"> 259         return axObject-&gt;hasUnderline();</span>
<span class="line-removed"> 260 </span>
<span class="line-removed"> 261     case AccessibilitySearchKey::UnvisitedLink:</span>
<span class="line-removed"> 262         return axObject-&gt;isUnvisited();</span>
<span class="line-removed"> 263 </span>
<span class="line-removed"> 264     case AccessibilitySearchKey::VisitedLink:</span>
<span class="line-removed"> 265         return axObject-&gt;isVisited();</span>
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267     default:</span>
<span class="line-removed"> 268         return false;</span>
<span class="line-removed"> 269     }</span>
<span class="line-removed"> 270 }</span>
<span class="line-removed"> 271 </span>
<span class="line-removed"> 272 bool AccessibilityObject::isAccessibilityObjectSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)</span>
<span class="line-removed"> 273 {</span>
<span class="line-removed"> 274     if (!axObject || !criteria)</span>
<span class="line-removed"> 275         return false;</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277     size_t length = criteria-&gt;searchKeys.size();</span>
<span class="line-removed"> 278     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="line-removed"> 279         if (isAccessibilityObjectSearchMatchAtIndex(axObject, criteria, i)) {</span>
<span class="line-removed"> 280             if (criteria-&gt;visibleOnly &amp;&amp; !axObject-&gt;isOnscreen())</span>
<span class="line-removed"> 281                 return false;</span>
<span class="line-removed"> 282             return true;</span>
<span class="line-removed"> 283         }</span>
<span class="line-removed"> 284     }</span>
<span class="line-removed"> 285     return false;</span>
<span class="line-removed"> 286 }</span>
<span class="line-removed"> 287 </span>
<span class="line-removed"> 288 bool AccessibilityObject::isAccessibilityTextSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)</span>
<span class="line-removed"> 289 {</span>
<span class="line-removed"> 290     if (!axObject || !criteria)</span>
<span class="line-removed"> 291         return false;</span>
<span class="line-removed"> 292 </span>
<span class="line-removed"> 293     return axObject-&gt;accessibilityObjectContainsText(&amp;criteria-&gt;searchText);</span>
<span class="line-removed"> 294 }</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296 bool AccessibilityObject::accessibilityObjectContainsText(String* text) const</span>
<span class="line-removed"> 297 {</span>
<span class="line-removed"> 298     // If text is null or empty we return true.</span>
<span class="line-removed"> 299     return !text</span>
<span class="line-removed"> 300         || text-&gt;isEmpty()</span>
<span class="line-removed"> 301         || findPlainText(title(), *text, CaseInsensitive)</span>
<span class="line-removed"> 302         || findPlainText(accessibilityDescription(), *text, CaseInsensitive)</span>
<span class="line-removed"> 303         || findPlainText(stringValue(), *text, CaseInsensitive);</span>
<span class="line-removed"> 304 }</span>
<span class="line-removed"> 305 </span>
 306 // ARIA marks elements as having their accessible name derive from either their contents, or their author provide name.
 307 bool AccessibilityObject::accessibleNameDerivesFromContent() const
 308 {
 309     // First check for objects specifically identified by ARIA.
 310     switch (ariaRoleAttribute()) {
 311     case AccessibilityRole::ApplicationAlert:
 312     case AccessibilityRole::ApplicationAlertDialog:
 313     case AccessibilityRole::ApplicationDialog:
 314     case AccessibilityRole::ApplicationGroup:
 315     case AccessibilityRole::ApplicationLog:
 316     case AccessibilityRole::ApplicationMarquee:
 317     case AccessibilityRole::ApplicationStatus:
 318     case AccessibilityRole::ApplicationTimer:
 319     case AccessibilityRole::ComboBox:
 320     case AccessibilityRole::Definition:
 321     case AccessibilityRole::Document:
 322     case AccessibilityRole::DocumentArticle:
 323     case AccessibilityRole::DocumentMath:
 324     case AccessibilityRole::DocumentNote:
 325     case AccessibilityRole::LandmarkRegion:
</pre>
<hr />
<pre>
 446 
 447     bool isMisspelled = false;
 448 
 449     if (unifiedTextCheckerEnabled(frame)) {
 450         Vector&lt;TextCheckingResult&gt; results;
 451         checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, results, frame-&gt;selection().selection());
 452         if (!results.isEmpty())
 453             isMisspelled = true;
 454         return isMisspelled;
 455     }
 456 
 457     int misspellingLength = 0;
 458     int misspellingLocation = -1;
 459     textChecker-&gt;checkSpellingOfString(stringValue(), &amp;misspellingLocation, &amp;misspellingLength);
 460     if (misspellingLength || misspellingLocation != -1)
 461         isMisspelled = true;
 462 
 463     return isMisspelled;
 464 }
 465 

















































 466 unsigned AccessibilityObject::blockquoteLevel() const
 467 {
 468     unsigned level = 0;
 469     for (Node* elementNode = node(); elementNode; elementNode = elementNode-&gt;parentNode()) {
 470         if (elementNode-&gt;hasTagName(blockquoteTag))
 471             ++level;
 472     }
 473 
 474     return level;
 475 }
 476 
<span class="line-modified"> 477 AccessibilityObject* AccessibilityObject::parentObjectUnignored() const</span>
 478 {
<span class="line-modified"> 479     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {</span>
 480         return !object.accessibilityIsIgnored();
<span class="line-modified"> 481     }));</span>
 482 }
 483 
 484 AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
 485 {
 486     AccessibilityObject* previous;
 487     ASSERT(limit &gt;= 0);
 488     for (previous = previousSibling(); previous &amp;&amp; previous-&gt;accessibilityIsIgnored(); previous = previous-&gt;previousSibling()) {
 489         limit--;
 490         if (limit &lt;= 0)
 491             break;
 492     }
 493     return previous;
 494 }
 495 
 496 FloatRect AccessibilityObject::convertFrameToSpace(const FloatRect&amp; frameRect, AccessibilityConversionSpace conversionSpace) const
 497 {
 498     ASSERT(isMainThread());
 499 
 500     // Find the appropriate scroll view to use to convert the contents to the window.
 501     const auto parentAccessibilityScrollView = ancestorAccessibilityScrollView(false /* includeSelf */);
</pre>
<hr />
<pre>
 555         return nullptr;
 556 
 557     AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 558     while (accessibleObject &amp;&amp; !isAccessible(*accessibleObject)) {
 559         node = NodeTraversal::next(*node);
 560 
 561         while (node &amp;&amp; !node-&gt;renderer())
 562             node = NodeTraversal::nextSkippingChildren(*node);
 563 
 564         if (!node)
 565             return nullptr;
 566 
 567         accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 568     }
 569 
 570     return accessibleObject;
 571 }
 572 
 573 bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
 574 {
<span class="line-modified"> 575     return AccessibilityObject::matchedParent(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {</span>
 576         return object.roleValue() == role;
 577     }) != nullptr;
 578 }
 579 
<span class="line-modified"> 580 static void appendAccessibilityObject(AccessibilityObject* object, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
 581 {
 582     // Find the next descendant of this attachment object so search can continue through frames.
 583     if (object-&gt;isAttachment()) {
 584         Widget* widget = object-&gt;widgetForAttachmentView();
 585         if (!is&lt;FrameView&gt;(widget))
 586             return;
 587 
 588         Document* document = downcast&lt;FrameView&gt;(*widget).frame().document();
 589         if (!document || !document-&gt;hasLivingRenderTree())
 590             return;
 591 
 592         object = object-&gt;axObjectCache()-&gt;getOrCreate(document);
 593     }
 594 
 595     if (object)
 596         results.append(object);
 597 }
 598 
<span class="line-modified"> 599 void AccessibilityObject::insertChild(AccessibilityObject* child, unsigned index)</span>
 600 {
 601     if (!child)
 602         return;
 603 
 604     // If the parent is asking for this child&#39;s children, then either it&#39;s the first time (and clearing is a no-op),
 605     // or its visibility has changed. In the latter case, this child may have a stale child cached.
 606     // This can prevent aria-hidden changes from working correctly. Hence, whenever a parent is getting children, ensure data is not stale.
 607     // Only clear the child&#39;s children when we know it&#39;s in the updating chain in order to avoid unnecessary work.
 608     if (child-&gt;needsToUpdateChildren() || m_subtreeDirty) {
 609         child-&gt;clearChildren();
 610         // Pass m_subtreeDirty flag down to the child so that children cache gets reset properly.
 611         if (m_subtreeDirty)
 612             child-&gt;setNeedsToUpdateSubtree();
 613     } else {
 614         // For some reason the grand children might be detached so that we need to regenerate the
 615         // children list of this child.
 616         for (const auto&amp; grandChild : child-&gt;children(false)) {
 617             if (grandChild-&gt;isDetachedFromParent()) {
 618                 child-&gt;clearChildren();
 619                 break;
 620             }
 621         }
 622     }
 623 
 624     setIsIgnoredFromParentDataForChild(child);
 625     if (child-&gt;accessibilityIsIgnored()) {
 626         const auto&amp; children = child-&gt;children();
 627         size_t length = children.size();
 628         for (size_t i = 0; i &lt; length; ++i)
 629             m_children.insert(index + i, children[i]);
 630     } else {
 631         ASSERT(child-&gt;parentObject() == this);
 632         m_children.insert(index, child);
 633     }
 634 
 635     // Reset the child&#39;s m_isIgnoredFromParentData since we are done adding that child and its children.
 636     child-&gt;clearIsIgnoredFromParentData();
 637 }
 638 
<span class="line-modified"> 639 void AccessibilityObject::addChild(AccessibilityObject* child)</span>
 640 {
 641     insertChild(child, m_children.size());
 642 }
 643 
<span class="line-modified"> 644 static void appendChildrenToArray(AccessibilityObject* object, bool isForward, AccessibilityObject* startObject, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
 645 {
 646     // A table&#39;s children includes elements whose own children are also the table&#39;s children (due to the way the Mac exposes tables).
 647     // The rows from the table should be queried, since those are direct descendants of the table, and they contain content.
 648     const auto&amp; searchChildren = is&lt;AccessibilityTable&gt;(*object) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*object).isExposableThroughAccessibility() ? downcast&lt;AccessibilityTable&gt;(*object).rows() : object-&gt;children();
 649 
 650     size_t childrenSize = searchChildren.size();
 651 
 652     size_t startIndex = isForward ? childrenSize : 0;
 653     size_t endIndex = isForward ? 0 : childrenSize;
 654 
 655     // If the startObject is ignored, we should use an accessible sibling as a start element instead.
 656     if (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored() &amp;&amp; startObject-&gt;isDescendantOfObject(object)) {
<span class="line-modified"> 657         AccessibilityObject* parentObject = startObject-&gt;parentObject();</span>
 658         // Go up the parent chain to find the highest ancestor that&#39;s also being ignored.
 659         while (parentObject &amp;&amp; parentObject-&gt;accessibilityIsIgnored()) {
 660             if (parentObject == object)
 661                 break;
 662             startObject = parentObject;
 663             parentObject = parentObject-&gt;parentObject();
 664         }
 665         // Get the un-ignored sibling based on the search direction, and update the searchPosition.
 666         while (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored())
 667             startObject = isForward ? startObject-&gt;previousSibling() : startObject-&gt;nextSibling();
 668     }
 669 
 670     size_t searchPosition = startObject ? searchChildren.find(startObject) : WTF::notFound;
 671 
 672     if (searchPosition != WTF::notFound) {
 673         if (isForward)
 674             endIndex = searchPosition + 1;
 675         else
 676             endIndex = searchPosition;
 677     }
 678 
 679     // This is broken into two statements so that it&#39;s easier read.
 680     if (isForward) {
 681         for (size_t i = startIndex; i &gt; endIndex; i--)
 682             appendAccessibilityObject(searchChildren.at(i - 1).get(), results);
 683     } else {
 684         for (size_t i = startIndex; i &lt; endIndex; i++)
 685             appendAccessibilityObject(searchChildren.at(i).get(), results);
 686     }
 687 }
 688 
<span class="line-removed"> 689 // Returns true if the number of results is now &gt;= the number of results desired.</span>
<span class="line-removed"> 690 bool AccessibilityObject::objectMatchesSearchCriteriaWithResultLimit(AccessibilityObject* object, AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)</span>
<span class="line-removed"> 691 {</span>
<span class="line-removed"> 692     if (isAccessibilityObjectSearchMatch(object, criteria) &amp;&amp; isAccessibilityTextSearchMatch(object, criteria)) {</span>
<span class="line-removed"> 693         results.append(object);</span>
<span class="line-removed"> 694 </span>
<span class="line-removed"> 695         // Enough results were found to stop searching.</span>
<span class="line-removed"> 696         if (results.size() &gt;= criteria-&gt;resultsLimit)</span>
<span class="line-removed"> 697             return true;</span>
<span class="line-removed"> 698     }</span>
<span class="line-removed"> 699 </span>
<span class="line-removed"> 700     return false;</span>
<span class="line-removed"> 701 }</span>
<span class="line-removed"> 702 </span>
 703 void AccessibilityObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 704 {
 705     ASSERT(criteria);
<span class="line-removed"> 706 </span>
 707     if (!criteria)
 708         return;
 709 
 710     if (AXObjectCache* cache = axObjectCache())
 711         cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
 712 
<span class="line-modified"> 713     // This search mechanism only searches the elements before/after the starting object.</span>
<span class="line-modified"> 714     // It does this by stepping up the parent chain and at each level doing a DFS.</span>
<span class="line-removed"> 715 </span>
<span class="line-removed"> 716     // If there&#39;s no start object, it means we want to search everything.</span>
<span class="line-removed"> 717     AccessibilityObject* startObject = criteria-&gt;startObject;</span>
<span class="line-removed"> 718     if (!startObject)</span>
<span class="line-removed"> 719         startObject = this;</span>
<span class="line-removed"> 720 </span>
<span class="line-removed"> 721     bool isForward = criteria-&gt;searchDirection == AccessibilitySearchDirection::Next;</span>
<span class="line-removed"> 722 </span>
<span class="line-removed"> 723     // The first iteration of the outer loop will examine the children of the start object for matches. However, when</span>
<span class="line-removed"> 724     // iterating backwards, the start object children should not be considered, so the loop is skipped ahead. We make an</span>
<span class="line-removed"> 725     // exception when no start object was specified because we want to search everything regardless of search direction.</span>
<span class="line-removed"> 726     AccessibilityObject* previousObject = nullptr;</span>
<span class="line-removed"> 727     if (!isForward &amp;&amp; startObject != this) {</span>
<span class="line-removed"> 728         previousObject = startObject;</span>
<span class="line-removed"> 729         startObject = startObject-&gt;parentObjectUnignored();</span>
<span class="line-removed"> 730     }</span>
<span class="line-removed"> 731 </span>
<span class="line-removed"> 732     // The outer loop steps up the parent chain each time (unignored is important here because otherwise elements would be searched twice)</span>
<span class="line-removed"> 733     for (AccessibilityObject* stopSearchElement = parentObjectUnignored(); startObject &amp;&amp; startObject != stopSearchElement; startObject = startObject-&gt;parentObjectUnignored()) {</span>
<span class="line-removed"> 734 </span>
<span class="line-removed"> 735         // Only append the children after/before the previous element, so that the search does not check elements that are</span>
<span class="line-removed"> 736         // already behind/ahead of start element.</span>
<span class="line-removed"> 737         AccessibilityChildrenVector searchStack;</span>
<span class="line-removed"> 738         if (!criteria-&gt;immediateDescendantsOnly || startObject == this)</span>
<span class="line-removed"> 739             appendChildrenToArray(startObject, isForward, previousObject, searchStack);</span>
<span class="line-removed"> 740 </span>
<span class="line-removed"> 741         // This now does a DFS at the current level of the parent.</span>
<span class="line-removed"> 742         while (!searchStack.isEmpty()) {</span>
<span class="line-removed"> 743             AccessibilityObject* searchObject = searchStack.last().get();</span>
<span class="line-removed"> 744             searchStack.removeLast();</span>
<span class="line-removed"> 745 </span>
<span class="line-removed"> 746             if (objectMatchesSearchCriteriaWithResultLimit(searchObject, criteria, results))</span>
<span class="line-removed"> 747                 break;</span>
<span class="line-removed"> 748 </span>
<span class="line-removed"> 749             if (!criteria-&gt;immediateDescendantsOnly)</span>
<span class="line-removed"> 750                 appendChildrenToArray(searchObject, isForward, 0, searchStack);</span>
<span class="line-removed"> 751         }</span>
<span class="line-removed"> 752 </span>
<span class="line-removed"> 753         if (results.size() &gt;= criteria-&gt;resultsLimit)</span>
<span class="line-removed"> 754             break;</span>
<span class="line-removed"> 755 </span>
<span class="line-removed"> 756         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.</span>
<span class="line-removed"> 757         if (!isForward &amp;&amp; startObject != this &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))</span>
<span class="line-removed"> 758             break;</span>
<span class="line-removed"> 759 </span>
<span class="line-removed"> 760         previousObject = startObject;</span>
<span class="line-removed"> 761     }</span>
 762 }
 763 
 764 // Returns the range that is fewer positions away from the reference range.
 765 // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
 766 // range is expected to ACTUALLY be before. These are not checked for performance reasons.
 767 static RefPtr&lt;Range&gt; rangeClosestToRange(RefPtr&lt;Range&gt; const&amp; referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)
 768 {
 769     if (!referenceRange)
 770         return nullptr;
 771 
 772     // The treeScope for shadow nodes may not be the same scope as another element in a document.
 773     // Comparisons may fail in that case, which are expected behavior and should not assert.
 774     if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 775         return nullptr;
 776     ASSERT(!afterRange || afterRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &gt;= 0);
 777 
 778     if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 779         return nullptr;
 780     ASSERT(!beforeRange || beforeRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &lt;= 0);
 781 
</pre>
<hr />
<pre>
 916         findAll(AccessibilitySearchTextDirection::Forward);
 917         findAll(AccessibilitySearchTextDirection::Backward);
 918         break;
 919     }
 920     }
 921 
 922     return result;
 923 }
 924 
 925 Vector&lt;String&gt; AccessibilityObject::performTextOperation(AccessibilityTextOperation const&amp; operation)
 926 {
 927     Vector&lt;String&gt; result;
 928 
 929     if (operation.textRanges.isEmpty())
 930         return result;
 931 
 932     Frame* frame = this-&gt;frame();
 933     if (!frame)
 934         return result;
 935 
<span class="line-modified"> 936     for (auto textRange : operation.textRanges) {</span>
 937         if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))
 938             continue;
 939 
 940         String text = textRange-&gt;text();
 941         String replacementString = operation.replacementText;
 942         bool replaceSelection = false;
 943         switch (operation.type) {
 944         case AccessibilityTextOperationType::Capitalize:
 945             replacementString = capitalize(text, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.
 946             replaceSelection = true;
 947             break;
 948         case AccessibilityTextOperationType::Uppercase:
 949             replacementString = text.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 950             replaceSelection = true;
 951             break;
 952         case AccessibilityTextOperationType::Lowercase:
 953             replacementString = text.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 954             replaceSelection = true;
 955             break;
 956         case AccessibilityTextOperationType::Replace: {
</pre>
<hr />
<pre>
1368 }
1369 
1370 // NOTE: Consider providing this utility method as AX API
1371 VisiblePositionRange AccessibilityObject::visiblePositionRangeForRange(const PlainTextRange&amp; range) const
1372 {
1373     unsigned textLength = getLengthForTextRange();
1374     if (range.start + range.length &gt; textLength)
1375         return VisiblePositionRange();
1376 
1377     VisiblePosition startPosition = visiblePositionForIndex(range.start);
1378     startPosition.setAffinity(DOWNSTREAM);
1379     VisiblePosition endPosition = visiblePositionForIndex(range.start + range.length);
1380     return VisiblePositionRange(startPosition, endPosition);
1381 }
1382 
1383 RefPtr&lt;Range&gt; AccessibilityObject::rangeForPlainTextRange(const PlainTextRange&amp; range) const
1384 {
1385     unsigned textLength = getLengthForTextRange();
1386     if (range.start + range.length &gt; textLength)
1387         return nullptr;



1388 
1389     if (AXObjectCache* cache = axObjectCache()) {
1390         CharacterOffset start = cache-&gt;characterOffsetForIndex(range.start, this);
1391         CharacterOffset end = cache-&gt;characterOffsetForIndex(range.start + range.length, this);
1392         return cache-&gt;rangeForUnorderedCharacterOffsets(start, end);
1393     }
1394     return nullptr;
1395 }
1396 
1397 VisiblePositionRange AccessibilityObject::lineRangeForPosition(const VisiblePosition&amp; visiblePosition) const
1398 {
1399     VisiblePosition startPosition = startOfLine(visiblePosition);
1400     VisiblePosition endPosition = endOfLine(visiblePosition);
1401     return VisiblePositionRange(startPosition, endPosition);
1402 }
1403 
1404 bool AccessibilityObject::replacedNodeNeedsCharacter(Node* replacedNode)
1405 {
1406     // we should always be given a rendered node and a replaced node, but be safe
1407     // replaced nodes are either attachments (widgets) or images
</pre>
<hr />
<pre>
1873 {
1874     if (!axObjectCache())
1875         return;
1876 
1877     // Updating the layout may delete this object.
1878     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1879     if (auto* document = this-&gt;document()) {
1880         if (!document-&gt;view()-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !document-&gt;inRenderTreeUpdate() &amp;&amp; !document-&gt;inStyleRecalc())
1881             document-&gt;updateLayoutIgnorePendingStylesheets();
1882     }
1883 
1884     if (auto cache = axObjectCache())
1885         cache-&gt;performDeferredCacheUpdate();
1886 
1887     updateChildrenIfNecessary();
1888 }
1889 #endif
1890 
1891 const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const
1892 {
<span class="line-modified">1893     return downcast&lt;AccessibilityScrollView&gt;(AccessibilityObject::matchedParent(*this, includeSelf, [] (const auto&amp; object) {</span>
1894         return is&lt;AccessibilityScrollView&gt;(object);
1895     }));
1896 }
1897 
1898 ScrollView* AccessibilityObject::scrollViewAncestor() const
1899 {
1900     if (auto parentScrollView = ancestorAccessibilityScrollView(true/* includeSelf */))
1901         return parentScrollView-&gt;scrollView();
1902 
1903     return nullptr;
1904 }
1905 
1906 Document* AccessibilityObject::document() const
1907 {
1908     FrameView* frameView = documentFrameView();
1909     if (!frameView)
1910         return nullptr;
1911 
1912     return frameView-&gt;frame().document();
1913 }
</pre>
<hr />
<pre>
1928 
1929     if (!object)
1930         return nullptr;
1931 
1932     return object-&gt;documentFrameView();
1933 }
1934 
1935 #if ENABLE(ACCESSIBILITY)
1936 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
1937 {
1938     if (updateChildrenIfNeeded)
1939         updateChildrenIfNecessary();
1940 
1941     return m_children;
1942 }
1943 #endif
1944 
1945 void AccessibilityObject::updateChildrenIfNecessary()
1946 {
1947     if (!hasChildren()) {

1948         // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
1949         AXAttributeCacheEnabler enableCache(axObjectCache());

1950         addChildren();
1951     }
1952 }
1953 
1954 void AccessibilityObject::clearChildren()
1955 {
1956     // Some objects have weak pointers to their parents and those associations need to be detached.
1957     for (const auto&amp; child : m_children)
1958         child-&gt;detachFromParent();
1959 
1960     m_children.clear();
1961     m_haveChildren = false;
1962 }
1963 
1964 AccessibilityObject* AccessibilityObject::anchorElementForNode(Node* node)
1965 {
1966     RenderObject* obj = node-&gt;renderer();
1967     if (!obj)
1968         return nullptr;
1969 
</pre>
<hr />
<pre>
1973         return nullptr;
1974 
1975     RenderObject* anchorRenderer = anchor-&gt;renderer();
1976     if (!anchorRenderer)
1977         return nullptr;
1978 
1979     return anchorRenderer-&gt;document().axObjectCache()-&gt;getOrCreate(anchorRenderer);
1980 }
1981 
1982 AccessibilityObject* AccessibilityObject::headingElementForNode(Node* node)
1983 {
1984     if (!node)
1985         return nullptr;
1986 
1987     RenderObject* renderObject = node-&gt;renderer();
1988     if (!renderObject)
1989         return nullptr;
1990 
1991     AccessibilityObject* axObject = renderObject-&gt;document().axObjectCache()-&gt;getOrCreate(renderObject);
1992 
<span class="line-modified">1993     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*axObject, true, [] (const AccessibilityObject&amp; object) {</span>
1994         return object.roleValue() == AccessibilityRole::Heading;
<span class="line-modified">1995     }));</span>
<span class="line-removed">1996 }</span>
<span class="line-removed">1997 </span>
<span class="line-removed">1998 const AccessibilityObject* AccessibilityObject::matchedParent(const AccessibilityObject&amp; object, bool includeSelf, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; matches)</span>
<span class="line-removed">1999 {</span>
<span class="line-removed">2000     const AccessibilityObject* parent = includeSelf ? &amp;object : object.parentObject();</span>
<span class="line-removed">2001     for (; parent; parent = parent-&gt;parentObject()) {</span>
<span class="line-removed">2002         if (matches(*parent))</span>
<span class="line-removed">2003             return parent;</span>
<span class="line-removed">2004     }</span>
<span class="line-removed">2005     return nullptr;</span>
2006 }
2007 
2008 void AccessibilityObject::ariaTreeRows(AccessibilityChildrenVector&amp; result)
2009 {
2010     for (const auto&amp; child : children()) {
2011         // Add tree items as the rows.
2012         if (child-&gt;roleValue() == AccessibilityRole::TreeItem)
2013             result.append(child);
2014 
2015         // Now see if this item also has rows hiding inside of it.
2016         child-&gt;ariaTreeRows(result);
2017     }
2018 }
2019 
2020 void AccessibilityObject::ariaTreeItemContent(AccessibilityChildrenVector&amp; result)
2021 {
2022     // The ARIA tree item content are the item that are not other tree items or their containing groups.
2023     for (const auto&amp; child : children()) {
2024         if (!child-&gt;isGroup() &amp;&amp; child-&gt;roleValue() != AccessibilityRole::TreeItem)
2025             result.append(child);
</pre>
<hr />
<pre>
2039 }
2040 
2041 const String AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityRole role)
2042 {
2043     switch (role) {
2044     case AccessibilityRole::ApplicationAlertDialog:
2045     case AccessibilityRole::ApplicationAlert:
2046         return &quot;assertive&quot;_s;
2047     case AccessibilityRole::ApplicationLog:
2048     case AccessibilityRole::ApplicationStatus:
2049         return &quot;polite&quot;_s;
2050     case AccessibilityRole::ApplicationTimer:
2051     case AccessibilityRole::ApplicationMarquee:
2052         return &quot;off&quot;_s;
2053     default:
2054         return nullAtom();
2055     }
2056 }
2057 
2058 #if ENABLE(ACCESSIBILITY)
<span class="line-modified">2059 const String&amp; AccessibilityObject::actionVerb() const</span>
2060 {
2061 #if !PLATFORM(IOS_FAMILY)
2062     // FIXME: Need to add verbs for select elements.
2063     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
2064     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
2065     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
2066     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXCheckedCheckBoxActionVerb());
2067     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
2068     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
2069     static NeverDestroyed&lt;const String&gt; menuListAction(AXMenuListActionVerb());
2070     static NeverDestroyed&lt;const String&gt; menuListPopupAction(AXMenuListPopupActionVerb());
2071     static NeverDestroyed&lt;const String&gt; listItemAction(AXListItemActionVerb());
2072 
2073     switch (roleValue()) {
2074     case AccessibilityRole::Button:
2075     case AccessibilityRole::ToggleButton:
2076         return buttonAction;
2077     case AccessibilityRole::TextField:
2078     case AccessibilityRole::TextArea:
2079         return textFieldAction;
</pre>
<hr />
<pre>
2295     if (!element.shouldUseInputMethod())
2296         return false;
2297 
2298     // Use Editor::insertText to mimic typing into the field.
2299     auto&amp; editor = renderer()-&gt;frame().editor();
2300     return editor.insertText(text, nullptr);
2301 }
2302 
2303 // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
2304 AccessibilityOrientation AccessibilityObject::orientation() const
2305 {
2306     LayoutRect bounds = elementRect();
2307     if (bounds.size().width() &gt; bounds.size().height())
2308         return AccessibilityOrientation::Horizontal;
2309     if (bounds.size().height() &gt; bounds.size().width())
2310         return AccessibilityOrientation::Vertical;
2311 
2312     return AccessibilityOrientation::Undefined;
2313 }
2314 
<span class="line-modified">2315 bool AccessibilityObject::isDescendantOfObject(const AccessibilityObject* axObject) const</span>
2316 {
2317     if (!axObject || !axObject-&gt;hasChildren())
2318         return false;
2319 
<span class="line-modified">2320     return AccessibilityObject::matchedParent(*this, false, [axObject] (const AccessibilityObject&amp; object) {</span>
2321         return &amp;object == axObject;
2322     }) != nullptr;
2323 }
2324 
<span class="line-modified">2325 bool AccessibilityObject::isAncestorOfObject(const AccessibilityObject* axObject) const</span>
2326 {
2327     if (!axObject)
2328         return false;
2329 
2330     return this == axObject || axObject-&gt;isDescendantOfObject(this);
2331 }
2332 
2333 AccessibilityObject* AccessibilityObject::firstAnonymousBlockChild() const
2334 {
2335     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
2336         if (child-&gt;renderer() &amp;&amp; child-&gt;renderer()-&gt;isAnonymousBlock())
2337             return child;
2338     }
2339     return nullptr;
2340 }
2341 
2342 using ARIARoleMap = HashMap&lt;String, AccessibilityRole, ASCIICaseInsensitiveHash&gt;;
2343 using ARIAReverseRoleMap = HashMap&lt;AccessibilityRole, String, DefaultHash&lt;int&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt;;
2344 
2345 static ARIARoleMap* gAriaRoleMap = nullptr;
</pre>
<hr />
<pre>
2546 
2547     if (role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton)
2548         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Button));
2549 
2550     if (role == AccessibilityRole::LandmarkDocRegion)
2551         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::LandmarkRegion));
2552 
2553     return reverseAriaRoleMap().get(static_cast&lt;int&gt;(role));
2554 }
2555 
2556 bool AccessibilityObject::hasHighlighting() const
2557 {
2558     for (Node* node = this-&gt;node(); node; node = node-&gt;parentNode()) {
2559         if (node-&gt;hasTagName(markTag))
2560             return true;
2561     }
2562 
2563     return false;
2564 }
2565 

































































2566 String AccessibilityObject::roleDescription() const
2567 {
<span class="line-modified">2568     return stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_roledescriptionAttr));</span>












2569 }
2570 
2571 bool nodeHasPresentationRole(Node* node)
2572 {
2573     return nodeHasRole(node, &quot;presentation&quot;) || nodeHasRole(node, &quot;none&quot;);
2574 }
2575 
2576 bool AccessibilityObject::supportsPressAction() const
2577 {
2578     if (isButton())
2579         return true;
2580     if (roleValue() == AccessibilityRole::Details)
2581         return true;
2582 
2583     Element* actionElement = this-&gt;actionElement();
2584     if (!actionElement)
2585         return false;
2586 
2587     // [Bug: 136247] Heuristic: element handlers that have more than one accessible descendant should not be exposed as supporting press.
2588     if (actionElement != element()) {
</pre>
<hr />
<pre>
2591             // Search within for immediate descendants that are static text. If we find more than one
2592             // then this is an event delegator actionElement and we should expose the press action.
2593             Vector&lt;AccessibilitySearchKey&gt; keys({ AccessibilitySearchKey::StaticText, AccessibilitySearchKey::Control, AccessibilitySearchKey::Graphic, AccessibilitySearchKey::Heading, AccessibilitySearchKey::Link });
2594             AccessibilitySearchCriteria criteria(axObj, AccessibilitySearchDirection::Next, emptyString(), 2, false, false);
2595             criteria.searchKeys = keys;
2596             axObj-&gt;findMatchingObjects(&amp;criteria, results);
2597             if (results.size() &gt; 1)
2598                 return false;
2599         }
2600     }
2601 
2602     // [Bug: 133613] Heuristic: If the action element is presentational, we shouldn&#39;t expose press as a supported action.
2603     return !nodeHasPresentationRole(actionElement);
2604 }
2605 
2606 bool AccessibilityObject::supportsDatetimeAttribute() const
2607 {
2608     return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
2609 }
2610 
<span class="line-modified">2611 const AtomString&amp; AccessibilityObject::datetimeAttributeValue() const</span>
2612 {
2613     return getAttribute(datetimeAttr);
2614 }
2615 
<span class="line-modified">2616 const AtomString&amp; AccessibilityObject::linkRelValue() const</span>
2617 {
2618     return getAttribute(relAttr);
2619 }
2620 





2621 const String AccessibilityObject::keyShortcutsValue() const
2622 {
2623     return getAttribute(aria_keyshortcutsAttr);
2624 }
2625 
2626 Element* AccessibilityObject::element() const
2627 {
2628     Node* node = this-&gt;node();
2629     if (is&lt;Element&gt;(node))
2630         return downcast&lt;Element&gt;(node);
2631     return nullptr;
2632 }
2633 
2634 bool AccessibilityObject::isValueAutofillAvailable() const
2635 {
2636     if (!isNativeTextControl())
2637         return false;
2638 
2639     Node* node = this-&gt;node();
2640     if (!is&lt;HTMLInputElement&gt;(node))
</pre>
<hr />
<pre>
2666 const String AccessibilityObject::placeholderValue() const
2667 {
2668     const AtomString&amp; placeholder = getAttribute(placeholderAttr);
2669     if (!placeholder.isEmpty())
2670         return placeholder;
2671 
2672     const AtomString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);
2673     if (!ariaPlaceholder.isEmpty())
2674         return ariaPlaceholder;
2675 
2676     return nullAtom();
2677 }
2678 
2679 bool AccessibilityObject::isInsideLiveRegion(bool excludeIfOff) const
2680 {
2681     return liveRegionAncestor(excludeIfOff);
2682 }
2683 
2684 AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
2685 {
<span class="line-modified">2686     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {</span>
2687         return object.supportsLiveRegion(excludeIfOff);
<span class="line-modified">2688     }));</span>
2689 }
2690 
2691 bool AccessibilityObject::supportsARIAAttributes() const
2692 {
2693     // This returns whether the element supports any global ARIA attributes.
2694     return supportsLiveRegion()
2695         || supportsARIADragging()
2696         || supportsARIADropping()
2697         || supportsARIAOwns()
2698         || hasAttribute(aria_atomicAttr)
2699         || hasAttribute(aria_busyAttr)
2700         || hasAttribute(aria_controlsAttr)
2701         || hasAttribute(aria_currentAttr)
2702         || hasAttribute(aria_describedbyAttr)
2703         || hasAttribute(aria_detailsAttr)
2704         || hasAttribute(aria_disabledAttr)
2705         || hasAttribute(aria_errormessageAttr)
2706         || hasAttribute(aria_flowtoAttr)
2707         || hasAttribute(aria_haspopupAttr)
2708         || hasAttribute(aria_invalidAttr)
2709         || hasAttribute(aria_labelAttr)
2710         || hasAttribute(aria_labelledbyAttr)
2711         || hasAttribute(aria_relevantAttr);
2712 }
2713 
2714 bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomString&amp; liveRegionStatus)
2715 {
2716     return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
2717 }
2718 
2719 bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
2720 {
2721     const AtomString&amp; liveRegionStatusValue = liveRegionStatus();
2722     return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
2723 }
2724 
<span class="line-modified">2725 AccessibilityObjectInterface* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2726 {
2727     // Send the hit test back into the sub-frame if necessary.
2728     if (isAttachment()) {
2729         Widget* widget = widgetForAttachmentView();
2730         // Normalize the point for the widget&#39;s bounds.
2731         if (widget &amp;&amp; widget-&gt;isFrameView()) {
2732             if (AXObjectCache* cache = axObjectCache())
2733                 return cache-&gt;getOrCreate(widget)-&gt;accessibilityHitTest(IntPoint(point - widget-&gt;frameRect().location()));
2734         }
2735     }
2736 
2737     // Check if there are any mock elements that need to be handled.
2738     for (const auto&amp; child : m_children) {
2739         if (child-&gt;isMockObject() &amp;&amp; child-&gt;elementRect().contains(point))
2740             return child-&gt;elementAccessibilityHitTest(point);
2741     }
2742 
2743     return const_cast&lt;AccessibilityObject*&gt;(this);
2744 }
2745 
2746 AXObjectCache* AccessibilityObject::axObjectCache() const
2747 {
2748     auto* document = this-&gt;document();
2749     return document ? document-&gt;axObjectCache() : nullptr;
2750 }
2751 
<span class="line-modified">2752 AccessibilityObjectInterface* AccessibilityObject::focusedUIElement() const</span>
2753 {
2754     auto* page = this-&gt;page();
<span class="line-modified">2755     return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;</span>

2756 }
2757 
2758 AccessibilitySortDirection AccessibilityObject::sortDirection() const
2759 {
2760     AccessibilityRole role = roleValue();
2761     if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
2762         return AccessibilitySortDirection::Invalid;
2763 
2764     const AtomString&amp; sortAttribute = getAttribute(aria_sortAttr);
2765     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
2766         return AccessibilitySortDirection::Ascending;
2767     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
2768         return AccessibilitySortDirection::Descending;
2769     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
2770         return AccessibilitySortDirection::Other;
2771 
2772     return AccessibilitySortDirection::None;
2773 }
2774 
2775 bool AccessibilityObject::supportsRangeValue() const
</pre>
<hr />
<pre>
2835 bool AccessibilityObject::supportsSetSize() const
2836 {
2837     return hasAttribute(aria_setsizeAttr);
2838 }
2839 
2840 bool AccessibilityObject::supportsPosInSet() const
2841 {
2842     return hasAttribute(aria_posinsetAttr);
2843 }
2844 
2845 int AccessibilityObject::setSize() const
2846 {
2847     return getAttribute(aria_setsizeAttr).toInt();
2848 }
2849 
2850 int AccessibilityObject::posInSet() const
2851 {
2852     return getAttribute(aria_posinsetAttr).toInt();
2853 }
2854 
<span class="line-modified">2855 const AtomString&amp; AccessibilityObject::identifierAttribute() const</span>
2856 {
2857     return getAttribute(idAttr);
2858 }
2859 
2860 void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
2861 {
2862     Node* node = this-&gt;node();
2863     if (!is&lt;Element&gt;(node))
2864         return;
2865 
2866     Element* element = downcast&lt;Element&gt;(node);
2867     DOMTokenList&amp; list = element-&gt;classList();
2868     unsigned length = list.length();
2869     for (unsigned k = 0; k &lt; length; k++)
2870         classList.append(list.item(k).string());
2871 }
2872 
2873 bool AccessibilityObject::supportsPressed() const
2874 {
2875     const AtomString&amp; expanded = getAttribute(aria_pressedAttr);
</pre>
<hr />
<pre>
2885     switch (roleValue()) {
2886     case AccessibilityRole::ComboBox:
2887     case AccessibilityRole::DisclosureTriangle:
2888     case AccessibilityRole::Details:
2889         return true;
2890     default:
2891         return false;
2892     }
2893 }
2894 
2895 bool AccessibilityObject::isExpanded() const
2896 {
2897     if (equalLettersIgnoringASCIICase(getAttribute(aria_expandedAttr), &quot;true&quot;))
2898         return true;
2899 
2900     if (is&lt;HTMLDetailsElement&gt;(node()))
2901         return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
2902 
2903     // Summary element should use its details parent&#39;s expanded status.
2904     if (isSummary()) {
<span class="line-modified">2905         if (const AccessibilityObject* parent = AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {</span>
2906             return is&lt;HTMLDetailsElement&gt;(object.node());
2907         }))
2908             return parent-&gt;isExpanded();
2909     }
2910 
2911     return false;
2912 }
2913 
2914 bool AccessibilityObject::supportsChecked() const
2915 {
2916     switch (roleValue()) {
2917     case AccessibilityRole::CheckBox:
2918     case AccessibilityRole::MenuItemCheckbox:
2919     case AccessibilityRole::MenuItemRadio:
2920     case AccessibilityRole::RadioButton:
2921     case AccessibilityRole::Switch:
2922         return true;
2923     default:
2924         return false;
2925     }
</pre>
<hr />
<pre>
3030         if (subfocusMax - subfocusMin &gt; viewportSize)
3031             subfocusMax = subfocusMin + viewportSize;
3032 
3033         // Compute the size of an object centered on the subfocus, the size of the viewport.
3034         int centeredObjectMin = (subfocusMin + subfocusMax - viewportSize) / 2;
3035         int centeredObjectMax = centeredObjectMin + viewportSize;
3036 
3037         objectMin = std::max(objectMin, centeredObjectMin);
3038         objectMax = std::min(objectMax, centeredObjectMax);
3039     }
3040 
3041     // Exit now if the focus is already within the viewport.
3042     if (objectMin - currentScrollOffset &gt;= viewportMin
3043         &amp;&amp; objectMax - currentScrollOffset &lt;= viewportMax)
3044         return currentScrollOffset;
3045 
3046     // Center the object in the viewport.
3047     return (objectMin + objectMax - viewportMin - viewportMax) / 2;
3048 }
3049 
<span class="line-modified">3050 bool AccessibilityObject::isOnscreen() const</span>
3051 {
3052     bool isOnscreen = true;
3053 
3054     // To figure out if the element is onscreen, we start by building of a stack starting with the
3055     // element, and then include every scrollable parent in the hierarchy.
3056     Vector&lt;const AccessibilityObject*&gt; objects;
3057 
3058     objects.append(this);
3059     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
3060         if (parentObject-&gt;getScrollableAreaIfScrollable())
3061             objects.append(parentObject);
3062     }
3063 
3064     // Now, go back through that chain and make sure each inner object is within the
3065     // visible bounds of the outer object.
3066     size_t levels = objects.size() - 1;
3067 
3068     for (size_t i = levels; i &gt;= 1; i--) {
3069         const AccessibilityObject* outer = objects[i];
3070         const AccessibilityObject* inner = objects[i - 1];
</pre>
<hr />
<pre>
3352 
3353     return AccessibilityRole::Button;
3354 }
3355 
3356 bool AccessibilityObject::isButton() const
3357 {
3358     AccessibilityRole role = roleValue();
3359 
3360     return role == AccessibilityRole::Button || role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton;
3361 }
3362 
3363 bool AccessibilityObject::accessibilityIsIgnoredByDefault() const
3364 {
3365     return defaultObjectInclusion() == AccessibilityObjectInclusion::IgnoreObject;
3366 }
3367 
3368 // ARIA component of hidden definition.
3369 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3370 bool AccessibilityObject::isAXHidden() const
3371 {
<span class="line-modified">3372     return AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3373         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;true&quot;);
3374     }) != nullptr;
3375 }
3376 
3377 // DOM component of hidden definition.
3378 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3379 bool AccessibilityObject::isDOMHidden() const
3380 {
3381     RenderObject* renderer = this-&gt;renderer();
3382     if (!renderer)
3383         return true;
3384 
3385     const RenderStyle&amp; style = renderer-&gt;style();
3386     return style.display() == DisplayType::None || style.visibility() != Visibility::Visible;
3387 }
3388 
3389 bool AccessibilityObject::isShowingValidationMessage() const
3390 {
3391     if (is&lt;HTMLFormControlElement&gt;(node()))
3392         return downcast&lt;HTMLFormControlElement&gt;(*node()).isShowingValidationMessage();
</pre>
<hr />
<pre>
3407     if (useParentData ? m_isIgnoredFromParentData.isAXHidden : isAXHidden())
3408         return AccessibilityObjectInclusion::IgnoreObject;
3409 
3410     if (ignoredFromModalPresence())
3411         return AccessibilityObjectInclusion::IgnoreObject;
3412 
3413     if (useParentData ? m_isIgnoredFromParentData.isPresentationalChildOfAriaRole : isPresentationalChildOfAriaRole())
3414         return AccessibilityObjectInclusion::IgnoreObject;
3415 
3416     return accessibilityPlatformIncludesObject();
3417 }
3418 
3419 bool AccessibilityObject::accessibilityIsIgnored() const
3420 {
3421     AXComputedObjectAttributeCache* attributeCache = nullptr;
3422     AXObjectCache* cache = axObjectCache();
3423     if (cache)
3424         attributeCache = cache-&gt;computedObjectAttributeCache();
3425 
3426     if (attributeCache) {
<span class="line-modified">3427         AccessibilityObjectInclusion ignored = attributeCache-&gt;getIgnored(axObjectID());</span>
3428         switch (ignored) {
3429         case AccessibilityObjectInclusion::IgnoreObject:
3430             return true;
3431         case AccessibilityObjectInclusion::IncludeObject:
3432             return false;
3433         case AccessibilityObjectInclusion::DefaultBehavior:
3434             break;
3435         }
3436     }
3437 
3438     bool result = computeAccessibilityIsIgnored();
3439 
3440     // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
3441     if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
<span class="line-modified">3442         attributeCache-&gt;setIgnored(axObjectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);</span>
3443 
3444     return result;
3445 }
3446 
3447 void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
3448 {
3449     Node* node = this-&gt;node();
3450     if (!node || !node-&gt;isElementNode())
3451         return;
3452 
3453     TreeScope&amp; treeScope = node-&gt;treeScope();
3454 
3455     const AtomString&amp; idList = getAttribute(attribute);
3456     if (idList.isEmpty())
3457         return;
3458 
3459     auto spaceSplitString = SpaceSplitString(idList, false);
3460     size_t length = spaceSplitString.size();
3461     for (size_t i = 0; i &lt; length; ++i) {
3462         if (auto* idElement = treeScope.getElementById(spaceSplitString[i]))
</pre>
<hr />
<pre>
3465 }
3466 
3467 #if PLATFORM(COCOA)
3468 bool AccessibilityObject::preventKeyboardDOMEventDispatch() const
3469 {
3470     Frame* frame = this-&gt;frame();
3471     return frame &amp;&amp; frame-&gt;settings().preventKeyboardDOMEventDispatch();
3472 }
3473 
3474 void AccessibilityObject::setPreventKeyboardDOMEventDispatch(bool on)
3475 {
3476     Frame* frame = this-&gt;frame();
3477     if (!frame)
3478         return;
3479     frame-&gt;settings().setPreventKeyboardDOMEventDispatch(on);
3480 }
3481 #endif
3482 
3483 AccessibilityObject* AccessibilityObject::focusableAncestor()
3484 {
<span class="line-modified">3485     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3486         return object.canSetFocusAttribute();
<span class="line-modified">3487     }));</span>
3488 }
3489 
3490 AccessibilityObject* AccessibilityObject::editableAncestor()
3491 {
<span class="line-modified">3492     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3493         return object.isTextControl();
<span class="line-modified">3494     }));</span>
3495 }
3496 
3497 AccessibilityObject* AccessibilityObject::highestEditableAncestor()
3498 {
3499     AccessibilityObject* editableAncestor = this-&gt;editableAncestor();
3500     AccessibilityObject* previousEditableAncestor = nullptr;
3501     while (editableAncestor) {
3502         if (editableAncestor == previousEditableAncestor) {
3503             if (AccessibilityObject* parent = editableAncestor-&gt;parentObject()) {
3504                 editableAncestor = parent-&gt;editableAncestor();
3505                 continue;
3506             }
3507             break;
3508         }
3509         previousEditableAncestor = editableAncestor;
3510         editableAncestor = editableAncestor-&gt;editableAncestor();
3511     }
3512     return previousEditableAncestor;
3513 }
3514 
3515 AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
3516 {
<span class="line-modified">3517     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {</span>
3518         return object.isRadioGroup();
<span class="line-modified">3519     }));</span>































3520 }
3521 
3522 bool AccessibilityObject::isStyleFormatGroup() const
3523 {
3524     Node* node = this-&gt;node();
3525     if (!node)
3526         return false;
3527 
3528     return node-&gt;hasTagName(kbdTag) || node-&gt;hasTagName(codeTag)
3529     || node-&gt;hasTagName(preTag) || node-&gt;hasTagName(sampTag)
3530     || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
3531     || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
3532     || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
3533 }
3534 
3535 bool AccessibilityObject::isFigureElement() const
3536 {
3537     Node* node = this-&gt;node();
3538     return node &amp;&amp; node-&gt;hasTagName(figureTag);
3539 }
</pre>
<hr />
<pre>
3547 
3548 bool AccessibilityObject::isOutput() const
3549 {
3550     Node* node = this-&gt;node();
3551     return node &amp;&amp; node-&gt;hasTagName(outputTag);
3552 }
3553 
3554 bool AccessibilityObject::isContainedByPasswordField() const
3555 {
3556     Node* node = this-&gt;node();
3557     if (!node)
3558         return false;
3559 
3560     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
3561         return false;
3562 
3563     Element* element = node-&gt;shadowHost();
3564     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
3565 }
3566 
<span class="line-modified">3567 AccessibilityObject* AccessibilityObject::selectedListItem()</span>
3568 {
3569     for (const auto&amp; child : children()) {
3570         if (child-&gt;isListItem() &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer()))
3571             return child.get();
3572     }
3573 
3574     return nullptr;
3575 }
3576 
3577 void AccessibilityObject::ariaElementsFromAttribute(AccessibilityChildrenVector&amp; children, const QualifiedName&amp; attributeName) const
3578 {
3579     Vector&lt;Element*&gt; elements;
3580     elementsFromAttribute(elements, attributeName);
3581     AXObjectCache* cache = axObjectCache();
3582     for (const auto&amp; element : elements) {
3583         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(element))
3584             children.append(axObject);
3585     }
3586 }
3587 
</pre>
<hr />
<pre>
3679         ariaElementsFromAttribute(ariaLabelledBy, aria_labeledbyAttr);
3680 }
3681 
3682 void AccessibilityObject::ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp; labels) const
3683 {
3684     ariaElementsReferencedByAttribute(labels, aria_labelledbyAttr);
3685     if (!labels.size())
3686         ariaElementsReferencedByAttribute(labels, aria_labeledbyAttr);
3687 }
3688 
3689 void AccessibilityObject::ariaOwnsElements(AccessibilityChildrenVector&amp; axObjects) const
3690 {
3691     ariaElementsFromAttribute(axObjects, aria_ownsAttr);
3692 }
3693 
3694 void AccessibilityObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp; owners) const
3695 {
3696     ariaElementsReferencedByAttribute(owners, aria_ownsAttr);
3697 }
3698 
<span class="line-modified">3699 void AccessibilityObject::setIsIgnoredFromParentDataForChild(AccessibilityObject* child)</span>
3700 {
3701     if (!child)
3702         return;
3703 
3704     if (child-&gt;parentObject() != this) {
3705         child-&gt;clearIsIgnoredFromParentData();
3706         return;
3707     }
3708 
3709     AccessibilityIsIgnoredFromParentData result = AccessibilityIsIgnoredFromParentData(this);
3710     if (!m_isIgnoredFromParentData.isNull()) {
3711         result.isAXHidden = m_isIgnoredFromParentData.isAXHidden || equalLettersIgnoringASCIICase(child-&gt;getAttribute(aria_hiddenAttr), &quot;true&quot;);
3712         result.isPresentationalChildOfAriaRole = m_isIgnoredFromParentData.isPresentationalChildOfAriaRole || ariaRoleHasPresentationalChildren();
3713         result.isDescendantOfBarrenParent = m_isIgnoredFromParentData.isDescendantOfBarrenParent || !canHaveChildren();
3714     } else {
3715         result.isAXHidden = child-&gt;isAXHidden();
3716         result.isPresentationalChildOfAriaRole = child-&gt;isPresentationalChildOfAriaRole();
3717         result.isDescendantOfBarrenParent = child-&gt;isDescendantOfBarrenParent();
3718     }
3719 
3720     child-&gt;setIsIgnoredFromParentData(result);
3721 }
3722 



















































































































































































































3723 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  46 #include &quot;FloatRect.h&quot;
  47 #include &quot;FocusController.h&quot;
  48 #include &quot;Frame.h&quot;
  49 #include &quot;FrameLoader.h&quot;
  50 #include &quot;FrameSelection.h&quot;
  51 #include &quot;HTMLDataListElement.h&quot;
  52 #include &quot;HTMLDetailsElement.h&quot;
  53 #include &quot;HTMLFormControlElement.h&quot;
  54 #include &quot;HTMLInputElement.h&quot;
  55 #include &quot;HTMLMediaElement.h&quot;
  56 #include &quot;HTMLNames.h&quot;
  57 #include &quot;HTMLParserIdioms.h&quot;
  58 #include &quot;HTMLTextAreaElement.h&quot;
  59 #include &quot;HitTestResult.h&quot;
  60 #include &quot;LocalizedStrings.h&quot;
  61 #include &quot;MathMLNames.h&quot;
  62 #include &quot;NodeList.h&quot;
  63 #include &quot;NodeTraversal.h&quot;
  64 #include &quot;Page.h&quot;
  65 #include &quot;RenderImage.h&quot;
<span class="line-added">  66 #include &quot;RenderInline.h&quot;</span>
  67 #include &quot;RenderLayer.h&quot;
  68 #include &quot;RenderListItem.h&quot;
  69 #include &quot;RenderListMarker.h&quot;
  70 #include &quot;RenderMenuList.h&quot;
  71 #include &quot;RenderText.h&quot;
  72 #include &quot;RenderTextControl.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RenderView.h&quot;
  75 #include &quot;RenderWidget.h&quot;
  76 #include &quot;RenderedPosition.h&quot;

  77 #include &quot;Settings.h&quot;
  78 #include &quot;TextCheckerClient.h&quot;
  79 #include &quot;TextCheckingHelper.h&quot;
  80 #include &quot;TextIterator.h&quot;
  81 #include &quot;UserGestureIndicator.h&quot;
  82 #include &quot;VisibleUnits.h&quot;
  83 #include &lt;wtf/NeverDestroyed.h&gt;
  84 #include &lt;wtf/StdLibExtras.h&gt;
  85 #include &lt;wtf/text/StringBuilder.h&gt;
  86 #include &lt;wtf/text/StringView.h&gt;
  87 #include &lt;wtf/text/WTFString.h&gt;
  88 #include &lt;wtf/unicode/CharacterNames.h&gt;
  89 
  90 namespace WebCore {
  91 
  92 using namespace HTMLNames;
  93 
  94 AccessibilityObject::~AccessibilityObject()
  95 {
  96     ASSERT(isDetached());
  97 }
  98 
<span class="line-modified">  99 void AccessibilityObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)</span>
 100 {
 101     // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
<span class="line-modified"> 102     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu) {</span>
<span class="line-modified"> 103         if (auto* cache = axObjectCache())</span>
<span class="line-added"> 104             cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);</span>
<span class="line-added"> 105     }</span>
 106 
 107     // Clear any children and call detachFromParent on them so that
 108     // no children are left with dangling pointers to their parent.
 109     clearChildren();




 110 }
 111 
 112 bool AccessibilityObject::isDetached() const
 113 {
 114 #if ENABLE(ACCESSIBILITY)
 115     return !wrapper();
 116 #else
 117     return true;
 118 #endif
 119 }
 120 























































































































































































 121 // ARIA marks elements as having their accessible name derive from either their contents, or their author provide name.
 122 bool AccessibilityObject::accessibleNameDerivesFromContent() const
 123 {
 124     // First check for objects specifically identified by ARIA.
 125     switch (ariaRoleAttribute()) {
 126     case AccessibilityRole::ApplicationAlert:
 127     case AccessibilityRole::ApplicationAlertDialog:
 128     case AccessibilityRole::ApplicationDialog:
 129     case AccessibilityRole::ApplicationGroup:
 130     case AccessibilityRole::ApplicationLog:
 131     case AccessibilityRole::ApplicationMarquee:
 132     case AccessibilityRole::ApplicationStatus:
 133     case AccessibilityRole::ApplicationTimer:
 134     case AccessibilityRole::ComboBox:
 135     case AccessibilityRole::Definition:
 136     case AccessibilityRole::Document:
 137     case AccessibilityRole::DocumentArticle:
 138     case AccessibilityRole::DocumentMath:
 139     case AccessibilityRole::DocumentNote:
 140     case AccessibilityRole::LandmarkRegion:
</pre>
<hr />
<pre>
 261 
 262     bool isMisspelled = false;
 263 
 264     if (unifiedTextCheckerEnabled(frame)) {
 265         Vector&lt;TextCheckingResult&gt; results;
 266         checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, results, frame-&gt;selection().selection());
 267         if (!results.isEmpty())
 268             isMisspelled = true;
 269         return isMisspelled;
 270     }
 271 
 272     int misspellingLength = 0;
 273     int misspellingLocation = -1;
 274     textChecker-&gt;checkSpellingOfString(stringValue(), &amp;misspellingLocation, &amp;misspellingLength);
 275     if (misspellingLength || misspellingLocation != -1)
 276         isMisspelled = true;
 277 
 278     return isMisspelled;
 279 }
 280 
<span class="line-added"> 281 RefPtr&lt;Range&gt; AccessibilityObject::getMisspellingRange(RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchDirection direction) const</span>
<span class="line-added"> 282 {</span>
<span class="line-added"> 283     auto node = this-&gt;node();</span>
<span class="line-added"> 284     if (!node)</span>
<span class="line-added"> 285         return nullptr;</span>
<span class="line-added"> 286 </span>
<span class="line-added"> 287     Frame* frame = node-&gt;document().frame();</span>
<span class="line-added"> 288     if (!frame)</span>
<span class="line-added"> 289         return nullptr;</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291     if (!unifiedTextCheckerEnabled(frame))</span>
<span class="line-added"> 292         return nullptr;</span>
<span class="line-added"> 293 </span>
<span class="line-added"> 294     Editor&amp; editor = frame-&gt;editor();</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296     TextCheckerClient* textChecker = editor.textChecker();</span>
<span class="line-added"> 297     if (!textChecker)</span>
<span class="line-added"> 298         return nullptr;</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300     Vector&lt;TextCheckingResult&gt; misspellings;</span>
<span class="line-added"> 301     checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, misspellings, frame-&gt;selection().selection());</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303     // The returned misspellings are assumed to be ordered in the document</span>
<span class="line-added"> 304     // logical order, which should be matched by Range::compareBoundaryPoints.</span>
<span class="line-added"> 305     // So iterate forward or backwards depending on the desired search</span>
<span class="line-added"> 306     // direction to find the closest misspelling in that direction.</span>
<span class="line-added"> 307     if (direction == AccessibilitySearchDirection::Next) {</span>
<span class="line-added"> 308         for (const auto&amp; misspelling : misspellings) {</span>
<span class="line-added"> 309             auto misspellingRange = editor.rangeForTextCheckingResult(misspelling);</span>
<span class="line-added"> 310             if (!misspellingRange)</span>
<span class="line-added"> 311                 continue;</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313             if (misspellingRange-&gt;compareBoundaryPoints(Range::END_TO_END, *start).releaseReturnValue() &gt; 0)</span>
<span class="line-added"> 314                 return misspellingRange;</span>
<span class="line-added"> 315         }</span>
<span class="line-added"> 316     } else if (direction == AccessibilitySearchDirection::Previous) {</span>
<span class="line-added"> 317         for (auto rit = misspellings.rbegin(); rit != misspellings.rend(); ++rit) {</span>
<span class="line-added"> 318             auto misspellingRange = editor.rangeForTextCheckingResult(*rit);</span>
<span class="line-added"> 319             if (!misspellingRange)</span>
<span class="line-added"> 320                 continue;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322             if (misspellingRange-&gt;compareBoundaryPoints(Range::START_TO_START, *start).releaseReturnValue() &lt; 0)</span>
<span class="line-added"> 323                 return misspellingRange;</span>
<span class="line-added"> 324         }</span>
<span class="line-added"> 325     }</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327     return nullptr;</span>
<span class="line-added"> 328 }</span>
<span class="line-added"> 329 </span>
 330 unsigned AccessibilityObject::blockquoteLevel() const
 331 {
 332     unsigned level = 0;
 333     for (Node* elementNode = node(); elementNode; elementNode = elementNode-&gt;parentNode()) {
 334         if (elementNode-&gt;hasTagName(blockquoteTag))
 335             ++level;
 336     }
 337 
 338     return level;
 339 }
 340 
<span class="line-modified"> 341 AXCoreObject* AccessibilityObject::parentObjectUnignored() const</span>
 342 {
<span class="line-modified"> 343     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
 344         return !object.accessibilityIsIgnored();
<span class="line-modified"> 345     });</span>
 346 }
 347 
 348 AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
 349 {
 350     AccessibilityObject* previous;
 351     ASSERT(limit &gt;= 0);
 352     for (previous = previousSibling(); previous &amp;&amp; previous-&gt;accessibilityIsIgnored(); previous = previous-&gt;previousSibling()) {
 353         limit--;
 354         if (limit &lt;= 0)
 355             break;
 356     }
 357     return previous;
 358 }
 359 
 360 FloatRect AccessibilityObject::convertFrameToSpace(const FloatRect&amp; frameRect, AccessibilityConversionSpace conversionSpace) const
 361 {
 362     ASSERT(isMainThread());
 363 
 364     // Find the appropriate scroll view to use to convert the contents to the window.
 365     const auto parentAccessibilityScrollView = ancestorAccessibilityScrollView(false /* includeSelf */);
</pre>
<hr />
<pre>
 419         return nullptr;
 420 
 421     AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 422     while (accessibleObject &amp;&amp; !isAccessible(*accessibleObject)) {
 423         node = NodeTraversal::next(*node);
 424 
 425         while (node &amp;&amp; !node-&gt;renderer())
 426             node = NodeTraversal::nextSkippingChildren(*node);
 427 
 428         if (!node)
 429             return nullptr;
 430 
 431         accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 432     }
 433 
 434     return accessibleObject;
 435 }
 436 
 437 bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
 438 {
<span class="line-modified"> 439     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {</span>
 440         return object.roleValue() == role;
 441     }) != nullptr;
 442 }
 443 
<span class="line-modified"> 444 static void appendAccessibilityObject(AXCoreObject* object, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
 445 {
 446     // Find the next descendant of this attachment object so search can continue through frames.
 447     if (object-&gt;isAttachment()) {
 448         Widget* widget = object-&gt;widgetForAttachmentView();
 449         if (!is&lt;FrameView&gt;(widget))
 450             return;
 451 
 452         Document* document = downcast&lt;FrameView&gt;(*widget).frame().document();
 453         if (!document || !document-&gt;hasLivingRenderTree())
 454             return;
 455 
 456         object = object-&gt;axObjectCache()-&gt;getOrCreate(document);
 457     }
 458 
 459     if (object)
 460         results.append(object);
 461 }
 462 
<span class="line-modified"> 463 void AccessibilityObject::insertChild(AXCoreObject* child, unsigned index)</span>
 464 {
 465     if (!child)
 466         return;
 467 
 468     // If the parent is asking for this child&#39;s children, then either it&#39;s the first time (and clearing is a no-op),
 469     // or its visibility has changed. In the latter case, this child may have a stale child cached.
 470     // This can prevent aria-hidden changes from working correctly. Hence, whenever a parent is getting children, ensure data is not stale.
 471     // Only clear the child&#39;s children when we know it&#39;s in the updating chain in order to avoid unnecessary work.
 472     if (child-&gt;needsToUpdateChildren() || m_subtreeDirty) {
 473         child-&gt;clearChildren();
 474         // Pass m_subtreeDirty flag down to the child so that children cache gets reset properly.
 475         if (m_subtreeDirty)
 476             child-&gt;setNeedsToUpdateSubtree();
 477     } else {
 478         // For some reason the grand children might be detached so that we need to regenerate the
 479         // children list of this child.
 480         for (const auto&amp; grandChild : child-&gt;children(false)) {
 481             if (grandChild-&gt;isDetachedFromParent()) {
 482                 child-&gt;clearChildren();
 483                 break;
 484             }
 485         }
 486     }
 487 
 488     setIsIgnoredFromParentDataForChild(child);
 489     if (child-&gt;accessibilityIsIgnored()) {
 490         const auto&amp; children = child-&gt;children();
 491         size_t length = children.size();
 492         for (size_t i = 0; i &lt; length; ++i)
 493             m_children.insert(index + i, children[i]);
 494     } else {
 495         ASSERT(child-&gt;parentObject() == this);
 496         m_children.insert(index, child);
 497     }
 498 
 499     // Reset the child&#39;s m_isIgnoredFromParentData since we are done adding that child and its children.
 500     child-&gt;clearIsIgnoredFromParentData();
 501 }
 502 
<span class="line-modified"> 503 void AccessibilityObject::addChild(AXCoreObject* child)</span>
 504 {
 505     insertChild(child, m_children.size());
 506 }
 507 
<span class="line-modified"> 508 static void appendChildrenToArray(AXCoreObject* object, bool isForward, AXCoreObject* startObject, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
 509 {
 510     // A table&#39;s children includes elements whose own children are also the table&#39;s children (due to the way the Mac exposes tables).
 511     // The rows from the table should be queried, since those are direct descendants of the table, and they contain content.
 512     const auto&amp; searchChildren = is&lt;AccessibilityTable&gt;(*object) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*object).isExposableThroughAccessibility() ? downcast&lt;AccessibilityTable&gt;(*object).rows() : object-&gt;children();
 513 
 514     size_t childrenSize = searchChildren.size();
 515 
 516     size_t startIndex = isForward ? childrenSize : 0;
 517     size_t endIndex = isForward ? 0 : childrenSize;
 518 
 519     // If the startObject is ignored, we should use an accessible sibling as a start element instead.
 520     if (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored() &amp;&amp; startObject-&gt;isDescendantOfObject(object)) {
<span class="line-modified"> 521         AXCoreObject* parentObject = startObject-&gt;parentObject();</span>
 522         // Go up the parent chain to find the highest ancestor that&#39;s also being ignored.
 523         while (parentObject &amp;&amp; parentObject-&gt;accessibilityIsIgnored()) {
 524             if (parentObject == object)
 525                 break;
 526             startObject = parentObject;
 527             parentObject = parentObject-&gt;parentObject();
 528         }
 529         // Get the un-ignored sibling based on the search direction, and update the searchPosition.
 530         while (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored())
 531             startObject = isForward ? startObject-&gt;previousSibling() : startObject-&gt;nextSibling();
 532     }
 533 
 534     size_t searchPosition = startObject ? searchChildren.find(startObject) : WTF::notFound;
 535 
 536     if (searchPosition != WTF::notFound) {
 537         if (isForward)
 538             endIndex = searchPosition + 1;
 539         else
 540             endIndex = searchPosition;
 541     }
 542 
 543     // This is broken into two statements so that it&#39;s easier read.
 544     if (isForward) {
 545         for (size_t i = startIndex; i &gt; endIndex; i--)
 546             appendAccessibilityObject(searchChildren.at(i - 1).get(), results);
 547     } else {
 548         for (size_t i = startIndex; i &lt; endIndex; i++)
 549             appendAccessibilityObject(searchChildren.at(i).get(), results);
 550     }
 551 }
 552 














 553 void AccessibilityObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 554 {
 555     ASSERT(criteria);

 556     if (!criteria)
 557         return;
 558 
 559     if (AXObjectCache* cache = axObjectCache())
 560         cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
 561 
<span class="line-modified"> 562     criteria-&gt;anchorObject = this;</span>
<span class="line-modified"> 563     Accessibility::findMatchingObjects(*criteria, results);</span>















































 564 }
 565 
 566 // Returns the range that is fewer positions away from the reference range.
 567 // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
 568 // range is expected to ACTUALLY be before. These are not checked for performance reasons.
 569 static RefPtr&lt;Range&gt; rangeClosestToRange(RefPtr&lt;Range&gt; const&amp; referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)
 570 {
 571     if (!referenceRange)
 572         return nullptr;
 573 
 574     // The treeScope for shadow nodes may not be the same scope as another element in a document.
 575     // Comparisons may fail in that case, which are expected behavior and should not assert.
 576     if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 577         return nullptr;
 578     ASSERT(!afterRange || afterRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &gt;= 0);
 579 
 580     if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 581         return nullptr;
 582     ASSERT(!beforeRange || beforeRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &lt;= 0);
 583 
</pre>
<hr />
<pre>
 718         findAll(AccessibilitySearchTextDirection::Forward);
 719         findAll(AccessibilitySearchTextDirection::Backward);
 720         break;
 721     }
 722     }
 723 
 724     return result;
 725 }
 726 
 727 Vector&lt;String&gt; AccessibilityObject::performTextOperation(AccessibilityTextOperation const&amp; operation)
 728 {
 729     Vector&lt;String&gt; result;
 730 
 731     if (operation.textRanges.isEmpty())
 732         return result;
 733 
 734     Frame* frame = this-&gt;frame();
 735     if (!frame)
 736         return result;
 737 
<span class="line-modified"> 738     for (const auto&amp; textRange : operation.textRanges) {</span>
 739         if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))
 740             continue;
 741 
 742         String text = textRange-&gt;text();
 743         String replacementString = operation.replacementText;
 744         bool replaceSelection = false;
 745         switch (operation.type) {
 746         case AccessibilityTextOperationType::Capitalize:
 747             replacementString = capitalize(text, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.
 748             replaceSelection = true;
 749             break;
 750         case AccessibilityTextOperationType::Uppercase:
 751             replacementString = text.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 752             replaceSelection = true;
 753             break;
 754         case AccessibilityTextOperationType::Lowercase:
 755             replacementString = text.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 756             replaceSelection = true;
 757             break;
 758         case AccessibilityTextOperationType::Replace: {
</pre>
<hr />
<pre>
1170 }
1171 
1172 // NOTE: Consider providing this utility method as AX API
1173 VisiblePositionRange AccessibilityObject::visiblePositionRangeForRange(const PlainTextRange&amp; range) const
1174 {
1175     unsigned textLength = getLengthForTextRange();
1176     if (range.start + range.length &gt; textLength)
1177         return VisiblePositionRange();
1178 
1179     VisiblePosition startPosition = visiblePositionForIndex(range.start);
1180     startPosition.setAffinity(DOWNSTREAM);
1181     VisiblePosition endPosition = visiblePositionForIndex(range.start + range.length);
1182     return VisiblePositionRange(startPosition, endPosition);
1183 }
1184 
1185 RefPtr&lt;Range&gt; AccessibilityObject::rangeForPlainTextRange(const PlainTextRange&amp; range) const
1186 {
1187     unsigned textLength = getLengthForTextRange();
1188     if (range.start + range.length &gt; textLength)
1189         return nullptr;
<span class="line-added">1190     // Avoid setting selection to uneditable parent node in FrameSelection::setSelectedRange. See webkit.org/b/206093.</span>
<span class="line-added">1191     if (range.isNull() &amp;&amp; !textLength)</span>
<span class="line-added">1192         return nullptr;</span>
1193 
1194     if (AXObjectCache* cache = axObjectCache()) {
1195         CharacterOffset start = cache-&gt;characterOffsetForIndex(range.start, this);
1196         CharacterOffset end = cache-&gt;characterOffsetForIndex(range.start + range.length, this);
1197         return cache-&gt;rangeForUnorderedCharacterOffsets(start, end);
1198     }
1199     return nullptr;
1200 }
1201 
1202 VisiblePositionRange AccessibilityObject::lineRangeForPosition(const VisiblePosition&amp; visiblePosition) const
1203 {
1204     VisiblePosition startPosition = startOfLine(visiblePosition);
1205     VisiblePosition endPosition = endOfLine(visiblePosition);
1206     return VisiblePositionRange(startPosition, endPosition);
1207 }
1208 
1209 bool AccessibilityObject::replacedNodeNeedsCharacter(Node* replacedNode)
1210 {
1211     // we should always be given a rendered node and a replaced node, but be safe
1212     // replaced nodes are either attachments (widgets) or images
</pre>
<hr />
<pre>
1678 {
1679     if (!axObjectCache())
1680         return;
1681 
1682     // Updating the layout may delete this object.
1683     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1684     if (auto* document = this-&gt;document()) {
1685         if (!document-&gt;view()-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !document-&gt;inRenderTreeUpdate() &amp;&amp; !document-&gt;inStyleRecalc())
1686             document-&gt;updateLayoutIgnorePendingStylesheets();
1687     }
1688 
1689     if (auto cache = axObjectCache())
1690         cache-&gt;performDeferredCacheUpdate();
1691 
1692     updateChildrenIfNecessary();
1693 }
1694 #endif
1695 
1696 const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const
1697 {
<span class="line-modified">1698     return downcast&lt;AccessibilityScrollView&gt;(Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, includeSelf, [] (const auto&amp; object) {</span>
1699         return is&lt;AccessibilityScrollView&gt;(object);
1700     }));
1701 }
1702 
1703 ScrollView* AccessibilityObject::scrollViewAncestor() const
1704 {
1705     if (auto parentScrollView = ancestorAccessibilityScrollView(true/* includeSelf */))
1706         return parentScrollView-&gt;scrollView();
1707 
1708     return nullptr;
1709 }
1710 
1711 Document* AccessibilityObject::document() const
1712 {
1713     FrameView* frameView = documentFrameView();
1714     if (!frameView)
1715         return nullptr;
1716 
1717     return frameView-&gt;frame().document();
1718 }
</pre>
<hr />
<pre>
1733 
1734     if (!object)
1735         return nullptr;
1736 
1737     return object-&gt;documentFrameView();
1738 }
1739 
1740 #if ENABLE(ACCESSIBILITY)
1741 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
1742 {
1743     if (updateChildrenIfNeeded)
1744         updateChildrenIfNecessary();
1745 
1746     return m_children;
1747 }
1748 #endif
1749 
1750 void AccessibilityObject::updateChildrenIfNecessary()
1751 {
1752     if (!hasChildren()) {
<span class="line-added">1753 #if HAVE(ACCESSIBILITY)</span>
1754         // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
1755         AXAttributeCacheEnabler enableCache(axObjectCache());
<span class="line-added">1756 #endif</span>
1757         addChildren();
1758     }
1759 }
1760 
1761 void AccessibilityObject::clearChildren()
1762 {
1763     // Some objects have weak pointers to their parents and those associations need to be detached.
1764     for (const auto&amp; child : m_children)
1765         child-&gt;detachFromParent();
1766 
1767     m_children.clear();
1768     m_haveChildren = false;
1769 }
1770 
1771 AccessibilityObject* AccessibilityObject::anchorElementForNode(Node* node)
1772 {
1773     RenderObject* obj = node-&gt;renderer();
1774     if (!obj)
1775         return nullptr;
1776 
</pre>
<hr />
<pre>
1780         return nullptr;
1781 
1782     RenderObject* anchorRenderer = anchor-&gt;renderer();
1783     if (!anchorRenderer)
1784         return nullptr;
1785 
1786     return anchorRenderer-&gt;document().axObjectCache()-&gt;getOrCreate(anchorRenderer);
1787 }
1788 
1789 AccessibilityObject* AccessibilityObject::headingElementForNode(Node* node)
1790 {
1791     if (!node)
1792         return nullptr;
1793 
1794     RenderObject* renderObject = node-&gt;renderer();
1795     if (!renderObject)
1796         return nullptr;
1797 
1798     AccessibilityObject* axObject = renderObject-&gt;document().axObjectCache()-&gt;getOrCreate(renderObject);
1799 
<span class="line-modified">1800     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*axObject, true, [] (const AccessibilityObject&amp; object) {</span>
1801         return object.roleValue() == AccessibilityRole::Heading;
<span class="line-modified">1802     });</span>










1803 }
1804 
1805 void AccessibilityObject::ariaTreeRows(AccessibilityChildrenVector&amp; result)
1806 {
1807     for (const auto&amp; child : children()) {
1808         // Add tree items as the rows.
1809         if (child-&gt;roleValue() == AccessibilityRole::TreeItem)
1810             result.append(child);
1811 
1812         // Now see if this item also has rows hiding inside of it.
1813         child-&gt;ariaTreeRows(result);
1814     }
1815 }
1816 
1817 void AccessibilityObject::ariaTreeItemContent(AccessibilityChildrenVector&amp; result)
1818 {
1819     // The ARIA tree item content are the item that are not other tree items or their containing groups.
1820     for (const auto&amp; child : children()) {
1821         if (!child-&gt;isGroup() &amp;&amp; child-&gt;roleValue() != AccessibilityRole::TreeItem)
1822             result.append(child);
</pre>
<hr />
<pre>
1836 }
1837 
1838 const String AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityRole role)
1839 {
1840     switch (role) {
1841     case AccessibilityRole::ApplicationAlertDialog:
1842     case AccessibilityRole::ApplicationAlert:
1843         return &quot;assertive&quot;_s;
1844     case AccessibilityRole::ApplicationLog:
1845     case AccessibilityRole::ApplicationStatus:
1846         return &quot;polite&quot;_s;
1847     case AccessibilityRole::ApplicationTimer:
1848     case AccessibilityRole::ApplicationMarquee:
1849         return &quot;off&quot;_s;
1850     default:
1851         return nullAtom();
1852     }
1853 }
1854 
1855 #if ENABLE(ACCESSIBILITY)
<span class="line-modified">1856 String AccessibilityObject::actionVerb() const</span>
1857 {
1858 #if !PLATFORM(IOS_FAMILY)
1859     // FIXME: Need to add verbs for select elements.
1860     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
1861     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
1862     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
1863     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXCheckedCheckBoxActionVerb());
1864     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
1865     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
1866     static NeverDestroyed&lt;const String&gt; menuListAction(AXMenuListActionVerb());
1867     static NeverDestroyed&lt;const String&gt; menuListPopupAction(AXMenuListPopupActionVerb());
1868     static NeverDestroyed&lt;const String&gt; listItemAction(AXListItemActionVerb());
1869 
1870     switch (roleValue()) {
1871     case AccessibilityRole::Button:
1872     case AccessibilityRole::ToggleButton:
1873         return buttonAction;
1874     case AccessibilityRole::TextField:
1875     case AccessibilityRole::TextArea:
1876         return textFieldAction;
</pre>
<hr />
<pre>
2092     if (!element.shouldUseInputMethod())
2093         return false;
2094 
2095     // Use Editor::insertText to mimic typing into the field.
2096     auto&amp; editor = renderer()-&gt;frame().editor();
2097     return editor.insertText(text, nullptr);
2098 }
2099 
2100 // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
2101 AccessibilityOrientation AccessibilityObject::orientation() const
2102 {
2103     LayoutRect bounds = elementRect();
2104     if (bounds.size().width() &gt; bounds.size().height())
2105         return AccessibilityOrientation::Horizontal;
2106     if (bounds.size().height() &gt; bounds.size().width())
2107         return AccessibilityOrientation::Vertical;
2108 
2109     return AccessibilityOrientation::Undefined;
2110 }
2111 
<span class="line-modified">2112 bool AccessibilityObject::isDescendantOfObject(const AXCoreObject* axObject) const</span>
2113 {
2114     if (!axObject || !axObject-&gt;hasChildren())
2115         return false;
2116 
<span class="line-modified">2117     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [axObject] (const AccessibilityObject&amp; object) {</span>
2118         return &amp;object == axObject;
2119     }) != nullptr;
2120 }
2121 
<span class="line-modified">2122 bool AccessibilityObject::isAncestorOfObject(const AXCoreObject* axObject) const</span>
2123 {
2124     if (!axObject)
2125         return false;
2126 
2127     return this == axObject || axObject-&gt;isDescendantOfObject(this);
2128 }
2129 
2130 AccessibilityObject* AccessibilityObject::firstAnonymousBlockChild() const
2131 {
2132     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
2133         if (child-&gt;renderer() &amp;&amp; child-&gt;renderer()-&gt;isAnonymousBlock())
2134             return child;
2135     }
2136     return nullptr;
2137 }
2138 
2139 using ARIARoleMap = HashMap&lt;String, AccessibilityRole, ASCIICaseInsensitiveHash&gt;;
2140 using ARIAReverseRoleMap = HashMap&lt;AccessibilityRole, String, DefaultHash&lt;int&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt;;
2141 
2142 static ARIARoleMap* gAriaRoleMap = nullptr;
</pre>
<hr />
<pre>
2343 
2344     if (role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton)
2345         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Button));
2346 
2347     if (role == AccessibilityRole::LandmarkDocRegion)
2348         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::LandmarkRegion));
2349 
2350     return reverseAriaRoleMap().get(static_cast&lt;int&gt;(role));
2351 }
2352 
2353 bool AccessibilityObject::hasHighlighting() const
2354 {
2355     for (Node* node = this-&gt;node(); node; node = node-&gt;parentNode()) {
2356         if (node-&gt;hasTagName(markTag))
2357             return true;
2358     }
2359 
2360     return false;
2361 }
2362 
<span class="line-added">2363 #if !PLATFORM(MAC)</span>
<span class="line-added">2364 String AccessibilityObject::rolePlatformString() const</span>
<span class="line-added">2365 {</span>
<span class="line-added">2366     // FIXME: implement in other platforms.</span>
<span class="line-added">2367     return String();</span>
<span class="line-added">2368 }</span>
<span class="line-added">2369 </span>
<span class="line-added">2370 String AccessibilityObject::rolePlatformDescription() const</span>
<span class="line-added">2371 {</span>
<span class="line-added">2372     // FIXME: implement in other platforms.</span>
<span class="line-added">2373     return String();</span>
<span class="line-added">2374 }</span>
<span class="line-added">2375 #endif</span>
<span class="line-added">2376 </span>
<span class="line-added">2377 String AccessibilityObject::ariaLandmarkRoleDescription() const</span>
<span class="line-added">2378 {</span>
<span class="line-added">2379     switch (roleValue()) {</span>
<span class="line-added">2380     case AccessibilityRole::LandmarkBanner:</span>
<span class="line-added">2381         return AXARIAContentGroupText(&quot;ARIALandmarkBanner&quot;);</span>
<span class="line-added">2382     case AccessibilityRole::LandmarkComplementary:</span>
<span class="line-added">2383         return AXARIAContentGroupText(&quot;ARIALandmarkComplementary&quot;);</span>
<span class="line-added">2384     case AccessibilityRole::LandmarkContentInfo:</span>
<span class="line-added">2385         return AXARIAContentGroupText(&quot;ARIALandmarkContentInfo&quot;);</span>
<span class="line-added">2386     case AccessibilityRole::LandmarkMain:</span>
<span class="line-added">2387         return AXARIAContentGroupText(&quot;ARIALandmarkMain&quot;);</span>
<span class="line-added">2388     case AccessibilityRole::LandmarkNavigation:</span>
<span class="line-added">2389         return AXARIAContentGroupText(&quot;ARIALandmarkNavigation&quot;);</span>
<span class="line-added">2390     case AccessibilityRole::LandmarkDocRegion:</span>
<span class="line-added">2391     case AccessibilityRole::LandmarkRegion:</span>
<span class="line-added">2392         return AXARIAContentGroupText(&quot;ARIALandmarkRegion&quot;);</span>
<span class="line-added">2393     case AccessibilityRole::LandmarkSearch:</span>
<span class="line-added">2394         return AXARIAContentGroupText(&quot;ARIALandmarkSearch&quot;);</span>
<span class="line-added">2395     case AccessibilityRole::ApplicationAlert:</span>
<span class="line-added">2396         return AXARIAContentGroupText(&quot;ARIAApplicationAlert&quot;);</span>
<span class="line-added">2397     case AccessibilityRole::ApplicationAlertDialog:</span>
<span class="line-added">2398         return AXARIAContentGroupText(&quot;ARIAApplicationAlertDialog&quot;);</span>
<span class="line-added">2399     case AccessibilityRole::ApplicationDialog:</span>
<span class="line-added">2400         return AXARIAContentGroupText(&quot;ARIAApplicationDialog&quot;);</span>
<span class="line-added">2401     case AccessibilityRole::ApplicationLog:</span>
<span class="line-added">2402         return AXARIAContentGroupText(&quot;ARIAApplicationLog&quot;);</span>
<span class="line-added">2403     case AccessibilityRole::ApplicationMarquee:</span>
<span class="line-added">2404         return AXARIAContentGroupText(&quot;ARIAApplicationMarquee&quot;);</span>
<span class="line-added">2405     case AccessibilityRole::ApplicationStatus:</span>
<span class="line-added">2406         return AXARIAContentGroupText(&quot;ARIAApplicationStatus&quot;);</span>
<span class="line-added">2407     case AccessibilityRole::ApplicationTimer:</span>
<span class="line-added">2408         return AXARIAContentGroupText(&quot;ARIAApplicationTimer&quot;);</span>
<span class="line-added">2409     case AccessibilityRole::Document:</span>
<span class="line-added">2410         return AXARIAContentGroupText(&quot;ARIADocument&quot;);</span>
<span class="line-added">2411     case AccessibilityRole::DocumentArticle:</span>
<span class="line-added">2412         return AXARIAContentGroupText(&quot;ARIADocumentArticle&quot;);</span>
<span class="line-added">2413     case AccessibilityRole::DocumentMath:</span>
<span class="line-added">2414         return AXARIAContentGroupText(&quot;ARIADocumentMath&quot;);</span>
<span class="line-added">2415     case AccessibilityRole::DocumentNote:</span>
<span class="line-added">2416         return AXARIAContentGroupText(&quot;ARIADocumentNote&quot;);</span>
<span class="line-added">2417     case AccessibilityRole::UserInterfaceTooltip:</span>
<span class="line-added">2418         return AXARIAContentGroupText(&quot;ARIAUserInterfaceTooltip&quot;);</span>
<span class="line-added">2419     case AccessibilityRole::TabPanel:</span>
<span class="line-added">2420         return AXARIAContentGroupText(&quot;ARIATabPanel&quot;);</span>
<span class="line-added">2421     case AccessibilityRole::WebApplication:</span>
<span class="line-added">2422         return AXARIAContentGroupText(&quot;ARIAWebApplication&quot;);</span>
<span class="line-added">2423     default:</span>
<span class="line-added">2424         return String();</span>
<span class="line-added">2425     }</span>
<span class="line-added">2426 }</span>
<span class="line-added">2427 </span>
2428 String AccessibilityObject::roleDescription() const
2429 {
<span class="line-modified">2430     // aria-roledescription takes precedence over any other rule.</span>
<span class="line-added">2431     String roleDescription = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_roledescriptionAttr));</span>
<span class="line-added">2432     if (!roleDescription.isEmpty())</span>
<span class="line-added">2433         return roleDescription;</span>
<span class="line-added">2434 </span>
<span class="line-added">2435     roleDescription = rolePlatformDescription();</span>
<span class="line-added">2436     if (!roleDescription.isEmpty())</span>
<span class="line-added">2437         return roleDescription;</span>
<span class="line-added">2438 </span>
<span class="line-added">2439     if (roleValue() == AccessibilityRole::Figure)</span>
<span class="line-added">2440         return AXFigureText();</span>
<span class="line-added">2441 </span>
<span class="line-added">2442     return roleDescription;</span>
2443 }
2444 
2445 bool nodeHasPresentationRole(Node* node)
2446 {
2447     return nodeHasRole(node, &quot;presentation&quot;) || nodeHasRole(node, &quot;none&quot;);
2448 }
2449 
2450 bool AccessibilityObject::supportsPressAction() const
2451 {
2452     if (isButton())
2453         return true;
2454     if (roleValue() == AccessibilityRole::Details)
2455         return true;
2456 
2457     Element* actionElement = this-&gt;actionElement();
2458     if (!actionElement)
2459         return false;
2460 
2461     // [Bug: 136247] Heuristic: element handlers that have more than one accessible descendant should not be exposed as supporting press.
2462     if (actionElement != element()) {
</pre>
<hr />
<pre>
2465             // Search within for immediate descendants that are static text. If we find more than one
2466             // then this is an event delegator actionElement and we should expose the press action.
2467             Vector&lt;AccessibilitySearchKey&gt; keys({ AccessibilitySearchKey::StaticText, AccessibilitySearchKey::Control, AccessibilitySearchKey::Graphic, AccessibilitySearchKey::Heading, AccessibilitySearchKey::Link });
2468             AccessibilitySearchCriteria criteria(axObj, AccessibilitySearchDirection::Next, emptyString(), 2, false, false);
2469             criteria.searchKeys = keys;
2470             axObj-&gt;findMatchingObjects(&amp;criteria, results);
2471             if (results.size() &gt; 1)
2472                 return false;
2473         }
2474     }
2475 
2476     // [Bug: 133613] Heuristic: If the action element is presentational, we shouldn&#39;t expose press as a supported action.
2477     return !nodeHasPresentationRole(actionElement);
2478 }
2479 
2480 bool AccessibilityObject::supportsDatetimeAttribute() const
2481 {
2482     return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
2483 }
2484 
<span class="line-modified">2485 String AccessibilityObject::datetimeAttributeValue() const</span>
2486 {
2487     return getAttribute(datetimeAttr);
2488 }
2489 
<span class="line-modified">2490 String AccessibilityObject::linkRelValue() const</span>
2491 {
2492     return getAttribute(relAttr);
2493 }
2494 
<span class="line-added">2495 bool AccessibilityObject::isInlineText() const</span>
<span class="line-added">2496 {</span>
<span class="line-added">2497     return is&lt;RenderInline&gt;(renderer());</span>
<span class="line-added">2498 }</span>
<span class="line-added">2499 </span>
2500 const String AccessibilityObject::keyShortcutsValue() const
2501 {
2502     return getAttribute(aria_keyshortcutsAttr);
2503 }
2504 
2505 Element* AccessibilityObject::element() const
2506 {
2507     Node* node = this-&gt;node();
2508     if (is&lt;Element&gt;(node))
2509         return downcast&lt;Element&gt;(node);
2510     return nullptr;
2511 }
2512 
2513 bool AccessibilityObject::isValueAutofillAvailable() const
2514 {
2515     if (!isNativeTextControl())
2516         return false;
2517 
2518     Node* node = this-&gt;node();
2519     if (!is&lt;HTMLInputElement&gt;(node))
</pre>
<hr />
<pre>
2545 const String AccessibilityObject::placeholderValue() const
2546 {
2547     const AtomString&amp; placeholder = getAttribute(placeholderAttr);
2548     if (!placeholder.isEmpty())
2549         return placeholder;
2550 
2551     const AtomString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);
2552     if (!ariaPlaceholder.isEmpty())
2553         return ariaPlaceholder;
2554 
2555     return nullAtom();
2556 }
2557 
2558 bool AccessibilityObject::isInsideLiveRegion(bool excludeIfOff) const
2559 {
2560     return liveRegionAncestor(excludeIfOff);
2561 }
2562 
2563 AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
2564 {
<span class="line-modified">2565     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {</span>
2566         return object.supportsLiveRegion(excludeIfOff);
<span class="line-modified">2567     });</span>
2568 }
2569 
2570 bool AccessibilityObject::supportsARIAAttributes() const
2571 {
2572     // This returns whether the element supports any global ARIA attributes.
2573     return supportsLiveRegion()
2574         || supportsARIADragging()
2575         || supportsARIADropping()
2576         || supportsARIAOwns()
2577         || hasAttribute(aria_atomicAttr)
2578         || hasAttribute(aria_busyAttr)
2579         || hasAttribute(aria_controlsAttr)
2580         || hasAttribute(aria_currentAttr)
2581         || hasAttribute(aria_describedbyAttr)
2582         || hasAttribute(aria_detailsAttr)
2583         || hasAttribute(aria_disabledAttr)
2584         || hasAttribute(aria_errormessageAttr)
2585         || hasAttribute(aria_flowtoAttr)
2586         || hasAttribute(aria_haspopupAttr)
2587         || hasAttribute(aria_invalidAttr)
2588         || hasAttribute(aria_labelAttr)
2589         || hasAttribute(aria_labelledbyAttr)
2590         || hasAttribute(aria_relevantAttr);
2591 }
2592 
2593 bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomString&amp; liveRegionStatus)
2594 {
2595     return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
2596 }
2597 
2598 bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
2599 {
2600     const AtomString&amp; liveRegionStatusValue = liveRegionStatus();
2601     return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
2602 }
2603 
<span class="line-modified">2604 AXCoreObject* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2605 {
2606     // Send the hit test back into the sub-frame if necessary.
2607     if (isAttachment()) {
2608         Widget* widget = widgetForAttachmentView();
2609         // Normalize the point for the widget&#39;s bounds.
2610         if (widget &amp;&amp; widget-&gt;isFrameView()) {
2611             if (AXObjectCache* cache = axObjectCache())
2612                 return cache-&gt;getOrCreate(widget)-&gt;accessibilityHitTest(IntPoint(point - widget-&gt;frameRect().location()));
2613         }
2614     }
2615 
2616     // Check if there are any mock elements that need to be handled.
2617     for (const auto&amp; child : m_children) {
2618         if (child-&gt;isMockObject() &amp;&amp; child-&gt;elementRect().contains(point))
2619             return child-&gt;elementAccessibilityHitTest(point);
2620     }
2621 
2622     return const_cast&lt;AccessibilityObject*&gt;(this);
2623 }
2624 
2625 AXObjectCache* AccessibilityObject::axObjectCache() const
2626 {
2627     auto* document = this-&gt;document();
2628     return document ? document-&gt;axObjectCache() : nullptr;
2629 }
2630 
<span class="line-modified">2631 AXCoreObject* AccessibilityObject::focusedUIElement() const</span>
2632 {
2633     auto* page = this-&gt;page();
<span class="line-modified">2634     auto* axObjectCache = this-&gt;axObjectCache();</span>
<span class="line-added">2635     return page &amp;&amp; axObjectCache ? axObjectCache-&gt;focusedUIElementForPage(page) : nullptr;</span>
2636 }
2637 
2638 AccessibilitySortDirection AccessibilityObject::sortDirection() const
2639 {
2640     AccessibilityRole role = roleValue();
2641     if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
2642         return AccessibilitySortDirection::Invalid;
2643 
2644     const AtomString&amp; sortAttribute = getAttribute(aria_sortAttr);
2645     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
2646         return AccessibilitySortDirection::Ascending;
2647     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
2648         return AccessibilitySortDirection::Descending;
2649     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
2650         return AccessibilitySortDirection::Other;
2651 
2652     return AccessibilitySortDirection::None;
2653 }
2654 
2655 bool AccessibilityObject::supportsRangeValue() const
</pre>
<hr />
<pre>
2715 bool AccessibilityObject::supportsSetSize() const
2716 {
2717     return hasAttribute(aria_setsizeAttr);
2718 }
2719 
2720 bool AccessibilityObject::supportsPosInSet() const
2721 {
2722     return hasAttribute(aria_posinsetAttr);
2723 }
2724 
2725 int AccessibilityObject::setSize() const
2726 {
2727     return getAttribute(aria_setsizeAttr).toInt();
2728 }
2729 
2730 int AccessibilityObject::posInSet() const
2731 {
2732     return getAttribute(aria_posinsetAttr).toInt();
2733 }
2734 
<span class="line-modified">2735 String AccessibilityObject::identifierAttribute() const</span>
2736 {
2737     return getAttribute(idAttr);
2738 }
2739 
2740 void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
2741 {
2742     Node* node = this-&gt;node();
2743     if (!is&lt;Element&gt;(node))
2744         return;
2745 
2746     Element* element = downcast&lt;Element&gt;(node);
2747     DOMTokenList&amp; list = element-&gt;classList();
2748     unsigned length = list.length();
2749     for (unsigned k = 0; k &lt; length; k++)
2750         classList.append(list.item(k).string());
2751 }
2752 
2753 bool AccessibilityObject::supportsPressed() const
2754 {
2755     const AtomString&amp; expanded = getAttribute(aria_pressedAttr);
</pre>
<hr />
<pre>
2765     switch (roleValue()) {
2766     case AccessibilityRole::ComboBox:
2767     case AccessibilityRole::DisclosureTriangle:
2768     case AccessibilityRole::Details:
2769         return true;
2770     default:
2771         return false;
2772     }
2773 }
2774 
2775 bool AccessibilityObject::isExpanded() const
2776 {
2777     if (equalLettersIgnoringASCIICase(getAttribute(aria_expandedAttr), &quot;true&quot;))
2778         return true;
2779 
2780     if (is&lt;HTMLDetailsElement&gt;(node()))
2781         return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
2782 
2783     // Summary element should use its details parent&#39;s expanded status.
2784     if (isSummary()) {
<span class="line-modified">2785         if (const AccessibilityObject* parent = Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
2786             return is&lt;HTMLDetailsElement&gt;(object.node());
2787         }))
2788             return parent-&gt;isExpanded();
2789     }
2790 
2791     return false;
2792 }
2793 
2794 bool AccessibilityObject::supportsChecked() const
2795 {
2796     switch (roleValue()) {
2797     case AccessibilityRole::CheckBox:
2798     case AccessibilityRole::MenuItemCheckbox:
2799     case AccessibilityRole::MenuItemRadio:
2800     case AccessibilityRole::RadioButton:
2801     case AccessibilityRole::Switch:
2802         return true;
2803     default:
2804         return false;
2805     }
</pre>
<hr />
<pre>
2910         if (subfocusMax - subfocusMin &gt; viewportSize)
2911             subfocusMax = subfocusMin + viewportSize;
2912 
2913         // Compute the size of an object centered on the subfocus, the size of the viewport.
2914         int centeredObjectMin = (subfocusMin + subfocusMax - viewportSize) / 2;
2915         int centeredObjectMax = centeredObjectMin + viewportSize;
2916 
2917         objectMin = std::max(objectMin, centeredObjectMin);
2918         objectMax = std::min(objectMax, centeredObjectMax);
2919     }
2920 
2921     // Exit now if the focus is already within the viewport.
2922     if (objectMin - currentScrollOffset &gt;= viewportMin
2923         &amp;&amp; objectMax - currentScrollOffset &lt;= viewportMax)
2924         return currentScrollOffset;
2925 
2926     // Center the object in the viewport.
2927     return (objectMin + objectMax - viewportMin - viewportMax) / 2;
2928 }
2929 
<span class="line-modified">2930 bool AccessibilityObject::isOnScreen() const</span>
2931 {
2932     bool isOnscreen = true;
2933 
2934     // To figure out if the element is onscreen, we start by building of a stack starting with the
2935     // element, and then include every scrollable parent in the hierarchy.
2936     Vector&lt;const AccessibilityObject*&gt; objects;
2937 
2938     objects.append(this);
2939     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
2940         if (parentObject-&gt;getScrollableAreaIfScrollable())
2941             objects.append(parentObject);
2942     }
2943 
2944     // Now, go back through that chain and make sure each inner object is within the
2945     // visible bounds of the outer object.
2946     size_t levels = objects.size() - 1;
2947 
2948     for (size_t i = levels; i &gt;= 1; i--) {
2949         const AccessibilityObject* outer = objects[i];
2950         const AccessibilityObject* inner = objects[i - 1];
</pre>
<hr />
<pre>
3232 
3233     return AccessibilityRole::Button;
3234 }
3235 
3236 bool AccessibilityObject::isButton() const
3237 {
3238     AccessibilityRole role = roleValue();
3239 
3240     return role == AccessibilityRole::Button || role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton;
3241 }
3242 
3243 bool AccessibilityObject::accessibilityIsIgnoredByDefault() const
3244 {
3245     return defaultObjectInclusion() == AccessibilityObjectInclusion::IgnoreObject;
3246 }
3247 
3248 // ARIA component of hidden definition.
3249 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3250 bool AccessibilityObject::isAXHidden() const
3251 {
<span class="line-modified">3252     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3253         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;true&quot;);
3254     }) != nullptr;
3255 }
3256 
3257 // DOM component of hidden definition.
3258 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3259 bool AccessibilityObject::isDOMHidden() const
3260 {
3261     RenderObject* renderer = this-&gt;renderer();
3262     if (!renderer)
3263         return true;
3264 
3265     const RenderStyle&amp; style = renderer-&gt;style();
3266     return style.display() == DisplayType::None || style.visibility() != Visibility::Visible;
3267 }
3268 
3269 bool AccessibilityObject::isShowingValidationMessage() const
3270 {
3271     if (is&lt;HTMLFormControlElement&gt;(node()))
3272         return downcast&lt;HTMLFormControlElement&gt;(*node()).isShowingValidationMessage();
</pre>
<hr />
<pre>
3287     if (useParentData ? m_isIgnoredFromParentData.isAXHidden : isAXHidden())
3288         return AccessibilityObjectInclusion::IgnoreObject;
3289 
3290     if (ignoredFromModalPresence())
3291         return AccessibilityObjectInclusion::IgnoreObject;
3292 
3293     if (useParentData ? m_isIgnoredFromParentData.isPresentationalChildOfAriaRole : isPresentationalChildOfAriaRole())
3294         return AccessibilityObjectInclusion::IgnoreObject;
3295 
3296     return accessibilityPlatformIncludesObject();
3297 }
3298 
3299 bool AccessibilityObject::accessibilityIsIgnored() const
3300 {
3301     AXComputedObjectAttributeCache* attributeCache = nullptr;
3302     AXObjectCache* cache = axObjectCache();
3303     if (cache)
3304         attributeCache = cache-&gt;computedObjectAttributeCache();
3305 
3306     if (attributeCache) {
<span class="line-modified">3307         AccessibilityObjectInclusion ignored = attributeCache-&gt;getIgnored(objectID());</span>
3308         switch (ignored) {
3309         case AccessibilityObjectInclusion::IgnoreObject:
3310             return true;
3311         case AccessibilityObjectInclusion::IncludeObject:
3312             return false;
3313         case AccessibilityObjectInclusion::DefaultBehavior:
3314             break;
3315         }
3316     }
3317 
3318     bool result = computeAccessibilityIsIgnored();
3319 
3320     // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
3321     if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
<span class="line-modified">3322         attributeCache-&gt;setIgnored(objectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);</span>
3323 
3324     return result;
3325 }
3326 
3327 void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
3328 {
3329     Node* node = this-&gt;node();
3330     if (!node || !node-&gt;isElementNode())
3331         return;
3332 
3333     TreeScope&amp; treeScope = node-&gt;treeScope();
3334 
3335     const AtomString&amp; idList = getAttribute(attribute);
3336     if (idList.isEmpty())
3337         return;
3338 
3339     auto spaceSplitString = SpaceSplitString(idList, false);
3340     size_t length = spaceSplitString.size();
3341     for (size_t i = 0; i &lt; length; ++i) {
3342         if (auto* idElement = treeScope.getElementById(spaceSplitString[i]))
</pre>
<hr />
<pre>
3345 }
3346 
3347 #if PLATFORM(COCOA)
3348 bool AccessibilityObject::preventKeyboardDOMEventDispatch() const
3349 {
3350     Frame* frame = this-&gt;frame();
3351     return frame &amp;&amp; frame-&gt;settings().preventKeyboardDOMEventDispatch();
3352 }
3353 
3354 void AccessibilityObject::setPreventKeyboardDOMEventDispatch(bool on)
3355 {
3356     Frame* frame = this-&gt;frame();
3357     if (!frame)
3358         return;
3359     frame-&gt;settings().setPreventKeyboardDOMEventDispatch(on);
3360 }
3361 #endif
3362 
3363 AccessibilityObject* AccessibilityObject::focusableAncestor()
3364 {
<span class="line-modified">3365     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3366         return object.canSetFocusAttribute();
<span class="line-modified">3367     });</span>
3368 }
3369 
3370 AccessibilityObject* AccessibilityObject::editableAncestor()
3371 {
<span class="line-modified">3372     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3373         return object.isTextControl();
<span class="line-modified">3374     });</span>
3375 }
3376 
3377 AccessibilityObject* AccessibilityObject::highestEditableAncestor()
3378 {
3379     AccessibilityObject* editableAncestor = this-&gt;editableAncestor();
3380     AccessibilityObject* previousEditableAncestor = nullptr;
3381     while (editableAncestor) {
3382         if (editableAncestor == previousEditableAncestor) {
3383             if (AccessibilityObject* parent = editableAncestor-&gt;parentObject()) {
3384                 editableAncestor = parent-&gt;editableAncestor();
3385                 continue;
3386             }
3387             break;
3388         }
3389         previousEditableAncestor = editableAncestor;
3390         editableAncestor = editableAncestor-&gt;editableAncestor();
3391     }
3392     return previousEditableAncestor;
3393 }
3394 
3395 AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
3396 {
<span class="line-modified">3397     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
3398         return object.isRadioGroup();
<span class="line-modified">3399     });</span>
<span class="line-added">3400 }</span>
<span class="line-added">3401 </span>
<span class="line-added">3402 String AccessibilityObject::documentURI() const</span>
<span class="line-added">3403 {</span>
<span class="line-added">3404     if (auto* document = this-&gt;document())</span>
<span class="line-added">3405         return document-&gt;documentURI();</span>
<span class="line-added">3406     return String();</span>
<span class="line-added">3407 }</span>
<span class="line-added">3408 </span>
<span class="line-added">3409 String AccessibilityObject::documentEncoding() const</span>
<span class="line-added">3410 {</span>
<span class="line-added">3411     if (auto* document = this-&gt;document())</span>
<span class="line-added">3412         return document-&gt;encoding();</span>
<span class="line-added">3413     return String();</span>
<span class="line-added">3414 }</span>
<span class="line-added">3415 </span>
<span class="line-added">3416 uint64_t AccessibilityObject::sessionID() const</span>
<span class="line-added">3417 {</span>
<span class="line-added">3418     if (auto* document = topDocument()) {</span>
<span class="line-added">3419         if (auto* page = document-&gt;page())</span>
<span class="line-added">3420             return page-&gt;sessionID().toUInt64();</span>
<span class="line-added">3421     }</span>
<span class="line-added">3422     return 0;</span>
<span class="line-added">3423 }</span>
<span class="line-added">3424 </span>
<span class="line-added">3425 String AccessibilityObject::tagName() const</span>
<span class="line-added">3426 {</span>
<span class="line-added">3427     if (Element* element = this-&gt;element())</span>
<span class="line-added">3428         return element-&gt;localName();</span>
<span class="line-added">3429 </span>
<span class="line-added">3430     return String();</span>
3431 }
3432 
3433 bool AccessibilityObject::isStyleFormatGroup() const
3434 {
3435     Node* node = this-&gt;node();
3436     if (!node)
3437         return false;
3438 
3439     return node-&gt;hasTagName(kbdTag) || node-&gt;hasTagName(codeTag)
3440     || node-&gt;hasTagName(preTag) || node-&gt;hasTagName(sampTag)
3441     || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
3442     || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
3443     || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
3444 }
3445 
3446 bool AccessibilityObject::isFigureElement() const
3447 {
3448     Node* node = this-&gt;node();
3449     return node &amp;&amp; node-&gt;hasTagName(figureTag);
3450 }
</pre>
<hr />
<pre>
3458 
3459 bool AccessibilityObject::isOutput() const
3460 {
3461     Node* node = this-&gt;node();
3462     return node &amp;&amp; node-&gt;hasTagName(outputTag);
3463 }
3464 
3465 bool AccessibilityObject::isContainedByPasswordField() const
3466 {
3467     Node* node = this-&gt;node();
3468     if (!node)
3469         return false;
3470 
3471     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
3472         return false;
3473 
3474     Element* element = node-&gt;shadowHost();
3475     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
3476 }
3477 
<span class="line-modified">3478 AXCoreObject* AccessibilityObject::selectedListItem()</span>
3479 {
3480     for (const auto&amp; child : children()) {
3481         if (child-&gt;isListItem() &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer()))
3482             return child.get();
3483     }
3484 
3485     return nullptr;
3486 }
3487 
3488 void AccessibilityObject::ariaElementsFromAttribute(AccessibilityChildrenVector&amp; children, const QualifiedName&amp; attributeName) const
3489 {
3490     Vector&lt;Element*&gt; elements;
3491     elementsFromAttribute(elements, attributeName);
3492     AXObjectCache* cache = axObjectCache();
3493     for (const auto&amp; element : elements) {
3494         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(element))
3495             children.append(axObject);
3496     }
3497 }
3498 
</pre>
<hr />
<pre>
3590         ariaElementsFromAttribute(ariaLabelledBy, aria_labeledbyAttr);
3591 }
3592 
3593 void AccessibilityObject::ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp; labels) const
3594 {
3595     ariaElementsReferencedByAttribute(labels, aria_labelledbyAttr);
3596     if (!labels.size())
3597         ariaElementsReferencedByAttribute(labels, aria_labeledbyAttr);
3598 }
3599 
3600 void AccessibilityObject::ariaOwnsElements(AccessibilityChildrenVector&amp; axObjects) const
3601 {
3602     ariaElementsFromAttribute(axObjects, aria_ownsAttr);
3603 }
3604 
3605 void AccessibilityObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp; owners) const
3606 {
3607     ariaElementsReferencedByAttribute(owners, aria_ownsAttr);
3608 }
3609 
<span class="line-modified">3610 void AccessibilityObject::setIsIgnoredFromParentDataForChild(AXCoreObject* child)</span>
3611 {
3612     if (!child)
3613         return;
3614 
3615     if (child-&gt;parentObject() != this) {
3616         child-&gt;clearIsIgnoredFromParentData();
3617         return;
3618     }
3619 
3620     AccessibilityIsIgnoredFromParentData result = AccessibilityIsIgnoredFromParentData(this);
3621     if (!m_isIgnoredFromParentData.isNull()) {
3622         result.isAXHidden = m_isIgnoredFromParentData.isAXHidden || equalLettersIgnoringASCIICase(child-&gt;getAttribute(aria_hiddenAttr), &quot;true&quot;);
3623         result.isPresentationalChildOfAriaRole = m_isIgnoredFromParentData.isPresentationalChildOfAriaRole || ariaRoleHasPresentationalChildren();
3624         result.isDescendantOfBarrenParent = m_isIgnoredFromParentData.isDescendantOfBarrenParent || !canHaveChildren();
3625     } else {
3626         result.isAXHidden = child-&gt;isAXHidden();
3627         result.isPresentationalChildOfAriaRole = child-&gt;isPresentationalChildOfAriaRole();
3628         result.isDescendantOfBarrenParent = child-&gt;isDescendantOfBarrenParent();
3629     }
3630 
3631     child-&gt;setIsIgnoredFromParentData(result);
3632 }
3633 
<span class="line-added">3634 namespace Accessibility {</span>
<span class="line-added">3635 </span>
<span class="line-added">3636 #if !PLATFORM(MAC)</span>
<span class="line-added">3637 // FIXME: implement in other platforms.</span>
<span class="line-added">3638 PlatformRoleMap createPlatformRoleMap() { return PlatformRoleMap(); }</span>
<span class="line-added">3639 #endif</span>
<span class="line-added">3640 </span>
<span class="line-added">3641 String roleToPlatformString(AccessibilityRole role)</span>
<span class="line-added">3642 {</span>
<span class="line-added">3643     static NeverDestroyed&lt;PlatformRoleMap&gt; roleMap = createPlatformRoleMap();</span>
<span class="line-added">3644     return roleMap-&gt;get(static_cast&lt;unsigned&gt;(role));</span>
<span class="line-added">3645 }</span>
<span class="line-added">3646 </span>
<span class="line-added">3647 static bool isAccessibilityObjectSearchMatchAtIndex(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria, size_t index)</span>
<span class="line-added">3648 {</span>
<span class="line-added">3649     switch (criteria.searchKeys[index]) {</span>
<span class="line-added">3650     case AccessibilitySearchKey::AnyType:</span>
<span class="line-added">3651         // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.</span>
<span class="line-added">3652         return true;</span>
<span class="line-added">3653     case AccessibilitySearchKey::Article:</span>
<span class="line-added">3654         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;</span>
<span class="line-added">3655     case AccessibilitySearchKey::BlockquoteSameLevel:</span>
<span class="line-added">3656         return criteria.startObject</span>
<span class="line-added">3657             &amp;&amp; axObject-&gt;isBlockquote()</span>
<span class="line-added">3658             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria.startObject-&gt;blockquoteLevel();</span>
<span class="line-added">3659     case AccessibilitySearchKey::Blockquote:</span>
<span class="line-added">3660         return axObject-&gt;isBlockquote();</span>
<span class="line-added">3661     case AccessibilitySearchKey::BoldFont:</span>
<span class="line-added">3662         return axObject-&gt;hasBoldFont();</span>
<span class="line-added">3663     case AccessibilitySearchKey::Button:</span>
<span class="line-added">3664         return axObject-&gt;isButton();</span>
<span class="line-added">3665     case AccessibilitySearchKey::CheckBox:</span>
<span class="line-added">3666         return axObject-&gt;isCheckbox();</span>
<span class="line-added">3667     case AccessibilitySearchKey::Control:</span>
<span class="line-added">3668         return axObject-&gt;isControl();</span>
<span class="line-added">3669     case AccessibilitySearchKey::DifferentType:</span>
<span class="line-added">3670         return criteria.startObject</span>
<span class="line-added">3671             &amp;&amp; axObject-&gt;roleValue() != criteria.startObject-&gt;roleValue();</span>
<span class="line-added">3672     case AccessibilitySearchKey::FontChange:</span>
<span class="line-added">3673         return criteria.startObject</span>
<span class="line-added">3674             &amp;&amp; !axObject-&gt;hasSameFont(criteria.startObject-&gt;renderer());</span>
<span class="line-added">3675     case AccessibilitySearchKey::FontColorChange:</span>
<span class="line-added">3676         return criteria.startObject</span>
<span class="line-added">3677             &amp;&amp; !axObject-&gt;hasSameFontColor(criteria.startObject-&gt;renderer());</span>
<span class="line-added">3678     case AccessibilitySearchKey::Frame:</span>
<span class="line-added">3679         return axObject-&gt;isWebArea();</span>
<span class="line-added">3680     case AccessibilitySearchKey::Graphic:</span>
<span class="line-added">3681         return axObject-&gt;isImage();</span>
<span class="line-added">3682     case AccessibilitySearchKey::HeadingLevel1:</span>
<span class="line-added">3683         return axObject-&gt;headingLevel() == 1;</span>
<span class="line-added">3684     case AccessibilitySearchKey::HeadingLevel2:</span>
<span class="line-added">3685         return axObject-&gt;headingLevel() == 2;</span>
<span class="line-added">3686     case AccessibilitySearchKey::HeadingLevel3:</span>
<span class="line-added">3687         return axObject-&gt;headingLevel() == 3;</span>
<span class="line-added">3688     case AccessibilitySearchKey::HeadingLevel4:</span>
<span class="line-added">3689         return axObject-&gt;headingLevel() == 4;</span>
<span class="line-added">3690     case AccessibilitySearchKey::HeadingLevel5:</span>
<span class="line-added">3691         return axObject-&gt;headingLevel() == 5;</span>
<span class="line-added">3692     case AccessibilitySearchKey::HeadingLevel6:</span>
<span class="line-added">3693         return axObject-&gt;headingLevel() == 6;</span>
<span class="line-added">3694     case AccessibilitySearchKey::HeadingSameLevel:</span>
<span class="line-added">3695         return criteria.startObject</span>
<span class="line-added">3696             &amp;&amp; axObject-&gt;isHeading()</span>
<span class="line-added">3697             &amp;&amp; axObject-&gt;headingLevel() == criteria.startObject-&gt;headingLevel();</span>
<span class="line-added">3698     case AccessibilitySearchKey::Heading:</span>
<span class="line-added">3699         return axObject-&gt;isHeading();</span>
<span class="line-added">3700     case AccessibilitySearchKey::Highlighted:</span>
<span class="line-added">3701         return axObject-&gt;hasHighlighting();</span>
<span class="line-added">3702     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-added">3703         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-added">3704     case AccessibilitySearchKey::ItalicFont:</span>
<span class="line-added">3705         return axObject-&gt;hasItalicFont();</span>
<span class="line-added">3706     case AccessibilitySearchKey::Landmark:</span>
<span class="line-added">3707         return axObject-&gt;isLandmark();</span>
<span class="line-added">3708     case AccessibilitySearchKey::Link: {</span>
<span class="line-added">3709         bool isLink = axObject-&gt;isLink();</span>
<span class="line-added">3710 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">3711         if (!isLink)</span>
<span class="line-added">3712             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);</span>
<span class="line-added">3713 #endif</span>
<span class="line-added">3714         return isLink;</span>
<span class="line-added">3715     }</span>
<span class="line-added">3716     case AccessibilitySearchKey::List:</span>
<span class="line-added">3717         return axObject-&gt;isList();</span>
<span class="line-added">3718     case AccessibilitySearchKey::LiveRegion:</span>
<span class="line-added">3719         return axObject-&gt;supportsLiveRegion();</span>
<span class="line-added">3720     case AccessibilitySearchKey::MisspelledWord:</span>
<span class="line-added">3721         return axObject-&gt;hasMisspelling();</span>
<span class="line-added">3722     case AccessibilitySearchKey::Outline:</span>
<span class="line-added">3723         return axObject-&gt;isTree();</span>
<span class="line-added">3724     case AccessibilitySearchKey::PlainText:</span>
<span class="line-added">3725         return axObject-&gt;hasPlainText();</span>
<span class="line-added">3726     case AccessibilitySearchKey::RadioGroup:</span>
<span class="line-added">3727         return axObject-&gt;isRadioGroup();</span>
<span class="line-added">3728     case AccessibilitySearchKey::SameType:</span>
<span class="line-added">3729         return criteria.startObject</span>
<span class="line-added">3730             &amp;&amp; axObject-&gt;roleValue() == criteria.startObject-&gt;roleValue();</span>
<span class="line-added">3731     case AccessibilitySearchKey::StaticText:</span>
<span class="line-added">3732         return axObject-&gt;isStaticText();</span>
<span class="line-added">3733     case AccessibilitySearchKey::StyleChange:</span>
<span class="line-added">3734         return criteria.startObject</span>
<span class="line-added">3735             &amp;&amp; !axObject-&gt;hasSameStyle(criteria.startObject-&gt;renderer());</span>
<span class="line-added">3736     case AccessibilitySearchKey::TableSameLevel:</span>
<span class="line-added">3737         return criteria.startObject</span>
<span class="line-added">3738             &amp;&amp; is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility()</span>
<span class="line-added">3739             &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).tableLevel() == criteria.startObject-&gt;tableLevel();</span>
<span class="line-added">3740     case AccessibilitySearchKey::Table:</span>
<span class="line-added">3741         return is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility();</span>
<span class="line-added">3742     case AccessibilitySearchKey::TextField:</span>
<span class="line-added">3743         return axObject-&gt;isTextControl();</span>
<span class="line-added">3744     case AccessibilitySearchKey::Underline:</span>
<span class="line-added">3745         return axObject-&gt;hasUnderline();</span>
<span class="line-added">3746     case AccessibilitySearchKey::UnvisitedLink:</span>
<span class="line-added">3747         return axObject-&gt;isUnvisited();</span>
<span class="line-added">3748     case AccessibilitySearchKey::VisitedLink:</span>
<span class="line-added">3749         return axObject-&gt;isVisited();</span>
<span class="line-added">3750     default:</span>
<span class="line-added">3751         return false;</span>
<span class="line-added">3752     }</span>
<span class="line-added">3753 }</span>
<span class="line-added">3754 </span>
<span class="line-added">3755 static bool isAccessibilityObjectSearchMatch(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria)</span>
<span class="line-added">3756 {</span>
<span class="line-added">3757     if (!axObject)</span>
<span class="line-added">3758         return false;</span>
<span class="line-added">3759 </span>
<span class="line-added">3760     size_t length = criteria.searchKeys.size();</span>
<span class="line-added">3761     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="line-added">3762         if (isAccessibilityObjectSearchMatchAtIndex(axObject, criteria, i)) {</span>
<span class="line-added">3763             if (criteria.visibleOnly &amp;&amp; !axObject-&gt;isOnScreen())</span>
<span class="line-added">3764                 return false;</span>
<span class="line-added">3765             return true;</span>
<span class="line-added">3766         }</span>
<span class="line-added">3767     }</span>
<span class="line-added">3768     return false;</span>
<span class="line-added">3769 }</span>
<span class="line-added">3770 </span>
<span class="line-added">3771 static bool isAccessibilityTextSearchMatch(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria)</span>
<span class="line-added">3772 {</span>
<span class="line-added">3773     if (!axObject)</span>
<span class="line-added">3774         return false;</span>
<span class="line-added">3775     return axObject-&gt;containsText(criteria.searchText);</span>
<span class="line-added">3776 }</span>
<span class="line-added">3777 </span>
<span class="line-added">3778 static bool objectMatchesSearchCriteriaWithResultLimit(AXCoreObject* object, AccessibilitySearchCriteria const&amp; criteria, AXCoreObject::AccessibilityChildrenVector&amp; results)</span>
<span class="line-added">3779 {</span>
<span class="line-added">3780     if (isAccessibilityObjectSearchMatch(object, criteria) &amp;&amp; isAccessibilityTextSearchMatch(object, criteria)) {</span>
<span class="line-added">3781         results.append(object);</span>
<span class="line-added">3782 </span>
<span class="line-added">3783         // Enough results were found to stop searching.</span>
<span class="line-added">3784         if (results.size() &gt;= criteria.resultsLimit)</span>
<span class="line-added">3785             return true;</span>
<span class="line-added">3786     }</span>
<span class="line-added">3787 </span>
<span class="line-added">3788     return false;</span>
<span class="line-added">3789 }</span>
<span class="line-added">3790 </span>
<span class="line-added">3791 void findMatchingObjects(AccessibilitySearchCriteria const&amp; criteria, AXCoreObject::AccessibilityChildrenVector&amp; results)</span>
<span class="line-added">3792 {</span>
<span class="line-added">3793     // This search algorithm only searches the elements before/after the starting object.</span>
<span class="line-added">3794     // It does this by stepping up the parent chain and at each level doing a DFS.</span>
<span class="line-added">3795 </span>
<span class="line-added">3796     // If there&#39;s no start object, it means we want to search everything.</span>
<span class="line-added">3797     AXCoreObject* startObject = criteria.startObject;</span>
<span class="line-added">3798     if (!startObject)</span>
<span class="line-added">3799         startObject = criteria.anchorObject;</span>
<span class="line-added">3800 </span>
<span class="line-added">3801     bool isForward = criteria.searchDirection == AccessibilitySearchDirection::Next;</span>
<span class="line-added">3802 </span>
<span class="line-added">3803     // The first iteration of the outer loop will examine the children of the start object for matches. However, when</span>
<span class="line-added">3804     // iterating backwards, the start object children should not be considered, so the loop is skipped ahead. We make an</span>
<span class="line-added">3805     // exception when no start object was specified because we want to search everything regardless of search direction.</span>
<span class="line-added">3806     AXCoreObject* previousObject = nullptr;</span>
<span class="line-added">3807     if (!isForward &amp;&amp; startObject != criteria.anchorObject) {</span>
<span class="line-added">3808         previousObject = startObject;</span>
<span class="line-added">3809         startObject = startObject-&gt;parentObjectUnignored();</span>
<span class="line-added">3810     }</span>
<span class="line-added">3811 </span>
<span class="line-added">3812     // The outer loop steps up the parent chain each time (unignored is important here because otherwise elements would be searched twice)</span>
<span class="line-added">3813     for (auto* stopSearchElement = criteria.anchorObject-&gt;parentObjectUnignored(); startObject &amp;&amp; startObject != stopSearchElement; startObject = startObject-&gt;parentObjectUnignored()) {</span>
<span class="line-added">3814         // Only append the children after/before the previous element, so that the search does not check elements that are</span>
<span class="line-added">3815         // already behind/ahead of start element.</span>
<span class="line-added">3816         AXCoreObject::AccessibilityChildrenVector searchStack;</span>
<span class="line-added">3817         if (!criteria.immediateDescendantsOnly || startObject == criteria.anchorObject)</span>
<span class="line-added">3818             appendChildrenToArray(startObject, isForward, previousObject, searchStack);</span>
<span class="line-added">3819 </span>
<span class="line-added">3820         // This now does a DFS at the current level of the parent.</span>
<span class="line-added">3821         while (!searchStack.isEmpty()) {</span>
<span class="line-added">3822             AXCoreObject* searchObject = searchStack.last().get();</span>
<span class="line-added">3823             searchStack.removeLast();</span>
<span class="line-added">3824 </span>
<span class="line-added">3825             if (objectMatchesSearchCriteriaWithResultLimit(searchObject, criteria, results))</span>
<span class="line-added">3826                 break;</span>
<span class="line-added">3827 </span>
<span class="line-added">3828             if (!criteria.immediateDescendantsOnly)</span>
<span class="line-added">3829                 appendChildrenToArray(searchObject, isForward, 0, searchStack);</span>
<span class="line-added">3830         }</span>
<span class="line-added">3831 </span>
<span class="line-added">3832         if (results.size() &gt;= criteria.resultsLimit)</span>
<span class="line-added">3833             break;</span>
<span class="line-added">3834 </span>
<span class="line-added">3835         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.</span>
<span class="line-added">3836         if (!isForward &amp;&amp; startObject != criteria.anchorObject &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))</span>
<span class="line-added">3837             break;</span>
<span class="line-added">3838 </span>
<span class="line-added">3839         previousObject = startObject;</span>
<span class="line-added">3840     }</span>
<span class="line-added">3841 }</span>
<span class="line-added">3842 </span>
<span class="line-added">3843 } // namespace Accessibility</span>
<span class="line-added">3844 </span>
3845 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityNodeObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
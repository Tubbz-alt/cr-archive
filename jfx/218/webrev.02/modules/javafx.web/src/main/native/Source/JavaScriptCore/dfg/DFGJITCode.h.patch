diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h
@@ -52,22 +52,22 @@
     virtual ~JITCode();
 
     CommonData* dfgCommon() override;
     JITCode* dfg() override;
 
-    OSREntryData* appendOSREntryData(unsigned bytecodeIndex, CodeLocationLabel<OSREntryPtrTag> machineCode)
+    OSREntryData* appendOSREntryData(BytecodeIndex bytecodeIndex, CodeLocationLabel<OSREntryPtrTag> machineCode)
     {
         DFG::OSREntryData entry;
         entry.m_bytecodeIndex = bytecodeIndex;
         entry.m_machineCode = machineCode;
         osrEntry.append(entry);
         return &osrEntry.last();
     }
 
-    OSREntryData* osrEntryDataForBytecodeIndex(unsigned bytecodeIndex)
+    OSREntryData* osrEntryDataForBytecodeIndex(BytecodeIndex bytecodeIndex)
     {
-        return tryBinarySearch<OSREntryData, unsigned>(
+        return tryBinarySearch<OSREntryData, BytecodeIndex>(
             osrEntry, osrEntry.size(), bytecodeIndex,
             getOSREntryDataBytecodeIndex);
     }
 
     void finalizeOSREntrypoints();
@@ -96,11 +96,11 @@
 
     // This is only applicable if we're at a point where all values are spilled to the
     // stack. Currently, it also has the restriction that the values must be in their
     // bytecode-designated stack slots.
     void reconstruct(
-        ExecState*, CodeBlock*, CodeOrigin, unsigned streamIndex, Operands<Optional<JSValue>>& result);
+        CallFrame*, CodeBlock*, CodeOrigin, unsigned streamIndex, Operands<Optional<JSValue>>& result);
 
 #if ENABLE(FTL_JIT)
     // NB. All of these methods take CodeBlock* because they may want to use
     // CodeBlock's logic about scaling thresholds. It should be a DFG CodeBlock.
 
@@ -113,11 +113,11 @@
     void setOptimizationThresholdBasedOnCompilationResult(CodeBlock*, CompilationResult);
 #endif // ENABLE(FTL_JIT)
 
     void validateReferences(const TrackedReferences&) override;
 
-    void shrinkToFit();
+    void shrinkToFit(const ConcurrentJSLocker&) override;
 
     RegisterSet liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock*, CallSiteIndex) override;
 #if ENABLE(FTL_JIT)
     CodeBlock* osrEntryBlock() { return m_osrEntryBlock.get(); }
     void setOSREntryBlock(VM&, const JSCell* owner, CodeBlock* osrEntryBlock);
@@ -149,25 +149,25 @@
     // For osrEntryPoint that are in inner loop, this maps their bytecode to the bytecode
     // of the outerloop entry points in order (from innermost to outermost).
     //
     // The key may not always be a target for OSR Entry but the list in the value is guaranteed
     // to be usable for OSR Entry.
-    HashMap<unsigned, Vector<unsigned>> tierUpInLoopHierarchy;
+    HashMap<BytecodeIndex, Vector<BytecodeIndex>> tierUpInLoopHierarchy;
 
     // Map each bytecode of CheckTierUpAndOSREnter to its stream index.
-    HashMap<unsigned, unsigned, WTF::IntHash<unsigned>, WTF::UnsignedWithZeroKeyHashTraits<unsigned>> bytecodeIndexToStreamIndex;
+    HashMap<BytecodeIndex, unsigned> bytecodeIndexToStreamIndex;
 
     enum class TriggerReason : uint8_t {
         DontTrigger,
         CompilationDone,
         StartCompilation,
     };
 
     // Map each bytecode of CheckTierUpAndOSREnter to its trigger forcing OSR Entry.
     // This can never be modified after it has been initialized since the addresses of the triggers
     // are used by the JIT.
-    HashMap<unsigned, TriggerReason> tierUpEntryTriggers;
+    HashMap<BytecodeIndex, TriggerReason> tierUpEntryTriggers;
 
     WriteBarrier<CodeBlock> m_osrEntryBlock;
     unsigned osrEntryRetry;
     bool abandonOSREntry;
 #endif // ENABLE(FTL_JIT)

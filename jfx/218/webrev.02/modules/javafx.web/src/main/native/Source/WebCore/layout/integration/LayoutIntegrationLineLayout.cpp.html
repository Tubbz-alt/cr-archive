<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/integration/LayoutIntegrationLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutIntegrationLineLayout.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;EventRegion.h&quot;
 33 #include &quot;FloatingState.h&quot;
 34 #include &quot;HitTestLocation.h&quot;
 35 #include &quot;HitTestRequest.h&quot;
 36 #include &quot;HitTestResult.h&quot;
 37 #include &quot;InlineFormattingContext.h&quot;
 38 #include &quot;InlineFormattingState.h&quot;
 39 #include &quot;InvalidationState.h&quot;
 40 #include &quot;LayoutTreeBuilder.h&quot;
 41 #include &quot;PaintInfo.h&quot;
 42 #include &quot;RenderBlockFlow.h&quot;
 43 #include &quot;RenderChildIterator.h&quot;
 44 #include &quot;RenderDescendantIterator.h&quot;
 45 #include &quot;RenderLineBreak.h&quot;
 46 #include &quot;RenderView.h&quot;
 47 #include &quot;RuntimeEnabledFeatures.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;SimpleLineLayout.h&quot;
 50 #include &quot;TextDecorationPainter.h&quot;
 51 #include &quot;TextPainter.h&quot;
 52 
 53 namespace WebCore {
 54 namespace LayoutIntegration {
 55 
 56 LineLayout::LineLayout(const RenderBlockFlow&amp; flow)
 57     : m_flow(flow)
 58     , m_boxTree(flow)
 59     , m_layoutState(m_flow.document(), rootLayoutBox())
 60     , m_inlineFormattingState(m_layoutState.ensureInlineFormattingState(rootLayoutBox()))
 61 {
 62     m_layoutState.setIsIntegratedRootBoxFirstChild(m_flow.parent()-&gt;firstChild() == &amp;m_flow);
 63 }
 64 
 65 LineLayout::~LineLayout() = default;
 66 
 67 bool LineLayout::canUseFor(const RenderBlockFlow&amp; flow, Optional&lt;bool&gt; couldUseSimpleLineLayout)
 68 {
 69     if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled())
 70         return false;
 71 
 72     // Initially only a subset of SLL features is supported.
 73     auto passesSimpleLineLayoutTest = valueOrCompute(couldUseSimpleLineLayout, [&amp;] {
 74         return SimpleLineLayout::canUseFor(flow);
 75     });
 76 
 77     if (!passesSimpleLineLayoutTest)
 78         return false;
 79 
 80     if (flow.fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow)
 81         return false;
 82 
 83     return true;
 84 }
 85 
 86 void LineLayout::updateStyle()
 87 {
 88     auto&amp; root = rootLayoutBox();
 89 
 90     // FIXME: Encapsulate style updates better.
 91     root.updateStyle(m_flow.style());
 92 
 93     for (auto* child = root.firstChild(); child; child = child-&gt;nextSibling()) {
 94         if (child-&gt;isAnonymous())
 95             child-&gt;updateStyle(RenderStyle::createAnonymousStyleWithDisplay(root.style(), DisplayType::Inline));
 96     }
 97 }
 98 
 99 void LineLayout::layout()
100 {
101     prepareLayoutState();
102     prepareFloatingState();
103 
104     auto inlineFormattingContext = Layout::InlineFormattingContext { rootLayoutBox(), m_inlineFormattingState };
105 
106     auto invalidationState = Layout::InvalidationState { };
107     auto horizontalConstraints = Layout::HorizontalConstraints { m_flow.borderAndPaddingStart(), m_flow.contentSize().width() };
108     auto verticalConstraints = Layout::VerticalConstraints { m_flow.borderAndPaddingBefore(), { } };
109 
110     inlineFormattingContext.layoutInFlowContent(invalidationState, horizontalConstraints, verticalConstraints);
111 }
112 
113 void LineLayout::prepareLayoutState()
114 {
115     m_layoutState.setViewportSize(m_flow.frame().view()-&gt;size());
116 }
117 
118 void LineLayout::prepareFloatingState()
119 {
120     auto&amp; floatingState = m_inlineFormattingState.floatingState();
121     floatingState.clear();
122 
123     if (!m_flow.containsFloats())
124         return;
125 
126     for (auto&amp; floatingObject : *m_flow.floatingObjectSet()) {
127         auto&amp; rect = floatingObject-&gt;frameRect();
128         auto position = floatingObject-&gt;type() == FloatingObject::FloatRight
129             ? Layout::FloatingState::FloatItem::Position::Right
130             : Layout::FloatingState::FloatItem::Position::Left;
131         auto box = Display::Box { };
132         // FIXME: We are flooring here for legacy compatibility.
133         //        See FloatingObjects::intervalForFloatingObject.
134         auto y = rect.y().floor();
135         auto maxY = rect.maxY().floor();
136         box.setTopLeft({ rect.x(), y });
137         box.setContentBoxWidth(rect.width());
138         box.setContentBoxHeight(maxY - y);
139         box.setBorder({ });
140         box.setPadding({ });
141         box.setHorizontalMargin({ });
142         box.setVerticalMargin({ });
143         floatingState.append({ position, box });
144     }
145 }
146 
147 LayoutUnit LineLayout::contentLogicalHeight() const
148 {
149     auto&amp; lineBoxes = displayInlineContent()-&gt;lineBoxes;
150     return LayoutUnit { lineBoxes.last().bottom() - lineBoxes.first().top() };
151 }
152 
153 size_t LineLayout::lineCount() const
154 {
155     auto* inlineContent = displayInlineContent();
156     if (!inlineContent)
157         return 0;
158     if (inlineContent-&gt;runs.isEmpty())
159         return 0;
160     return inlineContent-&gt;lineBoxes.size();
161 }
162 
163 LayoutUnit LineLayout::firstLineBaseline() const
164 {
165     auto* inlineContent = displayInlineContent();
166     if (!inlineContent) {
167         ASSERT_NOT_REACHED();
168         return 0_lu;
169     }
170 
171     auto&amp; firstLineBox = inlineContent-&gt;lineBoxes.first();
172     return Layout::toLayoutUnit(firstLineBox.top() + firstLineBox.baselineOffset());
173 }
174 
175 LayoutUnit LineLayout::lastLineBaseline() const
176 {
177     auto* inlineContent = displayInlineContent();
178     if (!inlineContent) {
179         ASSERT_NOT_REACHED();
180         return 0_lu;
181     }
182 
183     auto&amp; lastLineBox = inlineContent-&gt;lineBoxes.last();
184     return Layout::toLayoutUnit(lastLineBox.top() + lastLineBox.baselineOffset());
185 }
186 
187 void LineLayout::collectOverflow(RenderBlockFlow&amp; flow)
188 {
189     ASSERT(&amp;flow == &amp;m_flow);
190     ASSERT(!flow.hasOverflowClip());
191 
192     for (auto&amp; lineBox : displayInlineContent()-&gt;lineBoxes) {
193         flow.addLayoutOverflow(Layout::toLayoutRect(lineBox.scrollableOverflow()));
194         flow.addVisualOverflow(Layout::toLayoutRect(lineBox.inkOverflow()));
195     }
196 }
197 
198 const Display::InlineContent* LineLayout::displayInlineContent() const
199 {
200     return m_inlineFormattingState.displayInlineContent();
201 }
202 
203 LineLayoutTraversal::TextBoxIterator LineLayout::textBoxesFor(const RenderText&amp; renderText) const
204 {
205     auto* inlineContent = displayInlineContent();
206     if (!inlineContent)
207         return { };
208     auto* layoutBox = m_boxTree.layoutBoxForRenderer(renderText);
209     ASSERT(layoutBox);
210 
211     Optional&lt;size_t&gt; firstIndex;
212     size_t lastIndex = 0;
213     for (size_t i = 0; i &lt; inlineContent-&gt;runs.size(); ++i) {
214         auto&amp; run = inlineContent-&gt;runs[i];
215         if (&amp;run.layoutBox() == layoutBox) {
216             if (!firstIndex)
217                 firstIndex = i;
218             lastIndex = i;
219         } else if (firstIndex)
220             break;
221     }
222     if (!firstIndex)
223         return { };
224 
225     return { LineLayoutTraversal::DisplayRunPath(*inlineContent, *firstIndex, lastIndex + 1) };
226 }
227 
228 LineLayoutTraversal::ElementBoxIterator LineLayout::elementBoxFor(const RenderLineBreak&amp; renderLineBreak) const
229 {
230     auto* inlineContent = displayInlineContent();
231     if (!inlineContent)
232         return { };
233     auto* layoutBox = m_boxTree.layoutBoxForRenderer(renderLineBreak);
234     ASSERT(layoutBox);
235 
236     for (size_t i = 0; i &lt; inlineContent-&gt;runs.size(); ++i) {
237         auto&amp; run =  inlineContent-&gt;runs[i];
238         if (&amp;run.layoutBox() == layoutBox)
239             return { LineLayoutTraversal::DisplayRunPath(*inlineContent, i, i + 1) };
240     }
241 
242     return { };
243 }
244 
245 const Layout::Container&amp; LineLayout::rootLayoutBox() const
246 {
247     return m_boxTree.rootLayoutBox();
248 }
249 
250 Layout::Container&amp; LineLayout::rootLayoutBox()
251 {
252     return m_boxTree.rootLayoutBox();
253 }
254 
255 void LineLayout::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
256 {
257     if (!displayInlineContent())
258         return;
259 
260     if (paintInfo.phase != PaintPhase::Foreground &amp;&amp; paintInfo.phase != PaintPhase::EventRegion)
261         return;
262 
263     auto&amp; inlineContent = *displayInlineContent();
264     float deviceScaleFactor = m_flow.document().deviceScaleFactor();
265 
266     auto paintRect = paintInfo.rect;
267     paintRect.moveBy(-paintOffset);
268 
269     for (auto&amp; run : inlineContent.runsForRect(paintRect)) {
270         if (!run.textContext())
271             continue;
272 
273         auto&amp; textContext = *run.textContext();
274         if (!textContext.length())
275             continue;
276 
277         auto&amp; style = run.style();
278         if (style.visibility() != Visibility::Visible)
279             continue;
280 
281         auto rect = FloatRect { run.rect() };
282         auto visualOverflowRect = FloatRect { run.inkOverflow() };
283         if (paintRect.y() &gt; visualOverflowRect.maxY() || paintRect.maxY() &lt; visualOverflowRect.y())
284             continue;
285 
286         if (paintInfo.eventRegionContext) {
287             if (style.pointerEvents() != PointerEvents::None)
288                 paintInfo.eventRegionContext-&gt;unite(enclosingIntRect(visualOverflowRect), style);
289             continue;
290         }
291 
292         auto&amp; lineBox = inlineContent.lineBoxForRun(run);
293         auto baselineOffset = paintOffset.y() + lineBox.top() + lineBox.baselineOffset();
294 
295         auto behavior = textContext.expansion() ? textContext.expansion()-&gt;behavior : DefaultExpansion;
296         auto horizontalExpansion = textContext.expansion() ? textContext.expansion()-&gt;horizontalExpansion : 0;
297 
298         String textWithHyphen;
299         if (textContext.needsHyphen())
300             textWithHyphen = makeString(textContext.content(), style.hyphenString());
301         TextRun textRun { !textWithHyphen.isEmpty() ? textWithHyphen : textContext.content(), run.left() - lineBox.left(), horizontalExpansion, behavior };
302         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
303         FloatPoint textOrigin { rect.x() + paintOffset.x(), roundToDevicePixel(baselineOffset, deviceScaleFactor) };
304 
305         TextPainter textPainter(paintInfo.context());
306         textPainter.setFont(style.fontCascade());
307         textPainter.setStyle(computeTextPaintStyle(m_flow.frame(), style, paintInfo));
308         if (auto* debugShadow = debugTextShadow())
309             textPainter.setShadow(debugShadow);
310 
311         textPainter.setGlyphDisplayListIfNeeded(run, paintInfo, style.fontCascade(), paintInfo.context(), textRun);
312         textPainter.paint(textRun, rect, textOrigin);
313 
314         if (!style.textDecorationsInEffect().isEmpty()) {
315             // FIXME: Use correct RenderText.
316             if (auto* textRenderer = childrenOfType&lt;RenderText&gt;(m_flow).first()) {
317                 auto painter = TextDecorationPainter { paintInfo.context(), style.textDecorationsInEffect(), *textRenderer, false, style.fontCascade() };
318                 painter.setWidth(rect.width());
319                 painter.paintTextDecoration(textRun, textOrigin, rect.location() + paintOffset);
320             }
321         }
322     }
323 }
324 
325 bool LineLayout::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
326 {
327     if (hitTestAction != HitTestForeground)
328         return false;
329 
330     if (!displayInlineContent())
331         return false;
332 
333     auto&amp; inlineContent = *displayInlineContent();
334 
335     // FIXME: This should do something efficient to find the run range.
336     for (auto&amp; run : inlineContent.runs) {
337         auto runRect = Layout::toLayoutRect(run.rect());
338         runRect.moveBy(accumulatedOffset);
339 
340         if (!locationInContainer.intersects(runRect))
341             continue;
342 
343         auto&amp; style = run.style();
344         if (style.visibility() != Visibility::Visible || style.pointerEvents() == PointerEvents::None)
345             continue;
346 
347         auto&amp; renderer = const_cast&lt;RenderObject&amp;&gt;(*m_boxTree.rendererForLayoutBox(run.layoutBox()));
348 
349         renderer.updateHitTestResult(result, locationInContainer.point() - toLayoutSize(accumulatedOffset));
350         if (result.addNodeToListBasedTestResult(renderer.node(), request, locationInContainer, runRect) == HitTestProgress::Stop)
351             return true;
352     }
353 
354     return false;
355 }
356 
357 ShadowData* LineLayout::debugTextShadow()
358 {
359     if (!m_flow.settings().simpleLineLayoutDebugBordersEnabled())
360         return nullptr;
361 
362     static NeverDestroyed&lt;ShadowData&gt; debugTextShadow(IntPoint(0, 0), 10, 20, ShadowStyle::Normal, true, Color(0, 0, 150, 150));
363     return &amp;debugTextShadow.get();
364 }
365 
366 void LineLayout::releaseCaches(RenderView&amp; view)
367 {
368     if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled())
369         return;
370 
371     for (auto&amp; renderer : descendantsOfType&lt;RenderBlockFlow&gt;(view)) {
372         if (auto* lineLayout = renderer.layoutFormattingContextLineLayout())
373             lineLayout-&gt;releaseInlineItemCache();
374     }
375 }
376 
377 void LineLayout::releaseInlineItemCache()
378 {
379     m_inlineFormattingState.inlineItems().clear();
380 }
381 
382 
383 }
384 }
385 
386 #endif
    </pre>
  </body>
</html>
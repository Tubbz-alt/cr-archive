<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;array&gt;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &lt;wtf/Forward.h&gt;</span>
<span class="line-added"> 30 #include &lt;wtf/GetPtr.h&gt;</span>
<span class="line-added"> 31 #include &lt;wtf/HashFunctions.h&gt;</span>
 32 #include &lt;wtf/MathExtras.h&gt;
 33 #include &lt;wtf/StdLibExtras.h&gt;
 34 #include &lt;wtf/UnalignedAccess.h&gt;
 35 
 36 namespace WTF {
 37 
 38 template&lt;typename T&gt;
 39 class Packed {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
 42     static constexpr bool isPackedType = true;
 43 
 44     Packed()
 45         : Packed(T { })
 46     {
 47     }
 48 
 49     Packed(const T&amp; value)
 50     {
 51         unalignedStore&lt;T&gt;(m_storage.data(), value);
 52     }
 53 
 54     T get() const
 55     {
 56         return unalignedLoad&lt;T&gt;(m_storage.data());
 57     }
 58 
 59     void set(const T&amp; value)
 60     {
 61         unalignedStore&lt;T&gt;(m_storage.data(), value);
 62     }
 63 
 64     Packed&lt;T&gt;&amp; operator=(const T&amp; value)
 65     {
 66         set(value);
 67         return *this;
 68     }
 69 
 70     template&lt;class U&gt;
 71     T exchange(U&amp;&amp; newValue)
 72     {
 73         T oldValue = get();
 74         set(std::forward&lt;U&gt;(newValue));
 75         return oldValue;
 76     }
 77 
 78     void swap(Packed&amp; other)
 79     {
 80         m_storage.swap(other.m_storage);
 81     }
 82 
 83     template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
 84     void swap(Other&amp; other)
 85     {
 86         T t1 = get();
 87         T t2 = other.get();
 88         set(t2);
 89         other.set(t1);
 90     }
 91 
 92     void swap(T&amp; t2)
 93     {
 94         T t1 = get();
 95         std::swap(t1, t2);
 96         set(t1);
 97     }
 98 
 99 private:
100     std::array&lt;uint8_t, sizeof(T)&gt; m_storage;
101 };
102 
103 // PackedAlignedPtr can take alignment parameter too. PackedAlignedPtr only uses this alignment information if it is profitable: we use
104 // alignment information only when we can reduce the size of the storage. Since the pointer width is 36 bits and JSCells are aligned to 16 bytes,
105 // we can use 4 bits in Darwin ARM64, we can compact cell pointer into 4 bytes (32 bits).
<a name="2" id="anc2"></a><span class="line-modified">106 template&lt;typename T, size_t passedAlignment&gt;</span>
107 class PackedAlignedPtr {
108     WTF_MAKE_FAST_ALLOCATED;
109 public:
<a name="3" id="anc3"></a><span class="line-modified">110     static_assert(hasOneBitSet(passedAlignment), &quot;Alignment needs to be power-of-two&quot;);</span>
<span class="line-added">111     static constexpr size_t alignment = passedAlignment;</span>
112     static constexpr bool isPackedType = true;
113     static constexpr unsigned alignmentShiftSizeIfProfitable = getLSBSetConstexpr(alignment);
<a name="4" id="anc4"></a><span class="line-modified">114     static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf&lt;8&gt;(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH)) / 8;</span>
<span class="line-modified">115     static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf&lt;8&gt;(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH) - alignmentShiftSizeIfProfitable) / 8;</span>
116     static constexpr bool isAlignmentShiftProfitable = storageSizeWithoutAlignmentShift &gt; storageSizeWithAlignmentShift;
117     static constexpr unsigned alignmentShiftSize = isAlignmentShiftProfitable ? alignmentShiftSizeIfProfitable : 0;
118     static constexpr unsigned storageSize = storageSizeWithAlignmentShift;
119 
120     constexpr PackedAlignedPtr()
121         : m_storage()
122     {
123     }
124 
125     constexpr PackedAlignedPtr(std::nullptr_t)
126         : m_storage()
127     {
128     }
129 
130     PackedAlignedPtr(T* value)
131     {
132         set(value);
133     }
134 
135     T* get() const
136     {
137         // FIXME: PackedPtr&lt;&gt; can load memory with one mov by checking page boundary.
138         // https://bugs.webkit.org/show_bug.cgi?id=197754
139         uintptr_t value = 0;
140 #if CPU(LITTLE_ENDIAN)
141         memcpy(&amp;value, m_storage.data(), storageSize);
142 #else
143         memcpy(bitwise_cast&lt;uint8_t*&gt;(&amp;value) + (sizeof(void*) - storageSize), m_storage.data(), storageSize);
144 #endif
145         if (isAlignmentShiftProfitable)
146             value &lt;&lt;= alignmentShiftSize;
147         return bitwise_cast&lt;T*&gt;(value);
148     }
149 
150     void set(T* passedValue)
151     {
152         uintptr_t value = bitwise_cast&lt;uintptr_t&gt;(passedValue);
153         if (isAlignmentShiftProfitable)
154             value &gt;&gt;= alignmentShiftSize;
155 #if CPU(LITTLE_ENDIAN)
156         memcpy(m_storage.data(), &amp;value, storageSize);
157 #else
158         memcpy(m_storage.data(), bitwise_cast&lt;uint8_t*&gt;(&amp;value) + (sizeof(void*) - storageSize), storageSize);
159 #endif
160     }
161 
162     void clear()
163     {
164         set(nullptr);
165     }
166 
167     T* operator-&gt;() const { return get(); }
168     T&amp; operator*() const { return *get(); }
169     bool operator!() const { return !get(); }
<a name="5" id="anc5"></a><span class="line-added">170 </span>
<span class="line-added">171     // This conversion operator allows implicit conversion to bool but not to other integer types.</span>
<span class="line-added">172     typedef T* (PackedAlignedPtr::*UnspecifiedBoolType);</span>
<span class="line-added">173     operator UnspecifiedBoolType() const { return get() ? &amp;PackedAlignedPtr::m_storage : nullptr; }</span>
174     explicit operator bool() const { return get(); }
175 
176     PackedAlignedPtr&amp; operator=(T* value)
177     {
178         set(value);
179         return *this;
180     }
181 
182     template&lt;class U&gt;
<a name="6" id="anc6"></a><span class="line-modified">183     T* exchange(U&amp;&amp; newValue)</span>
184     {
<a name="7" id="anc7"></a><span class="line-modified">185         T* oldValue = get();</span>
186         set(std::forward&lt;U&gt;(newValue));
187         return oldValue;
188     }
189 
190     void swap(std::nullptr_t) { clear(); }
191 
192     void swap(PackedAlignedPtr&amp; other)
193     {
194         m_storage.swap(other.m_storage);
195     }
196 
197     template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
198     void swap(Other&amp; other)
199     {
<a name="8" id="anc8"></a><span class="line-modified">200         T* t1 = get();</span>
<span class="line-modified">201         T* t2 = other.get();</span>
202         set(t2);
203         other.set(t1);
204     }
205 
<a name="9" id="anc9"></a><span class="line-modified">206     void swap(T* t2)</span>
207     {
<a name="10" id="anc10"></a><span class="line-modified">208         T* t1 = get();</span>
209         std::swap(t1, t2);
210         set(t1);
211     }
212 
213 private:
214     std::array&lt;uint8_t, storageSize&gt; m_storage;
215 };
216 
217 template&lt;typename T&gt;
218 class Packed&lt;T*&gt; : public PackedAlignedPtr&lt;T, 1&gt; {
219 public:
220     using Base = PackedAlignedPtr&lt;T, 1&gt;;
221     using Base::Base;
<a name="11" id="anc11"></a><span class="line-added">222 </span>
<span class="line-added">223     // Hash table deleted values, which are only constructed and never copied or destroyed.</span>
<span class="line-added">224     Packed(HashTableDeletedValueType) : Base(bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(Base::alignment))) { }</span>
<span class="line-added">225     bool isHashTableDeletedValue() const { return Base::get() == bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(Base::alignment)); }</span>
226 };
227 
228 template&lt;typename T&gt;
229 using PackedPtr = Packed&lt;T*&gt;;
230 
<a name="12" id="anc12"></a><span class="line-added">231 template &lt;typename T&gt;</span>
<span class="line-added">232 struct GetPtrHelper&lt;PackedPtr&lt;T&gt;&gt; {</span>
<span class="line-added">233     using PtrType = T*;</span>
<span class="line-added">234     static T* getPtr(const PackedPtr&lt;T&gt;&amp; p) { return const_cast&lt;T*&gt;(p.get()); }</span>
<span class="line-added">235 };</span>
<span class="line-added">236 </span>
<span class="line-added">237 template &lt;typename T&gt;</span>
<span class="line-added">238 struct IsSmartPtr&lt;PackedPtr&lt;T&gt;&gt; {</span>
<span class="line-added">239     static constexpr bool value = true;</span>
<span class="line-added">240 };</span>
<span class="line-added">241 </span>
242 template&lt;typename T&gt;
243 struct PackedPtrTraits {
244     template&lt;typename U&gt; using RebindTraits = PackedPtrTraits&lt;U&gt;;
245 
246     using StorageType = PackedPtr&lt;T&gt;;
247 
248     template&lt;class U&gt; static ALWAYS_INLINE T* exchange(StorageType&amp; ptr, U&amp;&amp; newValue) { return ptr.exchange(newValue); }
249 
250     template&lt;typename Other&gt; static ALWAYS_INLINE void swap(PackedPtr&lt;T&gt;&amp; a, Other&amp; b) { a.swap(b); }
251 
252     static ALWAYS_INLINE T* unwrap(const StorageType&amp; ptr) { return ptr.get(); }
<a name="13" id="anc13"></a><span class="line-added">253 </span>
<span class="line-added">254     // We assume that,</span>
<span class="line-added">255     // 1. The alignment is &lt; 4KB. (It is tested by HashTraits).</span>
<span class="line-added">256     // 2. The first page (including nullptr) is never mapped.</span>
<span class="line-added">257     static StorageType hashTableDeletedValue() { return StorageType { bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(StorageType::alignment)) }; }</span>
<span class="line-added">258     static ALWAYS_INLINE bool isHashTableDeletedValue(const StorageType&amp; ptr) { return ptr.get() == bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(StorageType::alignment)); }</span>
259 };
260 
<a name="14" id="anc14"></a><span class="line-added">261 template&lt;typename P&gt; struct DefaultHash&lt;PackedPtr&lt;P&gt;&gt; { using Hash = PtrHash&lt;PackedPtr&lt;P&gt;&gt;; };</span>
<span class="line-added">262 </span>
263 } // namespace WTF
264 
265 using WTF::Packed;
266 using WTF::PackedAlignedPtr;
267 using WTF::PackedPtr;
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FEGaussianBlur.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2006, 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2005 Eric Seidel &lt;eric@webkit.org&gt;
  5  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  6  * Copyright (C) 2010 Igalia, S.L.
  7  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  8  * Copyright (C) 2015-2016 Apple, Inc. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FEGaussianBlur.h&quot;
 28 #if !PLATFORM(JAVA) || HAVE(ARM_NEON_INTRINSICS)
 29 #include &quot;FEGaussianBlurNEON.h&quot;
 30 #endif
 31 #include &quot;Filter.h&quot;
 32 #include &quot;GraphicsContext.h&quot;
 33 #include &lt;wtf/text/TextStream.h&gt;
 34 
 35 #if USE(ACCELERATE)
 36 #include &lt;Accelerate/Accelerate.h&gt;
 37 #endif
 38 
 39 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 40 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 41 #include &lt;JavaScriptCore/Uint8ClampedArray.h&gt;
 42 #include &lt;wtf/MathExtras.h&gt;
 43 #include &lt;wtf/ParallelJobs.h&gt;
 44 
 45 static inline float gaussianKernelFactor()
 46 {
 47     return 3 / 4.f * sqrtf(2 * piFloat);
 48 }
 49 
 50 static const int gMaxKernelSize = 500;
 51 
 52 namespace WebCore {
 53 
 54 inline void kernelPosition(int blurIteration, unsigned&amp; radius, int&amp; deltaLeft, int&amp; deltaRight)
 55 {
 56     // Check http://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement for details.
 57     switch (blurIteration) {
 58     case 0:
 59         if (!(radius % 2)) {
 60             deltaLeft = radius / 2 - 1;
 61             deltaRight = radius - deltaLeft;
 62         } else {
 63             deltaLeft = radius / 2;
 64             deltaRight = radius - deltaLeft;
 65         }
 66         break;
 67     case 1:
 68         if (!(radius % 2)) {
 69             deltaLeft++;
 70             deltaRight--;
 71         }
 72         break;
 73     case 2:
 74         if (!(radius % 2)) {
 75             deltaRight++;
 76             radius++;
 77         }
 78         break;
 79     }
 80 }
 81 
 82 FEGaussianBlur::FEGaussianBlur(Filter&amp; filter, float x, float y, EdgeModeType edgeMode)
 83     : FilterEffect(filter)
 84     , m_stdX(x)
 85     , m_stdY(y)
 86     , m_edgeMode(edgeMode)
 87 {
 88 }
 89 
 90 Ref&lt;FEGaussianBlur&gt; FEGaussianBlur::create(Filter&amp; filter, float x, float y, EdgeModeType edgeMode)
 91 {
 92     return adoptRef(*new FEGaussianBlur(filter, x, y, edgeMode));
 93 }
 94 
 95 void FEGaussianBlur::setStdDeviationX(float x)
 96 {
 97     m_stdX = x;
 98 }
 99 
100 void FEGaussianBlur::setStdDeviationY(float y)
101 {
102     m_stdY = y;
103 }
104 
105 void FEGaussianBlur::setEdgeMode(EdgeModeType edgeMode)
106 {
107     m_edgeMode = edgeMode;
108 }
109 
110 // This function only operates on Alpha channel.
111 inline void boxBlurAlphaOnly(const Uint8ClampedArray&amp; srcPixelArray, Uint8ClampedArray&amp; dstPixelArray,
112     unsigned dx, int&amp; dxLeft, int&amp; dxRight, int&amp; stride, int&amp; strideLine, int&amp; effectWidth, int&amp; effectHeight, const int&amp; maxKernelSize)
113 {
114     const uint8_t* srcData = srcPixelArray.data();
115     uint8_t* dstData = dstPixelArray.data();
116     // Memory alignment is: RGBA, zero-index based.
117     const int channel = 3;
118 
119     for (int y = 0; y &lt; effectHeight; ++y) {
120         int line = y * strideLine;
121         int sum = 0;
122 
123         // Fill the kernel.
124         for (int i = 0; i &lt; maxKernelSize; ++i) {
125             unsigned offset = line + i * stride;
126             const uint8_t* srcPtr = srcData + offset;
127             sum += srcPtr[channel];
128         }
129 
130         // Blurring.
131         for (int x = 0; x &lt; effectWidth; ++x) {
132             unsigned pixelByteOffset = line + x * stride + channel;
133             uint8_t* dstPtr = dstData + pixelByteOffset;
134             *dstPtr = static_cast&lt;uint8_t&gt;(sum / dx);
135 
136             // Shift kernel.
137             if (x &gt;= dxLeft) {
138                 unsigned leftOffset = pixelByteOffset - dxLeft * stride;
139                 const uint8_t* srcPtr = srcData + leftOffset;
140                 sum -= *srcPtr;
141             }
142 
143             if (x + dxRight &lt; effectWidth) {
144                 unsigned rightOffset = pixelByteOffset + dxRight * stride;
145                 const uint8_t* srcPtr = srcData + rightOffset;
146                 sum += *srcPtr;
147             }
148         }
149     }
150 }
151 
152 inline void boxBlur(const Uint8ClampedArray&amp; srcPixelArray, Uint8ClampedArray&amp; dstPixelArray,
153     unsigned dx, int dxLeft, int dxRight, int stride, int strideLine, int effectWidth, int effectHeight, bool alphaImage, EdgeModeType edgeMode)
154 {
155     const int maxKernelSize = std::min(dxRight, effectWidth);
156     if (alphaImage)
157         return boxBlurAlphaOnly(srcPixelArray, dstPixelArray, dx, dxLeft, dxRight, stride, strideLine,  effectWidth, effectHeight, maxKernelSize);
158 
159     const uint8_t* srcData = srcPixelArray.data();
160     uint8_t* dstData = dstPixelArray.data();
161 
162     // Concerning the array width/length: it is Element size + Margin + Border. The number of pixels will be
163     // P = width * height * channels.
164     for (int y = 0; y &lt; effectHeight; ++y) {
165         int line = y * strideLine;
166         int sumR = 0, sumG = 0, sumB = 0, sumA = 0;
167 
168         if (edgeMode == EDGEMODE_NONE) {
169             // Fill the kernel.
170             for (int i = 0; i &lt; maxKernelSize; ++i) {
171                 unsigned offset = line + i * stride;
172                 const uint8_t* srcPtr = srcData + offset;
173                 sumR += *srcPtr++;
174                 sumG += *srcPtr++;
175                 sumB += *srcPtr++;
176                 sumA += *srcPtr;
177             }
178 
179             // Blurring.
180             for (int x = 0; x &lt; effectWidth; ++x) {
181                 unsigned pixelByteOffset = line + x * stride;
182                 uint8_t* dstPtr = dstData + pixelByteOffset;
183 
184                 *dstPtr++ = static_cast&lt;uint8_t&gt;(sumR / dx);
185                 *dstPtr++ = static_cast&lt;uint8_t&gt;(sumG / dx);
186                 *dstPtr++ = static_cast&lt;uint8_t&gt;(sumB / dx);
187                 *dstPtr = static_cast&lt;uint8_t&gt;(sumA / dx);
188 
189                 // Shift kernel.
190                 if (x &gt;= dxLeft) {
191                     unsigned leftOffset = pixelByteOffset - dxLeft * stride;
192                     const uint8_t* srcPtr = srcData + leftOffset;
193                     sumR -= srcPtr[0];
194                     sumG -= srcPtr[1];
195                     sumB -= srcPtr[2];
196                     sumA -= srcPtr[3];
197                 }
198 
199                 if (x + dxRight &lt; effectWidth) {
200                     unsigned rightOffset = pixelByteOffset + dxRight * stride;
201                     const uint8_t* srcPtr = srcData + rightOffset;
202                     sumR += srcPtr[0];
203                     sumG += srcPtr[1];
204                     sumB += srcPtr[2];
205                     sumA += srcPtr[3];
206                 }
207             }
208 
209         } else {
210             // FIXME: Add support for &#39;wrap&#39; here.
211             // Get edge values for edgeMode &#39;duplicate&#39;.
212             const uint8_t* edgeValueLeft = srcData + line;
213             const uint8_t* edgeValueRight  = srcData + (line + (effectWidth - 1) * stride);
214 
215             // Fill the kernel.
216             for (int i = dxLeft * -1; i &lt; dxRight; ++i) {
217                 // Is this right for negative values of &#39;i&#39;?
218                 unsigned offset = line + i * stride;
219                 const uint8_t* srcPtr = srcData + offset;
220 
221                 if (i &lt; 0) {
222                     sumR += edgeValueLeft[0];
223                     sumG += edgeValueLeft[1];
224                     sumB += edgeValueLeft[2];
225                     sumA += edgeValueLeft[3];
226                 } else if (i &gt;= effectWidth) {
227                     sumR += edgeValueRight[0];
228                     sumG += edgeValueRight[1];
229                     sumB += edgeValueRight[2];
230                     sumA += edgeValueRight[3];
231                 } else {
232                     sumR += *srcPtr++;
233                     sumG += *srcPtr++;
234                     sumB += *srcPtr++;
235                     sumA += *srcPtr;
236                 }
237             }
238 
239             // Blurring.
240             for (int x = 0; x &lt; effectWidth; ++x) {
241                 unsigned pixelByteOffset = line + x * stride;
242                 uint8_t* dstPtr = dstData + pixelByteOffset;
243 
244                 *dstPtr++ = static_cast&lt;uint8_t&gt;(sumR / dx);
245                 *dstPtr++ = static_cast&lt;uint8_t&gt;(sumG / dx);
246                 *dstPtr++ = static_cast&lt;uint8_t&gt;(sumB / dx);
247                 *dstPtr = static_cast&lt;uint8_t&gt;(sumA / dx);
248 
249                 // Shift kernel.
250                 if (x &lt; dxLeft) {
251                     sumR -= edgeValueLeft[0];
252                     sumG -= edgeValueLeft[1];
253                     sumB -= edgeValueLeft[2];
254                     sumA -= edgeValueLeft[3];
255                 } else {
256                     unsigned leftOffset = pixelByteOffset - dxLeft * stride;
257                     const uint8_t* srcPtr = srcData + leftOffset;
258                     sumR -= srcPtr[0];
259                     sumG -= srcPtr[1];
260                     sumB -= srcPtr[2];
261                     sumA -= srcPtr[3];
262                 }
263 
264                 if (x + dxRight &gt;= effectWidth) {
265                     sumR += edgeValueRight[0];
266                     sumG += edgeValueRight[1];
267                     sumB += edgeValueRight[2];
268                     sumA += edgeValueRight[3];
269                 } else {
270                     unsigned rightOffset = pixelByteOffset + dxRight * stride;
271                     const uint8_t* srcPtr = srcData + rightOffset;
272                     sumR += srcPtr[0];
273                     sumG += srcPtr[1];
274                     sumB += srcPtr[2];
275                     sumA += srcPtr[3];
276                 }
277             }
278         }
279     }
280 }
281 
282 #if USE(ACCELERATE)
283 inline void accelerateBoxBlur(Uint8ClampedArray&amp; ioBuffer, Uint8ClampedArray&amp; tempBuffer, unsigned kernelSize, int stride, int effectWidth, int effectHeight)
284 {
285     if (!ioBuffer.data() || !tempBuffer.data()) {
286         ASSERT_NOT_REACHED();
287         return;
288     }
289 
290     if (effectWidth &lt;= 0 || effectHeight &lt;= 0 || stride &lt;= 0) {
291         ASSERT_NOT_REACHED();
292         return;
293     }
294 
295     // We must always use an odd radius.
296     if (kernelSize % 2 != 1)
297         kernelSize += 1;
298 
299     vImage_Buffer effectInBuffer;
300     effectInBuffer.data = static_cast&lt;void*&gt;(ioBuffer.data());
301     effectInBuffer.width = effectWidth;
302     effectInBuffer.height = effectHeight;
303     effectInBuffer.rowBytes = stride;
304 
305     vImage_Buffer effectOutBuffer;
306     effectOutBuffer.data = tempBuffer.data();
307     effectOutBuffer.width = effectWidth;
308     effectOutBuffer.height = effectHeight;
309     effectOutBuffer.rowBytes = stride;
310 
311     // Determine the size of a temporary buffer by calling the function first with a special flag. vImage will return
312     // the size needed, or an error (which are all negative).
313     size_t tmpBufferSize = vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, 0, 0, 0, kernelSize, kernelSize, 0, kvImageEdgeExtend | kvImageGetTempBufferSize);
314     if (tmpBufferSize &lt;= 0)
315         return;
316 
317     void* tmpBuffer = fastMalloc(tmpBufferSize);
318     vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, tmpBuffer, 0, 0, kernelSize, kernelSize, 0, kvImageEdgeExtend);
319     vImageBoxConvolve_ARGB8888(&amp;effectOutBuffer, &amp;effectInBuffer, tmpBuffer, 0, 0, kernelSize, kernelSize, 0, kvImageEdgeExtend);
320     vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, tmpBuffer, 0, 0, kernelSize, kernelSize, 0, kvImageEdgeExtend);
321     WTF::fastFree(tmpBuffer);
322 
323     // The final result should be stored in ioBuffer.
324     ASSERT(ioBuffer.length() == tempBuffer.length());
325     memcpy(ioBuffer.data(), tempBuffer.data(), ioBuffer.length());
326 }
327 #endif
328 
329 inline void standardBoxBlur(Uint8ClampedArray&amp; ioBuffer, Uint8ClampedArray&amp; tempBuffer, unsigned kernelSizeX, unsigned kernelSizeY, int stride, IntSize&amp; paintSize, bool isAlphaImage, EdgeModeType edgeMode)
330 {
331     int dxLeft = 0;
332     int dxRight = 0;
333     int dyLeft = 0;
334     int dyRight = 0;
335 
336     Uint8ClampedArray* fromBuffer = &amp;ioBuffer;
337     Uint8ClampedArray* toBuffer = &amp;tempBuffer;
338 
339     for (int i = 0; i &lt; 3; ++i) {
340         if (kernelSizeX) {
341             kernelPosition(i, kernelSizeX, dxLeft, dxRight);
342 #if HAVE(ARM_NEON_INTRINSICS)
343             if (!isAlphaImage)
344                 boxBlurNEON(*fromBuffer, *toBuffer, kernelSizeX, dxLeft, dxRight, 4, stride, paintSize.width(), paintSize.height());
345             else
346                 boxBlur(*fromBuffer, *toBuffer, kernelSizeX, dxLeft, dxRight, 4, stride, paintSize.width(), paintSize.height(), true, edgeMode);
347 #else
348             boxBlur(*fromBuffer, *toBuffer, kernelSizeX, dxLeft, dxRight, 4, stride, paintSize.width(), paintSize.height(), isAlphaImage, edgeMode);
349 #endif
350             std::swap(fromBuffer, toBuffer);
351         }
352 
353         if (kernelSizeY) {
354             kernelPosition(i, kernelSizeY, dyLeft, dyRight);
355 #if HAVE(ARM_NEON_INTRINSICS)
356             if (!isAlphaImage)
357                 boxBlurNEON(*fromBuffer, *toBuffer, kernelSizeY, dyLeft, dyRight, stride, 4, paintSize.height(), paintSize.width());
358             else
359                 boxBlur(*fromBuffer, *toBuffer, kernelSizeY, dyLeft, dyRight, stride, 4, paintSize.height(), paintSize.width(), true, edgeMode);
360 #else
361             boxBlur(*fromBuffer, *toBuffer, kernelSizeY, dyLeft, dyRight, stride, 4, paintSize.height(), paintSize.width(), isAlphaImage, edgeMode);
362 #endif
363             std::swap(fromBuffer, toBuffer);
364         }
365     }
366 
367     // The final result should be stored in ioBuffer.
368     if (&amp;ioBuffer != fromBuffer) {
369         ASSERT(ioBuffer.length() == fromBuffer-&gt;length());
370         memcpy(ioBuffer.data(), fromBuffer-&gt;data(), ioBuffer.length());
371     }
372 }
373 
374 inline void FEGaussianBlur::platformApplyGeneric(Uint8ClampedArray&amp; ioBuffer, Uint8ClampedArray&amp; tmpPixelArray, unsigned kernelSizeX, unsigned kernelSizeY, IntSize&amp; paintSize)
375 {
376     int stride = 4 * paintSize.width();
377 
378 #if USE(ACCELERATE)
379     if (kernelSizeX == kernelSizeY &amp;&amp; (m_edgeMode == EDGEMODE_NONE || m_edgeMode == EDGEMODE_DUPLICATE)) {
380         accelerateBoxBlur(ioBuffer, tmpPixelArray, kernelSizeX, stride, paintSize.width(), paintSize.height());
381         return;
382     }
383 #endif
384 
385     standardBoxBlur(ioBuffer, tmpPixelArray, kernelSizeX, kernelSizeY, stride, paintSize, isAlphaImage(), m_edgeMode);
386 }
387 
388 void FEGaussianBlur::platformApplyWorker(PlatformApplyParameters* parameters)
389 {
390     IntSize paintSize(parameters-&gt;width, parameters-&gt;height);
391     parameters-&gt;filter-&gt;platformApplyGeneric(*parameters-&gt;ioPixelArray, *parameters-&gt;tmpPixelArray, parameters-&gt;kernelSizeX, parameters-&gt;kernelSizeY, paintSize);
392 }
393 
394 inline void FEGaussianBlur::platformApply(Uint8ClampedArray&amp; ioBuffer, Uint8ClampedArray&amp; tmpPixelArray, unsigned kernelSizeX, unsigned kernelSizeY, IntSize&amp; paintSize)
395 {
396 #if !USE(ACCELERATE)
397     int scanline = 4 * paintSize.width();
398     int extraHeight = 3 * kernelSizeY * 0.5f;
399     int optimalThreadNumber = (paintSize.width() * paintSize.height()) / (s_minimalRectDimension + extraHeight * paintSize.width());
400 
401     if (optimalThreadNumber &gt; 1) {
402         WTF::ParallelJobs&lt;PlatformApplyParameters&gt; parallelJobs(&amp;platformApplyWorker, optimalThreadNumber);
403 
404         int jobs = parallelJobs.numberOfJobs();
405         if (jobs &gt; 1) {
406             // Split the job into &quot;blockHeight&quot;-sized jobs but there a few jobs that need to be slightly larger since
407             // blockHeight * jobs &lt; total size. These extras are handled by the remainder &quot;jobsWithExtra&quot;.
408             const int blockHeight = paintSize.height() / jobs;
409             const int jobsWithExtra = paintSize.height() % jobs;
410 
411             int currentY = 0;
412             for (int job = 0; job &lt; jobs; job++) {
413                 PlatformApplyParameters&amp; params = parallelJobs.parameter(job);
414                 params.filter = this;
415 
416                 int startY = !job ? 0 : currentY - extraHeight;
417                 currentY += job &lt; jobsWithExtra ? blockHeight + 1 : blockHeight;
418                 int endY = job == jobs - 1 ? currentY : currentY + extraHeight;
419 
420                 int blockSize = (endY - startY) * scanline;
421                 if (!job) {
422                     params.ioPixelArray = &amp;ioBuffer;
423                     params.tmpPixelArray = &amp;tmpPixelArray;
424                 } else {
425                     params.ioPixelArray = Uint8ClampedArray::createUninitialized(blockSize);
426                     params.tmpPixelArray = Uint8ClampedArray::createUninitialized(blockSize);
427                     memcpy(params.ioPixelArray-&gt;data(), ioBuffer.data() + startY * scanline, blockSize);
428                 }
429 
430                 params.width = paintSize.width();
431                 params.height = endY - startY;
432                 params.kernelSizeX = kernelSizeX;
433                 params.kernelSizeY = kernelSizeY;
434             }
435 
436             parallelJobs.execute();
437 
438             // Copy together the parts of the image.
439             currentY = 0;
440             for (int job = 1; job &lt; jobs; job++) {
441                 PlatformApplyParameters&amp; params = parallelJobs.parameter(job);
442                 int sourceOffset;
443                 int destinationOffset;
444                 int size;
445                 int adjustedBlockHeight = job &lt; jobsWithExtra ? blockHeight + 1 : blockHeight;
446 
447                 currentY += adjustedBlockHeight;
448                 sourceOffset = extraHeight * scanline;
449                 destinationOffset = currentY * scanline;
450                 size = adjustedBlockHeight * scanline;
451 
452                 memcpy(ioBuffer.data() + destinationOffset, params.ioPixelArray-&gt;data() + sourceOffset, size);
453             }
454             return;
455         }
456         // Fallback to single threaded mode.
457     }
458 #endif
459 
460     // The selection here eventually should happen dynamically on some platforms.
461     platformApplyGeneric(ioBuffer, tmpPixelArray, kernelSizeX, kernelSizeY, paintSize);
462 }
463 
464 static int clampedToKernelSize(float value)
465 {
466     // Limit the kernel size to 500. A bigger radius won&#39;t make a big difference for the result image but
467     // inflates the absolute paint rect too much. This is compatible with Firefox&#39; behavior.
468     unsigned size = std::max&lt;unsigned&gt;(2, static_cast&lt;unsigned&gt;(floorf(value * gaussianKernelFactor() + 0.5f)));
469     return clampTo&lt;int&gt;(std::min(size, static_cast&lt;unsigned&gt;(gMaxKernelSize)));
470 }
471 
472 IntSize FEGaussianBlur::calculateUnscaledKernelSize(FloatSize stdDeviation)
473 {
474     ASSERT(stdDeviation.width() &gt;= 0 &amp;&amp; stdDeviation.height() &gt;= 0);
475     IntSize kernelSize;
476 
477     if (stdDeviation.width())
478         kernelSize.setWidth(clampedToKernelSize(stdDeviation.width()));
479 
480     if (stdDeviation.height())
481         kernelSize.setHeight(clampedToKernelSize(stdDeviation.height()));
482 
483     return kernelSize;
484 }
485 
486 IntSize FEGaussianBlur::calculateKernelSize(const Filter&amp; filter, FloatSize stdDeviation)
487 {
488     return calculateUnscaledKernelSize(filter.scaledByFilterResolution(stdDeviation));
489 }
490 
<a name="1" id="anc1"></a><span class="line-added">491 IntSize FEGaussianBlur::calculateOutsetSize(FloatSize stdDeviation)</span>
<span class="line-added">492 {</span>
<span class="line-added">493     auto kernelSize = calculateUnscaledKernelSize(stdDeviation);</span>
<span class="line-added">494 </span>
<span class="line-added">495     // We take the half kernel size and multiply it with three, because we run box blur three times.</span>
<span class="line-added">496     return { 3 * kernelSize.width() / 2, 3 * kernelSize.height() / 2 };</span>
<span class="line-added">497 }</span>
<span class="line-added">498 </span>
499 void FEGaussianBlur::determineAbsolutePaintRect()
500 {
501     IntSize kernelSize = calculateKernelSize(filter(), { m_stdX, m_stdY });
502 
503     FloatRect absolutePaintRect = inputEffect(0)-&gt;absolutePaintRect();
504     // Edge modes other than &#39;none&#39; do not inflate the affected paint rect.
505     if (m_edgeMode != EDGEMODE_NONE) {
506         setAbsolutePaintRect(enclosingIntRect(absolutePaintRect));
507         return;
508     }
509 
510     // We take the half kernel size and multiply it with three, because we run box blur three times.
511     absolutePaintRect.inflateX(3 * kernelSize.width() * 0.5f);
512     absolutePaintRect.inflateY(3 * kernelSize.height() * 0.5f);
513 
514     if (clipsToBounds())
515         absolutePaintRect.intersect(maxEffectRect());
516     else
517         absolutePaintRect.unite(maxEffectRect());
518 
519     setAbsolutePaintRect(enclosingIntRect(absolutePaintRect));
520 }
521 
522 void FEGaussianBlur::platformApplySoftware()
523 {
524     FilterEffect* in = inputEffect(0);
525 
526     Uint8ClampedArray* resultPixelArray = createPremultipliedImageResult();
527     if (!resultPixelArray)
528         return;
529 
530     setIsAlphaImage(in-&gt;isAlphaImage());
531 
532     IntRect effectDrawingRect = requestedRegionOfInputImageData(in-&gt;absolutePaintRect());
533     in-&gt;copyPremultipliedResult(*resultPixelArray, effectDrawingRect);
534 
535     if (!m_stdX &amp;&amp; !m_stdY)
536         return;
537 
538     IntSize kernelSize = calculateKernelSize(filter(), { m_stdX, m_stdY });
539     kernelSize.scale(filter().filterScale());
540 
541     IntSize paintSize = absolutePaintRect().size();
542     paintSize.scale(filter().filterScale());
543     auto tmpImageData = Uint8ClampedArray::tryCreateUninitialized((paintSize.area() * 4).unsafeGet());
544     if (!tmpImageData)
545         return;
546 
547     platformApply(*resultPixelArray, *tmpImageData, kernelSize.width(), kernelSize.height(), paintSize);
548 }
549 
<a name="2" id="anc2"></a><span class="line-added">550 IntOutsets FEGaussianBlur::outsets() const</span>
<span class="line-added">551 {</span>
<span class="line-added">552     IntSize outsetSize = calculateOutsetSize({ m_stdX, m_stdY });</span>
<span class="line-added">553     return { outsetSize.height(), outsetSize.width(), outsetSize.height(), outsetSize.width() };</span>
<span class="line-added">554 }</span>
<span class="line-added">555 </span>
556 TextStream&amp; FEGaussianBlur::externalRepresentation(TextStream&amp; ts, RepresentationType representation) const
557 {
558     ts &lt;&lt; indent &lt;&lt; &quot;[feGaussianBlur&quot;;
559     FilterEffect::externalRepresentation(ts, representation);
560     ts &lt;&lt; &quot; stdDeviation=\&quot;&quot; &lt;&lt; m_stdX &lt;&lt; &quot;, &quot; &lt;&lt; m_stdY &lt;&lt; &quot;\&quot;]\n&quot;;
561 
562     TextStream::IndentScope indentScope(ts);
563     inputEffect(0)-&gt;externalRepresentation(ts, representation);
564     return ts;
565 }
566 
567 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
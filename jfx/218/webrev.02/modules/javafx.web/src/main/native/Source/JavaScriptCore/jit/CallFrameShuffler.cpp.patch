diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.cpp
@@ -59,15 +59,15 @@
     // on 32-bit architectures yet.
     m_lockedRegisters.exclude(RegisterSet::vmCalleeSaveRegisters());
 #endif
 
     ASSERT(!data.callee.isInJSStack() || data.callee.virtualRegister().isLocal());
-    addNew(VirtualRegister(CallFrameSlot::callee), data.callee);
+    addNew(CallFrameSlot::callee, data.callee);
 
     for (size_t i = 0; i < data.args.size(); ++i) {
         ASSERT(!data.args[i].isInJSStack() || data.args[i].virtualRegister().isLocal());
-        addNew(virtualRegisterForArgument(i), data.args[i]);
+        addNew(virtualRegisterForArgumentIncludingThis(i), data.args[i]);
     }
 
 #if USE(JSVALUE64)
     for (Reg reg = Reg::first(); reg <= Reg::last(); reg = reg.next()) {
         if (!data.registers[reg].isSet())
@@ -77,13 +77,13 @@
             addNew(JSValueRegs(reg.gpr()), data.registers[reg]);
         else
             addNew(reg.fpr(), data.registers[reg]);
     }
 
-    m_tagTypeNumber = data.tagTypeNumber;
-    if (m_tagTypeNumber != InvalidGPRReg)
-        lockGPR(m_tagTypeNumber);
+    m_numberTagRegister = data.numberTagRegister;
+    if (m_numberTagRegister != InvalidGPRReg)
+        lockGPR(m_numberTagRegister);
 #endif
 }
 
 void CallFrameShuffler::dump(PrintStream& out) const
 {
@@ -150,11 +150,11 @@
                 else {
                     auto recoveryStr = toCString(getNew(newReg)->recovery());
                     out.printf(" %c%8s <- %18s %c ", d, str.data(),
                         recoveryStr.data(), d);
                 }
-            } else if (newReg == VirtualRegister { CallFrameSlot::argumentCount })
+            } else if (newReg == VirtualRegister { CallFrameSlot::argumentCountIncludingThis })
                 out.printf(" %c%8s <- %18zu %c ", d, str.data(), argCount(), d);
             else
                 out.printf(" %c%30s %c ", d, "", d);
         } else
             out.print(emptySpace);
@@ -214,12 +214,12 @@
     if (m_oldFrameOffset)
         out.print("   Old frame offset is ", m_oldFrameOffset, "\n");
     if (m_newFrameOffset)
         out.print("   New frame offset is ", m_newFrameOffset, "\n");
 #if USE(JSVALUE64)
-    if (m_tagTypeNumber != InvalidGPRReg)
-        out.print("   TagTypeNumber is currently in ", m_tagTypeNumber, "\n");
+    if (m_numberTagRegister != InvalidGPRReg)
+        out.print("   NumberTag is currently in ", m_numberTagRegister, "\n");
 #endif
 }
 
 CachedRecovery* CallFrameShuffler::getCachedRecovery(ValueRecovery recovery)
 {
@@ -290,11 +290,11 @@
     updateRecovery(cachedRecovery, ValueRecovery::displacedInJSStack(spillSlot, format));
 }
 
 void CallFrameShuffler::emitDeltaCheck()
 {
-    if (ASSERT_DISABLED)
+    if (!ASSERT_ENABLED)
         return;
 
     GPRReg scratchGPR { getFreeGPR() };
     if (scratchGPR != InvalidGPRReg) {
         if (verbose)
@@ -375,23 +375,11 @@
     // We'll use sp-based indexing so that we can load the
     // caller's frame pointer into the fpr immediately
     m_oldFrameBase = MacroAssembler::stackPointerRegister;
     m_oldFrameOffset = numLocals();
     m_newFrameBase = acquireGPR();
-#if CPU(X86)
-    // We load the frame pointer manually, but we need to ask the
-    // algorithm to move the return PC for us (it'd probably
-    // require a write to the danger zone). Since it'd be awkward
-    // to ask for half a value move, we ask that the whole thing
-    // be moved for us.
-    addNew(VirtualRegister { 0 },
-        ValueRecovery::displacedInJSStack(VirtualRegister(0), DataFormatJS));
-
-    // sp will point to head0 and we will move it up half a slot
-    // manually
-    m_newFrameOffset = 0;
-#elif CPU(ARM_THUMB2) || CPU(MIPS)
+#if CPU(ARM_THUMB2) || CPU(MIPS)
     // We load the frame pointer and link register
     // manually. We could ask the algorithm to load them for us,
     // and it would allow us to use the link register as an extra
     // temporary - but it'd mean that the frame pointer can also
     // be used as an extra temporary, so we keep the link register
@@ -428,11 +416,11 @@
 
     // We compute the new frame base by first computing the top of the
     // old frame (taking into account an argument count higher than
     // the number of parameters), then substracting to it the aligned
     // new frame size (adjusted).
-    m_jit.load32(MacroAssembler::Address(GPRInfo::callFrameRegister, CallFrameSlot::argumentCount * static_cast<int>(sizeof(Register)) + PayloadOffset), m_newFrameBase);
+    m_jit.load32(MacroAssembler::Address(GPRInfo::callFrameRegister, CallFrameSlot::argumentCountIncludingThis * static_cast<int>(sizeof(Register)) + PayloadOffset), m_newFrameBase);
     MacroAssembler::Jump argumentCountOK =
         m_jit.branch32(MacroAssembler::BelowOrEqual, m_newFrameBase,
             MacroAssembler::TrustedImm32(m_jit.codeBlock()->numParameters()));
     m_jit.add32(MacroAssembler::TrustedImm32(stackAlignmentRegisters() - 1 + CallFrame::headerSizeInRegisters), m_newFrameBase);
     m_jit.and32(MacroAssembler::TrustedImm32(-stackAlignmentRegisters()), m_newFrameBase);
@@ -474,16 +462,10 @@
     if (verbose)
         dataLog("Preparing frame for tail call:\n", *this);
 
     prepareAny();
 
-#if CPU(X86)
-    if (verbose)
-        dataLog("  Simulating pop of the call frame register\n");
-    m_jit.addPtr(MacroAssembler::TrustedImm32(sizeof(void*)), MacroAssembler::stackPointerRegister);
-#endif
-
     if (verbose)
         dataLog("Ready for tail call!\n");
 }
 
 bool CallFrameShuffler::tryWrites(CachedRecovery& cachedRecovery)
@@ -714,12 +696,12 @@
         bool writesOK = tryWrites(*cachedRecovery);
         ASSERT_UNUSED(writesOK, writesOK);
     }
 
 #if USE(JSVALUE64)
-    if (m_tagTypeNumber != InvalidGPRReg && m_newRegisters[m_tagTypeNumber])
-        releaseGPR(m_tagTypeNumber);
+    if (m_numberTagRegister != InvalidGPRReg && m_newRegisters[m_numberTagRegister])
+        releaseGPR(m_numberTagRegister);
 #endif
 
     // Handle 2) by loading all registers. We don't have to do any
     // writes, since they have been taken care of above.
     if (verbose)
@@ -733,19 +715,19 @@
         emitBox(*cachedRecovery);
         ASSERT(cachedRecovery->targets().isEmpty());
     }
 
 #if USE(JSVALUE64)
-    if (m_tagTypeNumber != InvalidGPRReg)
-        releaseGPR(m_tagTypeNumber);
+    if (m_numberTagRegister != InvalidGPRReg)
+        releaseGPR(m_numberTagRegister);
 #endif
 
     // At this point, we have read everything we cared about from the
     // stack, and written everything we had to to the stack.
     if (verbose)
         dataLog("  Callee frame is fully set up\n");
-    if (!ASSERT_DISABLED) {
+    if (ASSERT_ENABLED) {
         for (VirtualRegister reg = firstNew(); reg <= lastNew(); reg += 1)
             ASSERT_UNUSED(reg, !getNew(reg));
 
         for (CachedRecovery* cachedRecovery : m_cachedRecoveries) {
             ASSERT_UNUSED(cachedRecovery, cachedRecovery->targets().isEmpty());
@@ -754,16 +736,16 @@
     }
 
     // We need to handle 4) first because it implies releasing
     // m_newFrameBase, which could be a wanted register.
     if (verbose)
-        dataLog("   * Storing the argument count into ", VirtualRegister { CallFrameSlot::argumentCount }, "\n");
+        dataLog("   * Storing the argument count into ", VirtualRegister { CallFrameSlot::argumentCountIncludingThis }, "\n");
     m_jit.store32(MacroAssembler::TrustedImm32(0),
-        addressForNew(VirtualRegister { CallFrameSlot::argumentCount }).withOffset(TagOffset));
+        addressForNew(VirtualRegister { CallFrameSlot::argumentCountIncludingThis }).withOffset(TagOffset));
     RELEASE_ASSERT(m_numPassedArgs != UINT_MAX);
     m_jit.store32(MacroAssembler::TrustedImm32(m_numPassedArgs),
-        addressForNew(VirtualRegister { CallFrameSlot::argumentCount }).withOffset(PayloadOffset));
+        addressForNew(VirtualRegister { CallFrameSlot::argumentCountIncludingThis }).withOffset(PayloadOffset));
 
     if (!isSlowPath()) {
         ASSERT(m_newFrameBase != MacroAssembler::stackPointerRegister);
         if (verbose)
             dataLog("  Releasing the new frame base pointer\n");

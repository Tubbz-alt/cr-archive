<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PropertyCondition.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyableAccessCase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSObject.h&quot;
 29 #include &lt;wtf/CompactPointerTuple.h&gt;
 30 #include &lt;wtf/HashMap.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class TrackedReferences;
 35 
 36 class PropertyCondition {
 37 public:
 38     enum Kind : uint8_t {
 39         Presence,
 40         Absence,
 41         AbsenceOfSetEffect,
 42         Equivalence, // An adaptive watchpoint on this will be a pair of watchpoints, and when the structure transitions, we will set the replacement watchpoint on the new structure.

 43         HasPrototype
 44     };
 45 
 46     using Header = CompactPointerTuple&lt;UniquedStringImpl*, Kind&gt;;
 47 
 48     PropertyCondition()
 49         : m_header(nullptr, Presence)
 50     {
 51         memset(&amp;u, 0, sizeof(u));
 52     }
 53 
 54     PropertyCondition(WTF::HashTableDeletedValueType)
 55         : m_header(nullptr, Absence)
 56     {
 57         memset(&amp;u, 0, sizeof(u));
 58     }
 59 
 60     static PropertyCondition presenceWithoutBarrier(UniquedStringImpl* uid, PropertyOffset offset, unsigned attributes)
 61     {
 62         PropertyCondition result;
</pre>
<hr />
<pre>
106         return absenceOfSetEffectWithoutBarrier(uid, prototype);
107     }
108 
109     static PropertyCondition equivalenceWithoutBarrier(
110         UniquedStringImpl* uid, JSValue value)
111     {
112         PropertyCondition result;
113         result.m_header = Header(uid, Equivalence);
114         result.u.equivalence.value = JSValue::encode(value);
115         return result;
116     }
117 
118     static PropertyCondition equivalence(
119         VM&amp; vm, JSCell* owner, UniquedStringImpl* uid, JSValue value)
120     {
121         if (value.isCell() &amp;&amp; owner)
122             vm.heap.writeBarrier(owner);
123         return equivalenceWithoutBarrier(uid, value);
124     }
125 







126     static PropertyCondition hasPrototypeWithoutBarrier(JSObject* prototype)
127     {
128         PropertyCondition result;
129         result.m_header = Header(nullptr, HasPrototype);
130         result.u.prototype.prototype = prototype;
131         return result;
132     }
133 
134     static PropertyCondition hasPrototype(VM&amp; vm, JSCell* owner, JSObject* prototype)
135     {
136         if (owner)
137             vm.heap.writeBarrier(owner);
138         return hasPrototypeWithoutBarrier(prototype);
139     }
140 
141     explicit operator bool() const { return m_header.pointer() || m_header.type() != Presence; }
142 
143     Kind kind() const { return m_header.type(); }
144     UniquedStringImpl* uid() const { return m_header.pointer(); }
145 
</pre>
<hr />
<pre>
176 
177     void dumpInContext(PrintStream&amp;, DumpContext*) const;
178     void dump(PrintStream&amp;) const;
179 
180     unsigned hash() const
181     {
182         unsigned result = WTF::PtrHash&lt;UniquedStringImpl*&gt;::hash(m_header.pointer()) + static_cast&lt;unsigned&gt;(m_header.type());
183         switch (m_header.type()) {
184         case Presence:
185             result ^= u.presence.offset;
186             result ^= u.presence.attributes;
187             break;
188         case Absence:
189         case AbsenceOfSetEffect:
190         case HasPrototype:
191             result ^= WTF::PtrHash&lt;JSObject*&gt;::hash(u.prototype.prototype);
192             break;
193         case Equivalence:
194             result ^= EncodedJSValueHash::hash(u.equivalence.value);
195             break;


196         }
197         return result;
198     }
199 
200     bool operator==(const PropertyCondition&amp; other) const
201     {
202         if (m_header.pointer() != other.m_header.pointer())
203             return false;
204         if (m_header.type() != other.m_header.type())
205             return false;
206         switch (m_header.type()) {
207         case Presence:
208             return u.presence.offset == other.u.presence.offset
209                 &amp;&amp; u.presence.attributes == other.u.presence.attributes;
210         case Absence:
211         case AbsenceOfSetEffect:
212         case HasPrototype:
213             return u.prototype.prototype == other.u.prototype.prototype;
214         case Equivalence:
215             return u.equivalence.value == other.u.equivalence.value;


216         }
217         RELEASE_ASSERT_NOT_REACHED();
218         return false;
219     }
220 
221     bool isHashTableDeletedValue() const
222     {
223         return !m_header.pointer() &amp;&amp; m_header.type() == Absence;
224     }
225 
226     // Two conditions are compatible if they are identical or if they speak of different uids. If
227     // false is returned, you have to decide how to resolve the conflict - for example if there is
228     // a Presence and an Equivalence then in some cases you&#39;ll want the more general of the two
229     // while in other cases you&#39;ll want the more specific of the two. This will also return false
230     // for contradictions, like Presence and Absence on the same uid. By convention, invalid
231     // conditions aren&#39;t compatible with anything.
232     bool isCompatibleWith(const PropertyCondition&amp; other) const
233     {
234         if (!*this || !other)
235             return false;
</pre>
<hr />
<pre>
262         // object, and implies that if the property happens not to be watchable then we don&#39;t make
263         // it watchable. This is mandatory if calling from a JIT thread. This is also somewhat
264         // preferable when first deciding whether to watch a condition for the first time (i.e.
265         // not from a watchpoint fire that causes us to see if we should adapt), since a
266         // watchpoint not being initialized for watching implies that maybe we don&#39;t know enough
267         // yet to make it profitable to watch -- as in, the thing being watched may not have
268         // stabilized yet. We prefer to only assume that a condition will hold if it has been
269         // known to hold for a while already.
270         MakeNoChanges,
271 
272         // Do what it takes to ensure that the property can be watched, if doing so has no
273         // user-observable effect. For now this just means that we will ensure that a property
274         // replacement watchpoint is enabled if it hadn&#39;t been enabled already. Do not use this
275         // from JIT threads, since the act of enabling watchpoints is not thread-safe.
276         EnsureWatchability
277     };
278 
279     // This means that it&#39;s still valid and we could enforce validity by setting a transition
280     // watchpoint on the structure and possibly an impure property watchpoint.
281     bool isWatchableAssumingImpurePropertyWatchpoint(
<span class="line-modified">282         Structure*, JSObject* base = nullptr, WatchabilityEffort = MakeNoChanges) const;</span>
283 
284     // This means that it&#39;s still valid and we could enforce validity by setting a transition
285     // watchpoint on the structure.
286     bool isWatchable(
<span class="line-modified">287         Structure*, JSObject* base = nullptr, WatchabilityEffort = MakeNoChanges) const;</span>
288 
289     bool watchingRequiresStructureTransitionWatchpoint() const
290     {
291         // Currently, this is required for all of our conditions.
292         return !!*this;
293     }
294     bool watchingRequiresReplacementWatchpoint() const
295     {
296         return !!*this &amp;&amp; m_header.type() == Equivalence;
297     }
298 
<span class="line-modified">299     // This means that the objects involved in this are still live.</span>
<span class="line-modified">300     bool isStillLive(VM&amp;) const;</span>







301 
302     void validateReferences(const TrackedReferences&amp;) const;
303 
304     static bool isValidValueForAttributes(VM&amp;, JSValue, unsigned attributes);
305 
306     bool isValidValueForPresence(VM&amp;, JSValue) const;
307 
308     PropertyCondition attemptToMakeEquivalenceWithoutBarrier(VM&amp;, JSObject* base) const;
309 
310 private:
311     bool isWatchableWhenValid(Structure*, WatchabilityEffort) const;
312 
313     Header m_header;
314     union {
315         struct {
316             PropertyOffset offset;
317             unsigned attributes;
318         } presence;
319         struct {
320             JSObject* prototype;
321         } prototype;
322         struct {
323             EncodedJSValue value;
324         } equivalence;
325     } u;
326 };
327 
328 struct PropertyConditionHash {
329     static unsigned hash(const PropertyCondition&amp; key) { return key.hash(); }
330     static bool equal(
331         const PropertyCondition&amp; a, const PropertyCondition&amp; b)
332     {
333         return a == b;
334     }
<span class="line-modified">335     static const bool safeToCompareToEmptyOrDeleted = true;</span>
336 };
337 
338 } // namespace JSC
339 
340 namespace WTF {
341 
342 void printInternal(PrintStream&amp;, JSC::PropertyCondition::Kind);
343 
344 template&lt;typename T&gt; struct DefaultHash;
345 template&lt;&gt; struct DefaultHash&lt;JSC::PropertyCondition&gt; {
346     typedef JSC::PropertyConditionHash Hash;
347 };
348 
349 template&lt;typename T&gt; struct HashTraits;
350 template&lt;&gt; struct HashTraits&lt;JSC::PropertyCondition&gt; : SimpleClassHashTraits&lt;JSC::PropertyCondition&gt; { };
351 
352 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSObject.h&quot;
 29 #include &lt;wtf/CompactPointerTuple.h&gt;
 30 #include &lt;wtf/HashMap.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class TrackedReferences;
 35 
 36 class PropertyCondition {
 37 public:
 38     enum Kind : uint8_t {
 39         Presence,
 40         Absence,
 41         AbsenceOfSetEffect,
 42         Equivalence, // An adaptive watchpoint on this will be a pair of watchpoints, and when the structure transitions, we will set the replacement watchpoint on the new structure.
<span class="line-added"> 43         CustomFunctionEquivalence, // Custom value or accessor.</span>
 44         HasPrototype
 45     };
 46 
 47     using Header = CompactPointerTuple&lt;UniquedStringImpl*, Kind&gt;;
 48 
 49     PropertyCondition()
 50         : m_header(nullptr, Presence)
 51     {
 52         memset(&amp;u, 0, sizeof(u));
 53     }
 54 
 55     PropertyCondition(WTF::HashTableDeletedValueType)
 56         : m_header(nullptr, Absence)
 57     {
 58         memset(&amp;u, 0, sizeof(u));
 59     }
 60 
 61     static PropertyCondition presenceWithoutBarrier(UniquedStringImpl* uid, PropertyOffset offset, unsigned attributes)
 62     {
 63         PropertyCondition result;
</pre>
<hr />
<pre>
107         return absenceOfSetEffectWithoutBarrier(uid, prototype);
108     }
109 
110     static PropertyCondition equivalenceWithoutBarrier(
111         UniquedStringImpl* uid, JSValue value)
112     {
113         PropertyCondition result;
114         result.m_header = Header(uid, Equivalence);
115         result.u.equivalence.value = JSValue::encode(value);
116         return result;
117     }
118 
119     static PropertyCondition equivalence(
120         VM&amp; vm, JSCell* owner, UniquedStringImpl* uid, JSValue value)
121     {
122         if (value.isCell() &amp;&amp; owner)
123             vm.heap.writeBarrier(owner);
124         return equivalenceWithoutBarrier(uid, value);
125     }
126 
<span class="line-added">127     static PropertyCondition customFunctionEquivalence(UniquedStringImpl* uid)</span>
<span class="line-added">128     {</span>
<span class="line-added">129         PropertyCondition result;</span>
<span class="line-added">130         result.m_header = Header(uid, CustomFunctionEquivalence);</span>
<span class="line-added">131         return result;</span>
<span class="line-added">132     }</span>
<span class="line-added">133 </span>
134     static PropertyCondition hasPrototypeWithoutBarrier(JSObject* prototype)
135     {
136         PropertyCondition result;
137         result.m_header = Header(nullptr, HasPrototype);
138         result.u.prototype.prototype = prototype;
139         return result;
140     }
141 
142     static PropertyCondition hasPrototype(VM&amp; vm, JSCell* owner, JSObject* prototype)
143     {
144         if (owner)
145             vm.heap.writeBarrier(owner);
146         return hasPrototypeWithoutBarrier(prototype);
147     }
148 
149     explicit operator bool() const { return m_header.pointer() || m_header.type() != Presence; }
150 
151     Kind kind() const { return m_header.type(); }
152     UniquedStringImpl* uid() const { return m_header.pointer(); }
153 
</pre>
<hr />
<pre>
184 
185     void dumpInContext(PrintStream&amp;, DumpContext*) const;
186     void dump(PrintStream&amp;) const;
187 
188     unsigned hash() const
189     {
190         unsigned result = WTF::PtrHash&lt;UniquedStringImpl*&gt;::hash(m_header.pointer()) + static_cast&lt;unsigned&gt;(m_header.type());
191         switch (m_header.type()) {
192         case Presence:
193             result ^= u.presence.offset;
194             result ^= u.presence.attributes;
195             break;
196         case Absence:
197         case AbsenceOfSetEffect:
198         case HasPrototype:
199             result ^= WTF::PtrHash&lt;JSObject*&gt;::hash(u.prototype.prototype);
200             break;
201         case Equivalence:
202             result ^= EncodedJSValueHash::hash(u.equivalence.value);
203             break;
<span class="line-added">204         case CustomFunctionEquivalence:</span>
<span class="line-added">205             break;</span>
206         }
207         return result;
208     }
209 
210     bool operator==(const PropertyCondition&amp; other) const
211     {
212         if (m_header.pointer() != other.m_header.pointer())
213             return false;
214         if (m_header.type() != other.m_header.type())
215             return false;
216         switch (m_header.type()) {
217         case Presence:
218             return u.presence.offset == other.u.presence.offset
219                 &amp;&amp; u.presence.attributes == other.u.presence.attributes;
220         case Absence:
221         case AbsenceOfSetEffect:
222         case HasPrototype:
223             return u.prototype.prototype == other.u.prototype.prototype;
224         case Equivalence:
225             return u.equivalence.value == other.u.equivalence.value;
<span class="line-added">226         case CustomFunctionEquivalence:</span>
<span class="line-added">227             return true;</span>
228         }
229         RELEASE_ASSERT_NOT_REACHED();
230         return false;
231     }
232 
233     bool isHashTableDeletedValue() const
234     {
235         return !m_header.pointer() &amp;&amp; m_header.type() == Absence;
236     }
237 
238     // Two conditions are compatible if they are identical or if they speak of different uids. If
239     // false is returned, you have to decide how to resolve the conflict - for example if there is
240     // a Presence and an Equivalence then in some cases you&#39;ll want the more general of the two
241     // while in other cases you&#39;ll want the more specific of the two. This will also return false
242     // for contradictions, like Presence and Absence on the same uid. By convention, invalid
243     // conditions aren&#39;t compatible with anything.
244     bool isCompatibleWith(const PropertyCondition&amp; other) const
245     {
246         if (!*this || !other)
247             return false;
</pre>
<hr />
<pre>
274         // object, and implies that if the property happens not to be watchable then we don&#39;t make
275         // it watchable. This is mandatory if calling from a JIT thread. This is also somewhat
276         // preferable when first deciding whether to watch a condition for the first time (i.e.
277         // not from a watchpoint fire that causes us to see if we should adapt), since a
278         // watchpoint not being initialized for watching implies that maybe we don&#39;t know enough
279         // yet to make it profitable to watch -- as in, the thing being watched may not have
280         // stabilized yet. We prefer to only assume that a condition will hold if it has been
281         // known to hold for a while already.
282         MakeNoChanges,
283 
284         // Do what it takes to ensure that the property can be watched, if doing so has no
285         // user-observable effect. For now this just means that we will ensure that a property
286         // replacement watchpoint is enabled if it hadn&#39;t been enabled already. Do not use this
287         // from JIT threads, since the act of enabling watchpoints is not thread-safe.
288         EnsureWatchability
289     };
290 
291     // This means that it&#39;s still valid and we could enforce validity by setting a transition
292     // watchpoint on the structure and possibly an impure property watchpoint.
293     bool isWatchableAssumingImpurePropertyWatchpoint(
<span class="line-modified">294         Structure*, JSObject* base, WatchabilityEffort = MakeNoChanges) const;</span>
295 
296     // This means that it&#39;s still valid and we could enforce validity by setting a transition
297     // watchpoint on the structure.
298     bool isWatchable(
<span class="line-modified">299         Structure*, JSObject*, WatchabilityEffort = MakeNoChanges) const;</span>
300 
301     bool watchingRequiresStructureTransitionWatchpoint() const
302     {
303         // Currently, this is required for all of our conditions.
304         return !!*this;
305     }
306     bool watchingRequiresReplacementWatchpoint() const
307     {
308         return !!*this &amp;&amp; m_header.type() == Equivalence;
309     }
310 
<span class="line-modified">311     template&lt;typename Functor&gt;</span>
<span class="line-modified">312     void forEachDependentCell(const Functor&amp; functor) const</span>
<span class="line-added">313     {</span>
<span class="line-added">314         if (hasPrototype() &amp;&amp; prototype())</span>
<span class="line-added">315             functor(prototype());</span>
<span class="line-added">316 </span>
<span class="line-added">317         if (hasRequiredValue() &amp;&amp; requiredValue() &amp;&amp; requiredValue().isCell())</span>
<span class="line-added">318             functor(requiredValue().asCell());</span>
<span class="line-added">319     }</span>
320 
321     void validateReferences(const TrackedReferences&amp;) const;
322 
323     static bool isValidValueForAttributes(VM&amp;, JSValue, unsigned attributes);
324 
325     bool isValidValueForPresence(VM&amp;, JSValue) const;
326 
327     PropertyCondition attemptToMakeEquivalenceWithoutBarrier(VM&amp;, JSObject* base) const;
328 
329 private:
330     bool isWatchableWhenValid(Structure*, WatchabilityEffort) const;
331 
332     Header m_header;
333     union {
334         struct {
335             PropertyOffset offset;
336             unsigned attributes;
337         } presence;
338         struct {
339             JSObject* prototype;
340         } prototype;
341         struct {
342             EncodedJSValue value;
343         } equivalence;
344     } u;
345 };
346 
347 struct PropertyConditionHash {
348     static unsigned hash(const PropertyCondition&amp; key) { return key.hash(); }
349     static bool equal(
350         const PropertyCondition&amp; a, const PropertyCondition&amp; b)
351     {
352         return a == b;
353     }
<span class="line-modified">354     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
355 };
356 
357 } // namespace JSC
358 
359 namespace WTF {
360 
361 void printInternal(PrintStream&amp;, JSC::PropertyCondition::Kind);
362 
363 template&lt;typename T&gt; struct DefaultHash;
364 template&lt;&gt; struct DefaultHash&lt;JSC::PropertyCondition&gt; {
365     typedef JSC::PropertyConditionHash Hash;
366 };
367 
368 template&lt;typename T&gt; struct HashTraits;
369 template&lt;&gt; struct HashTraits&lt;JSC::PropertyCondition&gt; : SimpleClassHashTraits&lt;JSC::PropertyCondition&gt; { };
370 
371 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="PropertyCondition.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyableAccessCase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
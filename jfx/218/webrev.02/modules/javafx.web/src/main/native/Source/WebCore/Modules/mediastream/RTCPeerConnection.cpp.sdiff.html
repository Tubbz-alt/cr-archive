<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RTCDataChannelEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RTCPeerConnection.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 #include &quot;config.h&quot;
 35 #include &quot;RTCPeerConnection.h&quot;
 36 
 37 #if ENABLE(WEB_RTC)
 38 
 39 #include &quot;Document.h&quot;
 40 #include &quot;Event.h&quot;
 41 #include &quot;EventNames.h&quot;
 42 #include &quot;Frame.h&quot;

 43 #include &quot;JSRTCPeerConnection.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;MediaEndpointConfiguration.h&quot;
 46 #include &quot;MediaStream.h&quot;
 47 #include &quot;MediaStreamTrack.h&quot;
 48 #include &quot;Page.h&quot;
 49 #include &quot;RTCConfiguration.h&quot;
 50 #include &quot;RTCController.h&quot;
 51 #include &quot;RTCDataChannel.h&quot;
 52 #include &quot;RTCIceCandidate.h&quot;
 53 #include &quot;RTCPeerConnectionIceEvent.h&quot;
 54 #include &quot;RTCSessionDescription.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &lt;wtf/CryptographicallyRandomNumber.h&gt;
 57 #include &lt;wtf/IsoMallocInlines.h&gt;
 58 #include &lt;wtf/MainThread.h&gt;
 59 #include &lt;wtf/UUID.h&gt;
 60 #include &lt;wtf/text/Base64.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 using namespace PeerConnection;
 65 
 66 WTF_MAKE_ISO_ALLOCATED_IMPL(RTCPeerConnection);
 67 
 68 Ref&lt;RTCPeerConnection&gt; RTCPeerConnection::create(ScriptExecutionContext&amp; context)
 69 {
<span class="line-modified"> 70     auto peerConnection = adoptRef(*new RTCPeerConnection(context));</span>

 71     peerConnection-&gt;suspendIfNeeded();
<span class="line-removed"> 72     // RTCPeerConnection may send events at about any time during its lifetime.</span>
<span class="line-removed"> 73     // Let&#39;s make it uncollectable until the pc is closed by JS or the page stops it.</span>
 74     if (!peerConnection-&gt;isClosed()) {
<span class="line-modified"> 75         peerConnection-&gt;m_pendingActivity = peerConnection-&gt;makePendingActivity(peerConnection.get());</span>
<span class="line-removed"> 76         if (auto* page = downcast&lt;Document&gt;(context).page()) {</span>
 77             peerConnection-&gt;registerToController(page-&gt;rtcController());
<span class="line-modified"> 78             page-&gt;libWebRTCProvider().setEnableLogging(!context.sessionID().isEphemeral());</span>
 79         }
 80     }
 81     return peerConnection;
 82 }
 83 
<span class="line-modified"> 84 RTCPeerConnection::RTCPeerConnection(ScriptExecutionContext&amp; context)</span>
<span class="line-modified"> 85     : ActiveDOMObject(&amp;context)</span>
 86 #if !RELEASE_LOG_DISABLED
<span class="line-modified"> 87     , m_logger(downcast&lt;Document&gt;(context).logger())</span>
 88     , m_logIdentifier(reinterpret_cast&lt;const void*&gt;(cryptographicallyRandomNumber()))
 89 #endif
 90     , m_backend(PeerConnectionBackend::create(*this))
 91 {
 92     ALWAYS_LOG(LOGIDENTIFIER);
 93 
 94 #if !RELEASE_LOG_DISABLED
<span class="line-modified"> 95     auto* page = downcast&lt;Document&gt;(context).page();</span>
 96     if (page &amp;&amp; !page-&gt;settings().webRTCEncryptionEnabled())
 97         ALWAYS_LOG(LOGIDENTIFIER, &quot;encryption is disabled&quot;);
 98 #endif
 99 
100     if (!m_backend)
101         m_connectionState = RTCPeerConnectionState::Closed;
102 }
103 
104 RTCPeerConnection::~RTCPeerConnection()
105 {
106     ALWAYS_LOG(LOGIDENTIFIER);
107     unregisterFromController();
108     stop();
109 }
110 
111 ExceptionOr&lt;void&gt; RTCPeerConnection::initializeWith(Document&amp; document, RTCConfiguration&amp;&amp; configuration)
112 {
113     if (!document.frame())
114         return Exception { NotSupportedError };
115 
</pre>
<hr />
<pre>
179             return Exception { InvalidStateError };
180 
181         return m_backend-&gt;addTransceiver(kind, init);
182     }
183 
184     if (isClosed())
185         return Exception { InvalidStateError };
186 
187     auto track = WTF::get&lt;RefPtr&lt;MediaStreamTrack&gt;&gt;(withTrack).releaseNonNull();
188     return m_backend-&gt;addTransceiver(WTFMove(track), init);
189 }
190 
191 void RTCPeerConnection::queuedCreateOffer(RTCOfferOptions&amp;&amp; options, SessionDescriptionPromise&amp;&amp; promise)
192 {
193     ALWAYS_LOG(LOGIDENTIFIER);
194     if (isClosed()) {
195         promise.reject(InvalidStateError);
196         return;
197     }
198 

199     m_backend-&gt;createOffer(WTFMove(options), WTFMove(promise));
200 }
201 
202 void RTCPeerConnection::queuedCreateAnswer(RTCAnswerOptions&amp;&amp; options, SessionDescriptionPromise&amp;&amp; promise)
203 {
204     ALWAYS_LOG(LOGIDENTIFIER);
205     if (isClosed()) {
206         promise.reject(InvalidStateError);
207         return;
208     }
209 

210     m_backend-&gt;createAnswer(WTFMove(options), WTFMove(promise));
211 }
212 
213 void RTCPeerConnection::queuedSetLocalDescription(RTCSessionDescription&amp; description, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
214 {
215     ALWAYS_LOG(LOGIDENTIFIER, &quot;Setting local description to:\n&quot;, description.sdp());
216     if (isClosed()) {
217         promise.reject(InvalidStateError);
218         return;
219     }
220 

221     m_backend-&gt;setLocalDescription(description, WTFMove(promise));
222 }
223 
224 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::localDescription() const
225 {
226     return m_backend-&gt;localDescription();
227 }
228 
229 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::currentLocalDescription() const
230 {
231     return m_backend-&gt;currentLocalDescription();
232 }
233 
234 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::pendingLocalDescription() const
235 {
236     return m_backend-&gt;pendingLocalDescription();
237 }
238 
239 void RTCPeerConnection::queuedSetRemoteDescription(RTCSessionDescription&amp; description, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
240 {
241     ALWAYS_LOG(LOGIDENTIFIER, &quot;Setting remote description to:\n&quot;, description.sdp());
242 
243     if (isClosed()) {
244         promise.reject(InvalidStateError);
245         return;
246     }

247     m_backend-&gt;setRemoteDescription(description, WTFMove(promise));
248 }
249 
250 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::remoteDescription() const
251 {
252     return m_backend-&gt;remoteDescription();
253 }
254 
255 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::currentRemoteDescription() const
256 {
257     return m_backend-&gt;currentRemoteDescription();
258 }
259 
260 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::pendingRemoteDescription() const
261 {
262     return m_backend-&gt;pendingRemoteDescription();
263 }
264 
265 void RTCPeerConnection::queuedAddIceCandidate(RTCIceCandidate* rtcCandidate, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
266 {
267     ALWAYS_LOG(LOGIDENTIFIER, &quot;Received ice candidate:\n&quot;, rtcCandidate ? rtcCandidate-&gt;candidate() : &quot;null&quot;);
268 
269     if (isClosed()) {
270         promise.reject(InvalidStateError);
271         return;
272     }
273 

274     m_backend-&gt;addIceCandidate(rtcCandidate, WTFMove(promise));
275 }
276 
277 // Implementation of https://w3c.github.io/webrtc-pc/#set-pc-configuration
278 static inline ExceptionOr&lt;Vector&lt;MediaEndpointConfiguration::IceServerInfo&gt;&gt; iceServersFromConfiguration(RTCConfiguration&amp; newConfiguration, const RTCConfiguration* existingConfiguration, bool isLocalDescriptionSet)
279 {
280     if (existingConfiguration &amp;&amp; newConfiguration.bundlePolicy != existingConfiguration-&gt;bundlePolicy)
281         return Exception { InvalidModificationError, &quot;BundlePolicy does not match existing policy&quot; };
282 
283     if (existingConfiguration &amp;&amp; newConfiguration.rtcpMuxPolicy != existingConfiguration-&gt;rtcpMuxPolicy)
284         return Exception { InvalidModificationError, &quot;RTCPMuxPolicy does not match existing policy&quot; };
285 
286     if (existingConfiguration &amp;&amp; newConfiguration.iceCandidatePoolSize != existingConfiguration-&gt;iceCandidatePoolSize &amp;&amp; isLocalDescriptionSet)
287         return Exception { InvalidModificationError, &quot;IceTransportPolicy pool size does not match existing pool size&quot; };
288 
289     Vector&lt;MediaEndpointConfiguration::IceServerInfo&gt; servers;
290     if (newConfiguration.iceServers) {
291         servers.reserveInitialCapacity(newConfiguration.iceServers-&gt;size());
292         for (auto&amp; server : newConfiguration.iceServers.value()) {
293             Vector&lt;URL&gt; serverURLs;
</pre>
<hr />
<pre>
301             });
302             for (auto&amp; serverURL : serverURLs) {
303                 if (serverURL.isNull())
304                     return Exception { TypeError, &quot;Bad ICE server URL&quot; };
305                 if (serverURL.protocolIs(&quot;turn&quot;) || serverURL.protocolIs(&quot;turns&quot;)) {
306                     if (server.credential.isNull() || server.username.isNull())
307                         return Exception { InvalidAccessError, &quot;TURN/TURNS server requires both username and credential&quot; };
308                 } else if (!serverURL.protocolIs(&quot;stun&quot;))
309                     return Exception { NotSupportedError, &quot;ICE server protocol not supported&quot; };
310             }
311             if (serverURLs.size())
312                 servers.uncheckedAppend({ WTFMove(serverURLs), server.credential, server.username });
313         }
314     }
315     return servers;
316 }
317 
318 ExceptionOr&lt;Vector&lt;MediaEndpointConfiguration::CertificatePEM&gt;&gt; RTCPeerConnection::certificatesFromConfiguration(const RTCConfiguration&amp; configuration)
319 {
320     auto currentMilliSeconds = WallTime::now().secondsSinceEpoch().milliseconds();
<span class="line-modified">321     auto&amp; origin = downcast&lt;Document&gt;(*scriptExecutionContext()).securityOrigin();</span>
322 
323     Vector&lt;MediaEndpointConfiguration::CertificatePEM&gt; certificates;
324     certificates.reserveInitialCapacity(configuration.certificates.size());
325     for (auto&amp; certificate : configuration.certificates) {
326         if (!origin.isSameOriginAs(certificate-&gt;origin()))
327             return Exception { InvalidAccessError, &quot;Certificate does not have a valid origin&quot; };
328 
329         if (currentMilliSeconds &gt; certificate-&gt;expires())
330             return Exception { InvalidAccessError, &quot;Certificate has expired&quot;_s };
331 
332         certificates.uncheckedAppend(MediaEndpointConfiguration::CertificatePEM { certificate-&gt;pemCertificate(), certificate-&gt;pemPrivateKey(), });
333     }
334     return certificates;
335 }
336 
337 ExceptionOr&lt;void&gt; RTCPeerConnection::initializeConfiguration(RTCConfiguration&amp;&amp; configuration)
338 {
339     INFO_LOG(LOGIDENTIFIER);
340 
341     auto servers = iceServersFromConfiguration(configuration, nullptr, false);
</pre>
<hr />
<pre>
381         return Exception { InvalidAccessError, &quot;Bad Configuration Parameters&quot; };
382 
383     m_configuration = WTFMove(configuration);
384     return { };
385 }
386 
387 void RTCPeerConnection::getStats(MediaStreamTrack* selector, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
388 {
389     if (selector) {
390         for (auto&amp; transceiver : m_transceiverSet-&gt;list()) {
391             if (transceiver-&gt;sender().track() == selector) {
392                 m_backend-&gt;getStats(transceiver-&gt;sender(), WTFMove(promise));
393                 return;
394             }
395             if (&amp;transceiver-&gt;receiver().track() == selector) {
396                 m_backend-&gt;getStats(transceiver-&gt;receiver(), WTFMove(promise));
397                 return;
398             }
399         }
400     }

401     m_backend-&gt;getStats(WTFMove(promise));
402 }
403 
<span class="line-modified">404 ExceptionOr&lt;Ref&lt;RTCDataChannel&gt;&gt; RTCPeerConnection::createDataChannel(ScriptExecutionContext&amp; context, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
405 {
406     ALWAYS_LOG(LOGIDENTIFIER);
407 
408     if (isClosed())
409         return Exception { InvalidStateError };
410 
411     if (options.negotiated &amp;&amp; !options.negotiated.value() &amp;&amp; (label.length() &gt; 65535 || options.protocol.length() &gt; 65535))
412         return Exception { TypeError };
413 
414     if (options.maxPacketLifeTime &amp;&amp; options.maxRetransmits)
415         return Exception { TypeError };
416 
417     if (options.id &amp;&amp; options.id.value() &gt; 65534)
418         return Exception { TypeError };
419 
420     auto channelHandler = m_backend-&gt;createDataChannelHandler(label, options);
421     if (!channelHandler)
422         return Exception { NotSupportedError };
423 
<span class="line-modified">424     return RTCDataChannel::create(context, WTFMove(channelHandler), WTFMove(label), WTFMove(options));</span>
425 }
426 
427 bool RTCPeerConnection::doClose()
428 {
429     if (isClosed())
430         return false;
431 

432     m_connectionState = RTCPeerConnectionState::Closed;
433     m_iceConnectionState = RTCIceConnectionState::Closed;
434     m_signalingState = RTCSignalingState::Closed;
435 
436     for (auto&amp; transceiver : m_transceiverSet-&gt;list()) {
437         transceiver-&gt;stop();
438         transceiver-&gt;sender().stop();
439         transceiver-&gt;receiver().stop();
440     }
441 
442     return true;
443 }
444 
445 void RTCPeerConnection::close()
446 {
447     if (!doClose())
448         return;
449 
450     updateConnectionState();
451     ASSERT(isClosed());
<span class="line-modified">452     doStop();</span>
453 }
454 
455 void RTCPeerConnection::emulatePlatformEvent(const String&amp; action)
456 {
457     m_backend-&gt;emulatePlatformEvent(action);
458 }
459 
460 void RTCPeerConnection::stop()
461 {
<span class="line-modified">462     if (!doClose())</span>
<span class="line-removed">463         return;</span>
<span class="line-removed">464 </span>
465     doStop();
466 }
467 
468 void RTCPeerConnection::doStop()
469 {
470     if (m_isStopped)
471         return;
472 
473     m_isStopped = true;
<span class="line-modified">474 </span>
<span class="line-modified">475     m_backend-&gt;stop();</span>
<span class="line-removed">476     m_pendingActivity = nullptr;</span>
477 }
478 
479 void RTCPeerConnection::registerToController(RTCController&amp; controller)
480 {
481     m_controller = &amp;controller;
482     m_controller-&gt;add(*this);
483 }
484 
485 void RTCPeerConnection::unregisterFromController()
486 {
487     if (m_controller)
488         m_controller-&gt;remove(*this);
489 }
490 
491 const char* RTCPeerConnection::activeDOMObjectName() const
492 {
493     return &quot;RTCPeerConnection&quot;;
494 }
495 
<span class="line-modified">496 bool RTCPeerConnection::canSuspendForDocumentSuspension() const</span>
497 {
<span class="line-modified">498     return !hasPendingActivity();</span>






















499 }
500 
501 bool RTCPeerConnection::hasPendingActivity() const
502 {
<span class="line-modified">503     return !m_isStopped;</span>








504 }
505 
506 void RTCPeerConnection::addTransceiver(Ref&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver)
507 {
508     INFO_LOG(LOGIDENTIFIER);
509     m_transceiverSet-&gt;append(WTFMove(transceiver));
510 }
511 
512 void RTCPeerConnection::setSignalingState(RTCSignalingState newState)
513 {
514     ALWAYS_LOG(LOGIDENTIFIER, newState);
515     m_signalingState = newState;
516 }
517 
518 void RTCPeerConnection::updateIceGatheringState(RTCIceGatheringState newState)
519 {
520     ALWAYS_LOG(LOGIDENTIFIER, newState);
521 
522     scriptExecutionContext()-&gt;postTask([protectedThis = makeRef(*this), newState](ScriptExecutionContext&amp;) {
523         if (protectedThis-&gt;isClosed() || protectedThis-&gt;m_iceGatheringState == newState)
524             return;
525 
526         protectedThis-&gt;m_iceGatheringState = newState;
<span class="line-modified">527         protectedThis-&gt;dispatchEvent(Event::create(eventNames().icegatheringstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
528         protectedThis-&gt;updateConnectionState();
529     });
530 }
531 
532 void RTCPeerConnection::updateIceConnectionState(RTCIceConnectionState newState)
533 {
534     ALWAYS_LOG(LOGIDENTIFIER, newState);
535 
536     scriptExecutionContext()-&gt;postTask([protectedThis = makeRef(*this), newState](ScriptExecutionContext&amp;) {
537         if (protectedThis-&gt;isClosed() || protectedThis-&gt;m_iceConnectionState == newState)
538             return;
539 
540         protectedThis-&gt;m_iceConnectionState = newState;
<span class="line-modified">541         protectedThis-&gt;dispatchEvent(Event::create(eventNames().iceconnectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
542         protectedThis-&gt;updateConnectionState();
543     });
544 }
545 
546 void RTCPeerConnection::updateConnectionState()
547 {
548     RTCPeerConnectionState state;
549 
550     if (m_iceConnectionState == RTCIceConnectionState::Closed)
551         state = RTCPeerConnectionState::Closed;
552     else if (m_iceConnectionState == RTCIceConnectionState::Disconnected)
553         state = RTCPeerConnectionState::Disconnected;
554     else if (m_iceConnectionState == RTCIceConnectionState::Failed)
555         state = RTCPeerConnectionState::Failed;
556     else if (m_iceConnectionState == RTCIceConnectionState::New &amp;&amp; m_iceGatheringState == RTCIceGatheringState::New)
557         state = RTCPeerConnectionState::New;
558     else if (m_iceConnectionState == RTCIceConnectionState::Checking || m_iceGatheringState == RTCIceGatheringState::Gathering)
559         state = RTCPeerConnectionState::Connecting;
560     else if ((m_iceConnectionState == RTCIceConnectionState::Completed || m_iceConnectionState == RTCIceConnectionState::Connected) &amp;&amp; m_iceGatheringState == RTCIceGatheringState::Complete)
561         state = RTCPeerConnectionState::Connected;
562     else
563         return;
564 
565     if (state == m_connectionState)
566         return;
567 
568     INFO_LOG(LOGIDENTIFIER, &quot;state changed from: &quot; , m_connectionState, &quot; to &quot;, state);
569 
570     m_connectionState = state;
<span class="line-modified">571     dispatchEvent(Event::create(eventNames().connectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
572 }
573 
574 void RTCPeerConnection::scheduleNegotiationNeededEvent()
575 {
576     scriptExecutionContext()-&gt;postTask([protectedThis = makeRef(*this)](ScriptExecutionContext&amp;) {
577         if (protectedThis-&gt;isClosed())
578             return;
579         if (!protectedThis-&gt;m_backend-&gt;isNegotiationNeeded())
580             return;
581         protectedThis-&gt;m_backend-&gt;clearNegotiationNeededState();
<span class="line-modified">582         protectedThis-&gt;dispatchEvent(Event::create(eventNames().negotiationneededEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
583     });
584 }
585 
<span class="line-modified">586 void RTCPeerConnection::fireEvent(Event&amp; event)</span>









587 {
<span class="line-modified">588     dispatchEvent(event);</span>


589 }
590 
591 void RTCPeerConnection::dispatchEvent(Event&amp; event)
592 {
593     INFO_LOG(LOGIDENTIFIER, &quot;dispatching &#39;&quot;, event.type(), &quot;&#39;&quot;);
594     EventTarget::dispatchEvent(event);
595 }
596 
<span class="line-modified">597 static inline ExceptionOr&lt;PeerConnectionBackend::CertificateInformation&gt; certificateTypeFromAlgorithmIdentifier(JSC::ExecState&amp; state, RTCPeerConnection::AlgorithmIdentifier&amp;&amp; algorithmIdentifier)</span>
598 {
599     if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier))
600         return Exception { NotSupportedError, &quot;Algorithm is not supported&quot;_s };
601 
602     auto&amp; value = WTF::get&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;(algorithmIdentifier);
603 
<span class="line-modified">604     JSC::VM&amp; vm = state.vm();</span>
605     auto scope = DECLARE_CATCH_SCOPE(vm);
606 
<span class="line-modified">607     auto parameters = convertDictionary&lt;RTCPeerConnection::CertificateParameters&gt;(state, value.get());</span>
608     if (UNLIKELY(scope.exception())) {
609         scope.clearException();
610         return Exception { TypeError, &quot;Unable to read certificate parameters&quot;_s };
611     }
612 
613     if (parameters.expires &amp;&amp; *parameters.expires &lt; 0)
614         return Exception { TypeError, &quot;Expire value is invalid&quot;_s };
615 
616     if (parameters.name == &quot;RSASSA-PKCS1-v1_5&quot;_s) {
617         if (!parameters.hash.isNull() &amp;&amp; parameters.hash != &quot;SHA-256&quot;_s)
618             return Exception { NotSupportedError, &quot;Only SHA-256 is supported for RSASSA-PKCS1-v1_5&quot;_s };
619 
620         auto result = PeerConnectionBackend::CertificateInformation::RSASSA_PKCS1_v1_5();
621         if (parameters.modulusLength &amp;&amp; parameters.publicExponent) {
622             int publicExponent = 0;
623             int value = 1;
624             for (unsigned counter = 0; counter &lt; parameters.publicExponent-&gt;byteLength(); ++counter) {
625                 publicExponent += parameters.publicExponent-&gt;data()[counter] * value;
626                 value &lt;&lt;= 8;
627             }
628 
629             result.rsaParameters = PeerConnectionBackend::CertificateInformation::RSA { *parameters.modulusLength, publicExponent };
630         }
631         result.expires = parameters.expires;
632         return result;
633     }
634     if (parameters.name == &quot;ECDSA&quot;_s &amp;&amp; parameters.namedCurve == &quot;P-256&quot;_s) {
635         auto result = PeerConnectionBackend::CertificateInformation::ECDSA_P256();
636         result.expires = parameters.expires;
637         return result;
638     }
639 
640     return Exception { NotSupportedError, &quot;Algorithm is not supported&quot;_s };
641 }
642 
<span class="line-modified">643 void RTCPeerConnection::generateCertificate(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, DOMPromiseDeferred&lt;IDLInterface&lt;RTCCertificate&gt;&gt;&amp;&amp; promise)</span>
644 {
<span class="line-modified">645     auto parameters = certificateTypeFromAlgorithmIdentifier(state, WTFMove(algorithmIdentifier));</span>
646     if (parameters.hasException()) {
647         promise.reject(parameters.releaseException());
648         return;
649     }
<span class="line-modified">650     auto&amp; document = downcast&lt;Document&gt;(*JSC::jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())-&gt;scriptExecutionContext());</span>
651     PeerConnectionBackend::generateCertificate(document, parameters.returnValue(), WTFMove(promise));
652 }
653 
654 Vector&lt;std::reference_wrapper&lt;RTCRtpSender&gt;&gt; RTCPeerConnection::getSenders() const
655 {
656     m_backend-&gt;collectTransceivers();
657     return m_transceiverSet-&gt;senders();
658 }
659 
660 Vector&lt;std::reference_wrapper&lt;RTCRtpReceiver&gt;&gt; RTCPeerConnection::getReceivers() const
661 {
662     m_backend-&gt;collectTransceivers();
663     return m_transceiverSet-&gt;receivers();
664 }
665 
666 const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; RTCPeerConnection::getTransceivers() const
667 {
668     m_backend-&gt;collectTransceivers();
669     return m_transceiverSet-&gt;list();
670 }
671 





672 #if !RELEASE_LOG_DISABLED
673 WTFLogChannel&amp; RTCPeerConnection::logChannel() const
674 {
675     return LogWebRTC;
676 }
677 #endif
678 
679 } // namespace WebCore
680 
681 #endif // ENABLE(WEB_RTC)
</pre>
</td>
<td>
<hr />
<pre>
 23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 #include &quot;config.h&quot;
 35 #include &quot;RTCPeerConnection.h&quot;
 36 
 37 #if ENABLE(WEB_RTC)
 38 
 39 #include &quot;Document.h&quot;
 40 #include &quot;Event.h&quot;
 41 #include &quot;EventNames.h&quot;
 42 #include &quot;Frame.h&quot;
<span class="line-added"> 43 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 44 #include &quot;JSRTCPeerConnection.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;MediaEndpointConfiguration.h&quot;
 47 #include &quot;MediaStream.h&quot;
 48 #include &quot;MediaStreamTrack.h&quot;
 49 #include &quot;Page.h&quot;
 50 #include &quot;RTCConfiguration.h&quot;
 51 #include &quot;RTCController.h&quot;
 52 #include &quot;RTCDataChannel.h&quot;
 53 #include &quot;RTCIceCandidate.h&quot;
 54 #include &quot;RTCPeerConnectionIceEvent.h&quot;
 55 #include &quot;RTCSessionDescription.h&quot;
 56 #include &quot;Settings.h&quot;
 57 #include &lt;wtf/CryptographicallyRandomNumber.h&gt;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 #include &lt;wtf/MainThread.h&gt;
 60 #include &lt;wtf/UUID.h&gt;
 61 #include &lt;wtf/text/Base64.h&gt;
 62 
 63 namespace WebCore {
 64 
 65 using namespace PeerConnection;
 66 
 67 WTF_MAKE_ISO_ALLOCATED_IMPL(RTCPeerConnection);
 68 
 69 Ref&lt;RTCPeerConnection&gt; RTCPeerConnection::create(ScriptExecutionContext&amp; context)
 70 {
<span class="line-modified"> 71     auto&amp; document = downcast&lt;Document&gt;(context);</span>
<span class="line-added"> 72     auto peerConnection = adoptRef(*new RTCPeerConnection(document));</span>
 73     peerConnection-&gt;suspendIfNeeded();


 74     if (!peerConnection-&gt;isClosed()) {
<span class="line-modified"> 75         if (auto* page = document.page()) {</span>

 76             peerConnection-&gt;registerToController(page-&gt;rtcController());
<span class="line-modified"> 77             page-&gt;libWebRTCProvider().setEnableLogging(!page-&gt;sessionID().isEphemeral());</span>
 78         }
 79     }
 80     return peerConnection;
 81 }
 82 
<span class="line-modified"> 83 RTCPeerConnection::RTCPeerConnection(Document&amp; document)</span>
<span class="line-modified"> 84     : ActiveDOMObject(document)</span>
 85 #if !RELEASE_LOG_DISABLED
<span class="line-modified"> 86     , m_logger(document.logger())</span>
 87     , m_logIdentifier(reinterpret_cast&lt;const void*&gt;(cryptographicallyRandomNumber()))
 88 #endif
 89     , m_backend(PeerConnectionBackend::create(*this))
 90 {
 91     ALWAYS_LOG(LOGIDENTIFIER);
 92 
 93 #if !RELEASE_LOG_DISABLED
<span class="line-modified"> 94     auto* page = document.page();</span>
 95     if (page &amp;&amp; !page-&gt;settings().webRTCEncryptionEnabled())
 96         ALWAYS_LOG(LOGIDENTIFIER, &quot;encryption is disabled&quot;);
 97 #endif
 98 
 99     if (!m_backend)
100         m_connectionState = RTCPeerConnectionState::Closed;
101 }
102 
103 RTCPeerConnection::~RTCPeerConnection()
104 {
105     ALWAYS_LOG(LOGIDENTIFIER);
106     unregisterFromController();
107     stop();
108 }
109 
110 ExceptionOr&lt;void&gt; RTCPeerConnection::initializeWith(Document&amp; document, RTCConfiguration&amp;&amp; configuration)
111 {
112     if (!document.frame())
113         return Exception { NotSupportedError };
114 
</pre>
<hr />
<pre>
178             return Exception { InvalidStateError };
179 
180         return m_backend-&gt;addTransceiver(kind, init);
181     }
182 
183     if (isClosed())
184         return Exception { InvalidStateError };
185 
186     auto track = WTF::get&lt;RefPtr&lt;MediaStreamTrack&gt;&gt;(withTrack).releaseNonNull();
187     return m_backend-&gt;addTransceiver(WTFMove(track), init);
188 }
189 
190 void RTCPeerConnection::queuedCreateOffer(RTCOfferOptions&amp;&amp; options, SessionDescriptionPromise&amp;&amp; promise)
191 {
192     ALWAYS_LOG(LOGIDENTIFIER);
193     if (isClosed()) {
194         promise.reject(InvalidStateError);
195         return;
196     }
197 
<span class="line-added">198     addPendingPromise(promise);</span>
199     m_backend-&gt;createOffer(WTFMove(options), WTFMove(promise));
200 }
201 
202 void RTCPeerConnection::queuedCreateAnswer(RTCAnswerOptions&amp;&amp; options, SessionDescriptionPromise&amp;&amp; promise)
203 {
204     ALWAYS_LOG(LOGIDENTIFIER);
205     if (isClosed()) {
206         promise.reject(InvalidStateError);
207         return;
208     }
209 
<span class="line-added">210     addPendingPromise(promise);</span>
211     m_backend-&gt;createAnswer(WTFMove(options), WTFMove(promise));
212 }
213 
214 void RTCPeerConnection::queuedSetLocalDescription(RTCSessionDescription&amp; description, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
215 {
216     ALWAYS_LOG(LOGIDENTIFIER, &quot;Setting local description to:\n&quot;, description.sdp());
217     if (isClosed()) {
218         promise.reject(InvalidStateError);
219         return;
220     }
221 
<span class="line-added">222     addPendingPromise(promise);</span>
223     m_backend-&gt;setLocalDescription(description, WTFMove(promise));
224 }
225 
226 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::localDescription() const
227 {
228     return m_backend-&gt;localDescription();
229 }
230 
231 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::currentLocalDescription() const
232 {
233     return m_backend-&gt;currentLocalDescription();
234 }
235 
236 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::pendingLocalDescription() const
237 {
238     return m_backend-&gt;pendingLocalDescription();
239 }
240 
241 void RTCPeerConnection::queuedSetRemoteDescription(RTCSessionDescription&amp; description, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
242 {
243     ALWAYS_LOG(LOGIDENTIFIER, &quot;Setting remote description to:\n&quot;, description.sdp());
244 
245     if (isClosed()) {
246         promise.reject(InvalidStateError);
247         return;
248     }
<span class="line-added">249     addPendingPromise(promise);</span>
250     m_backend-&gt;setRemoteDescription(description, WTFMove(promise));
251 }
252 
253 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::remoteDescription() const
254 {
255     return m_backend-&gt;remoteDescription();
256 }
257 
258 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::currentRemoteDescription() const
259 {
260     return m_backend-&gt;currentRemoteDescription();
261 }
262 
263 RefPtr&lt;RTCSessionDescription&gt; RTCPeerConnection::pendingRemoteDescription() const
264 {
265     return m_backend-&gt;pendingRemoteDescription();
266 }
267 
268 void RTCPeerConnection::queuedAddIceCandidate(RTCIceCandidate* rtcCandidate, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
269 {
270     ALWAYS_LOG(LOGIDENTIFIER, &quot;Received ice candidate:\n&quot;, rtcCandidate ? rtcCandidate-&gt;candidate() : &quot;null&quot;);
271 
272     if (isClosed()) {
273         promise.reject(InvalidStateError);
274         return;
275     }
276 
<span class="line-added">277     addPendingPromise(promise);</span>
278     m_backend-&gt;addIceCandidate(rtcCandidate, WTFMove(promise));
279 }
280 
281 // Implementation of https://w3c.github.io/webrtc-pc/#set-pc-configuration
282 static inline ExceptionOr&lt;Vector&lt;MediaEndpointConfiguration::IceServerInfo&gt;&gt; iceServersFromConfiguration(RTCConfiguration&amp; newConfiguration, const RTCConfiguration* existingConfiguration, bool isLocalDescriptionSet)
283 {
284     if (existingConfiguration &amp;&amp; newConfiguration.bundlePolicy != existingConfiguration-&gt;bundlePolicy)
285         return Exception { InvalidModificationError, &quot;BundlePolicy does not match existing policy&quot; };
286 
287     if (existingConfiguration &amp;&amp; newConfiguration.rtcpMuxPolicy != existingConfiguration-&gt;rtcpMuxPolicy)
288         return Exception { InvalidModificationError, &quot;RTCPMuxPolicy does not match existing policy&quot; };
289 
290     if (existingConfiguration &amp;&amp; newConfiguration.iceCandidatePoolSize != existingConfiguration-&gt;iceCandidatePoolSize &amp;&amp; isLocalDescriptionSet)
291         return Exception { InvalidModificationError, &quot;IceTransportPolicy pool size does not match existing pool size&quot; };
292 
293     Vector&lt;MediaEndpointConfiguration::IceServerInfo&gt; servers;
294     if (newConfiguration.iceServers) {
295         servers.reserveInitialCapacity(newConfiguration.iceServers-&gt;size());
296         for (auto&amp; server : newConfiguration.iceServers.value()) {
297             Vector&lt;URL&gt; serverURLs;
</pre>
<hr />
<pre>
305             });
306             for (auto&amp; serverURL : serverURLs) {
307                 if (serverURL.isNull())
308                     return Exception { TypeError, &quot;Bad ICE server URL&quot; };
309                 if (serverURL.protocolIs(&quot;turn&quot;) || serverURL.protocolIs(&quot;turns&quot;)) {
310                     if (server.credential.isNull() || server.username.isNull())
311                         return Exception { InvalidAccessError, &quot;TURN/TURNS server requires both username and credential&quot; };
312                 } else if (!serverURL.protocolIs(&quot;stun&quot;))
313                     return Exception { NotSupportedError, &quot;ICE server protocol not supported&quot; };
314             }
315             if (serverURLs.size())
316                 servers.uncheckedAppend({ WTFMove(serverURLs), server.credential, server.username });
317         }
318     }
319     return servers;
320 }
321 
322 ExceptionOr&lt;Vector&lt;MediaEndpointConfiguration::CertificatePEM&gt;&gt; RTCPeerConnection::certificatesFromConfiguration(const RTCConfiguration&amp; configuration)
323 {
324     auto currentMilliSeconds = WallTime::now().secondsSinceEpoch().milliseconds();
<span class="line-modified">325     auto&amp; origin = document()-&gt;securityOrigin();</span>
326 
327     Vector&lt;MediaEndpointConfiguration::CertificatePEM&gt; certificates;
328     certificates.reserveInitialCapacity(configuration.certificates.size());
329     for (auto&amp; certificate : configuration.certificates) {
330         if (!origin.isSameOriginAs(certificate-&gt;origin()))
331             return Exception { InvalidAccessError, &quot;Certificate does not have a valid origin&quot; };
332 
333         if (currentMilliSeconds &gt; certificate-&gt;expires())
334             return Exception { InvalidAccessError, &quot;Certificate has expired&quot;_s };
335 
336         certificates.uncheckedAppend(MediaEndpointConfiguration::CertificatePEM { certificate-&gt;pemCertificate(), certificate-&gt;pemPrivateKey(), });
337     }
338     return certificates;
339 }
340 
341 ExceptionOr&lt;void&gt; RTCPeerConnection::initializeConfiguration(RTCConfiguration&amp;&amp; configuration)
342 {
343     INFO_LOG(LOGIDENTIFIER);
344 
345     auto servers = iceServersFromConfiguration(configuration, nullptr, false);
</pre>
<hr />
<pre>
385         return Exception { InvalidAccessError, &quot;Bad Configuration Parameters&quot; };
386 
387     m_configuration = WTFMove(configuration);
388     return { };
389 }
390 
391 void RTCPeerConnection::getStats(MediaStreamTrack* selector, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
392 {
393     if (selector) {
394         for (auto&amp; transceiver : m_transceiverSet-&gt;list()) {
395             if (transceiver-&gt;sender().track() == selector) {
396                 m_backend-&gt;getStats(transceiver-&gt;sender(), WTFMove(promise));
397                 return;
398             }
399             if (&amp;transceiver-&gt;receiver().track() == selector) {
400                 m_backend-&gt;getStats(transceiver-&gt;receiver(), WTFMove(promise));
401                 return;
402             }
403         }
404     }
<span class="line-added">405     addPendingPromise(promise.get());</span>
406     m_backend-&gt;getStats(WTFMove(promise));
407 }
408 
<span class="line-modified">409 ExceptionOr&lt;Ref&lt;RTCDataChannel&gt;&gt; RTCPeerConnection::createDataChannel(String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
410 {
411     ALWAYS_LOG(LOGIDENTIFIER);
412 
413     if (isClosed())
414         return Exception { InvalidStateError };
415 
416     if (options.negotiated &amp;&amp; !options.negotiated.value() &amp;&amp; (label.length() &gt; 65535 || options.protocol.length() &gt; 65535))
417         return Exception { TypeError };
418 
419     if (options.maxPacketLifeTime &amp;&amp; options.maxRetransmits)
420         return Exception { TypeError };
421 
422     if (options.id &amp;&amp; options.id.value() &gt; 65534)
423         return Exception { TypeError };
424 
425     auto channelHandler = m_backend-&gt;createDataChannelHandler(label, options);
426     if (!channelHandler)
427         return Exception { NotSupportedError };
428 
<span class="line-modified">429     return RTCDataChannel::create(*document(), WTFMove(channelHandler), WTFMove(label), WTFMove(options));</span>
430 }
431 
432 bool RTCPeerConnection::doClose()
433 {
434     if (isClosed())
435         return false;
436 
<span class="line-added">437     m_shouldDelayTasks = false;</span>
438     m_connectionState = RTCPeerConnectionState::Closed;
439     m_iceConnectionState = RTCIceConnectionState::Closed;
440     m_signalingState = RTCSignalingState::Closed;
441 
442     for (auto&amp; transceiver : m_transceiverSet-&gt;list()) {
443         transceiver-&gt;stop();
444         transceiver-&gt;sender().stop();
445         transceiver-&gt;receiver().stop();
446     }
447 
448     return true;
449 }
450 
451 void RTCPeerConnection::close()
452 {
453     if (!doClose())
454         return;
455 
456     updateConnectionState();
457     ASSERT(isClosed());
<span class="line-modified">458     m_backend-&gt;close();</span>
459 }
460 
461 void RTCPeerConnection::emulatePlatformEvent(const String&amp; action)
462 {
463     m_backend-&gt;emulatePlatformEvent(action);
464 }
465 
466 void RTCPeerConnection::stop()
467 {
<span class="line-modified">468     doClose();</span>


469     doStop();
470 }
471 
472 void RTCPeerConnection::doStop()
473 {
474     if (m_isStopped)
475         return;
476 
477     m_isStopped = true;
<span class="line-modified">478     if (m_backend)</span>
<span class="line-modified">479         m_backend-&gt;stop();</span>

480 }
481 
482 void RTCPeerConnection::registerToController(RTCController&amp; controller)
483 {
484     m_controller = &amp;controller;
485     m_controller-&gt;add(*this);
486 }
487 
488 void RTCPeerConnection::unregisterFromController()
489 {
490     if (m_controller)
491         m_controller-&gt;remove(*this);
492 }
493 
494 const char* RTCPeerConnection::activeDOMObjectName() const
495 {
496     return &quot;RTCPeerConnection&quot;;
497 }
498 
<span class="line-modified">499 void RTCPeerConnection::suspend(ReasonForSuspension reason)</span>
500 {
<span class="line-modified">501     if (reason != ReasonForSuspension::BackForwardCache)</span>
<span class="line-added">502         return;</span>
<span class="line-added">503 </span>
<span class="line-added">504     m_shouldDelayTasks = true;</span>
<span class="line-added">505     m_backend-&gt;suspend();</span>
<span class="line-added">506 }</span>
<span class="line-added">507 </span>
<span class="line-added">508 void RTCPeerConnection::resume()</span>
<span class="line-added">509 {</span>
<span class="line-added">510     if (!m_shouldDelayTasks)</span>
<span class="line-added">511         return;</span>
<span class="line-added">512 </span>
<span class="line-added">513     m_shouldDelayTasks = false;</span>
<span class="line-added">514     m_backend-&gt;resume();</span>
<span class="line-added">515 </span>
<span class="line-added">516     scriptExecutionContext()-&gt;postTask([this, protectedThis = makeRef(*this)](auto&amp;) {</span>
<span class="line-added">517         if (m_isStopped || m_shouldDelayTasks)</span>
<span class="line-added">518             return;</span>
<span class="line-added">519 </span>
<span class="line-added">520         auto tasks = WTFMove(m_pendingTasks);</span>
<span class="line-added">521         for (auto&amp; task : tasks)</span>
<span class="line-added">522             task();</span>
<span class="line-added">523     });</span>
524 }
525 
526 bool RTCPeerConnection::hasPendingActivity() const
527 {
<span class="line-modified">528     if (m_isStopped)</span>
<span class="line-added">529         return false;</span>
<span class="line-added">530 </span>
<span class="line-added">531     // This returns true if we have pending promises to be resolved.</span>
<span class="line-added">532     if (ActiveDOMObject::hasPendingActivity())</span>
<span class="line-added">533         return true;</span>
<span class="line-added">534 </span>
<span class="line-added">535     // As long as the connection is not stopped and it has event listeners, it may dispatch events.</span>
<span class="line-added">536     return hasEventListeners();</span>
537 }
538 
539 void RTCPeerConnection::addTransceiver(Ref&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver)
540 {
541     INFO_LOG(LOGIDENTIFIER);
542     m_transceiverSet-&gt;append(WTFMove(transceiver));
543 }
544 
545 void RTCPeerConnection::setSignalingState(RTCSignalingState newState)
546 {
547     ALWAYS_LOG(LOGIDENTIFIER, newState);
548     m_signalingState = newState;
549 }
550 
551 void RTCPeerConnection::updateIceGatheringState(RTCIceGatheringState newState)
552 {
553     ALWAYS_LOG(LOGIDENTIFIER, newState);
554 
555     scriptExecutionContext()-&gt;postTask([protectedThis = makeRef(*this), newState](ScriptExecutionContext&amp;) {
556         if (protectedThis-&gt;isClosed() || protectedThis-&gt;m_iceGatheringState == newState)
557             return;
558 
559         protectedThis-&gt;m_iceGatheringState = newState;
<span class="line-modified">560         protectedThis-&gt;dispatchEventWhenFeasible(Event::create(eventNames().icegatheringstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
561         protectedThis-&gt;updateConnectionState();
562     });
563 }
564 
565 void RTCPeerConnection::updateIceConnectionState(RTCIceConnectionState newState)
566 {
567     ALWAYS_LOG(LOGIDENTIFIER, newState);
568 
569     scriptExecutionContext()-&gt;postTask([protectedThis = makeRef(*this), newState](ScriptExecutionContext&amp;) {
570         if (protectedThis-&gt;isClosed() || protectedThis-&gt;m_iceConnectionState == newState)
571             return;
572 
573         protectedThis-&gt;m_iceConnectionState = newState;
<span class="line-modified">574         protectedThis-&gt;dispatchEventWhenFeasible(Event::create(eventNames().iceconnectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
575         protectedThis-&gt;updateConnectionState();
576     });
577 }
578 
579 void RTCPeerConnection::updateConnectionState()
580 {
581     RTCPeerConnectionState state;
582 
583     if (m_iceConnectionState == RTCIceConnectionState::Closed)
584         state = RTCPeerConnectionState::Closed;
585     else if (m_iceConnectionState == RTCIceConnectionState::Disconnected)
586         state = RTCPeerConnectionState::Disconnected;
587     else if (m_iceConnectionState == RTCIceConnectionState::Failed)
588         state = RTCPeerConnectionState::Failed;
589     else if (m_iceConnectionState == RTCIceConnectionState::New &amp;&amp; m_iceGatheringState == RTCIceGatheringState::New)
590         state = RTCPeerConnectionState::New;
591     else if (m_iceConnectionState == RTCIceConnectionState::Checking || m_iceGatheringState == RTCIceGatheringState::Gathering)
592         state = RTCPeerConnectionState::Connecting;
593     else if ((m_iceConnectionState == RTCIceConnectionState::Completed || m_iceConnectionState == RTCIceConnectionState::Connected) &amp;&amp; m_iceGatheringState == RTCIceGatheringState::Complete)
594         state = RTCPeerConnectionState::Connected;
595     else
596         return;
597 
598     if (state == m_connectionState)
599         return;
600 
601     INFO_LOG(LOGIDENTIFIER, &quot;state changed from: &quot; , m_connectionState, &quot; to &quot;, state);
602 
603     m_connectionState = state;
<span class="line-modified">604     dispatchEventWhenFeasible(Event::create(eventNames().connectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
605 }
606 
607 void RTCPeerConnection::scheduleNegotiationNeededEvent()
608 {
609     scriptExecutionContext()-&gt;postTask([protectedThis = makeRef(*this)](ScriptExecutionContext&amp;) {
610         if (protectedThis-&gt;isClosed())
611             return;
612         if (!protectedThis-&gt;m_backend-&gt;isNegotiationNeeded())
613             return;
614         protectedThis-&gt;m_backend-&gt;clearNegotiationNeededState();
<span class="line-modified">615         protectedThis-&gt;dispatchEventWhenFeasible(Event::create(eventNames().negotiationneededEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
616     });
617 }
618 
<span class="line-modified">619 void RTCPeerConnection::doTask(Function&lt;void()&gt;&amp;&amp; task)</span>
<span class="line-added">620 {</span>
<span class="line-added">621     if (m_shouldDelayTasks || !m_pendingTasks.isEmpty()) {</span>
<span class="line-added">622         m_pendingTasks.append(WTFMove(task));</span>
<span class="line-added">623         return;</span>
<span class="line-added">624     }</span>
<span class="line-added">625     task();</span>
<span class="line-added">626 }</span>
<span class="line-added">627 </span>
<span class="line-added">628 void RTCPeerConnection::dispatchEventWhenFeasible(Ref&lt;Event&gt;&amp;&amp; event)</span>
629 {
<span class="line-modified">630     doTask([this, event = WTFMove(event)] {</span>
<span class="line-added">631         dispatchEvent(event);</span>
<span class="line-added">632     });</span>
633 }
634 
635 void RTCPeerConnection::dispatchEvent(Event&amp; event)
636 {
637     INFO_LOG(LOGIDENTIFIER, &quot;dispatching &#39;&quot;, event.type(), &quot;&#39;&quot;);
638     EventTarget::dispatchEvent(event);
639 }
640 
<span class="line-modified">641 static inline ExceptionOr&lt;PeerConnectionBackend::CertificateInformation&gt; certificateTypeFromAlgorithmIdentifier(JSC::JSGlobalObject&amp; lexicalGlobalObject, RTCPeerConnection::AlgorithmIdentifier&amp;&amp; algorithmIdentifier)</span>
642 {
643     if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier))
644         return Exception { NotSupportedError, &quot;Algorithm is not supported&quot;_s };
645 
646     auto&amp; value = WTF::get&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;(algorithmIdentifier);
647 
<span class="line-modified">648     JSC::VM&amp; vm = lexicalGlobalObject.vm();</span>
649     auto scope = DECLARE_CATCH_SCOPE(vm);
650 
<span class="line-modified">651     auto parameters = convertDictionary&lt;RTCPeerConnection::CertificateParameters&gt;(lexicalGlobalObject, value.get());</span>
652     if (UNLIKELY(scope.exception())) {
653         scope.clearException();
654         return Exception { TypeError, &quot;Unable to read certificate parameters&quot;_s };
655     }
656 
657     if (parameters.expires &amp;&amp; *parameters.expires &lt; 0)
658         return Exception { TypeError, &quot;Expire value is invalid&quot;_s };
659 
660     if (parameters.name == &quot;RSASSA-PKCS1-v1_5&quot;_s) {
661         if (!parameters.hash.isNull() &amp;&amp; parameters.hash != &quot;SHA-256&quot;_s)
662             return Exception { NotSupportedError, &quot;Only SHA-256 is supported for RSASSA-PKCS1-v1_5&quot;_s };
663 
664         auto result = PeerConnectionBackend::CertificateInformation::RSASSA_PKCS1_v1_5();
665         if (parameters.modulusLength &amp;&amp; parameters.publicExponent) {
666             int publicExponent = 0;
667             int value = 1;
668             for (unsigned counter = 0; counter &lt; parameters.publicExponent-&gt;byteLength(); ++counter) {
669                 publicExponent += parameters.publicExponent-&gt;data()[counter] * value;
670                 value &lt;&lt;= 8;
671             }
672 
673             result.rsaParameters = PeerConnectionBackend::CertificateInformation::RSA { *parameters.modulusLength, publicExponent };
674         }
675         result.expires = parameters.expires;
676         return result;
677     }
678     if (parameters.name == &quot;ECDSA&quot;_s &amp;&amp; parameters.namedCurve == &quot;P-256&quot;_s) {
679         auto result = PeerConnectionBackend::CertificateInformation::ECDSA_P256();
680         result.expires = parameters.expires;
681         return result;
682     }
683 
684     return Exception { NotSupportedError, &quot;Algorithm is not supported&quot;_s };
685 }
686 
<span class="line-modified">687 void RTCPeerConnection::generateCertificate(JSC::JSGlobalObject&amp; lexicalGlobalObject, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, DOMPromiseDeferred&lt;IDLInterface&lt;RTCCertificate&gt;&gt;&amp;&amp; promise)</span>
688 {
<span class="line-modified">689     auto parameters = certificateTypeFromAlgorithmIdentifier(lexicalGlobalObject, WTFMove(algorithmIdentifier));</span>
690     if (parameters.hasException()) {
691         promise.reject(parameters.releaseException());
692         return;
693     }
<span class="line-modified">694     auto&amp; document = downcast&lt;Document&gt;(*JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)-&gt;scriptExecutionContext());</span>
695     PeerConnectionBackend::generateCertificate(document, parameters.returnValue(), WTFMove(promise));
696 }
697 
698 Vector&lt;std::reference_wrapper&lt;RTCRtpSender&gt;&gt; RTCPeerConnection::getSenders() const
699 {
700     m_backend-&gt;collectTransceivers();
701     return m_transceiverSet-&gt;senders();
702 }
703 
704 Vector&lt;std::reference_wrapper&lt;RTCRtpReceiver&gt;&gt; RTCPeerConnection::getReceivers() const
705 {
706     m_backend-&gt;collectTransceivers();
707     return m_transceiverSet-&gt;receivers();
708 }
709 
710 const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; RTCPeerConnection::getTransceivers() const
711 {
712     m_backend-&gt;collectTransceivers();
713     return m_transceiverSet-&gt;list();
714 }
715 
<span class="line-added">716 Document* RTCPeerConnection::document()</span>
<span class="line-added">717 {</span>
<span class="line-added">718     return downcast&lt;Document&gt;(scriptExecutionContext());</span>
<span class="line-added">719 }</span>
<span class="line-added">720 </span>
721 #if !RELEASE_LOG_DISABLED
722 WTFLogChannel&amp; RTCPeerConnection::logChannel() const
723 {
724     return LogWebRTC;
725 }
726 #endif
727 
728 } // namespace WebCore
729 
730 #endif // ENABLE(WEB_RTC)
</pre>
</td>
</tr>
</table>
<center><a href="RTCDataChannelEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RTCPeerConnection.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
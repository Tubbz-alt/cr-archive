<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGLengthContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005, 2006 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  6  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;SVGLengthContext.h&quot;
 26 
 27 #include &quot;CSSHelper.h&quot;
 28 #include &quot;FontMetrics.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;LengthFunctions.h&quot;
 31 #include &quot;RenderSVGRoot.h&quot;
 32 #include &quot;RenderSVGViewportContainer.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &quot;SVGSVGElement.h&quot;
 35 #include &lt;wtf/MathExtras.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 SVGLengthContext::SVGLengthContext(const SVGElement* context)
 40     : m_context(context)
 41 {
 42 }
 43 
 44 SVGLengthContext::SVGLengthContext(const SVGElement* context, const FloatRect&amp; viewport)
 45     : m_context(context)
 46     , m_overriddenViewport(viewport)
 47 {
 48 }
 49 
 50 FloatRect SVGLengthContext::resolveRectangle(const SVGElement* context, SVGUnitTypes::SVGUnitType type, const FloatRect&amp; viewport, const SVGLengthValue&amp; x, const SVGLengthValue&amp; y, const SVGLengthValue&amp; width, const SVGLengthValue&amp; height)
 51 {
 52     ASSERT(type != SVGUnitTypes::SVG_UNIT_TYPE_UNKNOWN);
 53     if (type == SVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE) {
 54         SVGLengthContext lengthContext(context);
 55         return FloatRect(x.value(lengthContext), y.value(lengthContext), width.value(lengthContext), height.value(lengthContext));
 56     }
 57 
 58     SVGLengthContext lengthContext(context, viewport);
 59     return FloatRect(x.value(lengthContext) + viewport.x(),
 60                      y.value(lengthContext) + viewport.y(),
 61                      width.value(lengthContext),
 62                      height.value(lengthContext));
 63 }
 64 
 65 FloatPoint SVGLengthContext::resolvePoint(const SVGElement* context, SVGUnitTypes::SVGUnitType type, const SVGLengthValue&amp; x, const SVGLengthValue&amp; y)
 66 {
 67     ASSERT(type != SVGUnitTypes::SVG_UNIT_TYPE_UNKNOWN);
 68     if (type == SVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE) {
 69         SVGLengthContext lengthContext(context);
 70         return FloatPoint(x.value(lengthContext), y.value(lengthContext));
 71     }
 72 
 73     // FIXME: valueAsPercentage() won&#39;t be correct for eg. cm units. They need to be resolved in user space and then be considered in objectBoundingBox space.
 74     return FloatPoint(x.valueAsPercentage(), y.valueAsPercentage());
 75 }
 76 
 77 float SVGLengthContext::resolveLength(const SVGElement* context, SVGUnitTypes::SVGUnitType type, const SVGLengthValue&amp; x)
 78 {
 79     ASSERT(type != SVGUnitTypes::SVG_UNIT_TYPE_UNKNOWN);
 80     if (type == SVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE) {
 81         SVGLengthContext lengthContext(context);
 82         return x.value(lengthContext);
 83     }
 84 
 85     // FIXME: valueAsPercentage() won&#39;t be correct for eg. cm units. They need to be resolved in user space and then be considered in objectBoundingBox space.
 86     return x.valueAsPercentage();
 87 }
 88 
 89 float SVGLengthContext::valueForLength(const Length&amp; length, SVGLengthMode lengthMode)
 90 {
 91     if (length.isPercent()) {
 92         auto result = convertValueFromPercentageToUserUnits(length.value() / 100, lengthMode);
 93         if (result.hasException())
 94             return 0;
 95         return result.releaseReturnValue();
 96     }
 97     if (length.isAuto() || !length.isSpecified())
 98         return 0;
 99 
100     FloatSize viewportSize;
101     determineViewport(viewportSize);
102 
103     switch (lengthMode) {
104     case SVGLengthMode::Width:
105         return floatValueForLength(length, viewportSize.width());
106     case SVGLengthMode::Height:
107         return floatValueForLength(length, viewportSize.height());
108     case SVGLengthMode::Other:
109         return floatValueForLength(length, viewportSize.diagonalLength() / sqrtOfTwoFloat);
110     };
111     return 0;
112 }
113 
114 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueToUserUnits(float value, SVGLengthType lengthType, SVGLengthMode lengthMode) const
115 {
116     // If the SVGLengthContext carries a custom viewport, force resolving against it.
117     if (!m_overriddenViewport.isEmpty()) {
118         // 100% = 100.0 instead of 1.0 for historical reasons, this could eventually be changed
119         if (lengthType == SVGLengthType::Percentage)
120             value /= 100;
121         return convertValueFromPercentageToUserUnits(value, lengthMode);
122     }
123 
124     switch (lengthType) {
125     case SVGLengthType::Unknown:
126         return Exception { NotSupportedError };
127     case SVGLengthType::Number:
128         return value;
129     case SVGLengthType::Pixels:
130         return value;
131     case SVGLengthType::Percentage:
132         return convertValueFromPercentageToUserUnits(value / 100, lengthMode);
133     case SVGLengthType::Ems:
134         return convertValueFromEMSToUserUnits(value);
135     case SVGLengthType::Exs:
136         return convertValueFromEXSToUserUnits(value);
137     case SVGLengthType::Centimeters:
138         return value * cssPixelsPerInch / 2.54f;
139     case SVGLengthType::Millimeters:
140         return value * cssPixelsPerInch / 25.4f;
141     case SVGLengthType::Inches:
142         return value * cssPixelsPerInch;
143     case SVGLengthType::Points:
144         return value * cssPixelsPerInch / 72;
145     case SVGLengthType::Picas:
146         return value * cssPixelsPerInch / 6;
147     }
148 
149     ASSERT_NOT_REACHED();
150     return 0;
151 }
152 
153 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueFromUserUnits(float value, SVGLengthType lengthType, SVGLengthMode lengthMode) const
154 {
155     switch (lengthType) {
156     case SVGLengthType::Unknown:
157         return Exception { NotSupportedError };
158     case SVGLengthType::Number:
159         return value;
160     case SVGLengthType::Percentage:
161         return convertValueFromUserUnitsToPercentage(value * 100, lengthMode);
162     case SVGLengthType::Ems:
163         return convertValueFromUserUnitsToEMS(value);
164     case SVGLengthType::Exs:
165         return convertValueFromUserUnitsToEXS(value);
166     case SVGLengthType::Pixels:
167         return value;
168     case SVGLengthType::Centimeters:
169         return value * 2.54f / cssPixelsPerInch;
170     case SVGLengthType::Millimeters:
171         return value * 25.4f / cssPixelsPerInch;
172     case SVGLengthType::Inches:
173         return value / cssPixelsPerInch;
174     case SVGLengthType::Points:
175         return value * 72 / cssPixelsPerInch;
176     case SVGLengthType::Picas:
177         return value * 6 / cssPixelsPerInch;
178     }
179 
180     ASSERT_NOT_REACHED();
181     return 0;
182 }
183 
184 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueFromUserUnitsToPercentage(float value, SVGLengthMode lengthMode) const
185 {
186     FloatSize viewportSize;
187     if (!determineViewport(viewportSize))
188         return Exception { NotSupportedError };
189 
190     switch (lengthMode) {
191     case SVGLengthMode::Width:
192         return value / viewportSize.width() * 100;
193     case SVGLengthMode::Height:
194         return value / viewportSize.height() * 100;
195     case SVGLengthMode::Other:
196         return value / (viewportSize.diagonalLength() / sqrtOfTwoFloat) * 100;
197     };
198 
199     ASSERT_NOT_REACHED();
200     return 0;
201 }
202 
203 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueFromPercentageToUserUnits(float value, SVGLengthMode lengthMode) const
204 {
205     FloatSize viewportSize;
206     if (!determineViewport(viewportSize))
207         return Exception { NotSupportedError };
208 
209     switch (lengthMode) {
210     case SVGLengthMode::Width:
211         return value * viewportSize.width();
212     case SVGLengthMode::Height:
213         return value * viewportSize.height();
214     case SVGLengthMode::Other:
215         return value * viewportSize.diagonalLength() / sqrtOfTwoFloat;
216     };
217 
218     ASSERT_NOT_REACHED();
219     return 0;
220 }
221 
222 static inline const RenderStyle* renderStyleForLengthResolving(const SVGElement* context)
223 {
224     if (!context)
225         return nullptr;
226 
227     const ContainerNode* currentContext = context;
228     do {
229         if (currentContext-&gt;renderer())
230             return &amp;currentContext-&gt;renderer()-&gt;style();
231         currentContext = currentContext-&gt;parentNode();
232     } while (currentContext);
233 
234     // There must be at least a RenderSVGRoot renderer, carrying a style.
235     ASSERT_NOT_REACHED();
236     return nullptr;
237 }
238 
239 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueFromUserUnitsToEMS(float value) const
240 {
241     auto* style = renderStyleForLengthResolving(m_context);
242     if (!style)
243         return Exception { NotSupportedError };
244 
245     float fontSize = style-&gt;computedFontPixelSize();
246     if (!fontSize)
247         return Exception { NotSupportedError };
248 
249     return value / fontSize;
250 }
251 
252 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueFromEMSToUserUnits(float value) const
253 {
254     auto* style = renderStyleForLengthResolving(m_context);
255     if (!style)
256         return Exception { NotSupportedError };
257 
258     return value * style-&gt;computedFontPixelSize();
259 }
260 
261 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueFromUserUnitsToEXS(float value) const
262 {
263     auto* style = renderStyleForLengthResolving(m_context);
264     if (!style)
265         return Exception { NotSupportedError };
266 
267     // Use of ceil allows a pixel match to the W3Cs expected output of coords-units-03-b.svg
268     // if this causes problems in real world cases maybe it would be best to remove this
269     float xHeight = std::ceil(style-&gt;fontMetrics().xHeight());
270     if (!xHeight)
271         return Exception { NotSupportedError };
272 
273     return value / xHeight;
274 }
275 
276 ExceptionOr&lt;float&gt; SVGLengthContext::convertValueFromEXSToUserUnits(float value) const
277 {
278     auto* style = renderStyleForLengthResolving(m_context);
279     if (!style)
280         return Exception { NotSupportedError };
281 
282     // Use of ceil allows a pixel match to the W3Cs expected output of coords-units-03-b.svg
283     // if this causes problems in real world cases maybe it would be best to remove this
284     return value * std::ceil(style-&gt;fontMetrics().xHeight());
285 }
286 
287 bool SVGLengthContext::determineViewport(FloatSize&amp; viewportSize) const
288 {
289     if (!m_context)
290         return false;
291 
292     // If an overridden viewport is given, it has precedence.
293     if (!m_overriddenViewport.isEmpty()) {
294         viewportSize = m_overriddenViewport.size();
295         return true;
296     }
297 
298     // Root &lt;svg&gt; element lengths are resolved against the top level viewport.
299     if (m_context-&gt;isOutermostSVGSVGElement()) {
300         viewportSize = downcast&lt;SVGSVGElement&gt;(*m_context).currentViewportSize();
301         return true;
302     }
303 
304     // Take size from nearest viewport element.
305     auto viewportElement = makeRefPtr(m_context-&gt;viewportElement());
306     if (!is&lt;SVGSVGElement&gt;(viewportElement))
307         return false;
308 
309     const SVGSVGElement&amp; svg = downcast&lt;SVGSVGElement&gt;(*viewportElement);
310     viewportSize = svg.currentViewBoxRect().size();
311     if (viewportSize.isEmpty())
312         viewportSize = svg.currentViewportSize();
313 
314     return true;
315 }
316 
317 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPropertyResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLProgram.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLPruneUnreachableStandardLibraryFunctions.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPropertyResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,809 ***</span>
  #include &quot;config.h&quot;
  #include &quot;WHLSLPropertyResolver.h&quot;
  
  #if ENABLE(WEBGPU)
  
<span class="line-modified">! #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-modified">! #include &quot;WHLSLAssignmentExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLCallExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLCommaExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLDereferenceExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLDotExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLFunctionDeclaration.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLFunctionDefinition.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLIndexExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLMakePointerExpression.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLPointerType.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLReadModifyWriteExpression.h&quot;</span>
  #include &quot;WHLSLReplaceWith.h&quot;
<span class="line-removed">- #include &quot;WHLSLVariableDeclaration.h&quot;</span>
<span class="line-removed">- #include &quot;WHLSLVariableReference.h&quot;</span>
  #include &quot;WHLSLVisitor.h&quot;
  
  namespace WebCore {
  
  namespace WHLSL {
  
  class PropertyResolver : public Visitor {
<span class="line-modified">! public:</span>
<span class="line-modified">! private:</span>
<span class="line-modified">!     void visit(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified">!     void visit(AST::DotExpression&amp;) override;</span>
<span class="line-modified">!     void visit(AST::IndexExpression&amp;) override;</span>
<span class="line-modified">!     void visit(AST::AssignmentExpression&amp;) override;</span>
<span class="line-removed">-     void visit(AST::ReadModifyWriteExpression&amp;) override;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void simplifyRightValue(AST::PropertyAccessExpression&amp;);</span>
<span class="line-removed">-     bool simplifyAbstractLeftValue(AST::AssignmentExpression&amp;, AST::DotExpression&amp;, UniqueRef&lt;AST::Expression&gt;&amp;&amp; right);</span>
<span class="line-removed">-     void simplifyLeftValue(AST::Expression&amp;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     AST::VariableDeclarations m_variableDeclarations;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PropertyResolver::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Unless we&#39;re inside an AssignmentExpression or a ReadModifyWriteExpression, we&#39;re a right value.</span>
<span class="line-removed">-     simplifyRightValue(dotExpression);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PropertyResolver::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-removed">-     // Unless we&#39;re inside an AssignmentExpression or a ReadModifyWriteExpression, we&#39;re a right value.</span>
<span class="line-removed">-     simplifyRightValue(indexExpression);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void PropertyResolver::visit(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Visitor::visit(functionDefinition);</span>
<span class="line-modified">!     if (!m_variableDeclarations.isEmpty())</span>
<span class="line-modified">!         functionDefinition.block().statements().insert(0, makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.codeLocation(), WTFMove(m_variableDeclarations)));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! enum class WhichAnder {</span>
<span class="line-removed">-     ThreadAnder,</span>
<span class="line-removed">-     Ander</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! struct AnderCallArgumentResult {</span>
<span class="line-modified">!     UniqueRef&lt;AST::Expression&gt; expression;</span>
<span class="line-modified">!     Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclaration;</span>
<span class="line-modified">!     WhichAnder whichAnder;</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! template &lt;typename ExpressionConstructor, typename TypeConstructor&gt;</span>
<span class="line-modified">! static Optional&lt;AnderCallArgumentResult&gt; wrapAnderCallArgument(UniqueRef&lt;AST::Expression&gt;&amp; expression, Ref&lt;AST::UnnamedType&gt; baseType, AST::FunctionDeclaration* anderFunction, AST::FunctionDeclaration* threadAnderFunction)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto functionEscapeMode = [] (AST::FunctionDeclaration&amp; functionDeclaration) {</span>
<span class="line-removed">-         if (functionDeclaration.isNativeFunctionDeclaration() || functionDeclaration.parsingMode() == ParsingMode::StandardLibrary)</span>
<span class="line-removed">-             return AST::AddressEscapeMode::DoesNotEscape;</span>
<span class="line-removed">-         return AST::AddressEscapeMode::Escapes;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto location = expression-&gt;codeLocation();</span>
<span class="line-removed">-     if (auto addressSpace = expression-&gt;typeAnnotation().leftAddressSpace()) {</span>
<span class="line-removed">-         if (!anderFunction)</span>
<span class="line-removed">-             return WTF::nullopt;</span>
<span class="line-removed">-         auto makeArrayReference = makeUniqueRef&lt;ExpressionConstructor&gt;(location, WTFMove(expression), functionEscapeMode(*anderFunction));</span>
<span class="line-removed">-         makeArrayReference-&gt;setType(TypeConstructor::create(location, *addressSpace, WTFMove(baseType)));</span>
<span class="line-removed">-         makeArrayReference-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">-         return {{ WTFMove(makeArrayReference), WTF::nullopt, WhichAnder::Ander }};</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (threadAnderFunction) {</span>
<span class="line-removed">-         auto variableDeclaration = makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), baseType.copyRef(), String(), nullptr, nullptr);</span>
  
<span class="line-modified">!         auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-modified">!         variableReference1-&gt;setType(baseType.copyRef());</span>
<span class="line-modified">!         variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
  
<span class="line-modified">!         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference1), WTFMove(expression));</span>
<span class="line-modified">!         assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!         auto variableReference2 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-modified">!         variableReference2-&gt;setType(baseType.copyRef());</span>
<span class="line-modified">!         variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
  
<span class="line-modified">!         auto expression = makeUniqueRef&lt;ExpressionConstructor&gt;(location, WTFMove(variableReference2), functionEscapeMode(*threadAnderFunction));</span>
<span class="line-modified">!         auto resultType = TypeConstructor::create(location, AST::AddressSpace::Thread, WTFMove(baseType));</span>
<span class="line-removed">-         expression-&gt;setType(resultType.copyRef());</span>
<span class="line-removed">-         expression-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">-         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">-         expressions.append(WTFMove(expression));</span>
<span class="line-removed">-         auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));</span>
<span class="line-removed">-         commaExpression-&gt;setType(WTFMove(resultType));</span>
<span class="line-removed">-         commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">-         return {{ WTFMove(commaExpression), { WTFMove(variableDeclaration) }, WhichAnder::ThreadAnder}};</span>
      }
<span class="line-removed">-     return WTF::nullopt;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static Optional&lt;AnderCallArgumentResult&gt; anderCallArgument(UniqueRef&lt;AST::Expression&gt;&amp; expression, AST::FunctionDeclaration* anderFunction, AST::FunctionDeclaration* threadAnderFunction)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (!anderFunction &amp;&amp; !threadAnderFunction)</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     auto&amp; unifyNode = expression-&gt;resolvedType().unifyNode();</span>
<span class="line-modified">!     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {</span>
<span class="line-modified">!         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">!         ASSERT(!is&lt;AST::PointerType&gt;(unnamedType));</span>
<span class="line-modified">!         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified">!             return {{ WTFMove(expression), WTF::nullopt, WhichAnder::Ander }};</span>
<span class="line-modified">!         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified">!             return wrapAnderCallArgument&lt;AST::MakeArrayReferenceExpression, AST::ArrayReferenceType&gt;(expression, downcast&lt;AST::ArrayType&gt;(unnamedType).type(), anderFunction, threadAnderFunction);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return wrapAnderCallArgument&lt;AST::MakePointerExpression, AST::PointerType&gt;(expression, expression-&gt;resolvedType(), anderFunction, threadAnderFunction);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static UniqueRef&lt;AST::Expression&gt; setterCall(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::FunctionDeclaration* relevantAnder, UniqueRef&lt;AST::Expression&gt;&amp;&amp; newValue, const std::function&lt;UniqueRef&lt;AST::Expression&gt;()&gt;&amp; leftValueFactory, AST::VariableDeclaration* indexVariable)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto maybeAddIndexArgument = [&amp;](Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; arguments) {</span>
<span class="line-removed">-         if (!indexVariable)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));</span>
<span class="line-removed">-         ASSERT(indexVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setType(*indexVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">-         arguments.append(WTFMove(variableReference));</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">-     if (relevantAnder) {</span>
<span class="line-removed">-         // *operator&amp;.foo(&amp;v) = newValue</span>
<span class="line-removed">-         auto leftValue = leftValueFactory();</span>
<span class="line-removed">-         auto argument = anderCallArgument(leftValue, relevantAnder, relevantAnder);</span>
<span class="line-removed">-         ASSERT(argument);</span>
<span class="line-removed">-         ASSERT(!argument-&gt;variableDeclaration);</span>
<span class="line-removed">-         ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);</span>
<span class="line-removed">-         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">-         arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">-         maybeAddIndexArgument(arguments);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(relevantAnder-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">-         callExpression-&gt;setType(relevantAnder-&gt;type());</span>
<span class="line-removed">-         callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">-         callExpression-&gt;setFunction(*relevantAnder);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(callExpression));</span>
<span class="line-removed">-         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());</span>
<span class="line-removed">-         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(dereferenceExpression), WTFMove(newValue));</span>
<span class="line-removed">-         assignmentExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());</span>
<span class="line-removed">-         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return UniqueRef&lt;AST::Expression&gt;(WTFMove(assignmentExpression));</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // v = operator.foo=(v, newValue)</span>
<span class="line-removed">-     ASSERT(propertyAccessExpression.setterFunction());</span>
  
<span class="line-modified">!     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">-     arguments.append(leftValueFactory());</span>
<span class="line-removed">-     maybeAddIndexArgument(arguments);</span>
<span class="line-removed">-     arguments.append(WTFMove(newValue));</span>
  
<span class="line-modified">!     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(propertyAccessExpression.setterFunction()-&gt;name()), WTFMove(arguments));</span>
<span class="line-modified">!     callExpression-&gt;setType(propertyAccessExpression.setterFunction()-&gt;type());</span>
<span class="line-modified">!     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">-     callExpression-&gt;setFunction(*propertyAccessExpression.setterFunction());</span>
  
<span class="line-modified">!     auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, leftValueFactory(), WTFMove(callExpression));</span>
<span class="line-modified">!     assignmentExpression-&gt;setType(propertyAccessExpression.setterFunction()-&gt;type());</span>
<span class="line-modified">!     assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!     return UniqueRef&lt;AST::Expression&gt;(WTFMove(assignmentExpression));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static UniqueRef&lt;AST::Expression&gt; getterCall(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::FunctionDeclaration* relevantAnder, const std::function&lt;UniqueRef&lt;AST::Expression&gt;()&gt;&amp; leftValueFactory, AST::VariableDeclaration* indexVariable)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto maybeAddIndexArgument = [&amp;](Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; arguments) {</span>
<span class="line-removed">-         if (!indexVariable)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));</span>
<span class="line-removed">-         ASSERT(indexVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setType(*indexVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">-         arguments.append(WTFMove(variableReference));</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (relevantAnder) {</span>
<span class="line-removed">-         // *operator&amp;.foo(&amp;v)</span>
<span class="line-removed">-         auto leftValue = leftValueFactory();</span>
<span class="line-removed">-         auto argument = anderCallArgument(leftValue, relevantAnder, relevantAnder);</span>
<span class="line-removed">-         ASSERT(argument);</span>
<span class="line-removed">-         ASSERT(!argument-&gt;variableDeclaration);</span>
<span class="line-removed">-         ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);</span>
<span class="line-removed">-         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">-         arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">-         maybeAddIndexArgument(arguments);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(relevantAnder-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">-         callExpression-&gt;setType(relevantAnder-&gt;type());</span>
<span class="line-removed">-         callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">-         callExpression-&gt;setFunction(*relevantAnder);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(callExpression));</span>
<span class="line-removed">-         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());</span>
<span class="line-removed">-         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return UniqueRef&lt;AST::Expression&gt;(WTFMove(dereferenceExpression));</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // operator.foo(v)</span>
<span class="line-removed">-     ASSERT(propertyAccessExpression.getterFunction());</span>
  
<span class="line-modified">!     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-modified">!     arguments.append(leftValueFactory());</span>
<span class="line-modified">!     maybeAddIndexArgument(arguments);</span>
  
<span class="line-modified">!     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(propertyAccessExpression.getterFunction()-&gt;name()), WTFMove(arguments));</span>
<span class="line-modified">!     callExpression-&gt;setType(propertyAccessExpression.getterFunction()-&gt;type());</span>
<span class="line-modified">!     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-modified">!     callExpression-&gt;setFunction(*propertyAccessExpression.getterFunction());</span>
  
<span class="line-modified">!     return UniqueRef&lt;AST::Expression&gt;(WTFMove(callExpression));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! struct ModifyResult {</span>
<span class="line-removed">-     AST::Expression&amp; innerLeftValue;</span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclarations;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- struct ModificationResult {</span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">-     UniqueRef&lt;AST::Expression&gt; result;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- static ModifyResult modify(AST::PropertyAccessExpression&amp; propertyAccessExpression, std::function&lt;ModificationResult(UniqueRef&lt;AST::Expression&gt;&amp;&amp;)&gt; modification)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Consider a.b.c.d++;</span>
<span class="line-removed">-     // This would get transformed into:</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // Step 1:</span>
<span class="line-removed">-     // p = &amp;a;</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // Step 2:</span>
<span class="line-removed">-     // q = operator.b(*p);</span>
<span class="line-removed">-     // r = operator.c(q);</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // Step 3:</span>
<span class="line-removed">-     // oldValue = operator.d(r);</span>
<span class="line-removed">-     // newValue = ...;</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // Step 4:</span>
<span class="line-removed">-     // r = operator.d=(r, newValue);</span>
<span class="line-removed">-     // q = operator.c=(q, r);</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // Step 5:</span>
<span class="line-removed">-     // *p = operator.b=(*p, q);</span>
  
<span class="line-modified">!     // If the expression is a.b.c.d = e, Step 3 disappears and &quot;newValue&quot; in step 4 becomes &quot;e&quot;.</span>
  
  
<span class="line-modified">!     // Find the &quot;.b&quot; &quot;.c&quot; and &quot;.d&quot; expressions. They end up in the order [&quot;.d&quot;, &quot;.c&quot;, &quot;.b&quot;].</span>
<span class="line-modified">!     Vector&lt;std::reference_wrapper&lt;AST::PropertyAccessExpression&gt;&gt; chain;</span>
<span class="line-removed">-     AST::PropertyAccessExpression* iterator = &amp;propertyAccessExpression;</span>
<span class="line-removed">-     while (true) {</span>
<span class="line-removed">-         chain.append(*iterator);</span>
<span class="line-removed">-         if (iterator-&gt;base().typeAnnotation().leftAddressSpace())</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         ASSERT(!iterator-&gt;base().typeAnnotation().isRightValue());</span>
<span class="line-removed">-         iterator = &amp;downcast&lt;AST::PropertyAccessExpression&gt;(iterator-&gt;base());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     auto leftExpression = iterator-&gt;takeBase();</span>
<span class="line-removed">-     AST::Expression&amp; innerLeftExpression = leftExpression;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Create &quot;p&quot; variable.</span>
<span class="line-removed">-     auto pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(leftExpression-&gt;codeLocation(), AST::Qualifiers(), AST::PointerType::create(leftExpression-&gt;codeLocation(), *leftExpression-&gt;typeAnnotation().leftAddressSpace(), leftExpression-&gt;resolvedType()), String(), nullptr, nullptr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Create &quot;q&quot; and &quot;r&quot; variables.</span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; intermediateVariables;</span>
<span class="line-removed">-     intermediateVariables.reserveInitialCapacity(chain.size() - 1);</span>
<span class="line-removed">-     for (size_t i = 1; i &lt; chain.size(); ++i) {</span>
<span class="line-removed">-         auto&amp; propertyAccessExpression = static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(chain[i]);</span>
<span class="line-removed">-         intermediateVariables.uncheckedAppend(makeUniqueRef&lt;AST::VariableDeclaration&gt;(propertyAccessExpression.codeLocation(), AST::Qualifiers(), &amp;propertyAccessExpression.resolvedType(), String(), nullptr, nullptr));</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // Consider a[foo()][b] = c;</span>
<span class="line-modified">!     // Naively, This would get expanded to:</span>
<span class="line-modified">!     //</span>
<span class="line-modified">!     // temp = operator[](a, foo());</span>
<span class="line-removed">-     // temp = operator[]=(temp, b, c);</span>
<span class="line-removed">-     // a = operator[]=(a, foo(), temp);</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // However, if we did this, we would have to run foo() twice, which would be incorrect.</span>
<span class="line-removed">-     // Instead, we need to save foo() and b into more temporary variables.</span>
<span class="line-removed">-     // These temporary variables are parallel to &quot;chain&quot; above, with nullopt referring to a DotExpression (which doesn&#39;t have an index value to save to a variable).</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // Instead, this gets expanded to:</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // p = &amp;a;</span>
<span class="line-removed">-     // temp = foo();</span>
<span class="line-removed">-     // q = operator[](*p, temp);</span>
<span class="line-removed">-     // temp2 = b;</span>
<span class="line-removed">-     // q = operator[]=(q, temp2, c);</span>
<span class="line-removed">-     // *p = operator[]=(*p, temp, q);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Vector&lt;Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&gt; indexVariables;</span>
<span class="line-removed">-     indexVariables.reserveInitialCapacity(chain.size());</span>
<span class="line-removed">-     for (AST::PropertyAccessExpression&amp; propertyAccessExpression : chain) {</span>
<span class="line-removed">-         if (!is&lt;AST::IndexExpression&gt;(propertyAccessExpression)) {</span>
<span class="line-removed">-             indexVariables.append(WTF::nullopt);</span>
<span class="line-removed">-             continue;</span>
          }
<span class="line-removed">-         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">-         indexVariables.uncheckedAppend(makeUniqueRef&lt;AST::VariableDeclaration&gt;(propertyAccessExpression.codeLocation(), AST::Qualifiers(), &amp;indexExpression.indexExpression().resolvedType(), String(), nullptr, nullptr));</span>
      }
  
<span class="line-modified">!     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Step 1:</span>
      {
<span class="line-modified">!         auto makePointerExpression = makeUniqueRef&lt;AST::MakePointerExpression&gt;(innerLeftExpression.codeLocation(), WTFMove(leftExpression), AST::AddressEscapeMode::DoesNotEscape);</span>
<span class="line-removed">-         makePointerExpression-&gt;setType(AST::PointerType::create(innerLeftExpression.codeLocation(), *innerLeftExpression.typeAnnotation().leftAddressSpace(), innerLeftExpression.resolvedType()));</span>
<span class="line-removed">-         makePointerExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">-         ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(innerLeftExpression.codeLocation(), WTFMove(variableReference), WTFMove(makePointerExpression));</span>
<span class="line-removed">-         assignmentExpression-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">-         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Step 2:</span>
<span class="line-removed">-     AST::VariableDeclaration* previous = nullptr;</span>
<span class="line-removed">-     auto previousLeftValue = [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {</span>
<span class="line-removed">-         if (previous) {</span>
<span class="line-removed">-             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*previous));</span>
<span class="line-removed">-             ASSERT(previous-&gt;type());</span>
<span class="line-removed">-             variableReference-&gt;setType(*previous-&gt;type());</span>
<span class="line-removed">-             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">-             return variableReference;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">-         ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">-         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference));</span>
<span class="line-removed">-         ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">-         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).elementType());</span>
<span class="line-removed">-         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).addressSpace() });</span>
<span class="line-removed">-         return dereferenceExpression;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     auto appendIndexAssignment = [&amp;](AST::PropertyAccessExpression&amp; propertyAccessExpression, Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable) {</span>
<span class="line-removed">-         if (!indexVariable)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));</span>
<span class="line-removed">-         ASSERT(indexVariable-&gt;get().type());</span>
<span class="line-removed">-         variableReference-&gt;setType(*indexVariable-&gt;get().type());</span>
<span class="line-removed">-         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
  
<span class="line-modified">!         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference), indexExpression.takeIndex());</span>
<span class="line-removed">-         assignmentExpression-&gt;setType(*indexVariable-&gt;get().type());</span>
<span class="line-removed">-         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     for (size_t i = chain.size(); --i; ) {</span>
<span class="line-removed">-         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[i];</span>
<span class="line-removed">-         AST::VariableDeclaration&amp; variableDeclaration = intermediateVariables[i - 1];</span>
<span class="line-removed">-         Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable = indexVariables[i];</span>
  
<span class="line-modified">!         appendIndexAssignment(propertyAccessExpression, indexVariable);</span>
  
<span class="line-modified">!         AST::FunctionDeclaration* relevantAnder = i == chain.size() - 1 ? propertyAccessExpression.anderFunction() : propertyAccessExpression.threadAnderFunction();</span>
<span class="line-modified">!         auto callExpression = getterCall(propertyAccessExpression, relevantAnder, previousLeftValue, indexVariable ? &amp;*indexVariable : nullptr);</span>
  
<span class="line-modified">!         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-removed">-         ASSERT(variableDeclaration.type());</span>
<span class="line-removed">-         variableReference-&gt;setType(*variableDeclaration.type());</span>
<span class="line-removed">-         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
  
<span class="line-modified">!         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference), WTFMove(callExpression));</span>
<span class="line-modified">!         assignmentExpression-&gt;setType(*variableDeclaration.type());</span>
<span class="line-modified">!         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!         expressions.append(WTFMove(assignmentExpression));</span>
  
<span class="line-modified">!         previous = &amp;variableDeclaration;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     appendIndexAssignment(chain[0], indexVariables[0]);</span>
<span class="line-removed">-     AST::FunctionDeclaration* relevantAnder = chain.size() == 1 ? propertyAccessExpression.anderFunction() : propertyAccessExpression.threadAnderFunction();</span>
<span class="line-removed">-     auto lastGetterCallExpression = getterCall(chain[0], relevantAnder, previousLeftValue, indexVariables[0] ? &amp;*(indexVariables[0]) : nullptr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Step 3:</span>
<span class="line-removed">-     auto modificationResult = modification(WTFMove(lastGetterCallExpression));</span>
<span class="line-removed">-     for (size_t i = 0; i &lt; modificationResult.expressions.size(); ++i)</span>
<span class="line-removed">-         expressions.append(WTFMove(modificationResult.expressions[i]));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Step 4:</span>
<span class="line-removed">-     UniqueRef&lt;AST::Expression&gt; rightValue = WTFMove(modificationResult.result);</span>
<span class="line-removed">-     for (size_t i = 0; i &lt; chain.size() - 1; ++i) {</span>
<span class="line-removed">-         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[i];</span>
<span class="line-removed">-         AST::VariableDeclaration&amp; variableDeclaration = intermediateVariables[i];</span>
<span class="line-removed">-         Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable = indexVariables[i];</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto assignmentExpression = setterCall(propertyAccessExpression, propertyAccessExpression.threadAnderFunction(), WTFMove(rightValue), [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {</span>
<span class="line-removed">-             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-removed">-             ASSERT(variableDeclaration.type());</span>
<span class="line-removed">-             variableReference-&gt;setType(*variableDeclaration.type());</span>
<span class="line-removed">-             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">-             return variableReference;</span>
<span class="line-removed">-         }, indexVariable ? &amp;*indexVariable : nullptr);</span>
  
<span class="line-modified">!         expressions.append(WTFMove(assignmentExpression));</span>
  
<span class="line-modified">!         rightValue = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-modified">!         ASSERT(variableDeclaration.type());</span>
<span class="line-removed">-         rightValue-&gt;setType(*variableDeclaration.type());</span>
<span class="line-removed">-         rightValue-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
      }
  
<span class="line-modified">!     // Step 5:</span>
      {
<span class="line-modified">!         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[chain.size() - 1];</span>
<span class="line-removed">-         auto assignmentExpression = setterCall(propertyAccessExpression, propertyAccessExpression.anderFunction(), WTFMove(rightValue), [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {</span>
<span class="line-removed">-             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">-             ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">-             variableReference-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">-             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference));</span>
<span class="line-removed">-             ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">-             dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).elementType());</span>
<span class="line-removed">-             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).addressSpace() });</span>
<span class="line-removed">-             return dereferenceExpression;</span>
<span class="line-removed">-         }, indexVariables[indexVariables.size() - 1] ? &amp;*(indexVariables[indexVariables.size() - 1]) : nullptr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclarations;</span>
<span class="line-removed">-     variableDeclarations.append(WTFMove(pointerVariable));</span>
<span class="line-removed">-     for (auto&amp; intermediateVariable : intermediateVariables)</span>
<span class="line-removed">-         variableDeclarations.append(WTFMove(intermediateVariable));</span>
<span class="line-removed">-     for (auto&amp; indexVariable : indexVariables) {</span>
<span class="line-removed">-         if (indexVariable)</span>
<span class="line-removed">-             variableDeclarations.append(WTFMove(*indexVariable));</span>
      }
  
<span class="line-modified">!     return { innerLeftExpression, WTFMove(expressions), WTFMove(variableDeclarations) };</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- void PropertyResolver::visit(AST::AssignmentExpression&amp; assignmentExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (assignmentExpression.left().typeAnnotation().leftAddressSpace()) {</span>
<span class="line-removed">-         simplifyLeftValue(assignmentExpression.left());</span>
<span class="line-removed">-         checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-removed">-         return;</span>
      }
<span class="line-removed">-     ASSERT(!assignmentExpression.left().typeAnnotation().isRightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Ref&lt;AST::UnnamedType&gt; type = assignmentExpression.right().resolvedType();</span>
  
<span class="line-modified">!     checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto modifyResult = modify(downcast&lt;AST::PropertyAccessExpression&gt;(assignmentExpression.left()), [&amp;](UniqueRef&lt;AST::Expression&gt;&amp;&amp;) -&gt; ModificationResult {</span>
<span class="line-modified">!         return { Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;(), assignmentExpression.takeRight() };</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- </span>
<span class="line-removed">-     simplifyLeftValue(modifyResult.innerLeftValue);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto location = assignmentExpression.codeLocation();</span>
<span class="line-removed">-     auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(assignmentExpression, location, WTFMove(modifyResult.expressions));</span>
<span class="line-removed">-     commaExpression-&gt;setType(WTFMove(type));</span>
<span class="line-removed">-     commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto&amp; variableDeclaration : modifyResult.variableDeclarations)</span>
<span class="line-removed">-         m_variableDeclarations.append(WTFMove(variableDeclaration));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PropertyResolver::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     checkErrorAndVisit(readModifyWriteExpression.newValueExpression());</span>
<span class="line-removed">-     if (hasError())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto location = readModifyWriteExpression.codeLocation();</span>
<span class="line-removed">-     auto leftValueLocation = readModifyWriteExpression.leftValue().codeLocation();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (readModifyWriteExpression.leftValue().typeAnnotation().leftAddressSpace()) {</span>
<span class="line-removed">-         // Consider a++;</span>
<span class="line-removed">-         // This would get transformed into:</span>
<span class="line-removed">-         //</span>
<span class="line-removed">-         // p = &amp;a;</span>
<span class="line-removed">-         // oldValue = *p;</span>
<span class="line-removed">-         // newValue = ...;</span>
<span class="line-removed">-         // *p = newValue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         simplifyLeftValue(readModifyWriteExpression.leftValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Ref&lt;AST::UnnamedType&gt; baseType = readModifyWriteExpression.leftValue().resolvedType();</span>
<span class="line-removed">-         Ref&lt;AST::UnnamedType&gt; pointerType = AST::PointerType::create(leftValueLocation, *readModifyWriteExpression.leftValue().typeAnnotation().leftAddressSpace(), baseType.copyRef());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(leftValueLocation, AST::Qualifiers(), pointerType.copyRef(), String(), nullptr, nullptr);</span>
  
          Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
  
<span class="line-modified">!         {</span>
<span class="line-removed">-             auto makePointerExpression = makeUniqueRef&lt;AST::MakePointerExpression&gt;(leftValueLocation, readModifyWriteExpression.takeLeftValue(), AST::AddressEscapeMode::DoesNotEscape);</span>
<span class="line-removed">-             makePointerExpression-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">-             makePointerExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">-             variableReference-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">-             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
  
<span class="line-modified">!             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(makePointerExpression));</span>
<span class="line-removed">-             assignmentExpression-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">-             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-modified">!         }</span>
  
          {
<span class="line-modified">!             auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-modified">!             variableReference1-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified">!             variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-modified">! </span>
<span class="line-modified">!             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(variableReference1));</span>
<span class="line-modified">!             dereferenceExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-modified">!             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-modified">! </span>
<span class="line-removed">-             auto variableReference2 = readModifyWriteExpression.oldVariableReference();</span>
<span class="line-removed">-             variableReference2-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-             variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference2), WTFMove(dereferenceExpression));</span>
<span class="line-removed">-             assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             auto variableReference = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">-             variableReference-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto newValueExpression = readModifyWriteExpression.takeNewValueExpression();</span>
<span class="line-removed">-             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference), WTFMove(newValueExpression));</span>
<span class="line-removed">-             assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">-             variableReference1-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">-             variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(variableReference1));</span>
<span class="line-removed">-             dereferenceExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto variableReference2 = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">-             variableReference2-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-             variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(dereferenceExpression), WTFMove(variableReference2));</span>
<span class="line-removed">-             assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">-             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             expressions.append(WTFMove(assignmentExpression));</span>
          }
  
<span class="line-modified">!         auto resultExpression = readModifyWriteExpression.takeResultExpression();</span>
<span class="line-modified">!         Ref&lt;AST::UnnamedType&gt; type = resultExpression-&gt;resolvedType();</span>
<span class="line-modified">!         expressions.append(WTFMove(resultExpression));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         UniqueRef&lt;AST::VariableDeclaration&gt; oldVariableDeclaration = readModifyWriteExpression.takeOldValue();</span>
<span class="line-removed">-         UniqueRef&lt;AST::VariableDeclaration&gt; newVariableDeclaration = readModifyWriteExpression.takeNewValue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWriteExpression, location, WTFMove(expressions));</span>
<span class="line-removed">-         commaExpression-&gt;setType(WTFMove(type));</span>
<span class="line-removed">-         commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         m_variableDeclarations.append(WTFMove(pointerVariable));</span>
<span class="line-removed">-         m_variableDeclarations.append(WTFMove(oldVariableDeclaration));</span>
<span class="line-removed">-         m_variableDeclarations.append(WTFMove(newVariableDeclaration));</span>
<span class="line-removed">-         return;</span>
      }
  
<span class="line-modified">!     ASSERT(!readModifyWriteExpression.leftValue().typeAnnotation().isRightValue());</span>
<span class="line-modified">!     if (!is&lt;AST::PropertyAccessExpression&gt;(readModifyWriteExpression.leftValue())) {</span>
<span class="line-modified">!         setError(Error(&quot;Base of read modify write expression is a right-value.&quot;, readModifyWriteExpression.leftValue().codeLocation()));</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     auto modifyResult = modify(downcast&lt;AST::PropertyAccessExpression&gt;(readModifyWriteExpression.leftValue()), [&amp;](UniqueRef&lt;AST::Expression&gt;&amp;&amp; lastGetterCallExpression) -&gt; ModificationResult {</span>
<span class="line-removed">-         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             auto variableReference = readModifyWriteExpression.oldVariableReference();</span>
<span class="line-removed">-             variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">-             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(lastGetterCallExpression));</span>
<span class="line-removed">-             assignmentExpression-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">-             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             auto variableReference = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">-             variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">-             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
  
<span class="line-modified">!             auto newValueExpression = readModifyWriteExpression.takeNewValueExpression();</span>
<span class="line-modified">!             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(newValueExpression));</span>
<span class="line-removed">-             assignmentExpression-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">-             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!             expressions.append(WTFMove(assignmentExpression));</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         auto variableReference = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">-         variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">-         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return { WTFMove(expressions),  WTFMove(variableReference) };</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- </span>
<span class="line-removed">-     simplifyLeftValue(modifyResult.innerLeftValue);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto resultExpression = readModifyWriteExpression.takeResultExpression();</span>
<span class="line-removed">-     Ref&lt;AST::UnnamedType&gt; type = resultExpression-&gt;resolvedType();</span>
<span class="line-removed">-     modifyResult.expressions.append(WTFMove(resultExpression));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     UniqueRef&lt;AST::VariableDeclaration&gt; oldVariableDeclaration = readModifyWriteExpression.takeOldValue();</span>
<span class="line-removed">-     UniqueRef&lt;AST::VariableDeclaration&gt; newVariableDeclaration = readModifyWriteExpression.takeNewValue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWriteExpression, location, WTFMove(modifyResult.expressions));</span>
<span class="line-removed">-     commaExpression-&gt;setType(WTFMove(type));</span>
<span class="line-removed">-     commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto&amp; variableDeclaration : modifyResult.variableDeclarations)</span>
<span class="line-removed">-         m_variableDeclarations.append(WTFMove(variableDeclaration));</span>
<span class="line-removed">-     m_variableDeclarations.append(WTFMove(oldVariableDeclaration));</span>
<span class="line-removed">-     m_variableDeclarations.append(WTFMove(newVariableDeclaration));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static Optional&lt;AnderCallArgumentResult&gt; anderCallArgument(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return anderCallArgument(propertyAccessExpression.baseReference(), propertyAccessExpression.anderFunction(), propertyAccessExpression.threadAnderFunction());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PropertyResolver::simplifyRightValue(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     checkErrorAndVisit(propertyAccessExpression.base());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (auto argument = anderCallArgument(propertyAccessExpression)) {</span>
<span class="line-removed">-         auto* anderFunction = argument-&gt;whichAnder == WhichAnder::ThreadAnder ? propertyAccessExpression.threadAnderFunction() : propertyAccessExpression.anderFunction();</span>
<span class="line-removed">-         ASSERT(anderFunction);</span>
<span class="line-removed">-         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">-         arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">-         if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression))</span>
<span class="line-removed">-             arguments.append(downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression).takeIndex());</span>
<span class="line-removed">-         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(anderFunction-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">-         callExpression-&gt;setType(anderFunction-&gt;type());</span>
<span class="line-removed">-         callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">-         callExpression-&gt;setFunction(*anderFunction);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* dereferenceExpression = AST::replaceWith&lt;AST::DereferenceExpression&gt;(propertyAccessExpression, location, WTFMove(callExpression));</span>
<span class="line-removed">-         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType());</span>
<span class="line-removed">-         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).addressSpace() });</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (auto&amp; variableDeclaration = argument-&gt;variableDeclaration)</span>
<span class="line-removed">-             m_variableDeclarations.append(WTFMove(*variableDeclaration));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(propertyAccessExpression.getterFunction());</span>
<span class="line-removed">-     auto&amp; getterFunction = *propertyAccessExpression.getterFunction();</span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">-     arguments.append(propertyAccessExpression.takeBase());</span>
<span class="line-removed">-     AST::CallExpression* callExpression;</span>
<span class="line-removed">-     if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression)) {</span>
<span class="line-removed">-         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">-         arguments.append(indexExpression.takeIndex());</span>
<span class="line-removed">-         callExpression = AST::replaceWith&lt;AST::CallExpression&gt;(indexExpression, location, String(getterFunction.name()), WTFMove(arguments));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         ASSERT(is&lt;AST::DotExpression&gt;(propertyAccessExpression));</span>
<span class="line-removed">-         auto&amp; dotExpression = downcast&lt;AST::DotExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">-         callExpression = AST::replaceWith&lt;AST::CallExpression&gt;(dotExpression, location, String(getterFunction.name()), WTFMove(arguments));</span>
      }
<span class="line-removed">-     callExpression-&gt;setFunction(getterFunction);</span>
<span class="line-removed">-     callExpression-&gt;setType(getterFunction.type());</span>
<span class="line-removed">-     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">- }</span>
  
<span class="line-removed">- class LeftValueSimplifier : public Visitor {</span>
  private:
<span class="line-modified">!     void visit(AST::DotExpression&amp;) override;</span>
<span class="line-removed">-     void visit(AST::IndexExpression&amp;) override;</span>
<span class="line-removed">-     void visit(AST::DereferenceExpression&amp;) override;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void finishVisiting(AST::PropertyAccessExpression&amp;);</span>
  };
  
<span class="line-removed">- void LeftValueSimplifier::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(propertyAccessExpression.base().typeAnnotation().leftAddressSpace());</span>
<span class="line-removed">-     ASSERT(propertyAccessExpression.anderFunction());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Visitor::visit(propertyAccessExpression.base());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">-     auto* anderFunction = propertyAccessExpression.anderFunction();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto argument = anderCallArgument(propertyAccessExpression);</span>
<span class="line-removed">-     ASSERT(argument);</span>
<span class="line-removed">-     ASSERT(!argument-&gt;variableDeclaration);</span>
<span class="line-removed">-     ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">-     arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">-     if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression))</span>
<span class="line-removed">-         arguments.append(downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression).takeIndex());</span>
<span class="line-removed">-     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(anderFunction-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">-     callExpression-&gt;setType(anderFunction-&gt;type());</span>
<span class="line-removed">-     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">-     callExpression-&gt;setFunction(*anderFunction);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* dereferenceExpression = AST::replaceWith&lt;AST::DereferenceExpression&gt;(propertyAccessExpression, location, WTFMove(callExpression));</span>
<span class="line-removed">-     dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType());</span>
<span class="line-removed">-     dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).addressSpace() });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LeftValueSimplifier::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Visitor::visit(dotExpression);</span>
<span class="line-removed">-     finishVisiting(dotExpression);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LeftValueSimplifier::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     PropertyResolver().Visitor::visit(indexExpression.indexExpression());</span>
<span class="line-removed">-     finishVisiting(indexExpression);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LeftValueSimplifier::visit(AST::DereferenceExpression&amp; dereferenceExpression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Dereference expressions are the only expressions where the children might be more-right than we are.</span>
<span class="line-removed">-     // For example, a dereference expression may be a left value but its child may be a call expression which is a right value.</span>
<span class="line-removed">-     // LeftValueSimplifier doesn&#39;t handle right values, so we instead need to use PropertyResolver.</span>
<span class="line-removed">-     PropertyResolver().Visitor::visit(dereferenceExpression);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PropertyResolver::simplifyLeftValue(AST::Expression&amp; expression)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     LeftValueSimplifier().Visitor::visit(expression);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void resolveProperties(Program&amp; program)
  {
<span class="line-modified">!     PropertyResolver().Visitor::visit(program);</span>
  }
  
  } // namespace WHLSL
  
  } // namespace WebCore
<span class="line-new-header">--- 26,255 ---</span>
  #include &quot;config.h&quot;
  #include &quot;WHLSLPropertyResolver.h&quot;
  
  #if ENABLE(WEBGPU)
  
<span class="line-modified">! #include &quot;WHLSLAST.h&quot;</span>
<span class="line-modified">! #include &quot;WHLSLProgram.h&quot;</span>
  #include &quot;WHLSLReplaceWith.h&quot;
  #include &quot;WHLSLVisitor.h&quot;
  
  namespace WebCore {
  
  namespace WHLSL {
  
  class PropertyResolver : public Visitor {
<span class="line-modified">!     void handleLeftHandSideBase(UniqueRef&lt;AST::Expression&gt; base, UniqueRef&lt;AST::Expression&gt;&amp; slot, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (!base-&gt;mayBeEffectful()) {</span>
<span class="line-modified">!             slot = WTFMove(base);</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         auto leftAddressSpace = base-&gt;typeAnnotation().leftAddressSpace();</span>
<span class="line-modified">!         RELEASE_ASSERT(leftAddressSpace);</span>
<span class="line-modified">!         CodeLocation codeLocation = base-&gt;codeLocation();</span>
<span class="line-modified">!         Ref&lt;AST::UnnamedType&gt; baseType = base-&gt;resolvedType();</span>
<span class="line-modified">!         Ref&lt;AST::PointerType&gt; pointerType = AST::PointerType::create(codeLocation, *leftAddressSpace, baseType.copyRef());</span>
  
<span class="line-modified">!         UniqueRef&lt;AST::VariableDeclaration&gt; pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(codeLocation, AST::Qualifiers { }, pointerType.ptr(), String(), nullptr, nullptr);</span>
  
<span class="line-modified">!         auto makeVariableReference = [&amp;] {</span>
<span class="line-modified">!             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-modified">!             variableReference-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified">!             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-modified">!             return variableReference;</span>
<span class="line-added">+         };</span>
  
<span class="line-modified">!         {</span>
<span class="line-modified">!             auto pointerOfBase = makeUniqueRef&lt;AST::MakePointerExpression&gt;(codeLocation, WTFMove(base), AST::AddressEscapeMode::DoesNotEscape);</span>
<span class="line-modified">!             pointerOfBase-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified">!             pointerOfBase-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(codeLocation, makeVariableReference(), WTFMove(pointerOfBase));</span>
<span class="line-modified">!             assignment-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified">!             assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!             expressions.append(WTFMove(assignment));</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         {</span>
<span class="line-modified">!             auto dereference = makeUniqueRef&lt;AST::DereferenceExpression&gt;(codeLocation, makeVariableReference());</span>
<span class="line-modified">!             dereference-&gt;setType(baseType.copyRef());</span>
<span class="line-added">+             dereference-&gt;setTypeAnnotation(AST::LeftValue { *leftAddressSpace });</span>
  
<span class="line-modified">!             slot = WTFMove(dereference);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         m_variables.append(WTFMove(pointerVariable));</span>
      }
  
<span class="line-modified">!     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         AST::PropertyAccessExpression* currentPtr = &amp;propertyAccess;</span>
<span class="line-modified">!         // a.b[c].d will go into this array as [.d, [c], .b]</span>
<span class="line-modified">!         Vector&lt;std::reference_wrapper&lt;AST::PropertyAccessExpression&gt;&gt; chain;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         while (true) {</span>
<span class="line-modified">!             AST::PropertyAccessExpression&amp; current = *currentPtr;</span>
<span class="line-modified">!             chain.append(current);</span>
<span class="line-modified">!             if (is&lt;AST::IndexExpression&gt;(current))</span>
<span class="line-modified">!                 checkErrorAndVisit(downcast&lt;AST::IndexExpression&gt;(current).indexExpression());</span>
<span class="line-modified">!             if (!is&lt;AST::PropertyAccessExpression&gt;(current.base()))</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             currentPtr = &amp;downcast&lt;AST::PropertyAccessExpression&gt;(current.base());</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         AST::PropertyAccessExpression&amp; current = *currentPtr;</span>
  
<span class="line-modified">!         checkErrorAndVisit(current.base());</span>
  
<span class="line-modified">!         CodeLocation baseCodeLocation = current.base().codeLocation();</span>
  
<span class="line-modified">!         if (current.base().typeAnnotation().isRightValue()) {</span>
<span class="line-modified">!             UniqueRef&lt;AST::VariableDeclaration&gt; copy = makeUniqueRef&lt;AST::VariableDeclaration&gt;(baseCodeLocation, AST::Qualifiers { }, &amp;current.base().resolvedType(), String(), nullptr, nullptr);</span>
<span class="line-modified">!             Ref&lt;AST::UnnamedType&gt; baseType = current.base().resolvedType();</span>
  
<span class="line-modified">!             auto makeVariableReference = [&amp;] {</span>
<span class="line-modified">!                 auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(copy));</span>
<span class="line-modified">!                 variableReference-&gt;setType(baseType.copyRef());</span>
<span class="line-added">+                 variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-added">+                 return variableReference;</span>
<span class="line-added">+             };</span>
  
<span class="line-modified">!             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), current.takeBase());</span>
<span class="line-modified">!             assignment-&gt;setType(baseType.copyRef());</span>
<span class="line-added">+             assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!             expressions.append(WTFMove(assignment));</span>
  
<span class="line-modified">!             current.baseReference() = makeVariableReference();</span>
  
<span class="line-modified">!             m_variables.append(WTFMove(copy));</span>
<span class="line-modified">!         } else</span>
<span class="line-modified">!             handleLeftHandSideBase(current.takeBase(), current.baseReference(), expressions);</span>
  
<span class="line-modified">!         for (size_t i = chain.size(); i--; ) {</span>
<span class="line-modified">!             auto&amp; access = chain[i].get();</span>
<span class="line-modified">!             if (is&lt;AST::IndexExpression&gt;(access) &amp;&amp; downcast&lt;AST::IndexExpression&gt;(access).indexExpression().mayBeEffectful()) {</span>
<span class="line-modified">!                 auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(access);</span>
  
<span class="line-modified">!                 Ref&lt;AST::UnnamedType&gt; indexType = indexExpression.indexExpression().resolvedType();</span>
  
<span class="line-modified">!                 UniqueRef&lt;AST::VariableDeclaration&gt; indexVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(access.codeLocation(), AST::Qualifiers { }, indexType.ptr(), String(), nullptr, nullptr);</span>
  
<span class="line-modified">!                 auto makeVariableReference = [&amp;] {</span>
<span class="line-added">+                     auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(indexVariable));</span>
<span class="line-added">+                     variableReference-&gt;setType(indexType.copyRef());</span>
<span class="line-added">+                     variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-added">+                     return variableReference;</span>
<span class="line-added">+                 };</span>
  
<span class="line-added">+                 {</span>
<span class="line-added">+                     auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), indexExpression.takeIndex());</span>
<span class="line-added">+                     assignment-&gt;setType(indexType.copyRef());</span>
<span class="line-added">+                     assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
  
<span class="line-modified">!                     expressions.append(WTFMove(assignment));</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 indexExpression.indexReference() = makeVariableReference();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 m_variables.append(WTFMove(indexVariable));</span>
<span class="line-modified">!             }</span>
          }
      }
  
<span class="line-modified">!     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess)</span>
      {
<span class="line-modified">!         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
  
<span class="line-modified">!         handlePropertyAccess(propertyAccess, expressions);</span>
  
<span class="line-modified">!         Ref&lt;AST::UnnamedType&gt; accessType = propertyAccess.resolvedType();</span>
  
<span class="line-modified">!         AST::CommaExpression* comma;</span>
<span class="line-added">+         CodeLocation codeLocation = propertyAccess.codeLocation();</span>
<span class="line-added">+         if (is&lt;AST::IndexExpression&gt;(propertyAccess)) {</span>
<span class="line-added">+             auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccess);</span>
  
<span class="line-modified">!             auto newIndexExpression = makeUniqueRef&lt;AST::IndexExpression&gt;(codeLocation, indexExpression.takeBase(), indexExpression.takeIndex());</span>
<span class="line-modified">!             newIndexExpression-&gt;setType(indexExpression.resolvedType());</span>
<span class="line-added">+             newIndexExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(indexExpression.typeAnnotation()));</span>
  
<span class="line-modified">!             expressions.append(WTFMove(newIndexExpression));</span>
  
<span class="line-modified">!             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(indexExpression, codeLocation, WTFMove(expressions));</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             RELEASE_ASSERT(is&lt;AST::DotExpression&gt;(propertyAccess));</span>
<span class="line-added">+             auto&amp; dotExpression = downcast&lt;AST::DotExpression&gt;(propertyAccess);</span>
  
<span class="line-modified">!             auto newDotExpression = makeUniqueRef&lt;AST::DotExpression&gt;(codeLocation, dotExpression.takeBase(), String(dotExpression.fieldName()));</span>
<span class="line-added">+             newDotExpression-&gt;setType(dotExpression.resolvedType());</span>
<span class="line-added">+             newDotExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(dotExpression.typeAnnotation()));</span>
  
<span class="line-modified">!             expressions.append(WTFMove(newDotExpression));</span>
  
<span class="line-modified">!             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(dotExpression, codeLocation, WTFMove(expressions));</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         comma-&gt;setType(WTFMove(accessType));</span>
<span class="line-modified">!         comma-&gt;setTypeAnnotation(AST::RightValue());</span>
      }
  
<span class="line-modified">! public:</span>
<span class="line-added">+     void visit(AST::DotExpression&amp; dotExpression) override</span>
      {
<span class="line-modified">!         handlePropertyAccess(dotExpression);</span>
      }
  
<span class="line-modified">!     void visit(AST::IndexExpression&amp; indexExpression) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         handlePropertyAccess(indexExpression);</span>
      }
  
<span class="line-modified">!     void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         checkErrorAndVisit(readModifyWrite.newValueExpression());</span>
<span class="line-modified">!         checkErrorAndVisit(readModifyWrite.resultExpression());</span>
  
          Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
  
<span class="line-modified">!         CodeLocation codeLocation = readModifyWrite.codeLocation();</span>
  
<span class="line-modified">!         Ref&lt;AST::UnnamedType&gt; type = readModifyWrite.resolvedType();</span>
  
<span class="line-modified">!         if (is&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()))</span>
<span class="line-modified">!             handlePropertyAccess(downcast&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()), expressions);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             handleLeftHandSideBase(readModifyWrite.takeLeftValue(), readModifyWrite.leftValueReference(), expressions);</span>
  
          {
<span class="line-modified">!             UniqueRef&lt;AST::ReadModifyWriteExpression&gt; newReadModifyWrite = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(</span>
<span class="line-modified">!                 readModifyWrite.codeLocation(), readModifyWrite.takeLeftValue(), readModifyWrite.takeOldValue(), readModifyWrite.takeNewValue());</span>
<span class="line-modified">!             newReadModifyWrite-&gt;setNewValueExpression(readModifyWrite.takeNewValueExpression());</span>
<span class="line-modified">!             newReadModifyWrite-&gt;setResultExpression(readModifyWrite.takeResultExpression());</span>
<span class="line-modified">!             newReadModifyWrite-&gt;setType(type.copyRef());</span>
<span class="line-modified">!             newReadModifyWrite-&gt;setTypeAnnotation(AST::TypeAnnotation(readModifyWrite.typeAnnotation()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!             expressions.append(WTFMove(newReadModifyWrite));</span>
          }
  
<span class="line-modified">!         auto* comma = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWrite, codeLocation, WTFMove(expressions));</span>
<span class="line-modified">!         comma-&gt;setType(WTFMove(type));</span>
<span class="line-modified">!         comma-&gt;setTypeAnnotation(AST::RightValue());</span>
      }
  
<span class="line-modified">!     void visit(AST::FunctionDefinition&amp; functionDefinition) override</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         RELEASE_ASSERT(m_variables.isEmpty());</span>
  
<span class="line-modified">!         checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));</span>
<span class="line-modified">!         checkErrorAndVisit(functionDefinition.block());</span>
  
<span class="line-modified">!         if (!m_variables.isEmpty()) {</span>
<span class="line-added">+             functionDefinition.block().statements().insert(0,</span>
<span class="line-added">+                 makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.block().codeLocation(), WTFMove(m_variables)));</span>
          }
      }
  
  private:
<span class="line-modified">!     AST::VariableDeclarations m_variables;</span>
  };
  
  void resolveProperties(Program&amp; program)
  {
<span class="line-modified">!     // The goal of this phase is two allow two things:</span>
<span class="line-added">+     // 1. For property access expressions, metal codegen should be allowed to evaluate</span>
<span class="line-added">+     // the base, and if it&#39;s an index expression, the index, as many times as needed.</span>
<span class="line-added">+     // So this patch ensures that if Metal evaluates such things, effects aren&#39;t performed</span>
<span class="line-added">+     // more than once.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // 2. For ReadModifyWrite expressions, metal codegen should be able to evaluate the</span>
<span class="line-added">+     // leftValueExpression as many times as it&#39;d like without performing the effects of</span>
<span class="line-added">+     // leftValueExpression more than once.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // We do these things because it&#39;s convenient for metal codegen to be able to rely on</span>
<span class="line-added">+     // this with the way it structures the generated code.</span>
<span class="line-added">+     PropertyResolver resolver;</span>
<span class="line-added">+     for (auto&amp; function : program.functionDefinitions())</span>
<span class="line-added">+         resolver.visit(function);</span>
  }
  
  } // namespace WHLSL
  
  } // namespace WebCore
</pre>
<center><a href="WHLSLProgram.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLPruneUnreachableStandardLibraryFunctions.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm64e.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 # Copyright (C) 2018-2019 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 13 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 14 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 16 # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 17 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 18 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 19 # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 20 # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 22 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 class ARM64E
 25     # FIXME: This is fragile and needs to match the enum value in PtrTag.h.
 26     CFunctionPtrTag = 2
 27 end
 28 
 29 class Sequence
 30     def getModifiedListARM64E
 31         result = riscLowerMisplacedAddresses(@list)
 32         getModifiedListARM64(result)
 33     end
 34 end
 35 
 36 class Instruction
 37     def self.lowerMisplacedAddressesARM64E(node, newList)
 38         wasHandled = false
 39         if node.is_a? Instruction
 40             postInstructions = []
 41             annotation = node.annotation
 42             codeOrigin = node.codeOrigin
 43             case node.opcode
 44             when &quot;jmp&quot;, &quot;call&quot;
 45                 if node.operands.size &gt; 1
 46                     if node.operands[1].is_a? RegisterID
 47                         tag = riscAsRegister(newList, postInstructions, node.operands[1], &quot;p&quot;, false)
 48                     else
 49                         tag = Tmp.new(codeOrigin, :gpr)
 50                         newList &lt;&lt; Instruction.new(codeOrigin, &quot;move&quot;, [node.operands[1], tag], annotation)
 51                     end
 52                     operands = [riscAsRegister(newList, postInstructions, node.operands[0], &quot;p&quot;, false), tag]
 53                     newList &lt;&lt; Instruction.new(codeOrigin, node.opcode, operands, annotation)
 54                     wasHandled = true
 55                 end
 56             when &quot;untagArrayPtr&quot;
 57                 newOperands = node.operands.map {
 58                     | operand |
 59                     if operand.address?
 60                         tmp = Tmp.new(codeOrigin, :gpr)
 61                         newList &lt;&lt; Instruction.new(codeOrigin, &quot;loadp&quot;, [operand, tmp], annotation)
 62                         tmp
 63                     else
 64                         operand
 65                     end
 66                 }
 67                 newList &lt;&lt; Instruction.new(codeOrigin, node.opcode, newOperands, annotation)
 68                 wasHandled = true
 69             end
 70             newList += postInstructions if wasHandled
 71         end
 72         return wasHandled, newList
 73     end
 74 
 75     def lowerARM64E
 76         case opcode
 77         when &quot;call&quot;
 78             if operands.size == 1 or operands[0].label?
 79                 lowerARM64
 80             elsif operands[1] == ARM64E::CFunctionPtrTag
 81                 emitARM64Unflipped(&quot;blraaz&quot;, [operands[0]], :ptr)
 82             else
 83                 emitARM64Unflipped(&quot;blrab&quot;, operands, :ptr)
 84             end
 85         when &quot;jmp&quot;
 86             if operands[0].label?
 87                 lowerARM64
 88             else
 89                 emitARM64Unflipped(&quot;brab&quot;, operands, :ptr)
 90             end
 91         when &quot;tagReturnAddress&quot;
 92             raise if operands.size &lt; 1 or not operands[0].is_a? RegisterID
 93             if operands[0].is_a? RegisterID and operands[0].name == &quot;sp&quot;
 94                 $asm.puts &quot;pacibsp&quot;
 95             else
 96                 emitARM64Unflipped(&quot;pacib lr,&quot;, operands, :ptr)
 97             end
 98         when &quot;untagReturnAddress&quot;
 99             raise if operands.size &lt; 1 or not operands[0].is_a? RegisterID
100             if operands[0].is_a? RegisterID and operands[0].name == &quot;sp&quot;
101                 $asm.puts &quot;autibsp&quot;
102             else
103                 emitARM64Unflipped(&quot;autib lr,&quot;, operands, :ptr)
104             end
105         when &quot;removeCodePtrTag&quot;
106             raise unless operands[0].is_a? RegisterID
107             emitARM64Unflipped(&quot;xpaci &quot;, operands, :ptr)
108         when &quot;untagArrayPtr&quot;
109             raise if operands.size != 2 or not operands.each { |operand| operand.is_a? RegisterID or operand.is_a? Tmp }
110             emitARM64(&quot;autdb &quot;, operands, :ptr)
111         when &quot;ret&quot;
112             $asm.puts &quot;retab&quot;
113         else
114             lowerARM64
115         end
116     end
117 end
    </pre>
  </body>
</html>
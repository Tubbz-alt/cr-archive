<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/generateWasmValidateInlinesHeader.py</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 
  3 # Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 #
  9 # 1.  Redistributions of source code must retain the above copyright
 10 #     notice, this list of conditions and the following disclaimer.
 11 # 2.  Redistributions in binary form must reproduce the above copyright
 12 #     notice, this list of conditions and the following disclaimer in the
 13 #     documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 # This tool has a couple of helpful macros to process Wasm files from the wasm.json.
 27 
 28 from generateWasm import *
 29 import optparse
 30 import sys
 31 
 32 parser = optparse.OptionParser(usage=&quot;usage: %prog &lt;wasm.json&gt; &lt;WasmOps.h&gt;&quot;)
 33 (options, args) = parser.parse_args(sys.argv[0:])
 34 if len(args) != 3:
 35     parser.error(parser.usage)
 36 
 37 wasm = Wasm(args[0], args[1])
 38 opcodes = wasm.opcodes
 39 wasmValidateInlinesHFile = open(args[2], &quot;w&quot;)
 40 
 41 
 42 def cppType(name):
 43     result = {
 44         &quot;bool&quot;: &quot;I32&quot;,
 45         &quot;addr&quot;: &quot;I32&quot;,
 46         &quot;i32&quot;: &quot;I32&quot;,
 47         &quot;i64&quot;: &quot;I64&quot;,
 48         &quot;f32&quot;: &quot;F32&quot;,
 49         &quot;f64&quot;: &quot;F64&quot;,
 50     }.get(name, None)
 51     if result == None:
 52         raise ValueError(&quot;Unknown type name: &quot; + name)
 53     return result
 54 
 55 
 56 def toCpp(name):
 57     return wasm.toCpp(name)
 58 
 59 
 60 def unaryMacro(name):
 61     op = opcodes[name]
 62     return &quot;&quot;&quot;
 63 template&lt;&gt; auto Validate::addOp&lt;OpType::&quot;&quot;&quot; + toCpp(name) + &quot;&quot;&quot;&gt;(ExpressionType value, ExpressionType&amp; result) -&gt; Result
 64 {
 65     if (UNLIKELY(value != &quot;&quot;&quot; + cppType(op[&quot;parameter&quot;][0]) + &quot;&quot;&quot;))
 66         return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: &quot;&quot;&quot; + name + &quot;&quot;&quot; value type mismatch&quot;);
 67 
 68     result = &quot;&quot;&quot; + cppType(op[&quot;return&quot;][0]) + &quot;&quot;&quot;;
 69     return { };
 70 }
 71 &quot;&quot;&quot;
 72 
 73 
 74 def binaryMacro(name):
 75     op = opcodes[name]
 76     return &quot;&quot;&quot;
 77 template&lt;&gt; auto Validate::addOp&lt;OpType::&quot;&quot;&quot; + toCpp(name) + &quot;&quot;&quot;&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; Result
 78 {
 79     if (UNLIKELY(left != &quot;&quot;&quot; + cppType(op[&quot;parameter&quot;][0]) + &quot;&quot;&quot;))
 80         return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: &quot;&quot;&quot; + name + &quot;&quot;&quot; left value type mismatch&quot;);
 81 
 82     if (UNLIKELY(right != &quot;&quot;&quot; + cppType(op[&quot;parameter&quot;][1]) + &quot;&quot;&quot;))
 83         return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: &quot;&quot;&quot; + name + &quot;&quot;&quot; right value type mismatch&quot;);
 84 
 85     result = &quot;&quot;&quot; + cppType(op[&quot;return&quot;][0]) + &quot;&quot;&quot;;
 86     return { };
 87 }
 88 &quot;&quot;&quot;
 89 
 90 def loadMacro(name):
 91     op = opcodes[name]
 92     return &quot;&quot;&quot;
 93     case LoadOpType::&quot;&quot;&quot; + toCpp(name) + &quot;&quot;&quot;: {
 94         if (UNLIKELY(pointer != &quot;&quot;&quot; + cppType(op[&quot;parameter&quot;][0]) + &quot;&quot;&quot;))
 95             return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: &quot;&quot;&quot; + name + &quot;&quot;&quot; pointer type mismatch&quot;);
 96 
 97         result = &quot;&quot;&quot; + cppType(op[&quot;return&quot;][0]) + &quot;&quot;&quot;;
 98         return { };
 99     }&quot;&quot;&quot;
100 
101 
102 def storeMacro(name):
103     op = opcodes[name]
104     return &quot;&quot;&quot;
105     case StoreOpType::&quot;&quot;&quot; + toCpp(name) + &quot;&quot;&quot;: {
106         if (UNLIKELY(pointer != &quot;&quot;&quot; + cppType(op[&quot;parameter&quot;][0]) + &quot;&quot;&quot;))
107             return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: &quot;&quot;&quot; + name + &quot;&quot;&quot; pointer type mismatch&quot;);
108 
109         if (UNLIKELY(value != &quot;&quot;&quot; + cppType(op[&quot;parameter&quot;][1]) + &quot;&quot;&quot;))
110             return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: &quot;&quot;&quot; + name + &quot;&quot;&quot; value type mismatch&quot;);
111 
112         return { };
113     }&quot;&quot;&quot;
114 
115 
116 unarySpecializations = &quot;&quot;.join([op for op in wasm.opcodeIterator(isUnary, unaryMacro)])
117 binarySpecializations = &quot;&quot;.join([op for op in wasm.opcodeIterator(isBinary, binaryMacro)])
118 loadCases = &quot;&quot;.join([op for op in wasm.opcodeIterator(lambda op: op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1, loadMacro)])
119 storeCases = &quot;&quot;.join([op for op in wasm.opcodeIterator(lambda op: op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0, storeMacro)])
120 
121 contents = wasm.header + &quot;&quot;&quot;
122 // This file is intended to be inlined by WasmValidate.cpp only! It should not be included elsewhere.
123 
124 #pragma once
125 
126 #if ENABLE(WEBASSEMBLY)
127 
128 #include &lt;wtf/StdLibExtras.h&gt;
129 
130 #if ASSERT_DISABLED
131 IGNORE_RETURN_TYPE_WARNINGS_BEGIN
132 #endif
133 
134 namespace JSC { namespace Wasm {
135 
136 &quot;&quot;&quot; + unarySpecializations + binarySpecializations + &quot;&quot;&quot;
137 
138 auto Validate::load(LoadOpType op, ExpressionType pointer, ExpressionType&amp; result, uint32_t) -&gt; Result
139 {
140     if (UNLIKELY(!hasMemory()))
141         return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: load instruction without memory&quot;);
142 
143     switch (op) {
144 &quot;&quot;&quot; + loadCases + &quot;&quot;&quot;
145     }
146     ASSERT_NOT_REACHED();
147 }
148 
149 auto Validate::store(StoreOpType op, ExpressionType pointer, ExpressionType value, uint32_t) -&gt; Result
150 {
151     if (UNLIKELY(!hasMemory()))
152         return Unexpected&lt;Result::error_type&gt;(&quot;validation failed: store instruction without memory&quot;);
153 
154     switch (op) {
155 &quot;&quot;&quot; + storeCases + &quot;&quot;&quot;
156     }
157     ASSERT_NOT_REACHED();
158 }
159 
160 } } // namespace JSC::Wasm
161 
162 #if ASSERT_DISABLED
163 IGNORE_RETURN_TYPE_WARNINGS_END
164 #endif
165 
166 #endif // ENABLE(WEBASSEMBLY)
167 
168 &quot;&quot;&quot;
169 
170 wasmValidateInlinesHFile.write(contents)
171 wasmValidateInlinesHFile.close()
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/NodeRareData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NodeRareData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OverflowEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/NodeRareData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008, 2010 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2008 David Smith &lt;catfish.man@gmail.com&gt;
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ChildNodeList.h&quot;
 25 #include &quot;HTMLCollection.h&quot;
<span class="line-removed"> 26 #include &quot;HTMLNames.h&quot;</span>
<span class="line-removed"> 27 #include &quot;LiveNodeList.h&quot;</span>
 28 #include &quot;MutationObserverRegistration.h&quot;
 29 #include &quot;QualifiedName.h&quot;
 30 #include &quot;TagCollection.h&quot;
 31 #include &lt;wtf/HashSet.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
<span class="line-removed"> 33 #include &lt;wtf/text/AtomString.h&gt;</span>
 34 
 35 namespace WebCore {
 36 
 37 class LabelsNodeList;

 38 class NameNodeList;
 39 class RadioNodeList;
<span class="line-removed"> 40 class TreeScope;</span>
 41 
<span class="line-modified"> 42 template &lt;class ListType&gt; struct NodeListTypeIdentifier;</span>
<span class="line-removed"> 43 template &lt;&gt; struct NodeListTypeIdentifier&lt;NameNodeList&gt; { static int value() { return 0; } };</span>
<span class="line-removed"> 44 template &lt;&gt; struct NodeListTypeIdentifier&lt;RadioNodeList&gt; { static int value() { return 1; } };</span>
<span class="line-removed"> 45 template &lt;&gt; struct NodeListTypeIdentifier&lt;LabelsNodeList&gt; { static int value() { return 2; } };</span>
 46 

 47 class NodeListsNodeData {
<span class="line-modified"> 48     WTF_MAKE_NONCOPYABLE(NodeListsNodeData); WTF_MAKE_FAST_ALLOCATED;</span>

 49 public:
<span class="line-modified"> 50     NodeListsNodeData()</span>
<span class="line-removed"> 51         : m_childNodeList(nullptr)</span>
<span class="line-removed"> 52         , m_emptyChildNodeList(nullptr)</span>
<span class="line-removed"> 53     {</span>
<span class="line-removed"> 54     }</span>
 55 
 56     void clearChildNodeListCache()
 57     {
 58         if (m_childNodeList)
 59             m_childNodeList-&gt;invalidateCache();
 60     }
 61 
 62     Ref&lt;ChildNodeList&gt; ensureChildNodeList(ContainerNode&amp; node)
 63     {
 64         ASSERT(!m_emptyChildNodeList);
 65         if (m_childNodeList)
 66             return *m_childNodeList;
 67         auto list = ChildNodeList::create(node);
 68         m_childNodeList = list.ptr();
 69         return list;
 70     }
 71 
 72     void removeChildNodeList(ChildNodeList* list)
 73     {
 74         ASSERT(m_childNodeList == list);
</pre>
<hr />
<pre>
 87         return list;
 88     }
 89 
 90     void removeEmptyChildNodeList(EmptyNodeList* list)
 91     {
 92         ASSERT(m_emptyChildNodeList == list);
 93         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(list-&gt;ownerNode()))
 94             return;
 95         m_emptyChildNodeList = nullptr;
 96     }
 97 
 98     struct NodeListCacheMapEntryHash {
 99         static unsigned hash(const std::pair&lt;unsigned char, AtomString&gt;&amp; entry)
100         {
101             return DefaultHash&lt;AtomString&gt;::Hash::hash(entry.second) + entry.first;
102         }
103         static bool equal(const std::pair&lt;unsigned char, AtomString&gt;&amp; a, const std::pair&lt;unsigned char, AtomString&gt;&amp; b) { return a.first == b.first &amp;&amp; DefaultHash&lt;AtomString&gt;::Hash::equal(a.second, b.second); }
104         static const bool safeToCompareToEmptyOrDeleted = DefaultHash&lt;AtomString&gt;::Hash::safeToCompareToEmptyOrDeleted;
105     };
106 
<span class="line-modified">107     typedef HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, LiveNodeList*, NodeListCacheMapEntryHash&gt; NodeListAtomicNameCacheMap;</span>
<span class="line-modified">108     typedef HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, HTMLCollection*, NodeListCacheMapEntryHash&gt; CollectionCacheMap;</span>
<span class="line-modified">109     typedef HashMap&lt;QualifiedName, TagCollectionNS*&gt; TagCollectionNSCache;</span>
110 
111     template&lt;typename T, typename ContainerType&gt;
<span class="line-modified">112     ALWAYS_INLINE Ref&lt;T&gt; addCacheWithAtomicName(ContainerType&amp; container, const AtomString&amp; name)</span>
113     {
<span class="line-modified">114         NodeListAtomicNameCacheMap::AddResult result = m_atomicNameCaches.fastAdd(namedNodeListKey&lt;T&gt;(name), nullptr);</span>
115         if (!result.isNewEntry)
116             return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
117 
118         auto list = T::create(container, name);
119         result.iterator-&gt;value = &amp;list.get();
120         return list;
121     }
122 
123     ALWAYS_INLINE Ref&lt;TagCollectionNS&gt; addCachedTagCollectionNS(ContainerNode&amp; node, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
124     {
<span class="line-modified">125         QualifiedName name(nullAtom(), localName, namespaceURI);</span>
<span class="line-removed">126         TagCollectionNSCache::AddResult result = m_tagCollectionNSCache.fastAdd(name, nullptr);</span>
127         if (!result.isNewEntry)
128             return *result.iterator-&gt;value;
129 
130         auto list = TagCollectionNS::create(node, namespaceURI, localName);
131         result.iterator-&gt;value = list.ptr();
132         return list;
133     }
134 
135     template&lt;typename T, typename ContainerType&gt;
136     ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType, const AtomString&amp; name)
137     {
<span class="line-modified">138         CollectionCacheMap::AddResult result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, name), nullptr);</span>
139         if (!result.isNewEntry)
140             return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
141 
142         auto list = T::create(container, collectionType, name);
143         result.iterator-&gt;value = &amp;list.get();
144         return list;
145     }
146 
147     template&lt;typename T, typename ContainerType&gt;
148     ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType)
149     {
<span class="line-modified">150         CollectionCacheMap::AddResult result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, starAtom()), nullptr);</span>
151         if (!result.isNewEntry)
152             return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
153 
154         auto list = T::create(container, collectionType);
155         result.iterator-&gt;value = &amp;list.get();
156         return list;
157     }
158 
159     template&lt;typename T&gt;
160     T* cachedCollection(CollectionType collectionType)
161     {
162         return static_cast&lt;T*&gt;(m_cachedCollections.get(namedCollectionKey(collectionType, starAtom())));
163     }
164 
<span class="line-modified">165     template &lt;class NodeListType&gt;</span>
<span class="line-modified">166     void removeCacheWithAtomicName(NodeListType* list, const AtomString&amp; name = starAtom())</span>
167     {
<span class="line-modified">168         ASSERT(list == m_atomicNameCaches.get(namedNodeListKey&lt;NodeListType&gt;(name)));</span>
<span class="line-modified">169         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(list-&gt;ownerNode()))</span>
170             return;
<span class="line-modified">171         m_atomicNameCaches.remove(namedNodeListKey&lt;NodeListType&gt;(name));</span>
172     }
173 
174     void removeCachedTagCollectionNS(HTMLCollection&amp; collection, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
175     {
176         QualifiedName name(nullAtom(), localName, namespaceURI);
177         ASSERT(&amp;collection == m_tagCollectionNSCache.get(name));
178         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(collection.ownerNode()))
179             return;
180         m_tagCollectionNSCache.remove(name);
181     }
182 
183     void removeCachedCollection(HTMLCollection* collection, const AtomString&amp; name = starAtom())
184     {
185         ASSERT(collection == m_cachedCollections.get(namedCollectionKey(collection-&gt;type(), name)));
186         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(collection-&gt;ownerNode()))
187             return;
188         m_cachedCollections.remove(namedCollectionKey(collection-&gt;type(), name));
189     }
190 
191     void invalidateCaches();
192     void invalidateCachesForAttribute(const QualifiedName&amp; attrName);
193 
194     void adoptTreeScope()
195     {
196         invalidateCaches();
197     }
198 
199     void adoptDocument(Document&amp; oldDocument, Document&amp; newDocument)
200     {
201         if (&amp;oldDocument == &amp;newDocument) {
202             invalidateCaches();
203             return;
204         }
205 
<span class="line-modified">206         for (auto&amp; cache : m_atomicNameCaches.values())</span>
207             cache-&gt;invalidateCacheForDocument(oldDocument);
208 
209         for (auto&amp; list : m_tagCollectionNSCache.values()) {
210             ASSERT(!list-&gt;isRootedAtDocument());
211             list-&gt;invalidateCacheForDocument(oldDocument);
212         }
213 
214         for (auto&amp; collection : m_cachedCollections.values())
215             collection-&gt;invalidateCacheForDocument(oldDocument);
216     }
217 
218 private:
219     std::pair&lt;unsigned char, AtomString&gt; namedCollectionKey(CollectionType type, const AtomString&amp; name)
220     {
221         return std::pair&lt;unsigned char, AtomString&gt;(type, name);
222     }
223 
<span class="line-modified">224     template &lt;class NodeListType&gt;</span>
225     std::pair&lt;unsigned char, AtomString&gt; namedNodeListKey(const AtomString&amp; name)
226     {
227         return std::pair&lt;unsigned char, AtomString&gt;(NodeListTypeIdentifier&lt;NodeListType&gt;::value(), name);
228     }
229 
230     bool deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp;);
231 
232     // These two are currently mutually exclusive and could be unioned. Not very important as this class is large anyway.
<span class="line-modified">233     ChildNodeList* m_childNodeList;</span>
<span class="line-modified">234     EmptyNodeList* m_emptyChildNodeList;</span>
235 
<span class="line-modified">236     NodeListAtomicNameCacheMap m_atomicNameCaches;</span>
237     TagCollectionNSCache m_tagCollectionNSCache;
238     CollectionCacheMap m_cachedCollections;
239 };
240 
241 class NodeMutationObserverData {
242     WTF_MAKE_NONCOPYABLE(NodeMutationObserverData); WTF_MAKE_FAST_ALLOCATED;
243 public:
244     Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt; registry;
245     HashSet&lt;MutationObserverRegistration*&gt; transientRegistry;
246 
247     NodeMutationObserverData() { }
248 };
249 

250 class NodeRareData {
<span class="line-modified">251     WTF_MAKE_NONCOPYABLE(NodeRareData); WTF_MAKE_FAST_ALLOCATED;</span>

252 public:
253 #if defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS
254     enum class UseType : uint16_t {
255         ConnectedFrameCount = 1 &lt;&lt; 0,
256         NodeList = 1 &lt;&lt; 1,
257         MutationObserver = 1 &lt;&lt; 2,
258 
259         TabIndex = 1 &lt;&lt; 3,
260         MinimumSize = 1 &lt;&lt; 4,
261         ScrollingPosition = 1 &lt;&lt; 5,
262         ComputedStyle = 1 &lt;&lt; 6,
263         Dataset = 1 &lt;&lt; 7,
264         ClassList = 1 &lt;&lt; 8,
265         ShadowRoot = 1 &lt;&lt; 9,
266         CustomElementQueue = 1 &lt;&lt; 10,
267         AttributeMap = 1 &lt;&lt; 11,
268         InteractionObserver = 1 &lt;&lt; 12,
269         PseudoElements = 1 &lt;&lt; 13,
270     };
271 #endif
</pre>
<hr />
<pre>
314     {
315         OptionSet&lt;UseType&gt; result;
316         if (m_connectedFrameCount)
317             result.add(UseType::ConnectedFrameCount);
318         if (m_nodeLists)
319             result.add(UseType::NodeList);
320         if (m_mutationObserverData)
321             result.add(UseType::MutationObserver);
322         return result;
323     }
324 #endif
325 
326 private:
327     unsigned m_connectedFrameCount : 31; // Must fit Page::maxNumberOfFrames.
328     unsigned m_isElementRareData : 1;
329 
330     std::unique_ptr&lt;NodeListsNodeData&gt; m_nodeLists;
331     std::unique_ptr&lt;NodeMutationObserverData&gt; m_mutationObserverData;
332 };
333 












334 inline bool NodeListsNodeData::deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp; ownerNode)
335 {
336     ASSERT(ownerNode.nodeLists() == this);
<span class="line-modified">337     if ((m_childNodeList ? 1 : 0) + (m_emptyChildNodeList ? 1 : 0) + m_atomicNameCaches.size()</span>
<span class="line-modified">338         + m_tagCollectionNSCache.size() + m_cachedCollections.size() != 1)</span>




339         return false;
340     ownerNode.clearNodeLists();
341     return true;
342 }
343 
344 inline NodeRareData&amp; Node::ensureRareData()
345 {
346     if (!hasRareData())
347         materializeRareData();
348     return *rareData();
349 }
350 
351 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2008 David Smith &lt;catfish.man@gmail.com&gt;
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ChildNodeList.h&quot;
 25 #include &quot;HTMLCollection.h&quot;


 26 #include &quot;MutationObserverRegistration.h&quot;
 27 #include &quot;QualifiedName.h&quot;
 28 #include &quot;TagCollection.h&quot;
 29 #include &lt;wtf/HashSet.h&gt;
 30 #include &lt;wtf/StdLibExtras.h&gt;

 31 
 32 namespace WebCore {
 33 
 34 class LabelsNodeList;
<span class="line-added"> 35 class LiveNodeList;</span>
 36 class NameNodeList;
 37 class RadioNodeList;

 38 
<span class="line-modified"> 39 template&lt;typename ListType&gt; struct NodeListTypeIdentifier;</span>



 40 
<span class="line-added"> 41 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(NodeListsNodeData);</span>
 42 class NodeListsNodeData {
<span class="line-modified"> 43     WTF_MAKE_NONCOPYABLE(NodeListsNodeData);</span>
<span class="line-added"> 44     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(NodeListsNodeData);</span>
 45 public:
<span class="line-modified"> 46     NodeListsNodeData() = default;</span>




 47 
 48     void clearChildNodeListCache()
 49     {
 50         if (m_childNodeList)
 51             m_childNodeList-&gt;invalidateCache();
 52     }
 53 
 54     Ref&lt;ChildNodeList&gt; ensureChildNodeList(ContainerNode&amp; node)
 55     {
 56         ASSERT(!m_emptyChildNodeList);
 57         if (m_childNodeList)
 58             return *m_childNodeList;
 59         auto list = ChildNodeList::create(node);
 60         m_childNodeList = list.ptr();
 61         return list;
 62     }
 63 
 64     void removeChildNodeList(ChildNodeList* list)
 65     {
 66         ASSERT(m_childNodeList == list);
</pre>
<hr />
<pre>
 79         return list;
 80     }
 81 
 82     void removeEmptyChildNodeList(EmptyNodeList* list)
 83     {
 84         ASSERT(m_emptyChildNodeList == list);
 85         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(list-&gt;ownerNode()))
 86             return;
 87         m_emptyChildNodeList = nullptr;
 88     }
 89 
 90     struct NodeListCacheMapEntryHash {
 91         static unsigned hash(const std::pair&lt;unsigned char, AtomString&gt;&amp; entry)
 92         {
 93             return DefaultHash&lt;AtomString&gt;::Hash::hash(entry.second) + entry.first;
 94         }
 95         static bool equal(const std::pair&lt;unsigned char, AtomString&gt;&amp; a, const std::pair&lt;unsigned char, AtomString&gt;&amp; b) { return a.first == b.first &amp;&amp; DefaultHash&lt;AtomString&gt;::Hash::equal(a.second, b.second); }
 96         static const bool safeToCompareToEmptyOrDeleted = DefaultHash&lt;AtomString&gt;::Hash::safeToCompareToEmptyOrDeleted;
 97     };
 98 
<span class="line-modified"> 99     using NodeListCacheMap = HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, LiveNodeList*, NodeListCacheMapEntryHash&gt;;</span>
<span class="line-modified">100     using CollectionCacheMap = HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, HTMLCollection*, NodeListCacheMapEntryHash&gt;;</span>
<span class="line-modified">101     using TagCollectionNSCache = HashMap&lt;QualifiedName, TagCollectionNS*&gt;;</span>
102 
103     template&lt;typename T, typename ContainerType&gt;
<span class="line-modified">104     ALWAYS_INLINE Ref&lt;T&gt; addCacheWithAtomName(ContainerType&amp; container, const AtomString&amp; name)</span>
105     {
<span class="line-modified">106         auto result = m_atomNameCaches.fastAdd(namedNodeListKey&lt;T&gt;(name), nullptr);</span>
107         if (!result.isNewEntry)
108             return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
109 
110         auto list = T::create(container, name);
111         result.iterator-&gt;value = &amp;list.get();
112         return list;
113     }
114 
115     ALWAYS_INLINE Ref&lt;TagCollectionNS&gt; addCachedTagCollectionNS(ContainerNode&amp; node, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
116     {
<span class="line-modified">117         auto result = m_tagCollectionNSCache.fastAdd(QualifiedName { nullAtom(), localName, namespaceURI }, nullptr);</span>

118         if (!result.isNewEntry)
119             return *result.iterator-&gt;value;
120 
121         auto list = TagCollectionNS::create(node, namespaceURI, localName);
122         result.iterator-&gt;value = list.ptr();
123         return list;
124     }
125 
126     template&lt;typename T, typename ContainerType&gt;
127     ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType, const AtomString&amp; name)
128     {
<span class="line-modified">129         auto result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, name), nullptr);</span>
130         if (!result.isNewEntry)
131             return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
132 
133         auto list = T::create(container, collectionType, name);
134         result.iterator-&gt;value = &amp;list.get();
135         return list;
136     }
137 
138     template&lt;typename T, typename ContainerType&gt;
139     ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType)
140     {
<span class="line-modified">141         auto result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, starAtom()), nullptr);</span>
142         if (!result.isNewEntry)
143             return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
144 
145         auto list = T::create(container, collectionType);
146         result.iterator-&gt;value = &amp;list.get();
147         return list;
148     }
149 
150     template&lt;typename T&gt;
151     T* cachedCollection(CollectionType collectionType)
152     {
153         return static_cast&lt;T*&gt;(m_cachedCollections.get(namedCollectionKey(collectionType, starAtom())));
154     }
155 
<span class="line-modified">156     template&lt;typename NodeListType&gt;</span>
<span class="line-modified">157     void removeCacheWithAtomName(NodeListType&amp; list, const AtomString&amp; name)</span>
158     {
<span class="line-modified">159         ASSERT(&amp;list == m_atomNameCaches.get(namedNodeListKey&lt;NodeListType&gt;(name)));</span>
<span class="line-modified">160         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(list.ownerNode()))</span>
161             return;
<span class="line-modified">162         m_atomNameCaches.remove(namedNodeListKey&lt;NodeListType&gt;(name));</span>
163     }
164 
165     void removeCachedTagCollectionNS(HTMLCollection&amp; collection, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
166     {
167         QualifiedName name(nullAtom(), localName, namespaceURI);
168         ASSERT(&amp;collection == m_tagCollectionNSCache.get(name));
169         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(collection.ownerNode()))
170             return;
171         m_tagCollectionNSCache.remove(name);
172     }
173 
174     void removeCachedCollection(HTMLCollection* collection, const AtomString&amp; name = starAtom())
175     {
176         ASSERT(collection == m_cachedCollections.get(namedCollectionKey(collection-&gt;type(), name)));
177         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(collection-&gt;ownerNode()))
178             return;
179         m_cachedCollections.remove(namedCollectionKey(collection-&gt;type(), name));
180     }
181 
182     void invalidateCaches();
183     void invalidateCachesForAttribute(const QualifiedName&amp; attrName);
184 
185     void adoptTreeScope()
186     {
187         invalidateCaches();
188     }
189 
190     void adoptDocument(Document&amp; oldDocument, Document&amp; newDocument)
191     {
192         if (&amp;oldDocument == &amp;newDocument) {
193             invalidateCaches();
194             return;
195         }
196 
<span class="line-modified">197         for (auto&amp; cache : m_atomNameCaches.values())</span>
198             cache-&gt;invalidateCacheForDocument(oldDocument);
199 
200         for (auto&amp; list : m_tagCollectionNSCache.values()) {
201             ASSERT(!list-&gt;isRootedAtDocument());
202             list-&gt;invalidateCacheForDocument(oldDocument);
203         }
204 
205         for (auto&amp; collection : m_cachedCollections.values())
206             collection-&gt;invalidateCacheForDocument(oldDocument);
207     }
208 
209 private:
210     std::pair&lt;unsigned char, AtomString&gt; namedCollectionKey(CollectionType type, const AtomString&amp; name)
211     {
212         return std::pair&lt;unsigned char, AtomString&gt;(type, name);
213     }
214 
<span class="line-modified">215     template&lt;typename NodeListType&gt;</span>
216     std::pair&lt;unsigned char, AtomString&gt; namedNodeListKey(const AtomString&amp; name)
217     {
218         return std::pair&lt;unsigned char, AtomString&gt;(NodeListTypeIdentifier&lt;NodeListType&gt;::value(), name);
219     }
220 
221     bool deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp;);
222 
223     // These two are currently mutually exclusive and could be unioned. Not very important as this class is large anyway.
<span class="line-modified">224     ChildNodeList* m_childNodeList { nullptr };</span>
<span class="line-modified">225     EmptyNodeList* m_emptyChildNodeList { nullptr };</span>
226 
<span class="line-modified">227     NodeListCacheMap m_atomNameCaches;</span>
228     TagCollectionNSCache m_tagCollectionNSCache;
229     CollectionCacheMap m_cachedCollections;
230 };
231 
232 class NodeMutationObserverData {
233     WTF_MAKE_NONCOPYABLE(NodeMutationObserverData); WTF_MAKE_FAST_ALLOCATED;
234 public:
235     Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt; registry;
236     HashSet&lt;MutationObserverRegistration*&gt; transientRegistry;
237 
238     NodeMutationObserverData() { }
239 };
240 
<span class="line-added">241 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(NodeRareData);</span>
242 class NodeRareData {
<span class="line-modified">243     WTF_MAKE_NONCOPYABLE(NodeRareData);</span>
<span class="line-added">244     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(NodeRareData);</span>
245 public:
246 #if defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS
247     enum class UseType : uint16_t {
248         ConnectedFrameCount = 1 &lt;&lt; 0,
249         NodeList = 1 &lt;&lt; 1,
250         MutationObserver = 1 &lt;&lt; 2,
251 
252         TabIndex = 1 &lt;&lt; 3,
253         MinimumSize = 1 &lt;&lt; 4,
254         ScrollingPosition = 1 &lt;&lt; 5,
255         ComputedStyle = 1 &lt;&lt; 6,
256         Dataset = 1 &lt;&lt; 7,
257         ClassList = 1 &lt;&lt; 8,
258         ShadowRoot = 1 &lt;&lt; 9,
259         CustomElementQueue = 1 &lt;&lt; 10,
260         AttributeMap = 1 &lt;&lt; 11,
261         InteractionObserver = 1 &lt;&lt; 12,
262         PseudoElements = 1 &lt;&lt; 13,
263     };
264 #endif
</pre>
<hr />
<pre>
307     {
308         OptionSet&lt;UseType&gt; result;
309         if (m_connectedFrameCount)
310             result.add(UseType::ConnectedFrameCount);
311         if (m_nodeLists)
312             result.add(UseType::NodeList);
313         if (m_mutationObserverData)
314             result.add(UseType::MutationObserver);
315         return result;
316     }
317 #endif
318 
319 private:
320     unsigned m_connectedFrameCount : 31; // Must fit Page::maxNumberOfFrames.
321     unsigned m_isElementRareData : 1;
322 
323     std::unique_ptr&lt;NodeListsNodeData&gt; m_nodeLists;
324     std::unique_ptr&lt;NodeMutationObserverData&gt; m_mutationObserverData;
325 };
326 
<span class="line-added">327 template&lt;&gt; struct NodeListTypeIdentifier&lt;NameNodeList&gt; {</span>
<span class="line-added">328     static constexpr unsigned char value() { return 0; }</span>
<span class="line-added">329 };</span>
<span class="line-added">330 </span>
<span class="line-added">331 template&lt;&gt; struct NodeListTypeIdentifier&lt;RadioNodeList&gt; {</span>
<span class="line-added">332     static constexpr unsigned char value() { return 1; }</span>
<span class="line-added">333 };</span>
<span class="line-added">334 </span>
<span class="line-added">335 template&lt;&gt; struct NodeListTypeIdentifier&lt;LabelsNodeList&gt; {</span>
<span class="line-added">336     static constexpr unsigned char value() { return 2; }</span>
<span class="line-added">337 };</span>
<span class="line-added">338 </span>
339 inline bool NodeListsNodeData::deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp; ownerNode)
340 {
341     ASSERT(ownerNode.nodeLists() == this);
<span class="line-modified">342     size_t listsCount = (m_childNodeList ? 1 : 0)</span>
<span class="line-modified">343         + (m_emptyChildNodeList ? 1 : 0)</span>
<span class="line-added">344         + m_atomNameCaches.size()</span>
<span class="line-added">345         + m_tagCollectionNSCache.size()</span>
<span class="line-added">346         + m_cachedCollections.size();</span>
<span class="line-added">347     if (listsCount != 1)</span>
348         return false;
349     ownerNode.clearNodeLists();
350     return true;
351 }
352 
353 inline NodeRareData&amp; Node::ensureRareData()
354 {
355     if (!hasRareData())
356         materializeRareData();
357     return *rareData();
358 }
359 
360 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="NodeRareData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OverflowEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Breakpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Debugger.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,51 ***</span>
  #include &quot;MarkedSpaceInlines.h&quot;
  #include &quot;Parser.h&quot;
  #include &quot;Protect.h&quot;
  #include &quot;VMEntryScope.h&quot;
  
<span class="line-removed">- namespace {</span>
<span class="line-removed">- </span>
<span class="line-removed">- using namespace JSC;</span>
<span class="line-removed">- </span>
<span class="line-removed">- struct GatherSourceProviders : public MarkedBlock::VoidFunctor {</span>
<span class="line-removed">-     // FIXME: This is a mutable field because this isn&#39;t a C++ lambda.</span>
<span class="line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=159644</span>
<span class="line-removed">-     mutable HashSet&lt;SourceProvider*&gt; sourceProviders;</span>
<span class="line-removed">-     JSGlobalObject* m_globalObject;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     GatherSourceProviders(JSGlobalObject* globalObject)</span>
<span class="line-removed">-         : m_globalObject(globalObject) { }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IterationStatus operator()(HeapCell* heapCell, HeapCell::Kind kind) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (!isJSCellKind(kind))</span>
<span class="line-removed">-             return IterationStatus::Continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         JSCell* cell = static_cast&lt;JSCell*&gt;(heapCell);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(cell-&gt;vm(), cell);</span>
<span class="line-removed">-         if (!function)</span>
<span class="line-removed">-             return IterationStatus::Continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (function-&gt;scope()-&gt;globalObject() != m_globalObject)</span>
<span class="line-removed">-             return IterationStatus::Continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!function-&gt;executable()-&gt;isFunctionExecutable())</span>
<span class="line-removed">-             return IterationStatus::Continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (function-&gt;isHostOrBuiltinFunction())</span>
<span class="line-removed">-             return IterationStatus::Continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         sourceProviders.add(</span>
<span class="line-removed">-             jsCast&lt;FunctionExecutable*&gt;(function-&gt;executable())-&gt;source().provider());</span>
<span class="line-removed">-         return IterationStatus::Continue;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- } // namespace</span>
<span class="line-removed">- </span>
  namespace JSC {
  
  class DebuggerPausedScope {
  public:
      DebuggerPausedScope(Debugger&amp; debugger)
<span class="line-new-header">--- 34,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,27 ***</span>
      globalObject-&gt;setDebugger(this);
      m_globalObjects.add(globalObject);
  
      m_vm.setShouldBuildPCToCodeOriginMapping();
  
<span class="line-modified">!     // Call sourceParsed because it will execute JavaScript in the inspector.</span>
<span class="line-modified">!     GatherSourceProviders gatherSourceProviders(globalObject);</span>
      {
          HeapIterationScope iterationScope(m_vm.heap);
<span class="line-modified">!         m_vm.heap.objectSpace().forEachLiveCell(iterationScope, gatherSourceProviders);</span>
      }
<span class="line-modified">!     for (auto* sourceProvider : gatherSourceProviders.sourceProviders)</span>
<span class="line-modified">!         sourceParsed(globalObject-&gt;globalExec(), sourceProvider, -1, String());</span>
  }
  
  void Debugger::detach(JSGlobalObject* globalObject, ReasonForDetach reason)
  {
      // If we&#39;re detaching from the currently executing global object, manually tear down our
      // stack, since we won&#39;t get further debugger callbacks to do so. Also, resume execution,
      // since there&#39;s no point in staying paused once a window closes.
      // We know there is an entry scope, otherwise, m_currentCallFrame would be null.
      VM&amp; vm = globalObject-&gt;vm();
      if (m_isPaused &amp;&amp; m_currentCallFrame &amp;&amp; vm.entryScope-&gt;globalObject() == globalObject) {
          m_currentCallFrame = nullptr;
          m_pauseOnCallFrame = nullptr;
          continueProgram();
      }
<span class="line-new-header">--- 114,38 ---</span>
      globalObject-&gt;setDebugger(this);
      m_globalObjects.add(globalObject);
  
      m_vm.setShouldBuildPCToCodeOriginMapping();
  
<span class="line-modified">!     // Call `sourceParsed` after iterating because it will execute JavaScript in Web Inspector.</span>
<span class="line-modified">!     HashSet&lt;RefPtr&lt;SourceProvider&gt;&gt; sourceProviders;</span>
      {
          HeapIterationScope iterationScope(m_vm.heap);
<span class="line-modified">!         m_vm.heap.objectSpace().forEachLiveCell(iterationScope, [&amp;] (HeapCell* heapCell, HeapCell::Kind kind) {</span>
<span class="line-added">+             if (isJSCellKind(kind)) {</span>
<span class="line-added">+                 auto* cell = static_cast&lt;JSCell*&gt;(heapCell);</span>
<span class="line-added">+                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(cell-&gt;vm(), cell)) {</span>
<span class="line-added">+                     if (function-&gt;scope()-&gt;globalObject() == globalObject &amp;&amp; function-&gt;executable()-&gt;isFunctionExecutable() &amp;&amp; !function-&gt;isHostOrBuiltinFunction())</span>
<span class="line-added">+                         sourceProviders.add(jsCast&lt;FunctionExecutable*&gt;(function-&gt;executable())-&gt;source().provider());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return IterationStatus::Continue;</span>
<span class="line-added">+         });</span>
      }
<span class="line-modified">!     for (auto&amp; sourceProvider : sourceProviders)</span>
<span class="line-modified">!         sourceParsed(globalObject, sourceProvider.get(), -1, nullString());</span>
  }
  
  void Debugger::detach(JSGlobalObject* globalObject, ReasonForDetach reason)
  {
      // If we&#39;re detaching from the currently executing global object, manually tear down our
      // stack, since we won&#39;t get further debugger callbacks to do so. Also, resume execution,
      // since there&#39;s no point in staying paused once a window closes.
      // We know there is an entry scope, otherwise, m_currentCallFrame would be null.
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-added">+     JSLockHolder locker(vm);</span>
<span class="line-added">+ </span>
      if (m_isPaused &amp;&amp; m_currentCallFrame &amp;&amp; vm.entryScope-&gt;globalObject() == globalObject) {
          m_currentCallFrame = nullptr;
          m_pauseOnCallFrame = nullptr;
          continueProgram();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,26 ***</span>
  
      SourceID sourceID = static_cast&lt;SourceID&gt;(executable-&gt;sourceID());
      if (breakpoint.sourceID != sourceID)
          return;
  
<span class="line-removed">-     unsigned line = breakpoint.line;</span>
<span class="line-removed">-     unsigned column = breakpoint.column;</span>
<span class="line-removed">- </span>
      unsigned startLine = executable-&gt;firstLine();
      unsigned startColumn = executable-&gt;startColumn();
      unsigned endLine = executable-&gt;lastLine();
      unsigned endColumn = executable-&gt;endColumn();
  
      // Inspector breakpoint line and column values are zero-based but the executable
      // and CodeBlock line and column values are one-based.
<span class="line-modified">!     line += 1;</span>
<span class="line-modified">!     column = column ? column + 1 : Breakpoint::unspecifiedColumn;</span>
  
      if (line &lt; startLine || line &gt; endLine)
          return;
<span class="line-modified">!     if (column != Breakpoint::unspecifiedColumn) {</span>
          if (line == startLine &amp;&amp; column &lt; startColumn)
              return;
          if (line == endLine &amp;&amp; column &gt; endColumn)
              return;
      }
<span class="line-new-header">--- 236,25 ---</span>
  
      SourceID sourceID = static_cast&lt;SourceID&gt;(executable-&gt;sourceID());
      if (breakpoint.sourceID != sourceID)
          return;
  
      unsigned startLine = executable-&gt;firstLine();
      unsigned startColumn = executable-&gt;startColumn();
      unsigned endLine = executable-&gt;lastLine();
      unsigned endColumn = executable-&gt;endColumn();
  
      // Inspector breakpoint line and column values are zero-based but the executable
      // and CodeBlock line and column values are one-based.
<span class="line-modified">!     unsigned line = breakpoint.line + 1;</span>
<span class="line-modified">!     Optional&lt;unsigned&gt; column;</span>
<span class="line-added">+     if (breakpoint.column)</span>
<span class="line-added">+         column = breakpoint.column + 1;</span>
  
      if (line &lt; startLine || line &gt; endLine)
          return;
<span class="line-modified">!     if (column) {</span>
          if (line == startLine &amp;&amp; column &lt; startColumn)
              return;
          if (line == endLine &amp;&amp; column &gt; endColumn)
              return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,24 ***</span>
      RELEASE_ASSERT(!breakpoint.resolved);
      ASSERT(breakpoint.sourceID != noSourceID);
  
      // FIXME: &lt;https://webkit.org/b/162771&gt; Web Inspector: Adopt TextPosition in Inspector to avoid oneBasedInt/zeroBasedInt ambiguity
      // Inspector breakpoint line and column values are zero-based but the executable
<span class="line-modified">!     // and CodeBlock line and column values are one-based.</span>
<span class="line-modified">!     unsigned line = breakpoint.line + 1;</span>
<span class="line-modified">!     unsigned column = breakpoint.column ? breakpoint.column : Breakpoint::unspecifiedColumn;</span>
  
      DebuggerParseData&amp; parseData = debuggerParseData(breakpoint.sourceID, sourceProvider);
<span class="line-modified">!     Optional&lt;JSTextPosition&gt; resolvedPosition = parseData.pausePositions.breakpointLocationForLineColumn((int)line, (int)column);</span>
      if (!resolvedPosition)
          return;
  
<span class="line-modified">!     unsigned resolvedLine = resolvedPosition-&gt;line;</span>
<span class="line-modified">!     unsigned resolvedColumn = resolvedPosition-&gt;offset - resolvedPosition-&gt;lineStartOffset + 1;</span>
  
      breakpoint.line = resolvedLine - 1;
<span class="line-modified">!     breakpoint.column = resolvedColumn - 1;</span>
      breakpoint.resolved = true;
  }
  
  BreakpointID Debugger::setBreakpoint(Breakpoint&amp; breakpoint, bool&amp; existing)
  {
<span class="line-new-header">--- 326,39 ---</span>
      RELEASE_ASSERT(!breakpoint.resolved);
      ASSERT(breakpoint.sourceID != noSourceID);
  
      // FIXME: &lt;https://webkit.org/b/162771&gt; Web Inspector: Adopt TextPosition in Inspector to avoid oneBasedInt/zeroBasedInt ambiguity
      // Inspector breakpoint line and column values are zero-based but the executable
<span class="line-modified">!     // and CodeBlock line values are one-based while column is zero-based.</span>
<span class="line-modified">!     int line = breakpoint.line + 1;</span>
<span class="line-modified">!     int column = breakpoint.column;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Account for a &lt;script&gt;&#39;s start position on the first line only.</span>
<span class="line-added">+     int providerStartLine = sourceProvider-&gt;startPosition().m_line.oneBasedInt(); // One based to match the already adjusted line.</span>
<span class="line-added">+     int providerStartColumn = sourceProvider-&gt;startPosition().m_column.zeroBasedInt(); // Zero based so column zero is zero.</span>
<span class="line-added">+     if (line == providerStartLine &amp;&amp; breakpoint.column) {</span>
<span class="line-added">+         ASSERT(providerStartColumn &lt;= column);</span>
<span class="line-added">+         if (providerStartColumn)</span>
<span class="line-added">+             column -= providerStartColumn;</span>
<span class="line-added">+     }</span>
  
      DebuggerParseData&amp; parseData = debuggerParseData(breakpoint.sourceID, sourceProvider);
<span class="line-modified">!     Optional&lt;JSTextPosition&gt; resolvedPosition = parseData.pausePositions.breakpointLocationForLineColumn(line, column);</span>
      if (!resolvedPosition)
          return;
  
<span class="line-modified">!     int resolvedLine = resolvedPosition-&gt;line;</span>
<span class="line-modified">!     int resolvedColumn = resolvedPosition-&gt;column();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Re-account for a &lt;script&gt;&#39;s start position on the first line only.</span>
<span class="line-added">+     if (resolvedLine == providerStartLine &amp;&amp; breakpoint.column) {</span>
<span class="line-added">+         if (providerStartColumn)</span>
<span class="line-added">+             resolvedColumn += providerStartColumn;</span>
<span class="line-added">+     }</span>
  
      breakpoint.line = resolvedLine - 1;
<span class="line-modified">!     breakpoint.column = resolvedColumn;</span>
      breakpoint.resolved = true;
  }
  
  BreakpointID Debugger::setBreakpoint(Breakpoint&amp; breakpoint, bool&amp; existing)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,18 ***</span>
      ASSERT(breaksIt != it-&gt;value.end());
  
      toggleBreakpoint(*breakpoint, BreakpointDisabled);
  
      BreakpointsList&amp; breakpoints = *breaksIt-&gt;value;
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      bool found = false;
      for (Breakpoint* current = breakpoints.head(); current &amp;&amp; !found; current = current-&gt;next()) {
          if (current-&gt;id == breakpoint-&gt;id)
              found = true;
      }
      ASSERT(found);
<span class="line-modified">! #endif</span>
  
      m_breakpointIDToBreakpoint.remove(idIt);
      breakpoints.remove(breakpoint);
      delete breakpoint;
  
<span class="line-new-header">--- 417,18 ---</span>
      ASSERT(breaksIt != it-&gt;value.end());
  
      toggleBreakpoint(*breakpoint, BreakpointDisabled);
  
      BreakpointsList&amp; breakpoints = *breaksIt-&gt;value;
<span class="line-modified">! #if ASSERT_ENABLED</span>
      bool found = false;
      for (Breakpoint* current = breakpoints.head(); current &amp;&amp; !found; current = current-&gt;next()) {
          if (current-&gt;id == breakpoint-&gt;id)
              found = true;
      }
      ASSERT(found);
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
      m_breakpointIDToBreakpoint.remove(idIt);
      breakpoints.remove(breakpoint);
      delete breakpoint;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 509,17 ***</span>
  
      // We can lose the debugger while executing JavaScript.
      if (!m_currentCallFrame)
          return false;
  
      if (exception) {
          // An erroneous condition counts as &quot;false&quot;.
<span class="line-modified">!         handleExceptionInBreakpointCondition(m_currentCallFrame, exception);</span>
          return false;
      }
  
<span class="line-modified">!     return result.toBoolean(m_currentCallFrame);</span>
  }
  
  class Debugger::ClearCodeBlockDebuggerRequestsFunctor {
  public:
      ClearCodeBlockDebuggerRequestsFunctor(Debugger* debugger)
<span class="line-new-header">--- 493,18 ---</span>
  
      // We can lose the debugger while executing JavaScript.
      if (!m_currentCallFrame)
          return false;
  
<span class="line-added">+     JSGlobalObject* globalObject = m_currentCallFrame-&gt;lexicalGlobalObject(m_vm);</span>
      if (exception) {
          // An erroneous condition counts as &quot;false&quot;.
<span class="line-modified">!         handleExceptionInBreakpointCondition(globalObject, exception);</span>
          return false;
      }
  
<span class="line-modified">!     return result.toBoolean(globalObject);</span>
  }
  
  class Debugger::ClearCodeBlockDebuggerRequestsFunctor {
  public:
      ClearCodeBlockDebuggerRequestsFunctor(Debugger* debugger)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 609,11 ***</span>
          return;
  
      m_pauseAtNextOpportunity = true;
      setSteppingMode(SteppingModeEnabled);
      m_currentCallFrame = m_vm.topCallFrame;
<span class="line-modified">!     pauseIfNeeded(m_currentCallFrame);</span>
  }
  
  void Debugger::continueProgram()
  {
      clearNextPauseState();
<span class="line-new-header">--- 594,11 ---</span>
          return;
  
      m_pauseAtNextOpportunity = true;
      setSteppingMode(SteppingModeEnabled);
      m_currentCallFrame = m_vm.topCallFrame;
<span class="line-modified">!     pauseIfNeeded(m_currentCallFrame-&gt;lexicalGlobalObject(m_vm));</span>
  }
  
  void Debugger::continueProgram()
  {
      clearNextPauseState();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 654,21 ***</span>
      m_pauseOnStepOut = true;
      setSteppingMode(SteppingModeEnabled);
      notifyDoneProcessingDebuggerEvents();
  }
  
<span class="line-modified">! void Debugger::updateCallFrame(CallFrame* callFrame, CallFrameUpdateAction action)</span>
  {
      if (!callFrame) {
          m_currentCallFrame = nullptr;
          return;
      }
<span class="line-removed">- </span>
      updateCallFrameInternal(callFrame);
  
      if (action == AttemptPause)
<span class="line-modified">!         pauseIfNeeded(callFrame);</span>
  
      if (!isStepping())
          m_currentCallFrame = nullptr;
  }
  
<span class="line-new-header">--- 639,27 ---</span>
      m_pauseOnStepOut = true;
      setSteppingMode(SteppingModeEnabled);
      notifyDoneProcessingDebuggerEvents();
  }
  
<span class="line-modified">! static inline JSGlobalObject* lexicalGlobalObjectForCallFrame(VM&amp; vm, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!callFrame)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     return callFrame-&gt;lexicalGlobalObject(vm);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Debugger::updateCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrameUpdateAction action)</span>
  {
      if (!callFrame) {
          m_currentCallFrame = nullptr;
          return;
      }
      updateCallFrameInternal(callFrame);
  
      if (action == AttemptPause)
<span class="line-modified">!         pauseIfNeeded(globalObject);</span>
  
      if (!isStepping())
          m_currentCallFrame = nullptr;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 680,24 ***</span>
          m_lastExecutedLine = UINT_MAX;
          m_lastExecutedSourceID = sourceID;
      }
  }
  
<span class="line-modified">! void Debugger::pauseIfNeeded(CallFrame* callFrame)</span>
  {
      VM&amp; vm = m_vm;
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">-     ASSERT(callFrame);</span>
  
      if (m_isPaused)
          return;
  
      if (m_suppressAllPauses)
          return;
  
      intptr_t sourceID = DebuggerCallFrame::sourceIDForCallFrame(m_currentCallFrame);
<span class="line-modified">!     if (isBlacklisted(sourceID))</span>
          return;
  
      DebuggerPausedScope debuggerPausedScope(*this);
  
      bool pauseNow = m_pauseAtNextOpportunity;
<span class="line-new-header">--- 671,25 ---</span>
          m_lastExecutedLine = UINT_MAX;
          m_lastExecutedSourceID = sourceID;
      }
  }
  
<span class="line-modified">! void Debugger::pauseIfNeeded(JSGlobalObject* globalObject)</span>
  {
      VM&amp; vm = m_vm;
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (m_isPaused)
          return;
  
      if (m_suppressAllPauses)
          return;
  
      intptr_t sourceID = DebuggerCallFrame::sourceIDForCallFrame(m_currentCallFrame);
<span class="line-modified">! </span>
<span class="line-added">+     auto blackboxTypeIterator = m_blackboxedScripts.find(sourceID);</span>
<span class="line-added">+     if (blackboxTypeIterator != m_blackboxedScripts.end() &amp;&amp; blackboxTypeIterator-&gt;value == BlackboxType::Ignored)</span>
          return;
  
      DebuggerPausedScope debuggerPausedScope(*this);
  
      bool pauseNow = m_pauseAtNextOpportunity;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,20 ***</span>
      pauseNow |= didHitBreakpoint;
      m_lastExecutedLine = position.m_line.zeroBasedInt();
      if (!pauseNow)
          return;
  
      clearNextPauseState();
  
      // Make sure we are not going to pause again on breakpoint actions by
      // reseting the pause state before executing any breakpoint actions.
      TemporaryPausedState pausedState(*this);
  
<span class="line-removed">-     JSGlobalObject* vmEntryGlobalObject = vm.vmEntryGlobalObject(callFrame);</span>
<span class="line-removed">- </span>
      if (didHitBreakpoint) {
<span class="line-modified">!         handleBreakpointHit(vmEntryGlobalObject, breakpoint);</span>
          // Note that the actions can potentially stop the debugger, so we need to check that
          // we still have a current call frame when we get back.
          if (!m_currentCallFrame)
              return;
  
<span class="line-new-header">--- 703,19 ---</span>
      pauseNow |= didHitBreakpoint;
      m_lastExecutedLine = position.m_line.zeroBasedInt();
      if (!pauseNow)
          return;
  
<span class="line-added">+     bool afterBlackboxedScript = m_afterBlackboxedScript;</span>
      clearNextPauseState();
  
      // Make sure we are not going to pause again on breakpoint actions by
      // reseting the pause state before executing any breakpoint actions.
      TemporaryPausedState pausedState(*this);
  
      if (didHitBreakpoint) {
<span class="line-modified">!         handleBreakpointHit(globalObject, breakpoint);</span>
          // Note that the actions can potentially stop the debugger, so we need to check that
          // we still have a current call frame when we get back.
          if (!m_currentCallFrame)
              return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,13 ***</span>
              didHitBreakpoint = false;
          } else
              m_pausingBreakpointID = breakpoint.id;
      }
  
      {
<span class="line-modified">!         PauseReasonDeclaration reason(*this, didHitBreakpoint ? PausedForBreakpoint : m_reasonForPause);</span>
<span class="line-modified">!         handlePause(vmEntryGlobalObject, m_reasonForPause);</span>
          scope.releaseAssertNoException();
      }
  
      m_pausingBreakpointID = noBreakpointID;
  
<span class="line-new-header">--- 725,25 ---</span>
              didHitBreakpoint = false;
          } else
              m_pausingBreakpointID = breakpoint.id;
      }
  
<span class="line-added">+     if (blackboxTypeIterator != m_blackboxedScripts.end() &amp;&amp; blackboxTypeIterator-&gt;value == BlackboxType::Deferred) {</span>
<span class="line-added">+         m_afterBlackboxedScript = true;</span>
<span class="line-added">+         setPauseOnNextStatement(true);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      {
<span class="line-modified">!         auto reason = m_reasonForPause;</span>
<span class="line-modified">!         if (afterBlackboxedScript)</span>
<span class="line-added">+             reason = PausedAfterBlackboxedScript;</span>
<span class="line-added">+         else if (didHitBreakpoint)</span>
<span class="line-added">+             reason = PausedForBreakpoint;</span>
<span class="line-added">+         PauseReasonDeclaration rauseReasonDeclaration(*this, reason);</span>
<span class="line-added">+ </span>
<span class="line-added">+         handlePause(globalObject, m_reasonForPause);</span>
          scope.releaseAssertNoException();
      }
  
      m_pausingBreakpointID = noBreakpointID;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,11 ***</span>
          setSteppingMode(SteppingModeDisabled);
          m_currentCallFrame = nullptr;
      }
  }
  
<span class="line-modified">! void Debugger::exception(CallFrame* callFrame, JSValue exception, bool hasCatchHandler)</span>
  {
      if (m_isPaused)
          return;
  
      if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(m_vm, exception)) {
<span class="line-new-header">--- 751,11 ---</span>
          setSteppingMode(SteppingModeDisabled);
          m_currentCallFrame = nullptr;
      }
  }
  
<span class="line-modified">! void Debugger::exception(JSGlobalObject* globalObject, CallFrame* callFrame, JSValue exception, bool hasCatchHandler)</span>
  {
      if (m_isPaused)
          return;
  
      if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(m_vm, exception)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 771,11 ***</span>
          setSteppingMode(SteppingModeEnabled);
      }
  
      m_hasHandlerForExceptionCallback = true;
      m_currentException = exception;
<span class="line-modified">!     updateCallFrame(callFrame, AttemptPause);</span>
      m_currentException = JSValue();
      m_hasHandlerForExceptionCallback = false;
  }
  
  void Debugger::atStatement(CallFrame* callFrame)
<span class="line-new-header">--- 774,11 ---</span>
          setSteppingMode(SteppingModeEnabled);
      }
  
      m_hasHandlerForExceptionCallback = true;
      m_currentException = exception;
<span class="line-modified">!     updateCallFrame(globalObject, callFrame, AttemptPause);</span>
      m_currentException = JSValue();
      m_hasHandlerForExceptionCallback = false;
  }
  
  void Debugger::atStatement(CallFrame* callFrame)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 784,11 ***</span>
          return;
  
      m_pastFirstExpressionInStatement = false;
  
      PauseReasonDeclaration reason(*this, PausedAtStatement);
<span class="line-modified">!     updateCallFrame(callFrame, AttemptPause);</span>
  }
  
  void Debugger::atExpression(CallFrame* callFrame)
  {
      if (m_isPaused)
<span class="line-new-header">--- 787,11 ---</span>
          return;
  
      m_pastFirstExpressionInStatement = false;
  
      PauseReasonDeclaration reason(*this, PausedAtStatement);
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
  }
  
  void Debugger::atExpression(CallFrame* callFrame)
  {
      if (m_isPaused)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 802,29 ***</span>
  
      // Only pause at the next expression with step-in and step-out, not step-over.
      bool shouldAttemptPause = m_pauseAtNextOpportunity || m_pauseOnStepOut;
  
      PauseReasonDeclaration reason(*this, PausedAtExpression);
<span class="line-modified">!     updateCallFrame(callFrame, shouldAttemptPause ? AttemptPause : NoPause);</span>
  }
  
  void Debugger::callEvent(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
<span class="line-modified">!     updateCallFrame(callFrame, NoPause);</span>
  }
  
  void Debugger::returnEvent(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
      {
          PauseReasonDeclaration reason(*this, PausedBeforeReturn);
<span class="line-modified">!         updateCallFrame(callFrame, AttemptPause);</span>
      }
  
      // Detach may have been called during pauseIfNeeded.
      if (!m_currentCallFrame)
          return;
<span class="line-new-header">--- 805,29 ---</span>
  
      // Only pause at the next expression with step-in and step-out, not step-over.
      bool shouldAttemptPause = m_pauseAtNextOpportunity || m_pauseOnStepOut;
  
      PauseReasonDeclaration reason(*this, PausedAtExpression);
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, shouldAttemptPause ? AttemptPause : NoPause);</span>
  }
  
  void Debugger::callEvent(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
  }
  
  void Debugger::returnEvent(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
      {
          PauseReasonDeclaration reason(*this, PausedBeforeReturn);
<span class="line-modified">!         updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
      }
  
      // Detach may have been called during pauseIfNeeded.
      if (!m_currentCallFrame)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 839,19 ***</span>
      if (m_currentCallFrame == m_pauseOnCallFrame) {
          m_pauseOnCallFrame = callerFrame;
          m_pauseOnStepOut = true;
      }
  
<span class="line-modified">!     updateCallFrame(callerFrame, NoPause);</span>
  }
  
  void Debugger::unwindEvent(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
<span class="line-modified">!     updateCallFrame(callFrame, NoPause);</span>
  
      if (!m_currentCallFrame)
          return;
  
      EntryFrame* topEntryFrame = m_vm.topEntryFrame;
<span class="line-new-header">--- 842,19 ---</span>
      if (m_currentCallFrame == m_pauseOnCallFrame) {
          m_pauseOnCallFrame = callerFrame;
          m_pauseOnStepOut = true;
      }
  
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
  }
  
  void Debugger::unwindEvent(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
  
      if (!m_currentCallFrame)
          return;
  
      EntryFrame* topEntryFrame = m_vm.topEntryFrame;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 859,28 ***</span>
  
      // Treat stepping over an exception location like a step-out.
      if (m_currentCallFrame == m_pauseOnCallFrame)
          m_pauseOnCallFrame = callerFrame;
  
<span class="line-modified">!     updateCallFrame(callerFrame, NoPause);</span>
  }
  
  void Debugger::willExecuteProgram(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
<span class="line-modified">!     updateCallFrame(callFrame, NoPause);</span>
  }
  
  void Debugger::didExecuteProgram(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
      PauseReasonDeclaration reason(*this, PausedAtEndOfProgram);
<span class="line-modified">!     updateCallFrame(callFrame, AttemptPause);</span>
  
      // Detach may have been called during pauseIfNeeded.
      if (!m_currentCallFrame)
          return;
  
<span class="line-new-header">--- 862,28 ---</span>
  
      // Treat stepping over an exception location like a step-out.
      if (m_currentCallFrame == m_pauseOnCallFrame)
          m_pauseOnCallFrame = callerFrame;
  
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
  }
  
  void Debugger::willExecuteProgram(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
  }
  
  void Debugger::didExecuteProgram(CallFrame* callFrame)
  {
      if (m_isPaused)
          return;
  
      PauseReasonDeclaration reason(*this, PausedAtEndOfProgram);
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
  
      // Detach may have been called during pauseIfNeeded.
      if (!m_currentCallFrame)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,11 ***</span>
      if (m_currentCallFrame == m_pauseOnCallFrame) {
          m_pauseOnCallFrame = callerFrame;
          m_pauseAtNextOpportunity = true;
      }
  
<span class="line-modified">!     updateCallFrame(callerFrame, NoPause);</span>
  
      // Do not continue stepping into an unknown future program.
      if (!m_currentCallFrame)
          clearNextPauseState();
  }
<span class="line-new-header">--- 897,11 ---</span>
      if (m_currentCallFrame == m_pauseOnCallFrame) {
          m_pauseOnCallFrame = callerFrame;
          m_pauseAtNextOpportunity = true;
      }
  
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
  
      // Do not continue stepping into an unknown future program.
      if (!m_currentCallFrame)
          clearNextPauseState();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 906,41 ***</span>
  void Debugger::clearNextPauseState()
  {
      m_pauseOnCallFrame = nullptr;
      m_pauseAtNextOpportunity = false;
      m_pauseOnStepOut = false;
  }
  
<span class="line-modified">! void Debugger::didReachBreakpoint(CallFrame* callFrame)</span>
  {
      if (m_isPaused)
          return;
  
      PauseReasonDeclaration reason(*this, PausedForDebuggerStatement);
      m_pauseAtNextOpportunity = true;
      setSteppingMode(SteppingModeEnabled);
<span class="line-modified">!     updateCallFrame(callFrame, AttemptPause);</span>
  }
  
  DebuggerCallFrame&amp; Debugger::currentDebuggerCallFrame()
  {
      if (!m_currentDebuggerCallFrame)
          m_currentDebuggerCallFrame = DebuggerCallFrame::create(m_vm, m_currentCallFrame);
      return *m_currentDebuggerCallFrame;
  }
  
<span class="line-modified">! bool Debugger::isBlacklisted(SourceID sourceID) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_blacklistedScripts.contains(sourceID);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Debugger::addToBlacklist(SourceID sourceID)</span>
  {
<span class="line-modified">!     m_blacklistedScripts.add(sourceID);</span>
  }
  
<span class="line-modified">! void Debugger::clearBlacklist()</span>
  {
<span class="line-modified">!     m_blacklistedScripts.clear();</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 909,43 ---</span>
  void Debugger::clearNextPauseState()
  {
      m_pauseOnCallFrame = nullptr;
      m_pauseAtNextOpportunity = false;
      m_pauseOnStepOut = false;
<span class="line-added">+     m_afterBlackboxedScript = false;</span>
  }
  
<span class="line-modified">! void Debugger::didReachDebuggerStatement(CallFrame* callFrame)</span>
  {
      if (m_isPaused)
          return;
  
<span class="line-added">+     if (!m_pauseOnDebuggerStatements)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      PauseReasonDeclaration reason(*this, PausedForDebuggerStatement);
      m_pauseAtNextOpportunity = true;
      setSteppingMode(SteppingModeEnabled);
<span class="line-modified">!     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
  }
  
  DebuggerCallFrame&amp; Debugger::currentDebuggerCallFrame()
  {
      if (!m_currentDebuggerCallFrame)
          m_currentDebuggerCallFrame = DebuggerCallFrame::create(m_vm, m_currentCallFrame);
      return *m_currentDebuggerCallFrame;
  }
  
<span class="line-modified">! void Debugger::setBlackboxType(SourceID sourceID, Optional&lt;BlackboxType&gt; type)</span>
  {
<span class="line-modified">!     if (type)</span>
<span class="line-added">+         m_blackboxedScripts.set(sourceID, type.value());</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_blackboxedScripts.remove(sourceID);</span>
  }
  
<span class="line-modified">! void Debugger::clearBlackbox()</span>
  {
<span class="line-modified">!     m_blackboxedScripts.clear();</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="Breakpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Debugger.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
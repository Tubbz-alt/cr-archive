<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/SlotAssignment.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimulatedClick.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SlotAssignment.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/SlotAssignment.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 #include &quot;ShadowRoot.h&quot;
 32 #include &quot;TypedElementDescendantIterator.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 using namespace HTMLNames;
 37 
 38 static const AtomString&amp; slotNameFromAttributeValue(const AtomString&amp; value)
 39 {
 40     return value == nullAtom() ? SlotAssignment::defaultSlotName() : value;
 41 }
 42 
 43 static const AtomString&amp; slotNameFromSlotAttribute(const Node&amp; child)
 44 {
 45     if (is&lt;Text&gt;(child))
 46         return SlotAssignment::defaultSlotName();
 47 
 48     return slotNameFromAttributeValue(downcast&lt;Element&gt;(child).attributeWithoutSynchronization(slotAttr));
 49 }
 50 
<span class="line-modified"> 51 #if !ASSERT_DISABLED</span>
 52 static HTMLSlotElement* findSlotElement(ShadowRoot&amp; shadowRoot, const AtomString&amp; slotName)
 53 {
 54     for (auto&amp; slotElement : descendantsOfType&lt;HTMLSlotElement&gt;(shadowRoot)) {
 55         if (slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr)) == slotName)
 56             return &amp;slotElement;
 57     }
 58     return nullptr;
 59 }
<span class="line-modified"> 60 #endif</span>
 61 
 62 static HTMLSlotElement* nextSlotElementSkippingSubtree(ContainerNode&amp; startingNode, ContainerNode* skippedSubtree)
 63 {
 64     Node* node = &amp;startingNode;
 65     do {
 66         if (UNLIKELY(node == skippedSubtree))
 67             node = NodeTraversal::nextSkippingChildren(*node);
 68         else
 69             node = NodeTraversal::next(*node);
 70     } while (node &amp;&amp; !is&lt;HTMLSlotElement&gt;(node));
 71     return downcast&lt;HTMLSlotElement&gt;(node);
 72 }
 73 
 74 SlotAssignment::SlotAssignment() = default;
 75 
 76 SlotAssignment::~SlotAssignment() = default;
 77 
 78 HTMLSlotElement* SlotAssignment::findAssignedSlot(const Node&amp; node, ShadowRoot&amp; shadowRoot)
 79 {
 80     if (!is&lt;Text&gt;(node) &amp;&amp; !is&lt;Element&gt;(node))
</pre>
<hr />
<pre>
 89 
 90 inline bool SlotAssignment::hasAssignedNodes(ShadowRoot&amp; shadowRoot, Slot&amp; slot)
 91 {
 92     if (!m_slotAssignmentsIsValid)
 93         assignSlots(shadowRoot);
 94     return !slot.assignedNodes.isEmpty();
 95 }
 96 
 97 void SlotAssignment::renameSlotElement(HTMLSlotElement&amp; slotElement, const AtomString&amp; oldName, const AtomString&amp; newName, ShadowRoot&amp; shadowRoot)
 98 {
 99     ASSERT(m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
100 
101     m_slotMutationVersion++;
102 
103     removeSlotElementByName(oldName, slotElement, nullptr, shadowRoot);
104     addSlotElementByName(newName, slotElement, shadowRoot);
105 }
106 
107 void SlotAssignment::addSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slotElement, ShadowRoot&amp; shadowRoot)
108 {
<span class="line-modified">109 #ifndef NDEBUG</span>
110     ASSERT(!m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
111     m_slotElementsForConsistencyCheck.add(&amp;slotElement);
112 #endif
113 
114     // FIXME: We should be able to do a targeted reconstruction.
115     shadowRoot.host()-&gt;invalidateStyleAndRenderersForSubtree();
116 
117     auto&amp; slotName = slotNameFromAttributeValue(name);
118     auto addResult = m_slots.ensure(slotName, [&amp;] {
<span class="line-modified">119         // Unlike named slots, assignSlots doesn&#39;t collect nodes assigned to the default slot</span>
<span class="line-removed">120         // to avoid always having a vector of all child nodes of a shadow host.</span>
<span class="line-removed">121         if (slotName == defaultSlotName())</span>
<span class="line-removed">122             m_slotAssignmentsIsValid = false;</span>
123         return makeUnique&lt;Slot&gt;();
124     });
125     auto&amp; slot = *addResult.iterator-&gt;value;
126     bool needsSlotchangeEvent = shadowRoot.shouldFireSlotchangeEvent() &amp;&amp; hasAssignedNodes(shadowRoot, slot);
127 
128     slot.elementCount++;
129     if (slot.elementCount == 1) {
130         slot.element = makeWeakPtr(slotElement);
131         if (needsSlotchangeEvent)
132             slotElement.enqueueSlotChangeEvent();
133         return;
134     }
135 
136     if (!needsSlotchangeEvent) {
137         ASSERT(slot.element || m_needsToResolveSlotElements);
138         slot.element = nullptr;
139         m_needsToResolveSlotElements = true;
140         return;
141     }
142 
143     resolveSlotsAfterSlotMutation(shadowRoot, SlotMutationType::Insertion);
144 }
145 
146 void SlotAssignment::removeSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slotElement, ContainerNode* oldParentOfRemovedTreeForRemoval, ShadowRoot&amp; shadowRoot)
147 {
<span class="line-modified">148 #ifndef NDEBUG</span>
149     ASSERT(m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
150     m_slotElementsForConsistencyCheck.remove(&amp;slotElement);
151 #endif
152 
153     if (auto* host = shadowRoot.host()) // FIXME: We should be able to do a targeted reconstruction.
154         host-&gt;invalidateStyleAndRenderersForSubtree();
155 
156     auto* slot = m_slots.get(slotNameFromAttributeValue(name));
157     RELEASE_ASSERT(slot &amp;&amp; slot-&gt;hasSlotElements());
158     bool needsSlotchangeEvent = shadowRoot.shouldFireSlotchangeEvent() &amp;&amp; hasAssignedNodes(shadowRoot, *slot);
159 
160     slot-&gt;elementCount--;
161     if (!slot-&gt;elementCount) {
162         slot-&gt;element = nullptr;
163         if (needsSlotchangeEvent &amp;&amp; m_slotResolutionVersion != m_slotMutationVersion)
164             slotElement.enqueueSlotChangeEvent();
165         return;
166     }
167 
168     if (!needsSlotchangeEvent) {
</pre>
<hr />
<pre>
221             continue;
222         }
223         currentSlot-&gt;seenFirstElement = true;
224         slotCount++;
225         ASSERT(currentSlot-&gt;element || !hasAssignedNodes(shadowRoot, *currentSlot));
226         if (currentSlot-&gt;element != currentElement) {
227             if (hasAssignedNodes(shadowRoot, *currentSlot)) {
228                 currentSlot-&gt;oldElement = WTFMove(currentSlot-&gt;element);
229                 currentElement-&gt;enqueueSlotChangeEvent();
230             }
231             currentSlot-&gt;element = makeWeakPtr(*currentElement);
232         }
233     }
234 
235     if (slotCount == m_slots.size())
236         return;
237 
238     if (mutationType == SlotMutationType::Insertion) {
239         // This code path is taken only when continue above for !currentSlot is taken.
240         // i.e. there is a new slot being inserted into the tree but we have yet to invoke addSlotElementByName on it.
<span class="line-modified">241 #if !ASSERT_DISABLED</span>
242         for (auto&amp; entry : m_slots)
243             ASSERT(entry.value-&gt;seenFirstElement || !findSlotElement(shadowRoot, entry.key));
244 #endif
245         return;
246     }
247 
248     for (auto&amp; slot : m_slots.values()) {
249         if (slot-&gt;seenFirstElement)
250             continue;
251         if (!slot-&gt;elementCount) {
252             // Taken the fast path for removal.
253             ASSERT(!slot-&gt;element);
254             continue;
255         }
256         // All slot elements have been removed for this slot.
257         slot-&gt;seenFirstElement = true;
258         ASSERT(slot-&gt;element);
259         if (hasAssignedNodes(shadowRoot, *slot))
260             slot-&gt;oldElement = WTFMove(slot-&gt;element);
261         slot-&gt;element = nullptr;
</pre>
<hr />
<pre>
327     if (slot-&gt;assignedNodes.isEmpty())
328         return nullptr;
329 
330     RELEASE_ASSERT(slot-&gt;hasSlotElements());
331     if (slot-&gt;hasDuplicatedSlotElements() &amp;&amp; findFirstSlotElement(*slot, shadowRoot) != &amp;slotElement)
332         return nullptr;
333 
334     return &amp;slot-&gt;assignedNodes;
335 }
336 
337 const AtomString&amp; SlotAssignment::slotNameForHostChild(const Node&amp; child) const
338 {
339     return slotNameFromSlotAttribute(child);
340 }
341 
342 HTMLSlotElement* SlotAssignment::findFirstSlotElement(Slot&amp; slot, ShadowRoot&amp; shadowRoot)
343 {
344     if (slot.shouldResolveSlotElement())
345         resolveAllSlotElements(shadowRoot);
346 
<span class="line-removed">347 #ifndef NDEBUG</span>
348     ASSERT(!slot.element || m_slotElementsForConsistencyCheck.contains(slot.element.get()));
349     ASSERT(!!slot.element == !!slot.elementCount);
<span class="line-removed">350 #endif</span>
351 
352     return slot.element.get();
353 }
354 
355 void SlotAssignment::resolveAllSlotElements(ShadowRoot&amp; shadowRoot)
356 {
357     ASSERT(m_needsToResolveSlotElements);
358     m_needsToResolveSlotElements = false;
359 
360     // FIXME: It&#39;s inefficient to reset all values. We should be able to void this in common case.
361     for (auto&amp; entry : m_slots)
362         entry.value-&gt;seenFirstElement = false;
363 
364     unsigned slotCount = m_slots.size();
365     for (auto&amp; slotElement : descendantsOfType&lt;HTMLSlotElement&gt;(shadowRoot)) {
366         auto&amp; slotName = slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr));
367 
368         auto* slot = m_slots.get(slotName);
369         RELEASE_ASSERT(slot); // slot must have been created when a slot was inserted.
370 
</pre>
</td>
<td>
<hr />
<pre>
 31 #include &quot;ShadowRoot.h&quot;
 32 #include &quot;TypedElementDescendantIterator.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 using namespace HTMLNames;
 37 
 38 static const AtomString&amp; slotNameFromAttributeValue(const AtomString&amp; value)
 39 {
 40     return value == nullAtom() ? SlotAssignment::defaultSlotName() : value;
 41 }
 42 
 43 static const AtomString&amp; slotNameFromSlotAttribute(const Node&amp; child)
 44 {
 45     if (is&lt;Text&gt;(child))
 46         return SlotAssignment::defaultSlotName();
 47 
 48     return slotNameFromAttributeValue(downcast&lt;Element&gt;(child).attributeWithoutSynchronization(slotAttr));
 49 }
 50 
<span class="line-modified"> 51 #if ASSERT_ENABLED</span>
 52 static HTMLSlotElement* findSlotElement(ShadowRoot&amp; shadowRoot, const AtomString&amp; slotName)
 53 {
 54     for (auto&amp; slotElement : descendantsOfType&lt;HTMLSlotElement&gt;(shadowRoot)) {
 55         if (slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr)) == slotName)
 56             return &amp;slotElement;
 57     }
 58     return nullptr;
 59 }
<span class="line-modified"> 60 #endif // ASSERT_ENABLED</span>
 61 
 62 static HTMLSlotElement* nextSlotElementSkippingSubtree(ContainerNode&amp; startingNode, ContainerNode* skippedSubtree)
 63 {
 64     Node* node = &amp;startingNode;
 65     do {
 66         if (UNLIKELY(node == skippedSubtree))
 67             node = NodeTraversal::nextSkippingChildren(*node);
 68         else
 69             node = NodeTraversal::next(*node);
 70     } while (node &amp;&amp; !is&lt;HTMLSlotElement&gt;(node));
 71     return downcast&lt;HTMLSlotElement&gt;(node);
 72 }
 73 
 74 SlotAssignment::SlotAssignment() = default;
 75 
 76 SlotAssignment::~SlotAssignment() = default;
 77 
 78 HTMLSlotElement* SlotAssignment::findAssignedSlot(const Node&amp; node, ShadowRoot&amp; shadowRoot)
 79 {
 80     if (!is&lt;Text&gt;(node) &amp;&amp; !is&lt;Element&gt;(node))
</pre>
<hr />
<pre>
 89 
 90 inline bool SlotAssignment::hasAssignedNodes(ShadowRoot&amp; shadowRoot, Slot&amp; slot)
 91 {
 92     if (!m_slotAssignmentsIsValid)
 93         assignSlots(shadowRoot);
 94     return !slot.assignedNodes.isEmpty();
 95 }
 96 
 97 void SlotAssignment::renameSlotElement(HTMLSlotElement&amp; slotElement, const AtomString&amp; oldName, const AtomString&amp; newName, ShadowRoot&amp; shadowRoot)
 98 {
 99     ASSERT(m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
100 
101     m_slotMutationVersion++;
102 
103     removeSlotElementByName(oldName, slotElement, nullptr, shadowRoot);
104     addSlotElementByName(newName, slotElement, shadowRoot);
105 }
106 
107 void SlotAssignment::addSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slotElement, ShadowRoot&amp; shadowRoot)
108 {
<span class="line-modified">109 #if ASSERT_ENABLED</span>
110     ASSERT(!m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
111     m_slotElementsForConsistencyCheck.add(&amp;slotElement);
112 #endif
113 
114     // FIXME: We should be able to do a targeted reconstruction.
115     shadowRoot.host()-&gt;invalidateStyleAndRenderersForSubtree();
116 
117     auto&amp; slotName = slotNameFromAttributeValue(name);
118     auto addResult = m_slots.ensure(slotName, [&amp;] {
<span class="line-modified">119         m_slotAssignmentsIsValid = false;</span>



120         return makeUnique&lt;Slot&gt;();
121     });
122     auto&amp; slot = *addResult.iterator-&gt;value;
123     bool needsSlotchangeEvent = shadowRoot.shouldFireSlotchangeEvent() &amp;&amp; hasAssignedNodes(shadowRoot, slot);
124 
125     slot.elementCount++;
126     if (slot.elementCount == 1) {
127         slot.element = makeWeakPtr(slotElement);
128         if (needsSlotchangeEvent)
129             slotElement.enqueueSlotChangeEvent();
130         return;
131     }
132 
133     if (!needsSlotchangeEvent) {
134         ASSERT(slot.element || m_needsToResolveSlotElements);
135         slot.element = nullptr;
136         m_needsToResolveSlotElements = true;
137         return;
138     }
139 
140     resolveSlotsAfterSlotMutation(shadowRoot, SlotMutationType::Insertion);
141 }
142 
143 void SlotAssignment::removeSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slotElement, ContainerNode* oldParentOfRemovedTreeForRemoval, ShadowRoot&amp; shadowRoot)
144 {
<span class="line-modified">145 #if ASSERT_ENABLED</span>
146     ASSERT(m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
147     m_slotElementsForConsistencyCheck.remove(&amp;slotElement);
148 #endif
149 
150     if (auto* host = shadowRoot.host()) // FIXME: We should be able to do a targeted reconstruction.
151         host-&gt;invalidateStyleAndRenderersForSubtree();
152 
153     auto* slot = m_slots.get(slotNameFromAttributeValue(name));
154     RELEASE_ASSERT(slot &amp;&amp; slot-&gt;hasSlotElements());
155     bool needsSlotchangeEvent = shadowRoot.shouldFireSlotchangeEvent() &amp;&amp; hasAssignedNodes(shadowRoot, *slot);
156 
157     slot-&gt;elementCount--;
158     if (!slot-&gt;elementCount) {
159         slot-&gt;element = nullptr;
160         if (needsSlotchangeEvent &amp;&amp; m_slotResolutionVersion != m_slotMutationVersion)
161             slotElement.enqueueSlotChangeEvent();
162         return;
163     }
164 
165     if (!needsSlotchangeEvent) {
</pre>
<hr />
<pre>
218             continue;
219         }
220         currentSlot-&gt;seenFirstElement = true;
221         slotCount++;
222         ASSERT(currentSlot-&gt;element || !hasAssignedNodes(shadowRoot, *currentSlot));
223         if (currentSlot-&gt;element != currentElement) {
224             if (hasAssignedNodes(shadowRoot, *currentSlot)) {
225                 currentSlot-&gt;oldElement = WTFMove(currentSlot-&gt;element);
226                 currentElement-&gt;enqueueSlotChangeEvent();
227             }
228             currentSlot-&gt;element = makeWeakPtr(*currentElement);
229         }
230     }
231 
232     if (slotCount == m_slots.size())
233         return;
234 
235     if (mutationType == SlotMutationType::Insertion) {
236         // This code path is taken only when continue above for !currentSlot is taken.
237         // i.e. there is a new slot being inserted into the tree but we have yet to invoke addSlotElementByName on it.
<span class="line-modified">238 #if ASSERT_ENABLED</span>
239         for (auto&amp; entry : m_slots)
240             ASSERT(entry.value-&gt;seenFirstElement || !findSlotElement(shadowRoot, entry.key));
241 #endif
242         return;
243     }
244 
245     for (auto&amp; slot : m_slots.values()) {
246         if (slot-&gt;seenFirstElement)
247             continue;
248         if (!slot-&gt;elementCount) {
249             // Taken the fast path for removal.
250             ASSERT(!slot-&gt;element);
251             continue;
252         }
253         // All slot elements have been removed for this slot.
254         slot-&gt;seenFirstElement = true;
255         ASSERT(slot-&gt;element);
256         if (hasAssignedNodes(shadowRoot, *slot))
257             slot-&gt;oldElement = WTFMove(slot-&gt;element);
258         slot-&gt;element = nullptr;
</pre>
<hr />
<pre>
324     if (slot-&gt;assignedNodes.isEmpty())
325         return nullptr;
326 
327     RELEASE_ASSERT(slot-&gt;hasSlotElements());
328     if (slot-&gt;hasDuplicatedSlotElements() &amp;&amp; findFirstSlotElement(*slot, shadowRoot) != &amp;slotElement)
329         return nullptr;
330 
331     return &amp;slot-&gt;assignedNodes;
332 }
333 
334 const AtomString&amp; SlotAssignment::slotNameForHostChild(const Node&amp; child) const
335 {
336     return slotNameFromSlotAttribute(child);
337 }
338 
339 HTMLSlotElement* SlotAssignment::findFirstSlotElement(Slot&amp; slot, ShadowRoot&amp; shadowRoot)
340 {
341     if (slot.shouldResolveSlotElement())
342         resolveAllSlotElements(shadowRoot);
343 

344     ASSERT(!slot.element || m_slotElementsForConsistencyCheck.contains(slot.element.get()));
345     ASSERT(!!slot.element == !!slot.elementCount);

346 
347     return slot.element.get();
348 }
349 
350 void SlotAssignment::resolveAllSlotElements(ShadowRoot&amp; shadowRoot)
351 {
352     ASSERT(m_needsToResolveSlotElements);
353     m_needsToResolveSlotElements = false;
354 
355     // FIXME: It&#39;s inefficient to reset all values. We should be able to void this in common case.
356     for (auto&amp; entry : m_slots)
357         entry.value-&gt;seenFirstElement = false;
358 
359     unsigned slotCount = m_slots.size();
360     for (auto&amp; slotElement : descendantsOfType&lt;HTMLSlotElement&gt;(shadowRoot)) {
361         auto&amp; slotName = slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr));
362 
363         auto* slot = m_slots.get(slotName);
364         RELEASE_ASSERT(slot); // slot must have been created when a slot was inserted.
365 
</pre>
</td>
</tr>
</table>
<center><a href="SimulatedClick.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SlotAssignment.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
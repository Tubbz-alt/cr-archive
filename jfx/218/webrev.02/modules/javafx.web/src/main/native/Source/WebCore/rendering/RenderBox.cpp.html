<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
   5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
   6  * Copyright (C) 2005-2010, 2015 Apple Inc. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderBox.h&quot;
  27 
  28 #include &quot;CSSFontSelector.h&quot;
  29 #include &quot;ControlStates.h&quot;
  30 #include &quot;Document.h&quot;
  31 #include &quot;Editing.h&quot;
  32 #include &quot;EventHandler.h&quot;
  33 #include &quot;FloatQuad.h&quot;
  34 #include &quot;FloatRoundedRect.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;GraphicsContext.h&quot;
  38 #include &quot;HTMLBodyElement.h&quot;
  39 #include &quot;HTMLButtonElement.h&quot;
  40 #include &quot;HTMLFrameOwnerElement.h&quot;
  41 #include &quot;HTMLHtmlElement.h&quot;
  42 #include &quot;HTMLImageElement.h&quot;
  43 #include &quot;HTMLInputElement.h&quot;
  44 #include &quot;HTMLLegendElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLSelectElement.h&quot;
  47 #include &quot;HTMLTextAreaElement.h&quot;
  48 #include &quot;HitTestResult.h&quot;
  49 #include &quot;InlineElementBox.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PaintInfo.h&quot;
  52 #include &quot;RenderBoxFragmentInfo.h&quot;
  53 #include &quot;RenderChildIterator.h&quot;
  54 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  55 #include &quot;RenderFlexibleBox.h&quot;
  56 #include &quot;RenderFragmentContainer.h&quot;
  57 #include &quot;RenderGeometryMap.h&quot;
  58 #include &quot;RenderGrid.h&quot;
  59 #include &quot;RenderInline.h&quot;
  60 #include &quot;RenderIterator.h&quot;
  61 #include &quot;RenderLayer.h&quot;
  62 #include &quot;RenderLayerCompositor.h&quot;
  63 #include &quot;RenderLayoutState.h&quot;
  64 #include &quot;RenderMultiColumnFlow.h&quot;
  65 #include &quot;RenderTableCell.h&quot;
  66 #include &quot;RenderTheme.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;RuntimeApplicationChecks.h&quot;
  69 #include &quot;ScrollAnimator.h&quot;
  70 #include &quot;ScrollbarTheme.h&quot;
  71 #include &quot;Settings.h&quot;
  72 #include &quot;StyleScrollSnapPoints.h&quot;
  73 #include &quot;TransformState.h&quot;
  74 #include &lt;algorithm&gt;
  75 #include &lt;math.h&gt;
  76 #include &lt;wtf/IsoMallocInlines.h&gt;
  77 #include &lt;wtf/StackStats.h&gt;
  78 
  79 namespace WebCore {
  80 
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBox);
  82 
  83 struct SameSizeAsRenderBox : public RenderBoxModelObject {
  84     virtual ~SameSizeAsRenderBox() = default;
  85     LayoutRect frameRect;
  86     LayoutBoxExtent marginBox;
  87     LayoutUnit preferredLogicalWidths[2];
  88     void* pointers[2];
  89 };
  90 
  91 COMPILE_ASSERT(sizeof(RenderBox) == sizeof(SameSizeAsRenderBox), RenderBox_should_stay_small);
  92 
  93 using namespace HTMLNames;
  94 
  95 // Used by flexible boxes when flexing this element and by table cells.
  96 typedef WTF::HashMap&lt;const RenderBox*, LayoutUnit&gt; OverrideSizeMap;
  97 static OverrideSizeMap* gOverrideContentLogicalHeightMap = nullptr;
  98 static OverrideSizeMap* gOverrideContentLogicalWidthMap = nullptr;
  99 
 100 // Used by grid elements to properly size their grid items.
 101 // FIXME: We should store these based on physical direction.
 102 typedef WTF::HashMap&lt;const RenderBox*, Optional&lt;LayoutUnit&gt;&gt; OverrideOptionalSizeMap;
 103 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalHeightMap = nullptr;
 104 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalWidthMap = nullptr;
 105 
 106 // Size of border belt for autoscroll. When mouse pointer in border belt,
 107 // autoscroll is started.
 108 static const int autoscrollBeltSize = 20;
 109 static const unsigned backgroundObscurationTestMaxDepth = 4;
 110 
 111 using ControlStatesRendererMap = HashMap&lt;const RenderObject*, std::unique_ptr&lt;ControlStates&gt;&gt;;
 112 static ControlStatesRendererMap&amp; controlStatesRendererMap()
 113 {
 114     static NeverDestroyed&lt;ControlStatesRendererMap&gt; map;
 115     return map;
 116 }
 117 
 118 static ControlStates* controlStatesForRenderer(const RenderBox&amp; renderer)
 119 {
 120     return controlStatesRendererMap().ensure(&amp;renderer, [] {
 121         return makeUnique&lt;ControlStates&gt;();
 122     }).iterator-&gt;value.get();
 123 }
 124 
 125 static void removeControlStatesForRenderer(const RenderBox&amp; renderer)
 126 {
 127     controlStatesRendererMap().remove(&amp;renderer);
 128 }
 129 
 130 bool RenderBox::s_hadOverflowClip = false;
 131 
 132 RenderBox::RenderBox(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 133     : RenderBoxModelObject(element, WTFMove(style), baseTypeFlags)
 134 {
 135     setIsBox();
 136 }
 137 
 138 RenderBox::RenderBox(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 139     : RenderBoxModelObject(document, WTFMove(style), baseTypeFlags)
 140 {
 141     setIsBox();
 142 }
 143 
 144 RenderBox::~RenderBox()
 145 {
 146     // Do not add any code here. Add it to willBeDestroyed() instead.
 147 }
 148 
 149 void RenderBox::willBeDestroyed()
 150 {
 151     if (frame().eventHandler().autoscrollRenderer() == this)
 152         frame().eventHandler().stopAutoscrollTimer(true);
 153 
 154     clearOverrideContentSize();
 155     clearOverrideContainingBlockContentSize();
 156 
 157     RenderBlock::removePercentHeightDescendantIfNeeded(*this);
 158 
 159     ShapeOutsideInfo::removeInfo(*this);
 160 
 161     view().unscheduleLazyRepaint(*this);
 162     removeControlStatesForRenderer(*this);
 163 
 164 #if ENABLE(CSS_SCROLL_SNAP)
 165     if (hasInitializedStyle() &amp;&amp; style().scrollSnapArea().hasSnapPosition())
 166         view().unregisterBoxWithScrollSnapPositions(*this);
 167 #endif
 168 
 169     RenderBoxModelObject::willBeDestroyed();
 170 }
 171 
 172 RenderFragmentContainer* RenderBox::clampToStartAndEndFragments(RenderFragmentContainer* fragment) const
 173 {
 174     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 175 
 176     ASSERT(isRenderView() || (fragment &amp;&amp; fragmentedFlow));
 177     if (isRenderView())
 178         return fragment;
 179 
 180     // We need to clamp to the block, since we want any lines or blocks that overflow out of the
 181     // logical top or logical bottom of the block to size as though the border box in the first and
 182     // last fragments extended infinitely. Otherwise the lines are going to size according to the fragments
 183     // they overflow into, which makes no sense when this block doesn&#39;t exist in |fragment| at all.
 184     RenderFragmentContainer* startFragment = nullptr;
 185     RenderFragmentContainer* endFragment = nullptr;
 186     if (!fragmentedFlow-&gt;getFragmentRangeForBox(this, startFragment, endFragment))
 187         return fragment;
 188 
 189     if (fragment-&gt;logicalTopForFragmentedFlowContent() &lt; startFragment-&gt;logicalTopForFragmentedFlowContent())
 190         return startFragment;
 191     if (fragment-&gt;logicalTopForFragmentedFlowContent() &gt; endFragment-&gt;logicalTopForFragmentedFlowContent())
 192         return endFragment;
 193 
 194     return fragment;
 195 }
 196 
 197 bool RenderBox::hasFragmentRangeInFragmentedFlow() const
 198 {
 199     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 200     if (!fragmentedFlow || !fragmentedFlow-&gt;hasValidFragmentInfo())
 201         return false;
 202 
 203     return fragmentedFlow-&gt;hasCachedFragmentRangeForBox(*this);
 204 }
 205 
 206 LayoutRect RenderBox::clientBoxRectInFragment(RenderFragmentContainer* fragment) const
 207 {
 208     if (!fragment)
 209         return clientBoxRect();
 210 
 211     LayoutRect clientBox = borderBoxRectInFragment(fragment);
 212     clientBox.setLocation(clientBox.location() + LayoutSize(borderLeft(), borderTop()));
 213     clientBox.setSize(clientBox.size() - LayoutSize(borderLeft() + borderRight() + verticalScrollbarWidth(), borderTop() + borderBottom() + horizontalScrollbarHeight()));
 214 
 215     return clientBox;
 216 }
 217 
 218 LayoutRect RenderBox::borderBoxRectInFragment(RenderFragmentContainer*, RenderBoxFragmentInfoFlags) const
 219 {
 220     return borderBoxRect();
 221 }
 222 
 223 static RenderBlockFlow* outermostBlockContainingFloatingObject(RenderBox&amp; box)
 224 {
 225     ASSERT(box.isFloating());
 226     RenderBlockFlow* parentBlock = nullptr;
 227     for (auto&amp; ancestor : ancestorsOfType&lt;RenderBlockFlow&gt;(box)) {
 228         if (ancestor.isRenderView())
 229             break;
 230         if (!parentBlock || ancestor.containsFloat(box))
 231             parentBlock = &amp;ancestor;
 232     }
 233     return parentBlock;
 234 }
 235 
 236 void RenderBox::removeFloatingOrPositionedChildFromBlockLists()
 237 {
 238     ASSERT(isFloatingOrOutOfFlowPositioned());
 239 
 240     if (renderTreeBeingDestroyed())
 241         return;
 242 
 243     if (isFloating()) {
 244         if (RenderBlockFlow* parentBlock = outermostBlockContainingFloatingObject(*this)) {
 245             parentBlock-&gt;markSiblingsWithFloatsForLayout(this);
 246             parentBlock-&gt;markAllDescendantsWithFloatsForLayout(this, false);
 247         }
 248     }
 249 
 250     if (isOutOfFlowPositioned())
 251         RenderBlock::removePositionedObject(*this);
 252 }
 253 
 254 void RenderBox::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 255 {
 256     s_hadOverflowClip = hasOverflowClip();
 257 
 258     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 259     if (oldStyle) {
 260         // The background of the root element or the body element could propagate up to
 261         // the canvas. Issue full repaint, when our style changes substantially.
 262         if (diff &gt;= StyleDifference::Repaint &amp;&amp; (isDocumentElementRenderer() || isBody())) {
 263             view().repaintRootContents();
 264             if (oldStyle-&gt;hasEntirelyFixedBackground() != newStyle.hasEntirelyFixedBackground())
 265                 view().compositor().rootLayerConfigurationChanged();
 266         }
 267 
 268         // When a layout hint happens and an object&#39;s position style changes, we have to do a layout
 269         // to dirty the render tree using the old position value now.
 270         if (diff == StyleDifference::Layout &amp;&amp; parent() &amp;&amp; oldStyle-&gt;position() != newStyle.position()) {
 271             markContainingBlocksForLayout();
 272             if (oldStyle-&gt;position() == PositionType::Static)
 273                 repaint();
 274             else if (newStyle.hasOutOfFlowPosition())
 275                 parent()-&gt;setChildNeedsLayout();
 276             if (isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
 277                 removeFloatingOrPositionedChildFromBlockLists();
 278         }
 279     } else if (isBody())
 280         view().repaintRootContents();
 281 
 282 #if ENABLE(CSS_SCROLL_SNAP)
 283     bool boxContributesSnapPositions = newStyle.scrollSnapArea().hasSnapPosition();
 284     if (boxContributesSnapPositions || (oldStyle &amp;&amp; oldStyle-&gt;scrollSnapArea().hasSnapPosition())) {
 285         if (boxContributesSnapPositions)
 286             view().registerBoxWithScrollSnapPositions(*this);
 287         else
 288             view().unregisterBoxWithScrollSnapPositions(*this);
 289     }
 290 #endif
 291 
 292     RenderBoxModelObject::styleWillChange(diff, newStyle);
 293 }
 294 
 295 void RenderBox::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 296 {
 297     // Horizontal writing mode definition is updated in RenderBoxModelObject::updateFromStyle,
 298     // (as part of the RenderBoxModelObject::styleDidChange call below). So, we can safely cache the horizontal
 299     // writing mode value before style change here.
 300     bool oldHorizontalWritingMode = isHorizontalWritingMode();
 301 
 302     RenderBoxModelObject::styleDidChange(diff, oldStyle);
 303 
 304     const RenderStyle&amp; newStyle = style();
 305     if (needsLayout() &amp;&amp; oldStyle) {
 306         RenderBlock::removePercentHeightDescendantIfNeeded(*this);
 307 
 308         // Normally we can do optimized positioning layout for absolute/fixed positioned objects. There is one special case, however, which is
 309         // when the positioned object&#39;s margin-before is changed. In this case the parent has to get a layout in order to run margin collapsing
 310         // to determine the new static position.
 311         if (isOutOfFlowPositioned() &amp;&amp; newStyle.hasStaticBlockPosition(isHorizontalWritingMode()) &amp;&amp; oldStyle-&gt;marginBefore() != newStyle.marginBefore()
 312             &amp;&amp; parent() &amp;&amp; !parent()-&gt;normalChildNeedsLayout())
 313             parent()-&gt;setChildNeedsLayout();
 314     }
 315 
 316     if (RenderBlock::hasPercentHeightContainerMap() &amp;&amp; firstChild()
 317         &amp;&amp; oldHorizontalWritingMode != isHorizontalWritingMode())
 318         RenderBlock::clearPercentHeightDescendantsFrom(*this);
 319 
 320     // If our zoom factor changes and we have a defined scrollLeft/Top, we need to adjust that value into the
 321     // new zoomed coordinate space.
 322     if (hasOverflowClip() &amp;&amp; layer() &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;effectiveZoom() != newStyle.effectiveZoom()) {
 323         ScrollPosition scrollPosition = layer()-&gt;scrollPosition();
 324         float zoomScaleFactor = newStyle.effectiveZoom() / oldStyle-&gt;effectiveZoom();
 325         scrollPosition.scale(zoomScaleFactor);
 326         layer()-&gt;setPostLayoutScrollPosition(scrollPosition);
 327     }
 328 
 329     // Our opaqueness might have changed without triggering layout.
 330     if (diff &gt;= StyleDifference::Repaint &amp;&amp; diff &lt;= StyleDifference::RepaintLayer) {
 331         auto parentToInvalidate = parent();
 332         for (unsigned i = 0; i &lt; backgroundObscurationTestMaxDepth &amp;&amp; parentToInvalidate; ++i) {
 333             parentToInvalidate-&gt;invalidateBackgroundObscurationStatus();
 334             parentToInvalidate = parentToInvalidate-&gt;parent();
 335         }
 336     }
 337 
 338     bool isBodyRenderer = isBody();
 339     bool isDocElementRenderer = isDocumentElementRenderer();
 340 
 341     if (isDocElementRenderer || isBodyRenderer) {
 342         // Propagate the new writing mode and direction up to the RenderView.
 343         auto* documentElementRenderer = document().documentElement()-&gt;renderer();
 344         auto&amp; viewStyle = view().mutableStyle();
 345         bool rootStyleChanged = false;
 346         bool viewDirectionOrWritingModeChanged = false;
 347         auto* rootRenderer = isBodyRenderer ? documentElementRenderer : nullptr;
 348         if (viewStyle.direction() != newStyle.direction() &amp;&amp; (isDocElementRenderer || !documentElementRenderer-&gt;style().hasExplicitlySetDirection())) {
 349             viewStyle.setDirection(newStyle.direction());
 350             viewDirectionOrWritingModeChanged = true;
 351             if (isBodyRenderer) {
 352                 rootRenderer-&gt;mutableStyle().setDirection(newStyle.direction());
 353                 rootStyleChanged = true;
 354             }
 355             setNeedsLayoutAndPrefWidthsRecalc();
 356 
 357             view().frameView().topContentDirectionDidChange();
 358         }
 359 
 360         if (viewStyle.writingMode() != newStyle.writingMode() &amp;&amp; (isDocElementRenderer || !documentElementRenderer-&gt;style().hasExplicitlySetWritingMode())) {
 361             viewStyle.setWritingMode(newStyle.writingMode());
 362             viewDirectionOrWritingModeChanged = true;
 363             view().setHorizontalWritingMode(newStyle.isHorizontalWritingMode());
 364             view().markAllDescendantsWithFloatsForLayout();
 365             if (isBodyRenderer) {
 366                 rootStyleChanged = true;
 367                 rootRenderer-&gt;mutableStyle().setWritingMode(newStyle.writingMode());
 368                 rootRenderer-&gt;setHorizontalWritingMode(newStyle.isHorizontalWritingMode());
 369             }
 370             setNeedsLayoutAndPrefWidthsRecalc();
 371         }
 372 
 373 #if ENABLE(DARK_MODE_CSS)
 374         view().frameView().recalculateBaseBackgroundColor();
 375 #endif
 376 
 377         view().frameView().recalculateScrollbarOverlayStyle();
 378 
 379         const Pagination&amp; pagination = view().frameView().pagination();
 380         if (viewDirectionOrWritingModeChanged &amp;&amp; pagination.mode != Pagination::Unpaginated) {
 381             viewStyle.setColumnStylesFromPaginationMode(pagination.mode);
 382             if (view().multiColumnFlow())
 383                 view().updateColumnProgressionFromStyle(viewStyle);
 384         }
 385 
 386         if (viewDirectionOrWritingModeChanged &amp;&amp; view().multiColumnFlow())
 387             view().updateStylesForColumnChildren();
 388 
 389         if (rootStyleChanged &amp;&amp; is&lt;RenderBlockFlow&gt;(rootRenderer) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*rootRenderer).multiColumnFlow())
 390             downcast&lt;RenderBlockFlow&gt;(*rootRenderer).updateStylesForColumnChildren();
 391 
 392         if (isBodyRenderer &amp;&amp; pagination.mode != Pagination::Unpaginated &amp;&amp; page().paginationLineGridEnabled()) {
 393             // Propagate the body font back up to the RenderView and use it as
 394             // the basis of the grid.
 395             if (newStyle.fontDescription() != view().style().fontDescription()) {
 396                 view().mutableStyle().setFontDescription(FontCascadeDescription { newStyle.fontDescription() });
 397                 view().mutableStyle().fontCascade().update(&amp;document().fontSelector());
 398             }
 399         }
 400 
 401         if (diff != StyleDifference::Equal)
 402             view().compositor().rootOrBodyStyleChanged(*this, oldStyle);
 403     }
 404 
 405     if ((oldStyle &amp;&amp; oldStyle-&gt;shapeOutside()) || style().shapeOutside())
 406         updateShapeOutsideInfoAfterStyleChange(style(), oldStyle);
 407     updateGridPositionAfterStyleChange(style(), oldStyle);
 408 }
 409 
 410 void RenderBox::updateGridPositionAfterStyleChange(const RenderStyle&amp; style, const RenderStyle* oldStyle)
 411 {
 412     if (!oldStyle || !is&lt;RenderGrid&gt;(parent()))
 413         return;
 414 
 415     if (oldStyle-&gt;gridItemColumnStart() == style.gridItemColumnStart()
 416         &amp;&amp; oldStyle-&gt;gridItemColumnEnd() == style.gridItemColumnEnd()
 417         &amp;&amp; oldStyle-&gt;gridItemRowStart() == style.gridItemRowStart()
 418         &amp;&amp; oldStyle-&gt;gridItemRowEnd() == style.gridItemRowEnd()
 419         &amp;&amp; oldStyle-&gt;order() == style.order()
 420         &amp;&amp; oldStyle-&gt;hasOutOfFlowPosition() == style.hasOutOfFlowPosition())
 421         return;
 422 
 423     // Positioned items don&#39;t participate on the layout of the grid,
 424     // so we don&#39;t need to mark the grid as dirty if they change positions.
 425     if (oldStyle-&gt;hasOutOfFlowPosition() &amp;&amp; style.hasOutOfFlowPosition())
 426         return;
 427 
 428     // It should be possible to not dirty the grid in some cases (like moving an
 429     // explicitly placed grid item).
 430     // For now, it&#39;s more simple to just always recompute the grid.
 431     downcast&lt;RenderGrid&gt;(*parent()).dirtyGrid();
 432 }
 433 
 434 void RenderBox::updateShapeOutsideInfoAfterStyleChange(const RenderStyle&amp; style, const RenderStyle* oldStyle)
 435 {
 436     const ShapeValue* shapeOutside = style.shapeOutside();
 437     const ShapeValue* oldShapeOutside = oldStyle ? oldStyle-&gt;shapeOutside() : nullptr;
 438 
 439     Length shapeMargin = style.shapeMargin();
 440     Length oldShapeMargin = oldStyle ? oldStyle-&gt;shapeMargin() : RenderStyle::initialShapeMargin();
 441 
 442     float shapeImageThreshold = style.shapeImageThreshold();
 443     float oldShapeImageThreshold = oldStyle ? oldStyle-&gt;shapeImageThreshold() : RenderStyle::initialShapeImageThreshold();
 444 
 445     // FIXME: A future optimization would do a deep comparison for equality. (bug 100811)
 446     if (shapeOutside == oldShapeOutside &amp;&amp; shapeMargin == oldShapeMargin &amp;&amp; shapeImageThreshold == oldShapeImageThreshold)
 447         return;
 448 
 449     if (!shapeOutside)
 450         ShapeOutsideInfo::removeInfo(*this);
 451     else
 452         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();
 453 
 454     if (shapeOutside || shapeOutside != oldShapeOutside)
 455         markShapeOutsideDependentsForLayout();
 456 }
 457 
 458 void RenderBox::updateFromStyle()
 459 {
 460     RenderBoxModelObject::updateFromStyle();
 461 
 462     const RenderStyle&amp; styleToUse = style();
 463     bool isDocElementRenderer = isDocumentElementRenderer();
 464     bool isViewObject = isRenderView();
 465 
 466     // The root and the RenderView always paint their backgrounds/borders.
 467     if (isDocElementRenderer || isViewObject)
 468         setHasVisibleBoxDecorations(true);
 469 
 470     setFloating(!isOutOfFlowPositioned() &amp;&amp; styleToUse.isFloating());
 471 
 472     // We also handle &lt;body&gt; and &lt;html&gt;, whose overflow applies to the viewport.
 473     if (styleToUse.overflowX() != Overflow::Visible &amp;&amp; !isDocElementRenderer &amp;&amp; isRenderBlock()) {
 474         bool boxHasOverflowClip = true;
 475         if (isBody()) {
 476             // Overflow on the body can propagate to the viewport under the following conditions.
 477             // (1) The root element is &lt;html&gt;.
 478             // (2) We are the primary &lt;body&gt; (can be checked by looking at document.body).
 479             // (3) The root element has visible overflow.
 480             if (is&lt;HTMLHtmlElement&gt;(*document().documentElement())
 481                 &amp;&amp; document().body() == element()
 482                 &amp;&amp; document().documentElement()-&gt;renderer()-&gt;style().overflowX() == Overflow::Visible) {
 483                 boxHasOverflowClip = false;
 484             }
 485         }
 486         // Check for overflow clip.
 487         // It&#39;s sufficient to just check one direction, since it&#39;s illegal to have visible on only one overflow value.
 488         if (boxHasOverflowClip) {
 489             if (!s_hadOverflowClip &amp;&amp; hasRenderOverflow()) {
 490                 // Erase the overflow.
 491                 // Overflow changes have to result in immediate repaints of the entire layout overflow area because
 492                 // repaints issued by removal of descendants get clipped using the updated style when they shouldn&#39;t.
 493                 repaintRectangle(visualOverflowRect());
 494                 repaintRectangle(layoutOverflowRect());
 495             }
 496             setHasOverflowClip();
 497         }
 498     }
 499     setHasTransformRelatedProperty(styleToUse.hasTransformRelatedProperty());
 500     setHasReflection(styleToUse.boxReflect());
 501 }
 502 
 503 void RenderBox::layout()
 504 {
 505     StackStats::LayoutCheckPoint layoutCheckPoint;
 506     ASSERT(needsLayout());
 507 
 508     RenderObject* child = firstChild();
 509     if (!child) {
 510         clearNeedsLayout();
 511         return;
 512     }
 513 
 514     LayoutStateMaintainer statePusher(*this, locationOffset(), style().isFlippedBlocksWritingMode());
 515     while (child) {
 516         if (child-&gt;needsLayout())
 517             downcast&lt;RenderElement&gt;(*child).layout();
 518         ASSERT(!child-&gt;needsLayout());
 519         child = child-&gt;nextSibling();
 520     }
 521     invalidateBackgroundObscurationStatus();
 522     clearNeedsLayout();
 523 }
 524 
 525 // More IE extensions.  clientWidth and clientHeight represent the interior of an object
 526 // excluding border and scrollbar.
 527 LayoutUnit RenderBox::clientWidth() const
 528 {
 529     return paddingBoxWidth();
 530 }
 531 
 532 LayoutUnit RenderBox::clientHeight() const
 533 {
 534     return paddingBoxHeight();
 535 }
 536 
 537 int RenderBox::scrollWidth() const
 538 {
 539     if (hasOverflowClip() &amp;&amp; layer())
 540         return layer()-&gt;scrollWidth();
 541     // For objects with visible overflow, this matches IE.
 542     // FIXME: Need to work right with writing modes.
 543     if (style().isLeftToRightDirection()) {
 544         // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 545         return roundToInt(std::max(clientWidth(), layoutOverflowRect().maxX() - borderLeft()));
 546     }
 547     return roundToInt(clientWidth() - std::min&lt;LayoutUnit&gt;(0, layoutOverflowRect().x() - borderLeft()));
 548 }
 549 
 550 int RenderBox::scrollHeight() const
 551 {
 552     if (hasOverflowClip() &amp;&amp; layer())
 553         return layer()-&gt;scrollHeight();
 554     // For objects with visible overflow, this matches IE.
 555     // FIXME: Need to work right with writing modes.
 556     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 557     return roundToInt(std::max(clientHeight(), layoutOverflowRect().maxY() - borderTop()));
 558 }
 559 
 560 int RenderBox::scrollLeft() const
 561 {
 562     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().x() : 0;
 563 }
 564 
 565 int RenderBox::scrollTop() const
 566 {
 567     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
 568 }
 569 
 570 void RenderBox::resetLogicalHeightBeforeLayoutIfNeeded()
 571 {
 572     if (shouldResetLogicalHeightBeforeLayout() || (is&lt;RenderBlock&gt;(parent()) &amp;&amp; downcast&lt;RenderBlock&gt;(*parent()).shouldResetChildLogicalHeightBeforeLayout(*this)))
 573         setLogicalHeight(0_lu);
 574 }
 575 
 576 static void setupWheelEventMonitor(RenderLayer&amp; layer)
 577 {
 578     Page&amp; page = layer.renderer().page();
 579     if (!page.isMonitoringWheelEvents())
 580         return;
 581     layer.scrollAnimator().setWheelEventTestMonitor(page.wheelEventTestMonitor());
 582 }
 583 
 584 void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)
 585 {
 586     if (!hasOverflowClip() || !layer())
 587         return;
 588     setupWheelEventMonitor(*layer());
 589     layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);
 590 }
 591 
 592 void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)
 593 {
 594     if (!hasOverflowClip() || !layer())
 595         return;
 596     setupWheelEventMonitor(*layer());
 597     layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);
 598 }
 599 
 600 void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 601 {
 602     rects.append(snappedIntRect(accumulatedOffset, size()));
 603 }
 604 
 605 void RenderBox::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 606 {
 607     FloatRect localRect(0, 0, width(), height());
 608 
 609     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 610     if (fragmentedFlow &amp;&amp; fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
 611         return;
 612 
 613     quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
 614 }
 615 
 616 void RenderBox::updateLayerTransform()
 617 {
 618     // Transform-origin depends on box size, so we need to update the layer transform after layout.
 619     if (hasLayer())
 620         layer()-&gt;updateTransform();
 621 }
 622 
 623 LayoutUnit RenderBox::constrainLogicalWidthInFragmentByMinMax(LayoutUnit logicalWidth, LayoutUnit availableWidth, RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
 624 {
 625     const RenderStyle&amp; styleToUse = style();
 626     if (!styleToUse.logicalMaxWidth().isUndefined())
 627         logicalWidth = std::min(logicalWidth, computeLogicalWidthInFragmentUsing(MaxSize, styleToUse.logicalMaxWidth(), availableWidth, cb, fragment));
 628     return std::max(logicalWidth, computeLogicalWidthInFragmentUsing(MinSize, styleToUse.logicalMinWidth(), availableWidth, cb, fragment));
 629 }
 630 
 631 LayoutUnit RenderBox::constrainLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
 632 {
 633     const RenderStyle&amp; styleToUse = style();
 634     if (!styleToUse.logicalMaxHeight().isUndefined()) {
 635         if (Optional&lt;LayoutUnit&gt; maxH = computeLogicalHeightUsing(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 636             logicalHeight = std::min(logicalHeight, maxH.value());
 637     }
 638     if (Optional&lt;LayoutUnit&gt; computedLogicalHeight = computeLogicalHeightUsing(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 639         return std::max(logicalHeight, computedLogicalHeight.value());
 640     return logicalHeight;
 641 }
 642 
 643 LayoutUnit RenderBox::constrainContentBoxLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
 644 {
 645     const RenderStyle&amp; styleToUse = style();
 646     if (!styleToUse.logicalMaxHeight().isUndefined()) {
 647         if (Optional&lt;LayoutUnit&gt; maxH = computeContentLogicalHeight(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 648             logicalHeight = std::min(logicalHeight, maxH.value());
 649     }
 650     if (Optional&lt;LayoutUnit&gt; computedContentLogicalHeight = computeContentLogicalHeight(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 651         return std::max(logicalHeight, computedContentLogicalHeight.value());
 652     return logicalHeight;
 653 }
 654 
 655 RoundedRect::Radii RenderBox::borderRadii() const
 656 {
 657     auto&amp; style = this-&gt;style();
 658     LayoutRect bounds = frameRect();
 659 
 660     unsigned borderLeft = style.borderLeftWidth();
 661     unsigned borderTop = style.borderTopWidth();
 662     bounds.moveBy(LayoutPoint(borderLeft, borderTop));
 663     bounds.contract(borderLeft + style.borderRightWidth(), borderTop + style.borderBottomWidth());
 664     return style.getRoundedBorderFor(bounds).radii();
 665 }
 666 
 667 LayoutRect RenderBox::paddingBoxRect() const
 668 {
 669     auto verticalScrollbarWidth = this-&gt;verticalScrollbarWidth();
 670     LayoutUnit offsetForScrollbar = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth : 0;
 671 
 672     return LayoutRect(borderLeft() + offsetForScrollbar, borderTop(),
 673         width() - borderLeft() - borderRight() - verticalScrollbarWidth,
 674         height() - borderTop() - borderBottom() - horizontalScrollbarHeight());
 675 }
 676 
 677 LayoutRect RenderBox::contentBoxRect() const
 678 {
 679     return { contentBoxLocation(), contentSize() };
 680 }
 681 
 682 LayoutPoint RenderBox::contentBoxLocation() const
 683 {
 684     LayoutUnit scrollbarSpace = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth() : 0;
 685     return { borderLeft() + paddingLeft() + scrollbarSpace, borderTop() + paddingTop() };
 686 }
 687 
 688 IntRect RenderBox::absoluteContentBox() const
 689 {
 690     // This is wrong with transforms and flipped writing modes.
 691     IntRect rect = snappedIntRect(contentBoxRect());
 692     FloatPoint absPos = localToAbsolute();
 693     rect.move(absPos.x(), absPos.y());
 694     return rect;
 695 }
 696 
 697 FloatQuad RenderBox::absoluteContentQuad() const
 698 {
 699     LayoutRect rect = contentBoxRect();
 700     return localToAbsoluteQuad(FloatRect(rect));
 701 }
 702 
 703 LayoutRect RenderBox::outlineBoundsForRepaint(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap) const
 704 {
 705     LayoutRect box = borderBoundingBox();
 706     adjustRectForOutlineAndShadow(box);
 707 
 708     if (repaintContainer != this) {
 709         FloatQuad containerRelativeQuad;
 710         if (geometryMap)
 711             containerRelativeQuad = geometryMap-&gt;mapToContainer(box, repaintContainer);
 712         else
 713             containerRelativeQuad = localToContainerQuad(FloatRect(box), repaintContainer);
 714 
 715         box = LayoutRect(containerRelativeQuad.boundingBox());
 716     }
 717 
 718     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 719     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 720     box.move(view().frameView().layoutContext().layoutDelta());
 721 
 722     return LayoutRect(snapRectToDevicePixels(box, document().deviceScaleFactor()));
 723 }
 724 
 725 void RenderBox::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
 726 {
 727     if (!size().isEmpty())
 728         rects.append(LayoutRect(additionalOffset, size()));
 729 }
 730 
 731 int RenderBox::reflectionOffset() const
 732 {
 733     if (!style().boxReflect())
 734         return 0;
 735     if (style().boxReflect()-&gt;direction() == ReflectionDirection::Left || style().boxReflect()-&gt;direction() == ReflectionDirection::Right)
 736         return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
 737     return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
 738 }
 739 
 740 LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
 741 {
 742     if (!style().boxReflect())
 743         return LayoutRect();
 744 
 745     LayoutRect box = borderBoxRect();
 746     LayoutRect result = r;
 747     switch (style().boxReflect()-&gt;direction()) {
 748     case ReflectionDirection::Below:
 749         result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));
 750         break;
 751     case ReflectionDirection::Above:
 752         result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));
 753         break;
 754     case ReflectionDirection::Left:
 755         result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));
 756         break;
 757     case ReflectionDirection::Right:
 758         result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));
 759         break;
 760     }
 761     return result;
 762 }
 763 
 764 bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
 765 {
 766     return isFixedPositioned() &amp;&amp; container()-&gt;isRenderView() &amp;&amp; frameView.fixedElementsLayoutRelativeToFrame();
 767 }
 768 
 769 bool RenderBox::includeVerticalScrollbarSize() const
 770 {
 771     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 772         &amp;&amp; (style().overflowY() == Overflow::Scroll || style().overflowY() == Overflow::Auto);
 773 }
 774 
 775 bool RenderBox::includeHorizontalScrollbarSize() const
 776 {
 777     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 778         &amp;&amp; (style().overflowX() == Overflow::Scroll || style().overflowX() == Overflow::Auto);
 779 }
 780 
 781 int RenderBox::verticalScrollbarWidth() const
 782 {
 783     return includeVerticalScrollbarSize() ? layer()-&gt;verticalScrollbarWidth() : 0;
 784 }
 785 
 786 int RenderBox::horizontalScrollbarHeight() const
 787 {
 788     return includeHorizontalScrollbarSize() ? layer()-&gt;horizontalScrollbarHeight() : 0;
 789 }
 790 
 791 int RenderBox::intrinsicScrollbarLogicalWidth() const
 792 {
 793     if (!hasOverflowClip())
 794         return 0;
 795 
 796     if (isHorizontalWritingMode() &amp;&amp; (style().overflowY() == Overflow::Scroll &amp;&amp; !canUseOverlayScrollbars())) {
 797         ASSERT(layer() &amp;&amp; layer()-&gt;hasVerticalScrollbar());
 798         return verticalScrollbarWidth();
 799     }
 800 
 801     if (!isHorizontalWritingMode() &amp;&amp; (style().overflowX() == Overflow::Scroll &amp;&amp; !canUseOverlayScrollbars())) {
 802         ASSERT(layer() &amp;&amp; layer()-&gt;hasHorizontalScrollbar());
 803         return horizontalScrollbarHeight();
 804     }
 805 
 806     return 0;
 807 }
 808 
 809 bool RenderBox::scrollLayer(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement)
 810 {
 811     RenderLayer* boxLayer = layer();
 812     if (boxLayer &amp;&amp; boxLayer-&gt;scroll(direction, granularity, multiplier)) {
 813         if (stopElement)
 814             *stopElement = element();
 815 
 816         return true;
 817     }
 818 
 819     return false;
 820 }
 821 
 822 bool RenderBox::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement, RenderBox* startBox, const IntPoint&amp; wheelEventAbsolutePoint)
 823 {
 824     if (scrollLayer(direction, granularity, multiplier, stopElement))
 825         return true;
 826 
 827     if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == element())
 828         return true;
 829 
 830     RenderBlock* nextScrollBlock = containingBlock();
 831 
 832     if (nextScrollBlock &amp;&amp; !nextScrollBlock-&gt;isRenderView())
 833         return nextScrollBlock-&gt;scroll(direction, granularity, multiplier, stopElement, startBox, wheelEventAbsolutePoint);
 834 
 835     return false;
 836 }
 837 
 838 bool RenderBox::logicalScroll(ScrollLogicalDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement)
 839 {
 840     bool scrolled = false;
 841 
 842     RenderLayer* l = layer();
 843     if (l) {
 844 #if PLATFORM(COCOA)
 845         // On Mac only we reset the inline direction position when doing a document scroll (e.g., hitting Home/End).
 846         if (granularity == ScrollByDocument)
 847             scrolled = l-&gt;scroll(logicalToPhysical(ScrollInlineDirectionBackward, isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), ScrollByDocument, multiplier);
 848 #endif
 849         if (l-&gt;scroll(logicalToPhysical(direction, isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), granularity, multiplier))
 850             scrolled = true;
 851 
 852         if (scrolled) {
 853             if (stopElement)
 854                 *stopElement = element();
 855             return true;
 856         }
 857     }
 858 
 859     if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == element())
 860         return true;
 861 
 862     RenderBlock* b = containingBlock();
 863     if (b &amp;&amp; !b-&gt;isRenderView())
 864         return b-&gt;logicalScroll(direction, granularity, multiplier, stopElement);
 865     return false;
 866 }
 867 
 868 bool RenderBox::canBeScrolledAndHasScrollableArea() const
 869 {
 870     return canBeProgramaticallyScrolled() &amp;&amp; (hasHorizontalOverflow() || hasVerticalOverflow());
 871 }
 872 
 873 bool RenderBox::isScrollableOrRubberbandableBox() const
 874 {
 875     return canBeScrolledAndHasScrollableArea();
 876 }
 877 
 878 // FIXME: This is badly named. overflow:hidden can be programmatically scrolled, yet this returns false in that case.
 879 bool RenderBox::canBeProgramaticallyScrolled() const
 880 {
 881     if (isRenderView())
 882         return true;
 883 
 884     if (!hasOverflowClip())
 885         return false;
 886 
 887     if (hasScrollableOverflowX() || hasScrollableOverflowY())
 888         return true;
 889 
 890     return element() &amp;&amp; element()-&gt;hasEditableStyle();
 891 }
 892 
 893 bool RenderBox::usesCompositedScrolling() const
 894 {
 895     return hasOverflowClip() &amp;&amp; hasLayer() &amp;&amp; layer()-&gt;usesCompositedScrolling();
 896 }
 897 
 898 void RenderBox::autoscroll(const IntPoint&amp; position)
 899 {
 900     if (layer())
 901         layer()-&gt;autoscroll(position);
 902 }
 903 
 904 // There are two kinds of renderer that can autoscroll.
 905 bool RenderBox::canAutoscroll() const
 906 {
 907     if (isRenderView())
 908         return view().frameView().isScrollable();
 909 
 910     // Check for a box that can be scrolled in its own right.
 911     if (canBeScrolledAndHasScrollableArea())
 912         return true;
 913 
 914     return false;
 915 }
 916 
 917 // If specified point is in border belt, returned offset denotes direction of
 918 // scrolling.
 919 IntSize RenderBox::calculateAutoscrollDirection(const IntPoint&amp; windowPoint) const
 920 {
 921     IntRect box(absoluteBoundingBoxRect());
 922     box.moveBy(view().frameView().scrollPosition());
 923     IntRect windowBox = view().frameView().contentsToWindow(box);
 924 
 925     IntPoint windowAutoscrollPoint = windowPoint;
 926 
 927     if (windowAutoscrollPoint.x() &lt; windowBox.x() + autoscrollBeltSize)
 928         windowAutoscrollPoint.move(-autoscrollBeltSize, 0);
 929     else if (windowAutoscrollPoint.x() &gt; windowBox.maxX() - autoscrollBeltSize)
 930         windowAutoscrollPoint.move(autoscrollBeltSize, 0);
 931 
 932     if (windowAutoscrollPoint.y() &lt; windowBox.y() + autoscrollBeltSize)
 933         windowAutoscrollPoint.move(0, -autoscrollBeltSize);
 934     else if (windowAutoscrollPoint.y() &gt; windowBox.maxY() - autoscrollBeltSize)
 935         windowAutoscrollPoint.move(0, autoscrollBeltSize);
 936 
 937     return windowAutoscrollPoint - windowPoint;
 938 }
 939 
 940 RenderBox* RenderBox::findAutoscrollable(RenderObject* renderer)
 941 {
 942     while (renderer &amp;&amp; !(is&lt;RenderBox&gt;(*renderer) &amp;&amp; downcast&lt;RenderBox&gt;(*renderer).canAutoscroll())) {
 943         if (is&lt;RenderView&gt;(*renderer) &amp;&amp; renderer-&gt;document().ownerElement())
 944             renderer = renderer-&gt;document().ownerElement()-&gt;renderer();
 945         else
 946             renderer = renderer-&gt;parent();
 947     }
 948 
 949     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 950 }
 951 
 952 void RenderBox::panScroll(const IntPoint&amp; source)
 953 {
 954     if (layer())
 955         layer()-&gt;panScrollFromPoint(source);
 956 }
 957 
 958 bool RenderBox::canUseOverlayScrollbars() const
 959 {
 960     return !style().hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
 961 }
 962 
 963 bool RenderBox::hasVerticalScrollbarWithAutoBehavior() const
 964 {
 965     return hasOverflowClip() &amp;&amp; (style().overflowY() == Overflow::Auto || (style().overflowY() == Overflow::Scroll &amp;&amp; canUseOverlayScrollbars()));
 966 }
 967 
 968 bool RenderBox::hasHorizontalScrollbarWithAutoBehavior() const
 969 {
 970     return hasOverflowClip() &amp;&amp; (style().overflowX() == Overflow::Auto || (style().overflowX() == Overflow::Scroll &amp;&amp; canUseOverlayScrollbars()));
 971 }
 972 
 973 bool RenderBox::needsPreferredWidthsRecalculation() const
 974 {
 975     return style().paddingStart().isPercentOrCalculated() || style().paddingEnd().isPercentOrCalculated();
 976 }
 977 
 978 ScrollPosition RenderBox::scrollPosition() const
 979 {
 980     if (!hasOverflowClip())
 981         return { 0, 0 };
 982 
 983     ASSERT(hasLayer());
 984     return layer()-&gt;scrollPosition();
 985 }
 986 
 987 LayoutSize RenderBox::cachedSizeForOverflowClip() const
 988 {
 989     ASSERT(hasOverflowClip());
 990     ASSERT(hasLayer());
 991     return layer()-&gt;size();
 992 }
 993 
 994 bool RenderBox::applyCachedClipAndScrollPosition(LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 995 {
 996     flipForWritingMode(rect);
 997 
 998     if (context.m_options.contains(VisibleRectContextOption::ApplyCompositedContainerScrolls) || this != container || !usesCompositedScrolling())
 999         rect.moveBy(-scrollPosition()); // For overflow:auto/scroll/hidden.
1000 
1001     // Do not clip scroll layer contents to reduce the number of repaints while scrolling.
1002     if ((!context.m_options.contains(VisibleRectContextOption::ApplyCompositedClips) &amp;&amp; usesCompositedScrolling())
1003         || (!context.m_options.contains(VisibleRectContextOption::ApplyContainerClip) &amp;&amp; this == container)) {
1004         flipForWritingMode(rect);
1005         return true;
1006     }
1007 
1008     // height() is inaccurate if we&#39;re in the middle of a layout of this RenderBox, so use the
1009     // layer&#39;s size instead. Even if the layer&#39;s size is wrong, the layer itself will repaint
1010     // anyway if its size does change.
1011     LayoutRect clipRect(LayoutPoint(), cachedSizeForOverflowClip());
1012     bool intersects;
1013     if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
1014         intersects = rect.edgeInclusiveIntersect(clipRect);
1015     else {
1016         rect.intersect(clipRect);
1017         intersects = !rect.isEmpty();
1018     }
1019     flipForWritingMode(rect);
1020     return intersects;
1021 }
1022 
1023 void RenderBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
1024 {
1025     minLogicalWidth = minPreferredLogicalWidth() - borderAndPaddingLogicalWidth();
1026     maxLogicalWidth = maxPreferredLogicalWidth() - borderAndPaddingLogicalWidth();
1027 }
1028 
1029 LayoutUnit RenderBox::minPreferredLogicalWidth() const
1030 {
1031     if (preferredLogicalWidthsDirty()) {
1032 #ifndef NDEBUG
1033         SetLayoutNeededForbiddenScope layoutForbiddenScope(const_cast&lt;RenderBox*&gt;(this));
1034 #endif
1035         const_cast&lt;RenderBox*&gt;(this)-&gt;computePreferredLogicalWidths();
1036     }
1037 
1038     return m_minPreferredLogicalWidth;
1039 }
1040 
1041 LayoutUnit RenderBox::maxPreferredLogicalWidth() const
1042 {
1043     if (preferredLogicalWidthsDirty()) {
1044 #ifndef NDEBUG
1045         SetLayoutNeededForbiddenScope layoutForbiddenScope(const_cast&lt;RenderBox*&gt;(this));
1046 #endif
1047         const_cast&lt;RenderBox*&gt;(this)-&gt;computePreferredLogicalWidths();
1048     }
1049 
1050     return m_maxPreferredLogicalWidth;
1051 }
1052 
1053 bool RenderBox::hasOverrideContentLogicalHeight() const
1054 {
1055     return gOverrideContentLogicalHeightMap &amp;&amp; gOverrideContentLogicalHeightMap-&gt;contains(this);
1056 }
1057 
1058 bool RenderBox::hasOverrideContentLogicalWidth() const
1059 {
1060     return gOverrideContentLogicalWidthMap &amp;&amp; gOverrideContentLogicalWidthMap-&gt;contains(this);
1061 }
1062 
1063 void RenderBox::setOverrideContentLogicalHeight(LayoutUnit height)
1064 {
1065     if (!gOverrideContentLogicalHeightMap)
1066         gOverrideContentLogicalHeightMap = new OverrideSizeMap();
1067     gOverrideContentLogicalHeightMap-&gt;set(this, height);
1068 }
1069 
1070 void RenderBox::setOverrideContentLogicalWidth(LayoutUnit width)
1071 {
1072     if (!gOverrideContentLogicalWidthMap)
1073         gOverrideContentLogicalWidthMap = new OverrideSizeMap();
1074     gOverrideContentLogicalWidthMap-&gt;set(this, width);
1075 }
1076 
1077 void RenderBox::clearOverrideContentLogicalHeight()
1078 {
1079     if (gOverrideContentLogicalHeightMap)
1080         gOverrideContentLogicalHeightMap-&gt;remove(this);
1081 }
1082 
1083 void RenderBox::clearOverrideContentLogicalWidth()
1084 {
1085     if (gOverrideContentLogicalWidthMap)
1086         gOverrideContentLogicalWidthMap-&gt;remove(this);
1087 }
1088 
1089 void RenderBox::clearOverrideContentSize()
1090 {
1091     clearOverrideContentLogicalHeight();
1092     clearOverrideContentLogicalWidth();
1093 }
1094 
1095 LayoutUnit RenderBox::overrideContentLogicalWidth() const
1096 {
1097     ASSERT(hasOverrideContentLogicalWidth());
1098     return gOverrideContentLogicalWidthMap-&gt;get(this);
1099 }
1100 
1101 LayoutUnit RenderBox::overrideContentLogicalHeight() const
1102 {
1103     ASSERT(hasOverrideContentLogicalHeight());
1104     return gOverrideContentLogicalHeightMap-&gt;get(this);
1105 }
1106 
1107 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentWidth() const
1108 {
1109     ASSERT(hasOverrideContainingBlockContentWidth());
1110     return containingBlock()-&gt;style().isHorizontalWritingMode()
1111         ? gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this)
1112         : gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this);
1113 }
1114 
1115 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentHeight() const
1116 {
1117     ASSERT(hasOverrideContainingBlockContentHeight());
1118     return containingBlock()-&gt;style().isHorizontalWritingMode()
1119         ? gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this)
1120         : gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this);
1121 }
1122 
1123 bool RenderBox::hasOverrideContainingBlockContentWidth() const
1124 {
1125     RenderBlock* cb = containingBlock();
1126     if (!cb)
1127         return false;
1128 
1129     return cb-&gt;style().isHorizontalWritingMode()
1130         ? gOverrideContainingBlockContentLogicalWidthMap &amp;&amp; gOverrideContainingBlockContentLogicalWidthMap-&gt;contains(this)
1131         : gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1132 }
1133 
1134 bool RenderBox::hasOverrideContainingBlockContentHeight() const
1135 {
1136     RenderBlock* cb = containingBlock();
1137     if (!cb)
1138         return false;
1139 
1140     return cb-&gt;style().isHorizontalWritingMode()
1141         ? gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this)
1142         : gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1143 }
1144 
1145 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentLogicalWidth() const
1146 {
1147     ASSERT(hasOverrideContainingBlockContentLogicalWidth());
1148     return gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this);
1149 }
1150 
1151 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentLogicalHeight() const
1152 {
1153     ASSERT(hasOverrideContainingBlockContentLogicalHeight());
1154     return gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this);
1155 }
1156 
1157 bool RenderBox::hasOverrideContainingBlockContentLogicalWidth() const
1158 {
1159     return gOverrideContainingBlockContentLogicalWidthMap &amp;&amp; gOverrideContainingBlockContentLogicalWidthMap-&gt;contains(this);
1160 }
1161 
1162 bool RenderBox::hasOverrideContainingBlockContentLogicalHeight() const
1163 {
1164     return gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1165 }
1166 
1167 void RenderBox::setOverrideContainingBlockContentLogicalWidth(Optional&lt;LayoutUnit&gt; logicalWidth)
1168 {
1169     if (!gOverrideContainingBlockContentLogicalWidthMap)
1170         gOverrideContainingBlockContentLogicalWidthMap = new OverrideOptionalSizeMap;
1171     gOverrideContainingBlockContentLogicalWidthMap-&gt;set(this, logicalWidth);
1172 }
1173 
1174 void RenderBox::setOverrideContainingBlockContentLogicalHeight(Optional&lt;LayoutUnit&gt; logicalHeight)
1175 {
1176     if (!gOverrideContainingBlockContentLogicalHeightMap)
1177         gOverrideContainingBlockContentLogicalHeightMap = new OverrideOptionalSizeMap;
1178     gOverrideContainingBlockContentLogicalHeightMap-&gt;set(this, logicalHeight);
1179 }
1180 
1181 void RenderBox::clearOverrideContainingBlockContentSize()
1182 {
1183     if (gOverrideContainingBlockContentLogicalWidthMap)
1184         gOverrideContainingBlockContentLogicalWidthMap-&gt;remove(this);
1185     clearOverrideContainingBlockContentLogicalHeight();
1186 }
1187 
1188 void RenderBox::clearOverrideContainingBlockContentLogicalHeight()
1189 {
1190     if (gOverrideContainingBlockContentLogicalHeightMap)
1191         gOverrideContainingBlockContentLogicalHeightMap-&gt;remove(this);
1192 }
1193 
1194 LayoutUnit RenderBox::adjustBorderBoxLogicalWidthForBoxSizing(LayoutUnit width) const
1195 {
1196     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalWidth();
1197     if (style().boxSizing() == BoxSizing::ContentBox)
1198         return width + bordersPlusPadding;
1199     return std::max(width, bordersPlusPadding);
1200 }
1201 
1202 LayoutUnit RenderBox::adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const
1203 {
1204     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
1205     if (style().boxSizing() == BoxSizing::ContentBox)
1206         return height + bordersPlusPadding;
1207     return std::max(height, bordersPlusPadding);
1208 }
1209 
1210 LayoutUnit RenderBox::adjustContentBoxLogicalWidthForBoxSizing(LayoutUnit width) const
1211 {
1212     if (style().boxSizing() == BoxSizing::BorderBox)
1213         width -= borderAndPaddingLogicalWidth();
1214     return std::max&lt;LayoutUnit&gt;(0, width);
1215 }
1216 
1217 LayoutUnit RenderBox::adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const
1218 {
1219     if (!height)
1220         return 0;
1221     LayoutUnit result = height.value();
1222     if (style().boxSizing() == BoxSizing::BorderBox)
1223         result -= borderAndPaddingLogicalHeight();
1224     return std::max(0_lu, result);
1225 }
1226 
1227 // Hit Testing
1228 bool RenderBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction action)
1229 {
1230     LayoutPoint adjustedLocation = accumulatedOffset + location();
1231 
1232     // Check kids first.
1233     for (RenderObject* child = lastChild(); child; child = child-&gt;previousSibling()) {
1234         if (!child-&gt;hasLayer() &amp;&amp; child-&gt;nodeAtPoint(request, result, locationInContainer, adjustedLocation, action)) {
1235             updateHitTestResult(result, locationInContainer.point() - toLayoutSize(adjustedLocation));
1236             return true;
1237         }
1238     }
1239 
1240     // Check our bounds next. For this purpose always assume that we can only be hit in the
1241     // foreground phase (which is true for replaced elements like images).
1242     LayoutRect boundsRect = borderBoxRectInFragment(nullptr);
1243     boundsRect.moveBy(adjustedLocation);
1244     if (visibleToHitTesting() &amp;&amp; action == HitTestForeground &amp;&amp; locationInContainer.intersects(boundsRect)) {
1245         updateHitTestResult(result, locationInContainer.point() - toLayoutSize(adjustedLocation));
1246         if (result.addNodeToListBasedTestResult(element(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
1247             return true;
1248     }
1249 
1250     return false;
1251 }
1252 
1253 // --------------------- painting stuff -------------------------------
1254 
1255 void RenderBox::paintRootBoxFillLayers(const PaintInfo&amp; paintInfo)
1256 {
1257     ASSERT(isDocumentElementRenderer());
1258     if (paintInfo.skipRootBackground())
1259         return;
1260 
1261     auto* rootBackgroundRenderer = view().rendererForRootBackground();
1262     if (!rootBackgroundRenderer)
1263         return;
1264 
1265     auto&amp; style = rootBackgroundRenderer-&gt;style();
1266     auto color = style.visitedDependentColor(CSSPropertyBackgroundColor);
1267     auto compositeOp = document().compositeOperatorForBackgroundColor(color, *this);
1268 
1269     paintFillLayers(paintInfo, style.colorByApplyingColorFilter(color), style.backgroundLayers(), view().backgroundRect(), BackgroundBleedNone, compositeOp, rootBackgroundRenderer);
1270 }
1271 
1272 BackgroundBleedAvoidance RenderBox::determineBackgroundBleedAvoidance(GraphicsContext&amp; context) const
1273 {
1274     if (context.paintingDisabled())
1275         return BackgroundBleedNone;
1276 
1277     const RenderStyle&amp; style = this-&gt;style();
1278 
1279     if (!style.hasBackground() || !style.hasBorder() || !style.hasBorderRadius() || borderImageIsLoadedAndCanBeRendered())
1280         return BackgroundBleedNone;
1281 
1282     AffineTransform ctm = context.getCTM();
1283     FloatSize contextScaling(static_cast&lt;float&gt;(ctm.xScale()), static_cast&lt;float&gt;(ctm.yScale()));
1284 
1285     // Because RoundedRect uses IntRect internally the inset applied by the
1286     // BackgroundBleedShrinkBackground strategy cannot be less than one integer
1287     // layout coordinate, even with subpixel layout enabled. To take that into
1288     // account, we clamp the contextScaling to 1.0 for the following test so
1289     // that borderObscuresBackgroundEdge can only return true if the border
1290     // widths are greater than 2 in both layout coordinates and screen
1291     // coordinates.
1292     // This precaution will become obsolete if RoundedRect is ever promoted to
1293     // a sub-pixel representation.
1294     if (contextScaling.width() &gt; 1)
1295         contextScaling.setWidth(1);
1296     if (contextScaling.height() &gt; 1)
1297         contextScaling.setHeight(1);
1298 
1299     if (borderObscuresBackgroundEdge(contextScaling))
1300         return BackgroundBleedShrinkBackground;
1301     if (!style.hasAppearance() &amp;&amp; borderObscuresBackground() &amp;&amp; backgroundHasOpaqueTopLayer())
1302         return BackgroundBleedBackgroundOverBorder;
1303 
1304     return BackgroundBleedUseTransparencyLayer;
1305 }
1306 
1307 void RenderBox::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1308 {
1309     if (!paintInfo.shouldPaintWithinRoot(*this))
1310         return;
1311 
1312     LayoutRect paintRect = borderBoxRectInFragment(nullptr);
1313     paintRect.moveBy(paintOffset);
1314     adjustBorderBoxRectForPainting(paintRect);
1315 
1316 #if PLATFORM(IOS_FAMILY)
1317     // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
1318     // FIXME: Consolidate this code with the same code in RenderElement::paintOutline(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.
1319     if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1320         int width = std::min(paintRect.width(), paintRect.height());
1321         int height = width;
1322         paintRect = IntRect { paintRect.x(), paintRect.y() + (this-&gt;height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop
1323     }
1324 #endif
1325     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
1326 
1327     // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
1328     // custom shadows of their own.
1329     if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1330         paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Normal);
1331 
1332     GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
1333     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
1334         // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
1335         // into a transparency layer, and then clip that in one go (which requires setting up the clip before
1336         // beginning the layer).
1337         stateSaver.save();
1338         paintInfo.context().clipRoundedRect(style().getRoundedBorderFor(paintRect).pixelSnappedRoundedRectForPainting(document().deviceScaleFactor()));
1339         paintInfo.context().beginTransparencyLayer(1);
1340     }
1341 
1342     // If we have a native theme appearance, paint that before painting our background.
1343     // The theme will tell us whether or not we should also paint the CSS background.
1344     bool borderOrBackgroundPaintingIsNeeded = true;
1345     if (style().hasAppearance()) {
1346         ControlStates* controlStates = controlStatesForRenderer(*this);
1347         borderOrBackgroundPaintingIsNeeded = theme().paint(*this, *controlStates, paintInfo, paintRect);
1348         if (controlStates-&gt;needsRepaint())
1349             view().scheduleLazyRepaint(*this);
1350     }
1351 
1352     if (borderOrBackgroundPaintingIsNeeded) {
1353         if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
1354             paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1355 
1356         paintBackground(paintInfo, paintRect, bleedAvoidance);
1357 
1358         if (style().hasAppearance())
1359             theme().paintDecorations(*this, paintInfo, paintRect);
1360     }
1361     paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Inset);
1362 
1363     // The theme will tell us whether or not we should also paint the CSS border.
1364     if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
1365         paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1366 
1367     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer)
1368         paintInfo.context().endTransparencyLayer();
1369 }
1370 
1371 bool RenderBox::paintsOwnBackground() const
1372 {
1373     if (isBody()) {
1374         // The &lt;body&gt; only paints its background if the root element has defined a background independent of the body,
1375         // or if the &lt;body&gt;&#39;s parent is not the document element&#39;s renderer (e.g. inside SVG foreignObject).
1376         auto documentElementRenderer = document().documentElement()-&gt;renderer();
1377         return !documentElementRenderer
1378             || documentElementRenderer-&gt;hasBackground()
1379             || (documentElementRenderer != parent());
1380     }
1381 
1382     return true;
1383 }
1384 
1385 void RenderBox::paintBackground(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect, BackgroundBleedAvoidance bleedAvoidance)
1386 {
1387     if (isDocumentElementRenderer()) {
1388         paintRootBoxFillLayers(paintInfo);
1389         return;
1390     }
1391 
1392     if (!paintsOwnBackground())
1393         return;
1394 
1395     if (backgroundIsKnownToBeObscured(paintRect.location()) &amp;&amp; !boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1396         return;
1397 
1398     auto backgroundColor = style().visitedDependentColor(CSSPropertyBackgroundColor);
1399     auto compositeOp = document().compositeOperatorForBackgroundColor(backgroundColor, *this);
1400 
1401     paintFillLayers(paintInfo, style().colorByApplyingColorFilter(backgroundColor), style().backgroundLayers(), paintRect, bleedAvoidance, compositeOp);
1402 }
1403 
1404 bool RenderBox::getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp; paintedExtent) const
1405 {
1406     ASSERT(hasBackground());
1407     LayoutRect backgroundRect = snappedIntRect(borderBoxRect());
1408 
1409     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1410     if (backgroundColor.isVisible()) {
1411         paintedExtent = backgroundRect;
1412         return true;
1413     }
1414 
1415     auto&amp; layers = style().backgroundLayers();
1416     if (!layers.image() || layers.next()) {
1417         paintedExtent =  backgroundRect;
1418         return true;
1419     }
1420 
1421     auto geometry = calculateBackgroundImageGeometry(nullptr, layers, paintOffset, backgroundRect);
1422     paintedExtent = geometry.destRect();
1423     return !geometry.hasNonLocalGeometry();
1424 }
1425 
1426 bool RenderBox::backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const
1427 {
1428     if (!paintsOwnBackground())
1429         return false;
1430 
1431     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1432     if (!backgroundColor.isOpaque())
1433         return false;
1434 
1435     // If the element has appearance, it might be painted by theme.
1436     // We cannot be sure if theme paints the background opaque.
1437     // In this case it is safe to not assume opaqueness.
1438     // FIXME: May be ask theme if it paints opaque.
1439     if (style().hasAppearance())
1440         return false;
1441     // FIXME: Check the opaqueness of background images.
1442 
1443     if (hasClip() || hasClipPath())
1444         return false;
1445 
1446     // FIXME: Use rounded rect if border radius is present.
1447     if (style().hasBorderRadius())
1448         return false;
1449 
1450     // FIXME: The background color clip is defined by the last layer.
1451     if (style().backgroundLayers().next())
1452         return false;
1453     LayoutRect backgroundRect;
1454     switch (style().backgroundClip()) {
1455     case FillBox::Border:
1456         backgroundRect = borderBoxRect();
1457         break;
1458     case FillBox::Padding:
1459         backgroundRect = paddingBoxRect();
1460         break;
1461     case FillBox::Content:
1462         backgroundRect = contentBoxRect();
1463         break;
1464     default:
1465         break;
1466     }
1467     return backgroundRect.contains(localRect);
1468 }
1469 
1470 static bool isCandidateForOpaquenessTest(const RenderBox&amp; childBox)
1471 {
1472     const RenderStyle&amp; childStyle = childBox.style();
1473     if (childStyle.position() != PositionType::Static &amp;&amp; childBox.containingBlock() != childBox.parent())
1474         return false;
1475     if (childStyle.visibility() != Visibility::Visible)
1476         return false;
1477     if (childStyle.shapeOutside())
1478         return false;
1479     if (!childBox.width() || !childBox.height())
1480         return false;
1481     if (RenderLayer* childLayer = childBox.layer()) {
1482         if (childLayer-&gt;isComposited())
1483             return false;
1484         // FIXME: Deal with z-index.
1485         if (!childStyle.hasAutoUsedZIndex())
1486             return false;
1487         if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
1488             return false;
1489         if (!childBox.scrollPosition().isZero())
1490             return false;
1491     }
1492     return true;
1493 }
1494 
1495 bool RenderBox::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
1496 {
1497     if (!maxDepthToTest)
1498         return false;
1499 
1500     for (auto&amp; childBox : childrenOfType&lt;RenderBox&gt;(*this)) {
1501         if (!isCandidateForOpaquenessTest(childBox))
1502             continue;
1503         LayoutPoint childLocation = childBox.location();
1504         if (childBox.isRelativelyPositioned())
1505             childLocation.move(childBox.relativePositionOffset());
1506         LayoutRect childLocalRect = localRect;
1507         childLocalRect.moveBy(-childLocation);
1508         if (childLocalRect.y() &lt; 0 || childLocalRect.x() &lt; 0) {
1509             // If there is unobscured area above/left of a static positioned box then the rect is probably not covered.
1510             if (childBox.style().position() == PositionType::Static)
1511                 return false;
1512             continue;
1513         }
1514         if (childLocalRect.maxY() &gt; childBox.height() || childLocalRect.maxX() &gt; childBox.width())
1515             continue;
1516         if (childBox.backgroundIsKnownToBeOpaqueInRect(childLocalRect))
1517             return true;
1518         if (childBox.foregroundIsKnownToBeOpaqueInRect(childLocalRect, maxDepthToTest - 1))
1519             return true;
1520     }
1521     return false;
1522 }
1523 
1524 bool RenderBox::computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
1525 {
1526     // Test to see if the children trivially obscure the background.
1527     // FIXME: This test can be much more comprehensive.
1528     if (!hasBackground())
1529         return false;
1530     // Table and root background painting is special.
1531     if (isTable() || isDocumentElementRenderer())
1532         return false;
1533 
1534     LayoutRect backgroundRect;
1535     if (!getBackgroundPaintedExtent(paintOffset, backgroundRect))
1536         return false;
1537 
1538     if (hasLayer() &amp;&amp; layer()-&gt;scrollingMayRevealBackground())
1539         return false;
1540 
1541     return foregroundIsKnownToBeOpaqueInRect(backgroundRect, backgroundObscurationTestMaxDepth);
1542 }
1543 
1544 bool RenderBox::backgroundHasOpaqueTopLayer() const
1545 {
1546     auto&amp; fillLayer = style().backgroundLayers();
1547     if (fillLayer.clip() != FillBox::Border)
1548         return false;
1549 
1550     // Clipped with local scrolling
1551     if (hasOverflowClip() &amp;&amp; fillLayer.attachment() == FillAttachment::LocalBackground)
1552         return false;
1553 
1554     if (fillLayer.hasOpaqueImage(*this) &amp;&amp; fillLayer.hasRepeatXY() &amp;&amp; fillLayer.image()-&gt;canRender(this, style().effectiveZoom()))
1555         return true;
1556 
1557     // If there is only one layer and no image, check whether the background color is opaque.
1558     if (!fillLayer.next() &amp;&amp; !fillLayer.hasImage()) {
1559         Color bgColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1560         if (bgColor.isOpaque())
1561             return true;
1562     }
1563 
1564     return false;
1565 }
1566 
1567 void RenderBox::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1568 {
1569     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask || paintInfo.context().paintingDisabled())
1570         return;
1571 
1572     LayoutRect paintRect = LayoutRect(paintOffset, size());
1573     adjustBorderBoxRectForPainting(paintRect);
1574     paintMaskImages(paintInfo, paintRect);
1575 }
1576 
1577 void RenderBox::paintClippingMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1578 {
1579     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::ClippingMask || paintInfo.context().paintingDisabled())
1580         return;
1581 
1582     LayoutRect paintRect = LayoutRect(paintOffset, size());
1583     paintInfo.context().fillRect(snappedIntRect(paintRect), Color::black);
1584 }
1585 
1586 void RenderBox::paintMaskImages(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1587 {
1588     // Figure out if we need to push a transparency layer to render our mask.
1589     bool pushTransparencyLayer = false;
1590     bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
1591     bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
1592     CompositeOperator compositeOp = CompositeOperator::SourceOver;
1593 
1594     bool allMaskImagesLoaded = true;
1595 
1596     if (!compositedMask || flattenCompositingLayers) {
1597         pushTransparencyLayer = true;
1598 
1599         // Don&#39;t render a masked element until all the mask images have loaded, to prevent a flash of unmasked content.
1600         if (auto* maskBoxImage = style().maskBoxImage().image())
1601             allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
1602 
1603         allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
1604 
1605         paintInfo.context().setCompositeOperation(CompositeOperator::DestinationIn);
1606         paintInfo.context().beginTransparencyLayer(1);
1607         compositeOp = CompositeOperator::SourceOver;
1608     }
1609 
1610     if (allMaskImagesLoaded) {
1611         paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
1612         paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
1613     }
1614 
1615     if (pushTransparencyLayer)
1616         paintInfo.context().endTransparencyLayer();
1617 }
1618 
1619 LayoutRect RenderBox::maskClipRect(const LayoutPoint&amp; paintOffset)
1620 {
1621     const NinePieceImage&amp; maskBoxImage = style().maskBoxImage();
1622     if (maskBoxImage.image()) {
1623         LayoutRect borderImageRect = borderBoxRect();
1624 
1625         // Apply outsets to the border box.
1626         borderImageRect.expand(style().maskBoxImageOutsets());
1627         return borderImageRect;
1628     }
1629 
1630     LayoutRect result;
1631     LayoutRect borderBox = borderBoxRect();
1632     for (auto* maskLayer = &amp;style().maskLayers(); maskLayer; maskLayer = maskLayer-&gt;next()) {
1633         if (maskLayer-&gt;image()) {
1634             // Masks should never have fixed attachment, so it&#39;s OK for paintContainer to be null.
1635             result.unite(calculateBackgroundImageGeometry(nullptr, *maskLayer, paintOffset, borderBox).destRect());
1636         }
1637     }
1638     return result;
1639 }
1640 
1641 void RenderBox::paintFillLayers(const PaintInfo&amp; paintInfo, const Color&amp; color, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect,
1642     BackgroundBleedAvoidance bleedAvoidance, CompositeOperator op, RenderElement* backgroundObject)
1643 {
1644     Vector&lt;const FillLayer*, 8&gt; layers;
1645     bool shouldDrawBackgroundInSeparateBuffer = false;
1646 
1647     for (auto* layer = &amp;fillLayer; layer; layer = layer-&gt;next()) {
1648         layers.append(layer);
1649 
1650         if (layer-&gt;blendMode() != BlendMode::Normal)
1651             shouldDrawBackgroundInSeparateBuffer = true;
1652 
1653         // Stop traversal when an opaque layer is encountered.
1654         // FIXME: It would be possible for the following occlusion culling test to be more aggressive
1655         // on layers with no repeat by testing whether the image covers the layout rect.
1656         // Testing that here would imply duplicating a lot of calculations that are currently done in
1657         // RenderBoxModelObject::paintFillLayerExtended. A more efficient solution might be to move
1658         // the layer recursion into paintFillLayerExtended, or to compute the layer geometry here
1659         // and pass it down.
1660 
1661         // The clipOccludesNextLayers condition must be evaluated first to avoid short-circuiting.
1662         if (layer-&gt;clipOccludesNextLayers(layer == &amp;fillLayer) &amp;&amp; layer-&gt;hasOpaqueImage(*this) &amp;&amp; layer-&gt;image()-&gt;canRender(this, style().effectiveZoom()) &amp;&amp; layer-&gt;hasRepeatXY() &amp;&amp; layer-&gt;blendMode() == BlendMode::Normal)
1663             break;
1664     }
1665 
1666     auto&amp; context = paintInfo.context();
1667     auto baseBgColorUsage = BaseBackgroundColorUse;
1668 
1669     if (shouldDrawBackgroundInSeparateBuffer) {
1670         paintFillLayer(paintInfo, color, *layers.last(), rect, bleedAvoidance, op, backgroundObject, BaseBackgroundColorOnly);
1671         baseBgColorUsage = BaseBackgroundColorSkip;
1672         context.beginTransparencyLayer(1);
1673     }
1674 
1675     auto topLayer = layers.rend();
1676     for (auto it = layers.rbegin(); it != topLayer; ++it)
1677         paintFillLayer(paintInfo, color, **it, rect, bleedAvoidance, op, backgroundObject, baseBgColorUsage);
1678 
1679     if (shouldDrawBackgroundInSeparateBuffer)
1680         context.endTransparencyLayer();
1681 }
1682 
1683 void RenderBox::paintFillLayer(const PaintInfo&amp; paintInfo, const Color&amp; c, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect,
1684     BackgroundBleedAvoidance bleedAvoidance, CompositeOperator op, RenderElement* backgroundObject, BaseBackgroundColorUsage baseBgColorUsage)
1685 {
1686     paintFillLayerExtended(paintInfo, c, fillLayer, rect, bleedAvoidance, nullptr, LayoutSize(), op, backgroundObject, baseBgColorUsage);
1687 }
1688 
1689 static bool layersUseImage(WrappedImagePtr image, const FillLayer&amp; layers)
1690 {
1691     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1692         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data())
1693             return true;
1694     }
1695     return false;
1696 }
1697 
1698 void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)
1699 {
1700     if (!parent())
1701         return;
1702 
1703     if ((style().borderImage().image() &amp;&amp; style().borderImage().image()-&gt;data() == image) ||
1704         (style().maskBoxImage().image() &amp;&amp; style().maskBoxImage().image()-&gt;data() == image)) {
1705         repaint();
1706         return;
1707     }
1708 
1709     ShapeValue* shapeOutsideValue = style().shapeOutside();
1710     if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
1711         ShapeOutsideInfo&amp; info = ShapeOutsideInfo::ensureInfo(*this);
1712         if (!info.isComputingShape()) {
1713             info.markShapeAsDirty();
1714             markShapeOutsideDependentsForLayout();
1715         }
1716      }
1717 
1718     bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
1719     if (!didFullRepaint)
1720         repaintLayerRectsForImage(image, style().maskLayers(), false);
1721 
1722     if (!isComposited())
1723         return;
1724 
1725     if (layer()-&gt;hasCompositedMask() &amp;&amp; layersUseImage(image, style().maskLayers()))
1726         layer()-&gt;contentChanged(MaskImageChanged);
1727     if (layersUseImage(image, style().backgroundLayers()))
1728         layer()-&gt;contentChanged(BackgroundImageChanged);
1729 }
1730 
1731 bool RenderBox::repaintLayerRectsForImage(WrappedImagePtr image, const FillLayer&amp; layers, bool drawingBackground)
1732 {
1733     LayoutRect rendererRect;
1734     RenderBox* layerRenderer = nullptr;
1735 
1736     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1737         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data() &amp;&amp; layer-&gt;image()-&gt;canRender(this, style().effectiveZoom())) {
1738             // Now that we know this image is being used, compute the renderer and the rect if we haven&#39;t already.
1739             bool drawingRootBackground = drawingBackground &amp;&amp; (isDocumentElementRenderer() || (isBody() &amp;&amp; !document().documentElement()-&gt;renderer()-&gt;hasBackground()));
1740             if (!layerRenderer) {
1741                 if (drawingRootBackground) {
1742                     layerRenderer = &amp;view();
1743 
1744                     LayoutUnit rw = downcast&lt;RenderView&gt;(*layerRenderer).frameView().contentsWidth();
1745                     LayoutUnit rh = downcast&lt;RenderView&gt;(*layerRenderer).frameView().contentsHeight();
1746 
1747                     rendererRect = LayoutRect(-layerRenderer-&gt;marginLeft(),
1748                         -layerRenderer-&gt;marginTop(),
1749                         std::max(layerRenderer-&gt;width() + layerRenderer-&gt;horizontalMarginExtent() + layerRenderer-&gt;borderLeft() + layerRenderer-&gt;borderRight(), rw),
1750                         std::max(layerRenderer-&gt;height() + layerRenderer-&gt;verticalMarginExtent() + layerRenderer-&gt;borderTop() + layerRenderer-&gt;borderBottom(), rh));
1751                 } else {
1752                     layerRenderer = this;
1753                     rendererRect = borderBoxRect();
1754                 }
1755             }
1756             // FIXME: Figure out how to pass absolute position to calculateBackgroundImageGeometry (for pixel snapping)
1757             BackgroundImageGeometry geometry = layerRenderer-&gt;calculateBackgroundImageGeometry(nullptr, *layer, LayoutPoint(), rendererRect);
1758             if (geometry.hasNonLocalGeometry()) {
1759                 // Rather than incur the costs of computing the paintContainer for renderers with fixed backgrounds
1760                 // in order to get the right destRect, just repaint the entire renderer.
1761                 layerRenderer-&gt;repaint();
1762                 return true;
1763             }
1764 
1765             LayoutRect rectToRepaint = geometry.destRect();
1766             bool shouldClipToLayer = true;
1767 
1768             // If this is the root background layer, we may need to extend the repaintRect if the FrameView has an
1769             // extendedBackground. We should only extend the rect if it is already extending the full width or height
1770             // of the rendererRect.
1771             if (drawingRootBackground &amp;&amp; view().frameView().hasExtendedBackgroundRectForPainting()) {
1772                 shouldClipToLayer = false;
1773                 IntRect extendedBackgroundRect = view().frameView().extendedBackgroundRectForPainting();
1774                 if (rectToRepaint.width() == rendererRect.width()) {
1775                     rectToRepaint.move(extendedBackgroundRect.x(), 0);
1776                     rectToRepaint.setWidth(extendedBackgroundRect.width());
1777                 }
1778                 if (rectToRepaint.height() == rendererRect.height()) {
1779                     rectToRepaint.move(0, extendedBackgroundRect.y());
1780                     rectToRepaint.setHeight(extendedBackgroundRect.height());
1781                 }
1782             }
1783 
1784             layerRenderer-&gt;repaintRectangle(rectToRepaint, shouldClipToLayer);
1785             if (geometry.destRect() == rendererRect)
1786                 return true;
1787         }
1788     }
1789     return false;
1790 }
1791 
1792 bool RenderBox::pushContentsClip(PaintInfo&amp; paintInfo, const LayoutPoint&amp; accumulatedOffset)
1793 {
1794     if (paintInfo.phase == PaintPhase::BlockBackground || paintInfo.phase == PaintPhase::SelfOutline || paintInfo.phase == PaintPhase::Mask)
1795         return false;
1796 
1797     bool isControlClip = hasControlClip();
1798     bool isOverflowClip = hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer();
1799 
1800     if (!isControlClip &amp;&amp; !isOverflowClip)
1801         return false;
1802 
1803     if (paintInfo.phase == PaintPhase::Outline)
1804         paintInfo.phase = PaintPhase::ChildOutlines;
1805     else if (paintInfo.phase == PaintPhase::ChildBlockBackground) {
1806         paintInfo.phase = PaintPhase::BlockBackground;
1807         paintObject(paintInfo, accumulatedOffset);
1808         paintInfo.phase = PaintPhase::ChildBlockBackgrounds;
1809     }
1810     float deviceScaleFactor = document().deviceScaleFactor();
1811     FloatRect clipRect = snapRectToDevicePixels((isControlClip ? controlClipRect(accumulatedOffset) : overflowClipRect(accumulatedOffset, nullptr, IgnoreOverlayScrollbarSize, paintInfo.phase)), deviceScaleFactor);
1812     paintInfo.context().save();
1813     if (style().hasBorderRadius())
1814         paintInfo.context().clipRoundedRect(style().getRoundedInnerBorderFor(LayoutRect(accumulatedOffset, size())).pixelSnappedRoundedRectForPainting(deviceScaleFactor));
1815     paintInfo.context().clip(clipRect);
1816 
1817     if (paintInfo.phase == PaintPhase::EventRegion)
1818         paintInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(clipRect));
1819 
1820     return true;
1821 }
1822 
1823 void RenderBox::popContentsClip(PaintInfo&amp; paintInfo, PaintPhase originalPhase, const LayoutPoint&amp; accumulatedOffset)
1824 {
1825     ASSERT(hasControlClip() || (hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer()));
1826 
1827     if (paintInfo.phase == PaintPhase::EventRegion)
1828         paintInfo.eventRegionContext-&gt;popClip();
1829 
1830     paintInfo.context().restore();
1831     if (originalPhase == PaintPhase::Outline) {
1832         paintInfo.phase = PaintPhase::SelfOutline;
1833         paintObject(paintInfo, accumulatedOffset);
1834         paintInfo.phase = originalPhase;
1835     } else if (originalPhase == PaintPhase::ChildBlockBackground)
1836         paintInfo.phase = originalPhase;
1837 }
1838 
1839 LayoutRect RenderBox::overflowClipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment, OverlayScrollbarSizeRelevancy relevancy, PaintPhase)
1840 {
1841     // FIXME: When overflow-clip (CSS3) is implemented, we&#39;ll obtain the property
1842     // here.
1843     LayoutRect clipRect = borderBoxRectInFragment(fragment);
1844     clipRect.setLocation(location + clipRect.location() + LayoutSize(borderLeft(), borderTop()));
1845     clipRect.setSize(clipRect.size() - LayoutSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
1846 
1847     // Subtract out scrollbars if we have them.
1848     if (layer()) {
1849         if (shouldPlaceBlockDirectionScrollbarOnLeft())
1850             clipRect.move(layer()-&gt;verticalScrollbarWidth(relevancy), 0);
1851         clipRect.contract(layer()-&gt;verticalScrollbarWidth(relevancy), layer()-&gt;horizontalScrollbarHeight(relevancy));
1852     }
1853 
1854     return clipRect;
1855 }
1856 
1857 LayoutRect RenderBox::clipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment)
1858 {
1859     LayoutRect borderBoxRect = borderBoxRectInFragment(fragment);
1860     LayoutRect clipRect = LayoutRect(borderBoxRect.location() + location, borderBoxRect.size());
1861 
1862     if (!style().clipLeft().isAuto()) {
1863         LayoutUnit c = valueForLength(style().clipLeft(), borderBoxRect.width());
1864         clipRect.move(c, 0_lu);
1865         clipRect.contract(c, 0_lu);
1866     }
1867 
1868     // We don&#39;t use the fragment-specific border box&#39;s width and height since clip offsets are (stupidly) specified
1869     // from the left and top edges. Therefore it&#39;s better to avoid constraining to smaller widths and heights.
1870 
1871     if (!style().clipRight().isAuto())
1872         clipRect.contract(width() - valueForLength(style().clipRight(), width()), 0_lu);
1873 
1874     if (!style().clipTop().isAuto()) {
1875         LayoutUnit c = valueForLength(style().clipTop(), borderBoxRect.height());
1876         clipRect.move(0_lu, c);
1877         clipRect.contract(0_lu, c);
1878     }
1879 
1880     if (!style().clipBottom().isAuto())
1881         clipRect.contract(0_lu, height() - valueForLength(style().clipBottom(), height()));
1882 
1883     return clipRect;
1884 }
1885 
1886 LayoutUnit RenderBox::shrinkLogicalWidthToAvoidFloats(LayoutUnit childMarginStart, LayoutUnit childMarginEnd, const RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
1887 {
1888     RenderFragmentContainer* containingBlockFragment = nullptr;
1889     LayoutUnit logicalTopPosition = logicalTop();
1890     if (fragment) {
1891         LayoutUnit offsetFromLogicalTopOfFragment = fragment ? fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage() : 0_lu;
1892         logicalTopPosition = std::max(logicalTopPosition, logicalTopPosition + offsetFromLogicalTopOfFragment);
1893         containingBlockFragment = cb.clampToStartAndEndFragments(fragment);
1894     }
1895 
1896     LayoutUnit logicalHeight = cb.logicalHeightForChild(*this);
1897     LayoutUnit result = cb.availableLogicalWidthForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight) - childMarginStart - childMarginEnd;
1898 
1899     // We need to see if margins on either the start side or the end side can contain the floats in question. If they can,
1900     // then just using the line width is inaccurate. In the case where a float completely fits, we don&#39;t need to use the line
1901     // offset at all, but can instead push all the way to the content edge of the containing block. In the case where the float
1902     // doesn&#39;t fit, we can use the line offset, but we need to grow it by the margin to reflect the fact that the margin was
1903     // &quot;consumed&quot; by the float. Negative margins aren&#39;t consumed by the float, and so we ignore them.
1904     if (childMarginStart &gt; 0) {
1905         LayoutUnit startContentSide = cb.startOffsetForContent(containingBlockFragment);
1906         LayoutUnit startContentSideWithMargin = startContentSide + childMarginStart;
1907         LayoutUnit startOffset = cb.startOffsetForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight);
1908         if (startOffset &gt; startContentSideWithMargin)
1909             result += childMarginStart;
1910         else
1911             result += startOffset - startContentSide;
1912     }
1913 
1914     if (childMarginEnd &gt; 0) {
1915         LayoutUnit endContentSide = cb.endOffsetForContent(containingBlockFragment);
1916         LayoutUnit endContentSideWithMargin = endContentSide + childMarginEnd;
1917         LayoutUnit endOffset = cb.endOffsetForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight);
1918         if (endOffset &gt; endContentSideWithMargin)
1919             result += childMarginEnd;
1920         else
1921             result += endOffset - endContentSide;
1922     }
1923 
1924     return result;
1925 }
1926 
1927 LayoutUnit RenderBox::containingBlockLogicalWidthForContent() const
1928 {
1929     if (hasOverrideContainingBlockContentLogicalWidth()) {
1930         if (auto overrideLogicalWidth = overrideContainingBlockContentLogicalWidth())
1931             return overrideLogicalWidth.value();
1932     }
1933 
1934     if (RenderBlock* cb = containingBlock())
1935         return cb-&gt;availableLogicalWidth();
1936     return 0_lu;
1937 }
1938 
1939 LayoutUnit RenderBox::containingBlockLogicalHeightForContent(AvailableLogicalHeightType heightType) const
1940 {
1941     if (hasOverrideContainingBlockContentLogicalHeight()) {
1942         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
1943             return overrideLogicalHeight.value();
1944     }
1945 
1946     if (RenderBlock* cb = containingBlock())
1947         return cb-&gt;availableLogicalHeight(heightType);
1948     return 0_lu;
1949 }
1950 
1951 LayoutUnit RenderBox::containingBlockLogicalWidthForContentInFragment(RenderFragmentContainer* fragment) const
1952 {
1953     if (!fragment)
1954         return containingBlockLogicalWidthForContent();
1955 
1956     RenderBlock* cb = containingBlock();
1957     RenderFragmentContainer* containingBlockFragment = cb-&gt;clampToStartAndEndFragments(fragment);
1958     // FIXME: It&#39;s unclear if a fragment&#39;s content should use the containing block&#39;s override logical width.
1959     // If it should, the following line should call containingBlockLogicalWidthForContent.
1960     LayoutUnit result = cb-&gt;availableLogicalWidth();
1961     RenderBoxFragmentInfo* boxInfo = cb-&gt;renderBoxFragmentInfo(containingBlockFragment);
1962     if (!boxInfo)
1963         return result;
1964     return std::max&lt;LayoutUnit&gt;(0, result - (cb-&gt;logicalWidth() - boxInfo-&gt;logicalWidth()));
1965 }
1966 
1967 LayoutUnit RenderBox::containingBlockAvailableLineWidthInFragment(RenderFragmentContainer* fragment) const
1968 {
1969     RenderBlock* cb = containingBlock();
1970     RenderFragmentContainer* containingBlockFragment = nullptr;
1971     LayoutUnit logicalTopPosition = logicalTop();
1972     if (fragment) {
1973         LayoutUnit offsetFromLogicalTopOfFragment = fragment ? fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage() : 0_lu;
1974         logicalTopPosition = std::max(logicalTopPosition, logicalTopPosition + offsetFromLogicalTopOfFragment);
1975         containingBlockFragment = cb-&gt;clampToStartAndEndFragments(fragment);
1976     }
1977     return cb-&gt;availableLogicalWidthForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, availableLogicalHeight(IncludeMarginBorderPadding));
1978 }
1979 
1980 LayoutUnit RenderBox::perpendicularContainingBlockLogicalHeight() const
1981 {
1982     if (hasOverrideContainingBlockContentLogicalHeight()) {
1983         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
1984             return overrideLogicalHeight.value();
1985     }
1986 
1987     RenderBlock* cb = containingBlock();
1988     if (cb-&gt;hasOverrideContentLogicalHeight())
1989         return cb-&gt;overrideContentLogicalHeight();
1990 
1991     const RenderStyle&amp; containingBlockStyle = cb-&gt;style();
1992     Length logicalHeightLength = containingBlockStyle.logicalHeight();
1993 
1994     // FIXME: For now just support fixed heights.  Eventually should support percentage heights as well.
1995     if (!logicalHeightLength.isFixed()) {
1996         LayoutUnit fillFallbackExtent = containingBlockStyle.isHorizontalWritingMode() ? view().frameView().visibleHeight() : view().frameView().visibleWidth();
1997         LayoutUnit fillAvailableExtent = containingBlock()-&gt;availableLogicalHeight(ExcludeMarginBorderPadding);
1998         view().addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
1999         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=158286 We also need to perform the same percentHeightDescendant treatment to the element which dictates the return value for containingBlock()-&gt;availableLogicalHeight() above.
2000         return std::min(fillAvailableExtent, fillFallbackExtent);
2001     }
2002 
2003     // Use the content box logical height as specified by the style.
2004     return cb-&gt;adjustContentBoxLogicalHeightForBoxSizing(LayoutUnit(logicalHeightLength.value()));
2005 }
2006 
2007 void RenderBox::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
2008 {
2009     if (repaintContainer == this)
2010         return;
2011 
2012     if (!repaintContainer &amp;&amp; view().frameView().layoutContext().isPaintOffsetCacheEnabled()) {
2013         auto* layoutState = view().frameView().layoutContext().layoutState();
2014         LayoutSize offset = layoutState-&gt;paintOffset() + locationOffset();
2015         if (style().hasInFlowPosition() &amp;&amp; layer())
2016             offset += layer()-&gt;offsetForInFlowPosition();
2017         transformState.move(offset);
2018         return;
2019     }
2020 
2021     bool containerSkipped;
2022     RenderElement* container = this-&gt;container(repaintContainer, containerSkipped);
2023     if (!container)
2024         return;
2025 
2026     bool isFixedPos = isFixedPositioned();
2027     // If this box has a transform, it acts as a fixed position container for fixed descendants,
2028     // and may itself also be fixed position. So propagate &#39;fixed&#39; up only if this box is fixed position.
2029     if (hasTransform() &amp;&amp; !isFixedPos)
2030         mode &amp;= ~IsFixed;
2031     else if (isFixedPos)
2032         mode |= IsFixed;
2033 
2034     if (wasFixed)
2035         *wasFixed = mode &amp; IsFixed;
2036 
2037     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(transformState.mappedPoint()));
2038 
2039     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
2040     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
2041         TransformationMatrix t;
2042         getTransformFromContainer(container, containerOffset, t);
2043         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2044     } else
2045         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2046 
2047     if (containerSkipped) {
2048         // There can&#39;t be a transform between repaintContainer and o, because transforms create containers, so it should be safe
2049         // to just subtract the delta between the repaintContainer and o.
2050         LayoutSize containerOffset = repaintContainer-&gt;offsetFromAncestorContainer(*container);
2051         transformState.move(-containerOffset.width(), -containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2052         return;
2053     }
2054 
2055     mode &amp;= ~ApplyContainerFlip;
2056 
2057     container-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
2058 }
2059 
2060 const RenderObject* RenderBox::pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp; geometryMap) const
2061 {
2062     ASSERT(ancestorToStopAt != this);
2063 
2064     bool ancestorSkipped;
2065     RenderElement* container = this-&gt;container(ancestorToStopAt, ancestorSkipped);
2066     if (!container)
2067         return nullptr;
2068 
2069     bool isFixedPos = isFixedPositioned();
2070     LayoutSize adjustmentForSkippedAncestor;
2071     if (ancestorSkipped) {
2072         // There can&#39;t be a transform between repaintContainer and container, because transforms create containers, so it should be safe
2073         // to just subtract the delta between the ancestor and container.
2074         adjustmentForSkippedAncestor = -ancestorToStopAt-&gt;offsetFromAncestorContainer(*container);
2075     }
2076 
2077     bool offsetDependsOnPoint = false;
2078     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(), &amp;offsetDependsOnPoint);
2079 
2080     bool preserve3D = container-&gt;style().preserves3D() || style().preserves3D();
2081     if (shouldUseTransformFromContainer(container) &amp;&amp; (geometryMap.mapCoordinatesFlags() &amp; UseTransforms)) {
2082         TransformationMatrix t;
2083         getTransformFromContainer(container, containerOffset, t);
2084         t.translateRight(adjustmentForSkippedAncestor.width(), adjustmentForSkippedAncestor.height());
2085 
2086         geometryMap.push(this, t, preserve3D, offsetDependsOnPoint, isFixedPos, hasTransform());
2087     } else {
2088         containerOffset += adjustmentForSkippedAncestor;
2089         geometryMap.push(this, containerOffset, preserve3D, offsetDependsOnPoint, isFixedPos, hasTransform());
2090     }
2091 
2092     return ancestorSkipped ? ancestorToStopAt : container;
2093 }
2094 
2095 void RenderBox::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
2096 {
2097     bool isFixedPos = isFixedPositioned();
2098     if (hasTransform() &amp;&amp; !isFixedPos) {
2099         // If this box has a transform, it acts as a fixed position container for fixed descendants,
2100         // and may itself also be fixed position. So propagate &#39;fixed&#39; up only if this box is fixed position.
2101         mode &amp;= ~IsFixed;
2102     } else if (isFixedPos)
2103         mode |= IsFixed;
2104 
2105     RenderBoxModelObject::mapAbsoluteToLocalPoint(mode, transformState);
2106 }
2107 
2108 LayoutSize RenderBox::offsetFromContainer(RenderElement&amp; container, const LayoutPoint&amp;, bool* offsetDependsOnPoint) const
2109 {
2110     // A fragment &quot;has&quot; boxes inside it without being their container.
2111     ASSERT(&amp;container == this-&gt;container() || is&lt;RenderFragmentContainer&gt;(container));
2112 
2113     LayoutSize offset;
2114     if (isInFlowPositioned())
2115         offset += offsetForInFlowPosition();
2116 
2117     if (!isInline() || isReplaced())
2118         offset += topLeftLocationOffset();
2119 
2120     if (is&lt;RenderBox&gt;(container))
2121         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
2122 
2123     if (isAbsolutelyPositioned() &amp;&amp; container.isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(container))
2124         offset += downcast&lt;RenderInline&gt;(container).offsetForInFlowPositionedInline(this);
2125 
2126     if (offsetDependsOnPoint)
2127         *offsetDependsOnPoint |= is&lt;RenderFragmentedFlow&gt;(container);
2128 
2129     return offset;
2130 }
2131 
2132 std::unique_ptr&lt;InlineElementBox&gt; RenderBox::createInlineBox()
2133 {
2134     return makeUnique&lt;InlineElementBox&gt;(*this);
2135 }
2136 
2137 void RenderBox::dirtyLineBoxes(bool fullLayout)
2138 {
2139     if (!m_inlineBoxWrapper)
2140         return;
2141 
2142     if (fullLayout) {
2143         delete m_inlineBoxWrapper;
2144         m_inlineBoxWrapper = nullptr;
2145     } else
2146         m_inlineBoxWrapper-&gt;dirtyLineBoxes();
2147 }
2148 
2149 void RenderBox::positionLineBox(InlineElementBox&amp; box)
2150 {
2151     if (isOutOfFlowPositioned()) {
2152         // Cache the x position only if we were an DisplayType::Inline type originally.
2153         bool wasInline = style().isOriginalDisplayInlineType();
2154         if (wasInline) {
2155             // The value is cached in the xPos of the box.  We only need this value if
2156             // our object was inline originally, since otherwise it would have ended up underneath
2157             // the inlines.
2158             RootInlineBox&amp; rootBox = box.root();
2159             rootBox.blockFlow().setStaticInlinePositionForChild(*this, rootBox.lineTopWithLeading(), LayoutUnit::fromFloatRound(box.logicalLeft()));
2160             if (style().hasStaticInlinePosition(box.isHorizontal()))
2161                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2162         } else {
2163             // Our object was a block originally, so we make our normal flow position be
2164             // just below the line box (as though all the inlines that came before us got
2165             // wrapped in an anonymous block, which is what would have happened had we been
2166             // in flow).  This value was cached in the y() of the box.
2167             layer()-&gt;setStaticBlockPosition(LayoutUnit(box.logicalTop()));
2168             if (style().hasStaticBlockPosition(box.isHorizontal()))
2169                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2170         }
2171         return;
2172     }
2173 
2174     if (isReplaced()) {
2175         setLocation(LayoutPoint(box.topLeft()));
2176         setInlineBoxWrapper(&amp;box);
2177     }
2178 }
2179 
2180 void RenderBox::deleteLineBoxWrapper()
2181 {
2182     if (!m_inlineBoxWrapper)
2183         return;
2184 
2185     if (!renderTreeBeingDestroyed())
2186         m_inlineBoxWrapper-&gt;removeFromParent();
2187     delete m_inlineBoxWrapper;
2188     m_inlineBoxWrapper = nullptr;
2189 }
2190 
2191 LayoutRect RenderBox::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
2192 {
2193     if (style().visibility() != Visibility::Visible &amp;&amp; !enclosingLayer()-&gt;hasVisibleContent())
2194         return LayoutRect();
2195     LayoutRect r = visualOverflowRect();
2196     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
2197     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
2198     r.move(view().frameView().layoutContext().layoutDelta());
2199     return computeRectForRepaint(r, repaintContainer);
2200 }
2201 
2202 LayoutRect RenderBox::computeVisibleRectUsingPaintOffset(const LayoutRect&amp; rect) const
2203 {
2204     LayoutRect adjustedRect = rect;
2205     auto* layoutState = view().frameView().layoutContext().layoutState();
2206 
2207     if (layer() &amp;&amp; layer()-&gt;transform())
2208         adjustedRect = LayoutRect(encloseRectToDevicePixels(layer()-&gt;transform()-&gt;mapRect(adjustedRect), document().deviceScaleFactor()));
2209 
2210     // We can&#39;t trust the bits on RenderObject, because this might be called while re-resolving style.
2211     if (style().hasInFlowPosition() &amp;&amp; layer())
2212         adjustedRect.move(layer()-&gt;offsetForInFlowPosition());
2213 
2214     adjustedRect.moveBy(location());
2215     adjustedRect.move(layoutState-&gt;paintOffset());
2216     if (layoutState-&gt;isClipped())
2217         adjustedRect.intersect(layoutState-&gt;clipRect());
2218     return adjustedRect;
2219 }
2220 
2221 Optional&lt;LayoutRect&gt; RenderBox::computeVisibleRectInContainer(const LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
2222 {
2223     // The rect we compute at each step is shifted by our x/y offset in the parent container&#39;s coordinate space.
2224     // Only when we cross a writing mode boundary will we have to possibly flipForWritingMode (to convert into a more appropriate
2225     // offset corner for the enclosing container).  This allows for a fully RL or BT document to repaint
2226     // properly even during layout, since the rect remains flipped all the way until the end.
2227     //
2228     // RenderView::computeVisibleRectInContainer then converts the rect to physical coordinates. We also convert to
2229     // physical when we hit a repaint container boundary. Therefore the final rect returned is always in the
2230     // physical coordinate space of the container.
2231     const RenderStyle&amp; styleToUse = style();
2232     // Paint offset cache is only valid for root-relative, non-fixed position repainting
2233     if (view().frameView().layoutContext().isPaintOffsetCacheEnabled() &amp;&amp; !container &amp;&amp; styleToUse.position() != PositionType::Fixed &amp;&amp; !context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
2234         return computeVisibleRectUsingPaintOffset(rect);
2235 
2236     LayoutRect adjustedRect = rect;
2237     if (hasReflection())
2238         adjustedRect.unite(reflectedRect(adjustedRect));
2239 
2240     if (container == this) {
2241         if (container-&gt;style().isFlippedBlocksWritingMode())
2242             flipForWritingMode(adjustedRect);
2243         return adjustedRect;
2244     }
2245 
2246     bool containerIsSkipped;
2247     auto* localContainer = this-&gt;container(container, containerIsSkipped);
2248     if (!localContainer)
2249         return adjustedRect;
2250 
2251     // This code isn&#39;t necessary for in-flow RenderFragmentedFlows.
2252     // Don&#39;t add the location of the fragment in the flow thread for absolute positioned
2253     // elements because their absolute position already pushes them down through
2254     // the fragments so adding this here and then adding the topLeft again would cause
2255     // us to add the height twice.
2256     // The same logic applies for elements flowed directly into the flow thread. Their topLeft member
2257     // will already contain the portion rect of the fragment.
2258     auto position = styleToUse.position();
2259     if (localContainer-&gt;isOutOfFlowRenderFragmentedFlow() &amp;&amp; position != PositionType::Absolute &amp;&amp; containingBlock() != enclosingFragmentedFlow()) {
2260         RenderFragmentContainer* firstFragment = nullptr;
2261         RenderFragmentContainer* lastFragment = nullptr;
2262         if (downcast&lt;RenderFragmentedFlow&gt;(*localContainer).getFragmentRangeForBox(this, firstFragment, lastFragment))
2263             adjustedRect.moveBy(firstFragment-&gt;fragmentedFlowPortionRect().location());
2264     }
2265 
2266     if (isWritingModeRoot()) {
2267         if (!isOutOfFlowPositioned() || !context.m_dirtyRectIsFlipped) {
2268             flipForWritingMode(adjustedRect);
2269             context.m_dirtyRectIsFlipped = true;
2270         }
2271     }
2272 
2273     LayoutSize locationOffset = this-&gt;locationOffset();
2274     // FIXME: This is needed as long as RenderWidget snaps to integral size/position.
2275     if (isRenderReplaced() &amp;&amp; isWidget()) {
2276         LayoutSize flooredLocationOffset = toIntSize(flooredIntPoint(locationOffset));
2277         adjustedRect.expand(locationOffset - flooredLocationOffset);
2278         locationOffset = flooredLocationOffset;
2279     }
2280 
2281     if (is&lt;RenderMultiColumnFlow&gt;(this)) {
2282         // We won&#39;t normally run this code. Only when the container is null (i.e., we&#39;re trying
2283         // to get the rect in view coordinates) will we come in here, since normally container
2284         // will be set and we&#39;ll stop at the flow thread. This case is mainly hit by the check for whether
2285         // or not images should animate.
2286         // FIXME: Just as with offsetFromContainer, we aren&#39;t really handling objects that span
2287         // multiple columns properly.
2288         LayoutPoint physicalPoint(flipForWritingMode(adjustedRect.location()));
2289         if (auto* fragment = downcast&lt;RenderMultiColumnFlow&gt;(*this).physicalTranslationFromFlowToFragment((physicalPoint))) {
2290             adjustedRect.setLocation(fragment-&gt;flipForWritingMode(physicalPoint));
2291             return fragment-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
2292         }
2293     }
2294 
2295     LayoutPoint topLeft = adjustedRect.location();
2296     topLeft.move(locationOffset);
2297 
2298     // We are now in our parent container&#39;s coordinate space. Apply our transform to obtain a bounding box
2299     // in the parent&#39;s coordinate space that encloses us.
2300     if (hasLayer() &amp;&amp; layer()-&gt;transform()) {
2301         context.m_hasPositionFixedDescendant = position == PositionType::Fixed;
2302         adjustedRect = LayoutRect(encloseRectToDevicePixels(layer()-&gt;transform()-&gt;mapRect(adjustedRect), document().deviceScaleFactor()));
2303         topLeft = adjustedRect.location();
2304         topLeft.move(locationOffset);
2305     } else if (position == PositionType::Fixed)
2306         context.m_hasPositionFixedDescendant = true;
2307 
2308     if (position == PositionType::Absolute &amp;&amp; localContainer-&gt;isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(*localContainer))
2309         topLeft += downcast&lt;RenderInline&gt;(*localContainer).offsetForInFlowPositionedInline(this);
2310     else if (styleToUse.hasInFlowPosition() &amp;&amp; layer()) {
2311         // Apply the relative position offset when invalidating a rectangle.  The layer
2312         // is translated, but the render box isn&#39;t, so we need to do this to get the
2313         // right dirty rect.  Since this is called from RenderObject::setStyle, the relative position
2314         // flag on the RenderObject has been cleared, so use the one on the style().
2315         topLeft += layer()-&gt;offsetForInFlowPosition();
2316     }
2317 
2318     // FIXME: We ignore the lightweight clipping rect that controls use, since if |o| is in mid-layout,
2319     // its controlClipRect will be wrong. For overflow clip we use the values cached by the layer.
2320     adjustedRect.setLocation(topLeft);
2321     if (localContainer-&gt;hasOverflowClip()) {
2322         RenderBox&amp; containerBox = downcast&lt;RenderBox&gt;(*localContainer);
2323         bool isEmpty = !containerBox.applyCachedClipAndScrollPosition(adjustedRect, container, context);
2324         if (isEmpty) {
2325             if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
2326                 return WTF::nullopt;
2327             return adjustedRect;
2328         }
2329     }
2330 
2331     if (containerIsSkipped) {
2332         // If the container is below localContainer, then we need to map the rect into container&#39;s coordinates.
2333         LayoutSize containerOffset = container-&gt;offsetFromAncestorContainer(*localContainer);
2334         adjustedRect.move(-containerOffset);
2335         return adjustedRect;
2336     }
2337     return localContainer-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
2338 }
2339 
2340 void RenderBox::repaintDuringLayoutIfMoved(const LayoutRect&amp; oldRect)
2341 {
2342     if (oldRect.location() != m_frameRect.location()) {
2343         LayoutRect newRect = m_frameRect;
2344         // The child moved.  Invalidate the object&#39;s old and new positions.  We have to do this
2345         // since the object may not have gotten a layout.
2346         m_frameRect = oldRect;
2347         repaint();
2348         repaintOverhangingFloats(true);
2349         m_frameRect = newRect;
2350         repaint();
2351         repaintOverhangingFloats(true);
2352     }
2353 }
2354 
2355 void RenderBox::repaintOverhangingFloats(bool)
2356 {
2357 }
2358 
2359 void RenderBox::updateLogicalWidth()
2360 {
2361     LogicalExtentComputedValues computedValues;
2362     computeLogicalWidthInFragment(computedValues);
2363 
2364     setLogicalWidth(computedValues.m_extent);
2365     setLogicalLeft(computedValues.m_position);
2366     setMarginStart(computedValues.m_margins.m_start);
2367     setMarginEnd(computedValues.m_margins.m_end);
2368 }
2369 
2370 void RenderBox::computeLogicalWidthInFragment(LogicalExtentComputedValues&amp; computedValues, RenderFragmentContainer* fragment) const
2371 {
2372     computedValues.m_extent = logicalWidth();
2373     computedValues.m_position = logicalLeft();
2374     computedValues.m_margins.m_start = marginStart();
2375     computedValues.m_margins.m_end = marginEnd();
2376 
2377     if (isOutOfFlowPositioned()) {
2378         // FIXME: This calculation is not patched for block-flow yet.
2379         // https://bugs.webkit.org/show_bug.cgi?id=46500
2380         computePositionedLogicalWidth(computedValues, fragment);
2381         return;
2382     }
2383 
2384     // If layout is limited to a subtree, the subtree root&#39;s logical width does not change.
2385     if (element() &amp;&amp; !view().frameView().layoutContext().isLayoutPending() &amp;&amp; view().frameView().layoutContext().subtreeLayoutRoot() == this)
2386         return;
2387 
2388     // The parent box is flexing us, so it has increased or decreased our
2389     // width.  Use the width from the style context.
2390     // FIXME: Account for block-flow in flexible boxes.
2391     // https://bugs.webkit.org/show_bug.cgi?id=46418
2392     if (hasOverrideContentLogicalWidth() &amp;&amp; (isRubyRun() || style().borderFit() == BorderFit::Lines || (parent()-&gt;isFlexibleBoxIncludingDeprecated()))) {
2393         computedValues.m_extent = overrideContentLogicalWidth() + borderAndPaddingLogicalWidth();
2394         return;
2395     }
2396 
2397     // FIXME: Account for block-flow in flexible boxes.
2398     // https://bugs.webkit.org/show_bug.cgi?id=46418
2399     bool inVerticalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Vertical);
2400     bool stretching = (parent()-&gt;style().boxAlign() == BoxAlignment::Stretch);
2401     // FIXME: Stretching is the only reason why we don&#39;t want the box to be treated as a replaced element, so we could perhaps
2402     // refactor all this logic, not only for flex and grid since alignment is intended to be applied to any block.
2403     bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inVerticalBox || !stretching);
2404     treatAsReplaced = treatAsReplaced &amp;&amp; (!isGridItem() || !hasStretchedLogicalWidth());
2405 
2406     const RenderStyle&amp; styleToUse = style();
2407     Length logicalWidthLength = treatAsReplaced ? Length(computeReplacedLogicalWidth(), Fixed) : styleToUse.logicalWidth();
2408 
2409     RenderBlock&amp; cb = *containingBlock();
2410     LayoutUnit containerLogicalWidth = std::max&lt;LayoutUnit&gt;(0, containingBlockLogicalWidthForContentInFragment(fragment));
2411     bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2412 
2413     if (isInline() &amp;&amp; !isInlineBlockOrInlineTable()) {
2414         // just calculate margins
2415         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2416         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2417         if (treatAsReplaced)
2418             computedValues.m_extent = std::max(LayoutUnit(floatValueForLength(logicalWidthLength, 0) + borderAndPaddingLogicalWidth()), minPreferredLogicalWidth());
2419         return;
2420     }
2421 
2422     LayoutUnit containerWidthInInlineDirection = containerLogicalWidth;
2423     if (hasPerpendicularContainingBlock)
2424         containerWidthInInlineDirection = perpendicularContainingBlockLogicalHeight();
2425 
2426     // Width calculations
2427     if (treatAsReplaced) {
2428         computedValues.m_extent = logicalWidthLength.value() + borderAndPaddingLogicalWidth();
2429     } else {
2430         LayoutUnit preferredWidth = computeLogicalWidthInFragmentUsing(MainOrPreferredSize, styleToUse.logicalWidth(), containerWidthInInlineDirection, cb, fragment);
2431         computedValues.m_extent = constrainLogicalWidthInFragmentByMinMax(preferredWidth, containerWidthInInlineDirection, cb, fragment);
2432     }
2433 
2434     // Margin calculations.
2435     if (hasPerpendicularContainingBlock || isFloating() || isInline()) {
2436         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2437         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2438     } else {
2439         LayoutUnit containerLogicalWidthForAutoMargins = containerLogicalWidth;
2440         if (avoidsFloats() &amp;&amp; cb.containsFloats())
2441             containerLogicalWidthForAutoMargins = containingBlockAvailableLineWidthInFragment(fragment);
2442         bool hasInvertedDirection = cb.style().isLeftToRightDirection() != style().isLeftToRightDirection();
2443         computeInlineDirectionMargins(cb, containerLogicalWidthForAutoMargins, computedValues.m_extent,
2444             hasInvertedDirection ? computedValues.m_margins.m_end : computedValues.m_margins.m_start,
2445             hasInvertedDirection ? computedValues.m_margins.m_start : computedValues.m_margins.m_end);
2446     }
2447 
2448     if (!hasPerpendicularContainingBlock &amp;&amp; containerLogicalWidth &amp;&amp; containerLogicalWidth != (computedValues.m_extent + computedValues.m_margins.m_start + computedValues.m_margins.m_end)
2449         &amp;&amp; !isFloating() &amp;&amp; !isInline() &amp;&amp; !cb.isFlexibleBoxIncludingDeprecated()
2450 #if ENABLE(MATHML)
2451         // RenderMathMLBlocks take the size of their content so we must not adjust the margin to fill the container size.
2452         &amp;&amp; !cb.isRenderMathMLBlock()
2453 #endif
2454         &amp;&amp; !cb.isRenderGrid()
2455         ) {
2456         LayoutUnit newMarginTotal = containerLogicalWidth - computedValues.m_extent;
2457         bool hasInvertedDirection = cb.style().isLeftToRightDirection() != style().isLeftToRightDirection();
2458         if (hasInvertedDirection)
2459             computedValues.m_margins.m_start = newMarginTotal - computedValues.m_margins.m_end;
2460         else
2461             computedValues.m_margins.m_end = newMarginTotal - computedValues.m_margins.m_start;
2462     }
2463 }
2464 
2465 LayoutUnit RenderBox::fillAvailableMeasure(LayoutUnit availableLogicalWidth) const
2466 {
2467     LayoutUnit marginStart;
2468     LayoutUnit marginEnd;
2469     return fillAvailableMeasure(availableLogicalWidth, marginStart, marginEnd);
2470 }
2471 
2472 LayoutUnit RenderBox::fillAvailableMeasure(LayoutUnit availableLogicalWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const
2473 {
2474     marginStart = minimumValueForLength(style().marginStart(), availableLogicalWidth);
2475     marginEnd = minimumValueForLength(style().marginEnd(), availableLogicalWidth);
2476     return availableLogicalWidth - marginStart - marginEnd;
2477 }
2478 
2479 LayoutUnit RenderBox::computeIntrinsicLogicalWidthUsing(Length logicalWidthLength, LayoutUnit availableLogicalWidth, LayoutUnit borderAndPadding) const
2480 {
2481     if (logicalWidthLength.type() == FillAvailable)
2482         return std::max(borderAndPadding, fillAvailableMeasure(availableLogicalWidth));
2483 
2484     LayoutUnit minLogicalWidth;
2485     LayoutUnit maxLogicalWidth;
2486     computeIntrinsicLogicalWidths(minLogicalWidth, maxLogicalWidth);
2487 
2488     if (logicalWidthLength.type() == MinContent)
2489         return minLogicalWidth + borderAndPadding;
2490 
2491     if (logicalWidthLength.type() == MaxContent)
2492         return maxLogicalWidth + borderAndPadding;
2493 
2494     if (logicalWidthLength.type() == FitContent) {
2495         minLogicalWidth += borderAndPadding;
2496         maxLogicalWidth += borderAndPadding;
2497         return std::max(minLogicalWidth, std::min(maxLogicalWidth, fillAvailableMeasure(availableLogicalWidth)));
2498     }
2499 
2500     ASSERT_NOT_REACHED();
2501     return 0;
2502 }
2503 
2504 LayoutUnit RenderBox::computeLogicalWidthInFragmentUsing(SizeType widthType, Length logicalWidth, LayoutUnit availableLogicalWidth,
2505     const RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
2506 {
2507     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
2508     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
2509         return adjustBorderBoxLogicalWidthForBoxSizing(0);
2510 
2511     if (!logicalWidth.isIntrinsicOrAuto()) {
2512         // FIXME: If the containing block flow is perpendicular to our direction we need to use the available logical height instead.
2513         return adjustBorderBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, availableLogicalWidth));
2514     }
2515 
2516     if (logicalWidth.isIntrinsic())
2517         return computeIntrinsicLogicalWidthUsing(logicalWidth, availableLogicalWidth, borderAndPaddingLogicalWidth());
2518 
2519     LayoutUnit marginStart;
2520     LayoutUnit marginEnd;
2521     LayoutUnit logicalWidthResult = fillAvailableMeasure(availableLogicalWidth, marginStart, marginEnd);
2522 
2523     if (shrinkToAvoidFloats() &amp;&amp; cb.containsFloats())
2524         logicalWidthResult = std::min(logicalWidthResult, shrinkLogicalWidthToAvoidFloats(marginStart, marginEnd, cb, fragment));
2525 
2526     if (widthType == MainOrPreferredSize &amp;&amp; sizesLogicalWidthToFitContent(widthType))
2527         return std::max(minPreferredLogicalWidth(), std::min(maxPreferredLogicalWidth(), logicalWidthResult));
2528     return logicalWidthResult;
2529 }
2530 
2531 bool RenderBox::columnFlexItemHasStretchAlignment() const
2532 {
2533     // auto margins mean we don&#39;t stretch. Note that this function will only be
2534     // used for widths, so we don&#39;t have to check marginBefore/marginAfter.
2535     const auto&amp; parentStyle = parent()-&gt;style();
2536     ASSERT(parentStyle.isColumnFlexDirection());
2537     if (style().marginStart().isAuto() || style().marginEnd().isAuto())
2538         return false;
2539     return style().resolvedAlignSelf(&amp;parentStyle, containingBlock()-&gt;selfAlignmentNormalBehavior()).position() == ItemPosition::Stretch;
2540 }
2541 
2542 bool RenderBox::isStretchingColumnFlexItem() const
2543 {
2544     if (parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Vertical &amp;&amp; parent()-&gt;style().boxAlign() == BoxAlignment::Stretch)
2545         return true;
2546 
2547     // We don&#39;t stretch multiline flexboxes because they need to apply line spacing (align-content) first.
2548     if (parent()-&gt;isFlexibleBox() &amp;&amp; parent()-&gt;style().flexWrap() == FlexWrap::NoWrap &amp;&amp; parent()-&gt;style().isColumnFlexDirection() &amp;&amp; columnFlexItemHasStretchAlignment())
2549         return true;
2550     return false;
2551 }
2552 
2553 // FIXME: Can/Should we move this inside specific layout classes (flex. grid)? Can we refactor columnFlexItemHasStretchAlignment logic?
2554 bool RenderBox::hasStretchedLogicalWidth() const
2555 {
2556     auto&amp; style = this-&gt;style();
2557     if (!style.logicalWidth().isAuto() || style.marginStart().isAuto() || style.marginEnd().isAuto())
2558         return false;
2559     RenderBlock* containingBlock = this-&gt;containingBlock();
2560     if (!containingBlock) {
2561         // We are evaluating align-self/justify-self, which default to &#39;normal&#39; for the root element.
2562         // The &#39;normal&#39; value behaves like &#39;start&#39; except for Flexbox Items, which obviously should have a container.
2563         return false;
2564     }
2565     if (containingBlock-&gt;isHorizontalWritingMode() != isHorizontalWritingMode())
2566         return style.resolvedAlignSelf(&amp;containingBlock-&gt;style(), containingBlock-&gt;selfAlignmentNormalBehavior(this)).position() == ItemPosition::Stretch;
2567     return style.resolvedJustifySelf(&amp;containingBlock-&gt;style(), containingBlock-&gt;selfAlignmentNormalBehavior(this)).position() == ItemPosition::Stretch;
2568 }
2569 
2570 bool RenderBox::sizesLogicalWidthToFitContent(SizeType widthType) const
2571 {
2572     // Marquees in WinIE are like a mixture of blocks and inline-blocks.  They size as though they&#39;re blocks,
2573     // but they allow text to sit on the same line as the marquee.
2574     if (isFloating() || (isInlineBlockOrInlineTable() &amp;&amp; !isHTMLMarquee()))
2575         return true;
2576 
2577     if (isGridItem())
2578         return !hasStretchedLogicalWidth();
2579 
2580     // This code may look a bit strange.  Basically width:intrinsic should clamp the size when testing both
2581     // min-width and width.  max-width is only clamped if it is also intrinsic.
2582     Length logicalWidth = (widthType == MaxSize) ? style().logicalMaxWidth() : style().logicalWidth();
2583     if (logicalWidth.type() == Intrinsic)
2584         return true;
2585 
2586     // Children of a horizontal marquee do not fill the container by default.
2587     // FIXME: Need to deal with MarqueeDirection::Auto value properly. It could be vertical.
2588     // FIXME: Think about block-flow here.  Need to find out how marquee direction relates to
2589     // block-flow (as well as how marquee overflow should relate to block flow).
2590     // https://bugs.webkit.org/show_bug.cgi?id=46472
2591     if (parent()-&gt;isHTMLMarquee()) {
2592         MarqueeDirection dir = parent()-&gt;style().marqueeDirection();
2593         if (dir == MarqueeDirection::Auto || dir == MarqueeDirection::Forward || dir == MarqueeDirection::Backward || dir == MarqueeDirection::Left || dir == MarqueeDirection::Right)
2594             return true;
2595     }
2596 
2597 #if ENABLE(MATHML)
2598     // RenderMathMLBlocks take the size of their content, not of their container.
2599     if (parent()-&gt;isRenderMathMLBlock())
2600         return true;
2601 #endif
2602 
2603     // Flexible box items should shrink wrap, so we lay them out at their intrinsic widths.
2604     // In the case of columns that have a stretch alignment, we layout at the stretched size
2605     // to avoid an extra layout when applying alignment.
2606     if (parent()-&gt;isFlexibleBox()) {
2607         // For multiline columns, we need to apply align-content first, so we can&#39;t stretch now.
2608         if (!parent()-&gt;style().isColumnFlexDirection() || parent()-&gt;style().flexWrap() != FlexWrap::NoWrap)
2609             return true;
2610         if (!columnFlexItemHasStretchAlignment())
2611             return true;
2612     }
2613 
2614     // Flexible horizontal boxes lay out children at their intrinsic widths.  Also vertical boxes
2615     // that don&#39;t stretch their kids lay out their children at their intrinsic widths.
2616     // FIXME: Think about block-flow here.
2617     // https://bugs.webkit.org/show_bug.cgi?id=46473
2618     if (parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Horizontal || parent()-&gt;style().boxAlign() != BoxAlignment::Stretch))
2619         return true;
2620 
2621     // Button, input, select, textarea, and legend treat width value of &#39;auto&#39; as &#39;intrinsic&#39; unless it&#39;s in a
2622     // stretching column flexbox.
2623     // FIXME: Think about block-flow here.
2624     // https://bugs.webkit.org/show_bug.cgi?id=46473
2625     if (logicalWidth.type() == Auto &amp;&amp; !isStretchingColumnFlexItem() &amp;&amp; element() &amp;&amp; (is&lt;HTMLInputElement&gt;(*element()) || is&lt;HTMLSelectElement&gt;(*element()) || is&lt;HTMLButtonElement&gt;(*element()) || is&lt;HTMLTextAreaElement&gt;(*element()) || is&lt;HTMLLegendElement&gt;(*element())))
2626         return true;
2627 
2628     if (isHorizontalWritingMode() != containingBlock()-&gt;isHorizontalWritingMode())
2629         return true;
2630 
2631     return false;
2632 }
2633 
2634 void RenderBox::computeInlineDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit containerWidth, LayoutUnit childWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const
2635 {
2636 
2637     const RenderStyle&amp; containingBlockStyle = containingBlock.style();
2638     Length marginStartLength = style().marginStartUsing(&amp;containingBlockStyle);
2639     Length marginEndLength = style().marginEndUsing(&amp;containingBlockStyle);
2640 
2641     if (isFloating() || isInline()) {
2642         // Inline blocks/tables and floats don&#39;t have their margins increased.
2643         marginStart = minimumValueForLength(marginStartLength, containerWidth);
2644         marginEnd = minimumValueForLength(marginEndLength, containerWidth);
2645         return;
2646     }
2647 
2648     if (containingBlock.isFlexibleBox()) {
2649         // We need to let flexbox handle the margin adjustment - otherwise, flexbox
2650         // will think we&#39;re wider than we actually are and calculate line sizes
2651         // wrong. See also http://dev.w3.org/csswg/css-flexbox/#auto-margins
2652         if (marginStartLength.isAuto())
2653             marginStartLength = Length(0, Fixed);
2654         if (marginEndLength.isAuto())
2655             marginEndLength = Length(0, Fixed);
2656     }
2657 
2658     // Case One: The object is being centered in the containing block&#39;s available logical width.
2659     if ((marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto() &amp;&amp; childWidth &lt; containerWidth)
2660         || (!marginStartLength.isAuto() &amp;&amp; !marginEndLength.isAuto() &amp;&amp; containingBlock.style().textAlign() == TextAlignMode::WebKitCenter)) {
2661         // Other browsers center the margin box for align=center elements so we match them here.
2662         LayoutUnit marginStartWidth = minimumValueForLength(marginStartLength, containerWidth);
2663         LayoutUnit marginEndWidth = minimumValueForLength(marginEndLength, containerWidth);
2664         LayoutUnit centeredMarginBoxStart = std::max&lt;LayoutUnit&gt;(0, (containerWidth - childWidth - marginStartWidth - marginEndWidth) / 2);
2665         marginStart = centeredMarginBoxStart + marginStartWidth;
2666         marginEnd = containerWidth - childWidth - marginStart + marginEndWidth;
2667         return;
2668     }
2669 
2670     // Case Two: The object is being pushed to the start of the containing block&#39;s available logical width.
2671     if (marginEndLength.isAuto() &amp;&amp; childWidth &lt; containerWidth) {
2672         marginStart = valueForLength(marginStartLength, containerWidth);
2673         marginEnd = containerWidth - childWidth - marginStart;
2674         return;
2675     }
2676 
2677     // Case Three: The object is being pushed to the end of the containing block&#39;s available logical width.
2678     bool pushToEndFromTextAlign = !marginEndLength.isAuto() &amp;&amp; ((!containingBlockStyle.isLeftToRightDirection() &amp;&amp; containingBlockStyle.textAlign() == TextAlignMode::WebKitLeft)
2679         || (containingBlockStyle.isLeftToRightDirection() &amp;&amp; containingBlockStyle.textAlign() == TextAlignMode::WebKitRight));
2680     if ((marginStartLength.isAuto() || pushToEndFromTextAlign) &amp;&amp; childWidth &lt; containerWidth) {
2681         marginEnd = valueForLength(marginEndLength, containerWidth);
2682         marginStart = containerWidth - childWidth - marginEnd;
2683         return;
2684     }
2685 
2686     // Case Four: Either no auto margins, or our width is &gt;= the container width (css2.1, 10.3.3).  In that case
2687     // auto margins will just turn into 0.
2688     marginStart = minimumValueForLength(marginStartLength, containerWidth);
2689     marginEnd = minimumValueForLength(marginEndLength, containerWidth);
2690 }
2691 
2692 RenderBoxFragmentInfo* RenderBox::renderBoxFragmentInfo(RenderFragmentContainer* fragment, RenderBoxFragmentInfoFlags cacheFlag) const
2693 {
2694     // Make sure nobody is trying to call this with a null fragment.
2695     if (!fragment)
2696         return nullptr;
2697 
2698     // If we have computed our width in this fragment already, it will be cached, and we can
2699     // just return it.
2700     RenderBoxFragmentInfo* boxInfo = fragment-&gt;renderBoxFragmentInfo(this);
2701     if (boxInfo &amp;&amp; cacheFlag == CacheRenderBoxFragmentInfo)
2702         return boxInfo;
2703 
2704     return nullptr;
2705 }
2706 
2707 static bool shouldFlipBeforeAfterMargins(const RenderStyle&amp; containingBlockStyle, const RenderStyle* childStyle)
2708 {
2709     ASSERT(containingBlockStyle.isHorizontalWritingMode() != childStyle-&gt;isHorizontalWritingMode());
2710     WritingMode childWritingMode = childStyle-&gt;writingMode();
2711     bool shouldFlip = false;
2712     switch (containingBlockStyle.writingMode()) {
2713     case TopToBottomWritingMode:
2714         shouldFlip = (childWritingMode == RightToLeftWritingMode);
2715         break;
2716     case BottomToTopWritingMode:
2717         shouldFlip = (childWritingMode == RightToLeftWritingMode);
2718         break;
2719     case RightToLeftWritingMode:
2720         shouldFlip = (childWritingMode == BottomToTopWritingMode);
2721         break;
2722     case LeftToRightWritingMode:
2723         shouldFlip = (childWritingMode == BottomToTopWritingMode);
2724         break;
2725     }
2726 
2727     if (!containingBlockStyle.isLeftToRightDirection())
2728         shouldFlip = !shouldFlip;
2729 
2730     return shouldFlip;
2731 }
2732 
2733 void RenderBox::cacheIntrinsicContentLogicalHeightForFlexItem(LayoutUnit height) const
2734 {
2735     if (isFloatingOrOutOfFlowPositioned() || !parent() || !parent()-&gt;isFlexibleBox())
2736         return;
2737     downcast&lt;RenderFlexibleBox&gt;(parent())-&gt;setCachedChildIntrinsicContentLogicalHeight(*this, height);
2738 }
2739 
2740 void RenderBox::updateLogicalHeight()
2741 {
2742     cacheIntrinsicContentLogicalHeightForFlexItem(contentLogicalHeight());
2743     auto computedValues = computeLogicalHeight(logicalHeight(), logicalTop());
2744     setLogicalHeight(computedValues.m_extent);
2745     setLogicalTop(computedValues.m_position);
2746     setMarginBefore(computedValues.m_margins.m_before);
2747     setMarginAfter(computedValues.m_margins.m_after);
2748 }
2749 
2750 RenderBox::LogicalExtentComputedValues RenderBox::computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const
2751 {
2752     LogicalExtentComputedValues computedValues;
2753     computedValues.m_extent = logicalHeight;
2754     computedValues.m_position = logicalTop;
2755 
2756     // Cell height is managed by the table and inline non-replaced elements do not support a height property.
2757     if (isTableCell() || (isInline() &amp;&amp; !isReplaced()))
2758         return computedValues;
2759 
2760     Length h;
2761     if (isOutOfFlowPositioned())
2762         computePositionedLogicalHeight(computedValues);
2763     else {
2764         RenderBlock&amp; cb = *containingBlock();
2765         bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2766 
2767         if (!hasPerpendicularContainingBlock) {
2768             bool shouldFlipBeforeAfter = cb.style().writingMode() != style().writingMode();
2769             computeBlockDirectionMargins(cb,
2770                 shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2771                 shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2772         }
2773 
2774         // For tables, calculate margins only.
2775         if (isTable()) {
2776             if (hasPerpendicularContainingBlock) {
2777                 bool shouldFlipBeforeAfter = shouldFlipBeforeAfterMargins(cb.style(), &amp;style());
2778                 computeInlineDirectionMargins(cb, containingBlockLogicalWidthForContent(), computedValues.m_extent,
2779                     shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2780                     shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2781             }
2782             return computedValues;
2783         }
2784 
2785         // FIXME: Account for block-flow in flexible boxes.
2786         // https://bugs.webkit.org/show_bug.cgi?id=46418
2787         bool inHorizontalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Horizontal;
2788         bool stretching = parent()-&gt;style().boxAlign() == BoxAlignment::Stretch;
2789         bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inHorizontalBox || !stretching);
2790         bool checkMinMaxHeight = false;
2791 
2792         // The parent box is flexing us, so it has increased or decreased our height.  We have to
2793         // grab our cached flexible height.
2794         // FIXME: Account for block-flow in flexible boxes.
2795         // https://bugs.webkit.org/show_bug.cgi?id=46418
2796         if (hasOverrideContentLogicalHeight() &amp;&amp; (parent()-&gt;isFlexibleBoxIncludingDeprecated() || parent()-&gt;isRenderGrid())) {
2797             h = Length(overrideContentLogicalHeight(), Fixed);
2798         } else if (treatAsReplaced)
2799             h = Length(computeReplacedLogicalHeight(), Fixed);
2800         else {
2801             h = style().logicalHeight();
2802             checkMinMaxHeight = true;
2803         }
2804 
2805         // Block children of horizontal flexible boxes fill the height of the box.
2806         // FIXME: Account for block-flow in flexible boxes.
2807         // https://bugs.webkit.org/show_bug.cgi?id=46418
2808         if (h.isAuto() &amp;&amp; is&lt;RenderDeprecatedFlexibleBox&gt;(*parent()) &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Horizontal
2809                 &amp;&amp; downcast&lt;RenderDeprecatedFlexibleBox&gt;(*parent()).isStretchingChildren()) {
2810             h = Length(parentBox()-&gt;contentLogicalHeight() - marginBefore() - marginAfter() - borderAndPaddingLogicalHeight(), Fixed);
2811             checkMinMaxHeight = false;
2812         }
2813 
2814         LayoutUnit heightResult;
2815         if (checkMinMaxHeight) {
2816             LayoutUnit intrinsicHeight = computedValues.m_extent - borderAndPaddingLogicalHeight();
2817             heightResult = computeLogicalHeightUsing(MainOrPreferredSize, style().logicalHeight(), intrinsicHeight).valueOr(computedValues.m_extent);
2818             heightResult = constrainLogicalHeightByMinMax(heightResult, intrinsicHeight);
2819         } else {
2820             // The only times we don&#39;t check min/max height are when a fixed length has
2821             // been given as an override.  Just use that.  The value has already been adjusted
2822             // for box-sizing.
2823             ASSERT(h.isFixed());
2824             heightResult = h.value() + borderAndPaddingLogicalHeight();
2825         }
2826 
2827         computedValues.m_extent = heightResult;
2828 
2829         if (hasPerpendicularContainingBlock) {
2830             bool shouldFlipBeforeAfter = shouldFlipBeforeAfterMargins(cb.style(), &amp;style());
2831             computeInlineDirectionMargins(cb, containingBlockLogicalWidthForContent(), heightResult,
2832                     shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2833                     shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2834         }
2835     }
2836 
2837     // WinIE quirk: The &lt;html&gt; block always fills the entire canvas in quirks mode.  The &lt;body&gt; always fills the
2838     // &lt;html&gt; block in quirks mode.  Only apply this quirk if the block is normal flow and no height
2839     // is specified. When we&#39;re printing, we also need this quirk if the body or root has a percentage
2840     // height since we don&#39;t set a height in RenderView when we&#39;re printing. So without this quirk, the
2841     // height has nothing to be a percentage of, and it ends up being 0. That is bad.
2842     bool paginatedContentNeedsBaseHeight = document().printing() &amp;&amp; h.isPercentOrCalculated()
2843         &amp;&amp; (isDocumentElementRenderer() || (isBody() &amp;&amp; document().documentElement()-&gt;renderer()-&gt;style().logicalHeight().isPercentOrCalculated())) &amp;&amp; !isInline();
2844     if (stretchesToViewport() || paginatedContentNeedsBaseHeight) {
2845         LayoutUnit margins = collapsedMarginBefore() + collapsedMarginAfter();
2846         LayoutUnit visibleHeight = view().pageOrViewLogicalHeight();
2847         if (isDocumentElementRenderer())
2848             computedValues.m_extent = std::max(computedValues.m_extent, visibleHeight - margins);
2849         else {
2850             LayoutUnit marginsBordersPadding = margins + parentBox()-&gt;marginBefore() + parentBox()-&gt;marginAfter() + parentBox()-&gt;borderAndPaddingLogicalHeight();
2851             computedValues.m_extent = std::max(computedValues.m_extent, visibleHeight - marginsBordersPadding);
2852         }
2853     }
2854     return computedValues;
2855 }
2856 
2857 LayoutUnit RenderBox::computeLogicalHeightWithoutLayout() const
2858 {
2859     // FIXME:: We should probably return something other than just
2860     // border + padding, but for now we have no good way to do anything else
2861     // without layout, so we just use that.
2862     LogicalExtentComputedValues computedValues = computeLogicalHeight(borderAndPaddingLogicalHeight(), 0_lu);
2863     return computedValues.m_extent;
2864 }
2865 
2866 Optional&lt;LayoutUnit&gt; RenderBox::computeLogicalHeightUsing(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2867 {
2868     if (Optional&lt;LayoutUnit&gt; logicalHeight = computeContentAndScrollbarLogicalHeightUsing(heightType, height, intrinsicContentHeight))
2869         return adjustBorderBoxLogicalHeightForBoxSizing(logicalHeight.value());
2870     return WTF::nullopt;
2871 }
2872 
2873 Optional&lt;LayoutUnit&gt; RenderBox::computeContentLogicalHeight(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2874 {
2875     if (Optional&lt;LayoutUnit&gt; heightIncludingScrollbar = computeContentAndScrollbarLogicalHeightUsing(heightType, height, intrinsicContentHeight))
2876         return std::max&lt;LayoutUnit&gt;(0, adjustContentBoxLogicalHeightForBoxSizing(heightIncludingScrollbar) - scrollbarLogicalHeight());
2877     return WTF::nullopt;
2878 }
2879 
2880 Optional&lt;LayoutUnit&gt; RenderBox::computeIntrinsicLogicalContentHeightUsing(Length logicalHeightLength, Optional&lt;LayoutUnit&gt; intrinsicContentHeight, LayoutUnit borderAndPadding) const
2881 {
2882     // FIXME: The CSS sizing spec is considering changing what min-content/max-content should resolve to.
2883     // If that happens, this code will have to change.
2884     if (logicalHeightLength.isMinContent() || logicalHeightLength.isMaxContent() || logicalHeightLength.isFitContent()) {
2885         if (!intrinsicContentHeight)
2886             return intrinsicContentHeight;
2887         if (style().boxSizing() == BoxSizing::BorderBox)
2888             return intrinsicContentHeight.value() + borderAndPaddingLogicalHeight();
2889         return intrinsicContentHeight;
2890     }
2891     if (logicalHeightLength.isFillAvailable())
2892         return containingBlock()-&gt;availableLogicalHeight(ExcludeMarginBorderPadding) - borderAndPadding;
2893     ASSERT_NOT_REACHED();
2894     return 0_lu;
2895 }
2896 
2897 Optional&lt;LayoutUnit&gt; RenderBox::computeContentAndScrollbarLogicalHeightUsing(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2898 {
2899     if (height.isAuto())
2900         return heightType == MinSize ? Optional&lt;LayoutUnit&gt;(0) : WTF::nullopt;
2901     // FIXME: The CSS sizing spec is considering changing what min-content/max-content should resolve to.
2902     // If that happens, this code will have to change.
2903     if (height.isIntrinsic())
2904         return computeIntrinsicLogicalContentHeightUsing(height, intrinsicContentHeight, borderAndPaddingLogicalHeight());
2905     if (height.isFixed())
2906         return LayoutUnit(height.value());
2907     if (height.isPercentOrCalculated())
2908         return computePercentageLogicalHeight(height);
2909     return WTF::nullopt;
2910 }
2911 
2912 bool RenderBox::skipContainingBlockForPercentHeightCalculation(const RenderBox&amp; containingBlock, bool isPerpendicularWritingMode) const
2913 {
2914     // Flow threads for multicol or paged overflow should be skipped. They are invisible to the DOM,
2915     // and percent heights of children should be resolved against the multicol or paged container.
2916     if (containingBlock.isInFlowRenderFragmentedFlow() &amp;&amp; !isPerpendicularWritingMode)
2917         return true;
2918 
2919     // Render view is not considered auto height.
2920     if (is&lt;RenderView&gt;(containingBlock))
2921         return false;
2922 
2923     // If the writing mode of the containing block is orthogonal to ours, it means
2924     // that we shouldn&#39;t skip anything, since we&#39;re going to resolve the
2925     // percentage height against a containing block *width*.
2926     if (isPerpendicularWritingMode)
2927         return false;
2928 
2929     // Anonymous blocks should not impede percentage resolution on a child.
2930     // Examples of such anonymous blocks are blocks wrapped around inlines that
2931     // have block siblings (from the CSS spec) and multicol flow threads (an
2932     // implementation detail). Another implementation detail, ruby runs, create
2933     // anonymous inline-blocks, so skip those too. All other types of anonymous
2934     // objects, such as table-cells and flexboxes, will be treated as if they were
2935     // non-anonymous.
2936     if (containingBlock.isAnonymous())
2937         return containingBlock.style().display() == DisplayType::Block || containingBlock.style().display() == DisplayType::InlineBlock;
2938 
2939     // For quirks mode, we skip most auto-height containing blocks when computing
2940     // percentages.
2941     return document().inQuirksMode() &amp;&amp; !containingBlock.isTableCell() &amp;&amp; !containingBlock.isOutOfFlowPositioned() &amp;&amp; !containingBlock.isRenderGrid() &amp;&amp; containingBlock.style().logicalHeight().isAuto();
2942 }
2943 
2944 bool RenderBox::shouldTreatChildAsReplacedInTableCells() const
2945 {
2946     if (isReplaced())
2947         return true;
2948     return element() &amp;&amp; (element()-&gt;isFormControlElement() || is&lt;HTMLImageElement&gt;(element()));
2949 }
2950 
2951 static bool tableCellShouldHaveZeroInitialSize(const RenderBlock&amp; block, const RenderBox&amp; child, bool scrollsOverflowY)
2952 {
2953     // Normally we would let the cell size intrinsically, but scrolling overflow has to be
2954     // treated differently, since WinIE lets scrolled overflow fragments shrink as needed.
2955     // While we can&#39;t get all cases right, we can at least detect when the cell has a specified
2956     // height or when the table has a specified height. In these cases we want to initially have
2957     // no size and allow the flexing of the table or the cell to its specified height to cause us
2958     // to grow to fill the space. This could end up being wrong in some cases, but it is
2959     // preferable to the alternative (sizing intrinsically and making the row end up too big).
2960     const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(block);
2961     return scrollsOverflowY &amp;&amp; !child.shouldTreatChildAsReplacedInTableCells() &amp;&amp; (!cell.style().logicalHeight().isAuto() || !cell.table()-&gt;style().logicalHeight().isAuto());
2962 }
2963 
2964 Optional&lt;LayoutUnit&gt; RenderBox::computePercentageLogicalHeight(const Length&amp; height) const
2965 {
2966     Optional&lt;LayoutUnit&gt; availableHeight;
2967 
2968     bool skippedAutoHeightContainingBlock = false;
2969     RenderBlock* cb = containingBlock();
2970     const RenderBox* containingBlockChild = this;
2971     LayoutUnit rootMarginBorderPaddingHeight;
2972     bool isHorizontal = isHorizontalWritingMode();
2973     while (cb &amp;&amp; !is&lt;RenderView&gt;(*cb) &amp;&amp; skipContainingBlockForPercentHeightCalculation(*cb, isHorizontal != cb-&gt;isHorizontalWritingMode())) {
2974         if (cb-&gt;isBody() || cb-&gt;isDocumentElementRenderer())
2975             rootMarginBorderPaddingHeight += cb-&gt;marginBefore() + cb-&gt;marginAfter() + cb-&gt;borderAndPaddingLogicalHeight();
2976         skippedAutoHeightContainingBlock = true;
2977         containingBlockChild = cb;
2978         cb = cb-&gt;containingBlock();
2979     }
2980     cb-&gt;addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
2981 
2982     if (isHorizontal != cb-&gt;isHorizontalWritingMode())
2983         availableHeight = containingBlockChild-&gt;containingBlockLogicalWidthForContent();
2984     else if (hasOverrideContainingBlockContentLogicalHeight())
2985         availableHeight = overrideContainingBlockContentLogicalHeight();
2986     else if (is&lt;RenderTableCell&gt;(*cb)) {
2987         if (!skippedAutoHeightContainingBlock) {
2988             // Table cells violate what the CSS spec says to do with heights. Basically we
2989             // don&#39;t care if the cell specified a height or not. We just always make ourselves
2990             // be a percentage of the cell&#39;s current content height.
2991             if (!cb-&gt;hasOverrideContentLogicalHeight())
2992                 return tableCellShouldHaveZeroInitialSize(*cb, *this, scrollsOverflowY()) ? Optional&lt;LayoutUnit&gt;(0) : WTF::nullopt;
2993 
2994             availableHeight = cb-&gt;overrideContentLogicalHeight();
2995         }
2996     } else
2997         availableHeight = cb-&gt;availableLogicalHeightForPercentageComputation();
2998 
2999     if (!availableHeight)
3000         return availableHeight;
3001 
3002     LayoutUnit result = valueForLength(height, availableHeight.value() - rootMarginBorderPaddingHeight + (isTable() &amp;&amp; isOutOfFlowPositioned() ? cb-&gt;paddingBefore() + cb-&gt;paddingAfter() : 0_lu));
3003 
3004     // |overrideContentLogicalHeight| is the maximum height made available by the
3005     // cell to its percent height children when we decide they can determine the
3006     // height of the cell. If the percent height child is box-sizing:content-box
3007     // then we must subtract the border and padding from the cell&#39;s
3008     // |availableHeight| (given by |overrideContentLogicalHeight|) to arrive
3009     // at the child&#39;s computed height.
3010     bool subtractBorderAndPadding = isTable() || (is&lt;RenderTableCell&gt;(*cb) &amp;&amp; !skippedAutoHeightContainingBlock &amp;&amp; cb-&gt;hasOverrideContentLogicalHeight());
3011     if (subtractBorderAndPadding) {
3012         result -= borderAndPaddingLogicalHeight();
3013         return std::max(0_lu, result);
3014     }
3015     return result;
3016 }
3017 
3018 LayoutUnit RenderBox::computeReplacedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
3019 {
3020     return computeReplacedLogicalWidthRespectingMinMaxWidth(computeReplacedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth()), shouldComputePreferred);
3021 }
3022 
3023 LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const
3024 {
3025     auto&amp; logicalMinWidth = style().logicalMinWidth();
3026     auto&amp; logicalMaxWidth = style().logicalMaxWidth();
3027     bool useLogicalWidthForMinWidth = (shouldComputePreferred == ComputePreferred &amp;&amp; logicalMinWidth.isPercentOrCalculated()) || logicalMinWidth.isUndefined();
3028     bool useLogicalWidthForMaxWidth = (shouldComputePreferred == ComputePreferred &amp;&amp; logicalMaxWidth.isPercentOrCalculated()) || logicalMaxWidth.isUndefined();
3029     auto minLogicalWidth =  useLogicalWidthForMinWidth ? logicalWidth : computeReplacedLogicalWidthUsing(MinSize, logicalMinWidth);
3030     auto maxLogicalWidth =  useLogicalWidthForMaxWidth ? logicalWidth : computeReplacedLogicalWidthUsing(MaxSize, logicalMaxWidth);
3031     return std::max(minLogicalWidth, std::min(logicalWidth, maxLogicalWidth));
3032 }
3033 
3034 LayoutUnit RenderBox::computeReplacedLogicalWidthUsing(SizeType widthType, Length logicalWidth) const
3035 {
3036     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
3037     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
3038         return adjustContentBoxLogicalWidthForBoxSizing(0);
3039 
3040     switch (logicalWidth.type()) {
3041         case Fixed:
3042             return adjustContentBoxLogicalWidthForBoxSizing(logicalWidth.value());
3043         case MinContent:
3044         case MaxContent: {
3045             // MinContent/MaxContent don&#39;t need the availableLogicalWidth argument.
3046             LayoutUnit availableLogicalWidth;
3047             return computeIntrinsicLogicalWidthUsing(logicalWidth, availableLogicalWidth, borderAndPaddingLogicalWidth()) - borderAndPaddingLogicalWidth();
3048         }
3049         case FitContent:
3050         case FillAvailable:
3051         case Percent:
3052         case Calculated: {
3053             // FIXME: containingBlockLogicalWidthForContent() is wrong if the replaced element&#39;s block-flow is perpendicular to the
3054             // containing block&#39;s block-flow.
3055             // https://bugs.webkit.org/show_bug.cgi?id=46496
3056             const LayoutUnit cw = isOutOfFlowPositioned() ? containingBlockLogicalWidthForPositioned(downcast&lt;RenderBoxModelObject&gt;(*container())) : containingBlockLogicalWidthForContent();
3057             Length containerLogicalWidth = containingBlock()-&gt;style().logicalWidth();
3058             // FIXME: Handle cases when containing block width is calculated or viewport percent.
3059             // https://bugs.webkit.org/show_bug.cgi?id=91071
3060             if (logicalWidth.isIntrinsic())
3061                 return computeIntrinsicLogicalWidthUsing(logicalWidth, cw, borderAndPaddingLogicalWidth()) - borderAndPaddingLogicalWidth();
3062             if (cw &gt; 0 || (!cw &amp;&amp; (containerLogicalWidth.isFixed() || containerLogicalWidth.isPercentOrCalculated())))
3063                 return adjustContentBoxLogicalWidthForBoxSizing(minimumValueForLength(logicalWidth, cw));
3064             return 0_lu;
3065         }
3066         case Intrinsic:
3067         case MinIntrinsic:
3068         case Auto:
3069         case Relative:
3070         case Undefined:
3071             return intrinsicLogicalWidth();
3072     }
3073 
3074     ASSERT_NOT_REACHED();
3075     return 0;
3076 }
3077 
3078 LayoutUnit RenderBox::computeReplacedLogicalHeight(Optional&lt;LayoutUnit&gt;) const
3079 {
3080     return computeReplacedLogicalHeightRespectingMinMaxHeight(computeReplacedLogicalHeightUsing(MainOrPreferredSize, style().logicalHeight()));
3081 }
3082 
3083 static bool allowMinMaxPercentagesInAutoHeightBlocksQuirk()
3084 {
3085 #if PLATFORM(MAC)
3086     return MacApplication::isIBooks();
3087 #elif PLATFORM(IOS_FAMILY)
3088     return IOSApplication::isIBooks();
3089 #endif
3090     return false;
3091 }
3092 
3093 bool RenderBox::replacedMinMaxLogicalHeightComputesAsNone(SizeType sizeType) const
3094 {
3095     ASSERT(sizeType == MinSize || sizeType == MaxSize);
3096 
3097     auto logicalHeight = sizeType == MinSize ? style().logicalMinHeight() : style().logicalMaxHeight();
3098     auto initialLogicalHeight = sizeType == MinSize ? RenderStyle::initialMinSize() : RenderStyle::initialMaxSize();
3099 
3100     if (logicalHeight == initialLogicalHeight)
3101         return true;
3102 
3103     // Make sure % min-height and % max-height resolve to none if the containing block has auto height.
3104     // Note that the &quot;height&quot; case for replaced elements was handled by hasReplacedLogicalHeight, which is why
3105     // min and max-height are the only ones handled here.
3106     // FIXME: For now we put in a quirk for iBooks until we can move them to viewport units.
3107     if (auto* cb = containingBlockForAutoHeightDetection(logicalHeight))
3108         return allowMinMaxPercentagesInAutoHeightBlocksQuirk() ? false : cb-&gt;hasAutoHeightOrContainingBlockWithAutoHeight();
3109 
3110     return false;
3111 }
3112 
3113 LayoutUnit RenderBox::computeReplacedLogicalHeightRespectingMinMaxHeight(LayoutUnit logicalHeight) const
3114 {
3115     LayoutUnit minLogicalHeight;
3116     if (!replacedMinMaxLogicalHeightComputesAsNone(MinSize))
3117         minLogicalHeight = computeReplacedLogicalHeightUsing(MinSize, style().logicalMinHeight());
3118     LayoutUnit maxLogicalHeight = logicalHeight;
3119     if (!replacedMinMaxLogicalHeightComputesAsNone(MaxSize))
3120         maxLogicalHeight = computeReplacedLogicalHeightUsing(MaxSize, style().logicalMaxHeight());
3121     return std::max(minLogicalHeight, std::min(logicalHeight, maxLogicalHeight));
3122 }
3123 
3124 LayoutUnit RenderBox::computeReplacedLogicalHeightUsing(SizeType heightType, Length logicalHeight) const
3125 {
3126     ASSERT(heightType == MinSize || heightType == MainOrPreferredSize || !logicalHeight.isAuto());
3127     if (heightType == MinSize &amp;&amp; logicalHeight.isAuto())
3128         return adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt;(0));
3129 
3130     switch (logicalHeight.type()) {
3131         case Fixed:
3132             return adjustContentBoxLogicalHeightForBoxSizing(LayoutUnit(logicalHeight.value()));
3133         case Percent:
3134         case Calculated:
3135         {
3136             auto* container = isOutOfFlowPositioned() ? this-&gt;container() : containingBlock();
3137             while (container &amp;&amp; container-&gt;isAnonymous()) {
3138                 // Stop at rendering context root.
3139                 if (is&lt;RenderView&gt;(*container))
3140                     break;
3141                 container = container-&gt;containingBlock();
3142             }
3143             Optional&lt;LayoutUnit&gt; stretchedHeight;
3144             if (is&lt;RenderBlock&gt;(container)) {
3145                 auto* block = downcast&lt;RenderBlock&gt;(container);
3146                 block-&gt;addPercentHeightDescendant(*const_cast&lt;RenderBox*&gt;(this));
3147                 if (block-&gt;isFlexItem())
3148                     stretchedHeight = downcast&lt;RenderFlexibleBox&gt;(block-&gt;parent())-&gt;childLogicalHeightForPercentageResolution(*block);
3149                 else if (block-&gt;isGridItem() &amp;&amp; block-&gt;hasOverrideContentLogicalHeight())
3150                     stretchedHeight = block-&gt;overrideContentLogicalHeight();
3151             }
3152 
3153             // FIXME: This calculation is not patched for block-flow yet.
3154             // https://bugs.webkit.org/show_bug.cgi?id=46500
3155             if (container-&gt;isOutOfFlowPositioned()
3156                 &amp;&amp; container-&gt;style().height().isAuto()
3157                 &amp;&amp; !(container-&gt;style().top().isAuto() || container-&gt;style().bottom().isAuto())) {
3158                 ASSERT_WITH_SECURITY_IMPLICATION(container-&gt;isRenderBlock());
3159                 auto&amp; block = downcast&lt;RenderBlock&gt;(*container);
3160                 auto computedValues = block.computeLogicalHeight(block.logicalHeight(), 0);
3161                 LayoutUnit newContentHeight = computedValues.m_extent - block.borderAndPaddingLogicalHeight() - block.scrollbarLogicalHeight();
3162                 return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeight, newContentHeight));
3163             }
3164 
3165             // FIXME: availableLogicalHeight() is wrong if the replaced element&#39;s block-flow is perpendicular to the
3166             // containing block&#39;s block-flow.
3167             // https://bugs.webkit.org/show_bug.cgi?id=46496
3168             LayoutUnit availableHeight;
3169             if (isOutOfFlowPositioned())
3170                 availableHeight = containingBlockLogicalHeightForPositioned(downcast&lt;RenderBoxModelObject&gt;(*container));
3171             else if (stretchedHeight)
3172                 availableHeight = stretchedHeight.value();
3173             else {
3174                 availableHeight = containingBlockLogicalHeightForContent(IncludeMarginBorderPadding);
3175                 // It is necessary to use the border-box to match WinIE&#39;s broken
3176                 // box model.  This is essential for sizing inside
3177                 // table cells using percentage heights.
3178                 // FIXME: This needs to be made block-flow-aware.  If the cell and image are perpendicular block-flows, this isn&#39;t right.
3179                 // https://bugs.webkit.org/show_bug.cgi?id=46997
3180                 while (container &amp;&amp; !is&lt;RenderView&gt;(*container)
3181                     &amp;&amp; (container-&gt;style().logicalHeight().isAuto() || container-&gt;style().logicalHeight().isPercentOrCalculated())) {
3182                     if (container-&gt;isTableCell()) {
3183                         // Don&#39;t let table cells squeeze percent-height replaced elements
3184                         // &lt;http://bugs.webkit.org/show_bug.cgi?id=15359&gt;
3185                         availableHeight = std::max(availableHeight, intrinsicLogicalHeight());
3186                         return valueForLength(logicalHeight, availableHeight - borderAndPaddingLogicalHeight());
3187                     }
3188                     downcast&lt;RenderBlock&gt;(*container).addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
3189                     container = container-&gt;containingBlock();
3190                 }
3191             }
3192             return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeight, availableHeight));
3193         }
3194         case MinContent:
3195         case MaxContent:
3196         case FitContent:
3197         case FillAvailable:
3198             return adjustContentBoxLogicalHeightForBoxSizing(computeIntrinsicLogicalContentHeightUsing(logicalHeight, intrinsicLogicalHeight(), borderAndPaddingLogicalHeight()));
3199         default:
3200             return intrinsicLogicalHeight();
3201     }
3202 }
3203 
3204 LayoutUnit RenderBox::availableLogicalHeight(AvailableLogicalHeightType heightType) const
3205 {
3206     return constrainLogicalHeightByMinMax(availableLogicalHeightUsing(style().logicalHeight(), heightType), WTF::nullopt);
3207 }
3208 
3209 LayoutUnit RenderBox::availableLogicalHeightUsing(const Length&amp; h, AvailableLogicalHeightType heightType) const
3210 {
3211     // We need to stop here, since we don&#39;t want to increase the height of the table
3212     // artificially.  We&#39;re going to rely on this cell getting expanded to some new
3213     // height, and then when we lay out again we&#39;ll use the calculation below.
3214     if (isTableCell() &amp;&amp; (h.isAuto() || h.isPercentOrCalculated())) {
3215         if (hasOverrideContentLogicalHeight())
3216             return overrideContentLogicalHeight();
3217         return logicalHeight() - borderAndPaddingLogicalHeight();
3218     }
3219 
3220     if (isFlexItem()) {
3221         auto&amp; flexBox = downcast&lt;RenderFlexibleBox&gt;(*parent());
3222         auto stretchedHeight = flexBox.childLogicalHeightForPercentageResolution(*this);
3223         if (stretchedHeight)
3224             return stretchedHeight.value();
3225     }
3226 
3227     if (h.isPercentOrCalculated() &amp;&amp; isOutOfFlowPositioned() &amp;&amp; !isRenderFragmentedFlow()) {
3228         // FIXME: This is wrong if the containingBlock has a perpendicular writing mode.
3229         LayoutUnit availableHeight = containingBlockLogicalHeightForPositioned(*containingBlock());
3230         return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(h, availableHeight));
3231     }
3232 
3233     if (Optional&lt;LayoutUnit&gt; heightIncludingScrollbar = computeContentAndScrollbarLogicalHeightUsing(MainOrPreferredSize, h, WTF::nullopt))
3234         return std::max&lt;LayoutUnit&gt;(0, adjustContentBoxLogicalHeightForBoxSizing(heightIncludingScrollbar) - scrollbarLogicalHeight());
3235 
3236     // FIXME: Check logicalTop/logicalBottom here to correctly handle vertical writing-mode.
3237     // https://bugs.webkit.org/show_bug.cgi?id=46500
3238     if (is&lt;RenderBlock&gt;(*this) &amp;&amp; isOutOfFlowPositioned() &amp;&amp; style().height().isAuto() &amp;&amp; !(style().top().isAuto() || style().bottom().isAuto())) {
3239         RenderBlock&amp; block = const_cast&lt;RenderBlock&amp;&gt;(downcast&lt;RenderBlock&gt;(*this));
3240         auto computedValues = block.computeLogicalHeight(block.logicalHeight(), 0);
3241         return computedValues.m_extent - block.borderAndPaddingLogicalHeight() - block.scrollbarLogicalHeight();
3242     }
3243 
3244     // FIXME: This is wrong if the containingBlock has a perpendicular writing mode.
3245     LayoutUnit availableHeight = containingBlockLogicalHeightForContent(heightType);
3246     if (heightType == ExcludeMarginBorderPadding) {
3247         // FIXME: Margin collapsing hasn&#39;t happened yet, so this incorrectly removes collapsed margins.
3248         availableHeight -= marginBefore() + marginAfter() + borderAndPaddingLogicalHeight();
3249     }
3250     return availableHeight;
3251 }
3252 
3253 void RenderBox::computeBlockDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit&amp; marginBefore, LayoutUnit&amp; marginAfter) const
3254 {
3255     if (isTableCell()) {
3256         // FIXME: Not right if we allow cells to have different directionality than the table.  If we do allow this, though,
3257         // we may just do it with an extra anonymous block inside the cell.
3258         marginBefore = 0;
3259         marginAfter = 0;
3260         return;
3261     }
3262 
3263     // Margins are calculated with respect to the logical width of
3264     // the containing block (8.3)
3265     LayoutUnit cw = containingBlockLogicalWidthForContent();
3266     const RenderStyle&amp; containingBlockStyle = containingBlock.style();
3267     marginBefore = minimumValueForLength(style().marginBeforeUsing(&amp;containingBlockStyle), cw);
3268     marginAfter = minimumValueForLength(style().marginAfterUsing(&amp;containingBlockStyle), cw);
3269 }
3270 
3271 void RenderBox::computeAndSetBlockDirectionMargins(const RenderBlock&amp; containingBlock)
3272 {
3273     LayoutUnit marginBefore;
3274     LayoutUnit marginAfter;
3275     computeBlockDirectionMargins(containingBlock, marginBefore, marginAfter);
3276     containingBlock.setMarginBeforeForChild(*this, marginBefore);
3277     containingBlock.setMarginAfterForChild(*this, marginAfter);
3278 }
3279 
3280 LayoutUnit RenderBox::containingBlockLogicalWidthForPositioned(const RenderBoxModelObject&amp; containingBlock, RenderFragmentContainer* fragment, bool checkForPerpendicularWritingMode) const
3281 {
3282     if (checkForPerpendicularWritingMode &amp;&amp; containingBlock.isHorizontalWritingMode() != isHorizontalWritingMode())
3283         return containingBlockLogicalHeightForPositioned(containingBlock, false);
3284 
3285     if (hasOverrideContainingBlockContentLogicalWidth()) {
3286         if (auto overrideLogicalWidth = overrideContainingBlockContentLogicalWidth())
3287             return overrideLogicalWidth.value();
3288     }
3289 
3290     if (is&lt;RenderBox&gt;(containingBlock)) {
3291         bool isFixedPosition = isFixedPositioned();
3292 
3293         RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3294         if (!fragmentedFlow) {
3295             if (isFixedPosition &amp;&amp; is&lt;RenderView&gt;(containingBlock))
3296                 return downcast&lt;RenderView&gt;(containingBlock).clientLogicalWidthForFixedPosition();
3297 
3298             return downcast&lt;RenderBox&gt;(containingBlock).clientLogicalWidth();
3299         }
3300 
3301         if (!is&lt;RenderBlock&gt;(containingBlock))
3302             return downcast&lt;RenderBox&gt;(containingBlock).clientLogicalWidth();
3303 
3304         const RenderBlock&amp; cb = downcast&lt;RenderBlock&gt;(containingBlock);
3305         RenderBoxFragmentInfo* boxInfo = nullptr;
3306         if (!fragment) {
3307             if (is&lt;RenderFragmentedFlow&gt;(containingBlock) &amp;&amp; !checkForPerpendicularWritingMode)
3308                 return downcast&lt;RenderFragmentedFlow&gt;(containingBlock).contentLogicalWidthOfFirstFragment();
3309             if (isWritingModeRoot()) {
3310                 LayoutUnit cbPageOffset = cb.offsetFromLogicalTopOfFirstPage();
3311                 RenderFragmentContainer* cbFragment = cb.fragmentAtBlockOffset(cbPageOffset);
3312                 if (cbFragment)
3313                     boxInfo = cb.renderBoxFragmentInfo(cbFragment);
3314             }
3315         } else if (fragmentedFlow-&gt;isHorizontalWritingMode() == containingBlock.isHorizontalWritingMode()) {
3316             RenderFragmentContainer* containingBlockFragment = cb.clampToStartAndEndFragments(fragment);
3317             boxInfo = cb.renderBoxFragmentInfo(containingBlockFragment);
3318         }
3319         return (boxInfo) ? std::max&lt;LayoutUnit&gt;(0, cb.clientLogicalWidth() - (cb.logicalWidth() - boxInfo-&gt;logicalWidth())) : cb.clientLogicalWidth();
3320     }
3321 
3322     ASSERT(containingBlock.isInFlowPositioned());
3323 
3324     const auto&amp; flow = downcast&lt;RenderInline&gt;(containingBlock);
3325     InlineFlowBox* first = flow.firstLineBox();
3326     InlineFlowBox* last = flow.lastLineBox();
3327 
3328     // If the containing block is empty, return a width of 0.
3329     if (!first || !last)
3330         return 0;
3331 
3332     LayoutUnit fromLeft;
3333     LayoutUnit fromRight;
3334     if (containingBlock.style().isLeftToRightDirection()) {
3335         fromLeft = first-&gt;logicalLeft() + first-&gt;borderLogicalLeft();
3336         fromRight = last-&gt;logicalLeft() + last-&gt;logicalWidth() - last-&gt;borderLogicalRight();
3337     } else {
3338         fromRight = first-&gt;logicalLeft() + first-&gt;logicalWidth() - first-&gt;borderLogicalRight();
3339         fromLeft = last-&gt;logicalLeft() + last-&gt;borderLogicalLeft();
3340     }
3341 
3342     return std::max&lt;LayoutUnit&gt;(0, fromRight - fromLeft);
3343 }
3344 
3345 LayoutUnit RenderBox::containingBlockLogicalHeightForPositioned(const RenderBoxModelObject&amp; containingBlock, bool checkForPerpendicularWritingMode) const
3346 {
3347     if (checkForPerpendicularWritingMode &amp;&amp; containingBlock.isHorizontalWritingMode() != isHorizontalWritingMode())
3348         return containingBlockLogicalWidthForPositioned(containingBlock, nullptr, false);
3349 
3350     if (hasOverrideContainingBlockContentLogicalHeight()) {
3351         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
3352             return overrideLogicalHeight.value();
3353     }
3354 
3355     if (containingBlock.isBox()) {
3356         bool isFixedPosition = isFixedPositioned();
3357 
3358         if (isFixedPosition &amp;&amp; is&lt;RenderView&gt;(containingBlock))
3359             return downcast&lt;RenderView&gt;(containingBlock).clientLogicalHeightForFixedPosition();
3360 
3361         const RenderBlock&amp; cb = is&lt;RenderBlock&gt;(containingBlock) ? downcast&lt;RenderBlock&gt;(containingBlock) : *containingBlock.containingBlock();
3362         LayoutUnit result = cb.clientLogicalHeight();
3363         RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3364         if (fragmentedFlow &amp;&amp; is&lt;RenderFragmentedFlow&gt;(containingBlock) &amp;&amp; fragmentedFlow-&gt;isHorizontalWritingMode() == containingBlock.isHorizontalWritingMode())
3365             return downcast&lt;RenderFragmentedFlow&gt;(containingBlock).contentLogicalHeightOfFirstFragment();
3366         return result;
3367     }
3368 
3369     ASSERT(containingBlock.isInFlowPositioned());
3370 
3371     const auto&amp; flow = downcast&lt;RenderInline&gt;(containingBlock);
3372     InlineFlowBox* first = flow.firstLineBox();
3373     InlineFlowBox* last = flow.lastLineBox();
3374 
3375     // If the containing block is empty, return a height of 0.
3376     if (!first || !last)
3377         return 0;
3378 
3379     LayoutUnit heightResult;
3380     LayoutRect boundingBox = flow.linesBoundingBox();
3381     if (containingBlock.isHorizontalWritingMode())
3382         heightResult = boundingBox.height();
3383     else
3384         heightResult = boundingBox.width();
3385     heightResult -= (containingBlock.borderBefore() + containingBlock.borderAfter());
3386     return heightResult;
3387 }
3388 
3389 static void computeInlineStaticDistance(Length&amp; logicalLeft, Length&amp; logicalRight, const RenderBox* child, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalWidth, RenderFragmentContainer* fragment)
3390 {
3391     if (!logicalLeft.isAuto() || !logicalRight.isAuto())
3392         return;
3393 
3394     RenderObject* parent = child-&gt;parent();
3395     TextDirection parentDirection = parent-&gt;style().direction();
3396 
3397     // This method is using enclosingBox() which is wrong for absolutely
3398     // positioned grid items, as they rely on the grid area. So for grid items if
3399     // both &quot;left&quot; and &quot;right&quot; properties are &quot;auto&quot;, we can consider that one of
3400     // them (depending on the direction) is simply &quot;0&quot;.
3401     if (parent-&gt;isRenderGrid() &amp;&amp; parent == child-&gt;containingBlock()) {
3402         if (parentDirection == TextDirection::LTR)
3403             logicalLeft.setValue(Fixed, 0);
3404         else
3405             logicalRight.setValue(Fixed, 0);
3406         return;
3407     }
3408 
3409     // FIXME: The static distance computation has not been patched for mixed writing modes yet.
3410     if (parentDirection == TextDirection::LTR) {
3411         LayoutUnit staticPosition = child-&gt;layer()-&gt;staticInlinePosition() - containerBlock.borderLogicalLeft();
3412         for (auto* current = parent; current &amp;&amp; current != &amp;containerBlock; current = current-&gt;container()) {
3413             if (!is&lt;RenderBox&gt;(*current))
3414                 continue;
3415             const auto&amp; renderBox = downcast&lt;RenderBox&gt;(*current);
3416             staticPosition += renderBox.logicalLeft();
3417             if (renderBox.isInFlowPositioned())
3418                 staticPosition += renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().width() : renderBox.offsetForInFlowPosition().height();
3419             if (fragment &amp;&amp; is&lt;RenderBlock&gt;(*current)) {
3420                 const RenderBlock&amp; currentBlock = downcast&lt;RenderBlock&gt;(*current);
3421                 fragment = currentBlock.clampToStartAndEndFragments(fragment);
3422                 RenderBoxFragmentInfo* boxInfo = currentBlock.renderBoxFragmentInfo(fragment);
3423                 if (boxInfo)
3424                     staticPosition += boxInfo-&gt;logicalLeft();
3425             }
3426         }
3427         logicalLeft.setValue(Fixed, staticPosition);
3428     } else {
3429         LayoutUnit staticPosition = child-&gt;layer()-&gt;staticInlinePosition() + containerLogicalWidth + containerBlock.borderLogicalLeft();
3430         auto&amp; enclosingBox = parent-&gt;enclosingBox();
3431         if (&amp;enclosingBox != &amp;containerBlock &amp;&amp; containerBlock.isDescendantOf(&amp;enclosingBox)) {
3432             logicalRight.setValue(Fixed, staticPosition);
3433             return;
3434         }
3435 
3436         staticPosition -= enclosingBox.logicalWidth();
3437         for (const RenderElement* current = &amp;enclosingBox; current; current = current-&gt;container()) {
3438             if (!is&lt;RenderBox&gt;(*current))
3439                 continue;
3440 
3441             if (current != &amp;containerBlock) {
3442                 auto&amp; renderBox = downcast&lt;RenderBox&gt;(*current);
3443                 staticPosition -= renderBox.logicalLeft();
3444                 if (renderBox.isInFlowPositioned())
3445                     staticPosition -= renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().width() : renderBox.offsetForInFlowPosition().height();
3446             }
3447             if (fragment &amp;&amp; is&lt;RenderBlock&gt;(*current)) {
3448                 auto&amp; currentBlock = downcast&lt;RenderBlock&gt;(*current);
3449                 fragment = currentBlock.clampToStartAndEndFragments(fragment);
3450                 RenderBoxFragmentInfo* boxInfo = currentBlock.renderBoxFragmentInfo(fragment);
3451                 if (boxInfo) {
3452                     if (current != &amp;containerBlock)
3453                         staticPosition -= currentBlock.logicalWidth() - (boxInfo-&gt;logicalLeft() + boxInfo-&gt;logicalWidth());
3454                     if (current == &amp;enclosingBox)
3455                         staticPosition += enclosingBox.logicalWidth() - boxInfo-&gt;logicalWidth();
3456                 }
3457             }
3458             if (current == &amp;containerBlock)
3459                 break;
3460         }
3461         logicalRight.setValue(Fixed, staticPosition);
3462     }
3463 }
3464 
3465 void RenderBox::computePositionedLogicalWidth(LogicalExtentComputedValues&amp; computedValues, RenderFragmentContainer* fragment) const
3466 {
3467     if (isReplaced()) {
3468         // FIXME: Positioned replaced elements inside a flow thread are not working properly
3469         // with variable width fragments (see https://bugs.webkit.org/show_bug.cgi?id=69896 ).
3470         computePositionedLogicalWidthReplaced(computedValues);
3471         return;
3472     }
3473 
3474     // QUESTIONS
3475     // FIXME 1: Should we still deal with these the cases of &#39;left&#39; or &#39;right&#39; having
3476     // the type &#39;static&#39; in determining whether to calculate the static distance?
3477     // NOTE: &#39;static&#39; is not a legal value for &#39;left&#39; or &#39;right&#39; as of CSS 2.1.
3478 
3479     // FIXME 2: Can perhaps optimize out cases when max-width/min-width are greater
3480     // than or less than the computed width().  Be careful of box-sizing and
3481     // percentage issues.
3482 
3483     // The following is based off of the W3C Working Draft from April 11, 2006 of
3484     // CSS 2.1: Section 10.3.7 &quot;Absolutely positioned, non-replaced elements&quot;
3485     // &lt;http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width&gt;
3486     // (block-style-comments in this function and in computePositionedLogicalWidthUsing()
3487     // correspond to text from the spec)
3488 
3489 
3490     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing
3491     // relative positioned inline.
3492     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
3493 
3494     const LayoutUnit containerLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, fragment);
3495 
3496     // Use the container block&#39;s direction except when calculating the static distance
3497     // This conforms with the reference results for abspos-replaced-width-margin-000.htm
3498     // of the CSS 2.1 test suite
3499     TextDirection containerDirection = containerBlock.style().direction();
3500 
3501     bool isHorizontal = isHorizontalWritingMode();
3502     const LayoutUnit bordersPlusPadding = borderAndPaddingLogicalWidth();
3503     const Length marginLogicalLeft = isHorizontal ? style().marginLeft() : style().marginTop();
3504     const Length marginLogicalRight = isHorizontal ? style().marginRight() : style().marginBottom();
3505 
3506     Length logicalLeftLength = style().logicalLeft();
3507     Length logicalRightLength = style().logicalRight();
3508 
3509     /*---------------------------------------------------------------------------*\
3510      * For the purposes of this section and the next, the term &quot;static position&quot;
3511      * (of an element) refers, roughly, to the position an element would have had
3512      * in the normal flow. More precisely:
3513      *
3514      * * The static position for &#39;left&#39; is the distance from the left edge of the
3515      *   containing block to the left margin edge of a hypothetical box that would
3516      *   have been the first box of the element if its &#39;position&#39; property had
3517      *   been &#39;static&#39; and &#39;float&#39; had been &#39;none&#39;. The value is negative if the
3518      *   hypothetical box is to the left of the containing block.
3519      * * The static position for &#39;right&#39; is the distance from the right edge of the
3520      *   containing block to the right margin edge of the same hypothetical box as
3521      *   above. The value is positive if the hypothetical box is to the left of the
3522      *   containing block&#39;s edge.
3523      *
3524      * But rather than actually calculating the dimensions of that hypothetical box,
3525      * user agents are free to make a guess at its probable position.
3526      *
3527      * For the purposes of calculating the static position, the containing block of
3528      * fixed positioned elements is the initial containing block instead of the
3529      * viewport, and all scrollable boxes should be assumed to be scrolled to their
3530      * origin.
3531     \*---------------------------------------------------------------------------*/
3532 
3533     // see FIXME 1
3534     // Calculate the static distance if needed.
3535     computeInlineStaticDistance(logicalLeftLength, logicalRightLength, this, containerBlock, containerLogicalWidth, fragment);
3536 
3537     // Calculate constraint equation values for &#39;width&#39; case.
3538     computePositionedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth(), containerBlock, containerDirection,
3539                                        containerLogicalWidth, bordersPlusPadding,
3540                                        logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3541                                        computedValues);
3542 
3543     // Calculate constraint equation values for &#39;max-width&#39; case.
3544     if (!style().logicalMaxWidth().isUndefined()) {
3545         LogicalExtentComputedValues maxValues;
3546 
3547         computePositionedLogicalWidthUsing(MaxSize, style().logicalMaxWidth(), containerBlock, containerDirection,
3548                                            containerLogicalWidth, bordersPlusPadding,
3549                                            logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3550                                            maxValues);
3551 
3552         if (computedValues.m_extent &gt; maxValues.m_extent) {
3553             computedValues.m_extent = maxValues.m_extent;
3554             computedValues.m_position = maxValues.m_position;
3555             computedValues.m_margins.m_start = maxValues.m_margins.m_start;
3556             computedValues.m_margins.m_end = maxValues.m_margins.m_end;
3557         }
3558     }
3559 
3560     // Calculate constraint equation values for &#39;min-width&#39; case.
3561     if (!style().logicalMinWidth().isZero() || style().logicalMinWidth().isIntrinsic()) {
3562         LogicalExtentComputedValues minValues;
3563 
3564         computePositionedLogicalWidthUsing(MinSize, style().logicalMinWidth(), containerBlock, containerDirection,
3565                                            containerLogicalWidth, bordersPlusPadding,
3566                                            logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3567                                            minValues);
3568 
3569         if (computedValues.m_extent &lt; minValues.m_extent) {
3570             computedValues.m_extent = minValues.m_extent;
3571             computedValues.m_position = minValues.m_position;
3572             computedValues.m_margins.m_start = minValues.m_margins.m_start;
3573             computedValues.m_margins.m_end = minValues.m_margins.m_end;
3574         }
3575     }
3576 
3577     computedValues.m_extent += bordersPlusPadding;
3578     if (is&lt;RenderBox&gt;(containerBlock)) {
3579         auto&amp; containingBox = downcast&lt;RenderBox&gt;(containerBlock);
3580         if (containingBox.shouldPlaceBlockDirectionScrollbarOnLeft())
3581             computedValues.m_position += containingBox.verticalScrollbarWidth();
3582     }
3583 
3584     // Adjust logicalLeft if we need to for the flipped version of our writing mode in fragments.
3585     // FIXME: Add support for other types of objects as containerBlock, not only RenderBlock.
3586     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3587     if (fragmentedFlow &amp;&amp; !fragment &amp;&amp; isWritingModeRoot() &amp;&amp; isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode() &amp;&amp; is&lt;RenderBlock&gt;(containerBlock)) {
3588         ASSERT(containerBlock.canHaveBoxInfoInFragment());
3589         LayoutUnit logicalLeftPos = computedValues.m_position;
3590         const RenderBlock&amp; renderBlock = downcast&lt;RenderBlock&gt;(containerBlock);
3591         LayoutUnit cbPageOffset = renderBlock.offsetFromLogicalTopOfFirstPage();
3592         RenderFragmentContainer* cbFragment = renderBlock.fragmentAtBlockOffset(cbPageOffset);
3593         if (cbFragment) {
3594             RenderBoxFragmentInfo* boxInfo = renderBlock.renderBoxFragmentInfo(cbFragment);
3595             if (boxInfo) {
3596                 logicalLeftPos += boxInfo-&gt;logicalLeft();
3597                 computedValues.m_position = logicalLeftPos;
3598             }
3599         }
3600     }
3601 }
3602 
3603 static void computeLogicalLeftPositionedOffset(LayoutUnit&amp; logicalLeftPos, const RenderBox* child, LayoutUnit logicalWidthValue, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalWidth)
3604 {
3605     // Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space. If the containing block is flipped
3606     // along this axis, then we need to flip the coordinate.  This can only happen if the containing block is both a flipped mode and perpendicular to us.
3607     if (containerBlock.isHorizontalWritingMode() != child-&gt;isHorizontalWritingMode() &amp;&amp; containerBlock.style().isFlippedBlocksWritingMode()) {
3608         logicalLeftPos = containerLogicalWidth - logicalWidthValue - logicalLeftPos;
3609         logicalLeftPos += (child-&gt;isHorizontalWritingMode() ? containerBlock.borderRight() : containerBlock.borderBottom());
3610     } else
3611         logicalLeftPos += (child-&gt;isHorizontalWritingMode() ? containerBlock.borderLeft() : containerBlock.borderTop());
3612 }
3613 
3614 void RenderBox::computePositionedLogicalWidthUsing(SizeType widthType, Length logicalWidth, const RenderBoxModelObject&amp; containerBlock, TextDirection containerDirection,
3615                                                    LayoutUnit containerLogicalWidth, LayoutUnit bordersPlusPadding,
3616                                                    Length logicalLeft, Length logicalRight, Length marginLogicalLeft, Length marginLogicalRight,
3617                                                    LogicalExtentComputedValues&amp; computedValues) const
3618 {
3619     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
3620     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
3621         logicalWidth = Length(0, Fixed);
3622     else if (logicalWidth.isIntrinsic())
3623         logicalWidth = Length(computeIntrinsicLogicalWidthUsing(logicalWidth, containerLogicalWidth, bordersPlusPadding) - bordersPlusPadding, Fixed);
3624 
3625     // &#39;left&#39; and &#39;right&#39; cannot both be &#39;auto&#39; because one would of been
3626     // converted to the static position already
3627     ASSERT(!(logicalLeft.isAuto() &amp;&amp; logicalRight.isAuto()));
3628 
3629     LayoutUnit logicalLeftValue;
3630 
3631     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
3632 
3633     bool logicalWidthIsAuto = logicalWidth.isIntrinsicOrAuto();
3634     bool logicalLeftIsAuto = logicalLeft.isAuto();
3635     bool logicalRightIsAuto = logicalRight.isAuto();
3636     LayoutUnit&amp; marginLogicalLeftValue = style().isLeftToRightDirection() ? computedValues.m_margins.m_start : computedValues.m_margins.m_end;
3637     LayoutUnit&amp; marginLogicalRightValue = style().isLeftToRightDirection() ? computedValues.m_margins.m_end : computedValues.m_margins.m_start;
3638 
3639     if (!logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3640         /*-----------------------------------------------------------------------*\
3641          * If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-
3642          * right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that
3643          * the two margins get equal values, unless this would make them negative,
3644          * in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;),
3645          * set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and solve for &#39;margin-right&#39;
3646          * (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;,
3647          * solve the equation for that value. If the values are over-constrained,
3648          * ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the
3649          * containing block is &#39;rtl&#39;) or &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;)
3650          * and solve for that value.
3651         \*-----------------------------------------------------------------------*/
3652         // NOTE:  It is not necessary to solve for &#39;right&#39; in the over constrained
3653         // case because the value is not used for any further calculations.
3654 
3655         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3656         computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3657 
3658         const LayoutUnit availableSpace = containerLogicalWidth - (logicalLeftValue + computedValues.m_extent + valueForLength(logicalRight, containerLogicalWidth) + bordersPlusPadding);
3659 
3660         // Margins are now the only unknown
3661         if (marginLogicalLeft.isAuto() &amp;&amp; marginLogicalRight.isAuto()) {
3662             // Both margins auto, solve for equality
3663             if (availableSpace &gt;= 0) {
3664                 marginLogicalLeftValue = availableSpace / 2; // split the difference
3665                 marginLogicalRightValue = availableSpace - marginLogicalLeftValue; // account for odd valued differences
3666             } else {
3667                 // Use the containing block&#39;s direction rather than the parent block&#39;s
3668                 // per CSS 2.1 reference test abspos-non-replaced-width-margin-000.
3669                 if (containerDirection == TextDirection::LTR) {
3670                     marginLogicalLeftValue = 0;
3671                     marginLogicalRightValue = availableSpace; // will be negative
3672                 } else {
3673                     marginLogicalLeftValue = availableSpace; // will be negative
3674                     marginLogicalRightValue = 0;
3675                 }
3676             }
3677         } else if (marginLogicalLeft.isAuto()) {
3678             // Solve for left margin
3679             marginLogicalRightValue = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3680             marginLogicalLeftValue = availableSpace - marginLogicalRightValue;
3681         } else if (marginLogicalRight.isAuto()) {
3682             // Solve for right margin
3683             marginLogicalLeftValue = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3684             marginLogicalRightValue = availableSpace - marginLogicalLeftValue;
3685         } else {
3686             // Over-constrained, solve for left if direction is RTL
3687             marginLogicalLeftValue = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3688             marginLogicalRightValue = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3689 
3690             // Use the containing block&#39;s direction rather than the parent block&#39;s
3691             // per CSS 2.1 reference test abspos-non-replaced-width-margin-000.
3692             if (containerDirection == TextDirection::RTL)
3693                 logicalLeftValue = (availableSpace + logicalLeftValue) - marginLogicalLeftValue - marginLogicalRightValue;
3694         }
3695     } else {
3696         /*--------------------------------------------------------------------*\
3697          * Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39;
3698          * to 0, and pick the one of the following six rules that applies.
3699          *
3700          * 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the
3701          *    width is shrink-to-fit. Then solve for &#39;left&#39;
3702          *
3703          *              OMIT RULE 2 AS IT SHOULD NEVER BE HIT
3704          * ------------------------------------------------------------------
3705          * 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if
3706          *    the &#39;direction&#39; property of the containing block is &#39;ltr&#39; set
3707          *    &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the
3708          *    static position. Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;)
3709          *    or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
3710          * ------------------------------------------------------------------
3711          *
3712          * 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the
3713          *    width is shrink-to-fit . Then solve for &#39;right&#39;
3714          * 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve
3715          *    for &#39;left&#39;
3716          * 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve
3717          *    for &#39;width&#39;
3718          * 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve
3719          *    for &#39;right&#39;
3720          *
3721          * Calculation of the shrink-to-fit width is similar to calculating the
3722          * width of a table cell using the automatic table layout algorithm.
3723          * Roughly: calculate the preferred width by formatting the content
3724          * without breaking lines other than where explicit line breaks occur,
3725          * and also calculate the preferred minimum width, e.g., by trying all
3726          * possible line breaks. CSS 2.1 does not define the exact algorithm.
3727          * Thirdly, calculate the available width: this is found by solving
3728          * for &#39;width&#39; after setting &#39;left&#39; (in case 1) or &#39;right&#39; (in case 3)
3729          * to 0.
3730          *
3731          * Then the shrink-to-fit width is:
3732          * min(max(preferred minimum width, available width), preferred width).
3733         \*--------------------------------------------------------------------*/
3734         // NOTE: For rules 3 and 6 it is not necessary to solve for &#39;right&#39;
3735         // because the value is not used for any further calculations.
3736 
3737         // Calculate margins, &#39;auto&#39; margins are ignored.
3738         marginLogicalLeftValue = minimumValueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3739         marginLogicalRightValue = minimumValueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3740 
3741         const LayoutUnit availableSpace = containerLogicalWidth - (marginLogicalLeftValue + marginLogicalRightValue + bordersPlusPadding);
3742 
3743         // FIXME: Is there a faster way to find the correct case?
3744         // Use rule/case that applies.
3745         if (logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3746             // RULE 1: (use shrink-to-fit for width, and solve of left)
3747             LayoutUnit logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
3748 
3749             // FIXME: would it be better to have shrink-to-fit in one step?
3750             LayoutUnit preferredWidth = maxPreferredLogicalWidth() - bordersPlusPadding;
3751             LayoutUnit preferredMinWidth = minPreferredLogicalWidth() - bordersPlusPadding;
3752             LayoutUnit availableWidth = availableSpace - logicalRightValue;
3753             computedValues.m_extent = std::min(std::max(preferredMinWidth, availableWidth), preferredWidth);
3754             logicalLeftValue = availableSpace - (computedValues.m_extent + logicalRightValue);
3755         } else if (!logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; logicalRightIsAuto) {
3756             // RULE 3: (use shrink-to-fit for width, and no need solve of right)
3757             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3758 
3759             // FIXME: would it be better to have shrink-to-fit in one step?
3760             LayoutUnit preferredWidth = maxPreferredLogicalWidth() - bordersPlusPadding;
3761             LayoutUnit preferredMinWidth = minPreferredLogicalWidth() - bordersPlusPadding;
3762             LayoutUnit availableWidth = availableSpace - logicalLeftValue;
3763             computedValues.m_extent = std::min(std::max(preferredMinWidth, availableWidth), preferredWidth);
3764         } else if (logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3765             // RULE 4: (solve for left)
3766             computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3767             logicalLeftValue = availableSpace - (computedValues.m_extent + valueForLength(logicalRight, containerLogicalWidth));
3768         } else if (!logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3769             // RULE 5: (solve for width)
3770             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3771             computedValues.m_extent = availableSpace - (logicalLeftValue + valueForLength(logicalRight, containerLogicalWidth));
3772         } else if (!logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; logicalRightIsAuto) {
3773             // RULE 6: (no need solve for right)
3774             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3775             computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3776         }
3777     }
3778 
3779     // Use computed values to calculate the horizontal position.
3780 
3781     // FIXME: This hack is needed to calculate the  logical left position for a &#39;rtl&#39; relatively
3782     // positioned, inline because right now, it is using the logical left position
3783     // of the first line box when really it should use the last line box.  When
3784     // this is fixed elsewhere, this block should be removed.
3785     if (is&lt;RenderInline&gt;(containerBlock) &amp;&amp; !containerBlock.style().isLeftToRightDirection()) {
3786         const auto&amp; flow = downcast&lt;RenderInline&gt;(containerBlock);
3787         InlineFlowBox* firstLine = flow.firstLineBox();
3788         InlineFlowBox* lastLine = flow.lastLineBox();
3789         if (firstLine &amp;&amp; lastLine &amp;&amp; firstLine != lastLine) {
3790             computedValues.m_position = logicalLeftValue + marginLogicalLeftValue + lastLine-&gt;borderLogicalLeft() + (lastLine-&gt;logicalLeft() - firstLine-&gt;logicalLeft());
3791             return;
3792         }
3793     }
3794 
3795     computedValues.m_position = logicalLeftValue + marginLogicalLeftValue;
3796     computeLogicalLeftPositionedOffset(computedValues.m_position, this, computedValues.m_extent, containerBlock, containerLogicalWidth);
3797 }
3798 
3799 static void computeBlockStaticDistance(Length&amp; logicalTop, Length&amp; logicalBottom, const RenderBox* child, const RenderBoxModelObject&amp; containerBlock)
3800 {
3801     if (!logicalTop.isAuto() || !logicalBottom.isAuto())
3802         return;
3803 
3804     // FIXME: The static distance computation has not been patched for mixed writing modes.
3805     LayoutUnit staticLogicalTop = child-&gt;layer()-&gt;staticBlockPosition() - containerBlock.borderBefore();
3806     for (RenderElement* container = child-&gt;parent(); container &amp;&amp; container != &amp;containerBlock; container = container-&gt;container()) {
3807         if (!is&lt;RenderBox&gt;(*container))
3808             continue;
3809         const auto&amp; renderBox = downcast&lt;RenderBox&gt;(*container);
3810         if (!is&lt;RenderTableRow&gt;(renderBox))
3811             staticLogicalTop += renderBox.logicalTop();
3812         if (renderBox.isInFlowPositioned())
3813             staticLogicalTop += renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().height() : renderBox.offsetForInFlowPosition().width();
3814     }
3815     logicalTop.setValue(Fixed, staticLogicalTop);
3816 }
3817 
3818 void RenderBox::computePositionedLogicalHeight(LogicalExtentComputedValues&amp; computedValues) const
3819 {
3820     if (isReplaced()) {
3821         computePositionedLogicalHeightReplaced(computedValues);
3822         return;
3823     }
3824 
3825     // The following is based off of the W3C Working Draft from April 11, 2006 of
3826     // CSS 2.1: Section 10.6.4 &quot;Absolutely positioned, non-replaced elements&quot;
3827     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-non-replaced-height&gt;
3828     // (block-style-comments in this function and in computePositionedLogicalHeightUsing()
3829     // correspond to text from the spec)
3830 
3831 
3832     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing relpositioned inline.
3833     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
3834 
3835     const LayoutUnit containerLogicalHeight = containingBlockLogicalHeightForPositioned(containerBlock);
3836 
3837     const RenderStyle&amp; styleToUse = style();
3838     const LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
3839     const Length marginBefore = styleToUse.marginBefore();
3840     const Length marginAfter = styleToUse.marginAfter();
3841     Length logicalTopLength = styleToUse.logicalTop();
3842     Length logicalBottomLength = styleToUse.logicalBottom();
3843 
3844     /*---------------------------------------------------------------------------*\
3845      * For the purposes of this section and the next, the term &quot;static position&quot;
3846      * (of an element) refers, roughly, to the position an element would have had
3847      * in the normal flow. More precisely, the static position for &#39;top&#39; is the
3848      * distance from the top edge of the containing block to the top margin edge
3849      * of a hypothetical box that would have been the first box of the element if
3850      * its &#39;position&#39; property had been &#39;static&#39; and &#39;float&#39; had been &#39;none&#39;. The
3851      * value is negative if the hypothetical box is above the containing block.
3852      *
3853      * But rather than actually calculating the dimensions of that hypothetical
3854      * box, user agents are free to make a guess at its probable position.
3855      *
3856      * For the purposes of calculating the static position, the containing block
3857      * of fixed positioned elements is the initial containing block instead of
3858      * the viewport.
3859     \*---------------------------------------------------------------------------*/
3860 
3861     // see FIXME 1
3862     // Calculate the static distance if needed.
3863     computeBlockStaticDistance(logicalTopLength, logicalBottomLength, this, containerBlock);
3864 
3865     // Calculate constraint equation values for &#39;height&#39; case.
3866     LayoutUnit logicalHeight = computedValues.m_extent;
3867     computePositionedLogicalHeightUsing(MainOrPreferredSize, styleToUse.logicalHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3868                                         logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3869                                         computedValues);
3870 
3871     // Avoid doing any work in the common case (where the values of min-height and max-height are their defaults).
3872     // see FIXME 2
3873 
3874     // Calculate constraint equation values for &#39;max-height&#39; case.
3875     if (!styleToUse.logicalMaxHeight().isUndefined()) {
3876         LogicalExtentComputedValues maxValues;
3877 
3878         computePositionedLogicalHeightUsing(MaxSize, styleToUse.logicalMaxHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3879                                             logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3880                                             maxValues);
3881 
3882         if (computedValues.m_extent &gt; maxValues.m_extent) {
3883             computedValues.m_extent = maxValues.m_extent;
3884             computedValues.m_position = maxValues.m_position;
3885             computedValues.m_margins.m_before = maxValues.m_margins.m_before;
3886             computedValues.m_margins.m_after = maxValues.m_margins.m_after;
3887         }
3888     }
3889 
3890     // Calculate constraint equation values for &#39;min-height&#39; case.
3891     if (!styleToUse.logicalMinHeight().isZero() || styleToUse.logicalMinHeight().isIntrinsic()) {
3892         LogicalExtentComputedValues minValues;
3893 
3894         computePositionedLogicalHeightUsing(MinSize, styleToUse.logicalMinHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3895                                             logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3896                                             minValues);
3897 
3898         if (computedValues.m_extent &lt; minValues.m_extent) {
3899             computedValues.m_extent = minValues.m_extent;
3900             computedValues.m_position = minValues.m_position;
3901             computedValues.m_margins.m_before = minValues.m_margins.m_before;
3902             computedValues.m_margins.m_after = minValues.m_margins.m_after;
3903         }
3904     }
3905 
3906     // Set final height value.
3907     computedValues.m_extent += bordersPlusPadding;
3908 
3909     // Adjust logicalTop if we need to for perpendicular writing modes in fragments.
3910     // FIXME: Add support for other types of objects as containerBlock, not only RenderBlock.
3911     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3912     if (fragmentedFlow &amp;&amp; isHorizontalWritingMode() != containerBlock.isHorizontalWritingMode() &amp;&amp; is&lt;RenderBlock&gt;(containerBlock)) {
3913         ASSERT(containerBlock.canHaveBoxInfoInFragment());
3914         LayoutUnit logicalTopPos = computedValues.m_position;
3915         const RenderBlock&amp; renderBox = downcast&lt;RenderBlock&gt;(containerBlock);
3916         LayoutUnit cbPageOffset = renderBox.offsetFromLogicalTopOfFirstPage() - logicalLeft();
3917         RenderFragmentContainer* cbFragment = renderBox.fragmentAtBlockOffset(cbPageOffset);
3918         if (cbFragment) {
3919             RenderBoxFragmentInfo* boxInfo = renderBox.renderBoxFragmentInfo(cbFragment);
3920             if (boxInfo) {
3921                 logicalTopPos += boxInfo-&gt;logicalLeft();
3922                 computedValues.m_position = logicalTopPos;
3923             }
3924         }
3925     }
3926 }
3927 
3928 static void computeLogicalTopPositionedOffset(LayoutUnit&amp; logicalTopPos, const RenderBox* child, LayoutUnit logicalHeightValue, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalHeight)
3929 {
3930     // Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space. If the containing block is flipped
3931     // along this axis, then we need to flip the coordinate.  This can only happen if the containing block is both a flipped mode and perpendicular to us.
3932     if ((child-&gt;style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() != containerBlock.isHorizontalWritingMode())
3933         || (child-&gt;style().isFlippedBlocksWritingMode() != containerBlock.style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode()))
3934         logicalTopPos = containerLogicalHeight - logicalHeightValue - logicalTopPos;
3935 
3936     // Our offset is from the logical bottom edge in a flipped environment, e.g., right for vertical-rl and bottom for horizontal-bt.
3937     if (containerBlock.style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode()) {
3938         if (child-&gt;isHorizontalWritingMode())
3939             logicalTopPos += containerBlock.borderBottom();
3940         else
3941             logicalTopPos += containerBlock.borderRight();
3942     } else {
3943         if (child-&gt;isHorizontalWritingMode())
3944             logicalTopPos += containerBlock.borderTop();
3945         else
3946             logicalTopPos += containerBlock.borderLeft();
3947     }
3948 }
3949 
3950 void RenderBox::computePositionedLogicalHeightUsing(SizeType heightType, Length logicalHeightLength, const RenderBoxModelObject&amp; containerBlock,
3951                                                     LayoutUnit containerLogicalHeight, LayoutUnit bordersPlusPadding, LayoutUnit logicalHeight,
3952                                                     Length logicalTop, Length logicalBottom, Length marginBefore, Length marginAfter,
3953                                                     LogicalExtentComputedValues&amp; computedValues) const
3954 {
3955     ASSERT(heightType == MinSize || heightType == MainOrPreferredSize || !logicalHeightLength.isAuto());
3956     if (heightType == MinSize &amp;&amp; logicalHeightLength.isAuto())
3957         logicalHeightLength = Length(0, Fixed);
3958 
3959     // &#39;top&#39; and &#39;bottom&#39; cannot both be &#39;auto&#39; because &#39;top would of been
3960     // converted to the static position in computePositionedLogicalHeight()
3961     ASSERT(!(logicalTop.isAuto() &amp;&amp; logicalBottom.isAuto()));
3962 
3963     LayoutUnit logicalHeightValue;
3964     LayoutUnit contentLogicalHeight = logicalHeight - bordersPlusPadding;
3965 
3966     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
3967 
3968     LayoutUnit logicalTopValue;
3969 
3970     bool logicalHeightIsAuto = logicalHeightLength.isAuto();
3971     bool logicalTopIsAuto = logicalTop.isAuto();
3972     bool logicalBottomIsAuto = logicalBottom.isAuto();
3973 
3974     // Height is never unsolved for tables.
3975     LayoutUnit resolvedLogicalHeight;
3976     if (isTable()) {
3977         resolvedLogicalHeight = contentLogicalHeight;
3978         logicalHeightIsAuto = false;
3979     } else {
3980         if (logicalHeightLength.isIntrinsic())
3981             resolvedLogicalHeight = computeIntrinsicLogicalContentHeightUsing(logicalHeightLength, contentLogicalHeight, bordersPlusPadding).value();
3982         else
3983             resolvedLogicalHeight = adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeightLength, containerLogicalHeight));
3984     }
3985 
3986     if (!logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
3987         /*-----------------------------------------------------------------------*\
3988          * If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-
3989          * bottom&#39; are &#39;auto&#39;, solve the equation under the extra constraint that
3990          * the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-
3991          * bottom&#39; is &#39;auto&#39;, solve the equation for that value. If the values
3992          * are over-constrained, ignore the value for &#39;bottom&#39; and solve for that
3993          * value.
3994         \*-----------------------------------------------------------------------*/
3995         // NOTE:  It is not necessary to solve for &#39;bottom&#39; in the over constrained
3996         // case because the value is not used for any further calculations.
3997 
3998         logicalHeightValue = resolvedLogicalHeight;
3999         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4000 
4001         const LayoutUnit availableSpace = containerLogicalHeight - (logicalTopValue + logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight) + bordersPlusPadding);
4002 
4003         // Margins are now the only unknown
4004         if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
4005             // Both margins auto, solve for equality
4006             // NOTE: This may result in negative values.
4007             computedValues.m_margins.m_before = availableSpace / 2; // split the difference
4008             computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before; // account for odd valued differences
4009         } else if (marginBefore.isAuto()) {
4010             // Solve for top margin
4011             computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);
4012             computedValues.m_margins.m_before = availableSpace - computedValues.m_margins.m_after;
4013         } else if (marginAfter.isAuto()) {
4014             // Solve for bottom margin
4015             computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);
4016             computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before;
4017         } else {
4018             // Over-constrained, (no need solve for bottom)
4019             computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);
4020             computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);
4021         }
4022     } else {
4023         /*--------------------------------------------------------------------*\
4024          * Otherwise, set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39;
4025          * to 0, and pick the one of the following six rules that applies.
4026          *
4027          * 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then
4028          *    the height is based on the content, and solve for &#39;top&#39;.
4029          *
4030          *              OMIT RULE 2 AS IT SHOULD NEVER BE HIT
4031          * ------------------------------------------------------------------
4032          * 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then
4033          *    set &#39;top&#39; to the static position, and solve for &#39;bottom&#39;.
4034          * ------------------------------------------------------------------
4035          *
4036          * 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then
4037          *    the height is based on the content, and solve for &#39;bottom&#39;.
4038          * 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, and
4039          *    solve for &#39;top&#39;.
4040          * 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, and
4041          *    solve for &#39;height&#39;.
4042          * 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, and
4043          *    solve for &#39;bottom&#39;.
4044         \*--------------------------------------------------------------------*/
4045         // NOTE: For rules 3 and 6 it is not necessary to solve for &#39;bottom&#39;
4046         // because the value is not used for any further calculations.
4047 
4048         // Calculate margins, &#39;auto&#39; margins are ignored.
4049         computedValues.m_margins.m_before = minimumValueForLength(marginBefore, containerRelativeLogicalWidth);
4050         computedValues.m_margins.m_after = minimumValueForLength(marginAfter, containerRelativeLogicalWidth);
4051 
4052         const LayoutUnit availableSpace = containerLogicalHeight - (computedValues.m_margins.m_before + computedValues.m_margins.m_after + bordersPlusPadding);
4053 
4054         // Use rule/case that applies.
4055         if (logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4056             // RULE 1: (height is content based, solve of top)
4057             logicalHeightValue = contentLogicalHeight;
4058             logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));
4059         } else if (!logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; logicalBottomIsAuto) {
4060             // RULE 3: (height is content based, no need solve of bottom)
4061             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4062             logicalHeightValue = contentLogicalHeight;
4063         } else if (logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4064             // RULE 4: (solve of top)
4065             logicalHeightValue = resolvedLogicalHeight;
4066             logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));
4067         } else if (!logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4068             // RULE 5: (solve of height)
4069             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4070             logicalHeightValue = std::max&lt;LayoutUnit&gt;(0, availableSpace - (logicalTopValue + valueForLength(logicalBottom, containerLogicalHeight)));
4071         } else if (!logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; logicalBottomIsAuto) {
4072             // RULE 6: (no need solve of bottom)
4073             logicalHeightValue = resolvedLogicalHeight;
4074             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4075         }
4076     }
4077     computedValues.m_extent = logicalHeightValue;
4078 
4079     // Use computed values to calculate the vertical position.
4080     computedValues.m_position = logicalTopValue + computedValues.m_margins.m_before;
4081     computeLogicalTopPositionedOffset(computedValues.m_position, this, logicalHeightValue, containerBlock, containerLogicalHeight);
4082 }
4083 
4084 void RenderBox::computePositionedLogicalWidthReplaced(LogicalExtentComputedValues&amp; computedValues) const
4085 {
4086     // The following is based off of the W3C Working Draft from April 11, 2006 of
4087     // CSS 2.1: Section 10.3.8 &quot;Absolutely positioned, replaced elements&quot;
4088     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-replaced-width&gt;
4089     // (block-style-comments in this function correspond to text from the spec and
4090     // the numbers correspond to numbers in spec)
4091 
4092     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing
4093     // relative positioned inline.
4094     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
4095 
4096     const LayoutUnit containerLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock);
4097     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
4098 
4099     // To match WinIE, in quirks mode use the parent&#39;s &#39;direction&#39; property
4100     // instead of the container block&#39;s.
4101     TextDirection containerDirection = containerBlock.style().direction();
4102 
4103     // Variables to solve.
4104     bool isHorizontal = isHorizontalWritingMode();
4105     Length logicalLeft = style().logicalLeft();
4106     Length logicalRight = style().logicalRight();
4107     Length marginLogicalLeft = isHorizontal ? style().marginLeft() : style().marginTop();
4108     Length marginLogicalRight = isHorizontal ? style().marginRight() : style().marginBottom();
4109     LayoutUnit&amp; marginLogicalLeftAlias = style().isLeftToRightDirection() ? computedValues.m_margins.m_start : computedValues.m_margins.m_end;
4110     LayoutUnit&amp; marginLogicalRightAlias = style().isLeftToRightDirection() ? computedValues.m_margins.m_end : computedValues.m_margins.m_start;
4111 
4112     /*-----------------------------------------------------------------------*\
4113      * 1. The used value of &#39;width&#39; is determined as for inline replaced
4114      *    elements.
4115     \*-----------------------------------------------------------------------*/
4116     // NOTE: This value of width is final in that the min/max width calculations
4117     // are dealt with in computeReplacedWidth().  This means that the steps to produce
4118     // correct max/min in the non-replaced version, are not necessary.
4119     computedValues.m_extent = computeReplacedLogicalWidth() + borderAndPaddingLogicalWidth();
4120 
4121     const LayoutUnit availableSpace = containerLogicalWidth - computedValues.m_extent;
4122 
4123     /*-----------------------------------------------------------------------*\
4124      * 2. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if &#39;direction&#39;
4125      *    of the containing block is &#39;ltr&#39;, set &#39;left&#39; to the static position;
4126      *    else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
4127     \*-----------------------------------------------------------------------*/
4128     // see FIXME 1
4129     computeInlineStaticDistance(logicalLeft, logicalRight, this, containerBlock, containerLogicalWidth, nullptr); // FIXME: Pass the fragment.
4130 
4131     /*-----------------------------------------------------------------------*\
4132      * 3. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39;
4133      *    or &#39;margin-right&#39; with &#39;0&#39;.
4134     \*-----------------------------------------------------------------------*/
4135     if (logicalLeft.isAuto() || logicalRight.isAuto()) {
4136         if (marginLogicalLeft.isAuto())
4137             marginLogicalLeft.setValue(Fixed, 0);
4138         if (marginLogicalRight.isAuto())
4139             marginLogicalRight.setValue(Fixed, 0);
4140     }
4141 
4142     /*-----------------------------------------------------------------------*\
4143      * 4. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still
4144      *    &#39;auto&#39;, solve the equation under the extra constraint that the two
4145      *    margins must get equal values, unless this would make them negative,
4146      *    in which case when the direction of the containing block is &#39;ltr&#39;
4147      *    (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and solve for
4148      *    &#39;margin-right&#39; (&#39;margin-left&#39;).
4149     \*-----------------------------------------------------------------------*/
4150     LayoutUnit logicalLeftValue;
4151     LayoutUnit logicalRightValue;
4152 
4153     if (marginLogicalLeft.isAuto() &amp;&amp; marginLogicalRight.isAuto()) {
4154         // &#39;left&#39; and &#39;right&#39; cannot be &#39;auto&#39; due to step 3
4155         ASSERT(!(logicalLeft.isAuto() &amp;&amp; logicalRight.isAuto()));
4156 
4157         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4158         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4159 
4160         LayoutUnit difference = availableSpace - (logicalLeftValue + logicalRightValue);
4161         if (difference &gt; 0) {
4162             marginLogicalLeftAlias = difference / 2; // split the difference
4163             marginLogicalRightAlias = difference - marginLogicalLeftAlias; // account for odd valued differences
4164         } else {
4165             // Use the containing block&#39;s direction rather than the parent block&#39;s
4166             // per CSS 2.1 reference test abspos-replaced-width-margin-000.
4167             if (containerDirection == TextDirection::LTR) {
4168                 marginLogicalLeftAlias = 0;
4169                 marginLogicalRightAlias = difference; // will be negative
4170             } else {
4171                 marginLogicalLeftAlias = difference; // will be negative
4172                 marginLogicalRightAlias = 0;
4173             }
4174         }
4175 
4176     /*-----------------------------------------------------------------------*\
4177      * 5. If at this point there is an &#39;auto&#39; left, solve the equation for
4178      *    that value.
4179     \*-----------------------------------------------------------------------*/
4180     } else if (logicalLeft.isAuto()) {
4181         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4182         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4183         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4184 
4185         // Solve for &#39;left&#39;
4186         logicalLeftValue = availableSpace - (logicalRightValue + marginLogicalLeftAlias + marginLogicalRightAlias);
4187     } else if (logicalRight.isAuto()) {
4188         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4189         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4190         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4191 
4192         // Solve for &#39;right&#39;
4193         logicalRightValue = availableSpace - (logicalLeftValue + marginLogicalLeftAlias + marginLogicalRightAlias);
4194     } else if (marginLogicalLeft.isAuto()) {
4195         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4196         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4197         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4198 
4199         // Solve for &#39;margin-left&#39;
4200         marginLogicalLeftAlias = availableSpace - (logicalLeftValue + logicalRightValue + marginLogicalRightAlias);
4201     } else if (marginLogicalRight.isAuto()) {
4202         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4203         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4204         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4205 
4206         // Solve for &#39;margin-right&#39;
4207         marginLogicalRightAlias = availableSpace - (logicalLeftValue + logicalRightValue + marginLogicalLeftAlias);
4208     } else {
4209         // Nothing is &#39;auto&#39;, just calculate the values.
4210         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4211         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4212         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4213         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4214         // If the containing block is right-to-left, then push the left position as far to the right as possible
4215         if (containerDirection == TextDirection::RTL) {
4216             int totalLogicalWidth = computedValues.m_extent + logicalLeftValue + logicalRightValue +  marginLogicalLeftAlias + marginLogicalRightAlias;
4217             logicalLeftValue = containerLogicalWidth - (totalLogicalWidth - logicalLeftValue);
4218         }
4219     }
4220 
4221     /*-----------------------------------------------------------------------*\
4222      * 6. If at this point the values are over-constrained, ignore the value
4223      *    for either &#39;left&#39; (in case the &#39;direction&#39; property of the
4224      *    containing block is &#39;rtl&#39;) or &#39;right&#39; (in case &#39;direction&#39; is
4225      *    &#39;ltr&#39;) and solve for that value.
4226     \*-----------------------------------------------------------------------*/
4227     // NOTE: Constraints imposed by the width of the containing block and its content have already been accounted for above.
4228 
4229     // FIXME: Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space, so that
4230     // can make the result here rather complicated to compute.
4231 
4232     // Use computed values to calculate the horizontal position.
4233 
4234     // FIXME: This hack is needed to calculate the logical left position for a &#39;rtl&#39; relatively
4235     // positioned, inline containing block because right now, it is using the logical left position
4236     // of the first line box when really it should use the last line box.  When
4237     // this is fixed elsewhere, this block should be removed.
4238     if (is&lt;RenderInline&gt;(containerBlock) &amp;&amp; !containerBlock.style().isLeftToRightDirection()) {
4239         const auto&amp; flow = downcast&lt;RenderInline&gt;(containerBlock);
4240         InlineFlowBox* firstLine = flow.firstLineBox();
4241         InlineFlowBox* lastLine = flow.lastLineBox();
4242         if (firstLine &amp;&amp; lastLine &amp;&amp; firstLine != lastLine) {
4243             computedValues.m_position = logicalLeftValue + marginLogicalLeftAlias + lastLine-&gt;borderLogicalLeft() + (lastLine-&gt;logicalLeft() - firstLine-&gt;logicalLeft());
4244             return;
4245         }
4246     }
4247 
4248     LayoutUnit logicalLeftPos = logicalLeftValue + marginLogicalLeftAlias;
4249     computeLogicalLeftPositionedOffset(logicalLeftPos, this, computedValues.m_extent, containerBlock, containerLogicalWidth);
4250     computedValues.m_position = logicalLeftPos;
4251 }
4252 
4253 void RenderBox::computePositionedLogicalHeightReplaced(LogicalExtentComputedValues&amp; computedValues) const
4254 {
4255     // The following is based off of the W3C Working Draft from April 11, 2006 of
4256     // CSS 2.1: Section 10.6.5 &quot;Absolutely positioned, replaced elements&quot;
4257     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-replaced-height&gt;
4258     // (block-style-comments in this function correspond to text from the spec and
4259     // the numbers correspond to numbers in spec)
4260 
4261     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing relpositioned inline.
4262     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
4263 
4264     const LayoutUnit containerLogicalHeight = containingBlockLogicalHeightForPositioned(containerBlock);
4265     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
4266 
4267     // Variables to solve.
4268     Length marginBefore = style().marginBefore();
4269     Length marginAfter = style().marginAfter();
4270     LayoutUnit&amp; marginBeforeAlias = computedValues.m_margins.m_before;
4271     LayoutUnit&amp; marginAfterAlias = computedValues.m_margins.m_after;
4272 
4273     Length logicalTop = style().logicalTop();
4274     Length logicalBottom = style().logicalBottom();
4275 
4276     /*-----------------------------------------------------------------------*\
4277      * 1. The used value of &#39;height&#39; is determined as for inline replaced
4278      *    elements.
4279     \*-----------------------------------------------------------------------*/
4280     // NOTE: This value of height is final in that the min/max height calculations
4281     // are dealt with in computeReplacedHeight().  This means that the steps to produce
4282     // correct max/min in the non-replaced version, are not necessary.
4283     computedValues.m_extent = computeReplacedLogicalHeight() + borderAndPaddingLogicalHeight();
4284     const LayoutUnit availableSpace = containerLogicalHeight - computedValues.m_extent;
4285 
4286     /*-----------------------------------------------------------------------*\
4287      * 2. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39;
4288      *    with the element&#39;s static position.
4289     \*-----------------------------------------------------------------------*/
4290     // see FIXME 1
4291     computeBlockStaticDistance(logicalTop, logicalBottom, this, containerBlock);
4292 
4293     /*-----------------------------------------------------------------------*\
4294      * 3. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or
4295      *    &#39;margin-bottom&#39; with &#39;0&#39;.
4296     \*-----------------------------------------------------------------------*/
4297     // FIXME: The spec. says that this step should only be taken when bottom is
4298     // auto, but if only top is auto, this makes step 4 impossible.
4299     if (logicalTop.isAuto() || logicalBottom.isAuto()) {
4300         if (marginBefore.isAuto())
4301             marginBefore.setValue(Fixed, 0);
4302         if (marginAfter.isAuto())
4303             marginAfter.setValue(Fixed, 0);
4304     }
4305 
4306     /*-----------------------------------------------------------------------*\
4307      * 4. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still
4308      *    &#39;auto&#39;, solve the equation under the extra constraint that the two
4309      *    margins must get equal values.
4310     \*-----------------------------------------------------------------------*/
4311     LayoutUnit logicalTopValue;
4312     LayoutUnit logicalBottomValue;
4313 
4314     if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
4315         // &#39;top&#39; and &#39;bottom&#39; cannot be &#39;auto&#39; due to step 2 and 3 combined.
4316         ASSERT(!(logicalTop.isAuto() || logicalBottom.isAuto()));
4317 
4318         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4319         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4320 
4321         LayoutUnit difference = availableSpace - (logicalTopValue + logicalBottomValue);
4322         // NOTE: This may result in negative values.
4323         marginBeforeAlias =  difference / 2; // split the difference
4324         marginAfterAlias = difference - marginBeforeAlias; // account for odd valued differences
4325 
4326     /*-----------------------------------------------------------------------*\
4327      * 5. If at this point there is only one &#39;auto&#39; left, solve the equation
4328      *    for that value.
4329     \*-----------------------------------------------------------------------*/
4330     } else if (logicalTop.isAuto()) {
4331         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4332         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4333         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4334 
4335         // Solve for &#39;top&#39;
4336         logicalTopValue = availableSpace - (logicalBottomValue + marginBeforeAlias + marginAfterAlias);
4337     } else if (logicalBottom.isAuto()) {
4338         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4339         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4340         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4341 
4342         // Solve for &#39;bottom&#39;
4343         // NOTE: It is not necessary to solve for &#39;bottom&#39; because we don&#39;t ever
4344         // use the value.
4345     } else if (marginBefore.isAuto()) {
4346         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4347         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4348         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4349 
4350         // Solve for &#39;margin-top&#39;
4351         marginBeforeAlias = availableSpace - (logicalTopValue + logicalBottomValue + marginAfterAlias);
4352     } else if (marginAfter.isAuto()) {
4353         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4354         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4355         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4356 
4357         // Solve for &#39;margin-bottom&#39;
4358         marginAfterAlias = availableSpace - (logicalTopValue + logicalBottomValue + marginBeforeAlias);
4359     } else {
4360         // Nothing is &#39;auto&#39;, just calculate the values.
4361         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4362         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4363         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4364         // NOTE: It is not necessary to solve for &#39;bottom&#39; because we don&#39;t ever
4365         // use the value.
4366      }
4367 
4368     /*-----------------------------------------------------------------------*\
4369      * 6. If at this point the values are over-constrained, ignore the value
4370      *    for &#39;bottom&#39; and solve for that value.
4371     \*-----------------------------------------------------------------------*/
4372     // NOTE: It is not necessary to do this step because we don&#39;t end up using
4373     // the value of &#39;bottom&#39; regardless of whether the values are over-constrained
4374     // or not.
4375 
4376     // Use computed values to calculate the vertical position.
4377     LayoutUnit logicalTopPos = logicalTopValue + marginBeforeAlias;
4378     computeLogicalTopPositionedOffset(logicalTopPos, this, computedValues.m_extent, containerBlock, containerLogicalHeight);
4379     computedValues.m_position = logicalTopPos;
4380 }
4381 
4382 LayoutRect RenderBox::localCaretRect(InlineBox* box, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
4383 {
4384     // VisiblePositions at offsets inside containers either a) refer to the positions before/after
4385     // those containers (tables and select elements) or b) refer to the position inside an empty block.
4386     // They never refer to children.
4387     // FIXME: Paint the carets inside empty blocks differently than the carets before/after elements.
4388 
4389     LayoutRect rect(location(), LayoutSize(caretWidth, height()));
4390     bool ltr = box ? box-&gt;isLeftToRightDirection() : style().isLeftToRightDirection();
4391 
4392     if ((!caretOffset) ^ ltr)
4393         rect.move(LayoutSize(width() - caretWidth, 0_lu));
4394 
4395     if (box) {
4396         const RootInlineBox&amp; rootBox = box-&gt;root();
4397         LayoutUnit top = rootBox.lineTop();
4398         rect.setY(top);
4399         rect.setHeight(rootBox.lineBottom() - top);
4400     }
4401 
4402     // If height of box is smaller than font height, use the latter one,
4403     // otherwise the caret might become invisible.
4404     //
4405     // Also, if the box is not a replaced element, always use the font height.
4406     // This prevents the &quot;big caret&quot; bug described in:
4407     // &lt;rdar://problem/3777804&gt; Deleting all content in a document can result in giant tall-as-window insertion point
4408     //
4409     // FIXME: ignoring :first-line, missing good reason to take care of
4410     LayoutUnit fontHeight = style().fontMetrics().height();
4411     if (fontHeight &gt; rect.height() || (!isReplaced() &amp;&amp; !isTable()))
4412         rect.setHeight(fontHeight);
4413 
4414     if (extraWidthToEndOfLine)
4415         *extraWidthToEndOfLine = x() + width() - rect.maxX();
4416 
4417     // Move to local coords
4418     rect.moveBy(-location());
4419 
4420     // FIXME: Border/padding should be added for all elements but this workaround
4421     // is needed because we use offsets inside an &quot;atomic&quot; element to represent
4422     // positions before and after the element in deprecated editing offsets.
4423     if (element() &amp;&amp; !(editingIgnoresContent(*element()) || isRenderedTable(element()))) {
4424         rect.setX(rect.x() + borderLeft() + paddingLeft());
4425         rect.setY(rect.y() + paddingTop() + borderTop());
4426     }
4427 
4428     if (!isHorizontalWritingMode())
4429         return rect.transposedRect();
4430 
4431     return rect;
4432 }
4433 
4434 VisiblePosition RenderBox::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
4435 {
4436     // no children...return this render object&#39;s element, if there is one, and offset 0
4437     if (!firstChild())
4438         return createVisiblePosition(nonPseudoElement() ? firstPositionInOrBeforeNode(nonPseudoElement()) : Position());
4439 
4440     if (isTable() &amp;&amp; nonPseudoElement()) {
4441         LayoutUnit right = contentWidth() + horizontalBorderAndPaddingExtent();
4442         LayoutUnit bottom = contentHeight() + verticalBorderAndPaddingExtent();
4443 
4444         if (point.x() &lt; 0 || point.x() &gt; right || point.y() &lt; 0 || point.y() &gt; bottom) {
4445             if (point.x() &lt;= right / 2)
4446                 return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4447             return createVisiblePosition(lastPositionInOrAfterNode(nonPseudoElement()));
4448         }
4449     }
4450 
4451     // Pass off to the closest child.
4452     LayoutUnit minDist = LayoutUnit::max();
4453     RenderBox* closestRenderer = nullptr;
4454     LayoutPoint adjustedPoint = point;
4455     if (isTableRow())
4456         adjustedPoint.moveBy(location());
4457 
4458     for (auto&amp; renderer : childrenOfType&lt;RenderBox&gt;(*this)) {
4459         if (is&lt;RenderFragmentedFlow&gt;(*this)) {
4460             ASSERT(fragment);
4461             if (!downcast&lt;RenderFragmentedFlow&gt;(*this).objectShouldFragmentInFlowFragment(&amp;renderer, fragment))
4462                 continue;
4463         }
4464 
4465         if ((!renderer.firstChild() &amp;&amp; !renderer.isInline() &amp;&amp; !is&lt;RenderBlockFlow&gt;(renderer))
4466             || renderer.style().visibility() != Visibility::Visible)
4467             continue;
4468 
4469         LayoutUnit top = renderer.borderTop() + renderer.paddingTop() + (is&lt;RenderTableRow&gt;(*this) ? 0_lu : renderer.y());
4470         LayoutUnit bottom = top + renderer.contentHeight();
4471         LayoutUnit left = renderer.borderLeft() + renderer.paddingLeft() + (is&lt;RenderTableRow&gt;(*this) ? 0_lu : renderer.x());
4472         LayoutUnit right = left + renderer.contentWidth();
4473 
4474         if (point.x() &lt;= right &amp;&amp; point.x() &gt;= left &amp;&amp; point.y() &lt;= top &amp;&amp; point.y() &gt;= bottom) {
4475             if (is&lt;RenderTableRow&gt;(renderer))
4476                 return renderer.positionForPoint(point + adjustedPoint - renderer.locationOffset(), fragment);
4477             return renderer.positionForPoint(point - renderer.locationOffset(), fragment);
4478         }
4479 
4480         // Find the distance from (x, y) to the box.  Split the space around the box into 8 pieces
4481         // and use a different compare depending on which piece (x, y) is in.
4482         LayoutPoint cmp;
4483         if (point.x() &gt; right) {
4484             if (point.y() &lt; top)
4485                 cmp = LayoutPoint(right, top);
4486             else if (point.y() &gt; bottom)
4487                 cmp = LayoutPoint(right, bottom);
4488             else
4489                 cmp = LayoutPoint(right, point.y());
4490         } else if (point.x() &lt; left) {
4491             if (point.y() &lt; top)
4492                 cmp = LayoutPoint(left, top);
4493             else if (point.y() &gt; bottom)
4494                 cmp = LayoutPoint(left, bottom);
4495             else
4496                 cmp = LayoutPoint(left, point.y());
4497         } else {
4498             if (point.y() &lt; top)
4499                 cmp = LayoutPoint(point.x(), top);
4500             else
4501                 cmp = LayoutPoint(point.x(), bottom);
4502         }
4503 
4504         LayoutSize difference = cmp - point;
4505 
4506         LayoutUnit dist = difference.width() * difference.width() + difference.height() * difference.height();
4507         if (dist &lt; minDist) {
4508             closestRenderer = &amp;renderer;
4509             minDist = dist;
4510         }
4511     }
4512 
4513     if (closestRenderer)
4514         return closestRenderer-&gt;positionForPoint(adjustedPoint - closestRenderer-&gt;locationOffset(), fragment);
4515 
4516     return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4517 }
4518 
4519 bool RenderBox::shrinkToAvoidFloats() const
4520 {
4521     // Floating objects don&#39;t shrink.  Objects that don&#39;t avoid floats don&#39;t shrink.  Marquees don&#39;t shrink.
4522     if ((isInline() &amp;&amp; !isHTMLMarquee()) || !avoidsFloats() || isFloating())
4523         return false;
4524 
4525     // Only auto width objects can possibly shrink to avoid floats.
4526     return style().width().isAuto();
4527 }
4528 
4529 bool RenderBox::createsNewFormattingContext() const
4530 {
4531     return isInlineBlockOrInlineTable() || isFloatingOrOutOfFlowPositioned() || hasOverflowClip() || isFlexItemIncludingDeprecated()
4532         || isTableCell() || isTableCaption() || isFieldset() || isWritingModeRoot() || isDocumentElementRenderer() || isRenderFragmentedFlow() || isRenderFragmentContainer()
4533         || isGridItem() || style().specifiesColumns() || style().columnSpan() == ColumnSpan::All || style().display() == DisplayType::FlowRoot;
4534 }
4535 
4536 bool RenderBox::avoidsFloats() const
4537 {
4538     return isReplaced() || isHR() || isLegend() || isFieldset() || createsNewFormattingContext();
4539 }
4540 
4541 void RenderBox::addVisualEffectOverflow()
4542 {
4543     if (!style().boxShadow() &amp;&amp; !style().hasBorderImageOutsets() &amp;&amp; !outlineStyleForRepaint().hasOutlineInVisualOverflow())
4544         return;
4545 
4546     addVisualOverflow(applyVisualEffectOverflow(borderBoxRect()));
4547 
4548     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4549     if (fragmentedFlow)
4550         fragmentedFlow-&gt;addFragmentsVisualEffectOverflow(this);
4551 }
4552 
4553 LayoutRect RenderBox::applyVisualEffectOverflow(const LayoutRect&amp; borderBox) const
4554 {
4555     bool isFlipped = style().isFlippedBlocksWritingMode();
4556     bool isHorizontal = isHorizontalWritingMode();
4557 
4558     LayoutUnit overflowMinX = borderBox.x();
4559     LayoutUnit overflowMaxX = borderBox.maxX();
4560     LayoutUnit overflowMinY = borderBox.y();
4561     LayoutUnit overflowMaxY = borderBox.maxY();
4562 
4563     // Compute box-shadow overflow first.
4564     if (style().boxShadow()) {
4565         LayoutUnit shadowLeft;
4566         LayoutUnit shadowRight;
4567         LayoutUnit shadowTop;
4568         LayoutUnit shadowBottom;
4569         style().getBoxShadowExtent(shadowTop, shadowRight, shadowBottom, shadowLeft);
4570 
4571         // In flipped blocks writing modes such as vertical-rl, the physical right shadow value is actually at the lower x-coordinate.
4572         overflowMinX = borderBox.x() + ((!isFlipped || isHorizontal) ? shadowLeft : -shadowRight);
4573         overflowMaxX = borderBox.maxX() + ((!isFlipped || isHorizontal) ? shadowRight : -shadowLeft);
4574         overflowMinY = borderBox.y() + ((!isFlipped || !isHorizontal) ? shadowTop : -shadowBottom);
4575         overflowMaxY = borderBox.maxY() + ((!isFlipped || !isHorizontal) ? shadowBottom : -shadowTop);
4576     }
4577 
4578     // Now compute border-image-outset overflow.
4579     if (style().hasBorderImageOutsets()) {
4580         LayoutBoxExtent borderOutsets = style().borderImageOutsets();
4581 
4582         // In flipped blocks writing modes, the physical sides are inverted. For example in vertical-rl, the right
4583         // border is at the lower x coordinate value.
4584         overflowMinX = std::min(overflowMinX, borderBox.x() - ((!isFlipped || isHorizontal) ? borderOutsets.left() : borderOutsets.right()));
4585         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + ((!isFlipped || isHorizontal) ? borderOutsets.right() : borderOutsets.left()));
4586         overflowMinY = std::min(overflowMinY, borderBox.y() - ((!isFlipped || !isHorizontal) ? borderOutsets.top() : borderOutsets.bottom()));
4587         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + ((!isFlipped || !isHorizontal) ? borderOutsets.bottom() : borderOutsets.top()));
4588     }
4589 
4590     if (outlineStyleForRepaint().hasOutlineInVisualOverflow()) {
4591         LayoutUnit outlineSize { outlineStyleForRepaint().outlineSize() };
4592         overflowMinX = std::min(overflowMinX, borderBox.x() - outlineSize);
4593         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + outlineSize);
4594         overflowMinY = std::min(overflowMinY, borderBox.y() - outlineSize);
4595         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + outlineSize);
4596     }
4597     // Add in the final overflow with shadows and outsets combined.
4598     return LayoutRect(overflowMinX, overflowMinY, overflowMaxX - overflowMinX, overflowMaxY - overflowMinY);
4599 }
4600 
4601 void RenderBox::addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta)
4602 {
4603     // Never allow flow threads to propagate overflow up to a parent.
4604     if (child-&gt;isRenderFragmentedFlow())
4605         return;
4606 
4607     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4608     if (fragmentedFlow)
4609         fragmentedFlow-&gt;addFragmentsOverflowFromChild(this, child, delta);
4610 
4611     // Only propagate layout overflow from the child if the child isn&#39;t clipping its overflow.  If it is, then
4612     // its overflow is internal to it, and we don&#39;t care about it.  layoutOverflowRectForPropagation takes care of this
4613     // and just propagates the border box rect instead.
4614     LayoutRect childLayoutOverflowRect = child-&gt;layoutOverflowRectForPropagation(&amp;style());
4615     childLayoutOverflowRect.move(delta);
4616     addLayoutOverflow(childLayoutOverflowRect);
4617 
4618     // Add in visual overflow from the child.  Even if the child clips its overflow, it may still
4619     // have visual overflow of its own set from box shadows or reflections.  It is unnecessary to propagate this
4620     // overflow if we are clipping our own overflow.
4621     if (child-&gt;hasSelfPaintingLayer() || hasOverflowClip())
4622         return;
4623     LayoutRect childVisualOverflowRect = child-&gt;visualOverflowRectForPropagation(&amp;style());
4624     childVisualOverflowRect.move(delta);
4625     addVisualOverflow(childVisualOverflowRect);
4626 }
4627 
4628 void RenderBox::addLayoutOverflow(const LayoutRect&amp; rect)
4629 {
4630     LayoutRect clientBox = flippedClientBoxRect();
4631     if (clientBox.contains(rect) || rect.isEmpty())
4632         return;
4633 
4634     // For overflow clip objects, we don&#39;t want to propagate overflow into unreachable areas.
4635     LayoutRect overflowRect(rect);
4636     if (hasOverflowClip() || isRenderView()) {
4637         // Overflow is in the block&#39;s coordinate space and thus is flipped for horizontal-bt and vertical-rl
4638         // writing modes.  At this stage that is actually a simplification, since we can treat horizontal-tb/bt as the same
4639         // and vertical-lr/rl as the same.
4640         bool hasTopOverflow = isTopLayoutOverflowAllowed();
4641         bool hasLeftOverflow = isLeftLayoutOverflowAllowed();
4642 
4643         if (!hasTopOverflow)
4644             overflowRect.shiftYEdgeTo(std::max(overflowRect.y(), clientBox.y()));
4645         else
4646             overflowRect.shiftMaxYEdgeTo(std::min(overflowRect.maxY(), clientBox.maxY()));
4647         if (!hasLeftOverflow)
4648             overflowRect.shiftXEdgeTo(std::max(overflowRect.x(), clientBox.x()));
4649         else
4650             overflowRect.shiftMaxXEdgeTo(std::min(overflowRect.maxX(), clientBox.maxX()));
4651 
4652         // Now re-test with the adjusted rectangle and see if it has become unreachable or fully
4653         // contained.
4654         if (clientBox.contains(overflowRect) || overflowRect.isEmpty())
4655             return;
4656     }
4657 
4658     if (!m_overflow)
4659         m_overflow = adoptRef(new RenderOverflow(clientBox, borderBoxRect()));
4660 
4661     m_overflow-&gt;addLayoutOverflow(overflowRect);
4662 }
4663 
4664 void RenderBox::addVisualOverflow(const LayoutRect&amp; rect)
4665 {
4666     LayoutRect borderBox = borderBoxRect();
4667     if (borderBox.contains(rect) || rect.isEmpty())
4668         return;
4669 
4670     if (!m_overflow)
4671         m_overflow = adoptRef(new RenderOverflow(flippedClientBoxRect(), borderBox));
4672 
4673     m_overflow-&gt;addVisualOverflow(rect);
4674 }
4675 
4676 void RenderBox::clearOverflow()
4677 {
4678     m_overflow = nullptr;
4679     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4680     if (fragmentedFlow)
4681         fragmentedFlow-&gt;clearFragmentsOverflow(this);
4682 }
4683 
4684 bool RenderBox::percentageLogicalHeightIsResolvable() const
4685 {
4686     // Do this to avoid duplicating all the logic that already exists when computing
4687     // an actual percentage height.
4688     Length fakeLength(100, Percent);
4689     return computePercentageLogicalHeight(fakeLength) != WTF::nullopt;
4690 }
4691 
4692 bool RenderBox::hasUnsplittableScrollingOverflow() const
4693 {
4694     // We will paginate as long as we don&#39;t scroll overflow in the pagination direction.
4695     bool isHorizontal = isHorizontalWritingMode();
4696     if ((isHorizontal &amp;&amp; !scrollsOverflowY()) || (!isHorizontal &amp;&amp; !scrollsOverflowX()))
4697         return false;
4698 
4699     // We do have overflow. We&#39;ll still be willing to paginate as long as the block
4700     // has auto logical height, auto or undefined max-logical-height and a zero or auto min-logical-height.
4701     // Note this is just a heuristic, and it&#39;s still possible to have overflow under these
4702     // conditions, but it should work out to be good enough for common cases. Paginating overflow
4703     // with scrollbars present is not the end of the world and is what we used to do in the old model anyway.
4704     return !style().logicalHeight().isIntrinsicOrAuto()
4705         || (!style().logicalMaxHeight().isIntrinsicOrAuto() &amp;&amp; !style().logicalMaxHeight().isUndefined() &amp;&amp; (!style().logicalMaxHeight().isPercentOrCalculated() || percentageLogicalHeightIsResolvable()))
4706         || (!style().logicalMinHeight().isIntrinsicOrAuto() &amp;&amp; style().logicalMinHeight().isPositive() &amp;&amp; (!style().logicalMinHeight().isPercentOrCalculated() || percentageLogicalHeightIsResolvable()));
4707 }
4708 
4709 bool RenderBox::isUnsplittableForPagination() const
4710 {
4711     return isReplaced()
4712         || hasUnsplittableScrollingOverflow()
4713         || (parent() &amp;&amp; isWritingModeRoot())
4714         || (isFloating() &amp;&amp; style().styleType() == PseudoId::FirstLetter &amp;&amp; style().initialLetterDrop() &gt; 0);
4715 }
4716 
4717 LayoutUnit RenderBox::lineHeight(bool /*firstLine*/, LineDirectionMode direction, LinePositionMode /*linePositionMode*/) const
4718 {
4719     if (isReplaced())
4720         return direction == HorizontalLine ? m_marginBox.top() + height() + m_marginBox.bottom() : m_marginBox.right() + width() + m_marginBox.left();
4721     return 0;
4722 }
4723 
4724 int RenderBox::baselinePosition(FontBaseline baselineType, bool /*firstLine*/, LineDirectionMode direction, LinePositionMode /*linePositionMode*/) const
4725 {
4726     if (isReplaced()) {
4727         int result = direction == HorizontalLine ? m_marginBox.top() + height() + m_marginBox.bottom() : m_marginBox.right() + width() + m_marginBox.left();
4728         if (baselineType == AlphabeticBaseline)
4729             return result;
4730         return result - result / 2;
4731     }
4732     return 0;
4733 }
4734 
4735 
4736 RenderLayer* RenderBox::enclosingFloatPaintingLayer() const
4737 {
4738     for (auto&amp; box : lineageOfType&lt;RenderBox&gt;(*this)) {
4739         if (box.layer() &amp;&amp; box.layer()-&gt;isSelfPaintingLayer())
4740             return box.layer();
4741     }
4742     return nullptr;
4743 }
4744 
4745 LayoutRect RenderBox::logicalVisualOverflowRectForPropagation(const RenderStyle* parentStyle) const
4746 {
4747     LayoutRect rect = visualOverflowRectForPropagation(parentStyle);
4748     if (!parentStyle-&gt;isHorizontalWritingMode())
4749         return rect.transposedRect();
4750     return rect;
4751 }
4752 
4753 LayoutRect RenderBox::visualOverflowRectForPropagation(const RenderStyle* parentStyle) const
4754 {
4755     // If the writing modes of the child and parent match, then we don&#39;t have to
4756     // do anything fancy. Just return the result.
4757     LayoutRect rect = visualOverflowRect();
4758     if (parentStyle-&gt;writingMode() == style().writingMode())
4759         return rect;
4760 
4761     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4762     // in a particular axis, then we have to flip the rect along that axis.
4763     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4764         rect.setX(width() - rect.maxX());
4765     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4766         rect.setY(height() - rect.maxY());
4767 
4768     return rect;
4769 }
4770 
4771 LayoutRect RenderBox::logicalLayoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4772 {
4773     LayoutRect rect = layoutOverflowRectForPropagation(parentStyle);
4774     if (!parentStyle-&gt;isHorizontalWritingMode())
4775         return rect.transposedRect();
4776     return rect;
4777 }
4778 
4779 LayoutRect RenderBox::layoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4780 {
4781     // Only propagate interior layout overflow if we don&#39;t clip it.
4782     LayoutRect rect = borderBoxRect();
4783     if (!hasOverflowClip())
4784         rect.unite(layoutOverflowRect());
4785 
4786     bool hasTransform = this-&gt;hasTransform();
4787     if (isInFlowPositioned() || hasTransform) {
4788         // If we are relatively positioned or if we have a transform, then we have to convert
4789         // this rectangle into physical coordinates, apply relative positioning and transforms
4790         // to it, and then convert it back.
4791         flipForWritingMode(rect);
4792 
4793         if (hasTransform &amp;&amp; hasLayer())
4794             rect = layer()-&gt;currentTransform().mapRect(rect);
4795 
4796         if (isInFlowPositioned())
4797             rect.move(offsetForInFlowPosition());
4798 
4799         // Now we need to flip back.
4800         flipForWritingMode(rect);
4801     }
4802 
4803     // If the writing modes of the child and parent match, then we don&#39;t have to
4804     // do anything fancy. Just return the result.
4805     if (parentStyle-&gt;writingMode() == style().writingMode())
4806         return rect;
4807 
4808     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4809     // in a particular axis, then we have to flip the rect along that axis.
4810     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4811         rect.setX(width() - rect.maxX());
4812     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4813         rect.setY(height() - rect.maxY());
4814 
4815     return rect;
4816 }
4817 
4818 LayoutRect RenderBox::flippedClientBoxRect() const
4819 {
4820     // Because of the special coordinate system used for overflow rectangles (not quite logical, not
4821     // quite physical), we need to flip the block progression coordinate in vertical-rl and
4822     // horizontal-bt writing modes. Apart from that, this method does the same as clientBoxRect().
4823 
4824     LayoutUnit left = borderLeft();
4825     LayoutUnit top = borderTop();
4826     LayoutUnit right = borderRight();
4827     LayoutUnit bottom = borderBottom();
4828     // Calculate physical padding box.
4829     LayoutRect rect(left, top, width() - left - right, height() - top - bottom);
4830     // Flip block progression axis if writing mode is vertical-rl or horizontal-bt.
4831     flipForWritingMode(rect);
4832     // Subtract space occupied by scrollbars. They are at their physical edge in this coordinate
4833     // system, so order is important here: first flip, then subtract scrollbars.
4834     if (shouldPlaceBlockDirectionScrollbarOnLeft())
4835         rect.move(verticalScrollbarWidth(), 0);
4836     rect.contract(verticalScrollbarWidth(), horizontalScrollbarHeight());
4837     return rect;
4838 }
4839 
4840 LayoutRect RenderBox::overflowRectForPaintRejection() const
4841 {
4842     LayoutRect overflowRect = visualOverflowRect();
4843 
4844     if (!m_overflow || !usesCompositedScrolling())
4845         return overflowRect;
4846 
4847     overflowRect.unite(layoutOverflowRect());
4848     overflowRect.moveBy(-scrollPosition());
4849     return overflowRect;
4850 }
4851 
4852 LayoutUnit RenderBox::offsetLeft() const
4853 {
4854     return adjustedPositionRelativeToOffsetParent(topLeftLocation()).x();
4855 }
4856 
4857 LayoutUnit RenderBox::offsetTop() const
4858 {
4859     return adjustedPositionRelativeToOffsetParent(topLeftLocation()).y();
4860 }
4861 
4862 LayoutPoint RenderBox::flipForWritingModeForChild(const RenderBox* child, const LayoutPoint&amp; point) const
4863 {
4864     if (!style().isFlippedBlocksWritingMode())
4865         return point;
4866 
4867     // The child is going to add in its x() and y(), so we have to make sure it ends up in
4868     // the right place.
4869     if (isHorizontalWritingMode())
4870         return LayoutPoint(point.x(), point.y() + height() - child-&gt;height() - (2 * child-&gt;y()));
4871     return LayoutPoint(point.x() + width() - child-&gt;width() - (2 * child-&gt;x()), point.y());
4872 }
4873 
4874 void RenderBox::flipForWritingMode(LayoutRect&amp; rect) const
4875 {
4876     if (!style().isFlippedBlocksWritingMode())
4877         return;
4878 
4879     if (isHorizontalWritingMode())
4880         rect.setY(height() - rect.maxY());
4881     else
4882         rect.setX(width() - rect.maxX());
4883 }
4884 
4885 LayoutUnit RenderBox::flipForWritingMode(LayoutUnit position) const
4886 {
4887     if (!style().isFlippedBlocksWritingMode())
4888         return position;
4889     return logicalHeight() - position;
4890 }
4891 
4892 LayoutPoint RenderBox::flipForWritingMode(const LayoutPoint&amp; position) const
4893 {
4894     if (!style().isFlippedBlocksWritingMode())
4895         return position;
4896     return isHorizontalWritingMode() ? LayoutPoint(position.x(), height() - position.y()) : LayoutPoint(width() - position.x(), position.y());
4897 }
4898 
4899 LayoutSize RenderBox::flipForWritingMode(const LayoutSize&amp; offset) const
4900 {
4901     if (!style().isFlippedBlocksWritingMode())
4902         return offset;
4903     return isHorizontalWritingMode() ? LayoutSize(offset.width(), height() - offset.height()) : LayoutSize(width() - offset.width(), offset.height());
4904 }
4905 
4906 FloatPoint RenderBox::flipForWritingMode(const FloatPoint&amp; position) const
4907 {
4908     if (!style().isFlippedBlocksWritingMode())
4909         return position;
4910     return isHorizontalWritingMode() ? FloatPoint(position.x(), height() - position.y()) : FloatPoint(width() - position.x(), position.y());
4911 }
4912 
4913 void RenderBox::flipForWritingMode(FloatRect&amp; rect) const
4914 {
4915     if (!style().isFlippedBlocksWritingMode())
4916         return;
4917 
4918     if (isHorizontalWritingMode())
4919         rect.setY(height() - rect.maxY());
4920     else
4921         rect.setX(width() - rect.maxX());
4922 }
4923 
4924 LayoutPoint RenderBox::topLeftLocation() const
4925 {
4926     if (!view().frameView().hasFlippedBlockRenderers())
4927         return location();
4928 
4929     RenderBlock* containerBlock = containingBlock();
4930     if (!containerBlock || containerBlock == this)
4931         return location();
4932     return containerBlock-&gt;flipForWritingModeForChild(this, location());
4933 }
4934 
4935 LayoutSize RenderBox::topLeftLocationOffset() const
4936 {
4937     if (!view().frameView().hasFlippedBlockRenderers())
4938         return locationOffset();
4939 
4940     RenderBlock* containerBlock = containingBlock();
4941     if (!containerBlock || containerBlock == this)
4942         return locationOffset();
4943 
4944     LayoutRect rect(frameRect());
4945     containerBlock-&gt;flipForWritingMode(rect); // FIXME: This is wrong if we are an absolutely positioned object enclosed by a relative-positioned inline.
4946     return LayoutSize(rect.x(), rect.y());
4947 }
4948 
4949 void RenderBox::applyTopLeftLocationOffsetWithFlipping(LayoutPoint&amp; point) const
4950 {
4951     RenderBlock* containerBlock = containingBlock();
4952     if (!containerBlock || containerBlock == this) {
4953         point.move(m_frameRect.x(), m_frameRect.y());
4954         return;
4955     }
4956 
4957     LayoutRect rect(frameRect());
4958     containerBlock-&gt;flipForWritingMode(rect); // FIXME: This is wrong if we are an absolutely positioned object  enclosed by a relative-positioned inline.
4959     point.move(rect.x(), rect.y());
4960 }
4961 
4962 bool RenderBox::hasRelativeDimensions() const
4963 {
4964     return style().height().isPercentOrCalculated() || style().width().isPercentOrCalculated()
4965         || style().maxHeight().isPercentOrCalculated() || style().maxWidth().isPercentOrCalculated()
4966         || style().minHeight().isPercentOrCalculated() || style().minWidth().isPercentOrCalculated();
4967 }
4968 
4969 bool RenderBox::hasRelativeLogicalHeight() const
4970 {
4971     return style().logicalHeight().isPercentOrCalculated()
4972         || style().logicalMinHeight().isPercentOrCalculated()
4973         || style().logicalMaxHeight().isPercentOrCalculated();
4974 }
4975 
4976 bool RenderBox::hasRelativeLogicalWidth() const
4977 {
4978     return style().logicalWidth().isPercentOrCalculated()
4979         || style().logicalMinWidth().isPercentOrCalculated()
4980         || style().logicalMaxWidth().isPercentOrCalculated();
4981 }
4982 
4983 LayoutUnit RenderBox::offsetFromLogicalTopOfFirstPage() const
4984 {
4985     auto* layoutState = view().frameView().layoutContext().layoutState();
4986     if ((layoutState &amp;&amp; !layoutState-&gt;isPaginated()) || (!layoutState &amp;&amp; !enclosingFragmentedFlow()))
4987         return 0;
4988 
4989     RenderBlock* containerBlock = containingBlock();
4990     return containerBlock-&gt;offsetFromLogicalTopOfFirstPage() + logicalTop();
4991 }
4992 
4993 const RenderBox* RenderBox::findEnclosingScrollableContainer() const
4994 {
4995     for (auto&amp; candidate : lineageOfType&lt;RenderBox&gt;(*this)) {
4996         if (candidate.hasOverflowClip())
4997             return &amp;candidate;
4998     }
4999     // If all parent elements are not overflow scrollable, check the body.
5000     if (document().body() &amp;&amp; frame().mainFrame().view() &amp;&amp; frame().mainFrame().view()-&gt;isScrollable())
5001         return document().body()-&gt;renderBox();
5002 
5003     return nullptr;
5004 }
5005 
5006 } // namespace WebCore
    </pre>
  </body>
</html>
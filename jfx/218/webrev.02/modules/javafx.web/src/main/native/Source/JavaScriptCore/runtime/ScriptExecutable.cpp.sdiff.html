<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScriptExecutable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScopedArgumentsTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutable.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScriptExecutable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
179     case CodeForCall:
180         m_jitCodeForCall = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
181         m_jitCodeForCallWithArityCheck = nullptr;
182         break;
183     case CodeForConstruct:
184         m_jitCodeForConstruct = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
185         m_jitCodeForConstructWithArityCheck = nullptr;
186         break;
187     }
188 
189     auto&amp; clearableCodeSet = VM::SpaceAndSet::setFor(*subspace());
190     if (hasClearableCode(vm))
191         clearableCodeSet.add(this);
192     else
193         clearableCodeSet.remove(this);
194 
195     if (genericCodeBlock) {
196         RELEASE_ASSERT(genericCodeBlock-&gt;ownerExecutable() == this);
197         RELEASE_ASSERT(JITCode::isExecutableScript(genericCodeBlock-&gt;jitType()));
198 
<span class="line-modified">199         if (UNLIKELY(Options::verboseOSR()))</span>
<span class="line-removed">200             dataLog(&quot;Installing &quot;, *genericCodeBlock, &quot;\n&quot;);</span>
201 
202         if (UNLIKELY(vm.m_perBytecodeProfiler))
203             vm.m_perBytecodeProfiler-&gt;ensureBytecodesFor(genericCodeBlock);
204 
205         Debugger* debugger = genericCodeBlock-&gt;globalObject()-&gt;debugger();
206         if (UNLIKELY(debugger))
207             debugger-&gt;registerCodeBlock(genericCodeBlock);
208     }
209 
210     if (oldCodeBlock)
211         oldCodeBlock-&gt;unlinkIncomingCalls();
212 
213     vm.heap.writeBarrier(this);
214 }
215 
216 bool ScriptExecutable::hasClearableCode(VM&amp; vm) const
217 {
218     if (m_jitCodeForCall
219         || m_jitCodeForConstruct
220         || m_jitCodeForCallWithArityCheck
</pre>
<hr />
<pre>
239     } else if (structure(vm)-&gt;classInfo() == ModuleProgramExecutable::info()) {
240         auto* executable = static_cast&lt;const ModuleProgramExecutable*&gt;(this);
241         if (executable-&gt;m_moduleProgramCodeBlock
242             || executable-&gt;m_unlinkedModuleProgramCodeBlock
243             || executable-&gt;m_moduleEnvironmentSymbolTable)
244             return true;
245     }
246     return false;
247 }
248 
249 CodeBlock* ScriptExecutable::newCodeBlockFor(
250     CodeSpecializationKind kind, JSFunction* function, JSScope* scope, Exception*&amp; exception)
251 {
252     VM&amp; vm = scope-&gt;vm();
253     auto throwScope = DECLARE_THROW_SCOPE(vm);
254 
255     ASSERT(vm.heap.isDeferred());
256     ASSERT(endColumn() != UINT_MAX);
257 
258     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);
<span class="line-removed">259     ExecState* exec = globalObject-&gt;globalExec();</span>
260 
261     if (classInfo(vm) == EvalExecutable::info()) {
262         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
263         RELEASE_ASSERT(kind == CodeForCall);
264         RELEASE_ASSERT(!executable-&gt;m_evalCodeBlock);
265         RELEASE_ASSERT(!function);
266         auto codeBlock = EvalCodeBlock::create(vm,
267             executable, executable-&gt;m_unlinkedEvalCodeBlock.get(), scope);
268         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
269         if (!codeBlock) {
270             exception = throwException(
<span class="line-modified">271                 exec, throwScope,</span>
<span class="line-modified">272                 createOutOfMemoryError(exec));</span>
273             return nullptr;
274         }
275         return codeBlock;
276     }
277 
278     if (classInfo(vm) == ProgramExecutable::info()) {
279         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
280         RELEASE_ASSERT(kind == CodeForCall);
281         RELEASE_ASSERT(!executable-&gt;m_programCodeBlock);
282         RELEASE_ASSERT(!function);
283         auto codeBlock = ProgramCodeBlock::create(vm,
284             executable, executable-&gt;m_unlinkedProgramCodeBlock.get(), scope);
285         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
286         if (!codeBlock) {
287             exception = throwException(
<span class="line-modified">288                 exec, throwScope,</span>
<span class="line-modified">289                 createOutOfMemoryError(exec));</span>
290             return nullptr;
291         }
292         return codeBlock;
293     }
294 
295     if (classInfo(vm) == ModuleProgramExecutable::info()) {
296         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
297         RELEASE_ASSERT(kind == CodeForCall);
298         RELEASE_ASSERT(!executable-&gt;m_moduleProgramCodeBlock);
299         RELEASE_ASSERT(!function);
300         auto codeBlock = ModuleProgramCodeBlock::create(vm,
301             executable, executable-&gt;m_unlinkedModuleProgramCodeBlock.get(), scope);
302         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
303         if (!codeBlock) {
304             exception = throwException(
<span class="line-modified">305                 exec, throwScope,</span>
<span class="line-modified">306                 createOutOfMemoryError(exec));</span>
307             return nullptr;
308         }
309         return codeBlock;
310     }
311 
312     RELEASE_ASSERT(classInfo(vm) == FunctionExecutable::info());
313     RELEASE_ASSERT(function);
314     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
315     RELEASE_ASSERT(!executable-&gt;codeBlockFor(kind));
316     ParserError error;
317     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;defaultCodeGenerationMode();
318     // We continue using the same CodeGenerationMode for Generators because live generator objects can
319     // keep the state which is only valid with the CodeBlock compiled with the same CodeGenerationMode.
320     if (isGeneratorOrAsyncFunctionBodyParseMode(executable-&gt;parseMode())) {
321         if (!m_codeForGeneratorBodyWasGenerated) {
322             m_codeGenerationModeForGeneratorBody = codeGenerationMode;
323             m_codeForGeneratorBodyWasGenerated = true;
324         } else
325             codeGenerationMode = m_codeGenerationModeForGeneratorBody;
326     }
327     UnlinkedFunctionCodeBlock* unlinkedCodeBlock =
328         executable-&gt;m_unlinkedExecutable-&gt;unlinkedCodeBlockFor(
329             vm, executable-&gt;source(), kind, codeGenerationMode, error,
330             executable-&gt;parseMode());
331     recordParse(
332         executable-&gt;m_unlinkedExecutable-&gt;features(),
333         executable-&gt;m_unlinkedExecutable-&gt;hasCapturedVariables(),
334         lastLine(), endColumn());
335     if (!unlinkedCodeBlock) {
336         exception = throwException(
<span class="line-modified">337             globalObject-&gt;globalExec(), throwScope,</span>
338             error.toErrorObject(globalObject, executable-&gt;source()));
339         return nullptr;
340     }
341 
342     RELEASE_AND_RETURN(throwScope, FunctionCodeBlock::create(vm, executable, unlinkedCodeBlock, scope));
343 }
344 
345 CodeBlock* ScriptExecutable::newReplacementCodeBlockFor(
346     CodeSpecializationKind kind)
347 {
348     VM&amp; vm = this-&gt;vm();
349     if (classInfo(vm) == EvalExecutable::info()) {
350         RELEASE_ASSERT(kind == CodeForCall);
351         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
352         EvalCodeBlock* baseline = static_cast&lt;EvalCodeBlock*&gt;(
353             executable-&gt;codeBlock()-&gt;baselineVersion());
354         EvalCodeBlock* result = EvalCodeBlock::create(vm,
355             CodeBlock::CopyParsedBlock, *baseline);
356         result-&gt;setAlternative(vm, baseline);
357         return result;
</pre>
<hr />
<pre>
396 
397 static void setupJIT(VM&amp; vm, CodeBlock* codeBlock)
398 {
399 #if ENABLE(JIT)
400     CompilationResult result = JIT::compile(vm, codeBlock, JITCompilationMustSucceed);
401     RELEASE_ASSERT(result == CompilationSuccessful);
402 #else
403     UNUSED_PARAM(vm);
404     UNUSED_PARAM(codeBlock);
405     UNREACHABLE_FOR_PLATFORM();
406 #endif
407 }
408 
409 Exception* ScriptExecutable::prepareForExecutionImpl(
410     VM&amp; vm, JSFunction* function, JSScope* scope, CodeSpecializationKind kind, CodeBlock*&amp; resultCodeBlock)
411 {
412     auto throwScope = DECLARE_THROW_SCOPE(vm);
413     DeferGCForAWhile deferGC(vm.heap);
414 
415     if (UNLIKELY(vm.getAndClearFailNextNewCodeBlock())) {
<span class="line-modified">416         auto&amp; state = *scope-&gt;globalObject(vm)-&gt;globalExec();</span>
<span class="line-modified">417         return throwException(&amp;state, throwScope, createError(&amp;state, &quot;Forced Failure&quot;_s));</span>
418     }
419 
420     Exception* exception = nullptr;
421     CodeBlock* codeBlock = newCodeBlockFor(kind, function, scope, exception);
422     resultCodeBlock = codeBlock;
423     EXCEPTION_ASSERT(!!throwScope.exception() == !codeBlock);
424     if (UNLIKELY(!codeBlock))
425         return exception;
426 
427     if (Options::validateBytecode())
428         codeBlock-&gt;validate();
429 
430     if (Options::useLLInt())
431         setupLLInt(codeBlock);
432     else
433         setupJIT(vm, codeBlock);
434 
435     installCode(vm, codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());
436     return nullptr;
437 }
438 
439 ScriptExecutable* ScriptExecutable::topLevelExecutable()
440 {
441     switch (type()) {
442     case FunctionExecutableType:
443         return jsCast&lt;FunctionExecutable*&gt;(this)-&gt;topLevelExecutable();
444     default:
445         return this;
446     }
447 }
448 
<span class="line-modified">449 JSArray* ScriptExecutable::createTemplateObject(ExecState* exec, JSTemplateObjectDescriptor* descriptor)</span>
450 {
<span class="line-modified">451     VM&amp; vm = exec-&gt;vm();</span>
452     auto scope = DECLARE_THROW_SCOPE(vm);
453 
454     TemplateObjectMap&amp; templateObjectMap = ensureTemplateObjectMap(vm);
455     TemplateObjectMap::AddResult result;
456     {
457         auto locker = holdLock(cellLock());
458         result = templateObjectMap.add(descriptor-&gt;endOffset(), WriteBarrier&lt;JSArray&gt;());
459     }
460     if (JSArray* array = result.iterator-&gt;value.get())
461         return array;
<span class="line-modified">462     JSArray* templateObject = descriptor-&gt;createTemplateObject(exec);</span>
463     RETURN_IF_EXCEPTION(scope, nullptr);
464     result.iterator-&gt;value.set(vm, this, templateObject);
465     return templateObject;
466 }
467 
468 auto ScriptExecutable::ensureTemplateObjectMapImpl(std::unique_ptr&lt;TemplateObjectMap&gt;&amp; dest) -&gt; TemplateObjectMap&amp;
469 {
470     if (dest)
471         return *dest;
472     auto result = makeUnique&lt;TemplateObjectMap&gt;();
473     WTF::storeStoreFence();
474     dest = WTFMove(result);
475     return *dest;
476 }
477 
478 auto ScriptExecutable::ensureTemplateObjectMap(VM&amp; vm) -&gt; TemplateObjectMap&amp;
479 {
480     switch (type()) {
481     case FunctionExecutableType:
482         return static_cast&lt;FunctionExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);
</pre>
</td>
<td>
<hr />
<pre>
179     case CodeForCall:
180         m_jitCodeForCall = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
181         m_jitCodeForCallWithArityCheck = nullptr;
182         break;
183     case CodeForConstruct:
184         m_jitCodeForConstruct = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
185         m_jitCodeForConstructWithArityCheck = nullptr;
186         break;
187     }
188 
189     auto&amp; clearableCodeSet = VM::SpaceAndSet::setFor(*subspace());
190     if (hasClearableCode(vm))
191         clearableCodeSet.add(this);
192     else
193         clearableCodeSet.remove(this);
194 
195     if (genericCodeBlock) {
196         RELEASE_ASSERT(genericCodeBlock-&gt;ownerExecutable() == this);
197         RELEASE_ASSERT(JITCode::isExecutableScript(genericCodeBlock-&gt;jitType()));
198 
<span class="line-modified">199         dataLogLnIf(Options::verboseOSR(), &quot;Installing &quot;, *genericCodeBlock);</span>

200 
201         if (UNLIKELY(vm.m_perBytecodeProfiler))
202             vm.m_perBytecodeProfiler-&gt;ensureBytecodesFor(genericCodeBlock);
203 
204         Debugger* debugger = genericCodeBlock-&gt;globalObject()-&gt;debugger();
205         if (UNLIKELY(debugger))
206             debugger-&gt;registerCodeBlock(genericCodeBlock);
207     }
208 
209     if (oldCodeBlock)
210         oldCodeBlock-&gt;unlinkIncomingCalls();
211 
212     vm.heap.writeBarrier(this);
213 }
214 
215 bool ScriptExecutable::hasClearableCode(VM&amp; vm) const
216 {
217     if (m_jitCodeForCall
218         || m_jitCodeForConstruct
219         || m_jitCodeForCallWithArityCheck
</pre>
<hr />
<pre>
238     } else if (structure(vm)-&gt;classInfo() == ModuleProgramExecutable::info()) {
239         auto* executable = static_cast&lt;const ModuleProgramExecutable*&gt;(this);
240         if (executable-&gt;m_moduleProgramCodeBlock
241             || executable-&gt;m_unlinkedModuleProgramCodeBlock
242             || executable-&gt;m_moduleEnvironmentSymbolTable)
243             return true;
244     }
245     return false;
246 }
247 
248 CodeBlock* ScriptExecutable::newCodeBlockFor(
249     CodeSpecializationKind kind, JSFunction* function, JSScope* scope, Exception*&amp; exception)
250 {
251     VM&amp; vm = scope-&gt;vm();
252     auto throwScope = DECLARE_THROW_SCOPE(vm);
253 
254     ASSERT(vm.heap.isDeferred());
255     ASSERT(endColumn() != UINT_MAX);
256 
257     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);

258 
259     if (classInfo(vm) == EvalExecutable::info()) {
260         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
261         RELEASE_ASSERT(kind == CodeForCall);
262         RELEASE_ASSERT(!executable-&gt;m_evalCodeBlock);
263         RELEASE_ASSERT(!function);
264         auto codeBlock = EvalCodeBlock::create(vm,
265             executable, executable-&gt;m_unlinkedEvalCodeBlock.get(), scope);
266         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
267         if (!codeBlock) {
268             exception = throwException(
<span class="line-modified">269                 globalObject, throwScope,</span>
<span class="line-modified">270                 createOutOfMemoryError(globalObject));</span>
271             return nullptr;
272         }
273         return codeBlock;
274     }
275 
276     if (classInfo(vm) == ProgramExecutable::info()) {
277         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
278         RELEASE_ASSERT(kind == CodeForCall);
279         RELEASE_ASSERT(!executable-&gt;m_programCodeBlock);
280         RELEASE_ASSERT(!function);
281         auto codeBlock = ProgramCodeBlock::create(vm,
282             executable, executable-&gt;m_unlinkedProgramCodeBlock.get(), scope);
283         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
284         if (!codeBlock) {
285             exception = throwException(
<span class="line-modified">286                 globalObject, throwScope,</span>
<span class="line-modified">287                 createOutOfMemoryError(globalObject));</span>
288             return nullptr;
289         }
290         return codeBlock;
291     }
292 
293     if (classInfo(vm) == ModuleProgramExecutable::info()) {
294         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
295         RELEASE_ASSERT(kind == CodeForCall);
296         RELEASE_ASSERT(!executable-&gt;m_moduleProgramCodeBlock);
297         RELEASE_ASSERT(!function);
298         auto codeBlock = ModuleProgramCodeBlock::create(vm,
299             executable, executable-&gt;m_unlinkedModuleProgramCodeBlock.get(), scope);
300         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
301         if (!codeBlock) {
302             exception = throwException(
<span class="line-modified">303                 globalObject, throwScope,</span>
<span class="line-modified">304                 createOutOfMemoryError(globalObject));</span>
305             return nullptr;
306         }
307         return codeBlock;
308     }
309 
310     RELEASE_ASSERT(classInfo(vm) == FunctionExecutable::info());
311     RELEASE_ASSERT(function);
312     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
313     RELEASE_ASSERT(!executable-&gt;codeBlockFor(kind));
314     ParserError error;
315     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;defaultCodeGenerationMode();
316     // We continue using the same CodeGenerationMode for Generators because live generator objects can
317     // keep the state which is only valid with the CodeBlock compiled with the same CodeGenerationMode.
318     if (isGeneratorOrAsyncFunctionBodyParseMode(executable-&gt;parseMode())) {
319         if (!m_codeForGeneratorBodyWasGenerated) {
320             m_codeGenerationModeForGeneratorBody = codeGenerationMode;
321             m_codeForGeneratorBodyWasGenerated = true;
322         } else
323             codeGenerationMode = m_codeGenerationModeForGeneratorBody;
324     }
325     UnlinkedFunctionCodeBlock* unlinkedCodeBlock =
326         executable-&gt;m_unlinkedExecutable-&gt;unlinkedCodeBlockFor(
327             vm, executable-&gt;source(), kind, codeGenerationMode, error,
328             executable-&gt;parseMode());
329     recordParse(
330         executable-&gt;m_unlinkedExecutable-&gt;features(),
331         executable-&gt;m_unlinkedExecutable-&gt;hasCapturedVariables(),
332         lastLine(), endColumn());
333     if (!unlinkedCodeBlock) {
334         exception = throwException(
<span class="line-modified">335             globalObject, throwScope,</span>
336             error.toErrorObject(globalObject, executable-&gt;source()));
337         return nullptr;
338     }
339 
340     RELEASE_AND_RETURN(throwScope, FunctionCodeBlock::create(vm, executable, unlinkedCodeBlock, scope));
341 }
342 
343 CodeBlock* ScriptExecutable::newReplacementCodeBlockFor(
344     CodeSpecializationKind kind)
345 {
346     VM&amp; vm = this-&gt;vm();
347     if (classInfo(vm) == EvalExecutable::info()) {
348         RELEASE_ASSERT(kind == CodeForCall);
349         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
350         EvalCodeBlock* baseline = static_cast&lt;EvalCodeBlock*&gt;(
351             executable-&gt;codeBlock()-&gt;baselineVersion());
352         EvalCodeBlock* result = EvalCodeBlock::create(vm,
353             CodeBlock::CopyParsedBlock, *baseline);
354         result-&gt;setAlternative(vm, baseline);
355         return result;
</pre>
<hr />
<pre>
394 
395 static void setupJIT(VM&amp; vm, CodeBlock* codeBlock)
396 {
397 #if ENABLE(JIT)
398     CompilationResult result = JIT::compile(vm, codeBlock, JITCompilationMustSucceed);
399     RELEASE_ASSERT(result == CompilationSuccessful);
400 #else
401     UNUSED_PARAM(vm);
402     UNUSED_PARAM(codeBlock);
403     UNREACHABLE_FOR_PLATFORM();
404 #endif
405 }
406 
407 Exception* ScriptExecutable::prepareForExecutionImpl(
408     VM&amp; vm, JSFunction* function, JSScope* scope, CodeSpecializationKind kind, CodeBlock*&amp; resultCodeBlock)
409 {
410     auto throwScope = DECLARE_THROW_SCOPE(vm);
411     DeferGCForAWhile deferGC(vm.heap);
412 
413     if (UNLIKELY(vm.getAndClearFailNextNewCodeBlock())) {
<span class="line-modified">414         JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-modified">415         return throwException(globalObject, throwScope, createError(globalObject, &quot;Forced Failure&quot;_s));</span>
416     }
417 
418     Exception* exception = nullptr;
419     CodeBlock* codeBlock = newCodeBlockFor(kind, function, scope, exception);
420     resultCodeBlock = codeBlock;
421     EXCEPTION_ASSERT(!!throwScope.exception() == !codeBlock);
422     if (UNLIKELY(!codeBlock))
423         return exception;
424 
425     if (Options::validateBytecode())
426         codeBlock-&gt;validate();
427 
428     if (Options::useLLInt())
429         setupLLInt(codeBlock);
430     else
431         setupJIT(vm, codeBlock);
432 
433     installCode(vm, codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());
434     return nullptr;
435 }
436 
437 ScriptExecutable* ScriptExecutable::topLevelExecutable()
438 {
439     switch (type()) {
440     case FunctionExecutableType:
441         return jsCast&lt;FunctionExecutable*&gt;(this)-&gt;topLevelExecutable();
442     default:
443         return this;
444     }
445 }
446 
<span class="line-modified">447 JSArray* ScriptExecutable::createTemplateObject(JSGlobalObject* globalObject, JSTemplateObjectDescriptor* descriptor)</span>
448 {
<span class="line-modified">449     VM&amp; vm = globalObject-&gt;vm();</span>
450     auto scope = DECLARE_THROW_SCOPE(vm);
451 
452     TemplateObjectMap&amp; templateObjectMap = ensureTemplateObjectMap(vm);
453     TemplateObjectMap::AddResult result;
454     {
455         auto locker = holdLock(cellLock());
456         result = templateObjectMap.add(descriptor-&gt;endOffset(), WriteBarrier&lt;JSArray&gt;());
457     }
458     if (JSArray* array = result.iterator-&gt;value.get())
459         return array;
<span class="line-modified">460     JSArray* templateObject = descriptor-&gt;createTemplateObject(globalObject);</span>
461     RETURN_IF_EXCEPTION(scope, nullptr);
462     result.iterator-&gt;value.set(vm, this, templateObject);
463     return templateObject;
464 }
465 
466 auto ScriptExecutable::ensureTemplateObjectMapImpl(std::unique_ptr&lt;TemplateObjectMap&gt;&amp; dest) -&gt; TemplateObjectMap&amp;
467 {
468     if (dest)
469         return *dest;
470     auto result = makeUnique&lt;TemplateObjectMap&gt;();
471     WTF::storeStoreFence();
472     dest = WTFMove(result);
473     return *dest;
474 }
475 
476 auto ScriptExecutable::ensureTemplateObjectMap(VM&amp; vm) -&gt; TemplateObjectMap&amp;
477 {
478     switch (type()) {
479     case FunctionExecutableType:
480         return static_cast&lt;FunctionExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);
</pre>
</td>
</tr>
</table>
<center><a href="ScopedArgumentsTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutable.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
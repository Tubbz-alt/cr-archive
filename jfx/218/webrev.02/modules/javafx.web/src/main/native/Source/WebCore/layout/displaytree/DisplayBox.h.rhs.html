<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;DisplayRect.h&quot;
 31 #include &quot;LayoutUnits.h&quot;
<a name="1" id="anc1"></a>
 32 #include &lt;wtf/IsoMalloc.h&gt;
 33 
 34 namespace WebCore {
<a name="2" id="anc2"></a>













 35 namespace Display {
 36 
 37 class Box {
 38     WTF_MAKE_ISO_ALLOCATED(Box);
 39 public:
<a name="3" id="anc3"></a>









 40     Box(const Box&amp;);
<a name="4" id="anc4"></a><span class="line-added"> 41     Box() = default;</span>
 42     ~Box();
 43 
 44     LayoutUnit top() const;
 45     LayoutUnit left() const;
 46     LayoutUnit bottom() const { return top() + height(); }
 47     LayoutUnit right() const { return left() + width(); }
 48 
 49     LayoutPoint topLeft() const;
 50     LayoutPoint bottomRight() const { return { right(), bottom() }; }
 51 
 52     LayoutSize size() const { return { width(), height() }; }
 53     LayoutUnit width() const { return borderLeft() + paddingBoxWidth() + borderRight(); }
 54     LayoutUnit height() const { return borderTop() + paddingBoxHeight() + borderBottom(); }
<a name="5" id="anc5"></a><span class="line-added"> 55     bool isEmpty() const { return size().isEmpty(); }</span>
 56     Rect rect() const { return { top(), left(), width(), height() }; }
 57     Rect rectWithMargin() const;
 58 
 59     Layout::UsedVerticalMargin verticalMargin() const;
 60     Layout::UsedHorizontalMargin horizontalMargin() const;
 61     LayoutUnit marginBefore() const;
 62     LayoutUnit marginStart() const;
 63     LayoutUnit marginAfter() const;
 64     LayoutUnit marginEnd() const;
 65     bool hasCollapsedThroughMargin() const { return m_verticalMargin.isCollapsedThrough(); }
 66     bool hasClearance() const { return m_hasClearance; }
 67 
 68     LayoutUnit nonCollapsedMarginBefore() const;
 69     LayoutUnit nonCollapsedMarginAfter() const;
 70     Optional&lt;LayoutUnit&gt; computedMarginStart() const;
 71     Optional&lt;LayoutUnit&gt; computedMarginEnd() const;
 72 
 73     LayoutUnit borderTop() const;
 74     LayoutUnit borderLeft() const;
 75     LayoutUnit borderBottom() const;
 76     LayoutUnit borderRight() const;
 77     LayoutUnit verticalBorder() const { return borderTop() + borderBottom(); }
 78     LayoutUnit horizontalBorder() const { return borderLeft() + borderRight(); }
 79 
 80     Optional&lt;LayoutUnit&gt; paddingTop() const;
 81     Optional&lt;LayoutUnit&gt; paddingLeft() const;
 82     Optional&lt;LayoutUnit&gt; paddingBottom() const;
 83     Optional&lt;LayoutUnit&gt; paddingRight() const;
 84     Optional&lt;LayoutUnit&gt; verticalPadding() const;
 85     Optional&lt;LayoutUnit&gt; horizontalPadding() const;
 86 
 87     LayoutUnit contentBoxTop() const { return paddingBoxTop() + paddingTop().valueOr(0); }
 88     LayoutUnit contentBoxLeft() const { return paddingBoxLeft() + paddingLeft().valueOr(0); }
 89     LayoutUnit contentBoxBottom() const { return contentBoxTop() + contentBoxHeight(); }
 90     LayoutUnit contentBoxRight() const { return contentBoxLeft() + contentBoxWidth(); }
 91     LayoutUnit contentBoxHeight() const;
 92     LayoutUnit contentBoxWidth() const;
 93 
 94     LayoutUnit paddingBoxTop() const { return borderTop(); }
 95     LayoutUnit paddingBoxLeft() const { return borderLeft(); }
 96     LayoutUnit paddingBoxBottom() const { return paddingBoxTop() + paddingBoxHeight(); }
 97     LayoutUnit paddingBoxRight() const { return paddingBoxLeft() + paddingBoxWidth(); }
 98     LayoutUnit paddingBoxHeight() const { return paddingTop().valueOr(0) + contentBoxHeight() + paddingBottom().valueOr(0); }
 99     LayoutUnit paddingBoxWidth() const { return paddingLeft().valueOr(0) + contentBoxWidth() + paddingRight().valueOr(0); }
100 
101     LayoutUnit borderBoxHeight() const { return borderTop() + paddingBoxHeight() + borderBottom(); }
102     LayoutUnit borderBoxWidth() const { return borderLeft() + paddingBoxWidth() + borderRight(); }
103     LayoutUnit marginBoxHeight() const { return marginBefore() + borderBoxHeight() + marginAfter(); }
104     LayoutUnit marginBoxWidth() const { return marginStart() + borderBoxWidth() + marginEnd(); }
105 
106     LayoutUnit horizontalMarginBorderAndPadding() const { return marginStart() + horizontalBorder() + horizontalPadding().valueOr(0) + marginEnd(); }
107 
108     Rect marginBox() const;
109     Rect nonCollapsedMarginBox() const;
110 
111     Rect borderBox() const;
112     Rect paddingBox() const;
113     Rect contentBox() const;
114 
<a name="6" id="anc6"></a><span class="line-modified">115 #if ASSERT_ENABLED</span>
<span class="line-modified">116     void setHasPrecomputedMarginBefore() { m_hasPrecomputedMarginBefore = true; }</span>
117 #endif
118 
<a name="7" id="anc7"></a>






119     void setTopLeft(const LayoutPoint&amp;);
120     void setTop(LayoutUnit);
121     void setLeft(LayoutUnit);
122     void moveHorizontally(LayoutUnit offset) { m_topLeft.move(offset, 0_lu); }
123     void moveVertically(LayoutUnit offset) { m_topLeft.move(0_lu, offset); }
<a name="8" id="anc8"></a><span class="line-added">124     void move(const LayoutSize&amp; size) { m_topLeft.move(size); }</span>
<span class="line-added">125     void moveBy(LayoutPoint offset) { m_topLeft.moveBy(offset); }</span>
126 
127     void setContentBoxHeight(LayoutUnit);
128     void setContentBoxWidth(LayoutUnit);
129 
130     void setHorizontalMargin(Layout::UsedHorizontalMargin);
131     void setVerticalMargin(Layout::UsedVerticalMargin);
132     void setHorizontalComputedMargin(Layout::ComputedHorizontalMargin);
133     void setHasClearance() { m_hasClearance = true; }
134 
135     void setBorder(Layout::Edges);
136     void setPadding(Optional&lt;Layout::Edges&gt;);
137 
<a name="9" id="anc9"></a><span class="line-modified">138 private:</span>
<span class="line-added">139 #if ASSERT_ENABLED</span>
140     void invalidateMargin();
141     void invalidateBorder() { m_hasValidBorder = false; }
142     void invalidatePadding() { m_hasValidPadding = false; }
<a name="10" id="anc10"></a><span class="line-modified">143     void invalidatePrecomputedMarginBefore() { m_hasPrecomputedMarginBefore = false; }</span>
144 
145     void setHasValidTop() { m_hasValidTop = true; }
146     void setHasValidLeft() { m_hasValidLeft = true; }
147     void setHasValidVerticalMargin() { m_hasValidVerticalMargin = true; }
148     void setHasValidVerticalNonCollapsedMargin() { m_hasValidVerticalNonCollapsedMargin = true; }
149     void setHasValidHorizontalComputedMargin() { m_hasValidHorizontalComputedMargin = true; }
150     void setHasValidHorizontalMargin() { m_hasValidHorizontalMargin = true; }
151 
152     void setHasValidBorder() { m_hasValidBorder = true; }
153     void setHasValidPadding() { m_hasValidPadding = true; }
154 
155     void setHasValidContentHeight() { m_hasValidContentHeight = true; }
156     void setHasValidContentWidth() { m_hasValidContentWidth = true; }
<a name="11" id="anc11"></a><span class="line-modified">157 #endif // ASSERT_ENABLED</span>


158 
159     LayoutPoint m_topLeft;
160     LayoutUnit m_contentWidth;
161     LayoutUnit m_contentHeight;
162 
163     Layout::UsedHorizontalMargin m_horizontalMargin;
164     Layout::UsedVerticalMargin m_verticalMargin;
165     Layout::ComputedHorizontalMargin m_horizontalComputedMargin;
166     bool m_hasClearance { false };
167 
168     Layout::Edges m_border;
169     Optional&lt;Layout::Edges&gt; m_padding;
170 
<a name="12" id="anc12"></a><span class="line-modified">171 #if ASSERT_ENABLED</span>
172     bool m_hasValidTop { false };
173     bool m_hasValidLeft { false };
174     bool m_hasValidHorizontalMargin { false };
175     bool m_hasValidVerticalMargin { false };
176     bool m_hasValidVerticalNonCollapsedMargin { false };
177     bool m_hasValidHorizontalComputedMargin { false };
178     bool m_hasValidBorder { false };
179     bool m_hasValidPadding { false };
180     bool m_hasValidContentHeight { false };
181     bool m_hasValidContentWidth { false };
<a name="13" id="anc13"></a><span class="line-modified">182     bool m_hasPrecomputedMarginBefore { false };</span>
<span class="line-modified">183 #endif // ASSERT_ENABLED</span>
184 };
185 
<a name="14" id="anc14"></a><span class="line-modified">186 #if ASSERT_ENABLED</span>
187 inline void Box::invalidateMargin()
188 {
189     m_hasValidHorizontalMargin = false;
190     m_hasValidVerticalMargin = false;
191 }
192 #endif
193 
194 inline LayoutUnit Box::top() const
195 {
<a name="15" id="anc15"></a><span class="line-modified">196     ASSERT(m_hasValidTop &amp;&amp; (m_hasPrecomputedMarginBefore || m_hasValidVerticalMargin));</span>
197     return m_topLeft.y();
198 }
199 
200 inline LayoutUnit Box::left() const
201 {
202     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidHorizontalMargin);
203     return m_topLeft.x();
204 }
205 
206 inline LayoutPoint Box::topLeft() const
207 {
<a name="16" id="anc16"></a><span class="line-modified">208     ASSERT(m_hasValidTop &amp;&amp; (m_hasPrecomputedMarginBefore || m_hasValidVerticalMargin));</span>
209     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidHorizontalMargin);
210     return m_topLeft;
211 }
212 
213 inline void Box::setTopLeft(const LayoutPoint&amp; topLeft)
214 {
<a name="17" id="anc17"></a><span class="line-modified">215 #if ASSERT_ENABLED</span>
216     setHasValidTop();
217     setHasValidLeft();
218 #endif
219     m_topLeft = topLeft;
220 }
221 
222 inline void Box::setTop(LayoutUnit top)
223 {
<a name="18" id="anc18"></a><span class="line-modified">224 #if ASSERT_ENABLED</span>
225     setHasValidTop();
226 #endif
227     m_topLeft.setY(top);
228 }
229 
230 inline void Box::setLeft(LayoutUnit left)
231 {
<a name="19" id="anc19"></a><span class="line-modified">232 #if ASSERT_ENABLED</span>
233     setHasValidLeft();
234 #endif
235     m_topLeft.setX(left);
236 }
237 
238 inline void Box::setContentBoxHeight(LayoutUnit height)
239 {
<a name="20" id="anc20"></a><span class="line-modified">240 #if ASSERT_ENABLED</span>
241     setHasValidContentHeight();
242 #endif
243     m_contentHeight = height;
244 }
245 
246 inline void Box::setContentBoxWidth(LayoutUnit width)
247 {
<a name="21" id="anc21"></a><span class="line-modified">248 #if ASSERT_ENABLED</span>
249     setHasValidContentWidth();
250 #endif
251     m_contentWidth = width;
252 }
253 
254 inline LayoutUnit Box::contentBoxHeight() const
255 {
256     ASSERT(m_hasValidContentHeight);
257     return m_contentHeight;
258 }
259 
260 inline LayoutUnit Box::contentBoxWidth() const
261 {
262     ASSERT(m_hasValidContentWidth);
263     return m_contentWidth;
264 }
265 
266 inline void Box::setHorizontalMargin(Layout::UsedHorizontalMargin margin)
267 {
<a name="22" id="anc22"></a><span class="line-modified">268 #if ASSERT_ENABLED</span>
269     setHasValidHorizontalMargin();
270 #endif
271     m_horizontalMargin = margin;
272 }
273 
274 inline void Box::setVerticalMargin(Layout::UsedVerticalMargin margin)
275 {
<a name="23" id="anc23"></a><span class="line-modified">276 #if ASSERT_ENABLED</span>
277     setHasValidVerticalMargin();
278     setHasValidVerticalNonCollapsedMargin();
<a name="24" id="anc24"></a><span class="line-modified">279     invalidatePrecomputedMarginBefore();</span>
280 #endif
281     m_verticalMargin = margin;
282 }
283 
284 inline void Box::setHorizontalComputedMargin(Layout::ComputedHorizontalMargin margin)
285 {
<a name="25" id="anc25"></a><span class="line-modified">286 #if ASSERT_ENABLED</span>
287     setHasValidHorizontalComputedMargin();
288 #endif
289     m_horizontalComputedMargin = margin;
290 }
291 
292 inline void Box::setBorder(Layout::Edges border)
293 {
<a name="26" id="anc26"></a><span class="line-modified">294 #if ASSERT_ENABLED</span>
295     setHasValidBorder();
296 #endif
297     m_border = border;
298 }
299 
300 inline void Box::setPadding(Optional&lt;Layout::Edges&gt; padding)
301 {
<a name="27" id="anc27"></a><span class="line-modified">302 #if ASSERT_ENABLED</span>
303     setHasValidPadding();
304 #endif
305     m_padding = padding;
306 }
307 
308 inline Rect Box::rectWithMargin() const
309 {
310     auto marginAfter = this-&gt;marginAfter();
311     if (m_verticalMargin.collapsedValues().isCollapsedThrough)
312         marginAfter = 0;
313     return { top() - marginBefore(), left() - marginStart(), marginStart() + width() + marginEnd(), marginBefore() + height() + marginAfter };
314 }
315 
316 inline Layout::UsedVerticalMargin Box::verticalMargin() const
317 {
318     ASSERT(m_hasValidVerticalMargin);
319     return m_verticalMargin;
320 }
321 
322 inline Layout::UsedHorizontalMargin Box::horizontalMargin() const
323 {
324     ASSERT(m_hasValidHorizontalMargin);
325     return m_horizontalMargin;
326 }
327 
328 inline LayoutUnit Box::marginBefore() const
329 {
330     ASSERT(m_hasValidVerticalMargin);
331     return m_verticalMargin.before();
332 }
333 
334 inline LayoutUnit Box::marginStart() const
335 {
336     ASSERT(m_hasValidHorizontalMargin);
337     return m_horizontalMargin.start;
338 }
339 
340 inline LayoutUnit Box::marginAfter() const
341 {
342     ASSERT(m_hasValidVerticalMargin);
343     return m_verticalMargin.after();
344 }
345 
346 inline LayoutUnit Box::marginEnd() const
347 {
348     ASSERT(m_hasValidHorizontalMargin);
349     return m_horizontalMargin.end;
350 }
351 
352 inline LayoutUnit Box::nonCollapsedMarginBefore() const
353 {
354     ASSERT(m_hasValidVerticalNonCollapsedMargin);
355     return m_verticalMargin.nonCollapsedValues().before;
356 }
357 
358 inline LayoutUnit Box::nonCollapsedMarginAfter() const
359 {
360     ASSERT(m_hasValidVerticalNonCollapsedMargin);
361     return m_verticalMargin.nonCollapsedValues().after;
362 }
363 
364 inline Optional&lt;LayoutUnit&gt; Box::computedMarginStart() const
365 {
366     ASSERT(m_hasValidHorizontalComputedMargin);
367     return m_horizontalComputedMargin.start;
368 }
369 
370 inline Optional&lt;LayoutUnit&gt; Box::computedMarginEnd() const
371 {
372     ASSERT(m_hasValidHorizontalComputedMargin);
373     return m_horizontalComputedMargin.end;
374 }
375 
376 inline Optional&lt;LayoutUnit&gt; Box::paddingTop() const
377 {
378     ASSERT(m_hasValidPadding);
379     if (!m_padding)
380         return { };
381     return m_padding-&gt;vertical.top;
382 }
383 
384 inline Optional&lt;LayoutUnit&gt; Box::paddingLeft() const
385 {
386     ASSERT(m_hasValidPadding);
387     if (!m_padding)
388         return { };
389     return m_padding-&gt;horizontal.left;
390 }
391 
392 inline Optional&lt;LayoutUnit&gt; Box::paddingBottom() const
393 {
394     ASSERT(m_hasValidPadding);
395     if (!m_padding)
396         return { };
397     return m_padding-&gt;vertical.bottom;
398 }
399 
400 inline Optional&lt;LayoutUnit&gt; Box::paddingRight() const
401 {
402     ASSERT(m_hasValidPadding);
403     if (!m_padding)
404         return { };
405     return m_padding-&gt;horizontal.right;
406 }
407 
408 inline Optional&lt;LayoutUnit&gt; Box::verticalPadding() const
409 {
410     auto paddingTop = this-&gt;paddingTop();
411     auto paddingBottom = this-&gt;paddingBottom();
412     if (!paddingTop &amp;&amp; !paddingBottom)
413         return { };
414     return paddingTop.valueOr(0) + paddingBottom.valueOr(0);
415 }
416 
417 inline Optional&lt;LayoutUnit&gt; Box::horizontalPadding() const
418 {
419     auto paddingLeft = this-&gt;paddingLeft();
420     auto paddingRight = this-&gt;paddingRight();
421     if (!paddingLeft &amp;&amp; !paddingRight)
422         return { };
423     return paddingLeft.valueOr(0) + paddingRight.valueOr(0);
424 }
425 
426 inline LayoutUnit Box::borderTop() const
427 {
428     ASSERT(m_hasValidBorder);
429     return m_border.vertical.top;
430 }
431 
432 inline LayoutUnit Box::borderLeft() const
433 {
434     ASSERT(m_hasValidBorder);
435     return m_border.horizontal.left;
436 }
437 
438 inline LayoutUnit Box::borderBottom() const
439 {
440     ASSERT(m_hasValidBorder);
441     return m_border.vertical.bottom;
442 }
443 
444 inline LayoutUnit Box::borderRight() const
445 {
446     ASSERT(m_hasValidBorder);
447     return m_border.horizontal.right;
448 }
449 
450 }
451 }
452 #endif
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
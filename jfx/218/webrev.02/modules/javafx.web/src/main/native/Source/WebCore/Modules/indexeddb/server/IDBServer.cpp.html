<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBServer.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBRequestData.h&quot;
 32 #include &quot;IDBResultData.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;MemoryIDBBackingStore.h&quot;
 35 #include &quot;SQLiteDatabase.h&quot;
 36 #include &quot;SQLiteDatabaseTracker.h&quot;
 37 #include &quot;SQLiteFileSystem.h&quot;
 38 #include &quot;SQLiteIDBBackingStore.h&quot;
 39 #include &quot;SQLiteStatement.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &quot;StorageQuotaManager.h&quot;
 42 #include &lt;wtf/CrossThreadCopier.h&gt;
 43 #include &lt;wtf/Locker.h&gt;
 44 #include &lt;wtf/MainThread.h&gt;
 45 
 46 namespace WebCore {
 47 namespace IDBServer {
 48 
 49 IDBServer::IDBServer(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, StorageQuotaManagerSpaceRequester&amp;&amp; spaceRequester)
 50     : m_sessionID(sessionID)
 51     , m_spaceRequester(WTFMove(spaceRequester))
 52 {
 53     ASSERT(!isMainThread());
 54     ASSERT(databaseDirectoryPath.isSafeToSendToAnotherThread());
 55 
 56     m_databaseDirectoryPath = databaseDirectoryPath;
 57     upgradeFilesIfNecessary();
 58 }
 59 
 60 IDBServer::~IDBServer()
 61 {
 62     ASSERT(!isMainThread());
 63 }
 64 
 65 void IDBServer::registerConnection(IDBConnectionToClient&amp; connection)
 66 {
 67     ASSERT(!isMainThread());
 68     ASSERT(!m_connectionMap.contains(connection.identifier()));
 69     m_connectionMap.set(connection.identifier(), &amp;connection);
 70 }
 71 
 72 void IDBServer::unregisterConnection(IDBConnectionToClient&amp; connection)
 73 {
 74     ASSERT(!isMainThread());
 75     ASSERT(m_lock.isHeld());
 76     ASSERT(m_connectionMap.contains(connection.identifier()));
 77     ASSERT(m_connectionMap.get(connection.identifier()) == &amp;connection);
 78 
 79     connection.connectionToClientClosed();
 80 
 81     m_connectionMap.remove(connection.identifier());
 82 }
 83 
 84 void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
 85 {
 86     ASSERT(!isMainThread());
 87     ASSERT(m_lock.isHeld());
 88     ASSERT(!m_transactions.contains(transaction.info().identifier()));
 89     m_transactions.set(transaction.info().identifier(), &amp;transaction);
 90 }
 91 
 92 void IDBServer::unregisterTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
 93 {
 94     ASSERT(!isMainThread());
 95     ASSERT(m_lock.isHeld());
 96     ASSERT(m_transactions.contains(transaction.info().identifier()));
 97     ASSERT(m_transactions.get(transaction.info().identifier()) == &amp;transaction);
 98 
 99     m_transactions.remove(transaction.info().identifier());
100 }
101 
102 void IDBServer::registerDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
103 {
104     ASSERT(!m_databaseConnections.contains(connection.identifier()));
105     m_databaseConnections.set(connection.identifier(), &amp;connection);
106 }
107 
108 void IDBServer::unregisterDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
109 {
110     ASSERT(m_databaseConnections.contains(connection.identifier()));
111     m_databaseConnections.remove(connection.identifier());
112 }
113 
114 UniqueIDBDatabase&amp; IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier&amp; identifier)
115 {
116     ASSERT(!isMainThread());
117 
118     auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
119     if (uniqueIDBDatabase.isNewEntry)
120         uniqueIDBDatabase.iterator-&gt;value = makeUnique&lt;UniqueIDBDatabase&gt;(*this, identifier);
121 
122     return *uniqueIDBDatabase.iterator-&gt;value;
123 }
124 
125 std::unique_ptr&lt;IDBBackingStore&gt; IDBServer::createBackingStore(const IDBDatabaseIdentifier&amp; identifier)
126 {
127     ASSERT(!isMainThread());
128 
129     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
130     if (databaseDirectoryPath.isEmpty())
131         return makeUnique&lt;MemoryIDBBackingStore&gt;(m_sessionID, identifier);
132 
133     return makeUnique&lt;SQLiteIDBBackingStore&gt;(m_sessionID, identifier, databaseDirectoryPath);
134 }
135 
136 void IDBServer::openDatabase(const IDBRequestData&amp; requestData)
137 {
138     LOG(IndexedDB, &quot;IDBServer::openDatabase&quot;);
139     ASSERT(!isMainThread());
140     ASSERT(m_lock.isHeld());
141 
142     auto&amp; uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
143 
144     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
145     if (!connection) {
146         // If the connection back to the client is gone, there&#39;s no way to open the database as
147         // well as no way to message back failure.
148         return;
149     }
150 
151     uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
152 }
153 
154 void IDBServer::deleteDatabase(const IDBRequestData&amp; requestData)
155 {
156     LOG(IndexedDB, &quot;IDBServer::deleteDatabase - %s&quot;, requestData.databaseIdentifier().loggingString().utf8().data());
157     ASSERT(!isMainThread());
158     ASSERT(m_lock.isHeld());
159 
160     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
161     if (!connection) {
162         // If the connection back to the client is gone, there&#39;s no way to delete the database as
163         // well as no way to message back failure.
164         return;
165     }
166 
167     auto* database = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
168     if (!database)
169         database = &amp;getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
170 
171     database-&gt;handleDelete(*connection, requestData);
172 }
173 
174 std::unique_ptr&lt;UniqueIDBDatabase&gt; IDBServer::closeAndTakeUniqueIDBDatabase(UniqueIDBDatabase&amp; database)
175 {
176     LOG(IndexedDB, &quot;IDBServer::closeUniqueIDBDatabase&quot;);
177     ASSERT(isMainThread());
178 
179     auto uniquePointer = m_uniqueIDBDatabaseMap.take(database.identifier());
180     ASSERT(uniquePointer);
181 
182     return uniquePointer;
183 }
184 
185 void IDBServer::abortTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
186 {
187     LOG(IndexedDB, &quot;IDBServer::abortTransaction&quot;);
188     ASSERT(!isMainThread());
189     ASSERT(m_lock.isHeld());
190 
191     auto transaction = m_transactions.get(transactionIdentifier);
192     if (!transaction) {
193         // If there is no transaction there is nothing to abort.
194         // We also have no access to a connection over which to message failure-to-abort.
195         return;
196     }
197 
198     transaction-&gt;abort();
199 }
200 
201 void IDBServer::createObjectStore(const IDBRequestData&amp; requestData, const IDBObjectStoreInfo&amp; info)
202 {
203     LOG(IndexedDB, &quot;IDBServer::createObjectStore&quot;);
204     ASSERT(!isMainThread());
205     ASSERT(m_lock.isHeld());
206 
207     auto transaction = m_transactions.get(requestData.transactionIdentifier());
208     if (!transaction)
209         return;
210 
211     ASSERT(transaction-&gt;isVersionChange());
212     transaction-&gt;createObjectStore(requestData, info);
213 }
214 
215 void IDBServer::deleteObjectStore(const IDBRequestData&amp; requestData, const String&amp; objectStoreName)
216 {
217     LOG(IndexedDB, &quot;IDBServer::deleteObjectStore&quot;);
218     ASSERT(!isMainThread());
219     ASSERT(m_lock.isHeld());
220 
221     auto transaction = m_transactions.get(requestData.transactionIdentifier());
222     if (!transaction)
223         return;
224 
225     ASSERT(transaction-&gt;isVersionChange());
226     transaction-&gt;deleteObjectStore(requestData, objectStoreName);
227 }
228 
229 void IDBServer::renameObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; newName)
230 {
231     LOG(IndexedDB, &quot;IDBServer::renameObjectStore&quot;);
232     ASSERT(!isMainThread());
233     ASSERT(m_lock.isHeld());
234 
235     auto transaction = m_transactions.get(requestData.transactionIdentifier());
236     if (!transaction)
237         return;
238 
239     ASSERT(transaction-&gt;isVersionChange());
240     transaction-&gt;renameObjectStore(requestData, objectStoreIdentifier, newName);
241 }
242 
243 void IDBServer::clearObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier)
244 {
245     LOG(IndexedDB, &quot;IDBServer::clearObjectStore&quot;);
246     ASSERT(!isMainThread());
247     ASSERT(m_lock.isHeld());
248 
249     auto transaction = m_transactions.get(requestData.transactionIdentifier());
250     if (!transaction)
251         return;
252 
253     transaction-&gt;clearObjectStore(requestData, objectStoreIdentifier);
254 }
255 
256 void IDBServer::createIndex(const IDBRequestData&amp; requestData, const IDBIndexInfo&amp; info)
257 {
258     LOG(IndexedDB, &quot;IDBServer::createIndex&quot;);
259     ASSERT(!isMainThread());
260     ASSERT(m_lock.isHeld());
261 
262     auto transaction = m_transactions.get(requestData.transactionIdentifier());
263     if (!transaction)
264         return;
265 
266     ASSERT(transaction-&gt;isVersionChange());
267     transaction-&gt;createIndex(requestData, info);
268 }
269 
270 void IDBServer::deleteIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; indexName)
271 {
272     LOG(IndexedDB, &quot;IDBServer::deleteIndex&quot;);
273     ASSERT(!isMainThread());
274     ASSERT(m_lock.isHeld());
275 
276     auto transaction = m_transactions.get(requestData.transactionIdentifier());
277     if (!transaction)
278         return;
279 
280     ASSERT(transaction-&gt;isVersionChange());
281     transaction-&gt;deleteIndex(requestData, objectStoreIdentifier, indexName);
282 }
283 
284 void IDBServer::renameIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
285 {
286     LOG(IndexedDB, &quot;IDBServer::renameIndex&quot;);
287     ASSERT(!isMainThread());
288     ASSERT(m_lock.isHeld());
289 
290     auto transaction = m_transactions.get(requestData.transactionIdentifier());
291     if (!transaction)
292         return;
293 
294     ASSERT(transaction-&gt;isVersionChange());
295     transaction-&gt;renameIndex(requestData, objectStoreIdentifier, indexIdentifier, newName);
296 }
297 
298 void IDBServer::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
299 {
300     LOG(IndexedDB, &quot;IDBServer::putOrAdd&quot;);
301     ASSERT(!isMainThread());
302     ASSERT(m_lock.isHeld());
303 
304     auto transaction = m_transactions.get(requestData.transactionIdentifier());
305     if (!transaction)
306         return;
307 
308     transaction-&gt;putOrAdd(requestData, keyData, value, overwriteMode);
309 }
310 
311 void IDBServer::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData)
312 {
313     LOG(IndexedDB, &quot;IDBServer::getRecord&quot;);
314     ASSERT(!isMainThread());
315     ASSERT(m_lock.isHeld());
316 
317     auto transaction = m_transactions.get(requestData.transactionIdentifier());
318     if (!transaction)
319         return;
320 
321     transaction-&gt;getRecord(requestData, getRecordData);
322 }
323 
324 void IDBServer::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData)
325 {
326     LOG(IndexedDB, &quot;IDBServer::getAllRecords&quot;);
327     ASSERT(!isMainThread());
328     ASSERT(m_lock.isHeld());
329 
330     auto transaction = m_transactions.get(requestData.transactionIdentifier());
331     if (!transaction)
332         return;
333 
334     transaction-&gt;getAllRecords(requestData, getAllRecordsData);
335 }
336 
337 void IDBServer::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
338 {
339     LOG(IndexedDB, &quot;IDBServer::getCount&quot;);
340     ASSERT(!isMainThread());
341     ASSERT(m_lock.isHeld());
342 
343     auto transaction = m_transactions.get(requestData.transactionIdentifier());
344     if (!transaction)
345         return;
346 
347     transaction-&gt;getCount(requestData, keyRangeData);
348 }
349 
350 void IDBServer::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
351 {
352     LOG(IndexedDB, &quot;IDBServer::deleteRecord&quot;);
353     ASSERT(!isMainThread());
354     ASSERT(m_lock.isHeld());
355 
356     auto transaction = m_transactions.get(requestData.transactionIdentifier());
357     if (!transaction)
358         return;
359 
360     transaction-&gt;deleteRecord(requestData, keyRangeData);
361 }
362 
363 void IDBServer::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info)
364 {
365     LOG(IndexedDB, &quot;IDBServer::openCursor&quot;);
366     ASSERT(!isMainThread());
367     ASSERT(m_lock.isHeld());
368 
369     auto transaction = m_transactions.get(requestData.transactionIdentifier());
370     if (!transaction)
371         return;
372 
373     transaction-&gt;openCursor(requestData, info);
374 }
375 
376 void IDBServer::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data)
377 {
378     LOG(IndexedDB, &quot;IDBServer::iterateCursor&quot;);
379     ASSERT(!isMainThread());
380     ASSERT(m_lock.isHeld());
381 
382     auto transaction = m_transactions.get(requestData.transactionIdentifier());
383     if (!transaction)
384         return;
385 
386     transaction-&gt;iterateCursor(requestData, data);
387 }
388 
389 void IDBServer::establishTransaction(uint64_t databaseConnectionIdentifier, const IDBTransactionInfo&amp; info)
390 {
391     LOG(IndexedDB, &quot;IDBServer::establishTransaction&quot;);
392     ASSERT(!isMainThread());
393     ASSERT(m_lock.isHeld());
394 
395     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
396     if (!databaseConnection)
397         return;
398 
399     databaseConnection-&gt;establishTransaction(info);
400 }
401 
402 void IDBServer::commitTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
403 {
404     LOG(IndexedDB, &quot;IDBServer::commitTransaction&quot;);
405     ASSERT(!isMainThread());
406     ASSERT(m_lock.isHeld());
407 
408     auto transaction = m_transactions.get(transactionIdentifier);
409     if (!transaction) {
410         // If there is no transaction there is nothing to commit.
411         // We also have no access to a connection over which to message failure-to-commit.
412         return;
413     }
414 
415     transaction-&gt;commit();
416 }
417 
418 void IDBServer::didFinishHandlingVersionChangeTransaction(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
419 {
420     LOG(IndexedDB, &quot;IDBServer::didFinishHandlingVersionChangeTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
421     ASSERT(!isMainThread());
422     ASSERT(m_lock.isHeld());
423 
424     auto* connection = m_databaseConnections.get(databaseConnectionIdentifier);
425     if (!connection)
426         return;
427 
428     connection-&gt;didFinishHandlingVersionChange(transactionIdentifier);
429 }
430 
431 void IDBServer::databaseConnectionPendingClose(uint64_t databaseConnectionIdentifier)
432 {
433     LOG(IndexedDB, &quot;IDBServer::databaseConnectionPendingClose - %&quot; PRIu64, databaseConnectionIdentifier);
434     ASSERT(!isMainThread());
435     ASSERT(m_lock.isHeld());
436 
437     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
438     if (!databaseConnection)
439         return;
440 
441     databaseConnection-&gt;connectionPendingCloseFromClient();
442 }
443 
444 void IDBServer::databaseConnectionClosed(uint64_t databaseConnectionIdentifier)
445 {
446     LOG(IndexedDB, &quot;IDBServer::databaseConnectionClosed - %&quot; PRIu64, databaseConnectionIdentifier);
447     ASSERT(!isMainThread());
448     ASSERT(m_lock.isHeld());
449 
450     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
451     if (!databaseConnection)
452         return;
453 
454     databaseConnection-&gt;connectionClosedFromClient();
455 }
456 
457 void IDBServer::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
458 {
459     LOG(IndexedDB, &quot;IDBServer::abortOpenAndUpgradeNeeded&quot;);
460     ASSERT(!isMainThread());
461     ASSERT(m_lock.isHeld());
462 
463     auto transaction = m_transactions.get(transactionIdentifier);
464     if (transaction)
465         transaction-&gt;abortWithoutCallback();
466 
467     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
468     if (!databaseConnection)
469         return;
470 
471     databaseConnection-&gt;connectionClosedFromClient();
472 }
473 
474 void IDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosed)
475 {
476     LOG(IndexedDB, &quot;IDBServer::didFireVersionChangeEvent&quot;);
477     ASSERT(!isMainThread());
478     ASSERT(m_lock.isHeld());
479 
480     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
481         databaseConnection-&gt;didFireVersionChangeEvent(requestIdentifier, connectionClosed);
482 }
483 
484 void IDBServer::openDBRequestCancelled(const IDBRequestData&amp; requestData)
485 {
486     LOG(IndexedDB, &quot;IDBServer::openDBRequestCancelled&quot;);
487     ASSERT(!isMainThread());
488     ASSERT(m_lock.isHeld());
489 
490     auto* uniqueIDBDatabase = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
491     if (!uniqueIDBDatabase)
492         return;
493 
494     uniqueIDBDatabase-&gt;openDBRequestCancelled(requestData.requestIdentifier());
495 }
496 
497 void IDBServer::getAllDatabaseNames(IDBConnectionIdentifier serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)
498 {
499     ASSERT(!isMainThread());
500     ASSERT(m_lock.isHeld());
501 
502     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
503     String oldDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v0&quot;);
504     Vector&lt;String&gt; files = FileSystem::listDirectory(oldDirectory, &quot;*&quot;_s);
505     Vector&lt;String&gt; databases;
506     for (auto&amp; file : files) {
507         String encodedName = FileSystem::lastComponentOfPathIgnoringTrailingSlash(file);
508         databases.append(SQLiteIDBBackingStore::databaseNameFromEncodedFilename(encodedName));
509     }
510 
511     String directory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v1&quot;);
512     files = FileSystem::listDirectory(directory, &quot;*&quot;_s);
513     for (auto&amp; file : files) {
514         auto databaseName = SQLiteIDBBackingStore::databaseNameFromFile(SQLiteIDBBackingStore::fullDatabasePathForDirectory(file));
515         if (!databaseName.isEmpty())
516             databases.append(databaseName);
517     }
518 
519     auto connection = m_connectionMap.get(serverConnectionIdentifier);
520     if (!connection)
521         return;
522 
523     connection-&gt;didGetAllDatabaseNames(callbackID, databases);
524 }
525 
526 void IDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime)
527 {
528     ASSERT(!isMainThread());
529     ASSERT(m_lock.isHeld());
530 
531     // If the modification time is in the future, don&#39;t both doing anything.
532     if (modificationTime &gt; WallTime::now())
533         return;
534 
535     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
536     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
537         database-&gt;immediateCloseForUserDelete();
538 
539     m_uniqueIDBDatabaseMap.clear();
540 
541     if (!m_databaseDirectoryPath.isEmpty()) {
542         removeDatabasesModifiedSinceForVersion(modificationTime, &quot;v0&quot;);
543         removeDatabasesModifiedSinceForVersion(modificationTime, &quot;v1&quot;);
544     }
545 }
546 
547 void IDBServer::closeAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins)
548 {
549     ASSERT(!isMainThread());
550     ASSERT(m_lock.isHeld());
551 
552     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
553     for (auto&amp; database : m_uniqueIDBDatabaseMap.values()) {
554         const auto&amp; identifier = database-&gt;identifier();
555         for (auto&amp; origin : origins) {
556             if (identifier.isRelatedToOrigin(origin)) {
557                 openDatabases.add(database.get());
558                 break;
559             }
560         }
561     }
562 
563     for (auto&amp; database : openDatabases) {
564         database-&gt;immediateCloseForUserDelete();
565         m_uniqueIDBDatabaseMap.remove(database-&gt;identifier());
566     }
567 
568     if (!m_databaseDirectoryPath.isEmpty()) {
569         removeDatabasesWithOriginsForVersion(origins, &quot;v0&quot;);
570         removeDatabasesWithOriginsForVersion(origins, &quot;v1&quot;);
571     }
572 }
573 
574 static void removeAllDatabasesForFullOriginPath(const String&amp; originPath, WallTime modifiedSince)
575 {
576     LOG(IndexedDB, &quot;removeAllDatabasesForOriginPath with originPath %s&quot;, originPath.utf8().data());
577     Vector&lt;String&gt; databasePaths = FileSystem::listDirectory(originPath, &quot;*&quot;);
578 
579     for (auto&amp; databasePath : databasePaths) {
580         String databaseFile = FileSystem::pathByAppendingComponent(databasePath, &quot;IndexedDB.sqlite3&quot;);
581         if (modifiedSince &gt; -WallTime::infinity() &amp;&amp; FileSystem::fileExists(databaseFile)) {
582             auto modificationTime = FileSystem::getFileModificationTime(databaseFile);
583             if (!modificationTime)
584                 continue;
585 
586             if (modificationTime.value() &lt; modifiedSince)
587                 continue;
588         }
589 
590         // Deleting this database means we need to delete all files that represent it.
591         // This includes:
592         //     - The directory itself, which is named after the database.
593         //     - IndexedDB.sqlite3 and related SQLite files.
594         //     - Blob files that we stored in the directory.
595         //
596         // To be conservative, we should *not* try to delete files that are unexpected;
597         // We should only delete files we think we put there.
598         //
599         // IndexedDB blob files are named &quot;N.blob&quot; where N is a decimal integer,
600         // so those are the only blob files we should be trying to delete.
601         for (auto&amp; blobPath : FileSystem::listDirectory(databasePath, &quot;[0-9]*.blob&quot;)) {
602             // Globbing can&#39;t give us only filenames starting with 1-or-more digits.
603             // The above globbing gives us files that start with a digit and ends with &quot;.blob&quot;, but there might be non-digits in between.
604             // We need to validate that each filename contains only digits before deleting it, as any other files are not ones we put there.
605             String filename = FileSystem::pathGetFileName(blobPath);
606             auto filenameLength = filename.length();
607 
608             ASSERT(filenameLength &gt;= 6);
609             ASSERT(filename.endsWith(&quot;.blob&quot;));
610 
611             if (filename.length() &lt; 6)
612                 continue;
613             if (!filename.endsWith(&quot;.blob&quot;))
614                 continue;
615 
616             bool validFilename = true;
617             for (unsigned i = 0; i &lt; filenameLength - 5; ++i) {
618                 if (!isASCIIDigit(filename[i])) {
619                     validFilename = false;
620                     break;
621                 }
622             }
623 
624             if (validFilename)
625                 FileSystem::deleteFile(blobPath);
626         }
627 
628         // Now delete IndexedDB.sqlite3 and related SQLite files.
629         SQLiteFileSystem::deleteDatabaseFile(databaseFile);
630 
631         // And finally, if we can, delete the empty directory.
632         FileSystem::deleteEmptyDirectory(databasePath);
633     }
634 
635     // If no databases remain for this origin, we can delete the origin directory as well.
636     FileSystem::deleteEmptyDirectory(originPath);
637 }
638 
639 static void removeAllDatabasesForOriginPath(const String&amp; originPath, WallTime modifiedSince)
640 {
641     String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(originPath);
642     if (!SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
643         return;
644 
645     auto directories = FileSystem::listDirectory(originPath, &quot;*&quot;_s);
646     for (auto&amp; directory : directories) {
647         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(directory);
648         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
649             removeAllDatabasesForFullOriginPath(directory, modifiedSince);
650     }
651 
652     removeAllDatabasesForFullOriginPath(originPath, modifiedSince);
653 }
654 
655 void IDBServer::removeDatabasesModifiedSinceForVersion(WallTime modifiedSince, const String&amp; version)
656 {
657     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
658     for (auto&amp; originPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {
659         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(originPath);
660         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
661             removeAllDatabasesForOriginPath(originPath, modifiedSince);
662     }
663 }
664 
665 void IDBServer::removeDatabasesWithOriginsForVersion(const Vector&lt;SecurityOriginData&gt; &amp;origins, const String&amp; version)
666 {
667     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
668     for (const auto&amp; origin : origins) {
669         String originPath = FileSystem::pathByAppendingComponent(versionPath, origin.databaseIdentifier());
670         removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
671 
672         for (auto&amp; topOriginPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {
673             originPath = FileSystem::pathByAppendingComponent(topOriginPath, origin.databaseIdentifier());
674             removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
675         }
676     }
677 }
678 
679 StorageQuotaManager::Decision IDBServer::requestSpace(const ClientOrigin&amp; origin, uint64_t taskSize)
680 {
681     ASSERT(!isMainThread());
682     ASSERT(m_lock.isHeld());
683 
684     StorageQuotaManager::Decision result = StorageQuotaManager::Decision::Deny;
685 
686     // Release lock because space requesting could be blocked.
687     m_lock.unlock();
688     result = m_spaceRequester(origin, taskSize);
689     m_lock.lock();
690 
691     return result;
692 }
693 
694 uint64_t IDBServer::diskUsage(const String&amp; rootDirectory, const ClientOrigin&amp; origin)
695 {
696     ASSERT(!isMainThread());
697 
698     auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, &quot;v0&quot;_str);
699     auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, &quot;v1&quot;_str);
700     return SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);
701 }
702 
703 void IDBServer::upgradeFilesIfNecessary()
704 {
705     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
706     if (databaseDirectoryPath.isEmpty() || !FileSystem::fileExists(databaseDirectoryPath))
707         return;
708 
709     String newVersionDirectory = FileSystem::pathByAppendingComponent(databaseDirectoryPath, &quot;v1&quot;);
710     if (!FileSystem::fileExists(newVersionDirectory))
711         FileSystem::makeAllDirectories(newVersionDirectory);
712 }
713 
714 void IDBServer::stopDatabaseActivitiesOnMainThread()
715 {
716     ASSERT(isMainThread());
717     ASSERT(m_lock.isHeld());
718 
719     // Only stop non-ephemeral IDBServers that can hold locked database files.
720     if (m_sessionID.isEphemeral())
721         return;
722 
723     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
724         database-&gt;abortActiveTransactions();
725 }
726 
727 } // namespace IDBServer
728 } // namespace WebCore
729 
730 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
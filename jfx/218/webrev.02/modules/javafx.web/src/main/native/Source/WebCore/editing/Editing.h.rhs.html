<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2006, 2008, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Position.h&quot;
 29 #include &lt;wtf/Forward.h&gt;
<a name="1" id="anc1"></a><span class="line-added"> 30 #include &lt;wtf/HashSet.h&gt;</span>
 31 #include &lt;wtf/unicode/CharacterNames.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 class Document;
 36 class HTMLElement;
<a name="2" id="anc2"></a><span class="line-added"> 37 class HTMLImageElement;</span>
 38 class HTMLSpanElement;
 39 class HTMLTextFormControlElement;
 40 class RenderBlock;
 41 class VisiblePosition;
 42 class VisibleSelection;
 43 
 44 // -------------------------------------------------------------------------
 45 // Node
 46 // -------------------------------------------------------------------------
 47 
 48 ContainerNode* highestEditableRoot(const Position&amp;, EditableType = ContentIsEditable);
 49 
 50 Node* highestEnclosingNodeOfType(const Position&amp;, bool (*nodeIsOfType)(const Node*), EditingBoundaryCrossingRule = CannotCrossEditingBoundary, Node* stayWithin = nullptr);
 51 Node* highestNodeToRemoveInPruning(Node*);
 52 Element* lowestEditableAncestor(Node*);
 53 
 54 Element* deprecatedEnclosingBlockFlowElement(Node*); // Use enclosingBlock instead.
 55 Element* enclosingBlock(Node*, EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
 56 Element* enclosingTableCell(const Position&amp;);
 57 Node* enclosingEmptyListItem(const VisiblePosition&amp;);
 58 Element* enclosingAnchorElement(const Position&amp;);
 59 Element* enclosingElementWithTag(const Position&amp;, const QualifiedName&amp;);
 60 Node* enclosingNodeOfType(const Position&amp;, bool (*nodeIsOfType)(const Node*), EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
 61 HTMLSpanElement* tabSpanNode(const Node*);
 62 Element* isLastPositionBeforeTable(const VisiblePosition&amp;); // FIXME: Strange to name this isXXX, but return an element.
 63 Element* isFirstPositionAfterTable(const VisiblePosition&amp;); // FIXME: Strange to name this isXXX, but return an element.
 64 
 65 // These two deliver leaf nodes as if the whole DOM tree were a linear chain of its leaf nodes.
 66 Node* nextLeafNode(const Node*);
 67 Node* previousLeafNode(const Node*);
 68 
 69 WEBCORE_EXPORT int lastOffsetForEditing(const Node&amp;);
 70 int caretMinOffset(const Node&amp;);
 71 int caretMaxOffset(const Node&amp;);
 72 
 73 bool hasEditableStyle(const Node&amp;, EditableType);
 74 bool isEditableNode(const Node&amp;);
 75 
 76 // FIXME: editingIgnoresContent, canHaveChildrenForEditing, and isAtomicNode should be named to clarify how they differ.
 77 
 78 // Returns true for nodes that either have no content, or have content that is ignored (skipped over) while editing.
 79 // There are no VisiblePositions inside these nodes.
 80 bool editingIgnoresContent(const Node&amp;);
 81 
 82 bool canHaveChildrenForEditing(const Node&amp;);
 83 bool isAtomicNode(const Node*);
 84 
 85 bool isBlock(const Node*);
 86 bool isBlockFlowElement(const Node&amp;);
 87 bool isInline(const Node*);
 88 bool isTabSpanNode(const Node*);
 89 bool isTabSpanTextNode(const Node*);
 90 bool isMailBlockquote(const Node*);
 91 bool isRenderedTable(const Node*);
 92 bool isTableCell(const Node*);
 93 bool isEmptyTableCell(const Node*);
 94 bool isTableStructureNode(const Node*);
 95 bool isListHTMLElement(Node*);
 96 bool isListItem(const Node*);
 97 bool isNodeRendered(const Node&amp;);
 98 bool isRenderedAsNonInlineTableImageOrHR(const Node*);
 99 bool isNonTableCellHTMLBlockElement(const Node*);
100 
101 bool isNodeVisiblyContainedWithin(Node&amp;, const Range&amp;);
102 
103 bool areIdenticalElements(const Node&amp;, const Node&amp;);
104 
105 bool positionBeforeOrAfterNodeIsCandidate(Node&amp;);
106 
<a name="3" id="anc3"></a><span class="line-added">107 WEBCORE_EXPORT HashSet&lt;RefPtr&lt;HTMLImageElement&gt;&gt; visibleImageElementsInRangeWithNonLoadedImages(const Range&amp;);</span>
<span class="line-added">108 </span>
109 // -------------------------------------------------------------------------
110 // Position
111 // -------------------------------------------------------------------------
112 
113 Position nextCandidate(const Position&amp;);
114 Position previousCandidate(const Position&amp;);
115 
116 Position nextVisuallyDistinctCandidate(const Position&amp;);
117 Position previousVisuallyDistinctCandidate(const Position&amp;);
118 
119 Position positionBeforeContainingSpecialElement(const Position&amp;, HTMLElement** containingSpecialElement = nullptr);
120 Position positionAfterContainingSpecialElement(const Position&amp;, HTMLElement** containingSpecialElement = nullptr);
121 
122 Position firstPositionInOrBeforeNode(Node*);
123 Position lastPositionInOrAfterNode(Node*);
124 
125 Position firstEditablePositionAfterPositionInRoot(const Position&amp;, ContainerNode* root);
126 Position lastEditablePositionBeforePositionInRoot(const Position&amp;, ContainerNode* root);
127 
128 WEBCORE_EXPORT int comparePositions(const Position&amp;, const Position&amp;);
129 
130 WEBCORE_EXPORT bool isEditablePosition(const Position&amp;, EditableType = ContentIsEditable);
131 bool isRichlyEditablePosition(const Position&amp;);
132 bool lineBreakExistsAtPosition(const Position&amp;);
133 bool isAtUnsplittableElement(const Position&amp;);
134 
135 unsigned numEnclosingMailBlockquotes(const Position&amp;);
136 void updatePositionForNodeRemoval(Position&amp;, Node&amp;);
137 
138 WEBCORE_EXPORT TextDirection directionOfEnclosingBlock(const Position&amp;);
139 
140 // -------------------------------------------------------------------------
141 // VisiblePosition
142 // -------------------------------------------------------------------------
143 
144 VisiblePosition visiblePositionBeforeNode(Node&amp;);
145 VisiblePosition visiblePositionAfterNode(Node&amp;);
146 
147 bool lineBreakExistsAtVisiblePosition(const VisiblePosition&amp;);
148 
149 WEBCORE_EXPORT int comparePositions(const VisiblePosition&amp;, const VisiblePosition&amp;);
150 
151 WEBCORE_EXPORT int indexForVisiblePosition(const VisiblePosition&amp;, RefPtr&lt;ContainerNode&gt;&amp; scope);
152 int indexForVisiblePosition(Node&amp;, const VisiblePosition&amp;, bool forSelectionPreservation);
153 WEBCORE_EXPORT VisiblePosition visiblePositionForPositionWithOffset(const VisiblePosition&amp;, int offset);
154 WEBCORE_EXPORT VisiblePosition visiblePositionForIndex(int index, ContainerNode* scope);
155 VisiblePosition visiblePositionForIndexUsingCharacterIterator(Node&amp;, int index); // FIXME: Why do we need this version?
156 
157 // -------------------------------------------------------------------------
158 // HTMLElement
159 // -------------------------------------------------------------------------
160 
161 WEBCORE_EXPORT Ref&lt;HTMLElement&gt; createDefaultParagraphElement(Document&amp;);
162 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp;, const QualifiedName&amp;);
163 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp;, const AtomString&amp;);
164 
165 WEBCORE_EXPORT HTMLElement* enclosingList(Node*);
166 HTMLElement* outermostEnclosingList(Node*, Node* rootList = nullptr);
167 Node* enclosingListChild(Node*);
168 
169 // -------------------------------------------------------------------------
170 // Element
171 // -------------------------------------------------------------------------
172 
173 Ref&lt;Element&gt; createTabSpanElement(Document&amp;);
174 Ref&lt;Element&gt; createTabSpanElement(Document&amp;, const String&amp; tabText);
175 Ref&lt;Element&gt; createBlockPlaceholderElement(Document&amp;);
176 
177 Element* editableRootForPosition(const Position&amp;, EditableType = ContentIsEditable);
178 Element* unsplittableElementForPosition(const Position&amp;);
179 
180 bool canMergeLists(Element* firstList, Element* secondList);
181 
182 // -------------------------------------------------------------------------
183 // VisibleSelection
184 // -------------------------------------------------------------------------
185 
186 VisibleSelection selectionForParagraphIteration(const VisibleSelection&amp;);
187 Position adjustedSelectionStartForStyleComputation(const VisibleSelection&amp;);
188 
189 // -------------------------------------------------------------------------
190 
191 // FIXME: This is only one of many definitions of whitespace. Possibly never the right one to use.
192 bool deprecatedIsEditingWhitespace(UChar);
193 
194 // FIXME: Can&#39;t answer this question correctly without being passed the white-space mode.
195 bool deprecatedIsCollapsibleWhitespace(UChar);
196 
197 bool isAmbiguousBoundaryCharacter(UChar);
198 
199 String stringWithRebalancedWhitespace(const String&amp;, bool startIsStartOfParagraph, bool endIsEndOfParagraph);
200 const String&amp; nonBreakingSpaceString();
201 
202 // Miscellaneous functions for caret rendering.
203 
204 RenderBlock* rendererForCaretPainting(Node*);
205 LayoutRect localCaretRectInRendererForCaretPainting(const VisiblePosition&amp;, RenderBlock*&amp;);
206 LayoutRect localCaretRectInRendererForRect(LayoutRect&amp;, Node*, RenderObject*, RenderBlock*&amp;);
207 IntRect absoluteBoundsForLocalCaretRect(RenderBlock* rendererForCaretPainting, const LayoutRect&amp;, bool* insideFixed = nullptr);
208 
209 // -------------------------------------------------------------------------
210 
211 inline bool deprecatedIsEditingWhitespace(UChar c)
212 {
213     return c == noBreakSpace || c == &#39; &#39; || c == &#39;\n&#39; || c == &#39;\t&#39;;
214 }
215 
216 // FIXME: Can&#39;t really answer this question correctly without knowing the white-space mode.
217 inline bool deprecatedIsCollapsibleWhitespace(UChar c)
218 {
219     return c == &#39; &#39; || c == &#39;\n&#39;;
220 }
221 
222 bool isAmbiguousBoundaryCharacter(UChar);
223 
224 inline bool editingIgnoresContent(const Node&amp; node)
225 {
226     return !node.canContainRangeEndPoint();
227 }
228 
229 inline bool positionBeforeOrAfterNodeIsCandidate(Node&amp; node)
230 {
231     return isRenderedTable(&amp;node) || editingIgnoresContent(node);
232 }
233 
234 inline Position firstPositionInOrBeforeNode(Node* node)
235 {
236     if (!node)
237         return { };
238     return editingIgnoresContent(*node) ? positionBeforeNode(node) : firstPositionInNode(node);
239 }
240 
241 inline Position lastPositionInOrAfterNode(Node* node)
242 {
243     if (!node)
244         return { };
245     return editingIgnoresContent(*node) ? positionAfterNode(node) : lastPositionInNode(node);
246 }
247 
248 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
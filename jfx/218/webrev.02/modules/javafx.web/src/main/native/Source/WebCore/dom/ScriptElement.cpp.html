<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  6  * Copyright (C) 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;ScriptElement.h&quot;
 26 
 27 #include &quot;CachedResourceLoader.h&quot;
 28 #include &quot;CachedResourceRequest.h&quot;
 29 #include &quot;CachedScript.h&quot;
 30 #include &quot;ContentSecurityPolicy.h&quot;
 31 #include &quot;CrossOriginAccessControl.h&quot;
 32 #include &quot;CurrentScriptIncrementer.h&quot;
 33 #include &quot;Event.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;HTMLNames.h&quot;
 38 #include &quot;HTMLParserIdioms.h&quot;
 39 #include &quot;IgnoreDestructiveWriteCountIncrementer.h&quot;
 40 #include &quot;InlineClassicScript.h&quot;
 41 #include &quot;LoadableClassicScript.h&quot;
 42 #include &quot;LoadableModuleScript.h&quot;
 43 #include &quot;MIMETypeRegistry.h&quot;
 44 #include &quot;PendingScript.h&quot;
 45 #include &quot;RuntimeApplicationChecks.h&quot;
 46 #include &quot;SVGScriptElement.h&quot;
 47 #include &quot;ScriptController.h&quot;
 48 #include &quot;ScriptDisallowedScope.h&quot;
 49 #include &quot;ScriptRunner.h&quot;
 50 #include &quot;ScriptSourceCode.h&quot;
 51 #include &quot;ScriptableDocumentParser.h&quot;
 52 #include &quot;Settings.h&quot;
 53 #include &quot;TextNodeTraversal.h&quot;
 54 #include &lt;wtf/StdLibExtras.h&gt;
 55 #include &lt;wtf/text/StringBuilder.h&gt;
 56 #include &lt;wtf/text/StringHash.h&gt;
 57 
 58 namespace WebCore {
 59 
 60 static const auto maxUserGesturePropagationTime = 1_s;
 61 
 62 ScriptElement::ScriptElement(Element&amp; element, bool parserInserted, bool alreadyStarted)
 63     : m_element(element)
 64     , m_startLineNumber(WTF::OrdinalNumber::beforeFirst())
 65     , m_parserInserted(parserInserted)
 66     , m_isExternalScript(false)
 67     , m_alreadyStarted(alreadyStarted)
 68     , m_haveFiredLoad(false)
 69     , m_errorOccurred(false)
 70     , m_willBeParserExecuted(false)
 71     , m_readyToBeParserExecuted(false)
 72     , m_willExecuteWhenDocumentFinishedParsing(false)
 73     , m_forceAsync(!parserInserted)
 74     , m_willExecuteInOrder(false)
 75     , m_isModuleScript(false)
 76     , m_creationTime(MonotonicTime::now())
 77     , m_userGestureToken(UserGestureIndicator::currentUserGesture())
 78 {
 79     if (parserInserted &amp;&amp; m_element.document().scriptableDocumentParser() &amp;&amp; !m_element.document().isInDocumentWrite())
 80         m_startLineNumber = m_element.document().scriptableDocumentParser()-&gt;textPosition().m_line;
 81 }
 82 
 83 void ScriptElement::didFinishInsertingNode()
 84 {
 85     ASSERT(!m_parserInserted);
 86     prepareScript(); // FIXME: Provide a real starting line number here.
 87 }
 88 
 89 void ScriptElement::childrenChanged(const ContainerNode::ChildChange&amp; childChange)
 90 {
 91     if (!m_parserInserted &amp;&amp; childChange.isInsertion() &amp;&amp; m_element.isConnected())
 92         prepareScript(); // FIXME: Provide a real starting line number here.
 93 }
 94 
 95 void ScriptElement::handleSourceAttribute(const String&amp; sourceURL)
 96 {
 97     if (ignoresLoadRequest() || sourceURL.isEmpty())
 98         return;
 99 
100     prepareScript(); // FIXME: Provide a real starting line number here.
101 }
102 
103 void ScriptElement::handleAsyncAttribute()
104 {
105     m_forceAsync = false;
106 }
107 
108 static bool isLegacySupportedJavaScriptLanguage(const String&amp; language)
109 {
110     static const auto languages = makeNeverDestroyed(HashSet&lt;String, ASCIICaseInsensitiveHash&gt; {
111         &quot;javascript&quot;,
112         &quot;javascript1.0&quot;,
113         &quot;javascript1.1&quot;,
114         &quot;javascript1.2&quot;,
115         &quot;javascript1.3&quot;,
116         &quot;javascript1.4&quot;,
117         &quot;javascript1.5&quot;,
118         &quot;javascript1.6&quot;,
119         &quot;javascript1.7&quot;,
120         &quot;livescript&quot;,
121         &quot;ecmascript&quot;,
122         &quot;jscript&quot;,
123     });
124     return languages.get().contains(language);
125 }
126 
127 void ScriptElement::dispatchErrorEvent()
128 {
129     m_element.dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
130 }
131 
132 Optional&lt;ScriptElement::ScriptType&gt; ScriptElement::determineScriptType(LegacyTypeSupport supportLegacyTypes) const
133 {
134     // FIXME: isLegacySupportedJavaScriptLanguage() is not valid HTML5. It is used here to maintain backwards compatibility with existing layout tests. The specific violations are:
135     // - Allowing type=javascript. type= should only support MIME types, such as text/javascript.
136     // - Allowing a different set of languages for language= and type=. language= supports Javascript 1.1 and 1.4-1.6, but type= does not.
137     String type = typeAttributeValue();
138     String language = languageAttributeValue();
139     if (type.isEmpty()) {
140         if (language.isEmpty())
141             return ScriptType::Classic; // Assume text/javascript.
142         if (MIMETypeRegistry::isSupportedJavaScriptMIMEType(&quot;text/&quot; + language))
143             return ScriptType::Classic;
144         if (isLegacySupportedJavaScriptLanguage(language))
145             return ScriptType::Classic;
146         return WTF::nullopt;
147     }
148     if (MIMETypeRegistry::isSupportedJavaScriptMIMEType(type.stripWhiteSpace()))
149         return ScriptType::Classic;
150     if (supportLegacyTypes == AllowLegacyTypeInTypeAttribute &amp;&amp; isLegacySupportedJavaScriptLanguage(type))
151         return ScriptType::Classic;
152 
153     // FIXME: XHTML spec defines &quot;defer&quot; attribute. But WebKit does not implement it for a long time.
154     // And module tag also uses defer attribute semantics. We disable script type=&quot;module&quot; for non HTML document.
155     // Once &quot;defer&quot; is implemented, we can reconsider enabling modules in XHTML.
156     // https://bugs.webkit.org/show_bug.cgi?id=123387
157     if (!m_element.document().isHTMLDocument())
158         return WTF::nullopt;
159 
160     // https://html.spec.whatwg.org/multipage/scripting.html#attr-script-type
161     // Setting the attribute to an ASCII case-insensitive match for the string &quot;module&quot; means that the script is a module script.
162     if (equalLettersIgnoringASCIICase(type, &quot;module&quot;))
163         return ScriptType::Module;
164     return WTF::nullopt;
165 }
166 
167 // http://dev.w3.org/html5/spec/Overview.html#prepare-a-script
168 bool ScriptElement::prepareScript(const TextPosition&amp; scriptStartPosition, LegacyTypeSupport supportLegacyTypes)
169 {
170     if (m_alreadyStarted)
171         return false;
172 
173     bool wasParserInserted;
174     if (m_parserInserted) {
175         wasParserInserted = true;
176         m_parserInserted = false;
177     } else
178         wasParserInserted = false;
179 
180     if (wasParserInserted &amp;&amp; !hasAsyncAttribute())
181         m_forceAsync = true;
182 
183     // FIXME: HTML5 spec says we should check that all children are either comments or empty text nodes.
184     if (!hasSourceAttribute() &amp;&amp; !m_element.firstChild())
185         return false;
186 
187     if (!m_element.isConnected())
188         return false;
189 
190     ScriptType scriptType = ScriptType::Classic;
191     if (Optional&lt;ScriptType&gt; result = determineScriptType(supportLegacyTypes))
192         scriptType = result.value();
193     else
194         return false;
195     m_isModuleScript = scriptType == ScriptType::Module;
196 
197     if (wasParserInserted) {
198         m_parserInserted = true;
199         m_forceAsync = false;
200     }
201 
202     m_alreadyStarted = true;
203 
204     // FIXME: If script is parser inserted, verify it&#39;s still in the original document.
205     Document&amp; document = m_element.document();
206 
207     // FIXME: Eventually we&#39;d like to evaluate scripts which are inserted into a
208     // viewless document but this&#39;ll do for now.
209     // See http://bugs.webkit.org/show_bug.cgi?id=5727
210     if (!document.frame())
211         return false;
212 
213     if (scriptType == ScriptType::Classic &amp;&amp; hasNoModuleAttribute())
214         return false;
215 
216     if (!document.frame()-&gt;script().canExecuteScripts(AboutToExecuteScript))
217         return false;
218 
219     if (scriptType == ScriptType::Classic &amp;&amp; !isScriptForEventSupported())
220         return false;
221 
222     // According to the spec, the module tag ignores the &quot;charset&quot; attribute as the same to the worker&#39;s
223     // importScript. But WebKit supports the &quot;charset&quot; for importScript intentionally. So to be consistent,
224     // even for the module tags, we handle the &quot;charset&quot; attribute.
225     if (!charsetAttributeValue().isEmpty())
226         m_characterEncoding = charsetAttributeValue();
227     else
228         m_characterEncoding = document.charset();
229 
230     if (scriptType == ScriptType::Classic) {
231         if (hasSourceAttribute()) {
232             if (!requestClassicScript(sourceAttributeValue()))
233                 return false;
234         }
235     } else {
236         ASSERT(scriptType == ScriptType::Module);
237         if (!requestModuleScript(scriptStartPosition))
238             return false;
239     }
240 
241     // All the inlined module script is handled by requestModuleScript. It produces LoadableModuleScript and inlined module script
242     // is handled as the same to the external module script.
243 
244     bool isClassicExternalScript = scriptType == ScriptType::Classic &amp;&amp; hasSourceAttribute();
245     bool isParserInsertedDeferredScript = ((isClassicExternalScript &amp;&amp; hasDeferAttribute()) || scriptType == ScriptType::Module)
246         &amp;&amp; m_parserInserted &amp;&amp; !hasAsyncAttribute();
247     if (isParserInsertedDeferredScript) {
248         m_willExecuteWhenDocumentFinishedParsing = true;
249         m_willBeParserExecuted = true;
250     } else if (isClassicExternalScript &amp;&amp; m_parserInserted &amp;&amp; !hasAsyncAttribute()) {
251         ASSERT(scriptType == ScriptType::Classic);
252         m_willBeParserExecuted = true;
253     } else if ((isClassicExternalScript || scriptType == ScriptType::Module) &amp;&amp; !hasAsyncAttribute() &amp;&amp; !m_forceAsync) {
254         m_willExecuteInOrder = true;
255         ASSERT(m_loadableScript);
256         document.scriptRunner().queueScriptForExecution(*this, *m_loadableScript, ScriptRunner::IN_ORDER_EXECUTION);
257     } else if (hasSourceAttribute() || scriptType == ScriptType::Module) {
258         ASSERT(m_loadableScript);
259         ASSERT(hasAsyncAttribute() || m_forceAsync);
260         document.scriptRunner().queueScriptForExecution(*this, *m_loadableScript, ScriptRunner::ASYNC_EXECUTION);
261     } else if (!hasSourceAttribute() &amp;&amp; m_parserInserted &amp;&amp; !document.haveStylesheetsLoaded()) {
262         ASSERT(scriptType == ScriptType::Classic);
263         m_willBeParserExecuted = true;
264         m_readyToBeParserExecuted = true;
265     } else {
266         ASSERT(scriptType == ScriptType::Classic);
267         TextPosition position = document.isInDocumentWrite() ? TextPosition() : scriptStartPosition;
268         executeClassicScript(ScriptSourceCode(scriptContent(), URL(document.url()), position, JSC::SourceProviderSourceType::Program, InlineClassicScript::create(*this)));
269     }
270 
271     return true;
272 }
273 
274 bool ScriptElement::requestClassicScript(const String&amp; sourceURL)
275 {
276     Ref&lt;Document&gt; originalDocument(m_element.document());
277     if (!m_element.dispatchBeforeLoadEvent(sourceURL))
278         return false;
279     bool didEventListenerDisconnectThisElement = !m_element.isConnected() || &amp;m_element.document() != originalDocument.ptr();
280     if (didEventListenerDisconnectThisElement)
281         return false;
282 
283     ASSERT(!m_loadableScript);
284     if (!stripLeadingAndTrailingHTMLSpaces(sourceURL).isEmpty()) {
285         auto script = LoadableClassicScript::create(
286             m_element.attributeWithoutSynchronization(HTMLNames::nonceAttr),
287             m_element.document().settings().subresourceIntegrityEnabled() ? m_element.attributeWithoutSynchronization(HTMLNames::integrityAttr).string() : emptyString(),
288             referrerPolicy(),
289             m_element.attributeWithoutSynchronization(HTMLNames::crossoriginAttr),
290             scriptCharset(),
291             m_element.localName(),
292             m_element.isInUserAgentShadowTree());
293 
294         auto scriptURL = m_element.document().completeURL(sourceURL);
295         m_element.document().willLoadScriptElement(scriptURL);
296         if (script-&gt;load(m_element.document(), scriptURL)) {
297             m_loadableScript = WTFMove(script);
298             m_isExternalScript = true;
299         }
300     }
301 
302     if (m_loadableScript)
303         return true;
304 
305     callOnMainThread([this, element = Ref&lt;Element&gt;(m_element)] {
306         dispatchErrorEvent();
307     });
308     return false;
309 }
310 
311 bool ScriptElement::requestModuleScript(const TextPosition&amp; scriptStartPosition)
312 {
313     String nonce = m_element.attributeWithoutSynchronization(HTMLNames::nonceAttr);
314     String crossOriginMode = m_element.attributeWithoutSynchronization(HTMLNames::crossoriginAttr);
315     if (crossOriginMode.isNull())
316         crossOriginMode = &quot;omit&quot;_s;
317 
318     if (hasSourceAttribute()) {
319         String sourceURL = sourceAttributeValue();
320         Ref&lt;Document&gt; originalDocument(m_element.document());
321         if (!m_element.dispatchBeforeLoadEvent(sourceURL))
322             return false;
323 
324         bool didEventListenerDisconnectThisElement = !m_element.isConnected() || &amp;m_element.document() != originalDocument.ptr();
325         if (didEventListenerDisconnectThisElement)
326             return false;
327 
328         if (stripLeadingAndTrailingHTMLSpaces(sourceURL).isEmpty()) {
329             dispatchErrorEvent();
330             return false;
331         }
332 
333         auto moduleScriptRootURL = m_element.document().completeURL(sourceURL);
334         if (!moduleScriptRootURL.isValid()) {
335             dispatchErrorEvent();
336             return false;
337         }
338 
339         m_isExternalScript = true;
340         auto script = LoadableModuleScript::create(
341             nonce,
342             m_element.document().settings().subresourceIntegrityEnabled() ? m_element.attributeWithoutSynchronization(HTMLNames::integrityAttr).string() : emptyString(),
343             referrerPolicy(),
344             crossOriginMode,
345             scriptCharset(),
346             m_element.localName(),
347             m_element.isInUserAgentShadowTree());
348         script-&gt;load(m_element.document(), moduleScriptRootURL);
349         m_loadableScript = WTFMove(script);
350         return true;
351     }
352 
353     auto script = LoadableModuleScript::create(nonce, emptyString(), referrerPolicy(), crossOriginMode, scriptCharset(), m_element.localName(), m_element.isInUserAgentShadowTree());
354 
355     TextPosition position = m_element.document().isInDocumentWrite() ? TextPosition() : scriptStartPosition;
356     ScriptSourceCode sourceCode(scriptContent(), URL(m_element.document().url()), position, JSC::SourceProviderSourceType::Module, script.copyRef());
357 
358     ASSERT(m_element.document().contentSecurityPolicy());
359     const auto&amp; contentSecurityPolicy = *m_element.document().contentSecurityPolicy();
360     bool hasKnownNonce = contentSecurityPolicy.allowScriptWithNonce(nonce, m_element.isInUserAgentShadowTree());
361     if (!contentSecurityPolicy.allowInlineScript(m_element.document().url(), m_startLineNumber, sourceCode.source().toStringWithoutCopying(), hasKnownNonce))
362         return false;
363 
364     script-&gt;load(m_element.document(), sourceCode);
365     m_loadableScript = WTFMove(script);
366     return true;
367 }
368 
369 void ScriptElement::executeClassicScript(const ScriptSourceCode&amp; sourceCode)
370 {
371     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed() || !isInWebProcess());
372     ASSERT(m_alreadyStarted);
373 
374     if (sourceCode.isEmpty())
375         return;
376 
377     if (!m_isExternalScript) {
378         ASSERT(m_element.document().contentSecurityPolicy());
379         const ContentSecurityPolicy&amp; contentSecurityPolicy = *m_element.document().contentSecurityPolicy();
380         bool hasKnownNonce = contentSecurityPolicy.allowScriptWithNonce(m_element.attributeWithoutSynchronization(HTMLNames::nonceAttr), m_element.isInUserAgentShadowTree());
381         if (!contentSecurityPolicy.allowInlineScript(m_element.document().url(), m_startLineNumber, sourceCode.source().toStringWithoutCopying(), hasKnownNonce))
382             return;
383     }
384 
385     auto&amp; document = m_element.document();
386     auto* frame = document.frame();
387     if (!frame)
388         return;
389 
390     IgnoreDestructiveWriteCountIncrementer ignoreDesctructiveWriteCountIncrementer(m_isExternalScript ? &amp;document : nullptr);
391     CurrentScriptIncrementer currentScriptIncrementer(document, m_element);
392 
393     frame-&gt;script().evaluateIgnoringException(sourceCode);
394 }
395 
396 void ScriptElement::executeModuleScript(LoadableModuleScript&amp; loadableModuleScript)
397 {
398     // https://html.spec.whatwg.org/multipage/scripting.html#execute-the-script-block
399 
400     ASSERT(!loadableModuleScript.error());
401 
402     auto&amp; document = m_element.document();
403     auto* frame = document.frame();
404     if (!frame)
405         return;
406 
407     IgnoreDestructiveWriteCountIncrementer ignoreDesctructiveWriteCountIncrementer(&amp;document);
408     CurrentScriptIncrementer currentScriptIncrementer(document, m_element);
409 
410     frame-&gt;script().linkAndEvaluateModuleScript(loadableModuleScript);
411 }
412 
413 void ScriptElement::dispatchLoadEventRespectingUserGestureIndicator()
414 {
415     if (MonotonicTime::now() - m_creationTime &gt; maxUserGesturePropagationTime) {
416         dispatchLoadEvent();
417         return;
418     }
419 
420     UserGestureIndicator indicator(m_userGestureToken);
421     dispatchLoadEvent();
422 }
423 
424 void ScriptElement::executeScriptAndDispatchEvent(LoadableScript&amp; loadableScript)
425 {
426     if (Optional&lt;LoadableScript::Error&gt; error = loadableScript.error()) {
427         if (Optional&lt;LoadableScript::ConsoleMessage&gt; message = error-&gt;consoleMessage)
428             m_element.document().addConsoleMessage(message-&gt;source, message-&gt;level, message-&gt;message);
429         dispatchErrorEvent();
430     } else if (!loadableScript.wasCanceled()) {
431         ASSERT(!loadableScript.error());
432         loadableScript.execute(*this);
433         dispatchLoadEventRespectingUserGestureIndicator();
434     }
435 }
436 
437 void ScriptElement::executePendingScript(PendingScript&amp; pendingScript)
438 {
439     if (auto* loadableScript = pendingScript.loadableScript())
440         executeScriptAndDispatchEvent(*loadableScript);
441     else {
442         ASSERT(!pendingScript.error());
443         ASSERT_WITH_MESSAGE(scriptType() == ScriptType::Classic, &quot;Module script always have a loadableScript pointer.&quot;);
444         executeClassicScript(ScriptSourceCode(scriptContent(), URL(m_element.document().url()), pendingScript.startingPosition(), JSC::SourceProviderSourceType::Program, InlineClassicScript::create(*this)));
445         dispatchLoadEventRespectingUserGestureIndicator();
446     }
447 }
448 
449 bool ScriptElement::ignoresLoadRequest() const
450 {
451     return m_alreadyStarted || m_isExternalScript || m_parserInserted || !m_element.isConnected();
452 }
453 
454 bool ScriptElement::isScriptForEventSupported() const
455 {
456     String eventAttribute = eventAttributeValue();
457     String forAttribute = forAttributeValue();
458     if (!eventAttribute.isNull() &amp;&amp; !forAttribute.isNull()) {
459         forAttribute = stripLeadingAndTrailingHTMLSpaces(forAttribute);
460         if (!equalLettersIgnoringASCIICase(forAttribute, &quot;window&quot;))
461             return false;
462 
463         eventAttribute = stripLeadingAndTrailingHTMLSpaces(eventAttribute);
464         if (!equalLettersIgnoringASCIICase(eventAttribute, &quot;onload&quot;) &amp;&amp; !equalLettersIgnoringASCIICase(eventAttribute, &quot;onload()&quot;))
465             return false;
466     }
467     return true;
468 }
469 
470 String ScriptElement::scriptContent() const
471 {
472     return TextNodeTraversal::childTextContent(m_element);
473 }
474 
475 void ScriptElement::ref()
476 {
477     m_element.ref();
478 }
479 
480 void ScriptElement::deref()
481 {
482     m_element.deref();
483 }
484 
485 bool isScriptElement(Element&amp; element)
486 {
487     return is&lt;HTMLScriptElement&gt;(element) || is&lt;SVGScriptElement&gt;(element);
488 }
489 
490 ScriptElement&amp; downcastScriptElement(Element&amp; element)
491 {
492     if (is&lt;HTMLScriptElement&gt;(element))
493         return downcast&lt;HTMLScriptElement&gt;(element);
494     return downcast&lt;SVGScriptElement&gt;(element);
495 }
496 
497 }
    </pre>
  </body>
</html>
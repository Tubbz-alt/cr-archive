<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ReplaceRangeWithTextCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReplaceSelectionCommand.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;Document.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Editing.h&quot;
  41 #include &quot;EditingBehavior.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;EventNames.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameSelection.h&quot;
  46 #include &quot;HTMLBRElement.h&quot;
  47 #include &quot;HTMLBaseElement.h&quot;
  48 #include &quot;HTMLBodyElement.h&quot;
  49 #include &quot;HTMLInputElement.h&quot;
  50 #include &quot;HTMLLIElement.h&quot;
  51 #include &quot;HTMLLinkElement.h&quot;
  52 #include &quot;HTMLMetaElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;HTMLTitleElement.h&quot;
  56 #include &quot;NodeList.h&quot;
  57 #include &quot;NodeRenderStyle.h&quot;

  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderText.h&quot;
  60 #include &quot;ScriptElement.h&quot;
  61 #include &quot;SimplifyMarkupCommand.h&quot;
  62 #include &quot;SmartReplace.h&quot;
  63 #include &quot;StyleProperties.h&quot;
  64 #include &quot;Text.h&quot;
  65 #include &quot;TextIterator.h&quot;
  66 #include &quot;VisibleUnits.h&quot;
  67 #include &quot;markup.h&quot;
  68 #include &lt;wtf/NeverDestroyed.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 
  71 namespace WebCore {
  72 
  73 using namespace HTMLNames;
  74 
  75 enum EFragmentType { EmptyFragment, SingleTextNodeFragment, TreeFragment };
  76 
  77 // --- ReplacementFragment helper class
</pre>
<hr />
<pre>
 370     }
 371 }
 372 
 373 inline void ReplaceSelectionCommand::InsertedNodes::respondToNodeInsertion(Node* node)
 374 {
 375     if (!node)
 376         return;
 377 
 378     if (!m_firstNodeInserted)
 379         m_firstNodeInserted = node;
 380 
 381     m_lastNodeInserted = node;
 382 }
 383 
 384 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNodePreservingChildren(Node* node)
 385 {
 386     if (m_firstNodeInserted == node)
 387         m_firstNodeInserted = NodeTraversal::next(*node);
 388     if (m_lastNodeInserted == node) {
 389         m_lastNodeInserted = node-&gt;lastChild() ? node-&gt;lastChild() : NodeTraversal::nextSkippingChildren(*node);
<span class="line-modified"> 390         if (!m_lastNodeInserted) {</span>
 391             // If the last inserted node is at the end of the document and doesn&#39;t have any children, look backwards for the
 392             // previous node as the last inserted node, clamping to the first inserted node if needed to ensure that the
 393             // document position of the last inserted node is not behind the first inserted node.
 394             auto* previousNode = NodeTraversal::previousSkippingChildren(*node);
 395             ASSERT(previousNode);
 396             m_lastNodeInserted = m_firstNodeInserted-&gt;compareDocumentPosition(*previousNode) &amp; Node::DOCUMENT_POSITION_FOLLOWING ? previousNode : m_firstNodeInserted;
 397         }
 398     }
 399 }
 400 
 401 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNode(Node* node)
 402 {
 403     if (m_firstNodeInserted == node &amp;&amp; m_lastNodeInserted == node) {
 404         m_firstNodeInserted = nullptr;
 405         m_lastNodeInserted = nullptr;
 406     } else if (m_firstNodeInserted == node)
 407         m_firstNodeInserted = NodeTraversal::nextSkippingChildren(*m_firstNodeInserted);
 408     else if (m_lastNodeInserted == node)
 409         m_lastNodeInserted = NodeTraversal::previousSkippingChildren(*m_lastNodeInserted);
 410 }
</pre>
<hr />
<pre>
 503 bool ReplaceSelectionCommand::shouldMerge(const VisiblePosition&amp; source, const VisiblePosition&amp; destination)
 504 {
 505     if (source.isNull() || destination.isNull())
 506         return false;
 507 
 508     auto* sourceNode = source.deepEquivalent().deprecatedNode();
 509     auto* destinationNode = destination.deepEquivalent().deprecatedNode();
 510     auto* sourceBlock = enclosingBlock(sourceNode);
 511     auto* destinationBlock = enclosingBlock(destinationNode);
 512     return !enclosingNodeOfType(source.deepEquivalent(), &amp;isMailPasteAsQuotationNode)
 513         &amp;&amp; sourceBlock
 514         &amp;&amp; (!sourceBlock-&gt;hasTagName(blockquoteTag) || isMailBlockquote(sourceBlock))
 515         &amp;&amp; enclosingListChild(sourceBlock) == enclosingListChild(destinationNode)
 516         &amp;&amp; enclosingTableCell(source.deepEquivalent()) == enclosingTableCell(destination.deepEquivalent())
 517         &amp;&amp; (!isHeaderElement(sourceBlock) || haveSameTagName(sourceBlock, destinationBlock))
 518         // Don&#39;t merge to or from a position before or after a block because it would
 519         // be a no-op and cause infinite recursion.
 520         &amp;&amp; !isBlock(sourceNode) &amp;&amp; !isBlock(destinationNode);
 521 }
 522 












































































 523 // Style rules that match just inserted elements could change their appearance, like
 524 // a div inserted into a document with div { display:inline; }.
 525 void ReplaceSelectionCommand::removeRedundantStylesAndKeepStyleSpanInline(InsertedNodes&amp; insertedNodes)
 526 {
 527     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 528     RefPtr&lt;Node&gt; next;
 529     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 530         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 531 
 532         next = NodeTraversal::next(*node);
 533         if (!is&lt;StyledElement&gt;(*node))
 534             continue;
 535 
 536         StyledElement* element = downcast&lt;StyledElement&gt;(node.get());
 537 
 538         const StyleProperties* inlineStyle = element-&gt;inlineStyle();
 539         auto newInlineStyle = EditingStyle::create(inlineStyle);
 540         if (inlineStyle) {
 541             if (is&lt;HTMLElement&gt;(*element)) {
 542                 Vector&lt;QualifiedName&gt; attributes;
</pre>
<hr />
<pre>
1098         else if (isStartOfBlock(visibleInsertionPos))
1099             insertionPos = positionInParentBeforeNode(insertionBlock.get());
1100     }
1101 
1102     // Paste at start or end of link goes outside of link.
1103     insertionPos = positionAvoidingSpecialElementBoundary(insertionPos);
1104 
1105     // FIXME: Can this wait until after the operation has been performed?  There doesn&#39;t seem to be
1106     // any work performed after this that queries or uses the typing style.
1107     frame().selection().clearTypingStyle();
1108 
1109     // We don&#39;t want the destination to end up inside nodes that weren&#39;t selected.  To avoid that, we move the
1110     // position forward without changing the visible position so we&#39;re still at the same visible location, but
1111     // outside of preceding tags.
1112     insertionPos = positionAvoidingPrecedingNodes(insertionPos);
1113 
1114     // Paste into run of tabs splits the tab span.
1115     insertionPos = positionOutsideTabSpan(insertionPos);
1116 
1117     bool hasBlankLinesBetweenParagraphs = hasBlankLineBetweenParagraphs(insertionPos);
<span class="line-removed">1118 </span>
1119     bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);

1120 
1121     // We&#39;re finished if there is nothing to add.
1122     if (fragment.isEmpty() || !fragment.firstChild())
1123         return;
1124 
1125     // If we are not trying to match the destination style we prefer a position
1126     // that is outside inline elements that provide style.
1127     // This way we can produce a less verbose markup.
1128     // We can skip this optimization for fragments not wrapped in one of
1129     // our style spans and for positions inside list items
1130     // since insertAsListItems already does the right thing.
1131     if (!m_matchStyle &amp;&amp; !enclosingList(insertionPos.containerNode())) {
1132         if (insertionPos.containerNode()-&gt;isTextNode() &amp;&amp; insertionPos.offsetInContainerNode() &amp;&amp; !insertionPos.atLastEditingPositionForNode()) {
1133             splitTextNode(*insertionPos.containerText(), insertionPos.offsetInContainerNode());
1134             insertionPos = firstPositionInNode(insertionPos.containerNode());
1135         }
1136 
1137         if (RefPtr&lt;Node&gt; nodeToSplitTo = nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(insertionPos)) {
1138             if (insertionPos.containerNode() != nodeToSplitTo-&gt;parentNode()) {
1139                 Node* splitStart = insertionPos.computeNodeAfterPosition();
</pre>
<hr />
<pre>
1215 
1216     // We inserted before the insertionBlock to prevent nesting, and the content before the insertionBlock wasn&#39;t in its own block and
1217     // didn&#39;t have a br after it, so the inserted content ended up in the same paragraph.
1218     if (!startOfInsertedContent.isNull() &amp;&amp; insertionBlock &amp;&amp; insertionPos.deprecatedNode() == insertionBlock-&gt;parentNode() &amp;&amp; (unsigned)insertionPos.deprecatedEditingOffset() &lt; insertionBlock-&gt;computeNodeIndex() &amp;&amp; !isStartOfParagraph(startOfInsertedContent))
1219         insertNodeAt(HTMLBRElement::create(document()), startOfInsertedContent.deepEquivalent());
1220 
1221     if (endBR &amp;&amp; (plainTextFragment || shouldRemoveEndBR(endBR.get(), originalVisPosBeforeEndBR))) {
1222         RefPtr&lt;Node&gt; parent = endBR-&gt;parentNode();
1223         insertedNodes.willRemoveNode(endBR.get());
1224         removeNode(*endBR);
1225         if (Node* nodeToRemove = highestNodeToRemoveInPruning(parent.get())) {
1226             insertedNodes.willRemoveNode(nodeToRemove);
1227             removeNode(*nodeToRemove);
1228         }
1229     }
1230 
1231     makeInsertedContentRoundTrippableWithHTMLTreeBuilder(insertedNodes);
1232     if (insertedNodes.isEmpty())
1233         return;
1234 



1235     removeRedundantStylesAndKeepStyleSpanInline(insertedNodes);
1236     if (insertedNodes.isEmpty())
1237         return;
1238 
1239     if (m_sanitizeFragment)
1240         applyCommandToComposite(SimplifyMarkupCommand::create(document(), insertedNodes.firstNodeInserted(), insertedNodes.pastLastLeaf()));
1241 
1242     // Setup m_startOfInsertedContent and m_endOfInsertedContent. This should be the last two lines of code that access insertedNodes.
1243     m_startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1244     m_endOfInsertedContent = lastPositionInOrAfterNode(insertedNodes.lastLeafInserted());
1245 
1246     // Determine whether or not we should merge the end of inserted content with what&#39;s after it before we do
1247     // the start merge so that the start merge doesn&#39;t effect our decision.
1248     m_shouldMergeEnd = shouldMergeEnd(selectionEndWasEndOfParagraph);
1249 
1250     if (shouldMergeStart(selectionStartWasStartOfParagraph, fragment.hasInterchangeNewlineAtStart(), shouldHandleMailBlockquote)) {
1251         VisiblePosition startOfParagraphToMove = positionAtStartOfInsertedContent();
1252         VisiblePosition destination = startOfParagraphToMove.previous();
1253         // We need to handle the case where we need to merge the end
1254         // but our destination node is inside an inline that is the last in the block.
</pre>
<hr />
<pre>
1325     // no style matching is necessary.
1326     if (plainTextFragment)
1327         m_matchStyle = false;
1328 
1329     completeHTMLReplacement(lastPositionToSelect);
1330 }
1331 
1332 String ReplaceSelectionCommand::inputEventData() const
1333 {
1334     if (isEditingTextAreaOrTextInput())
1335         return m_documentFragment-&gt;textContent();
1336 
1337     return CompositeEditCommand::inputEventData();
1338 }
1339 
1340 RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
1341 {
1342     if (isEditingTextAreaOrTextInput())
1343         return CompositeEditCommand::inputEventDataTransfer();
1344 
<span class="line-modified">1345     return DataTransfer::createForInputEvent(document(), m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
1346 }
1347 
1348 bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
1349 {
1350     if (!endBR || !endBR-&gt;isConnected())
1351         return false;
1352 
1353     VisiblePosition visiblePos(positionBeforeNode(endBR));
1354 
1355     // Don&#39;t remove the br if nothing was inserted.
1356     if (visiblePos.previous() == originalVisPosBeforeEndBR)
1357         return false;
1358 
1359     // Remove the br if it is collapsed away and so is unnecessary.
1360     if (!document().inNoQuirksMode() &amp;&amp; isEndOfBlock(visiblePos) &amp;&amp; !isStartOfParagraph(visiblePos))
1361         return true;
1362 
1363     // A br that was originally holding a line open should be displaced by inserted content or turned into a line break.
1364     // A br that was originally acting as a line break should still be acting as a line break, not as a placeholder.
1365     return isStartOfParagraph(visiblePos) &amp;&amp; isEndOfParagraph(visiblePos);
</pre>
<hr />
<pre>
1674 
1675     Position start = endingSelection().start();
1676     Position end = replaceSelectedTextInNode(textNode.data());
1677     if (end.isNull())
1678         return false;
1679 
1680     if (nodeAfterInsertionPos &amp;&amp; nodeAfterInsertionPos-&gt;parentNode() &amp;&amp; nodeAfterInsertionPos-&gt;hasTagName(brTag)
1681         &amp;&amp; shouldRemoveEndBR(nodeAfterInsertionPos.get(), positionBeforeNode(nodeAfterInsertionPos.get())))
1682         removeNodeAndPruneAncestors(*nodeAfterInsertionPos);
1683 
1684     VisibleSelection selectionAfterReplace(m_selectReplacement ? start : end, end);
1685 
1686     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1687         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1688 
1689     setEndingSelection(selectionAfterReplace);
1690 
1691     return true;
1692 }
1693 








1694 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;Document.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Editing.h&quot;
  41 #include &quot;EditingBehavior.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;EventNames.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameSelection.h&quot;
  46 #include &quot;HTMLBRElement.h&quot;
  47 #include &quot;HTMLBaseElement.h&quot;
  48 #include &quot;HTMLBodyElement.h&quot;
  49 #include &quot;HTMLInputElement.h&quot;
  50 #include &quot;HTMLLIElement.h&quot;
  51 #include &quot;HTMLLinkElement.h&quot;
  52 #include &quot;HTMLMetaElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;HTMLTitleElement.h&quot;
  56 #include &quot;NodeList.h&quot;
  57 #include &quot;NodeRenderStyle.h&quot;
<span class="line-added">  58 #include &quot;Position.h&quot;</span>
  59 #include &quot;RenderInline.h&quot;
  60 #include &quot;RenderText.h&quot;
  61 #include &quot;ScriptElement.h&quot;
  62 #include &quot;SimplifyMarkupCommand.h&quot;
  63 #include &quot;SmartReplace.h&quot;
  64 #include &quot;StyleProperties.h&quot;
  65 #include &quot;Text.h&quot;
  66 #include &quot;TextIterator.h&quot;
  67 #include &quot;VisibleUnits.h&quot;
  68 #include &quot;markup.h&quot;
  69 #include &lt;wtf/NeverDestroyed.h&gt;
  70 #include &lt;wtf/StdLibExtras.h&gt;
  71 
  72 namespace WebCore {
  73 
  74 using namespace HTMLNames;
  75 
  76 enum EFragmentType { EmptyFragment, SingleTextNodeFragment, TreeFragment };
  77 
  78 // --- ReplacementFragment helper class
</pre>
<hr />
<pre>
 371     }
 372 }
 373 
 374 inline void ReplaceSelectionCommand::InsertedNodes::respondToNodeInsertion(Node* node)
 375 {
 376     if (!node)
 377         return;
 378 
 379     if (!m_firstNodeInserted)
 380         m_firstNodeInserted = node;
 381 
 382     m_lastNodeInserted = node;
 383 }
 384 
 385 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNodePreservingChildren(Node* node)
 386 {
 387     if (m_firstNodeInserted == node)
 388         m_firstNodeInserted = NodeTraversal::next(*node);
 389     if (m_lastNodeInserted == node) {
 390         m_lastNodeInserted = node-&gt;lastChild() ? node-&gt;lastChild() : NodeTraversal::nextSkippingChildren(*node);
<span class="line-modified"> 391         if (!m_lastNodeInserted &amp;&amp; m_firstNodeInserted) {</span>
 392             // If the last inserted node is at the end of the document and doesn&#39;t have any children, look backwards for the
 393             // previous node as the last inserted node, clamping to the first inserted node if needed to ensure that the
 394             // document position of the last inserted node is not behind the first inserted node.
 395             auto* previousNode = NodeTraversal::previousSkippingChildren(*node);
 396             ASSERT(previousNode);
 397             m_lastNodeInserted = m_firstNodeInserted-&gt;compareDocumentPosition(*previousNode) &amp; Node::DOCUMENT_POSITION_FOLLOWING ? previousNode : m_firstNodeInserted;
 398         }
 399     }
 400 }
 401 
 402 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNode(Node* node)
 403 {
 404     if (m_firstNodeInserted == node &amp;&amp; m_lastNodeInserted == node) {
 405         m_firstNodeInserted = nullptr;
 406         m_lastNodeInserted = nullptr;
 407     } else if (m_firstNodeInserted == node)
 408         m_firstNodeInserted = NodeTraversal::nextSkippingChildren(*m_firstNodeInserted);
 409     else if (m_lastNodeInserted == node)
 410         m_lastNodeInserted = NodeTraversal::previousSkippingChildren(*m_lastNodeInserted);
 411 }
</pre>
<hr />
<pre>
 504 bool ReplaceSelectionCommand::shouldMerge(const VisiblePosition&amp; source, const VisiblePosition&amp; destination)
 505 {
 506     if (source.isNull() || destination.isNull())
 507         return false;
 508 
 509     auto* sourceNode = source.deepEquivalent().deprecatedNode();
 510     auto* destinationNode = destination.deepEquivalent().deprecatedNode();
 511     auto* sourceBlock = enclosingBlock(sourceNode);
 512     auto* destinationBlock = enclosingBlock(destinationNode);
 513     return !enclosingNodeOfType(source.deepEquivalent(), &amp;isMailPasteAsQuotationNode)
 514         &amp;&amp; sourceBlock
 515         &amp;&amp; (!sourceBlock-&gt;hasTagName(blockquoteTag) || isMailBlockquote(sourceBlock))
 516         &amp;&amp; enclosingListChild(sourceBlock) == enclosingListChild(destinationNode)
 517         &amp;&amp; enclosingTableCell(source.deepEquivalent()) == enclosingTableCell(destination.deepEquivalent())
 518         &amp;&amp; (!isHeaderElement(sourceBlock) || haveSameTagName(sourceBlock, destinationBlock))
 519         // Don&#39;t merge to or from a position before or after a block because it would
 520         // be a no-op and cause infinite recursion.
 521         &amp;&amp; !isBlock(sourceNode) &amp;&amp; !isBlock(destinationNode);
 522 }
 523 
<span class="line-added"> 524 static bool fragmentNeedsColorTransformed(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)</span>
<span class="line-added"> 525 {</span>
<span class="line-added"> 526     // Dark mode content that is inserted should have the inline styles inverse color</span>
<span class="line-added"> 527     // transformed by the color filter to match the color filtered document contents.</span>
<span class="line-added"> 528     // This applies to Mail and Notes when pasting from Xcode. &lt;rdar://problem/40529867&gt;</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530     RefPtr&lt;Element&gt; editableRoot = insertionPos.rootEditableElement();</span>
<span class="line-added"> 531     ASSERT(editableRoot);</span>
<span class="line-added"> 532     if (!editableRoot)</span>
<span class="line-added"> 533         return false;</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535     auto* editableRootRenderer = editableRoot-&gt;renderer();</span>
<span class="line-added"> 536     if (!editableRootRenderer || !editableRootRenderer-&gt;style().hasAppleColorFilter())</span>
<span class="line-added"> 537         return false;</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539     const auto&amp; colorFilter = editableRootRenderer-&gt;style().appleColorFilter();</span>
<span class="line-added"> 540     for (const auto&amp; colorFilterOperation : colorFilter.operations()) {</span>
<span class="line-added"> 541         if (colorFilterOperation-&gt;type() != FilterOperation::APPLE_INVERT_LIGHTNESS)</span>
<span class="line-added"> 542             return false;</span>
<span class="line-added"> 543     }</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545     auto propertyLightness = [&amp;](const StyleProperties&amp; inlineStyle, CSSPropertyID propertyID) -&gt; Optional&lt;double&gt; {</span>
<span class="line-added"> 546         auto color = inlineStyle.propertyAsColor(propertyID);</span>
<span class="line-added"> 547         if (!color || !color.value().isVisible() || color.value().isSemantic())</span>
<span class="line-added"> 548             return { };</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550         double hue, saturation, lightness;</span>
<span class="line-added"> 551         color.value().getHSL(hue, saturation, lightness);</span>
<span class="line-added"> 552         return lightness;</span>
<span class="line-added"> 553     };</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555     const double lightnessDarkEnoughForText = 0.4;</span>
<span class="line-added"> 556     const double lightnessLightEnoughForBackground = 0.6;</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558     for (RefPtr&lt;Node&gt; node = fragment.firstChild(); node; node = NodeTraversal::next(*node)) {</span>
<span class="line-added"> 559         if (!is&lt;StyledElement&gt;(*node))</span>
<span class="line-added"> 560             continue;</span>
<span class="line-added"> 561 </span>
<span class="line-added"> 562         auto&amp; element = downcast&lt;StyledElement&gt;(*node);</span>
<span class="line-added"> 563         auto* inlineStyle = element.inlineStyle();</span>
<span class="line-added"> 564         if (!inlineStyle)</span>
<span class="line-added"> 565             continue;</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567         auto textLightness = propertyLightness(*inlineStyle, CSSPropertyColor);</span>
<span class="line-added"> 568         if (textLightness &amp;&amp; *textLightness &lt; lightnessDarkEnoughForText)</span>
<span class="line-added"> 569             return false;</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571         auto backgroundLightness = propertyLightness(*inlineStyle, CSSPropertyBackgroundColor);</span>
<span class="line-added"> 572         if (backgroundLightness &amp;&amp; *backgroundLightness &gt; lightnessLightEnoughForBackground)</span>
<span class="line-added"> 573             return false;</span>
<span class="line-added"> 574     }</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576     return true;</span>
<span class="line-added"> 577 }</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579 void ReplaceSelectionCommand::inverseTransformColor(InsertedNodes&amp; insertedNodes)</span>
<span class="line-added"> 580 {</span>
<span class="line-added"> 581     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();</span>
<span class="line-added"> 582     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = NodeTraversal::next(*node)) {</span>
<span class="line-added"> 583         if (!is&lt;StyledElement&gt;(*node))</span>
<span class="line-added"> 584             continue;</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586         auto&amp; element = downcast&lt;StyledElement&gt;(*node);</span>
<span class="line-added"> 587         auto* inlineStyle = element.inlineStyle();</span>
<span class="line-added"> 588         if (!inlineStyle)</span>
<span class="line-added"> 589             continue;</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591         auto editingStyle = EditingStyle::create(inlineStyle);</span>
<span class="line-added"> 592         auto transformedStyle = editingStyle-&gt;inverseTransformColorIfNeeded(element);</span>
<span class="line-added"> 593         if (editingStyle.ptr() == transformedStyle.ptr())</span>
<span class="line-added"> 594             continue;</span>
<span class="line-added"> 595 </span>
<span class="line-added"> 596         setNodeAttribute(element, styleAttr, transformedStyle-&gt;style()-&gt;asText());</span>
<span class="line-added"> 597     }</span>
<span class="line-added"> 598 }</span>
<span class="line-added"> 599 </span>
 600 // Style rules that match just inserted elements could change their appearance, like
 601 // a div inserted into a document with div { display:inline; }.
 602 void ReplaceSelectionCommand::removeRedundantStylesAndKeepStyleSpanInline(InsertedNodes&amp; insertedNodes)
 603 {
 604     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 605     RefPtr&lt;Node&gt; next;
 606     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 607         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 608 
 609         next = NodeTraversal::next(*node);
 610         if (!is&lt;StyledElement&gt;(*node))
 611             continue;
 612 
 613         StyledElement* element = downcast&lt;StyledElement&gt;(node.get());
 614 
 615         const StyleProperties* inlineStyle = element-&gt;inlineStyle();
 616         auto newInlineStyle = EditingStyle::create(inlineStyle);
 617         if (inlineStyle) {
 618             if (is&lt;HTMLElement&gt;(*element)) {
 619                 Vector&lt;QualifiedName&gt; attributes;
</pre>
<hr />
<pre>
1175         else if (isStartOfBlock(visibleInsertionPos))
1176             insertionPos = positionInParentBeforeNode(insertionBlock.get());
1177     }
1178 
1179     // Paste at start or end of link goes outside of link.
1180     insertionPos = positionAvoidingSpecialElementBoundary(insertionPos);
1181 
1182     // FIXME: Can this wait until after the operation has been performed?  There doesn&#39;t seem to be
1183     // any work performed after this that queries or uses the typing style.
1184     frame().selection().clearTypingStyle();
1185 
1186     // We don&#39;t want the destination to end up inside nodes that weren&#39;t selected.  To avoid that, we move the
1187     // position forward without changing the visible position so we&#39;re still at the same visible location, but
1188     // outside of preceding tags.
1189     insertionPos = positionAvoidingPrecedingNodes(insertionPos);
1190 
1191     // Paste into run of tabs splits the tab span.
1192     insertionPos = positionOutsideTabSpan(insertionPos);
1193 
1194     bool hasBlankLinesBetweenParagraphs = hasBlankLineBetweenParagraphs(insertionPos);

1195     bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);
<span class="line-added">1196     bool needsColorTransformed = fragmentNeedsColorTransformed(fragment, insertionPos);</span>
1197 
1198     // We&#39;re finished if there is nothing to add.
1199     if (fragment.isEmpty() || !fragment.firstChild())
1200         return;
1201 
1202     // If we are not trying to match the destination style we prefer a position
1203     // that is outside inline elements that provide style.
1204     // This way we can produce a less verbose markup.
1205     // We can skip this optimization for fragments not wrapped in one of
1206     // our style spans and for positions inside list items
1207     // since insertAsListItems already does the right thing.
1208     if (!m_matchStyle &amp;&amp; !enclosingList(insertionPos.containerNode())) {
1209         if (insertionPos.containerNode()-&gt;isTextNode() &amp;&amp; insertionPos.offsetInContainerNode() &amp;&amp; !insertionPos.atLastEditingPositionForNode()) {
1210             splitTextNode(*insertionPos.containerText(), insertionPos.offsetInContainerNode());
1211             insertionPos = firstPositionInNode(insertionPos.containerNode());
1212         }
1213 
1214         if (RefPtr&lt;Node&gt; nodeToSplitTo = nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(insertionPos)) {
1215             if (insertionPos.containerNode() != nodeToSplitTo-&gt;parentNode()) {
1216                 Node* splitStart = insertionPos.computeNodeAfterPosition();
</pre>
<hr />
<pre>
1292 
1293     // We inserted before the insertionBlock to prevent nesting, and the content before the insertionBlock wasn&#39;t in its own block and
1294     // didn&#39;t have a br after it, so the inserted content ended up in the same paragraph.
1295     if (!startOfInsertedContent.isNull() &amp;&amp; insertionBlock &amp;&amp; insertionPos.deprecatedNode() == insertionBlock-&gt;parentNode() &amp;&amp; (unsigned)insertionPos.deprecatedEditingOffset() &lt; insertionBlock-&gt;computeNodeIndex() &amp;&amp; !isStartOfParagraph(startOfInsertedContent))
1296         insertNodeAt(HTMLBRElement::create(document()), startOfInsertedContent.deepEquivalent());
1297 
1298     if (endBR &amp;&amp; (plainTextFragment || shouldRemoveEndBR(endBR.get(), originalVisPosBeforeEndBR))) {
1299         RefPtr&lt;Node&gt; parent = endBR-&gt;parentNode();
1300         insertedNodes.willRemoveNode(endBR.get());
1301         removeNode(*endBR);
1302         if (Node* nodeToRemove = highestNodeToRemoveInPruning(parent.get())) {
1303             insertedNodes.willRemoveNode(nodeToRemove);
1304             removeNode(*nodeToRemove);
1305         }
1306     }
1307 
1308     makeInsertedContentRoundTrippableWithHTMLTreeBuilder(insertedNodes);
1309     if (insertedNodes.isEmpty())
1310         return;
1311 
<span class="line-added">1312     if (needsColorTransformed)</span>
<span class="line-added">1313         inverseTransformColor(insertedNodes);</span>
<span class="line-added">1314 </span>
1315     removeRedundantStylesAndKeepStyleSpanInline(insertedNodes);
1316     if (insertedNodes.isEmpty())
1317         return;
1318 
1319     if (m_sanitizeFragment)
1320         applyCommandToComposite(SimplifyMarkupCommand::create(document(), insertedNodes.firstNodeInserted(), insertedNodes.pastLastLeaf()));
1321 
1322     // Setup m_startOfInsertedContent and m_endOfInsertedContent. This should be the last two lines of code that access insertedNodes.
1323     m_startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1324     m_endOfInsertedContent = lastPositionInOrAfterNode(insertedNodes.lastLeafInserted());
1325 
1326     // Determine whether or not we should merge the end of inserted content with what&#39;s after it before we do
1327     // the start merge so that the start merge doesn&#39;t effect our decision.
1328     m_shouldMergeEnd = shouldMergeEnd(selectionEndWasEndOfParagraph);
1329 
1330     if (shouldMergeStart(selectionStartWasStartOfParagraph, fragment.hasInterchangeNewlineAtStart(), shouldHandleMailBlockquote)) {
1331         VisiblePosition startOfParagraphToMove = positionAtStartOfInsertedContent();
1332         VisiblePosition destination = startOfParagraphToMove.previous();
1333         // We need to handle the case where we need to merge the end
1334         // but our destination node is inside an inline that is the last in the block.
</pre>
<hr />
<pre>
1405     // no style matching is necessary.
1406     if (plainTextFragment)
1407         m_matchStyle = false;
1408 
1409     completeHTMLReplacement(lastPositionToSelect);
1410 }
1411 
1412 String ReplaceSelectionCommand::inputEventData() const
1413 {
1414     if (isEditingTextAreaOrTextInput())
1415         return m_documentFragment-&gt;textContent();
1416 
1417     return CompositeEditCommand::inputEventData();
1418 }
1419 
1420 RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
1421 {
1422     if (isEditingTextAreaOrTextInput())
1423         return CompositeEditCommand::inputEventDataTransfer();
1424 
<span class="line-modified">1425     return DataTransfer::createForInputEvent(m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
1426 }
1427 
1428 bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
1429 {
1430     if (!endBR || !endBR-&gt;isConnected())
1431         return false;
1432 
1433     VisiblePosition visiblePos(positionBeforeNode(endBR));
1434 
1435     // Don&#39;t remove the br if nothing was inserted.
1436     if (visiblePos.previous() == originalVisPosBeforeEndBR)
1437         return false;
1438 
1439     // Remove the br if it is collapsed away and so is unnecessary.
1440     if (!document().inNoQuirksMode() &amp;&amp; isEndOfBlock(visiblePos) &amp;&amp; !isStartOfParagraph(visiblePos))
1441         return true;
1442 
1443     // A br that was originally holding a line open should be displaced by inserted content or turned into a line break.
1444     // A br that was originally acting as a line break should still be acting as a line break, not as a placeholder.
1445     return isStartOfParagraph(visiblePos) &amp;&amp; isEndOfParagraph(visiblePos);
</pre>
<hr />
<pre>
1754 
1755     Position start = endingSelection().start();
1756     Position end = replaceSelectedTextInNode(textNode.data());
1757     if (end.isNull())
1758         return false;
1759 
1760     if (nodeAfterInsertionPos &amp;&amp; nodeAfterInsertionPos-&gt;parentNode() &amp;&amp; nodeAfterInsertionPos-&gt;hasTagName(brTag)
1761         &amp;&amp; shouldRemoveEndBR(nodeAfterInsertionPos.get(), positionBeforeNode(nodeAfterInsertionPos.get())))
1762         removeNodeAndPruneAncestors(*nodeAfterInsertionPos);
1763 
1764     VisibleSelection selectionAfterReplace(m_selectReplacement ? start : end, end);
1765 
1766     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1767         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1768 
1769     setEndingSelection(selectionAfterReplace);
1770 
1771     return true;
1772 }
1773 
<span class="line-added">1774 RefPtr&lt;Range&gt; ReplaceSelectionCommand::insertedContentRange() const</span>
<span class="line-added">1775 {</span>
<span class="line-added">1776     if (auto document = makeRefPtr(m_startOfInsertedContent.document()))</span>
<span class="line-added">1777         return Range::create(*document, m_startOfInsertedContent, m_endOfInsertedContent);</span>
<span class="line-added">1778 </span>
<span class="line-added">1779     return nullptr;</span>
<span class="line-added">1780 }</span>
<span class="line-added">1781 </span>
1782 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ReplaceRangeWithTextCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReplaceSelectionCommand.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 66,13 ***</span>
  // and bail-out to an alternate code path if these checks fail.
  // Importantly, the speculative code path cannot be reentered once
  // a speculative check has failed. This allows the SpeculativeJIT
  // to propagate type information (including information that has
  // only speculatively been asserted) through the dataflow.
  class SpeculativeJIT {
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed">- </span>
      friend struct OSRExit;
  private:
      typedef JITCompiler::TrustedImm32 TrustedImm32;
      typedef JITCompiler::Imm32 Imm32;
      typedef JITCompiler::ImmPtr ImmPtr;
<span class="line-new-header">--- 66,13 ---</span>
  // and bail-out to an alternate code path if these checks fail.
  // Importantly, the speculative code path cannot be reentered once
  // a speculative check has failed. This allows the SpeculativeJIT
  // to propagate type information (including information that has
  // only speculatively been asserted) through the dataflow.
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SpeculativeJIT);</span>
  class SpeculativeJIT {
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(SpeculativeJIT);</span>
      friend struct OSRExit;
  private:
      typedef JITCompiler::TrustedImm32 TrustedImm32;
      typedef JITCompiler::Imm32 Imm32;
      typedef JITCompiler::ImmPtr ImmPtr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,11 ***</span>
  
              GPRReg reg = info.gpr();
              // We need to box int32 and cell values ...
              // but on JSVALUE64 boxing a cell is a no-op!
              if (spillFormat == DataFormatInt32)
<span class="line-modified">!                 m_jit.or64(GPRInfo::tagTypeNumberRegister, reg);</span>
  
              // Spill the value, and record it as spilled in its boxed form.
              m_jit.store64(reg, JITCompiler::addressFor(spillMe));
              info.spill(*m_stream, spillMe, (DataFormat)(spillFormat | DataFormatJS));
              return;
<span class="line-new-header">--- 536,11 ---</span>
  
              GPRReg reg = info.gpr();
              // We need to box int32 and cell values ...
              // but on JSVALUE64 boxing a cell is a no-op!
              if (spillFormat == DataFormatInt32)
<span class="line-modified">!                 m_jit.or64(GPRInfo::numberTagRegister, reg);</span>
  
              // Spill the value, and record it as spilled in its boxed form.
              m_jit.store64(reg, JITCompiler::addressFor(spillMe));
              info.spill(*m_stream, spillMe, (DataFormat)(spillFormat | DataFormatJS));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 658,11 ***</span>
          }
      }
      void shiftOp(NodeType op, GPRReg op1, int32_t shiftAmount, GPRReg result)
      {
          switch (op) {
<span class="line-modified">!         case BitRShift:</span>
              m_jit.rshift32(op1, Imm32(shiftAmount), result);
              break;
          case ArithBitLShift:
              m_jit.lshift32(op1, Imm32(shiftAmount), result);
              break;
<span class="line-new-header">--- 658,11 ---</span>
          }
      }
      void shiftOp(NodeType op, GPRReg op1, int32_t shiftAmount, GPRReg result)
      {
          switch (op) {
<span class="line-modified">!         case ArithBitRShift:</span>
              m_jit.rshift32(op1, Imm32(shiftAmount), result);
              break;
          case ArithBitLShift:
              m_jit.lshift32(op1, Imm32(shiftAmount), result);
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 674,11 ***</span>
          }
      }
      void shiftOp(NodeType op, GPRReg op1, GPRReg shiftAmount, GPRReg result)
      {
          switch (op) {
<span class="line-modified">!         case BitRShift:</span>
              m_jit.rshift32(op1, shiftAmount, result);
              break;
          case ArithBitLShift:
              m_jit.lshift32(op1, shiftAmount, result);
              break;
<span class="line-new-header">--- 674,11 ---</span>
          }
      }
      void shiftOp(NodeType op, GPRReg op1, GPRReg shiftAmount, GPRReg result)
      {
          switch (op) {
<span class="line-modified">!         case ArithBitRShift:</span>
              m_jit.rshift32(op1, shiftAmount, result);
              break;
          case ArithBitLShift:
              m_jit.lshift32(op1, shiftAmount, result);
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,12 ***</span>
<span class="line-new-header">--- 712,15 ---</span>
      void compileCheckTraps(Node*);
  
      void compileMovHint(Node*);
      void compileMovHintAndCheck(Node*);
  
<span class="line-added">+     void compileCheckNeutered(Node*);</span>
<span class="line-added">+ </span>
      void cachedGetById(CodeOrigin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
      void cachedPutById(CodeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind, JITCompiler::Jump slowPathTarget = JITCompiler::Jump(), SpillRegistersMode = NeedToSpill);
<span class="line-added">+     void cachedGetByVal(CodeOrigin, JSValueRegs base, JSValueRegs property, JSValueRegs result, JITCompiler::Jump slowPathTarget);</span>
  
  #if USE(JSVALUE64)
      void cachedGetById(CodeOrigin, GPRReg baseGPR, GPRReg resultGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
      void cachedGetByIdWithThis(CodeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget = JITCompiler::JumpList());
  #elif USE(JSVALUE32_64)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,12 ***</span>
      void compileInByVal(Node*);
  
      void nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand);
      void nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode);
  
<span class="line-modified">!     void nonSpeculativePeepholeBranch(Node*, Node* branchNode, MacroAssembler::RelationalCondition, S_JITOperation_EJJ helperFunction);</span>
<span class="line-modified">!     void nonSpeculativeNonPeepholeCompare(Node*, MacroAssembler::RelationalCondition, S_JITOperation_EJJ helperFunction);</span>
  
      void nonSpeculativePeepholeStrictEq(Node*, Node* branchNode, bool invert = false);
      void nonSpeculativeNonPeepholeStrictEq(Node*, bool invert = false);
      bool nonSpeculativeStrictEq(Node*, bool invert = false);
  
<span class="line-new-header">--- 737,12 ---</span>
      void compileInByVal(Node*);
  
      void nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand);
      void nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode);
  
<span class="line-modified">!     void nonSpeculativePeepholeBranch(Node*, Node* branchNode, MacroAssembler::RelationalCondition, S_JITOperation_GJJ helperFunction);</span>
<span class="line-modified">!     void nonSpeculativeNonPeepholeCompare(Node*, MacroAssembler::RelationalCondition, S_JITOperation_GJJ helperFunction);</span>
  
      void nonSpeculativePeepholeStrictEq(Node*, Node* branchNode, bool invert = false);
      void nonSpeculativeNonPeepholeStrictEq(Node*, bool invert = false);
      bool nonSpeculativeStrictEq(Node*, bool invert = false);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 919,85 ***</span>
      {
          ASSERT(node-&gt;hasConstant());
          generationInfo(node).initConstant(node, node-&gt;refCount());
      }
  
<span class="line-removed">- #define FIRST_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;0&gt;</span>
<span class="line-removed">- </span>
      template&lt;typename OperationType, typename ResultRegType, typename... Args&gt;
      std::enable_if_t&lt;
          FunctionTraits&lt;OperationType&gt;::hasResult,
      JITCompiler::Call&gt;
      callOperation(OperationType operation, ResultRegType result, Args... args)
      {
          m_jit.setupArguments&lt;OperationType&gt;(args...);
          return appendCallSetResult(operation, result);
      }
  
<span class="line-removed">-     template&lt;typename OperationType, typename Arg, typename... Args&gt;</span>
<span class="line-removed">-     std::enable_if_t&lt;</span>
<span class="line-removed">-         !FunctionTraits&lt;OperationType&gt;::hasResult</span>
<span class="line-removed">-         &amp;&amp; !std::is_same&lt;Arg, NoResultTag&gt;::value,</span>
<span class="line-removed">-     JITCompiler::Call&gt;</span>
<span class="line-removed">-     callOperation(OperationType operation, Arg arg, Args... args)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         m_jit.setupArguments&lt;OperationType&gt;(arg, args...);</span>
<span class="line-removed">-         return appendCall(operation);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      template&lt;typename OperationType, typename... Args&gt;
      std::enable_if_t&lt;
          !FunctionTraits&lt;OperationType&gt;::hasResult,
      JITCompiler::Call&gt;
<span class="line-modified">!     callOperation(OperationType operation, NoResultTag, Args... args)</span>
      {
          m_jit.setupArguments&lt;OperationType&gt;(args...);
          return appendCall(operation);
      }
  
<span class="line-modified">!     template&lt;typename OperationType&gt;</span>
<span class="line-removed">-     std::enable_if_t&lt;</span>
<span class="line-removed">-         !FunctionTraits&lt;OperationType&gt;::hasResult,</span>
<span class="line-removed">-     JITCompiler::Call&gt;</span>
<span class="line-removed">-     callOperation(OperationType operation)</span>
      {
<span class="line-modified">!         m_jit.setupArguments&lt;OperationType&gt;();</span>
<span class="line-modified">!         return appendCall(operation);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #undef FIRST_ARGUMENT_TYPE</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JITCompiler::Call callOperationWithCallFrameRollbackOnException(V_JITOperation_ECb operation, void* pointer)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         m_jit.setupArguments&lt;V_JITOperation_ECb&gt;(TrustedImmPtr(pointer));</span>
          return appendCallWithCallFrameRollbackOnException(operation);
      }
  
<span class="line-modified">!     JITCompiler::Call callOperationWithCallFrameRollbackOnException(Z_JITOperation_E operation, GPRReg result)</span>
      {
<span class="line-modified">!         m_jit.setupArguments&lt;Z_JITOperation_E&gt;();</span>
          return appendCallWithCallFrameRollbackOnExceptionSetResult(operation, result);
      }
  
<span class="line-removed">- #if !defined(NDEBUG) &amp;&amp; !CPU(ARM_THUMB2) &amp;&amp; !CPU(MIPS)</span>
      void prepareForExternalCall()
      {
          // We&#39;re about to call out to a &quot;native&quot; helper function. The helper
<span class="line-modified">!         // function is expected to set topCallFrame itself with the ExecState</span>
          // that is passed to it.
          //
          // We explicitly trash topCallFrame here so that we&#39;ll know if some of
          // the helper functions are not setting topCallFrame when they should
          // be doing so. Note: the previous value in topcallFrame was not valid
          // anyway since it was not being updated by JIT&#39;ed code by design.
  
          for (unsigned i = 0; i &lt; sizeof(void*) / 4; i++)
              m_jit.store32(TrustedImm32(0xbadbeef), reinterpret_cast&lt;char*&gt;(&amp;vm().topCallFrame) + i * 4);
<span class="line-removed">-     }</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     void prepareForExternalCall() { }</span>
  #endif
  
      // These methods add call instructions, optionally setting results, and optionally rolling back the call frame on an exception.
      JITCompiler::Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
      {
          prepareForExternalCall();
<span class="line-new-header">--- 922,60 ---</span>
      {
          ASSERT(node-&gt;hasConstant());
          generationInfo(node).initConstant(node, node-&gt;refCount());
      }
  
      template&lt;typename OperationType, typename ResultRegType, typename... Args&gt;
      std::enable_if_t&lt;
          FunctionTraits&lt;OperationType&gt;::hasResult,
      JITCompiler::Call&gt;
      callOperation(OperationType operation, ResultRegType result, Args... args)
      {
          m_jit.setupArguments&lt;OperationType&gt;(args...);
          return appendCallSetResult(operation, result);
      }
  
      template&lt;typename OperationType, typename... Args&gt;
      std::enable_if_t&lt;
          !FunctionTraits&lt;OperationType&gt;::hasResult,
      JITCompiler::Call&gt;
<span class="line-modified">!     callOperation(OperationType operation, Args... args)</span>
      {
          m_jit.setupArguments&lt;OperationType&gt;(args...);
          return appendCall(operation);
      }
  
<span class="line-modified">!     JITCompiler::Call callOperationWithCallFrameRollbackOnException(V_JITOperation_Cb operation, CodeBlock* codeBlock)</span>
      {
<span class="line-modified">!         // Do not register CodeBlock* as a weak-pointer.</span>
<span class="line-modified">!         m_jit.setupArguments&lt;V_JITOperation_Cb&gt;(TrustedImmPtr(static_cast&lt;void*&gt;(codeBlock)));</span>
          return appendCallWithCallFrameRollbackOnException(operation);
      }
  
<span class="line-modified">!     JITCompiler::Call callOperationWithCallFrameRollbackOnException(Z_JITOperation_G operation, GPRReg result, JSGlobalObject* globalObject)</span>
      {
<span class="line-modified">!         m_jit.setupArguments&lt;Z_JITOperation_G&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject));</span>
          return appendCallWithCallFrameRollbackOnExceptionSetResult(operation, result);
      }
  
      void prepareForExternalCall()
      {
<span class="line-added">+ #if !defined(NDEBUG) &amp;&amp; !CPU(ARM_THUMB2) &amp;&amp; !CPU(MIPS)</span>
          // We&#39;re about to call out to a &quot;native&quot; helper function. The helper
<span class="line-modified">!         // function is expected to set topCallFrame itself with the CallFrame</span>
          // that is passed to it.
          //
          // We explicitly trash topCallFrame here so that we&#39;ll know if some of
          // the helper functions are not setting topCallFrame when they should
          // be doing so. Note: the previous value in topcallFrame was not valid
          // anyway since it was not being updated by JIT&#39;ed code by design.
  
          for (unsigned i = 0; i &lt; sizeof(void*) / 4; i++)
              m_jit.store32(TrustedImm32(0xbadbeef), reinterpret_cast&lt;char*&gt;(&amp;vm().topCallFrame) + i * 4);
  #endif
<span class="line-added">+         m_jit.prepareCallOperation(vm());</span>
<span class="line-added">+     }</span>
  
      // These methods add call instructions, optionally setting results, and optionally rolling back the call frame on an exception.
      JITCompiler::Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
      {
          prepareForExternalCall();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,21 ***</span>
  #else
          return appendCallSetResult(function, resultRegs.payloadGPR(), resultRegs.tagGPR());
  #endif
      }
  
<span class="line-modified">! #if CPU(X86)</span>
<span class="line-removed">-     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         JITCompiler::Call call = appendCall(function);</span>
<span class="line-removed">-         if (result != InvalidFPRReg) {</span>
<span class="line-removed">-             m_jit.assembler().fstpl(0, JITCompiler::stackPointerRegister);</span>
<span class="line-removed">-             m_jit.loadDouble(JITCompiler::stackPointerRegister, result);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return call;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #elif CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP)</span>
      JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)
      {
          JITCompiler::Call call = appendCall(function);
          if (result != InvalidFPRReg)
              m_jit.assembler().vmov(result, GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
<span class="line-new-header">--- 1020,11 ---</span>
  #else
          return appendCallSetResult(function, resultRegs.payloadGPR(), resultRegs.tagGPR());
  #endif
      }
  
<span class="line-modified">! #if CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP)</span>
      JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)
      {
          JITCompiler::Call call = appendCall(function);
          if (result != InvalidFPRReg)
              m_jit.assembler().vmov(result, GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1173,13 ***</span>
      bool betterUseStrictInt52(Edge edge)
      {
          return betterUseStrictInt52(edge.node());
      }
  
<span class="line-modified">!     bool compare(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_EJJ);</span>
      void compileCompareUnsigned(Node*, MacroAssembler::RelationalCondition);
<span class="line-modified">!     bool compilePeepHoleBranch(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_EJJ);</span>
      void compilePeepHoleInt32Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
      void compilePeepHoleInt52Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
      void compilePeepHoleBooleanBranch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
      void compilePeepHoleDoubleBranch(Node*, Node* branchNode, JITCompiler::DoubleCondition);
      void compilePeepHoleObjectEquality(Node*, Node* branchNode);
<span class="line-new-header">--- 1141,13 ---</span>
      bool betterUseStrictInt52(Edge edge)
      {
          return betterUseStrictInt52(edge.node());
      }
  
<span class="line-modified">!     bool compare(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_GJJ);</span>
      void compileCompareUnsigned(Node*, MacroAssembler::RelationalCondition);
<span class="line-modified">!     bool compilePeepHoleBranch(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_GJJ);</span>
      void compilePeepHoleInt32Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
      void compilePeepHoleInt52Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
      void compilePeepHoleBooleanBranch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
      void compilePeepHoleDoubleBranch(Node*, Node* branchNode, JITCompiler::DoubleCondition);
      void compilePeepHoleObjectEquality(Node*, Node* branchNode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1231,17 ***</span>
          BasicBlock* target;
      };
  
      void emitSwitchIntJump(SwitchData*, GPRReg value, GPRReg scratch);
      void emitSwitchImm(Node*, SwitchData*);
<span class="line-modified">!     void emitSwitchCharStringJump(SwitchData*, GPRReg value, GPRReg scratch);</span>
      void emitSwitchChar(Node*, SwitchData*);
      void emitBinarySwitchStringRecurse(
          SwitchData*, const Vector&lt;StringSwitchCase&gt;&amp;, unsigned numChecked,
          unsigned begin, unsigned end, GPRReg buffer, GPRReg length, GPRReg temp,
          unsigned alreadyCheckedLength, bool checkedExactLength);
<span class="line-modified">!     void emitSwitchStringOnString(SwitchData*, GPRReg string);</span>
      void emitSwitchString(Node*, SwitchData*);
      void emitSwitch(Node*);
  
      void compileToStringOrCallStringConstructorOrStringValueOf(Node*);
      void compileNumberToStringWithRadix(Node*);
<span class="line-new-header">--- 1199,17 ---</span>
          BasicBlock* target;
      };
  
      void emitSwitchIntJump(SwitchData*, GPRReg value, GPRReg scratch);
      void emitSwitchImm(Node*, SwitchData*);
<span class="line-modified">!     void emitSwitchCharStringJump(Node*, SwitchData*, GPRReg value, GPRReg scratch);</span>
      void emitSwitchChar(Node*, SwitchData*);
      void emitBinarySwitchStringRecurse(
          SwitchData*, const Vector&lt;StringSwitchCase&gt;&amp;, unsigned numChecked,
          unsigned begin, unsigned end, GPRReg buffer, GPRReg length, GPRReg temp,
          unsigned alreadyCheckedLength, bool checkedExactLength);
<span class="line-modified">!     void emitSwitchStringOnString(Node*, SwitchData*, GPRReg string);</span>
      void emitSwitchString(Node*, SwitchData*);
      void emitSwitch(Node*);
  
      void compileToStringOrCallStringConstructorOrStringValueOf(Node*);
      void compileNumberToStringWithRadix(Node*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1312,11 ***</span>
      void compileGetGlobalThis(Node*);
  
      void compileGetArrayLength(Node*);
  
      void compileCheckTypeInfoFlags(Node*);
<span class="line-modified">!     void compileCheckStringIdent(Node*);</span>
  
      void compileParseInt(Node*);
  
      void compileValueRep(Node*);
      void compileDoubleRep(Node*);
<span class="line-new-header">--- 1280,11 ---</span>
      void compileGetGlobalThis(Node*);
  
      void compileGetArrayLength(Node*);
  
      void compileCheckTypeInfoFlags(Node*);
<span class="line-modified">!     void compileCheckIdent(Node*);</span>
  
      void compileParseInt(Node*);
  
      void compileValueRep(Node*);
      void compileDoubleRep(Node*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1326,32 ***</span>
      void compileDoubleAsInt32(Node*);
  
      void compileValueBitNot(Node*);
      void compileBitwiseNot(Node*);
  
<span class="line-modified">!     template&lt;typename SnippetGenerator, J_JITOperation_EJJ slowPathFunction&gt;</span>
      void emitUntypedBitOp(Node*);
      void compileBitwiseOp(Node*);
      void compileValueBitwiseOp(Node*);
  
      void emitUntypedRightShiftBitOp(Node*);
      void compileValueLShiftOp(Node*);
      void compileShiftOp(Node*);
  
      template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
      void compileMathIC(Node*, JITBinaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction, NonRepatchingFunction);
      template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
      void compileMathIC(Node*, JITUnaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, RepatchingFunction, NonRepatchingFunction);
  
<span class="line-modified">!     void compileArithDoubleUnaryOp(Node*, double (*doubleFunction)(double), double (*operation)(ExecState*, EncodedJSValue));</span>
      void compileValueAdd(Node*);
      void compileValueSub(Node*);
      void compileArithAdd(Node*);
      void compileMakeRope(Node*);
      void compileArithAbs(Node*);
      void compileArithClz32(Node*);
      void compileArithSub(Node*);
      void compileValueNegate(Node*);
      void compileArithNegate(Node*);
      void compileValueMul(Node*);
      void compileArithMul(Node*);
      void compileValueDiv(Node*);
<span class="line-new-header">--- 1294,34 ---</span>
      void compileDoubleAsInt32(Node*);
  
      void compileValueBitNot(Node*);
      void compileBitwiseNot(Node*);
  
<span class="line-modified">!     template&lt;typename SnippetGenerator, J_JITOperation_GJJ slowPathFunction&gt;</span>
      void emitUntypedBitOp(Node*);
      void compileBitwiseOp(Node*);
      void compileValueBitwiseOp(Node*);
  
      void emitUntypedRightShiftBitOp(Node*);
      void compileValueLShiftOp(Node*);
<span class="line-added">+     void compileValueBitRShift(Node*);</span>
      void compileShiftOp(Node*);
  
      template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
      void compileMathIC(Node*, JITBinaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction, NonRepatchingFunction);
      template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
      void compileMathIC(Node*, JITUnaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, RepatchingFunction, NonRepatchingFunction);
  
<span class="line-modified">!     void compileArithDoubleUnaryOp(Node*, double (*doubleFunction)(double), double (*operation)(JSGlobalObject*, EncodedJSValue));</span>
      void compileValueAdd(Node*);
      void compileValueSub(Node*);
      void compileArithAdd(Node*);
      void compileMakeRope(Node*);
      void compileArithAbs(Node*);
      void compileArithClz32(Node*);
      void compileArithSub(Node*);
<span class="line-added">+     void compileIncOrDec(Node*);</span>
      void compileValueNegate(Node*);
      void compileArithNegate(Node*);
      void compileValueMul(Node*);
      void compileArithMul(Node*);
      void compileValueDiv(Node*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1398,18 ***</span>
<span class="line-new-header">--- 1368,20 ---</span>
      template &lt;typename ClassType&gt; void compileNewFunctionCommon(GPRReg, RegisteredStructure, GPRReg, GPRReg, GPRReg, MacroAssembler::JumpList&amp;, size_t, FunctionExecutable*);
      void compileNewFunction(Node*);
      void compileSetFunctionName(Node*);
      void compileNewRegexp(Node*);
      void compileForwardVarargs(Node*);
<span class="line-added">+     void compileVarargsLength(Node*);</span>
      void compileLoadVarargs(Node*);
      void compileCreateActivation(Node*);
      void compileCreateDirectArguments(Node*);
      void compileGetFromArguments(Node*);
      void compilePutToArguments(Node*);
      void compileGetArgument(Node*);
      void compileCreateScopedArguments(Node*);
      void compileCreateClonedArguments(Node*);
<span class="line-added">+     void compileCreateArgumentsButterfly(Node*);</span>
      void compileCreateRest(Node*);
      void compileSpread(Node*);
      void compileNewArray(Node*);
      void compileNewArrayWithSpread(Node*);
      void compileGetRestLength(Node*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1446,10 ***</span>
<span class="line-new-header">--- 1418,12 ---</span>
      void compilePutGlobalVariable(Node*);
      void compileGetDynamicVar(Node*);
      void compilePutDynamicVar(Node*);
      void compileGetClosureVar(Node*);
      void compilePutClosureVar(Node*);
<span class="line-added">+     void compileGetInternalField(Node*);</span>
<span class="line-added">+     void compilePutInternalField(Node*);</span>
      void compileCompareEqPtr(Node*);
      void compileDefineDataProperty(Node*);
      void compileDefineAccessorProperty(Node*);
      void compileStringSlice(Node*);
      void compileToLowerCase(Node*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1479,18 ***</span>
<span class="line-new-header">--- 1453,34 ---</span>
      void compileNewTypedArray(Node*);
      void compileToThis(Node*);
      void compileObjectKeys(Node*);
      void compileObjectCreate(Node*);
      void compileCreateThis(Node*);
<span class="line-added">+     void compileCreatePromise(Node*);</span>
<span class="line-added">+     void compileCreateGenerator(Node*);</span>
<span class="line-added">+     void compileCreateAsyncGenerator(Node*);</span>
      void compileNewObject(Node*);
<span class="line-added">+     void compileNewPromise(Node*);</span>
<span class="line-added">+     void compileNewGenerator(Node*);</span>
<span class="line-added">+     void compileNewAsyncGenerator(Node*);</span>
<span class="line-added">+     void compileNewArrayIterator(Node*);</span>
      void compileToPrimitive(Node*);
<span class="line-added">+     void compileToPropertyKey(Node*);</span>
<span class="line-added">+     void compileToNumeric(Node*);</span>
      void compileLogShadowChickenPrologue(Node*);
      void compileLogShadowChickenTail(Node*);
      void compileHasIndexedProperty(Node*);
      void compileExtractCatchLocal(Node*);
      void compileClearCatchLocals(Node*);
      void compileProfileType(Node*);
<span class="line-added">+     void compileStringCodePointAt(Node*);</span>
<span class="line-added">+     void compileDateGet(Node*);</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">+     void compileCreateInternalFieldObject(Node*, Operation);</span>
<span class="line-added">+     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">+     void compileNewInternalFieldObject(Node*, Operation);</span>
  
      void moveTrueTo(GPRReg);
      void moveFalseTo(GPRReg);
      void blessBoolean(GPRReg);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1603,14 ***</span>
<span class="line-new-header">--- 1593,18 ---</span>
      void speculateFunction(Edge);
      void speculateFinalObject(Edge, GPRReg cell);
      void speculateFinalObject(Edge);
      void speculateRegExpObject(Edge, GPRReg cell);
      void speculateRegExpObject(Edge);
<span class="line-added">+     void speculatePromiseObject(Edge);</span>
<span class="line-added">+     void speculatePromiseObject(Edge, GPRReg cell);</span>
      void speculateProxyObject(Edge, GPRReg cell);
      void speculateProxyObject(Edge);
      void speculateDerivedArray(Edge, GPRReg cell);
      void speculateDerivedArray(Edge);
<span class="line-added">+     void speculateDateObject(Edge);</span>
<span class="line-added">+     void speculateDateObject(Edge, GPRReg cell);</span>
      void speculateMapObject(Edge);
      void speculateMapObject(Edge, GPRReg cell);
      void speculateSetObject(Edge);
      void speculateSetObject(Edge, GPRReg cell);
      void speculateWeakMapObject(Edge);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1654,19 ***</span>
      GPRReg fillSpeculateInt32Internal(Edge, DataFormat&amp; returnFormat);
  
      void cageTypedArrayStorage(GPRReg, GPRReg);
  
      void recordSetLocal(
<span class="line-modified">!         VirtualRegister bytecodeReg, VirtualRegister machineReg, DataFormat format)</span>
      {
          m_stream-&gt;appendAndLog(VariableEvent::setLocal(bytecodeReg, machineReg, format));
      }
  
      void recordSetLocal(DataFormat format)
      {
          VariableAccessData* variable = m_currentNode-&gt;variableAccessData();
<span class="line-modified">!         recordSetLocal(variable-&gt;local(), variable-&gt;machineLocal(), format);</span>
      }
  
      GenerationInfo&amp; generationInfoFromVirtualRegister(VirtualRegister virtualRegister)
      {
          return m_generationInfo[virtualRegister.toLocal()];
<span class="line-new-header">--- 1648,20 ---</span>
      GPRReg fillSpeculateInt32Internal(Edge, DataFormat&amp; returnFormat);
  
      void cageTypedArrayStorage(GPRReg, GPRReg);
  
      void recordSetLocal(
<span class="line-modified">!         Operand bytecodeReg, VirtualRegister machineReg, DataFormat format)</span>
      {
<span class="line-added">+         ASSERT(!bytecodeReg.isArgument() || bytecodeReg.virtualRegister().toArgument() &gt;= 0);</span>
          m_stream-&gt;appendAndLog(VariableEvent::setLocal(bytecodeReg, machineReg, format));
      }
  
      void recordSetLocal(DataFormat format)
      {
          VariableAccessData* variable = m_currentNode-&gt;variableAccessData();
<span class="line-modified">!         recordSetLocal(variable-&gt;operand(), variable-&gt;machineLocal(), format);</span>
      }
  
      GenerationInfo&amp; generationInfoFromVirtualRegister(VirtualRegister virtualRegister)
      {
          return m_generationInfo[virtualRegister.toLocal()];
</pre>
<center><a href="DFGSpeculativeJIT.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
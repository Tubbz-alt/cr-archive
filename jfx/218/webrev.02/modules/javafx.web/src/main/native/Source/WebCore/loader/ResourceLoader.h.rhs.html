<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/ResourceLoader.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;LoadTiming.h&quot;
 32 #include &quot;ResourceHandleClient.h&quot;
 33 #include &quot;ResourceLoaderOptions.h&quot;
 34 #include &quot;ResourceLoaderTypes.h&quot;
 35 #include &quot;ResourceRequest.h&quot;
 36 #include &quot;ResourceResponse.h&quot;
 37 #include &lt;wtf/Forward.h&gt;
 38 #include &lt;wtf/WeakPtr.h&gt;
 39 
 40 #if ENABLE(CONTENT_EXTENSIONS)
 41 #include &quot;ResourceLoadInfo.h&quot;
 42 #endif
 43 
 44 namespace WTF {
 45 class SchedulePair;
 46 }
 47 
 48 namespace WebCore {
 49 
 50 class AuthenticationChallenge;
 51 class DocumentLoader;
 52 class Frame;
 53 class FrameLoader;
<a name="1" id="anc1"></a><span class="line-added"> 54 class LegacyPreviewLoader;</span>
 55 class NetworkLoadMetrics;
<a name="2" id="anc2"></a>
 56 
<a name="3" id="anc3"></a><span class="line-added"> 57 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ResourceLoader);</span>
 58 class ResourceLoader : public CanMakeWeakPtr&lt;ResourceLoader&gt;, public RefCounted&lt;ResourceLoader&gt;, protected ResourceHandleClient {
<a name="4" id="anc4"></a><span class="line-added"> 59     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ResourceLoader);</span>
 60 public:
 61     virtual ~ResourceLoader() = 0;
 62 
 63     WEBCORE_EXPORT void cancel();
 64 
 65     virtual void init(ResourceRequest&amp;&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;);
 66 
 67     void deliverResponseAndData(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;&amp;&amp;);
 68 
 69 #if PLATFORM(IOS_FAMILY)
 70     virtual void startLoading()
 71     {
 72         start();
 73     }
 74 
 75     virtual const ResourceRequest&amp; iOSOriginalRequest() const { return request(); }
 76 #endif
 77 
 78     WEBCORE_EXPORT FrameLoader* frameLoader() const;
 79     DocumentLoader* documentLoader() const { return m_documentLoader.get(); }
 80     const ResourceRequest&amp; originalRequest() const { return m_originalRequest; }
 81 
 82     WEBCORE_EXPORT void start();
 83     WEBCORE_EXPORT void cancel(const ResourceError&amp;);
 84     WEBCORE_EXPORT ResourceError cancelledError();
 85     ResourceError blockedError();
 86     ResourceError blockedByContentBlockerError();
 87     ResourceError cannotShowURLError();
 88 
 89     virtual void setDefersLoading(bool);
 90     bool defersLoading() const { return m_defersLoading; }
 91 
 92     unsigned long identifier() const { return m_identifier; }
 93 
 94     bool wasAuthenticationChallengeBlocked() const { return m_wasAuthenticationChallengeBlocked; }
 95 
 96     virtual void releaseResources();
 97     const ResourceResponse&amp; response() const { return m_response; }
 98 
 99     SharedBuffer* resourceData() const { return m_resourceData.get(); }
100     void clearResourceData();
101 
102     virtual bool isSubresourceLoader() const;
103 
104     virtual void willSendRequest(ResourceRequest&amp;&amp;, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; callback);
105     virtual void didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent);
106     virtual void didReceiveResponse(const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler);
107     virtual void didReceiveData(const char*, unsigned, long long encodedDataLength, DataPayloadType);
108     virtual void didReceiveBuffer(Ref&lt;SharedBuffer&gt;&amp;&amp;, long long encodedDataLength, DataPayloadType);
109     virtual void didFinishLoading(const NetworkLoadMetrics&amp;);
110     virtual void didFail(const ResourceError&amp;);
111 
112     WEBCORE_EXPORT void didBlockAuthenticationChallenge();
113 
114     virtual bool shouldUseCredentialStorage();
115 #if USE(PROTECTION_SPACE_AUTH_CALLBACK)
116     virtual bool canAuthenticateAgainstProtectionSpace(const ProtectionSpace&amp;);
117 #endif
118     virtual void receivedCancellation(const AuthenticationChallenge&amp;);
119 
120 #if USE(QUICK_LOOK)
121     bool isQuickLookResource() const;
<a name="5" id="anc5"></a><span class="line-added">122     virtual void didReceivePreviewResponse(const ResourceResponse&amp;) { };</span>
123 #endif
124 
125     const URL&amp; url() const { return m_request.url(); }
126     ResourceHandle* handle() const { return m_handle.get(); }
127     bool shouldSendResourceLoadCallbacks() const { return m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks; }
128     void setSendCallbackPolicy(SendCallbackPolicy sendLoadCallbacks) { m_options.sendLoadCallbacks = sendLoadCallbacks; }
129     bool shouldSniffContent() const { return m_options.sniffContent == ContentSniffingPolicy::SniffContent; }
130     bool shouldSniffContentEncoding() const { return m_options.sniffContentEncoding == ContentEncodingSniffingPolicy::Sniff; }
131     WEBCORE_EXPORT bool isAllowedToAskUserForCredentials() const;
132     WEBCORE_EXPORT bool shouldIncludeCertificateInfo() const;
133 
134     bool reachedTerminalState() const { return m_reachedTerminalState; }
135 
<a name="6" id="anc6"></a>
136     const ResourceRequest&amp; request() const { return m_request; }
137     void setRequest(ResourceRequest&amp;&amp; request) { m_request = WTFMove(request); }
138 
139     void setDataBufferingPolicy(DataBufferingPolicy);
140 
141     void willSwitchToSubstituteResource();
142 
143     const LoadTiming&amp; loadTiming() { return m_loadTiming; }
144 
145 #if PLATFORM(COCOA)
146     void schedule(WTF::SchedulePair&amp;);
147     void unschedule(WTF::SchedulePair&amp;);
148 #endif
149 
150     const Frame* frame() const { return m_frame.get(); }
151     WEBCORE_EXPORT bool isAlwaysOnLoggingAllowed() const;
152 
153     const ResourceLoaderOptions&amp; options() const { return m_options; }
154 
155     const ResourceRequest&amp; deferredRequest() const { return m_deferredRequest; }
156     ResourceRequest takeDeferredRequest() { return std::exchange(m_deferredRequest, { }); }
157 
158 protected:
159     ResourceLoader(Frame&amp;, ResourceLoaderOptions);
160 
161     void didFinishLoadingOnePart(const NetworkLoadMetrics&amp;);
162     void cleanupForError(const ResourceError&amp;);
163 
164     bool wasCancelled() const { return m_cancellationStatus &gt;= Cancelled; }
165 
166     void didReceiveDataOrBuffer(const char*, unsigned, RefPtr&lt;SharedBuffer&gt;&amp;&amp;, long long encodedDataLength, DataPayloadType);
167 
168     void setReferrerPolicy(ReferrerPolicy referrerPolicy) { m_options.referrerPolicy = referrerPolicy; }
169     ReferrerPolicy referrerPolicy() const { return m_options.referrerPolicy; }
170 
171 #if PLATFORM(COCOA)
172     void willCacheResponseAsync(ResourceHandle*, NSCachedURLResponse*, CompletionHandler&lt;void(NSCachedURLResponse *)&gt;&amp;&amp;) override;
173 #endif
174 
175     virtual void willSendRequestInternal(ResourceRequest&amp;&amp;, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
176 
177     RefPtr&lt;ResourceHandle&gt; m_handle;
178     RefPtr&lt;Frame&gt; m_frame;
179     RefPtr&lt;DocumentLoader&gt; m_documentLoader;
180     ResourceResponse m_response;
181     LoadTiming m_loadTiming;
182 #if USE(QUICK_LOOK)
<a name="7" id="anc7"></a><span class="line-modified">183     std::unique_ptr&lt;LegacyPreviewLoader&gt; m_previewLoader;</span>
184 #endif
185     bool m_canCrossOriginRequestsAskUserForCredentials { true };
186 
187 private:
188     virtual void willCancel(const ResourceError&amp;) = 0;
189     virtual void didCancel(const ResourceError&amp;) = 0;
190 
191     void addDataOrBuffer(const char*, unsigned, SharedBuffer*, DataPayloadType);
192     void loadDataURL();
193     void finishNetworkLoad();
194 
195     bool shouldAllowResourceToAskForCredentials() const;
196 
197     // ResourceHandleClient
198     void didSendData(ResourceHandle*, unsigned long long bytesSent, unsigned long long totalBytesToBeSent) override;
199     void didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;) override;
200     void willSendRequestAsync(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;) override;
201     void didReceiveData(ResourceHandle*, const char*, unsigned, int encodedDataLength) override;
202     void didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, int encodedDataLength) override;
203     void didFinishLoading(ResourceHandle*) override;
204     void didFail(ResourceHandle*, const ResourceError&amp;) override;
205     void wasBlocked(ResourceHandle*) override;
206     void cannotShowURL(ResourceHandle*) override;
207     bool shouldUseCredentialStorage(ResourceHandle*) override { return shouldUseCredentialStorage(); }
208     void didReceiveAuthenticationChallenge(ResourceHandle*, const AuthenticationChallenge&amp;) override;
209 #if USE(PROTECTION_SPACE_AUTH_CALLBACK)
210     void canAuthenticateAgainstProtectionSpaceAsync(ResourceHandle*, const ProtectionSpace&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;) override;
211 #endif
212     void receivedCancellation(ResourceHandle*, const AuthenticationChallenge&amp; challenge) override { receivedCancellation(challenge); }
213 #if PLATFORM(IOS_FAMILY)
214     RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceHandle*) override;
215 #endif
216 #if USE(CFURLCONNECTION)
217     // FIXME: Windows should use willCacheResponse - &lt;https://bugs.webkit.org/show_bug.cgi?id=57257&gt;.
218     bool shouldCacheResponse(ResourceHandle*, CFCachedURLResponseRef) override;
219 #endif
220 
221 #if USE(SOUP)
222     void loadGResource();
223 #endif
224 
225     ResourceRequest m_request;
226     ResourceRequest m_originalRequest; // Before redirects.
227     RefPtr&lt;SharedBuffer&gt; m_resourceData;
228 
229     unsigned long m_identifier { 0 };
230 
231     bool m_reachedTerminalState { false };
232     bool m_notifiedLoadComplete { false };
233 
234     enum CancellationStatus {
235         NotCancelled,
236         CalledWillCancel,
237         Cancelled,
238         FinishedCancel
239     };
240     CancellationStatus m_cancellationStatus { NotCancelled };
241 
242     bool m_defersLoading;
243     bool m_wasAuthenticationChallengeBlocked { false };
244     ResourceRequest m_deferredRequest;
245     ResourceLoaderOptions m_options;
246 
247 #if ENABLE(CONTENT_EXTENSIONS)
248 protected:
249     ContentExtensions::ResourceType m_resourceType { ContentExtensions::ResourceType::Invalid };
250 #endif
251 };
252 
253 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
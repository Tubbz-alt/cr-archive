diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.h
@@ -33,21 +33,19 @@
 #include <wtf/StdLibExtras.h>
 #include <wtf/Vector.h>
 
 namespace JSC {
 
+class CallFrame;
 class CodeBlock;
-class ExecState;
 class JSArray;
 class JSObject;
 class JSScope;
 class LLIntOffsetsExtractor;
 class SlotVisitor;
 class VM;
 
-typedef ExecState CallFrame;
-
 // ShadowChicken is a log that can be used to produce a shadow stack of CHICKEN-style stack frames.
 // This enables the debugger to almost always see the tail-deleted stack frames, so long as we have
 // memory inside ShadowChicken to remember them.
 //
 // The ShadowChicken log comprises packets that have one of two shapes:
@@ -75,13 +73,13 @@
     struct Packet {
         Packet()
         {
         }
 
-        static const constexpr unsigned unlikelyValue = 0x7a11;
+        static constexpr unsigned unlikelyValue = 0x7a11;
 
-        static const constexpr intptr_t tailMarkerValue = static_cast<intptr_t>(unlikelyValue);
+        static constexpr intptr_t tailMarkerValue = static_cast<intptr_t>(unlikelyValue);
         static JSObject* tailMarker()
         {
             return bitwise_cast<JSObject*>(tailMarkerValue);
         }
 
@@ -184,21 +182,21 @@
     };
 
     ShadowChicken();
     ~ShadowChicken();
 
-    void log(VM& vm, ExecState* exec, const Packet&);
+    void log(VM& vm, CallFrame*, const Packet&);
 
-    void update(VM&, ExecState*);
+    void update(VM&, CallFrame*);
 
     // Expects this signature: (const Frame& frame) -> bool. Return true to keep iterating. Return false to stop iterating.
     // Note that this only works right with inlining disabled, but that's OK since for now we
     // disable inlining when the inspector is attached. It would be easy to make this work with
     // inlining, and would mostly require that we can request that StackVisitor doesn't skip tail
     // frames.
     template<typename Functor>
-    void iterate(VM&, ExecState*, const Functor&);
+    void iterate(VM&, CallFrame*, const Functor&);
 
     void visitChildren(SlotVisitor&);
     void reset();
 
     // JIT support.
@@ -207,11 +205,11 @@
     Packet** addressOfLogCursor() { return &m_logCursor; }
     Packet* logEnd() { return m_logEnd; }
 
     void dump(PrintStream&) const;
 
-    JS_EXPORT_PRIVATE JSArray* functionsOnStack(ExecState*);
+    JS_EXPORT_PRIVATE JSArray* functionsOnStack(JSGlobalObject*, CallFrame*);
 
 private:
     friend class LLIntOffsetsExtractor;
 
     Packet* m_log { nullptr };

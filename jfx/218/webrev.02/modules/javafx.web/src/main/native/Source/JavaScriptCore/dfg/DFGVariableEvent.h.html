<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEvent.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGMinifiedID.h&quot;
 31 #include &quot;DataFormat.h&quot;
 32 #include &quot;MacroAssembler.h&quot;
 33 #include &quot;Operands.h&quot;
 34 #include &quot;VirtualRegister.h&quot;
 35 #include &lt;stdio.h&gt;
 36 
 37 namespace JSC { namespace DFG {
 38 
 39 enum VariableEventKind : uint8_t {
 40     // Marks the beginning of a checkpoint. If you interpret the variable
 41     // events starting at a Reset point then you&#39;ll get everything you need.
 42     Reset,
 43 
 44     // Node births. Points in the code where a node becomes relevant for OSR.
 45     // It may be the point where it is actually born (i.e. assigned) or it may
 46     // be a later point, if it&#39;s only later in the sequence of instructions
 47     // that we start to care about this node.
 48     BirthToFill,
 49     BirthToSpill,
 50     Birth,
 51 
 52     // Events related to how a node is represented.
 53     Fill,
 54     Spill,
 55 
 56     // Death of a node - after this we no longer care about this node.
 57     Death,
 58 
 59     // A MovHintEvent means that a node is being associated with a bytecode operand,
 60     // but that it has not been stored into that operand.
 61     MovHintEvent,
 62 
 63     // A SetLocalEvent means that a node&#39;s value has been stored into the stack.
 64     SetLocalEvent,
 65 
 66     // Used to indicate an uninitialized VariableEvent. Don&#39;t use for other
 67     // purposes.
 68     InvalidEventKind
 69 };
 70 
 71 union VariableRepresentation {
 72     VariableRepresentation()
 73         : operand()
 74     { }
 75 
 76     MacroAssembler::RegisterID gpr;
 77     MacroAssembler::FPRegisterID fpr;
 78 #if USE(JSVALUE32_64)
 79     struct {
 80         MacroAssembler::RegisterID tagGPR;
 81         MacroAssembler::RegisterID payloadGPR;
 82     } pair;
 83 #endif
 84     Operand operand;
 85 };
 86 
 87 class VariableEvent {
 88 public:
 89     VariableEvent()
 90         : m_kind(InvalidEventKind)
 91     {
 92     }
 93 
 94     static VariableEvent reset()
 95     {
 96         VariableEvent event;
 97         event.m_kind = Reset;
 98         return event;
 99     }
100 
101     static VariableEvent fillGPR(VariableEventKind kind, MinifiedID id, MacroAssembler::RegisterID gpr, DataFormat dataFormat)
102     {
103         ASSERT(kind == BirthToFill || kind == Fill);
104         ASSERT(dataFormat != DataFormatDouble);
105 #if USE(JSVALUE32_64)
106         ASSERT(!(dataFormat &amp; DataFormatJS));
107 #endif
108         VariableEvent event;
109         WhichType which;
110         which.id = id.bits();
111         VariableRepresentation representation;
112         representation.gpr = gpr;
113         event.m_kind = kind;
114         event.m_dataFormat = dataFormat;
115         event.m_which = WTFMove(which);
116         event.m_representation = WTFMove(representation);
117         return event;
118     }
119 
120 #if USE(JSVALUE32_64)
121     static VariableEvent fillPair(VariableEventKind kind, MinifiedID id, MacroAssembler::RegisterID tagGPR, MacroAssembler::RegisterID payloadGPR)
122     {
123         ASSERT(kind == BirthToFill || kind == Fill);
124         VariableEvent event;
125         WhichType which;
126         which.id = id.bits();
127         VariableRepresentation representation;
128         representation.pair.tagGPR = tagGPR;
129         representation.pair.payloadGPR = payloadGPR;
130         event.m_kind = kind;
131         event.m_dataFormat = DataFormatJS;
132         event.m_which = WTFMove(which);
133         event.m_representation = WTFMove(representation);
134         return event;
135     }
136 #endif // USE(JSVALUE32_64)
137 
138     static VariableEvent fillFPR(VariableEventKind kind, MinifiedID id, MacroAssembler::FPRegisterID fpr)
139     {
140         ASSERT(kind == BirthToFill || kind == Fill);
141         VariableEvent event;
142         WhichType which;
143         which.id = id.bits();
144         VariableRepresentation representation;
145         representation.fpr = fpr;
146         event.m_kind = kind;
147         event.m_dataFormat = DataFormatDouble;
148         event.m_which = WTFMove(which);
149         event.m_representation = WTFMove(representation);
150         return event;
151     }
152 
153     static VariableEvent birth(MinifiedID id)
154     {
155         VariableEvent event;
156         WhichType which;
157         which.id = id.bits();
158         event.m_kind = Birth;
159         event.m_which = WTFMove(which);
160         return event;
161     }
162 
163     static VariableEvent spill(VariableEventKind kind, MinifiedID id, VirtualRegister virtualRegister, DataFormat format)
164     {
165         ASSERT(kind == BirthToSpill || kind == Spill);
166         VariableEvent event;
167         WhichType which;
168         which.id = id.bits();
169         VariableRepresentation representation;
170         representation.operand = virtualRegister;
171         event.m_kind = kind;
172         event.m_dataFormat = format;
173         event.m_which = WTFMove(which);
174         event.m_representation = WTFMove(representation);
175         return event;
176     }
177 
178     static VariableEvent death(MinifiedID id)
179     {
180         VariableEvent event;
181         WhichType which;
182         which.id = id.bits();
183         event.m_kind = Death;
184         event.m_which = WTFMove(which);
185         return event;
186     }
187 
188     static VariableEvent setLocal(
189         Operand bytecodeOperand, VirtualRegister machineReg, DataFormat format)
190     {
191         VariableEvent event;
192         WhichType which;
193         which.virtualReg = machineReg.offset();
194         VariableRepresentation representation;
195         representation.operand = bytecodeOperand;
196         event.m_kind = SetLocalEvent;
197         event.m_dataFormat = format;
198         event.m_which = WTFMove(which);
199         event.m_representation = WTFMove(representation);
200         return event;
201     }
202 
203     static VariableEvent movHint(MinifiedID id, Operand bytecodeReg)
204     {
205         VariableEvent event;
206         WhichType which;
207         which.id = id.bits();
208         VariableRepresentation representation;
209         representation.operand = bytecodeReg;
210         event.m_kind = MovHintEvent;
211         event.m_which = WTFMove(which);
212         event.m_representation = WTFMove(representation);
213         return event;
214     }
215 
216     VariableEventKind kind() const
217     {
218         return static_cast&lt;VariableEventKind&gt;(m_kind);
219     }
220 
221     MinifiedID id() const
222     {
223         ASSERT(
224             m_kind == BirthToFill || m_kind == Fill || m_kind == BirthToSpill || m_kind == Spill
225             || m_kind == Death || m_kind == MovHintEvent || m_kind == Birth);
226         return MinifiedID::fromBits(m_which.get().id);
227     }
228 
229     DataFormat dataFormat() const
230     {
231         ASSERT(
232             m_kind == BirthToFill || m_kind == Fill || m_kind == BirthToSpill || m_kind == Spill
233             || m_kind == SetLocalEvent);
234         return m_dataFormat;
235     }
236 
237     MacroAssembler::RegisterID gpr() const
238     {
239         ASSERT(m_kind == BirthToFill || m_kind == Fill);
240         ASSERT(m_dataFormat);
241         ASSERT(m_dataFormat != DataFormatDouble);
242 #if USE(JSVALUE32_64)
243         ASSERT(!(m_dataFormat &amp; DataFormatJS));
244 #endif
245         return m_representation.get().gpr;
246     }
247 
248 #if USE(JSVALUE32_64)
249     MacroAssembler::RegisterID tagGPR() const
250     {
251         ASSERT(m_kind == BirthToFill || m_kind == Fill);
252         ASSERT(m_dataFormat &amp; DataFormatJS);
253         return m_representation.get().pair.tagGPR;
254     }
255     MacroAssembler::RegisterID payloadGPR() const
256     {
257         ASSERT(m_kind == BirthToFill || m_kind == Fill);
258         ASSERT(m_dataFormat &amp; DataFormatJS);
259         return m_representation.get().pair.payloadGPR;
260     }
261 #endif // USE(JSVALUE32_64)
262 
263     MacroAssembler::FPRegisterID fpr() const
264     {
265         ASSERT(m_kind == BirthToFill || m_kind == Fill);
266         ASSERT(m_dataFormat == DataFormatDouble);
267         return m_representation.get().fpr;
268     }
269 
270     VirtualRegister spillRegister() const
271     {
272         ASSERT(m_kind == BirthToSpill || m_kind == Spill);
273         return m_representation.get().operand.virtualRegister();
274     }
275 
276     Operand operand() const
277     {
278         ASSERT(m_kind == SetLocalEvent || m_kind == MovHintEvent);
279         return m_representation.get().operand;
280     }
281 
282     VirtualRegister machineRegister() const
283     {
284         ASSERT(m_kind == SetLocalEvent);
285         return VirtualRegister(m_which.get().virtualReg);
286     }
287 
288     VariableRepresentation variableRepresentation() const { return m_representation.get(); }
289 
290     void dump(PrintStream&amp;) const;
291 
292 private:
293     void dumpFillInfo(const char* name, PrintStream&amp;) const;
294     void dumpSpillInfo(const char* name, PrintStream&amp;) const;
295 
296     union WhichType {
297         int virtualReg;
298         unsigned id;
299     };
300     Packed&lt;WhichType&gt; m_which;
301 
302     // For BirthToFill, Fill:
303     //   - The GPR or FPR, or a GPR pair.
304     // For BirthToSpill, Spill:
305     //   - The virtual register.
306     // For MovHintEvent, SetLocalEvent:
307     //   - The bytecode operand.
308     // For Death:
309     //   - Unused.
310     Packed&lt;VariableRepresentation&gt; m_representation;
311 
312     VariableEventKind m_kind;
313     DataFormat m_dataFormat { DataFormatNone };
314 };
315 
316 } } // namespace JSC::DFG
317 
318 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
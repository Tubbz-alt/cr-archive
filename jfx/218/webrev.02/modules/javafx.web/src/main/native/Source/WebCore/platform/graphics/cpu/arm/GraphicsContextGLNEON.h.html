<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cpu/arm/GraphicsContextGLNEON.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Gabor Rapcsanyi (rgabor@inf.u-szeged.hu), University of Szeged
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF SZEGED ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL UNIVERSITY OF SZEGED OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if HAVE(ARM_NEON_INTRINSICS)
 29 
 30 #include &lt;arm_neon.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 namespace SIMD {
 35 
 36 ALWAYS_INLINE void unpackOneRowOfRGBA16LittleToRGBA8(const uint16_t*&amp; source, uint8_t*&amp; destination, unsigned&amp; pixelsPerRow)
 37 {
 38     unsigned componentsPerRow = pixelsPerRow * 4;
 39     unsigned tailComponents = componentsPerRow % 16;
 40     unsigned componentsSize = componentsPerRow - tailComponents;
 41     const uint8_t* src = reinterpret_cast&lt;const uint8_t*&gt;(source);
 42 
 43     for (unsigned i = 0; i &lt; componentsSize; i += 16) {
 44         uint8x16x2_t components = vld2q_u8(src + i * 2);
 45         vst1q_u8(destination + i, components.val[1]);
 46     }
 47 
 48     source += componentsSize;
 49     destination += componentsSize;
 50     pixelsPerRow = tailComponents / 4;
 51 }
 52 
 53 ALWAYS_INLINE void unpackOneRowOfRGB16LittleToRGBA8(const uint16_t*&amp; source, uint8_t*&amp; destination, unsigned&amp; pixelsPerRow)
 54 {
 55     unsigned componentsPerRow = pixelsPerRow * 3;
 56     unsigned tailComponents = componentsPerRow % 24;
 57     unsigned componentsSize = componentsPerRow - tailComponents;
 58 
 59     uint8x8_t componentA = vdup_n_u8(0xFF);
 60     for (unsigned i = 0; i &lt; componentsSize; i += 24) {
 61         uint16x8x3_t RGB16 = vld3q_u16(source + i);
 62         uint8x8_t componentR = vqmovn_u16(vshrq_n_u16(RGB16.val[0], 8));
 63         uint8x8_t componentG = vqmovn_u16(vshrq_n_u16(RGB16.val[1], 8));
 64         uint8x8_t componentB = vqmovn_u16(vshrq_n_u16(RGB16.val[2], 8));
 65         uint8x8x4_t RGBA8 = {{componentR, componentG, componentB, componentA}};
 66         vst4_u8(destination, RGBA8);
 67         destination += 32;
 68     }
 69 
 70     source += componentsSize;
 71     pixelsPerRow = tailComponents / 3;
 72 }
 73 
 74 ALWAYS_INLINE void unpackOneRowOfARGB16LittleToRGBA8(const uint16_t*&amp; source, uint8_t*&amp; destination, unsigned&amp; pixelsPerRow)
 75 {
 76     unsigned componentsPerRow = pixelsPerRow * 4;
 77     unsigned tailComponents = componentsPerRow % 32;
 78     unsigned componentsSize = componentsPerRow - tailComponents;
 79 
 80     for (unsigned i = 0; i &lt; componentsSize; i += 32) {
 81         uint16x8x4_t ARGB16 = vld4q_u16(source + i);
 82         uint8x8_t componentA = vqmovn_u16(vshrq_n_u16(ARGB16.val[0], 8));
 83         uint8x8_t componentR = vqmovn_u16(vshrq_n_u16(ARGB16.val[1], 8));
 84         uint8x8_t componentG = vqmovn_u16(vshrq_n_u16(ARGB16.val[2], 8));
 85         uint8x8_t componentB = vqmovn_u16(vshrq_n_u16(ARGB16.val[3], 8));
 86         uint8x8x4_t RGBA8 = {{componentR, componentG, componentB, componentA}};
 87         vst4_u8(destination + i, RGBA8);
 88     }
 89 
 90     source += componentsSize;
 91     destination += componentsSize;
 92     pixelsPerRow = tailComponents / 4;
 93 }
 94 
 95 ALWAYS_INLINE void unpackOneRowOfBGRA16LittleToRGBA8(const uint16_t*&amp; source, uint8_t*&amp; destination, unsigned&amp; pixelsPerRow)
 96 {
 97     unsigned componentsPerRow = pixelsPerRow * 4;
 98     unsigned tailComponents = componentsPerRow % 32;
 99     unsigned componentsSize = componentsPerRow - tailComponents;
100 
101     for (unsigned i = 0; i &lt; componentsSize; i += 32) {
102         uint16x8x4_t ARGB16 = vld4q_u16(source + i);
103         uint8x8_t componentB = vqmovn_u16(vshrq_n_u16(ARGB16.val[0], 8));
104         uint8x8_t componentG = vqmovn_u16(vshrq_n_u16(ARGB16.val[1], 8));
105         uint8x8_t componentR = vqmovn_u16(vshrq_n_u16(ARGB16.val[2], 8));
106         uint8x8_t componentA = vqmovn_u16(vshrq_n_u16(ARGB16.val[3], 8));
107         uint8x8x4_t RGBA8 = {{componentR, componentG, componentB, componentA}};
108         vst4_u8(destination + i, RGBA8);
109     }
110 
111     source += componentsSize;
112     destination += componentsSize;
113     pixelsPerRow = tailComponents / 4;
114 }
115 
116 ALWAYS_INLINE void unpackOneRowOfRGBA4444ToRGBA8(const uint16_t*&amp; source, uint8_t*&amp; destination, unsigned&amp; pixelsPerRow)
117 {
118     unsigned tailPixels = pixelsPerRow % 8;
119     unsigned pixelSize = pixelsPerRow - tailPixels;
120 
121     uint16x8_t immediate0x0f = vdupq_n_u16(0x0F);
122     for (unsigned i = 0; i &lt; pixelSize; i += 8) {
123         uint16x8_t eightPixels = vld1q_u16(source + i);
124 
125         uint8x8_t componentR = vqmovn_u16(vshrq_n_u16(eightPixels, 12));
126         uint8x8_t componentG = vqmovn_u16(vandq_u16(vshrq_n_u16(eightPixels, 8), immediate0x0f));
127         uint8x8_t componentB = vqmovn_u16(vandq_u16(vshrq_n_u16(eightPixels, 4), immediate0x0f));
128         uint8x8_t componentA = vqmovn_u16(vandq_u16(eightPixels, immediate0x0f));
129 
130         componentR = vorr_u8(vshl_n_u8(componentR, 4), componentR);
131         componentG = vorr_u8(vshl_n_u8(componentG, 4), componentG);
132         componentB = vorr_u8(vshl_n_u8(componentB, 4), componentB);
133         componentA = vorr_u8(vshl_n_u8(componentA, 4), componentA);
134 
135         uint8x8x4_t destComponents = {{componentR, componentG, componentB, componentA}};
136         vst4_u8(destination, destComponents);
137         destination += 32;
138     }
139 
140     source += pixelSize;
141     pixelsPerRow = tailPixels;
142 }
143 
144 ALWAYS_INLINE void packOneRowOfRGBA8ToUnsignedShort4444(const uint8_t*&amp; source, uint16_t*&amp; destination, unsigned&amp; pixelsPerRow)
145 {
146     unsigned componentsPerRow = pixelsPerRow * 4;
147     unsigned tailComponents = componentsPerRow % 32;
148     unsigned componentsSize = componentsPerRow - tailComponents;
149 
150     uint8_t* dst = reinterpret_cast&lt;uint8_t*&gt;(destination);
151     uint8x8_t immediate0xf0 = vdup_n_u8(0xF0);
152     for (unsigned i = 0; i &lt; componentsSize; i += 32) {
153         uint8x8x4_t RGBA8 = vld4_u8(source + i);
154 
155         uint8x8_t componentR = vand_u8(RGBA8.val[0], immediate0xf0);
156         uint8x8_t componentG = vshr_n_u8(vand_u8(RGBA8.val[1], immediate0xf0), 4);
157         uint8x8_t componentB = vand_u8(RGBA8.val[2], immediate0xf0);
158         uint8x8_t componentA = vshr_n_u8(vand_u8(RGBA8.val[3], immediate0xf0), 4);
159 
160         uint8x8x2_t RGBA4;
161         RGBA4.val[0] = vorr_u8(componentB, componentA);
162         RGBA4.val[1] = vorr_u8(componentR, componentG);
163         vst2_u8(dst, RGBA4);
164         dst += 16;
165     }
166 
167     source += componentsSize;
168     destination += componentsSize / 4;
169     pixelsPerRow = tailComponents / 4;
170 }
171 
172 ALWAYS_INLINE void unpackOneRowOfRGBA5551ToRGBA8(const uint16_t*&amp; source, uint8_t*&amp; destination, unsigned&amp; pixelsPerRow)
173 {
174     unsigned tailPixels = pixelsPerRow % 8;
175     unsigned pixelSize = pixelsPerRow - tailPixels;
176 
177     uint8x8_t immediate0x7 = vdup_n_u8(0x7);
178     uint8x8_t immediate0xff = vdup_n_u8(0xFF);
179     uint16x8_t immediate0x1f = vdupq_n_u16(0x1F);
180     uint16x8_t immediate0x1 = vdupq_n_u16(0x1);
181 
182     for (unsigned i = 0; i &lt; pixelSize; i += 8) {
183         uint16x8_t eightPixels = vld1q_u16(source + i);
184 
185         uint8x8_t componentR = vqmovn_u16(vshrq_n_u16(eightPixels, 11));
186         uint8x8_t componentG = vqmovn_u16(vandq_u16(vshrq_n_u16(eightPixels, 6), immediate0x1f));
187         uint8x8_t componentB = vqmovn_u16(vandq_u16(vshrq_n_u16(eightPixels, 1), immediate0x1f));
188         uint8x8_t componentA = vqmovn_u16(vandq_u16(eightPixels, immediate0x1));
189 
190         componentR = vorr_u8(vshl_n_u8(componentR, 3), vand_u8(componentR, immediate0x7));
191         componentG = vorr_u8(vshl_n_u8(componentG, 3), vand_u8(componentG, immediate0x7));
192         componentB = vorr_u8(vshl_n_u8(componentB, 3), vand_u8(componentB, immediate0x7));
193         componentA = vmul_u8(componentA, immediate0xff);
194 
195         uint8x8x4_t destComponents = {{componentR, componentG, componentB, componentA}};
196         vst4_u8(destination, destComponents);
197         destination += 32;
198     }
199 
200     source += pixelSize;
201     pixelsPerRow = tailPixels;
202 }
203 
204 ALWAYS_INLINE void packOneRowOfRGBA8ToUnsignedShort5551(const uint8_t*&amp; source, uint16_t*&amp; destination, unsigned&amp; pixelsPerRow)
205 {
206     unsigned componentsPerRow = pixelsPerRow * 4;
207     unsigned tailComponents = componentsPerRow % 32;
208     unsigned componentsSize = componentsPerRow - tailComponents;
209 
210     uint8_t* dst = reinterpret_cast&lt;uint8_t*&gt;(destination);
211 
212     uint8x8_t immediate0xf8 = vdup_n_u8(0xF8);
213     uint8x8_t immediate0x18 = vdup_n_u8(0x18);
214     for (unsigned i = 0; i &lt; componentsSize; i += 32) {
215         uint8x8x4_t RGBA8 = vld4_u8(source + i);
216 
217         uint8x8_t componentR = vand_u8(RGBA8.val[0], immediate0xf8);
218         uint8x8_t componentG3bit = vshr_n_u8(RGBA8.val[1], 5);
219 
220         uint8x8_t componentG2bit = vshl_n_u8(vand_u8(RGBA8.val[1], immediate0x18), 3);
221         uint8x8_t componentB = vshr_n_u8(vand_u8(RGBA8.val[2], immediate0xf8), 2);
222         uint8x8_t componentA = vshr_n_u8(RGBA8.val[3], 7);
223 
224         uint8x8x2_t RGBA5551;
225         RGBA5551.val[0] = vorr_u8(vorr_u8(componentG2bit, componentB), componentA);
226         RGBA5551.val[1] = vorr_u8(componentR, componentG3bit);
227         vst2_u8(dst, RGBA5551);
228         dst += 16;
229     }
230 
231     source += componentsSize;
232     destination += componentsSize / 4;
233     pixelsPerRow = tailComponents / 4;
234 }
235 
236 ALWAYS_INLINE void unpackOneRowOfRGB565ToRGBA8(const uint16_t*&amp; source, uint8_t*&amp; destination, unsigned&amp; pixelsPerRow)
237 {
238     unsigned tailPixels = pixelsPerRow % 8;
239     unsigned pixelSize = pixelsPerRow - tailPixels;
240 
241     uint16x8_t immediate0x3f = vdupq_n_u16(0x3F);
242     uint16x8_t immediate0x1f = vdupq_n_u16(0x1F);
243     uint8x8_t immediate0x3 = vdup_n_u8(0x3);
244     uint8x8_t immediate0x7 = vdup_n_u8(0x7);
245 
246     uint8x8_t componentA = vdup_n_u8(0xFF);
247 
248     for (unsigned i = 0; i &lt; pixelSize; i += 8) {
249         uint16x8_t eightPixels = vld1q_u16(source + i);
250 
251         uint8x8_t componentR = vqmovn_u16(vshrq_n_u16(eightPixels, 11));
252         uint8x8_t componentG = vqmovn_u16(vandq_u16(vshrq_n_u16(eightPixels, 5), immediate0x3f));
253         uint8x8_t componentB = vqmovn_u16(vandq_u16(eightPixels, immediate0x1f));
254 
255         componentR = vorr_u8(vshl_n_u8(componentR, 3), vand_u8(componentR, immediate0x7));
256         componentG = vorr_u8(vshl_n_u8(componentG, 2), vand_u8(componentG, immediate0x3));
257         componentB = vorr_u8(vshl_n_u8(componentB, 3), vand_u8(componentB, immediate0x7));
258 
259         uint8x8x4_t destComponents = {{componentR, componentG, componentB, componentA}};
260         vst4_u8(destination, destComponents);
261         destination += 32;
262     }
263 
264     source += pixelSize;
265     pixelsPerRow = tailPixels;
266 }
267 
268 ALWAYS_INLINE void packOneRowOfRGBA8ToUnsignedShort565(const uint8_t*&amp; source, uint16_t*&amp; destination, unsigned&amp; pixelsPerRow)
269 {
270     unsigned componentsPerRow = pixelsPerRow * 4;
271     unsigned tailComponents = componentsPerRow % 32;
272     unsigned componentsSize = componentsPerRow - tailComponents;
273     uint8_t* dst = reinterpret_cast&lt;uint8_t*&gt;(destination);
274 
275     uint8x8_t immediate0xf8 = vdup_n_u8(0xF8);
276     uint8x8_t immediate0x1c = vdup_n_u8(0x1C);
277     for (unsigned i = 0; i &lt; componentsSize; i += 32) {
278         uint8x8x4_t RGBA8 = vld4_u8(source + i);
279 
280         uint8x8_t componentR = vand_u8(RGBA8.val[0], immediate0xf8);
281         uint8x8_t componentGLeft = vshr_n_u8(RGBA8.val[1], 5);
282         uint8x8_t componentGRight = vshl_n_u8(vand_u8(RGBA8.val[1], immediate0x1c), 3);
283         uint8x8_t componentB = vshr_n_u8(vand_u8(RGBA8.val[2], immediate0xf8), 3);
284 
285         uint8x8x2_t RGB565;
286         RGB565.val[0] = vorr_u8(componentGRight, componentB);
287         RGB565.val[1] = vorr_u8(componentR, componentGLeft);
288         vst2_u8(dst, RGB565);
289         dst += 16;
290     }
291 
292     source += componentsSize;
293     destination += componentsSize / 4;
294     pixelsPerRow = tailComponents / 4;
295 }
296 
297 } // namespace SIMD
298 
299 } // namespace WebCore
300 
301 #endif // HAVE(ARM_NEON_INTRINSICS)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLVideoElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007, 2008, 2009, 2010 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HTMLVideoElement.h&quot;
 28 
 29 #if ENABLE(VIDEO)
 30 
 31 #include &quot;CSSPropertyNames.h&quot;
 32 #include &quot;Chrome.h&quot;
 33 #include &quot;ChromeClient.h&quot;
 34 #include &quot;Document.h&quot;
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;HTMLImageLoader.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;Page.h&quot;
 42 #include &quot;PictureInPictureSupport.h&quot;
 43 #include &quot;RenderImage.h&quot;
 44 #include &quot;RenderVideo.h&quot;
 45 #include &quot;ScriptController.h&quot;
 46 #include &quot;Settings.h&quot;
 47 #include &lt;wtf/IsoMallocInlines.h&gt;
 48 #include &lt;wtf/text/TextStream.h&gt;
 49 
 50 #if ENABLE(VIDEO_PRESENTATION_MODE)
 51 #include &quot;VideoFullscreenModel.h&quot;
 52 #endif
 53 
 54 #if ENABLE(PICTURE_IN_PICTURE_API)
 55 #include &quot;HTMLVideoElementPictureInPicture.h&quot;
 56 #include &quot;PictureInPictureObserver.h&quot;
 57 #endif
 58 
 59 namespace WebCore {
 60 
 61 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLVideoElement);
 62 
 63 using namespace HTMLNames;
 64 
 65 inline HTMLVideoElement::HTMLVideoElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 66     : HTMLMediaElement(tagName, document, createdByParser)
 67 {
 68     ASSERT(hasTagName(videoTag));
 69     setHasCustomStyleResolveCallbacks();
 70     m_defaultPosterURL = document.settings().defaultVideoPosterURL();
 71 }
 72 
 73 Ref&lt;HTMLVideoElement&gt; HTMLVideoElement::create(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 74 {
 75     auto videoElement = adoptRef(*new HTMLVideoElement(tagName, document, createdByParser));
 76 
 77 #if ENABLE(PICTURE_IN_PICTURE_API)
 78     HTMLVideoElementPictureInPicture::providePictureInPictureTo(videoElement);
 79 #endif
 80 
 81     videoElement-&gt;finishInitialization();
 82     videoElement-&gt;suspendIfNeeded();
 83     return videoElement;
 84 }
 85 
 86 Ref&lt;HTMLVideoElement&gt; HTMLVideoElement::create(Document&amp; document)
 87 {
 88     return create(videoTag, document, false);
 89 }
 90 
 91 bool HTMLVideoElement::rendererIsNeeded(const RenderStyle&amp; style)
 92 {
 93     return HTMLElement::rendererIsNeeded(style);
 94 }
 95 
 96 RenderPtr&lt;RenderElement&gt; HTMLVideoElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 97 {
 98     return createRenderer&lt;RenderVideo&gt;(*this, WTFMove(style));
 99 }
100 
101 void HTMLVideoElement::didAttachRenderers()
102 {
103     HTMLMediaElement::didAttachRenderers();
104 
105     updateDisplayState();
106     if (shouldDisplayPosterImage()) {
107         if (!m_imageLoader)
108             m_imageLoader = makeUnique&lt;HTMLImageLoader&gt;(*this);
109         m_imageLoader-&gt;updateFromElement();
110         if (auto* renderer = this-&gt;renderer())
111             renderer-&gt;imageResource().setCachedImage(m_imageLoader-&gt;image());
112     }
113 }
114 
115 void HTMLVideoElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
116 {
117     if (name == widthAttr)
118         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
119     else if (name == heightAttr)
120         addHTMLLengthToStyle(style, CSSPropertyHeight, value);
121     else
122         HTMLMediaElement::collectStyleForPresentationAttribute(name, value, style);
123 }
124 
125 bool HTMLVideoElement::isPresentationAttribute(const QualifiedName&amp; name) const
126 {
127     if (name == widthAttr || name == heightAttr)
128         return true;
129     return HTMLMediaElement::isPresentationAttribute(name);
130 }
131 
132 void HTMLVideoElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
133 {
134     if (name == posterAttr) {
135         // Force a poster recalc by setting m_displayMode to Unknown directly before calling updateDisplayState.
136         HTMLMediaElement::setDisplayMode(Unknown);
137         updateDisplayState();
138 
139         if (shouldDisplayPosterImage()) {
140             if (!m_imageLoader)
141                 m_imageLoader = makeUnique&lt;HTMLImageLoader&gt;(*this);
142             m_imageLoader-&gt;updateFromElementIgnoringPreviousError();
143         } else {
144             if (auto* renderer = this-&gt;renderer())
145                 renderer-&gt;imageResource().setCachedImage(nullptr);
146         }
147     }
148 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
149     else if (name == webkitwirelessvideoplaybackdisabledAttr)
150         mediaSession().setWirelessVideoPlaybackDisabled(true);
151 #endif
152     else {
153         HTMLMediaElement::parseAttribute(name, value);
154 
155 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(WIRELESS_PLAYBACK_TARGET)
156         if (name == webkitairplayAttr) {
157             bool disabled = false;
158             if (equalLettersIgnoringASCIICase(attributeWithoutSynchronization(HTMLNames::webkitairplayAttr), &quot;deny&quot;))
159                 disabled = true;
160             mediaSession().setWirelessVideoPlaybackDisabled(disabled);
161         }
162 #endif
163     }
164 
165 }
166 
167 bool HTMLVideoElement::supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode videoFullscreenMode) const
168 {
169     if (!player())
170         return false;
171 
172     if (videoFullscreenMode == HTMLMediaElementEnums::VideoFullscreenModePictureInPicture) {
173         if (!mediaSession().allowsPictureInPicture())
174             return false;
175         if (!player()-&gt;supportsPictureInPicture())
176             return false;
177     }
178 
179     Page* page = document().page();
180     if (!page)
181         return false;
182 
183     if (!player()-&gt;supportsFullscreen())
184         return false;
185 
186 #if PLATFORM(IOS_FAMILY)
187     UNUSED_PARAM(videoFullscreenMode);
188     // Fullscreen implemented by player.
189     return true;
190 #else
191 #if ENABLE(FULLSCREEN_API)
192     // If the full screen API is enabled and is supported for the current element
193     // do not require that the player has a video track to enter full screen.
194     if (videoFullscreenMode == HTMLMediaElementEnums::VideoFullscreenModeStandard &amp;&amp; page-&gt;chrome().client().supportsFullScreenForElement(*this, false))
195         return true;
196 #endif
197 
198     if (!player()-&gt;hasVideo())
199         return false;
200 
201     return page-&gt;chrome().client().supportsVideoFullscreen(videoFullscreenMode);
202 #endif // PLATFORM(IOS_FAMILY)
203 }
204 
205 
206 #if ENABLE(FULLSCREEN_API) &amp;&amp; PLATFORM(IOS_FAMILY)
207 void HTMLVideoElement::webkitRequestFullscreen()
208 {
209     webkitSetPresentationMode(HTMLVideoElement::VideoPresentationMode::Fullscreen);
210 }
211 #endif
212 
213 unsigned HTMLVideoElement::videoWidth() const
214 {
215     if (!player())
216         return 0;
217     return clampToUnsigned(player()-&gt;naturalSize().width());
218 }
219 
220 unsigned HTMLVideoElement::videoHeight() const
221 {
222     if (!player())
223         return 0;
224     return clampToUnsigned(player()-&gt;naturalSize().height());
225 }
226 
227 void HTMLVideoElement::scheduleResizeEvent()
228 {
229     m_lastReportedVideoWidth = videoWidth();
230     m_lastReportedVideoHeight = videoHeight();
231     scheduleEvent(eventNames().resizeEvent);
232 }
233 
234 void HTMLVideoElement::scheduleResizeEventIfSizeChanged()
235 {
236     if (m_lastReportedVideoWidth == videoWidth() &amp;&amp; m_lastReportedVideoHeight == videoHeight())
237         return;
238     scheduleResizeEvent();
239 }
240 
241 bool HTMLVideoElement::isURLAttribute(const Attribute&amp; attribute) const
242 {
243     return attribute.name() == posterAttr || HTMLMediaElement::isURLAttribute(attribute);
244 }
245 
246 const AtomString&amp; HTMLVideoElement::imageSourceURL() const
247 {
248     const AtomString&amp; url = attributeWithoutSynchronization(posterAttr);
249     if (!stripLeadingAndTrailingHTMLSpaces(url).isEmpty())
250         return url;
251     return m_defaultPosterURL;
252 }
253 
254 void HTMLVideoElement::setDisplayMode(DisplayMode mode)
255 {
256     DisplayMode oldMode = displayMode();
257     URL poster = posterImageURL();
258 
259     if (!poster.isEmpty()) {
260         // We have a poster path, but only show it until the user triggers display by playing or seeking and the
261         // media engine has something to display.
262         if (mode == Video) {
263             if (oldMode != Video &amp;&amp; player())
264                 player()-&gt;prepareForRendering();
265             if (!hasAvailableVideoFrame())
266                 mode = PosterWaitingForVideo;
267         }
268     } else if (oldMode != Video &amp;&amp; player())
269         player()-&gt;prepareForRendering();
270 
271     HTMLMediaElement::setDisplayMode(mode);
272 
273     if (auto* renderer = this-&gt;renderer()) {
274         if (displayMode() != oldMode)
275             renderer-&gt;updateFromElement();
276     }
277 }
278 
279 void HTMLVideoElement::updateDisplayState()
280 {
281     if (posterImageURL().isEmpty())
282         setDisplayMode(Video);
283     else if (displayMode() &lt; Poster)
284         setDisplayMode(Poster);
285 }
286 
287 void HTMLVideoElement::paintCurrentFrameInContext(GraphicsContext&amp; context, const FloatRect&amp; destRect)
288 {
289     RefPtr&lt;MediaPlayer&gt; player = HTMLMediaElement::player();
290     if (!player)
291         return;
292 
293     player-&gt;setVisible(true); // Make player visible or it won&#39;t draw.
294     player-&gt;paintCurrentFrameInContext(context, destRect);
295 }
296 
297 bool HTMLVideoElement::copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL* context, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)
298 {
299     if (!player())
300         return false;
301     return player()-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
302 }
303 
304 bool HTMLVideoElement::hasAvailableVideoFrame() const
305 {
306     if (!player())
307         return false;
308 
309     return player()-&gt;hasVideo() &amp;&amp; player()-&gt;hasAvailableVideoFrame();
310 }
311 
312 NativeImagePtr HTMLVideoElement::nativeImageForCurrentTime()
313 {
314     if (!player())
315         return nullptr;
316 
317     return player()-&gt;nativeImageForCurrentTime();
318 }
319 
320 ExceptionOr&lt;void&gt; HTMLVideoElement::webkitEnterFullscreen()
321 {
322     ALWAYS_LOG(LOGIDENTIFIER);
323     if (isFullscreen())
324         return { };
325 
326     // Generate an exception if this isn&#39;t called in response to a user gesture, or if the
327     // element does not support fullscreen.
328     if (!mediaSession().fullscreenPermitted() || !supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModeStandard))
329         return Exception { InvalidStateError };
330 
331     enterFullscreen();
332     return { };
333 }
334 
335 void HTMLVideoElement::webkitExitFullscreen()
336 {
337     ALWAYS_LOG(LOGIDENTIFIER);
338     if (isFullscreen())
339         exitFullscreen();
340 }
341 
342 bool HTMLVideoElement::webkitSupportsFullscreen()
343 {
344     return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModeStandard);
345 }
346 
347 bool HTMLVideoElement::webkitDisplayingFullscreen()
348 {
349     return isFullscreen();
350 }
351 
352 void HTMLVideoElement::ancestorWillEnterFullscreen()
353 {
354 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
355     if (fullscreenMode() == VideoFullscreenModeNone)
356         return;
357 
358     // If this video element&#39;s presentation mode is not inline, but its ancestor
359     // is entering fullscreen, exit its current fullscreen mode.
360     exitToFullscreenModeWithoutAnimationIfPossible(fullscreenMode(), VideoFullscreenModeNone);
361 #endif
362 }
363 
364 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
365 bool HTMLVideoElement::webkitWirelessVideoPlaybackDisabled() const
366 {
367     return mediaSession().wirelessVideoPlaybackDisabled();
368 }
369 
370 void HTMLVideoElement::setWebkitWirelessVideoPlaybackDisabled(bool disabled)
371 {
372     setBooleanAttribute(webkitwirelessvideoplaybackdisabledAttr, disabled);
373 }
374 #endif
375 
376 void HTMLVideoElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
377 {
378     if (m_imageLoader)
379         m_imageLoader-&gt;elementDidMoveToNewDocument();
380     HTMLMediaElement::didMoveToNewDocument(oldDocument, newDocument);
381 }
382 
383 #if ENABLE(MEDIA_STATISTICS)
384 unsigned HTMLVideoElement::webkitDecodedFrameCount() const
385 {
386     if (!player())
387         return 0;
388 
389     return player()-&gt;decodedFrameCount();
390 }
391 
392 unsigned HTMLVideoElement::webkitDroppedFrameCount() const
393 {
394     if (!player())
395         return 0;
396 
397     return player()-&gt;droppedFrameCount();
398 }
399 #endif
400 
401 URL HTMLVideoElement::posterImageURL() const
402 {
403     String url = stripLeadingAndTrailingHTMLSpaces(imageSourceURL());
404     if (url.isEmpty())
405         return URL();
406     return document().completeURL(url);
407 }
408 
409 #if ENABLE(VIDEO_PRESENTATION_MODE)
410 
411 bool HTMLVideoElement::webkitSupportsPresentationMode(VideoPresentationMode mode) const
412 {
413     if (mode == VideoPresentationMode::Fullscreen)
414         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModeStandard);
415 
416     if (mode == VideoPresentationMode::PictureInPicture) {
417         if (!supportsPictureInPicture())
418             return false;
419 
420         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModePictureInPicture);
421     }
422 
423     if (mode == VideoPresentationMode::Inline)
424         return !mediaSession().requiresFullscreenForVideoPlayback();
425 
426     return false;
427 }
428 
429 static inline HTMLMediaElementEnums::VideoFullscreenMode toFullscreenMode(HTMLVideoElement::VideoPresentationMode mode)
430 {
431     switch (mode) {
432     case HTMLVideoElement::VideoPresentationMode::Fullscreen:
433         return HTMLMediaElementEnums::VideoFullscreenModeStandard;
434     case HTMLVideoElement::VideoPresentationMode::PictureInPicture:
435         return HTMLMediaElementEnums::VideoFullscreenModePictureInPicture;
436     case HTMLVideoElement::VideoPresentationMode::Inline:
437         return HTMLMediaElementEnums::VideoFullscreenModeNone;
438     }
439     ASSERT_NOT_REACHED();
440     return HTMLMediaElementEnums::VideoFullscreenModeNone;
441 }
442 
443 void HTMLVideoElement::webkitSetPresentationMode(VideoPresentationMode mode)
444 {
445     INFO_LOG(LOGIDENTIFIER, &quot;, mode = &quot;,  mode);
446     setFullscreenMode(toFullscreenMode(mode));
447 }
448 
449 void HTMLVideoElement::setFullscreenMode(HTMLMediaElementEnums::VideoFullscreenMode mode)
450 {
451     INFO_LOG(LOGIDENTIFIER, &quot;, mode = &quot;, mode);
452 #if ENABLE(PICTURE_IN_PICTURE_API)
453     if (m_pictureInPictureAPITestEnabled) {
454         if (mode == VideoFullscreenModePictureInPicture) {
455             fullscreenModeChanged(mode);
456             didBecomeFullscreenElement();
457             setVideoFullscreenFrame({0, 0, 100, 100});
458             return;
459         }
460 
461         if (mode == VideoFullscreenModeNone) {
462             fullscreenModeChanged(mode);
463             return;
464         }
465     }
466 #endif
467 
468     if (mode == VideoFullscreenModeNone) {
469         if (isFullscreen())
470             exitFullscreen();
471 
472         return;
473     }
474 
475     if (!mediaSession().fullscreenPermitted() || !supportsFullscreen(mode))
476         return;
477 
478     enterFullscreen(mode);
479 }
480 
481 static HTMLVideoElement::VideoPresentationMode toPresentationMode(HTMLMediaElementEnums::VideoFullscreenMode mode)
482 {
483     if (mode == HTMLMediaElementEnums::VideoFullscreenModeStandard)
484         return HTMLVideoElement::VideoPresentationMode::Fullscreen;
485 
486     if (mode &amp; HTMLMediaElementEnums::VideoFullscreenModePictureInPicture)
487         return HTMLVideoElement::VideoPresentationMode::PictureInPicture;
488 
489     if (mode == HTMLMediaElementEnums::VideoFullscreenModeNone)
490         return HTMLVideoElement::VideoPresentationMode::Inline;
491 
492     ASSERT_NOT_REACHED();
493     return HTMLVideoElement::VideoPresentationMode::Inline;
494 }
495 
496 auto HTMLVideoElement::webkitPresentationMode() const -&gt; VideoPresentationMode
497 {
498     return toPresentationMode(fullscreenMode());
499 }
500 
501 void HTMLVideoElement::fullscreenModeChanged(VideoFullscreenMode mode)
502 {
503     if (mode != fullscreenMode()) {
504         INFO_LOG(LOGIDENTIFIER, &quot;changed from &quot;, fullscreenMode(), &quot;, to &quot;, mode);
505         scheduleEvent(eventNames().webkitpresentationmodechangedEvent);
506 
507 #if ENABLE(PICTURE_IN_PICTURE_API)
508         if (m_pictureInPictureObserver) {
509             HTMLVideoElement::VideoPresentationMode targetVideoPresentationMode = toPresentationMode(mode);
510             HTMLVideoElement::VideoPresentationMode sourceVideoPresentationMode = toPresentationMode(fullscreenMode());
511 
512             if (targetVideoPresentationMode != HTMLVideoElement::VideoPresentationMode::PictureInPicture &amp;&amp; sourceVideoPresentationMode == HTMLVideoElement::VideoPresentationMode::PictureInPicture) {
513                 m_pictureInPictureObserver-&gt;didExitPictureInPicture();
514                 m_isFullscreen = false;
515             }
516         }
517 #endif
518     }
519 
520     if (player())
521         player()-&gt;setVideoFullscreenMode(mode);
522 
523     HTMLMediaElement::fullscreenModeChanged(mode);
524 }
525 
526 #if ENABLE(PICTURE_IN_PICTURE_API)
527 void HTMLVideoElement::didBecomeFullscreenElement()
528 {
529     m_isFullscreen = true;
530     m_waitingForPictureInPictureWindowFrame = true;
531     HTMLMediaElement::didBecomeFullscreenElement();
532 }
533 
534 void HTMLVideoElement::setPictureInPictureObserver(PictureInPictureObserver* observer)
535 {
536     m_pictureInPictureObserver = observer;
537 }
538 
539 void HTMLVideoElement::setPictureInPictureAPITestEnabled(bool enabled)
540 {
541     m_pictureInPictureAPITestEnabled = enabled;
542 }
543 #endif
544 
545 #endif
546 
547 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
548 void HTMLVideoElement::setVideoFullscreenFrame(FloatRect frame)
549 {
550     HTMLMediaElement::setVideoFullscreenFrame(frame);
551 
552 #if ENABLE(PICTURE_IN_PICTURE_API)
553     // fullscreenMode() does not always provide the correct fullscreen mode
554     // when mode changing is happening (webkit.org/b/203443)
555     if (!m_isFullscreen)
556         return;
557 
558     if (toPresentationMode(fullscreenMode()) != VideoPresentationMode::PictureInPicture)
559         return;
560 
561     if (m_waitingForPictureInPictureWindowFrame) {
562         m_waitingForPictureInPictureWindowFrame = false;
563         if (m_pictureInPictureObserver)
564             m_pictureInPictureObserver-&gt;didEnterPictureInPicture(IntSize(frame.size()));
565 
566         return;
567     }
568 
569     if (m_pictureInPictureObserver)
570         m_pictureInPictureObserver-&gt;pictureInPictureWindowResized(IntSize(frame.size()));
571 #endif
572 }
573 #endif
574 
575 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
576 void HTMLVideoElement::exitToFullscreenModeWithoutAnimationIfPossible(HTMLMediaElementEnums::VideoFullscreenMode fromMode, HTMLMediaElementEnums::VideoFullscreenMode toMode)
577 {
578     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(fromMode))
579         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(*this, toMode);
580 }
581 #endif
582 
583 }
584 
585 #endif
    </pre>
  </body>
</html>
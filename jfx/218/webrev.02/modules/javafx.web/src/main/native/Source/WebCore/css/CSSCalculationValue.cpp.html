<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSCalculationValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011, 2012 Google Inc. All rights reserved.
   3  * Copyright (C) 2014, 2019 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;CSSCalculationValue.h&quot;
  34 
  35 #include &quot;CSSParser.h&quot;
  36 #include &quot;CSSParserTokenRange.h&quot;
  37 #include &quot;CSSPrimitiveValueMappings.h&quot;
  38 #include &quot;Logging.h&quot;
  39 #include &quot;StyleResolver.h&quot;
  40 #include &lt;wtf/MathExtras.h&gt;
  41 #include &lt;wtf/text/StringBuilder.h&gt;
  42 #include &lt;wtf/text/TextStream.h&gt;
  43 
  44 static const int maxExpressionDepth = 100;
  45 
  46 namespace WebCore {
  47 class CSSCalcPrimitiveValueNode;
  48 class CSSCalcOperationNode;
  49 class CSSCalcNegateNode;
  50 class CSSCalcInvertNode;
  51 }
  52 
  53 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcPrimitiveValueNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcPrimitiveValue)
  54 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcOperationNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcOperation)
  55 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcNegateNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcNegate)
  56 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcInvertNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcInvert)
  57 
  58 namespace WebCore {
  59 
  60 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp;, const RenderStyle&amp;);
  61 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp;, const RenderStyle&amp;);
  62 
  63 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CSSCalcExpressionNode&amp; node)
  64 {
  65     node.dump(ts);
  66     return ts;
  67 }
  68 
  69 static CalculationCategory calcUnitCategory(CSSUnitType type)
  70 {
  71     switch (type) {
  72     case CSSUnitType::CSS_NUMBER:
  73         return CalculationCategory::Number;
  74     case CSSUnitType::CSS_EMS:
  75     case CSSUnitType::CSS_EXS:
  76     case CSSUnitType::CSS_PX:
  77     case CSSUnitType::CSS_CM:
  78     case CSSUnitType::CSS_MM:
  79     case CSSUnitType::CSS_IN:
  80     case CSSUnitType::CSS_PT:
  81     case CSSUnitType::CSS_PC:
  82     case CSSUnitType::CSS_Q:
  83     case CSSUnitType::CSS_REMS:
  84     case CSSUnitType::CSS_CHS:
  85     case CSSUnitType::CSS_VW:
  86     case CSSUnitType::CSS_VH:
  87     case CSSUnitType::CSS_VMIN:
  88     case CSSUnitType::CSS_VMAX:
  89         return CalculationCategory::Length;
  90     case CSSUnitType::CSS_PERCENTAGE:
  91         return CalculationCategory::Percent;
  92     case CSSUnitType::CSS_DEG:
  93     case CSSUnitType::CSS_RAD:
  94     case CSSUnitType::CSS_GRAD:
  95     case CSSUnitType::CSS_TURN:
  96         return CalculationCategory::Angle;
  97     case CSSUnitType::CSS_MS:
  98     case CSSUnitType::CSS_S:
  99         return CalculationCategory::Time;
 100     case CSSUnitType::CSS_HZ:
 101     case CSSUnitType::CSS_KHZ:
 102         return CalculationCategory::Frequency;
 103     default:
 104         return CalculationCategory::Other;
 105     }
 106 }
 107 
 108 static CalculationCategory calculationCategoryForCombination(CSSUnitType type)
 109 {
 110     switch (type) {
 111     case CSSUnitType::CSS_NUMBER:
 112         return CalculationCategory::Number;
 113     case CSSUnitType::CSS_PX:
 114     case CSSUnitType::CSS_CM:
 115     case CSSUnitType::CSS_MM:
 116     case CSSUnitType::CSS_IN:
 117     case CSSUnitType::CSS_PT:
 118     case CSSUnitType::CSS_PC:
 119     case CSSUnitType::CSS_Q:
 120         return CalculationCategory::Length;
 121     case CSSUnitType::CSS_PERCENTAGE:
 122         return CalculationCategory::Percent;
 123     case CSSUnitType::CSS_DEG:
 124     case CSSUnitType::CSS_RAD:
 125     case CSSUnitType::CSS_GRAD:
 126     case CSSUnitType::CSS_TURN:
 127         return CalculationCategory::Angle;
 128     case CSSUnitType::CSS_MS:
 129     case CSSUnitType::CSS_S:
 130         return CalculationCategory::Time;
 131     case CSSUnitType::CSS_HZ:
 132     case CSSUnitType::CSS_KHZ:
 133         return CalculationCategory::Frequency;
 134     case CSSUnitType::CSS_EMS:
 135     case CSSUnitType::CSS_EXS:
 136     case CSSUnitType::CSS_REMS:
 137     case CSSUnitType::CSS_CHS:
 138     case CSSUnitType::CSS_VW:
 139     case CSSUnitType::CSS_VH:
 140     case CSSUnitType::CSS_VMIN:
 141     case CSSUnitType::CSS_VMAX:
 142     default:
 143         return CalculationCategory::Other;
 144     }
 145 }
 146 
 147 static CSSUnitType canonicalUnitTypeForCalculationCategory(CalculationCategory category)
 148 {
 149     switch (category) {
 150     case CalculationCategory::Number: return CSSUnitType::CSS_NUMBER;
 151     case CalculationCategory::Length: return CSSUnitType::CSS_PX;
 152     case CalculationCategory::Percent: return CSSUnitType::CSS_PERCENTAGE;
 153     case CalculationCategory::Angle: return CSSUnitType::CSS_DEG;
 154     case CalculationCategory::Time: return CSSUnitType::CSS_MS;
 155     case CalculationCategory::Frequency: return CSSUnitType::CSS_HZ;
 156     case CalculationCategory::Other:
 157     case CalculationCategory::PercentNumber:
 158     case CalculationCategory::PercentLength:
 159         ASSERT_NOT_REACHED();
 160         break;
 161     }
 162     return CSSUnitType::CSS_UNKNOWN;
 163 }
 164 
 165 static bool hasDoubleValue(CSSUnitType type)
 166 {
 167     switch (type) {
 168     case CSSUnitType::CSS_NUMBER:
 169     case CSSUnitType::CSS_PERCENTAGE:
 170     case CSSUnitType::CSS_EMS:
 171     case CSSUnitType::CSS_EXS:
 172     case CSSUnitType::CSS_CHS:
 173     case CSSUnitType::CSS_REMS:
 174     case CSSUnitType::CSS_PX:
 175     case CSSUnitType::CSS_CM:
 176     case CSSUnitType::CSS_MM:
 177     case CSSUnitType::CSS_IN:
 178     case CSSUnitType::CSS_PT:
 179     case CSSUnitType::CSS_PC:
 180     case CSSUnitType::CSS_DEG:
 181     case CSSUnitType::CSS_RAD:
 182     case CSSUnitType::CSS_GRAD:
 183     case CSSUnitType::CSS_TURN:
 184     case CSSUnitType::CSS_MS:
 185     case CSSUnitType::CSS_S:
 186     case CSSUnitType::CSS_HZ:
 187     case CSSUnitType::CSS_KHZ:
 188     case CSSUnitType::CSS_DIMENSION:
 189     case CSSUnitType::CSS_VW:
 190     case CSSUnitType::CSS_VH:
 191     case CSSUnitType::CSS_VMIN:
 192     case CSSUnitType::CSS_VMAX:
 193     case CSSUnitType::CSS_DPPX:
 194     case CSSUnitType::CSS_DPI:
 195     case CSSUnitType::CSS_DPCM:
 196     case CSSUnitType::CSS_FR:
 197     case CSSUnitType::CSS_Q:
 198         return true;
 199     case CSSUnitType::CSS_UNKNOWN:
 200     case CSSUnitType::CSS_STRING:
 201     case CSSUnitType::CSS_FONT_FAMILY:
 202     case CSSUnitType::CSS_URI:
 203     case CSSUnitType::CSS_IDENT:
 204     case CSSUnitType::CSS_ATTR:
 205     case CSSUnitType::CSS_COUNTER:
 206     case CSSUnitType::CSS_RECT:
 207     case CSSUnitType::CSS_RGBCOLOR:
 208     case CSSUnitType::CSS_PAIR:
 209     case CSSUnitType::CSS_UNICODE_RANGE:
 210     case CSSUnitType::CSS_COUNTER_NAME:
 211     case CSSUnitType::CSS_SHAPE:
 212     case CSSUnitType::CSS_QUAD:
 213     case CSSUnitType::CSS_QUIRKY_EMS:
 214     case CSSUnitType::CSS_CALC:
 215     case CSSUnitType::CSS_CALC_PERCENTAGE_WITH_NUMBER:
 216     case CSSUnitType::CSS_CALC_PERCENTAGE_WITH_LENGTH:
 217     case CSSUnitType::CSS_PROPERTY_ID:
 218     case CSSUnitType::CSS_VALUE_ID:
 219         return false;
 220     };
 221     ASSERT_NOT_REACHED();
 222     return false;
 223 }
 224 
 225 static CSSValueID functionFromOperator(CalcOperator op)
 226 {
 227     switch (op) {
 228     case CalcOperator::Add:
 229     case CalcOperator::Subtract:
 230     case CalcOperator::Multiply:
 231     case CalcOperator::Divide:
 232         return CSSValueCalc;
 233     case CalcOperator::Min:
 234         return CSSValueMin;
 235     case CalcOperator::Max:
 236         return CSSValueMax;
 237     case CalcOperator::Clamp:
 238         return CSSValueClamp;
 239     }
 240     return CSSValueCalc;
 241 }
 242 
 243 #if !LOG_DISABLED
 244 static String prettyPrintNode(const CSSCalcExpressionNode&amp; node)
 245 {
 246     TextStream multilineStream;
 247     multilineStream &lt;&lt; node;
 248     return multilineStream.release();
 249 }
 250 
 251 static String prettyPrintNodes(const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes)
 252 {
 253     TextStream multilineStream;
 254     multilineStream &lt;&lt; nodes;
 255     return multilineStream.release();
 256 }
 257 #endif
 258 
 259 class CSSCalcPrimitiveValueNode final : public CSSCalcExpressionNode {
 260     WTF_MAKE_FAST_ALLOCATED;
 261 public:
 262     static Ref&lt;CSSCalcPrimitiveValueNode&gt; create(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)
 263     {
 264         return adoptRef(*new CSSCalcPrimitiveValueNode(WTFMove(value)));
 265     }
 266 
 267     static RefPtr&lt;CSSCalcPrimitiveValueNode&gt; create(double value, CSSUnitType type)
 268     {
 269         if (!std::isfinite(value))
 270             return nullptr;
 271         return adoptRef(new CSSCalcPrimitiveValueNode(CSSPrimitiveValue::create(value, type)));
 272     }
 273 
 274     String customCSSText() const
 275     {
 276         return m_value-&gt;cssText();
 277     }
 278 
 279     CSSUnitType primitiveType() const final
 280     {
 281         return m_value-&gt;primitiveType();
 282     }
 283 
 284     bool isNumericValue() const;
 285     bool isNegative() const;
 286 
 287     void negate();
 288     void invert();
 289 
 290     enum class UnitConversion {
 291         Invalid,
 292         Preserve,
 293         Canonicalize
 294     };
 295     void add(const CSSCalcPrimitiveValueNode&amp;, UnitConversion = UnitConversion::Preserve);
 296     void multiply(double);
 297 
 298     void convertToUnitType(CSSUnitType);
 299     void canonicalizeUnit();
 300 
 301     const CSSPrimitiveValue&amp; value() const { return m_value.get(); }
 302 
 303 private:
 304     bool isZero() const final
 305     {
 306         return !m_value-&gt;doubleValue();
 307     }
 308 
 309     bool equals(const CSSCalcExpressionNode&amp; other) const final;
 310     Type type() const final { return CssCalcPrimitiveValue; }
 311 
 312     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;
 313     double doubleValue(CSSUnitType) const final;
 314 
 315     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;
 316     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;
 317     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;
 318 
 319     void dump(TextStream&amp;) const final;
 320 
 321 private:
 322     explicit CSSCalcPrimitiveValueNode(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)
 323         : CSSCalcExpressionNode(calcUnitCategory(value-&gt;primitiveType()))
 324         , m_value(WTFMove(value))
 325     {
 326     }
 327 
 328     Ref&lt;CSSPrimitiveValue&gt; m_value;
 329 };
 330 
 331 // FIXME: Use calcUnitCategory?
 332 bool CSSCalcPrimitiveValueNode::isNumericValue() const
 333 {
 334     return m_value-&gt;isLength() || m_value-&gt;isNumber() || m_value-&gt;isPercentage() || m_value-&gt;isAngle()
 335         || m_value-&gt;isTime() || m_value-&gt;isResolution() || m_value-&gt;isFlex() || m_value-&gt;isFrequency();
 336 }
 337 
 338 bool CSSCalcPrimitiveValueNode::isNegative() const
 339 {
 340     return isNumericValue() &amp;&amp; m_value-&gt;doubleValue() &lt; 0.0;
 341 }
 342 
 343 void CSSCalcPrimitiveValueNode::negate()
 344 {
 345     ASSERT(isNumericValue());
 346     m_value = CSSPrimitiveValue::create(0.0 - m_value-&gt;doubleValue(), m_value-&gt;primitiveType());
 347 }
 348 
 349 void CSSCalcPrimitiveValueNode::invert()
 350 {
 351     ASSERT(isNumericValue());
 352     if (!m_value-&gt;doubleValue())
 353         m_value = CSSPrimitiveValue::create(std::numeric_limits&lt;double&gt;::infinity(), m_value-&gt;primitiveType());
 354 
 355     m_value = CSSPrimitiveValue::create(1.0 / m_value-&gt;doubleValue(), m_value-&gt;primitiveType());
 356 }
 357 
 358 void CSSCalcPrimitiveValueNode::add(const CSSCalcPrimitiveValueNode&amp; node, UnitConversion unitConversion)
 359 {
 360     auto valueType = m_value-&gt;primitiveType();
 361 
 362     switch (unitConversion) {
 363     case UnitConversion::Invalid:
 364         ASSERT_NOT_REACHED();
 365         break;
 366     case UnitConversion::Preserve:
 367         ASSERT(node.primitiveType() == valueType);
 368         m_value = CSSPrimitiveValue::create(m_value-&gt;doubleValue() + node.doubleValue(valueType), valueType);
 369         break;
 370     case UnitConversion::Canonicalize: {
 371         auto valueCategory = unitCategory(valueType);
 372         // FIXME: It&#39;s awkward that canonicalUnitTypeForCategory() has special handling for CSSUnitCategory::Percent.
 373         auto canonicalType = valueCategory == CSSUnitCategory::Percent ? CSSUnitType::CSS_PERCENTAGE : canonicalUnitTypeForCategory(valueCategory);
 374         ASSERT(canonicalType != CSSUnitType::CSS_UNKNOWN);
 375         double leftValue = m_value-&gt;doubleValue(canonicalType);
 376         double rightValue = node.doubleValue(canonicalType);
 377         m_value = CSSPrimitiveValue::create(leftValue + rightValue, canonicalType);
 378         break;
 379     }
 380     }
 381 }
 382 
 383 void CSSCalcPrimitiveValueNode::multiply(double multiplier)
 384 {
 385     auto valueType = m_value-&gt;primitiveType();
 386     ASSERT(hasDoubleValue(valueType));
 387     m_value = CSSPrimitiveValue::create(m_value-&gt;doubleValue(valueType) * multiplier, valueType);
 388 }
 389 
 390 void CSSCalcPrimitiveValueNode::convertToUnitType(CSSUnitType unitType)
 391 {
 392     ASSERT(unitCategory(unitType) == unitCategory(m_value-&gt;primitiveType()));
 393     double newValue = m_value-&gt;doubleValue(unitType);
 394     m_value = CSSPrimitiveValue::create(newValue, unitType);
 395 }
 396 
 397 void CSSCalcPrimitiveValueNode::canonicalizeUnit()
 398 {
 399     auto category = calculationCategoryForCombination(m_value-&gt;primitiveType());
 400     if (category == CalculationCategory::Other)
 401         return;
 402 
 403     auto canonicalType = canonicalUnitTypeForCalculationCategory(category);
 404     if (canonicalType == m_value-&gt;primitiveType())
 405         return;
 406 
 407     double newValue = m_value-&gt;doubleValue(canonicalType);
 408     m_value = CSSPrimitiveValue::create(newValue, canonicalType);
 409 }
 410 
 411 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcPrimitiveValueNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const
 412 {
 413     switch (category()) {
 414     case CalculationCategory::Number:
 415         return makeUnique&lt;CalcExpressionNumber&gt;(m_value-&gt;floatValue());
 416     case CalculationCategory::Length:
 417         return makeUnique&lt;CalcExpressionLength&gt;(Length(m_value-&gt;computeLength&lt;float&gt;(conversionData), WebCore::Fixed));
 418     case CalculationCategory::Percent:
 419     case CalculationCategory::PercentLength: {
 420         return makeUnique&lt;CalcExpressionLength&gt;(m_value-&gt;convertToLength&lt;FixedFloatConversion | PercentConversion&gt;(conversionData));
 421     }
 422     // Only types that could be part of a Length expression can be converted
 423     // to a CalcExpressionNode. CalculationCategory::PercentNumber makes no sense as a Length.
 424     case CalculationCategory::PercentNumber:
 425     case CalculationCategory::Angle:
 426     case CalculationCategory::Time:
 427     case CalculationCategory::Frequency:
 428     case CalculationCategory::Other:
 429         ASSERT_NOT_REACHED();
 430     }
 431     ASSERT_NOT_REACHED();
 432     return nullptr;
 433 }
 434 
 435 double CSSCalcPrimitiveValueNode::doubleValue(CSSUnitType unitType) const
 436 {
 437     if (hasDoubleValue(unitType)) {
 438         // FIXME: This should ASSERT(unitCategory(m_value-&gt;primitiveType()) == unitCategory(unitType)), but only when all callers are fixed (e.g. webkit.org/b/204826).
 439         if (unitCategory(m_value-&gt;primitiveType()) != unitCategory(unitType)) {
 440             LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Calling doubleValue() with unit &quot; &lt;&lt; unitType &lt;&lt; &quot; on a node of unit type &quot; &lt;&lt; m_value-&gt;primitiveType() &lt;&lt; &quot; which is incompatible&quot;);
 441             return 0;
 442         }
 443 
 444         return m_value-&gt;doubleValue(unitType);
 445     }
 446     ASSERT_NOT_REACHED();
 447     return 0;
 448 }
 449 
 450 double CSSCalcPrimitiveValueNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const
 451 {
 452     switch (category()) {
 453     case CalculationCategory::Length:
 454         return m_value-&gt;computeLength&lt;double&gt;(conversionData);
 455     case CalculationCategory::Percent:
 456     case CalculationCategory::Number:
 457         return m_value-&gt;doubleValue();
 458     case CalculationCategory::PercentLength:
 459     case CalculationCategory::PercentNumber:
 460     case CalculationCategory::Angle:
 461     case CalculationCategory::Time:
 462     case CalculationCategory::Frequency:
 463     case CalculationCategory::Other:
 464         ASSERT_NOT_REACHED();
 465         break;
 466     }
 467     ASSERT_NOT_REACHED();
 468     return 0;
 469 }
 470 
 471 void CSSCalcPrimitiveValueNode::collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const
 472 {
 473     m_value-&gt;collectDirectComputationalDependencies(values);
 474 }
 475 
 476 void CSSCalcPrimitiveValueNode::collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const
 477 {
 478     m_value-&gt;collectDirectRootComputationalDependencies(values);
 479 }
 480 
 481 bool CSSCalcPrimitiveValueNode::equals(const CSSCalcExpressionNode&amp; other) const
 482 {
 483     if (type() != other.type())
 484         return false;
 485 
 486     return compareCSSValue(m_value, static_cast&lt;const CSSCalcPrimitiveValueNode&amp;&gt;(other).m_value);
 487 }
 488 
 489 void CSSCalcPrimitiveValueNode::dump(TextStream&amp; ts) const
 490 {
 491     ts &lt;&lt; &quot;value &quot; &lt;&lt; m_value-&gt;customCSSText() &lt;&lt; &quot; (category: &quot; &lt;&lt; category() &lt;&lt; &quot;, type: &quot; &lt;&lt; primitiveType() &lt;&lt; &quot;)&quot;;
 492 }
 493 
 494 class CSSCalcNegateNode final : public CSSCalcExpressionNode {
 495 public:
 496     static Ref&lt;CSSCalcNegateNode&gt; create(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)
 497     {
 498         return adoptRef(*new CSSCalcNegateNode(WTFMove(child)));
 499     }
 500 
 501     const CSSCalcExpressionNode&amp; child() const { return m_child.get(); }
 502     CSSCalcExpressionNode&amp; child() { return m_child.get(); }
 503 
 504     void setChild(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child) { m_child = WTFMove(child); }
 505 
 506 private:
 507     CSSCalcNegateNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)
 508         : CSSCalcExpressionNode(child-&gt;category())
 509         , m_child(WTFMove(child))
 510     {
 511     }
 512 
 513     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;
 514 
 515     bool isZero() const final { return m_child-&gt;isZero(); }
 516     double doubleValue(CSSUnitType unitType) const final { return -m_child-&gt;doubleValue(unitType); }
 517     double computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const final { return -m_child-&gt;computeLengthPx(conversionData); }
 518     Type type() const final { return Type::CssCalcNegate; }
 519     CSSUnitType primitiveType() const final { return m_child-&gt;primitiveType(); }
 520 
 521     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectComputationalDependencies(properties); }
 522     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectRootComputationalDependencies(properties); }
 523 
 524     void dump(TextStream&amp;) const final;
 525 
 526     Ref&lt;CSSCalcExpressionNode&gt; m_child;
 527 };
 528 
 529 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcNegateNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const
 530 {
 531     auto childNode = m_child-&gt;createCalcExpression(conversionData);
 532     return makeUnique&lt;CalcExpressionNegation&gt;(WTFMove(childNode));
 533 }
 534 
 535 void CSSCalcNegateNode::dump(TextStream&amp; ts) const
 536 {
 537     ts &lt;&lt; &quot;-&quot; &lt;&lt; m_child.get();
 538 }
 539 
 540 class CSSCalcInvertNode final : public CSSCalcExpressionNode {
 541 public:
 542     static Ref&lt;CSSCalcInvertNode&gt; create(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)
 543     {
 544         return adoptRef(*new CSSCalcInvertNode(WTFMove(child)));
 545     }
 546 
 547     const CSSCalcExpressionNode&amp; child() const { return m_child.get(); }
 548     CSSCalcExpressionNode&amp; child() { return m_child.get(); }
 549 
 550     void setChild(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child) { m_child = WTFMove(child); }
 551 
 552 private:
 553     CSSCalcInvertNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)
 554         : CSSCalcExpressionNode(child-&gt;category())
 555         , m_child(WTFMove(child))
 556     {
 557     }
 558 
 559     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;
 560 
 561     bool isZero() const final { return m_child-&gt;isZero(); }
 562     double doubleValue(CSSUnitType) const final;
 563     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;
 564     Type type() const final { return Type::CssCalcInvert; }
 565     CSSUnitType primitiveType() const final { return m_child-&gt;primitiveType(); }
 566 
 567     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectComputationalDependencies(properties); }
 568     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectRootComputationalDependencies(properties); }
 569 
 570     void dump(TextStream&amp;) const final;
 571 
 572     Ref&lt;CSSCalcExpressionNode&gt; m_child;
 573 };
 574 
 575 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcInvertNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const
 576 {
 577     auto childNode = m_child-&gt;createCalcExpression(conversionData);
 578     return makeUnique&lt;CalcExpressionInversion&gt;(WTFMove(childNode));
 579 }
 580 
 581 double CSSCalcInvertNode::doubleValue(CSSUnitType unitType) const
 582 {
 583     auto childValue = m_child-&gt;doubleValue(unitType);
 584     if (!childValue)
 585         return std::numeric_limits&lt;double&gt;::infinity();
 586     return 1.0 / childValue;
 587 }
 588 
 589 double CSSCalcInvertNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const
 590 {
 591     auto childValue = m_child-&gt;computeLengthPx(conversionData);
 592     if (!childValue)
 593         return std::numeric_limits&lt;double&gt;::infinity();
 594     return 1.0 / childValue;
 595 }
 596 
 597 void CSSCalcInvertNode::dump(TextStream&amp; ts) const
 598 {
 599     ts &lt;&lt; &quot;1/&quot; &lt;&lt; m_child.get();
 600 }
 601 
 602 // This is the result of the &quot;To add two types type1 and type2, perform the following steps:&quot; rules.
 603 
 604 static const CalculationCategory addSubtractResult[static_cast&lt;unsigned&gt;(CalculationCategory::Angle)][static_cast&lt;unsigned&gt;(CalculationCategory::Angle)] = {
 605 //    CalculationCategory::Number         CalculationCategory::Length         CalculationCategory::Percent        CalculationCategory::PercentNumber  CalculationCategory::PercentLength
 606     { CalculationCategory::Number,        CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::Number
 607     { CalculationCategory::Other,         CalculationCategory::Length,        CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::Length
 608     { CalculationCategory::PercentNumber, CalculationCategory::PercentLength, CalculationCategory::Percent,       CalculationCategory::PercentNumber, CalculationCategory::PercentLength }, // CalculationCategory::Percent
 609     { CalculationCategory::PercentNumber, CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::PercentNumber
 610     { CalculationCategory::Other,         CalculationCategory::PercentLength, CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::PercentLength
 611 };
 612 
 613 static CalculationCategory determineCategory(const CSSCalcExpressionNode&amp; leftSide, const CSSCalcExpressionNode&amp; rightSide, CalcOperator op)
 614 {
 615     CalculationCategory leftCategory = leftSide.category();
 616     CalculationCategory rightCategory = rightSide.category();
 617     ASSERT(leftCategory &lt; CalculationCategory::Other);
 618     ASSERT(rightCategory &lt; CalculationCategory::Other);
 619 
 620     switch (op) {
 621     case CalcOperator::Add:
 622     case CalcOperator::Subtract:
 623         if (leftCategory &lt; CalculationCategory::Angle &amp;&amp; rightCategory &lt; CalculationCategory::Angle)
 624             return addSubtractResult[static_cast&lt;unsigned&gt;(leftCategory)][static_cast&lt;unsigned&gt;(rightCategory)];
 625         if (leftCategory == rightCategory)
 626             return leftCategory;
 627         return CalculationCategory::Other;
 628     case CalcOperator::Multiply:
 629         if (leftCategory != CalculationCategory::Number &amp;&amp; rightCategory != CalculationCategory::Number)
 630             return CalculationCategory::Other;
 631         return leftCategory == CalculationCategory::Number ? rightCategory : leftCategory;
 632     case CalcOperator::Divide:
 633         if (rightCategory != CalculationCategory::Number || rightSide.isZero())
 634             return CalculationCategory::Other;
 635         return leftCategory;
 636     case CalcOperator::Min:
 637     case CalcOperator::Max:
 638     case CalcOperator::Clamp:
 639         ASSERT_NOT_REACHED();
 640         return CalculationCategory::Other;
 641     }
 642 
 643     ASSERT_NOT_REACHED();
 644     return CalculationCategory::Other;
 645 }
 646 
 647 // FIXME: Need to implement correct category computation per:
 648 // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-invert-a-type&gt;
 649 // To invert a type type, perform the following steps:
 650 // Let result be a new type with an initially empty ordered map and an initially null percent hint
 651 // For each unit → exponent of type, set result[unit] to (-1 * exponent).
 652 static CalculationCategory categoryForInvert(CalculationCategory category)
 653 {
 654     return category;
 655 }
 656 
 657 static CalculationCategory determineCategory(const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes, CalcOperator op)
 658 {
 659     if (nodes.isEmpty())
 660         return CalculationCategory::Other;
 661 
 662     auto currentCategory = nodes[0]-&gt;category();
 663 
 664     for (unsigned i = 1; i &lt; nodes.size(); ++i) {
 665         const auto&amp; node = nodes[i].get();
 666 
 667         auto usedOperator = op;
 668         if (node.type() == CSSCalcExpressionNode::Type::CssCalcInvert)
 669             usedOperator = CalcOperator::Divide;
 670 
 671         auto nextCategory = node.category();
 672 
 673         switch (usedOperator) {
 674         case CalcOperator::Add:
 675         case CalcOperator::Subtract:
 676             // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-add-two-types&gt;
 677             // At a + or - sub-expression, attempt to add the types of the left and right arguments.
 678             // If this returns failure, the entire calculation’s type is failure. Otherwise, the sub-expression’s type is the returned type.
 679             if (currentCategory &lt; CalculationCategory::Angle &amp;&amp; nextCategory &lt; CalculationCategory::Angle)
 680                 currentCategory = addSubtractResult[static_cast&lt;unsigned&gt;(currentCategory)][static_cast&lt;unsigned&gt;(nextCategory)];
 681             else if (currentCategory != nextCategory)
 682                 return CalculationCategory::Other;
 683             break;
 684 
 685         case CalcOperator::Multiply:
 686             // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-multiply-two-types&gt;
 687             // At a * sub-expression, multiply the types of the left and right arguments. The sub-expression’s type is the returned result.
 688             if (currentCategory != CalculationCategory::Number &amp;&amp; nextCategory != CalculationCategory::Number)
 689                 return CalculationCategory::Other;
 690 
 691             currentCategory = currentCategory == CalculationCategory::Number ? nextCategory : currentCategory;
 692             break;
 693 
 694         case CalcOperator::Divide: {
 695             auto invertCategory = categoryForInvert(nextCategory);
 696 
 697             // At a / sub-expression, let left type be the result of finding the types of its left argument,
 698             // and right type be the result of finding the types of its right argument and then inverting it.
 699             // The sub-expression’s type is the result of multiplying the left type and right type.
 700             if (invertCategory != CalculationCategory::Number || node.isZero())
 701                 return CalculationCategory::Other;
 702             break;
 703         }
 704 
 705         case CalcOperator::Min:
 706         case CalcOperator::Max:
 707         case CalcOperator::Clamp:
 708             // The type of a min(), max(), or clamp() expression is the result of adding the types of its comma-separated calculations
 709             return CalculationCategory::Other;
 710         }
 711     }
 712 
 713     return currentCategory;
 714 }
 715 
 716 static CalculationCategory resolvedTypeForMinOrMaxOrClamp(CalculationCategory category, CalculationCategory destinationCategory)
 717 {
 718     switch (category) {
 719     case CalculationCategory::Number:
 720     case CalculationCategory::Length:
 721     case CalculationCategory::PercentNumber:
 722     case CalculationCategory::PercentLength:
 723     case CalculationCategory::Angle:
 724     case CalculationCategory::Time:
 725     case CalculationCategory::Frequency:
 726     case CalculationCategory::Other:
 727         return category;
 728 
 729     case CalculationCategory::Percent:
 730         if (destinationCategory == CalculationCategory::Length)
 731             return CalculationCategory::PercentLength;
 732         if (destinationCategory == CalculationCategory::Number)
 733             return CalculationCategory::PercentNumber;
 734         return category;
 735     }
 736 
 737     return CalculationCategory::Other;
 738 }
 739 
 740 static bool isSamePair(CalculationCategory a, CalculationCategory b, CalculationCategory x, CalculationCategory y)
 741 {
 742     return (a == x &amp;&amp; b == y) || (a == y &amp;&amp; b == x);
 743 }
 744 
 745 class CSSCalcOperationNode final : public CSSCalcExpressionNode {
 746     WTF_MAKE_FAST_ALLOCATED;
 747 public:
 748     static RefPtr&lt;CSSCalcOperationNode&gt; create(CalcOperator, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide);
 749     static RefPtr&lt;CSSCalcOperationNode&gt; createSum(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values);
 750     static RefPtr&lt;CSSCalcOperationNode&gt; createProduct(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values);
 751     static RefPtr&lt;CSSCalcOperationNode&gt; createMinOrMaxOrClamp(CalcOperator, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory);
 752 
 753     static Ref&lt;CSSCalcExpressionNode&gt; simplify(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;);
 754 
 755     static void buildCSSText(const CSSCalcExpressionNode&amp;, StringBuilder&amp;);
 756 
 757     CalcOperator calcOperator() const { return m_operator; }
 758     bool isCalcSumNode() const { return m_operator == CalcOperator::Add; }
 759     bool isCalcProductNode() const { return m_operator == CalcOperator::Multiply; }
 760     bool isMinOrMaxNode() const { return m_operator == CalcOperator::Min || m_operator == CalcOperator::Max; }
 761     bool shouldSortChildren() const { return isCalcSumNode() || isCalcProductNode(); }
 762 
 763     void hoistChildrenWithOperator(CalcOperator);
 764     void combineChildren();
 765 
 766     bool canCombineAllChildren() const;
 767 
 768     const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; children() const { return m_children; }
 769     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; children() { return m_children; }
 770 
 771 private:
 772     CSSCalcOperationNode(CalculationCategory category, CalcOperator op, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)
 773         : CSSCalcExpressionNode(category)
 774         , m_operator(op)
 775     {
 776         m_children.reserveInitialCapacity(2);
 777         m_children.uncheckedAppend(WTFMove(leftSide));
 778         m_children.uncheckedAppend(WTFMove(rightSide));
 779     }
 780 
 781     CSSCalcOperationNode(CalculationCategory category, CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; children)
 782         : CSSCalcExpressionNode(category)
 783         , m_operator(op)
 784         , m_children(WTFMove(children))
 785     {
 786     }
 787 
 788     Type type() const final { return CssCalcOperation; }
 789 
 790     bool isZero() const final
 791     {
 792         return !doubleValue(primitiveType());
 793     }
 794 
 795     bool equals(const CSSCalcExpressionNode&amp;) const final;
 796 
 797     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;
 798 
 799     CSSUnitType primitiveType() const final;
 800     double doubleValue(CSSUnitType) const final;
 801     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;
 802 
 803     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;
 804     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;
 805 
 806     void dump(TextStream&amp;) const final;
 807 
 808     static CSSCalcExpressionNode* getNumberSide(CSSCalcExpressionNode&amp; leftSide, CSSCalcExpressionNode&amp; rightSide)
 809     {
 810         if (leftSide.category() == CalculationCategory::Number)
 811             return &amp;leftSide;
 812         if (rightSide.category() == CalculationCategory::Number)
 813             return &amp;rightSide;
 814         return nullptr;
 815     }
 816 
 817     double evaluate(const Vector&lt;double&gt;&amp; children) const
 818     {
 819         return evaluateOperator(m_operator, children);
 820     }
 821 
 822     static double evaluateOperator(CalcOperator, const Vector&lt;double&gt;&amp;);
 823     static Ref&lt;CSSCalcExpressionNode&gt; simplifyNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;, int depth);
 824     static Ref&lt;CSSCalcExpressionNode&gt; simplifyRecursive(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;, int depth);
 825 
 826     enum class GroupingParens {
 827         Omit,
 828         Include
 829     };
 830     static void buildCSSTextRecursive(const CSSCalcExpressionNode&amp;, StringBuilder&amp;, GroupingParens = GroupingParens::Include);
 831 
 832     const CalcOperator m_operator;
 833     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; m_children;
 834 };
 835 
 836 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::create(CalcOperator op, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)
 837 {
 838     if (!leftSide || !rightSide)
 839         return nullptr;
 840 
 841     ASSERT(op == CalcOperator::Add || op == CalcOperator::Multiply);
 842 
 843     ASSERT(leftSide-&gt;category() &lt; CalculationCategory::Other);
 844     ASSERT(rightSide-&gt;category() &lt; CalculationCategory::Other);
 845 
 846     auto newCategory = determineCategory(*leftSide, *rightSide, op);
 847     if (newCategory == CalculationCategory::Other) {
 848         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create CSSCalcOperationNode &quot; &lt;&lt; op &lt;&lt; &quot; node because unable to determine category from &quot; &lt;&lt; prettyPrintNode(*leftSide) &lt;&lt; &quot; and &quot; &lt;&lt; *rightSide);
 849         return nullptr;
 850     }
 851 
 852     return adoptRef(new CSSCalcOperationNode(newCategory, op, leftSide.releaseNonNull(), rightSide.releaseNonNull()));
 853 }
 854 
 855 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createSum(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values)
 856 {
 857     if (values.isEmpty())
 858         return nullptr;
 859 
 860     auto newCategory = determineCategory(values, CalcOperator::Add);
 861     if (newCategory == CalculationCategory::Other) {
 862         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create sum node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));
 863         newCategory = determineCategory(values, CalcOperator::Add);
 864         return nullptr;
 865     }
 866 
 867     return adoptRef(new CSSCalcOperationNode(newCategory, CalcOperator::Add, WTFMove(values)));
 868 }
 869 
 870 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createProduct(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values)
 871 {
 872     if (values.isEmpty())
 873         return nullptr;
 874 
 875     auto newCategory = determineCategory(values, CalcOperator::Multiply);
 876     if (newCategory == CalculationCategory::Other) {
 877         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create product node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));
 878         return nullptr;
 879     }
 880 
 881     return adoptRef(new CSSCalcOperationNode(newCategory, CalcOperator::Multiply, WTFMove(values)));
 882 }
 883 
 884 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory)
 885 {
 886     ASSERT(op == CalcOperator::Min || op == CalcOperator::Max || op == CalcOperator::Clamp);
 887     ASSERT_IMPLIES(op == CalcOperator::Clamp, values.size() == 3);
 888 
 889     Optional&lt;CalculationCategory&gt; category = WTF::nullopt;
 890     for (auto&amp; value : values) {
 891         auto valueCategory = resolvedTypeForMinOrMaxOrClamp(value-&gt;category(), destinationCategory);
 892 
 893         ASSERT(valueCategory &lt; CalculationCategory::Other);
 894         if (!category) {
 895             if (valueCategory == CalculationCategory::Other) {
 896                 LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create CSSCalcOperationNode &quot; &lt;&lt; op &lt;&lt; &quot; node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));
 897                 return nullptr;
 898             }
 899             category = valueCategory;
 900         }
 901 
 902         if (category != valueCategory) {
 903             if (isSamePair(category.value(), valueCategory, CalculationCategory::Length, CalculationCategory::PercentLength)) {
 904                 category = CalculationCategory::PercentLength;
 905                 continue;
 906             }
 907             if (isSamePair(category.value(), valueCategory, CalculationCategory::Number, CalculationCategory::PercentNumber)) {
 908                 category = CalculationCategory::PercentNumber;
 909                 continue;
 910             }
 911             return nullptr;
 912         }
 913     }
 914 
 915     return adoptRef(new CSSCalcOperationNode(category.value(), op, WTFMove(values)));
 916 }
 917 
 918 void CSSCalcOperationNode::hoistChildrenWithOperator(CalcOperator op)
 919 {
 920     ASSERT(op == CalcOperator::Add || op == CalcOperator::Multiply);
 921 
 922     auto hasChildWithOperator = [&amp;] (CalcOperator op) {
 923         for (auto&amp; child : m_children) {
 924             if (is&lt;CSSCalcOperationNode&gt;(child.get()) &amp;&amp; downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator() == op)
 925                 return true;
 926         }
 927         return false;
 928     };
 929 
 930     if (!hasChildWithOperator(op))
 931         return;
 932 
 933     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;
 934     for (auto&amp; child : m_children) {
 935         if (is&lt;CSSCalcOperationNode&gt;(child.get()) &amp;&amp; downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator() == op) {
 936             auto&amp; children = downcast&lt;CSSCalcOperationNode&gt;(child.get()).children();
 937             for (auto&amp; childToMove : children)
 938                 newChildren.append(WTFMove(childToMove));
 939         } else
 940             newChildren.append(WTFMove(child));
 941     }
 942 
 943     newChildren.shrinkToFit();
 944     m_children = WTFMove(newChildren);
 945 }
 946 
 947 enum class SortingCategory {
 948     Number,
 949     Percent,
 950     Dimension,
 951     Other
 952 };
 953 
 954 static SortingCategory sortingCategoryForType(CSSUnitType unitType)
 955 {
 956     static constexpr SortingCategory sortOrder[] = {
 957         SortingCategory::Number,        // CalculationCategory::Number,
 958         SortingCategory::Dimension,     // CalculationCategory::Length,
 959         SortingCategory::Percent,       // CalculationCategory::Percent,
 960         SortingCategory::Number,        // CalculationCategory::PercentNumber,
 961         SortingCategory::Dimension,     // CalculationCategory::PercentLength,
 962         SortingCategory::Dimension,     // CalculationCategory::Angle,
 963         SortingCategory::Dimension,     // CalculationCategory::Time,
 964         SortingCategory::Dimension,     // CalculationCategory::Frequency,
 965         SortingCategory::Other,         // UOther
 966     };
 967 
 968     COMPILE_ASSERT(ARRAY_SIZE(sortOrder) == static_cast&lt;unsigned&gt;(CalculationCategory::Other) + 1, sortOrder_size_should_match_UnitCategory);
 969     return sortOrder[static_cast&lt;unsigned&gt;(calcUnitCategory(unitType))];
 970 }
 971 
 972 static SortingCategory sortingCategory(const CSSCalcExpressionNode&amp; node)
 973 {
 974     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node))
 975         return sortingCategoryForType(node.primitiveType());
 976 
 977     return SortingCategory::Other;
 978 }
 979 
 980 static CSSUnitType primitiveTypeForCombination(const CSSCalcExpressionNode&amp; node)
 981 {
 982     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node))
 983         return node.primitiveType();
 984 
 985     return CSSUnitType::CSS_UNKNOWN;
 986 }
 987 
 988 static CSSCalcPrimitiveValueNode::UnitConversion conversionToAddValuesWithTypes(CSSUnitType firstType, CSSUnitType secondType)
 989 {
 990     if (firstType == CSSUnitType::CSS_UNKNOWN || secondType == CSSUnitType::CSS_UNKNOWN)
 991         return CSSCalcPrimitiveValueNode::UnitConversion::Invalid;
 992 
 993     auto firstCategory = calculationCategoryForCombination(firstType);
 994 
 995     // Compatible types.
 996     if (firstCategory != CalculationCategory::Other &amp;&amp; firstCategory == calculationCategoryForCombination(secondType))
 997         return CSSCalcPrimitiveValueNode::UnitConversion::Canonicalize;
 998 
 999     // Matching types.
1000     if (firstType == secondType &amp;&amp; hasDoubleValue(firstType))
1001         return CSSCalcPrimitiveValueNode::UnitConversion::Preserve;
1002 
1003     return CSSCalcPrimitiveValueNode::UnitConversion::Invalid;
1004 }
1005 
1006 bool CSSCalcOperationNode::canCombineAllChildren() const
1007 {
1008     if (m_children.size() &lt; 2)
1009         return false;
1010 
1011     if (!is&lt;CSSCalcPrimitiveValueNode&gt;(m_children[0]))
1012         return false;
1013 
1014     auto firstUnitType = m_children[0]-&gt;primitiveType();
1015     auto firstCategory = calculationCategoryForCombination(m_children[0]-&gt;primitiveType());
1016 
1017     for (unsigned i = 1; i &lt; m_children.size(); ++i) {
1018         auto&amp; node = m_children[i];
1019 
1020         if (!is&lt;CSSCalcPrimitiveValueNode&gt;(node))
1021             return false;
1022 
1023         auto nodeUnitType = node-&gt;primitiveType();
1024         auto nodeCategory = calculationCategoryForCombination(nodeUnitType);
1025 
1026         if (nodeCategory != firstCategory)
1027             return false;
1028 
1029         if (nodeCategory == CalculationCategory::Other &amp;&amp; nodeUnitType != firstUnitType)
1030             return false;
1031 
1032         if (!hasDoubleValue(nodeUnitType))
1033             return false;
1034     }
1035 
1036     return true;
1037 }
1038 
1039 void CSSCalcOperationNode::combineChildren()
1040 {
1041     if (m_children.size() &lt; 2)
1042         return;
1043 
1044     if (shouldSortChildren()) {
1045         // &lt;https://drafts.csswg.org/css-values-4/#sort-a-calculations-children&gt;
1046         std::stable_sort(m_children.begin(), m_children.end(), [](const auto&amp; first, const auto&amp; second) {
1047             // Sort order: number, percentage, dimension, other.
1048             SortingCategory firstCategory = sortingCategory(first.get());
1049             SortingCategory secondCategory = sortingCategory(second.get());
1050 
1051             if (firstCategory == SortingCategory::Dimension &amp;&amp; secondCategory == SortingCategory::Dimension) {
1052                 // If nodes contains any dimensions, remove them from nodes, sort them by their units, and append them to ret.
1053                 auto firstUnitString = CSSPrimitiveValue::unitTypeString(first-&gt;primitiveType());
1054                 auto secondUnitString = CSSPrimitiveValue::unitTypeString(second-&gt;primitiveType());
1055                 return codePointCompareLessThan(firstUnitString, secondUnitString);
1056             }
1057 
1058             return static_cast&lt;unsigned&gt;(firstCategory) &lt; static_cast&lt;unsigned&gt;(secondCategory);
1059         });
1060 
1061         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;post-sort: &quot; &lt;&lt; *this);
1062     }
1063 
1064     if (calcOperator() == CalcOperator::Add) {
1065         // For each set of root’s children that are numeric values with identical units,
1066         // remove those children and replace them with a single numeric value containing
1067         // the sum of the removed nodes, and with the same unit.
1068         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;
1069         newChildren.reserveInitialCapacity(m_children.size());
1070         newChildren.uncheckedAppend(m_children[0].copyRef());
1071 
1072         CSSUnitType previousType = primitiveTypeForCombination(newChildren[0].get());
1073 
1074         for (unsigned i = 1; i &lt; m_children.size(); ++i) {
1075             auto&amp; currentNode = m_children[i];
1076             CSSUnitType currentType = primitiveTypeForCombination(currentNode.get());
1077 
1078             auto conversionType = conversionToAddValuesWithTypes(previousType, currentType);
1079             if (conversionType != CSSCalcPrimitiveValueNode::UnitConversion::Invalid) {
1080                 downcast&lt;CSSCalcPrimitiveValueNode&gt;(newChildren.last().get()).add(downcast&lt;CSSCalcPrimitiveValueNode&gt;(currentNode.get()), conversionType);
1081                 continue;
1082             }
1083 
1084             previousType = primitiveTypeForCombination(currentNode);
1085             newChildren.uncheckedAppend(currentNode.copyRef());
1086         }
1087 
1088         newChildren.shrinkToFit();
1089         m_children = WTFMove(newChildren);
1090         return;
1091     }
1092 
1093     if (calcOperator() == CalcOperator::Multiply) {
1094         // If root has multiple children that are numbers (not percentages or dimensions),
1095         // remove them and replace them with a single number containing the product of the removed nodes.
1096         double multiplier = 1;
1097 
1098         // Sorting will have put the number nodes first.
1099         unsigned leadingNumberNodeCount = 0;
1100         for (auto&amp; node : m_children) {
1101             auto nodeType = primitiveTypeForCombination(node.get());
1102             if (nodeType != CSSUnitType::CSS_NUMBER)
1103                 break;
1104 
1105             multiplier *= node-&gt;doubleValue(CSSUnitType::CSS_NUMBER);
1106             ++leadingNumberNodeCount;
1107         }
1108 
1109         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;
1110         newChildren.reserveInitialCapacity(m_children.size());
1111 
1112         // If root contains only two children, one of which is a number (not a percentage or dimension) and the other of
1113         // which is a Sum whose children are all numeric values, multiply all of the Sum’s children by the number, then
1114         // return the Sum.
1115         // The Sum&#39;s children simplification will have happened already.
1116         bool didMultipy = false;
1117         if (leadingNumberNodeCount &amp;&amp; m_children.size() - leadingNumberNodeCount == 1) {
1118             auto multiplicandCategory = calcUnitCategory(primitiveTypeForCombination(m_children.last().get()));
1119             if (multiplicandCategory != CalculationCategory::Other) {
1120                 newChildren.uncheckedAppend(m_children.last().copyRef());
1121                 downcast&lt;CSSCalcPrimitiveValueNode&gt;(newChildren[0].get()).multiply(multiplier);
1122                 didMultipy = true;
1123             }
1124         }
1125 
1126         if (!didMultipy) {
1127             if (leadingNumberNodeCount) {
1128                 auto multiplierNode = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(multiplier, CSSUnitType::CSS_NUMBER));
1129                 newChildren.uncheckedAppend(WTFMove(multiplierNode));
1130             }
1131 
1132             for (unsigned i = leadingNumberNodeCount; i &lt; m_children.size(); ++i)
1133                 newChildren.uncheckedAppend(m_children[i].copyRef());
1134         }
1135 
1136         newChildren.shrinkToFit();
1137         m_children = WTFMove(newChildren);
1138     }
1139 
1140     if (isMinOrMaxNode() &amp;&amp; canCombineAllChildren()) {
1141         auto combinedUnitType = m_children[0]-&gt;primitiveType();
1142         auto category = calculationCategoryForCombination(combinedUnitType);
1143         if (category != CalculationCategory::Other)
1144             combinedUnitType = canonicalUnitTypeForCalculationCategory(category);
1145 
1146         double resolvedValue = doubleValue(combinedUnitType);
1147         auto newChild = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(resolvedValue, combinedUnitType));
1148 
1149         m_children.clear();
1150         m_children.append(WTFMove(newChild));
1151     }
1152 }
1153 
1154 // https://drafts.csswg.org/css-values-4/#simplify-a-calculation-tree
1155 
1156 Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplify(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode)
1157 {
1158     return simplifyRecursive(WTFMove(rootNode), 0);
1159 }
1160 
1161 Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplifyRecursive(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode, int depth)
1162 {
1163     if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {
1164         auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode.get());
1165 
1166         auto&amp; children = operationNode.children();
1167         for (unsigned i = 0; i &lt; children.size(); ++i) {
1168             auto child = children[i].copyRef();
1169             auto newNode = simplifyRecursive(WTFMove(child), depth + 1);
1170             if (newNode.ptr() != children[i].ptr())
1171                 children[i] = WTFMove(newNode);
1172         }
1173     } else if (is&lt;CSSCalcNegateNode&gt;(rootNode)) {
1174         auto&amp; negateNode = downcast&lt;CSSCalcNegateNode&gt;(rootNode.get());
1175         Ref&lt;CSSCalcExpressionNode&gt; child = negateNode.child();
1176         auto newNode = simplifyRecursive(WTFMove(child), depth + 1);
1177         if (newNode.ptr() != &amp;negateNode.child())
1178             negateNode.setChild(WTFMove(newNode));
1179     } else if (is&lt;CSSCalcInvertNode&gt;(rootNode)) {
1180         auto&amp; invertNode = downcast&lt;CSSCalcInvertNode&gt;(rootNode.get());
1181         Ref&lt;CSSCalcExpressionNode&gt; child = invertNode.child();
1182         auto newNode = simplifyRecursive(WTFMove(child), depth + 1);
1183         if (newNode.ptr() != &amp;invertNode.child())
1184             invertNode.setChild(WTFMove(newNode));
1185     }
1186 
1187     return simplifyNode(WTFMove(rootNode), depth);
1188 }
1189 
1190 Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplifyNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode, int depth)
1191 {
1192     if (is&lt;CSSCalcPrimitiveValueNode&gt;(rootNode)) {
1193         // If root is a percentage that will be resolved against another value, and there is enough information
1194         // available to resolve it, do so, and express the resulting numeric value in the appropriate canonical
1195         // unit. Return the value.
1196 
1197         // If root is a dimension that is not expressed in its canonical unit, and there is enough information
1198         // available to convert it to the canonical unit, do so, and return the value.
1199         auto&amp; primitiveValueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(rootNode.get());
1200         primitiveValueNode.canonicalizeUnit();
1201         return WTFMove(rootNode);
1202     }
1203 
1204     // If root is an operator node that’s not one of the calc-operator nodes, and all of its children are numeric values
1205     // with enough information to computed the operation root represents, return the result of running root’s operation
1206     // using its children, expressed in the result’s canonical unit.
1207     if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {
1208         auto&amp; calcOperationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode.get());
1209         // Don&#39;t simplify at the root, otherwise we lose track of the operation for serialization.
1210         if (calcOperationNode.children().size() == 1 &amp;&amp; depth)
1211             return WTFMove(calcOperationNode.children()[0]);
1212 
1213         if (calcOperationNode.isCalcSumNode()) {
1214             calcOperationNode.hoistChildrenWithOperator(CalcOperator::Add);
1215             calcOperationNode.combineChildren();
1216         }
1217 
1218         if (calcOperationNode.isCalcProductNode()) {
1219             calcOperationNode.hoistChildrenWithOperator(CalcOperator::Multiply);
1220             calcOperationNode.combineChildren();
1221         }
1222 
1223         if (calcOperationNode.isMinOrMaxNode())
1224             calcOperationNode.combineChildren();
1225 
1226         // If only one child remains, return the child (except at the root).
1227         auto shouldCombineParentWithOnlyChild = [](const CSSCalcOperationNode&amp; parent, int depth)
1228         {
1229             if (parent.children().size() != 1)
1230                 return false;
1231 
1232             // Always simplify below the root.
1233             if (depth)
1234                 return true;
1235 
1236             // At the root, preserve the root function by only merging nodes with the same function.
1237             auto&amp; child = parent.children().first();
1238             if (!is&lt;CSSCalcOperationNode&gt;(child))
1239                 return false;
1240 
1241             auto parentFunction = functionFromOperator(parent.calcOperator());
1242             auto childFunction = functionFromOperator(downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator());
1243             return childFunction == parentFunction;
1244         };
1245 
1246         if (shouldCombineParentWithOnlyChild(calcOperationNode, depth))
1247             return WTFMove(calcOperationNode.children().first());
1248 
1249         return WTFMove(rootNode);
1250     }
1251 
1252     if (is&lt;CSSCalcNegateNode&gt;(rootNode)) {
1253         auto&amp; childNode = downcast&lt;CSSCalcNegateNode&gt;(rootNode.get()).child();
1254         // If root’s child is a numeric value, return an equivalent numeric value, but with the value negated (0 - value).
1255         if (is&lt;CSSCalcPrimitiveValueNode&gt;(childNode) &amp;&amp; downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).isNumericValue()) {
1256             downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).negate();
1257             return childNode;
1258         }
1259 
1260         // If root’s child is a Negate node, return the child’s child.
1261         if (is&lt;CSSCalcNegateNode&gt;(childNode))
1262             return downcast&lt;CSSCalcNegateNode&gt;(childNode).child();
1263 
1264         return WTFMove(rootNode);
1265     }
1266 
1267     if (is&lt;CSSCalcInvertNode&gt;(rootNode)) {
1268         auto&amp; childNode = downcast&lt;CSSCalcInvertNode&gt;(rootNode.get()).child();
1269         // If root’s child is a number (not a percentage or dimension) return the reciprocal of the child’s value.
1270         if (is&lt;CSSCalcPrimitiveValueNode&gt;(childNode) &amp;&amp; downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).isNumericValue()) {
1271             downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).invert();
1272             return childNode;
1273         }
1274 
1275         // If root’s child is an Invert node, return the child’s child.
1276         if (is&lt;CSSCalcInvertNode&gt;(childNode))
1277             return downcast&lt;CSSCalcInvertNode&gt;(childNode).child();
1278 
1279         return WTFMove(rootNode);
1280     }
1281 
1282     return WTFMove(rootNode);
1283 }
1284 
1285 CSSUnitType CSSCalcOperationNode::primitiveType() const
1286 {
1287     auto unitCategory = category();
1288     switch (unitCategory) {
1289     case CalculationCategory::Number:
1290 #if ASSERT_ENABLED
1291         for (auto&amp; child : m_children)
1292             ASSERT(child-&gt;category() == CalculationCategory::Number);
1293 #endif
1294         return CSSUnitType::CSS_NUMBER;
1295 
1296     case CalculationCategory::Percent: {
1297         if (m_children.isEmpty())
1298             return CSSUnitType::CSS_UNKNOWN;
1299 
1300         if (m_children.size() == 2) {
1301             if (m_children[0]-&gt;category() == CalculationCategory::Number)
1302                 return m_children[1]-&gt;primitiveType();
1303             if (m_children[1]-&gt;category() == CalculationCategory::Number)
1304                 return m_children[0]-&gt;primitiveType();
1305         }
1306         CSSUnitType firstType = m_children[0]-&gt;primitiveType();
1307         for (auto&amp; child : m_children) {
1308             if (firstType != child-&gt;primitiveType())
1309                 return CSSUnitType::CSS_UNKNOWN;
1310         }
1311         return firstType;
1312     }
1313 
1314     case CalculationCategory::Length:
1315     case CalculationCategory::Angle:
1316     case CalculationCategory::Time:
1317     case CalculationCategory::Frequency:
1318         if (m_children.size() == 1)
1319             return m_children.first()-&gt;primitiveType();
1320         return canonicalUnitTypeForCalculationCategory(unitCategory);
1321 
1322     case CalculationCategory::PercentLength:
1323     case CalculationCategory::PercentNumber:
1324     case CalculationCategory::Other:
1325         return CSSUnitType::CSS_UNKNOWN;
1326     }
1327     ASSERT_NOT_REACHED();
1328     return CSSUnitType::CSS_UNKNOWN;
1329 }
1330 
1331 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcOperationNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const
1332 {
1333     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; nodes;
1334     nodes.reserveInitialCapacity(m_children.size());
1335 
1336     for (auto&amp; child : m_children) {
1337         auto node = child-&gt;createCalcExpression(conversionData);
1338         if (!node)
1339             return nullptr;
1340         nodes.uncheckedAppend(WTFMove(node));
1341     }
1342     return makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(nodes), m_operator);
1343 }
1344 
1345 double CSSCalcOperationNode::doubleValue(CSSUnitType unitType) const
1346 {
1347     bool allowNumbers = calcOperator() == CalcOperator::Multiply;
1348 
1349     return evaluate(m_children.map([&amp;] (auto&amp; child) {
1350         CSSUnitType childType = unitType;
1351         if (allowNumbers &amp;&amp; unitType != CSSUnitType::CSS_NUMBER &amp;&amp; child-&gt;primitiveType() == CSSUnitType::CSS_NUMBER)
1352             childType = CSSUnitType::CSS_NUMBER;
1353         return child-&gt;doubleValue(childType);
1354     }));
1355 }
1356 
1357 double CSSCalcOperationNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const
1358 {
1359     return evaluate(m_children.map([&amp;] (auto&amp; child) {
1360         return child-&gt;computeLengthPx(conversionData);
1361     }));
1362 }
1363 
1364 void CSSCalcOperationNode::collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const
1365 {
1366     for (auto&amp; child : m_children)
1367         child-&gt;collectDirectComputationalDependencies(values);
1368 }
1369 
1370 void CSSCalcOperationNode::collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const
1371 {
1372     for (auto&amp; child : m_children)
1373         child-&gt;collectDirectRootComputationalDependencies(values);
1374 }
1375 
1376 void CSSCalcOperationNode::buildCSSText(const CSSCalcExpressionNode&amp; node, StringBuilder&amp; builder)
1377 {
1378     auto shouldOutputEnclosingCalc = [](const CSSCalcExpressionNode&amp; rootNode) {
1379         if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {
1380             auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode);
1381             return operationNode.isCalcSumNode() || operationNode.isCalcProductNode();
1382         }
1383         return true;
1384     };
1385 
1386     bool outputCalc = shouldOutputEnclosingCalc(node);
1387     if (outputCalc)
1388         builder.append(&quot;calc(&quot;);
1389 
1390     buildCSSTextRecursive(node, builder, GroupingParens::Omit);
1391 
1392     if (outputCalc)
1393         builder.append(&#39;)&#39;);
1394 }
1395 
1396 static const char* functionPrefixForOperator(CalcOperator op)
1397 {
1398     switch (op) {
1399     case CalcOperator::Add:
1400     case CalcOperator::Subtract:
1401     case CalcOperator::Multiply:
1402     case CalcOperator::Divide:
1403         ASSERT_NOT_REACHED();
1404         return &quot;&quot;;
1405     case CalcOperator::Min: return &quot;min(&quot;;
1406     case CalcOperator::Max: return &quot;max(&quot;;
1407     case CalcOperator::Clamp: return &quot;clamp(&quot;;
1408     }
1409 
1410     return &quot;&quot;;
1411 }
1412 
1413 // &lt;https://drafts.csswg.org/css-values-4/#serialize-a-calculation-tree&gt;
1414 void CSSCalcOperationNode::buildCSSTextRecursive(const CSSCalcExpressionNode&amp; node, StringBuilder&amp; builder, GroupingParens parens)
1415 {
1416     // If root is a numeric value, or a non-math function, serialize root per the normal rules for it and return the result.
1417     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node)) {
1418         auto&amp; valueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(node);
1419         builder.append(valueNode.customCSSText());
1420         return;
1421     }
1422 
1423     if (is&lt;CSSCalcOperationNode&gt;(node)) {
1424         auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(node);
1425 
1426         if (operationNode.isCalcSumNode()) {
1427             // If root is a Sum node, let s be a string initially containing &quot;(&quot;.
1428             if (parens == GroupingParens::Include)
1429                 builder.append(&#39;(&#39;);
1430 
1431             // Simplification already sorted children.
1432             auto&amp; children = operationNode.children();
1433             ASSERT(children.size());
1434             // Serialize root’s first child, and append it to s.
1435             buildCSSTextRecursive(children.first(), builder);
1436 
1437             // For each child of root beyond the first:
1438             // If child is a Negate node, append &quot; - &quot; to s, then serialize the Negate’s child and append the result to s.
1439             // If child is a negative numeric value, append &quot; - &quot; to s, then serialize the negation of child as normal and append the result to s.
1440             // Otherwise, append &quot; + &quot; to s, then serialize child and append the result to s.
1441             for (unsigned i = 1; i &lt; children.size(); ++i) {
1442                 auto&amp; child = children[i];
1443                 if (is&lt;CSSCalcNegateNode&gt;(child)) {
1444                     builder.append(&quot; - &quot;);
1445                     buildCSSTextRecursive(downcast&lt;CSSCalcNegateNode&gt;(child.get()).child(), builder);
1446                     continue;
1447                 }
1448 
1449                 if (is&lt;CSSCalcPrimitiveValueNode&gt;(child)) {
1450                     auto&amp; primitiveValueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(child.get());
1451                     if (primitiveValueNode.isNegative()) {
1452                         builder.append(&quot; - &quot;);
1453                         // Serialize the negation of child.
1454                         auto unitType = primitiveValueNode.value().primitiveType();
1455                         builder.append(0 - primitiveValueNode.value().doubleValue(), CSSPrimitiveValue::unitTypeString(unitType));
1456                         continue;
1457                     }
1458                 }
1459 
1460                 builder.append(&quot; + &quot;);
1461                 buildCSSTextRecursive(child, builder);
1462             }
1463 
1464             if (parens == GroupingParens::Include)
1465                 builder.append(&#39;)&#39;);
1466             return;
1467         }
1468 
1469         if (operationNode.isCalcProductNode()) {
1470             // If root is a Product node, let s be a string initially containing &quot;(&quot;.
1471             if (parens == GroupingParens::Include)
1472                 builder.append(&#39;(&#39;);
1473 
1474             // Simplification already sorted children.
1475             auto&amp; children = operationNode.children();
1476             ASSERT(children.size());
1477             // Serialize root’s first child, and append it to s.
1478             buildCSSTextRecursive(children.first(), builder);
1479 
1480             // For each child of root beyond the first:
1481             // If child is an Invert node, append &quot; / &quot; to s, then serialize the Invert’s child and append the result to s.
1482             // Otherwise, append &quot; * &quot; to s, then serialize child and append the result to s.
1483             for (unsigned i = 1; i &lt; children.size(); ++i) {
1484                 auto&amp; child = children[i];
1485                 if (is&lt;CSSCalcInvertNode&gt;(child)) {
1486                     builder.append(&quot; / &quot;);
1487                     buildCSSTextRecursive(downcast&lt;CSSCalcInvertNode&gt;(child.get()).child(), builder);
1488                     continue;
1489                 }
1490 
1491                 builder.append(&quot; * &quot;);
1492                 buildCSSTextRecursive(child, builder);
1493             }
1494 
1495             if (parens == GroupingParens::Include)
1496                 builder.append(&#39;)&#39;);
1497             return;
1498         }
1499 
1500         // If root is anything but a Sum, Negate, Product, or Invert node, serialize a math function for the
1501         // function corresponding to the node type, treating the node’s children as the function’s
1502         // comma-separated calculation arguments, and return the result.
1503         builder.append(functionPrefixForOperator(operationNode.calcOperator()));
1504 
1505         auto&amp; children = operationNode.children();
1506         ASSERT(children.size());
1507         buildCSSTextRecursive(children.first(), builder, GroupingParens::Omit);
1508 
1509         for (unsigned i = 1; i &lt; children.size(); ++i) {
1510             builder.append(&quot;, &quot;);
1511             buildCSSTextRecursive(children[i], builder, GroupingParens::Omit);
1512         }
1513 
1514         builder.append(&#39;)&#39;);
1515         return;
1516     }
1517 
1518     if (is&lt;CSSCalcNegateNode&gt;(node)) {
1519         auto&amp; negateNode = downcast&lt;CSSCalcNegateNode&gt;(node);
1520         // If root is a Negate node, let s be a string initially containing &quot;(-1 * &quot;.
1521         builder.append(&quot;-1 *&quot;);
1522         buildCSSTextRecursive(negateNode.child(), builder);
1523         return;
1524     }
1525 
1526     if (is&lt;CSSCalcInvertNode&gt;(node)) {
1527         auto&amp; invertNode = downcast&lt;CSSCalcInvertNode&gt;(node);
1528         // If root is an Invert node, let s be a string initially containing &quot;(1 / &quot;.
1529         builder.append(&quot;1 / &quot;);
1530         buildCSSTextRecursive(invertNode.child(), builder);
1531         return;
1532     }
1533 }
1534 
1535 void CSSCalcOperationNode::dump(TextStream&amp; ts) const
1536 {
1537     ts &lt;&lt; &quot;calc operation &quot; &lt;&lt; m_operator &lt;&lt; &quot; (category: &quot; &lt;&lt; category() &lt;&lt; &quot;, type &quot; &lt;&lt; primitiveType() &lt;&lt; &quot;)&quot;;
1538 
1539     TextStream::GroupScope scope(ts);
1540     ts &lt;&lt; m_children.size() &lt;&lt; &quot; children&quot;;
1541     for (auto&amp; child : m_children)
1542         ts.dumpProperty(&quot;node&quot;, child);
1543 }
1544 
1545 bool CSSCalcOperationNode::equals(const CSSCalcExpressionNode&amp; exp) const
1546 {
1547     if (type() != exp.type())
1548         return false;
1549 
1550     const CSSCalcOperationNode&amp; other = static_cast&lt;const CSSCalcOperationNode&amp;&gt;(exp);
1551 
1552     if (m_children.size() != other.m_children.size() || m_operator != other.m_operator)
1553         return false;
1554 
1555     for (size_t i = 0; i &lt; m_children.size(); ++i) {
1556         if (!compareCSSValue(m_children[i], other.m_children[i]))
1557             return false;
1558     }
1559     return true;
1560 }
1561 
1562 double CSSCalcOperationNode::evaluateOperator(CalcOperator op, const Vector&lt;double&gt;&amp; children)
1563 {
1564     switch (op) {
1565     case CalcOperator::Add: {
1566         double sum = 0;
1567         for (auto&amp; child : children)
1568             sum += child;
1569         return sum;
1570     }
1571     case CalcOperator::Subtract:
1572         ASSERT(children.size() == 2);
1573         return children[0] - children[1];
1574     case CalcOperator::Multiply: {
1575         double product = 1;
1576         for (auto&amp; child : children)
1577             product *= child;
1578         return product;
1579     }
1580     case CalcOperator::Divide:
1581         ASSERT(children.size() == 1 || children.size() == 2);
1582         if (children.size() == 1)
1583             return std::numeric_limits&lt;double&gt;::quiet_NaN();
1584         return children[0] / children[1];
1585     case CalcOperator::Min: {
1586         if (children.isEmpty())
1587             return std::numeric_limits&lt;double&gt;::quiet_NaN();
1588         double minimum = children[0];
1589         for (auto child : children)
1590             minimum = std::min(minimum, child);
1591         return minimum;
1592     }
1593     case CalcOperator::Max: {
1594         if (children.isEmpty())
1595             return std::numeric_limits&lt;double&gt;::quiet_NaN();
1596         double maximum = children[0];
1597         for (auto child : children)
1598             maximum = std::max(maximum, child);
1599         return maximum;
1600     }
1601     case CalcOperator::Clamp: {
1602         if (children.size() != 3)
1603             return std::numeric_limits&lt;double&gt;::quiet_NaN();
1604         double min = children[0];
1605         double value = children[1];
1606         double max = children[2];
1607         return std::max(min, std::min(value, max));
1608     }
1609     }
1610     ASSERT_NOT_REACHED();
1611     return 0;
1612 }
1613 
1614 
1615 class CSSCalcExpressionNodeParser {
1616 public:
1617     explicit CSSCalcExpressionNodeParser(CalculationCategory destinationCategory)
1618         : m_destinationCategory(destinationCategory)
1619     { }
1620 
1621     RefPtr&lt;CSSCalcExpressionNode&gt; parseCalc(CSSParserTokenRange, CSSValueID function);
1622 
1623 private:
1624     char operatorValue(const CSSParserToken&amp; token)
1625     {
1626         if (token.type() == DelimiterToken)
1627             return token.delimiter();
1628         return 0;
1629     }
1630 
1631     bool parseValue(CSSParserTokenRange&amp;, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);
1632     bool parseValueTerm(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);
1633     bool parseCalcFunction(CSSParserTokenRange&amp;, CSSValueID, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);
1634     bool parseCalcSum(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);
1635     bool parseCalcProduct(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);
1636     bool parseCalcValue(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);
1637 
1638     CalculationCategory m_destinationCategory;
1639 };
1640 
1641 // &lt;https://drafts.csswg.org/css-values-4/#calc-syntax&gt;:
1642 // &lt;calc()&gt;  = calc( &lt;calc-sum&gt; )
1643 // &lt;min()&gt;   = min( &lt;calc-sum&gt;# )
1644 // &lt;max()&gt;   = max( &lt;calc-sum&gt;# )
1645 // &lt;clamp()&gt; = clamp( &lt;calc-sum&gt;#{3} )
1646 // &lt;sin()&gt;   = sin( &lt;calc-sum&gt; )
1647 // &lt;cos()&gt;   = cos( &lt;calc-sum&gt; )
1648 // &lt;tan()&gt;   = tan( &lt;calc-sum&gt; )
1649 // &lt;asin()&gt;  = asin( &lt;calc-sum&gt; )
1650 // &lt;acos()&gt;  = acos( &lt;calc-sum&gt; )
1651 // &lt;atan()&gt;  = atan( &lt;calc-sum&gt; )
1652 // &lt;atan2()&gt; = atan2( &lt;calc-sum&gt;, &lt;calc-sum&gt; )
1653 // &lt;pow()&gt;   = pow( &lt;calc-sum&gt;, &lt;calc-sum&gt; )
1654 // &lt;sqrt()&gt;  = sqrt( &lt;calc-sum&gt; )
1655 // &lt;hypot()&gt; = hypot( &lt;calc-sum&gt;# )
1656 // &lt;calc-sum&gt; = &lt;calc-product&gt; [ [ &#39;+&#39; | &#39;-&#39; ] &lt;calc-product&gt; ]*
1657 // &lt;calc-product&gt; = &lt;calc-value&gt; [ [ &#39;*&#39; | &#39;/&#39; ] &lt;calc-value&gt; ]*
1658 // &lt;calc-value&gt; = &lt;number&gt; | &lt;dimension&gt; | &lt;percentage&gt; | ( &lt;calc-sum&gt; )
1659 RefPtr&lt;CSSCalcExpressionNode&gt; CSSCalcExpressionNodeParser::parseCalc(CSSParserTokenRange tokens, CSSValueID function)
1660 {
1661     tokens.consumeWhitespace();
1662 
1663     RefPtr&lt;CSSCalcExpressionNode&gt; result;
1664     bool ok = parseCalcFunction(tokens, function, 0, result);
1665     if (!ok || !tokens.atEnd())
1666         return nullptr;
1667 
1668     if (!result)
1669         return nullptr;
1670 
1671     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcExpressionNodeParser::parseCalc &quot; &lt;&lt; prettyPrintNode(*result));
1672 
1673     result = CSSCalcOperationNode::simplify(result.releaseNonNull());
1674 
1675     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcExpressionNodeParser::parseCalc - after simplification &quot; &lt;&lt; prettyPrintNode(*result));
1676 
1677     return result;
1678 }
1679 
1680 enum ParseState {
1681     OK,
1682     TooDeep,
1683     NoMoreTokens
1684 };
1685 
1686 static ParseState checkDepthAndIndex(int depth, CSSParserTokenRange tokens)
1687 {
1688     if (tokens.atEnd())
1689         return NoMoreTokens;
1690     if (depth &gt; maxExpressionDepth) {
1691         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Depth &quot; &lt;&lt; depth &lt;&lt; &quot; exceeded maxExpressionDepth &quot; &lt;&lt; maxExpressionDepth);
1692         return TooDeep;
1693     }
1694     return OK;
1695 }
1696 
1697 bool CSSCalcExpressionNodeParser::parseCalcFunction(CSSParserTokenRange&amp; tokens, CSSValueID functionID, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)
1698 {
1699     if (checkDepthAndIndex(depth, tokens) != OK)
1700         return false;
1701 
1702     // &quot;arguments&quot; refers to things between commas.
1703     unsigned minArgumentCount = 1;
1704     Optional&lt;unsigned&gt; maxArgumentCount;
1705 
1706     switch (functionID) {
1707     case CSSValueMin:
1708     case CSSValueMax:
1709         maxArgumentCount = WTF::nullopt;
1710         break;
1711     case CSSValueClamp:
1712         minArgumentCount = 3;
1713         maxArgumentCount = 3;
1714         break;
1715     case CSSValueCalc:
1716         maxArgumentCount = 1;
1717         break;
1718     // TODO: clamp, sin, cos, tan, asin, acos, atan, atan2, pow, sqrt, hypot.
1719     default:
1720         break;
1721     }
1722 
1723     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;
1724 
1725     bool requireComma = false;
1726     unsigned argumentCount = 0;
1727     while (!tokens.atEnd()) {
1728         tokens.consumeWhitespace();
1729         if (requireComma) {
1730             if (tokens.consume().type() != CommaToken)
1731                 return false;
1732             tokens.consumeWhitespace();
1733         }
1734 
1735         RefPtr&lt;CSSCalcExpressionNode&gt; node;
1736         if (!parseCalcSum(tokens, depth, node))
1737             return false;
1738 
1739         ++argumentCount;
1740         if (maxArgumentCount &amp;&amp; argumentCount &gt; maxArgumentCount.value())
1741             return false;
1742 
1743         nodes.append(node.releaseNonNull());
1744         requireComma = true;
1745     }
1746 
1747     if (argumentCount &lt; minArgumentCount)
1748         return false;
1749 
1750     switch (functionID) {
1751     case CSSValueMin:
1752         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Min, WTFMove(nodes), m_destinationCategory);
1753         break;
1754     case CSSValueMax:
1755         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Max, WTFMove(nodes), m_destinationCategory);
1756         break;
1757     case CSSValueClamp:
1758         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Clamp, WTFMove(nodes), m_destinationCategory);
1759         break;
1760     case CSSValueWebkitCalc:
1761     case CSSValueCalc:
1762         result = CSSCalcOperationNode::createSum(WTFMove(nodes));
1763         break;
1764     // TODO: clamp, sin, cos, tan, asin, acos, atan, atan2, pow, sqrt, hypot
1765     default:
1766         break;
1767     }
1768 
1769     return !!result;
1770 }
1771 
1772 bool CSSCalcExpressionNodeParser::parseValue(CSSParserTokenRange&amp; tokens, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)
1773 {
1774     CSSParserToken token = tokens.consumeIncludingWhitespace();
1775     if (!(token.type() == NumberToken || token.type() == PercentageToken || token.type() == DimensionToken))
1776         return false;
1777 
1778     auto type = token.unitType();
1779     if (calcUnitCategory(type) == CalculationCategory::Other)
1780         return false;
1781 
1782     result = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(token.numericValue(), type));
1783 
1784     return true;
1785 }
1786 
1787 bool CSSCalcExpressionNodeParser::parseCalcValue(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)
1788 {
1789     if (checkDepthAndIndex(depth, tokens) != OK)
1790         return false;
1791 
1792     auto findFunctionId = [&amp;](CSSValueID&amp; functionId) {
1793         if (tokens.peek().type() == LeftParenthesisToken) {
1794             functionId = CSSValueCalc;
1795             return true;
1796         }
1797 
1798         functionId = tokens.peek().functionId();
1799         return CSSCalcValue::isCalcFunction(functionId);
1800     };
1801 
1802     CSSValueID functionId;
1803     if (findFunctionId(functionId)) {
1804         CSSParserTokenRange innerRange = tokens.consumeBlock();
1805         tokens.consumeWhitespace();
1806         innerRange.consumeWhitespace();
1807         return parseCalcFunction(innerRange, functionId, depth + 1, result);
1808     }
1809 
1810     return parseValue(tokens, result);
1811 }
1812 
1813 bool CSSCalcExpressionNodeParser::parseCalcProduct(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)
1814 {
1815     if (checkDepthAndIndex(depth, tokens) != OK)
1816         return false;
1817 
1818     RefPtr&lt;CSSCalcExpressionNode&gt; firstValue;
1819     if (!parseCalcValue(tokens, depth, firstValue))
1820         return false;
1821 
1822     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;
1823 
1824     while (!tokens.atEnd()) {
1825         char operatorCharacter = operatorValue(tokens.peek());
1826         if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Multiply) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Divide))
1827             break;
1828         tokens.consumeIncludingWhitespace();
1829 
1830         RefPtr&lt;CSSCalcExpressionNode&gt; nextValue;
1831         if (!parseCalcValue(tokens, depth, nextValue) || !nextValue)
1832             return false;
1833 
1834         if (operatorCharacter == static_cast&lt;char&gt;(CalcOperator::Divide))
1835             nextValue = CSSCalcInvertNode::create(nextValue.releaseNonNull());
1836 
1837         if (firstValue)
1838             nodes.append(firstValue.releaseNonNull());
1839 
1840         nodes.append(nextValue.releaseNonNull());
1841     }
1842 
1843     if (nodes.isEmpty()) {
1844         result = WTFMove(firstValue);
1845         return !!result;
1846     }
1847 
1848     result = CSSCalcOperationNode::createProduct(WTFMove(nodes));
1849     return !!result;
1850 }
1851 
1852 bool CSSCalcExpressionNodeParser::parseCalcSum(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)
1853 {
1854     if (checkDepthAndIndex(depth, tokens) != OK)
1855         return false;
1856 
1857     RefPtr&lt;CSSCalcExpressionNode&gt; firstValue;
1858     if (!parseCalcProduct(tokens, depth, firstValue))
1859         return false;
1860 
1861     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;
1862 
1863     while (!tokens.atEnd()) {
1864         char operatorCharacter = operatorValue(tokens.peek());
1865         if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Add) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Subtract))
1866             break;
1867 
1868         if ((&amp;tokens.peek() - 1)-&gt;type() != WhitespaceToken)
1869             return false; // calc(1px+ 2px) is invalid
1870 
1871         tokens.consume();
1872         if (tokens.peek().type() != WhitespaceToken)
1873             return false; // calc(1px +2px) is invalid
1874 
1875         tokens.consumeIncludingWhitespace();
1876 
1877         RefPtr&lt;CSSCalcExpressionNode&gt; nextValue;
1878         if (!parseCalcProduct(tokens, depth, nextValue) || !nextValue)
1879             return false;
1880 
1881         if (operatorCharacter == static_cast&lt;char&gt;(CalcOperator::Subtract))
1882             nextValue = CSSCalcNegateNode::create(nextValue.releaseNonNull());
1883 
1884         if (firstValue)
1885             nodes.append(firstValue.releaseNonNull());
1886 
1887         nodes.append(nextValue.releaseNonNull());
1888     }
1889 
1890     if (nodes.isEmpty()) {
1891         result = WTFMove(firstValue);
1892         return !!result;
1893     }
1894 
1895     result = CSSCalcOperationNode::createSum(WTFMove(nodes));
1896     return !!result;
1897 }
1898 
1899 static inline RefPtr&lt;CSSCalcOperationNode&gt; createBlendHalf(const Length&amp; length, const RenderStyle&amp; style, float progress)
1900 {
1901     return CSSCalcOperationNode::create(CalcOperator::Multiply, createCSS(length, style),
1902         CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(progress, CSSUnitType::CSS_NUMBER)));
1903 }
1904 
1905 static Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; createCSS(const Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt;&amp; nodes, const RenderStyle&amp; style)
1906 {
1907     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;
1908     values.reserveInitialCapacity(nodes.size());
1909     for (auto&amp; node : nodes) {
1910         auto cssNode = createCSS(*node, style);
1911         if (!cssNode)
1912             return { };
1913         values.uncheckedAppend(cssNode.releaseNonNull());
1914     }
1915     return values;
1916 }
1917 
1918 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp; node, const RenderStyle&amp; style)
1919 {
1920     switch (node.type()) {
1921     case CalcExpressionNodeType::Number: {
1922         float value = downcast&lt;CalcExpressionNumber&gt;(node).value(); // double?
1923         return CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(value, CSSUnitType::CSS_NUMBER));
1924     }
1925     case CalcExpressionNodeType::Length:
1926         return createCSS(downcast&lt;CalcExpressionLength&gt;(node).length(), style);
1927 
1928     case CalcExpressionNodeType::Negation: {
1929         auto childNode = createCSS(*downcast&lt;CalcExpressionNegation&gt;(node).child(), style);
1930         if (!childNode)
1931             return nullptr;
1932         return CSSCalcNegateNode::create(childNode.releaseNonNull());
1933     }
1934     case CalcExpressionNodeType::Inversion: {
1935         auto childNode = createCSS(*downcast&lt;CalcExpressionInversion&gt;(node).child(), style);
1936         if (!childNode)
1937             return nullptr;
1938         return CSSCalcInvertNode::create(childNode.releaseNonNull());
1939     }
1940     case CalcExpressionNodeType::Operation: {
1941         auto&amp; operationNode = downcast&lt;CalcExpressionOperation&gt;(node);
1942         auto&amp; operationChildren = operationNode.children();
1943         CalcOperator op = operationNode.getOperator();
1944 
1945         switch (op) {
1946         case CalcOperator::Add: {
1947             auto children = createCSS(operationChildren, style);
1948             if (children.isEmpty())
1949                 return nullptr;
1950             return CSSCalcOperationNode::createSum(WTFMove(children));
1951         } case CalcOperator::Subtract: {
1952             ASSERT(operationChildren.size() == 2);
1953 
1954             Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;
1955             values.reserveInitialCapacity(operationChildren.size());
1956 
1957             auto firstChild = createCSS(*operationChildren[0], style);
1958             if (!firstChild)
1959                 return nullptr;
1960 
1961             auto secondChild = createCSS(*operationChildren[1], style);
1962             if (!secondChild)
1963                 return nullptr;
1964             auto negateNode = CSSCalcNegateNode::create(secondChild.releaseNonNull());
1965 
1966             values.append(firstChild.releaseNonNull());
1967             values.append(WTFMove(negateNode));
1968 
1969             return CSSCalcOperationNode::createSum(WTFMove(values));
1970         }
1971         case CalcOperator::Multiply: {
1972             auto children = createCSS(operationChildren, style);
1973             if (children.isEmpty())
1974                 return nullptr;
1975             return CSSCalcOperationNode::createProduct(WTFMove(children));
1976         }
1977         case CalcOperator::Divide: {
1978             ASSERT(operationChildren.size() == 2);
1979 
1980             Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;
1981             values.reserveInitialCapacity(operationChildren.size());
1982 
1983             auto firstChild = createCSS(*operationChildren[0], style);
1984             if (!firstChild)
1985                 return nullptr;
1986 
1987             auto secondChild = createCSS(*operationChildren[1], style);
1988             if (!secondChild)
1989                 return nullptr;
1990             auto invertNode = CSSCalcInvertNode::create(secondChild.releaseNonNull());
1991 
1992             values.append(firstChild.releaseNonNull());
1993             values.append(WTFMove(invertNode));
1994 
1995             return CSSCalcOperationNode::createProduct(createCSS(operationChildren, style));
1996         }
1997         case CalcOperator::Min:
1998         case CalcOperator::Max:
1999         case CalcOperator::Clamp: {
2000             auto children = createCSS(operationChildren, style);
2001             if (children.isEmpty())
2002                 return nullptr;
2003             return CSSCalcOperationNode::createMinOrMaxOrClamp(op, WTFMove(children), CalculationCategory::Other);
2004         }
2005         }
2006         return nullptr;
2007     }
2008     case CalcExpressionNodeType::BlendLength: {
2009         // FIXME: (http://webkit.org/b/122036) Create a CSSCalcExpressionNode equivalent of CalcExpressionBlendLength.
2010         auto&amp; blend = downcast&lt;CalcExpressionBlendLength&gt;(node);
2011         float progress = blend.progress();
2012         return CSSCalcOperationNode::create(CalcOperator::Add, createBlendHalf(blend.from(), style, 1 - progress), createBlendHalf(blend.to(), style, progress));
2013     }
2014     case CalcExpressionNodeType::Undefined:
2015         ASSERT_NOT_REACHED();
2016     }
2017     return nullptr;
2018 }
2019 
2020 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp; length, const RenderStyle&amp; style)
2021 {
2022     switch (length.type()) {
2023     case Percent:
2024     case Fixed:
2025         return CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(length, style));
2026     case Calculated:
2027         return createCSS(length.calculationValue().expression(), style);
2028     case Auto:
2029     case Intrinsic:
2030     case MinIntrinsic:
2031     case MinContent:
2032     case MaxContent:
2033     case FillAvailable:
2034     case FitContent:
2035     case Relative:
2036     case Undefined:
2037         ASSERT_NOT_REACHED();
2038     }
2039     return nullptr;
2040 }
2041 
2042 String CSSCalcValue::customCSSText() const
2043 {
2044     StringBuilder builder;
2045     CSSCalcOperationNode::buildCSSText(m_expression.get(), builder);
2046     return builder.toString();
2047 }
2048 
2049 bool CSSCalcValue::equals(const CSSCalcValue&amp; other) const
2050 {
2051     return compareCSSValue(m_expression, other.m_expression);
2052 }
2053 
2054 inline double CSSCalcValue::clampToPermittedRange(double value) const
2055 {
2056     return m_shouldClampToNonNegative &amp;&amp; value &lt; 0 ? 0 : value;
2057 }
2058 
2059 double CSSCalcValue::doubleValue() const
2060 {
2061     return clampToPermittedRange(m_expression-&gt;doubleValue(primitiveType()));
2062 }
2063 
2064 double CSSCalcValue::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const
2065 {
2066     return clampToPermittedRange(m_expression-&gt;computeLengthPx(conversionData));
2067 }
2068 
2069 bool CSSCalcValue::isCalcFunction(CSSValueID functionId)
2070 {
2071     switch (functionId) {
2072     case CSSValueCalc:
2073     case CSSValueWebkitCalc:
2074     case CSSValueMin:
2075     case CSSValueMax:
2076     case CSSValueClamp:
2077         return true;
2078     default:
2079         return false;
2080     }
2081     return false;
2082 }
2083 
2084 void CSSCalcValue::dump(TextStream&amp; ts) const
2085 {
2086     ts &lt;&lt; indent &lt;&lt; &quot;(&quot; &lt;&lt; &quot;CSSCalcValue&quot;;
2087 
2088     TextStream multilineStream;
2089     multilineStream.setIndent(ts.indent() + 2);
2090 
2091     multilineStream.dumpProperty(&quot;should clamp non-negative&quot;, m_shouldClampToNonNegative);
2092     multilineStream.dumpProperty(&quot;expression&quot;, m_expression.get());
2093 
2094     ts &lt;&lt; multilineStream.release();
2095     ts &lt;&lt; &quot;)\n&quot;;
2096 }
2097 
2098 RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(CSSValueID function, const CSSParserTokenRange&amp; tokens, CalculationCategory destinationCategory, ValueRange range)
2099 {
2100     CSSCalcExpressionNodeParser parser(destinationCategory);
2101     auto expression = parser.parseCalc(tokens, function);
2102     if (!expression)
2103         return nullptr;
2104     auto result = adoptRef(new CSSCalcValue(expression.releaseNonNull(), range != ValueRangeAll));
2105     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcValue::create &quot; &lt;&lt; *result);
2106     return result;
2107 }
2108 
2109 RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(const CalculationValue&amp; value, const RenderStyle&amp; style)
2110 {
2111     auto expression = createCSS(value.expression(), style);
2112     if (!expression)
2113         return nullptr;
2114     auto result = adoptRef(new CSSCalcValue(expression.releaseNonNull(), value.shouldClampToNonNegative()));
2115     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcValue::create from CalculationValue: &quot; &lt;&lt; *result);
2116     return result;
2117 }
2118 
2119 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CalculationCategory category)
2120 {
2121     switch (category) {
2122     case CalculationCategory::Number: ts &lt;&lt; &quot;number&quot;; break;
2123     case CalculationCategory::Length: ts &lt;&lt; &quot;length&quot;; break;
2124     case CalculationCategory::Percent: ts &lt;&lt; &quot;percent&quot;; break;
2125     case CalculationCategory::PercentNumber: ts &lt;&lt; &quot;percent-number&quot;; break;
2126     case CalculationCategory::PercentLength: ts &lt;&lt; &quot;percent-length&quot;; break;
2127     case CalculationCategory::Angle: ts &lt;&lt; &quot;angle&quot;; break;
2128     case CalculationCategory::Time: ts &lt;&lt; &quot;time&quot;; break;
2129     case CalculationCategory::Frequency: ts &lt;&lt; &quot;frequency&quot;; break;
2130     case CalculationCategory::Other: ts &lt;&lt; &quot;other&quot;; break;
2131     }
2132 
2133     return ts;
2134 }
2135 
2136 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CSSCalcValue&amp; value)
2137 {
2138     value.dump(ts);
2139     return ts;
2140 }
2141 
2142 } // namespace WebCore
    </pre>
  </body>
</html>
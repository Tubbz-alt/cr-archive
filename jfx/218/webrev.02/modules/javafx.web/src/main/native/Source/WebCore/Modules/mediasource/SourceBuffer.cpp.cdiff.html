<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SampleMap.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SourceBuffer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,10 ***</span>
<span class="line-new-header">--- 39,11 ---</span>
  #include &quot;Event.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;GenericEventQueue.h&quot;
  #include &quot;HTMLMediaElement.h&quot;
  #include &quot;InbandTextTrack.h&quot;
<span class="line-added">+ #include &quot;InbandTextTrackPrivate.h&quot;</span>
  #include &quot;Logging.h&quot;
  #include &quot;MediaDescription.h&quot;
  #include &quot;MediaSample.h&quot;
  #include &quot;MediaSource.h&quot;
  #include &quot;SampleMap.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 55,26 ***</span>
  #include &lt;JavaScriptCore/JSLock.h&gt;
  #include &lt;JavaScriptCore/VM.h&gt;
  #include &lt;limits&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(SourceBuffer);
  
  static const double ExponentialMovingAverageCoefficient = 0.1;
  
  struct SourceBuffer::TrackBuffer {
      MediaTime lastDecodeTimestamp;
      MediaTime greatestDecodeDuration;
      MediaTime lastFrameDuration;
      MediaTime highestPresentationTimestamp;
<span class="line-modified">!     MediaTime lastEnqueuedPresentationTime;</span>
      MediaTime minimumEnqueuedPresentationTime;
      DecodeOrderSampleMap::KeyType lastEnqueuedDecodeKey;
<span class="line-modified">!     MediaTime lastEnqueuedDecodeDuration;</span>
      MediaTime roundedTimestampOffset;
      uint32_t lastFrameTimescale { 0 };
      bool needRandomAccessFlag { true };
      bool enabled { false };
      bool needsReenqueueing { false };
<span class="line-new-header">--- 56,36 ---</span>
  #include &lt;JavaScriptCore/JSLock.h&gt;
  #include &lt;JavaScriptCore/VM.h&gt;
  #include &lt;limits&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
  #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="line-added">+ #include &lt;wtf/WeakPtr.h&gt;</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(SourceBuffer);
  
  static const double ExponentialMovingAverageCoefficient = 0.1;
  
<span class="line-added">+ // Do not enqueue samples spanning a significant unbuffered gap.</span>
<span class="line-added">+ // NOTE: one second is somewhat arbitrary. MediaSource::monitorSourceBuffers() is run</span>
<span class="line-added">+ // on the playbackTimer, which is effectively every 350ms. Allowing &gt; 350ms gap between</span>
<span class="line-added">+ // enqueued samples allows for situations where we overrun the end of a buffered range</span>
<span class="line-added">+ // but don&#39;t notice for 350s of playback time, and the client can enqueue data for the</span>
<span class="line-added">+ // new current time without triggering this early return.</span>
<span class="line-added">+ // FIXME(135867): Make this gap detection logic less arbitrary.</span>
<span class="line-added">+ static const MediaTime discontinuityTolerance = MediaTime(1, 1);</span>
<span class="line-added">+ </span>
  struct SourceBuffer::TrackBuffer {
      MediaTime lastDecodeTimestamp;
      MediaTime greatestDecodeDuration;
      MediaTime lastFrameDuration;
      MediaTime highestPresentationTimestamp;
<span class="line-modified">!     MediaTime highestEnqueuedPresentationTime;</span>
      MediaTime minimumEnqueuedPresentationTime;
      DecodeOrderSampleMap::KeyType lastEnqueuedDecodeKey;
<span class="line-modified">!     MediaTime enqueueDiscontinuityBoundary { MediaTime::zeroTime() };</span>
      MediaTime roundedTimestampOffset;
      uint32_t lastFrameTimescale { 0 };
      bool needRandomAccessFlag { true };
      bool enabled { false };
      bool needsReenqueueing { false };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,13 ***</span>
      TrackBuffer()
          : lastDecodeTimestamp(MediaTime::invalidTime())
          , greatestDecodeDuration(MediaTime::invalidTime())
          , lastFrameDuration(MediaTime::invalidTime())
          , highestPresentationTimestamp(MediaTime::invalidTime())
<span class="line-modified">!         , lastEnqueuedPresentationTime(MediaTime::invalidTime())</span>
          , lastEnqueuedDecodeKey({MediaTime::invalidTime(), MediaTime::invalidTime()})
<span class="line-modified">!         , lastEnqueuedDecodeDuration(MediaTime::invalidTime())</span>
      {
      }
  };
  
  Ref&lt;SourceBuffer&gt; SourceBuffer::create(Ref&lt;SourceBufferPrivate&gt;&amp;&amp; sourceBufferPrivate, MediaSource* source)
<span class="line-new-header">--- 98,13 ---</span>
      TrackBuffer()
          : lastDecodeTimestamp(MediaTime::invalidTime())
          , greatestDecodeDuration(MediaTime::invalidTime())
          , lastFrameDuration(MediaTime::invalidTime())
          , highestPresentationTimestamp(MediaTime::invalidTime())
<span class="line-modified">!         , highestEnqueuedPresentationTime(MediaTime::invalidTime())</span>
          , lastEnqueuedDecodeKey({MediaTime::invalidTime(), MediaTime::invalidTime()})
<span class="line-modified">!         , enqueueDiscontinuityBoundary(discontinuityTolerance)</span>
      {
      }
  };
  
  Ref&lt;SourceBuffer&gt; SourceBuffer::create(Ref&lt;SourceBufferPrivate&gt;&amp;&amp; sourceBufferPrivate, MediaSource* source)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,11 ***</span>
  
  SourceBuffer::SourceBuffer(Ref&lt;SourceBufferPrivate&gt;&amp;&amp; sourceBufferPrivate, MediaSource* source)
      : ActiveDOMObject(source-&gt;scriptExecutionContext())
      , m_private(WTFMove(sourceBufferPrivate))
      , m_source(source)
<span class="line-modified">!     , m_asyncEventQueue(*this)</span>
      , m_appendBufferTimer(*this, &amp;SourceBuffer::appendBufferTimerFired)
      , m_appendWindowStart(MediaTime::zeroTime())
      , m_appendWindowEnd(MediaTime::positiveInfiniteTime())
      , m_groupStartTimestamp(MediaTime::invalidTime())
      , m_groupEndTimestamp(MediaTime::zeroTime())
<span class="line-new-header">--- 116,11 ---</span>
  
  SourceBuffer::SourceBuffer(Ref&lt;SourceBufferPrivate&gt;&amp;&amp; sourceBufferPrivate, MediaSource* source)
      : ActiveDOMObject(source-&gt;scriptExecutionContext())
      , m_private(WTFMove(sourceBufferPrivate))
      , m_source(source)
<span class="line-modified">!     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))</span>
      , m_appendBufferTimer(*this, &amp;SourceBuffer::appendBufferTimerFired)
      , m_appendWindowStart(MediaTime::zeroTime())
      , m_appendWindowEnd(MediaTime::positiveInfiniteTime())
      , m_groupStartTimestamp(MediaTime::invalidTime())
      , m_groupEndTimestamp(MediaTime::zeroTime())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,12 ***</span>
  }
  
  MediaTime SourceBuffer::sourceBufferPrivateFastSeekTimeForMediaTime(const MediaTime&amp; targetTime, const MediaTime&amp; negativeThreshold, const MediaTime&amp; positiveThreshold)
  {
      MediaTime seekTime = targetTime;
<span class="line-removed">-     MediaTime lowerBoundTime = targetTime - negativeThreshold;</span>
<span class="line-removed">-     MediaTime upperBoundTime = targetTime + positiveThreshold;</span>
  
      for (auto&amp; trackBuffer : m_trackBufferMap.values()) {
          // Find the sample which contains the target time time.
          auto futureSyncSampleIterator = trackBuffer.samples.decodeOrder().findSyncSampleAfterPresentationTime(targetTime, positiveThreshold);
          auto pastSyncSampleIterator = trackBuffer.samples.decodeOrder().findSyncSamplePriorToPresentationTime(targetTime, negativeThreshold);
<span class="line-new-header">--- 502,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 526,44 ***</span>
      return seekTime;
  }
  
  bool SourceBuffer::hasPendingActivity() const
  {
<span class="line-modified">!     return m_source || m_asyncEventQueue.hasPendingEvents();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void SourceBuffer::suspend(ReasonForSuspension reason)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     switch (reason) {</span>
<span class="line-removed">-     case ReasonForSuspension::PageCache:</span>
<span class="line-removed">-     case ReasonForSuspension::PageWillBeSuspended:</span>
<span class="line-removed">-         m_asyncEventQueue.suspend();</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case ReasonForSuspension::JavaScriptDebuggerPaused:</span>
<span class="line-removed">-     case ReasonForSuspension::WillDeferLoading:</span>
<span class="line-removed">-         // Do nothing, we don&#39;t pause media playback in these cases.</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void SourceBuffer::resume()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_asyncEventQueue.resume();</span>
  }
  
  void SourceBuffer::stop()
  {
<span class="line-removed">-     m_asyncEventQueue.close();</span>
      m_appendBufferTimer.stop();
      m_removeTimer.stop();
  }
  
<span class="line-removed">- bool SourceBuffer::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return !hasPendingActivity();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  const char* SourceBuffer::activeDOMObjectName() const
  {
      return &quot;SourceBuffer&quot;;
  }
  
<span class="line-new-header">--- 535,19 ---</span>
      return seekTime;
  }
  
  bool SourceBuffer::hasPendingActivity() const
  {
<span class="line-modified">!     return m_source || m_asyncEventQueue-&gt;hasPendingEvents();</span>
  }
  
  void SourceBuffer::stop()
  {
      m_appendBufferTimer.stop();
      m_removeTimer.stop();
  }
  
  const char* SourceBuffer::activeDOMObjectName() const
  {
      return &quot;SourceBuffer&quot;;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,11 ***</span>
  void SourceBuffer::scheduleEvent(const AtomString&amp; eventName)
  {
      auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No);
      event-&gt;setTarget(this);
  
<span class="line-modified">!     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
  }
  
  ExceptionOr&lt;void&gt; SourceBuffer::appendBufferInternal(const unsigned char* data, unsigned size)
  {
      // Section 3.2 appendBuffer()
<span class="line-new-header">--- 559,11 ---</span>
  void SourceBuffer::scheduleEvent(const AtomString&amp; eventName)
  {
      auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No);
      event-&gt;setTarget(this);
  
<span class="line-modified">!     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
  }
  
  ExceptionOr&lt;void&gt; SourceBuffer::appendBufferInternal(const unsigned char* data, unsigned size)
  {
      // Section 3.2 appendBuffer()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 823,15 ***</span>
  
  void SourceBuffer::removeCodedFrames(const MediaTime&amp; start, const MediaTime&amp; end)
  {
      DEBUG_LOG(LOGIDENTIFIER, &quot;start = &quot;, start, &quot;, end = &quot;, end);
  
      // 3.5.9 Coded Frame Removal Algorithm
      // https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#sourcebuffer-coded-frame-removal
  
      // 1. Let start be the starting presentation timestamp for the removal range.
<span class="line-removed">-     MediaTime durationMediaTime = m_source-&gt;duration();</span>
      MediaTime currentMediaTime = m_source-&gt;currentTime();
  
      // 2. Let end be the end presentation timestamp for the removal range.
      // 3. For each track buffer in this source buffer, run the following steps:
      for (auto&amp; trackBufferKeyValue : m_trackBufferMap) {
<span class="line-new-header">--- 807,18 ---</span>
  
  void SourceBuffer::removeCodedFrames(const MediaTime&amp; start, const MediaTime&amp; end)
  {
      DEBUG_LOG(LOGIDENTIFIER, &quot;start = &quot;, start, &quot;, end = &quot;, end);
  
<span class="line-added">+     ASSERT(start &lt; end);</span>
<span class="line-added">+     if (start &gt;= end)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      // 3.5.9 Coded Frame Removal Algorithm
      // https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#sourcebuffer-coded-frame-removal
  
      // 1. Let start be the starting presentation timestamp for the removal range.
      MediaTime currentMediaTime = m_source-&gt;currentTime();
  
      // 2. Let end be the end presentation timestamp for the removal range.
      // 3. For each track buffer in this source buffer, run the following steps:
      for (auto&amp; trackBufferKeyValue : m_trackBufferMap) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,12 ***</span>
          DecodeOrderSampleMap::MapType erasedSamples(removeDecodeStart, removeDecodeEnd);
          PlatformTimeRanges erasedRanges = removeSamplesFromTrackBuffer(erasedSamples, trackBuffer, this, &quot;removeCodedFrames&quot;);
  
          // Only force the TrackBuffer to re-enqueue if the removed ranges overlap with enqueued and possibly
          // not yet displayed samples.
<span class="line-modified">!         if (trackBuffer.lastEnqueuedPresentationTime.isValid() &amp;&amp; currentMediaTime &lt; trackBuffer.lastEnqueuedPresentationTime) {</span>
<span class="line-modified">!             PlatformTimeRanges possiblyEnqueuedRanges(currentMediaTime, trackBuffer.lastEnqueuedPresentationTime);</span>
              possiblyEnqueuedRanges.intersectWith(erasedRanges);
              if (possiblyEnqueuedRanges.length()) {
                  trackBuffer.needsReenqueueing = true;
                  DEBUG_LOG(LOGIDENTIFIER, &quot;the range in removeCodedFrames() includes already enqueued samples, reenqueueing from &quot;, currentMediaTime);
                  reenqueueMediaForTime(trackBuffer, trackID, currentMediaTime);
<span class="line-new-header">--- 871,12 ---</span>
          DecodeOrderSampleMap::MapType erasedSamples(removeDecodeStart, removeDecodeEnd);
          PlatformTimeRanges erasedRanges = removeSamplesFromTrackBuffer(erasedSamples, trackBuffer, this, &quot;removeCodedFrames&quot;);
  
          // Only force the TrackBuffer to re-enqueue if the removed ranges overlap with enqueued and possibly
          // not yet displayed samples.
<span class="line-modified">!         if (trackBuffer.highestEnqueuedPresentationTime.isValid() &amp;&amp; currentMediaTime &lt; trackBuffer.highestEnqueuedPresentationTime) {</span>
<span class="line-modified">!             PlatformTimeRanges possiblyEnqueuedRanges(currentMediaTime, trackBuffer.highestEnqueuedPresentationTime);</span>
              possiblyEnqueuedRanges.intersectWith(erasedRanges);
              if (possiblyEnqueuedRanges.length()) {
                  trackBuffer.needsReenqueueing = true;
                  DEBUG_LOG(LOGIDENTIFIER, &quot;the range in removeCodedFrames() includes already enqueued samples, reenqueueing from &quot;, currentMediaTime);
                  reenqueueMediaForTime(trackBuffer, trackID, currentMediaTime);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 901,12 ***</span>
          setBufferedDirty(true);
  
          // 3.4 If this object is in activeSourceBuffers, the current playback position is greater than or equal to start
          // and less than the remove end timestamp, and HTMLMediaElement.readyState is greater than HAVE_METADATA, then set
          // the HTMLMediaElement.readyState attribute to HAVE_METADATA and stall playback.
<span class="line-modified">!         if (m_active &amp;&amp; currentMediaTime &gt;= start &amp;&amp; currentMediaTime &lt; end &amp;&amp; m_private-&gt;readyState() &gt; MediaPlayer::HaveMetadata)</span>
<span class="line-modified">!             m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);</span>
      }
  
      updateBufferedFromTrackBuffers();
  
      // 4. If buffer full flag equals true and this object is ready to accept more bytes, then set the buffer full flag to false.
<span class="line-new-header">--- 888,12 ---</span>
          setBufferedDirty(true);
  
          // 3.4 If this object is in activeSourceBuffers, the current playback position is greater than or equal to start
          // and less than the remove end timestamp, and HTMLMediaElement.readyState is greater than HAVE_METADATA, then set
          // the HTMLMediaElement.readyState attribute to HAVE_METADATA and stall playback.
<span class="line-modified">!         if (m_active &amp;&amp; currentMediaTime &gt;= start &amp;&amp; currentMediaTime &lt; end &amp;&amp; m_private-&gt;readyState() &gt; MediaPlayer::ReadyState::HaveMetadata)</span>
<span class="line-modified">!             m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
      }
  
      updateBufferedFromTrackBuffers();
  
      // 4. If buffer full flag equals true and this object is ready to accept more bytes, then set the buffer full flag to false.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1055,25 ***</span>
  }
  
  VideoTrackList&amp; SourceBuffer::videoTracks()
  {
      if (!m_videoTracks)
<span class="line-modified">!         m_videoTracks = VideoTrackList::create(m_source-&gt;mediaElement(), scriptExecutionContext());</span>
      return *m_videoTracks;
  }
  
  AudioTrackList&amp; SourceBuffer::audioTracks()
  {
      if (!m_audioTracks)
<span class="line-modified">!         m_audioTracks = AudioTrackList::create(m_source-&gt;mediaElement(), scriptExecutionContext());</span>
      return *m_audioTracks;
  }
  
  TextTrackList&amp; SourceBuffer::textTracks()
  {
      if (!m_textTracks)
<span class="line-modified">!         m_textTracks = TextTrackList::create(m_source-&gt;mediaElement(), scriptExecutionContext());</span>
      return *m_textTracks;
  }
  
  void SourceBuffer::setActive(bool active)
  {
<span class="line-new-header">--- 1042,25 ---</span>
  }
  
  VideoTrackList&amp; SourceBuffer::videoTracks()
  {
      if (!m_videoTracks)
<span class="line-modified">!         m_videoTracks = VideoTrackList::create(makeWeakPtr(m_source-&gt;mediaElement()), scriptExecutionContext());</span>
      return *m_videoTracks;
  }
  
  AudioTrackList&amp; SourceBuffer::audioTracks()
  {
      if (!m_audioTracks)
<span class="line-modified">!         m_audioTracks = AudioTrackList::create(makeWeakPtr(m_source-&gt;mediaElement()), scriptExecutionContext());</span>
      return *m_audioTracks;
  }
  
  TextTrackList&amp; SourceBuffer::textTracks()
  {
      if (!m_textTracks)
<span class="line-modified">!         m_textTracks = TextTrackList::create(makeWeakPtr(m_source-&gt;mediaElement()), scriptExecutionContext());</span>
      return *m_textTracks;
  }
  
  void SourceBuffer::setActive(bool active)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1303,27 ***</span>
      // (Note: Issue #155 adds this step after step 5:)
      // 6. Set  pending initialization segment for changeType flag  to false.
      m_pendingInitializationSegmentForChangeType = false;
  
      // 6. If the HTMLMediaElement.readyState attribute is HAVE_NOTHING, then run the following steps:
<span class="line-modified">!     if (m_private-&gt;readyState() == MediaPlayer::HaveNothing) {</span>
          // 6.1 If one or more objects in sourceBuffers have first initialization segment flag set to false, then abort these steps.
          for (auto&amp; sourceBuffer : *m_source-&gt;sourceBuffers()) {
              if (!sourceBuffer-&gt;m_receivedFirstInitializationSegment)
                  return;
          }
  
          // 6.2 Set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
          // 6.3 Queue a task to fire a simple event named loadedmetadata at the media element.
<span class="line-modified">!         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);</span>
      }
  
      // 7. If the active track flag equals true and the HTMLMediaElement.readyState
      // attribute is greater than HAVE_CURRENT_DATA, then set the HTMLMediaElement.readyState
      // attribute to HAVE_METADATA.
<span class="line-modified">!     if (activeTrackFlag &amp;&amp; m_private-&gt;readyState() &gt; MediaPlayer::HaveCurrentData)</span>
<span class="line-modified">!         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);</span>
  }
  
  bool SourceBuffer::validateInitializationSegment(const InitializationSegment&amp; segment)
  {
      // FIXME: ordering of all 3.5.X (X&gt;=7) functions needs to be updated to post-[24 July 2014 Editor&#39;s Draft] version
<span class="line-new-header">--- 1290,27 ---</span>
      // (Note: Issue #155 adds this step after step 5:)
      // 6. Set  pending initialization segment for changeType flag  to false.
      m_pendingInitializationSegmentForChangeType = false;
  
      // 6. If the HTMLMediaElement.readyState attribute is HAVE_NOTHING, then run the following steps:
<span class="line-modified">!     if (m_private-&gt;readyState() == MediaPlayer::ReadyState::HaveNothing) {</span>
          // 6.1 If one or more objects in sourceBuffers have first initialization segment flag set to false, then abort these steps.
          for (auto&amp; sourceBuffer : *m_source-&gt;sourceBuffers()) {
              if (!sourceBuffer-&gt;m_receivedFirstInitializationSegment)
                  return;
          }
  
          // 6.2 Set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
          // 6.3 Queue a task to fire a simple event named loadedmetadata at the media element.
<span class="line-modified">!         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
      }
  
      // 7. If the active track flag equals true and the HTMLMediaElement.readyState
      // attribute is greater than HAVE_CURRENT_DATA, then set the HTMLMediaElement.readyState
      // attribute to HAVE_METADATA.
<span class="line-modified">!     if (activeTrackFlag &amp;&amp; m_private-&gt;readyState() &gt; MediaPlayer::ReadyState::HaveCurrentData)</span>
<span class="line-modified">!         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
  }
  
  bool SourceBuffer::validateInitializationSegment(const InitializationSegment&amp; segment)
  {
      // FIXME: ordering of all 3.5.X (X&gt;=7) functions needs to be updated to post-[24 July 2014 Editor&#39;s Draft] version
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1694,10 ***</span>
<span class="line-new-header">--- 1681,33 ---</span>
              auto iter_pair = trackBuffer.samples.presentationOrder().findSamplesBetweenPresentationTimes(presentationTimestamp, frameEndTimestamp);
              if (iter_pair.first != trackBuffer.samples.presentationOrder().end())
                  erasedSamples.addRange(iter_pair.first, iter_pair.second);
          }
  
<span class="line-added">+         // When appending media containing B-frames (media whose samples&#39; presentation timestamps</span>
<span class="line-added">+         // do not increase monotonically, the prior erase steps could leave a sample in the trackBuffer</span>
<span class="line-added">+         // which will be disconnected from its previous I-frame. If the incoming frame is an I-frame,</span>
<span class="line-added">+         // remove all samples in decode order between the incoming I-frame&#39;s decode timestamp and the</span>
<span class="line-added">+         // next I-frame. See &lt;https://github.com/w3c/media-source/issues/187&gt; for a discussion of what</span>
<span class="line-added">+         // the how the MSE specification should handlie this secnario.</span>
<span class="line-added">+         do {</span>
<span class="line-added">+             if (!sample.isSync())</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             DecodeOrderSampleMap::KeyType decodeKey(sample.decodeTime(), sample.presentationTime());</span>
<span class="line-added">+             auto nextSampleInDecodeOrder = trackBuffer.samples.decodeOrder().findSampleAfterDecodeKey(decodeKey);</span>
<span class="line-added">+             if (nextSampleInDecodeOrder == trackBuffer.samples.decodeOrder().end())</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (nextSampleInDecodeOrder-&gt;second-&gt;isSync())</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto nextSyncSample = trackBuffer.samples.decodeOrder().findSyncSampleAfterDecodeIterator(nextSampleInDecodeOrder);</span>
<span class="line-added">+             INFO_LOG(LOGIDENTIFIER, &quot;Discovered out-of-order frames, from: &quot;, *nextSampleInDecodeOrder-&gt;second, &quot; to: &quot;, (nextSyncSample == trackBuffer.samples.decodeOrder().end() ? &quot;[end]&quot;_s : toString(*nextSyncSample-&gt;second)));</span>
<span class="line-added">+             erasedSamples.addRange(nextSampleInDecodeOrder, nextSyncSample);</span>
<span class="line-added">+         } while (false);</span>
<span class="line-added">+ </span>
          // There are many files out there where the frame times are not perfectly contiguous and may have small overlaps
          // between the beginning of a frame and the end of the previous one; therefore a tolerance is needed whenever
          // durations are considered.
          // For instance, most WebM files are muxed rounded to the millisecond (the default TimecodeScale of the format)
          // but their durations use a finer timescale (causing a sub-millisecond overlap). More rarely, there are also
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1757,12 ***</span>
              PlatformTimeRanges erasedRanges = removeSamplesFromTrackBuffer(dependentSamples, trackBuffer, this, &quot;sourceBufferPrivateDidReceiveSample&quot;);
  
              // Only force the TrackBuffer to re-enqueue if the removed ranges overlap with enqueued and possibly
              // not yet displayed samples.
              MediaTime currentMediaTime = m_source-&gt;currentTime();
<span class="line-modified">!             if (trackBuffer.lastEnqueuedPresentationTime.isValid() &amp;&amp; currentMediaTime &lt; trackBuffer.lastEnqueuedPresentationTime) {</span>
<span class="line-modified">!                 PlatformTimeRanges possiblyEnqueuedRanges(currentMediaTime, trackBuffer.lastEnqueuedPresentationTime);</span>
                  possiblyEnqueuedRanges.intersectWith(erasedRanges);
                  if (possiblyEnqueuedRanges.length())
                      trackBuffer.needsReenqueueing = true;
              }
  
<span class="line-new-header">--- 1767,12 ---</span>
              PlatformTimeRanges erasedRanges = removeSamplesFromTrackBuffer(dependentSamples, trackBuffer, this, &quot;sourceBufferPrivateDidReceiveSample&quot;);
  
              // Only force the TrackBuffer to re-enqueue if the removed ranges overlap with enqueued and possibly
              // not yet displayed samples.
              MediaTime currentMediaTime = m_source-&gt;currentTime();
<span class="line-modified">!             if (trackBuffer.highestEnqueuedPresentationTime.isValid() &amp;&amp; currentMediaTime &lt; trackBuffer.highestEnqueuedPresentationTime) {</span>
<span class="line-modified">!                 PlatformTimeRanges possiblyEnqueuedRanges(currentMediaTime, trackBuffer.highestEnqueuedPresentationTime);</span>
                  possiblyEnqueuedRanges.intersectWith(erasedRanges);
                  if (possiblyEnqueuedRanges.length())
                      trackBuffer.needsReenqueueing = true;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1780,15 ***</span>
          // Otherwise:
          // Add the coded frame with the presentation timestamp, decode timestamp, and frame duration to the track buffer.
          trackBuffer.samples.addSample(sample);
  
          // Note: The terminology here is confusing: &quot;enqueuing&quot; means providing a frame to the inner media framework.
<span class="line-modified">!         // First, frames are inserted in the decode queue; later, at the end of the append all the frames in the decode</span>
<span class="line-modified">!         // queue are &quot;enqueued&quot; (sent to the inner media framework) in `provideMediaData()`.</span>
          //
<span class="line-modified">!         // In order to check whether a frame should be added to the decode queue we check whether it starts after the</span>
<span class="line-modified">!         // lastEnqueuedDecodeKey.</span>
          DecodeOrderSampleMap::KeyType decodeKey(sample.decodeTime(), sample.presentationTime());
          if (trackBuffer.lastEnqueuedDecodeKey.first.isInvalid() || decodeKey &gt; trackBuffer.lastEnqueuedDecodeKey) {
              trackBuffer.decodeQueue.insert(DecodeOrderSampleMap::MapType::value_type(decodeKey, &amp;sample));
  
              if (trackBuffer.minimumEnqueuedPresentationTime.isValid() &amp;&amp; sample.presentationTime() &lt; trackBuffer.minimumEnqueuedPresentationTime)
<span class="line-new-header">--- 1790,19 ---</span>
          // Otherwise:
          // Add the coded frame with the presentation timestamp, decode timestamp, and frame duration to the track buffer.
          trackBuffer.samples.addSample(sample);
  
          // Note: The terminology here is confusing: &quot;enqueuing&quot; means providing a frame to the inner media framework.
<span class="line-modified">!         // First, frames are inserted in the decode queue; later, at the end of the append some of the frames in the</span>
<span class="line-modified">!         // decode may be &quot;enqueued&quot; (sent to the inner media framework) in `provideMediaData()`.</span>
          //
<span class="line-modified">!         // In order to check whether a frame should be added to the decode queue we check that it does not precede any</span>
<span class="line-modified">!         // frame already enqueued.</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // Note that adding a frame to the decode queue is no guarantee that it will be actually enqueued at that point.</span>
<span class="line-added">+         // If the frame is after the discontinuity boundary, the enqueueing algorithm will hold it there until samples</span>
<span class="line-added">+         // with earlier timestamps are enqueued. The decode queue is not FIFO, but rather an ordered map.</span>
          DecodeOrderSampleMap::KeyType decodeKey(sample.decodeTime(), sample.presentationTime());
          if (trackBuffer.lastEnqueuedDecodeKey.first.isInvalid() || decodeKey &gt; trackBuffer.lastEnqueuedDecodeKey) {
              trackBuffer.decodeQueue.insert(DecodeOrderSampleMap::MapType::value_type(decodeKey, &amp;sample));
  
              if (trackBuffer.minimumEnqueuedPresentationTime.isValid() &amp;&amp; sample.presentationTime() &lt; trackBuffer.minimumEnqueuedPresentationTime)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2039,32 ***</span>
          // FIXME(rdar://problem/20635969): Remove this re-entrancy protection when the aforementioned radar is resolved; protecting
          // against re-entrancy introduces a small inefficency when removing appended samples from the decode queue one at a time
          // rather than when all samples have been enqueued.
          auto sample = trackBuffer.decodeQueue.begin()-&gt;second;
  
<span class="line-modified">!         // Do not enqueue samples spanning a significant unbuffered gap.</span>
<span class="line-modified">!         // NOTE: one second is somewhat arbitrary. MediaSource::monitorSourceBuffers() is run</span>
<span class="line-removed">-         // on the playbackTimer, which is effectively every 350ms. Allowing &gt; 350ms gap between</span>
<span class="line-removed">-         // enqueued samples allows for situations where we overrun the end of a buffered range</span>
<span class="line-removed">-         // but don&#39;t notice for 350s of playback time, and the client can enqueue data for the</span>
<span class="line-removed">-         // new current time without triggering this early return.</span>
<span class="line-removed">-         // FIXME(135867): Make this gap detection logic less arbitrary.</span>
<span class="line-removed">-         MediaTime oneSecond(1, 1);</span>
<span class="line-removed">-         if (trackBuffer.lastEnqueuedDecodeKey.first.isValid()</span>
<span class="line-removed">-             &amp;&amp; trackBuffer.lastEnqueuedDecodeDuration.isValid()</span>
<span class="line-removed">-             &amp;&amp; sample-&gt;decodeTime() - trackBuffer.lastEnqueuedDecodeKey.first &gt; oneSecond + trackBuffer.lastEnqueuedDecodeDuration) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         DEBUG_LOG(LOGIDENTIFIER, &quot;bailing early because of unbuffered gap, new sample: &quot;, sample-&gt;decodeTime(), &quot;, last enqueued sample ends: &quot;, trackBuffer.lastEnqueuedDecodeKey.first + trackBuffer.lastEnqueuedDecodeDuration);</span>
              break;
          }
  
          // Remove the sample from the decode queue now.
          trackBuffer.decodeQueue.erase(trackBuffer.decodeQueue.begin());
  
<span class="line-modified">!         trackBuffer.lastEnqueuedPresentationTime = sample-&gt;presentationTime();</span>
          trackBuffer.lastEnqueuedDecodeKey = {sample-&gt;decodeTime(), sample-&gt;presentationTime()};
<span class="line-modified">!         trackBuffer.lastEnqueuedDecodeDuration = sample-&gt;duration();</span>
          m_private-&gt;enqueueSample(sample.releaseNonNull(), trackID);
  #if !RELEASE_LOG_DISABLED
          ++enqueuedSamples;
  #endif
      }
<span class="line-new-header">--- 2053,25 ---</span>
          // FIXME(rdar://problem/20635969): Remove this re-entrancy protection when the aforementioned radar is resolved; protecting
          // against re-entrancy introduces a small inefficency when removing appended samples from the decode queue one at a time
          // rather than when all samples have been enqueued.
          auto sample = trackBuffer.decodeQueue.begin()-&gt;second;
  
<span class="line-modified">!         if (sample-&gt;decodeTime() &gt; trackBuffer.enqueueDiscontinuityBoundary) {</span>
<span class="line-modified">!             DEBUG_LOG(LOGIDENTIFIER, &quot;bailing early because of unbuffered gap, new sample: &quot;, sample-&gt;decodeTime(), &quot; &gt;= the current discontinuity boundary: &quot;, trackBuffer.enqueueDiscontinuityBoundary);</span>
              break;
          }
  
          // Remove the sample from the decode queue now.
          trackBuffer.decodeQueue.erase(trackBuffer.decodeQueue.begin());
  
<span class="line-modified">!         MediaTime samplePresentationEnd = sample-&gt;presentationTime() + sample-&gt;duration();</span>
<span class="line-added">+         if (trackBuffer.highestEnqueuedPresentationTime.isInvalid() || samplePresentationEnd &gt; trackBuffer.highestEnqueuedPresentationTime)</span>
<span class="line-added">+             trackBuffer.highestEnqueuedPresentationTime = samplePresentationEnd;</span>
<span class="line-added">+ </span>
          trackBuffer.lastEnqueuedDecodeKey = {sample-&gt;decodeTime(), sample-&gt;presentationTime()};
<span class="line-modified">!         trackBuffer.enqueueDiscontinuityBoundary = sample-&gt;decodeTime() + sample-&gt;duration() + discontinuityTolerance;</span>
<span class="line-added">+ </span>
          m_private-&gt;enqueueSample(sample.releaseNonNull(), trackID);
  #if !RELEASE_LOG_DISABLED
          ++enqueuedSamples;
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2130,10 ***</span>
<span class="line-new-header">--- 2137,14 ---</span>
  void SourceBuffer::reenqueueMediaForTime(TrackBuffer&amp; trackBuffer, const AtomString&amp; trackID, const MediaTime&amp; time)
  {
      m_private-&gt;flush(trackID);
      trackBuffer.decodeQueue.clear();
  
<span class="line-added">+     trackBuffer.highestEnqueuedPresentationTime = MediaTime::invalidTime();</span>
<span class="line-added">+     trackBuffer.lastEnqueuedDecodeKey = {MediaTime::invalidTime(), MediaTime::invalidTime()};</span>
<span class="line-added">+     trackBuffer.enqueueDiscontinuityBoundary = time + discontinuityTolerance;</span>
<span class="line-added">+ </span>
      // Find the sample which contains the current presentation time.
      auto currentSamplePTSIterator = trackBuffer.samples.presentationOrder().findSampleContainingPresentationTime(time);
  
      if (currentSamplePTSIterator == trackBuffer.samples.presentationOrder().end())
          currentSamplePTSIterator = trackBuffer.samples.presentationOrder().findSampleStartingOnOrAfterPresentationTime(time);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2157,23 ***</span>
          auto copy = iter-&gt;second-&gt;createNonDisplayingCopy();
          DecodeOrderSampleMap::KeyType decodeKey(copy-&gt;decodeTime(), copy-&gt;presentationTime());
          trackBuffer.decodeQueue.insert(DecodeOrderSampleMap::MapType::value_type(decodeKey, WTFMove(copy)));
      }
  
<span class="line-removed">-     if (!trackBuffer.decodeQueue.empty()) {</span>
<span class="line-removed">-         auto lastSampleIter = trackBuffer.decodeQueue.rbegin();</span>
<span class="line-removed">-         auto lastSampleDecodeKey = lastSampleIter-&gt;first;</span>
<span class="line-removed">-         auto lastSampleDuration = lastSampleIter-&gt;second-&gt;duration();</span>
<span class="line-removed">-         trackBuffer.lastEnqueuedPresentationTime = lastSampleDecodeKey.second;</span>
<span class="line-removed">-         trackBuffer.lastEnqueuedDecodeKey = lastSampleDecodeKey;</span>
<span class="line-removed">-         trackBuffer.lastEnqueuedDecodeDuration = lastSampleDuration;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         trackBuffer.lastEnqueuedPresentationTime = MediaTime::invalidTime();</span>
<span class="line-removed">-         trackBuffer.lastEnqueuedDecodeKey = {MediaTime::invalidTime(), MediaTime::invalidTime()};</span>
<span class="line-removed">-         trackBuffer.lastEnqueuedDecodeDuration = MediaTime::invalidTime();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // Fill the decode queue with the remaining samples.
      for (auto iter = currentSampleDTSIterator; iter != trackBuffer.samples.decodeOrder().end(); ++iter)
          trackBuffer.decodeQueue.insert(*iter);
      provideMediaData(trackBuffer, trackID);
  
<span class="line-new-header">--- 2168,10 ---</span>
</pre>
<center><a href="SampleMap.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SourceBuffer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
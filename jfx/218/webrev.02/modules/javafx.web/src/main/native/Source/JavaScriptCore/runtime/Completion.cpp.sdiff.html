<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Completion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommonSlowPaths.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Completion.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Completion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;Completion.h&quot;
 25 
 26 #include &quot;BytecodeCacheError.h&quot;
 27 #include &quot;CallFrame.h&quot;
 28 #include &quot;CatchScope.h&quot;
 29 #include &quot;CodeCache.h&quot;
 30 #include &quot;CodeProfiling.h&quot;
 31 #include &quot;Exception.h&quot;
 32 #include &quot;IdentifierInlines.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;JSInternalPromise.h&quot;
<span class="line-removed"> 37 #include &quot;JSInternalPromiseDeferred.h&quot;</span>
 38 #include &quot;JSLock.h&quot;
 39 #include &quot;JSModuleLoader.h&quot;
 40 #include &quot;JSModuleRecord.h&quot;
 41 #include &quot;JSWithScope.h&quot;
 42 #include &quot;ModuleAnalyzer.h&quot;
 43 #include &quot;Parser.h&quot;
 44 #include &quot;ProgramExecutable.h&quot;
 45 #include &quot;ScriptProfilingScope.h&quot;
 46 
 47 namespace JSC {
 48 
 49 static inline bool checkSyntaxInternal(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error)
 50 {
 51     return !!parse&lt;ProgramNode&gt;(
 52         vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin,
 53         JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, error);
 54 }
 55 
<span class="line-modified"> 56 bool checkSyntax(ExecState* exec, const SourceCode&amp; source, JSValue* returnedException)</span>
 57 {
<span class="line-modified"> 58     VM&amp; vm = exec-&gt;vm();</span>
 59     JSLockHolder lock(vm);
 60     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 61 
 62     ParserError error;
 63     if (checkSyntaxInternal(vm, source, error))
 64         return true;
 65     ASSERT(error.isValid());
 66     if (returnedException)
<span class="line-modified"> 67         *returnedException = error.toErrorObject(exec-&gt;lexicalGlobalObject(), source);</span>
 68     return false;
 69 }
 70 
 71 bool checkSyntax(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error)
 72 {
 73     JSLockHolder lock(vm);
 74     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 75     return checkSyntaxInternal(vm, source, error);
 76 }
 77 
<span class="line-modified"> 78 bool checkModuleSyntax(ExecState* exec, const SourceCode&amp; source, ParserError&amp; error)</span>
 79 {
<span class="line-modified"> 80     VM&amp; vm = exec-&gt;vm();</span>
 81     JSLockHolder lock(vm);
 82     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 83     std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
 84         vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin,
 85         JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
 86     if (!moduleProgramNode)
 87         return false;
 88 
 89     PrivateName privateName(PrivateName::Description, &quot;EntryPointModule&quot;);
<span class="line-modified"> 90     ModuleAnalyzer moduleAnalyzer(exec, Identifier::fromUid(privateName), source, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());</span>
 91     moduleAnalyzer.analyze(*moduleProgramNode);
 92     return true;
 93 }
 94 
 95 RefPtr&lt;CachedBytecode&gt; generateProgramBytecode(VM&amp; vm, const SourceCode&amp; source, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)
 96 {
 97     JSLockHolder lock(vm);
 98     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 99 
100     VariableEnvironment variablesUnderTDZ;
101     JSParserStrictMode strictMode = JSParserStrictMode::NotStrict;
102     JSParserScriptMode scriptMode = JSParserScriptMode::Classic;
103     EvalContextType evalContextType = EvalContextType::None;
104 
105     ParserError parserError;
<span class="line-modified">106     UnlinkedCodeBlock* unlinkedCodeBlock = recursivelyGenerateUnlinkedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(vm, source, strictMode, scriptMode, { }, parserError, evalContextType, &amp;variablesUnderTDZ);</span>
107     if (parserError.isValid())
108         error = parserError;
109     if (!unlinkedCodeBlock)
110         return nullptr;
111 
112     return serializeBytecode(vm, unlinkedCodeBlock, source, SourceCodeType::ProgramType, strictMode, scriptMode, fd, error, { });
113 }
114 
115 RefPtr&lt;CachedBytecode&gt; generateModuleBytecode(VM&amp; vm, const SourceCode&amp; source, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)
116 {
117     JSLockHolder lock(vm);
118     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
119 
120     VariableEnvironment variablesUnderTDZ;
121     JSParserStrictMode strictMode = JSParserStrictMode::Strict;
122     JSParserScriptMode scriptMode = JSParserScriptMode::Module;
123     EvalContextType evalContextType = EvalContextType::None;
124 
125     ParserError parserError;
<span class="line-modified">126     UnlinkedCodeBlock* unlinkedCodeBlock = recursivelyGenerateUnlinkedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(vm, source, strictMode, scriptMode, { }, parserError, evalContextType, &amp;variablesUnderTDZ);</span>
127     if (parserError.isValid())
128         error = parserError;
129     if (!unlinkedCodeBlock)
130         return nullptr;
131     return serializeBytecode(vm, unlinkedCodeBlock, source, SourceCodeType::ModuleType, strictMode, scriptMode, fd, error, { });
132 }
133 
<span class="line-modified">134 JSValue evaluate(ExecState* exec, const SourceCode&amp; source, JSValue thisValue, NakedPtr&lt;Exception&gt;&amp; returnedException)</span>
135 {
<span class="line-modified">136     VM&amp; vm = exec-&gt;vm();</span>
137     JSLockHolder lock(vm);
138     auto scope = DECLARE_CATCH_SCOPE(vm);
139     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
140     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
141 
142     CodeProfiling profile(source);
143 
144     if (!thisValue || thisValue.isUndefinedOrNull())
<span class="line-modified">145         thisValue = vm.vmEntryGlobalObject(exec);</span>
<span class="line-modified">146     JSObject* thisObj = jsCast&lt;JSObject*&gt;(thisValue.toThis(exec, NotStrictMode));</span>
<span class="line-modified">147     JSValue result = vm.interpreter-&gt;executeProgram(source, exec, thisObj);</span>
148 
149     if (scope.exception()) {
150         returnedException = scope.exception();
151         scope.clearException();
152         return jsUndefined();
153     }
154 
155     RELEASE_ASSERT(result);
156     return result;
157 }
158 
<span class="line-modified">159 JSValue profiledEvaluate(ExecState* exec, ProfilingReason reason, const SourceCode&amp; source, JSValue thisValue, NakedPtr&lt;Exception&gt;&amp; returnedException)</span>
160 {
<span class="line-modified">161     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">162     ScriptProfilingScope profilingScope(vm.vmEntryGlobalObject(exec), reason);</span>
<span class="line-removed">163     return evaluate(exec, source, thisValue, returnedException);</span>
164 }
165 
<span class="line-modified">166 JSValue evaluateWithScopeExtension(ExecState* exec, const SourceCode&amp; source, JSObject* scopeExtensionObject, NakedPtr&lt;Exception&gt;&amp; returnedException)</span>
167 {
<span class="line-modified">168     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">169     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
170 
171     if (scopeExtensionObject) {
172         JSScope* ignoredPreviousScope = globalObject-&gt;globalScope();
173         globalObject-&gt;setGlobalScopeExtension(JSWithScope::create(vm, globalObject, ignoredPreviousScope, scopeExtensionObject));
174     }
175 
<span class="line-modified">176     JSValue returnValue = JSC::evaluate(globalObject-&gt;globalExec(), source, globalObject, returnedException);</span>
177 
178     if (scopeExtensionObject)
179         globalObject-&gt;clearGlobalScopeExtension();
180 
181     return returnValue;
182 }
183 
184 static Symbol* createSymbolForEntryPointModule(VM&amp; vm)
185 {
186     // Generate the unique key for the source-provided module.
187     PrivateName privateName(PrivateName::Description, &quot;EntryPointModule&quot;);
188     return Symbol::create(vm, privateName.uid());
189 }
190 
<span class="line-modified">191 static JSInternalPromise* rejectPromise(ExecState* exec, JSGlobalObject* globalObject)</span>
192 {
<span class="line-modified">193     VM&amp; vm = exec-&gt;vm();</span>
194     auto scope = DECLARE_CATCH_SCOPE(vm);
195     scope.assertNoException();
196     JSValue exception = scope.exception()-&gt;value();
197     scope.clearException();
<span class="line-modified">198     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-modified">199     scope.releaseAssertNoException();</span>
<span class="line-modified">200     deferred-&gt;reject(exec, exception);</span>
<span class="line-removed">201     scope.releaseAssertNoException();</span>
<span class="line-removed">202     return deferred-&gt;promise();</span>
203 }
204 
<span class="line-modified">205 JSInternalPromise* loadAndEvaluateModule(ExecState* exec, Symbol* moduleId, JSValue parameters, JSValue scriptFetcher)</span>
206 {
<span class="line-modified">207     VM&amp; vm = exec-&gt;vm();</span>
208     JSLockHolder lock(vm);
209     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
210     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
211 
<span class="line-modified">212     return vm.vmEntryGlobalObject(exec)-&gt;moduleLoader()-&gt;loadAndEvaluateModule(exec, moduleId, parameters, scriptFetcher);</span>
213 }
214 
<span class="line-modified">215 JSInternalPromise* loadAndEvaluateModule(ExecState* exec, const String&amp; moduleName, JSValue parameters, JSValue scriptFetcher)</span>
216 {
<span class="line-modified">217     VM&amp; vm = exec-&gt;vm();</span>
218     JSLockHolder lock(vm);
219     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
220     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
221 
<span class="line-modified">222     return vm.vmEntryGlobalObject(exec)-&gt;moduleLoader()-&gt;loadAndEvaluateModule(exec, identifierToJSValue(vm, Identifier::fromString(vm, moduleName)), parameters, scriptFetcher);</span>
223 }
224 
<span class="line-modified">225 JSInternalPromise* loadAndEvaluateModule(ExecState* exec, const SourceCode&amp; source, JSValue scriptFetcher)</span>
226 {
<span class="line-modified">227     VM&amp; vm = exec-&gt;vm();</span>
228     JSLockHolder lock(vm);
229     auto scope = DECLARE_THROW_SCOPE(vm);
230     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
231     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
232 
233     Symbol* key = createSymbolForEntryPointModule(vm);
234 
<span class="line-removed">235     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
<span class="line-removed">236 </span>
237     // Insert the given source code to the ModuleLoader registry as the fetched registry entry.
<span class="line-modified">238     globalObject-&gt;moduleLoader()-&gt;provideFetch(exec, key, source);</span>
<span class="line-modified">239     RETURN_IF_EXCEPTION(scope, rejectPromise(exec, globalObject));</span>
240 
<span class="line-modified">241     return globalObject-&gt;moduleLoader()-&gt;loadAndEvaluateModule(exec, key, jsUndefined(), scriptFetcher);</span>
242 }
243 
<span class="line-modified">244 JSInternalPromise* loadModule(ExecState* exec, const String&amp; moduleName, JSValue parameters, JSValue scriptFetcher)</span>
245 {
<span class="line-modified">246     VM&amp; vm = exec-&gt;vm();</span>
247     JSLockHolder lock(vm);
248     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
249     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
250 
<span class="line-modified">251     return vm.vmEntryGlobalObject(exec)-&gt;moduleLoader()-&gt;loadModule(exec, identifierToJSValue(vm, Identifier::fromString(vm, moduleName)), parameters, scriptFetcher);</span>
252 }
253 
<span class="line-modified">254 JSInternalPromise* loadModule(ExecState* exec, const SourceCode&amp; source, JSValue scriptFetcher)</span>
255 {
<span class="line-modified">256     VM&amp; vm = exec-&gt;vm();</span>
257     JSLockHolder lock(vm);
258     auto scope = DECLARE_THROW_SCOPE(vm);
259     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
260     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
261 
262     Symbol* key = createSymbolForEntryPointModule(vm);
263 
<span class="line-removed">264     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
<span class="line-removed">265 </span>
266     // Insert the given source code to the ModuleLoader registry as the fetched registry entry.
267     // FIXME: Introduce JSSourceCode object to wrap around this source.
<span class="line-modified">268     globalObject-&gt;moduleLoader()-&gt;provideFetch(exec, key, source);</span>
<span class="line-modified">269     RETURN_IF_EXCEPTION(scope, rejectPromise(exec, globalObject));</span>
270 
<span class="line-modified">271     return globalObject-&gt;moduleLoader()-&gt;loadModule(exec, key, jsUndefined(), scriptFetcher);</span>
272 }
273 
<span class="line-modified">274 JSValue linkAndEvaluateModule(ExecState* exec, const Identifier&amp; moduleKey, JSValue scriptFetcher)</span>
275 {
<span class="line-modified">276     VM&amp; vm = exec-&gt;vm();</span>
277     JSLockHolder lock(vm);
278     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
279     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
280 
<span class="line-modified">281     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
<span class="line-removed">282     return globalObject-&gt;moduleLoader()-&gt;linkAndEvaluateModule(exec, identifierToJSValue(vm, moduleKey), scriptFetcher);</span>
283 }
284 
<span class="line-modified">285 JSInternalPromise* importModule(ExecState* exec, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)</span>
286 {
<span class="line-modified">287     VM&amp; vm = exec-&gt;vm();</span>
288     JSLockHolder lock(vm);
289     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
290     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
291 
<span class="line-modified">292     return vm.vmEntryGlobalObject(exec)-&gt;moduleLoader()-&gt;requestImportModule(exec, moduleKey, parameters, scriptFetcher);</span>
293 }
294 
295 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;Completion.h&quot;
 25 
 26 #include &quot;BytecodeCacheError.h&quot;
 27 #include &quot;CallFrame.h&quot;
 28 #include &quot;CatchScope.h&quot;
 29 #include &quot;CodeCache.h&quot;
 30 #include &quot;CodeProfiling.h&quot;
 31 #include &quot;Exception.h&quot;
 32 #include &quot;IdentifierInlines.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;JSInternalPromise.h&quot;

 37 #include &quot;JSLock.h&quot;
 38 #include &quot;JSModuleLoader.h&quot;
 39 #include &quot;JSModuleRecord.h&quot;
 40 #include &quot;JSWithScope.h&quot;
 41 #include &quot;ModuleAnalyzer.h&quot;
 42 #include &quot;Parser.h&quot;
 43 #include &quot;ProgramExecutable.h&quot;
 44 #include &quot;ScriptProfilingScope.h&quot;
 45 
 46 namespace JSC {
 47 
 48 static inline bool checkSyntaxInternal(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error)
 49 {
 50     return !!parse&lt;ProgramNode&gt;(
 51         vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin,
 52         JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, error);
 53 }
 54 
<span class="line-modified"> 55 bool checkSyntax(JSGlobalObject* globalObject, const SourceCode&amp; source, JSValue* returnedException)</span>
 56 {
<span class="line-modified"> 57     VM&amp; vm = globalObject-&gt;vm();</span>
 58     JSLockHolder lock(vm);
 59     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 60 
 61     ParserError error;
 62     if (checkSyntaxInternal(vm, source, error))
 63         return true;
 64     ASSERT(error.isValid());
 65     if (returnedException)
<span class="line-modified"> 66         *returnedException = error.toErrorObject(globalObject, source);</span>
 67     return false;
 68 }
 69 
 70 bool checkSyntax(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error)
 71 {
 72     JSLockHolder lock(vm);
 73     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 74     return checkSyntaxInternal(vm, source, error);
 75 }
 76 
<span class="line-modified"> 77 bool checkModuleSyntax(JSGlobalObject* globalObject, const SourceCode&amp; source, ParserError&amp; error)</span>
 78 {
<span class="line-modified"> 79     VM&amp; vm = globalObject-&gt;vm();</span>
 80     JSLockHolder lock(vm);
 81     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 82     std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
 83         vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin,
 84         JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
 85     if (!moduleProgramNode)
 86         return false;
 87 
 88     PrivateName privateName(PrivateName::Description, &quot;EntryPointModule&quot;);
<span class="line-modified"> 89     ModuleAnalyzer moduleAnalyzer(globalObject, Identifier::fromUid(privateName), source, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());</span>
 90     moduleAnalyzer.analyze(*moduleProgramNode);
 91     return true;
 92 }
 93 
 94 RefPtr&lt;CachedBytecode&gt; generateProgramBytecode(VM&amp; vm, const SourceCode&amp; source, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)
 95 {
 96     JSLockHolder lock(vm);
 97     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
 98 
 99     VariableEnvironment variablesUnderTDZ;
100     JSParserStrictMode strictMode = JSParserStrictMode::NotStrict;
101     JSParserScriptMode scriptMode = JSParserScriptMode::Classic;
102     EvalContextType evalContextType = EvalContextType::None;
103 
104     ParserError parserError;
<span class="line-modified">105     UnlinkedCodeBlock* unlinkedCodeBlock = recursivelyGenerateUnlinkedCodeBlockForProgram(vm, source, strictMode, scriptMode, { }, parserError, evalContextType, &amp;variablesUnderTDZ);</span>
106     if (parserError.isValid())
107         error = parserError;
108     if (!unlinkedCodeBlock)
109         return nullptr;
110 
111     return serializeBytecode(vm, unlinkedCodeBlock, source, SourceCodeType::ProgramType, strictMode, scriptMode, fd, error, { });
112 }
113 
114 RefPtr&lt;CachedBytecode&gt; generateModuleBytecode(VM&amp; vm, const SourceCode&amp; source, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)
115 {
116     JSLockHolder lock(vm);
117     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
118 
119     VariableEnvironment variablesUnderTDZ;
120     JSParserStrictMode strictMode = JSParserStrictMode::Strict;
121     JSParserScriptMode scriptMode = JSParserScriptMode::Module;
122     EvalContextType evalContextType = EvalContextType::None;
123 
124     ParserError parserError;
<span class="line-modified">125     UnlinkedCodeBlock* unlinkedCodeBlock = recursivelyGenerateUnlinkedCodeBlockForModuleProgram(vm, source, strictMode, scriptMode, { }, parserError, evalContextType, &amp;variablesUnderTDZ);</span>
126     if (parserError.isValid())
127         error = parserError;
128     if (!unlinkedCodeBlock)
129         return nullptr;
130     return serializeBytecode(vm, unlinkedCodeBlock, source, SourceCodeType::ModuleType, strictMode, scriptMode, fd, error, { });
131 }
132 
<span class="line-modified">133 JSValue evaluate(JSGlobalObject* globalObject, const SourceCode&amp; source, JSValue thisValue, NakedPtr&lt;Exception&gt;&amp; returnedException)</span>
134 {
<span class="line-modified">135     VM&amp; vm = globalObject-&gt;vm();</span>
136     JSLockHolder lock(vm);
137     auto scope = DECLARE_CATCH_SCOPE(vm);
138     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
139     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
140 
141     CodeProfiling profile(source);
142 
143     if (!thisValue || thisValue.isUndefinedOrNull())
<span class="line-modified">144         thisValue = globalObject;</span>
<span class="line-modified">145     JSObject* thisObj = jsCast&lt;JSObject*&gt;(thisValue.toThis(globalObject, NotStrictMode));</span>
<span class="line-modified">146     JSValue result = vm.interpreter-&gt;executeProgram(source, globalObject, thisObj);</span>
147 
148     if (scope.exception()) {
149         returnedException = scope.exception();
150         scope.clearException();
151         return jsUndefined();
152     }
153 
154     RELEASE_ASSERT(result);
155     return result;
156 }
157 
<span class="line-modified">158 JSValue profiledEvaluate(JSGlobalObject* globalObject, ProfilingReason reason, const SourceCode&amp; source, JSValue thisValue, NakedPtr&lt;Exception&gt;&amp; returnedException)</span>
159 {
<span class="line-modified">160     ScriptProfilingScope profilingScope(globalObject, reason);</span>
<span class="line-modified">161     return evaluate(globalObject, source, thisValue, returnedException);</span>

162 }
163 
<span class="line-modified">164 JSValue evaluateWithScopeExtension(JSGlobalObject* globalObject, const SourceCode&amp; source, JSObject* scopeExtensionObject, NakedPtr&lt;Exception&gt;&amp; returnedException)</span>
165 {
<span class="line-modified">166     VM&amp; vm = globalObject-&gt;vm();</span>

167 
168     if (scopeExtensionObject) {
169         JSScope* ignoredPreviousScope = globalObject-&gt;globalScope();
170         globalObject-&gt;setGlobalScopeExtension(JSWithScope::create(vm, globalObject, ignoredPreviousScope, scopeExtensionObject));
171     }
172 
<span class="line-modified">173     JSValue returnValue = JSC::evaluate(globalObject, source, globalObject, returnedException);</span>
174 
175     if (scopeExtensionObject)
176         globalObject-&gt;clearGlobalScopeExtension();
177 
178     return returnValue;
179 }
180 
181 static Symbol* createSymbolForEntryPointModule(VM&amp; vm)
182 {
183     // Generate the unique key for the source-provided module.
184     PrivateName privateName(PrivateName::Description, &quot;EntryPointModule&quot;);
185     return Symbol::create(vm, privateName.uid());
186 }
187 
<span class="line-modified">188 static JSInternalPromise* rejectPromise(JSGlobalObject* globalObject)</span>
189 {
<span class="line-modified">190     VM&amp; vm = globalObject-&gt;vm();</span>
191     auto scope = DECLARE_CATCH_SCOPE(vm);
192     scope.assertNoException();
193     JSValue exception = scope.exception()-&gt;value();
194     scope.clearException();
<span class="line-modified">195     JSInternalPromise* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-modified">196     promise-&gt;reject(globalObject, exception);</span>
<span class="line-modified">197     return promise;</span>


198 }
199 
<span class="line-modified">200 JSInternalPromise* loadAndEvaluateModule(JSGlobalObject* globalObject, Symbol* moduleId, JSValue parameters, JSValue scriptFetcher)</span>
201 {
<span class="line-modified">202     VM&amp; vm = globalObject-&gt;vm();</span>
203     JSLockHolder lock(vm);
204     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
205     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
206 
<span class="line-modified">207     return globalObject-&gt;moduleLoader()-&gt;loadAndEvaluateModule(globalObject, moduleId, parameters, scriptFetcher);</span>
208 }
209 
<span class="line-modified">210 JSInternalPromise* loadAndEvaluateModule(JSGlobalObject* globalObject, const String&amp; moduleName, JSValue parameters, JSValue scriptFetcher)</span>
211 {
<span class="line-modified">212     VM&amp; vm = globalObject-&gt;vm();</span>
213     JSLockHolder lock(vm);
214     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
215     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
216 
<span class="line-modified">217     return globalObject-&gt;moduleLoader()-&gt;loadAndEvaluateModule(globalObject, identifierToJSValue(vm, Identifier::fromString(vm, moduleName)), parameters, scriptFetcher);</span>
218 }
219 
<span class="line-modified">220 JSInternalPromise* loadAndEvaluateModule(JSGlobalObject* globalObject, const SourceCode&amp; source, JSValue scriptFetcher)</span>
221 {
<span class="line-modified">222     VM&amp; vm = globalObject-&gt;vm();</span>
223     JSLockHolder lock(vm);
224     auto scope = DECLARE_THROW_SCOPE(vm);
225     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
226     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
227 
228     Symbol* key = createSymbolForEntryPointModule(vm);
229 


230     // Insert the given source code to the ModuleLoader registry as the fetched registry entry.
<span class="line-modified">231     globalObject-&gt;moduleLoader()-&gt;provideFetch(globalObject, key, source);</span>
<span class="line-modified">232     RETURN_IF_EXCEPTION(scope, rejectPromise(globalObject));</span>
233 
<span class="line-modified">234     return globalObject-&gt;moduleLoader()-&gt;loadAndEvaluateModule(globalObject, key, jsUndefined(), scriptFetcher);</span>
235 }
236 
<span class="line-modified">237 JSInternalPromise* loadModule(JSGlobalObject* globalObject, const String&amp; moduleName, JSValue parameters, JSValue scriptFetcher)</span>
238 {
<span class="line-modified">239     VM&amp; vm = globalObject-&gt;vm();</span>
240     JSLockHolder lock(vm);
241     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
242     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
243 
<span class="line-modified">244     return globalObject-&gt;moduleLoader()-&gt;loadModule(globalObject, identifierToJSValue(vm, Identifier::fromString(vm, moduleName)), parameters, scriptFetcher);</span>
245 }
246 
<span class="line-modified">247 JSInternalPromise* loadModule(JSGlobalObject* globalObject, const SourceCode&amp; source, JSValue scriptFetcher)</span>
248 {
<span class="line-modified">249     VM&amp; vm = globalObject-&gt;vm();</span>
250     JSLockHolder lock(vm);
251     auto scope = DECLARE_THROW_SCOPE(vm);
252     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
253     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
254 
255     Symbol* key = createSymbolForEntryPointModule(vm);
256 


257     // Insert the given source code to the ModuleLoader registry as the fetched registry entry.
258     // FIXME: Introduce JSSourceCode object to wrap around this source.
<span class="line-modified">259     globalObject-&gt;moduleLoader()-&gt;provideFetch(globalObject, key, source);</span>
<span class="line-modified">260     RETURN_IF_EXCEPTION(scope, rejectPromise(globalObject));</span>
261 
<span class="line-modified">262     return globalObject-&gt;moduleLoader()-&gt;loadModule(globalObject, key, jsUndefined(), scriptFetcher);</span>
263 }
264 
<span class="line-modified">265 JSValue linkAndEvaluateModule(JSGlobalObject* globalObject, const Identifier&amp; moduleKey, JSValue scriptFetcher)</span>
266 {
<span class="line-modified">267     VM&amp; vm = globalObject-&gt;vm();</span>
268     JSLockHolder lock(vm);
269     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
270     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
271 
<span class="line-modified">272     return globalObject-&gt;moduleLoader()-&gt;linkAndEvaluateModule(globalObject, identifierToJSValue(vm, moduleKey), scriptFetcher);</span>

273 }
274 
<span class="line-modified">275 JSInternalPromise* importModule(JSGlobalObject* globalObject, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)</span>
276 {
<span class="line-modified">277     VM&amp; vm = globalObject-&gt;vm();</span>
278     JSLockHolder lock(vm);
279     RELEASE_ASSERT(vm.atomStringTable() == Thread::current().atomStringTable());
280     RELEASE_ASSERT(!vm.isCollectorBusyOnCurrentThread());
281 
<span class="line-modified">282     return globalObject-&gt;moduleLoader()-&gt;requestImportModule(globalObject, moduleKey, parameters, scriptFetcher);</span>
283 }
284 
285 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="CommonSlowPaths.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Completion.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
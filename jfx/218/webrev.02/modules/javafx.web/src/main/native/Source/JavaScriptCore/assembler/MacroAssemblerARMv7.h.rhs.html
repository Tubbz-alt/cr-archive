<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARMv7.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2010 University of Szeged
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #if ENABLE(ASSEMBLER)
  30 
  31 #include &quot;ARMv7Assembler.h&quot;
  32 #include &quot;AbstractMacroAssembler.h&quot;
  33 
  34 namespace JSC {
  35 
  36 using Assembler = TARGET_ASSEMBLER;
  37 
  38 class MacroAssemblerARMv7 : public AbstractMacroAssembler&lt;Assembler&gt; {
<a name="2" id="anc2"></a><span class="line-modified">  39     static constexpr RegisterID dataTempRegister = ARMRegisters::ip;</span>
<span class="line-modified">  40     static constexpr RegisterID addressTempRegister = ARMRegisters::r6;</span>
  41 
<a name="3" id="anc3"></a><span class="line-modified">  42     static constexpr ARMRegisters::FPDoubleRegisterID fpTempRegister = ARMRegisters::d7;</span>
  43     inline ARMRegisters::FPSingleRegisterID fpTempRegisterAsSingle() { return ARMRegisters::asSingle(fpTempRegister); }
  44 
  45 public:
<a name="4" id="anc4"></a><span class="line-modified">  46     static constexpr unsigned numGPRs = 16;</span>
<span class="line-modified">  47     static constexpr unsigned numFPRs = 16;</span>
  48 
  49     MacroAssemblerARMv7()
  50         : m_makeJumpPatchable(false)
  51     {
  52     }
  53 
  54     typedef ARMv7Assembler::LinkRecord LinkRecord;
  55     typedef ARMv7Assembler::JumpType JumpType;
  56     typedef ARMv7Assembler::JumpLinkType JumpLinkType;
  57     typedef ARMv7Assembler::Condition Condition;
  58 
<a name="5" id="anc5"></a><span class="line-modified">  59     static constexpr ARMv7Assembler::Condition DefaultCondition = ARMv7Assembler::ConditionInvalid;</span>
<span class="line-modified">  60     static constexpr ARMv7Assembler::JumpType DefaultJump = ARMv7Assembler::JumpNoConditionFixedSize;</span>
  61 
  62     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  63     {
  64         return value &gt;= -255 &amp;&amp; value &lt;= 255;
  65     }
  66 
  67     Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt;&amp; jumpsToLink() { return m_assembler.jumpsToLink(); }
  68     static bool canCompact(JumpType jumpType) { return ARMv7Assembler::canCompact(jumpType); }
  69     static JumpLinkType computeJumpType(JumpType jumpType, const uint8_t* from, const uint8_t* to) { return ARMv7Assembler::computeJumpType(jumpType, from, to); }
  70     static JumpLinkType computeJumpType(LinkRecord&amp; record, const uint8_t* from, const uint8_t* to) { return ARMv7Assembler::computeJumpType(record, from, to); }
  71     static int jumpSizeDelta(JumpType jumpType, JumpLinkType jumpLinkType) { return ARMv7Assembler::jumpSizeDelta(jumpType, jumpLinkType); }
<a name="6" id="anc6"></a><span class="line-modified">  72     template &lt;Assembler::CopyFunction copy&gt;</span>
<span class="line-modified">  73     static void link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction, uint8_t* to) { return ARMv7Assembler::link&lt;copy&gt;(record, from, fromInstruction, to); }</span>
  74 
  75     struct ArmAddress {
  76         enum AddressType {
  77             HasOffset,
  78             HasIndex,
  79         } type;
  80         RegisterID base;
  81         union {
  82             int32_t offset;
  83             struct {
  84                 RegisterID index;
  85                 Scale scale;
  86             };
  87         } u;
  88 
  89         explicit ArmAddress(RegisterID base, int32_t offset = 0)
  90             : type(HasOffset)
  91             , base(base)
  92         {
  93             u.offset = offset;
  94         }
  95 
  96         explicit ArmAddress(RegisterID base, RegisterID index, Scale scale = TimesOne)
  97             : type(HasIndex)
  98             , base(base)
  99         {
 100             u.index = index;
 101             u.scale = scale;
 102         }
 103     };
 104 
 105 public:
<a name="7" id="anc7"></a><span class="line-modified"> 106     static constexpr Scale ScalePtr = TimesFour;</span>
 107 
 108     enum RelationalCondition {
 109         Equal = ARMv7Assembler::ConditionEQ,
 110         NotEqual = ARMv7Assembler::ConditionNE,
 111         Above = ARMv7Assembler::ConditionHI,
 112         AboveOrEqual = ARMv7Assembler::ConditionHS,
 113         Below = ARMv7Assembler::ConditionLO,
 114         BelowOrEqual = ARMv7Assembler::ConditionLS,
 115         GreaterThan = ARMv7Assembler::ConditionGT,
 116         GreaterThanOrEqual = ARMv7Assembler::ConditionGE,
 117         LessThan = ARMv7Assembler::ConditionLT,
 118         LessThanOrEqual = ARMv7Assembler::ConditionLE
 119     };
 120 
 121     enum ResultCondition {
 122         Overflow = ARMv7Assembler::ConditionVS,
 123         Signed = ARMv7Assembler::ConditionMI,
 124         PositiveOrZero = ARMv7Assembler::ConditionPL,
 125         Zero = ARMv7Assembler::ConditionEQ,
 126         NonZero = ARMv7Assembler::ConditionNE
 127     };
 128 
 129     enum DoubleCondition {
 130         // These conditions will only evaluate to true if the comparison is ordered - i.e. neither operand is NaN.
 131         DoubleEqual = ARMv7Assembler::ConditionEQ,
 132         DoubleNotEqual = ARMv7Assembler::ConditionVC, // Not the right flag! check for this &amp; handle differently.
 133         DoubleGreaterThan = ARMv7Assembler::ConditionGT,
 134         DoubleGreaterThanOrEqual = ARMv7Assembler::ConditionGE,
 135         DoubleLessThan = ARMv7Assembler::ConditionLO,
 136         DoubleLessThanOrEqual = ARMv7Assembler::ConditionLS,
 137         // If either operand is NaN, these conditions always evaluate to true.
 138         DoubleEqualOrUnordered = ARMv7Assembler::ConditionVS, // Not the right flag! check for this &amp; handle differently.
 139         DoubleNotEqualOrUnordered = ARMv7Assembler::ConditionNE,
 140         DoubleGreaterThanOrUnordered = ARMv7Assembler::ConditionHI,
 141         DoubleGreaterThanOrEqualOrUnordered = ARMv7Assembler::ConditionHS,
 142         DoubleLessThanOrUnordered = ARMv7Assembler::ConditionLT,
 143         DoubleLessThanOrEqualOrUnordered = ARMv7Assembler::ConditionLE,
 144     };
 145 
<a name="8" id="anc8"></a><span class="line-modified"> 146     static constexpr RegisterID stackPointerRegister = ARMRegisters::sp;</span>
<span class="line-modified"> 147     static constexpr RegisterID framePointerRegister = ARMRegisters::fp;</span>
<span class="line-modified"> 148     static constexpr RegisterID linkRegister = ARMRegisters::lr;</span>
 149 
 150     // Integer arithmetic operations:
 151     //
 152     // Operations are typically two operand - operation(source, srcDst)
 153     // For many operations the source may be an TrustedImm32, the srcDst operand
 154     // may often be a memory location (explictly described using an Address
 155     // object).
 156 
 157     void add32(RegisterID src, RegisterID dest)
 158     {
 159         m_assembler.add(dest, dest, src);
 160     }
 161 
 162     void add32(RegisterID left, RegisterID right, RegisterID dest)
 163     {
 164         m_assembler.add(dest, left, right);
 165     }
 166 
 167     void add32(TrustedImm32 imm, RegisterID dest)
 168     {
 169         add32(imm, dest, dest);
 170     }
 171 
 172     void add32(AbsoluteAddress src, RegisterID dest)
 173     {
 174         load32(src.m_ptr, dataTempRegister);
 175         add32(dataTempRegister, dest);
 176     }
 177 
 178     void add32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 179     {
 180         // For adds with stack pointer destination avoid unpredictable instruction
 181         if (dest == ARMRegisters::sp &amp;&amp; src != dest) {
 182             add32(imm, src, dataTempRegister);
 183             move(dataTempRegister, dest);
 184             return;
 185         }
 186 
 187         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12OrEncodedImm(imm.m_value);
 188 
 189         if (armImm.isValid())
 190             m_assembler.add(dest, src, armImm);
 191         else {
 192             move(imm, dataTempRegister);
 193             m_assembler.add(dest, src, dataTempRegister);
 194         }
 195     }
 196 
 197     void add32(TrustedImm32 imm, Address address)
 198     {
 199         load32(address, dataTempRegister);
 200 
 201         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12OrEncodedImm(imm.m_value);
 202         if (armImm.isValid())
 203             m_assembler.add(dataTempRegister, dataTempRegister, armImm);
 204         else {
 205             // Hrrrm, since dataTempRegister holds the data loaded,
 206             // use addressTempRegister to hold the immediate.
 207             move(imm, addressTempRegister);
 208             m_assembler.add(dataTempRegister, dataTempRegister, addressTempRegister);
 209         }
 210 
 211         store32(dataTempRegister, address);
 212     }
 213 
 214     void add32(Address src, RegisterID dest)
 215     {
 216         load32(src, dataTempRegister);
 217         add32(dataTempRegister, dest);
 218     }
 219 
 220     void add32(TrustedImm32 imm, AbsoluteAddress address)
 221     {
 222         load32(address.m_ptr, dataTempRegister);
 223 
 224         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12OrEncodedImm(imm.m_value);
 225         if (armImm.isValid())
 226             m_assembler.add(dataTempRegister, dataTempRegister, armImm);
 227         else {
 228             // Hrrrm, since dataTempRegister holds the data loaded,
 229             // use addressTempRegister to hold the immediate.
 230             move(imm, addressTempRegister);
 231             m_assembler.add(dataTempRegister, dataTempRegister, addressTempRegister);
 232         }
 233 
 234         store32(dataTempRegister, address.m_ptr);
 235     }
 236 
 237     void getEffectiveAddress(BaseIndex address, RegisterID dest)
 238     {
 239         m_assembler.lsl(addressTempRegister, address.index, static_cast&lt;int&gt;(address.scale));
 240         m_assembler.add(dest, address.base, addressTempRegister);
 241         if (address.offset)
 242             add32(TrustedImm32(address.offset), dest);
 243     }
 244 
 245     void addPtrNoFlags(TrustedImm32 imm, RegisterID srcDest)
 246     {
 247         add32(imm, srcDest);
 248     }
 249 
 250     void add64(TrustedImm32 imm, AbsoluteAddress address)
 251     {
 252         move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 253 
 254         m_assembler.ldr(dataTempRegister, addressTempRegister, ARMThumbImmediate::makeUInt12(0));
 255         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
 256         if (armImm.isValid())
 257             m_assembler.add_S(dataTempRegister, dataTempRegister, armImm);
 258         else {
 259             move(imm, addressTempRegister);
 260             m_assembler.add_S(dataTempRegister, dataTempRegister, addressTempRegister);
 261             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 262         }
 263         m_assembler.str(dataTempRegister, addressTempRegister, ARMThumbImmediate::makeUInt12(0));
 264 
 265         m_assembler.ldr(dataTempRegister, addressTempRegister, ARMThumbImmediate::makeUInt12(4));
 266         m_assembler.adc(dataTempRegister, dataTempRegister, ARMThumbImmediate::makeEncodedImm(imm.m_value &gt;&gt; 31));
 267         m_assembler.str(dataTempRegister, addressTempRegister, ARMThumbImmediate::makeUInt12(4));
 268     }
 269 
 270     void and16(Address src, RegisterID dest)
 271     {
 272         load16(src, dataTempRegister);
 273         and32(dataTempRegister, dest);
 274     }
 275 
 276     void and32(RegisterID op1, RegisterID op2, RegisterID dest)
 277     {
 278         m_assembler.ARM_and(dest, op1, op2);
 279     }
 280 
 281     void and32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 282     {
 283         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
 284         if (armImm.isValid())
 285             m_assembler.ARM_and(dest, src, armImm);
 286         else {
 287             move(imm, dataTempRegister);
 288             m_assembler.ARM_and(dest, src, dataTempRegister);
 289         }
 290     }
 291 
 292     void and32(RegisterID src, RegisterID dest)
 293     {
 294         and32(dest, src, dest);
 295     }
 296 
 297     void and32(TrustedImm32 imm, RegisterID dest)
 298     {
 299         and32(imm, dest, dest);
 300     }
 301 
 302     void and32(Address src, RegisterID dest)
 303     {
 304         load32(src, dataTempRegister);
 305         and32(dataTempRegister, dest);
 306     }
 307 
 308     void countLeadingZeros32(RegisterID src, RegisterID dest)
 309     {
 310         m_assembler.clz(dest, src);
 311     }
 312 
 313     void lshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
 314     {
 315         // Clamp the shift to the range 0..31
 316         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(0x1f);
 317         ASSERT(armImm.isValid());
 318         m_assembler.ARM_and(dataTempRegister, shiftAmount, armImm);
 319 
 320         m_assembler.lsl(dest, src, dataTempRegister);
 321     }
 322 
 323     void lshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 324     {
 325         m_assembler.lsl(dest, src, imm.m_value &amp; 0x1f);
 326     }
 327 
 328     void lshift32(RegisterID shiftAmount, RegisterID dest)
 329     {
 330         lshift32(dest, shiftAmount, dest);
 331     }
 332 
 333     void lshift32(TrustedImm32 imm, RegisterID dest)
 334     {
 335         lshift32(dest, imm, dest);
 336     }
 337 
 338     void mul32(RegisterID src, RegisterID dest)
 339     {
 340         m_assembler.smull(dest, dataTempRegister, dest, src);
 341     }
 342 
 343     void mul32(RegisterID left, RegisterID right, RegisterID dest)
 344     {
 345         m_assembler.smull(dest, dataTempRegister, left, right);
 346     }
 347 
 348     void mul32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 349     {
 350         move(imm, dataTempRegister);
 351         m_assembler.smull(dest, dataTempRegister, src, dataTempRegister);
 352     }
 353 
 354     void neg32(RegisterID srcDest)
 355     {
 356         m_assembler.neg(srcDest, srcDest);
 357     }
 358 
 359     void neg32(RegisterID src, RegisterID dest)
 360     {
 361         m_assembler.neg(dest, src);
 362     }
 363 
 364     void or32(RegisterID src, RegisterID dest)
 365     {
 366         m_assembler.orr(dest, dest, src);
 367     }
 368 
<a name="9" id="anc9"></a><span class="line-added"> 369     void or16(TrustedImm32 imm, AbsoluteAddress dest)</span>
<span class="line-added"> 370     {</span>
<span class="line-added"> 371         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);</span>
<span class="line-added"> 372         if (armImm.isValid()) {</span>
<span class="line-added"> 373             move(TrustedImmPtr(dest.m_ptr), addressTempRegister);</span>
<span class="line-added"> 374             load16(addressTempRegister, dataTempRegister);</span>
<span class="line-added"> 375             m_assembler.orr(dataTempRegister, dataTempRegister, armImm);</span>
<span class="line-added"> 376             store16(dataTempRegister, addressTempRegister);</span>
<span class="line-added"> 377         } else {</span>
<span class="line-added"> 378             move(TrustedImmPtr(dest.m_ptr), addressTempRegister);</span>
<span class="line-added"> 379             load16(addressTempRegister, dataTempRegister);</span>
<span class="line-added"> 380             move(imm, addressTempRegister);</span>
<span class="line-added"> 381             m_assembler.orr(dataTempRegister, dataTempRegister, addressTempRegister);</span>
<span class="line-added"> 382             move(TrustedImmPtr(dest.m_ptr), addressTempRegister);</span>
<span class="line-added"> 383             store16(dataTempRegister, addressTempRegister);</span>
<span class="line-added"> 384         }</span>
<span class="line-added"> 385     }</span>
<span class="line-added"> 386 </span>
 387     void or32(RegisterID src, AbsoluteAddress dest)
 388     {
 389         move(TrustedImmPtr(dest.m_ptr), addressTempRegister);
 390         load32(addressTempRegister, dataTempRegister);
 391         or32(src, dataTempRegister);
 392         store32(dataTempRegister, addressTempRegister);
 393     }
 394 
 395     void or32(TrustedImm32 imm, AbsoluteAddress address)
 396     {
 397         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
 398         if (armImm.isValid()) {
 399             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 400             load32(addressTempRegister, dataTempRegister);
 401             m_assembler.orr(dataTempRegister, dataTempRegister, armImm);
 402             store32(dataTempRegister, addressTempRegister);
 403         } else {
 404             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 405             load32(addressTempRegister, dataTempRegister);
 406             move(imm, addressTempRegister);
 407             m_assembler.orr(dataTempRegister, dataTempRegister, addressTempRegister);
 408             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 409             store32(dataTempRegister, addressTempRegister);
 410         }
 411     }
 412 
 413     void or32(TrustedImm32 imm, Address address)
 414     {
 415         load32(address, dataTempRegister);
 416         or32(imm, dataTempRegister, dataTempRegister);
 417         store32(dataTempRegister, address);
 418     }
 419 
 420     void or32(TrustedImm32 imm, RegisterID dest)
 421     {
 422         or32(imm, dest, dest);
 423     }
 424 
 425     void or32(RegisterID op1, RegisterID op2, RegisterID dest)
 426     {
 427         m_assembler.orr(dest, op1, op2);
 428     }
 429 
 430     void or32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 431     {
 432         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
 433         if (armImm.isValid())
 434             m_assembler.orr(dest, src, armImm);
 435         else {
 436             ASSERT(src != dataTempRegister);
 437             move(imm, dataTempRegister);
 438             m_assembler.orr(dest, src, dataTempRegister);
 439         }
 440     }
 441 
 442     void rshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
 443     {
 444         // Clamp the shift to the range 0..31
 445         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(0x1f);
 446         ASSERT(armImm.isValid());
 447         m_assembler.ARM_and(dataTempRegister, shiftAmount, armImm);
 448 
 449         m_assembler.asr(dest, src, dataTempRegister);
 450     }
 451 
 452     void rshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 453     {
 454         if (!imm.m_value)
 455             move(src, dest);
 456         else
 457             m_assembler.asr(dest, src, imm.m_value &amp; 0x1f);
 458     }
 459 
 460     void rshift32(RegisterID shiftAmount, RegisterID dest)
 461     {
 462         rshift32(dest, shiftAmount, dest);
 463     }
 464 
 465     void rshift32(TrustedImm32 imm, RegisterID dest)
 466     {
 467         rshift32(dest, imm, dest);
 468     }
 469 
 470     void urshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
 471     {
 472         // Clamp the shift to the range 0..31
 473         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(0x1f);
 474         ASSERT(armImm.isValid());
 475         m_assembler.ARM_and(dataTempRegister, shiftAmount, armImm);
 476 
 477         m_assembler.lsr(dest, src, dataTempRegister);
 478     }
 479 
 480     void urshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 481     {
 482         if (!imm.m_value)
 483             move(src, dest);
 484         else
 485             m_assembler.lsr(dest, src, imm.m_value &amp; 0x1f);
 486     }
 487 
 488     void urshift32(RegisterID shiftAmount, RegisterID dest)
 489     {
 490         urshift32(dest, shiftAmount, dest);
 491     }
 492 
 493     void urshift32(TrustedImm32 imm, RegisterID dest)
 494     {
 495         urshift32(dest, imm, dest);
 496     }
 497 
 498     void sub32(RegisterID src, RegisterID dest)
 499     {
 500         m_assembler.sub(dest, dest, src);
 501     }
 502 
 503     void sub32(RegisterID left, RegisterID right, RegisterID dest)
 504     {
 505         m_assembler.sub(dest, left, right);
 506     }
 507 
 508     void sub32(TrustedImm32 imm, RegisterID dest)
 509     {
 510         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12OrEncodedImm(imm.m_value);
 511         if (armImm.isValid())
 512             m_assembler.sub(dest, dest, armImm);
 513         else {
 514             move(imm, dataTempRegister);
 515             m_assembler.sub(dest, dest, dataTempRegister);
 516         }
 517     }
 518 
 519     void sub32(TrustedImm32 imm, Address address)
 520     {
 521         load32(address, dataTempRegister);
 522 
 523         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12OrEncodedImm(imm.m_value);
 524         if (armImm.isValid())
 525             m_assembler.sub(dataTempRegister, dataTempRegister, armImm);
 526         else {
 527             // Hrrrm, since dataTempRegister holds the data loaded,
 528             // use addressTempRegister to hold the immediate.
 529             move(imm, addressTempRegister);
 530             m_assembler.sub(dataTempRegister, dataTempRegister, addressTempRegister);
 531         }
 532 
 533         store32(dataTempRegister, address);
 534     }
 535 
 536     void sub32(Address src, RegisterID dest)
 537     {
 538         load32(src, dataTempRegister);
 539         sub32(dataTempRegister, dest);
 540     }
 541 
 542     void sub32(TrustedImm32 imm, AbsoluteAddress address)
 543     {
 544         load32(address.m_ptr, dataTempRegister);
 545 
 546         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12OrEncodedImm(imm.m_value);
 547         if (armImm.isValid())
 548             m_assembler.sub(dataTempRegister, dataTempRegister, armImm);
 549         else {
 550             // Hrrrm, since dataTempRegister holds the data loaded,
 551             // use addressTempRegister to hold the immediate.
 552             move(imm, addressTempRegister);
 553             m_assembler.sub(dataTempRegister, dataTempRegister, addressTempRegister);
 554         }
 555 
 556         store32(dataTempRegister, address.m_ptr);
 557     }
 558 
 559     void xor32(RegisterID op1, RegisterID op2, RegisterID dest)
 560     {
 561         m_assembler.eor(dest, op1, op2);
 562     }
 563 
 564     void xor32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 565     {
 566         if (imm.m_value == -1) {
 567             m_assembler.mvn(dest, src);
 568             return;
 569         }
 570 
 571         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
 572         if (armImm.isValid())
 573             m_assembler.eor(dest, src, armImm);
 574         else {
 575             move(imm, dataTempRegister);
 576             m_assembler.eor(dest, src, dataTempRegister);
 577         }
 578     }
 579 
 580     void xor32(RegisterID src, RegisterID dest)
 581     {
 582         xor32(dest, src, dest);
 583     }
 584 
 585     void xor32(Address src, RegisterID dest)
 586     {
 587         load32(src, dataTempRegister);
 588         xor32(dataTempRegister, dest);
 589     }
 590 
 591     void xor32(TrustedImm32 imm, RegisterID dest)
 592     {
 593         if (imm.m_value == -1)
 594             m_assembler.mvn(dest, dest);
 595         else
 596             xor32(imm, dest, dest);
 597     }
 598 
 599     void not32(RegisterID srcDest)
 600     {
 601         m_assembler.mvn(srcDest, srcDest);
 602     }
 603 
 604     // Memory access operations:
 605     //
 606     // Loads are of the form load(address, destination) and stores of the form
 607     // store(source, address).  The source for a store may be an TrustedImm32.  Address
 608     // operand objects to loads and store will be implicitly constructed if a
 609     // register is passed.
 610 
 611 private:
 612     void load32(ArmAddress address, RegisterID dest)
 613     {
 614         if (address.type == ArmAddress::HasIndex)
 615             m_assembler.ldr(dest, address.base, address.u.index, address.u.scale);
 616         else if (address.u.offset &gt;= 0) {
 617             ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.u.offset);
 618             ASSERT(armImm.isValid());
 619             m_assembler.ldr(dest, address.base, armImm);
 620         } else {
 621             ASSERT(address.u.offset &gt;= -255);
 622             m_assembler.ldr(dest, address.base, address.u.offset, true, false);
 623         }
 624     }
 625 
 626     void load16(ArmAddress address, RegisterID dest)
 627     {
 628         if (address.type == ArmAddress::HasIndex)
 629             m_assembler.ldrh(dest, address.base, address.u.index, address.u.scale);
 630         else if (address.u.offset &gt;= 0) {
 631             ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.u.offset);
 632             ASSERT(armImm.isValid());
 633             m_assembler.ldrh(dest, address.base, armImm);
 634         } else {
 635             ASSERT(address.u.offset &gt;= -255);
 636             m_assembler.ldrh(dest, address.base, address.u.offset, true, false);
 637         }
 638     }
 639 
 640     void load16SignedExtendTo32(ArmAddress address, RegisterID dest)
 641     {
 642         ASSERT(address.type == ArmAddress::HasIndex);
 643         m_assembler.ldrsh(dest, address.base, address.u.index, address.u.scale);
 644     }
 645 
 646     void load8(ArmAddress address, RegisterID dest)
 647     {
 648         if (address.type == ArmAddress::HasIndex)
 649             m_assembler.ldrb(dest, address.base, address.u.index, address.u.scale);
 650         else if (address.u.offset &gt;= 0) {
 651             ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.u.offset);
 652             ASSERT(armImm.isValid());
 653             m_assembler.ldrb(dest, address.base, armImm);
 654         } else {
 655             ASSERT(address.u.offset &gt;= -255);
 656             m_assembler.ldrb(dest, address.base, address.u.offset, true, false);
 657         }
 658     }
 659 
 660     void load8SignedExtendTo32(ArmAddress address, RegisterID dest)
 661     {
 662         ASSERT(address.type == ArmAddress::HasIndex);
 663         m_assembler.ldrsb(dest, address.base, address.u.index, address.u.scale);
 664     }
 665 
 666 protected:
 667     void store32(RegisterID src, ArmAddress address)
 668     {
 669         if (address.type == ArmAddress::HasIndex)
 670             m_assembler.str(src, address.base, address.u.index, address.u.scale);
 671         else if (address.u.offset &gt;= 0) {
 672             ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.u.offset);
 673             ASSERT(armImm.isValid());
 674             m_assembler.str(src, address.base, armImm);
 675         } else {
 676             ASSERT(address.u.offset &gt;= -255);
 677             m_assembler.str(src, address.base, address.u.offset, true, false);
 678         }
 679     }
 680 
 681 private:
 682     void store8(RegisterID src, ArmAddress address)
 683     {
 684         if (address.type == ArmAddress::HasIndex)
 685             m_assembler.strb(src, address.base, address.u.index, address.u.scale);
 686         else if (address.u.offset &gt;= 0) {
 687             ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.u.offset);
 688             ASSERT(armImm.isValid());
 689             m_assembler.strb(src, address.base, armImm);
 690         } else {
 691             ASSERT(address.u.offset &gt;= -255);
 692             m_assembler.strb(src, address.base, address.u.offset, true, false);
 693         }
 694     }
 695 
 696     void store16(RegisterID src, ArmAddress address)
 697     {
 698         if (address.type == ArmAddress::HasIndex)
 699             m_assembler.strh(src, address.base, address.u.index, address.u.scale);
 700         else if (address.u.offset &gt;= 0) {
 701             ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.u.offset);
 702             ASSERT(armImm.isValid());
 703             m_assembler.strh(src, address.base, armImm);
 704         } else {
 705             ASSERT(address.u.offset &gt;= -255);
 706             m_assembler.strh(src, address.base, address.u.offset, true, false);
 707         }
 708     }
 709 
 710 public:
 711     void load32(ImplicitAddress address, RegisterID dest)
 712     {
 713         load32(setupArmAddress(address), dest);
 714     }
 715 
 716     void load32(BaseIndex address, RegisterID dest)
 717     {
 718         load32(setupArmAddress(address), dest);
 719     }
 720 
 721     void load32WithUnalignedHalfWords(BaseIndex address, RegisterID dest)
 722     {
 723         load32(setupArmAddress(address), dest);
 724     }
 725 
 726     void load16Unaligned(BaseIndex address, RegisterID dest)
 727     {
 728         load16(setupArmAddress(address), dest);
 729     }
 730 
 731     void load32(const void* address, RegisterID dest)
 732     {
 733         move(TrustedImmPtr(address), addressTempRegister);
 734         m_assembler.ldr(dest, addressTempRegister, ARMThumbImmediate::makeUInt16(0));
 735     }
 736 
 737     void abortWithReason(AbortReason reason)
 738     {
 739         move(TrustedImm32(reason), dataTempRegister);
 740         breakpoint();
 741     }
 742 
 743     void abortWithReason(AbortReason reason, intptr_t misc)
 744     {
 745         move(TrustedImm32(misc), addressTempRegister);
 746         abortWithReason(reason);
 747     }
 748 
 749     ConvertibleLoadLabel convertibleLoadPtr(Address address, RegisterID dest)
 750     {
 751         ConvertibleLoadLabel result(this);
 752         ASSERT(address.offset &gt;= 0 &amp;&amp; address.offset &lt;= 255);
 753         m_assembler.ldrWide8BitImmediate(dest, address.base, address.offset);
 754         return result;
 755     }
 756 
 757     void load8(ImplicitAddress address, RegisterID dest)
 758     {
 759         load8(setupArmAddress(address), dest);
 760     }
 761 
 762     void load8SignedExtendTo32(ImplicitAddress, RegisterID)
 763     {
 764         UNREACHABLE_FOR_PLATFORM();
 765     }
 766 
 767     void load8(BaseIndex address, RegisterID dest)
 768     {
 769         load8(setupArmAddress(address), dest);
 770     }
 771 
 772     void load8SignedExtendTo32(BaseIndex address, RegisterID dest)
 773     {
 774         load8SignedExtendTo32(setupArmAddress(address), dest);
 775     }
 776 
 777     void load8(const void* address, RegisterID dest)
 778     {
 779         move(TrustedImmPtr(address), dest);
 780         load8(dest, dest);
 781     }
 782 
 783     DataLabel32 load32WithAddressOffsetPatch(Address address, RegisterID dest)
 784     {
 785         DataLabel32 label = moveWithPatch(TrustedImm32(address.offset), dataTempRegister);
 786         load32(ArmAddress(address.base, dataTempRegister), dest);
 787         return label;
 788     }
 789 
 790     DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
 791     {
 792         padBeforePatch();
 793 
 794         RegisterID base = address.base;
 795 
 796         DataLabelCompact label(this);
 797         ASSERT(isCompactPtrAlignedAddressOffset(address.offset));
 798 
 799         m_assembler.ldr(dest, base, address.offset, true, false);
 800         return label;
 801     }
 802 
<a name="10" id="anc10"></a><span class="line-added"> 803     void load16(const void* address, RegisterID dest)</span>
<span class="line-added"> 804     {</span>
<span class="line-added"> 805         move(TrustedImmPtr(address), addressTempRegister);</span>
<span class="line-added"> 806         m_assembler.ldrh(dest, addressTempRegister, ARMThumbImmediate::makeUInt16(0));</span>
<span class="line-added"> 807     }</span>
<span class="line-added"> 808 </span>
 809     void load16(BaseIndex address, RegisterID dest)
 810     {
 811         m_assembler.ldrh(dest, makeBaseIndexBase(address), address.index, address.scale);
 812     }
 813 
 814     void load16SignedExtendTo32(BaseIndex address, RegisterID dest)
 815     {
 816         load16SignedExtendTo32(setupArmAddress(address), dest);
 817     }
 818 
 819     void load16(ImplicitAddress address, RegisterID dest)
 820     {
 821         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.offset);
 822         if (armImm.isValid())
 823             m_assembler.ldrh(dest, address.base, armImm);
 824         else {
 825             move(TrustedImm32(address.offset), dataTempRegister);
 826             m_assembler.ldrh(dest, address.base, dataTempRegister);
 827         }
 828     }
 829 
 830     void load16SignedExtendTo32(ImplicitAddress, RegisterID)
 831     {
 832         UNREACHABLE_FOR_PLATFORM();
 833     }
 834 
 835     DataLabel32 store32WithAddressOffsetPatch(RegisterID src, Address address)
 836     {
 837         DataLabel32 label = moveWithPatch(TrustedImm32(address.offset), dataTempRegister);
 838         store32(src, ArmAddress(address.base, dataTempRegister));
 839         return label;
 840     }
 841 
 842     void store32(RegisterID src, ImplicitAddress address)
 843     {
 844         store32(src, setupArmAddress(address));
 845     }
 846 
 847     void store32(RegisterID src, BaseIndex address)
 848     {
 849         store32(src, setupArmAddress(address));
 850     }
 851 
 852     void store32(TrustedImm32 imm, ImplicitAddress address)
 853     {
 854         move(imm, dataTempRegister);
 855         store32(dataTempRegister, setupArmAddress(address));
 856     }
 857 
 858     void store32(TrustedImm32 imm, BaseIndex address)
 859     {
 860         move(imm, dataTempRegister);
 861         store32(dataTempRegister, setupArmAddress(address));
 862     }
 863 
 864     void store32(RegisterID src, const void* address)
 865     {
 866         move(TrustedImmPtr(address), addressTempRegister);
 867         m_assembler.str(src, addressTempRegister, ARMThumbImmediate::makeUInt16(0));
 868     }
 869 
 870     void store32(TrustedImm32 imm, const void* address)
 871     {
 872         move(imm, dataTempRegister);
 873         store32(dataTempRegister, address);
 874     }
 875 
 876     void store8(RegisterID src, Address address)
 877     {
 878         store8(src, setupArmAddress(address));
 879     }
 880 
 881     void store8(RegisterID src, BaseIndex address)
 882     {
 883         store8(src, setupArmAddress(address));
 884     }
 885 
 886     void store8(RegisterID src, void* address)
 887     {
 888         move(TrustedImmPtr(address), addressTempRegister);
 889         store8(src, ArmAddress(addressTempRegister, 0));
 890     }
 891 
 892     void store8(TrustedImm32 imm, void* address)
 893     {
 894         TrustedImm32 imm8(static_cast&lt;int8_t&gt;(imm.m_value));
 895         move(imm8, dataTempRegister);
 896         store8(dataTempRegister, address);
 897     }
 898 
 899     void store8(TrustedImm32 imm, Address address)
 900     {
 901         TrustedImm32 imm8(static_cast&lt;int8_t&gt;(imm.m_value));
 902         move(imm8, dataTempRegister);
 903         store8(dataTempRegister, address);
 904     }
 905 
 906     void store16(RegisterID src, ImplicitAddress address)
 907     {
 908         store16(src, setupArmAddress(address));
 909     }
 910 
 911     void store16(RegisterID src, BaseIndex address)
 912     {
 913         store16(src, setupArmAddress(address));
 914     }
 915 
<a name="11" id="anc11"></a><span class="line-added"> 916     void store16(RegisterID src, const void* address)</span>
<span class="line-added"> 917     {</span>
<span class="line-added"> 918         move(TrustedImmPtr(address), addressTempRegister);</span>
<span class="line-added"> 919         m_assembler.strh(src, addressTempRegister, ARMThumbImmediate::makeUInt12(0));</span>
<span class="line-added"> 920     }</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922     void store16(TrustedImm32 imm, const void* address)</span>
<span class="line-added"> 923     {</span>
<span class="line-added"> 924         move(imm, dataTempRegister);</span>
<span class="line-added"> 925         store16(dataTempRegister, address);</span>
<span class="line-added"> 926     }</span>
<span class="line-added"> 927 </span>
 928     // Possibly clobbers src, but not on this architecture.
 929     void moveDoubleToInts(FPRegisterID src, RegisterID dest1, RegisterID dest2)
 930     {
 931         m_assembler.vmov(dest1, dest2, src);
 932     }
 933 
 934     void moveIntsToDouble(RegisterID src1, RegisterID src2, FPRegisterID dest, FPRegisterID scratch)
 935     {
 936         UNUSED_PARAM(scratch);
 937         m_assembler.vmov(dest, src1, src2);
 938     }
 939 
 940     static bool shouldBlindForSpecificArch(uint32_t value)
 941     {
 942         ARMThumbImmediate immediate = ARMThumbImmediate::makeEncodedImm(value);
 943 
 944         // Couldn&#39;t be encoded as an immediate, so assume it&#39;s untrusted.
 945         if (!immediate.isValid())
 946             return true;
 947 
 948         // If we can encode the immediate, we have less than 16 attacker
 949         // controlled bits.
 950         if (immediate.isEncodedImm())
 951             return false;
 952 
 953         // Don&#39;t let any more than 12 bits of an instruction word
 954         // be controlled by an attacker.
 955         return !immediate.isUInt12();
 956     }
 957 
 958     // Floating-point operations:
 959 
 960     static bool supportsFloatingPoint() { return true; }
 961     static bool supportsFloatingPointTruncate() { return true; }
 962     static bool supportsFloatingPointSqrt() { return true; }
 963     static bool supportsFloatingPointAbs() { return true; }
 964     static bool supportsFloatingPointRounding() { return false; }
 965 
 966     void loadDouble(ImplicitAddress address, FPRegisterID dest)
 967     {
 968         RegisterID base = address.base;
 969         int32_t offset = address.offset;
 970 
 971         // Arm vfp addresses can be offset by a 9-bit ones-comp immediate, left shifted by 2.
 972         if ((offset &amp; 3) || (offset &gt; (255 * 4)) || (offset &lt; -(255 * 4))) {
 973             add32(TrustedImm32(offset), base, addressTempRegister);
 974             base = addressTempRegister;
 975             offset = 0;
 976         }
 977 
 978         m_assembler.vldr(dest, base, offset);
 979     }
 980 
 981     void loadFloat(ImplicitAddress address, FPRegisterID dest)
 982     {
 983         RegisterID base = address.base;
 984         int32_t offset = address.offset;
 985 
 986         // Arm vfp addresses can be offset by a 9-bit ones-comp immediate, left shifted by 2.
 987         if ((offset &amp; 3) || (offset &gt; (255 * 4)) || (offset &lt; -(255 * 4))) {
 988             add32(TrustedImm32(offset), base, addressTempRegister);
 989             base = addressTempRegister;
 990             offset = 0;
 991         }
 992 
 993         m_assembler.flds(ARMRegisters::asSingle(dest), base, offset);
 994     }
 995 
 996     void loadDouble(BaseIndex address, FPRegisterID dest)
 997     {
 998         move(address.index, addressTempRegister);
 999         lshift32(TrustedImm32(address.scale), addressTempRegister);
1000         add32(address.base, addressTempRegister);
1001         loadDouble(Address(addressTempRegister, address.offset), dest);
1002     }
1003 
1004     void loadFloat(BaseIndex address, FPRegisterID dest)
1005     {
1006         move(address.index, addressTempRegister);
1007         lshift32(TrustedImm32(address.scale), addressTempRegister);
1008         add32(address.base, addressTempRegister);
1009         loadFloat(Address(addressTempRegister, address.offset), dest);
1010     }
1011 
1012     void moveDouble(FPRegisterID src, FPRegisterID dest)
1013     {
1014         if (src != dest)
1015             m_assembler.vmov(dest, src);
1016     }
1017 
1018     void moveDouble(FPRegisterID src, RegisterID dest)
1019     {
1020         m_assembler.vmov(dest, RegisterID(dest + 1), src);
1021     }
1022 
1023     void moveZeroToDouble(FPRegisterID reg)
1024     {
1025         static double zeroConstant = 0.;
1026         loadDouble(TrustedImmPtr(&amp;zeroConstant), reg);
1027     }
1028 
1029     void loadDouble(TrustedImmPtr address, FPRegisterID dest)
1030     {
1031         move(address, addressTempRegister);
1032         m_assembler.vldr(dest, addressTempRegister, 0);
1033     }
1034 
1035     void storeDouble(FPRegisterID src, ImplicitAddress address)
1036     {
1037         RegisterID base = address.base;
1038         int32_t offset = address.offset;
1039 
1040         // Arm vfp addresses can be offset by a 9-bit ones-comp immediate, left shifted by 2.
1041         if ((offset &amp; 3) || (offset &gt; (255 * 4)) || (offset &lt; -(255 * 4))) {
1042             add32(TrustedImm32(offset), base, addressTempRegister);
1043             base = addressTempRegister;
1044             offset = 0;
1045         }
1046 
1047         m_assembler.vstr(src, base, offset);
1048     }
1049 
1050     void storeFloat(FPRegisterID src, ImplicitAddress address)
1051     {
1052         RegisterID base = address.base;
1053         int32_t offset = address.offset;
1054 
1055         // Arm vfp addresses can be offset by a 9-bit ones-comp immediate, left shifted by 2.
1056         if ((offset &amp; 3) || (offset &gt; (255 * 4)) || (offset &lt; -(255 * 4))) {
1057             add32(TrustedImm32(offset), base, addressTempRegister);
1058             base = addressTempRegister;
1059             offset = 0;
1060         }
1061 
1062         m_assembler.fsts(ARMRegisters::asSingle(src), base, offset);
1063     }
1064 
1065     void storeDouble(FPRegisterID src, TrustedImmPtr address)
1066     {
1067         move(address, addressTempRegister);
1068         storeDouble(src, addressTempRegister);
1069     }
1070 
1071     void storeDouble(FPRegisterID src, BaseIndex address)
1072     {
1073         move(address.index, addressTempRegister);
1074         lshift32(TrustedImm32(address.scale), addressTempRegister);
1075         add32(address.base, addressTempRegister);
1076         storeDouble(src, Address(addressTempRegister, address.offset));
1077     }
1078 
1079     void storeFloat(FPRegisterID src, BaseIndex address)
1080     {
1081         move(address.index, addressTempRegister);
1082         lshift32(TrustedImm32(address.scale), addressTempRegister);
1083         add32(address.base, addressTempRegister);
1084         storeFloat(src, Address(addressTempRegister, address.offset));
1085     }
1086 
1087     void addDouble(FPRegisterID src, FPRegisterID dest)
1088     {
1089         m_assembler.vadd(dest, dest, src);
1090     }
1091 
1092     void addDouble(Address src, FPRegisterID dest)
1093     {
1094         loadDouble(src, fpTempRegister);
1095         addDouble(fpTempRegister, dest);
1096     }
1097 
1098     void addDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
1099     {
1100         m_assembler.vadd(dest, op1, op2);
1101     }
1102 
1103     void addDouble(AbsoluteAddress address, FPRegisterID dest)
1104     {
1105         loadDouble(TrustedImmPtr(address.m_ptr), fpTempRegister);
1106         m_assembler.vadd(dest, dest, fpTempRegister);
1107     }
1108 
1109     void divDouble(FPRegisterID src, FPRegisterID dest)
1110     {
1111         m_assembler.vdiv(dest, dest, src);
1112     }
1113 
1114     void divDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
1115     {
1116         m_assembler.vdiv(dest, op1, op2);
1117     }
1118 
1119     void subDouble(FPRegisterID src, FPRegisterID dest)
1120     {
1121         m_assembler.vsub(dest, dest, src);
1122     }
1123 
1124     void subDouble(Address src, FPRegisterID dest)
1125     {
1126         loadDouble(src, fpTempRegister);
1127         subDouble(fpTempRegister, dest);
1128     }
1129 
1130     void subDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
1131     {
1132         m_assembler.vsub(dest, op1, op2);
1133     }
1134 
1135     void mulDouble(FPRegisterID src, FPRegisterID dest)
1136     {
1137         m_assembler.vmul(dest, dest, src);
1138     }
1139 
1140     void mulDouble(Address src, FPRegisterID dest)
1141     {
1142         loadDouble(src, fpTempRegister);
1143         mulDouble(fpTempRegister, dest);
1144     }
1145 
1146     void mulDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
1147     {
1148         m_assembler.vmul(dest, op1, op2);
1149     }
1150 
1151     void sqrtDouble(FPRegisterID src, FPRegisterID dest)
1152     {
1153         m_assembler.vsqrt(dest, src);
1154     }
1155 
1156     void absDouble(FPRegisterID src, FPRegisterID dest)
1157     {
1158         m_assembler.vabs(dest, src);
1159     }
1160 
1161     void negateDouble(FPRegisterID src, FPRegisterID dest)
1162     {
1163         m_assembler.vneg(dest, src);
1164     }
1165 
1166     NO_RETURN_DUE_TO_CRASH void ceilDouble(FPRegisterID, FPRegisterID)
1167     {
1168         ASSERT(!supportsFloatingPointRounding());
1169         CRASH();
1170     }
1171 
1172     NO_RETURN_DUE_TO_CRASH void floorDouble(FPRegisterID, FPRegisterID)
1173     {
1174         ASSERT(!supportsFloatingPointRounding());
1175         CRASH();
1176     }
1177 
1178     NO_RETURN_DUE_TO_CRASH void roundTowardZeroDouble(FPRegisterID, FPRegisterID)
1179     {
1180         ASSERT(!supportsFloatingPointRounding());
1181         CRASH();
1182     }
1183 
1184     void convertInt32ToDouble(RegisterID src, FPRegisterID dest)
1185     {
1186         m_assembler.vmov(fpTempRegister, src, src);
1187         m_assembler.vcvt_signedToFloatingPoint(dest, fpTempRegisterAsSingle());
1188     }
1189 
1190     void convertInt32ToDouble(Address address, FPRegisterID dest)
1191     {
1192         // Fixme: load directly into the fpr!
1193         load32(address, dataTempRegister);
1194         m_assembler.vmov(fpTempRegister, dataTempRegister, dataTempRegister);
1195         m_assembler.vcvt_signedToFloatingPoint(dest, fpTempRegisterAsSingle());
1196     }
1197 
1198     void convertInt32ToDouble(AbsoluteAddress address, FPRegisterID dest)
1199     {
1200         // Fixme: load directly into the fpr!
1201         load32(address.m_ptr, dataTempRegister);
1202         m_assembler.vmov(fpTempRegister, dataTempRegister, dataTempRegister);
1203         m_assembler.vcvt_signedToFloatingPoint(dest, fpTempRegisterAsSingle());
1204     }
1205 
1206     void convertFloatToDouble(FPRegisterID src, FPRegisterID dst)
1207     {
1208         m_assembler.vcvtds(dst, ARMRegisters::asSingle(src));
1209     }
1210 
1211     void convertDoubleToFloat(FPRegisterID src, FPRegisterID dst)
1212     {
1213         m_assembler.vcvtsd(ARMRegisters::asSingle(dst), src);
1214     }
1215 
1216     Jump branchDouble(DoubleCondition cond, FPRegisterID left, FPRegisterID right)
1217     {
1218         m_assembler.vcmp(left, right);
1219         m_assembler.vmrs();
1220 
1221         if (cond == DoubleNotEqual) {
1222             // ConditionNE jumps if NotEqual *or* unordered - force the unordered cases not to jump.
1223             Jump unordered = makeBranch(ARMv7Assembler::ConditionVS);
1224             Jump result = makeBranch(ARMv7Assembler::ConditionNE);
1225             unordered.link(this);
1226             return result;
1227         }
1228         if (cond == DoubleEqualOrUnordered) {
1229             Jump unordered = makeBranch(ARMv7Assembler::ConditionVS);
1230             Jump notEqual = makeBranch(ARMv7Assembler::ConditionNE);
1231             unordered.link(this);
1232             // We get here if either unordered or equal.
1233             Jump result = jump();
1234             notEqual.link(this);
1235             return result;
1236         }
1237         return makeBranch(cond);
1238     }
1239 
1240     enum BranchTruncateType { BranchIfTruncateFailed, BranchIfTruncateSuccessful };
1241     Jump branchTruncateDoubleToInt32(FPRegisterID src, RegisterID dest, BranchTruncateType branchType = BranchIfTruncateFailed)
1242     {
1243         // Convert into dest.
1244         m_assembler.vcvt_floatingPointToSigned(fpTempRegisterAsSingle(), src);
1245         m_assembler.vmov(dest, fpTempRegisterAsSingle());
1246 
1247         // Calculate 2x dest.  If the value potentially underflowed, it will have
1248         // clamped to 0x80000000, so 2x dest is zero in this case. In the case of
1249         // overflow the result will be equal to -2.
1250         Jump underflow = branchAdd32(Zero, dest, dest, dataTempRegister);
1251         Jump noOverflow = branch32(NotEqual, dataTempRegister, TrustedImm32(-2));
1252 
1253         // For BranchIfTruncateSuccessful, we branch if &#39;noOverflow&#39; jumps.
1254         underflow.link(this);
1255         if (branchType == BranchIfTruncateSuccessful)
1256             return noOverflow;
1257 
1258         // We&#39;ll reach the current point in the code on failure, so plant a
1259         // jump here &amp; link the success case.
1260         Jump failure = jump();
1261         noOverflow.link(this);
1262         return failure;
1263     }
1264 
1265     // Result is undefined if the value is outside of the integer range.
1266     void truncateDoubleToInt32(FPRegisterID src, RegisterID dest)
1267     {
1268         m_assembler.vcvt_floatingPointToSigned(fpTempRegisterAsSingle(), src);
1269         m_assembler.vmov(dest, fpTempRegisterAsSingle());
1270     }
1271 
1272     void truncateDoubleToUint32(FPRegisterID src, RegisterID dest)
1273     {
1274         m_assembler.vcvt_floatingPointToUnsigned(fpTempRegisterAsSingle(), src);
1275         m_assembler.vmov(dest, fpTempRegisterAsSingle());
1276     }
1277 
1278     // Convert &#39;src&#39; to an integer, and places the resulting &#39;dest&#39;.
1279     // If the result is not representable as a 32 bit value, branch.
1280     // May also branch for some values that are representable in 32 bits
1281     // (specifically, in this case, 0).
1282     void branchConvertDoubleToInt32(FPRegisterID src, RegisterID dest, JumpList&amp; failureCases, FPRegisterID, bool negZeroCheck = true)
1283     {
1284         m_assembler.vcvt_floatingPointToSigned(fpTempRegisterAsSingle(), src);
1285         m_assembler.vmov(dest, fpTempRegisterAsSingle());
1286 
1287         // Convert the integer result back to float &amp; compare to the original value - if not equal or unordered (NaN) then jump.
1288         m_assembler.vcvt_signedToFloatingPoint(fpTempRegister, fpTempRegisterAsSingle());
1289         failureCases.append(branchDouble(DoubleNotEqualOrUnordered, src, fpTempRegister));
1290 
1291         // Test for negative zero.
1292         if (negZeroCheck) {
1293             Jump valueIsNonZero = branchTest32(NonZero, dest);
1294             m_assembler.vmov(dataTempRegister, ARMRegisters::asSingleUpper(src));
1295             failureCases.append(branch32(LessThan, dataTempRegister, TrustedImm32(0)));
1296             valueIsNonZero.link(this);
1297         }
1298     }
1299 
1300     Jump branchDoubleNonZero(FPRegisterID reg, FPRegisterID)
1301     {
1302         m_assembler.vcmpz(reg);
1303         m_assembler.vmrs();
1304         Jump unordered = makeBranch(ARMv7Assembler::ConditionVS);
1305         Jump result = makeBranch(ARMv7Assembler::ConditionNE);
1306         unordered.link(this);
1307         return result;
1308     }
1309 
1310     Jump branchDoubleZeroOrNaN(FPRegisterID reg, FPRegisterID)
1311     {
1312         m_assembler.vcmpz(reg);
1313         m_assembler.vmrs();
1314         Jump unordered = makeBranch(ARMv7Assembler::ConditionVS);
1315         Jump notEqual = makeBranch(ARMv7Assembler::ConditionNE);
1316         unordered.link(this);
1317         // We get here if either unordered or equal.
1318         Jump result = jump();
1319         notEqual.link(this);
1320         return result;
1321     }
1322 
1323     // Stack manipulation operations:
1324     //
1325     // The ABI is assumed to provide a stack abstraction to memory,
1326     // containing machine word sized units of data.  Push and pop
1327     // operations add and remove a single register sized unit of data
1328     // to or from the stack.  Peek and poke operations read or write
1329     // values on the stack, without moving the current stack position.
1330 
1331     void pop(RegisterID dest)
1332     {
1333         m_assembler.pop(dest);
1334     }
1335 
1336     void push(RegisterID src)
1337     {
1338         m_assembler.push(src);
1339     }
1340 
1341     void push(Address address)
1342     {
1343         load32(address, dataTempRegister);
1344         push(dataTempRegister);
1345     }
1346 
1347     void push(TrustedImm32 imm)
1348     {
1349         move(imm, dataTempRegister);
1350         push(dataTempRegister);
1351     }
1352 
1353     void popPair(RegisterID dest1, RegisterID dest2)
1354     {
1355         m_assembler.pop(1 &lt;&lt; dest1 | 1 &lt;&lt; dest2);
1356     }
1357 
1358     void pushPair(RegisterID src1, RegisterID src2)
1359     {
1360         m_assembler.push(1 &lt;&lt; src1 | 1 &lt;&lt; src2);
1361     }
1362 
1363     // Register move operations:
1364     //
1365     // Move values in registers.
1366 
1367     void move(TrustedImm32 imm, RegisterID dest)
1368     {
1369         uint32_t value = imm.m_value;
1370 
1371         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(value);
1372 
1373         if (armImm.isValid())
1374             m_assembler.mov(dest, armImm);
1375         else if ((armImm = ARMThumbImmediate::makeEncodedImm(~value)).isValid())
1376             m_assembler.mvn(dest, armImm);
1377         else {
1378             m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(value));
1379             if (value &amp; 0xffff0000)
1380                 m_assembler.movt(dest, ARMThumbImmediate::makeUInt16(value &gt;&gt; 16));
1381         }
1382     }
1383 
1384     void move(RegisterID src, RegisterID dest)
1385     {
1386         if (src != dest)
1387             m_assembler.mov(dest, src);
1388     }
1389 
1390     void move(TrustedImmPtr imm, RegisterID dest)
1391     {
1392         move(TrustedImm32(imm), dest);
1393     }
1394 
1395     void swap(RegisterID reg1, RegisterID reg2)
1396     {
1397         move(reg1, dataTempRegister);
1398         move(reg2, reg1);
1399         move(dataTempRegister, reg2);
1400     }
1401 
1402     void swap(FPRegisterID fr1, FPRegisterID fr2)
1403     {
1404         moveDouble(fr1, fpTempRegister);
1405         moveDouble(fr2, fr1);
1406         moveDouble(fpTempRegister, fr2);
1407     }
1408 
1409     void signExtend32ToPtr(RegisterID src, RegisterID dest)
1410     {
1411         move(src, dest);
1412     }
1413 
1414     void zeroExtend32ToPtr(RegisterID src, RegisterID dest)
1415     {
1416         move(src, dest);
1417     }
1418 
1419     // Invert a relational condition, e.g. == becomes !=, &lt; becomes &gt;=, etc.
1420     static RelationalCondition invert(RelationalCondition cond)
1421     {
1422         return static_cast&lt;RelationalCondition&gt;(cond ^ 1);
1423     }
1424 
1425     void nop()
1426     {
1427         m_assembler.nop();
1428     }
1429 
1430     void memoryFence()
1431     {
1432         m_assembler.dmbSY();
1433     }
1434 
1435     void storeFence()
1436     {
1437         m_assembler.dmbISHST();
1438     }
1439 
1440     template&lt;PtrTag startTag, PtrTag destTag&gt;
1441     static void replaceWithJump(CodeLocationLabel&lt;startTag&gt; instructionStart, CodeLocationLabel&lt;destTag&gt; destination)
1442     {
1443         ARMv7Assembler::replaceWithJump(instructionStart.dataLocation(), destination.dataLocation());
1444     }
1445 
1446     static ptrdiff_t maxJumpReplacementSize()
1447     {
1448         return ARMv7Assembler::maxJumpReplacementSize();
1449     }
1450 
1451     static ptrdiff_t patchableJumpSize()
1452     {
1453         return ARMv7Assembler::patchableJumpSize();
1454     }
1455 
1456     // Forwards / external control flow operations:
1457     //
1458     // This set of jump and conditional branch operations return a Jump
1459     // object which may linked at a later point, allow forwards jump,
1460     // or jumps that will require external linkage (after the code has been
1461     // relocated).
1462     //
1463     // For branches, signed &lt;, &gt;, &lt;= and &gt;= are denoted as l, g, le, and ge
1464     // respecitvely, for unsigned comparisons the names b, a, be, and ae are
1465     // used (representing the names &#39;below&#39; and &#39;above&#39;).
1466     //
1467     // Operands to the comparision are provided in the expected order, e.g.
1468     // jle32(reg1, TrustedImm32(5)) will branch if the value held in reg1, when
1469     // treated as a signed 32bit value, is less than or equal to 5.
1470     //
1471     // jz and jnz test whether the first operand is equal to zero, and take
1472     // an optional second operand of a mask under which to perform the test.
1473 private:
1474 
1475     // Should we be using TEQ for equal/not-equal?
1476     void compare32AndSetFlags(RegisterID left, TrustedImm32 right)
1477     {
1478         int32_t imm = right.m_value;
1479         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm);
1480         if (armImm.isValid())
1481             m_assembler.cmp(left, armImm);
1482         else if ((armImm = ARMThumbImmediate::makeEncodedImm(-imm)).isValid())
1483             m_assembler.cmn(left, armImm);
1484         else {
1485             move(TrustedImm32(imm), dataTempRegister);
1486             m_assembler.cmp(left, dataTempRegister);
1487         }
1488     }
1489 
1490 public:
1491     void test32(RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
1492     {
1493         int32_t imm = mask.m_value;
1494 
1495         if (imm == -1)
1496             m_assembler.tst(reg, reg);
1497         else {
1498             ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm);
1499             if (armImm.isValid()) {
1500                 if (reg == ARMRegisters::sp) {
1501                     move(reg, addressTempRegister);
1502                     m_assembler.tst(addressTempRegister, armImm);
1503                 } else
1504                     m_assembler.tst(reg, armImm);
1505             } else {
1506                 move(mask, dataTempRegister);
1507                 if (reg == ARMRegisters::sp) {
1508                     move(reg, addressTempRegister);
1509                     m_assembler.tst(addressTempRegister, dataTempRegister);
1510                 } else
1511                     m_assembler.tst(reg, dataTempRegister);
1512             }
1513         }
1514     }
1515 
1516     Jump branch(ResultCondition cond)
1517     {
1518         return Jump(makeBranch(cond));
1519     }
1520 
1521     Jump branch32(RelationalCondition cond, RegisterID left, RegisterID right)
1522     {
1523         m_assembler.cmp(left, right);
1524         return Jump(makeBranch(cond));
1525     }
1526 
1527     Jump branch32(RelationalCondition cond, RegisterID left, TrustedImm32 right)
1528     {
1529         compare32AndSetFlags(left, right);
1530         return Jump(makeBranch(cond));
1531     }
1532 
1533     Jump branch32(RelationalCondition cond, RegisterID left, Address right)
1534     {
1535         load32(right, dataTempRegister);
1536         return branch32(cond, left, dataTempRegister);
1537     }
1538 
1539     Jump branch32(RelationalCondition cond, Address left, RegisterID right)
1540     {
1541         load32(left, dataTempRegister);
1542         return branch32(cond, dataTempRegister, right);
1543     }
1544 
1545     Jump branch32(RelationalCondition cond, Address left, TrustedImm32 right)
1546     {
1547         // use addressTempRegister incase the branch32 we call uses dataTempRegister. :-/
1548         load32(left, addressTempRegister);
1549         return branch32(cond, addressTempRegister, right);
1550     }
1551 
1552     Jump branch32(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
1553     {
1554         // use addressTempRegister incase the branch32 we call uses dataTempRegister. :-/
1555         load32(left, addressTempRegister);
1556         return branch32(cond, addressTempRegister, right);
1557     }
1558 
1559     Jump branch32WithUnalignedHalfWords(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
1560     {
1561         // use addressTempRegister incase the branch32 we call uses dataTempRegister. :-/
1562         load32WithUnalignedHalfWords(left, addressTempRegister);
1563         return branch32(cond, addressTempRegister, right);
1564     }
1565 
1566     Jump branch32(RelationalCondition cond, AbsoluteAddress left, RegisterID right)
1567     {
1568         load32(left.m_ptr, dataTempRegister);
1569         return branch32(cond, dataTempRegister, right);
1570     }
1571 
1572     Jump branch32(RelationalCondition cond, AbsoluteAddress left, TrustedImm32 right)
1573     {
1574         // use addressTempRegister incase the branch32 we call uses dataTempRegister. :-/
1575         load32(left.m_ptr, addressTempRegister);
1576         return branch32(cond, addressTempRegister, right);
1577     }
1578 
1579     Jump branchPtr(RelationalCondition cond, BaseIndex left, RegisterID right)
1580     {
1581         load32(left, dataTempRegister);
1582         return branch32(cond, dataTempRegister, right);
1583     }
1584 
1585     Jump branch8(RelationalCondition cond, RegisterID left, TrustedImm32 right)
1586     {
1587         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1588         compare32AndSetFlags(left, right8);
1589         return Jump(makeBranch(cond));
1590     }
1591 
1592     Jump branch8(RelationalCondition cond, Address left, TrustedImm32 right)
1593     {
1594         // use addressTempRegister incase the branch8 we call uses dataTempRegister. :-/
1595         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1596         MacroAssemblerHelpers::load8OnCondition(*this, cond, left, addressTempRegister);
1597         return branch8(cond, addressTempRegister, right8);
1598     }
1599 
1600     Jump branch8(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
1601     {
1602         // use addressTempRegister incase the branch32 we call uses dataTempRegister. :-/
1603         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1604         MacroAssemblerHelpers::load8OnCondition(*this, cond, left, addressTempRegister);
1605         return branch32(cond, addressTempRegister, right8);
1606     }
1607 
1608     Jump branch8(RelationalCondition cond, AbsoluteAddress address, TrustedImm32 right)
1609     {
1610         // Use addressTempRegister instead of dataTempRegister, since branch32 uses dataTempRegister.
1611         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1612         move(TrustedImmPtr(address.m_ptr), addressTempRegister);
1613         MacroAssemblerHelpers::load8OnCondition(*this, cond, Address(addressTempRegister), addressTempRegister);
1614         return branch32(cond, addressTempRegister, right8);
1615     }
1616 
1617     Jump branchTest32(ResultCondition cond, RegisterID reg, RegisterID mask)
1618     {
1619         ASSERT(cond == Zero || cond == NonZero || cond == Signed || cond == PositiveOrZero);
1620         m_assembler.tst(reg, mask);
1621         return Jump(makeBranch(cond));
1622     }
1623 
1624     Jump branchTest32(ResultCondition cond, RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
1625     {
1626         ASSERT(cond == Zero || cond == NonZero || cond == Signed || cond == PositiveOrZero);
1627         test32(reg, mask);
1628         return Jump(makeBranch(cond));
1629     }
1630 
1631     Jump branchTest32(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
1632     {
1633         // use addressTempRegister incase the branchTest32 we call uses dataTempRegister. :-/
1634         load32(address, addressTempRegister);
1635         return branchTest32(cond, addressTempRegister, mask);
1636     }
1637 
1638     Jump branchTest32(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
1639     {
1640         // use addressTempRegister incase the branchTest32 we call uses dataTempRegister. :-/
1641         load32(address, addressTempRegister);
1642         return branchTest32(cond, addressTempRegister, mask);
1643     }
1644 
1645     Jump branchTest8(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
1646     {
1647         // use addressTempRegister incase the branchTest8 we call uses dataTempRegister. :-/
1648         TrustedImm32 mask8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, mask);
1649         MacroAssemblerHelpers::load8OnCondition(*this, cond, address, addressTempRegister);
1650         return branchTest32(cond, addressTempRegister, mask8);
1651     }
1652 
1653     Jump branchTest8(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
1654     {
1655         // use addressTempRegister incase the branchTest8 we call uses dataTempRegister. :-/
1656         TrustedImm32 mask8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, mask);
1657         MacroAssemblerHelpers::load8OnCondition(*this, cond, address, addressTempRegister);
1658         return branchTest32(cond, addressTempRegister, mask8);
1659     }
1660 
1661     Jump branchTest8(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask = TrustedImm32(-1))
1662     {
1663         // use addressTempRegister incase the branchTest8 we call uses dataTempRegister. :-/
1664         TrustedImm32 mask8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, mask);
1665         move(TrustedImmPtr(address.m_ptr), addressTempRegister);
1666         MacroAssemblerHelpers::load8OnCondition(*this, cond, Address(addressTempRegister), addressTempRegister);
1667         return branchTest32(cond, addressTempRegister, mask8);
1668     }
1669 
1670     void farJump(RegisterID target, PtrTag)
1671     {
1672         m_assembler.bx(target);
1673     }
1674 
1675     // Address is a memory location containing the address to jump to
1676     void farJump(Address address, PtrTag)
1677     {
1678         load32(address, dataTempRegister);
1679         m_assembler.bx(dataTempRegister);
1680     }
1681 
1682     void farJump(AbsoluteAddress address, PtrTag)
1683     {
1684         move(TrustedImmPtr(address.m_ptr), dataTempRegister);
1685         load32(Address(dataTempRegister), dataTempRegister);
1686         m_assembler.bx(dataTempRegister);
1687     }
1688 
1689     ALWAYS_INLINE void farJump(RegisterID target, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(target, NoPtrTag); }
1690     ALWAYS_INLINE void farJump(Address address, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(address, NoPtrTag); }
1691     ALWAYS_INLINE void farJump(AbsoluteAddress address, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(address, NoPtrTag); }
1692 
1693     // Arithmetic control flow operations:
1694     //
1695     // This set of conditional branch operations branch based
1696     // on the result of an arithmetic operation.  The operation
1697     // is performed as normal, storing the result.
1698     //
1699     // * jz operations branch if the result is zero.
1700     // * jo operations branch if the (signed) arithmetic
1701     //   operation caused an overflow to occur.
1702 
1703     Jump branchAdd32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest)
1704     {
1705         m_assembler.add_S(dest, op1, op2);
1706         return Jump(makeBranch(cond));
1707     }
1708 
1709     Jump branchAdd32(ResultCondition cond, RegisterID op1, TrustedImm32 imm, RegisterID dest)
1710     {
1711         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
1712         if (armImm.isValid())
1713             m_assembler.add_S(dest, op1, armImm);
1714         else {
1715             move(imm, dataTempRegister);
1716             m_assembler.add_S(dest, op1, dataTempRegister);
1717         }
1718         return Jump(makeBranch(cond));
1719     }
1720 
1721     Jump branchAdd32(ResultCondition cond, RegisterID src, RegisterID dest)
1722     {
1723         return branchAdd32(cond, dest, src, dest);
1724     }
1725 
1726     Jump branchAdd32(ResultCondition cond, Address src, RegisterID dest)
1727     {
1728         load32(src, dataTempRegister);
1729         return branchAdd32(cond, dest, dataTempRegister, dest);
1730     }
1731 
1732     Jump branchAdd32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
1733     {
1734         return branchAdd32(cond, dest, imm, dest);
1735     }
1736 
1737     Jump branchAdd32(ResultCondition cond, TrustedImm32 imm, AbsoluteAddress dest)
1738     {
1739         // Move the high bits of the address into addressTempRegister,
1740         // and load the value into dataTempRegister.
1741         move(TrustedImmPtr(dest.m_ptr), addressTempRegister);
1742         m_assembler.ldr(dataTempRegister, addressTempRegister, ARMThumbImmediate::makeUInt16(0));
1743 
1744         // Do the add.
1745         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
1746         if (armImm.isValid())
1747             m_assembler.add_S(dataTempRegister, dataTempRegister, armImm);
1748         else {
1749             // If the operand does not fit into an immediate then load it temporarily
1750             // into addressTempRegister; since we&#39;re overwriting addressTempRegister
1751             // we&#39;ll need to reload it with the high bits of the address afterwards.
1752             move(imm, addressTempRegister);
1753             m_assembler.add_S(dataTempRegister, dataTempRegister, addressTempRegister);
1754             move(TrustedImmPtr(dest.m_ptr), addressTempRegister);
1755         }
1756 
1757         // Store the result.
1758         m_assembler.str(dataTempRegister, addressTempRegister, ARMThumbImmediate::makeUInt16(0));
1759 
1760         return Jump(makeBranch(cond));
1761     }
1762 
1763     Jump branchMul32(ResultCondition cond, RegisterID src1, RegisterID src2, RegisterID dest)
1764     {
1765         m_assembler.smull(dest, dataTempRegister, src1, src2);
1766 
1767         if (cond == Overflow) {
1768             m_assembler.asr(addressTempRegister, dest, 31);
1769             return branch32(NotEqual, addressTempRegister, dataTempRegister);
1770         }
1771 
1772         return branchTest32(cond, dest);
1773     }
1774 
1775     Jump branchMul32(ResultCondition cond, RegisterID src, RegisterID dest)
1776     {
1777         return branchMul32(cond, src, dest, dest);
1778     }
1779 
1780     Jump branchMul32(ResultCondition cond, RegisterID src, TrustedImm32 imm, RegisterID dest)
1781     {
1782         move(imm, dataTempRegister);
1783         return branchMul32(cond, dataTempRegister, src, dest);
1784     }
1785 
1786     Jump branchNeg32(ResultCondition cond, RegisterID srcDest)
1787     {
1788         ARMThumbImmediate zero = ARMThumbImmediate::makeUInt12(0);
1789         m_assembler.sub_S(srcDest, zero, srcDest);
1790         return Jump(makeBranch(cond));
1791     }
1792 
1793     Jump branchOr32(ResultCondition cond, RegisterID src, RegisterID dest)
1794     {
1795         m_assembler.orr_S(dest, dest, src);
1796         return Jump(makeBranch(cond));
1797     }
1798 
1799     Jump branchSub32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest)
1800     {
1801         m_assembler.sub_S(dest, op1, op2);
1802         return Jump(makeBranch(cond));
1803     }
1804 
1805     Jump branchSub32(ResultCondition cond, RegisterID op1, TrustedImm32 imm, RegisterID dest)
1806     {
1807         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
1808         if (armImm.isValid())
1809             m_assembler.sub_S(dest, op1, armImm);
1810         else {
1811             move(imm, dataTempRegister);
1812             m_assembler.sub_S(dest, op1, dataTempRegister);
1813         }
1814         return Jump(makeBranch(cond));
1815     }
1816 
1817     Jump branchSub32(ResultCondition cond, RegisterID src, RegisterID dest)
1818     {
1819         return branchSub32(cond, dest, src, dest);
1820     }
1821 
1822     Jump branchSub32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
1823     {
1824         return branchSub32(cond, dest, imm, dest);
1825     }
1826 
1827     void relativeTableJump(RegisterID index, int scale)
1828     {
1829         ASSERT(scale &gt;= 0 &amp;&amp; scale &lt;= 31);
1830 
1831         // dataTempRegister will point after the jump if index register contains zero
1832         move(ARMRegisters::pc, dataTempRegister);
1833         m_assembler.add(dataTempRegister, dataTempRegister, ARMThumbImmediate::makeEncodedImm(9));
1834 
1835         ShiftTypeAndAmount shift(SRType_LSL, scale);
1836         m_assembler.add(dataTempRegister, dataTempRegister, index, shift);
1837         farJump(dataTempRegister, NoPtrTag);
1838     }
1839 
1840     // Miscellaneous operations:
1841 
1842     void breakpoint(uint8_t imm = 0)
1843     {
1844         m_assembler.bkpt(imm);
1845     }
1846 
1847     static bool isBreakpoint(void* address) { return ARMv7Assembler::isBkpt(address); }
1848 
1849     ALWAYS_INLINE Call nearCall()
1850     {
1851         moveFixedWidthEncoding(TrustedImm32(0), dataTempRegister);
1852         return Call(m_assembler.blx(dataTempRegister), Call::LinkableNear);
1853     }
1854 
1855     ALWAYS_INLINE Call nearTailCall()
1856     {
1857         moveFixedWidthEncoding(TrustedImm32(0), dataTempRegister);
1858         return Call(m_assembler.bx(dataTempRegister), Call::LinkableNearTail);
1859     }
1860 
1861     ALWAYS_INLINE Call call(PtrTag)
1862     {
1863         moveFixedWidthEncoding(TrustedImm32(0), dataTempRegister);
1864         return Call(m_assembler.blx(dataTempRegister), Call::Linkable);
1865     }
1866 
1867     ALWAYS_INLINE Call call(RegisterID target, PtrTag)
1868     {
1869         return Call(m_assembler.blx(target), Call::None);
1870     }
1871 
1872     ALWAYS_INLINE Call call(Address address, PtrTag)
1873     {
1874         load32(address, dataTempRegister);
1875         return Call(m_assembler.blx(dataTempRegister), Call::None);
1876     }
1877 
1878     ALWAYS_INLINE Call call(RegisterID callTag) { return UNUSED_PARAM(callTag), call(NoPtrTag); }
1879     ALWAYS_INLINE Call call(RegisterID target, RegisterID callTag) { return UNUSED_PARAM(callTag), call(target, NoPtrTag); }
1880     ALWAYS_INLINE Call call(Address address, RegisterID callTag) { return UNUSED_PARAM(callTag), call(address, NoPtrTag); }
1881 
1882     ALWAYS_INLINE void ret()
1883     {
1884         m_assembler.bx(linkRegister);
1885     }
1886 
1887     void compare32(RelationalCondition cond, RegisterID left, RegisterID right, RegisterID dest)
1888     {
1889         m_assembler.cmp(left, right);
1890         m_assembler.it(armV7Condition(cond), false);
1891         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(1));
1892         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(0));
1893     }
1894 
1895     void compare32(RelationalCondition cond, Address left, RegisterID right, RegisterID dest)
1896     {
1897         load32(left, dataTempRegister);
1898         compare32(cond, dataTempRegister, right, dest);
1899     }
1900 
1901     void compare8(RelationalCondition cond, Address left, TrustedImm32 right, RegisterID dest)
1902     {
1903         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1904         MacroAssemblerHelpers::load8OnCondition(*this, cond, left, addressTempRegister);
1905         compare32(cond, addressTempRegister, right8, dest);
1906     }
1907 
1908     void compare32(RelationalCondition cond, RegisterID left, TrustedImm32 right, RegisterID dest)
1909     {
1910         compare32AndSetFlags(left, right);
1911         m_assembler.it(armV7Condition(cond), false);
1912         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(1));
1913         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(0));
1914     }
1915 
1916     // FIXME:
1917     // The mask should be optional... paerhaps the argument order should be
1918     // dest-src, operations always have a dest? ... possibly not true, considering
1919     // asm ops like test, or pseudo ops like pop().
1920     void test32(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
1921     {
1922         load32(address, dataTempRegister);
1923         test32(dataTempRegister, mask);
1924         m_assembler.it(armV7Condition(cond), false);
1925         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(1));
1926         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(0));
1927     }
1928 
1929     void test8(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
1930     {
1931         TrustedImm32 mask8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, mask);
1932         MacroAssemblerHelpers::load8OnCondition(*this, cond, address, dataTempRegister);
1933         test32(dataTempRegister, mask8);
1934         m_assembler.it(armV7Condition(cond), false);
1935         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(1));
1936         m_assembler.mov(dest, ARMThumbImmediate::makeUInt16(0));
1937     }
1938 
1939     ALWAYS_INLINE DataLabel32 moveWithPatch(TrustedImm32 imm, RegisterID dst)
1940     {
1941         padBeforePatch();
1942         moveFixedWidthEncoding(imm, dst);
1943         return DataLabel32(this);
1944     }
1945 
1946     ALWAYS_INLINE DataLabelPtr moveWithPatch(TrustedImmPtr imm, RegisterID dst)
1947     {
1948         padBeforePatch();
1949         moveFixedWidthEncoding(TrustedImm32(imm), dst);
1950         return DataLabelPtr(this);
1951     }
1952 
1953     ALWAYS_INLINE Jump branchPtrWithPatch(RelationalCondition cond, RegisterID left, DataLabelPtr&amp; dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(nullptr))
1954     {
1955         dataLabel = moveWithPatch(initialRightValue, dataTempRegister);
1956         return branch32(cond, left, dataTempRegister);
1957     }
1958 
1959     ALWAYS_INLINE Jump branchPtrWithPatch(RelationalCondition cond, Address left, DataLabelPtr&amp; dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(nullptr))
1960     {
1961         load32(left, addressTempRegister);
1962         dataLabel = moveWithPatch(initialRightValue, dataTempRegister);
1963         return branch32(cond, addressTempRegister, dataTempRegister);
1964     }
1965 
1966     ALWAYS_INLINE Jump branch32WithPatch(RelationalCondition cond, Address left, DataLabel32&amp; dataLabel, TrustedImm32 initialRightValue = TrustedImm32(0))
1967     {
1968         load32(left, addressTempRegister);
1969         dataLabel = moveWithPatch(initialRightValue, dataTempRegister);
1970         return branch32(cond, addressTempRegister, dataTempRegister);
1971     }
1972 
1973     PatchableJump patchableBranchPtr(RelationalCondition cond, Address left, TrustedImmPtr right = TrustedImmPtr(nullptr))
1974     {
1975         m_makeJumpPatchable = true;
1976         Jump result = branch32(cond, left, TrustedImm32(right));
1977         m_makeJumpPatchable = false;
1978         return PatchableJump(result);
1979     }
1980 
1981     PatchableJump patchableBranchTest32(ResultCondition cond, RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
1982     {
1983         m_makeJumpPatchable = true;
1984         Jump result = branchTest32(cond, reg, mask);
1985         m_makeJumpPatchable = false;
1986         return PatchableJump(result);
1987     }
1988 
1989     PatchableJump patchableBranch8(RelationalCondition cond, Address left, TrustedImm32 imm)
1990     {
1991         m_makeJumpPatchable = true;
1992         Jump result = branch8(cond, left, imm);
1993         m_makeJumpPatchable = false;
1994         return PatchableJump(result);
1995     }
1996 
1997     PatchableJump patchableBranch32(RelationalCondition cond, RegisterID reg, TrustedImm32 imm)
1998     {
1999         m_makeJumpPatchable = true;
2000         Jump result = branch32(cond, reg, imm);
2001         m_makeJumpPatchable = false;
2002         return PatchableJump(result);
2003     }
2004 
2005     PatchableJump patchableBranch32(RelationalCondition cond, Address left, TrustedImm32 imm)
2006     {
2007         m_makeJumpPatchable = true;
2008         Jump result = branch32(cond, left, imm);
2009         m_makeJumpPatchable = false;
2010         return PatchableJump(result);
2011     }
2012 
2013     PatchableJump patchableBranchPtrWithPatch(RelationalCondition cond, Address left, DataLabelPtr&amp; dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(nullptr))
2014     {
2015         m_makeJumpPatchable = true;
2016         Jump result = branchPtrWithPatch(cond, left, dataLabel, initialRightValue);
2017         m_makeJumpPatchable = false;
2018         return PatchableJump(result);
2019     }
2020 
2021     PatchableJump patchableBranch32WithPatch(RelationalCondition cond, Address left, DataLabel32&amp; dataLabel, TrustedImm32 initialRightValue = TrustedImm32(0))
2022     {
2023         m_makeJumpPatchable = true;
2024         Jump result = branch32WithPatch(cond, left, dataLabel, initialRightValue);
2025         m_makeJumpPatchable = false;
2026         return PatchableJump(result);
2027     }
2028 
2029     PatchableJump patchableJump()
2030     {
2031         padBeforePatch();
2032         m_makeJumpPatchable = true;
2033         Jump result = jump();
2034         m_makeJumpPatchable = false;
2035         return PatchableJump(result);
2036     }
2037 
2038     ALWAYS_INLINE DataLabelPtr storePtrWithPatch(TrustedImmPtr initialValue, ImplicitAddress address)
2039     {
2040         DataLabelPtr label = moveWithPatch(initialValue, dataTempRegister);
2041         store32(dataTempRegister, address);
2042         return label;
2043     }
2044     ALWAYS_INLINE DataLabelPtr storePtrWithPatch(ImplicitAddress address) { return storePtrWithPatch(TrustedImmPtr(nullptr), address); }
2045 
2046     template&lt;PtrTag resultTag, PtrTag locationTag&gt;
2047     static FunctionPtr&lt;resultTag&gt; readCallTarget(CodeLocationCall&lt;locationTag&gt; call)
2048     {
2049         return FunctionPtr&lt;resultTag&gt;(reinterpret_cast&lt;void(*)()&gt;(ARMv7Assembler::readCallTarget(call.dataLocation())));
2050     }
2051 
2052     static bool canJumpReplacePatchableBranchPtrWithPatch() { return false; }
2053     static bool canJumpReplacePatchableBranch32WithPatch() { return false; }
2054 
2055     template&lt;PtrTag tag&gt;
2056     static CodeLocationLabel&lt;tag&gt; startOfBranchPtrWithPatchOnRegister(CodeLocationDataLabelPtr&lt;tag&gt; label)
2057     {
2058         const unsigned twoWordOpSize = 4;
2059         return label.labelAtOffset(-twoWordOpSize * 2);
2060     }
2061 
2062     template&lt;PtrTag tag&gt;
2063     static void revertJumpReplacementToBranchPtrWithPatch(CodeLocationLabel&lt;tag&gt; instructionStart, RegisterID rd, void* initialValue)
2064     {
2065 #if OS(LINUX)
2066         ARMv7Assembler::revertJumpTo_movT3movtcmpT2(instructionStart.dataLocation(), rd, dataTempRegister, reinterpret_cast&lt;uintptr_t&gt;(initialValue));
2067 #else
2068         UNUSED_PARAM(rd);
2069         ARMv7Assembler::revertJumpTo_movT3(instructionStart.dataLocation(), dataTempRegister, ARMThumbImmediate::makeUInt16(reinterpret_cast&lt;uintptr_t&gt;(initialValue) &amp; 0xffff));
2070 #endif
2071     }
2072 
2073     template&lt;PtrTag tag&gt;
2074     static CodeLocationLabel&lt;tag&gt; startOfPatchableBranchPtrWithPatchOnAddress(CodeLocationDataLabelPtr&lt;tag&gt;)
2075     {
2076         UNREACHABLE_FOR_PLATFORM();
2077         return CodeLocationLabel&lt;tag&gt;();
2078     }
2079 
2080     template&lt;PtrTag tag&gt;
2081     static CodeLocationLabel&lt;tag&gt; startOfPatchableBranch32WithPatchOnAddress(CodeLocationDataLabel32&lt;tag&gt;)
2082     {
2083         UNREACHABLE_FOR_PLATFORM();
2084         return CodeLocationLabel&lt;tag&gt;();
2085     }
2086 
2087     template&lt;PtrTag tag&gt;
2088     static void revertJumpReplacementToPatchableBranchPtrWithPatch(CodeLocationLabel&lt;tag&gt;, Address, void*)
2089     {
2090         UNREACHABLE_FOR_PLATFORM();
2091     }
2092 
2093     template&lt;PtrTag tag&gt;
2094     static void revertJumpReplacementToPatchableBranch32WithPatch(CodeLocationLabel&lt;tag&gt;, Address, int32_t)
2095     {
2096         UNREACHABLE_FOR_PLATFORM();
2097     }
2098 
2099     template&lt;PtrTag callTag, PtrTag destTag&gt;
2100     static void repatchCall(CodeLocationCall&lt;callTag&gt; call, CodeLocationLabel&lt;destTag&gt; destination)
2101     {
2102         ARMv7Assembler::relinkCall(call.dataLocation(), destination.executableAddress());
2103     }
2104 
2105     template&lt;PtrTag callTag, PtrTag destTag&gt;
2106     static void repatchCall(CodeLocationCall&lt;callTag&gt; call, FunctionPtr&lt;destTag&gt; destination)
2107     {
2108         ARMv7Assembler::relinkCall(call.dataLocation(), destination.executableAddress());
2109     }
2110 
2111 protected:
2112     ALWAYS_INLINE Jump jump()
2113     {
2114         m_assembler.label(); // Force nop-padding if we&#39;re in the middle of a watchpoint.
2115         moveFixedWidthEncoding(TrustedImm32(0), dataTempRegister);
2116         return Jump(m_assembler.bx(dataTempRegister), m_makeJumpPatchable ? ARMv7Assembler::JumpNoConditionFixedSize : ARMv7Assembler::JumpNoCondition);
2117     }
2118 
2119     ALWAYS_INLINE Jump makeBranch(ARMv7Assembler::Condition cond)
2120     {
2121         m_assembler.label(); // Force nop-padding if we&#39;re in the middle of a watchpoint.
2122         m_assembler.it(cond, true, true);
2123         moveFixedWidthEncoding(TrustedImm32(0), dataTempRegister);
2124         return Jump(m_assembler.bx(dataTempRegister), m_makeJumpPatchable ? ARMv7Assembler::JumpConditionFixedSize : ARMv7Assembler::JumpCondition, cond);
2125     }
2126     ALWAYS_INLINE Jump makeBranch(RelationalCondition cond) { return makeBranch(armV7Condition(cond)); }
2127     ALWAYS_INLINE Jump makeBranch(ResultCondition cond) { return makeBranch(armV7Condition(cond)); }
2128     ALWAYS_INLINE Jump makeBranch(DoubleCondition cond) { return makeBranch(armV7Condition(cond)); }
2129 
2130     ArmAddress setupArmAddress(BaseIndex address)
2131     {
2132         if (address.offset) {
2133             ARMThumbImmediate imm = ARMThumbImmediate::makeUInt12OrEncodedImm(address.offset);
2134             if (imm.isValid())
2135                 m_assembler.add(addressTempRegister, address.base, imm);
2136             else {
2137                 move(TrustedImm32(address.offset), addressTempRegister);
2138                 m_assembler.add(addressTempRegister, addressTempRegister, address.base);
2139             }
2140 
2141             return ArmAddress(addressTempRegister, address.index, address.scale);
2142         } else
2143             return ArmAddress(address.base, address.index, address.scale);
2144     }
2145 
2146     ArmAddress setupArmAddress(Address address)
2147     {
2148         if ((address.offset &gt;= -0xff) &amp;&amp; (address.offset &lt;= 0xfff))
2149             return ArmAddress(address.base, address.offset);
2150 
2151         move(TrustedImm32(address.offset), addressTempRegister);
2152         return ArmAddress(address.base, addressTempRegister);
2153     }
2154 
2155     ArmAddress setupArmAddress(ImplicitAddress address)
2156     {
2157         if ((address.offset &gt;= -0xff) &amp;&amp; (address.offset &lt;= 0xfff))
2158             return ArmAddress(address.base, address.offset);
2159 
2160         move(TrustedImm32(address.offset), addressTempRegister);
2161         return ArmAddress(address.base, addressTempRegister);
2162     }
2163 
2164     RegisterID makeBaseIndexBase(BaseIndex address)
2165     {
2166         if (!address.offset)
2167             return address.base;
2168 
2169         ARMThumbImmediate imm = ARMThumbImmediate::makeUInt12OrEncodedImm(address.offset);
2170         if (imm.isValid())
2171             m_assembler.add(addressTempRegister, address.base, imm);
2172         else {
2173             move(TrustedImm32(address.offset), addressTempRegister);
2174             m_assembler.add(addressTempRegister, addressTempRegister, address.base);
2175         }
2176 
2177         return addressTempRegister;
2178     }
2179 
2180     void moveFixedWidthEncoding(TrustedImm32 imm, RegisterID dst)
2181     {
2182         uint32_t value = imm.m_value;
2183         m_assembler.movT3(dst, ARMThumbImmediate::makeUInt16(value &amp; 0xffff));
2184         m_assembler.movt(dst, ARMThumbImmediate::makeUInt16(value &gt;&gt; 16));
2185     }
2186 
2187     ARMv7Assembler::Condition armV7Condition(RelationalCondition cond)
2188     {
2189         return static_cast&lt;ARMv7Assembler::Condition&gt;(cond);
2190     }
2191 
2192     ARMv7Assembler::Condition armV7Condition(ResultCondition cond)
2193     {
2194         return static_cast&lt;ARMv7Assembler::Condition&gt;(cond);
2195     }
2196 
2197     ARMv7Assembler::Condition armV7Condition(DoubleCondition cond)
2198     {
2199         return static_cast&lt;ARMv7Assembler::Condition&gt;(cond);
2200     }
2201 
2202 private:
2203     friend class LinkBuffer;
2204 
2205     template&lt;PtrTag tag&gt;
2206     static void linkCall(void* code, Call call, FunctionPtr&lt;tag&gt; function)
2207     {
2208         if (call.isFlagSet(Call::Tail))
2209             ARMv7Assembler::linkJump(code, call.m_label, function.executableAddress());
2210         else
2211             ARMv7Assembler::linkCall(code, call.m_label, function.executableAddress());
2212     }
2213 
2214     bool m_makeJumpPatchable;
2215 };
2216 
2217 } // namespace JSC
2218 
2219 #endif // ENABLE(ASSEMBLER)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITToDFGDeferredCompilationCallback.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITWorklist.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITWorklist.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;JIT.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;VMInlines.h&quot;
 34 
 35 namespace JSC {
 36 
 37 class JITWorklist::Plan : public ThreadSafeRefCounted&lt;JITWorklist::Plan&gt; {
 38 public:
<span class="line-modified"> 39     Plan(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
 40         : m_codeBlock(codeBlock)
<span class="line-modified"> 41         , m_jit(codeBlock-&gt;vm(), codeBlock, loopOSREntryBytecodeOffset)</span>
 42     {
 43         m_jit.doMainThreadPreparationBeforeCompile();
 44     }
 45 
 46     void compileInThread()
 47     {
 48         m_jit.compileWithoutLinking(JITCompilationCanFail);
 49 
 50         LockHolder locker(m_lock);
 51         m_isFinishedCompiling = true;
 52     }
 53 
 54     void finalize()
 55     {
 56         CompilationResult result = m_jit.link();
 57         switch (result) {
 58         case CompilationFailed:
 59             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;delayJITCompile&quot;, (&quot;compilation failed&quot;));
<span class="line-modified"> 60             if (Options::verboseOSR())</span>
<span class="line-removed"> 61                 dataLogF(&quot;    JIT compilation failed.\n&quot;);</span>
 62             m_codeBlock-&gt;dontJITAnytimeSoon();
 63             m_codeBlock-&gt;m_didFailJITCompilation = true;
 64             return;
 65         case CompilationSuccessful:
<span class="line-modified"> 66             if (Options::verboseOSR())</span>
<span class="line-removed"> 67                 dataLogF(&quot;    JIT compilation successful.\n&quot;);</span>
 68             m_codeBlock-&gt;ownerExecutable()-&gt;installCode(m_codeBlock);
 69             m_codeBlock-&gt;jitSoon();
 70             return;
 71         default:
 72             RELEASE_ASSERT_NOT_REACHED();
 73             return;
 74         }
 75     }
 76 
 77     CodeBlock* codeBlock() { return m_codeBlock; }
 78     VM&amp; vm() { return m_codeBlock-&gt;vm(); }
 79 
 80     bool isFinishedCompiling()
 81     {
 82         LockHolder locker(m_lock);
 83         return m_isFinishedCompiling;
 84     }
 85 
<span class="line-modified"> 86     static void compileNow(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
 87     {
<span class="line-modified"> 88         Plan plan(codeBlock, loopOSREntryBytecodeOffset);</span>
 89         plan.compileInThread();
 90         plan.finalize();
 91     }
 92 
 93 private:
 94     CodeBlock* m_codeBlock;
 95     JIT m_jit;
 96     Lock m_lock;
 97     bool m_isFinishedCompiling { false };
 98 };
 99 
100 class JITWorklist::Thread : public AutomaticThread {
101 public:
102     Thread(const AbstractLocker&amp; locker, JITWorklist&amp; worklist)
103         : AutomaticThread(locker, worklist.m_lock, worklist.m_condition.copyRef())
104         , m_worklist(worklist)
105     {
106         m_worklist.m_numAvailableThreads++;
107     }
108 
</pre>
<hr />
<pre>
211 void JITWorklist::poll(VM&amp; vm)
212 {
213     DeferGC deferGC(vm.heap);
214     Plans myPlans;
215     {
216         LockHolder locker(*m_lock);
217         m_plans.removeAllMatching(
218             [&amp;] (RefPtr&lt;Plan&gt;&amp; plan) {
219                 if (&amp;plan-&gt;vm() != &amp;vm)
220                     return false;
221                 if (!plan-&gt;isFinishedCompiling())
222                     return false;
223                 myPlans.append(WTFMove(plan));
224                 return true;
225             });
226     }
227 
228     finalizePlans(myPlans);
229 }
230 
<span class="line-modified">231 void JITWorklist::compileLater(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
232 {
233     DeferGC deferGC(codeBlock-&gt;vm().heap);
234     RELEASE_ASSERT(codeBlock-&gt;jitType() == JITType::InterpreterThunk);
235 
236     if (codeBlock-&gt;m_didFailJITCompilation) {
237         codeBlock-&gt;dontJITAnytimeSoon();
238         return;
239     }
240 
241     if (!Options::useConcurrentJIT()) {
<span class="line-modified">242         Plan::compileNow(codeBlock, loopOSREntryBytecodeOffset);</span>
243         return;
244     }
245 
246     codeBlock-&gt;jitSoon();
247 
248     {
249         LockHolder locker(*m_lock);
250 
251         if (m_planned.contains(codeBlock))
252             return;
253 
254         if (m_numAvailableThreads) {
255             m_planned.add(codeBlock);
<span class="line-modified">256             RefPtr&lt;Plan&gt; plan = adoptRef(new Plan(codeBlock, loopOSREntryBytecodeOffset));</span>
257             m_plans.append(plan);
258             m_queue.append(plan);
259             m_condition-&gt;notifyAll(locker);
260             return;
261         }
262     }
263 
264     // Compiling on the main thread if the helper thread isn&#39;t available is a defense against this
265     // pathology:
266     //
267     // 1) Do something that is allowed to take a while, like load a giant piece of initialization
268     //    code. This plans the compile of the init code, but doesn&#39;t finish it. It will take a
269     //    while.
270     //
271     // 2) Do something that is supposed to be quick. Now all baseline compiles, and so all DFG and
272     //    FTL compiles, of everything is blocked on the long-running baseline compile of that
273     //    initialization code.
274     //
275     // The single-threaded concurrent JIT has this tendency to convoy everything while at the same
276     // time postponing when it happens, which means that the convoy delays are less predictable.
277     // This works around the issue. If the concurrent JIT thread is convoyed, we revert to main
278     // thread compiles. This is probably not as good as if we had multiple JIT threads. Maybe we
279     // can do that someday.
<span class="line-modified">280     Plan::compileNow(codeBlock, loopOSREntryBytecodeOffset);</span>
281 }
282 
<span class="line-modified">283 void JITWorklist::compileNow(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
284 {
285     VM&amp; vm = codeBlock-&gt;vm();
286     DeferGC deferGC(vm.heap);
287     if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
288         return;
289 
290     bool isPlanned;
291     {
292         LockHolder locker(*m_lock);
293         isPlanned = m_planned.contains(codeBlock);
294     }
295 
296     if (isPlanned) {
297         RELEASE_ASSERT(Options::useConcurrentJIT());
298         // This is expensive, but probably good enough.
299         completeAllForVM(vm);
300     }
301 
302     // Now it might be compiled!
303     if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
304         return;
305 
306     // We do this in case we had previously attempted, and then failed, to compile with the
307     // baseline JIT.
308     codeBlock-&gt;resetJITData();
309 
310     // OK, just compile it.
<span class="line-modified">311     JIT::compile(vm, codeBlock, JITCompilationMustSucceed, loopOSREntryBytecodeOffset);</span>
312     codeBlock-&gt;ownerExecutable()-&gt;installCode(codeBlock);
313 }
314 
315 void JITWorklist::finalizePlans(Plans&amp; myPlans)
316 {
317     for (RefPtr&lt;Plan&gt;&amp; plan : myPlans) {
318         plan-&gt;finalize();
319 
320         LockHolder locker(*m_lock);
321         m_planned.remove(plan-&gt;codeBlock());
322     }
323 }
324 
325 static JITWorklist* theGlobalJITWorklist { nullptr };
326 
327 JITWorklist* JITWorklist::existingGlobalWorklistOrNull()
328 {
329     return theGlobalJITWorklist;
330 }
331 
</pre>
</td>
<td>
<hr />
<pre>
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITWorklist.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;JIT.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;VMInlines.h&quot;
 34 
 35 namespace JSC {
 36 
 37 class JITWorklist::Plan : public ThreadSafeRefCounted&lt;JITWorklist::Plan&gt; {
 38 public:
<span class="line-modified"> 39     Plan(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
 40         : m_codeBlock(codeBlock)
<span class="line-modified"> 41         , m_jit(codeBlock-&gt;vm(), codeBlock, loopOSREntryBytecodeIndex)</span>
 42     {
 43         m_jit.doMainThreadPreparationBeforeCompile();
 44     }
 45 
 46     void compileInThread()
 47     {
 48         m_jit.compileWithoutLinking(JITCompilationCanFail);
 49 
 50         LockHolder locker(m_lock);
 51         m_isFinishedCompiling = true;
 52     }
 53 
 54     void finalize()
 55     {
 56         CompilationResult result = m_jit.link();
 57         switch (result) {
 58         case CompilationFailed:
 59             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;delayJITCompile&quot;, (&quot;compilation failed&quot;));
<span class="line-modified"> 60             dataLogLnIf(Options::verboseOSR(), &quot;    JIT compilation failed.&quot;);</span>

 61             m_codeBlock-&gt;dontJITAnytimeSoon();
 62             m_codeBlock-&gt;m_didFailJITCompilation = true;
 63             return;
 64         case CompilationSuccessful:
<span class="line-modified"> 65             dataLogLnIf(Options::verboseOSR(), &quot;    JIT compilation successful.&quot;);</span>

 66             m_codeBlock-&gt;ownerExecutable()-&gt;installCode(m_codeBlock);
 67             m_codeBlock-&gt;jitSoon();
 68             return;
 69         default:
 70             RELEASE_ASSERT_NOT_REACHED();
 71             return;
 72         }
 73     }
 74 
 75     CodeBlock* codeBlock() { return m_codeBlock; }
 76     VM&amp; vm() { return m_codeBlock-&gt;vm(); }
 77 
 78     bool isFinishedCompiling()
 79     {
 80         LockHolder locker(m_lock);
 81         return m_isFinishedCompiling;
 82     }
 83 
<span class="line-modified"> 84     static void compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
 85     {
<span class="line-modified"> 86         Plan plan(codeBlock, loopOSREntryBytecodeIndex);</span>
 87         plan.compileInThread();
 88         plan.finalize();
 89     }
 90 
 91 private:
 92     CodeBlock* m_codeBlock;
 93     JIT m_jit;
 94     Lock m_lock;
 95     bool m_isFinishedCompiling { false };
 96 };
 97 
 98 class JITWorklist::Thread : public AutomaticThread {
 99 public:
100     Thread(const AbstractLocker&amp; locker, JITWorklist&amp; worklist)
101         : AutomaticThread(locker, worklist.m_lock, worklist.m_condition.copyRef())
102         , m_worklist(worklist)
103     {
104         m_worklist.m_numAvailableThreads++;
105     }
106 
</pre>
<hr />
<pre>
209 void JITWorklist::poll(VM&amp; vm)
210 {
211     DeferGC deferGC(vm.heap);
212     Plans myPlans;
213     {
214         LockHolder locker(*m_lock);
215         m_plans.removeAllMatching(
216             [&amp;] (RefPtr&lt;Plan&gt;&amp; plan) {
217                 if (&amp;plan-&gt;vm() != &amp;vm)
218                     return false;
219                 if (!plan-&gt;isFinishedCompiling())
220                     return false;
221                 myPlans.append(WTFMove(plan));
222                 return true;
223             });
224     }
225 
226     finalizePlans(myPlans);
227 }
228 
<span class="line-modified">229 void JITWorklist::compileLater(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
230 {
231     DeferGC deferGC(codeBlock-&gt;vm().heap);
232     RELEASE_ASSERT(codeBlock-&gt;jitType() == JITType::InterpreterThunk);
233 
234     if (codeBlock-&gt;m_didFailJITCompilation) {
235         codeBlock-&gt;dontJITAnytimeSoon();
236         return;
237     }
238 
239     if (!Options::useConcurrentJIT()) {
<span class="line-modified">240         Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);</span>
241         return;
242     }
243 
244     codeBlock-&gt;jitSoon();
245 
246     {
247         LockHolder locker(*m_lock);
248 
249         if (m_planned.contains(codeBlock))
250             return;
251 
252         if (m_numAvailableThreads) {
253             m_planned.add(codeBlock);
<span class="line-modified">254             RefPtr&lt;Plan&gt; plan = adoptRef(new Plan(codeBlock, loopOSREntryBytecodeIndex));</span>
255             m_plans.append(plan);
256             m_queue.append(plan);
257             m_condition-&gt;notifyAll(locker);
258             return;
259         }
260     }
261 
262     // Compiling on the main thread if the helper thread isn&#39;t available is a defense against this
263     // pathology:
264     //
265     // 1) Do something that is allowed to take a while, like load a giant piece of initialization
266     //    code. This plans the compile of the init code, but doesn&#39;t finish it. It will take a
267     //    while.
268     //
269     // 2) Do something that is supposed to be quick. Now all baseline compiles, and so all DFG and
270     //    FTL compiles, of everything is blocked on the long-running baseline compile of that
271     //    initialization code.
272     //
273     // The single-threaded concurrent JIT has this tendency to convoy everything while at the same
274     // time postponing when it happens, which means that the convoy delays are less predictable.
275     // This works around the issue. If the concurrent JIT thread is convoyed, we revert to main
276     // thread compiles. This is probably not as good as if we had multiple JIT threads. Maybe we
277     // can do that someday.
<span class="line-modified">278     Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);</span>
279 }
280 
<span class="line-modified">281 void JITWorklist::compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
282 {
283     VM&amp; vm = codeBlock-&gt;vm();
284     DeferGC deferGC(vm.heap);
285     if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
286         return;
287 
288     bool isPlanned;
289     {
290         LockHolder locker(*m_lock);
291         isPlanned = m_planned.contains(codeBlock);
292     }
293 
294     if (isPlanned) {
295         RELEASE_ASSERT(Options::useConcurrentJIT());
296         // This is expensive, but probably good enough.
297         completeAllForVM(vm);
298     }
299 
300     // Now it might be compiled!
301     if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
302         return;
303 
304     // We do this in case we had previously attempted, and then failed, to compile with the
305     // baseline JIT.
306     codeBlock-&gt;resetJITData();
307 
308     // OK, just compile it.
<span class="line-modified">309     JIT::compile(vm, codeBlock, JITCompilationMustSucceed, loopOSREntryBytecodeIndex);</span>
310     codeBlock-&gt;ownerExecutable()-&gt;installCode(codeBlock);
311 }
312 
313 void JITWorklist::finalizePlans(Plans&amp; myPlans)
314 {
315     for (RefPtr&lt;Plan&gt;&amp; plan : myPlans) {
316         plan-&gt;finalize();
317 
318         LockHolder locker(*m_lock);
319         m_planned.remove(plan-&gt;codeBlock());
320     }
321 }
322 
323 static JITWorklist* theGlobalJITWorklist { nullptr };
324 
325 JITWorklist* JITWorklist::existingGlobalWorklistOrNull()
326 {
327     return theGlobalJITWorklist;
328 }
329 
</pre>
</td>
</tr>
</table>
<center><a href="JITToDFGDeferredCompilationCallback.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITWorklist.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
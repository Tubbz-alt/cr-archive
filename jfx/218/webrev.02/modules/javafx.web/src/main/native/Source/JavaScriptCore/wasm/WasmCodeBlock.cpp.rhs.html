<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmCodeBlock.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;WasmBBQPlan.h&quot;</span>
 32 #include &quot;WasmCallee.h&quot;
 33 #include &quot;WasmFormat.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 34 #include &quot;WasmLLIntPlan.h&quot;</span>
 35 #include &quot;WasmWorklist.h&quot;
 36 
 37 namespace JSC { namespace Wasm {
 38 
<a name="3" id="anc3"></a><span class="line-modified"> 39 Ref&lt;CodeBlock&gt; CodeBlock::create(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, RefPtr&lt;LLIntCallees&gt; llintCallees)</span>
 40 {
<a name="4" id="anc4"></a><span class="line-modified"> 41     auto* result = new (NotNull, fastMalloc(sizeof(CodeBlock))) CodeBlock(context, mode, moduleInformation, llintCallees);</span>
 42     return adoptRef(*result);
 43 }
 44 
<a name="5" id="anc5"></a><span class="line-modified"> 45 CodeBlock::CodeBlock(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, RefPtr&lt;LLIntCallees&gt; llintCallees)</span>
 46     : m_calleeCount(moduleInformation.internalFunctionCount())
 47     , m_mode(mode)
<a name="6" id="anc6"></a><span class="line-added"> 48     , m_llintCallees(llintCallees)</span>
 49 {
 50     RefPtr&lt;CodeBlock&gt; protectedThis = this;
 51 
<a name="7" id="anc7"></a><span class="line-modified"> 52     if (Options::useWasmLLInt()) {</span>
<span class="line-modified"> 53         m_plan = adoptRef(*new LLIntPlan(context, makeRef(moduleInformation), m_llintCallees-&gt;data(), createSharedTask&lt;Plan::CallbackType&gt;([this, protectedThis = WTFMove(protectedThis)] (Plan&amp;) {</span>
<span class="line-modified"> 54             auto locker = holdLock(m_lock);</span>
<span class="line-modified"> 55             if (m_plan-&gt;failed()) {</span>
<span class="line-added"> 56                 m_errorMessage = m_plan-&gt;errorMessage();</span>
<span class="line-added"> 57                 setCompilationFinished();</span>
<span class="line-added"> 58                 return;</span>
<span class="line-added"> 59             }</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61             // FIXME: we should eventually collect the BBQ code.</span>
<span class="line-added"> 62             m_bbqCallees.resize(m_calleeCount);</span>
<span class="line-added"> 63             m_omgCallees.resize(m_calleeCount);</span>
<span class="line-added"> 64             m_wasmIndirectCallEntryPoints.resize(m_calleeCount);</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66             for (unsigned i = 0; i &lt; m_calleeCount; ++i)</span>
<span class="line-added"> 67                 m_wasmIndirectCallEntryPoints[i] = m_llintCallees-&gt;at(i)-&gt;entrypoint();</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69             m_wasmToWasmExitStubs = m_plan-&gt;takeWasmToWasmExitStubs();</span>
<span class="line-added"> 70             m_wasmToWasmCallsites = m_plan-&gt;takeWasmToWasmCallsites();</span>
<span class="line-added"> 71             m_embedderCallees = static_cast&lt;LLIntPlan*&gt;(m_plan.get())-&gt;takeEmbedderCallees();</span>
<span class="line-added"> 72 </span>
 73             setCompilationFinished();
<a name="8" id="anc8"></a><span class="line-modified"> 74         })));</span>
<span class="line-modified"> 75     } else {</span>
<span class="line-modified"> 76         m_plan = adoptRef(*new BBQPlan(context, makeRef(moduleInformation), EntryPlan::FullCompile, createSharedTask&lt;Plan::CallbackType&gt;([this, protectedThis = WTFMove(protectedThis)] (Plan&amp;) {</span>
<span class="line-modified"> 77             auto locker = holdLock(m_lock);</span>
<span class="line-modified"> 78             if (m_plan-&gt;failed()) {</span>
<span class="line-modified"> 79                 m_errorMessage = m_plan-&gt;errorMessage();</span>
<span class="line-modified"> 80                 setCompilationFinished();</span>
<span class="line-modified"> 81                 return;</span>




 82             }
<a name="9" id="anc9"></a>


 83 
<a name="10" id="anc10"></a><span class="line-modified"> 84             // FIXME: we should eventually collect the BBQ code.</span>
<span class="line-modified"> 85             m_bbqCallees.resize(m_calleeCount);</span>
<span class="line-added"> 86             m_omgCallees.resize(m_calleeCount);</span>
<span class="line-added"> 87             m_wasmIndirectCallEntryPoints.resize(m_calleeCount);</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89             BBQPlan* bbqPlan = static_cast&lt;BBQPlan*&gt;(m_plan.get());</span>
<span class="line-added"> 90             bbqPlan-&gt;initializeCallees([&amp;] (unsigned calleeIndex, RefPtr&lt;EmbedderEntrypointCallee&gt;&amp;&amp; embedderEntrypointCallee, RefPtr&lt;BBQCallee&gt;&amp;&amp; wasmEntrypoint) {</span>
<span class="line-added"> 91                 if (embedderEntrypointCallee) {</span>
<span class="line-added"> 92                     auto result = m_embedderCallees.set(calleeIndex, WTFMove(embedderEntrypointCallee));</span>
<span class="line-added"> 93                     ASSERT_UNUSED(result, result.isNewEntry);</span>
<span class="line-added"> 94                 }</span>
<span class="line-added"> 95                 m_wasmIndirectCallEntryPoints[calleeIndex] = wasmEntrypoint-&gt;entrypoint();</span>
<span class="line-added"> 96                 m_bbqCallees[calleeIndex] = adoptRef(static_cast&lt;BBQCallee*&gt;(wasmEntrypoint.leakRef()));</span>
<span class="line-added"> 97             });</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99             m_wasmToWasmExitStubs = m_plan-&gt;takeWasmToWasmExitStubs();</span>
<span class="line-added">100             m_wasmToWasmCallsites = m_plan-&gt;takeWasmToWasmCallsites();</span>
101 
<a name="11" id="anc11"></a><span class="line-modified">102             setCompilationFinished();</span>
<span class="line-modified">103         })));</span>
<span class="line-added">104     }</span>
105     m_plan-&gt;setMode(mode);
106 
107     auto&amp; worklist = Wasm::ensureWorklist();
108     // Note, immediately after we enqueue the plan, there is a chance the above callback will be called.
109     worklist.enqueue(makeRef(*m_plan.get()));
110 }
111 
112 CodeBlock::~CodeBlock() { }
113 
114 void CodeBlock::waitUntilFinished()
115 {
116     RefPtr&lt;Plan&gt; plan;
117     {
118         auto locker = holdLock(m_lock);
119         plan = m_plan;
120     }
121 
122     if (plan) {
123         auto&amp; worklist = Wasm::ensureWorklist();
124         worklist.completePlanSynchronously(*plan.get());
125     }
126     // else, if we don&#39;t have a plan, we&#39;re already compiled.
127 }
128 
129 void CodeBlock::compileAsync(Context* context, AsyncCompilationCallback&amp;&amp; task)
130 {
131     RefPtr&lt;Plan&gt; plan;
132     {
133         auto locker = holdLock(m_lock);
134         plan = m_plan;
135     }
136 
137     if (plan) {
138         // We don&#39;t need to keep a RefPtr on the Plan because the worklist will keep
139         // a RefPtr on the Plan until the plan finishes notifying all of its callbacks.
140         RefPtr&lt;CodeBlock&gt; protectedThis = this;
141         plan-&gt;addCompletionTask(context, createSharedTask&lt;Plan::CallbackType&gt;([this, task = WTFMove(task), protectedThis = WTFMove(protectedThis)] (Plan&amp;) {
142             task-&gt;run(makeRef(*this));
143         }));
144     } else
145         task-&gt;run(makeRef(*this));
146 }
147 
148 bool CodeBlock::isSafeToRun(MemoryMode memoryMode)
149 {
150     if (!runnable())
151         return false;
152 
153     switch (m_mode) {
154     case Wasm::MemoryMode::BoundsChecking:
155         return true;
156     case Wasm::MemoryMode::Signaling:
157         // Code being in Signaling mode means that it performs no bounds checks.
158         // Its memory, even if empty, absolutely must also be in Signaling mode
159         // because the page protection detects out-of-bounds accesses.
160         return memoryMode == Wasm::MemoryMode::Signaling;
161     }
162     RELEASE_ASSERT_NOT_REACHED();
163     return false;
164 }
165 
166 
167 void CodeBlock::setCompilationFinished()
168 {
169     m_plan = nullptr;
170     m_compilationFinished.store(true);
171 }
172 
173 } } // namespace JSC::Wasm
174 
175 #endif // ENABLE(WEBASSEMBLY)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
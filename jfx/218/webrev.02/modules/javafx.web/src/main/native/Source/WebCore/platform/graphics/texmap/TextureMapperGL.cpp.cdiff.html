<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperGC3DPlatformLayer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperGL.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,11 ***</span>
  
  #if USE(TEXTURE_MAPPER_GL)
  
  #include &quot;BitmapTextureGL.h&quot;
  #include &quot;BitmapTexturePool.h&quot;
<span class="line-modified">! #include &quot;Extensions3D.h&quot;</span>
  #include &quot;FilterOperations.h&quot;
  #include &quot;FloatQuad.h&quot;
  #include &quot;GLContext.h&quot;
  #include &quot;GraphicsContext.h&quot;
  #include &quot;Image.h&quot;
<span class="line-new-header">--- 24,11 ---</span>
  
  #if USE(TEXTURE_MAPPER_GL)
  
  #include &quot;BitmapTextureGL.h&quot;
  #include &quot;BitmapTexturePool.h&quot;
<span class="line-modified">! #include &quot;ExtensionsGL.h&quot;</span>
  #include &quot;FilterOperations.h&quot;
  #include &quot;FloatQuad.h&quot;
  #include &quot;GLContext.h&quot;
  #include &quot;GraphicsContext.h&quot;
  #include &quot;Image.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,25 ***</span>
  
  static TextureMapperShaderProgram::Options optionsForFilterType(FilterOperation::OperationType type, unsigned pass)
  {
      switch (type) {
      case FilterOperation::GRAYSCALE:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::GrayscaleFilter;</span>
      case FilterOperation::SEPIA:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::SepiaFilter;</span>
      case FilterOperation::SATURATE:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::SaturateFilter;</span>
      case FilterOperation::HUE_ROTATE:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::HueRotateFilter;</span>
      case FilterOperation::INVERT:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::InvertFilter;</span>
      case FilterOperation::BRIGHTNESS:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::BrightnessFilter;</span>
      case FilterOperation::CONTRAST:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::ContrastFilter;</span>
      case FilterOperation::OPACITY:
<span class="line-modified">!         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::OpacityFilter;</span>
      case FilterOperation::BLUR:
          return TextureMapperShaderProgram::BlurFilter;
      case FilterOperation::DROP_SHADOW:
          return TextureMapperShaderProgram::AlphaBlur
              | (pass ? TextureMapperShaderProgram::ContentTexture | TextureMapperShaderProgram::SolidColor: 0);
<span class="line-new-header">--- 317,25 ---</span>
  
  static TextureMapperShaderProgram::Options optionsForFilterType(FilterOperation::OperationType type, unsigned pass)
  {
      switch (type) {
      case FilterOperation::GRAYSCALE:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::GrayscaleFilter;</span>
      case FilterOperation::SEPIA:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::SepiaFilter;</span>
      case FilterOperation::SATURATE:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::SaturateFilter;</span>
      case FilterOperation::HUE_ROTATE:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::HueRotateFilter;</span>
      case FilterOperation::INVERT:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::InvertFilter;</span>
      case FilterOperation::BRIGHTNESS:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::BrightnessFilter;</span>
      case FilterOperation::CONTRAST:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::ContrastFilter;</span>
      case FilterOperation::OPACITY:
<span class="line-modified">!         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::OpacityFilter;</span>
      case FilterOperation::BLUR:
          return TextureMapperShaderProgram::BlurFilter;
      case FilterOperation::DROP_SHADOW:
          return TextureMapperShaderProgram::AlphaBlur
              | (pass ? TextureMapperShaderProgram::ContentTexture | TextureMapperShaderProgram::SolidColor: 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,11 ***</span>
      bool useRect = flags &amp; ShouldUseARBTextureRect;
      bool useAntialiasing = m_enableEdgeDistanceAntialiasing
          &amp;&amp; exposedEdges == AllEdges
          &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();
  
<span class="line-modified">!     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::Texture;</span>
      if (useRect)
          options |= TextureMapperShaderProgram::Rect;
      if (opacity &lt; 1)
          options |= TextureMapperShaderProgram::Opacity;
      if (useAntialiasing) {
<span class="line-new-header">--- 468,11 ---</span>
      bool useRect = flags &amp; ShouldUseARBTextureRect;
      bool useAntialiasing = m_enableEdgeDistanceAntialiasing
          &amp;&amp; exposedEdges == AllEdges
          &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();
  
<span class="line-modified">!     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::TextureRGB;</span>
      if (useRect)
          options |= TextureMapperShaderProgram::Rect;
      if (opacity &lt; 1)
          options |= TextureMapperShaderProgram::Opacity;
      if (useAntialiasing) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 502,10 ***</span>
<span class="line-new-header">--- 502,177 ---</span>
          prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);
  
      drawTexturedQuadWithProgram(program.get(), texture, flags, textureSize, targetRect, modelViewMatrix, opacity);
  }
  
<span class="line-added">+ static void prepareTransformationMatrixWithFlags(TransformationMatrix&amp; patternTransform, TextureMapperGL::Flags flags, const IntSize&amp; size)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (flags &amp; TextureMapperGL::ShouldRotateTexture90) {</span>
<span class="line-added">+         patternTransform.rotate(-90);</span>
<span class="line-added">+         patternTransform.translate(-1, 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (flags &amp; TextureMapperGL::ShouldRotateTexture180) {</span>
<span class="line-added">+         patternTransform.rotate(180);</span>
<span class="line-added">+         patternTransform.translate(-1, -1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (flags &amp; TextureMapperGL::ShouldRotateTexture270) {</span>
<span class="line-added">+         patternTransform.rotate(-270);</span>
<span class="line-added">+         patternTransform.translate(0, -1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (flags &amp; TextureMapperGL::ShouldFlipTexture)</span>
<span class="line-added">+         patternTransform.flipY();</span>
<span class="line-added">+     if (flags &amp; TextureMapperGL::ShouldUseARBTextureRect)</span>
<span class="line-added">+         patternTransform.scaleNonUniform(size.width(), size.height());</span>
<span class="line-added">+     if (flags &amp; TextureMapperGL::ShouldFlipTexture)</span>
<span class="line-added">+         patternTransform.translate(0, -1);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TextureMapperGL::drawTexturePlanarYUV(const std::array&lt;GLuint, 3&gt;&amp; textures, const std::array&lt;GLfloat, 9&gt;&amp; yuvToRgbMatrix, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool useRect = flags &amp; ShouldUseARBTextureRect;</span>
<span class="line-added">+     bool useAntialiasing = m_enableEdgeDistanceAntialiasing</span>
<span class="line-added">+         &amp;&amp; exposedEdges == AllEdges</span>
<span class="line-added">+         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();</span>
<span class="line-added">+ </span>
<span class="line-added">+     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::TextureYUV;</span>
<span class="line-added">+     if (useRect)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Rect;</span>
<span class="line-added">+     if (opacity &lt; 1)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Opacity;</span>
<span class="line-added">+     if (useAntialiasing) {</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Antialiasing;</span>
<span class="line-added">+         flags |= ShouldAntialias;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::ManualRepeat;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;</span>
<span class="line-added">+     GLuint filterContentTextureID = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (filter) {</span>
<span class="line-added">+         if (data().filterInfo-&gt;contentTexture)</span>
<span class="line-added">+             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();</span>
<span class="line-added">+         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);</span>
<span class="line-added">+         if (filter-&gt;affectsOpacity())</span>
<span class="line-added">+             flags |= ShouldBlend;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (useAntialiasing || opacity &lt; 1)</span>
<span class="line-added">+         flags |= ShouldBlend;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (filter)</span>
<span class="line-added">+         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt; texturesAndSamplers = {</span>
<span class="line-added">+         { textures[0], program-&gt;samplerYLocation() },</span>
<span class="line-added">+         { textures[1], program-&gt;samplerULocation() },</span>
<span class="line-added">+         { textures[2], program-&gt;samplerVLocation() }</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     glUseProgram(program-&gt;programID());</span>
<span class="line-added">+     glUniformMatrix3fv(program-&gt;yuvToRgbLocation(), 1, GL_FALSE, static_cast&lt;const GLfloat *&gt;(&amp;yuvToRgbMatrix[0]));</span>
<span class="line-added">+     drawTexturedQuadWithProgram(program.get(), texturesAndSamplers, flags, textureSize, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TextureMapperGL::drawTextureSemiPlanarYUV(const std::array&lt;GLuint, 2&gt;&amp; textures, bool uvReversed, const std::array&lt;GLfloat, 9&gt;&amp; yuvToRgbMatrix, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool useRect = flags &amp; ShouldUseARBTextureRect;</span>
<span class="line-added">+     bool useAntialiasing = m_enableEdgeDistanceAntialiasing</span>
<span class="line-added">+         &amp;&amp; exposedEdges == AllEdges</span>
<span class="line-added">+         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();</span>
<span class="line-added">+ </span>
<span class="line-added">+     TextureMapperShaderProgram::Options options = uvReversed ?</span>
<span class="line-added">+         TextureMapperShaderProgram::TextureNV21 : TextureMapperShaderProgram::TextureNV12;</span>
<span class="line-added">+     if (useRect)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Rect;</span>
<span class="line-added">+     if (opacity &lt; 1)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Opacity;</span>
<span class="line-added">+     if (useAntialiasing) {</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Antialiasing;</span>
<span class="line-added">+         flags |= ShouldAntialias;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::ManualRepeat;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;</span>
<span class="line-added">+     GLuint filterContentTextureID = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (filter) {</span>
<span class="line-added">+         if (data().filterInfo-&gt;contentTexture)</span>
<span class="line-added">+             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();</span>
<span class="line-added">+         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);</span>
<span class="line-added">+         if (filter-&gt;affectsOpacity())</span>
<span class="line-added">+             flags |= ShouldBlend;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (useAntialiasing || opacity &lt; 1)</span>
<span class="line-added">+         flags |= ShouldBlend;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (filter)</span>
<span class="line-added">+         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt; texturesAndSamplers = {</span>
<span class="line-added">+         { textures[0], program-&gt;samplerYLocation() },</span>
<span class="line-added">+         { textures[1], program-&gt;samplerULocation() }</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     glUseProgram(program-&gt;programID());</span>
<span class="line-added">+     glUniformMatrix3fv(program-&gt;yuvToRgbLocation(), 1, GL_FALSE, static_cast&lt;const GLfloat *&gt;(&amp;yuvToRgbMatrix[0]));</span>
<span class="line-added">+     drawTexturedQuadWithProgram(program.get(), texturesAndSamplers, flags, textureSize, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TextureMapperGL::drawTexturePackedYUV(GLuint texture, const std::array&lt;GLfloat, 9&gt;&amp; yuvToRgbMatrix, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool useRect = flags &amp; ShouldUseARBTextureRect;</span>
<span class="line-added">+     bool useAntialiasing = m_enableEdgeDistanceAntialiasing</span>
<span class="line-added">+         &amp;&amp; exposedEdges == AllEdges</span>
<span class="line-added">+         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();</span>
<span class="line-added">+ </span>
<span class="line-added">+     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::TexturePackedYUV;</span>
<span class="line-added">+     if (useRect)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Rect;</span>
<span class="line-added">+     if (opacity &lt; 1)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Opacity;</span>
<span class="line-added">+     if (useAntialiasing) {</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::Antialiasing;</span>
<span class="line-added">+         flags |= ShouldAntialias;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)</span>
<span class="line-added">+         options |= TextureMapperShaderProgram::ManualRepeat;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;</span>
<span class="line-added">+     GLuint filterContentTextureID = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (filter) {</span>
<span class="line-added">+         if (data().filterInfo-&gt;contentTexture)</span>
<span class="line-added">+             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();</span>
<span class="line-added">+         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);</span>
<span class="line-added">+         if (filter-&gt;affectsOpacity())</span>
<span class="line-added">+             flags |= ShouldBlend;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (useAntialiasing || opacity &lt; 1)</span>
<span class="line-added">+         flags |= ShouldBlend;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (filter)</span>
<span class="line-added">+         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt; texturesAndSamplers = {</span>
<span class="line-added">+         { texture, program-&gt;samplerLocation() }</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     glUseProgram(program-&gt;programID());</span>
<span class="line-added">+     glUniformMatrix3fv(program-&gt;yuvToRgbLocation(), 1, GL_FALSE, static_cast&lt;const GLfloat *&gt;(&amp;yuvToRgbMatrix[0]));</span>
<span class="line-added">+     drawTexturedQuadWithProgram(program.get(), texturesAndSamplers, flags, textureSize, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void TextureMapperGL::drawSolidColor(const FloatRect&amp; rect, const TransformationMatrix&amp; matrix, const Color&amp; color, bool isBlendingAllowed)
  {
      Flags flags = 0;
      TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::SolidColor;
      if (!matrix.mapQuad(rect).isRectilinear()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 552,11 ***</span>
          SIDE_TRIANGLE_DATA(right, top, right, bottom),
          SIDE_TRIANGLE_DATA(left, bottom, right, bottom)
      };
  #undef SIDE_TRIANGLE_DATA
  
<span class="line-modified">!     GLuint vbo = data().getStaticVBO(GL_ARRAY_BUFFER, sizeof(GC3Dfloat) * 48, unitRectSideTriangles);</span>
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      glVertexAttribPointer(program.vertexLocation(), 4, GL_FLOAT, false, 0, 0);
      glDrawArrays(GL_TRIANGLES, 0, 12);
      glBindBuffer(GL_ARRAY_BUFFER, 0);
  }
<span class="line-new-header">--- 719,11 ---</span>
          SIDE_TRIANGLE_DATA(right, top, right, bottom),
          SIDE_TRIANGLE_DATA(left, bottom, right, bottom)
      };
  #undef SIDE_TRIANGLE_DATA
  
<span class="line-modified">!     GLuint vbo = data().getStaticVBO(GL_ARRAY_BUFFER, sizeof(GCGLfloat) * 48, unitRectSideTriangles);</span>
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      glVertexAttribPointer(program.vertexLocation(), 4, GL_FLOAT, false, 0, 0);
      glDrawArrays(GL_TRIANGLES, 0, 12);
      glBindBuffer(GL_ARRAY_BUFFER, 0);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 599,52 ***</span>
      glDisableVertexAttribArray(program.vertexLocation());
      glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
      glEnable(GL_BLEND);
  }
  
<span class="line-modified">! void TextureMapperGL::drawTexturedQuadWithProgram(TextureMapperShaderProgram&amp; program, uint32_t texture, Flags flags, const IntSize&amp; size, const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
  {
      glUseProgram(program.programID());
<span class="line-modified">!     glActiveTexture(GL_TEXTURE0);</span>
<span class="line-modified">!     GLenum target = flags &amp; ShouldUseARBTextureRect ? GLenum(GL_TEXTURE_RECTANGLE_ARB) : GLenum(GL_TEXTURE_2D);</span>
<span class="line-modified">!     glBindTexture(target, texture);</span>
<span class="line-modified">!     glUniform1i(program.samplerLocation(), 0);</span>
<span class="line-modified">!     if (wrapMode() == RepeatWrap &amp;&amp; m_contextAttributes.supportsNPOTTextures) {</span>
<span class="line-modified">!         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span>
<span class="line-modified">!         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span>
      }
  
      TransformationMatrix patternTransform = this-&gt;patternTransform();
<span class="line-modified">!     if (flags &amp; ShouldRotateTexture90) {</span>
<span class="line-removed">-         patternTransform.rotate(-90);</span>
<span class="line-removed">-         patternTransform.translate(-1, 0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (flags &amp; ShouldRotateTexture180) {</span>
<span class="line-removed">-         patternTransform.rotate(180);</span>
<span class="line-removed">-         patternTransform.translate(-1, -1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (flags &amp; ShouldRotateTexture270) {</span>
<span class="line-removed">-         patternTransform.rotate(-270);</span>
<span class="line-removed">-         patternTransform.translate(0, -1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (flags &amp; ShouldFlipTexture)</span>
<span class="line-removed">-         patternTransform.flipY();</span>
<span class="line-removed">-     if (flags &amp; ShouldUseARBTextureRect)</span>
<span class="line-removed">-         patternTransform.scaleNonUniform(size.width(), size.height());</span>
<span class="line-removed">-     if (flags &amp; ShouldFlipTexture)</span>
<span class="line-removed">-         patternTransform.translate(0, -1);</span>
  
      program.setMatrix(program.textureSpaceMatrixLocation(), patternTransform);
      program.setMatrix(program.textureColorSpaceMatrixLocation(), colorSpaceMatrixForFlags(flags));
      glUniform1f(program.opacityLocation(), opacity);
  
      if (opacity &lt; 1)
          flags |= ShouldBlend;
  
      draw(rect, modelViewMatrix, program, GL_TRIANGLE_FAN, flags);
<span class="line-modified">!     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span>
<span class="line-modified">!     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span>
  }
  
  void TextureMapperGL::drawFiltered(const BitmapTexture&amp; sampler, const BitmapTexture* contentTexture, const FilterOperation&amp; filter, int pass)
  {
      // For standard filters, we always draw the whole texture without transformations.
<span class="line-new-header">--- 766,58 ---</span>
      glDisableVertexAttribArray(program.vertexLocation());
      glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
      glEnable(GL_BLEND);
  }
  
<span class="line-modified">! void TextureMapperGL::drawTexturedQuadWithProgram(TextureMapperShaderProgram&amp; program, const Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt;&amp; texturesAndSamplers, Flags flags, const IntSize&amp; size, const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
  {
      glUseProgram(program.programID());
<span class="line-modified">! </span>
<span class="line-modified">!     bool repeatWrap = wrapMode() == RepeatWrap &amp;&amp; m_contextAttributes.supportsNPOTTextures;</span>
<span class="line-modified">!     GLenum target;</span>
<span class="line-modified">!     if (flags &amp; ShouldUseExternalOESTextureRect)</span>
<span class="line-modified">!         target = GLenum(GL_TEXTURE_EXTERNAL_OES);</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!         target = flags &amp; ShouldUseARBTextureRect ? GLenum(GL_TEXTURE_RECTANGLE_ARB) : GLenum(GL_TEXTURE_2D);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (unsigned i = 0; i &lt; texturesAndSamplers.size(); ++i) {</span>
<span class="line-added">+         auto&amp; textureAndSampler = texturesAndSamplers[i];</span>
<span class="line-added">+ </span>
<span class="line-added">+         glActiveTexture(GL_TEXTURE0 + i);</span>
<span class="line-added">+         glBindTexture(target, textureAndSampler.first);</span>
<span class="line-added">+         glUniform1i(textureAndSampler.second, i);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (repeatWrap) {</span>
<span class="line-added">+             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span>
<span class="line-added">+             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span>
<span class="line-added">+         }</span>
      }
  
      TransformationMatrix patternTransform = this-&gt;patternTransform();
<span class="line-modified">!     prepareTransformationMatrixWithFlags(patternTransform, flags, size);</span>
  
      program.setMatrix(program.textureSpaceMatrixLocation(), patternTransform);
      program.setMatrix(program.textureColorSpaceMatrixLocation(), colorSpaceMatrixForFlags(flags));
      glUniform1f(program.opacityLocation(), opacity);
  
      if (opacity &lt; 1)
          flags |= ShouldBlend;
  
      draw(rect, modelViewMatrix, program, GL_TRIANGLE_FAN, flags);
<span class="line-modified">! </span>
<span class="line-modified">!     if (repeatWrap) {</span>
<span class="line-added">+         for (auto&amp; textureAndSampler : texturesAndSamplers) {</span>
<span class="line-added">+             glBindTexture(target, textureAndSampler.first);</span>
<span class="line-added">+             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span>
<span class="line-added">+             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TextureMapperGL::drawTexturedQuadWithProgram(TextureMapperShaderProgram&amp; program, uint32_t texture, Flags flags, const IntSize&amp; size, const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     drawTexturedQuadWithProgram(program, { { texture, program.samplerLocation() } }, flags, size, rect, modelViewMatrix, opacity);</span>
  }
  
  void TextureMapperGL::drawFiltered(const BitmapTexture&amp; sampler, const BitmapTexture* contentTexture, const FilterOperation&amp; filter, int pass)
  {
      // For standard filters, we always draw the whole texture without transformations.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 791,8 ***</span>
<span class="line-new-header">--- 964,15 ---</span>
  std::unique_ptr&lt;TextureMapper&gt; TextureMapper::platformCreateAccelerated()
  {
      return makeUnique&lt;TextureMapperGL&gt;();
  }
  
<span class="line-added">+ void TextureMapperGL::drawTextureExternalOES(GLuint texture, Flags flags, const IntSize&amp; size, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(TextureMapperShaderProgram::Option::TextureExternalOES);</span>
<span class="line-added">+     drawTexturedQuadWithProgram(program.get(), { { texture, program-&gt;externalOESTextureLocation() } },</span>
<span class="line-added">+         flags | TextureMapperGL::ShouldUseExternalOESTextureRect, size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  };
  
  #endif // USE(TEXTURE_MAPPER_GL)
</pre>
<center><a href="TextureMapperGC3DPlatformLayer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperGL.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.h
@@ -28,16 +28,16 @@
 
 namespace JSC {
 
 class FunctionPrototype;
 
-class InternalFunction : public JSDestructibleObject {
+class InternalFunction : public JSNonFinalObject {
     friend class JIT;
     friend class LLIntOffsetsExtractor;
 public:
-    typedef JSDestructibleObject Base;
-    static const unsigned StructureFlags = Base::StructureFlags | ImplementsHasInstance | ImplementsDefaultHasInstance | OverridesGetCallData;
+    using Base = JSNonFinalObject;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | ImplementsHasInstance | ImplementsDefaultHasInstance | OverridesGetCallData;
 
     template<typename CellType, SubspaceAccess>
     static IsoSubspace* subspaceFor(VM& vm)
     {
         static_assert(sizeof(CellType) == sizeof(InternalFunction), "InternalFunction subclasses that add fields need to override subspaceFor<>()");
@@ -55,11 +55,11 @@
     static Structure* createStructure(VM& vm, JSGlobalObject* globalObject, JSValue proto)
     {
         return Structure::create(vm, globalObject, proto, TypeInfo(InternalFunctionType, StructureFlags), info());
     }
 
-    static Structure* createSubclassStructure(ExecState*, JSValue newTarget, Structure*);
+    static Structure* createSubclassStructure(JSGlobalObject*, JSObject* baseCallee, JSValue newTarget, Structure*);
 
     TaggedNativeFunction nativeFunctionFor(CodeSpecializationKind kind)
     {
         if (kind == CodeForCall)
             return m_functionForCall;
@@ -73,34 +73,39 @@
             return OBJECT_OFFSETOF(InternalFunction, m_functionForCall);
         ASSERT(kind == CodeForConstruct);
         return OBJECT_OFFSETOF(InternalFunction, m_functionForConstruct);
     }
 
+    static ptrdiff_t offsetOfGlobalObject()
+    {
+        return OBJECT_OFFSETOF(InternalFunction, m_globalObject);
+    }
+
+    JSGlobalObject* globalObject() const { return m_globalObject.get(); }
+
 protected:
     JS_EXPORT_PRIVATE InternalFunction(VM&, Structure*, NativeFunction functionForCall, NativeFunction functionForConstruct);
 
-    enum class NameVisibility { Visible, Anonymous };
     enum class NameAdditionMode { WithStructureTransition, WithoutStructureTransition };
-    JS_EXPORT_PRIVATE void finishCreation(VM&, const String& name, NameVisibility = NameVisibility::Visible, NameAdditionMode = NameAdditionMode::WithStructureTransition);
+    JS_EXPORT_PRIVATE void finishCreation(VM&, const String& name, NameAdditionMode = NameAdditionMode::WithStructureTransition);
 
-    JS_EXPORT_PRIVATE static Structure* createSubclassStructureSlow(ExecState*, JSValue newTarget, Structure*);
+    JS_EXPORT_PRIVATE static Structure* createSubclassStructureSlow(JSGlobalObject*, JSValue newTarget, Structure*);
 
     JS_EXPORT_PRIVATE static ConstructType getConstructData(JSCell*, ConstructData&);
     JS_EXPORT_PRIVATE static CallType getCallData(JSCell*, CallData&);
 
     TaggedNativeFunction m_functionForCall;
     TaggedNativeFunction m_functionForConstruct;
     WriteBarrier<JSString> m_originalName;
+    WriteBarrier<JSGlobalObject> m_globalObject;
 };
 
-ALWAYS_INLINE Structure* InternalFunction::createSubclassStructure(ExecState* exec, JSValue newTarget, Structure* baseClass)
+ALWAYS_INLINE Structure* InternalFunction::createSubclassStructure(JSGlobalObject* globalObject, JSObject* baseCallee, JSValue newTarget, Structure* baseClass)
 {
     // We allow newTarget == JSValue() because the API needs to be able to create classes without having a real JS frame.
-    // Since we don't allow subclassing in the API we just treat newTarget == JSValue() as newTarget == exec->jsCallee()
-    ASSERT(!newTarget || newTarget.isConstructor(exec->vm()));
-
-    if (newTarget && newTarget != exec->jsCallee())
-        return createSubclassStructureSlow(exec, newTarget, baseClass);
+    // Since we don't allow subclassing in the API we just treat newTarget == JSValue() as newTarget == callFrame->jsCallee()
+    if (newTarget && newTarget != baseCallee)
+        return createSubclassStructureSlow(globalObject, newTarget, baseClass);
     return baseClass;
 }
 
 } // namespace JSC

diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2003, 2004, 2005, 2006, 2008 Apple Inc. All rights reserved.
+ * Copyright (C) 2003-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -25,30 +25,22 @@
 
 #include "config.h"
 #include "Color.h"
 
 #include "AnimationUtilities.h"
+#include "ColorUtilities.h"
 #include "HashTools.h"
 #include <wtf/Assertions.h>
 #include <wtf/HexNumber.h>
 #include <wtf/MathExtras.h>
 #include <wtf/text/StringBuilder.h>
 #include <wtf/text/TextStream.h>
 
 namespace WebCore {
 
-#if !COMPILER(MSVC)
-const RGBA32 Color::black;
-const RGBA32 Color::white;
-const RGBA32 Color::darkGray;
-const RGBA32 Color::gray;
-const RGBA32 Color::lightGray;
-const RGBA32 Color::transparent;
-#endif
-
-static const RGBA32 lightenedBlack = 0xFF545454;
-static const RGBA32 darkenedWhite = 0xFFABABAB;
+static constexpr SimpleColor lightenedBlack { 0xFF545454 };
+static constexpr SimpleColor darkenedWhite { 0xFFABABAB };
 
 static inline unsigned premultipliedChannel(unsigned c, unsigned a, bool ceiling = true)
 {
     return fastDivideBy255(ceiling ? c * a + 254 : c * a);
 }
@@ -58,16 +50,16 @@
     return (fastMultiplyBy255(c) + a - 1) / a;
 }
 
 RGBA32 makeRGB(int r, int g, int b)
 {
-    return 0xFF000000 | std::max(0, std::min(r, 255)) << 16 | std::max(0, std::min(g, 255)) << 8 | std::max(0, std::min(b, 255));
+    return makeRGBA(r, g, b, 0xFF);
 }
 
 RGBA32 makeRGBA(int r, int g, int b, int a)
 {
-    return std::max(0, std::min(a, 255)) << 24 | std::max(0, std::min(r, 255)) << 16 | std::max(0, std::min(g, 255)) << 8 | std::max(0, std::min(b, 255));
+    return { static_cast<unsigned>(std::max(0, std::min(a, 0xFF)) << 24 | std::max(0, std::min(r, 0xFF)) << 16 | std::max(0, std::min(g, 0xFF)) << 8 | std::max(0, std::min(b, 0xFF))) };
 }
 
 RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling)
 {
     return makeRGBA(premultipliedChannel(r, a, ceiling), premultipliedChannel(g, a, ceiling), premultipliedChannel(b, a, ceiling), a);
@@ -84,57 +76,27 @@
     return std::max(0, std::min(static_cast<int>(lroundf(255.0f * f)), 255));
 }
 
 RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a)
 {
-    return colorFloatToRGBAByte(a) << 24 | colorFloatToRGBAByte(r) << 16 | colorFloatToRGBAByte(g) << 8 | colorFloatToRGBAByte(b);
+    return makeRGBA(colorFloatToRGBAByte(r), colorFloatToRGBAByte(g), colorFloatToRGBAByte(b), colorFloatToRGBAByte(a));
 }
 
 RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha)
 {
-    RGBA32 rgbOnly = color & 0x00FFFFFF;
-    RGBA32 rgba = rgbOnly | colorFloatToRGBAByte(overrideAlpha) << 24;
-    return rgba;
+    return { (color.value() & 0x00FFFFFF) | colorFloatToRGBAByte(overrideAlpha) << 24 };
 }
 
-static double calcHue(double temp1, double temp2, double hueVal)
-{
-    if (hueVal < 0.0)
-        hueVal += 6.0;
-    else if (hueVal >= 6.0)
-        hueVal -= 6.0;
-    if (hueVal < 1.0)
-        return temp1 + (temp2 - temp1) * hueVal;
-    if (hueVal < 3.0)
-        return temp2;
-    if (hueVal < 4.0)
-        return temp1 + (temp2 - temp1) * (4.0 - hueVal);
-    return temp1;
-}
-
-// Explanation of this algorithm can be found in the CSS Color 4 Module
-// specification at https://drafts.csswg.org/css-color-4/#hsl-to-rgb with
-// further explanation available at http://en.wikipedia.org/wiki/HSL_color_space
-
-// Hue is in the range of 0 to 6.0, the remainder are in the range 0 to 1.0
-// FIXME: Use HSLToSRGB().
-RGBA32 makeRGBAFromHSLA(double hue, double saturation, double lightness, double alpha)
+RGBA32 makeRGBAFromHSLA(float hue, float saturation, float lightness, float alpha)
 {
-    const double scaleFactor = nextafter(256.0, 0.0);
-
-    if (!saturation) {
-        int greyValue = static_cast<int>(lightness * scaleFactor);
-        return makeRGBA(greyValue, greyValue, greyValue, static_cast<int>(alpha * scaleFactor));
-    }
-
-    double temp2 = lightness <= 0.5 ? lightness * (1.0 + saturation) : lightness + saturation - lightness * saturation;
-    double temp1 = 2.0 * lightness - temp2;
-
-    return makeRGBA(static_cast<int>(calcHue(temp1, temp2, hue + 2.0) * scaleFactor),
-                    static_cast<int>(calcHue(temp1, temp2, hue) * scaleFactor),
-                    static_cast<int>(calcHue(temp1, temp2, hue - 2.0) * scaleFactor),
-                    static_cast<int>(alpha * scaleFactor));
+    const float scaleFactor = 255.0;
+    FloatComponents floatResult = HSLToSRGB({ hue, saturation, lightness, alpha });
+    return makeRGBA(
+        round(floatResult.components[0] * scaleFactor),
+        round(floatResult.components[1] * scaleFactor),
+        round(floatResult.components[2] * scaleFactor),
+        round(floatResult.components[3] * scaleFactor));
 }
 
 RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a)
 {
     double colors = 1 - k;
@@ -156,32 +118,32 @@
             return false;
         value <<= 4;
         value |= toASCIIHexValue(name[i]);
     }
     if (length == 6) {
-        rgb = 0xFF000000 | value;
+        rgb = { 0xFF000000 | value };
         return true;
     }
     if (length == 8) {
         // We parsed the values into RGBA order, but the RGBA32 type
         // expects them to be in ARGB order, so we right rotate eight bits.
-        rgb = value << 24 | value >> 8;
+        rgb = { value << 24 | value >> 8 };
         return true;
     }
     if (length == 4) {
         // #abcd converts to ddaabbcc in RGBA32.
-        rgb = (value & 0xF) << 28 | (value & 0xF) << 24
+        rgb = { (value & 0xF) << 28 | (value & 0xF) << 24
             | (value & 0xF000) << 8 | (value & 0xF000) << 4
             | (value & 0xF00) << 4 | (value & 0xF00)
-            | (value & 0xF0) | (value & 0xF0) >> 4;
+            | (value & 0xF0) | (value & 0xF0) >> 4 };
         return true;
     }
     // #abc converts to #aabbcc
-    rgb = 0xFF000000
+    rgb = { 0xFF000000
         | (value & 0xF00) << 12 | (value & 0xF00) << 8
         | (value & 0xF0) << 8 | (value & 0xF0) << 4
-        | (value & 0xF) << 4 | (value & 0xF);
+        | (value & 0xF) << 4 | (value & 0xF) };
     return true;
 }
 
 bool Color::parseHexColor(const LChar* name, unsigned length, RGBA32& rgb)
 {
@@ -194,11 +156,10 @@
 }
 
 bool Color::parseHexColor(const String& name, RGBA32& rgb)
 {
     unsigned length = name.length();
-
     if (!length)
         return false;
     if (name.is8Bit())
         return parseHexColor(name.characters8(), name.length(), rgb);
     return parseHexColor(name.characters16(), name.length(), rgb);
@@ -261,30 +222,22 @@
 
         if (valid)
             setRGB(color);
     } else {
         if (auto* foundColor = findNamedColor(name))
-            setRGB(foundColor->ARGBValue);
-        else
-            m_colorData.rgbaAndFlags = invalidRGBAColor;
+            setRGB({ foundColor->ARGBValue });
     }
 }
 
 Color::Color(const char* name)
 {
-    RGBA32 color;
-    bool valid;
-    if (name[0] == '#')
-        valid = parseHexColor((String)&name[1], color);
-    else {
-        const NamedColor* foundColor = findColor(name, strlen(name));
-        color = foundColor ? foundColor->ARGBValue : 0;
-        valid = foundColor;
-    }
-
-    if (valid)
-        setRGB(color);
+    if (name[0] == '#') {
+        SimpleColor color;
+        if (parseHexColor(reinterpret_cast<const LChar*>(&name[1]), std::strlen(&name[1]), color))
+            setRGB(color);
+    } else if (auto* foundColor = findColor(name, strlen(name)))
+        setRGB({ foundColor->ARGBValue });
 }
 
 Color::Color(const Color& other)
     : m_colorData(other.m_colorData)
 {
@@ -334,64 +287,71 @@
     other.m_colorData.rgbaAndFlags = invalidRGBAColor;
 
     return *this;
 }
 
+String SimpleColor::serializationForHTML() const
+{
+    if (isOpaque())
+        return makeString('#', hex(redComponent(), 2, Lowercase), hex(greenComponent(), 2, Lowercase), hex(blueComponent(), 2, Lowercase));
+    return serializationForCSS();
+}
+
 String Color::serialized() const
 {
     if (isExtended())
         return asExtended().cssText();
+    return rgb().serializationForHTML();
+}
 
-    if (isOpaque()) {
-        StringBuilder builder;
-        builder.reserveCapacity(7);
-        builder.append('#');
-        appendByteAsHex(red(), builder, Lowercase);
-        appendByteAsHex(green(), builder, Lowercase);
-        appendByteAsHex(blue(), builder, Lowercase);
-        return builder.toString();
-    }
+static char decimalDigit(unsigned number)
+{
+    ASSERT(number < 10);
+    return '0' + number;
+}
 
-    return cssText();
+static std::array<char, 4> fractionDigitsForFractionalAlphaValue(uint8_t alpha)
+{
+    ASSERT(alpha > 0);
+    ASSERT(alpha < 0xFF);
+    if (((alpha * 100 + 0x7F) / 0xFF * 0xFF + 50) / 100 != alpha)
+        return { { decimalDigit(alpha * 10 / 0xFF % 10), decimalDigit(alpha * 100 / 0xFF % 10), decimalDigit((alpha * 1000 + 0x7F) / 0xFF % 10), '\0' } };
+    if (int thirdDigit = (alpha * 100 + 0x7F) / 0xFF % 10)
+        return { { decimalDigit(alpha * 10 / 0xFF), decimalDigit(thirdDigit), '\0', '\0' } };
+    return { { decimalDigit((alpha * 10 + 0x7F) / 0xFF), '\0', '\0', '\0' } };
+}
+
+String SimpleColor::serializationForCSS() const
+{
+    switch (alphaComponent()) {
+    case 0:
+        return makeString("rgba(", redComponent(), ", ", greenComponent(), ", ", blueComponent(), ", 0)");
+    case 0xFF:
+        return makeString("rgb(", redComponent(), ", ", greenComponent(), ", ", blueComponent(), ')');
+    default:
+        return makeString("rgba(", redComponent(), ", ", greenComponent(), ", ", blueComponent(), ", 0.", fractionDigitsForFractionalAlphaValue(alphaComponent()).data(), ')');
+    }
 }
 
 String Color::cssText() const
 {
     if (isExtended())
         return asExtended().cssText();
+    return rgb().serializationForCSS();
+}
 
-    StringBuilder builder;
-    builder.reserveCapacity(28);
-    bool colorHasAlpha = !isOpaque();
-    if (colorHasAlpha)
-        builder.appendLiteral("rgba(");
-    else
-        builder.appendLiteral("rgb(");
-
-    builder.appendNumber(static_cast<unsigned char>(red()));
-    builder.appendLiteral(", ");
-
-    builder.appendNumber(static_cast<unsigned char>(green()));
-    builder.appendLiteral(", ");
-
-
-    builder.appendNumber(static_cast<unsigned char>(blue()));
-    if (colorHasAlpha) {
-        builder.appendLiteral(", ");
-        builder.appendFixedPrecisionNumber(alpha() / 255.0f);
-    }
-
-    builder.append(')');
-    return builder.toString();
+String RGBA32::serializationForRenderTreeAsText() const
+{
+    if (alphaComponent() < 0xFF)
+        return makeString('#', hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2), hex(alphaComponent(), 2));
+    return makeString('#', hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2));
 }
 
 String Color::nameForRenderTreeAsText() const
 {
-    // FIXME: Handle ExtendedColors.
-    if (alpha() < 0xFF)
-        return makeString('#', hex(red(), 2), hex(green(), 2), hex(blue(), 2), hex(alpha(), 2));
-    return makeString('#', hex(red(), 2), hex(green(), 2), hex(blue(), 2));
+    // FIXME: Handle extended colors.
+    return rgb().serializationForRenderTreeAsText();
 }
 
 Color Color::light() const
 {
     // Hardcode this common case for speed.
@@ -605,14 +565,13 @@
     value = max;
 }
 
 Color colorFromPremultipliedARGB(RGBA32 pixelColor)
 {
-    int alpha = alphaChannel(pixelColor);
-    if (alpha && alpha < 255)
-        pixelColor = makeUnPremultipliedRGBA(redChannel(pixelColor), greenChannel(pixelColor), blueChannel(pixelColor), alpha);
-    return Color(pixelColor);
+    if (pixelColor.isVisible() && !pixelColor.isOpaque())
+        return makeUnPremultipliedRGBA(pixelColor.redComponent(), pixelColor.greenComponent(), pixelColor.blueComponent(), pixelColor.alphaComponent());
+    return pixelColor;
 }
 
 RGBA32 premultipliedARGBFromColor(const Color& color)
 {
     if (color.isOpaque()) {
@@ -633,14 +592,13 @@
     // We need to preserve the state of the valid flag at the end of the animation
     if (progress == 1 && !to.isValid())
         return Color();
 
     if (blendPremultiplied) {
-        // Contrary to the name, RGBA32 actually stores ARGB, so we can initialize Color directly from premultipliedARGBFromColor().
-        // Also, premultipliedARGBFromColor() bails on zero alpha, so special-case that.
-        Color premultFrom = from.alpha() ? premultipliedARGBFromColor(from) : 0;
-        Color premultTo = to.alpha() ? premultipliedARGBFromColor(to) : 0;
+        // Since premultipliedARGBFromColor() bails on zero alpha, special-case that.
+        Color premultFrom = from.alpha() ? premultipliedARGBFromColor(from) : Color::transparent;
+        Color premultTo = to.alpha() ? premultipliedARGBFromColor(to) : Color::transparent;
 
         Color premultBlended(blend(premultFrom.red(), premultTo.red(), progress),
             blend(premultFrom.green(), premultTo.green(), progress),
             blend(premultFrom.blue(), premultTo.blue(), progress),
             blend(premultFrom.alpha(), premultTo.alpha(), progress));
@@ -671,17 +629,17 @@
 }
 
 TextStream& operator<<(TextStream& ts, ColorSpace colorSpace)
 {
     switch (colorSpace) {
-    case ColorSpaceSRGB:
+    case ColorSpace::SRGB:
         ts << "sRGB";
         break;
-    case ColorSpaceLinearRGB:
+    case ColorSpace::LinearRGB:
         ts << "LinearRGB";
         break;
-    case ColorSpaceDisplayP3:
+    case ColorSpace::DisplayP3:
         ts << "DisplayP3";
         break;
     }
     return ts;
 }

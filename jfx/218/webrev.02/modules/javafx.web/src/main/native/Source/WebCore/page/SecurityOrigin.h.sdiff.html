<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SecurityOrigin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SecurityOriginData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 71     // example, we don&#39;t include the &quot;jar&quot; scheme, even though Firefox
 72     // understands that &quot;jar&quot; uses an inner URL for it&#39;s security origin.
 73     static bool shouldUseInnerURL(const URL&amp;);
 74     static URL extractInnerURL(const URL&amp;);
 75 
 76     // Create a deep copy of this SecurityOrigin. This method is useful
 77     // when marshalling a SecurityOrigin to another thread.
 78     WEBCORE_EXPORT Ref&lt;SecurityOrigin&gt; isolatedCopy() const;
 79 
 80     // Set the domain property of this security origin to newDomain. This
 81     // function does not check whether newDomain is a suffix of the current
 82     // domain. The caller is responsible for validating newDomain.
 83     void setDomainFromDOM(const String&amp; newDomain);
 84     bool domainWasSetInDOM() const { return m_domainWasSetInDOM; }
 85 
 86     const String&amp; protocol() const { return m_data.protocol; }
 87     const String&amp; host() const { return m_data.host; }
 88     const String&amp; domain() const { return m_domain; }
 89     Optional&lt;uint16_t&gt; port() const { return m_data.port; }
 90 


 91     // Returns true if a given URL is secure, based either directly on its
 92     // own protocol, or, when relevant, on the protocol of its &quot;inner URL&quot;
 93     // Protocols like blob: and filesystem: fall into this latter category.
 94     static bool isSecure(const URL&amp;);
 95 
 96     // Returns true if this SecurityOrigin can script objects in the given
 97     // SecurityOrigin. For example, call this function before allowing
 98     // script from one security origin to read or write objects from
 99     // another SecurityOrigin.
100     WEBCORE_EXPORT bool canAccess(const SecurityOrigin&amp;) const;
101 
102     // Returns true if this SecurityOrigin can read content retrieved from
103     // the given URL. For example, call this function before issuing
104     // XMLHttpRequests.
105     WEBCORE_EXPORT bool canRequest(const URL&amp;) const;
106 
107     // Returns true if this SecurityOrigin can receive drag content from the
108     // initiator. For example, call this function before allowing content to be
109     // dropped onto a target.
110     bool canReceiveDragData(const SecurityOrigin&amp; dragInitiator) const;
</pre>
<hr />
<pre>
194     // For access checks, use canAccess().
195     // FIXME: If this method is really only useful for hash table keys, it
196     // should be refactored into SecurityOriginHash.
197     WEBCORE_EXPORT bool equal(const SecurityOrigin*) const;
198 
199     // This method checks for equality, ignoring the value of document.domain
200     // (and whether it was set) but considering the host. It is used for postMessage.
201     WEBCORE_EXPORT bool isSameSchemeHostPort(const SecurityOrigin&amp;) const;
202 
203     // This method implements the &quot;same origin&quot; algorithm from the HTML Standard:
204     // https://html.spec.whatwg.org/multipage/browsers.html#same-origin
205     WEBCORE_EXPORT bool isSameOriginAs(const SecurityOrigin&amp;) const;
206 
207     // This method implements the &quot;is a registrable domain suffix of or is equal to&quot; algorithm from the HTML Standard:
208     // https://html.spec.whatwg.org/multipage/origin.html#is-a-registrable-domain-suffix-of-or-is-equal-to
209     WEBCORE_EXPORT bool isMatchingRegistrableDomainSuffix(const String&amp;, bool treatIPAddressAsDomain = false) const;
210 
211     bool isPotentiallyTrustworthy() const { return m_isPotentiallyTrustworthy; }
212     void setIsPotentiallyTrustworthy(bool value) { m_isPotentiallyTrustworthy = value; }
213 
<span class="line-modified">214     static bool isLocalHostOrLoopbackIPAddress(StringView);</span>
215 
216     const SecurityOriginData&amp; data() const { return m_data; }
217 
218     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
219     template&lt;class Decoder&gt; static RefPtr&lt;SecurityOrigin&gt; decode(Decoder&amp;);
220 
221 private:
222     SecurityOrigin();
223     explicit SecurityOrigin(const URL&amp;);
224     explicit SecurityOrigin(const SecurityOrigin*);
225 
226     // FIXME: Rename this function to something more semantic.
227     bool passesFileCheck(const SecurityOrigin&amp;) const;
228 
229     // This method checks that the scheme for this origin is an HTTP-family
230     // scheme, e.g. HTTP and HTTPS.
231     bool isHTTPFamily() const { return m_data.protocol == &quot;http&quot; || m_data.protocol == &quot;https&quot;; }
232 
233     enum ShouldAllowFromThirdParty { AlwaysAllowFromThirdParty, MaybeAllowFromThirdParty };
234     WEBCORE_EXPORT bool canAccessStorage(const SecurityOrigin*, ShouldAllowFromThirdParty = MaybeAllowFromThirdParty) const;
</pre>
</td>
<td>
<hr />
<pre>
 71     // example, we don&#39;t include the &quot;jar&quot; scheme, even though Firefox
 72     // understands that &quot;jar&quot; uses an inner URL for it&#39;s security origin.
 73     static bool shouldUseInnerURL(const URL&amp;);
 74     static URL extractInnerURL(const URL&amp;);
 75 
 76     // Create a deep copy of this SecurityOrigin. This method is useful
 77     // when marshalling a SecurityOrigin to another thread.
 78     WEBCORE_EXPORT Ref&lt;SecurityOrigin&gt; isolatedCopy() const;
 79 
 80     // Set the domain property of this security origin to newDomain. This
 81     // function does not check whether newDomain is a suffix of the current
 82     // domain. The caller is responsible for validating newDomain.
 83     void setDomainFromDOM(const String&amp; newDomain);
 84     bool domainWasSetInDOM() const { return m_domainWasSetInDOM; }
 85 
 86     const String&amp; protocol() const { return m_data.protocol; }
 87     const String&amp; host() const { return m_data.host; }
 88     const String&amp; domain() const { return m_domain; }
 89     Optional&lt;uint16_t&gt; port() const { return m_data.port; }
 90 
<span class="line-added"> 91     static bool shouldIgnoreHost(const URL&amp;);</span>
<span class="line-added"> 92 </span>
 93     // Returns true if a given URL is secure, based either directly on its
 94     // own protocol, or, when relevant, on the protocol of its &quot;inner URL&quot;
 95     // Protocols like blob: and filesystem: fall into this latter category.
 96     static bool isSecure(const URL&amp;);
 97 
 98     // Returns true if this SecurityOrigin can script objects in the given
 99     // SecurityOrigin. For example, call this function before allowing
100     // script from one security origin to read or write objects from
101     // another SecurityOrigin.
102     WEBCORE_EXPORT bool canAccess(const SecurityOrigin&amp;) const;
103 
104     // Returns true if this SecurityOrigin can read content retrieved from
105     // the given URL. For example, call this function before issuing
106     // XMLHttpRequests.
107     WEBCORE_EXPORT bool canRequest(const URL&amp;) const;
108 
109     // Returns true if this SecurityOrigin can receive drag content from the
110     // initiator. For example, call this function before allowing content to be
111     // dropped onto a target.
112     bool canReceiveDragData(const SecurityOrigin&amp; dragInitiator) const;
</pre>
<hr />
<pre>
196     // For access checks, use canAccess().
197     // FIXME: If this method is really only useful for hash table keys, it
198     // should be refactored into SecurityOriginHash.
199     WEBCORE_EXPORT bool equal(const SecurityOrigin*) const;
200 
201     // This method checks for equality, ignoring the value of document.domain
202     // (and whether it was set) but considering the host. It is used for postMessage.
203     WEBCORE_EXPORT bool isSameSchemeHostPort(const SecurityOrigin&amp;) const;
204 
205     // This method implements the &quot;same origin&quot; algorithm from the HTML Standard:
206     // https://html.spec.whatwg.org/multipage/browsers.html#same-origin
207     WEBCORE_EXPORT bool isSameOriginAs(const SecurityOrigin&amp;) const;
208 
209     // This method implements the &quot;is a registrable domain suffix of or is equal to&quot; algorithm from the HTML Standard:
210     // https://html.spec.whatwg.org/multipage/origin.html#is-a-registrable-domain-suffix-of-or-is-equal-to
211     WEBCORE_EXPORT bool isMatchingRegistrableDomainSuffix(const String&amp;, bool treatIPAddressAsDomain = false) const;
212 
213     bool isPotentiallyTrustworthy() const { return m_isPotentiallyTrustworthy; }
214     void setIsPotentiallyTrustworthy(bool value) { m_isPotentiallyTrustworthy = value; }
215 
<span class="line-modified">216     WEBCORE_EXPORT static bool isLocalHostOrLoopbackIPAddress(StringView);</span>
217 
218     const SecurityOriginData&amp; data() const { return m_data; }
219 
220     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
221     template&lt;class Decoder&gt; static RefPtr&lt;SecurityOrigin&gt; decode(Decoder&amp;);
222 
223 private:
224     SecurityOrigin();
225     explicit SecurityOrigin(const URL&amp;);
226     explicit SecurityOrigin(const SecurityOrigin*);
227 
228     // FIXME: Rename this function to something more semantic.
229     bool passesFileCheck(const SecurityOrigin&amp;) const;
230 
231     // This method checks that the scheme for this origin is an HTTP-family
232     // scheme, e.g. HTTP and HTTPS.
233     bool isHTTPFamily() const { return m_data.protocol == &quot;http&quot; || m_data.protocol == &quot;https&quot;; }
234 
235     enum ShouldAllowFromThirdParty { AlwaysAllowFromThirdParty, MaybeAllowFromThirdParty };
236     WEBCORE_EXPORT bool canAccessStorage(const SecurityOrigin*, ShouldAllowFromThirdParty = MaybeAllowFromThirdParty) const;
</pre>
</td>
</tr>
</table>
<center><a href="SecurityOrigin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SecurityOriginData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
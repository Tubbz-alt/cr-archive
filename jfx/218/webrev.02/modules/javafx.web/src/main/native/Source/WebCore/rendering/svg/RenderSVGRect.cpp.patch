diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGRect.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGRect.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGRect.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGRect.cpp
@@ -56,28 +56,25 @@
     m_outerStrokeRect = FloatRect();
     clearPath();
     m_usePathFallback = false;
 
     SVGLengthContext lengthContext(&rectElement());
-    FloatSize boundingBoxSize(lengthContext.valueForLength(style().width(), LengthModeWidth), lengthContext.valueForLength(style().height(), LengthModeHeight));
+    FloatSize boundingBoxSize(lengthContext.valueForLength(style().width(), SVGLengthMode::Width), lengthContext.valueForLength(style().height(), SVGLengthMode::Height));
 
-    // Element is invalid if either dimension is negative.
-    if (boundingBoxSize.width() < 0 || boundingBoxSize.height() < 0)
+    // Spec: "A negative value is illegal. A value of zero disables rendering of the element."
+    if (boundingBoxSize.isEmpty())
         return;
 
-    // Rendering enabled? Spec: "A value of zero disables rendering of the element."
-    if (!boundingBoxSize.isEmpty()) {
-        if (rectElement().rx().value(lengthContext) > 0 || rectElement().ry().value(lengthContext) > 0 || hasNonScalingStroke()) {
-            // Fall back to RenderSVGShape
-            RenderSVGShape::updateShapeFromElement();
-            m_usePathFallback = true;
-            return;
-        }
+    if (rectElement().rx().value(lengthContext) > 0 || rectElement().ry().value(lengthContext) > 0 || hasNonScalingStroke()) {
+        // Fall back to RenderSVGShape
+        RenderSVGShape::updateShapeFromElement();
+        m_usePathFallback = true;
+        return;
     }
 
-    m_fillBoundingBox = FloatRect(FloatPoint(lengthContext.valueForLength(style().svgStyle().x(), LengthModeWidth),
-        lengthContext.valueForLength(style().svgStyle().y(), LengthModeHeight)),
+    m_fillBoundingBox = FloatRect(FloatPoint(lengthContext.valueForLength(style().svgStyle().x(), SVGLengthMode::Width),
+        lengthContext.valueForLength(style().svgStyle().y(), SVGLengthMode::Height)),
         boundingBoxSize);
 
     // To decide if the stroke contains a point we create two rects which represent the inner and
     // the outer stroke borders. A stroke contains the point, if the point is between them.
     m_innerStrokeRect = m_fillBoundingBox;

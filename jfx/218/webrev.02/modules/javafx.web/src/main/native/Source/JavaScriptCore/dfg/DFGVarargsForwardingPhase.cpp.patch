diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -39,26 +39,24 @@
 
 namespace JSC { namespace DFG {
 
 namespace {
 
-namespace DFGVarargsForwardingPhaseInternal {
-static const bool verbose = false;
-}
 
 class VarargsForwardingPhase : public Phase {
+    static constexpr bool verbose = false;
 public:
     VarargsForwardingPhase(Graph& graph)
         : Phase(graph, "varargs forwarding")
     {
     }
 
     bool run()
     {
         DFG_ASSERT(m_graph, nullptr, m_graph.m_form != SSA);
 
-        if (DFGVarargsForwardingPhaseInternal::verbose) {
+        if (verbose) {
             dataLog("Graph before varargs forwarding:\n");
             m_graph.dump();
         }
 
         m_changed = false;
@@ -86,11 +84,11 @@
     void handleCandidate(BasicBlock* block, unsigned candidateNodeIndex)
     {
         // We expect calls into this function to be rare. So, this is written in a simple O(n) manner.
 
         Node* candidate = block->at(candidateNodeIndex);
-        if (DFGVarargsForwardingPhaseInternal::verbose)
+        if (verbose)
             dataLog("Handling candidate ", candidate, "\n");
 
         // We eliminate GetButterfly over CreateClonedArguments if the butterfly is only
         // used by a GetByOffset  that loads the CreateClonedArguments's length. We also
         // eliminate it if the GetButterfly node is totally unused.
@@ -103,11 +101,11 @@
         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex < block->size(); ++nodeIndex) {
             Node* node = block->at(nodeIndex);
 
             auto defaultEscape = [&] {
                 if (m_graph.uses(node, candidate)) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("    Escape at ", node, "\n");
                     return true;
                 }
                 return false;
             };
@@ -115,13 +113,14 @@
             bool validGetByOffset = false;
             switch (node->op()) {
             case MovHint:
                 if (node->child1() != candidate)
                     break;
+                ASSERT_WITH_MESSAGE(!node->unlinkedOperand().isTmp(), "We don't currently support a tmp referring to an arguments object.");
                 lastUserIndex = nodeIndex;
-                if (!relevantLocals.contains(node->unlinkedLocal()))
-                    relevantLocals.append(node->unlinkedLocal());
+                if (!relevantLocals.contains(node->unlinkedOperand().virtualRegister()))
+                    relevantLocals.append(node->unlinkedOperand().virtualRegister());
                 break;
 
             case CheckVarargs:
             case Check: {
                 bool sawEscape = false;
@@ -138,38 +137,39 @@
                             return;
 
                         sawEscape = true;
                     });
                 if (sawEscape) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("    Escape at ", node, "\n");
                     return;
                 }
                 break;
             }
 
+            case VarargsLength:
             case LoadVarargs:
                 if (m_graph.uses(node, candidate))
                     lastUserIndex = nodeIndex;
                 break;
 
             case CallVarargs:
             case ConstructVarargs:
             case TailCallVarargs:
             case TailCallVarargsInlinedCaller:
                 if (node->child1() == candidate || node->child2() == candidate) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("    Escape at ", node, "\n");
                     return;
                 }
                 if (node->child2() == candidate)
                     lastUserIndex = nodeIndex;
                 break;
 
             case SetLocal:
                 if (node->child1() == candidate && node->variableAccessData()->isLoadedFrom()) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("    Escape at ", node, "\n");
                     return;
                 }
                 break;
 
@@ -192,11 +192,11 @@
                 if (defaultEscape())
                     return;
                 break;
             }
 
-            case FilterGetByIdStatus:
+            case FilterGetByStatus:
             case FilterPutByIdStatus:
             case FilterCallLinkStatus:
             case FilterInByIdStatus:
                 break;
 
@@ -224,32 +224,32 @@
             }
 
             if (!validGetByOffset) {
                 for (Node* butterfly : candidateButterflies) {
                     if (m_graph.uses(node, butterfly)) {
-                        if (DFGVarargsForwardingPhaseInternal::verbose)
+                        if (verbose)
                             dataLog("    Butterfly escaped at ", node, "\n");
                         return;
                     }
                 }
             }
 
             forAllKilledOperands(
                 m_graph, node, block->tryAt(nodeIndex + 1),
-                [&] (VirtualRegister reg) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
-                        dataLog("    Killing ", reg, " while we are interested in ", listDump(relevantLocals), "\n");
+                [&] (Operand operand) {
+                    if (verbose)
+                        dataLog("    Killing ", operand, " while we are interested in ", listDump(relevantLocals), "\n");
                     for (unsigned i = 0; i < relevantLocals.size(); ++i) {
-                        if (relevantLocals[i] == reg) {
+                        if (operand == relevantLocals[i]) {
                             relevantLocals[i--] = relevantLocals.last();
                             relevantLocals.removeLast();
                             lastUserIndex = nodeIndex;
                         }
                     }
                 });
         }
-        if (DFGVarargsForwardingPhaseInternal::verbose)
+        if (verbose)
             dataLog("Selected lastUserIndex = ", lastUserIndex, ", ", block->at(lastUserIndex), "\n");
 
         // We're still in business. Determine if between the candidate and the last user there is any
         // effect that could interfere with sinking.
         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex <= lastUserIndex; ++nodeIndex) {
@@ -261,29 +261,29 @@
             // what gets read on OSR exit.
             switch (node->op()) {
             case MovHint:
             case ZombieHint:
             case KillStack:
-                if (argumentsInvolveStackSlot(candidate, node->unlinkedLocal())) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                if (argumentsInvolveStackSlot(candidate, node->unlinkedOperand())) {
+                    if (verbose)
                         dataLog("    Interference at ", node, "\n");
                     return;
                 }
                 break;
 
             case PutStack:
-                if (argumentsInvolveStackSlot(candidate, node->stackAccessData()->local)) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                if (argumentsInvolveStackSlot(candidate, node->stackAccessData()->operand)) {
+                    if (verbose)
                         dataLog("    Interference at ", node, "\n");
                     return;
                 }
                 break;
 
             case SetLocal:
             case Flush:
-                if (argumentsInvolveStackSlot(candidate, node->local())) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                if (argumentsInvolveStackSlot(candidate, node->operand())) {
+                    if (verbose)
                         dataLog("    Interference at ", node, "\n");
                     return;
                 }
                 break;
 
@@ -295,25 +295,24 @@
                         if (heap.kind() != Stack) {
                             ASSERT(!heap.overlaps(Stack));
                             return;
                         }
                         ASSERT(!heap.payload().isTop());
-                        VirtualRegister reg(heap.payload().value32());
-                        if (argumentsInvolveStackSlot(candidate, reg))
+                        if (argumentsInvolveStackSlot(candidate, heap.operand()))
                             doesInterfere = true;
                     },
                     NoOpClobberize());
                 if (doesInterfere) {
-                    if (DFGVarargsForwardingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("    Interference at ", node, "\n");
                     return;
                 }
             } }
         }
 
         // We can make this work.
-        if (DFGVarargsForwardingPhaseInternal::verbose)
+        if (verbose)
             dataLog("    Will do forwarding!\n");
         m_changed = true;
 
         // Transform the program.
         switch (candidate->op()) {
@@ -339,12 +338,20 @@
             case MovHint:
             case PutHint:
                 // We don't need to change anything with these.
                 break;
 
+            case VarargsLength: {
+                if (node->argumentsChild() != candidate)
+                    break;
+
+                node->convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node->origin, /* addThis = */ true));
+                break;
+            }
+
             case LoadVarargs:
-                if (node->child1() != candidate)
+                if (node->argumentsChild() != candidate)
                     break;
                 node->setOpAndDefaultFlags(ForwardVarargs);
                 break;
 
             case CallVarargs:
@@ -386,11 +393,11 @@
                     node->remove(m_graph);
                 }
                 break;
             }
 
-            case FilterGetByIdStatus:
+            case FilterGetByStatus:
             case FilterPutByIdStatus:
             case FilterCallLinkStatus:
             case FilterInByIdStatus:
                 if (node->child1().node() == candidate)
                     node->remove(m_graph);
@@ -412,11 +419,11 @@
                         emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node->origin));
                 }
                 break;
 
             default:
-                if (ASSERT_DISABLED)
+                if (!ASSERT_ENABLED)
                     break;
                 m_graph.doToChildren(
                     node,
                     [&] (Edge edge) {
                         DFG_ASSERT(m_graph, node, edge != candidate);

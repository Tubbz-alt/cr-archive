<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPropertyResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLPropertyResolver.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;WHLSLAST.h&quot;</span>
<span class="line-modified"> 32 #include &quot;WHLSLProgram.h&quot;</span>











 33 #include &quot;WHLSLReplaceWith.h&quot;
<a name="2" id="anc2"></a>

 34 #include &quot;WHLSLVisitor.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 namespace WHLSL {
 39 
 40 class PropertyResolver : public Visitor {
<a name="3" id="anc3"></a><span class="line-modified"> 41     void handleLeftHandSideBase(UniqueRef&lt;AST::Expression&gt; base, UniqueRef&lt;AST::Expression&gt;&amp; slot, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)</span>
<span class="line-modified"> 42     {</span>
<span class="line-modified"> 43         if (!base-&gt;mayBeEffectful()) {</span>
<span class="line-modified"> 44             slot = WTFMove(base);</span>
<span class="line-modified"> 45             return;</span>
<span class="line-modified"> 46         }</span>





















 47 
<a name="4" id="anc4"></a><span class="line-modified"> 48         auto leftAddressSpace = base-&gt;typeAnnotation().leftAddressSpace();</span>
<span class="line-modified"> 49         RELEASE_ASSERT(leftAddressSpace);</span>
<span class="line-modified"> 50         CodeLocation codeLocation = base-&gt;codeLocation();</span>
<span class="line-modified"> 51         Ref&lt;AST::UnnamedType&gt; baseType = base-&gt;resolvedType();</span>
<span class="line-modified"> 52         Ref&lt;AST::PointerType&gt; pointerType = AST::PointerType::create(codeLocation, *leftAddressSpace, baseType.copyRef());</span>

 53 
<a name="5" id="anc5"></a><span class="line-modified"> 54         UniqueRef&lt;AST::VariableDeclaration&gt; pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(codeLocation, AST::Qualifiers { }, pointerType.ptr(), String(), nullptr, nullptr);</span>



 55 
<a name="6" id="anc6"></a><span class="line-modified"> 56         auto makeVariableReference = [&amp;] {</span>
<span class="line-modified"> 57             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-modified"> 58             variableReference-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified"> 59             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-modified"> 60             return variableReference;</span>
<span class="line-added"> 61         };</span>
 62 
<a name="7" id="anc7"></a><span class="line-modified"> 63         {</span>
<span class="line-modified"> 64             auto pointerOfBase = makeUniqueRef&lt;AST::MakePointerExpression&gt;(codeLocation, WTFMove(base), AST::AddressEscapeMode::DoesNotEscape);</span>
<span class="line-modified"> 65             pointerOfBase-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified"> 66             pointerOfBase-&gt;setTypeAnnotation(AST::RightValue());</span>
















 67 
<a name="8" id="anc8"></a><span class="line-modified"> 68             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(codeLocation, makeVariableReference(), WTFMove(pointerOfBase));</span>
<span class="line-modified"> 69             assignment-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified"> 70             assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
 71 
<a name="9" id="anc9"></a><span class="line-modified"> 72             expressions.append(WTFMove(assignment));</span>
<span class="line-modified"> 73         }</span>

 74 
<a name="10" id="anc10"></a><span class="line-modified"> 75         {</span>
<span class="line-modified"> 76             auto dereference = makeUniqueRef&lt;AST::DereferenceExpression&gt;(codeLocation, makeVariableReference());</span>
<span class="line-modified"> 77             dereference-&gt;setType(baseType.copyRef());</span>
<span class="line-added"> 78             dereference-&gt;setTypeAnnotation(AST::LeftValue { *leftAddressSpace });</span>
 79 
<a name="11" id="anc11"></a><span class="line-modified"> 80             slot = WTFMove(dereference);</span>
<span class="line-modified"> 81         }</span>


 82 
<a name="12" id="anc12"></a><span class="line-modified"> 83         m_variables.append(WTFMove(pointerVariable));</span>






 84     }
<a name="13" id="anc13"></a>

 85 
<a name="14" id="anc14"></a><span class="line-modified"> 86     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)</span>
<span class="line-modified"> 87     {</span>
<span class="line-modified"> 88         AST::PropertyAccessExpression* currentPtr = &amp;propertyAccess;</span>
<span class="line-modified"> 89         // a.b[c].d will go into this array as [.d, [c], .b]</span>
<span class="line-modified"> 90         Vector&lt;std::reference_wrapper&lt;AST::PropertyAccessExpression&gt;&gt; chain;</span>
<span class="line-modified"> 91 </span>
<span class="line-modified"> 92         while (true) {</span>
<span class="line-modified"> 93             AST::PropertyAccessExpression&amp; current = *currentPtr;</span>
<span class="line-modified"> 94             chain.append(current);</span>
<span class="line-modified"> 95             if (is&lt;AST::IndexExpression&gt;(current))</span>
<span class="line-modified"> 96                 checkErrorAndVisit(downcast&lt;AST::IndexExpression&gt;(current).indexExpression());</span>
<span class="line-modified"> 97             if (!is&lt;AST::PropertyAccessExpression&gt;(current.base()))</span>
<span class="line-modified"> 98                 break;</span>
<span class="line-modified"> 99             currentPtr = &amp;downcast&lt;AST::PropertyAccessExpression&gt;(current.base());</span>
<span class="line-modified">100         }</span>
101 
<a name="15" id="anc15"></a><span class="line-modified">102         AST::PropertyAccessExpression&amp; current = *currentPtr;</span>






































103 
<a name="16" id="anc16"></a><span class="line-modified">104         checkErrorAndVisit(current.base());</span>

105 
<a name="17" id="anc17"></a><span class="line-modified">106         CodeLocation baseCodeLocation = current.base().codeLocation();</span>



107 
<a name="18" id="anc18"></a><span class="line-modified">108         if (current.base().typeAnnotation().isRightValue()) {</span>
<span class="line-modified">109             UniqueRef&lt;AST::VariableDeclaration&gt; copy = makeUniqueRef&lt;AST::VariableDeclaration&gt;(baseCodeLocation, AST::Qualifiers { }, &amp;current.base().resolvedType(), String(), nullptr, nullptr);</span>
<span class="line-modified">110             Ref&lt;AST::UnnamedType&gt; baseType = current.base().resolvedType();</span>

111 
<a name="19" id="anc19"></a><span class="line-modified">112             auto makeVariableReference = [&amp;] {</span>
<span class="line-modified">113                 auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(copy));</span>
<span class="line-modified">114                 variableReference-&gt;setType(baseType.copyRef());</span>
<span class="line-added">115                 variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-added">116                 return variableReference;</span>
<span class="line-added">117             };</span>
118 
<a name="20" id="anc20"></a><span class="line-modified">119             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), current.takeBase());</span>
<span class="line-modified">120             assignment-&gt;setType(baseType.copyRef());</span>
<span class="line-added">121             assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
122 
<a name="21" id="anc21"></a><span class="line-modified">123             expressions.append(WTFMove(assignment));</span>



































124 
<a name="22" id="anc22"></a><span class="line-modified">125             current.baseReference() = makeVariableReference();</span>

126 
<a name="23" id="anc23"></a><span class="line-modified">127             m_variables.append(WTFMove(copy));</span>
<span class="line-modified">128         } else</span>
<span class="line-modified">129             handleLeftHandSideBase(current.takeBase(), current.baseReference(), expressions);</span>
130 
<a name="24" id="anc24"></a><span class="line-modified">131         for (size_t i = chain.size(); i--; ) {</span>
<span class="line-modified">132             auto&amp; access = chain[i].get();</span>
<span class="line-modified">133             if (is&lt;AST::IndexExpression&gt;(access) &amp;&amp; downcast&lt;AST::IndexExpression&gt;(access).indexExpression().mayBeEffectful()) {</span>
<span class="line-modified">134                 auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(access);</span>
135 
<a name="25" id="anc25"></a><span class="line-modified">136                 Ref&lt;AST::UnnamedType&gt; indexType = indexExpression.indexExpression().resolvedType();</span>

137 
<a name="26" id="anc26"></a><span class="line-modified">138                 UniqueRef&lt;AST::VariableDeclaration&gt; indexVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(access.codeLocation(), AST::Qualifiers { }, indexType.ptr(), String(), nullptr, nullptr);</span>






























139 
<a name="27" id="anc27"></a><span class="line-modified">140                 auto makeVariableReference = [&amp;] {</span>
<span class="line-added">141                     auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(indexVariable));</span>
<span class="line-added">142                     variableReference-&gt;setType(indexType.copyRef());</span>
<span class="line-added">143                     variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-added">144                     return variableReference;</span>
<span class="line-added">145                 };</span>
146 
<a name="28" id="anc28"></a><span class="line-added">147                 {</span>
<span class="line-added">148                     auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), indexExpression.takeIndex());</span>
<span class="line-added">149                     assignment-&gt;setType(indexType.copyRef());</span>
<span class="line-added">150                     assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
151 
<a name="29" id="anc29"></a><span class="line-modified">152                     expressions.append(WTFMove(assignment));</span>
<span class="line-modified">153                 }</span>





















154 
<a name="30" id="anc30"></a><span class="line-modified">155                 indexExpression.indexReference() = makeVariableReference();</span>
<span class="line-modified">156 </span>
<span class="line-modified">157                 m_variables.append(WTFMove(indexVariable));</span>
<span class="line-modified">158             }</span>






















159         }
<a name="31" id="anc31"></a>

160     }
161 
<a name="32" id="anc32"></a><span class="line-modified">162     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess)</span>


163     {
<a name="33" id="anc33"></a><span class="line-modified">164         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>















































165 
<a name="34" id="anc34"></a><span class="line-modified">166         handlePropertyAccess(propertyAccess, expressions);</span>


167 
<a name="35" id="anc35"></a><span class="line-modified">168         Ref&lt;AST::UnnamedType&gt; accessType = propertyAccess.resolvedType();</span>





169 
<a name="36" id="anc36"></a><span class="line-modified">170         AST::CommaExpression* comma;</span>
<span class="line-added">171         CodeLocation codeLocation = propertyAccess.codeLocation();</span>
<span class="line-added">172         if (is&lt;AST::IndexExpression&gt;(propertyAccess)) {</span>
<span class="line-added">173             auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccess);</span>
174 
<a name="37" id="anc37"></a><span class="line-modified">175             auto newIndexExpression = makeUniqueRef&lt;AST::IndexExpression&gt;(codeLocation, indexExpression.takeBase(), indexExpression.takeIndex());</span>
<span class="line-modified">176             newIndexExpression-&gt;setType(indexExpression.resolvedType());</span>
<span class="line-added">177             newIndexExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(indexExpression.typeAnnotation()));</span>
178 
<a name="38" id="anc38"></a><span class="line-modified">179             expressions.append(WTFMove(newIndexExpression));</span>



180 
<a name="39" id="anc39"></a><span class="line-modified">181             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(indexExpression, codeLocation, WTFMove(expressions));</span>
<span class="line-modified">182         } else {</span>
<span class="line-modified">183             RELEASE_ASSERT(is&lt;AST::DotExpression&gt;(propertyAccess));</span>
<span class="line-added">184             auto&amp; dotExpression = downcast&lt;AST::DotExpression&gt;(propertyAccess);</span>
185 
<a name="40" id="anc40"></a><span class="line-modified">186             auto newDotExpression = makeUniqueRef&lt;AST::DotExpression&gt;(codeLocation, dotExpression.takeBase(), String(dotExpression.fieldName()));</span>
<span class="line-added">187             newDotExpression-&gt;setType(dotExpression.resolvedType());</span>
<span class="line-added">188             newDotExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(dotExpression.typeAnnotation()));</span>
189 
<a name="41" id="anc41"></a><span class="line-modified">190             expressions.append(WTFMove(newDotExpression));</span>
























191 
<a name="42" id="anc42"></a><span class="line-modified">192             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(dotExpression, codeLocation, WTFMove(expressions));</span>
<span class="line-added">193         }</span>
194 
<a name="43" id="anc43"></a><span class="line-modified">195         comma-&gt;setType(WTFMove(accessType));</span>
<span class="line-modified">196         comma-&gt;setTypeAnnotation(AST::RightValue());</span>


197     }
198 
<a name="44" id="anc44"></a><span class="line-modified">199 public:</span>
<span class="line-added">200     void visit(AST::DotExpression&amp; dotExpression) override</span>
201     {
<a name="45" id="anc45"></a><span class="line-modified">202         handlePropertyAccess(dotExpression);</span>























203     }
204 
<a name="46" id="anc46"></a><span class="line-modified">205     void visit(AST::IndexExpression&amp; indexExpression) override</span>
<span class="line-modified">206     {</span>
<span class="line-modified">207         handlePropertyAccess(indexExpression);</span>






208     }
<a name="47" id="anc47"></a>


209 
<a name="48" id="anc48"></a><span class="line-modified">210     void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override</span>
<span class="line-modified">211     {</span>
<span class="line-modified">212         checkErrorAndVisit(readModifyWrite.newValueExpression());</span>
<span class="line-modified">213         checkErrorAndVisit(readModifyWrite.resultExpression());</span>





































214 
215         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
216 
<a name="49" id="anc49"></a><span class="line-modified">217         CodeLocation codeLocation = readModifyWrite.codeLocation();</span>







218 
<a name="50" id="anc50"></a><span class="line-modified">219         Ref&lt;AST::UnnamedType&gt; type = readModifyWrite.resolvedType();</span>


220 
<a name="51" id="anc51"></a><span class="line-modified">221         if (is&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()))</span>
<span class="line-modified">222             handlePropertyAccess(downcast&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()), expressions);</span>
<span class="line-added">223         else</span>
<span class="line-added">224             handleLeftHandSideBase(readModifyWrite.takeLeftValue(), readModifyWrite.leftValueReference(), expressions);</span>
225 
226         {
<a name="52" id="anc52"></a><span class="line-modified">227             UniqueRef&lt;AST::ReadModifyWriteExpression&gt; newReadModifyWrite = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(</span>
<span class="line-modified">228                 readModifyWrite.codeLocation(), readModifyWrite.takeLeftValue(), readModifyWrite.takeOldValue(), readModifyWrite.takeNewValue());</span>
<span class="line-modified">229             newReadModifyWrite-&gt;setNewValueExpression(readModifyWrite.takeNewValueExpression());</span>
<span class="line-modified">230             newReadModifyWrite-&gt;setResultExpression(readModifyWrite.takeResultExpression());</span>
<span class="line-modified">231             newReadModifyWrite-&gt;setType(type.copyRef());</span>
<span class="line-modified">232             newReadModifyWrite-&gt;setTypeAnnotation(AST::TypeAnnotation(readModifyWrite.typeAnnotation()));</span>
<span class="line-modified">233 </span>
<span class="line-modified">234             expressions.append(WTFMove(newReadModifyWrite));</span>










































235         }
236 
<a name="53" id="anc53"></a><span class="line-modified">237         auto* comma = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWrite, codeLocation, WTFMove(expressions));</span>
<span class="line-modified">238         comma-&gt;setType(WTFMove(type));</span>
<span class="line-modified">239         comma-&gt;setTypeAnnotation(AST::RightValue());</span>












240     }
241 
<a name="54" id="anc54"></a><span class="line-modified">242     void visit(AST::FunctionDefinition&amp; functionDefinition) override</span>
<span class="line-modified">243     {</span>
<span class="line-modified">244         RELEASE_ASSERT(m_variables.isEmpty());</span>





















245 
<a name="55" id="anc55"></a><span class="line-modified">246         checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));</span>
<span class="line-modified">247         checkErrorAndVisit(functionDefinition.block());</span>


248 
<a name="56" id="anc56"></a><span class="line-modified">249         if (!m_variables.isEmpty()) {</span>
<span class="line-added">250             functionDefinition.block().statements().insert(0,</span>
<span class="line-added">251                 makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.block().codeLocation(), WTFMove(m_variables)));</span>
252         }
<a name="57" id="anc57"></a>








































































253     }
<a name="58" id="anc58"></a>



254 
<a name="59" id="anc59"></a>
255 private:
<a name="60" id="anc60"></a><span class="line-modified">256     AST::VariableDeclarations m_variables;</span>




257 };
258 
<a name="61" id="anc61"></a>





















































259 void resolveProperties(Program&amp; program)
260 {
<a name="62" id="anc62"></a><span class="line-modified">261     // The goal of this phase is two allow two things:</span>
<span class="line-added">262     // 1. For property access expressions, metal codegen should be allowed to evaluate</span>
<span class="line-added">263     // the base, and if it&#39;s an index expression, the index, as many times as needed.</span>
<span class="line-added">264     // So this patch ensures that if Metal evaluates such things, effects aren&#39;t performed</span>
<span class="line-added">265     // more than once.</span>
<span class="line-added">266     //</span>
<span class="line-added">267     // 2. For ReadModifyWrite expressions, metal codegen should be able to evaluate the</span>
<span class="line-added">268     // leftValueExpression as many times as it&#39;d like without performing the effects of</span>
<span class="line-added">269     // leftValueExpression more than once.</span>
<span class="line-added">270     //</span>
<span class="line-added">271     // We do these things because it&#39;s convenient for metal codegen to be able to rely on</span>
<span class="line-added">272     // this with the way it structures the generated code.</span>
<span class="line-added">273     PropertyResolver resolver;</span>
<span class="line-added">274     for (auto&amp; function : program.functionDefinitions())</span>
<span class="line-added">275         resolver.visit(function);</span>
276 }
277 
278 } // namespace WHLSL
279 
280 } // namespace WebCore
281 
282 #endif // ENABLE(WEBGPU)
<a name="63" id="anc63"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="63" type="hidden" />
</body>
</html>
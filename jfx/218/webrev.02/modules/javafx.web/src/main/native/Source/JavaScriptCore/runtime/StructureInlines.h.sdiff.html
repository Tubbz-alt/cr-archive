<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StructureIDTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureRareData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSArrayBufferView.h&quot;
 29 #include &quot;JSCJSValueInlines.h&quot;
 30 #include &quot;JSGlobalObject.h&quot;
 31 #include &quot;PropertyMapHashTable.h&quot;
 32 #include &quot;Structure.h&quot;
 33 #include &quot;StructureChain.h&quot;
 34 #include &quot;StructureRareDataInlines.h&quot;

 35 
 36 namespace JSC {
 37 
 38 inline Structure* Structure::create(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 39 {
 40     ASSERT(vm.structureStructure);
 41     ASSERT(classInfo);
 42     if (auto* object = prototype.getObject()) {
 43         ASSERT(!object-&gt;anyObjectInChainMayInterceptIndexedAccesses(vm) || hasSlowPutArrayStorage(indexingType) || !hasIndexedProperties(indexingType));
 44         object-&gt;didBecomePrototype();
 45     }
 46 
 47     Structure* structure = new (NotNull, allocateCell&lt;Structure&gt;(vm.heap)) Structure(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
 48     structure-&gt;finishCreation(vm);
 49     return structure;
 50 }
 51 
 52 inline Structure* Structure::createStructure(VM&amp; vm)
 53 {
 54     ASSERT(!vm.structureStructure);
</pre>
<hr />
<pre>
 91 inline JSObject* Structure::storedPrototypeObject() const
 92 {
 93     ASSERT(hasMonoProto());
 94     JSValue value = m_prototype.get();
 95     if (value.isNull())
 96         return nullptr;
 97     return asObject(value);
 98 }
 99 
100 inline Structure* Structure::storedPrototypeStructure() const
101 {
102     ASSERT(hasMonoProto());
103     JSObject* object = storedPrototypeObject();
104     if (!object)
105         return nullptr;
106     return object-&gt;structure();
107 }
108 
109 ALWAYS_INLINE JSValue Structure::storedPrototype(const JSObject* object) const
110 {
<span class="line-modified">111     ASSERT(!isMainThread() || object-&gt;structure() == this);</span>
112     if (hasMonoProto())
113         return storedPrototype();
114     return object-&gt;getDirect(knownPolyProtoOffset);
115 }
116 
117 ALWAYS_INLINE JSObject* Structure::storedPrototypeObject(const JSObject* object) const
118 {
<span class="line-modified">119     ASSERT(!isMainThread() || object-&gt;structure() == this);</span>
120     if (hasMonoProto())
121         return storedPrototypeObject();
122     JSValue proto = object-&gt;getDirect(knownPolyProtoOffset);
123     if (proto.isNull())
124         return nullptr;
125     return asObject(proto);
126 }
127 
128 ALWAYS_INLINE Structure* Structure::storedPrototypeStructure(const JSObject* object) const
129 {
130     if (JSObject* proto = storedPrototypeObject(object))
131         return proto-&gt;structure();
132     return nullptr;
133 }
134 
135 ALWAYS_INLINE PropertyOffset Structure::get(VM&amp; vm, PropertyName propertyName)
136 {
137     unsigned attributes;
138     return get(vm, propertyName, attributes);
139 }
140 
141 ALWAYS_INLINE PropertyOffset Structure::get(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes)
142 {
143     ASSERT(!isCompilationThread());
144     ASSERT(structure(vm)-&gt;classInfo() == info());
145 



146     PropertyTable* propertyTable = ensurePropertyTableIfNotEmpty(vm);
147     if (!propertyTable)
148         return invalidOffset;
149 
150     PropertyMapEntry* entry = propertyTable-&gt;get(propertyName.uid());
151     if (!entry)
152         return invalidOffset;
153 
154     attributes = entry-&gt;attributes;
155     return entry-&gt;offset;
156 }
157 
158 template&lt;typename Functor&gt;
159 void Structure::forEachPropertyConcurrently(const Functor&amp; functor)
160 {
161     Vector&lt;Structure*, 8&gt; structures;
<span class="line-modified">162     Structure* structure;</span>
163     PropertyTable* table;
164 
<span class="line-modified">165     findStructuresAndMapForMaterialization(structures, structure, table);</span>


















166 
167     if (table) {
168         for (auto&amp; entry : *table) {



169             if (!functor(entry)) {
<span class="line-modified">170                 structure-&gt;m_lock.unlock();</span>
171                 return;
172             }
173         }
<span class="line-modified">174         structure-&gt;m_lock.unlock();</span>
<span class="line-removed">175     }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177     for (unsigned i = structures.size(); i--;) {</span>
<span class="line-removed">178         structure = structures[i];</span>
<span class="line-removed">179         if (!structure-&gt;m_nameInPrevious)</span>
<span class="line-removed">180             continue;</span>
<span class="line-removed">181 </span>
<span class="line-removed">182         if (!functor(PropertyMapEntry(structure-&gt;m_nameInPrevious.get(), structure-&gt;m_offset, structure-&gt;attributesInPrevious())))</span>
<span class="line-removed">183             return;</span>
184     }
185 }
186 
187 template&lt;typename Functor&gt;
188 void Structure::forEachProperty(VM&amp; vm, const Functor&amp; functor)
189 {
190     if (PropertyTable* table = ensurePropertyTableIfNotEmpty(vm)) {
191         for (auto&amp; entry : *table) {
192             if (!functor(entry))
193                 return;
194         }
195     }
196 }
197 
198 inline PropertyOffset Structure::getConcurrently(UniquedStringImpl* uid)
199 {
200     unsigned attributesIgnored;
201     return getConcurrently(uid, attributesIgnored);
202 }
203 
</pre>
<hr />
<pre>
280 
281 inline JSValue Structure::prototypeForLookup(JSGlobalObject* globalObject, JSCell* base) const
282 {
283     ASSERT(base-&gt;structure() == this);
284     if (isObject())
285         return storedPrototype(asObject(base));
286     return prototypeForLookupPrimitiveImpl(globalObject, this);
287 }
288 
289 inline StructureChain* Structure::prototypeChain(VM&amp; vm, JSGlobalObject* globalObject, JSObject* base) const
290 {
291     ASSERT(base-&gt;structure(vm) == this);
292     // We cache our prototype chain so our clients can share it.
293     if (!isValid(globalObject, m_cachedPrototypeChain.get(), base)) {
294         JSValue prototype = prototypeForLookup(globalObject, base);
295         m_cachedPrototypeChain.set(vm, this, StructureChain::create(vm, prototype.isNull() ? nullptr : asObject(prototype)));
296     }
297     return m_cachedPrototypeChain.get();
298 }
299 
<span class="line-modified">300 inline StructureChain* Structure::prototypeChain(ExecState* exec, JSObject* base) const</span>
301 {
<span class="line-modified">302     return prototypeChain(exec-&gt;vm(), exec-&gt;lexicalGlobalObject(), base);</span>
303 }
304 
305 inline bool Structure::isValid(JSGlobalObject* globalObject, StructureChain* cachedPrototypeChain, JSObject* base) const
306 {
307     if (!cachedPrototypeChain)
308         return false;
309 
310     VM&amp; vm = globalObject-&gt;vm();
311     JSValue prototype = prototypeForLookup(globalObject, base);
<span class="line-modified">312     WriteBarrier&lt;Structure&gt;* cachedStructure = cachedPrototypeChain-&gt;head();</span>
313     while (*cachedStructure &amp;&amp; !prototype.isNull()) {
<span class="line-modified">314         if (asObject(prototype)-&gt;structure(vm) != cachedStructure-&gt;get())</span>
315             return false;
316         ++cachedStructure;
317         prototype = asObject(prototype)-&gt;getPrototypeDirect(vm);
318     }
319     return prototype.isNull() &amp;&amp; !*cachedStructure;
320 }
321 
322 inline void Structure::didReplaceProperty(PropertyOffset offset)
323 {
324     if (LIKELY(!hasRareData()))
325         return;
326     StructureRareData::PropertyWatchpointMap* map = rareData()-&gt;m_replacementWatchpointSets.get();
327     if (LIKELY(!map))
328         return;
329     WatchpointSet* set = map-&gt;get(offset);
330     if (LIKELY(!set))
331         return;
332     set-&gt;fireAll(vm(), &quot;Property did get replaced&quot;);
333 }
334 
</pre>
<hr />
<pre>
343         return nullptr;
344     return map-&gt;get(offset);
345 }
346 
347 template&lt;typename DetailsFunc&gt;
348 ALWAYS_INLINE bool Structure::checkOffsetConsistency(PropertyTable* propertyTable, const DetailsFunc&amp; detailsFunc) const
349 {
350     // We cannot reliably assert things about the property table in the concurrent
351     // compilation thread. It is possible for the table to be stolen and then have
352     // things added to it, which leads to the offsets being all messed up. We could
353     // get around this by grabbing a lock here, but I think that would be overkill.
354     if (isCompilationThread())
355         return true;
356 
357     unsigned totalSize = propertyTable-&gt;propertyStorageSize();
358     unsigned inlineOverflowAccordingToTotalSize = totalSize &lt; m_inlineCapacity ? 0 : totalSize - m_inlineCapacity;
359 
360     auto fail = [&amp;] (const char* description) {
361         dataLog(&quot;Detected offset inconsistency: &quot;, description, &quot;!\n&quot;);
362         dataLog(&quot;this = &quot;, RawPointer(this), &quot;\n&quot;);
<span class="line-modified">363         dataLog(&quot;m_offset = &quot;, m_offset, &quot;\n&quot;);</span>

364         dataLog(&quot;m_inlineCapacity = &quot;, m_inlineCapacity, &quot;\n&quot;);
365         dataLog(&quot;propertyTable = &quot;, RawPointer(propertyTable), &quot;\n&quot;);
<span class="line-modified">366         dataLog(&quot;numberOfSlotsForLastOffset = &quot;, numberOfSlotsForLastOffset(m_offset, m_inlineCapacity), &quot;\n&quot;);</span>
367         dataLog(&quot;totalSize = &quot;, totalSize, &quot;\n&quot;);
368         dataLog(&quot;inlineOverflowAccordingToTotalSize = &quot;, inlineOverflowAccordingToTotalSize, &quot;\n&quot;);
<span class="line-modified">369         dataLog(&quot;numberOfOutOfLineSlotsForLastOffset = &quot;, numberOfOutOfLineSlotsForLastOffset(m_offset), &quot;\n&quot;);</span>
370         detailsFunc();
371         UNREACHABLE_FOR_PLATFORM();
372     };
373 
<span class="line-modified">374     if (numberOfSlotsForLastOffset(m_offset, m_inlineCapacity) != totalSize)</span>
<span class="line-modified">375         fail(&quot;numberOfSlotsForLastOffset doesn&#39;t match totalSize&quot;);</span>
<span class="line-modified">376     if (inlineOverflowAccordingToTotalSize != numberOfOutOfLineSlotsForLastOffset(m_offset))</span>
<span class="line-modified">377         fail(&quot;inlineOverflowAccordingToTotalSize doesn&#39;t match numberOfOutOfLineSlotsForLastOffset&quot;);</span>
378 
379     return true;
380 }
381 
382 ALWAYS_INLINE bool Structure::checkOffsetConsistency() const
383 {
384     PropertyTable* propertyTable = propertyTableOrNull();
385 
386     if (!propertyTable) {
387         ASSERT(!isPinnedPropertyTable());
388         return true;
389     }
390 
391     // We cannot reliably assert things about the property table in the concurrent
392     // compilation thread. It is possible for the table to be stolen and then have
393     // things added to it, which leads to the offsets being all messed up. We could
394     // get around this by grabbing a lock here, but I think that would be overkill.
395     if (isCompilationThread())
396         return true;
397 
398     return checkOffsetConsistency(propertyTable, [] () { });
399 }
400 
401 inline void Structure::checkConsistency()
402 {
403     checkOffsetConsistency();
404 }
405 
406 inline size_t nextOutOfLineStorageCapacity(size_t currentCapacity)
407 {
408     if (!currentCapacity)
409         return initialOutOfLineCapacity;
410     return currentCapacity * outOfLineGrowthFactor;
411 }
412 
<span class="line-modified">413 inline void Structure::setObjectToStringValue(ExecState* exec, VM&amp; vm, JSString* value, PropertySlot toStringTagSymbolSlot)</span>
414 {
415     if (!hasRareData())
416         allocateRareData(vm);
<span class="line-modified">417     rareData()-&gt;setObjectToStringValue(exec, vm, this, value, toStringTagSymbolSlot);</span>
418 }
419 
420 template&lt;Structure::ShouldPin shouldPin, typename Func&gt;
421 inline PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
422 {
423     PropertyTable* table = ensurePropertyTable(vm);
424 
425     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
426 
427     switch (shouldPin) {
428     case ShouldPin::Yes:
429         pin(locker, vm, table);
430         break;
431     case ShouldPin::No:
432         setPropertyTable(vm, table);
433         break;
434     }
435 
436     ASSERT(!JSC::isValidOffset(get(vm, propertyName)));
437 
438     checkConsistency();
439     if (attributes &amp; PropertyAttribute::DontEnum || propertyName.isSymbol())
440         setIsQuickPropertyAccessAllowedForEnumeration(false);
441     if (propertyName == vm.propertyNames-&gt;underscoreProto)
442         setHasUnderscoreProtoPropertyExcludingOriginalProto(true);
443 
444     auto rep = propertyName.uid();
445 
446     PropertyOffset newOffset = table-&gt;nextOffset(m_inlineCapacity);
447 
448     m_propertyHash = m_propertyHash ^ rep-&gt;existingSymbolAwareHash();

449 
<span class="line-modified">450     PropertyOffset newLastOffset = m_offset;</span>
<span class="line-modified">451     table-&gt;add(PropertyMapEntry(rep, newOffset, attributes), newLastOffset, PropertyTable::PropertyOffsetMayChange);</span>


452 
<span class="line-modified">453     func(locker, newOffset, newLastOffset);</span>
454 
<span class="line-modified">455     ASSERT(m_offset == newLastOffset);</span>
456 
457     checkConsistency();
458     return newOffset;
459 }
460 
<span class="line-modified">461 template&lt;typename Func&gt;</span>
<span class="line-modified">462 inline PropertyOffset Structure::remove(PropertyName propertyName, const Func&amp; func)</span>
463 {
<span class="line-modified">464     ConcurrentJSLocker locker(m_lock);</span>

465 
<span class="line-modified">466     checkConsistency();</span>







467 
<span class="line-modified">468     auto rep = propertyName.uid();</span>
469 
<span class="line-modified">470     // We ONLY remove from uncacheable dictionaries, which will have a pinned property table.</span>
<span class="line-removed">471     // The only way for them not to have a table is if they are empty.</span>
<span class="line-removed">472     PropertyTable* table = propertyTableOrNull();</span>
473 
<span class="line-modified">474     if (!table)</span>
<span class="line-removed">475         return invalidOffset;</span>
476 
477     PropertyTable::find_iterator position = table-&gt;find(rep);
478     if (!position.first)
479         return invalidOffset;
480 


481     PropertyOffset offset = position.first-&gt;offset;
482 
483     table-&gt;remove(position);
484     table-&gt;addDeletedOffset(offset);
485 
<span class="line-modified">486     checkConsistency();</span>


487 
<span class="line-modified">488     func(locker, offset);</span>



489     return offset;
490 }
491 
492 template&lt;typename Func&gt;
493 inline PropertyOffset Structure::addPropertyWithoutTransition(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
494 {
495     return add&lt;ShouldPin::Yes&gt;(vm, propertyName, attributes, func);
496 }
497 
498 template&lt;typename Func&gt;
<span class="line-modified">499 inline PropertyOffset Structure::removePropertyWithoutTransition(VM&amp;, PropertyName propertyName, const Func&amp; func)</span>
500 {
501     ASSERT(isUncacheableDictionary());
502     ASSERT(isPinnedPropertyTable());
503     ASSERT(propertyTableOrNull());
504 
<span class="line-modified">505     return remove(propertyName, func);</span>
506 }
507 
508 ALWAYS_INLINE void Structure::setPrototypeWithoutTransition(VM&amp; vm, JSValue prototype)
509 {
510     ASSERT(isValidPrototype(prototype));
511     m_prototype.set(vm, this, prototype);
512 }
513 
514 ALWAYS_INLINE void Structure::setGlobalObject(VM&amp; vm, JSGlobalObject* globalObject)
515 {
516     m_globalObject.set(vm, this, globalObject);
517 }
518 
519 ALWAYS_INLINE void Structure::setPropertyTable(VM&amp; vm, PropertyTable* table)
520 {
521     m_propertyTableUnsafe.setMayBeNull(vm, this, table);
522 }
523 
524 ALWAYS_INLINE void Structure::setPreviousID(VM&amp; vm, Structure* structure)
525 {
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSArrayBufferView.h&quot;
 29 #include &quot;JSCJSValueInlines.h&quot;
 30 #include &quot;JSGlobalObject.h&quot;
 31 #include &quot;PropertyMapHashTable.h&quot;
 32 #include &quot;Structure.h&quot;
 33 #include &quot;StructureChain.h&quot;
 34 #include &quot;StructureRareDataInlines.h&quot;
<span class="line-added"> 35 #include &lt;wtf/Threading.h&gt;</span>
 36 
 37 namespace JSC {
 38 
 39 inline Structure* Structure::create(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 40 {
 41     ASSERT(vm.structureStructure);
 42     ASSERT(classInfo);
 43     if (auto* object = prototype.getObject()) {
 44         ASSERT(!object-&gt;anyObjectInChainMayInterceptIndexedAccesses(vm) || hasSlowPutArrayStorage(indexingType) || !hasIndexedProperties(indexingType));
 45         object-&gt;didBecomePrototype();
 46     }
 47 
 48     Structure* structure = new (NotNull, allocateCell&lt;Structure&gt;(vm.heap)) Structure(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
 49     structure-&gt;finishCreation(vm);
 50     return structure;
 51 }
 52 
 53 inline Structure* Structure::createStructure(VM&amp; vm)
 54 {
 55     ASSERT(!vm.structureStructure);
</pre>
<hr />
<pre>
 92 inline JSObject* Structure::storedPrototypeObject() const
 93 {
 94     ASSERT(hasMonoProto());
 95     JSValue value = m_prototype.get();
 96     if (value.isNull())
 97         return nullptr;
 98     return asObject(value);
 99 }
100 
101 inline Structure* Structure::storedPrototypeStructure() const
102 {
103     ASSERT(hasMonoProto());
104     JSObject* object = storedPrototypeObject();
105     if (!object)
106         return nullptr;
107     return object-&gt;structure();
108 }
109 
110 ALWAYS_INLINE JSValue Structure::storedPrototype(const JSObject* object) const
111 {
<span class="line-modified">112     ASSERT(isCompilationThread() || Thread::mayBeGCThread() || object-&gt;structure() == this);</span>
113     if (hasMonoProto())
114         return storedPrototype();
115     return object-&gt;getDirect(knownPolyProtoOffset);
116 }
117 
118 ALWAYS_INLINE JSObject* Structure::storedPrototypeObject(const JSObject* object) const
119 {
<span class="line-modified">120     ASSERT(isCompilationThread() || Thread::mayBeGCThread() || object-&gt;structure() == this);</span>
121     if (hasMonoProto())
122         return storedPrototypeObject();
123     JSValue proto = object-&gt;getDirect(knownPolyProtoOffset);
124     if (proto.isNull())
125         return nullptr;
126     return asObject(proto);
127 }
128 
129 ALWAYS_INLINE Structure* Structure::storedPrototypeStructure(const JSObject* object) const
130 {
131     if (JSObject* proto = storedPrototypeObject(object))
132         return proto-&gt;structure();
133     return nullptr;
134 }
135 
136 ALWAYS_INLINE PropertyOffset Structure::get(VM&amp; vm, PropertyName propertyName)
137 {
138     unsigned attributes;
139     return get(vm, propertyName, attributes);
140 }
141 
142 ALWAYS_INLINE PropertyOffset Structure::get(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes)
143 {
144     ASSERT(!isCompilationThread());
145     ASSERT(structure(vm)-&gt;classInfo() == info());
146 
<span class="line-added">147     if (m_seenProperties.ruleOut(bitwise_cast&lt;uintptr_t&gt;(propertyName.uid())))</span>
<span class="line-added">148         return invalidOffset;</span>
<span class="line-added">149 </span>
150     PropertyTable* propertyTable = ensurePropertyTableIfNotEmpty(vm);
151     if (!propertyTable)
152         return invalidOffset;
153 
154     PropertyMapEntry* entry = propertyTable-&gt;get(propertyName.uid());
155     if (!entry)
156         return invalidOffset;
157 
158     attributes = entry-&gt;attributes;
159     return entry-&gt;offset;
160 }
161 
162 template&lt;typename Functor&gt;
163 void Structure::forEachPropertyConcurrently(const Functor&amp; functor)
164 {
165     Vector&lt;Structure*, 8&gt; structures;
<span class="line-modified">166     Structure* tableStructure;</span>
167     PropertyTable* table;
168 
<span class="line-modified">169     findStructuresAndMapForMaterialization(structures, tableStructure, table);</span>
<span class="line-added">170 </span>
<span class="line-added">171     HashSet&lt;UniquedStringImpl*&gt; seenProperties;</span>
<span class="line-added">172 </span>
<span class="line-added">173     for (auto* structure : structures) {</span>
<span class="line-added">174         if (!structure-&gt;m_transitionPropertyName || seenProperties.contains(structure-&gt;m_transitionPropertyName.get()))</span>
<span class="line-added">175             continue;</span>
<span class="line-added">176 </span>
<span class="line-added">177         seenProperties.add(structure-&gt;m_transitionPropertyName.get());</span>
<span class="line-added">178 </span>
<span class="line-added">179         if (structure-&gt;isPropertyDeletionTransition())</span>
<span class="line-added">180             continue;</span>
<span class="line-added">181 </span>
<span class="line-added">182         if (!functor(PropertyMapEntry(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionOffset(), structure-&gt;transitionPropertyAttributes()))) {</span>
<span class="line-added">183             if (table)</span>
<span class="line-added">184                 tableStructure-&gt;m_lock.unlock();</span>
<span class="line-added">185             return;</span>
<span class="line-added">186         }</span>
<span class="line-added">187     }</span>
188 
189     if (table) {
190         for (auto&amp; entry : *table) {
<span class="line-added">191             if (seenProperties.contains(entry.key))</span>
<span class="line-added">192                 continue;</span>
<span class="line-added">193 </span>
194             if (!functor(entry)) {
<span class="line-modified">195                 tableStructure-&gt;m_lock.unlock();</span>
196                 return;
197             }
198         }
<span class="line-modified">199         tableStructure-&gt;m_lock.unlock();</span>









200     }
201 }
202 
203 template&lt;typename Functor&gt;
204 void Structure::forEachProperty(VM&amp; vm, const Functor&amp; functor)
205 {
206     if (PropertyTable* table = ensurePropertyTableIfNotEmpty(vm)) {
207         for (auto&amp; entry : *table) {
208             if (!functor(entry))
209                 return;
210         }
211     }
212 }
213 
214 inline PropertyOffset Structure::getConcurrently(UniquedStringImpl* uid)
215 {
216     unsigned attributesIgnored;
217     return getConcurrently(uid, attributesIgnored);
218 }
219 
</pre>
<hr />
<pre>
296 
297 inline JSValue Structure::prototypeForLookup(JSGlobalObject* globalObject, JSCell* base) const
298 {
299     ASSERT(base-&gt;structure() == this);
300     if (isObject())
301         return storedPrototype(asObject(base));
302     return prototypeForLookupPrimitiveImpl(globalObject, this);
303 }
304 
305 inline StructureChain* Structure::prototypeChain(VM&amp; vm, JSGlobalObject* globalObject, JSObject* base) const
306 {
307     ASSERT(base-&gt;structure(vm) == this);
308     // We cache our prototype chain so our clients can share it.
309     if (!isValid(globalObject, m_cachedPrototypeChain.get(), base)) {
310         JSValue prototype = prototypeForLookup(globalObject, base);
311         m_cachedPrototypeChain.set(vm, this, StructureChain::create(vm, prototype.isNull() ? nullptr : asObject(prototype)));
312     }
313     return m_cachedPrototypeChain.get();
314 }
315 
<span class="line-modified">316 inline StructureChain* Structure::prototypeChain(JSGlobalObject* globalObject, JSObject* base) const</span>
317 {
<span class="line-modified">318     return prototypeChain(globalObject-&gt;vm(), globalObject, base);</span>
319 }
320 
321 inline bool Structure::isValid(JSGlobalObject* globalObject, StructureChain* cachedPrototypeChain, JSObject* base) const
322 {
323     if (!cachedPrototypeChain)
324         return false;
325 
326     VM&amp; vm = globalObject-&gt;vm();
327     JSValue prototype = prototypeForLookup(globalObject, base);
<span class="line-modified">328     StructureID* cachedStructure = cachedPrototypeChain-&gt;head();</span>
329     while (*cachedStructure &amp;&amp; !prototype.isNull()) {
<span class="line-modified">330         if (asObject(prototype)-&gt;structureID() != *cachedStructure)</span>
331             return false;
332         ++cachedStructure;
333         prototype = asObject(prototype)-&gt;getPrototypeDirect(vm);
334     }
335     return prototype.isNull() &amp;&amp; !*cachedStructure;
336 }
337 
338 inline void Structure::didReplaceProperty(PropertyOffset offset)
339 {
340     if (LIKELY(!hasRareData()))
341         return;
342     StructureRareData::PropertyWatchpointMap* map = rareData()-&gt;m_replacementWatchpointSets.get();
343     if (LIKELY(!map))
344         return;
345     WatchpointSet* set = map-&gt;get(offset);
346     if (LIKELY(!set))
347         return;
348     set-&gt;fireAll(vm(), &quot;Property did get replaced&quot;);
349 }
350 
</pre>
<hr />
<pre>
359         return nullptr;
360     return map-&gt;get(offset);
361 }
362 
363 template&lt;typename DetailsFunc&gt;
364 ALWAYS_INLINE bool Structure::checkOffsetConsistency(PropertyTable* propertyTable, const DetailsFunc&amp; detailsFunc) const
365 {
366     // We cannot reliably assert things about the property table in the concurrent
367     // compilation thread. It is possible for the table to be stolen and then have
368     // things added to it, which leads to the offsets being all messed up. We could
369     // get around this by grabbing a lock here, but I think that would be overkill.
370     if (isCompilationThread())
371         return true;
372 
373     unsigned totalSize = propertyTable-&gt;propertyStorageSize();
374     unsigned inlineOverflowAccordingToTotalSize = totalSize &lt; m_inlineCapacity ? 0 : totalSize - m_inlineCapacity;
375 
376     auto fail = [&amp;] (const char* description) {
377         dataLog(&quot;Detected offset inconsistency: &quot;, description, &quot;!\n&quot;);
378         dataLog(&quot;this = &quot;, RawPointer(this), &quot;\n&quot;);
<span class="line-modified">379         dataLog(&quot;transitionOffset = &quot;, transitionOffset(), &quot;\n&quot;);</span>
<span class="line-added">380         dataLog(&quot;maxOffset = &quot;, maxOffset(), &quot;\n&quot;);</span>
381         dataLog(&quot;m_inlineCapacity = &quot;, m_inlineCapacity, &quot;\n&quot;);
382         dataLog(&quot;propertyTable = &quot;, RawPointer(propertyTable), &quot;\n&quot;);
<span class="line-modified">383         dataLog(&quot;numberOfSlotsForMaxOffset = &quot;, numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity), &quot;\n&quot;);</span>
384         dataLog(&quot;totalSize = &quot;, totalSize, &quot;\n&quot;);
385         dataLog(&quot;inlineOverflowAccordingToTotalSize = &quot;, inlineOverflowAccordingToTotalSize, &quot;\n&quot;);
<span class="line-modified">386         dataLog(&quot;numberOfOutOfLineSlotsForMaxOffset = &quot;, numberOfOutOfLineSlotsForMaxOffset(maxOffset()), &quot;\n&quot;);</span>
387         detailsFunc();
388         UNREACHABLE_FOR_PLATFORM();
389     };
390 
<span class="line-modified">391     if (numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity) != totalSize)</span>
<span class="line-modified">392         fail(&quot;numberOfSlotsForMaxOffset doesn&#39;t match totalSize&quot;);</span>
<span class="line-modified">393     if (inlineOverflowAccordingToTotalSize != numberOfOutOfLineSlotsForMaxOffset(maxOffset()))</span>
<span class="line-modified">394         fail(&quot;inlineOverflowAccordingToTotalSize doesn&#39;t match numberOfOutOfLineSlotsForMaxOffset&quot;);</span>
395 
396     return true;
397 }
398 
399 ALWAYS_INLINE bool Structure::checkOffsetConsistency() const
400 {
401     PropertyTable* propertyTable = propertyTableOrNull();
402 
403     if (!propertyTable) {
404         ASSERT(!isPinnedPropertyTable());
405         return true;
406     }
407 
408     // We cannot reliably assert things about the property table in the concurrent
409     // compilation thread. It is possible for the table to be stolen and then have
410     // things added to it, which leads to the offsets being all messed up. We could
411     // get around this by grabbing a lock here, but I think that would be overkill.
412     if (isCompilationThread())
413         return true;
414 
415     return checkOffsetConsistency(propertyTable, [] () { });
416 }
417 
418 inline void Structure::checkConsistency()
419 {
420     checkOffsetConsistency();
421 }
422 
423 inline size_t nextOutOfLineStorageCapacity(size_t currentCapacity)
424 {
425     if (!currentCapacity)
426         return initialOutOfLineCapacity;
427     return currentCapacity * outOfLineGrowthFactor;
428 }
429 
<span class="line-modified">430 inline void Structure::setObjectToStringValue(JSGlobalObject* globalObject, VM&amp; vm, JSString* value, PropertySlot toStringTagSymbolSlot)</span>
431 {
432     if (!hasRareData())
433         allocateRareData(vm);
<span class="line-modified">434     rareData()-&gt;setObjectToStringValue(globalObject, vm, this, value, toStringTagSymbolSlot);</span>
435 }
436 
437 template&lt;Structure::ShouldPin shouldPin, typename Func&gt;
438 inline PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
439 {
440     PropertyTable* table = ensurePropertyTable(vm);
441 
442     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
443 
444     switch (shouldPin) {
445     case ShouldPin::Yes:
446         pin(locker, vm, table);
447         break;
448     case ShouldPin::No:
449         setPropertyTable(vm, table);
450         break;
451     }
452 
453     ASSERT(!JSC::isValidOffset(get(vm, propertyName)));
454 
455     checkConsistency();
456     if (attributes &amp; PropertyAttribute::DontEnum || propertyName.isSymbol())
457         setIsQuickPropertyAccessAllowedForEnumeration(false);
458     if (propertyName == vm.propertyNames-&gt;underscoreProto)
459         setHasUnderscoreProtoPropertyExcludingOriginalProto(true);
460 
461     auto rep = propertyName.uid();
462 
463     PropertyOffset newOffset = table-&gt;nextOffset(m_inlineCapacity);
464 
465     m_propertyHash = m_propertyHash ^ rep-&gt;existingSymbolAwareHash();
<span class="line-added">466     m_seenProperties.add(bitwise_cast&lt;uintptr_t&gt;(rep));</span>
467 
<span class="line-modified">468     auto result = table-&gt;add(PropertyMapEntry(rep, newOffset, attributes));</span>
<span class="line-modified">469     ASSERT_UNUSED(result, result.second);</span>
<span class="line-added">470     ASSERT_UNUSED(result, result.first.first-&gt;offset == newOffset);</span>
<span class="line-added">471     auto newMaxOffset = std::max(newOffset, maxOffset());</span>
472 
<span class="line-modified">473     func(locker, newOffset, newMaxOffset);</span>
474 
<span class="line-modified">475     ASSERT(maxOffset() == newMaxOffset);</span>
476 
477     checkConsistency();
478     return newOffset;
479 }
480 
<span class="line-modified">481 template&lt;Structure::ShouldPin shouldPin, typename Func&gt;</span>
<span class="line-modified">482 inline PropertyOffset Structure::remove(VM&amp; vm, PropertyName propertyName, const Func&amp; func)</span>
483 {
<span class="line-modified">484     PropertyTable* table = ensurePropertyTable(vm);</span>
<span class="line-added">485     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);</span>
486 
<span class="line-modified">487     switch (shouldPin) {</span>
<span class="line-added">488     case ShouldPin::Yes:</span>
<span class="line-added">489         pin(locker, vm, table);</span>
<span class="line-added">490         break;</span>
<span class="line-added">491     case ShouldPin::No:</span>
<span class="line-added">492         setPropertyTable(vm, table);</span>
<span class="line-added">493         break;</span>
<span class="line-added">494     }</span>
495 
<span class="line-modified">496     ASSERT(JSC::isValidOffset(get(vm, propertyName)));</span>
497 
<span class="line-modified">498     checkConsistency();</span>


499 
<span class="line-modified">500     auto rep = propertyName.uid();</span>

501 
502     PropertyTable::find_iterator position = table-&gt;find(rep);
503     if (!position.first)
504         return invalidOffset;
505 
<span class="line-added">506     setIsQuickPropertyAccessAllowedForEnumeration(false);</span>
<span class="line-added">507 </span>
508     PropertyOffset offset = position.first-&gt;offset;
509 
510     table-&gt;remove(position);
511     table-&gt;addDeletedOffset(offset);
512 
<span class="line-modified">513     PropertyOffset newMaxOffset = maxOffset();</span>
<span class="line-added">514 </span>
<span class="line-added">515     func(locker, offset, newMaxOffset);</span>
516 
<span class="line-modified">517     ASSERT(maxOffset() == newMaxOffset);</span>
<span class="line-added">518     ASSERT(!JSC::isValidOffset(get(vm, propertyName)));</span>
<span class="line-added">519 </span>
<span class="line-added">520     checkConsistency();</span>
521     return offset;
522 }
523 
524 template&lt;typename Func&gt;
525 inline PropertyOffset Structure::addPropertyWithoutTransition(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
526 {
527     return add&lt;ShouldPin::Yes&gt;(vm, propertyName, attributes, func);
528 }
529 
530 template&lt;typename Func&gt;
<span class="line-modified">531 inline PropertyOffset Structure::removePropertyWithoutTransition(VM&amp; vm, PropertyName propertyName, const Func&amp; func)</span>
532 {
533     ASSERT(isUncacheableDictionary());
534     ASSERT(isPinnedPropertyTable());
535     ASSERT(propertyTableOrNull());
536 
<span class="line-modified">537     return remove&lt;ShouldPin::Yes&gt;(vm, propertyName, func);</span>
538 }
539 
540 ALWAYS_INLINE void Structure::setPrototypeWithoutTransition(VM&amp; vm, JSValue prototype)
541 {
542     ASSERT(isValidPrototype(prototype));
543     m_prototype.set(vm, this, prototype);
544 }
545 
546 ALWAYS_INLINE void Structure::setGlobalObject(VM&amp; vm, JSGlobalObject* globalObject)
547 {
548     m_globalObject.set(vm, this, globalObject);
549 }
550 
551 ALWAYS_INLINE void Structure::setPropertyTable(VM&amp; vm, PropertyTable* table)
552 {
553     m_propertyTableUnsafe.setMayBeNull(vm, this, table);
554 }
555 
556 ALWAYS_INLINE void Structure::setPreviousID(VM&amp; vm, Structure* structure)
557 {
</pre>
</td>
</tr>
</table>
<center><a href="StructureIDTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureRareData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
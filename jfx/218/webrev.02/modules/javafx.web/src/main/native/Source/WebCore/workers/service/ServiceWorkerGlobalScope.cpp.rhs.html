<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerGlobalScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerGlobalScope.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExtendableEvent.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 33 #include &quot;SWContextManager.h&quot;
 34 #include &quot;ServiceWorkerClient.h&quot;
 35 #include &quot;ServiceWorkerClients.h&quot;
 36 #include &quot;ServiceWorkerContainer.h&quot;
 37 #include &quot;ServiceWorkerThread.h&quot;
 38 #include &quot;ServiceWorkerWindowClient.h&quot;
 39 #include &quot;WorkerNavigator.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerGlobalScope);
 45 
<a name="2" id="anc2"></a><span class="line-modified"> 46 Ref&lt;ServiceWorkerGlobalScope&gt; ServiceWorkerGlobalScope::create(const ServiceWorkerContextData&amp; data, const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, ServiceWorkerThread&amp; thread, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)</span>
 47 {
<a name="3" id="anc3"></a><span class="line-modified"> 48     auto scope = adoptRef(*new ServiceWorkerGlobalScope { data, params, WTFMove(origin), thread, WTFMove(topOrigin), connectionProxy, socketProvider });</span>
<span class="line-modified"> 49     scope-&gt;applyContentSecurityPolicyResponseHeaders(params.contentSecurityPolicyResponseHeaders);</span>
 50     return scope;
 51 }
 52 
<a name="4" id="anc4"></a><span class="line-modified"> 53 ServiceWorkerGlobalScope::ServiceWorkerGlobalScope(const ServiceWorkerContextData&amp; data, const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, ServiceWorkerThread&amp; thread, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)</span>
<span class="line-modified"> 54     : WorkerGlobalScope(params, WTFMove(origin), thread, WTFMove(topOrigin), connectionProxy, socketProvider)</span>
 55     , m_contextData(crossThreadCopy(data))
 56     , m_registration(ServiceWorkerRegistration::getOrCreate(*this, navigator().serviceWorker(), WTFMove(m_contextData.registration)))
 57     , m_clients(ServiceWorkerClients::create())
 58 {
 59 }
 60 
 61 ServiceWorkerGlobalScope::~ServiceWorkerGlobalScope() = default;
 62 
 63 void ServiceWorkerGlobalScope::skipWaiting(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 64 {
 65     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
 66     m_pendingSkipWaitingPromises.add(requestIdentifier, WTFMove(promise));
 67 
 68     callOnMainThread([workerThread = makeRef(thread()), requestIdentifier]() mutable {
 69         if (auto* connection = SWContextManager::singleton().connection()) {
 70             auto identifier = workerThread-&gt;identifier();
 71             connection-&gt;skipWaiting(identifier, [workerThread = WTFMove(workerThread), requestIdentifier] {
 72                 workerThread-&gt;runLoop().postTask([requestIdentifier](auto&amp; context) {
 73                     auto&amp; scope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);
<a name="5" id="anc5"></a><span class="line-modified"> 74                     scope.eventLoop().queueTask(TaskSource::DOMManipulation, [scope = makeRef(scope), requestIdentifier]() mutable {</span>
<span class="line-modified"> 75                         if (auto promise = scope-&gt;m_pendingSkipWaitingPromises.take(requestIdentifier))</span>
<span class="line-added"> 76                             promise-&gt;resolve();</span>
<span class="line-added"> 77                     });</span>
 78                 });
 79             });
 80         }
 81     });
 82 }
 83 
 84 EventTargetInterface ServiceWorkerGlobalScope::eventTargetInterface() const
 85 {
 86     return ServiceWorkerGlobalScopeEventTargetInterfaceType;
 87 }
 88 
 89 ServiceWorkerThread&amp; ServiceWorkerGlobalScope::thread()
 90 {
 91     return static_cast&lt;ServiceWorkerThread&amp;&gt;(WorkerGlobalScope::thread());
 92 }
 93 
 94 ServiceWorkerClient* ServiceWorkerGlobalScope::serviceWorkerClient(ServiceWorkerClientIdentifier identifier)
 95 {
 96     return m_clientMap.get(identifier);
 97 }
 98 
 99 void ServiceWorkerGlobalScope::addServiceWorkerClient(ServiceWorkerClient&amp; client)
100 {
101     auto result = m_clientMap.add(client.identifier(), &amp;client);
102     ASSERT_UNUSED(result, result.isNewEntry);
103 }
104 
105 void ServiceWorkerGlobalScope::removeServiceWorkerClient(ServiceWorkerClient&amp; client)
106 {
107     auto isRemoved = m_clientMap.remove(client.identifier());
108     ASSERT_UNUSED(isRemoved, isRemoved);
109 }
110 
111 // https://w3c.github.io/ServiceWorker/#update-service-worker-extended-events-set-algorithm
112 void ServiceWorkerGlobalScope::updateExtendedEventsSet(ExtendableEvent* newEvent)
113 {
114     ASSERT(!isMainThread());
115     ASSERT(!newEvent || !newEvent-&gt;isBeingDispatched());
116     bool hadPendingEvents = hasPendingEvents();
117     m_extendedEvents.removeAllMatching([](auto&amp; event) {
118         return !event-&gt;pendingPromiseCount();
119     });
120 
121     if (newEvent &amp;&amp; newEvent-&gt;pendingPromiseCount()) {
122         m_extendedEvents.append(*newEvent);
123         newEvent-&gt;whenAllExtendLifetimePromisesAreSettled([this](auto&amp;&amp;) {
124             this-&gt;updateExtendedEventsSet();
125         });
126         // Clear out the event&#39;s target as it is the WorkerGlobalScope and we do not want to keep it
127         // alive unnecessarily.
128         newEvent-&gt;setTarget(nullptr);
129     }
130 
131     bool hasPendingEvents = this-&gt;hasPendingEvents();
132     if (hasPendingEvents == hadPendingEvents)
133         return;
134 
135     callOnMainThread([threadIdentifier = thread().identifier(), hasPendingEvents] {
136         if (auto* connection = SWContextManager::singleton().connection())
137             connection-&gt;setServiceWorkerHasPendingEvents(threadIdentifier, hasPendingEvents);
138     });
139 }
140 
141 const ServiceWorkerContextData::ImportedScript* ServiceWorkerGlobalScope::scriptResource(const URL&amp; url) const
142 {
143     auto iterator = m_contextData.scriptResourceMap.find(url);
144     return iterator == m_contextData.scriptResourceMap.end() ? nullptr : &amp;iterator-&gt;value;
145 }
146 
147 void ServiceWorkerGlobalScope::setScriptResource(const URL&amp; url, ServiceWorkerContextData::ImportedScript&amp;&amp; script)
148 {
149     callOnMainThread([threadIdentifier = thread().identifier(), url = url.isolatedCopy(), script = script.isolatedCopy()] {
150         if (auto* connection = SWContextManager::singleton().connection())
151             connection-&gt;setScriptResource(threadIdentifier, url, script);
152     });
153 
154     m_contextData.scriptResourceMap.set(url, WTFMove(script));
155 }
156 
157 } // namespace WebCore
158 
159 #endif // ENABLE(SERVICE_WORKER)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;DisplayList.h&quot;
  29 #include &quot;FloatPoint.h&quot;
  30 #include &quot;FloatRoundedRect.h&quot;
  31 #include &quot;Font.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;Image.h&quot;
  34 #include &quot;Pattern.h&quot;
  35 #include &lt;wtf/RefCounted.h&gt;
  36 #include &lt;wtf/TypeCasts.h&gt;
  37 
  38 namespace WTF {
  39 class TextStream;
  40 }
  41 
  42 namespace WebCore {
  43 
  44 struct ImagePaintingOptions;
  45 
  46 namespace DisplayList {
  47 
  48 class DrawingItem : public Item {
  49 public:
  50     WEBCORE_EXPORT explicit DrawingItem(ItemType);
  51 
  52     WEBCORE_EXPORT virtual ~DrawingItem();
  53 
  54     void setExtent(const FloatRect&amp; r) { m_extent = r; }
  55     const FloatRect&amp; extent() const { return m_extent.value(); }
  56 
  57     bool extentKnown() const { return static_cast&lt;bool&gt;(m_extent); }
  58 
  59     // Return bounds of this drawing operation in local coordinates.
  60     // Does not include effets of transform, shadow etc in the state.
  61     virtual Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const { return WTF::nullopt; }
  62 
  63 private:
  64     bool isDrawingItem() const override { return true; }
  65 
  66     Optional&lt;FloatRect&gt; m_extent; // In base coordinates, taking shadows and transforms into account.
  67 };
  68 
  69 class Save : public Item {
  70 public:
  71     static Ref&lt;Save&gt; create()
  72     {
  73         return adoptRef(*new Save);
  74     }
  75 
  76     WEBCORE_EXPORT virtual ~Save();
  77 
  78     // Index in the display list of the corresponding Restore item. 0 if unmatched.
  79     size_t restoreIndex() const { return m_restoreIndex; }
  80     void setRestoreIndex(size_t index) { m_restoreIndex = index; }
  81 
  82     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
  83     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Save&gt;&gt; decode(Decoder&amp;);
  84 
  85 private:
  86     WEBCORE_EXPORT Save();
  87 
  88     void apply(GraphicsContext&amp;) const override;
  89 
  90     size_t m_restoreIndex { 0 };
  91 };
  92 
  93 template&lt;class Encoder&gt;
  94 void Save::encode(Encoder&amp; encoder) const
  95 {
  96     encoder &lt;&lt; static_cast&lt;uint64_t&gt;(m_restoreIndex);
  97 }
  98 
  99 template&lt;class Decoder&gt;
 100 Optional&lt;Ref&lt;Save&gt;&gt; Save::decode(Decoder&amp; decoder)
 101 {
 102     Optional&lt;uint64_t&gt; restoreIndex;
 103     decoder &gt;&gt; restoreIndex;
 104     if (!restoreIndex)
 105         return WTF::nullopt;
 106 
 107     // FIXME: Validate restoreIndex? But we don&#39;t have the list context here.
 108     auto save = Save::create();
 109     save-&gt;setRestoreIndex(static_cast&lt;size_t&gt;(*restoreIndex));
 110     return save;
 111 }
 112 
 113 class Restore : public Item {
 114 public:
 115     static Ref&lt;Restore&gt; create()
 116     {
 117         return adoptRef(*new Restore);
 118     }
 119 
 120     WEBCORE_EXPORT virtual ~Restore();
 121 
 122     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 123     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Restore&gt;&gt; decode(Decoder&amp;);
 124 
 125 private:
 126     WEBCORE_EXPORT Restore();
 127 
 128     void apply(GraphicsContext&amp;) const override;
 129 };
 130 
 131 template&lt;class Encoder&gt;
 132 void Restore::encode(Encoder&amp;) const
 133 {
 134 }
 135 
 136 template&lt;class Decoder&gt;
 137 Optional&lt;Ref&lt;Restore&gt;&gt; Restore::decode(Decoder&amp;)
 138 {
 139     return Restore::create();
 140 }
 141 
 142 class Translate : public Item {
 143 public:
 144     static Ref&lt;Translate&gt; create(float x, float y)
 145     {
 146         return adoptRef(*new Translate(x, y));
 147     }
 148 
 149     WEBCORE_EXPORT virtual ~Translate();
 150 
 151     float x() const { return m_x; }
 152     float y() const { return m_y; }
 153 
 154     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 155     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Translate&gt;&gt; decode(Decoder&amp;);
 156 
 157 private:
 158     WEBCORE_EXPORT Translate(float x, float y);
 159 
 160     void apply(GraphicsContext&amp;) const override;
 161 
 162     float m_x;
 163     float m_y;
 164 };
 165 
 166 template&lt;class Encoder&gt;
 167 void Translate::encode(Encoder&amp; encoder) const
 168 {
 169     encoder &lt;&lt; m_x;
 170     encoder &lt;&lt; m_y;
 171 }
 172 
 173 template&lt;class Decoder&gt;
 174 Optional&lt;Ref&lt;Translate&gt;&gt; Translate::decode(Decoder&amp; decoder)
 175 {
 176     Optional&lt;float&gt; x;
 177     decoder &gt;&gt; x;
 178     if (!x)
 179         return WTF::nullopt;
 180 
 181     Optional&lt;float&gt; y;
 182     decoder &gt;&gt; y;
 183     if (!y)
 184         return WTF::nullopt;
 185 
 186     return Translate::create(*x, *y);
 187 }
 188 
 189 class Rotate : public Item {
 190 public:
 191     static Ref&lt;Rotate&gt; create(float angleInRadians)
 192     {
 193         return adoptRef(*new Rotate(angleInRadians));
 194     }
 195 
 196     WEBCORE_EXPORT virtual ~Rotate();
 197 
 198     float angle() const { return m_angle; }
 199 
 200     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 201     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Rotate&gt;&gt; decode(Decoder&amp;);
 202 
 203 private:
 204     WEBCORE_EXPORT Rotate(float angle);
 205 
 206     void apply(GraphicsContext&amp;) const override;
 207 
 208     float m_angle; // In radians.
 209 };
 210 
 211 template&lt;class Encoder&gt;
 212 void Rotate::encode(Encoder&amp; encoder) const
 213 {
 214     encoder &lt;&lt; m_angle;
 215 }
 216 
 217 template&lt;class Decoder&gt;
 218 Optional&lt;Ref&lt;Rotate&gt;&gt; Rotate::decode(Decoder&amp; decoder)
 219 {
 220     Optional&lt;float&gt; angle;
 221     decoder &gt;&gt; angle;
 222     if (!angle)
 223         return WTF::nullopt;
 224 
 225     return Rotate::create(*angle);
 226 }
 227 
 228 class Scale : public Item {
 229 public:
 230     static Ref&lt;Scale&gt; create(const FloatSize&amp; size)
 231     {
 232         return adoptRef(*new Scale(size));
 233     }
 234 
 235     WEBCORE_EXPORT virtual ~Scale();
 236 
 237     const FloatSize&amp; amount() const { return m_size; }
 238 
 239     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 240     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Scale&gt;&gt; decode(Decoder&amp;);
 241 
 242 private:
 243     WEBCORE_EXPORT Scale(const FloatSize&amp;);
 244 
 245     void apply(GraphicsContext&amp;) const override;
 246 
 247     FloatSize m_size;
 248 };
 249 
 250 template&lt;class Encoder&gt;
 251 void Scale::encode(Encoder&amp; encoder) const
 252 {
 253     encoder &lt;&lt; m_size;
 254 }
 255 
 256 template&lt;class Decoder&gt;
 257 Optional&lt;Ref&lt;Scale&gt;&gt; Scale::decode(Decoder&amp; decoder)
 258 {
 259     Optional&lt;FloatSize&gt; scale;
 260     decoder &gt;&gt; scale;
 261     if (!scale)
 262         return WTF::nullopt;
 263 
 264     return Scale::create(*scale);
 265 }
 266 
 267 class SetCTM : public Item {
 268 public:
 269     static Ref&lt;SetCTM&gt; create(const AffineTransform&amp; matrix)
 270     {
 271         return adoptRef(*new SetCTM(matrix));
 272     }
 273 
 274     WEBCORE_EXPORT virtual ~SetCTM();
 275 
 276     const AffineTransform&amp; transform() const { return m_transform; }
 277 
 278     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 279     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetCTM&gt;&gt; decode(Decoder&amp;);
 280 
 281 private:
 282     WEBCORE_EXPORT SetCTM(const AffineTransform&amp;);
 283 
 284     void apply(GraphicsContext&amp;) const override;
 285 
 286     AffineTransform m_transform;
 287 };
 288 
 289 template&lt;class Encoder&gt;
 290 void SetCTM::encode(Encoder&amp; encoder) const
 291 {
 292     encoder &lt;&lt; m_transform;
 293 }
 294 
 295 template&lt;class Decoder&gt;
 296 Optional&lt;Ref&lt;SetCTM&gt;&gt; SetCTM::decode(Decoder&amp; decoder)
 297 {
 298     Optional&lt;AffineTransform&gt; transform;
 299     decoder &gt;&gt; transform;
 300     if (!transform)
 301         return WTF::nullopt;
 302 
 303     return SetCTM::create(*transform);
 304 }
 305 
 306 class ConcatenateCTM : public Item {
 307 public:
 308     static Ref&lt;ConcatenateCTM&gt; create(const AffineTransform&amp; matrix)
 309     {
 310         return adoptRef(*new ConcatenateCTM(matrix));
 311     }
 312 
 313     WEBCORE_EXPORT virtual ~ConcatenateCTM();
 314 
 315     const AffineTransform&amp; transform() const { return m_transform; }
 316 
 317     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 318     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ConcatenateCTM&gt;&gt; decode(Decoder&amp;);
 319 
 320 private:
 321     WEBCORE_EXPORT ConcatenateCTM(const AffineTransform&amp;);
 322 
 323     void apply(GraphicsContext&amp;) const override;
 324 
 325     AffineTransform m_transform;
 326 };
 327 
 328 template&lt;class Encoder&gt;
 329 void ConcatenateCTM::encode(Encoder&amp; encoder) const
 330 {
 331     encoder &lt;&lt; m_transform;
 332 }
 333 
 334 template&lt;class Decoder&gt;
 335 Optional&lt;Ref&lt;ConcatenateCTM&gt;&gt; ConcatenateCTM::decode(Decoder&amp; decoder)
 336 {
 337     Optional&lt;AffineTransform&gt; transform;
 338     decoder &gt;&gt; transform;
 339     if (!transform)
 340         return WTF::nullopt;
 341 
 342     return ConcatenateCTM::create(*transform);
 343 }
 344 
 345 class SetState : public Item {
 346 public:
 347     static Ref&lt;SetState&gt; create(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 348     {
 349         return adoptRef(*new SetState(state, flags));
 350     }
 351 
 352     static Ref&lt;SetState&gt; create(const GraphicsContextStateChange&amp; stateChange)
 353     {
 354         return adoptRef(*new SetState(stateChange));
 355     }
 356 
 357     WEBCORE_EXPORT virtual ~SetState();
 358 
 359     const GraphicsContextStateChange&amp; state() const { return m_state; }
 360 
 361     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 362 
 363     void accumulate(GraphicsContextState&amp;) const;
 364 
 365     static void builderState(GraphicsContext&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 366 
 367     static void dumpStateChanges(WTF::TextStream&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 368 
 369     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 370     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetState&gt;&gt; decode(Decoder&amp;);
 371 
 372 private:
 373     WEBCORE_EXPORT SetState(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 374     WEBCORE_EXPORT SetState(const GraphicsContextStateChange&amp;);
 375 
 376     void apply(GraphicsContext&amp;) const override;
 377 
 378     GraphicsContextStateChange m_state;
 379 };
 380 
 381 template&lt;class Encoder&gt;
 382 void SetState::encode(Encoder&amp; encoder) const
 383 {
 384     auto changeFlags = m_state.m_changeFlags;
 385     encoder &lt;&lt; changeFlags;
 386 
 387     auto&amp; state = m_state.m_state;
 388 
 389     if (changeFlags.contains(GraphicsContextState::StrokeGradientChange)) {
 390         encoder &lt;&lt; !!state.strokeGradient;
 391         if (state.strokeGradient)
 392             encoder &lt;&lt; *state.strokeGradient;
 393     }
 394 
 395     if (changeFlags.contains(GraphicsContextState::StrokePatternChange)) {
 396         encoder &lt;&lt; !!state.strokePattern;
 397         if (state.strokePattern)
 398             encoder &lt;&lt; *state.strokePattern;
 399     }
 400 
 401     if (changeFlags.contains(GraphicsContextState::FillGradientChange)) {
 402         encoder &lt;&lt; !!state.fillGradient;
 403         if (state.fillGradient)
 404             encoder &lt;&lt; *state.fillGradient;
 405     }
 406 
 407     if (changeFlags.contains(GraphicsContextState::FillPatternChange)) {
 408         encoder &lt;&lt; !!state.fillPattern;
 409         if (state.fillPattern)
 410             encoder &lt;&lt; *state.fillPattern;
 411     }
 412 
 413     if (changeFlags.contains(GraphicsContextState::ShadowChange)) {
 414         encoder &lt;&lt; state.shadowOffset;
 415         encoder &lt;&lt; state.shadowBlur;
 416         encoder &lt;&lt; state.shadowColor;
 417 #if USE(CG)
 418         encoder &lt;&lt; state.shadowsUseLegacyRadius;
 419 #endif // USE(CG)
 420     }
 421 
 422     if (changeFlags.contains(GraphicsContextState::StrokeThicknessChange))
 423         encoder &lt;&lt; state.strokeThickness;
 424 
 425     if (changeFlags.contains(GraphicsContextState::TextDrawingModeChange))
 426         encoder.encodeEnum(state.textDrawingMode);
 427 
 428     if (changeFlags.contains(GraphicsContextState::StrokeColorChange))
 429         encoder &lt;&lt; state.strokeColor;
 430 
 431     if (changeFlags.contains(GraphicsContextState::FillColorChange))
 432         encoder &lt;&lt; state.fillColor;
 433 
 434     if (changeFlags.contains(GraphicsContextState::StrokeStyleChange))
 435         encoder.encodeEnum(state.strokeStyle);
 436 
 437     if (changeFlags.contains(GraphicsContextState::FillRuleChange))
 438         encoder &lt;&lt; state.fillRule;
 439 
 440     if (changeFlags.contains(GraphicsContextState::CompositeOperationChange))
 441         encoder &lt;&lt; state.compositeOperator;
 442 
 443     if (changeFlags.contains(GraphicsContextState::BlendModeChange))
 444         encoder &lt;&lt; state.blendMode;
 445 
 446     if (changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange))
 447         encoder &lt;&lt; state.imageInterpolationQuality;
 448 
 449     if (changeFlags.contains(GraphicsContextState::AlphaChange))
 450         encoder &lt;&lt; state.alpha;
 451 
 452     if (changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))
 453         encoder &lt;&lt; state.shouldAntialias;
 454 
 455     if (changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))
 456         encoder &lt;&lt; state.shouldSmoothFonts;
 457 
 458     if (changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))
 459         encoder &lt;&lt; state.shouldSubpixelQuantizeFonts;
 460 
 461     if (changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))
 462         encoder &lt;&lt; state.shadowsIgnoreTransforms;
 463 }
 464 
 465 template&lt;class Decoder&gt;
 466 Optional&lt;Ref&lt;SetState&gt;&gt; SetState::decode(Decoder&amp; decoder)
 467 {
 468     Optional&lt;GraphicsContextState::StateChangeFlags&gt; changeFlags;
 469     decoder &gt;&gt; changeFlags;
 470     if (!changeFlags)
 471         return WTF::nullopt;
 472 
 473     GraphicsContextStateChange stateChange;
 474     stateChange.m_changeFlags = *changeFlags;
 475 
 476     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeGradientChange)) {
 477         Optional&lt;bool&gt; hasStrokeGradient;
 478         decoder &gt;&gt; hasStrokeGradient;
 479         if (!hasStrokeGradient.hasValue())
 480             return WTF::nullopt;
 481 
 482         if (hasStrokeGradient.value()) {
 483             auto strokeGradient = Gradient::decode(decoder);
 484             if (!strokeGradient)
 485                 return WTF::nullopt;
 486 
 487             stateChange.m_state.strokeGradient = WTFMove(*strokeGradient);
 488         }
 489     }
 490 
 491     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokePatternChange)) {
 492         Optional&lt;bool&gt; hasStrokePattern;
 493         decoder &gt;&gt; hasStrokePattern;
 494         if (!hasStrokePattern.hasValue())
 495             return WTF::nullopt;
 496 
 497         if (hasStrokePattern.value()) {
 498             auto strokePattern = Pattern::decode(decoder);
 499             if (!strokePattern)
 500                 return WTF::nullopt;
 501 
 502             stateChange.m_state.strokePattern = WTFMove(*strokePattern);
 503         }
 504     }
 505 
 506     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillGradientChange)) {
 507         Optional&lt;bool&gt; hasFillGradient;
 508         decoder &gt;&gt; hasFillGradient;
 509         if (!hasFillGradient.hasValue())
 510             return WTF::nullopt;
 511 
 512         if (hasFillGradient.value()) {
 513             auto fillGradient = Gradient::decode(decoder);
 514             if (!fillGradient)
 515                 return WTF::nullopt;
 516 
 517             stateChange.m_state.fillGradient = WTFMove(*fillGradient);
 518         }
 519     }
 520 
 521     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillPatternChange)) {
 522         Optional&lt;bool&gt; hasFillPattern;
 523         decoder &gt;&gt; hasFillPattern;
 524         if (!hasFillPattern.hasValue())
 525             return WTF::nullopt;
 526 
 527         if (hasFillPattern.value()) {
 528             auto fillPattern = Pattern::decode(decoder);
 529             if (!fillPattern)
 530                 return WTF::nullopt;
 531 
 532             stateChange.m_state.fillPattern = WTFMove(*fillPattern);
 533         }
 534     }
 535 
 536     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShadowChange)) {
 537         Optional&lt;FloatSize&gt; shadowOffset;
 538         decoder &gt;&gt; shadowOffset;
 539         if (!shadowOffset)
 540             return WTF::nullopt;
 541 
 542         stateChange.m_state.shadowOffset = *shadowOffset;
 543 
 544         Optional&lt;float&gt; shadowBlur;
 545         decoder &gt;&gt; shadowBlur;
 546         if (!shadowBlur)
 547             return WTF::nullopt;
 548 
 549         stateChange.m_state.shadowBlur = *shadowBlur;
 550 
 551         Optional&lt;Color&gt; shadowColor;
 552         decoder &gt;&gt; shadowColor;
 553         if (!shadowColor)
 554             return WTF::nullopt;
 555 
 556         stateChange.m_state.shadowColor = *shadowColor;
 557 
 558 #if USE(CG)
 559         Optional&lt;bool&gt; shadowsUseLegacyRadius;
 560         decoder &gt;&gt; shadowsUseLegacyRadius;
 561         if (!shadowsUseLegacyRadius)
 562             return WTF::nullopt;
 563 
 564         stateChange.m_state.shadowsUseLegacyRadius = *shadowsUseLegacyRadius;
 565 #endif // USE(CG)
 566     }
 567 
 568     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange)) {
 569         Optional&lt;float&gt; strokeThickness;
 570         decoder &gt;&gt; strokeThickness;
 571         if (!strokeThickness)
 572             return WTF::nullopt;
 573 
 574         stateChange.m_state.strokeThickness = *strokeThickness;
 575     }
 576 
 577     if (stateChange.m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange)) {
 578         TextDrawingModeFlags textDrawingMode;
 579         if (!decoder.decodeEnum(textDrawingMode))
 580             return WTF::nullopt;
 581 
 582         stateChange.m_state.textDrawingMode = textDrawingMode;
 583     }
 584 
 585     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeColorChange)) {
 586         Optional&lt;Color&gt; strokeColor;
 587         decoder &gt;&gt; strokeColor;
 588         if (!strokeColor)
 589             return WTF::nullopt;
 590 
 591         stateChange.m_state.strokeColor = *strokeColor;
 592     }
 593 
 594     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillColorChange)) {
 595         Optional&lt;Color&gt; fillColor;
 596         decoder &gt;&gt; fillColor;
 597         if (!fillColor)
 598             return WTF::nullopt;
 599 
 600         stateChange.m_state.fillColor = *fillColor;
 601     }
 602 
 603     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeStyleChange)) {
 604         StrokeStyle strokeStyle;
 605         if (!decoder.decodeEnum(strokeStyle))
 606             return WTF::nullopt;
 607 
 608         stateChange.m_state.strokeStyle = strokeStyle;
 609     }
 610 
 611     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillRuleChange)) {
 612         Optional&lt;WindRule&gt; fillRule;
 613         decoder &gt;&gt; fillRule;
 614         if (!fillRule)
 615             return WTF::nullopt;
 616 
 617         stateChange.m_state.fillRule = *fillRule;
 618     }
 619 
 620     if (stateChange.m_changeFlags.contains(GraphicsContextState::CompositeOperationChange)) {
 621         Optional&lt;CompositeOperator&gt; compositeOperator;
 622         decoder &gt;&gt; compositeOperator;
 623         if (!compositeOperator)
 624             return WTF::nullopt;
 625 
 626         stateChange.m_state.compositeOperator = *compositeOperator;
 627     }
 628 
 629     if (stateChange.m_changeFlags.contains(GraphicsContextState::BlendModeChange)) {
 630         Optional&lt;BlendMode&gt; blendMode;
 631         decoder &gt;&gt; blendMode;
 632         if (!blendMode)
 633             return WTF::nullopt;
 634 
 635         stateChange.m_state.blendMode = *blendMode;
 636     }
 637 
 638     if (stateChange.m_changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange)) {
 639         Optional&lt;InterpolationQuality&gt; imageInterpolationQuality;
 640         decoder &gt;&gt; imageInterpolationQuality;
 641         if (!imageInterpolationQuality)
 642             return WTF::nullopt;
 643 
 644         stateChange.m_state.imageInterpolationQuality = *imageInterpolationQuality;
 645     }
 646 
 647     if (stateChange.m_changeFlags.contains(GraphicsContextState::AlphaChange)) {
 648         Optional&lt;float&gt; alpha;
 649         decoder &gt;&gt; alpha;
 650         if (!alpha)
 651             return WTF::nullopt;
 652 
 653         stateChange.m_state.alpha = *alpha;
 654     }
 655 
 656     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange)) {
 657         Optional&lt;bool&gt; shouldAntialias;
 658         decoder &gt;&gt; shouldAntialias;
 659         if (!shouldAntialias)
 660             return WTF::nullopt;
 661 
 662         stateChange.m_state.shouldAntialias = *shouldAntialias;
 663     }
 664 
 665     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange)) {
 666         Optional&lt;bool&gt; shouldSmoothFonts;
 667         decoder &gt;&gt; shouldSmoothFonts;
 668         if (!shouldSmoothFonts)
 669             return WTF::nullopt;
 670 
 671         stateChange.m_state.shouldSmoothFonts = *shouldSmoothFonts;
 672     }
 673 
 674     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange)) {
 675         Optional&lt;bool&gt; shouldSubpixelQuantizeFonts;
 676         decoder &gt;&gt; shouldSubpixelQuantizeFonts;
 677         if (!shouldSubpixelQuantizeFonts)
 678             return WTF::nullopt;
 679 
 680         stateChange.m_state.shouldSubpixelQuantizeFonts = *shouldSubpixelQuantizeFonts;
 681     }
 682 
 683     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange)) {
 684         Optional&lt;bool&gt; shadowsIgnoreTransforms;
 685         decoder &gt;&gt; shadowsIgnoreTransforms;
 686         if (!shadowsIgnoreTransforms)
 687             return WTF::nullopt;
 688 
 689         stateChange.m_state.shadowsIgnoreTransforms = *shadowsIgnoreTransforms;
 690     }
 691 
 692     return SetState::create(stateChange);
 693 }
 694 
 695 class SetLineCap : public Item {
 696 public:
 697     static Ref&lt;SetLineCap&gt; create(LineCap lineCap)
 698     {
 699         return adoptRef(*new SetLineCap(lineCap));
 700     }
 701 
 702     WEBCORE_EXPORT virtual ~SetLineCap();
 703 
 704     LineCap lineCap() const { return m_lineCap; }
 705 
 706     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 707     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineCap&gt;&gt; decode(Decoder&amp;);
 708 
 709 private:
 710     WEBCORE_EXPORT SetLineCap(LineCap);
 711 
 712     void apply(GraphicsContext&amp;) const override;
 713 
 714     LineCap m_lineCap;
 715 };
 716 
 717 template&lt;class Encoder&gt;
 718 void SetLineCap::encode(Encoder&amp; encoder) const
 719 {
 720     encoder &lt;&lt; m_lineCap;
 721 }
 722 
 723 template&lt;class Decoder&gt;
 724 Optional&lt;Ref&lt;SetLineCap&gt;&gt; SetLineCap::decode(Decoder&amp; decoder)
 725 {
 726     Optional&lt;LineCap&gt; lineCap;
 727     decoder &gt;&gt; lineCap;
 728     if (!lineCap)
 729         return WTF::nullopt;
 730 
 731     return SetLineCap::create(*lineCap);
 732 }
 733 
 734 class SetLineDash : public Item {
 735 public:
 736     static Ref&lt;SetLineDash&gt; create(const DashArray&amp; dashArray, float dashOffset)
 737     {
 738         return adoptRef(*new SetLineDash(dashArray, dashOffset));
 739     }
 740 
 741     WEBCORE_EXPORT virtual ~SetLineDash();
 742 
 743     const DashArray&amp; dashArray() const { return m_dashArray; }
 744     float dashOffset() const { return m_dashOffset; }
 745 
 746     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 747     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineDash&gt;&gt; decode(Decoder&amp;);
 748 
 749 private:
 750     WEBCORE_EXPORT SetLineDash(const DashArray&amp;, float dashOffset);
 751 
 752     void apply(GraphicsContext&amp;) const override;
 753 
 754     DashArray m_dashArray;
 755     float m_dashOffset;
 756 };
 757 
 758 template&lt;class Encoder&gt;
 759 void SetLineDash::encode(Encoder&amp; encoder) const
 760 {
 761     encoder &lt;&lt; m_dashArray;
 762     encoder &lt;&lt; m_dashOffset;
 763 }
 764 
 765 template&lt;class Decoder&gt;
 766 Optional&lt;Ref&lt;SetLineDash&gt;&gt; SetLineDash::decode(Decoder&amp; decoder)
 767 {
 768     Optional&lt;DashArray&gt; dashArray;
 769     decoder &gt;&gt; dashArray;
 770     if (!dashArray)
 771         return WTF::nullopt;
 772 
 773     Optional&lt;float&gt; dashOffset;
 774     decoder &gt;&gt; dashOffset;
 775     if (!dashOffset)
 776         return WTF::nullopt;
 777 
 778     return SetLineDash::create(*dashArray, *dashOffset);
 779 }
 780 
 781 class SetLineJoin : public Item {
 782 public:
 783     static Ref&lt;SetLineJoin&gt; create(LineJoin lineJoin)
 784     {
 785         return adoptRef(*new SetLineJoin(lineJoin));
 786     }
 787 
 788     WEBCORE_EXPORT virtual ~SetLineJoin();
 789 
 790     LineJoin lineJoin() const { return m_lineJoin; }
 791 
 792     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 793     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineJoin&gt;&gt; decode(Decoder&amp;);
 794 
 795 private:
 796     WEBCORE_EXPORT SetLineJoin(LineJoin);
 797 
 798     void apply(GraphicsContext&amp;) const override;
 799 
 800     LineJoin m_lineJoin;
 801 };
 802 
 803 template&lt;class Encoder&gt;
 804 void SetLineJoin::encode(Encoder&amp; encoder) const
 805 {
 806     encoder &lt;&lt; m_lineJoin;
 807 }
 808 
 809 template&lt;class Decoder&gt;
 810 Optional&lt;Ref&lt;SetLineJoin&gt;&gt; SetLineJoin::decode(Decoder&amp; decoder)
 811 {
 812     Optional&lt;LineJoin&gt; lineJoin;
 813     decoder &gt;&gt; lineJoin;
 814     if (!lineJoin)
 815         return WTF::nullopt;
 816 
 817     return SetLineJoin::create(*lineJoin);
 818 }
 819 
 820 class SetMiterLimit : public Item {
 821 public:
 822     static Ref&lt;SetMiterLimit&gt; create(float limit)
 823     {
 824         return adoptRef(*new SetMiterLimit(limit));
 825     }
 826 
 827     WEBCORE_EXPORT virtual ~SetMiterLimit();
 828 
 829     float miterLimit() const { return m_miterLimit; }
 830 
 831     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 832     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetMiterLimit&gt;&gt; decode(Decoder&amp;);
 833 
 834 private:
 835     WEBCORE_EXPORT SetMiterLimit(float);
 836 
 837     void apply(GraphicsContext&amp;) const override;
 838 
 839     float m_miterLimit;
 840 };
 841 
 842 template&lt;class Encoder&gt;
 843 void SetMiterLimit::encode(Encoder&amp; encoder) const
 844 {
 845     encoder &lt;&lt; m_miterLimit;
 846 }
 847 
 848 template&lt;class Decoder&gt;
 849 Optional&lt;Ref&lt;SetMiterLimit&gt;&gt; SetMiterLimit::decode(Decoder&amp; decoder)
 850 {
 851     Optional&lt;float&gt; miterLimit;
 852     decoder &gt;&gt; miterLimit;
 853     if (!miterLimit)
 854         return WTF::nullopt;
 855 
 856     return SetMiterLimit::create(*miterLimit);
 857 }
 858 
 859 class ClearShadow : public Item {
 860 public:
 861     static Ref&lt;ClearShadow&gt; create()
 862     {
 863         return adoptRef(*new ClearShadow);
 864     }
 865 
 866     WEBCORE_EXPORT virtual ~ClearShadow();
 867 
 868     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 869     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClearShadow&gt;&gt; decode(Decoder&amp;);
 870 
 871 private:
 872     WEBCORE_EXPORT ClearShadow();
 873 
 874     void apply(GraphicsContext&amp;) const override;
 875 };
 876 
 877 template&lt;class Encoder&gt;
 878 void ClearShadow::encode(Encoder&amp;) const
 879 {
 880 }
 881 
 882 template&lt;class Decoder&gt;
 883 Optional&lt;Ref&lt;ClearShadow&gt;&gt; ClearShadow::decode(Decoder&amp;)
 884 {
 885     return ClearShadow::create();
 886 }
 887 
 888 // FIXME: treat as DrawingItem?
 889 class Clip : public Item {
 890 public:
 891     static Ref&lt;Clip&gt; create(const FloatRect&amp; rect)
 892     {
 893         return adoptRef(*new Clip(rect));
 894     }
 895 
 896     WEBCORE_EXPORT virtual ~Clip();
 897 
 898     FloatRect rect() const { return m_rect; }
 899 
 900     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 901     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Clip&gt;&gt; decode(Decoder&amp;);
 902 
 903 private:
 904     WEBCORE_EXPORT Clip(const FloatRect&amp;);
 905 
 906     void apply(GraphicsContext&amp;) const override;
 907 
 908     FloatRect m_rect;
 909 };
 910 
 911 template&lt;class Encoder&gt;
 912 void Clip::encode(Encoder&amp; encoder) const
 913 {
 914     encoder &lt;&lt; m_rect;
 915 }
 916 
 917 template&lt;class Decoder&gt;
 918 Optional&lt;Ref&lt;Clip&gt;&gt; Clip::decode(Decoder&amp; decoder)
 919 {
 920     Optional&lt;FloatRect&gt; rect;
 921     decoder &gt;&gt; rect;
 922     if (!rect)
 923         return WTF::nullopt;
 924 
 925     return Clip::create(*rect);
 926 }
 927 
 928 class ClipOut : public Item {
 929 public:
 930     static Ref&lt;ClipOut&gt; create(const FloatRect&amp; rect)
 931     {
 932         return adoptRef(*new ClipOut(rect));
 933     }
 934 
 935     WEBCORE_EXPORT virtual ~ClipOut();
 936 
 937     FloatRect rect() const { return m_rect; }
 938 
 939     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 940     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipOut&gt;&gt; decode(Decoder&amp;);
 941 
 942 private:
 943     WEBCORE_EXPORT ClipOut(const FloatRect&amp;);
 944 
 945     void apply(GraphicsContext&amp;) const override;
 946 
 947     FloatRect m_rect;
 948 };
 949 
 950 template&lt;class Encoder&gt;
 951 void ClipOut::encode(Encoder&amp; encoder) const
 952 {
 953     encoder &lt;&lt; m_rect;
 954 }
 955 
 956 template&lt;class Decoder&gt;
 957 Optional&lt;Ref&lt;ClipOut&gt;&gt; ClipOut::decode(Decoder&amp; decoder)
 958 {
 959     Optional&lt;FloatRect&gt; rect;
 960     decoder &gt;&gt; rect;
 961     if (!rect)
 962         return WTF::nullopt;
 963 
 964     return ClipOut::create(*rect);
 965 }
 966 
 967 class ClipOutToPath : public Item {
 968 public:
 969     static Ref&lt;ClipOutToPath&gt; create(const Path&amp; path)
 970     {
 971         return adoptRef(*new ClipOutToPath(path));
 972     }
 973 
 974     WEBCORE_EXPORT virtual ~ClipOutToPath();
 975 
 976     const Path&amp; path() const { return m_path; }
 977 
 978     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 979     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipOutToPath&gt;&gt; decode(Decoder&amp;);
 980 
 981 private:
 982     WEBCORE_EXPORT ClipOutToPath(const Path&amp;);
 983 
 984     void apply(GraphicsContext&amp;) const override;
 985 
 986     const Path m_path;
 987 };
 988 
 989 template&lt;class Encoder&gt;
 990 void ClipOutToPath::encode(Encoder&amp; encoder) const
 991 {
 992     encoder &lt;&lt; m_path;
 993 }
 994 
 995 template&lt;class Decoder&gt;
 996 Optional&lt;Ref&lt;ClipOutToPath&gt;&gt; ClipOutToPath::decode(Decoder&amp; decoder)
 997 {
 998     Optional&lt;Path&gt; path;
 999     decoder &gt;&gt; path;
1000     if (!path)
1001         return WTF::nullopt;
1002 
1003     return ClipOutToPath::create(*path);
1004 }
1005 
1006 class ClipPath : public Item {
1007 public:
1008     static Ref&lt;ClipPath&gt; create(const Path&amp; path, WindRule windRule)
1009     {
1010         return adoptRef(*new ClipPath(path, windRule));
1011     }
1012 
1013     WEBCORE_EXPORT ~ClipPath();
1014 
1015     const Path&amp; path() const { return m_path; }
1016     WindRule windRule() const { return m_windRule; }
1017 
1018     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1019     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipPath&gt;&gt; decode(Decoder&amp;);
1020 
1021 private:
1022     WEBCORE_EXPORT ClipPath(const Path&amp;, WindRule);
1023 
1024     void apply(GraphicsContext&amp;) const override;
1025 
1026     const Path m_path;
1027     WindRule m_windRule;
1028 };
1029 
1030 template&lt;class Encoder&gt;
1031 void ClipPath::encode(Encoder&amp; encoder) const
1032 {
1033     encoder &lt;&lt; m_path;
1034     encoder &lt;&lt; m_windRule;
1035 }
1036 
1037 template&lt;class Decoder&gt;
1038 Optional&lt;Ref&lt;ClipPath&gt;&gt; ClipPath::decode(Decoder&amp; decoder)
1039 {
1040     Optional&lt;Path&gt; path;
1041     decoder &gt;&gt; path;
1042     if (!path)
1043         return WTF::nullopt;
1044 
1045     Optional&lt;WindRule&gt; windRule;
1046     decoder &gt;&gt; windRule;
1047     if (!windRule)
1048         return WTF::nullopt;
1049 
1050     return ClipPath::create(*path, *windRule);
1051 }
1052 
1053 class DrawGlyphs : public DrawingItem {
1054 public:
1055     static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
1056     {
1057         return adoptRef(*new DrawGlyphs(font, glyphs, advances, count, blockLocation, localAnchor, smoothingMode));
1058     }
1059 
1060     static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp; glyphs, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp; advances, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
1061     {
1062         return adoptRef(*new DrawGlyphs(font, WTFMove(glyphs), WTFMove(advances), blockLocation, localAnchor, smoothingMode));
1063     }
1064 
1065     WEBCORE_EXPORT virtual ~DrawGlyphs();
1066 
1067     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
1068     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
1069 
1070     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
1071 
1072     FloatPoint anchorPoint() const { return m_blockLocation + m_localAnchor; }
1073 
1074     const Vector&lt;GlyphBufferGlyph, 128&gt;&amp; glyphs() const { return m_glyphs; }
1075 
1076     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1077     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawGlyphs&gt;&gt; decode(Decoder&amp;);
1078 
1079 private:
1080     DrawGlyphs(const Font&amp;, const GlyphBufferGlyph*, const GlyphBufferAdvance*, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);
1081     WEBCORE_EXPORT DrawGlyphs(const Font&amp;, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp;, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp;, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);
1082 
1083     void computeBounds();
1084 
1085     void apply(GraphicsContext&amp;) const override;
1086 
1087     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1088 
1089     GlyphBuffer generateGlyphBuffer() const;
1090 
1091     Ref&lt;Font&gt; m_font;
1092     Vector&lt;GlyphBufferGlyph, 128&gt; m_glyphs;
1093     Vector&lt;GlyphBufferAdvance, 128&gt; m_advances;
1094     FloatRect m_bounds;
1095     FloatPoint m_blockLocation;
1096     FloatSize m_localAnchor;
1097     FontSmoothingMode m_smoothingMode;
1098 };
1099 
1100 template&lt;class Encoder&gt;
1101 void DrawGlyphs::encode(Encoder&amp; encoder) const
1102 {
1103     FontHandle handle;
1104     handle.font = m_font.ptr();
1105     encoder &lt;&lt; handle;
1106     encoder &lt;&lt; m_glyphs;
1107     encoder &lt;&lt; m_advances;
1108     encoder &lt;&lt; m_blockLocation;
1109     encoder &lt;&lt; m_localAnchor;
1110     encoder &lt;&lt; m_smoothingMode;
1111 }
1112 
1113 template&lt;class Decoder&gt;
1114 Optional&lt;Ref&lt;DrawGlyphs&gt;&gt; DrawGlyphs::decode(Decoder&amp; decoder)
1115 {
1116     Optional&lt;FontHandle&gt; handle;
1117     decoder &gt;&gt; handle;
1118     if (!handle || !handle-&gt;font)
1119         return WTF::nullopt;
1120 
1121     Optional&lt;Vector&lt;GlyphBufferGlyph, 128&gt;&gt; glyphs;
1122     decoder &gt;&gt; glyphs;
1123     if (!glyphs)
1124         return WTF::nullopt;
1125 
1126     Optional&lt;Vector&lt;GlyphBufferAdvance, 128&gt;&gt; advances;
1127     decoder &gt;&gt; advances;
1128     if (!advances)
1129         return WTF::nullopt;
1130 
1131     if (glyphs-&gt;size() != advances-&gt;size())
1132         return WTF::nullopt;
1133 
1134     Optional&lt;FloatPoint&gt; blockLocation;
1135     decoder &gt;&gt; blockLocation;
1136     if (!blockLocation)
1137         return WTF::nullopt;
1138 
1139     Optional&lt;FloatSize&gt; localAnchor;
1140     decoder &gt;&gt; localAnchor;
1141     if (!localAnchor)
1142         return WTF::nullopt;
1143 
1144     Optional&lt;FontSmoothingMode&gt; smoothingMode;
1145     decoder &gt;&gt; smoothingMode;
1146     if (!smoothingMode)
1147         return WTF::nullopt;
1148 
1149     return DrawGlyphs::create(handle-&gt;font.releaseNonNull(), WTFMove(*glyphs), WTFMove(*advances), *blockLocation, *localAnchor, *smoothingMode);
1150 }
1151 
1152 class DrawImage : public DrawingItem {
1153 public:
1154     static Ref&lt;DrawImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
1155     {
1156         return adoptRef(*new DrawImage(image, destination, source, imagePaintingOptions));
1157     }
1158 
1159     WEBCORE_EXPORT virtual ~DrawImage();
1160 
1161     const Image&amp; image() const { return m_image.get(); }
1162     FloatRect source() const { return m_source; }
1163     FloatRect destination() const { return m_destination; }
1164 
1165     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1166     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawImage&gt;&gt; decode(Decoder&amp;);
1167 
1168 private:
1169     WEBCORE_EXPORT DrawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp;);
1170 
1171     void apply(GraphicsContext&amp;) const override;
1172 
1173     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1174 
1175     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1176     FloatRect m_destination;
1177     FloatRect m_source;
1178     ImagePaintingOptions m_imagePaintingOptions;
1179 };
1180 
1181 template&lt;class Encoder&gt;
1182 void DrawImage::encode(Encoder&amp; encoder) const
1183 {
1184     ImageHandle imageHandle;
1185     imageHandle.image = m_image.ptr();
1186 
1187     encoder &lt;&lt; imageHandle;
1188     encoder &lt;&lt; m_destination;
1189     encoder &lt;&lt; m_source;
1190     encoder &lt;&lt; m_imagePaintingOptions;
1191 }
1192 
1193 template&lt;class Decoder&gt;
1194 Optional&lt;Ref&lt;DrawImage&gt;&gt; DrawImage::decode(Decoder&amp; decoder)
1195 {
1196     Optional&lt;ImageHandle&gt; imageHandle;
1197     decoder &gt;&gt; imageHandle;
1198     if (!imageHandle)
1199         return WTF::nullopt;
1200 
1201     Optional&lt;FloatRect&gt; destination;
1202     decoder &gt;&gt; destination;
1203     if (!destination)
1204         return WTF::nullopt;
1205 
1206     Optional&lt;FloatRect&gt; source;
1207     decoder &gt;&gt; source;
1208     if (!source)
1209         return WTF::nullopt;
1210 
1211     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;
1212     decoder &gt;&gt; imagePaintingOptions;
1213     if (!imagePaintingOptions)
1214         return WTF::nullopt;
1215 
1216     return DrawImage::create(*imageHandle-&gt;image, *destination, *source, *imagePaintingOptions);
1217 }
1218 
1219 class DrawTiledImage : public DrawingItem {
1220 public:
1221     static Ref&lt;DrawTiledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
1222     {
1223         return adoptRef(*new DrawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions));
1224     }
1225 
1226     WEBCORE_EXPORT virtual ~DrawTiledImage();
1227 
1228     const Image&amp; image() const { return m_image.get(); }
1229     FloatPoint source() const { return m_source; }
1230     FloatRect destination() const { return m_destination; }
1231 
1232     FloatSize tileSize() const { return m_tileSize; }
1233     FloatSize spacing() const { return m_spacing; }
1234 
1235     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1236     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawTiledImage&gt;&gt; decode(Decoder&amp;);
1237 
1238 private:
1239     WEBCORE_EXPORT DrawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp;);
1240 
1241     void apply(GraphicsContext&amp;) const override;
1242 
1243     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1244 
1245     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1246     FloatRect m_destination;
1247     FloatPoint m_source;
1248     FloatSize m_tileSize;
1249     FloatSize m_spacing;
1250     ImagePaintingOptions m_imagePaintingOptions;
1251 };
1252 
1253 template&lt;class Encoder&gt;
1254 void DrawTiledImage::encode(Encoder&amp; encoder) const
1255 {
1256     ImageHandle imageHandle;
1257     imageHandle.image = m_image.ptr();
1258     encoder &lt;&lt; imageHandle;
1259     encoder &lt;&lt; m_destination;
1260     encoder &lt;&lt; m_source;
1261     encoder &lt;&lt; m_tileSize;
1262     encoder &lt;&lt; m_spacing;
1263     encoder &lt;&lt; m_imagePaintingOptions;
1264 }
1265 
1266 template&lt;class Decoder&gt;
1267 Optional&lt;Ref&lt;DrawTiledImage&gt;&gt; DrawTiledImage::decode(Decoder&amp; decoder)
1268 {
1269     Optional&lt;ImageHandle&gt; imageHandle;
1270     decoder &gt;&gt; imageHandle;
1271     if (!imageHandle)
1272         return WTF::nullopt;
1273 
1274     Optional&lt;FloatRect&gt; destination;
1275     decoder &gt;&gt; destination;
1276     if (!destination)
1277         return WTF::nullopt;
1278 
1279     Optional&lt;FloatPoint&gt; source;
1280     decoder &gt;&gt; source;
1281     if (!source)
1282         return WTF::nullopt;
1283 
1284     Optional&lt;FloatSize&gt; tileSize;
1285     decoder &gt;&gt; tileSize;
1286     if (!tileSize)
1287         return WTF::nullopt;
1288 
1289     Optional&lt;FloatSize&gt; spacing;
1290     decoder &gt;&gt; spacing;
1291     if (!spacing)
1292         return WTF::nullopt;
1293 
1294     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;
1295     decoder &gt;&gt; imagePaintingOptions;
1296     if (!imagePaintingOptions)
1297         return WTF::nullopt;
1298 
1299     return DrawTiledImage::create(*imageHandle-&gt;image, *destination, *source, *tileSize, *spacing, *imagePaintingOptions);
1300 }
1301 
1302 class DrawTiledScaledImage : public DrawingItem {
1303 public:
1304     static Ref&lt;DrawTiledScaledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
1305     {
1306         return adoptRef(*new DrawTiledScaledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions));
1307     }
1308 
1309     WEBCORE_EXPORT virtual ~DrawTiledScaledImage();
1310 
1311     const Image&amp; image() const { return m_image.get(); }
1312     FloatRect source() const { return m_source; }
1313     FloatRect destination() const { return m_destination; }
1314 
1315     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1316     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawTiledScaledImage&gt;&gt; decode(Decoder&amp;);
1317 
1318 private:
1319     WEBCORE_EXPORT DrawTiledScaledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp;);
1320 
1321     void apply(GraphicsContext&amp;) const override;
1322 
1323     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1324 
1325     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1326     FloatRect m_destination;
1327     FloatRect m_source;
1328     FloatSize m_tileScaleFactor;
1329     Image::TileRule m_hRule;
1330     Image::TileRule m_vRule;
1331     ImagePaintingOptions m_imagePaintingOptions;
1332 };
1333 
1334 template&lt;class Encoder&gt;
1335 void DrawTiledScaledImage::encode(Encoder&amp; encoder) const
1336 {
1337     ImageHandle imageHandle;
1338     imageHandle.image = m_image.ptr();
1339     encoder &lt;&lt; imageHandle;
1340     encoder &lt;&lt; m_destination;
1341     encoder &lt;&lt; m_source;
1342     encoder &lt;&lt; m_tileScaleFactor;
1343     encoder.encodeEnum(m_hRule);
1344     encoder.encodeEnum(m_vRule);
1345     encoder &lt;&lt; m_imagePaintingOptions;
1346 }
1347 
1348 template&lt;class Decoder&gt;
1349 Optional&lt;Ref&lt;DrawTiledScaledImage&gt;&gt; DrawTiledScaledImage::decode(Decoder&amp; decoder)
1350 {
1351     Optional&lt;ImageHandle&gt; imageHandle;
1352     decoder &gt;&gt; imageHandle;
1353     if (!imageHandle)
1354         return WTF::nullopt;
1355 
1356     Optional&lt;FloatRect&gt; destination;
1357     decoder &gt;&gt; destination;
1358     if (!destination)
1359         return WTF::nullopt;
1360 
1361     Optional&lt;FloatRect&gt; source;
1362     decoder &gt;&gt; source;
1363     if (!source)
1364         return WTF::nullopt;
1365 
1366     Optional&lt;FloatSize&gt; tileScaleFactor;
1367     decoder &gt;&gt; tileScaleFactor;
1368     if (!tileScaleFactor)
1369         return WTF::nullopt;
1370 
1371     Image::TileRule hRule;
1372     if (!decoder.decodeEnum(hRule))
1373         return WTF::nullopt;
1374 
1375     Image::TileRule vRule;
1376     if (!decoder.decodeEnum(vRule))
1377         return WTF::nullopt;
1378 
1379     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;
1380     decoder &gt;&gt; imagePaintingOptions;
1381     if (!imagePaintingOptions)
1382         return WTF::nullopt;
1383 
1384     return DrawTiledScaledImage::create(*imageHandle-&gt;image, *destination, *source, *tileScaleFactor, hRule, vRule, *imagePaintingOptions);
1385 }
1386 
1387 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
1388 class DrawNativeImage : public DrawingItem {
1389 public:
1390     static Ref&lt;DrawNativeImage&gt; create(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
1391     {
1392         return adoptRef(*new DrawNativeImage(image, imageSize, destRect, srcRect, options));
1393     }
1394 
1395     WEBCORE_EXPORT virtual ~DrawNativeImage();
1396 
1397     FloatRect source() const { return m_srcRect; }
1398     FloatRect destinationRect() const { return m_destinationRect; }
1399 
1400     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1401     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawNativeImage&gt;&gt; decode(Decoder&amp;);
1402 
1403 private:
1404     WEBCORE_EXPORT DrawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp;);
1405 
1406     void apply(GraphicsContext&amp;) const override;
1407 
1408     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destinationRect; }
1409 
1410 #if USE(CG)
1411     NativeImagePtr m_image;
1412 #endif
1413     FloatSize m_imageSize;
1414     FloatRect m_destinationRect;
1415     FloatRect m_srcRect;
1416     ImagePaintingOptions m_options;
1417 };
1418 
1419 template&lt;class Encoder&gt;
1420 void DrawNativeImage::encode(Encoder&amp; encoder) const
1421 {
1422 #if USE(CG)
1423     NativeImageHandle handle { m_image };
1424     encoder &lt;&lt; handle;
1425 #endif
1426     encoder &lt;&lt; m_imageSize;
1427     encoder &lt;&lt; m_destinationRect;
1428     encoder &lt;&lt; m_srcRect;
1429     encoder &lt;&lt; m_options;
1430 }
1431 
1432 template&lt;class Decoder&gt;
1433 Optional&lt;Ref&lt;DrawNativeImage&gt;&gt; DrawNativeImage::decode(Decoder&amp; decoder)
1434 {
1435 #if USE(CG)
1436     Optional&lt;NativeImageHandle&gt; handle;
1437     decoder &gt;&gt; handle;
1438     if (!handle)
1439         return WTF::nullopt;
1440 #endif
1441 
1442     Optional&lt;FloatSize&gt; imageSize;
1443     decoder &gt;&gt; imageSize;
1444     if (!imageSize)
1445         return WTF::nullopt;
1446 
1447     Optional&lt;FloatRect&gt; destinationRect;
1448     decoder &gt;&gt; destinationRect;
1449     if (!destinationRect)
1450         return WTF::nullopt;
1451 
1452     Optional&lt;FloatRect&gt; srcRect;
1453     decoder &gt;&gt; srcRect;
1454     if (!srcRect)
1455         return WTF::nullopt;
1456 
1457     Optional&lt;ImagePaintingOptions&gt; options;
1458     decoder &gt;&gt; options;
1459     if (!options)
1460         return WTF::nullopt;
1461 
1462 #if USE(CG)
1463     NativeImagePtr image = handle-&gt;image;
1464 #else
1465     NativeImagePtr image = nullptr;
1466 #endif
1467     return DrawNativeImage::create(image, *imageSize, *destinationRect, *srcRect, *options);
1468 }
1469 #endif
1470 
1471 class DrawPattern : public DrawingItem {
1472 public:
1473     static Ref&lt;DrawPattern&gt; create(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
1474     {
1475         return adoptRef(*new DrawPattern(image, destRect, tileRect, patternTransform, phase, spacing, options));
1476     }
1477 
1478     WEBCORE_EXPORT virtual ~DrawPattern();
1479 
1480     const Image&amp; image() const { return m_image.get(); }
1481     const AffineTransform&amp; patternTransform() const { return m_patternTransform; }
1482     FloatRect tileRect() const { return m_tileRect; }
1483     FloatRect destRect() const { return m_destination; }
1484     FloatPoint phase() const { return m_phase; }
1485     FloatSize spacing() const { return m_spacing; }
1486 
1487     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1488     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawPattern&gt;&gt; decode(Decoder&amp;);
1489 
1490 private:
1491     WEBCORE_EXPORT DrawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
1492 
1493     void apply(GraphicsContext&amp;) const override;
1494 
1495     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1496 
1497     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1498     AffineTransform m_patternTransform;
1499     FloatRect m_tileRect;
1500     FloatRect m_destination;
1501     FloatPoint m_phase;
1502     FloatSize m_spacing;
1503     ImagePaintingOptions m_options;
1504 };
1505 
1506 template&lt;class Encoder&gt;
1507 void DrawPattern::encode(Encoder&amp; encoder) const
1508 {
1509     ImageHandle imageHandle;
1510     imageHandle.image = m_image.ptr();
1511     encoder &lt;&lt; imageHandle;
1512     encoder &lt;&lt; m_patternTransform;
1513     encoder &lt;&lt; m_tileRect;
1514     encoder &lt;&lt; m_destination;
1515     encoder &lt;&lt; m_phase;
1516     encoder &lt;&lt; m_spacing;
1517     encoder &lt;&lt; m_options;
1518 }
1519 
1520 template&lt;class Decoder&gt;
1521 Optional&lt;Ref&lt;DrawPattern&gt;&gt; DrawPattern::decode(Decoder&amp; decoder)
1522 {
1523     Optional&lt;ImageHandle&gt; imageHandle;
1524     decoder &gt;&gt; imageHandle;
1525     if (!imageHandle)
1526         return WTF::nullopt;
1527 
1528     Optional&lt;AffineTransform&gt; patternTransform;
1529     decoder &gt;&gt; patternTransform;
1530     if (!patternTransform)
1531         return WTF::nullopt;
1532 
1533     Optional&lt;FloatRect&gt; tileRect;
1534     decoder &gt;&gt; tileRect;
1535     if (!tileRect)
1536         return WTF::nullopt;
1537 
1538     Optional&lt;FloatRect&gt; destination;
1539     decoder &gt;&gt; destination;
1540     if (!destination)
1541         return WTF::nullopt;
1542 
1543     Optional&lt;FloatPoint&gt; phase;
1544     decoder &gt;&gt; phase;
1545     if (!phase)
1546         return WTF::nullopt;
1547 
1548     Optional&lt;FloatSize&gt; spacing;
1549     decoder &gt;&gt; spacing;
1550     if (!spacing)
1551         return WTF::nullopt;
1552 
1553     Optional&lt;ImagePaintingOptions&gt; options;
1554     decoder &gt;&gt; options;
1555     if (!options)
1556         return WTF::nullopt;
1557 
1558     return DrawPattern::create(*imageHandle-&gt;image, *destination, *tileRect, *patternTransform, *phase, *spacing, *options);
1559 }
1560 
1561 // Is DrawingItem because the size of the transparency layer is implicitly the clip bounds.
1562 class BeginTransparencyLayer : public DrawingItem {
1563 public:
1564     static Ref&lt;BeginTransparencyLayer&gt; create(float opacity)
1565     {
1566         return adoptRef(*new BeginTransparencyLayer(opacity));
1567     }
1568 
1569     WEBCORE_EXPORT virtual ~BeginTransparencyLayer();
1570 
1571     float opacity() const { return m_opacity; }
1572 
1573     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1574     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;BeginTransparencyLayer&gt;&gt; decode(Decoder&amp;);
1575 
1576 private:
1577     WEBCORE_EXPORT BeginTransparencyLayer(float opacity);
1578 
1579     void apply(GraphicsContext&amp;) const override;
1580 
1581     float m_opacity;
1582 };
1583 
1584 template&lt;class Encoder&gt;
1585 void BeginTransparencyLayer::encode(Encoder&amp; encoder) const
1586 {
1587     encoder &lt;&lt; m_opacity;
1588 }
1589 
1590 template&lt;class Decoder&gt;
1591 Optional&lt;Ref&lt;BeginTransparencyLayer&gt;&gt; BeginTransparencyLayer::decode(Decoder&amp; decoder)
1592 {
1593     Optional&lt;float&gt; opacity;
1594     decoder &gt;&gt; opacity;
1595     if (!opacity)
1596         return WTF::nullopt;
1597 
1598     return BeginTransparencyLayer::create(*opacity);
1599 }
1600 
1601 class EndTransparencyLayer : public DrawingItem {
1602 public:
1603     static Ref&lt;EndTransparencyLayer&gt; create()
1604     {
1605         return adoptRef(*new EndTransparencyLayer);
1606     }
1607 
1608     WEBCORE_EXPORT virtual ~EndTransparencyLayer();
1609 
1610     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1611     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;EndTransparencyLayer&gt;&gt; decode(Decoder&amp;);
1612 
1613 private:
1614     WEBCORE_EXPORT EndTransparencyLayer();
1615 
1616     void apply(GraphicsContext&amp;) const override;
1617 };
1618 
1619 template&lt;class Encoder&gt;
1620 void EndTransparencyLayer::encode(Encoder&amp;) const
1621 {
1622 }
1623 
1624 template&lt;class Decoder&gt;
1625 Optional&lt;Ref&lt;EndTransparencyLayer&gt;&gt; EndTransparencyLayer::decode(Decoder&amp;)
1626 {
1627     return EndTransparencyLayer::create();
1628 }
1629 
1630 class DrawRect : public DrawingItem {
1631 public:
1632     static Ref&lt;DrawRect&gt; create(const FloatRect&amp; rect, float borderThickness)
1633     {
1634         return adoptRef(*new DrawRect(rect, borderThickness));
1635     }
1636 
1637     WEBCORE_EXPORT virtual ~DrawRect();
1638 
1639     FloatRect rect() const { return m_rect; }
1640     float borderThickness() const { return m_borderThickness; }
1641 
1642     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1643     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawRect&gt;&gt; decode(Decoder&amp;);
1644 
1645 private:
1646     WEBCORE_EXPORT DrawRect(const FloatRect&amp;, float borderThickness);
1647 
1648     void apply(GraphicsContext&amp;) const override;
1649     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1650 
1651     FloatRect m_rect;
1652     float m_borderThickness;
1653 };
1654 
1655 template&lt;class Encoder&gt;
1656 void DrawRect::encode(Encoder&amp; encoder) const
1657 {
1658     encoder &lt;&lt; m_rect;
1659     encoder &lt;&lt; m_borderThickness;
1660 }
1661 
1662 template&lt;class Decoder&gt;
1663 Optional&lt;Ref&lt;DrawRect&gt;&gt; DrawRect::decode(Decoder&amp; decoder)
1664 {
1665     Optional&lt;FloatRect&gt; rect;
1666     decoder &gt;&gt; rect;
1667     if (!rect)
1668         return WTF::nullopt;
1669 
1670     Optional&lt;float&gt; borderThickness;
1671     decoder &gt;&gt; borderThickness;
1672     if (!borderThickness)
1673         return WTF::nullopt;
1674 
1675     return DrawRect::create(*rect, *borderThickness);
1676 }
1677 
1678 class DrawLine : public DrawingItem {
1679 public:
1680     static Ref&lt;DrawLine&gt; create(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
1681     {
1682         return adoptRef(*new DrawLine(point1, point2));
1683     }
1684 
1685     WEBCORE_EXPORT virtual ~DrawLine();
1686 
1687     FloatPoint point1() const { return m_point1; }
1688     FloatPoint point2() const { return m_point2; }
1689 
1690     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1691     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawLine&gt;&gt; decode(Decoder&amp;);
1692 
1693 private:
1694     WEBCORE_EXPORT DrawLine(const FloatPoint&amp;, const FloatPoint&amp;);
1695 
1696     void apply(GraphicsContext&amp;) const override;
1697     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1698 
1699     FloatPoint m_point1;
1700     FloatPoint m_point2;
1701 };
1702 
1703 template&lt;class Encoder&gt;
1704 void DrawLine::encode(Encoder&amp; encoder) const
1705 {
1706     encoder &lt;&lt; m_point1;
1707     encoder &lt;&lt; m_point2;
1708 }
1709 
1710 template&lt;class Decoder&gt;
1711 Optional&lt;Ref&lt;DrawLine&gt;&gt; DrawLine::decode(Decoder&amp; decoder)
1712 {
1713     Optional&lt;FloatPoint&gt; point1;
1714     decoder &gt;&gt; point1;
1715     if (!point1)
1716         return WTF::nullopt;
1717 
1718     Optional&lt;FloatPoint&gt; point2;
1719     decoder &gt;&gt; point2;
1720     if (!point2)
1721         return WTF::nullopt;
1722 
1723     return DrawLine::create(*point1, *point2);
1724 }
1725 
1726 class DrawLinesForText : public DrawingItem {
1727 public:
1728     static Ref&lt;DrawLinesForText&gt; create(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
1729     {
1730         return adoptRef(*new DrawLinesForText(blockLocation, localAnchor, thickness, widths, printing, doubleLines));
1731     }
1732 
1733     WEBCORE_EXPORT virtual ~DrawLinesForText();
1734 
1735     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
1736     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
1737     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
1738     FloatPoint point() const { return m_blockLocation + m_localAnchor; }
1739     float thickness() const { return m_thickness; }
1740     const DashArray&amp; widths() const { return m_widths; }
1741     bool isPrinting() const { return m_printing; }
1742     bool doubleLines() const { return m_doubleLines; }
1743 
1744     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1745     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawLinesForText&gt;&gt; decode(Decoder&amp;);
1746 
1747 private:
1748     WEBCORE_EXPORT DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines);
1749 
1750     void apply(GraphicsContext&amp;) const override;
1751 
1752     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1753 
1754     FloatPoint m_blockLocation;
1755     FloatSize m_localAnchor;
1756     DashArray m_widths;
1757     float m_thickness;
1758     bool m_printing;
1759     bool m_doubleLines;
1760 };
1761 
1762 template&lt;class Encoder&gt;
1763 void DrawLinesForText::encode(Encoder&amp; encoder) const
1764 {
1765     encoder &lt;&lt; m_blockLocation;
1766     encoder &lt;&lt; m_localAnchor;
1767     encoder &lt;&lt; m_widths;
1768     encoder &lt;&lt; m_thickness;
1769     encoder &lt;&lt; m_printing;
1770     encoder &lt;&lt; m_doubleLines;
1771 }
1772 
1773 template&lt;class Decoder&gt;
1774 Optional&lt;Ref&lt;DrawLinesForText&gt;&gt; DrawLinesForText::decode(Decoder&amp; decoder)
1775 {
1776     Optional&lt;FloatPoint&gt; blockLocation;
1777     decoder &gt;&gt; blockLocation;
1778     if (!blockLocation)
1779         return WTF::nullopt;
1780 
1781     Optional&lt;FloatSize&gt; localAnchor;
1782     decoder &gt;&gt; localAnchor;
1783     if (!localAnchor)
1784         return WTF::nullopt;
1785 
1786     Optional&lt;DashArray&gt; widths;
1787     decoder &gt;&gt; widths;
1788     if (!widths)
1789         return WTF::nullopt;
1790 
1791     Optional&lt;float&gt; thickness;
1792     decoder &gt;&gt; thickness;
1793     if (!thickness)
1794         return WTF::nullopt;
1795 
1796     Optional&lt;bool&gt; printing;
1797     decoder &gt;&gt; printing;
1798     if (!printing)
1799         return WTF::nullopt;
1800 
1801     Optional&lt;bool&gt; doubleLines;
1802     decoder &gt;&gt; doubleLines;
1803     if (!doubleLines)
1804         return WTF::nullopt;
1805 
1806     return DrawLinesForText::create(*blockLocation, *localAnchor, *thickness, *widths, *printing, *doubleLines);
1807 }
1808 
1809 class DrawDotsForDocumentMarker : public DrawingItem {
1810 public:
1811     static Ref&lt;DrawDotsForDocumentMarker&gt; create(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
1812     {
1813         return adoptRef(*new DrawDotsForDocumentMarker(rect, style));
1814     }
1815 
1816     WEBCORE_EXPORT virtual ~DrawDotsForDocumentMarker();
1817 
1818     FloatRect rect() const { return m_rect; }
1819 
1820     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1821     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawDotsForDocumentMarker&gt;&gt; decode(Decoder&amp;);
1822 
1823 private:
1824     WEBCORE_EXPORT DrawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);
1825 
1826     void apply(GraphicsContext&amp;) const override;
1827 
1828     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1829 
1830     FloatRect m_rect;
1831     DocumentMarkerLineStyle m_style;
1832 };
1833 
1834 template&lt;class Encoder&gt;
1835 void DrawDotsForDocumentMarker::encode(Encoder&amp; encoder) const
1836 {
1837     encoder &lt;&lt; m_rect;
1838     encoder &lt;&lt; m_style;
1839 }
1840 
1841 template&lt;class Decoder&gt;
1842 Optional&lt;Ref&lt;DrawDotsForDocumentMarker&gt;&gt; DrawDotsForDocumentMarker::decode(Decoder&amp; decoder)
1843 {
1844     Optional&lt;FloatRect&gt; rect;
1845     decoder &gt;&gt; rect;
1846     if (!rect)
1847         return WTF::nullopt;
1848 
1849     Optional&lt;DocumentMarkerLineStyle&gt; style;
1850     decoder &gt;&gt; style;
1851     if (!style)
1852         return WTF::nullopt;
1853 
1854     return DrawDotsForDocumentMarker::create(*rect, *style);
1855 }
1856 
1857 class DrawEllipse : public DrawingItem {
1858 public:
1859     static Ref&lt;DrawEllipse&gt; create(const FloatRect&amp; rect)
1860     {
1861         return adoptRef(*new DrawEllipse(rect));
1862     }
1863 
1864     WEBCORE_EXPORT ~DrawEllipse();
1865 
1866     FloatRect rect() const { return m_rect; }
1867 
1868     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1869     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawEllipse&gt;&gt; decode(Decoder&amp;);
1870 
1871 private:
1872     WEBCORE_EXPORT DrawEllipse(const FloatRect&amp;);
1873 
1874     void apply(GraphicsContext&amp;) const override;
1875     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1876 
1877     FloatRect m_rect;
1878 };
1879 
1880 template&lt;class Encoder&gt;
1881 void DrawEllipse::encode(Encoder&amp; encoder) const
1882 {
1883     encoder &lt;&lt; m_rect;
1884 }
1885 
1886 template&lt;class Decoder&gt;
1887 Optional&lt;Ref&lt;DrawEllipse&gt;&gt; DrawEllipse::decode(Decoder&amp; decoder)
1888 {
1889     Optional&lt;FloatRect&gt; rect;
1890     decoder &gt;&gt; rect;
1891     if (!rect)
1892         return WTF::nullopt;
1893 
1894     return DrawEllipse::create(*rect);
1895 }
1896 
1897 class DrawPath : public DrawingItem {
1898 public:
1899     static Ref&lt;DrawPath&gt; create(const Path&amp; path)
1900     {
1901         return adoptRef(*new DrawPath(path));
1902     }
1903 
1904     WEBCORE_EXPORT virtual ~DrawPath();
1905 
1906     const Path&amp; path() const { return m_path; }
1907 
1908     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1909     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawPath&gt;&gt; decode(Decoder&amp;);
1910 
1911 private:
1912     WEBCORE_EXPORT DrawPath(const Path&amp;);
1913 
1914     void apply(GraphicsContext&amp;) const override;
1915 
1916     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
1917 
1918     const Path m_path;
1919 };
1920 
1921 template&lt;class Encoder&gt;
1922 void DrawPath::encode(Encoder&amp; encoder) const
1923 {
1924     encoder &lt;&lt; m_path;
1925 }
1926 
1927 template&lt;class Decoder&gt;
1928 Optional&lt;Ref&lt;DrawPath&gt;&gt; DrawPath::decode(Decoder&amp; decoder)
1929 {
1930     Optional&lt;Path&gt; path;
1931     decoder &gt;&gt; path;
1932     if (!path)
1933         return WTF::nullopt;
1934 
1935     return DrawPath::create(*path);
1936 }
1937 
1938 class DrawFocusRingPath : public DrawingItem {
1939 public:
1940     static Ref&lt;DrawFocusRingPath&gt; create(const Path&amp; path, float width, float offset, const Color&amp; color)
1941     {
1942         return adoptRef(*new DrawFocusRingPath(path, width, offset, color));
1943     }
1944 
1945     WEBCORE_EXPORT virtual ~DrawFocusRingPath();
1946 
1947     const Path&amp; path() const { return m_path; }
1948     float width() const { return m_width; }
1949     float offset() const { return m_offset; }
1950     const Color&amp; color() const { return m_color; }
1951 
1952     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
1953     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawFocusRingPath&gt;&gt; decode(Decoder&amp;);
1954 
1955 private:
1956     WEBCORE_EXPORT DrawFocusRingPath(const Path&amp;, float width, float offset, const Color&amp;);
1957 
1958     void apply(GraphicsContext&amp;) const override;
1959 
1960     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1961 
1962     const Path m_path;
1963     float m_width;
1964     float m_offset;
1965     Color m_color;
1966 };
1967 
1968 template&lt;class Encoder&gt;
1969 void DrawFocusRingPath::encode(Encoder&amp; encoder) const
1970 {
1971     encoder &lt;&lt; m_path;
1972     encoder &lt;&lt; m_width;
1973     encoder &lt;&lt; m_offset;
1974     encoder &lt;&lt; m_color;
1975 }
1976 
1977 template&lt;class Decoder&gt;
1978 Optional&lt;Ref&lt;DrawFocusRingPath&gt;&gt; DrawFocusRingPath::decode(Decoder&amp; decoder)
1979 {
1980     Optional&lt;Path&gt; path;
1981     decoder &gt;&gt; path;
1982     if (!path)
1983         return WTF::nullopt;
1984 
1985     Optional&lt;float&gt; width;
1986     decoder &gt;&gt; width;
1987     if (!width)
1988         return WTF::nullopt;
1989 
1990     Optional&lt;float&gt; offset;
1991     decoder &gt;&gt; offset;
1992     if (!offset)
1993         return WTF::nullopt;
1994 
1995     Optional&lt;Color&gt; color;
1996     decoder &gt;&gt; color;
1997     if (!color)
1998         return WTF::nullopt;
1999 
2000     return DrawFocusRingPath::create(*path, *width, *offset, *color);
2001 }
2002 
2003 class DrawFocusRingRects : public DrawingItem {
2004 public:
2005     static Ref&lt;DrawFocusRingRects&gt; create(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
2006     {
2007         return adoptRef(*new DrawFocusRingRects(rects, width, offset, color));
2008     }
2009 
2010     WEBCORE_EXPORT virtual ~DrawFocusRingRects();
2011 
2012     const Vector&lt;FloatRect&gt; rects() const { return m_rects; }
2013     float width() const { return m_width; }
2014     float offset() const { return m_offset; }
2015     const Color&amp; color() const { return m_color; }
2016 
2017     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2018     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawFocusRingRects&gt;&gt; decode(Decoder&amp;);
2019 
2020 private:
2021     WEBCORE_EXPORT DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp;, float width, float offset, const Color&amp;);
2022 
2023     void apply(GraphicsContext&amp;) const override;
2024 
2025     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2026 
2027     Vector&lt;FloatRect&gt; m_rects;
2028     float m_width;
2029     float m_offset;
2030     Color m_color;
2031 };
2032 
2033 template&lt;class Encoder&gt;
2034 void DrawFocusRingRects::encode(Encoder&amp; encoder) const
2035 {
2036     encoder &lt;&lt; m_rects;
2037     encoder &lt;&lt; m_width;
2038     encoder &lt;&lt; m_offset;
2039     encoder &lt;&lt; m_color;
2040 }
2041 
2042 template&lt;class Decoder&gt;
2043 Optional&lt;Ref&lt;DrawFocusRingRects&gt;&gt; DrawFocusRingRects::decode(Decoder&amp; decoder)
2044 {
2045     Optional&lt;Vector&lt;FloatRect&gt;&gt; rects;
2046     decoder &gt;&gt; rects;
2047     if (!rects)
2048         return WTF::nullopt;
2049 
2050     Optional&lt;float&gt; width;
2051     decoder &gt;&gt; width;
2052     if (!width)
2053         return WTF::nullopt;
2054 
2055     Optional&lt;float&gt; offset;
2056     decoder &gt;&gt; offset;
2057     if (!offset)
2058         return WTF::nullopt;
2059 
2060     Optional&lt;Color&gt; color;
2061     decoder &gt;&gt; color;
2062     if (!color)
2063         return WTF::nullopt;
2064 
2065     return DrawFocusRingRects::create(*rects, *width, *offset, *color);
2066 }
2067 
2068 class FillRect : public DrawingItem {
2069 public:
2070     static Ref&lt;FillRect&gt; create(const FloatRect&amp; rect)
2071     {
2072         return adoptRef(*new FillRect(rect));
2073     }
2074 
2075     WEBCORE_EXPORT virtual ~FillRect();
2076 
2077     FloatRect rect() const { return m_rect; }
2078 
2079     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2080     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRect&gt;&gt; decode(Decoder&amp;);
2081 
2082 private:
2083     WEBCORE_EXPORT FillRect(const FloatRect&amp;);
2084 
2085     void apply(GraphicsContext&amp;) const override;
2086     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2087 
2088     FloatRect m_rect;
2089 };
2090 
2091 template&lt;class Encoder&gt;
2092 void FillRect::encode(Encoder&amp; encoder) const
2093 {
2094     encoder &lt;&lt; m_rect;
2095 }
2096 
2097 template&lt;class Decoder&gt;
2098 Optional&lt;Ref&lt;FillRect&gt;&gt; FillRect::decode(Decoder&amp; decoder)
2099 {
2100     Optional&lt;FloatRect&gt; rect;
2101     decoder &gt;&gt; rect;
2102     if (!rect)
2103         return WTF::nullopt;
2104 
2105     return FillRect::create(*rect);
2106 }
2107 
2108 // FIXME: Make these inherit from FillRect proper.
2109 class FillRectWithColor : public DrawingItem {
2110 public:
2111     static Ref&lt;FillRectWithColor&gt; create(const FloatRect&amp; rect, const Color&amp; color)
2112     {
2113         return adoptRef(*new FillRectWithColor(rect, color));
2114     }
2115 
2116     WEBCORE_EXPORT virtual ~FillRectWithColor();
2117 
2118     FloatRect rect() const { return m_rect; }
2119     const Color&amp; color() const { return m_color; }
2120 
2121     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2122     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithColor&gt;&gt; decode(Decoder&amp;);
2123 
2124 private:
2125     WEBCORE_EXPORT FillRectWithColor(const FloatRect&amp;, const Color&amp;);
2126 
2127     void apply(GraphicsContext&amp;) const override;
2128     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2129 
2130     FloatRect m_rect;
2131     Color m_color;
2132 };
2133 
2134 template&lt;class Encoder&gt;
2135 void FillRectWithColor::encode(Encoder&amp; encoder) const
2136 {
2137     encoder &lt;&lt; m_rect;
2138     encoder &lt;&lt; m_color;
2139 }
2140 
2141 template&lt;class Decoder&gt;
2142 Optional&lt;Ref&lt;FillRectWithColor&gt;&gt; FillRectWithColor::decode(Decoder&amp; decoder)
2143 {
2144     Optional&lt;FloatRect&gt; rect;
2145     decoder &gt;&gt; rect;
2146     if (!rect)
2147         return WTF::nullopt;
2148 
2149     Optional&lt;Color&gt; color;
2150     decoder &gt;&gt; color;
2151     if (!color)
2152         return WTF::nullopt;
2153 
2154     return FillRectWithColor::create(*rect, *color);
2155 }
2156 
2157 class FillRectWithGradient : public DrawingItem {
2158 public:
2159     static Ref&lt;FillRectWithGradient&gt; create(const FloatRect&amp; rect, Gradient&amp; gradient)
2160     {
2161         return adoptRef(*new FillRectWithGradient(rect, gradient));
2162     }
2163 
2164     WEBCORE_EXPORT virtual ~FillRectWithGradient();
2165 
2166     FloatRect rect() const { return m_rect; }
2167 
2168     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2169     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithGradient&gt;&gt; decode(Decoder&amp;);
2170 
2171 private:
2172     WEBCORE_EXPORT FillRectWithGradient(const FloatRect&amp;, Gradient&amp;);
2173 
2174     void apply(GraphicsContext&amp;) const override;
2175     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2176 
2177     FloatRect m_rect;
2178     mutable Ref&lt;Gradient&gt; m_gradient; // FIXME: Make this not mutable
2179 };
2180 
2181 template&lt;class Encoder&gt;
2182 void FillRectWithGradient::encode(Encoder&amp; encoder) const
2183 {
2184     encoder &lt;&lt; m_rect;
2185     encoder &lt;&lt; m_gradient.get();
2186 }
2187 
2188 template&lt;class Decoder&gt;
2189 Optional&lt;Ref&lt;FillRectWithGradient&gt;&gt; FillRectWithGradient::decode(Decoder&amp; decoder)
2190 {
2191     Optional&lt;FloatRect&gt; rect;
2192     decoder &gt;&gt; rect;
2193     if (!rect)
2194         return WTF::nullopt;
2195 
2196     auto gradient = Gradient::decode(decoder);
2197     if (!gradient)
2198         return WTF::nullopt;
2199 
2200     return FillRectWithGradient::create(*rect, gradient-&gt;get());
2201 }
2202 
2203 class FillCompositedRect : public DrawingItem {
2204 public:
2205     static Ref&lt;FillCompositedRect&gt; create(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
2206     {
2207         return adoptRef(*new FillCompositedRect(rect, color, op, blendMode));
2208     }
2209 
2210     WEBCORE_EXPORT virtual ~FillCompositedRect();
2211 
2212     FloatRect rect() const { return m_rect; }
2213     const Color&amp; color() const { return m_color; }
2214     CompositeOperator compositeOperator() const { return m_op; }
2215     BlendMode blendMode() const { return m_blendMode; }
2216 
2217     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2218     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillCompositedRect&gt;&gt; decode(Decoder&amp;);
2219 
2220 private:
2221     WEBCORE_EXPORT FillCompositedRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode);
2222 
2223     void apply(GraphicsContext&amp;) const override;
2224     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2225 
2226     FloatRect m_rect;
2227     Color m_color;
2228     CompositeOperator m_op;
2229     BlendMode m_blendMode;
2230 };
2231 
2232 template&lt;class Encoder&gt;
2233 void FillCompositedRect::encode(Encoder&amp; encoder) const
2234 {
2235     encoder &lt;&lt; m_rect;
2236     encoder &lt;&lt; m_color;
2237     encoder &lt;&lt; m_op;
2238     encoder &lt;&lt; m_blendMode;
2239 }
2240 
2241 template&lt;class Decoder&gt;
2242 Optional&lt;Ref&lt;FillCompositedRect&gt;&gt; FillCompositedRect::decode(Decoder&amp; decoder)
2243 {
2244     Optional&lt;FloatRect&gt; rect;
2245     decoder &gt;&gt; rect;
2246     if (!rect)
2247         return WTF::nullopt;
2248 
2249     Optional&lt;Color&gt; color;
2250     decoder &gt;&gt; color;
2251     if (!color)
2252         return WTF::nullopt;
2253 
2254     Optional&lt;CompositeOperator&gt; op;
2255     decoder &gt;&gt; op;
2256     if (!op)
2257         return WTF::nullopt;
2258 
2259     Optional&lt;BlendMode&gt; blendMode;
2260     decoder &gt;&gt; blendMode;
2261     if (!blendMode)
2262         return WTF::nullopt;
2263 
2264     return FillCompositedRect::create(*rect, *color, *op, *blendMode);
2265 }
2266 
2267 class FillRoundedRect : public DrawingItem {
2268 public:
2269     static Ref&lt;FillRoundedRect&gt; create(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
2270     {
2271         return adoptRef(*new FillRoundedRect(rect, color, blendMode));
2272     }
2273 
2274     WEBCORE_EXPORT virtual ~FillRoundedRect();
2275 
2276     const FloatRoundedRect&amp; roundedRect() const { return m_rect; }
2277     const Color&amp; color() const { return m_color; }
2278     BlendMode blendMode() const { return m_blendMode; }
2279 
2280     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2281     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRoundedRect&gt;&gt; decode(Decoder&amp;);
2282 
2283 private:
2284     WEBCORE_EXPORT FillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode);
2285 
2286     void apply(GraphicsContext&amp;) const override;
2287     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect.rect(); }
2288 
2289     FloatRoundedRect m_rect;
2290     Color m_color;
2291     BlendMode m_blendMode;
2292 };
2293 
2294 template&lt;class Encoder&gt;
2295 void FillRoundedRect::encode(Encoder&amp; encoder) const
2296 {
2297     encoder &lt;&lt; m_rect;
2298     encoder &lt;&lt; m_color;
2299     encoder &lt;&lt; m_blendMode;
2300 }
2301 
2302 template&lt;class Decoder&gt;
2303 Optional&lt;Ref&lt;FillRoundedRect&gt;&gt; FillRoundedRect::decode(Decoder&amp; decoder)
2304 {
2305     Optional&lt;FloatRoundedRect&gt; rect;
2306     decoder &gt;&gt; rect;
2307     if (!rect)
2308         return WTF::nullopt;
2309 
2310     Optional&lt;Color&gt; color;
2311     decoder &gt;&gt; color;
2312     if (!color)
2313         return WTF::nullopt;
2314 
2315     Optional&lt;BlendMode&gt; blendMode;
2316     decoder &gt;&gt; blendMode;
2317     if (!blendMode)
2318         return WTF::nullopt;
2319 
2320     return FillRoundedRect::create(*rect, *color, *blendMode);
2321 }
2322 
2323 class FillRectWithRoundedHole : public DrawingItem {
2324 public:
2325     static Ref&lt;FillRectWithRoundedHole&gt; create(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
2326     {
2327         return adoptRef(*new FillRectWithRoundedHole(rect, roundedHoleRect, color));
2328     }
2329 
2330     WEBCORE_EXPORT virtual ~FillRectWithRoundedHole();
2331 
2332     const FloatRect&amp; rect() const { return m_rect; }
2333     const FloatRoundedRect&amp; roundedHoleRect() const { return m_roundedHoleRect; }
2334     const Color&amp; color() const { return m_color; }
2335 
2336     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2337     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithRoundedHole&gt;&gt; decode(Decoder&amp;);
2338 
2339 private:
2340     WEBCORE_EXPORT FillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp;, const Color&amp;);
2341 
2342     void apply(GraphicsContext&amp;) const override;
2343     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2344 
2345     FloatRect m_rect;
2346     FloatRoundedRect m_roundedHoleRect;
2347     Color m_color;
2348 };
2349 
2350 template&lt;class Encoder&gt;
2351 void FillRectWithRoundedHole::encode(Encoder&amp; encoder) const
2352 {
2353     encoder &lt;&lt; m_rect;
2354     encoder &lt;&lt; m_roundedHoleRect;
2355     encoder &lt;&lt; m_color;
2356 }
2357 
2358 template&lt;class Decoder&gt;
2359 Optional&lt;Ref&lt;FillRectWithRoundedHole&gt;&gt; FillRectWithRoundedHole::decode(Decoder&amp; decoder)
2360 {
2361     Optional&lt;FloatRect&gt; rect;
2362     decoder &gt;&gt; rect;
2363     if (!rect)
2364         return WTF::nullopt;
2365 
2366     Optional&lt;FloatRoundedRect&gt; roundedHoleRect;
2367     decoder &gt;&gt; roundedHoleRect;
2368     if (!roundedHoleRect)
2369         return WTF::nullopt;
2370 
2371     Optional&lt;Color&gt; color;
2372     decoder &gt;&gt; color;
2373     if (!color)
2374         return WTF::nullopt;
2375 
2376     return FillRectWithRoundedHole::create(*rect, *roundedHoleRect, *color);
2377 }
2378 
2379 class FillPath : public DrawingItem {
2380 public:
2381     static Ref&lt;FillPath&gt; create(const Path&amp; path)
2382     {
2383         return adoptRef(*new FillPath(path));
2384     }
2385 
2386     WEBCORE_EXPORT virtual ~FillPath();
2387 
2388     const Path&amp; path() const { return m_path; }
2389 
2390     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2391     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillPath&gt;&gt; decode(Decoder&amp;);
2392 
2393 private:
2394     WEBCORE_EXPORT FillPath(const Path&amp;);
2395 
2396     void apply(GraphicsContext&amp;) const override;
2397     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
2398 
2399     const Path m_path;
2400 };
2401 
2402 template&lt;class Encoder&gt;
2403 void FillPath::encode(Encoder&amp; encoder) const
2404 {
2405     encoder &lt;&lt; m_path;
2406 }
2407 
2408 template&lt;class Decoder&gt;
2409 Optional&lt;Ref&lt;FillPath&gt;&gt; FillPath::decode(Decoder&amp; decoder)
2410 {
2411     Optional&lt;Path&gt; path;
2412     decoder &gt;&gt; path;
2413     if (!path)
2414         return WTF::nullopt;
2415 
2416     return FillPath::create(*path);
2417 }
2418 
2419 class FillEllipse : public DrawingItem {
2420 public:
2421     static Ref&lt;FillEllipse&gt; create(const FloatRect&amp; rect)
2422     {
2423         return adoptRef(*new FillEllipse(rect));
2424     }
2425 
2426     WEBCORE_EXPORT virtual ~FillEllipse();
2427 
2428     FloatRect rect() const { return m_rect; }
2429 
2430     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2431     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillEllipse&gt;&gt; decode(Decoder&amp;);
2432 
2433 private:
2434     WEBCORE_EXPORT FillEllipse(const FloatRect&amp;);
2435 
2436     void apply(GraphicsContext&amp;) const override;
2437 
2438     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2439 
2440     FloatRect m_rect;
2441 };
2442 
2443 template&lt;class Encoder&gt;
2444 void FillEllipse::encode(Encoder&amp; encoder) const
2445 {
2446     encoder &lt;&lt; m_rect;
2447 }
2448 
2449 template&lt;class Decoder&gt;
2450 Optional&lt;Ref&lt;FillEllipse&gt;&gt; FillEllipse::decode(Decoder&amp; decoder)
2451 {
2452     Optional&lt;FloatRect&gt; rect;
2453     decoder &gt;&gt; rect;
2454     if (!rect)
2455         return WTF::nullopt;
2456 
2457     return FillEllipse::create(*rect);
2458 }
2459 
2460 class StrokeRect : public DrawingItem {
2461 public:
2462     static Ref&lt;StrokeRect&gt; create(const FloatRect&amp; rect, float lineWidth)
2463     {
2464         return adoptRef(*new StrokeRect(rect, lineWidth));
2465     }
2466 
2467     WEBCORE_EXPORT virtual ~StrokeRect();
2468 
2469     FloatRect rect() const { return m_rect; }
2470     float lineWidth() const { return m_lineWidth; }
2471 
2472     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2473     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokeRect&gt;&gt; decode(Decoder&amp;);
2474 
2475 private:
2476     WEBCORE_EXPORT StrokeRect(const FloatRect&amp;, float);
2477 
2478     void apply(GraphicsContext&amp;) const override;
2479     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2480 
2481     FloatRect m_rect;
2482     float m_lineWidth;
2483 };
2484 
2485 template&lt;class Encoder&gt;
2486 void StrokeRect::encode(Encoder&amp; encoder) const
2487 {
2488     encoder &lt;&lt; m_rect;
2489     encoder &lt;&lt; m_lineWidth;
2490 }
2491 
2492 template&lt;class Decoder&gt;
2493 Optional&lt;Ref&lt;StrokeRect&gt;&gt; StrokeRect::decode(Decoder&amp; decoder)
2494 {
2495     Optional&lt;FloatRect&gt; rect;
2496     decoder &gt;&gt; rect;
2497     if (!rect)
2498         return WTF::nullopt;
2499 
2500     Optional&lt;float&gt; lineWidth;
2501     decoder &gt;&gt; lineWidth;
2502     if (!lineWidth)
2503         return WTF::nullopt;
2504 
2505     return StrokeRect::create(*rect, *lineWidth);
2506 }
2507 
2508 class StrokePath : public DrawingItem {
2509 public:
2510     static Ref&lt;StrokePath&gt; create(const Path&amp; path)
2511     {
2512         return adoptRef(*new StrokePath(path));
2513     }
2514 
2515     WEBCORE_EXPORT virtual ~StrokePath();
2516 
2517     const Path&amp; path() const { return m_path; }
2518 
2519     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2520     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokePath&gt;&gt; decode(Decoder&amp;);
2521 
2522 private:
2523     WEBCORE_EXPORT StrokePath(const Path&amp;);
2524 
2525     void apply(GraphicsContext&amp;) const override;
2526     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2527 
2528     const Path m_path;
2529 };
2530 
2531 template&lt;class Encoder&gt;
2532 void StrokePath::encode(Encoder&amp; encoder) const
2533 {
2534     encoder &lt;&lt; m_path;
2535 }
2536 
2537 template&lt;class Decoder&gt;
2538 Optional&lt;Ref&lt;StrokePath&gt;&gt; StrokePath::decode(Decoder&amp; decoder)
2539 {
2540     Optional&lt;Path&gt; path;
2541     decoder &gt;&gt; path;
2542     if (!path)
2543         return WTF::nullopt;
2544 
2545     return StrokePath::create(*path);
2546 }
2547 
2548 class StrokeEllipse : public DrawingItem {
2549 public:
2550     static Ref&lt;StrokeEllipse&gt; create(const FloatRect&amp; rect)
2551     {
2552         return adoptRef(*new StrokeEllipse(rect));
2553     }
2554 
2555     WEBCORE_EXPORT ~StrokeEllipse();
2556 
2557     FloatRect rect() const { return m_rect; }
2558 
2559     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2560     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokeEllipse&gt;&gt; decode(Decoder&amp;);
2561 
2562 private:
2563     WEBCORE_EXPORT StrokeEllipse(const FloatRect&amp;);
2564 
2565     void apply(GraphicsContext&amp;) const override;
2566     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2567 
2568     FloatRect m_rect;
2569 };
2570 
2571 template&lt;class Encoder&gt;
2572 void StrokeEllipse::encode(Encoder&amp; encoder) const
2573 {
2574     encoder &lt;&lt; m_rect;
2575 }
2576 
2577 template&lt;class Decoder&gt;
2578 Optional&lt;Ref&lt;StrokeEllipse&gt;&gt; StrokeEllipse::decode(Decoder&amp; decoder)
2579 {
2580     Optional&lt;FloatRect&gt; rect;
2581     decoder &gt;&gt; rect;
2582     if (!rect)
2583         return WTF::nullopt;
2584 
2585     return StrokeEllipse::create(*rect);
2586 }
2587 
2588 class ClearRect : public DrawingItem {
2589 public:
2590     static Ref&lt;ClearRect&gt; create(const FloatRect&amp; rect)
2591     {
2592         return adoptRef(*new ClearRect(rect));
2593     }
2594 
2595     WEBCORE_EXPORT virtual ~ClearRect();
2596 
2597     FloatRect rect() const { return m_rect; }
2598 
2599     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2600     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClearRect&gt;&gt; decode(Decoder&amp;);
2601 
2602 private:
2603     WEBCORE_EXPORT ClearRect(const FloatRect&amp;);
2604 
2605     void apply(GraphicsContext&amp;) const override;
2606     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2607 
2608     FloatRect m_rect;
2609 };
2610 
2611 template&lt;class Encoder&gt;
2612 void ClearRect::encode(Encoder&amp; encoder) const
2613 {
2614     encoder &lt;&lt; m_rect;
2615 }
2616 
2617 template&lt;class Decoder&gt;
2618 Optional&lt;Ref&lt;ClearRect&gt;&gt; ClearRect::decode(Decoder&amp; decoder)
2619 {
2620     Optional&lt;FloatRect&gt; rect;
2621     decoder &gt;&gt; rect;
2622     if (!rect)
2623         return WTF::nullopt;
2624 
2625     return ClearRect::create(*rect);
2626 }
2627 
2628 #if USE(CG)
2629 class ApplyStrokePattern : public Item {
2630 public:
2631     static Ref&lt;ApplyStrokePattern&gt; create()
2632     {
2633         return adoptRef(*new ApplyStrokePattern);
2634     }
2635 
2636     WEBCORE_EXPORT virtual ~ApplyStrokePattern();
2637 
2638     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2639     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyStrokePattern&gt;&gt; decode(Decoder&amp;);
2640 
2641 private:
2642     WEBCORE_EXPORT ApplyStrokePattern();
2643 
2644     void apply(GraphicsContext&amp;) const override;
2645 };
2646 
2647 template&lt;class Encoder&gt;
2648 void ApplyStrokePattern::encode(Encoder&amp;) const
2649 {
2650 }
2651 
2652 template&lt;class Decoder&gt;
2653 Optional&lt;Ref&lt;ApplyStrokePattern&gt;&gt; ApplyStrokePattern::decode(Decoder&amp;)
2654 {
2655     return ApplyStrokePattern::create();
2656 }
2657 
2658 class ApplyFillPattern : public Item {
2659 public:
2660     static Ref&lt;ApplyFillPattern&gt; create()
2661     {
2662         return adoptRef(*new ApplyFillPattern);
2663     }
2664 
2665     WEBCORE_EXPORT virtual ~ApplyFillPattern();
2666 
2667     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2668     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyFillPattern&gt;&gt; decode(Decoder&amp;);
2669 
2670 private:
2671     WEBCORE_EXPORT ApplyFillPattern();
2672 
2673     void apply(GraphicsContext&amp;) const override;
2674 };
2675 
2676 template&lt;class Encoder&gt;
2677 void ApplyFillPattern::encode(Encoder&amp;) const
2678 {
2679 }
2680 
2681 template&lt;class Decoder&gt;
2682 Optional&lt;Ref&lt;ApplyFillPattern&gt;&gt; ApplyFillPattern::decode(Decoder&amp;)
2683 {
2684     return ApplyFillPattern::create();
2685 }
2686 #endif
2687 
2688 class ApplyDeviceScaleFactor : public Item {
2689 public:
2690     static Ref&lt;ApplyDeviceScaleFactor&gt; create(float scaleFactor)
2691     {
2692         return adoptRef(*new ApplyDeviceScaleFactor(scaleFactor));
2693     }
2694 
2695     WEBCORE_EXPORT virtual ~ApplyDeviceScaleFactor();
2696 
2697     float scaleFactor() const { return m_scaleFactor; }
2698 
2699     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
2700     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyDeviceScaleFactor&gt;&gt; decode(Decoder&amp;);
2701 
2702 private:
2703     WEBCORE_EXPORT ApplyDeviceScaleFactor(float scaleFactor);
2704 
2705     void apply(GraphicsContext&amp;) const override;
2706 
2707     float m_scaleFactor;
2708 };
2709 
2710 template&lt;class Encoder&gt;
2711 void ApplyDeviceScaleFactor::encode(Encoder&amp; encoder) const
2712 {
2713     encoder &lt;&lt; m_scaleFactor;
2714 }
2715 
2716 template&lt;class Decoder&gt;
2717 Optional&lt;Ref&lt;ApplyDeviceScaleFactor&gt;&gt; ApplyDeviceScaleFactor::decode(Decoder&amp; decoder)
2718 {
2719     Optional&lt;float&gt; scaleFactor;
2720     decoder &gt;&gt; scaleFactor;
2721     if (!scaleFactor)
2722         return WTF::nullopt;
2723 
2724     return ApplyDeviceScaleFactor::create(*scaleFactor);
2725 }
2726 
2727 
2728 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Item&amp;);
2729 
2730 template&lt;class Encoder&gt;
2731 void Item::encode(Encoder&amp; encoder) const
2732 {
2733     encoder &lt;&lt; m_type;
2734 
2735     switch (m_type) {
2736     case ItemType::Save:
2737         encoder &lt;&lt; downcast&lt;Save&gt;(*this);
2738         break;
2739     case ItemType::Restore:
2740         encoder &lt;&lt; downcast&lt;Restore&gt;(*this);
2741         break;
2742     case ItemType::Translate:
2743         encoder &lt;&lt; downcast&lt;Translate&gt;(*this);
2744         break;
2745     case ItemType::Rotate:
2746         encoder &lt;&lt; downcast&lt;Rotate&gt;(*this);
2747         break;
2748     case ItemType::Scale:
2749         encoder &lt;&lt; downcast&lt;Scale&gt;(*this);
2750         break;
2751     case ItemType::SetCTM:
2752         encoder &lt;&lt; downcast&lt;SetCTM&gt;(*this);
2753         break;
2754     case ItemType::ConcatenateCTM:
2755         encoder &lt;&lt; downcast&lt;ConcatenateCTM&gt;(*this);
2756         break;
2757     case ItemType::SetState:
2758         encoder &lt;&lt; downcast&lt;SetState&gt;(*this);
2759         break;
2760     case ItemType::SetLineCap:
2761         encoder &lt;&lt; downcast&lt;SetLineCap&gt;(*this);
2762         break;
2763     case ItemType::SetLineDash:
2764         encoder &lt;&lt; downcast&lt;SetLineDash&gt;(*this);
2765         break;
2766     case ItemType::SetLineJoin:
2767         encoder &lt;&lt; downcast&lt;SetLineJoin&gt;(*this);
2768         break;
2769     case ItemType::SetMiterLimit:
2770         encoder &lt;&lt; downcast&lt;SetMiterLimit&gt;(*this);
2771         break;
2772     case ItemType::ClearShadow:
2773         encoder &lt;&lt; downcast&lt;ClearShadow&gt;(*this);
2774         break;
2775     case ItemType::Clip:
2776         encoder &lt;&lt; downcast&lt;Clip&gt;(*this);
2777         break;
2778     case ItemType::ClipOut:
2779         encoder &lt;&lt; downcast&lt;ClipOut&gt;(*this);
2780         break;
2781     case ItemType::ClipOutToPath:
2782         encoder &lt;&lt; downcast&lt;ClipOutToPath&gt;(*this);
2783         break;
2784     case ItemType::ClipPath:
2785         encoder &lt;&lt; downcast&lt;ClipPath&gt;(*this);
2786         break;
2787     case ItemType::DrawGlyphs:
2788         encoder &lt;&lt; downcast&lt;DrawGlyphs&gt;(*this);
2789         break;
2790     case ItemType::DrawImage:
2791         encoder &lt;&lt; downcast&lt;DrawImage&gt;(*this);
2792         break;
2793     case ItemType::DrawTiledImage:
2794         encoder &lt;&lt; downcast&lt;DrawTiledImage&gt;(*this);
2795         break;
2796     case ItemType::DrawTiledScaledImage:
2797         encoder &lt;&lt; downcast&lt;DrawTiledScaledImage&gt;(*this);
2798         break;
2799 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
2800     case ItemType::DrawNativeImage:
2801         encoder &lt;&lt; downcast&lt;DrawNativeImage&gt;(*this);
2802         break;
2803 #endif
2804     case ItemType::DrawPattern:
2805         encoder &lt;&lt; downcast&lt;DrawPattern&gt;(*this);
2806         break;
2807     case ItemType::DrawRect:
2808         encoder &lt;&lt; downcast&lt;DrawRect&gt;(*this);
2809         break;
2810     case ItemType::DrawLine:
2811         encoder &lt;&lt; downcast&lt;DrawLine&gt;(*this);
2812         break;
2813     case ItemType::DrawLinesForText:
2814         encoder &lt;&lt; downcast&lt;DrawLinesForText&gt;(*this);
2815         break;
2816     case ItemType::DrawDotsForDocumentMarker:
2817         encoder &lt;&lt; downcast&lt;DrawDotsForDocumentMarker&gt;(*this);
2818         break;
2819     case ItemType::DrawEllipse:
2820         encoder &lt;&lt; downcast&lt;DrawEllipse&gt;(*this);
2821         break;
2822     case ItemType::DrawPath:
2823         encoder &lt;&lt; downcast&lt;DrawPath&gt;(*this);
2824         break;
2825     case ItemType::DrawFocusRingPath:
2826         encoder &lt;&lt; downcast&lt;DrawFocusRingPath&gt;(*this);
2827         break;
2828     case ItemType::DrawFocusRingRects:
2829         encoder &lt;&lt; downcast&lt;DrawFocusRingRects&gt;(*this);
2830         break;
2831     case ItemType::FillRect:
2832         encoder &lt;&lt; downcast&lt;FillRect&gt;(*this);
2833         break;
2834     case ItemType::FillRectWithColor:
2835         encoder &lt;&lt; downcast&lt;FillRectWithColor&gt;(*this);
2836         break;
2837     case ItemType::FillRectWithGradient:
2838         encoder &lt;&lt; downcast&lt;FillRectWithGradient&gt;(*this);
2839         break;
2840     case ItemType::FillCompositedRect:
2841         encoder &lt;&lt; downcast&lt;FillCompositedRect&gt;(*this);
2842         break;
2843     case ItemType::FillRoundedRect:
2844         encoder &lt;&lt; downcast&lt;FillRoundedRect&gt;(*this);
2845         break;
2846     case ItemType::FillRectWithRoundedHole:
2847         encoder &lt;&lt; downcast&lt;FillRectWithRoundedHole&gt;(*this);
2848         break;
2849     case ItemType::FillPath:
2850         encoder &lt;&lt; downcast&lt;FillPath&gt;(*this);
2851         break;
2852     case ItemType::FillEllipse:
2853         encoder &lt;&lt; downcast&lt;FillEllipse&gt;(*this);
2854         break;
2855     case ItemType::StrokeRect:
2856         encoder &lt;&lt; downcast&lt;StrokeRect&gt;(*this);
2857         break;
2858     case ItemType::StrokePath:
2859         encoder &lt;&lt; downcast&lt;StrokePath&gt;(*this);
2860         break;
2861     case ItemType::StrokeEllipse:
2862         encoder &lt;&lt; downcast&lt;StrokeEllipse&gt;(*this);
2863         break;
2864     case ItemType::ClearRect:
2865         encoder &lt;&lt; downcast&lt;ClearRect&gt;(*this);
2866         break;
2867     case ItemType::BeginTransparencyLayer:
2868         encoder &lt;&lt; downcast&lt;BeginTransparencyLayer&gt;(*this);
2869         break;
2870     case ItemType::EndTransparencyLayer:
2871         encoder &lt;&lt; downcast&lt;EndTransparencyLayer&gt;(*this);
2872         break;
2873 #if USE(CG)
2874     case ItemType::ApplyStrokePattern:
2875         encoder &lt;&lt; downcast&lt;ApplyStrokePattern&gt;(*this);
2876         break;
2877     case ItemType::ApplyFillPattern:
2878         encoder &lt;&lt; downcast&lt;ApplyFillPattern&gt;(*this);
2879         break;
2880 #endif
2881     case ItemType::ApplyDeviceScaleFactor:
2882         encoder &lt;&lt; downcast&lt;ApplyDeviceScaleFactor&gt;(*this);
2883         break;
2884     }
2885 }
2886 
2887 template&lt;class Decoder&gt;
2888 Optional&lt;Ref&lt;Item&gt;&gt; Item::decode(Decoder&amp; decoder)
2889 {
2890     Optional&lt;ItemType&gt; itemType;
2891     decoder &gt;&gt; itemType;
2892     if (!itemType)
2893         return WTF::nullopt;
2894 
2895     switch (*itemType) {
2896     case ItemType::Save:
2897         if (auto item = Save::decode(decoder))
2898             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2899         break;
2900     case ItemType::Restore:
2901         if (auto item = Restore::decode(decoder))
2902             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2903         break;
2904     case ItemType::Translate:
2905         if (auto item = Translate::decode(decoder))
2906             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2907         break;
2908     case ItemType::Rotate:
2909         if (auto item = Rotate::decode(decoder))
2910             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2911         break;
2912     case ItemType::Scale:
2913         if (auto item = Scale::decode(decoder))
2914             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2915         break;
2916     case ItemType::SetCTM:
2917         if (auto item = SetCTM::decode(decoder))
2918             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2919         break;
2920     case ItemType::ConcatenateCTM:
2921         if (auto item = ConcatenateCTM::decode(decoder))
2922             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2923         break;
2924     case ItemType::SetState:
2925         if (auto item = SetState::decode(decoder))
2926             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2927         break;
2928     case ItemType::SetLineCap:
2929         if (auto item = SetLineCap::decode(decoder))
2930             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2931         break;
2932     case ItemType::SetLineDash:
2933         if (auto item = SetLineDash::decode(decoder))
2934             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2935         break;
2936     case ItemType::SetLineJoin:
2937         if (auto item = SetLineJoin::decode(decoder))
2938             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2939         break;
2940     case ItemType::SetMiterLimit:
2941         if (auto item = SetMiterLimit::decode(decoder))
2942             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2943         break;
2944     case ItemType::ClearShadow:
2945         if (auto item = ClearShadow::decode(decoder))
2946             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2947         break;
2948     case ItemType::Clip:
2949         if (auto item = Clip::decode(decoder))
2950             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2951         break;
2952     case ItemType::ClipOut:
2953         if (auto item = ClipOut::decode(decoder))
2954             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2955         break;
2956     case ItemType::ClipOutToPath:
2957         if (auto item = ClipOutToPath::decode(decoder))
2958             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2959         break;
2960     case ItemType::ClipPath:
2961         if (auto item = ClipPath::decode(decoder))
2962             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2963         break;
2964     case ItemType::DrawGlyphs:
2965         if (auto item = DrawGlyphs::decode(decoder))
2966             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2967         break;
2968     case ItemType::DrawImage:
2969         if (auto item = DrawImage::decode(decoder))
2970             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2971         break;
2972     case ItemType::DrawTiledImage:
2973         if (auto item = DrawTiledImage::decode(decoder))
2974             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2975         break;
2976     case ItemType::DrawTiledScaledImage:
2977         if (auto item = DrawTiledScaledImage::decode(decoder))
2978             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2979         break;
2980 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
2981     case ItemType::DrawNativeImage:
2982         if (auto item = DrawNativeImage::decode(decoder))
2983             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2984         break;
2985 #endif
2986     case ItemType::DrawPattern:
2987         if (auto item = DrawPattern::decode(decoder))
2988             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2989         break;
2990     case ItemType::DrawRect:
2991         if (auto item = DrawRect::decode(decoder))
2992             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2993         break;
2994     case ItemType::DrawLine:
2995         if (auto item = DrawLine::decode(decoder))
2996             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
2997         break;
2998     case ItemType::DrawLinesForText:
2999         if (auto item = DrawLinesForText::decode(decoder))
3000             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3001         break;
3002     case ItemType::DrawDotsForDocumentMarker:
3003         if (auto item = DrawDotsForDocumentMarker::decode(decoder))
3004             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3005         break;
3006     case ItemType::DrawEllipse:
3007         if (auto item = DrawEllipse::decode(decoder))
3008             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3009         break;
3010     case ItemType::DrawPath:
3011         if (auto item = DrawPath::decode(decoder))
3012             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3013         break;
3014     case ItemType::DrawFocusRingPath:
3015         if (auto item = DrawFocusRingPath::decode(decoder))
3016             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3017         break;
3018     case ItemType::DrawFocusRingRects:
3019         if (auto item = DrawFocusRingRects::decode(decoder))
3020             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3021         break;
3022     case ItemType::FillRect:
3023         if (auto item = FillRect::decode(decoder))
3024             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3025         break;
3026     case ItemType::FillRectWithColor:
3027         if (auto item = FillRectWithColor::decode(decoder))
3028             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3029         break;
3030     case ItemType::FillRectWithGradient:
3031         if (auto item = FillRectWithGradient::decode(decoder))
3032             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3033         break;
3034     case ItemType::FillCompositedRect:
3035         if (auto item = FillCompositedRect::decode(decoder))
3036             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3037         break;
3038     case ItemType::FillRoundedRect:
3039         if (auto item = FillRoundedRect::decode(decoder))
3040             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3041         break;
3042     case ItemType::FillRectWithRoundedHole:
3043         if (auto item = FillRectWithRoundedHole::decode(decoder))
3044             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3045         break;
3046     case ItemType::FillPath:
3047         if (auto item = FillPath::decode(decoder))
3048             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3049         break;
3050     case ItemType::FillEllipse:
3051         if (auto item = FillEllipse::decode(decoder))
3052             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3053         break;
3054     case ItemType::StrokeRect:
3055         if (auto item = StrokeRect::decode(decoder))
3056             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3057         break;
3058     case ItemType::StrokePath:
3059         if (auto item = StrokePath::decode(decoder))
3060             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3061         break;
3062     case ItemType::StrokeEllipse:
3063         if (auto item = StrokeEllipse::decode(decoder))
3064             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3065         break;
3066     case ItemType::ClearRect:
3067         if (auto item = ClearRect::decode(decoder))
3068             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3069         break;
3070     case ItemType::BeginTransparencyLayer:
3071         if (auto item = BeginTransparencyLayer::decode(decoder))
3072             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3073         break;
3074     case ItemType::EndTransparencyLayer:
3075         if (auto item = EndTransparencyLayer::decode(decoder))
3076             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3077         break;
3078 #if USE(CG)
3079     case ItemType::ApplyStrokePattern:
3080         if (auto item = ApplyStrokePattern::decode(decoder))
3081             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3082         break;
3083     case ItemType::ApplyFillPattern:
3084         if (auto item = ApplyFillPattern::decode(decoder))
3085             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3086         break;
3087 #endif
3088     case ItemType::ApplyDeviceScaleFactor:
3089         if (auto item = ApplyDeviceScaleFactor::decode(decoder))
3090             return static_reference_cast&lt;Item&gt;(WTFMove(*item));
3091         break;
3092     }
3093 
3094     return WTF::nullopt;
3095 }
3096 
3097 } // namespace DisplayList
3098 } // namespace WebCore
3099 
3100 
3101 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(ToValueTypeName, predicate) \
3102 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
3103     static bool isType(const WebCore::DisplayList::Item&amp; object) { return object.predicate; } \
3104 SPECIALIZE_TYPE_TRAITS_END()
3105 
3106 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(DrawingItem, isDrawingItem())
3107 
3108 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ToValueTypeName) \
3109 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
3110     static bool isType(const WebCore::DisplayList::Item&amp; item) { return item.type() == WebCore::DisplayList::ItemType::ToValueTypeName; } \
3111 SPECIALIZE_TYPE_TRAITS_END()
3112 
3113 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Save)
3114 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Restore)
3115 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Translate)
3116 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Rotate)
3117 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Scale)
3118 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetCTM)
3119 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ConcatenateCTM)
3120 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetState)
3121 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineCap)
3122 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineDash)
3123 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineJoin)
3124 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetMiterLimit)
3125 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Clip)
3126 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOut)
3127 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOutToPath)
3128 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipPath)
3129 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawGlyphs)
3130 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawImage)
3131 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledImage)
3132 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledScaledImage)
3133 #if USE(CG) || USE(CAIRO)
3134 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawNativeImage)
3135 #endif
3136 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawPattern)
3137 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawRect)
3138 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawLine)
3139 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawLinesForText)
3140 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawDotsForDocumentMarker)
3141 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawEllipse)
3142 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawPath)
3143 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawFocusRingPath)
3144 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawFocusRingRects)
3145 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRect)
3146 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithColor)
3147 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithGradient)
3148 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillCompositedRect)
3149 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRoundedRect)
3150 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithRoundedHole)
3151 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillPath)
3152 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillEllipse)
3153 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeRect)
3154 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokePath)
3155 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeEllipse)
3156 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearRect)
3157 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(BeginTransparencyLayer)
3158 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(EndTransparencyLayer)
3159 #if USE(CG)
3160 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyStrokePattern)
3161 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyFillPattern)
3162 #endif
3163 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyDeviceScaleFactor)
3164 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearShadow)
3165 
3166 namespace WTF {
3167 
3168 template&lt;&gt; struct EnumTraits&lt;WebCore::DisplayList::ItemType&gt; {
3169     using values = EnumValues&lt;
3170     WebCore::DisplayList::ItemType,
3171     WebCore::DisplayList::ItemType::Save,
3172     WebCore::DisplayList::ItemType::Restore,
3173     WebCore::DisplayList::ItemType::Translate,
3174     WebCore::DisplayList::ItemType::Rotate,
3175     WebCore::DisplayList::ItemType::Scale,
3176     WebCore::DisplayList::ItemType::SetCTM,
3177     WebCore::DisplayList::ItemType::ConcatenateCTM,
3178     WebCore::DisplayList::ItemType::SetState,
3179     WebCore::DisplayList::ItemType::SetLineCap,
3180     WebCore::DisplayList::ItemType::SetLineDash,
3181     WebCore::DisplayList::ItemType::SetLineJoin,
3182     WebCore::DisplayList::ItemType::SetMiterLimit,
3183     WebCore::DisplayList::ItemType::ClearShadow,
3184     WebCore::DisplayList::ItemType::Clip,
3185     WebCore::DisplayList::ItemType::ClipOut,
3186     WebCore::DisplayList::ItemType::ClipOutToPath,
3187     WebCore::DisplayList::ItemType::ClipPath,
3188     WebCore::DisplayList::ItemType::DrawGlyphs,
3189     WebCore::DisplayList::ItemType::DrawImage,
3190     WebCore::DisplayList::ItemType::DrawTiledImage,
3191     WebCore::DisplayList::ItemType::DrawTiledScaledImage,
3192 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
3193     WebCore::DisplayList::ItemType::DrawNativeImage,
3194 #endif
3195     WebCore::DisplayList::ItemType::DrawPattern,
3196     WebCore::DisplayList::ItemType::DrawRect,
3197     WebCore::DisplayList::ItemType::DrawLine,
3198     WebCore::DisplayList::ItemType::DrawLinesForText,
3199     WebCore::DisplayList::ItemType::DrawDotsForDocumentMarker,
3200     WebCore::DisplayList::ItemType::DrawEllipse,
3201     WebCore::DisplayList::ItemType::DrawPath,
3202     WebCore::DisplayList::ItemType::DrawFocusRingPath,
3203     WebCore::DisplayList::ItemType::DrawFocusRingRects,
3204     WebCore::DisplayList::ItemType::FillRect,
3205     WebCore::DisplayList::ItemType::FillRectWithColor,
3206     WebCore::DisplayList::ItemType::FillRectWithGradient,
3207     WebCore::DisplayList::ItemType::FillCompositedRect,
3208     WebCore::DisplayList::ItemType::FillRoundedRect,
3209     WebCore::DisplayList::ItemType::FillRectWithRoundedHole,
3210     WebCore::DisplayList::ItemType::FillPath,
3211     WebCore::DisplayList::ItemType::FillEllipse,
3212     WebCore::DisplayList::ItemType::StrokeRect,
3213     WebCore::DisplayList::ItemType::StrokePath,
3214     WebCore::DisplayList::ItemType::StrokeEllipse,
3215     WebCore::DisplayList::ItemType::ClearRect,
3216     WebCore::DisplayList::ItemType::BeginTransparencyLayer,
3217     WebCore::DisplayList::ItemType::EndTransparencyLayer,
3218 #if USE(CG)
3219     WebCore::DisplayList::ItemType::ApplyStrokePattern,
3220     WebCore::DisplayList::ItemType::ApplyFillPattern,
3221 #endif
3222     WebCore::DisplayList::ItemType::ApplyDeviceScaleFactor
3223     &gt;;
3224 };
3225 
3226 } // namespace WTF
    </pre>
  </body>
</html>
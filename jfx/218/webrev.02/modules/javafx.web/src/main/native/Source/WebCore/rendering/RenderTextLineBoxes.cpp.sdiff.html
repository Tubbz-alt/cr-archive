<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderText.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextLineBoxes.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
129     m_first = nullptr;
130     m_last = nullptr;
131 }
132 
133 InlineTextBox* RenderTextLineBoxes::findNext(int offset, int&amp; position) const
134 {
135     if (!m_first)
136         return nullptr;
137     // FIXME: This looks buggy. The function is only used for debugging purposes.
138     auto current = m_first;
139     int currentOffset = current-&gt;len();
140     while (offset &gt; currentOffset &amp;&amp; current-&gt;nextTextBox()) {
141         current = current-&gt;nextTextBox();
142         currentOffset = current-&gt;start() + current-&gt;len();
143     }
144     // we are now in the correct text run
145     position = (offset &gt; currentOffset ? current-&gt;len() : current-&gt;len() - (currentOffset - offset));
146     return current;
147 }
148 
<span class="line-removed">149 IntRect RenderTextLineBoxes::boundingBox(const RenderText&amp; renderer) const</span>
<span class="line-removed">150 {</span>
<span class="line-removed">151     if (!m_first)</span>
<span class="line-removed">152         return IntRect();</span>
<span class="line-removed">153 </span>
<span class="line-removed">154     // Return the width of the minimal left side and the maximal right side.</span>
<span class="line-removed">155     float logicalLeftSide = 0;</span>
<span class="line-removed">156     float logicalRightSide = 0;</span>
<span class="line-removed">157     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {</span>
<span class="line-removed">158         if (current == m_first || current-&gt;logicalLeft() &lt; logicalLeftSide)</span>
<span class="line-removed">159             logicalLeftSide = current-&gt;logicalLeft();</span>
<span class="line-removed">160         if (current == m_first || current-&gt;logicalRight() &gt; logicalRightSide)</span>
<span class="line-removed">161             logicalRightSide = current-&gt;logicalRight();</span>
<span class="line-removed">162     }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164     bool isHorizontal = renderer.style().isHorizontalWritingMode();</span>
<span class="line-removed">165 </span>
<span class="line-removed">166     float x = isHorizontal ? logicalLeftSide : m_first-&gt;x();</span>
<span class="line-removed">167     float y = isHorizontal ? m_first-&gt;y() : logicalLeftSide;</span>
<span class="line-removed">168     float width = isHorizontal ? logicalRightSide - logicalLeftSide : m_last-&gt;logicalBottom() - x;</span>
<span class="line-removed">169     float height = isHorizontal ? m_last-&gt;logicalBottom() - y : logicalRightSide - logicalLeftSide;</span>
<span class="line-removed">170     return enclosingIntRect(FloatRect(x, y, width, height));</span>
<span class="line-removed">171 }</span>
<span class="line-removed">172 </span>
<span class="line-removed">173 IntPoint RenderTextLineBoxes::firstRunLocation() const</span>
<span class="line-removed">174 {</span>
<span class="line-removed">175     if (!m_first)</span>
<span class="line-removed">176         return IntPoint();</span>
<span class="line-removed">177     return IntPoint(m_first-&gt;topLeft());</span>
<span class="line-removed">178 }</span>
<span class="line-removed">179 </span>
180 LayoutRect RenderTextLineBoxes::visualOverflowBoundingBox(const RenderText&amp; renderer) const
181 {
182     if (!m_first)
183         return LayoutRect();
184 
185     // Return the width of the minimal left side and the maximal right side.
186     auto logicalLeftSide = LayoutUnit::max();
187     auto logicalRightSide = LayoutUnit::min();
188     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
189         logicalLeftSide = std::min(logicalLeftSide, current-&gt;logicalLeftVisualOverflow());
190         logicalRightSide = std::max(logicalRightSide, current-&gt;logicalRightVisualOverflow());
191     }
192 
193     auto logicalTop = m_first-&gt;logicalTopVisualOverflow();
194     auto logicalWidth = logicalRightSide - logicalLeftSide;
195     auto logicalHeight = m_last-&gt;logicalBottomVisualOverflow() - logicalTop;
196 
197     LayoutRect rect(logicalLeftSide, logicalTop, logicalWidth, logicalHeight);
198     if (!renderer.style().isHorizontalWritingMode())
199         rect = rect.transposedRect();
200     return rect;
201 }
202 
<span class="line-removed">203 bool RenderTextLineBoxes::hasRenderedText() const</span>
<span class="line-removed">204 {</span>
<span class="line-removed">205     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">206         if (box-&gt;len())</span>
<span class="line-removed">207             return true;</span>
<span class="line-removed">208     }</span>
<span class="line-removed">209     return false;</span>
<span class="line-removed">210 }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212 int RenderTextLineBoxes::caretMinOffset() const</span>
<span class="line-removed">213 {</span>
<span class="line-removed">214     auto box = m_first;</span>
<span class="line-removed">215     if (!box)</span>
<span class="line-removed">216         return 0;</span>
<span class="line-removed">217     int minOffset = box-&gt;start();</span>
<span class="line-removed">218     for (box = box-&gt;nextTextBox(); box; box = box-&gt;nextTextBox())</span>
<span class="line-removed">219         minOffset = std::min&lt;int&gt;(minOffset, box-&gt;start());</span>
<span class="line-removed">220     return minOffset;</span>
<span class="line-removed">221 }</span>
<span class="line-removed">222 </span>
<span class="line-removed">223 int RenderTextLineBoxes::caretMaxOffset(const RenderText&amp; renderer) const</span>
<span class="line-removed">224 {</span>
<span class="line-removed">225     auto box = m_last;</span>
<span class="line-removed">226     if (!box)</span>
<span class="line-removed">227         return renderer.text().length();</span>
<span class="line-removed">228 </span>
<span class="line-removed">229     int maxOffset = box-&gt;start() + box-&gt;len();</span>
<span class="line-removed">230     for (box = box-&gt;prevTextBox(); box; box = box-&gt;prevTextBox())</span>
<span class="line-removed">231         maxOffset = std::max&lt;int&gt;(maxOffset, box-&gt;start() + box-&gt;len());</span>
<span class="line-removed">232     return maxOffset;</span>
<span class="line-removed">233 }</span>
<span class="line-removed">234 </span>
<span class="line-removed">235 bool RenderTextLineBoxes::containsOffset(const RenderText&amp; renderer, unsigned offset, OffsetType type) const</span>
<span class="line-removed">236 {</span>
<span class="line-removed">237     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">238         if (offset &lt; box-&gt;start() &amp;&amp; !renderer.containsReversedText())</span>
<span class="line-removed">239             return false;</span>
<span class="line-removed">240         unsigned boxEnd = box-&gt;start() + box-&gt;len();</span>
<span class="line-removed">241         if (offset &gt;= box-&gt;start() &amp;&amp; offset &lt;= boxEnd) {</span>
<span class="line-removed">242             if (offset == boxEnd &amp;&amp; (type == CharacterOffset || box-&gt;isLineBreak()))</span>
<span class="line-removed">243                 continue;</span>
<span class="line-removed">244             if (type == CharacterOffset)</span>
<span class="line-removed">245                 return true;</span>
<span class="line-removed">246             // Return false for offsets inside composed characters.</span>
<span class="line-removed">247             return !offset || offset == static_cast&lt;unsigned&gt;(renderer.nextOffset(renderer.previousOffset(offset)));</span>
<span class="line-removed">248         }</span>
<span class="line-removed">249     }</span>
<span class="line-removed">250     return false;</span>
<span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253 unsigned RenderTextLineBoxes::countCharacterOffsetsUntil(unsigned offset) const</span>
<span class="line-removed">254 {</span>
<span class="line-removed">255     unsigned result = 0;</span>
<span class="line-removed">256     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">257         if (offset &lt; box-&gt;start())</span>
<span class="line-removed">258             return result;</span>
<span class="line-removed">259         if (offset &lt;= box-&gt;start() + box-&gt;len()) {</span>
<span class="line-removed">260             result += offset - box-&gt;start();</span>
<span class="line-removed">261             return result;</span>
<span class="line-removed">262         }</span>
<span class="line-removed">263         result += box-&gt;len();</span>
<span class="line-removed">264     }</span>
<span class="line-removed">265     return result;</span>
<span class="line-removed">266 }</span>
<span class="line-removed">267 </span>
268 enum ShouldAffinityBeDownstream { AlwaysDownstream, AlwaysUpstream, UpstreamIfPositionIsNotAtStart };
269 
270 static bool lineDirectionPointFitsInBox(int pointLineDirection, const InlineTextBox&amp; box, ShouldAffinityBeDownstream&amp; shouldAffinityBeDownstream)
271 {
272     shouldAffinityBeDownstream = AlwaysDownstream;
273 
274     // the x coordinate is equal to the left edge of this box
275     // the affinity must be downstream so the position doesn&#39;t jump back to the previous line
276     // except when box is the first box in the line
277     if (pointLineDirection &lt;= box.logicalLeft()) {
<span class="line-modified">278         shouldAffinityBeDownstream = !box.prevLeafChild() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;</span>
279         return true;
280     }
281 
282 #if !PLATFORM(IOS_FAMILY)
283     // and the x coordinate is to the left of the right edge of this box
284     // check to see if position goes in this box
285     if (pointLineDirection &lt; box.logicalRight()) {
286         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
287         return true;
288     }
289 #endif
290 
291     // box is first on line
292     // and the x coordinate is to the left of the first text box left edge
<span class="line-modified">293     if (!box.prevLeafChildIgnoringLineBreak() &amp;&amp; pointLineDirection &lt; box.logicalLeft())</span>
294         return true;
295 
<span class="line-modified">296     if (!box.nextLeafChildIgnoringLineBreak()) {</span>
297         // box is last on line
298         // and the x coordinate is to the right of the last text box right edge
299         // generate VisiblePosition, use UPSTREAM affinity if possible
300         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
301         return true;
302     }
303 
304     return false;
305 }
306 
307 static VisiblePosition createVisiblePositionForBox(const InlineBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
308 {
309     EAffinity affinity = VP_DEFAULT_AFFINITY;
310     switch (shouldAffinityBeDownstream) {
311     case AlwaysDownstream:
312         affinity = DOWNSTREAM;
313         break;
314     case AlwaysUpstream:
315         affinity = VP_UPSTREAM_IF_POSSIBLE;
316         break;
317     case UpstreamIfPositionIsNotAtStart:
318         affinity = offset &gt; box.caretMinOffset() ? VP_UPSTREAM_IF_POSSIBLE : DOWNSTREAM;
319         break;
320     }
321     return box.renderer().createVisiblePosition(offset, affinity);
322 }
323 
324 static VisiblePosition createVisiblePositionAfterAdjustingOffsetForBiDi(const InlineTextBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
325 {
326     ASSERT(offset &gt;= 0);
327 
328     if (offset &amp;&amp; static_cast&lt;unsigned&gt;(offset) &lt; box.len())
329         return createVisiblePositionForBox(box, box.start() + offset, shouldAffinityBeDownstream);
330 
331     bool positionIsAtStartOfBox = !offset;
332     if (positionIsAtStartOfBox == box.isLeftToRightDirection()) {
333         // offset is on the left edge
334 
<span class="line-modified">335         const InlineBox* prevBox = box.prevLeafChildIgnoringLineBreak();</span>
336         if ((prevBox &amp;&amp; prevBox-&gt;bidiLevel() == box.bidiLevel())
337             || box.renderer().containingBlock()-&gt;style().direction() == box.direction()) // FIXME: left on 12CBA
338             return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
339 
340         if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
341             // e.g. left of B in aDC12BAb
342             const InlineBox* leftmostBox;
343             do {
344                 leftmostBox = prevBox;
<span class="line-modified">345                 prevBox = leftmostBox-&gt;prevLeafChildIgnoringLineBreak();</span>
346             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel());
347             return createVisiblePositionForBox(*leftmostBox, leftmostBox-&gt;caretRightmostOffset(), shouldAffinityBeDownstream);
348         }
349 
350         if (!prevBox || prevBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
351             // e.g. left of D in aDC12BAb
352             const InlineBox* rightmostBox;
353             const InlineBox* nextBox = &amp;box;
354             do {
355                 rightmostBox = nextBox;
<span class="line-modified">356                 nextBox = rightmostBox-&gt;nextLeafChildIgnoringLineBreak();</span>
357             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt;= box.bidiLevel());
358             return createVisiblePositionForBox(*rightmostBox,
359                 box.isLeftToRightDirection() ? rightmostBox-&gt;caretMaxOffset() : rightmostBox-&gt;caretMinOffset(), shouldAffinityBeDownstream);
360         }
361 
362         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
363     }
364 
<span class="line-modified">365     const InlineBox* nextBox = box.nextLeafChildIgnoringLineBreak();</span>
366     if ((nextBox &amp;&amp; nextBox-&gt;bidiLevel() == box.bidiLevel())
367         || box.renderer().containingBlock()-&gt;style().direction() == box.direction())
368         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
369 
370     // offset is on the right edge
371     if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
372         // e.g. right of C in aDC12BAb
373         const InlineBox* rightmostBox;
374         do {
375             rightmostBox = nextBox;
<span class="line-modified">376             nextBox = rightmostBox-&gt;nextLeafChildIgnoringLineBreak();</span>
377         } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel());
378         return createVisiblePositionForBox(*rightmostBox, rightmostBox-&gt;caretLeftmostOffset(), shouldAffinityBeDownstream);
379     }
380 
381     if (!nextBox || nextBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
382         // e.g. right of A in aDC12BAb
383         const InlineBox* leftmostBox;
384         const InlineBox* prevBox = &amp;box;
385         do {
386             leftmostBox = prevBox;
<span class="line-modified">387             prevBox = leftmostBox-&gt;prevLeafChildIgnoringLineBreak();</span>
388         } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt;= box.bidiLevel());
389         return createVisiblePositionForBox(*leftmostBox,
390             box.isLeftToRightDirection() ? leftmostBox-&gt;caretMinOffset() : leftmostBox-&gt;caretMaxOffset(), shouldAffinityBeDownstream);
391     }
392 
393     return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
394 }
395 
396 VisiblePosition RenderTextLineBoxes::positionForPoint(const RenderText&amp; renderer, const LayoutPoint&amp; point) const
397 {
398     if (!m_first || !renderer.text().length())
399         return renderer.createVisiblePosition(0, DOWNSTREAM);
400 
401     LayoutUnit pointLineDirection = m_first-&gt;isHorizontal() ? point.x() : point.y();
402     LayoutUnit pointBlockDirection = m_first-&gt;isHorizontal() ? point.y() : point.x();
403     bool blocksAreFlipped = renderer.style().isFlippedBlocksWritingMode();
404 
405     InlineTextBox* lastBox = nullptr;
406     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">407         if (box-&gt;isLineBreak() &amp;&amp; !box-&gt;prevLeafChild() &amp;&amp; box-&gt;nextLeafChild() &amp;&amp; !box-&gt;nextLeafChild()-&gt;isLineBreak())</span>
408             box = box-&gt;nextTextBox();
409 
410         auto&amp; rootBox = box-&gt;root();
411         LayoutUnit top = std::min(rootBox.selectionTop(), rootBox.lineTop());
412         if (pointBlockDirection &gt; top || (!blocksAreFlipped &amp;&amp; pointBlockDirection == top)) {
413             LayoutUnit bottom = rootBox.selectionBottom();
414             if (rootBox.nextRootBox())
415                 bottom = std::min(bottom, rootBox.nextRootBox()-&gt;lineTop());
416 
417             if (pointBlockDirection &lt; bottom || (blocksAreFlipped &amp;&amp; pointBlockDirection == bottom)) {
418                 ShouldAffinityBeDownstream shouldAffinityBeDownstream;
419 #if PLATFORM(IOS_FAMILY)
420                 if (pointLineDirection != box-&gt;logicalLeft() &amp;&amp; point.x() &lt; box-&gt;x() + box-&gt;logicalWidth()) {
421                     int half = box-&gt;x() + box-&gt;logicalWidth() / 2;
422                     EAffinity affinity = point.x() &lt; half ? DOWNSTREAM : VP_UPSTREAM_IF_POSSIBLE;
423                     return renderer.createVisiblePosition(box-&gt;offsetForPosition(pointLineDirection) + box-&gt;start(), affinity);
424                 }
425 #endif
426                 if (lineDirectionPointFitsInBox(pointLineDirection, *box, shouldAffinityBeDownstream))
427                     return createVisiblePositionAfterAdjustingOffsetForBiDi(*box, box-&gt;offsetForPosition(pointLineDirection), shouldAffinityBeDownstream);
</pre>
<hr />
<pre>
429         }
430         lastBox = box;
431     }
432 
433     if (lastBox) {
434         ShouldAffinityBeDownstream shouldAffinityBeDownstream;
435         lineDirectionPointFitsInBox(pointLineDirection, *lastBox, shouldAffinityBeDownstream);
436         return createVisiblePositionAfterAdjustingOffsetForBiDi(*lastBox, lastBox-&gt;offsetForPosition(pointLineDirection) + lastBox-&gt;start(), shouldAffinityBeDownstream);
437     }
438     return renderer.createVisiblePosition(0, DOWNSTREAM);
439 }
440 
441 void RenderTextLineBoxes::setSelectionState(RenderText&amp; renderer, RenderObject::SelectionState state)
442 {
443     if (state == RenderObject::SelectionInside || state == RenderObject::SelectionNone) {
444         for (auto* box = m_first; box; box = box-&gt;nextTextBox())
445             box-&gt;root().setHasSelectedChildren(state == RenderObject::SelectionInside);
446         return;
447     }
448 
<span class="line-modified">449     auto start = renderer.view().selection().startPosition();</span>
<span class="line-modified">450     auto end = renderer.view().selection().endPosition();</span>
451     if (state == RenderObject::SelectionStart) {
452         end = renderer.text().length();
453         // to handle selection from end of text to end of line
454         if (start &amp;&amp; start == end)
455             start = end - 1;
456     } else if (state == RenderObject::SelectionEnd)
457         start = 0;
458 
459     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
460         if (box-&gt;isSelected(start, end))
461             box-&gt;root().setHasSelectedChildren(true);
462     }
463 }
464 
465 static IntRect ellipsisRectForBox(const InlineTextBox&amp; box, unsigned start, unsigned end)
466 {
467     unsigned short truncation = box.truncation();
468     if (truncation == cNoTruncation)
469         return IntRect();
470 
</pre>
<hr />
<pre>
488 {
489     LayoutRect rect;
490     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
491         rect.unite(box-&gt;localSelectionRect(start, end));
492         rect.unite(ellipsisRectForBox(*box, start, end));
493     }
494     return rect;
495 }
496 
497 void RenderTextLineBoxes::collectSelectionRectsForRange(unsigned start, unsigned end, Vector&lt;LayoutRect&gt;&amp; rects)
498 {
499     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
500         LayoutRect rect;
501         rect.unite(box-&gt;localSelectionRect(start, end));
502         rect.unite(ellipsisRectForBox(*box, start, end));
503         if (!rect.size().isEmpty())
504             rects.append(rect);
505     }
506 }
507 
<span class="line-removed">508 Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRects(const LayoutPoint&amp; accumulatedOffset) const</span>
<span class="line-removed">509 {</span>
<span class="line-removed">510     Vector&lt;IntRect&gt; rects;</span>
<span class="line-removed">511     for (auto* box = m_first; box; box = box-&gt;nextTextBox())</span>
<span class="line-removed">512         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + box-&gt;topLeft(), box-&gt;size())));</span>
<span class="line-removed">513     return rects;</span>
<span class="line-removed">514 }</span>
<span class="line-removed">515 </span>
516 static FloatRect localQuadForTextBox(const InlineTextBox&amp; box, unsigned start, unsigned end, bool useSelectionHeight)
517 {
<span class="line-modified">518     unsigned realEnd = std::min(box.end() + 1, end);</span>
519     LayoutRect boxSelectionRect = box.localSelectionRect(start, realEnd);
520     if (!boxSelectionRect.height())
521         return FloatRect();
522     if (useSelectionHeight)
523         return boxSelectionRect;
524     // Change the height and y position (or width and x for vertical text)
525     // because selectionRect uses selection-specific values.
526     if (box.isHorizontal()) {
527         boxSelectionRect.setHeight(box.height());
528         boxSelectionRect.setY(box.y());
529     } else {
530         boxSelectionRect.setWidth(box.width());
531         boxSelectionRect.setX(box.x());
532     }
533     return boxSelectionRect;
534 }
535 
<span class="line-modified">536 Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRectsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
537 {
<span class="line-modified">538     Vector&lt;IntRect&gt; rects;</span>
539     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">540         // Note: box-&gt;end() returns the index of the last character, not the index past it</span>
<span class="line-modified">541         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end) {</span>

542             FloatRect boundaries = box-&gt;calculateBoundaries();
543             if (useSelectionHeight) {
544                 LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);
545                 if (box-&gt;isHorizontal()) {
546                     boundaries.setHeight(selectionRect.height());
547                     boundaries.setY(selectionRect.y());
548                 } else {
549                     boundaries.setWidth(selectionRect.width());
550                     boundaries.setX(selectionRect.x());
551                 }
552             }
<span class="line-modified">553             rects.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed).enclosingBoundingBox());</span>
554             continue;
555         }
556         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
557         if (!rect.isZero())
<span class="line-modified">558             rects.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed).enclosingBoundingBox());</span>
559     }
<span class="line-modified">560     return rects;</span>





561 }
562 
563 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuads(const RenderText&amp; renderer, bool* wasFixed, ClippingOption option) const
564 {
565     Vector&lt;FloatQuad&gt; quads;
566     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
567         FloatRect boundaries = box-&gt;calculateBoundaries();
568 
569         // Shorten the width of this text box if it ends in an ellipsis.
570         // FIXME: ellipsisRectForBox should switch to return FloatRect soon with the subpixellayout branch.
571         IntRect ellipsisRect = (option == ClipToEllipsis) ? ellipsisRectForBox(*box, 0, renderer.text().length()) : IntRect();
572         if (!ellipsisRect.isEmpty()) {
573             if (renderer.style().isHorizontalWritingMode())
574                 boundaries.setWidth(ellipsisRect.maxX() - boundaries.x());
575             else
576                 boundaries.setHeight(ellipsisRect.maxY() - boundaries.y());
577         }
578         quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
579     }
580     return quads;
581 }
582 
<span class="line-removed">583 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuadsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
<span class="line-removed">584 {</span>
<span class="line-removed">585     Vector&lt;FloatQuad&gt; quads;</span>
<span class="line-removed">586     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">587         // Note: box-&gt;end() returns the index of the last character, not the index past it</span>
<span class="line-removed">588         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end) {</span>
<span class="line-removed">589             FloatRect boundaries = box-&gt;calculateBoundaries();</span>
<span class="line-removed">590             if (useSelectionHeight) {</span>
<span class="line-removed">591                 LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);</span>
<span class="line-removed">592                 if (box-&gt;isHorizontal()) {</span>
<span class="line-removed">593                     boundaries.setHeight(selectionRect.height());</span>
<span class="line-removed">594                     boundaries.setY(selectionRect.y());</span>
<span class="line-removed">595                 } else {</span>
<span class="line-removed">596                     boundaries.setWidth(selectionRect.width());</span>
<span class="line-removed">597                     boundaries.setX(selectionRect.x());</span>
<span class="line-removed">598                 }</span>
<span class="line-removed">599             }</span>
<span class="line-removed">600             quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));</span>
<span class="line-removed">601             continue;</span>
<span class="line-removed">602         }</span>
<span class="line-removed">603         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);</span>
<span class="line-removed">604         if (!rect.isZero())</span>
<span class="line-removed">605             quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));</span>
<span class="line-removed">606     }</span>
<span class="line-removed">607     return quads;</span>
<span class="line-removed">608 }</span>
<span class="line-removed">609 </span>
610 void RenderTextLineBoxes::dirtyAll()
611 {
612     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
613         box-&gt;dirtyLineBoxes();
614 }
615 
616 bool RenderTextLineBoxes::dirtyRange(RenderText&amp; renderer, unsigned start, unsigned end, int lengthDelta)
617 {
618     RootInlineBox* firstRootBox = nullptr;
619     RootInlineBox* lastRootBox = nullptr;
620 
621     // Dirty all text boxes that include characters in between offset and offset+len.
622     bool dirtiedLines = false;
623     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
624         // FIXME: This shouldn&#39;t rely on the end of a dirty line box. See https://bugs.webkit.org/show_bug.cgi?id=97264
625         // Text run is entirely before the affected range.
<span class="line-modified">626         if (current-&gt;end() &lt; start)</span>
627             continue;
628         // Text run is entirely after the affected range.
<span class="line-modified">629         if (current-&gt;start() &gt; end) {</span>
630             current-&gt;offsetRun(lengthDelta);
631             auto&amp; rootBox = current-&gt;root();
632             if (!firstRootBox) {
633                 firstRootBox = &amp;rootBox;
634                 if (!dirtiedLines) {
635                     // The affected area was in between two runs. Mark the root box of the run after the affected area as dirty.
636                     firstRootBox-&gt;markDirty();
637                     dirtiedLines = true;
638                 }
639             }
640             lastRootBox = &amp;rootBox;
641             continue;
642         }
<span class="line-modified">643         if (current-&gt;end() &gt;= start &amp;&amp; current-&gt;end() &lt;= end) {</span>
644             // Text run overlaps with the left end of the affected range.
645             current-&gt;dirtyLineBoxes();
646             dirtiedLines = true;
647             continue;
648         }
649         if (current-&gt;start() &lt;= start &amp;&amp; current-&gt;end() &gt;= end) {
650             // Text run subsumes the affected range.
651             current-&gt;dirtyLineBoxes();
652             dirtiedLines = true;
653             continue;
654         }
<span class="line-modified">655         if (current-&gt;start() &lt;= end &amp;&amp; current-&gt;end() &gt;= end) {</span>
656             // Text run overlaps with right end of the affected range.
657             current-&gt;dirtyLineBoxes();
658             dirtiedLines = true;
659             continue;
660         }
661     }
662 
663     // Now we have to walk all of the clean lines and adjust their cached line break information
664     // to reflect our updated offsets.
665     if (lastRootBox)
666         lastRootBox = lastRootBox-&gt;nextRootBox();
667     if (firstRootBox) {
668         auto previousRootBox = firstRootBox-&gt;prevRootBox();
669         if (previousRootBox)
670             firstRootBox = previousRootBox;
671     } else if (m_last) {
672         ASSERT(!lastRootBox);
673         firstRootBox = &amp;m_last-&gt;root();
674         firstRootBox-&gt;markDirty();
675         dirtiedLines = true;
676     }
677     for (auto* current = firstRootBox; current &amp;&amp; current != lastRootBox; current = current-&gt;nextRootBox()) {
678         if (current-&gt;lineBreakObj() == &amp;renderer &amp;&amp; current-&gt;lineBreakPos() &gt; end)
679             current-&gt;setLineBreakPos(current-&gt;lineBreakPos() + lengthDelta);
680     }
681 
682     // If the text node is empty, dirty the line where new text will be inserted.
683     if (!m_first &amp;&amp; renderer.parent()) {
684         renderer.parent()-&gt;dirtyLinesFromChangedChild(renderer);
685         dirtiedLines = true;
686     }
687     return dirtiedLines;
688 }
689 
690 inline void RenderTextLineBoxes::checkConsistency() const
691 {
<span class="line-modified">692 #if !ASSERT_DISABLED</span>
693 #ifdef CHECK_CONSISTENCY
694     const InlineTextBox* prev = nullptr;
695     for (auto* child = m_first; child; child = child-&gt;nextTextBox()) {
696         ASSERT(child-&gt;renderer() == this);
697         ASSERT(child-&gt;prevTextBox() == prev);
698         prev = child;
699     }
700     ASSERT(prev == m_last);
701 #endif
<span class="line-modified">702 #endif</span>
703 }
704 
<span class="line-modified">705 #if !ASSERT_DISABLED</span>
706 RenderTextLineBoxes::~RenderTextLineBoxes()
707 {
708     ASSERT(!m_first);
709     ASSERT(!m_last);
710 }
711 #endif
712 
713 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
714 void RenderTextLineBoxes::invalidateParentChildLists()
715 {
716     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
717         box-&gt;invalidateParentChildList();
718 }
719 #endif
720 
721 }
</pre>
</td>
<td>
<hr />
<pre>
129     m_first = nullptr;
130     m_last = nullptr;
131 }
132 
133 InlineTextBox* RenderTextLineBoxes::findNext(int offset, int&amp; position) const
134 {
135     if (!m_first)
136         return nullptr;
137     // FIXME: This looks buggy. The function is only used for debugging purposes.
138     auto current = m_first;
139     int currentOffset = current-&gt;len();
140     while (offset &gt; currentOffset &amp;&amp; current-&gt;nextTextBox()) {
141         current = current-&gt;nextTextBox();
142         currentOffset = current-&gt;start() + current-&gt;len();
143     }
144     // we are now in the correct text run
145     position = (offset &gt; currentOffset ? current-&gt;len() : current-&gt;len() - (currentOffset - offset));
146     return current;
147 }
148 































149 LayoutRect RenderTextLineBoxes::visualOverflowBoundingBox(const RenderText&amp; renderer) const
150 {
151     if (!m_first)
152         return LayoutRect();
153 
154     // Return the width of the minimal left side and the maximal right side.
155     auto logicalLeftSide = LayoutUnit::max();
156     auto logicalRightSide = LayoutUnit::min();
157     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
158         logicalLeftSide = std::min(logicalLeftSide, current-&gt;logicalLeftVisualOverflow());
159         logicalRightSide = std::max(logicalRightSide, current-&gt;logicalRightVisualOverflow());
160     }
161 
162     auto logicalTop = m_first-&gt;logicalTopVisualOverflow();
163     auto logicalWidth = logicalRightSide - logicalLeftSide;
164     auto logicalHeight = m_last-&gt;logicalBottomVisualOverflow() - logicalTop;
165 
166     LayoutRect rect(logicalLeftSide, logicalTop, logicalWidth, logicalHeight);
167     if (!renderer.style().isHorizontalWritingMode())
168         rect = rect.transposedRect();
169     return rect;
170 }
171 

































































172 enum ShouldAffinityBeDownstream { AlwaysDownstream, AlwaysUpstream, UpstreamIfPositionIsNotAtStart };
173 
174 static bool lineDirectionPointFitsInBox(int pointLineDirection, const InlineTextBox&amp; box, ShouldAffinityBeDownstream&amp; shouldAffinityBeDownstream)
175 {
176     shouldAffinityBeDownstream = AlwaysDownstream;
177 
178     // the x coordinate is equal to the left edge of this box
179     // the affinity must be downstream so the position doesn&#39;t jump back to the previous line
180     // except when box is the first box in the line
181     if (pointLineDirection &lt;= box.logicalLeft()) {
<span class="line-modified">182         shouldAffinityBeDownstream = !box.previousLeafOnLine() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;</span>
183         return true;
184     }
185 
186 #if !PLATFORM(IOS_FAMILY)
187     // and the x coordinate is to the left of the right edge of this box
188     // check to see if position goes in this box
189     if (pointLineDirection &lt; box.logicalRight()) {
190         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
191         return true;
192     }
193 #endif
194 
195     // box is first on line
196     // and the x coordinate is to the left of the first text box left edge
<span class="line-modified">197     if (!box.previousLeafOnLineIgnoringLineBreak() &amp;&amp; pointLineDirection &lt; box.logicalLeft())</span>
198         return true;
199 
<span class="line-modified">200     if (!box.nextLeafOnLineIgnoringLineBreak()) {</span>
201         // box is last on line
202         // and the x coordinate is to the right of the last text box right edge
203         // generate VisiblePosition, use UPSTREAM affinity if possible
204         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
205         return true;
206     }
207 
208     return false;
209 }
210 
211 static VisiblePosition createVisiblePositionForBox(const InlineBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
212 {
213     EAffinity affinity = VP_DEFAULT_AFFINITY;
214     switch (shouldAffinityBeDownstream) {
215     case AlwaysDownstream:
216         affinity = DOWNSTREAM;
217         break;
218     case AlwaysUpstream:
219         affinity = VP_UPSTREAM_IF_POSSIBLE;
220         break;
221     case UpstreamIfPositionIsNotAtStart:
222         affinity = offset &gt; box.caretMinOffset() ? VP_UPSTREAM_IF_POSSIBLE : DOWNSTREAM;
223         break;
224     }
225     return box.renderer().createVisiblePosition(offset, affinity);
226 }
227 
228 static VisiblePosition createVisiblePositionAfterAdjustingOffsetForBiDi(const InlineTextBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
229 {
230     ASSERT(offset &gt;= 0);
231 
232     if (offset &amp;&amp; static_cast&lt;unsigned&gt;(offset) &lt; box.len())
233         return createVisiblePositionForBox(box, box.start() + offset, shouldAffinityBeDownstream);
234 
235     bool positionIsAtStartOfBox = !offset;
236     if (positionIsAtStartOfBox == box.isLeftToRightDirection()) {
237         // offset is on the left edge
238 
<span class="line-modified">239         const InlineBox* prevBox = box.previousLeafOnLineIgnoringLineBreak();</span>
240         if ((prevBox &amp;&amp; prevBox-&gt;bidiLevel() == box.bidiLevel())
241             || box.renderer().containingBlock()-&gt;style().direction() == box.direction()) // FIXME: left on 12CBA
242             return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
243 
244         if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
245             // e.g. left of B in aDC12BAb
246             const InlineBox* leftmostBox;
247             do {
248                 leftmostBox = prevBox;
<span class="line-modified">249                 prevBox = leftmostBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
250             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel());
251             return createVisiblePositionForBox(*leftmostBox, leftmostBox-&gt;caretRightmostOffset(), shouldAffinityBeDownstream);
252         }
253 
254         if (!prevBox || prevBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
255             // e.g. left of D in aDC12BAb
256             const InlineBox* rightmostBox;
257             const InlineBox* nextBox = &amp;box;
258             do {
259                 rightmostBox = nextBox;
<span class="line-modified">260                 nextBox = rightmostBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
261             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt;= box.bidiLevel());
262             return createVisiblePositionForBox(*rightmostBox,
263                 box.isLeftToRightDirection() ? rightmostBox-&gt;caretMaxOffset() : rightmostBox-&gt;caretMinOffset(), shouldAffinityBeDownstream);
264         }
265 
266         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
267     }
268 
<span class="line-modified">269     const InlineBox* nextBox = box.nextLeafOnLineIgnoringLineBreak();</span>
270     if ((nextBox &amp;&amp; nextBox-&gt;bidiLevel() == box.bidiLevel())
271         || box.renderer().containingBlock()-&gt;style().direction() == box.direction())
272         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
273 
274     // offset is on the right edge
275     if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
276         // e.g. right of C in aDC12BAb
277         const InlineBox* rightmostBox;
278         do {
279             rightmostBox = nextBox;
<span class="line-modified">280             nextBox = rightmostBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
281         } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel());
282         return createVisiblePositionForBox(*rightmostBox, rightmostBox-&gt;caretLeftmostOffset(), shouldAffinityBeDownstream);
283     }
284 
285     if (!nextBox || nextBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
286         // e.g. right of A in aDC12BAb
287         const InlineBox* leftmostBox;
288         const InlineBox* prevBox = &amp;box;
289         do {
290             leftmostBox = prevBox;
<span class="line-modified">291             prevBox = leftmostBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
292         } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt;= box.bidiLevel());
293         return createVisiblePositionForBox(*leftmostBox,
294             box.isLeftToRightDirection() ? leftmostBox-&gt;caretMinOffset() : leftmostBox-&gt;caretMaxOffset(), shouldAffinityBeDownstream);
295     }
296 
297     return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
298 }
299 
300 VisiblePosition RenderTextLineBoxes::positionForPoint(const RenderText&amp; renderer, const LayoutPoint&amp; point) const
301 {
302     if (!m_first || !renderer.text().length())
303         return renderer.createVisiblePosition(0, DOWNSTREAM);
304 
305     LayoutUnit pointLineDirection = m_first-&gt;isHorizontal() ? point.x() : point.y();
306     LayoutUnit pointBlockDirection = m_first-&gt;isHorizontal() ? point.y() : point.x();
307     bool blocksAreFlipped = renderer.style().isFlippedBlocksWritingMode();
308 
309     InlineTextBox* lastBox = nullptr;
310     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">311         if (box-&gt;isLineBreak() &amp;&amp; !box-&gt;previousLeafOnLine() &amp;&amp; box-&gt;nextLeafOnLine() &amp;&amp; !box-&gt;nextLeafOnLine()-&gt;isLineBreak())</span>
312             box = box-&gt;nextTextBox();
313 
314         auto&amp; rootBox = box-&gt;root();
315         LayoutUnit top = std::min(rootBox.selectionTop(), rootBox.lineTop());
316         if (pointBlockDirection &gt; top || (!blocksAreFlipped &amp;&amp; pointBlockDirection == top)) {
317             LayoutUnit bottom = rootBox.selectionBottom();
318             if (rootBox.nextRootBox())
319                 bottom = std::min(bottom, rootBox.nextRootBox()-&gt;lineTop());
320 
321             if (pointBlockDirection &lt; bottom || (blocksAreFlipped &amp;&amp; pointBlockDirection == bottom)) {
322                 ShouldAffinityBeDownstream shouldAffinityBeDownstream;
323 #if PLATFORM(IOS_FAMILY)
324                 if (pointLineDirection != box-&gt;logicalLeft() &amp;&amp; point.x() &lt; box-&gt;x() + box-&gt;logicalWidth()) {
325                     int half = box-&gt;x() + box-&gt;logicalWidth() / 2;
326                     EAffinity affinity = point.x() &lt; half ? DOWNSTREAM : VP_UPSTREAM_IF_POSSIBLE;
327                     return renderer.createVisiblePosition(box-&gt;offsetForPosition(pointLineDirection) + box-&gt;start(), affinity);
328                 }
329 #endif
330                 if (lineDirectionPointFitsInBox(pointLineDirection, *box, shouldAffinityBeDownstream))
331                     return createVisiblePositionAfterAdjustingOffsetForBiDi(*box, box-&gt;offsetForPosition(pointLineDirection), shouldAffinityBeDownstream);
</pre>
<hr />
<pre>
333         }
334         lastBox = box;
335     }
336 
337     if (lastBox) {
338         ShouldAffinityBeDownstream shouldAffinityBeDownstream;
339         lineDirectionPointFitsInBox(pointLineDirection, *lastBox, shouldAffinityBeDownstream);
340         return createVisiblePositionAfterAdjustingOffsetForBiDi(*lastBox, lastBox-&gt;offsetForPosition(pointLineDirection) + lastBox-&gt;start(), shouldAffinityBeDownstream);
341     }
342     return renderer.createVisiblePosition(0, DOWNSTREAM);
343 }
344 
345 void RenderTextLineBoxes::setSelectionState(RenderText&amp; renderer, RenderObject::SelectionState state)
346 {
347     if (state == RenderObject::SelectionInside || state == RenderObject::SelectionNone) {
348         for (auto* box = m_first; box; box = box-&gt;nextTextBox())
349             box-&gt;root().setHasSelectedChildren(state == RenderObject::SelectionInside);
350         return;
351     }
352 
<span class="line-modified">353     auto start = renderer.view().selection().startOffset();</span>
<span class="line-modified">354     auto end = renderer.view().selection().endOffset();</span>
355     if (state == RenderObject::SelectionStart) {
356         end = renderer.text().length();
357         // to handle selection from end of text to end of line
358         if (start &amp;&amp; start == end)
359             start = end - 1;
360     } else if (state == RenderObject::SelectionEnd)
361         start = 0;
362 
363     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
364         if (box-&gt;isSelected(start, end))
365             box-&gt;root().setHasSelectedChildren(true);
366     }
367 }
368 
369 static IntRect ellipsisRectForBox(const InlineTextBox&amp; box, unsigned start, unsigned end)
370 {
371     unsigned short truncation = box.truncation();
372     if (truncation == cNoTruncation)
373         return IntRect();
374 
</pre>
<hr />
<pre>
392 {
393     LayoutRect rect;
394     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
395         rect.unite(box-&gt;localSelectionRect(start, end));
396         rect.unite(ellipsisRectForBox(*box, start, end));
397     }
398     return rect;
399 }
400 
401 void RenderTextLineBoxes::collectSelectionRectsForRange(unsigned start, unsigned end, Vector&lt;LayoutRect&gt;&amp; rects)
402 {
403     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
404         LayoutRect rect;
405         rect.unite(box-&gt;localSelectionRect(start, end));
406         rect.unite(ellipsisRectForBox(*box, start, end));
407         if (!rect.size().isEmpty())
408             rects.append(rect);
409     }
410 }
411 








412 static FloatRect localQuadForTextBox(const InlineTextBox&amp; box, unsigned start, unsigned end, bool useSelectionHeight)
413 {
<span class="line-modified">414     unsigned realEnd = std::min(box.end(), end);</span>
415     LayoutRect boxSelectionRect = box.localSelectionRect(start, realEnd);
416     if (!boxSelectionRect.height())
417         return FloatRect();
418     if (useSelectionHeight)
419         return boxSelectionRect;
420     // Change the height and y position (or width and x for vertical text)
421     // because selectionRect uses selection-specific values.
422     if (box.isHorizontal()) {
423         boxSelectionRect.setHeight(box.height());
424         boxSelectionRect.setY(box.y());
425     } else {
426         boxSelectionRect.setWidth(box.width());
427         boxSelectionRect.setX(box.x());
428     }
429     return boxSelectionRect;
430 }
431 
<span class="line-modified">432 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuadsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool ignoreEmptyTextSelections, bool* wasFixed) const</span>
433 {
<span class="line-modified">434     Vector&lt;FloatQuad&gt; quads;</span>
435     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<span class="line-modified">436         if (ignoreEmptyTextSelections &amp;&amp; !box-&gt;isSelected(start, end))</span>
<span class="line-modified">437             continue;</span>
<span class="line-added">438         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt;= end) {</span>
439             FloatRect boundaries = box-&gt;calculateBoundaries();
440             if (useSelectionHeight) {
441                 LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);
442                 if (box-&gt;isHorizontal()) {
443                     boundaries.setHeight(selectionRect.height());
444                     boundaries.setY(selectionRect.y());
445                 } else {
446                     boundaries.setWidth(selectionRect.width());
447                     boundaries.setX(selectionRect.x());
448                 }
449             }
<span class="line-modified">450             quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));</span>
451             continue;
452         }
453         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
454         if (!rect.isZero())
<span class="line-modified">455             quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));</span>
456     }
<span class="line-modified">457     return quads;</span>
<span class="line-added">458 }</span>
<span class="line-added">459 </span>
<span class="line-added">460 Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRectsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
<span class="line-added">461 {</span>
<span class="line-added">462     return absoluteQuadsForRange(renderer, start, end, useSelectionHeight, false /* ignoreEmptyTextSelections */, wasFixed).map([](auto&amp; quad) { return quad.enclosingBoundingBox(); });</span>
463 }
464 
465 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuads(const RenderText&amp; renderer, bool* wasFixed, ClippingOption option) const
466 {
467     Vector&lt;FloatQuad&gt; quads;
468     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
469         FloatRect boundaries = box-&gt;calculateBoundaries();
470 
471         // Shorten the width of this text box if it ends in an ellipsis.
472         // FIXME: ellipsisRectForBox should switch to return FloatRect soon with the subpixellayout branch.
473         IntRect ellipsisRect = (option == ClipToEllipsis) ? ellipsisRectForBox(*box, 0, renderer.text().length()) : IntRect();
474         if (!ellipsisRect.isEmpty()) {
475             if (renderer.style().isHorizontalWritingMode())
476                 boundaries.setWidth(ellipsisRect.maxX() - boundaries.x());
477             else
478                 boundaries.setHeight(ellipsisRect.maxY() - boundaries.y());
479         }
480         quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
481     }
482     return quads;
483 }
484 



























485 void RenderTextLineBoxes::dirtyAll()
486 {
487     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
488         box-&gt;dirtyLineBoxes();
489 }
490 
491 bool RenderTextLineBoxes::dirtyRange(RenderText&amp; renderer, unsigned start, unsigned end, int lengthDelta)
492 {
493     RootInlineBox* firstRootBox = nullptr;
494     RootInlineBox* lastRootBox = nullptr;
495 
496     // Dirty all text boxes that include characters in between offset and offset+len.
497     bool dirtiedLines = false;
498     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
499         // FIXME: This shouldn&#39;t rely on the end of a dirty line box. See https://bugs.webkit.org/show_bug.cgi?id=97264
500         // Text run is entirely before the affected range.
<span class="line-modified">501         if (current-&gt;end() &lt;= start)</span>
502             continue;
503         // Text run is entirely after the affected range.
<span class="line-modified">504         if (current-&gt;start() &gt;= end) {</span>
505             current-&gt;offsetRun(lengthDelta);
506             auto&amp; rootBox = current-&gt;root();
507             if (!firstRootBox) {
508                 firstRootBox = &amp;rootBox;
509                 if (!dirtiedLines) {
510                     // The affected area was in between two runs. Mark the root box of the run after the affected area as dirty.
511                     firstRootBox-&gt;markDirty();
512                     dirtiedLines = true;
513                 }
514             }
515             lastRootBox = &amp;rootBox;
516             continue;
517         }
<span class="line-modified">518         if (current-&gt;end() &gt; start &amp;&amp; current-&gt;end() &lt;= end) {</span>
519             // Text run overlaps with the left end of the affected range.
520             current-&gt;dirtyLineBoxes();
521             dirtiedLines = true;
522             continue;
523         }
524         if (current-&gt;start() &lt;= start &amp;&amp; current-&gt;end() &gt;= end) {
525             // Text run subsumes the affected range.
526             current-&gt;dirtyLineBoxes();
527             dirtiedLines = true;
528             continue;
529         }
<span class="line-modified">530         if (current-&gt;start() &lt; end &amp;&amp; current-&gt;end() &gt;= end) {</span>
531             // Text run overlaps with right end of the affected range.
532             current-&gt;dirtyLineBoxes();
533             dirtiedLines = true;
534             continue;
535         }
536     }
537 
538     // Now we have to walk all of the clean lines and adjust their cached line break information
539     // to reflect our updated offsets.
540     if (lastRootBox)
541         lastRootBox = lastRootBox-&gt;nextRootBox();
542     if (firstRootBox) {
543         auto previousRootBox = firstRootBox-&gt;prevRootBox();
544         if (previousRootBox)
545             firstRootBox = previousRootBox;
546     } else if (m_last) {
547         ASSERT(!lastRootBox);
548         firstRootBox = &amp;m_last-&gt;root();
549         firstRootBox-&gt;markDirty();
550         dirtiedLines = true;
551     }
552     for (auto* current = firstRootBox; current &amp;&amp; current != lastRootBox; current = current-&gt;nextRootBox()) {
553         if (current-&gt;lineBreakObj() == &amp;renderer &amp;&amp; current-&gt;lineBreakPos() &gt; end)
554             current-&gt;setLineBreakPos(current-&gt;lineBreakPos() + lengthDelta);
555     }
556 
557     // If the text node is empty, dirty the line where new text will be inserted.
558     if (!m_first &amp;&amp; renderer.parent()) {
559         renderer.parent()-&gt;dirtyLinesFromChangedChild(renderer);
560         dirtiedLines = true;
561     }
562     return dirtiedLines;
563 }
564 
565 inline void RenderTextLineBoxes::checkConsistency() const
566 {
<span class="line-modified">567 #if ASSERT_ENABLED</span>
568 #ifdef CHECK_CONSISTENCY
569     const InlineTextBox* prev = nullptr;
570     for (auto* child = m_first; child; child = child-&gt;nextTextBox()) {
571         ASSERT(child-&gt;renderer() == this);
572         ASSERT(child-&gt;prevTextBox() == prev);
573         prev = child;
574     }
575     ASSERT(prev == m_last);
576 #endif
<span class="line-modified">577 #endif // ASSERT_ENABLED</span>
578 }
579 
<span class="line-modified">580 #if ASSERT_ENABLED</span>
581 RenderTextLineBoxes::~RenderTextLineBoxes()
582 {
583     ASSERT(!m_first);
584     ASSERT(!m_last);
585 }
586 #endif
587 
588 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
589 void RenderTextLineBoxes::invalidateParentChildLists()
590 {
591     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
592         box-&gt;invalidateParentChildList();
593 }
594 #endif
595 
596 }
</pre>
</td>
</tr>
</table>
<center><a href="RenderText.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextLineBoxes.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
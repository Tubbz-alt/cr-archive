<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/LargeRange.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LargeMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LineMetadata.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/LargeRange.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef LargeRange_h
 27 #define LargeRange_h
 28 
 29 #include &quot;BAssert.h&quot;
 30 #include &quot;Range.h&quot;
 31 
 32 namespace bmalloc {
 33 
 34 class LargeRange : public Range {
 35 public:
 36     LargeRange()
 37         : Range()
 38         , m_startPhysicalSize(0)
 39         , m_totalPhysicalSize(0)

 40         , m_isEligible(true)
 41         , m_usedSinceLastScavenge(false)

 42     {
 43     }
 44 
 45     LargeRange(const Range&amp; other, size_t startPhysicalSize, size_t totalPhysicalSize)
 46         : Range(other)
 47         , m_startPhysicalSize(startPhysicalSize)
 48         , m_totalPhysicalSize(totalPhysicalSize)

 49         , m_isEligible(true)
 50         , m_usedSinceLastScavenge(false)

 51     {
 52         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());
 53         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());
 54     }
 55 










 56     LargeRange(void* begin, size_t size, size_t startPhysicalSize, size_t totalPhysicalSize, bool usedSinceLastScavenge = false)
 57         : Range(begin, size)
 58         , m_startPhysicalSize(startPhysicalSize)
 59         , m_totalPhysicalSize(totalPhysicalSize)
 60         , m_isEligible(true)
 61         , m_usedSinceLastScavenge(usedSinceLastScavenge)
 62     {
 63         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());
 64         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());
 65     }

 66 
 67     // Returns a lower bound on physical size at the start of the range. Ranges that
 68     // span non-physical fragments use this number to remember the physical size of
 69     // the first fragment.
 70     size_t startPhysicalSize() const { return m_startPhysicalSize; }
 71     void setStartPhysicalSize(size_t startPhysicalSize) { m_startPhysicalSize = startPhysicalSize; }
 72 
 73     // This is accurate in the sense that if you take a range A and split it N ways
 74     // and sum totalPhysicalSize over each of the N splits, you&#39;ll end up with A&#39;s
 75     // totalPhysicalSize. This means if you take a LargeRange out of a LargeMap, split it,
 76     // then insert the subsequent two ranges back into the LargeMap, the sum of the
 77     // totalPhysicalSize of each LargeRange in the LargeMap will stay constant. This
 78     // property is not true of startPhysicalSize. This invariant about totalPhysicalSize
 79     // is good enough to get an accurate footprint estimate for memory used in bmalloc.
 80     // The reason this is just an estimate is that splitting LargeRanges may lead to this
 81     // number being rebalanced in arbitrary ways between the two resulting ranges. This
 82     // is why the footprint is just an estimate. In practice, this arbitrary rebalance
 83     // doesn&#39;t really affect accuracy.
 84     size_t totalPhysicalSize() const { return m_totalPhysicalSize; }
 85     void setTotalPhysicalSize(size_t totalPhysicalSize) { m_totalPhysicalSize = totalPhysicalSize; }
 86 
 87     std::pair&lt;LargeRange, LargeRange&gt; split(size_t) const;
 88 
 89     void setEligible(bool eligible) { m_isEligible = eligible; }
 90     bool isEligibile() const { return m_isEligible; }
 91 

 92     bool usedSinceLastScavenge() const { return m_usedSinceLastScavenge; }
 93     void clearUsedSinceLastScavenge() { m_usedSinceLastScavenge = false; }
 94     void setUsedSinceLastScavenge() { m_usedSinceLastScavenge = true; }

 95 
 96     bool operator&lt;(const void* other) const { return begin() &lt; other; }
 97     bool operator&lt;(const LargeRange&amp; other) const { return begin() &lt; other.begin(); }
 98 
 99 private:
100     size_t m_startPhysicalSize;
101     size_t m_totalPhysicalSize;



102     unsigned m_isEligible: 1;
103     unsigned m_usedSinceLastScavenge: 1;

104 };
105 
106 inline bool canMerge(const LargeRange&amp; a, const LargeRange&amp; b)
107 {
108     if (!a.isEligibile() || !b.isEligibile()) {
109         // FIXME: We can make this work if we find it&#39;s helpful as long as the merged
110         // range is only eligible if a and b are eligible.
111         return false;
112     }
113 
114     if (a.end() == b.begin())
115         return true;
116 
117     if (b.end() == a.begin())
118         return true;
119 
120     return false;
121 }
122 
123 inline LargeRange merge(const LargeRange&amp; a, const LargeRange&amp; b)
124 {
125     const LargeRange&amp; left = std::min(a, b);

126     bool mergedUsedSinceLastScavenge = a.usedSinceLastScavenge() || b.usedSinceLastScavenge();

127     if (left.size() == left.startPhysicalSize()) {
128         return LargeRange(
129             left.begin(),
130             a.size() + b.size(),
131             a.startPhysicalSize() + b.startPhysicalSize(),
<span class="line-modified">132             a.totalPhysicalSize() + b.totalPhysicalSize(),</span>
<span class="line-modified">133             mergedUsedSinceLastScavenge);</span>




134     }
135 
136     return LargeRange(
137         left.begin(),
138         a.size() + b.size(),
139         left.startPhysicalSize(),
<span class="line-modified">140         a.totalPhysicalSize() + b.totalPhysicalSize(),</span>
<span class="line-modified">141         mergedUsedSinceLastScavenge);</span>



142 }
143 
144 inline std::pair&lt;LargeRange, LargeRange&gt; LargeRange::split(size_t leftSize) const
145 {
146     BASSERT(leftSize &lt;= this-&gt;size());
147     size_t rightSize = this-&gt;size() - leftSize;
148 
149     if (leftSize &lt;= startPhysicalSize()) {
150         BASSERT(totalPhysicalSize() &gt;= leftSize);
151         LargeRange left(begin(), leftSize, leftSize, leftSize);
152         LargeRange right(left.end(), rightSize, startPhysicalSize() - leftSize, totalPhysicalSize() - leftSize);
153         return std::make_pair(left, right);
154     }
155 
156     double ratio = static_cast&lt;double&gt;(leftSize) / static_cast&lt;double&gt;(this-&gt;size());
157     size_t leftTotalPhysicalSize = static_cast&lt;size_t&gt;(ratio * totalPhysicalSize());
158     BASSERT(leftTotalPhysicalSize &lt;= leftSize);
159     leftTotalPhysicalSize = std::max(startPhysicalSize(), leftTotalPhysicalSize);
160     size_t rightTotalPhysicalSize = totalPhysicalSize() - leftTotalPhysicalSize;
161     if (rightTotalPhysicalSize &gt; rightSize) { // This may happen because of rounding.
</pre>
</td>
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef LargeRange_h
 27 #define LargeRange_h
 28 
 29 #include &quot;BAssert.h&quot;
 30 #include &quot;Range.h&quot;
 31 
 32 namespace bmalloc {
 33 
 34 class LargeRange : public Range {
 35 public:
 36     LargeRange()
 37         : Range()
 38         , m_startPhysicalSize(0)
 39         , m_totalPhysicalSize(0)
<span class="line-added"> 40 #if !BUSE(PARTIAL_SCAVENGE)</span>
 41         , m_isEligible(true)
 42         , m_usedSinceLastScavenge(false)
<span class="line-added"> 43 #endif</span>
 44     {
 45     }
 46 
 47     LargeRange(const Range&amp; other, size_t startPhysicalSize, size_t totalPhysicalSize)
 48         : Range(other)
 49         , m_startPhysicalSize(startPhysicalSize)
 50         , m_totalPhysicalSize(totalPhysicalSize)
<span class="line-added"> 51 #if !BUSE(PARTIAL_SCAVENGE)</span>
 52         , m_isEligible(true)
 53         , m_usedSinceLastScavenge(false)
<span class="line-added"> 54 #endif</span>
 55     {
 56         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());
 57         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());
 58     }
 59 
<span class="line-added"> 60 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added"> 61     LargeRange(void* begin, size_t size, size_t startPhysicalSize, size_t totalPhysicalSize)</span>
<span class="line-added"> 62         : Range(begin, size)</span>
<span class="line-added"> 63         , m_startPhysicalSize(startPhysicalSize)</span>
<span class="line-added"> 64         , m_totalPhysicalSize(totalPhysicalSize)</span>
<span class="line-added"> 65     {</span>
<span class="line-added"> 66         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());</span>
<span class="line-added"> 67         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 #else</span>
 70     LargeRange(void* begin, size_t size, size_t startPhysicalSize, size_t totalPhysicalSize, bool usedSinceLastScavenge = false)
 71         : Range(begin, size)
 72         , m_startPhysicalSize(startPhysicalSize)
 73         , m_totalPhysicalSize(totalPhysicalSize)
 74         , m_isEligible(true)
 75         , m_usedSinceLastScavenge(usedSinceLastScavenge)
 76     {
 77         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());
 78         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());
 79     }
<span class="line-added"> 80 #endif</span>
 81 
 82     // Returns a lower bound on physical size at the start of the range. Ranges that
 83     // span non-physical fragments use this number to remember the physical size of
 84     // the first fragment.
 85     size_t startPhysicalSize() const { return m_startPhysicalSize; }
 86     void setStartPhysicalSize(size_t startPhysicalSize) { m_startPhysicalSize = startPhysicalSize; }
 87 
 88     // This is accurate in the sense that if you take a range A and split it N ways
 89     // and sum totalPhysicalSize over each of the N splits, you&#39;ll end up with A&#39;s
 90     // totalPhysicalSize. This means if you take a LargeRange out of a LargeMap, split it,
 91     // then insert the subsequent two ranges back into the LargeMap, the sum of the
 92     // totalPhysicalSize of each LargeRange in the LargeMap will stay constant. This
 93     // property is not true of startPhysicalSize. This invariant about totalPhysicalSize
 94     // is good enough to get an accurate footprint estimate for memory used in bmalloc.
 95     // The reason this is just an estimate is that splitting LargeRanges may lead to this
 96     // number being rebalanced in arbitrary ways between the two resulting ranges. This
 97     // is why the footprint is just an estimate. In practice, this arbitrary rebalance
 98     // doesn&#39;t really affect accuracy.
 99     size_t totalPhysicalSize() const { return m_totalPhysicalSize; }
100     void setTotalPhysicalSize(size_t totalPhysicalSize) { m_totalPhysicalSize = totalPhysicalSize; }
101 
102     std::pair&lt;LargeRange, LargeRange&gt; split(size_t) const;
103 
104     void setEligible(bool eligible) { m_isEligible = eligible; }
105     bool isEligibile() const { return m_isEligible; }
106 
<span class="line-added">107 #if !BUSE(PARTIAL_SCAVENGE)</span>
108     bool usedSinceLastScavenge() const { return m_usedSinceLastScavenge; }
109     void clearUsedSinceLastScavenge() { m_usedSinceLastScavenge = false; }
110     void setUsedSinceLastScavenge() { m_usedSinceLastScavenge = true; }
<span class="line-added">111 #endif</span>
112 
113     bool operator&lt;(const void* other) const { return begin() &lt; other; }
114     bool operator&lt;(const LargeRange&amp; other) const { return begin() &lt; other.begin(); }
115 
116 private:
117     size_t m_startPhysicalSize;
118     size_t m_totalPhysicalSize;
<span class="line-added">119 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">120     bool m_isEligible { true };</span>
<span class="line-added">121 #else</span>
122     unsigned m_isEligible: 1;
123     unsigned m_usedSinceLastScavenge: 1;
<span class="line-added">124 #endif</span>
125 };
126 
127 inline bool canMerge(const LargeRange&amp; a, const LargeRange&amp; b)
128 {
129     if (!a.isEligibile() || !b.isEligibile()) {
130         // FIXME: We can make this work if we find it&#39;s helpful as long as the merged
131         // range is only eligible if a and b are eligible.
132         return false;
133     }
134 
135     if (a.end() == b.begin())
136         return true;
137 
138     if (b.end() == a.begin())
139         return true;
140 
141     return false;
142 }
143 
144 inline LargeRange merge(const LargeRange&amp; a, const LargeRange&amp; b)
145 {
146     const LargeRange&amp; left = std::min(a, b);
<span class="line-added">147 #if !BUSE(PARTIAL_SCAVENGE)</span>
148     bool mergedUsedSinceLastScavenge = a.usedSinceLastScavenge() || b.usedSinceLastScavenge();
<span class="line-added">149 #endif</span>
150     if (left.size() == left.startPhysicalSize()) {
151         return LargeRange(
152             left.begin(),
153             a.size() + b.size(),
154             a.startPhysicalSize() + b.startPhysicalSize(),
<span class="line-modified">155             a.totalPhysicalSize() + b.totalPhysicalSize()</span>
<span class="line-modified">156 #if !BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">157             , mergedUsedSinceLastScavenge</span>
<span class="line-added">158 #endif</span>
<span class="line-added">159         );</span>
<span class="line-added">160 </span>
161     }
162 
163     return LargeRange(
164         left.begin(),
165         a.size() + b.size(),
166         left.startPhysicalSize(),
<span class="line-modified">167         a.totalPhysicalSize() + b.totalPhysicalSize()</span>
<span class="line-modified">168 #if !BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">169         , mergedUsedSinceLastScavenge</span>
<span class="line-added">170 #endif</span>
<span class="line-added">171     );</span>
172 }
173 
174 inline std::pair&lt;LargeRange, LargeRange&gt; LargeRange::split(size_t leftSize) const
175 {
176     BASSERT(leftSize &lt;= this-&gt;size());
177     size_t rightSize = this-&gt;size() - leftSize;
178 
179     if (leftSize &lt;= startPhysicalSize()) {
180         BASSERT(totalPhysicalSize() &gt;= leftSize);
181         LargeRange left(begin(), leftSize, leftSize, leftSize);
182         LargeRange right(left.end(), rightSize, startPhysicalSize() - leftSize, totalPhysicalSize() - leftSize);
183         return std::make_pair(left, right);
184     }
185 
186     double ratio = static_cast&lt;double&gt;(leftSize) / static_cast&lt;double&gt;(this-&gt;size());
187     size_t leftTotalPhysicalSize = static_cast&lt;size_t&gt;(ratio * totalPhysicalSize());
188     BASSERT(leftTotalPhysicalSize &lt;= leftSize);
189     leftTotalPhysicalSize = std::max(startPhysicalSize(), leftTotalPhysicalSize);
190     size_t rightTotalPhysicalSize = totalPhysicalSize() - leftTotalPhysicalSize;
191     if (rightTotalPhysicalSize &gt; rightSize) { // This may happen because of rounding.
</pre>
</td>
</tr>
</table>
<center><a href="LargeMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LineMetadata.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
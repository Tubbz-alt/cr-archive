<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;B3Compilation.h&quot;
 31 #include &quot;B3Procedure.h&quot;
 32 #include &quot;VirtualRegister.h&quot;
 33 #include &quot;WasmFormat.h&quot;
 34 #include &quot;WasmLimits.h&quot;
 35 #include &quot;WasmModuleInformation.h&quot;
 36 #include &quot;WasmOps.h&quot;
 37 #include &quot;WasmSections.h&quot;
 38 #include &lt;type_traits&gt;
 39 #include &lt;wtf/Expected.h&gt;
 40 #include &lt;wtf/LEBDecoder.h&gt;
 41 #include &lt;wtf/StdLibExtras.h&gt;
 42 #include &lt;wtf/StringPrintStream.h&gt;
 43 #include &lt;wtf/text/WTFString.h&gt;
 44 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
 45 
 46 namespace JSC { namespace Wasm {
 47 
 48 namespace FailureHelper {
 49 // FIXME We should move this to makeString. It&#39;s in its own namespace to enable C++ Argument Dependent Lookup Ã  la std::swap: user code can deblare its own &quot;boxFailure&quot; and the fail() helper will find it.
 50 template&lt;typename T&gt;
 51 inline String makeString(const T&amp; failure) { return WTF::toString(failure); }
 52 }
 53 
 54 template&lt;typename SuccessType&gt;
 55 class Parser {
 56 public:
 57     typedef String ErrorType;
 58     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 59     typedef Expected&lt;void, ErrorType&gt; PartialResult;
 60     typedef Expected&lt;SuccessType, ErrorType&gt; Result;
 61 
 62     const uint8_t* source() const { return m_source; }
 63     size_t length() const { return m_sourceLength; }
 64     size_t offset() const { return m_offset; }
 65 
 66 protected:
 67     Parser(const uint8_t*, size_t);
 68 
 69     bool WARN_UNUSED_RETURN consumeCharacter(char);
 70     bool WARN_UNUSED_RETURN consumeString(const char*);
 71     bool WARN_UNUSED_RETURN consumeUTF8String(Name&amp;, size_t);
 72 
 73     bool WARN_UNUSED_RETURN parseVarUInt1(uint8_t&amp;);
 74     bool WARN_UNUSED_RETURN parseInt7(int8_t&amp;);
 75     bool WARN_UNUSED_RETURN peekInt7(int8_t&amp;);
 76     bool WARN_UNUSED_RETURN parseUInt7(uint8_t&amp;);
 77     bool WARN_UNUSED_RETURN parseUInt8(uint8_t&amp;);
 78     bool WARN_UNUSED_RETURN parseUInt32(uint32_t&amp;);
 79     bool WARN_UNUSED_RETURN parseUInt64(uint64_t&amp;);
 80     bool WARN_UNUSED_RETURN parseVarUInt32(uint32_t&amp;);
 81     bool WARN_UNUSED_RETURN parseVarUInt64(uint64_t&amp;);
 82 
 83     bool WARN_UNUSED_RETURN parseVarInt32(int32_t&amp;);
 84     bool WARN_UNUSED_RETURN parseVarInt64(int64_t&amp;);
 85 
 86     PartialResult WARN_UNUSED_RETURN parseBlockSignature(const ModuleInformation&amp;, BlockSignature&amp;);
 87     bool WARN_UNUSED_RETURN parseValueType(Type&amp;);
 88     bool WARN_UNUSED_RETURN parseExternalKind(ExternalKind&amp;);
 89 
 90     size_t m_offset = 0;
 91 
 92     template &lt;typename ...Args&gt;
 93     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 94     {
 95         using namespace FailureHelper; // See ADL comment in namespace above.
 96         return UnexpectedResult(makeString(&quot;WebAssembly.Module doesn&#39;t parse at byte &quot;_s, String::number(m_offset), &quot;: &quot;_s, makeString(args)...));
 97     }
 98 #define WASM_PARSER_FAIL_IF(condition, ...) do { \
 99     if (UNLIKELY(condition))                     \
100         return fail(__VA_ARGS__);                \
101     } while (0)
102 
103 #define WASM_FAIL_IF_HELPER_FAILS(helper) do {                      \
104         auto helperResult = helper;                                 \
105         if (UNLIKELY(!helperResult))                                \
106             return makeUnexpected(WTFMove(helperResult.error()));   \
107     } while (0)
108 
109 private:
110     const uint8_t* m_source;
111     size_t m_sourceLength;
112     // We keep a local reference to the global table so we don&#39;t have to fetch it to find thunk signatures.
113     const SignatureInformation&amp; m_signatureInformation;
114 };
115 
116 template&lt;typename SuccessType&gt;
117 ALWAYS_INLINE Parser&lt;SuccessType&gt;::Parser(const uint8_t* sourceBuffer, size_t sourceLength)
118     : m_source(sourceBuffer)
119     , m_sourceLength(sourceLength)
120     , m_signatureInformation(SignatureInformation::singleton())
121 {
122 }
123 
124 template&lt;typename SuccessType&gt;
125 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeCharacter(char c)
126 {
127     if (m_offset &gt;= length())
128         return false;
129     if (c == source()[m_offset]) {
130         m_offset++;
131         return true;
132     }
133     return false;
134 }
135 
136 template&lt;typename SuccessType&gt;
137 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeString(const char* str)
138 {
139     unsigned start = m_offset;
140     if (m_offset &gt;= length())
141         return false;
142     for (size_t i = 0; str[i]; i++) {
143         if (!consumeCharacter(str[i])) {
144             m_offset = start;
145             return false;
146         }
147     }
148     return true;
149 }
150 
151 template&lt;typename SuccessType&gt;
152 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeUTF8String(Name&amp; result, size_t stringLength)
153 {
154     if (length() &lt; stringLength || m_offset &gt; length() - stringLength)
155         return false;
156     if (stringLength &gt; maxStringSize)
157         return false;
158     if (!result.tryReserveCapacity(stringLength))
159         return false;
160 
161     const uint8_t* stringStart = source() + m_offset;
162 
163     // We don&#39;t cache the UTF-16 characters since it seems likely the string is ASCII.
164     if (UNLIKELY(!charactersAreAllASCII(stringStart, stringLength))) {
165         Vector&lt;UChar, 1024&gt; buffer(stringLength);
166         UChar* bufferStart = buffer.data();
167 
168         UChar* bufferCurrent = bufferStart;
169         const char* stringCurrent = reinterpret_cast&lt;const char*&gt;(stringStart);
170         if (!WTF::Unicode::convertUTF8ToUTF16(stringCurrent, reinterpret_cast&lt;const char *&gt;(stringStart + stringLength), &amp;bufferCurrent, bufferCurrent + buffer.size()))
171             return false;
172     }
173 
174     result.grow(stringLength);
175     memcpy(result.data(), stringStart, stringLength);
176     m_offset += stringLength;
177     return true;
178 }
179 
180 template&lt;typename SuccessType&gt;
181 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseVarUInt32(uint32_t&amp; result)
182 {
183     return WTF::LEBDecoder::decodeUInt32(m_source, m_sourceLength, m_offset, result);
184 }
185 
186 template&lt;typename SuccessType&gt;
187 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseVarUInt64(uint64_t&amp; result)
188 {
189     return WTF::LEBDecoder::decodeUInt64(m_source, m_sourceLength, m_offset, result);
190 }
191 
192 template&lt;typename SuccessType&gt;
193 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseVarInt32(int32_t&amp; result)
194 {
195     return WTF::LEBDecoder::decodeInt32(m_source, m_sourceLength, m_offset, result);
196 }
197 
198 template&lt;typename SuccessType&gt;
199 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseVarInt64(int64_t&amp; result)
200 {
201     return WTF::LEBDecoder::decodeInt64(m_source, m_sourceLength, m_offset, result);
202 }
203 
204 template&lt;typename SuccessType&gt;
205 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt32(uint32_t&amp; result)
206 {
207     if (length() &lt; 4 || m_offset &gt; length() - 4)
208         return false;
209     result = *reinterpret_cast&lt;const uint32_t*&gt;(source() + m_offset);
210     m_offset += 4;
211     return true;
212 }
213 
214 template&lt;typename SuccessType&gt;
215 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt64(uint64_t&amp; result)
216 {
217     if (length() &lt; 8 || m_offset &gt; length() - 8)
218         return false;
219     result = *reinterpret_cast&lt;const uint64_t*&gt;(source() + m_offset);
220     m_offset += 8;
221     return true;
222 }
223 
224 template&lt;typename SuccessType&gt;
225 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt8(uint8_t&amp; result)
226 {
227     if (m_offset &gt;= length())
228         return false;
229     result = source()[m_offset++];
230     return true;
231 }
232 
233 template&lt;typename SuccessType&gt;
234 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseInt7(int8_t&amp; result)
235 {
236     if (m_offset &gt;= length())
237         return false;
238     uint8_t v = source()[m_offset++];
239     result = (v &amp; 0x40) ? WTF::bitwise_cast&lt;int8_t&gt;(uint8_t(v | 0x80)) : v;
240     return (v &amp; 0x80) == 0;
241 }
242 
243 template&lt;typename SuccessType&gt;
244 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::peekInt7(int8_t&amp; result)
245 {
246     if (m_offset &gt;= length())
247         return false;
248     uint8_t v = source()[m_offset];
249     result = (v &amp; 0x40) ? WTF::bitwise_cast&lt;int8_t&gt;(uint8_t(v | 0x80)) : v;
250     return (v &amp; 0x80) == 0;
251 }
252 
253 template&lt;typename SuccessType&gt;
254 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt7(uint8_t&amp; result)
255 {
256     if (m_offset &gt;= length())
257         return false;
258     result = source()[m_offset++];
259     return result &lt; 0x80;
260 }
261 
262 template&lt;typename SuccessType&gt;
263 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseVarUInt1(uint8_t&amp; result)
264 {
265     uint32_t temp;
266     if (!parseVarUInt32(temp))
267         return false;
268     if (temp &gt; 1)
269         return false;
270     result = static_cast&lt;uint8_t&gt;(temp);
271     return true;
272 }
273 
274 template&lt;typename SuccessType&gt;
275 ALWAYS_INLINE typename Parser&lt;SuccessType&gt;::PartialResult Parser&lt;SuccessType&gt;::parseBlockSignature(const ModuleInformation&amp; info, BlockSignature&amp; result)
276 {
277     int8_t value;
278     if (peekInt7(value) &amp;&amp; isValidType(value)) {
279         Type type = static_cast&lt;Type&gt;(value);
280         WASM_PARSER_FAIL_IF(!(isValueType(type) || type == Void), &quot;result type of block: &quot;, makeString(type), &quot; is not a value type or Void&quot;);
281         result = m_signatureInformation.thunkFor(type);
282         m_offset++;
283         return { };
284     }
285 
286     WASM_PARSER_FAIL_IF(!Options::useWebAssemblyMultiValues(), &quot;Type table indices for block signatures are not supported yet&quot;);
287 
288     int64_t index;
289     WASM_PARSER_FAIL_IF(!parseVarInt64(index), &quot;Block-like instruction doesn&#39;t return value type but can&#39;t decode type section index&quot;);
290     WASM_PARSER_FAIL_IF(index &lt; 0, &quot;Block-like instruction signature index is negative&quot;);
291     WASM_PARSER_FAIL_IF(static_cast&lt;size_t&gt;(index) &gt;= info.usedSignatures.size(), &quot;Block-like instruction signature index is out of bounds. Index: &quot;, index, &quot; type index space: &quot;, info.usedSignatures.size());
292 
293     result = &amp;info.usedSignatures[index].get();
294     return { };
295 }
296 
297 template&lt;typename SuccessType&gt;
298 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseValueType(Type&amp; result)
299 {
300     int8_t value;
301     if (!parseInt7(value))
302         return false;
303     if (!isValidType(value) || !isValueType(static_cast&lt;Type&gt;(value)))
304         return false;
305     result = static_cast&lt;Type&gt;(value);
306     return true;
307 }
308 
309 template&lt;typename SuccessType&gt;
310 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseExternalKind(ExternalKind&amp; result)
311 {
312     uint8_t value;
313     if (!parseUInt7(value))
314         return false;
315     if (!isValidExternalKind(value))
316         return false;
317     result = static_cast&lt;ExternalKind&gt;(value);
318     return true;
319 }
320 
321 ALWAYS_INLINE I32InitExpr makeI32InitExpr(uint8_t opcode, uint32_t bits)
322 {
323     RELEASE_ASSERT(opcode == I32Const || opcode == GetGlobal);
324     if (opcode == I32Const)
325         return I32InitExpr::constValue(bits);
326     return I32InitExpr::globalImport(bits);
327 }
328 
329 } } // namespace JSC::Wasm
330 
331 #endif // ENABLE(WEBASSEMBLY)
    </pre>
  </body>
</html>
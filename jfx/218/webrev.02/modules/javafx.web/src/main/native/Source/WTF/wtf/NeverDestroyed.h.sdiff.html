<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/NeverDestroyed.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NaturalLoops.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/NeverDestroyed.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83     // and hand out chunks of it to NeverDestroyed instead, to reduce fragmentation.
 84     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_storage;
 85 };
 86 
 87 template&lt;typename T&gt; NeverDestroyed&lt;T&gt; makeNeverDestroyed(T&amp;&amp;);
 88 
 89 // FIXME: It&#39;s messy to have to repeat the whole class just to make this &quot;lazy&quot; version.
 90 // Should revisit clients to see if we really need this, and perhaps use templates to
 91 // share more of the code with the main NeverDestroyed above.
 92 template&lt;typename T&gt; class LazyNeverDestroyed {
 93     WTF_MAKE_NONCOPYABLE(LazyNeverDestroyed);
 94     WTF_FORBID_HEAP_ALLOCATION;
 95 public:
 96     LazyNeverDestroyed() = default;
 97 
 98     template&lt;typename... Args&gt;
 99     void construct(Args&amp;&amp;... args)
100     {
101         ASSERT(!m_isConstructed);
102 
<span class="line-modified">103 #if !ASSERT_DISABLED</span>
104         m_isConstructed = true;
105 #endif
106 
107         MaybeRelax&lt;T&gt;(new (storagePointer()) T(std::forward&lt;Args&gt;(args)...));
108     }
109 
110     operator T&amp;() { return *storagePointer(); }
111     T&amp; get() { return *storagePointer(); }
112 
113     T* operator-&gt;() { return storagePointer(); }
114 
115     operator const T&amp;() const { return *storagePointer(); }
116     const T&amp; get() const { return *storagePointer(); }
117 
118     const T* operator-&gt;() const { return storagePointer(); }
119 
<span class="line-modified">120 #if !ASSERT_DISABLED</span>
121     bool isConstructed() const { return m_isConstructed; }
122 #endif
123 
124 private:
125     using PointerType = typename std::remove_const&lt;T&gt;::type*;
126 
127     PointerType storagePointer() const
128     {
129         ASSERT(m_isConstructed);
130         return const_cast&lt;PointerType&gt;(reinterpret_cast&lt;const T*&gt;(&amp;m_storage));
131     }
132 
133     template&lt;typename PtrType, bool ShouldRelax = std::is_base_of&lt;RefCountedBase, PtrType&gt;::value&gt; struct MaybeRelax {
134         explicit MaybeRelax(PtrType*) { }
135     };
136     template&lt;typename PtrType&gt; struct MaybeRelax&lt;PtrType, true&gt; {
137         explicit MaybeRelax(PtrType* ptr) { ptr-&gt;relaxAdoptionRequirement(); }
138     };
139 
<span class="line-modified">140 #if !ASSERT_DISABLED</span>
141     // LazyNeverDestroyed objects are always static, so this variable is initialized to false.
142     // It must not be initialized dynamically; that would not be thread safe.
143     bool m_isConstructed;
144 #endif
145 
146     // FIXME: Investigate whether we should allocate a hunk of virtual memory
147     // and hand out chunks of it to NeverDestroyed instead, to reduce fragmentation.
148     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_storage;
149 };
150 
151 template&lt;typename T&gt; inline NeverDestroyed&lt;T&gt; makeNeverDestroyed(T&amp;&amp; argument)
152 {
153     return WTFMove(argument);
154 }
155 
156 } // namespace WTF;
157 
158 using WTF::LazyNeverDestroyed;
159 using WTF::NeverDestroyed;
160 using WTF::makeNeverDestroyed;
</pre>
</td>
<td>
<hr />
<pre>
 83     // and hand out chunks of it to NeverDestroyed instead, to reduce fragmentation.
 84     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_storage;
 85 };
 86 
 87 template&lt;typename T&gt; NeverDestroyed&lt;T&gt; makeNeverDestroyed(T&amp;&amp;);
 88 
 89 // FIXME: It&#39;s messy to have to repeat the whole class just to make this &quot;lazy&quot; version.
 90 // Should revisit clients to see if we really need this, and perhaps use templates to
 91 // share more of the code with the main NeverDestroyed above.
 92 template&lt;typename T&gt; class LazyNeverDestroyed {
 93     WTF_MAKE_NONCOPYABLE(LazyNeverDestroyed);
 94     WTF_FORBID_HEAP_ALLOCATION;
 95 public:
 96     LazyNeverDestroyed() = default;
 97 
 98     template&lt;typename... Args&gt;
 99     void construct(Args&amp;&amp;... args)
100     {
101         ASSERT(!m_isConstructed);
102 
<span class="line-modified">103 #if ASSERT_ENABLED</span>
104         m_isConstructed = true;
105 #endif
106 
107         MaybeRelax&lt;T&gt;(new (storagePointer()) T(std::forward&lt;Args&gt;(args)...));
108     }
109 
110     operator T&amp;() { return *storagePointer(); }
111     T&amp; get() { return *storagePointer(); }
112 
113     T* operator-&gt;() { return storagePointer(); }
114 
115     operator const T&amp;() const { return *storagePointer(); }
116     const T&amp; get() const { return *storagePointer(); }
117 
118     const T* operator-&gt;() const { return storagePointer(); }
119 
<span class="line-modified">120 #if ASSERT_ENABLED</span>
121     bool isConstructed() const { return m_isConstructed; }
122 #endif
123 
124 private:
125     using PointerType = typename std::remove_const&lt;T&gt;::type*;
126 
127     PointerType storagePointer() const
128     {
129         ASSERT(m_isConstructed);
130         return const_cast&lt;PointerType&gt;(reinterpret_cast&lt;const T*&gt;(&amp;m_storage));
131     }
132 
133     template&lt;typename PtrType, bool ShouldRelax = std::is_base_of&lt;RefCountedBase, PtrType&gt;::value&gt; struct MaybeRelax {
134         explicit MaybeRelax(PtrType*) { }
135     };
136     template&lt;typename PtrType&gt; struct MaybeRelax&lt;PtrType, true&gt; {
137         explicit MaybeRelax(PtrType* ptr) { ptr-&gt;relaxAdoptionRequirement(); }
138     };
139 
<span class="line-modified">140 #if ASSERT_ENABLED</span>
141     // LazyNeverDestroyed objects are always static, so this variable is initialized to false.
142     // It must not be initialized dynamically; that would not be thread safe.
143     bool m_isConstructed;
144 #endif
145 
146     // FIXME: Investigate whether we should allocate a hunk of virtual memory
147     // and hand out chunks of it to NeverDestroyed instead, to reduce fragmentation.
148     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_storage;
149 };
150 
151 template&lt;typename T&gt; inline NeverDestroyed&lt;T&gt; makeNeverDestroyed(T&amp;&amp; argument)
152 {
153     return WTFMove(argument);
154 }
155 
156 } // namespace WTF;
157 
158 using WTF::LazyNeverDestroyed;
159 using WTF::NeverDestroyed;
160 using WTF::makeNeverDestroyed;
</pre>
</td>
</tr>
</table>
<center><a href="NaturalLoops.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
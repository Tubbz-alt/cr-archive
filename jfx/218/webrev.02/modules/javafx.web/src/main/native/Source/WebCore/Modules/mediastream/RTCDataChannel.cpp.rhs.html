<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCDataChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Google Inc. All rights reserved.
  3  * Copyright (C) 2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RTCDataChannel.h&quot;
 28 
 29 #if ENABLE(WEB_RTC)
 30 
 31 #include &quot;Blob.h&quot;
<a name="1" id="anc1"></a>
 32 #include &quot;EventNames.h&quot;
 33 #include &quot;MessageEvent.h&quot;
<a name="2" id="anc2"></a>
 34 #include &quot;ScriptExecutionContext.h&quot;
 35 #include &quot;SharedBuffer.h&quot;
<a name="3" id="anc3"></a>
 36 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 #include &lt;wtf/NeverDestroyed.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(RTCDataChannel);
 43 
 44 static const AtomString&amp; blobKeyword()
 45 {
 46     static NeverDestroyed&lt;AtomString&gt; blob(&quot;blob&quot;, AtomString::ConstructFromLiteral);
 47     return blob;
 48 }
 49 
 50 static const AtomString&amp; arraybufferKeyword()
 51 {
 52     static NeverDestroyed&lt;AtomString&gt; arraybuffer(&quot;arraybuffer&quot;, AtomString::ConstructFromLiteral);
 53     return arraybuffer;
 54 }
 55 
<a name="4" id="anc4"></a><span class="line-modified"> 56 Ref&lt;RTCDataChannel&gt; RTCDataChannel::create(Document&amp; document, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
 57 {
 58     ASSERT(handler);
<a name="5" id="anc5"></a><span class="line-modified"> 59     auto channel = adoptRef(*new RTCDataChannel(document, WTFMove(handler), WTFMove(label), WTFMove(options)));</span>
 60     channel-&gt;suspendIfNeeded();
 61     channel-&gt;m_handler-&gt;setClient(channel.get());
 62     channel-&gt;setPendingActivity(channel.get());
 63     return channel;
 64 }
 65 
<a name="6" id="anc6"></a><span class="line-modified"> 66 NetworkSendQueue RTCDataChannel::createMessageQueue(Document&amp; document, RTCDataChannel&amp; channel)</span>
<span class="line-modified"> 67 {</span>
<span class="line-added"> 68     return { document, [&amp;channel](const String&amp; data) {</span>
<span class="line-added"> 69         if (!channel.m_handler-&gt;sendStringData(data))</span>
<span class="line-added"> 70             channel.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Error sending string through RTCDataChannel.&quot;_s);</span>
<span class="line-added"> 71     }, [&amp;channel](auto* data, size_t length) {</span>
<span class="line-added"> 72         if (!channel.m_handler-&gt;sendRawData(data, length))</span>
<span class="line-added"> 73             channel.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Error sending binary data through RTCDataChannel.&quot;_s);</span>
<span class="line-added"> 74     }, [&amp;channel](int errorCode) {</span>
<span class="line-added"> 75         if (auto* context = channel.scriptExecutionContext())</span>
<span class="line-added"> 76             context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, makeString(&quot;Error &quot;, errorCode, &quot; in retrieving a blob data to be sent through RTCDataChannel.&quot;));</span>
<span class="line-added"> 77         return NetworkSendQueue::Continue::Yes;</span>
<span class="line-added"> 78     } };</span>
<span class="line-added"> 79 }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 RTCDataChannel::RTCDataChannel(Document&amp; document, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
<span class="line-added"> 82     : ActiveDOMObject(document)</span>
 83     , m_handler(WTFMove(handler))
<a name="7" id="anc7"></a>
 84     , m_label(WTFMove(label))
 85     , m_options(WTFMove(options))
<a name="8" id="anc8"></a><span class="line-added"> 86     , m_messageQueue(createMessageQueue(document, *this))</span>
 87 {
 88 }
 89 
 90 size_t RTCDataChannel::bufferedAmount() const
 91 {
 92     // FIXME: We should compute our own bufferedAmount and not count on m_handler which is made null at closing time.
 93     if (m_stopped)
 94         return 0;
 95     return m_handler-&gt;bufferedAmount();
 96 }
 97 
 98 const AtomString&amp; RTCDataChannel::binaryType() const
 99 {
100     switch (m_binaryType) {
101     case BinaryType::Blob:
102         return blobKeyword();
103     case BinaryType::ArrayBuffer:
104         return arraybufferKeyword();
105     }
106 
107     ASSERT_NOT_REACHED();
108     return emptyAtom();
109 }
110 
111 ExceptionOr&lt;void&gt; RTCDataChannel::setBinaryType(const AtomString&amp; binaryType)
112 {
113     if (binaryType == blobKeyword()) {
114         m_binaryType = BinaryType::Blob;
115         return { };
116     }
117     if (binaryType == arraybufferKeyword()) {
118         m_binaryType = BinaryType::ArrayBuffer;
119         return { };
120     }
121     return Exception { TypeMismatchError };
122 }
123 
124 ExceptionOr&lt;void&gt; RTCDataChannel::send(const String&amp; data)
125 {
126     if (m_readyState != RTCDataChannelState::Open)
127         return Exception { InvalidStateError };
128 
<a name="9" id="anc9"></a><span class="line-modified">129     m_messageQueue.enqueue(data);</span>




130     return { };
131 }
132 
<a name="10" id="anc10"></a><span class="line-modified">133 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBuffer&amp; data)</span>
134 {
135     if (m_readyState != RTCDataChannelState::Open)
136         return Exception { InvalidStateError };
137 
<a name="11" id="anc11"></a><span class="line-modified">138     m_messageQueue.enqueue(data, 0, data.byteLength());</span>







139     return { };
140 }
141 
<a name="12" id="anc12"></a>





142 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBufferView&amp; data)
143 {
<a name="13" id="anc13"></a><span class="line-modified">144     if (m_readyState != RTCDataChannelState::Open)</span>
<span class="line-added">145         return Exception { InvalidStateError };</span>
<span class="line-added">146 </span>
<span class="line-added">147     m_messageQueue.enqueue(*data.unsharedBuffer(), data.byteOffset(), data.byteLength());</span>
<span class="line-added">148     return { };</span>
149 }
150 
<a name="14" id="anc14"></a><span class="line-modified">151 ExceptionOr&lt;void&gt; RTCDataChannel::send(Blob&amp; blob)</span>
152 {
<a name="15" id="anc15"></a><span class="line-modified">153     if (m_readyState != RTCDataChannelState::Open)</span>
<span class="line-modified">154         return Exception { InvalidStateError };</span>
<span class="line-added">155 </span>
<span class="line-added">156     m_messageQueue.enqueue(blob);</span>
<span class="line-added">157     return { };</span>
158 }
159 
160 void RTCDataChannel::close()
161 {
162     if (m_stopped)
163         return;
164 
165     m_stopped = true;
166     m_readyState = RTCDataChannelState::Closed;
167 
<a name="16" id="anc16"></a><span class="line-added">168     m_messageQueue.clear();</span>
<span class="line-added">169 </span>
170     m_handler-&gt;close();
171     m_handler = nullptr;
172     unsetPendingActivity(*this);
173 }
174 
175 void RTCDataChannel::didChangeReadyState(RTCDataChannelState newState)
176 {
177     if (m_stopped || m_readyState == RTCDataChannelState::Closed || m_readyState == newState)
178         return;
179 
180     m_readyState = newState;
181 
182     switch (m_readyState) {
183     case RTCDataChannelState::Open:
184         scheduleDispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
185         break;
186     case RTCDataChannelState::Closed:
187         scheduleDispatchEvent(Event::create(eventNames().closeEvent, Event::CanBubble::No, Event::IsCancelable::No));
188         break;
189     default:
190         break;
191     }
192 }
193 
194 void RTCDataChannel::didReceiveStringData(const String&amp; text)
195 {
<a name="17" id="anc17"></a>


196     scheduleDispatchEvent(MessageEvent::create(text));
197 }
198 
199 void RTCDataChannel::didReceiveRawData(const char* data, size_t dataLength)
200 {
<a name="18" id="anc18"></a>


201     switch (m_binaryType) {
202     case BinaryType::Blob:
<a name="19" id="anc19"></a><span class="line-modified">203         scheduleDispatchEvent(MessageEvent::create(Blob::create(SharedBuffer::create(data, dataLength), emptyString()), { }));</span>
204         return;
205     case BinaryType::ArrayBuffer:
206         scheduleDispatchEvent(MessageEvent::create(ArrayBuffer::create(data, dataLength)));
207         return;
208     }
209     ASSERT_NOT_REACHED();
210 }
211 
212 void RTCDataChannel::didDetectError()
213 {
<a name="20" id="anc20"></a>


214     scheduleDispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
215 }
216 
217 void RTCDataChannel::bufferedAmountIsDecreasing(size_t amount)
218 {
<a name="21" id="anc21"></a>


219     if (amount &lt;= m_bufferedAmountLowThreshold)
220         scheduleDispatchEvent(Event::create(eventNames().bufferedamountlowEvent, Event::CanBubble::No, Event::IsCancelable::No));
221 }
222 
223 void RTCDataChannel::stop()
224 {
225     close();
226 }
227 
228 void RTCDataChannel::scheduleDispatchEvent(Ref&lt;Event&gt;&amp;&amp; event)
<a name="22" id="anc22"></a>







229 {
230     if (m_stopped)
231         return;
232 
<a name="23" id="anc23"></a><span class="line-modified">233     // https://w3c.github.io/webrtc-pc/#operation</span>
<span class="line-modified">234     queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(event));</span>



235 }
236 
237 } // namespace WebCore
238 
239 #endif // ENABLE(WEB_RTC)
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
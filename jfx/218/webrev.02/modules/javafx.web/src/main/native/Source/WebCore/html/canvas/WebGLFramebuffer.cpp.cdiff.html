<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLExtension.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLFramebuffer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,11 ***</span>
  #include &quot;config.h&quot;
  #include &quot;WebGLFramebuffer.h&quot;
  
  #if ENABLE(WEBGL)
  
<span class="line-modified">! #include &quot;Extensions3D.h&quot;</span>
  #include &quot;WebGLContextGroup.h&quot;
  #include &quot;WebGLDrawBuffers.h&quot;
  #include &quot;WebGLRenderingContextBase.h&quot;
  
  namespace WebCore {
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;config.h&quot;
  #include &quot;WebGLFramebuffer.h&quot;
  
  #if ENABLE(WEBGL)
  
<span class="line-modified">! #include &quot;ExtensionsGL.h&quot;</span>
  #include &quot;WebGLContextGroup.h&quot;
  #include &quot;WebGLDrawBuffers.h&quot;
  #include &quot;WebGLRenderingContextBase.h&quot;
  
  namespace WebCore {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,21 ***</span>
      public:
          static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLRenderbuffer*);
  
      private:
          WebGLRenderbufferAttachment(WebGLRenderbuffer*);
<span class="line-modified">!         GC3Dsizei getWidth() const override;</span>
<span class="line-modified">!         GC3Dsizei getHeight() const override;</span>
<span class="line-modified">!         GC3Denum getFormat() const override;</span>
          WebGLSharedObject* getObject() const override;
          bool isSharedObject(WebGLSharedObject*) const override;
          bool isValid() const override;
          bool isInitialized() const override;
          void setInitialized() override;
<span class="line-modified">!         void onDetached(GraphicsContext3D*) override;</span>
<span class="line-modified">!         void attach(GraphicsContext3D*, GC3Denum attachment) override;</span>
<span class="line-modified">!         void unattach(GraphicsContext3D*, GC3Denum attachment) override;</span>
  
          WebGLRenderbufferAttachment() { };
  
          RefPtr&lt;WebGLRenderbuffer&gt; m_renderbuffer;
      };
<span class="line-new-header">--- 41,21 ---</span>
      public:
          static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLRenderbuffer*);
  
      private:
          WebGLRenderbufferAttachment(WebGLRenderbuffer*);
<span class="line-modified">!         GCGLsizei getWidth() const override;</span>
<span class="line-modified">!         GCGLsizei getHeight() const override;</span>
<span class="line-modified">!         GCGLenum getFormat() const override;</span>
          WebGLSharedObject* getObject() const override;
          bool isSharedObject(WebGLSharedObject*) const override;
          bool isValid() const override;
          bool isInitialized() const override;
          void setInitialized() override;
<span class="line-modified">!         void onDetached(GraphicsContextGLOpenGL*) override;</span>
<span class="line-modified">!         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
<span class="line-modified">!         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
  
          WebGLRenderbufferAttachment() { };
  
          RefPtr&lt;WebGLRenderbuffer&gt; m_renderbuffer;
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,21 ***</span>
      WebGLRenderbufferAttachment::WebGLRenderbufferAttachment(WebGLRenderbuffer* renderbuffer)
          : m_renderbuffer(renderbuffer)
      {
      }
  
<span class="line-modified">!     GC3Dsizei WebGLRenderbufferAttachment::getWidth() const</span>
      {
          return m_renderbuffer-&gt;getWidth();
      }
  
<span class="line-modified">!     GC3Dsizei WebGLRenderbufferAttachment::getHeight() const</span>
      {
          return m_renderbuffer-&gt;getHeight();
      }
  
<span class="line-modified">!     GC3Denum WebGLRenderbufferAttachment::getFormat() const</span>
      {
          return m_renderbuffer-&gt;getInternalFormat();
      }
  
      WebGLSharedObject* WebGLRenderbufferAttachment::getObject() const
<span class="line-new-header">--- 68,21 ---</span>
      WebGLRenderbufferAttachment::WebGLRenderbufferAttachment(WebGLRenderbuffer* renderbuffer)
          : m_renderbuffer(renderbuffer)
      {
      }
  
<span class="line-modified">!     GCGLsizei WebGLRenderbufferAttachment::getWidth() const</span>
      {
          return m_renderbuffer-&gt;getWidth();
      }
  
<span class="line-modified">!     GCGLsizei WebGLRenderbufferAttachment::getHeight() const</span>
      {
          return m_renderbuffer-&gt;getHeight();
      }
  
<span class="line-modified">!     GCGLenum WebGLRenderbufferAttachment::getFormat() const</span>
      {
          return m_renderbuffer-&gt;getInternalFormat();
      }
  
      WebGLSharedObject* WebGLRenderbufferAttachment::getObject() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,78 ***</span>
      {
          if (m_renderbuffer-&gt;object())
              m_renderbuffer-&gt;setInitialized();
      }
  
<span class="line-modified">!     void WebGLRenderbufferAttachment::onDetached(GraphicsContext3D* context)</span>
      {
          m_renderbuffer-&gt;onDetached(context);
      }
  
<span class="line-modified">!     void WebGLRenderbufferAttachment::attach(GraphicsContext3D* context, GC3Denum attachment)</span>
      {
<span class="line-modified">!         Platform3DObject object = objectOrZero(m_renderbuffer.get());</span>
<span class="line-modified">!         context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::RENDERBUFFER, object);</span>
      }
  
<span class="line-modified">!     void WebGLRenderbufferAttachment::unattach(GraphicsContext3D* context, GC3Denum attachment)</span>
      {
<span class="line-modified">!         if (attachment == GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">!             context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::RENDERBUFFER, 0);</span>
<span class="line-modified">!             context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::RENDERBUFFER, 0);</span>
          } else
<span class="line-modified">!             context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::RENDERBUFFER, 0);</span>
      }
  
      class WebGLTextureAttachment : public WebGLFramebuffer::WebGLAttachment {
      public:
<span class="line-modified">!         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLTexture*, GC3Denum target, GC3Dint level);</span>
  
      private:
<span class="line-modified">!         WebGLTextureAttachment(WebGLTexture*, GC3Denum target, GC3Dint level);</span>
<span class="line-modified">!         GC3Dsizei getWidth() const override;</span>
<span class="line-modified">!         GC3Dsizei getHeight() const override;</span>
<span class="line-modified">!         GC3Denum getFormat() const override;</span>
          WebGLSharedObject* getObject() const override;
          bool isSharedObject(WebGLSharedObject*) const override;
          bool isValid() const override;
          bool isInitialized() const override;
          void setInitialized() override;
<span class="line-modified">!         void onDetached(GraphicsContext3D*) override;</span>
<span class="line-modified">!         void attach(GraphicsContext3D*, GC3Denum attachment) override;</span>
<span class="line-modified">!         void unattach(GraphicsContext3D*, GC3Denum attachment) override;</span>
  
          WebGLTextureAttachment() { };
  
          RefPtr&lt;WebGLTexture&gt; m_texture;
<span class="line-modified">!         GC3Denum m_target;</span>
<span class="line-modified">!         GC3Dint m_level;</span>
      };
  
<span class="line-modified">!     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLTextureAttachment::create(WebGLTexture* texture, GC3Denum target, GC3Dint level)</span>
      {
          return adoptRef(*new WebGLTextureAttachment(texture, target, level));
      }
  
<span class="line-modified">!     WebGLTextureAttachment::WebGLTextureAttachment(WebGLTexture* texture, GC3Denum target, GC3Dint level)</span>
          : m_texture(texture)
          , m_target(target)
          , m_level(level)
      {
      }
  
<span class="line-modified">!     GC3Dsizei WebGLTextureAttachment::getWidth() const</span>
      {
          return m_texture-&gt;getWidth(m_target, m_level);
      }
  
<span class="line-modified">!     GC3Dsizei WebGLTextureAttachment::getHeight() const</span>
      {
          return m_texture-&gt;getHeight(m_target, m_level);
      }
  
<span class="line-modified">!     GC3Denum WebGLTextureAttachment::getFormat() const</span>
      {
          return m_texture-&gt;getInternalFormat(m_target, m_level);
      }
  
      WebGLSharedObject* WebGLTextureAttachment::getObject() const
<span class="line-new-header">--- 109,80 ---</span>
      {
          if (m_renderbuffer-&gt;object())
              m_renderbuffer-&gt;setInitialized();
      }
  
<span class="line-modified">!     void WebGLRenderbufferAttachment::onDetached(GraphicsContextGLOpenGL* context)</span>
      {
          m_renderbuffer-&gt;onDetached(context);
      }
  
<span class="line-modified">!     void WebGLRenderbufferAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
      {
<span class="line-modified">!         PlatformGLObject object = objectOrZero(m_renderbuffer.get());</span>
<span class="line-modified">!         context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, object);</span>
      }
  
<span class="line-modified">!     void WebGLRenderbufferAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
      {
<span class="line-modified">! #if !USE(ANGLE)</span>
<span class="line-modified">!         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">!             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);</span>
<span class="line-added">+             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);</span>
          } else
<span class="line-modified">! #endif</span>
<span class="line-added">+             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, 0);</span>
      }
  
      class WebGLTextureAttachment : public WebGLFramebuffer::WebGLAttachment {
      public:
<span class="line-modified">!         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLTexture*, GCGLenum target, GCGLint level);</span>
  
      private:
<span class="line-modified">!         WebGLTextureAttachment(WebGLTexture*, GCGLenum target, GCGLint level);</span>
<span class="line-modified">!         GCGLsizei getWidth() const override;</span>
<span class="line-modified">!         GCGLsizei getHeight() const override;</span>
<span class="line-modified">!         GCGLenum getFormat() const override;</span>
          WebGLSharedObject* getObject() const override;
          bool isSharedObject(WebGLSharedObject*) const override;
          bool isValid() const override;
          bool isInitialized() const override;
          void setInitialized() override;
<span class="line-modified">!         void onDetached(GraphicsContextGLOpenGL*) override;</span>
<span class="line-modified">!         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
<span class="line-modified">!         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
  
          WebGLTextureAttachment() { };
  
          RefPtr&lt;WebGLTexture&gt; m_texture;
<span class="line-modified">!         GCGLenum m_target;</span>
<span class="line-modified">!         GCGLint m_level;</span>
      };
  
<span class="line-modified">!     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLTextureAttachment::create(WebGLTexture* texture, GCGLenum target, GCGLint level)</span>
      {
          return adoptRef(*new WebGLTextureAttachment(texture, target, level));
      }
  
<span class="line-modified">!     WebGLTextureAttachment::WebGLTextureAttachment(WebGLTexture* texture, GCGLenum target, GCGLint level)</span>
          : m_texture(texture)
          , m_target(target)
          , m_level(level)
      {
      }
  
<span class="line-modified">!     GCGLsizei WebGLTextureAttachment::getWidth() const</span>
      {
          return m_texture-&gt;getWidth(m_target, m_level);
      }
  
<span class="line-modified">!     GCGLsizei WebGLTextureAttachment::getHeight() const</span>
      {
          return m_texture-&gt;getHeight(m_target, m_level);
      }
  
<span class="line-modified">!     GCGLenum WebGLTextureAttachment::getFormat() const</span>
      {
          return m_texture-&gt;getInternalFormat(m_target, m_level);
      }
  
      WebGLSharedObject* WebGLTextureAttachment::getObject() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,48 ***</span>
      void WebGLTextureAttachment::setInitialized()
      {
          // Textures are assumed to be initialized.
      }
  
<span class="line-modified">!     void WebGLTextureAttachment::onDetached(GraphicsContext3D* context)</span>
      {
          m_texture-&gt;onDetached(context);
      }
  
<span class="line-modified">!     void WebGLTextureAttachment::attach(GraphicsContext3D* context, GC3Denum attachment)</span>
      {
<span class="line-modified">!         Platform3DObject object = objectOrZero(m_texture.get());</span>
<span class="line-modified">!         context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, attachment, m_target, object, m_level);</span>
      }
  
<span class="line-modified">!     void WebGLTextureAttachment::unattach(GraphicsContext3D* context, GC3Denum attachment)</span>
      {
<span class="line-modified">!         if (attachment == GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, m_target, 0, m_level);</span>
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, m_target, 0, m_level);</span>
          } else
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, attachment, m_target, 0, m_level);</span>
      }
  
<span class="line-modified">!     bool isAttachmentComplete(WebGLFramebuffer::WebGLAttachment* attachedObject, GC3Denum attachment, const char** reason)</span>
      {
          ASSERT(attachedObject &amp;&amp; attachedObject-&gt;isValid());
          ASSERT(reason);
<span class="line-modified">!         GC3Denum format = attachedObject-&gt;getFormat();</span>
<span class="line-modified">!         unsigned need = GraphicsContext3D::getClearBitsByAttachmentType(attachment);</span>
<span class="line-modified">!         unsigned have = GraphicsContext3D::getClearBitsByFormat(format);</span>
  
          if ((need &amp; have) != need) {
              *reason = &quot;attachment type is not correct for attachment&quot;;
              return false;
          }
          if (!attachedObject-&gt;getWidth() || !attachedObject-&gt;getHeight()) {
              *reason = &quot;attachment has a 0 dimension&quot;;
              return false;
          }
<span class="line-modified">!         if ((attachment == GraphicsContext3D::DEPTH_ATTACHMENT || attachment == GraphicsContext3D::STENCIL_ATTACHMENT)</span>
<span class="line-modified">!             &amp;&amp; format == GraphicsContext3D::DEPTH_STENCIL) {</span>
            *reason = &quot;attachment DEPTH_STENCIL not allowed on DEPTH or STENCIL attachment&quot;;
            return false;
          }
          return true;
      }
<span class="line-new-header">--- 209,50 ---</span>
      void WebGLTextureAttachment::setInitialized()
      {
          // Textures are assumed to be initialized.
      }
  
<span class="line-modified">!     void WebGLTextureAttachment::onDetached(GraphicsContextGLOpenGL* context)</span>
      {
          m_texture-&gt;onDetached(context);
      }
  
<span class="line-modified">!     void WebGLTextureAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
      {
<span class="line-modified">!         PlatformGLObject object = objectOrZero(m_texture.get());</span>
<span class="line-modified">!         context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, object, m_level);</span>
      }
  
<span class="line-modified">!     void WebGLTextureAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
      {
<span class="line-modified">! #if !USE(ANGLE)</span>
<span class="line-modified">!         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, m_target, 0, m_level);</span>
<span class="line-added">+             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, m_target, 0, m_level);</span>
          } else
<span class="line-modified">! #endif</span>
<span class="line-added">+             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, 0, m_level);</span>
      }
  
<span class="line-modified">!     bool isAttachmentComplete(WebGLFramebuffer::WebGLAttachment* attachedObject, GCGLenum attachment, const char** reason)</span>
      {
          ASSERT(attachedObject &amp;&amp; attachedObject-&gt;isValid());
          ASSERT(reason);
<span class="line-modified">!         GCGLenum format = attachedObject-&gt;getFormat();</span>
<span class="line-modified">!         unsigned need = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachment);</span>
<span class="line-modified">!         unsigned have = GraphicsContextGLOpenGL::getClearBitsByFormat(format);</span>
  
          if ((need &amp; have) != need) {
              *reason = &quot;attachment type is not correct for attachment&quot;;
              return false;
          }
          if (!attachedObject-&gt;getWidth() || !attachedObject-&gt;getHeight()) {
              *reason = &quot;attachment has a 0 dimension&quot;;
              return false;
          }
<span class="line-modified">!         if ((attachment == GraphicsContextGL::DEPTH_ATTACHMENT || attachment == GraphicsContextGL::STENCIL_ATTACHMENT)</span>
<span class="line-modified">!             &amp;&amp; format == GraphicsContextGL::DEPTH_STENCIL) {</span>
            *reason = &quot;attachment DEPTH_STENCIL not allowed on DEPTH or STENCIL attachment&quot;;
            return false;
          }
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,19 ***</span>
  
  WebGLFramebuffer::WebGLFramebuffer(WebGLRenderingContextBase&amp; ctx)
      : WebGLContextObject(ctx)
      , m_hasEverBeenBound(false)
  {
<span class="line-modified">!     setObject(ctx.graphicsContext3D()-&gt;createFramebuffer());</span>
  }
  
  WebGLFramebuffer::~WebGLFramebuffer()
  {
      deleteObject(0);
  }
  
<span class="line-modified">! void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GC3Denum attachment, GC3Denum texTarget, WebGLTexture* texture, GC3Dint level)</span>
  {
      ASSERT(isBound());
      removeAttachmentFromBoundFramebuffer(attachment);
      if (!object())
          return;
<span class="line-new-header">--- 270,19 ---</span>
  
  WebGLFramebuffer::WebGLFramebuffer(WebGLRenderingContextBase&amp; ctx)
      : WebGLContextObject(ctx)
      , m_hasEverBeenBound(false)
  {
<span class="line-modified">!     setObject(ctx.graphicsContextGL()-&gt;createFramebuffer());</span>
  }
  
  WebGLFramebuffer::~WebGLFramebuffer()
  {
      deleteObject(0);
  }
  
<span class="line-modified">! void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, GCGLenum texTarget, WebGLTexture* texture, GCGLint level)</span>
  {
      ASSERT(isBound());
      removeAttachmentFromBoundFramebuffer(attachment);
      if (!object())
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,11 ***</span>
          drawBuffersIfNecessary(false);
          texture-&gt;onAttached();
      }
  }
  
<span class="line-modified">! void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GC3Denum attachment, WebGLRenderbuffer* renderbuffer)</span>
  {
      ASSERT(isBound());
      removeAttachmentFromBoundFramebuffer(attachment);
      if (!object())
          return;
<span class="line-new-header">--- 291,11 ---</span>
          drawBuffersIfNecessary(false);
          texture-&gt;onAttached();
      }
  }
  
<span class="line-modified">! void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, WebGLRenderbuffer* renderbuffer)</span>
  {
      ASSERT(isBound());
      removeAttachmentFromBoundFramebuffer(attachment);
      if (!object())
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,55 ***</span>
          drawBuffersIfNecessary(false);
          renderbuffer-&gt;onAttached();
      }
  }
  
<span class="line-modified">! void WebGLFramebuffer::attach(GC3Denum attachment, GC3Denum attachmentPoint)</span>
  {
      ASSERT(isBound());
      RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
      if (attachmentObject)
<span class="line-modified">!         attachmentObject-&gt;attach(context()-&gt;graphicsContext3D(), attachmentPoint);</span>
  }
  
<span class="line-modified">! WebGLSharedObject* WebGLFramebuffer::getAttachmentObject(GC3Denum attachment) const</span>
  {
      if (!object())
          return 0;
      RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
      return attachmentObject ? attachmentObject-&gt;getObject() : 0;
  }
  
<span class="line-modified">! WebGLFramebuffer::WebGLAttachment* WebGLFramebuffer::getAttachment(GC3Denum attachment) const</span>
  {
      const AttachmentMap::const_iterator it = m_attachments.find(attachment);
      return (it != m_attachments.end()) ? it-&gt;value.get() : 0;
  }
  
<span class="line-modified">! void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(GC3Denum attachment)</span>
  {
      ASSERT(isBound());
      if (!object())
          return;
  
      RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
      if (attachmentObject) {
<span class="line-modified">!         attachmentObject-&gt;onDetached(context()-&gt;graphicsContext3D());</span>
          m_attachments.remove(attachment);
          drawBuffersIfNecessary(false);
          switch (attachment) {
<span class="line-modified">!         case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="line-modified">!             attach(GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::DEPTH_ATTACHMENT);</span>
<span class="line-modified">!             attach(GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::STENCIL_ATTACHMENT);</span>
              break;
<span class="line-modified">!         case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
<span class="line-modified">!             attach(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT, GraphicsContext3D::DEPTH_ATTACHMENT);</span>
              break;
<span class="line-modified">!         case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
<span class="line-modified">!             attach(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT, GraphicsContext3D::STENCIL_ATTACHMENT);</span>
              break;
          }
      }
  }
  
  void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(WebGLSharedObject* attachment)
  {
<span class="line-new-header">--- 304,57 ---</span>
          drawBuffersIfNecessary(false);
          renderbuffer-&gt;onAttached();
      }
  }
  
<span class="line-modified">! void WebGLFramebuffer::attach(GCGLenum attachment, GCGLenum attachmentPoint)</span>
  {
      ASSERT(isBound());
      RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
      if (attachmentObject)
<span class="line-modified">!         attachmentObject-&gt;attach(context()-&gt;graphicsContextGL(), attachmentPoint);</span>
  }
  
<span class="line-modified">! WebGLSharedObject* WebGLFramebuffer::getAttachmentObject(GCGLenum attachment) const</span>
  {
      if (!object())
          return 0;
      RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
      return attachmentObject ? attachmentObject-&gt;getObject() : 0;
  }
  
<span class="line-modified">! WebGLFramebuffer::WebGLAttachment* WebGLFramebuffer::getAttachment(GCGLenum attachment) const</span>
  {
      const AttachmentMap::const_iterator it = m_attachments.find(attachment);
      return (it != m_attachments.end()) ? it-&gt;value.get() : 0;
  }
  
<span class="line-modified">! void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(GCGLenum attachment)</span>
  {
      ASSERT(isBound());
      if (!object())
          return;
  
      RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
      if (attachmentObject) {
<span class="line-modified">!         attachmentObject-&gt;onDetached(context()-&gt;graphicsContextGL());</span>
          m_attachments.remove(attachment);
          drawBuffersIfNecessary(false);
<span class="line-added">+ #if !USE(ANGLE)</span>
          switch (attachment) {
<span class="line-modified">!         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="line-modified">!             attach(GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);</span>
<span class="line-modified">!             attach(GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);</span>
              break;
<span class="line-modified">!         case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
<span class="line-modified">!             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);</span>
              break;
<span class="line-modified">!         case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
<span class="line-modified">!             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);</span>
              break;
          }
<span class="line-added">+ #endif</span>
      }
  }
  
  void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(WebGLSharedObject* attachment)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 362,191 ***</span>
      do {
          checkMore = false;
          for (auto&amp; entry : m_attachments) {
              RefPtr&lt;WebGLAttachment&gt; attachmentObject = entry.value.get();
              if (attachmentObject-&gt;isSharedObject(attachment)) {
<span class="line-modified">!                 GC3Denum attachmentType = entry.key;</span>
<span class="line-modified">!                 attachmentObject-&gt;unattach(context()-&gt;graphicsContext3D(), attachmentType);</span>
                  removeAttachmentFromBoundFramebuffer(attachmentType);
                  checkMore = true;
                  break;
              }
          }
      } while (checkMore);
  }
  
<span class="line-modified">! GC3Dsizei WebGLFramebuffer::getColorBufferWidth() const</span>
  {
      if (!object())
          return 0;
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::COLOR_ATTACHMENT0);</span>
      if (!attachment)
          return 0;
  
      return attachment-&gt;getWidth();
  }
  
<span class="line-modified">! GC3Dsizei WebGLFramebuffer::getColorBufferHeight() const</span>
  {
      if (!object())
          return 0;
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::COLOR_ATTACHMENT0);</span>
      if (!attachment)
          return 0;
  
      return attachment-&gt;getHeight();
  }
  
<span class="line-modified">! GC3Denum WebGLFramebuffer::getColorBufferFormat() const</span>
  {
      if (!object())
          return 0;
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::COLOR_ATTACHMENT0);</span>
      if (!attachment)
          return 0;
      return attachment-&gt;getFormat();
  }
  
<span class="line-modified">! GC3Denum WebGLFramebuffer::checkStatus(const char** reason) const</span>
  {
      unsigned int count = 0;
<span class="line-modified">!     GC3Dsizei width = 0, height = 0;</span>
      bool haveDepth = false;
      bool haveStencil = false;
      bool haveDepthStencil = false;
      for (auto&amp; entry : m_attachments) {
          RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
          if (!isAttachmentComplete(attachment.get(), entry.key, reason))
<span class="line-modified">!             return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
          if (!attachment-&gt;isValid()) {
              *reason = &quot;attachment is not valid&quot;;
<span class="line-modified">!             return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;</span>
          }
<span class="line-modified">!         GC3Denum attachmentFormat = attachment-&gt;getFormat();</span>
  
          // Attaching an SRGB_EXT format attachment to a framebuffer is invalid.
<span class="line-modified">!         if (attachmentFormat == Extensions3D::SRGB_EXT)</span>
              attachmentFormat = 0;
  
          if (!attachmentFormat) {
              *reason = &quot;attachment is an unsupported format&quot;;
<span class="line-modified">!             return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
          }
          switch (entry.key) {
<span class="line-modified">!         case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
              haveDepth = true;
              break;
<span class="line-modified">!         case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
              haveStencil = true;
              break;
<span class="line-modified">!         case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
              haveDepthStencil = true;
              break;
          }
          if (!count) {
              width = attachment-&gt;getWidth();
              height = attachment-&gt;getHeight();
          } else {
              if (width != attachment-&gt;getWidth() || height != attachment-&gt;getHeight()) {
                  *reason = &quot;attachments do not have the same dimensions&quot;;
<span class="line-modified">!                 return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_DIMENSIONS;</span>
              }
          }
          ++count;
      }
      if (!count) {
          *reason = &quot;no attachments&quot;;
<span class="line-modified">!         return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;</span>
      }
      if (!width || !height) {
          *reason = &quot;framebuffer has a 0 dimension&quot;;
<span class="line-modified">!         return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
      }
      // WebGL specific: no conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments.
      if ((haveDepthStencil &amp;&amp; (haveDepth || haveStencil)) || (haveDepth &amp;&amp; haveStencil)) {
          *reason = &quot;conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments&quot;;
<span class="line-modified">!         return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;</span>
      }
<span class="line-modified">!     return GraphicsContext3D::FRAMEBUFFER_COMPLETE;</span>
  }
  
<span class="line-modified">! bool WebGLFramebuffer::onAccess(GraphicsContext3D* context3d, const char** reason)</span>
  {
<span class="line-modified">!     if (checkStatus(reason) != GraphicsContext3D::FRAMEBUFFER_COMPLETE)</span>
          return false;
      return initializeAttachments(context3d, reason);
  }
  
  bool WebGLFramebuffer::hasStencilBuffer() const
  {
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::STENCIL_ATTACHMENT);</span>
      if (!attachment)
<span class="line-modified">!         attachment = getAttachment(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT);</span>
      return attachment &amp;&amp; attachment-&gt;isValid();
  }
  
<span class="line-modified">! void WebGLFramebuffer::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)</span>
  {
      for (auto&amp; attachment : m_attachments.values())
          attachment-&gt;onDetached(context3d);
  
      context3d-&gt;deleteFramebuffer(object);
  }
  
<span class="line-modified">! bool WebGLFramebuffer::initializeAttachments(GraphicsContext3D* g3d, const char** reason)</span>
  {
      ASSERT(object());
<span class="line-modified">!     GC3Dbitfield mask = 0;</span>
  
      for (auto&amp; entry : m_attachments) {
<span class="line-modified">!         GC3Denum attachmentType = entry.key;</span>
          RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
          if (!attachment-&gt;isInitialized())
<span class="line-modified">!            mask |= GraphicsContext3D::getClearBitsByAttachmentType(attachmentType);</span>
      }
      if (!mask)
          return true;
  
      // We only clear un-initialized renderbuffers when they are ready to be
      // read, i.e., when the framebuffer is complete.
<span class="line-modified">!     if (g3d-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
          *reason = &quot;framebuffer not complete&quot;;
          return false;
      }
  
<span class="line-modified">!     bool initColor = mask &amp; GraphicsContext3D::COLOR_BUFFER_BIT;</span>
<span class="line-modified">!     bool initDepth = mask &amp; GraphicsContext3D::DEPTH_BUFFER_BIT;</span>
<span class="line-modified">!     bool initStencil = mask &amp; GraphicsContext3D::STENCIL_BUFFER_BIT;</span>
  
<span class="line-modified">!     GC3Dfloat colorClearValue[] = {0, 0, 0, 0}, depthClearValue = 0;</span>
<span class="line-modified">!     GC3Dint stencilClearValue = 0;</span>
<span class="line-modified">!     GC3Dboolean colorMask[] = {0, 0, 0, 0}, depthMask = 0;</span>
<span class="line-modified">!     GC3Duint stencilMask = 0xffffffff;</span>
<span class="line-modified">!     GC3Dboolean isScissorEnabled = 0;</span>
<span class="line-modified">!     GC3Dboolean isDitherEnabled = 0;</span>
      if (initColor) {
<span class="line-modified">!         g3d-&gt;getFloatv(GraphicsContext3D::COLOR_CLEAR_VALUE, colorClearValue);</span>
<span class="line-modified">!         g3d-&gt;getBooleanv(GraphicsContext3D::COLOR_WRITEMASK, colorMask);</span>
          g3d-&gt;clearColor(0, 0, 0, 0);
          g3d-&gt;colorMask(true, true, true, true);
      }
      if (initDepth) {
<span class="line-modified">!         g3d-&gt;getFloatv(GraphicsContext3D::DEPTH_CLEAR_VALUE, &amp;depthClearValue);</span>
<span class="line-modified">!         g3d-&gt;getBooleanv(GraphicsContext3D::DEPTH_WRITEMASK, &amp;depthMask);</span>
          g3d-&gt;clearDepth(1.0f);
          g3d-&gt;depthMask(true);
      }
      if (initStencil) {
<span class="line-modified">!         g3d-&gt;getIntegerv(GraphicsContext3D::STENCIL_CLEAR_VALUE, &amp;stencilClearValue);</span>
<span class="line-modified">!         g3d-&gt;getIntegerv(GraphicsContext3D::STENCIL_WRITEMASK, reinterpret_cast&lt;GC3Dint*&gt;(&amp;stencilMask));</span>
          g3d-&gt;clearStencil(0);
          g3d-&gt;stencilMask(0xffffffff);
      }
<span class="line-modified">!     isScissorEnabled = g3d-&gt;isEnabled(GraphicsContext3D::SCISSOR_TEST);</span>
<span class="line-modified">!     g3d-&gt;disable(GraphicsContext3D::SCISSOR_TEST);</span>
<span class="line-modified">!     isDitherEnabled = g3d-&gt;isEnabled(GraphicsContext3D::DITHER);</span>
<span class="line-modified">!     g3d-&gt;disable(GraphicsContext3D::DITHER);</span>
  
      g3d-&gt;clear(mask);
  
      if (initColor) {
          g3d-&gt;clearColor(colorClearValue[0], colorClearValue[1], colorClearValue[2], colorClearValue[3]);
<span class="line-new-header">--- 368,191 ---</span>
      do {
          checkMore = false;
          for (auto&amp; entry : m_attachments) {
              RefPtr&lt;WebGLAttachment&gt; attachmentObject = entry.value.get();
              if (attachmentObject-&gt;isSharedObject(attachment)) {
<span class="line-modified">!                 GCGLenum attachmentType = entry.key;</span>
<span class="line-modified">!                 attachmentObject-&gt;unattach(context()-&gt;graphicsContextGL(), attachmentType);</span>
                  removeAttachmentFromBoundFramebuffer(attachmentType);
                  checkMore = true;
                  break;
              }
          }
      } while (checkMore);
  }
  
<span class="line-modified">! GCGLsizei WebGLFramebuffer::getColorBufferWidth() const</span>
  {
      if (!object())
          return 0;
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
      if (!attachment)
          return 0;
  
      return attachment-&gt;getWidth();
  }
  
<span class="line-modified">! GCGLsizei WebGLFramebuffer::getColorBufferHeight() const</span>
  {
      if (!object())
          return 0;
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
      if (!attachment)
          return 0;
  
      return attachment-&gt;getHeight();
  }
  
<span class="line-modified">! GCGLenum WebGLFramebuffer::getColorBufferFormat() const</span>
  {
      if (!object())
          return 0;
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
      if (!attachment)
          return 0;
      return attachment-&gt;getFormat();
  }
  
<span class="line-modified">! GCGLenum WebGLFramebuffer::checkStatus(const char** reason) const</span>
  {
      unsigned int count = 0;
<span class="line-modified">!     GCGLsizei width = 0, height = 0;</span>
      bool haveDepth = false;
      bool haveStencil = false;
      bool haveDepthStencil = false;
      for (auto&amp; entry : m_attachments) {
          RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
          if (!isAttachmentComplete(attachment.get(), entry.key, reason))
<span class="line-modified">!             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
          if (!attachment-&gt;isValid()) {
              *reason = &quot;attachment is not valid&quot;;
<span class="line-modified">!             return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
          }
<span class="line-modified">!         GCGLenum attachmentFormat = attachment-&gt;getFormat();</span>
  
          // Attaching an SRGB_EXT format attachment to a framebuffer is invalid.
<span class="line-modified">!         if (attachmentFormat == ExtensionsGL::SRGB_EXT)</span>
              attachmentFormat = 0;
  
          if (!attachmentFormat) {
              *reason = &quot;attachment is an unsupported format&quot;;
<span class="line-modified">!             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
          }
          switch (entry.key) {
<span class="line-modified">!         case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
              haveDepth = true;
              break;
<span class="line-modified">!         case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
              haveStencil = true;
              break;
<span class="line-modified">!         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
              haveDepthStencil = true;
              break;
          }
          if (!count) {
              width = attachment-&gt;getWidth();
              height = attachment-&gt;getHeight();
          } else {
              if (width != attachment-&gt;getWidth() || height != attachment-&gt;getHeight()) {
                  *reason = &quot;attachments do not have the same dimensions&quot;;
<span class="line-modified">!                 return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_DIMENSIONS;</span>
              }
          }
          ++count;
      }
      if (!count) {
          *reason = &quot;no attachments&quot;;
<span class="line-modified">!         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;</span>
      }
      if (!width || !height) {
          *reason = &quot;framebuffer has a 0 dimension&quot;;
<span class="line-modified">!         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
      }
      // WebGL specific: no conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments.
      if ((haveDepthStencil &amp;&amp; (haveDepth || haveStencil)) || (haveDepth &amp;&amp; haveStencil)) {
          *reason = &quot;conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments&quot;;
<span class="line-modified">!         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
      }
<span class="line-modified">!     return GraphicsContextGL::FRAMEBUFFER_COMPLETE;</span>
  }
  
<span class="line-modified">! bool WebGLFramebuffer::onAccess(GraphicsContextGLOpenGL* context3d, const char** reason)</span>
  {
<span class="line-modified">!     if (checkStatus(reason) != GraphicsContextGL::FRAMEBUFFER_COMPLETE)</span>
          return false;
      return initializeAttachments(context3d, reason);
  }
  
  bool WebGLFramebuffer::hasStencilBuffer() const
  {
<span class="line-modified">!     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::STENCIL_ATTACHMENT);</span>
      if (!attachment)
<span class="line-modified">!         attachment = getAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT);</span>
      return attachment &amp;&amp; attachment-&gt;isValid();
  }
  
<span class="line-modified">! void WebGLFramebuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
  {
      for (auto&amp; attachment : m_attachments.values())
          attachment-&gt;onDetached(context3d);
  
      context3d-&gt;deleteFramebuffer(object);
  }
  
<span class="line-modified">! bool WebGLFramebuffer::initializeAttachments(GraphicsContextGLOpenGL* g3d, const char** reason)</span>
  {
      ASSERT(object());
<span class="line-modified">!     GCGLbitfield mask = 0;</span>
  
      for (auto&amp; entry : m_attachments) {
<span class="line-modified">!         GCGLenum attachmentType = entry.key;</span>
          RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
          if (!attachment-&gt;isInitialized())
<span class="line-modified">!             mask |= GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);</span>
      }
      if (!mask)
          return true;
  
      // We only clear un-initialized renderbuffers when they are ready to be
      // read, i.e., when the framebuffer is complete.
<span class="line-modified">!     if (g3d-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
          *reason = &quot;framebuffer not complete&quot;;
          return false;
      }
  
<span class="line-modified">!     bool initColor = mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT;</span>
<span class="line-modified">!     bool initDepth = mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT;</span>
<span class="line-modified">!     bool initStencil = mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT;</span>
  
<span class="line-modified">!     GCGLfloat colorClearValue[] = {0, 0, 0, 0}, depthClearValue = 0;</span>
<span class="line-modified">!     GCGLint stencilClearValue = 0;</span>
<span class="line-modified">!     GCGLboolean colorMask[] = {0, 0, 0, 0}, depthMask = 0;</span>
<span class="line-modified">!     GCGLuint stencilMask = 0xffffffff;</span>
<span class="line-modified">!     GCGLboolean isScissorEnabled = 0;</span>
<span class="line-modified">!     GCGLboolean isDitherEnabled = 0;</span>
      if (initColor) {
<span class="line-modified">!         g3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, colorClearValue);</span>
<span class="line-modified">!         g3d-&gt;getBooleanv(GraphicsContextGL::COLOR_WRITEMASK, colorMask);</span>
          g3d-&gt;clearColor(0, 0, 0, 0);
          g3d-&gt;colorMask(true, true, true, true);
      }
      if (initDepth) {
<span class="line-modified">!         g3d-&gt;getFloatv(GraphicsContextGL::DEPTH_CLEAR_VALUE, &amp;depthClearValue);</span>
<span class="line-modified">!         g3d-&gt;getBooleanv(GraphicsContextGL::DEPTH_WRITEMASK, &amp;depthMask);</span>
          g3d-&gt;clearDepth(1.0f);
          g3d-&gt;depthMask(true);
      }
      if (initStencil) {
<span class="line-modified">!         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_CLEAR_VALUE, &amp;stencilClearValue);</span>
<span class="line-modified">!         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_WRITEMASK, reinterpret_cast&lt;GCGLint*&gt;(&amp;stencilMask));</span>
          g3d-&gt;clearStencil(0);
          g3d-&gt;stencilMask(0xffffffff);
      }
<span class="line-modified">!     isScissorEnabled = g3d-&gt;isEnabled(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified">!     g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified">!     isDitherEnabled = g3d-&gt;isEnabled(GraphicsContextGL::DITHER);</span>
<span class="line-modified">!     g3d-&gt;disable(GraphicsContextGL::DITHER);</span>
  
      g3d-&gt;clear(mask);
  
      if (initColor) {
          g3d-&gt;clearColor(colorClearValue[0], colorClearValue[1], colorClearValue[2], colorClearValue[3]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,22 ***</span>
      if (initStencil) {
          g3d-&gt;clearStencil(stencilClearValue);
          g3d-&gt;stencilMask(stencilMask);
      }
      if (isScissorEnabled)
<span class="line-modified">!         g3d-&gt;enable(GraphicsContext3D::SCISSOR_TEST);</span>
      else
<span class="line-modified">!         g3d-&gt;disable(GraphicsContext3D::SCISSOR_TEST);</span>
      if (isDitherEnabled)
<span class="line-modified">!         g3d-&gt;enable(GraphicsContext3D::DITHER);</span>
      else
<span class="line-modified">!         g3d-&gt;disable(GraphicsContext3D::DITHER);</span>
  
      for (AttachmentMap::iterator it = m_attachments.begin(); it != m_attachments.end(); ++it) {
<span class="line-modified">!         GC3Denum attachmentType = it-&gt;key;</span>
          auto attachment = it-&gt;value;
<span class="line-modified">!         GC3Dbitfield bits = GraphicsContext3D::getClearBitsByAttachmentType(attachmentType);</span>
          if (bits &amp; mask)
              attachment-&gt;setInitialized();
      }
      return true;
  }
<span class="line-new-header">--- 565,22 ---</span>
      if (initStencil) {
          g3d-&gt;clearStencil(stencilClearValue);
          g3d-&gt;stencilMask(stencilMask);
      }
      if (isScissorEnabled)
<span class="line-modified">!         g3d-&gt;enable(GraphicsContextGL::SCISSOR_TEST);</span>
      else
<span class="line-modified">!         g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
      if (isDitherEnabled)
<span class="line-modified">!         g3d-&gt;enable(GraphicsContextGL::DITHER);</span>
      else
<span class="line-modified">!         g3d-&gt;disable(GraphicsContextGL::DITHER);</span>
  
      for (AttachmentMap::iterator it = m_attachments.begin(); it != m_attachments.end(); ++it) {
<span class="line-modified">!         GCGLenum attachmentType = it-&gt;key;</span>
          auto attachment = it-&gt;value;
<span class="line-modified">!         GCGLbitfield bits = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);</span>
          if (bits &amp; mask)
              attachment-&gt;setInitialized();
      }
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 582,16 ***</span>
  bool WebGLFramebuffer::isBound() const
  {
      return (context()-&gt;m_framebufferBinding.get() == this) || (context()-&gt;m_readFramebufferBinding.get() == this);
  }
  
<span class="line-modified">! void WebGLFramebuffer::drawBuffers(const Vector&lt;GC3Denum&gt;&amp; bufs)</span>
  {
      m_drawBuffers = bufs;
      m_filteredDrawBuffers.resize(m_drawBuffers.size());
      for (auto&amp; buffer : m_filteredDrawBuffers)
<span class="line-modified">!         buffer = GraphicsContext3D::NONE;</span>
      drawBuffersIfNecessary(true);
  }
  
  void WebGLFramebuffer::drawBuffersIfNecessary(bool force)
  {
<span class="line-new-header">--- 588,16 ---</span>
  bool WebGLFramebuffer::isBound() const
  {
      return (context()-&gt;m_framebufferBinding.get() == this) || (context()-&gt;m_readFramebufferBinding.get() == this);
  }
  
<span class="line-modified">! void WebGLFramebuffer::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; bufs)</span>
  {
      m_drawBuffers = bufs;
      m_filteredDrawBuffers.resize(m_drawBuffers.size());
      for (auto&amp; buffer : m_filteredDrawBuffers)
<span class="line-modified">!         buffer = GraphicsContextGL::NONE;</span>
      drawBuffersIfNecessary(true);
  }
  
  void WebGLFramebuffer::drawBuffersIfNecessary(bool force)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 603,37 ***</span>
          return;
  #endif
      bool reset = force;
      // This filtering works around graphics driver bugs on Mac OS X.
      for (size_t i = 0; i &lt; m_drawBuffers.size(); ++i) {
<span class="line-modified">!         if (m_drawBuffers[i] != GraphicsContext3D::NONE &amp;&amp; getAttachment(m_drawBuffers[i])) {</span>
              if (m_filteredDrawBuffers[i] != m_drawBuffers[i]) {
                  m_filteredDrawBuffers[i] = m_drawBuffers[i];
                  reset = true;
              }
          } else {
<span class="line-modified">!             if (m_filteredDrawBuffers[i] != GraphicsContext3D::NONE) {</span>
<span class="line-modified">!                 m_filteredDrawBuffers[i] = GraphicsContext3D::NONE;</span>
                  reset = true;
              }
          }
      }
      if (reset) {
<span class="line-modified">!         context()-&gt;graphicsContext3D()-&gt;getExtensions().drawBuffersEXT(</span>
              m_filteredDrawBuffers.size(), m_filteredDrawBuffers.data());
      }
  }
  
<span class="line-modified">! GC3Denum WebGLFramebuffer::getDrawBuffer(GC3Denum drawBuffer)</span>
  {
<span class="line-modified">!     int index = static_cast&lt;int&gt;(drawBuffer - Extensions3D::DRAW_BUFFER0_EXT);</span>
      ASSERT(index &gt;= 0);
      if (index &lt; static_cast&lt;int&gt;(m_drawBuffers.size()))
          return m_drawBuffers[index];
<span class="line-modified">!     if (drawBuffer == Extensions3D::DRAW_BUFFER0_EXT)</span>
<span class="line-modified">!         return GraphicsContext3D::COLOR_ATTACHMENT0;</span>
<span class="line-modified">!     return GraphicsContext3D::NONE;</span>
  }
  
  }
  
  #endif // ENABLE(WEBGL)
<span class="line-new-header">--- 609,37 ---</span>
          return;
  #endif
      bool reset = force;
      // This filtering works around graphics driver bugs on Mac OS X.
      for (size_t i = 0; i &lt; m_drawBuffers.size(); ++i) {
<span class="line-modified">!         if (m_drawBuffers[i] != GraphicsContextGL::NONE &amp;&amp; getAttachment(m_drawBuffers[i])) {</span>
              if (m_filteredDrawBuffers[i] != m_drawBuffers[i]) {
                  m_filteredDrawBuffers[i] = m_drawBuffers[i];
                  reset = true;
              }
          } else {
<span class="line-modified">!             if (m_filteredDrawBuffers[i] != GraphicsContextGL::NONE) {</span>
<span class="line-modified">!                 m_filteredDrawBuffers[i] = GraphicsContextGL::NONE;</span>
                  reset = true;
              }
          }
      }
      if (reset) {
<span class="line-modified">!         context()-&gt;graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(</span>
              m_filteredDrawBuffers.size(), m_filteredDrawBuffers.data());
      }
  }
  
<span class="line-modified">! GCGLenum WebGLFramebuffer::getDrawBuffer(GCGLenum drawBuffer)</span>
  {
<span class="line-modified">!     int index = static_cast&lt;int&gt;(drawBuffer - ExtensionsGL::DRAW_BUFFER0_EXT);</span>
      ASSERT(index &gt;= 0);
      if (index &lt; static_cast&lt;int&gt;(m_drawBuffers.size()))
          return m_drawBuffers[index];
<span class="line-modified">!     if (drawBuffer == ExtensionsGL::DRAW_BUFFER0_EXT)</span>
<span class="line-modified">!         return GraphicsContextGL::COLOR_ATTACHMENT0;</span>
<span class="line-modified">!     return GraphicsContextGL::NONE;</span>
  }
  
  }
  
  #endif // ENABLE(WEBGL)
</pre>
<center><a href="WebGLExtension.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLFramebuffer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
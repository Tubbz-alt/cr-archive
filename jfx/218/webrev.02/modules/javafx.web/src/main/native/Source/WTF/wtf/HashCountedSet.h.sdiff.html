<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/HashCountedSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GregorianDateTime.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashFunctions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/HashCountedSet.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93     // Decrements the count of the value, and removes it if count goes down to zero.
 94     // Returns true if the value is removed.
 95     bool remove(const ValueType&amp;);
 96     bool remove(iterator);
 97 
 98     // Removes the value, regardless of its count.
 99     // Returns true if a value was removed.
100     bool removeAll(iterator);
101     bool removeAll(const ValueType&amp;);
102 
103     // Clears the whole set.
104     void clear();
105 
106     // Overloads for smart pointer keys that take the raw pointer type as the parameter.
107     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType);
108     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, const_iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType) const;
109     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type contains(typename GetPtrHelper&lt;V&gt;::PtrType) const;
110     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, unsigned&gt;::type count(typename GetPtrHelper&lt;V&gt;::PtrType) const;
111     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type remove(typename GetPtrHelper&lt;V&gt;::PtrType);
112 


113 private:
114     ImplType m_impl;
115 };
116 
117 
118 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
119 inline void HashCountedSet&lt;Value, HashFunctions, Traits&gt;::swap(HashCountedSet&amp; other)
120 {
121     m_impl.swap(other.m_impl);
122 }
123 
124 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
125 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::size() const
126 {
127     return m_impl.size();
128 }
129 
130 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
131 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::capacity() const
132 {
</pre>
</td>
<td>
<hr />
<pre>
 93     // Decrements the count of the value, and removes it if count goes down to zero.
 94     // Returns true if the value is removed.
 95     bool remove(const ValueType&amp;);
 96     bool remove(iterator);
 97 
 98     // Removes the value, regardless of its count.
 99     // Returns true if a value was removed.
100     bool removeAll(iterator);
101     bool removeAll(const ValueType&amp;);
102 
103     // Clears the whole set.
104     void clear();
105 
106     // Overloads for smart pointer keys that take the raw pointer type as the parameter.
107     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType);
108     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, const_iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType) const;
109     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type contains(typename GetPtrHelper&lt;V&gt;::PtrType) const;
110     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, unsigned&gt;::type count(typename GetPtrHelper&lt;V&gt;::PtrType) const;
111     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type remove(typename GetPtrHelper&lt;V&gt;::PtrType);
112 
<span class="line-added">113     static bool isValidValue(const ValueType&amp; value) { return ImplType::isValidValue(value); }</span>
<span class="line-added">114 </span>
115 private:
116     ImplType m_impl;
117 };
118 
119 
120 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
121 inline void HashCountedSet&lt;Value, HashFunctions, Traits&gt;::swap(HashCountedSet&amp; other)
122 {
123     m_impl.swap(other.m_impl);
124 }
125 
126 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
127 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::size() const
128 {
129     return m_impl.size();
130 }
131 
132 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
133 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::capacity() const
134 {
</pre>
</td>
</tr>
</table>
<center><a href="GregorianDateTime.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashFunctions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
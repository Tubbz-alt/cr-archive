<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2003, 2006 Apple Inc.  All rights reserved.
  3  *                     2006 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;Path.h&quot;
 31 
 32 #include &quot;FloatPoint.h&quot;
 33 #include &quot;FloatRect.h&quot;
 34 #include &quot;FloatRoundedRect.h&quot;
 35 #include &quot;PathTraversalState.h&quot;
 36 #include &quot;RoundedRect.h&quot;
 37 #include &lt;math.h&gt;
 38 #include &lt;wtf/MathExtras.h&gt;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 #if !USE(DIRECT2D)
 44 float Path::length() const
 45 {
 46     PathTraversalState traversalState(PathTraversalState::Action::TotalLength);
 47 
 48     apply([&amp;traversalState](const PathElement&amp; element) {
 49         traversalState.processPathElement(element);
 50     });
 51 
 52     return traversalState.totalLength();
 53 }
 54 #endif
 55 
<a name="1" id="anc1"></a><span class="line-modified"> 56 PathTraversalState Path::traversalStateAtLength(float length, bool&amp; success) const</span>
 57 {
 58     PathTraversalState traversalState(PathTraversalState::Action::VectorAtLength, length);
 59 
 60     apply([&amp;traversalState](const PathElement&amp; element) {
 61         traversalState.processPathElement(element);
 62     });
 63 
<a name="2" id="anc2"></a><span class="line-removed"> 64     success = traversalState.success();</span>
 65     return traversalState;
 66 }
 67 
<a name="3" id="anc3"></a><span class="line-modified"> 68 FloatPoint Path::pointAtLength(float length, bool&amp; success) const</span>
 69 {
<a name="4" id="anc4"></a><span class="line-modified"> 70     return traversalStateAtLength(length, success).current();</span>
<span class="line-removed"> 71 }</span>
<span class="line-removed"> 72 </span>
<span class="line-removed"> 73 float Path::normalAngleAtLength(float length, bool&amp; success) const</span>
<span class="line-removed"> 74 {</span>
<span class="line-removed"> 75     return traversalStateAtLength(length, success).normalAngle();</span>
 76 }
 77 
 78 void Path::addRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; roundingRadii, RoundedRectStrategy strategy)
 79 {
 80     if (rect.isEmpty())
 81         return;
 82 
 83     FloatSize radius(roundingRadii);
 84     FloatSize halfSize = rect.size() / 2;
 85 
 86     // Apply the SVG corner radius constraints, per the rect section of the SVG shapes spec: if
 87     // one of rx,ry is negative, then the other corner radius value is used. If both values are
 88     // negative then rx = ry = 0. If rx is greater than half of the width of the rectangle
 89     // then set rx to half of the width; ry is handled similarly.
 90 
 91     if (radius.width() &lt; 0)
 92         radius.setWidth((radius.height() &lt; 0) ? 0 : radius.height());
 93 
 94     if (radius.height() &lt; 0)
 95         radius.setHeight(radius.width());
 96 
 97     if (radius.width() &gt; halfSize.width())
 98         radius.setWidth(halfSize.width());
 99 
100     if (radius.height() &gt; halfSize.height())
101         radius.setHeight(halfSize.height());
102 
103     addRoundedRect(FloatRoundedRect(rect, radius, radius, radius, radius), strategy);
104 }
105 
106 void Path::addRoundedRect(const FloatRoundedRect&amp; r, RoundedRectStrategy strategy)
107 {
108     if (r.isEmpty())
109         return;
110 
111     const FloatRoundedRect::Radii&amp; radii = r.radii();
112     const FloatRect&amp; rect = r.rect();
113 
114     if (!r.isRenderable()) {
115         // If all the radii cannot be accommodated, return a rect.
116         addRect(rect);
117         return;
118     }
119 
<a name="5" id="anc5"></a><span class="line-modified">120     if (strategy == PreferNativeRoundedRect) {</span>
121 #if USE(CG) || USE(DIRECT2D)
122         platformAddPathForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
123         return;
124 #endif
125     }
126 
127     addBeziersForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
128 }
129 
130 void Path::addRoundedRect(const RoundedRect&amp; r)
131 {
132     addRoundedRect(FloatRoundedRect(r));
133 }
134 
135 void Path::addBeziersForRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius)
136 {
137     moveTo(FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));
138 
139     addLineTo(FloatPoint(rect.maxX() - topRightRadius.width(), rect.y()));
140     if (topRightRadius.width() &gt; 0 || topRightRadius.height() &gt; 0)
141         addBezierCurveTo(FloatPoint(rect.maxX() - topRightRadius.width() * circleControlPoint(), rect.y()),
142             FloatPoint(rect.maxX(), rect.y() + topRightRadius.height() * circleControlPoint()),
143             FloatPoint(rect.maxX(), rect.y() + topRightRadius.height()));
144     addLineTo(FloatPoint(rect.maxX(), rect.maxY() - bottomRightRadius.height()));
145     if (bottomRightRadius.width() &gt; 0 || bottomRightRadius.height() &gt; 0)
146         addBezierCurveTo(FloatPoint(rect.maxX(), rect.maxY() - bottomRightRadius.height() * circleControlPoint()),
147             FloatPoint(rect.maxX() - bottomRightRadius.width() * circleControlPoint(), rect.maxY()),
148             FloatPoint(rect.maxX() - bottomRightRadius.width(), rect.maxY()));
149     addLineTo(FloatPoint(rect.x() + bottomLeftRadius.width(), rect.maxY()));
150     if (bottomLeftRadius.width() &gt; 0 || bottomLeftRadius.height() &gt; 0)
151         addBezierCurveTo(FloatPoint(rect.x() + bottomLeftRadius.width() * circleControlPoint(), rect.maxY()),
152             FloatPoint(rect.x(), rect.maxY() - bottomLeftRadius.height() * circleControlPoint()),
153             FloatPoint(rect.x(), rect.maxY() - bottomLeftRadius.height()));
154     addLineTo(FloatPoint(rect.x(), rect.y() + topLeftRadius.height()));
155     if (topLeftRadius.width() &gt; 0 || topLeftRadius.height() &gt; 0)
156         addBezierCurveTo(FloatPoint(rect.x(), rect.y() + topLeftRadius.height() * circleControlPoint()),
157             FloatPoint(rect.x() + topLeftRadius.width() * circleControlPoint(), rect.y()),
158             FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));
159 
160     closeSubpath();
161 }
162 
163 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
164 Path Path::polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp; points)
165 {
166     Path path;
167     if (points.size() &lt; 2)
168         return path;
169 
170     path.moveTo(points[0]);
171     for (size_t i = 1; i &lt; points.size(); ++i)
172         path.addLineTo(points[i]);
173 
174     path.closeSubpath();
175     return path;
176 }
177 
178 FloatRect Path::fastBoundingRect() const
179 {
180     return boundingRect();
181 }
182 #endif
183 
184 #ifndef NDEBUG
185 void Path::dump() const
186 {
187     TextStream stream;
188     stream &lt;&lt; *this;
189     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
190 }
191 #endif
192 
193 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const Path&amp; path)
194 {
195     bool isFirst = true;
196     path.apply([&amp;stream, &amp;isFirst](const PathElement&amp; element) {
197         if (!isFirst)
198             stream &lt;&lt; &quot;, &quot;;
199         isFirst = false;
200         switch (element.type) {
<a name="6" id="anc6"></a><span class="line-modified">201         case PathElementMoveToPoint: // The points member will contain 1 value.</span>
202             stream &lt;&lt; &quot;move to &quot; &lt;&lt; element.points[0];
203             break;
<a name="7" id="anc7"></a><span class="line-modified">204         case PathElementAddLineToPoint: // The points member will contain 1 value.</span>
205             stream &lt;&lt; &quot;add line to &quot; &lt;&lt; element.points[0];
206             break;
<a name="8" id="anc8"></a><span class="line-modified">207         case PathElementAddQuadCurveToPoint: // The points member will contain 2 values.</span>
208             stream &lt;&lt; &quot;add quad curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1];
209             break;
<a name="9" id="anc9"></a><span class="line-modified">210         case PathElementAddCurveToPoint: // The points member will contain 3 values.</span>
211             stream &lt;&lt; &quot;add curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1] &lt;&lt; &quot; &quot; &lt;&lt; element.points[2];
212             break;
<a name="10" id="anc10"></a><span class="line-modified">213         case PathElementCloseSubpath: // The points member will contain no values.</span>
214             stream &lt;&lt; &quot;close subpath&quot;;
215             break;
216         }
217     });
218 
219     return stream;
220 }
221 
222 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
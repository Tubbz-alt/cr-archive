<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 221         m_isFrameLayerWithTiledBacking = renderer().page().chrome().client().shouldUseTiledBackingForFrameView(renderer().view().frameView());
 222     }
 223 
 224     createPrimaryGraphicsLayer();
 225 #if ENABLE(FULLSCREEN_API)
 226     setRequiresBackgroundLayer(layer.renderer().isRenderFullScreen());
 227 #endif
 228 
 229     if (auto* tiledBacking = this-&gt;tiledBacking()) {
 230         tiledBacking-&gt;setIsInWindow(renderer().page().isInWindow());
 231 
 232         if (m_isFrameLayerWithTiledBacking) {
 233             tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(renderer().settings().scrollingPerformanceLoggingEnabled());
 234             adjustTiledBackingCoverage();
 235         }
 236     }
 237 }
 238 
 239 RenderLayerBacking::~RenderLayerBacking()
 240 {




 241     // Note that m_owningLayer-&gt;backing() is null here.
 242     updateAncestorClipping(false, nullptr);
 243     updateChildClippingStrategy(false);
 244     updateDescendantClippingLayer(false);
 245     updateOverflowControlsLayers(false, false, false);
 246     updateForegroundLayer(false);
 247     updateBackgroundLayer(false);
 248     updateMaskingLayer(false, false);
 249     updateScrollingLayers(false);
 250 
 251     ASSERT(!m_viewportConstrainedNodeID);
 252     ASSERT(!m_scrollingNodeID);
 253     ASSERT(!m_frameHostingNodeID);
 254     ASSERT(!m_positioningNodeID);
 255 
 256     destroyGraphicsLayers();
 257 }
 258 
 259 void RenderLayerBacking::willBeDestroyed()
 260 {





 261     ASSERT(m_owningLayer.backing() == this);
 262     compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
 263 
 264     clearBackingSharingLayers();
 265 }
 266 
 267 void RenderLayerBacking::willDestroyLayer(const GraphicsLayer* layer)
 268 {
 269     if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
 270         compositor().layerTiledBackingUsageChanged(layer, false);
 271 }
 272 
<span class="line-modified"> 273 static void clearBackingSharingLayerProviders(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; sharingLayers)</span>
 274 {
 275     for (auto&amp; layerWeakPtr : sharingLayers) {
 276         if (!layerWeakPtr)
 277             continue;
<span class="line-modified"> 278         layerWeakPtr-&gt;setBackingProviderLayer(nullptr);</span>

 279     }
 280 }
 281 
 282 void RenderLayerBacking::setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp; sharingLayers)
 283 {
 284     bool sharingLayersChanged = m_backingSharingLayers != sharingLayers;
 285     if (sharingLayersChanged) {
 286         // For layers that used to share and no longer do, and are not composited, recompute repaint rects.
 287         for (auto&amp; oldSharingLayer : m_backingSharingLayers) {
 288             // Layers that go from shared to composited have their repaint rects recomputed in RenderLayerCompositor::updateBacking().
 289             // FIXME: Two O(n^2) traversals in this funtion. Probably OK because sharing lists are usually small, but still.
 290             if (!sharingLayers.contains(oldSharingLayer) &amp;&amp; !oldSharingLayer-&gt;isComposited())
 291                 oldSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
 292         }
 293     }
 294 
<span class="line-modified"> 295     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
 296 
<span class="line-modified"> 297     if (sharingLayers != m_backingSharingLayers)</span>


 298         setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.

 299 
 300     auto oldSharingLayers = WTFMove(m_backingSharingLayers);
 301     m_backingSharingLayers = WTFMove(sharingLayers);
 302 
 303     for (auto&amp; layerWeakPtr : m_backingSharingLayers)
 304         layerWeakPtr-&gt;setBackingProviderLayer(&amp;m_owningLayer);
 305 
 306     if (sharingLayersChanged) {
 307         // For layers that are newly sharing, recompute repaint rects.
 308         for (auto&amp; currentSharingLayer : m_backingSharingLayers) {
 309             if (!oldSharingLayers.contains(currentSharingLayer))
 310                 currentSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
 311         }
 312     }
 313 }
 314 
 315 void RenderLayerBacking::removeBackingSharingLayer(RenderLayer&amp; layer)
 316 {
 317     layer.setBackingProviderLayer(nullptr);
 318     m_backingSharingLayers.removeAll(&amp;layer);
 319 }
 320 
 321 void RenderLayerBacking::clearBackingSharingLayers()
 322 {
<span class="line-modified"> 323     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
 324     m_backingSharingLayers.clear();
 325 }
 326 
 327 Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
 328 {
 329     auto* graphicsLayerFactory = renderer().page().chrome().client().graphicsLayerFactory();
 330 
 331     auto graphicsLayer = GraphicsLayer::create(graphicsLayerFactory, *this, layerType);
 332 
 333     graphicsLayer-&gt;setName(name);
 334 
 335 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 336     graphicsLayer-&gt;setAcceleratesDrawing(compositor().acceleratedDrawingEnabled());
 337     graphicsLayer-&gt;setUsesDisplayListDrawing(compositor().displayListDrawingEnabled());
 338 #endif
 339 
 340     return graphicsLayer;
 341 }
 342 
 343 void RenderLayerBacking::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
</pre>
<hr />
<pre>
 678 #endif
 679 
 680     if (m_isFrameLayerWithTiledBacking)
 681         return false;
 682 
 683     if (layerOrAncestorIsTransformedOrUsingCompositedScrolling(m_owningLayer))
 684         return false;
 685 
 686     return true;
 687 }
 688 
 689 static bool hasNonZeroTransformOrigin(const RenderObject&amp; renderer)
 690 {
 691     const RenderStyle&amp; style = renderer.style();
 692     return (style.transformOriginX().type() == Fixed &amp;&amp; style.transformOriginX().value())
 693         || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
 694 }
 695 
 696 bool RenderLayerBacking::updateCompositedBounds()
 697 {





 698     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, { }, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);
 699     // Clip to the size of the document or enclosing overflow-scroll layer.
 700     // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
 701     // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
 702     if (shouldClipCompositedBounds()) {
 703         auto&amp; view = renderer().view();
 704         auto* rootLayer = view.layer();
 705 
 706         LayoutRect clippingBounds;
 707         if (renderer().isFixedPositioned() &amp;&amp; renderer().container() == &amp;view)
 708             clippingBounds = view.frameView().rectForFixedPositionLayout();
 709         else
 710             clippingBounds = view.unscaledDocumentRect();
 711 
 712         if (&amp;m_owningLayer != rootLayer)
 713             clippingBounds.intersect(m_owningLayer.backgroundClipRect(RenderLayer::ClipRectsContext(rootLayer, AbsoluteClipRects)).rect()); // FIXME: Incorrect for CSS regions.
 714 
 715         LayoutPoint delta = m_owningLayer.convertToLayerCoords(rootLayer, LayoutPoint(), RenderLayer::AdjustForColumns);
 716         clippingBounds.move(-delta.x(), -delta.y());
 717 
</pre>
<hr />
<pre>
 769         fixedLayoutRect = frameView.rectForFixedPositionLayout();
 770 
 771     bool allowDetaching = !fixedLayoutRect.intersects(absoluteBounds);
 772     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerBacking (layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot;) updateAllowsBackingStoreDetaching - absoluteBounds &quot; &lt;&lt; absoluteBounds &lt;&lt; &quot; layoutViewportRect &quot; &lt;&lt; fixedLayoutRect &lt;&lt; &quot;, allowDetaching &quot; &lt;&lt; allowDetaching);
 773     setAllowsBackingStoreDetaching(allowDetaching);
 774 }
 775 
 776 void RenderLayerBacking::updateAfterWidgetResize()
 777 {
 778     if (!is&lt;RenderWidget&gt;(renderer()))
 779         return;
 780 
 781     if (auto* innerCompositor = RenderLayerCompositor::frameContentsCompositor(downcast&lt;RenderWidget&gt;(renderer()))) {
 782         innerCompositor-&gt;frameViewDidChangeSize();
 783         innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
 784     }
 785 }
 786 
 787 void RenderLayerBacking::updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint)
 788 {





 789     LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
 790 
 791     // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
 792     // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
 793     // take overflow into account.
 794     if (updateCompositedBounds()) {
 795         m_owningLayer.setNeedsCompositingGeometryUpdate();
 796         // This layer&#39;s geometry affects those of its children.
 797         m_owningLayer.setChildrenNeedCompositingGeometryUpdate();
 798     } else if (needsClippingUpdate) {
 799         m_owningLayer.setNeedsCompositingConfigurationUpdate();
 800         m_owningLayer.setNeedsCompositingGeometryUpdate();
 801     }
 802 
 803     if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
 804         setContentsNeedDisplay();
 805 }
 806 
 807 // This can only update things that don&#39;t require up-to-date layout.
 808 void RenderLayerBacking::updateConfigurationAfterStyleChange()
</pre>
<hr />
<pre>
 814             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 815             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 816         }
 817     } else
 818         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 819 
 820     // FIXME: do we care if opacity is animating?
 821     auto&amp; style = renderer().style();
 822     updateOpacity(style);
 823     updateFilters(style);
 824 
 825 #if ENABLE(FILTERS_LEVEL_2)
 826     updateBackdropFilters(style);
 827 #endif
 828 #if ENABLE(CSS_COMPOSITING)
 829     updateBlendMode(style);
 830 #endif
 831     updateCustomAppearance(style);
 832 }
 833 
<span class="line-modified"> 834 bool RenderLayerBacking::updateConfiguration()</span>
 835 {
 836     ASSERT(!m_owningLayer.normalFlowListDirty());
 837     ASSERT(!m_owningLayer.zOrderListsDirty());
 838     ASSERT(!renderer().view().needsLayout());
 839 
 840     bool layerConfigChanged = false;
 841     auto&amp; compositor = this-&gt;compositor();
 842 
 843     setBackgroundLayerPaintsFixedRootBackground(compositor.needsFixedRootBackgroundLayer(m_owningLayer));
 844 
 845     if (updateBackgroundLayer(m_backgroundLayerPaintsFixedRootBackground || m_requiresBackgroundLayer))
 846         layerConfigChanged = true;
 847 
 848     if (updateForegroundLayer(compositor.needsContentsCompositingLayer(m_owningLayer)))
 849         layerConfigChanged = true;
 850 
 851     bool needsDescendantsClippingLayer = false;
 852     bool usesCompositedScrolling = m_owningLayer.hasCompositedScrollableOverflow();
 853 
 854     if (usesCompositedScrolling) {
 855         // If it&#39;s scrollable, it has to be a box.
 856         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 857         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 858         needsDescendantsClippingLayer = contentsClippingRect.isRounded();
 859     } else
 860         needsDescendantsClippingLayer = RenderLayerCompositor::clipsCompositingDescendants(m_owningLayer);
 861 
 862     if (updateScrollingLayers(usesCompositedScrolling))
 863         layerConfigChanged = true;
 864 
 865     if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
 866         layerConfigChanged = true;
 867 
<span class="line-modified"> 868     auto* compositingAncestor = m_owningLayer.ancestorCompositingLayer();</span>
 869     if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))
 870         layerConfigChanged = true;
 871 
 872     if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
 873         layerConfigChanged = true;
 874 
 875     if (layerConfigChanged)
 876         updateInternalHierarchy();
 877 
 878     if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
 879         if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
 880             m_graphicsLayer-&gt;addChild(*flatteningLayer);
 881     }
 882 
 883     if (updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath()))
 884         layerConfigChanged = true;
 885 
 886     updateChildClippingStrategy(needsDescendantsClippingLayer);
 887 
 888     if (m_owningLayer.hasReflection()) {
</pre>
<hr />
<pre>
 934 
 935         layerConfigChanged = true;
 936     }
 937 #endif
 938     if (is&lt;RenderWidget&gt;(renderer()) &amp;&amp; compositor.parentFrameContentLayers(downcast&lt;RenderWidget&gt;(renderer()))) {
 939         m_owningLayer.setNeedsCompositingGeometryUpdate();
 940         layerConfigChanged = true;
 941     }
 942 
 943     if (is&lt;RenderImage&gt;(renderer()) &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage()) {
 944         auto element = renderer().element();
 945         if (is&lt;HTMLImageElement&gt;(element)) {
 946             m_graphicsLayer-&gt;setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType::EditableImage, downcast&lt;HTMLImageElement&gt;(element)-&gt;editableImageViewID());
 947             layerConfigChanged = true;
 948         }
 949     }
 950 
 951     if (layerConfigChanged)
 952         updatePaintingPhases();
 953 





 954     return layerConfigChanged;
 955 }
 956 
 957 static LayoutRect clipBox(RenderBox&amp; renderer)
 958 {
 959     LayoutRect result = LayoutRect::infiniteRect();
 960     if (renderer.hasOverflowClip())
 961         result = renderer.overflowClipRect(LayoutPoint(), 0); // FIXME: Incorrect for CSS regions.
 962 
 963     if (renderer.hasClip())
 964         result.intersect(renderer.clipRect(LayoutPoint(), 0)); // FIXME: Incorrect for CSS regions.
 965 
 966     return result;
 967 }
 968 
 969 static bool subpixelOffsetFromRendererChanged(const LayoutSize&amp; oldSubpixelOffsetFromRenderer, const LayoutSize&amp; newSubpixelOffsetFromRenderer, float deviceScaleFactor)
 970 {
 971     FloatSize previous = snapSizeToDevicePixel(oldSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 972     FloatSize current = snapSizeToDevicePixel(newSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
 973     return previous != current;
</pre>
<hr />
<pre>
1009     snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
1010     return snappedGraphicsLayer;
1011 }
1012 
1013 static LayoutSize computeOffsetFromAncestorGraphicsLayer(const RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)
1014 {
1015     if (!compositedAncestor)
1016         return toLayoutSize(location);
1017 
1018     // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
1019     // could be stale when a dynamic composited state change triggers a pre-order updateGeometry() traversal.
1020     LayoutSize ancestorSubpixelOffsetFromRenderer = compositedAncestor-&gt;backing()-&gt;subpixelOffsetFromRenderer();
1021     LayoutRect ancestorCompositedBounds = compositedAncestor-&gt;backing()-&gt;compositedBounds();
1022     LayoutSize floored = toLayoutSize(LayoutPoint(floorPointToDevicePixels(ancestorCompositedBounds.location() - ancestorSubpixelOffsetFromRenderer, deviceScaleFactor)));
1023     LayoutSize ancestorRendererOffsetFromAncestorGraphicsLayer = -(floored + ancestorSubpixelOffsetFromRenderer);
1024     return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
1025 }
1026 
1027 class ComputedOffsets {
1028 public:
<span class="line-modified">1029     ComputedOffsets(const RenderLayer&amp; renderLayer, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)</span>
1030         : m_renderLayer(renderLayer)

1031         , m_location(localRect.location())
1032         , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
1033         , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
1034         , m_deviceScaleFactor(renderLayer.renderer().document().deviceScaleFactor())
1035     {
1036     }
1037 
1038     LayoutSize fromParentGraphicsLayer()
1039     {
1040         if (!m_fromParentGraphicsLayer)
1041             m_fromParentGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset;
1042         return m_fromParentGraphicsLayer.value();
1043     }
1044 
1045     LayoutSize fromPrimaryGraphicsLayer()
1046     {
1047         if (!m_fromPrimaryGraphicsLayer)
1048             m_fromPrimaryGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset - m_primaryGraphicsLayerOffset;
1049         return m_fromPrimaryGraphicsLayer.value();
1050     }
1051 
1052 private:
1053     LayoutSize fromAncestorGraphicsLayer()
1054     {
1055         if (!m_fromAncestorGraphicsLayer) {
<span class="line-modified">1056             auto* compositedAncestor = m_renderLayer.ancestorCompositingLayer();</span>
<span class="line-modified">1057             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(compositedAncestor, m_location, RenderLayer::AdjustForColumns);</span>
<span class="line-removed">1058             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);</span>
1059         }
1060         return m_fromAncestorGraphicsLayer.value();
1061     }
1062 
1063     Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
1064     Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
1065     Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
1066 
1067     const RenderLayer&amp; m_renderLayer;

1068     // Location is relative to the renderer.
1069     const LayoutPoint m_location;
1070     const LayoutSize m_parentGraphicsLayerOffset;
1071     const LayoutSize m_primaryGraphicsLayerOffset;
1072     float m_deviceScaleFactor;
1073 };
1074 
<span class="line-modified">1075 LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const</span>
1076 {
<span class="line-modified">1077     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, { });</span>
1078     return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
1079         deviceScaleFactor()));
1080 }
1081 
1082 // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
1083 LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const
1084 {
1085     if (!compositedAncestor || !compositedAncestor-&gt;backing())
1086         return renderer().view().documentRect();
1087 
1088     auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
1089     LayoutRect parentGraphicsLayerRect;
1090     if (m_owningLayer.isInsideFragmentedFlow()) {
1091         // FIXME: flows/columns need work.
1092         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1093         ancestorCompositedBounds.setLocation(LayoutPoint());
1094         parentGraphicsLayerRect = ancestorCompositedBounds;
1095     }
1096 
1097     if (ancestorBackingLayer-&gt;hasClippingLayer()) {
1098         // If the compositing ancestor has a layer to clip children, we parent in that, and therefore position relative to it.
1099         LayoutRect clippingBox = clipBox(downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer()));
1100         LayoutSize clippingBoxOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clippingBox.location(), deviceScaleFactor());
1101         parentGraphicsLayerRect = snappedGraphicsLayer(clippingBoxOffset, clippingBox.size(), deviceScaleFactor()).m_snappedRect;
1102     }
1103 
1104     if (compositedAncestor-&gt;hasCompositedScrollableOverflow()) {
1105         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1106         auto&amp; renderBox = downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer());
1107         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();
1108         ScrollOffset scrollOffset = compositedAncestor-&gt;scrollOffset();
1109         parentGraphicsLayerRect = LayoutRect((paddingBoxIncludingScrollbar.location() - toLayoutSize(ancestorCompositedBounds.location()) - toLayoutSize(scrollOffset)), paddingBoxIncludingScrollbar.size());
1110     }
1111 
1112     return parentGraphicsLayerRect;
1113 }
1114 
<span class="line-modified">1115 void RenderLayerBacking::updateGeometry()</span>
1116 {
1117     ASSERT(!m_owningLayer.normalFlowListDirty());
1118     ASSERT(!m_owningLayer.zOrderListsDirty());
1119     ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
1120     ASSERT(!renderer().view().needsLayout());
1121 
1122     const RenderStyle&amp; style = renderer().style();
1123 
1124     bool isRunningAcceleratedTransformAnimation = false;
1125     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1126         if (auto* timeline = renderer().documentTimeline())
1127             isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
1128     } else
1129         isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
1130 
1131     updateTransform(style);
1132     updateOpacity(style);
1133     updateFilters(style);
1134 #if ENABLE(FILTERS_LEVEL_2)
1135     updateBackdropFilters(style);
1136 #endif
1137 #if ENABLE(CSS_COMPOSITING)
1138     updateBlendMode(style);
1139 #endif
1140 
<span class="line-modified">1141     auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();</span>
1142     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);
1143 
1144     if (m_ancestorClippingStack) {
1145         // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.
1146         auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));
1147         LayoutRect lastClipLayerRect = parentGraphicsLayerRect;
1148 
1149         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {
1150             auto clipRect = entry.clipData.clipRect;
1151             LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clipRect.location() + offsetFromCompositedAncestor, deviceScaleFactor());
1152             LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, clipRect.size(), deviceScaleFactor()).m_snappedRect;
1153 
1154             entry.clippingLayer-&gt;setPosition(toLayoutPoint(snappedClippingLayerRect.location() - lastClipLayerRect.location()));
1155             lastClipLayerRect = snappedClippingLayerRect;
1156 
1157             entry.clippingLayer-&gt;setSize(snappedClippingLayerRect.size());
1158 
1159             if (entry.clipData.isOverflowScroll) {
1160                 ScrollOffset scrollOffset = entry.clipData.clippingLayer-&gt;scrollOffset();
1161 
1162                 entry.clippingLayer-&gt;setBoundsOrigin(scrollOffset);
1163                 lastClipLayerRect.moveBy(-scrollOffset);
1164             } else
1165                 entry.clippingLayer-&gt;setBoundsOrigin({ });
1166         }
1167 
1168         parentGraphicsLayerRect = lastClipLayerRect;
1169     }
1170 
<span class="line-modified">1171     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);</span>
1172 
<span class="line-modified">1173     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-modified">1174     ComputedOffsets rendererOffset(m_owningLayer, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
1175 
1176     m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
1177 
1178     auto primaryLayerPosition = primaryGraphicsLayerRect.location();
1179 
1180     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959
1181     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();
1182     if (m_contentsContainmentLayer) {
1183         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);
1184         m_contentsContainmentLayer-&gt;setPosition(primaryLayerPosition);
1185         primaryLayerPosition = { };
1186         // Use the same size as m_graphicsLayer so transforms behave correctly.
1187         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());
1188     }
1189 
1190     auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
1191         LayoutRect animatedBounds;
1192         if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
1193             return FloatRect(animatedBounds);
1194         return { };
</pre>
<hr />
<pre>
1264             if (clipLayer) {
1265                 clipLayer-&gt;setChildrenTransform(t);
1266                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1267             }
1268             else
1269                 m_graphicsLayer-&gt;setChildrenTransform(t);
1270         } else {
1271             if (clipLayer)
1272                 clipLayer-&gt;setChildrenTransform(TransformationMatrix());
1273             else
1274                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1275         }
1276     } else {
1277         m_graphicsLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1278         if (m_contentsContainmentLayer)
1279             m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1280     }
1281 
1282     if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
1283         auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
<span class="line-modified">1284         reflectionBacking-&gt;updateGeometry();</span>
1285 
1286         // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
1287         // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
1288         FloatRect layerBounds = this-&gt;compositedBounds();
1289         FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
1290         reflectionBacking-&gt;graphicsLayer()-&gt;setReplicatedLayerPosition(FloatPoint(layerBounds.location() - reflectionLayerBounds.location()));
1291     }
1292 
1293     if (m_scrollContainerLayer) {
1294         ASSERT(m_scrolledContentsLayer);
1295         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
1296         LayoutRect paddingBox = renderBox.paddingBoxRect();
1297         LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
1298 
1299         // FIXME: need to do some pixel snapping here.
1300         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBox.location() - parentLayerBounds.location()));
1301         m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
1302 
1303         ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
1304         updateScrollOffset(scrollOffset);
</pre>
<hr />
<pre>
1410     if (!m_owningLayer.isRenderViewLayer()) {
1411         bool didUpdateContentsRect = false;
1412         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
1413         if (!didUpdateContentsRect &amp;&amp; m_graphicsLayer-&gt;usesContentsLayer())
1414             resetContentsRect();
1415     }
1416 
1417     updateDrawsContent(contentsInfo);
1418 
1419     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {
1420         // For non-root layers, background is always painted by the primary graphics layer.
1421         ASSERT(!m_backgroundLayer);
1422         m_graphicsLayer-&gt;setContentsOpaque(!m_hasSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));
1423     }
1424 
1425     m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
1426     if (m_scrollContainerLayer) {
1427         m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
1428         m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
1429     }





1430 }
1431 
1432 // FIXME: Avoid repaints when clip path changes.
1433 void RenderLayerBacking::updateMaskingLayerGeometry()
1434 {
1435     m_maskLayer-&gt;setSize(m_graphicsLayer-&gt;size());
1436     m_maskLayer-&gt;setPosition(FloatPoint());
1437     m_maskLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());
1438 
1439     if (!m_maskLayer-&gt;drawsContent()) {
1440         if (renderer().hasClipPath()) {
1441             ASSERT(renderer().style().clipPath()-&gt;type() != ClipPathOperation::Reference);
1442 
1443             WindRule windRule;
1444             // FIXME: Use correct reference box for inlines: https://bugs.webkit.org/show_bug.cgi?id=129047
1445             LayoutRect boundingBox = m_owningLayer.boundingBox(&amp;m_owningLayer);
1446             LayoutRect referenceBoxForClippedInline = LayoutRect(snapRectToDevicePixels(boundingBox, deviceScaleFactor()));
1447             LayoutSize offset = LayoutSize(snapSizeToDevicePixel(-m_subpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor()));
1448             Path clipPath = m_owningLayer.computeClipPath(offset, referenceBoxForClippedInline, windRule);
1449 
</pre>
<hr />
<pre>
1574     } else
1575         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1576 
1577     if (m_backgroundLayer)
1578         m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
1579 }
1580 
1581 void RenderLayerBacking::updateEventRegion()
1582 {
1583 #if PLATFORM(IOS_FAMILY)
1584     if (paintsIntoCompositedAncestor())
1585         return;
1586 
1587     bool hasTouchActionElements = false;
1588 #if ENABLE(POINTER_EVENTS)
1589     hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();
1590 #endif
1591     if (m_owningLayer.isRenderViewLayer() &amp;&amp; !hasTouchActionElements)
1592         return;
1593 
<span class="line-modified">1594     GraphicsContext nullContext(nullptr);</span>
<span class="line-modified">1595     RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, compositedBounds(), { }, LayoutSize());</span>



1596 
<span class="line-modified">1597     EventRegion eventRegion;</span>
<span class="line-modified">1598     auto eventRegionContext = eventRegion.makeContext();</span>
<span class="line-modified">1599     paintingInfo.eventRegionContext = &amp;eventRegionContext;</span>


1600 
<span class="line-modified">1601     auto paintFlags = RenderLayer::paintLayerPaintingCompositingAllPhasesFlags() | RenderLayer::PaintLayerCollectingEventRegion;</span>
<span class="line-modified">1602     m_owningLayer.paintLayerContents(nullContext, paintingInfo, paintFlags);</span>
1603 
<span class="line-modified">1604     for (auto&amp; layer : m_backingSharingLayers)</span>
<span class="line-removed">1605         layer-&gt;paintLayerWithEffects(nullContext, paintingInfo, paintFlags);</span>
1606 
<span class="line-modified">1607     GraphicsLayer&amp; layerForEventRegion = m_scrolledContentsLayer ? *m_scrolledContentsLayer : *m_graphicsLayer;</span>

1608 
<span class="line-modified">1609     auto layerOffset = toIntSize(layerForEventRegion.scrollOffset()) - roundedIntSize(layerForEventRegion.offsetFromRenderer());</span>
<span class="line-removed">1610     eventRegion.translate(layerOffset);</span>
1611 
<span class="line-modified">1612     layerForEventRegion.setEventRegion(WTFMove(eventRegion));</span>

1613 #endif
1614 }
1615 
1616 bool RenderLayerBacking::updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp; clippingData)
1617 {
1618     if (!m_ancestorClippingStack &amp;&amp; clippingData.isEmpty())
1619         return false;
1620 
1621     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
1622 
1623     if (m_ancestorClippingStack &amp;&amp; clippingData.isEmpty()) {
1624         m_ancestorClippingStack-&gt;clear(scrollingCoordinator);
1625         m_ancestorClippingStack = nullptr;
1626         return true;
1627     }
1628 
1629     if (!m_ancestorClippingStack) {
1630         m_ancestorClippingStack = makeUnique&lt;LayerAncestorClippingStack&gt;(WTFMove(clippingData));
1631         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);
1632         return true;
</pre>
<hr />
<pre>
1914             // We need a geometry update to size the new mask layer.
1915             m_owningLayer.setNeedsCompositingGeometryUpdate();
1916         }
1917     } else if (m_maskLayer) {
1918         m_graphicsLayer-&gt;setMaskLayer(nullptr);
1919         willDestroyLayer(m_maskLayer.get());
1920         GraphicsLayer::clear(m_maskLayer);
1921         layerChanged = true;
1922     }
1923 
1924     return layerChanged;
1925 }
1926 
1927 void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
1928 {
1929     if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
1930         if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
1931             auto* clipLayer = clippingLayer();
1932             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
1933             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">1934             contentsClippingRect.move(LayoutSize(clipLayer-&gt;offsetFromRenderer()));</span>
1935             // Note that we have to set this rounded rect again during the geometry update (clipLayer-&gt;offsetFromRenderer() may be stale here).
1936             if (clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect)) {
1937                 clipLayer-&gt;setMaskLayer(nullptr);
1938                 GraphicsLayer::clear(m_childClippingMaskLayer);
1939                 return;
1940             }
1941 
1942             if (!m_childClippingMaskLayer) {
1943                 m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
1944                 m_childClippingMaskLayer-&gt;setDrawsContent(true);
1945                 m_childClippingMaskLayer-&gt;setPaintingPhase({ GraphicsLayerPaintingPhase::ChildClippingMask });
1946                 clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
1947             }
1948         }
1949     } else {
1950         if (m_childClippingMaskLayer) {
1951             if (hasClippingLayer())
1952                 clippingLayer()-&gt;setMaskLayer(nullptr);
1953             GraphicsLayer::clear(m_childClippingMaskLayer);
1954         } else
</pre>
<hr />
<pre>
2080     if (!GraphicsLayer::supportsContentsTiling())
2081         return false;
2082 
2083     auto&amp; fillLayer = style.backgroundLayers();
2084     if (fillLayer.next())
2085         return false;
2086 
2087     if (!fillLayer.imagesAreLoaded())
2088         return false;
2089 
2090     if (fillLayer.attachment() != FillAttachment::ScrollBackground)
2091         return false;
2092 
2093     // FIXME: Allow color+image compositing when it makes sense.
2094     // For now bailing out.
2095     if (style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isVisible())
2096         return false;
2097 
2098     // FIXME: support gradients with isGeneratedImage.
2099     auto* styleImage = fillLayer.image();
<span class="line-modified">2100     if (!styleImage-&gt;isCachedImage())</span>
2101         return false;
2102 
2103     auto* image = styleImage-&gt;cachedImage()-&gt;image();
2104     if (!image-&gt;isBitmapImage())
2105         return false;
2106 
2107     return true;
2108 }
2109 
2110 static bool hasPaintedBoxDecorationsOrBackgroundImage(const RenderStyle&amp; style)
2111 {
2112     if (hasVisibleBoxDecorations(style))
2113         return true;
2114 
2115     if (!style.hasBackgroundImage())
2116         return false;
2117 
2118     return !canDirectlyCompositeBackgroundBackgroundImage(style);
2119 }
2120 
</pre>
<hr />
<pre>
2253 {
2254     if (!GraphicsLayer::supportsBackgroundColorContent())
2255         return false;
2256 
2257     const RenderStyle&amp; style = renderer.style();
2258     if (renderer.hasClip())
2259         return false;
2260 
2261     if (hasPaintedBoxDecorationsOrBackgroundImage(style))
2262         return false;
2263 
2264     // FIXME: We can&#39;t create a directly composited background if this
2265     // layer will have children that intersect with the background layer.
2266     // A better solution might be to introduce a flattening layer if
2267     // we do direct box decoration composition.
2268     // https://bugs.webkit.org/show_bug.cgi?id=119461
2269     if (hasPerspectiveOrPreserves3D(style))
2270         return false;
2271 
2272     // FIXME: we should be able to allow backgroundComposite; However since this is not a common use case it has been deferred for now.
<span class="line-modified">2273     if (style.backgroundComposite() != CompositeSourceOver)</span>
2274         return false;
2275 
2276     return true;
2277 }
2278 
2279 bool RenderLayerBacking::paintsBoxDecorations() const
2280 {
2281     if (!m_owningLayer.hasVisibleBoxDecorations())
2282         return false;
2283 
2284     return !supportsDirectlyCompositedBoxDecorations(renderer());
2285 }
2286 
2287 bool RenderLayerBacking::paintsContent(RenderLayer::PaintedContentRequest&amp; request) const
2288 {
2289     m_owningLayer.updateDescendantDependentFlags();
2290 
2291     bool paintsContent = false;
2292 
2293     if (m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasNonEmptyChildRenderers(request))
</pre>
<hr />
<pre>
2348     if (contentsInfo.paintsBoxDecorations() || contentsInfo.paintsContent())
2349         return false;
2350 
2351     if (renderer().style().backgroundClip() == FillBox::Text)
2352         return false;
2353 
2354     if (renderer().isDocumentElementRenderer() &amp;&amp; m_owningLayer.isolatesCompositedBlending())
2355         return false;
2356 
2357     return true;
2358 }
2359 
2360 // Returning true stops the traversal.
2361 enum class LayerTraversal { Continue, Stop };
2362 
2363 static LayerTraversal traverseVisibleNonCompositedDescendantLayers(RenderLayer&amp; parent, const WTF::Function&lt;LayerTraversal (const RenderLayer&amp;)&gt;&amp; layerFunc)
2364 {
2365     // FIXME: We shouldn&#39;t be called with a stale z-order lists. See bug 85512.
2366     parent.updateLayerListsIfNeeded();
2367 
<span class="line-modified">2368 #if !ASSERT_DISABLED</span>
2369     LayerListMutationDetector mutationChecker(parent);
2370 #endif
2371 
2372     for (auto* childLayer : parent.normalFlowLayers()) {
2373         if (compositedWithOwnBackingStore(*childLayer))
2374             continue;
2375 
2376         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2377             return LayerTraversal::Stop;
2378 
2379         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2380             return LayerTraversal::Stop;
2381     }
2382 
2383     if (parent.isStackingContext() &amp;&amp; !parent.hasVisibleDescendant())
2384         return LayerTraversal::Continue;
2385 
2386     // Use the m_hasCompositingDescendant bit to optimize?
2387     for (auto* childLayer : parent.negativeZOrderLayers()) {
2388         if (compositedWithOwnBackingStore(*childLayer))
</pre>
<hr />
<pre>
2758         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2759         layerDirtyRect.move(-m_maskLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2760         m_maskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2761     }
2762 
2763     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent()) {
2764         FloatRect layerDirtyRect = r;
2765         layerDirtyRect.move(-m_childClippingMaskLayer-&gt;offsetFromRenderer());
2766         m_childClippingMaskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect);
2767     }
2768 
2769     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
2770         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2771         layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);
2772         m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2773     }
2774 }
2775 
2776 void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
2777     const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">2778     OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase)</span>
2779 {
<span class="line-modified">2780     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; paintingPhase != OptionSet&lt;GraphicsLayerPaintingPhase&gt;(GraphicsLayerPaintingPhase::ChildClippingMask)) {</span>





2781 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
2782         // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
<span class="line-modified">2783         // when pages are restored from the PageCache.</span>
<span class="line-modified">2784         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in PageCache</span>
2785         ASSERT_NOT_REACHED();
2786 #endif
2787         return;
2788     }
2789 
<span class="line-modified">2790     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;</span>
<span class="line-removed">2791     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))</span>
<span class="line-removed">2792         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);</span>
<span class="line-removed">2793     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))</span>
<span class="line-removed">2794         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);</span>
<span class="line-removed">2795     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))</span>
<span class="line-removed">2796         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);</span>
<span class="line-removed">2797     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))</span>
<span class="line-removed">2798         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);</span>
<span class="line-removed">2799     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))</span>
<span class="line-removed">2800         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);</span>
<span class="line-removed">2801     if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
<span class="line-removed">2802         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);</span>
<span class="line-removed">2803     if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))</span>
<span class="line-removed">2804         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);</span>
2805 
<span class="line-modified">2806     if (graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)</span>
<span class="line-modified">2807         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.</span>
<span class="line-removed">2808     else if (compositor().fixedRootBackgroundLayer())</span>
<span class="line-removed">2809         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);</span>
2810 
2811 #ifndef NDEBUG
2812     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
2813 #endif
2814 
2815     auto paintOneLayer = [&amp;](RenderLayer&amp; layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags) {
<span class="line-removed">2816         InspectorInstrumentation::willPaint(layer.renderer());</span>
<span class="line-removed">2817 </span>
2818         FrameView::PaintingState paintingState;
<span class="line-modified">2819         if (layer.isRenderViewLayer())</span>
<span class="line-modified">2820             renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>




2821 
2822         RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);

2823 
2824         if (&amp;layer == &amp;m_owningLayer) {
2825             layer.paintLayerContents(context, paintingInfo, paintFlags);
2826 
<span class="line-modified">2827             if (layer.containsDirtyOverlayScrollbars())</span>
2828                 layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);
2829         } else
2830             layer.paintLayerWithEffects(context, paintingInfo, paintFlags);
2831 
<span class="line-modified">2832         if (layer.isRenderViewLayer())</span>
<span class="line-modified">2833             renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>

2834 
<span class="line-modified">2835         ASSERT(!m_owningLayer.m_usedTransparency);</span>

2836 
<span class="line-modified">2837         InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);</span>
2838     };
2839 
2840     paintOneLayer(m_owningLayer, paintFlags);
2841 
2842     // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.
2843     GraphicsLayer* destinationForSharingLayers = m_scrolledContentsLayer ? m_scrolledContentsLayer.get() : m_graphicsLayer.get();
2844 
2845     if (graphicsLayer == destinationForSharingLayers) {
2846         OptionSet&lt;RenderLayer::PaintLayerFlag&gt; sharingLayerPaintFlags = {
2847             RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,
2848             RenderLayer::PaintLayerPaintingCompositingForegroundPhase };
2849 
<span class="line-modified">2850         if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
2851             sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);


2852 
2853         for (auto&amp; layerWeakPtr : m_backingSharingLayers)
2854             paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);
2855     }
2856 
<span class="line-modified">2857     compositor().didPaintBacking(this);</span>


































2858 }
2859 
2860 #if ENABLE(POINTER_EVENTS)
2861 static RefPtr&lt;Pattern&gt; patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext&amp; destContext)
2862 {
2863     auto toIndex = [](TouchAction touchAction) -&gt; unsigned {
2864         switch (touchAction) {
2865         case TouchAction::None:
2866             return 1;
2867         case TouchAction::Manipulation:
2868             return 2;
2869         case TouchAction::PanX:
2870             return 3;
2871         case TouchAction::PanY:
2872             return 4;
2873         case TouchAction::PinchZoom:
2874             return 5;
2875         case TouchAction::Auto:
2876             break;
2877         }
</pre>
<hr />
<pre>
2881     struct TouchActionAndRGB {
2882         TouchAction action;
2883         ASCIILiteral name;
2884         FloatSize phase;
2885     };
2886     static const TouchActionAndRGB actionsAndColors[] = {
2887         { TouchAction::Auto, &quot;auto&quot;_s, { } },
2888         { TouchAction::None, &quot;none&quot;_s, { } },
2889         { TouchAction::Manipulation, &quot;manip&quot;_s, { } },
2890         { TouchAction::PanX, &quot;pan-x&quot;_s, { } },
2891         { TouchAction::PanY, &quot;pan-y&quot;_s, { 0, 9 } },
2892         { TouchAction::PinchZoom, &quot;p-z&quot;_s, { 16, 4.5 } },
2893     };
2894 
2895     auto actionIndex = toIndex(touchAction);
2896     if (!actionIndex || actionIndex &gt;= ARRAY_SIZE(actionsAndColors))
2897         return nullptr;
2898 
2899     const FloatSize tileSize { 32, 18 };
2900 
<span class="line-modified">2901     auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpaceSRGB, destContext);</span>
2902     if (!imageBuffer)
2903         return nullptr;
2904 
2905     const auto&amp; touchActionData = actionsAndColors[actionIndex];
2906     {
2907         GraphicsContext&amp; imageContext = imageBuffer-&gt;context();
2908 
2909         FontCascadeDescription fontDescription;
2910         fontDescription.setOneFamily(&quot;Helvetica&quot;);
2911         fontDescription.setSpecifiedSize(10);
2912         fontDescription.setComputedSize(10);
2913         fontDescription.setWeight(FontSelectionValue(500));
2914         FontCascade font(WTFMove(fontDescription), 0, 0);
2915         font.update(nullptr);
2916 
2917         TextRun textRun = TextRun(touchActionData.name);
2918         imageContext.setFillColor(Color(0, 0, 0, 128));
2919 
2920         constexpr float textGap = 4;
2921         constexpr float yOffset = 12;
</pre>
<hr />
<pre>
2960         TouchAction::PinchZoom,
2961     };
2962 
2963     for (auto action : touchActionList) {
2964         auto* actionRegion = graphicsLayer-&gt;eventRegion().regionForTouchAction(action);
2965         if (!actionRegion)
2966             continue;
2967 
2968         auto fillPattern = patternForTouchAction(action, contentOffsetInCompositingLayer(), context);
2969         if (!fillPattern)
2970             continue;
2971 
2972         context.setFillPattern(fillPattern.releaseNonNull());
2973         for (auto rect : actionRegion-&gt;rects())
2974             context.fillRect(rect);
2975     }
2976 #endif // ENABLE(POINTER_EVENTS)
2977 }
2978 
2979 // Up-call from compositing layer drawing callback.
<span class="line-modified">2980 void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
2981 {
2982 #ifndef NDEBUG
2983     renderer().page().setIsPainting(true);
2984 #endif
2985 
2986 #if PLATFORM(MAC)
2987     LocalDefaultSystemAppearance localAppearance(renderer().useDarkAppearance());
2988 #endif
2989 
2990     // The dirtyRect is in the coords of the painting root.
2991     FloatRect adjustedClipRect = clip;
2992     adjustedClipRect.move(m_subpixelOffsetFromRenderer);
2993     IntRect dirtyRect = enclosingIntRect(adjustedClipRect);
2994 
2995     if (!graphicsLayer-&gt;repaintCount())
2996         layerPaintBehavior |= GraphicsLayerPaintFirstTilePaint;
2997 
2998     if (graphicsLayer == m_graphicsLayer.get()
2999         || graphicsLayer == m_foregroundLayer.get()
3000         || graphicsLayer == m_backgroundLayer.get()
3001         || graphicsLayer == m_maskLayer.get()
3002         || graphicsLayer == m_childClippingMaskLayer.get()
3003         || graphicsLayer == m_scrolledContentsLayer.get()) {
3004 
<span class="line-modified">3005         if (!paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
3006             dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
3007 
3008         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
3009         OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
3010         if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
3011             behavior.add(PaintBehavior::Snapshotting);
3012 
3013         if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
3014             behavior.add(PaintBehavior::TileFirstPaint);
3015 
<span class="line-modified">3016         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);</span>
3017 
3018         if (renderer().settings().visibleDebugOverlayRegions() &amp; NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.
3019             paintDebugOverlays(graphicsLayer, context);
3020 
3021     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
3022         paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
3023     } else if (graphicsLayer == layerForVerticalScrollbar()) {
3024         paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
3025     } else if (graphicsLayer == layerForScrollCorner()) {
3026         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
3027         GraphicsContextStateSaver stateSaver(context);
3028         context.translate(-scrollCornerAndResizer.location());
3029         LayoutRect transformedClip = LayoutRect(clip);
3030         transformedClip.moveBy(scrollCornerAndResizer.location());
3031         m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
3032         m_owningLayer.paintResizer(context, IntPoint(), transformedClip);
3033     }
3034 #ifndef NDEBUG
3035     renderer().page().setIsPainting(false);
3036 #endif
</pre>
<hr />
<pre>
3197 
3198     if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
3199         return false;
3200 
3201     bool didAnimate = false;
3202 
3203     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), &amp;animation, keyframes.animationName(), timeOffset))
3204         didAnimate = true;
3205 
3206     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3207         didAnimate = true;
3208 
3209     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3210         didAnimate = true;
3211 
3212 #if ENABLE(FILTERS_LEVEL_2)
3213     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3214         didAnimate = true;
3215 #endif
3216 
<span class="line-modified">3217     if (didAnimate)</span>
3218         m_owningLayer.setNeedsPostLayoutCompositingUpdate();


3219 
3220     return didAnimate;
3221 }
3222 
3223 void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
3224 {
3225     m_graphicsLayer-&gt;pauseAnimation(animationName, timeOffset);
3226 }
3227 
3228 void RenderLayerBacking::animationSeeked(double timeOffset, const String&amp; animationName)
3229 {
3230     m_graphicsLayer-&gt;seekAnimation(animationName, timeOffset);
3231 }
3232 
3233 void RenderLayerBacking::animationFinished(const String&amp; animationName)
3234 {
3235     m_graphicsLayer-&gt;removeAnimation(animationName);
3236     m_owningLayer.setNeedsPostLayoutCompositingUpdate();

3237 }
3238 
3239 bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
3240 {
3241     bool didAnimate = false;
3242 
3243     ASSERT(property != CSSPropertyInvalid);
3244 
3245     if (property == CSSPropertyOpacity) {
3246         const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
3247         if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
3248             KeyframeValueList opacityVector(AnimatedPropertyOpacity);
3249             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));
3250             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));
3251             // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
3252             if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
3253                 // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
3254                 updateOpacity(*toStyle);
3255                 didAnimate = true;
3256             }
</pre>
<hr />
<pre>
3308 }
3309 
3310 void RenderLayerBacking::transitionPaused(double timeOffset, CSSPropertyID property)
3311 {
3312     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
3313     if (animatedProperty != AnimatedPropertyInvalid)
3314         m_graphicsLayer-&gt;pauseAnimation(GraphicsLayer::animationNameForTransition(animatedProperty), timeOffset);
3315 }
3316 
3317 void RenderLayerBacking::transitionFinished(CSSPropertyID property)
3318 {
3319     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
3320     if (animatedProperty != AnimatedPropertyInvalid) {
3321         m_graphicsLayer-&gt;removeAnimation(GraphicsLayer::animationNameForTransition(animatedProperty));
3322         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3323     }
3324 }
3325 
3326 void RenderLayerBacking::notifyAnimationStarted(const GraphicsLayer*, const String&amp;, MonotonicTime time)
3327 {
<span class="line-modified">3328     renderer().animation().notifyAnimationStarted(renderer(), time);</span>

3329 }
3330 
3331 void RenderLayerBacking::notifyFlushRequired(const GraphicsLayer* layer)
3332 {
3333     if (renderer().renderTreeBeingDestroyed())
3334         return;
3335     compositor().scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
3336 }
3337 
3338 void RenderLayerBacking::notifyFlushBeforeDisplayRefresh(const GraphicsLayer* layer)
3339 {
3340     compositor().notifyFlushBeforeDisplayRefresh(layer);
3341 }
3342 
3343 // This is used for the &#39;freeze&#39; API, for testing only.
3344 void RenderLayerBacking::suspendAnimations(MonotonicTime time)
3345 {
3346     m_graphicsLayer-&gt;suspendAnimations(time);
3347 }
3348 
</pre>
</td>
<td>
<hr />
<pre>
 221         m_isFrameLayerWithTiledBacking = renderer().page().chrome().client().shouldUseTiledBackingForFrameView(renderer().view().frameView());
 222     }
 223 
 224     createPrimaryGraphicsLayer();
 225 #if ENABLE(FULLSCREEN_API)
 226     setRequiresBackgroundLayer(layer.renderer().isRenderFullScreen());
 227 #endif
 228 
 229     if (auto* tiledBacking = this-&gt;tiledBacking()) {
 230         tiledBacking-&gt;setIsInWindow(renderer().page().isInWindow());
 231 
 232         if (m_isFrameLayerWithTiledBacking) {
 233             tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(renderer().settings().scrollingPerformanceLoggingEnabled());
 234             adjustTiledBackingCoverage();
 235         }
 236     }
 237 }
 238 
 239 RenderLayerBacking::~RenderLayerBacking()
 240 {
<span class="line-added"> 241 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added"> 242     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;~RenderLayerBacking: m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added"> 243     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;~RenderLayerBacking: m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added"> 244 #endif</span>
 245     // Note that m_owningLayer-&gt;backing() is null here.
 246     updateAncestorClipping(false, nullptr);
 247     updateChildClippingStrategy(false);
 248     updateDescendantClippingLayer(false);
 249     updateOverflowControlsLayers(false, false, false);
 250     updateForegroundLayer(false);
 251     updateBackgroundLayer(false);
 252     updateMaskingLayer(false, false);
 253     updateScrollingLayers(false);
 254 
 255     ASSERT(!m_viewportConstrainedNodeID);
 256     ASSERT(!m_scrollingNodeID);
 257     ASSERT(!m_frameHostingNodeID);
 258     ASSERT(!m_positioningNodeID);
 259 
 260     destroyGraphicsLayers();
 261 }
 262 
 263 void RenderLayerBacking::willBeDestroyed()
 264 {
<span class="line-added"> 265 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added"> 266     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::willBeDestroyed(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added"> 267     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::willBeDestroyed(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added"> 268 #endif</span>
<span class="line-added"> 269 </span>
 270     ASSERT(m_owningLayer.backing() == this);
 271     compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
 272 
 273     clearBackingSharingLayers();
 274 }
 275 
 276 void RenderLayerBacking::willDestroyLayer(const GraphicsLayer* layer)
 277 {
 278     if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
 279         compositor().layerTiledBackingUsageChanged(layer, false);
 280 }
 281 
<span class="line-modified"> 282 static void clearBackingSharingLayerProviders(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; sharingLayers, const RenderLayer&amp; providerLayer)</span>
 283 {
 284     for (auto&amp; layerWeakPtr : sharingLayers) {
 285         if (!layerWeakPtr)
 286             continue;
<span class="line-modified"> 287         if (layerWeakPtr-&gt;backingProviderLayer() == &amp;providerLayer)</span>
<span class="line-added"> 288             layerWeakPtr-&gt;setBackingProviderLayer(nullptr);</span>
 289     }
 290 }
 291 
 292 void RenderLayerBacking::setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp; sharingLayers)
 293 {
 294     bool sharingLayersChanged = m_backingSharingLayers != sharingLayers;
 295     if (sharingLayersChanged) {
 296         // For layers that used to share and no longer do, and are not composited, recompute repaint rects.
 297         for (auto&amp; oldSharingLayer : m_backingSharingLayers) {
 298             // Layers that go from shared to composited have their repaint rects recomputed in RenderLayerCompositor::updateBacking().
 299             // FIXME: Two O(n^2) traversals in this funtion. Probably OK because sharing lists are usually small, but still.
 300             if (!sharingLayers.contains(oldSharingLayer) &amp;&amp; !oldSharingLayer-&gt;isComposited())
 301                 oldSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
 302         }
 303     }
 304 
<span class="line-modified"> 305     clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);</span>
 306 
<span class="line-modified"> 307     if (sharingLayers != m_backingSharingLayers) {</span>
<span class="line-added"> 308         if (sharingLayers.size())</span>
<span class="line-added"> 309             setRequiresOwnBackingStore(true);</span>
 310         setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.
<span class="line-added"> 311     }</span>
 312 
 313     auto oldSharingLayers = WTFMove(m_backingSharingLayers);
 314     m_backingSharingLayers = WTFMove(sharingLayers);
 315 
 316     for (auto&amp; layerWeakPtr : m_backingSharingLayers)
 317         layerWeakPtr-&gt;setBackingProviderLayer(&amp;m_owningLayer);
 318 
 319     if (sharingLayersChanged) {
 320         // For layers that are newly sharing, recompute repaint rects.
 321         for (auto&amp; currentSharingLayer : m_backingSharingLayers) {
 322             if (!oldSharingLayers.contains(currentSharingLayer))
 323                 currentSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
 324         }
 325     }
 326 }
 327 
 328 void RenderLayerBacking::removeBackingSharingLayer(RenderLayer&amp; layer)
 329 {
 330     layer.setBackingProviderLayer(nullptr);
 331     m_backingSharingLayers.removeAll(&amp;layer);
 332 }
 333 
 334 void RenderLayerBacking::clearBackingSharingLayers()
 335 {
<span class="line-modified"> 336     clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);</span>
 337     m_backingSharingLayers.clear();
 338 }
 339 
 340 Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
 341 {
 342     auto* graphicsLayerFactory = renderer().page().chrome().client().graphicsLayerFactory();
 343 
 344     auto graphicsLayer = GraphicsLayer::create(graphicsLayerFactory, *this, layerType);
 345 
 346     graphicsLayer-&gt;setName(name);
 347 
 348 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 349     graphicsLayer-&gt;setAcceleratesDrawing(compositor().acceleratedDrawingEnabled());
 350     graphicsLayer-&gt;setUsesDisplayListDrawing(compositor().displayListDrawingEnabled());
 351 #endif
 352 
 353     return graphicsLayer;
 354 }
 355 
 356 void RenderLayerBacking::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
</pre>
<hr />
<pre>
 691 #endif
 692 
 693     if (m_isFrameLayerWithTiledBacking)
 694         return false;
 695 
 696     if (layerOrAncestorIsTransformedOrUsingCompositedScrolling(m_owningLayer))
 697         return false;
 698 
 699     return true;
 700 }
 701 
 702 static bool hasNonZeroTransformOrigin(const RenderObject&amp; renderer)
 703 {
 704     const RenderStyle&amp; style = renderer.style();
 705     return (style.transformOriginX().type() == Fixed &amp;&amp; style.transformOriginX().value())
 706         || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
 707 }
 708 
 709 bool RenderLayerBacking::updateCompositedBounds()
 710 {
<span class="line-added"> 711 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added"> 712     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateCompositedBounds(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added"> 713     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateCompositedBounds(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added"> 714 #endif</span>
<span class="line-added"> 715 </span>
 716     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, { }, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);
 717     // Clip to the size of the document or enclosing overflow-scroll layer.
 718     // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
 719     // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
 720     if (shouldClipCompositedBounds()) {
 721         auto&amp; view = renderer().view();
 722         auto* rootLayer = view.layer();
 723 
 724         LayoutRect clippingBounds;
 725         if (renderer().isFixedPositioned() &amp;&amp; renderer().container() == &amp;view)
 726             clippingBounds = view.frameView().rectForFixedPositionLayout();
 727         else
 728             clippingBounds = view.unscaledDocumentRect();
 729 
 730         if (&amp;m_owningLayer != rootLayer)
 731             clippingBounds.intersect(m_owningLayer.backgroundClipRect(RenderLayer::ClipRectsContext(rootLayer, AbsoluteClipRects)).rect()); // FIXME: Incorrect for CSS regions.
 732 
 733         LayoutPoint delta = m_owningLayer.convertToLayerCoords(rootLayer, LayoutPoint(), RenderLayer::AdjustForColumns);
 734         clippingBounds.move(-delta.x(), -delta.y());
 735 
</pre>
<hr />
<pre>
 787         fixedLayoutRect = frameView.rectForFixedPositionLayout();
 788 
 789     bool allowDetaching = !fixedLayoutRect.intersects(absoluteBounds);
 790     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerBacking (layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot;) updateAllowsBackingStoreDetaching - absoluteBounds &quot; &lt;&lt; absoluteBounds &lt;&lt; &quot; layoutViewportRect &quot; &lt;&lt; fixedLayoutRect &lt;&lt; &quot;, allowDetaching &quot; &lt;&lt; allowDetaching);
 791     setAllowsBackingStoreDetaching(allowDetaching);
 792 }
 793 
 794 void RenderLayerBacking::updateAfterWidgetResize()
 795 {
 796     if (!is&lt;RenderWidget&gt;(renderer()))
 797         return;
 798 
 799     if (auto* innerCompositor = RenderLayerCompositor::frameContentsCompositor(downcast&lt;RenderWidget&gt;(renderer()))) {
 800         innerCompositor-&gt;frameViewDidChangeSize();
 801         innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
 802     }
 803 }
 804 
 805 void RenderLayerBacking::updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint)
 806 {
<span class="line-added"> 807 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added"> 808     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateAfterLayout(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added"> 809     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateAfterLayout(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added"> 810 #endif</span>
<span class="line-added"> 811 </span>
 812     LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
 813 
 814     // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
 815     // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
 816     // take overflow into account.
 817     if (updateCompositedBounds()) {
 818         m_owningLayer.setNeedsCompositingGeometryUpdate();
 819         // This layer&#39;s geometry affects those of its children.
 820         m_owningLayer.setChildrenNeedCompositingGeometryUpdate();
 821     } else if (needsClippingUpdate) {
 822         m_owningLayer.setNeedsCompositingConfigurationUpdate();
 823         m_owningLayer.setNeedsCompositingGeometryUpdate();
 824     }
 825 
 826     if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
 827         setContentsNeedDisplay();
 828 }
 829 
 830 // This can only update things that don&#39;t require up-to-date layout.
 831 void RenderLayerBacking::updateConfigurationAfterStyleChange()
</pre>
<hr />
<pre>
 837             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 838             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 839         }
 840     } else
 841         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 842 
 843     // FIXME: do we care if opacity is animating?
 844     auto&amp; style = renderer().style();
 845     updateOpacity(style);
 846     updateFilters(style);
 847 
 848 #if ENABLE(FILTERS_LEVEL_2)
 849     updateBackdropFilters(style);
 850 #endif
 851 #if ENABLE(CSS_COMPOSITING)
 852     updateBlendMode(style);
 853 #endif
 854     updateCustomAppearance(style);
 855 }
 856 
<span class="line-modified"> 857 bool RenderLayerBacking::updateConfiguration(const RenderLayer* compositingAncestor)</span>
 858 {
 859     ASSERT(!m_owningLayer.normalFlowListDirty());
 860     ASSERT(!m_owningLayer.zOrderListsDirty());
 861     ASSERT(!renderer().view().needsLayout());
 862 
 863     bool layerConfigChanged = false;
 864     auto&amp; compositor = this-&gt;compositor();
 865 
 866     setBackgroundLayerPaintsFixedRootBackground(compositor.needsFixedRootBackgroundLayer(m_owningLayer));
 867 
 868     if (updateBackgroundLayer(m_backgroundLayerPaintsFixedRootBackground || m_requiresBackgroundLayer))
 869         layerConfigChanged = true;
 870 
 871     if (updateForegroundLayer(compositor.needsContentsCompositingLayer(m_owningLayer)))
 872         layerConfigChanged = true;
 873 
 874     bool needsDescendantsClippingLayer = false;
 875     bool usesCompositedScrolling = m_owningLayer.hasCompositedScrollableOverflow();
 876 
 877     if (usesCompositedScrolling) {
 878         // If it&#39;s scrollable, it has to be a box.
 879         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 880         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 881         needsDescendantsClippingLayer = contentsClippingRect.isRounded();
 882     } else
 883         needsDescendantsClippingLayer = RenderLayerCompositor::clipsCompositingDescendants(m_owningLayer);
 884 
 885     if (updateScrollingLayers(usesCompositedScrolling))
 886         layerConfigChanged = true;
 887 
 888     if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
 889         layerConfigChanged = true;
 890 
<span class="line-modified"> 891     ASSERT(compositingAncestor == m_owningLayer.ancestorCompositingLayer());</span>
 892     if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))
 893         layerConfigChanged = true;
 894 
 895     if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
 896         layerConfigChanged = true;
 897 
 898     if (layerConfigChanged)
 899         updateInternalHierarchy();
 900 
 901     if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
 902         if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
 903             m_graphicsLayer-&gt;addChild(*flatteningLayer);
 904     }
 905 
 906     if (updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath()))
 907         layerConfigChanged = true;
 908 
 909     updateChildClippingStrategy(needsDescendantsClippingLayer);
 910 
 911     if (m_owningLayer.hasReflection()) {
</pre>
<hr />
<pre>
 957 
 958         layerConfigChanged = true;
 959     }
 960 #endif
 961     if (is&lt;RenderWidget&gt;(renderer()) &amp;&amp; compositor.parentFrameContentLayers(downcast&lt;RenderWidget&gt;(renderer()))) {
 962         m_owningLayer.setNeedsCompositingGeometryUpdate();
 963         layerConfigChanged = true;
 964     }
 965 
 966     if (is&lt;RenderImage&gt;(renderer()) &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage()) {
 967         auto element = renderer().element();
 968         if (is&lt;HTMLImageElement&gt;(element)) {
 969             m_graphicsLayer-&gt;setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType::EditableImage, downcast&lt;HTMLImageElement&gt;(element)-&gt;editableImageViewID());
 970             layerConfigChanged = true;
 971         }
 972     }
 973 
 974     if (layerConfigChanged)
 975         updatePaintingPhases();
 976 
<span class="line-added"> 977 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added"> 978     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateConfiguration(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added"> 979     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateConfiguration(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added"> 980 #endif</span>
<span class="line-added"> 981 </span>
 982     return layerConfigChanged;
 983 }
 984 
 985 static LayoutRect clipBox(RenderBox&amp; renderer)
 986 {
 987     LayoutRect result = LayoutRect::infiniteRect();
 988     if (renderer.hasOverflowClip())
 989         result = renderer.overflowClipRect(LayoutPoint(), 0); // FIXME: Incorrect for CSS regions.
 990 
 991     if (renderer.hasClip())
 992         result.intersect(renderer.clipRect(LayoutPoint(), 0)); // FIXME: Incorrect for CSS regions.
 993 
 994     return result;
 995 }
 996 
 997 static bool subpixelOffsetFromRendererChanged(const LayoutSize&amp; oldSubpixelOffsetFromRenderer, const LayoutSize&amp; newSubpixelOffsetFromRenderer, float deviceScaleFactor)
 998 {
 999     FloatSize previous = snapSizeToDevicePixel(oldSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
1000     FloatSize current = snapSizeToDevicePixel(newSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
1001     return previous != current;
</pre>
<hr />
<pre>
1037     snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
1038     return snappedGraphicsLayer;
1039 }
1040 
1041 static LayoutSize computeOffsetFromAncestorGraphicsLayer(const RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)
1042 {
1043     if (!compositedAncestor)
1044         return toLayoutSize(location);
1045 
1046     // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
1047     // could be stale when a dynamic composited state change triggers a pre-order updateGeometry() traversal.
1048     LayoutSize ancestorSubpixelOffsetFromRenderer = compositedAncestor-&gt;backing()-&gt;subpixelOffsetFromRenderer();
1049     LayoutRect ancestorCompositedBounds = compositedAncestor-&gt;backing()-&gt;compositedBounds();
1050     LayoutSize floored = toLayoutSize(LayoutPoint(floorPointToDevicePixels(ancestorCompositedBounds.location() - ancestorSubpixelOffsetFromRenderer, deviceScaleFactor)));
1051     LayoutSize ancestorRendererOffsetFromAncestorGraphicsLayer = -(floored + ancestorSubpixelOffsetFromRenderer);
1052     return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
1053 }
1054 
1055 class ComputedOffsets {
1056 public:
<span class="line-modified">1057     ComputedOffsets(const RenderLayer&amp; renderLayer, const RenderLayer* compositingAncestor, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)</span>
1058         : m_renderLayer(renderLayer)
<span class="line-added">1059         , m_compositingAncestor(compositingAncestor)</span>
1060         , m_location(localRect.location())
1061         , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
1062         , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
1063         , m_deviceScaleFactor(renderLayer.renderer().document().deviceScaleFactor())
1064     {
1065     }
1066 
1067     LayoutSize fromParentGraphicsLayer()
1068     {
1069         if (!m_fromParentGraphicsLayer)
1070             m_fromParentGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset;
1071         return m_fromParentGraphicsLayer.value();
1072     }
1073 
1074     LayoutSize fromPrimaryGraphicsLayer()
1075     {
1076         if (!m_fromPrimaryGraphicsLayer)
1077             m_fromPrimaryGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset - m_primaryGraphicsLayerOffset;
1078         return m_fromPrimaryGraphicsLayer.value();
1079     }
1080 
1081 private:
1082     LayoutSize fromAncestorGraphicsLayer()
1083     {
1084         if (!m_fromAncestorGraphicsLayer) {
<span class="line-modified">1085             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(m_compositingAncestor, m_location, RenderLayer::AdjustForColumns);</span>
<span class="line-modified">1086             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(m_compositingAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);</span>

1087         }
1088         return m_fromAncestorGraphicsLayer.value();
1089     }
1090 
1091     Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
1092     Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
1093     Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
1094 
1095     const RenderLayer&amp; m_renderLayer;
<span class="line-added">1096     const RenderLayer* m_compositingAncestor;</span>
1097     // Location is relative to the renderer.
1098     const LayoutPoint m_location;
1099     const LayoutSize m_parentGraphicsLayerOffset;
1100     const LayoutSize m_primaryGraphicsLayerOffset;
1101     float m_deviceScaleFactor;
1102 };
1103 
<span class="line-modified">1104 LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const RenderLayer* compositedAncestor, const LayoutRect&amp; parentGraphicsLayerRect) const</span>
1105 {
<span class="line-modified">1106     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, { });</span>
1107     return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
1108         deviceScaleFactor()));
1109 }
1110 
1111 // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
1112 LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const
1113 {
1114     if (!compositedAncestor || !compositedAncestor-&gt;backing())
1115         return renderer().view().documentRect();
1116 
1117     auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
1118     LayoutRect parentGraphicsLayerRect;
1119     if (m_owningLayer.isInsideFragmentedFlow()) {
1120         // FIXME: flows/columns need work.
1121         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1122         ancestorCompositedBounds.setLocation(LayoutPoint());
1123         parentGraphicsLayerRect = ancestorCompositedBounds;
1124     }
1125 
1126     if (ancestorBackingLayer-&gt;hasClippingLayer()) {
1127         // If the compositing ancestor has a layer to clip children, we parent in that, and therefore position relative to it.
1128         LayoutRect clippingBox = clipBox(downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer()));
1129         LayoutSize clippingBoxOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clippingBox.location(), deviceScaleFactor());
1130         parentGraphicsLayerRect = snappedGraphicsLayer(clippingBoxOffset, clippingBox.size(), deviceScaleFactor()).m_snappedRect;
1131     }
1132 
1133     if (compositedAncestor-&gt;hasCompositedScrollableOverflow()) {
1134         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1135         auto&amp; renderBox = downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer());
1136         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();
1137         ScrollOffset scrollOffset = compositedAncestor-&gt;scrollOffset();
1138         parentGraphicsLayerRect = LayoutRect((paddingBoxIncludingScrollbar.location() - toLayoutSize(ancestorCompositedBounds.location()) - toLayoutSize(scrollOffset)), paddingBoxIncludingScrollbar.size());
1139     }
1140 
1141     return parentGraphicsLayerRect;
1142 }
1143 
<span class="line-modified">1144 void RenderLayerBacking::updateGeometry(const RenderLayer* compositedAncestor)</span>
1145 {
1146     ASSERT(!m_owningLayer.normalFlowListDirty());
1147     ASSERT(!m_owningLayer.zOrderListsDirty());
1148     ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
1149     ASSERT(!renderer().view().needsLayout());
1150 
1151     const RenderStyle&amp; style = renderer().style();
1152 
1153     bool isRunningAcceleratedTransformAnimation = false;
1154     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1155         if (auto* timeline = renderer().documentTimeline())
1156             isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
1157     } else
1158         isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
1159 
1160     updateTransform(style);
1161     updateOpacity(style);
1162     updateFilters(style);
1163 #if ENABLE(FILTERS_LEVEL_2)
1164     updateBackdropFilters(style);
1165 #endif
1166 #if ENABLE(CSS_COMPOSITING)
1167     updateBlendMode(style);
1168 #endif
1169 
<span class="line-modified">1170     ASSERT(compositedAncestor == m_owningLayer.ancestorCompositingLayer());</span>
1171     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);
1172 
1173     if (m_ancestorClippingStack) {
1174         // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.
1175         auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));
1176         LayoutRect lastClipLayerRect = parentGraphicsLayerRect;
1177 
1178         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {
1179             auto clipRect = entry.clipData.clipRect;
1180             LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clipRect.location() + offsetFromCompositedAncestor, deviceScaleFactor());
1181             LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, clipRect.size(), deviceScaleFactor()).m_snappedRect;
1182 
1183             entry.clippingLayer-&gt;setPosition(toLayoutPoint(snappedClippingLayerRect.location() - lastClipLayerRect.location()));
1184             lastClipLayerRect = snappedClippingLayerRect;
1185 
1186             entry.clippingLayer-&gt;setSize(snappedClippingLayerRect.size());
1187 
1188             if (entry.clipData.isOverflowScroll) {
1189                 ScrollOffset scrollOffset = entry.clipData.clippingLayer-&gt;scrollOffset();
1190 
1191                 entry.clippingLayer-&gt;setBoundsOrigin(scrollOffset);
1192                 lastClipLayerRect.moveBy(-scrollOffset);
1193             } else
1194                 entry.clippingLayer-&gt;setBoundsOrigin({ });
1195         }
1196 
1197         parentGraphicsLayerRect = lastClipLayerRect;
1198     }
1199 
<span class="line-modified">1200     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(compositedAncestor, parentGraphicsLayerRect);</span>
1201 
<span class="line-modified">1202     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-modified">1203     ComputedOffsets rendererOffset(m_owningLayer, compositedAncestor, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
1204 
1205     m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
1206 
1207     auto primaryLayerPosition = primaryGraphicsLayerRect.location();
1208 
1209     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959
1210     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();
1211     if (m_contentsContainmentLayer) {
1212         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);
1213         m_contentsContainmentLayer-&gt;setPosition(primaryLayerPosition);
1214         primaryLayerPosition = { };
1215         // Use the same size as m_graphicsLayer so transforms behave correctly.
1216         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());
1217     }
1218 
1219     auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
1220         LayoutRect animatedBounds;
1221         if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
1222             return FloatRect(animatedBounds);
1223         return { };
</pre>
<hr />
<pre>
1293             if (clipLayer) {
1294                 clipLayer-&gt;setChildrenTransform(t);
1295                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1296             }
1297             else
1298                 m_graphicsLayer-&gt;setChildrenTransform(t);
1299         } else {
1300             if (clipLayer)
1301                 clipLayer-&gt;setChildrenTransform(TransformationMatrix());
1302             else
1303                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1304         }
1305     } else {
1306         m_graphicsLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1307         if (m_contentsContainmentLayer)
1308             m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1309     }
1310 
1311     if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
1312         auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
<span class="line-modified">1313         reflectionBacking-&gt;updateGeometry(&amp;m_owningLayer);</span>
1314 
1315         // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
1316         // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
1317         FloatRect layerBounds = this-&gt;compositedBounds();
1318         FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
1319         reflectionBacking-&gt;graphicsLayer()-&gt;setReplicatedLayerPosition(FloatPoint(layerBounds.location() - reflectionLayerBounds.location()));
1320     }
1321 
1322     if (m_scrollContainerLayer) {
1323         ASSERT(m_scrolledContentsLayer);
1324         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
1325         LayoutRect paddingBox = renderBox.paddingBoxRect();
1326         LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
1327 
1328         // FIXME: need to do some pixel snapping here.
1329         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBox.location() - parentLayerBounds.location()));
1330         m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
1331 
1332         ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
1333         updateScrollOffset(scrollOffset);
</pre>
<hr />
<pre>
1439     if (!m_owningLayer.isRenderViewLayer()) {
1440         bool didUpdateContentsRect = false;
1441         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
1442         if (!didUpdateContentsRect &amp;&amp; m_graphicsLayer-&gt;usesContentsLayer())
1443             resetContentsRect();
1444     }
1445 
1446     updateDrawsContent(contentsInfo);
1447 
1448     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {
1449         // For non-root layers, background is always painted by the primary graphics layer.
1450         ASSERT(!m_backgroundLayer);
1451         m_graphicsLayer-&gt;setContentsOpaque(!m_hasSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));
1452     }
1453 
1454     m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
1455     if (m_scrollContainerLayer) {
1456         m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
1457         m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
1458     }
<span class="line-added">1459 </span>
<span class="line-added">1460 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">1461     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateAfterDescendants(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">1462     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateAfterDescendants(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">1463 #endif</span>
1464 }
1465 
1466 // FIXME: Avoid repaints when clip path changes.
1467 void RenderLayerBacking::updateMaskingLayerGeometry()
1468 {
1469     m_maskLayer-&gt;setSize(m_graphicsLayer-&gt;size());
1470     m_maskLayer-&gt;setPosition(FloatPoint());
1471     m_maskLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());
1472 
1473     if (!m_maskLayer-&gt;drawsContent()) {
1474         if (renderer().hasClipPath()) {
1475             ASSERT(renderer().style().clipPath()-&gt;type() != ClipPathOperation::Reference);
1476 
1477             WindRule windRule;
1478             // FIXME: Use correct reference box for inlines: https://bugs.webkit.org/show_bug.cgi?id=129047
1479             LayoutRect boundingBox = m_owningLayer.boundingBox(&amp;m_owningLayer);
1480             LayoutRect referenceBoxForClippedInline = LayoutRect(snapRectToDevicePixels(boundingBox, deviceScaleFactor()));
1481             LayoutSize offset = LayoutSize(snapSizeToDevicePixel(-m_subpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor()));
1482             Path clipPath = m_owningLayer.computeClipPath(offset, referenceBoxForClippedInline, windRule);
1483 
</pre>
<hr />
<pre>
1608     } else
1609         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1610 
1611     if (m_backgroundLayer)
1612         m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
1613 }
1614 
1615 void RenderLayerBacking::updateEventRegion()
1616 {
1617 #if PLATFORM(IOS_FAMILY)
1618     if (paintsIntoCompositedAncestor())
1619         return;
1620 
1621     bool hasTouchActionElements = false;
1622 #if ENABLE(POINTER_EVENTS)
1623     hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();
1624 #endif
1625     if (m_owningLayer.isRenderViewLayer() &amp;&amp; !hasTouchActionElements)
1626         return;
1627 
<span class="line-modified">1628     auto updateEventRegionForLayer = [&amp;](GraphicsLayer&amp; graphicsLayer) {</span>
<span class="line-modified">1629         GraphicsContext nullContext(nullptr);</span>
<span class="line-added">1630         EventRegion eventRegion;</span>
<span class="line-added">1631         auto eventRegionContext = eventRegion.makeContext();</span>
<span class="line-added">1632         auto layerOffset = graphicsLayer.scrollOffset() - roundedIntSize(graphicsLayer.offsetFromRenderer());</span>
1633 
<span class="line-modified">1634         if (&amp;graphicsLayer == m_scrolledContentsLayer &amp;&amp; renderer().visibleToHitTesting()) {</span>
<span class="line-modified">1635             // Initialize scrolled contents layer with layer-sized event region as it can all used for scrolling.</span>
<span class="line-modified">1636             // This avoids generating unnecessarily complex event regions. We still need to to do the paint to capture touch-action regions.</span>
<span class="line-added">1637             eventRegionContext.unite(enclosingIntRect(FloatRect(-layerOffset, graphicsLayer.size())), RenderStyle::defaultStyle());</span>
<span class="line-added">1638         }</span>
1639 
<span class="line-modified">1640         auto dirtyRect = enclosingIntRect(FloatRect(FloatPoint(graphicsLayer.offsetFromRenderer()), graphicsLayer.size()));</span>
<span class="line-modified">1641         paintIntoLayer(&amp;graphicsLayer, nullContext, dirtyRect, { }, &amp;eventRegionContext);</span>
1642 
<span class="line-modified">1643         eventRegion.translate(toIntSize(layerOffset));</span>

1644 
<span class="line-modified">1645         graphicsLayer.setEventRegion(WTFMove(eventRegion));</span>
<span class="line-added">1646     };</span>
1647 
<span class="line-modified">1648     updateEventRegionForLayer(*m_graphicsLayer);</span>

1649 
<span class="line-modified">1650     if (m_scrolledContentsLayer)</span>
<span class="line-added">1651         updateEventRegionForLayer(*m_scrolledContentsLayer);</span>
1652 #endif
1653 }
1654 
1655 bool RenderLayerBacking::updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp; clippingData)
1656 {
1657     if (!m_ancestorClippingStack &amp;&amp; clippingData.isEmpty())
1658         return false;
1659 
1660     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
1661 
1662     if (m_ancestorClippingStack &amp;&amp; clippingData.isEmpty()) {
1663         m_ancestorClippingStack-&gt;clear(scrollingCoordinator);
1664         m_ancestorClippingStack = nullptr;
1665         return true;
1666     }
1667 
1668     if (!m_ancestorClippingStack) {
1669         m_ancestorClippingStack = makeUnique&lt;LayerAncestorClippingStack&gt;(WTFMove(clippingData));
1670         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);
1671         return true;
</pre>
<hr />
<pre>
1953             // We need a geometry update to size the new mask layer.
1954             m_owningLayer.setNeedsCompositingGeometryUpdate();
1955         }
1956     } else if (m_maskLayer) {
1957         m_graphicsLayer-&gt;setMaskLayer(nullptr);
1958         willDestroyLayer(m_maskLayer.get());
1959         GraphicsLayer::clear(m_maskLayer);
1960         layerChanged = true;
1961     }
1962 
1963     return layerChanged;
1964 }
1965 
1966 void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
1967 {
1968     if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
1969         if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
1970             auto* clipLayer = clippingLayer();
1971             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
1972             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">1973             contentsClippingRect.move(LayoutSize(-clipLayer-&gt;offsetFromRenderer()));</span>
1974             // Note that we have to set this rounded rect again during the geometry update (clipLayer-&gt;offsetFromRenderer() may be stale here).
1975             if (clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect)) {
1976                 clipLayer-&gt;setMaskLayer(nullptr);
1977                 GraphicsLayer::clear(m_childClippingMaskLayer);
1978                 return;
1979             }
1980 
1981             if (!m_childClippingMaskLayer) {
1982                 m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
1983                 m_childClippingMaskLayer-&gt;setDrawsContent(true);
1984                 m_childClippingMaskLayer-&gt;setPaintingPhase({ GraphicsLayerPaintingPhase::ChildClippingMask });
1985                 clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
1986             }
1987         }
1988     } else {
1989         if (m_childClippingMaskLayer) {
1990             if (hasClippingLayer())
1991                 clippingLayer()-&gt;setMaskLayer(nullptr);
1992             GraphicsLayer::clear(m_childClippingMaskLayer);
1993         } else
</pre>
<hr />
<pre>
2119     if (!GraphicsLayer::supportsContentsTiling())
2120         return false;
2121 
2122     auto&amp; fillLayer = style.backgroundLayers();
2123     if (fillLayer.next())
2124         return false;
2125 
2126     if (!fillLayer.imagesAreLoaded())
2127         return false;
2128 
2129     if (fillLayer.attachment() != FillAttachment::ScrollBackground)
2130         return false;
2131 
2132     // FIXME: Allow color+image compositing when it makes sense.
2133     // For now bailing out.
2134     if (style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isVisible())
2135         return false;
2136 
2137     // FIXME: support gradients with isGeneratedImage.
2138     auto* styleImage = fillLayer.image();
<span class="line-modified">2139     if (!styleImage-&gt;hasCachedImage())</span>
2140         return false;
2141 
2142     auto* image = styleImage-&gt;cachedImage()-&gt;image();
2143     if (!image-&gt;isBitmapImage())
2144         return false;
2145 
2146     return true;
2147 }
2148 
2149 static bool hasPaintedBoxDecorationsOrBackgroundImage(const RenderStyle&amp; style)
2150 {
2151     if (hasVisibleBoxDecorations(style))
2152         return true;
2153 
2154     if (!style.hasBackgroundImage())
2155         return false;
2156 
2157     return !canDirectlyCompositeBackgroundBackgroundImage(style);
2158 }
2159 
</pre>
<hr />
<pre>
2292 {
2293     if (!GraphicsLayer::supportsBackgroundColorContent())
2294         return false;
2295 
2296     const RenderStyle&amp; style = renderer.style();
2297     if (renderer.hasClip())
2298         return false;
2299 
2300     if (hasPaintedBoxDecorationsOrBackgroundImage(style))
2301         return false;
2302 
2303     // FIXME: We can&#39;t create a directly composited background if this
2304     // layer will have children that intersect with the background layer.
2305     // A better solution might be to introduce a flattening layer if
2306     // we do direct box decoration composition.
2307     // https://bugs.webkit.org/show_bug.cgi?id=119461
2308     if (hasPerspectiveOrPreserves3D(style))
2309         return false;
2310 
2311     // FIXME: we should be able to allow backgroundComposite; However since this is not a common use case it has been deferred for now.
<span class="line-modified">2312     if (style.backgroundComposite() != CompositeOperator::SourceOver)</span>
2313         return false;
2314 
2315     return true;
2316 }
2317 
2318 bool RenderLayerBacking::paintsBoxDecorations() const
2319 {
2320     if (!m_owningLayer.hasVisibleBoxDecorations())
2321         return false;
2322 
2323     return !supportsDirectlyCompositedBoxDecorations(renderer());
2324 }
2325 
2326 bool RenderLayerBacking::paintsContent(RenderLayer::PaintedContentRequest&amp; request) const
2327 {
2328     m_owningLayer.updateDescendantDependentFlags();
2329 
2330     bool paintsContent = false;
2331 
2332     if (m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasNonEmptyChildRenderers(request))
</pre>
<hr />
<pre>
2387     if (contentsInfo.paintsBoxDecorations() || contentsInfo.paintsContent())
2388         return false;
2389 
2390     if (renderer().style().backgroundClip() == FillBox::Text)
2391         return false;
2392 
2393     if (renderer().isDocumentElementRenderer() &amp;&amp; m_owningLayer.isolatesCompositedBlending())
2394         return false;
2395 
2396     return true;
2397 }
2398 
2399 // Returning true stops the traversal.
2400 enum class LayerTraversal { Continue, Stop };
2401 
2402 static LayerTraversal traverseVisibleNonCompositedDescendantLayers(RenderLayer&amp; parent, const WTF::Function&lt;LayerTraversal (const RenderLayer&amp;)&gt;&amp; layerFunc)
2403 {
2404     // FIXME: We shouldn&#39;t be called with a stale z-order lists. See bug 85512.
2405     parent.updateLayerListsIfNeeded();
2406 
<span class="line-modified">2407 #if ASSERT_ENABLED</span>
2408     LayerListMutationDetector mutationChecker(parent);
2409 #endif
2410 
2411     for (auto* childLayer : parent.normalFlowLayers()) {
2412         if (compositedWithOwnBackingStore(*childLayer))
2413             continue;
2414 
2415         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2416             return LayerTraversal::Stop;
2417 
2418         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2419             return LayerTraversal::Stop;
2420     }
2421 
2422     if (parent.isStackingContext() &amp;&amp; !parent.hasVisibleDescendant())
2423         return LayerTraversal::Continue;
2424 
2425     // Use the m_hasCompositingDescendant bit to optimize?
2426     for (auto* childLayer : parent.negativeZOrderLayers()) {
2427         if (compositedWithOwnBackingStore(*childLayer))
</pre>
<hr />
<pre>
2797         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2798         layerDirtyRect.move(-m_maskLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2799         m_maskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2800     }
2801 
2802     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent()) {
2803         FloatRect layerDirtyRect = r;
2804         layerDirtyRect.move(-m_childClippingMaskLayer-&gt;offsetFromRenderer());
2805         m_childClippingMaskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect);
2806     }
2807 
2808     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
2809         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2810         layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);
2811         m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2812     }
2813 }
2814 
2815 void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
2816     const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">2817     OptionSet&lt;PaintBehavior&gt; paintBehavior, EventRegionContext* eventRegionContext)</span>
2818 {
<span class="line-modified">2819 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">2820     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::paintIntoLayer(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">2821     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::paintIntoLayer(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">2822 #endif</span>
<span class="line-added">2823 </span>
<span class="line-added">2824     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; graphicsLayer-&gt;paintingPhase() != OptionSet&lt;GraphicsLayerPaintingPhase&gt;(GraphicsLayerPaintingPhase::ChildClippingMask)) {</span>
2825 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
2826         // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
<span class="line-modified">2827         // when pages are restored from the BackForwardCache.</span>
<span class="line-modified">2828         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in BackForwardCache</span>
2829         ASSERT_NOT_REACHED();
2830 #endif
2831         return;
2832     }
2833 
<span class="line-modified">2834     auto paintFlags = paintFlagsForLayer(*graphicsLayer);</span>














2835 
<span class="line-modified">2836     if (eventRegionContext)</span>
<span class="line-modified">2837         paintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);</span>


2838 
2839 #ifndef NDEBUG
2840     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
2841 #endif
2842 
2843     auto paintOneLayer = [&amp;](RenderLayer&amp; layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags) {


2844         FrameView::PaintingState paintingState;
<span class="line-modified">2845         if (!eventRegionContext) {</span>
<span class="line-modified">2846             InspectorInstrumentation::willPaint(layer.renderer());</span>
<span class="line-added">2847 </span>
<span class="line-added">2848             if (layer.isRenderViewLayer())</span>
<span class="line-added">2849                 renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
<span class="line-added">2850         }</span>
2851 
2852         RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);
<span class="line-added">2853         paintingInfo.eventRegionContext = eventRegionContext;</span>
2854 
2855         if (&amp;layer == &amp;m_owningLayer) {
2856             layer.paintLayerContents(context, paintingInfo, paintFlags);
2857 
<span class="line-modified">2858             if (layer.containsDirtyOverlayScrollbars() &amp;&amp; !eventRegionContext)</span>
2859                 layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);
2860         } else
2861             layer.paintLayerWithEffects(context, paintingInfo, paintFlags);
2862 
<span class="line-modified">2863         if (!eventRegionContext) {</span>
<span class="line-modified">2864             if (layer.isRenderViewLayer())</span>
<span class="line-added">2865                 renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>
2866 
<span class="line-modified">2867             InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);</span>
<span class="line-added">2868         }</span>
2869 
<span class="line-modified">2870         ASSERT(!m_owningLayer.m_usedTransparency);</span>
2871     };
2872 
2873     paintOneLayer(m_owningLayer, paintFlags);
2874 
2875     // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.
2876     GraphicsLayer* destinationForSharingLayers = m_scrolledContentsLayer ? m_scrolledContentsLayer.get() : m_graphicsLayer.get();
2877 
2878     if (graphicsLayer == destinationForSharingLayers) {
2879         OptionSet&lt;RenderLayer::PaintLayerFlag&gt; sharingLayerPaintFlags = {
2880             RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,
2881             RenderLayer::PaintLayerPaintingCompositingForegroundPhase };
2882 
<span class="line-modified">2883         if (graphicsLayer-&gt;paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
2884             sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
<span class="line-added">2885         if (eventRegionContext)</span>
<span class="line-added">2886             sharingLayerPaintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);</span>
2887 
2888         for (auto&amp; layerWeakPtr : m_backingSharingLayers)
2889             paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);
2890     }
2891 
<span class="line-modified">2892     if (!eventRegionContext)</span>
<span class="line-added">2893         compositor().didPaintBacking(this);</span>
<span class="line-added">2894 </span>
<span class="line-added">2895 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">2896     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::paintIntoLayer() end: m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">2897     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::paintIntoLayer() end: m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">2898 #endif</span>
<span class="line-added">2899 }</span>
<span class="line-added">2900 </span>
<span class="line-added">2901 OptionSet&lt;RenderLayer::PaintLayerFlag&gt; RenderLayerBacking::paintFlagsForLayer(const GraphicsLayer&amp; graphicsLayer) const</span>
<span class="line-added">2902 {</span>
<span class="line-added">2903     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;</span>
<span class="line-added">2904 </span>
<span class="line-added">2905     auto paintingPhase = graphicsLayer.paintingPhase();</span>
<span class="line-added">2906     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))</span>
<span class="line-added">2907         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);</span>
<span class="line-added">2908     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))</span>
<span class="line-added">2909         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);</span>
<span class="line-added">2910     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))</span>
<span class="line-added">2911         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);</span>
<span class="line-added">2912     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))</span>
<span class="line-added">2913         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);</span>
<span class="line-added">2914     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))</span>
<span class="line-added">2915         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);</span>
<span class="line-added">2916     if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
<span class="line-added">2917         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);</span>
<span class="line-added">2918     if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))</span>
<span class="line-added">2919         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);</span>
<span class="line-added">2920 </span>
<span class="line-added">2921     if (&amp;graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)</span>
<span class="line-added">2922         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.</span>
<span class="line-added">2923     else if (compositor().fixedRootBackgroundLayer())</span>
<span class="line-added">2924         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);</span>
<span class="line-added">2925 </span>
<span class="line-added">2926     return paintFlags;</span>
2927 }
2928 
2929 #if ENABLE(POINTER_EVENTS)
2930 static RefPtr&lt;Pattern&gt; patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext&amp; destContext)
2931 {
2932     auto toIndex = [](TouchAction touchAction) -&gt; unsigned {
2933         switch (touchAction) {
2934         case TouchAction::None:
2935             return 1;
2936         case TouchAction::Manipulation:
2937             return 2;
2938         case TouchAction::PanX:
2939             return 3;
2940         case TouchAction::PanY:
2941             return 4;
2942         case TouchAction::PinchZoom:
2943             return 5;
2944         case TouchAction::Auto:
2945             break;
2946         }
</pre>
<hr />
<pre>
2950     struct TouchActionAndRGB {
2951         TouchAction action;
2952         ASCIILiteral name;
2953         FloatSize phase;
2954     };
2955     static const TouchActionAndRGB actionsAndColors[] = {
2956         { TouchAction::Auto, &quot;auto&quot;_s, { } },
2957         { TouchAction::None, &quot;none&quot;_s, { } },
2958         { TouchAction::Manipulation, &quot;manip&quot;_s, { } },
2959         { TouchAction::PanX, &quot;pan-x&quot;_s, { } },
2960         { TouchAction::PanY, &quot;pan-y&quot;_s, { 0, 9 } },
2961         { TouchAction::PinchZoom, &quot;p-z&quot;_s, { 16, 4.5 } },
2962     };
2963 
2964     auto actionIndex = toIndex(touchAction);
2965     if (!actionIndex || actionIndex &gt;= ARRAY_SIZE(actionsAndColors))
2966         return nullptr;
2967 
2968     const FloatSize tileSize { 32, 18 };
2969 
<span class="line-modified">2970     auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpace::SRGB, destContext);</span>
2971     if (!imageBuffer)
2972         return nullptr;
2973 
2974     const auto&amp; touchActionData = actionsAndColors[actionIndex];
2975     {
2976         GraphicsContext&amp; imageContext = imageBuffer-&gt;context();
2977 
2978         FontCascadeDescription fontDescription;
2979         fontDescription.setOneFamily(&quot;Helvetica&quot;);
2980         fontDescription.setSpecifiedSize(10);
2981         fontDescription.setComputedSize(10);
2982         fontDescription.setWeight(FontSelectionValue(500));
2983         FontCascade font(WTFMove(fontDescription), 0, 0);
2984         font.update(nullptr);
2985 
2986         TextRun textRun = TextRun(touchActionData.name);
2987         imageContext.setFillColor(Color(0, 0, 0, 128));
2988 
2989         constexpr float textGap = 4;
2990         constexpr float yOffset = 12;
</pre>
<hr />
<pre>
3029         TouchAction::PinchZoom,
3030     };
3031 
3032     for (auto action : touchActionList) {
3033         auto* actionRegion = graphicsLayer-&gt;eventRegion().regionForTouchAction(action);
3034         if (!actionRegion)
3035             continue;
3036 
3037         auto fillPattern = patternForTouchAction(action, contentOffsetInCompositingLayer(), context);
3038         if (!fillPattern)
3039             continue;
3040 
3041         context.setFillPattern(fillPattern.releaseNonNull());
3042         for (auto rect : actionRegion-&gt;rects())
3043             context.fillRect(rect);
3044     }
3045 #endif // ENABLE(POINTER_EVENTS)
3046 }
3047 
3048 // Up-call from compositing layer drawing callback.
<span class="line-modified">3049 void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
3050 {
3051 #ifndef NDEBUG
3052     renderer().page().setIsPainting(true);
3053 #endif
3054 
3055 #if PLATFORM(MAC)
3056     LocalDefaultSystemAppearance localAppearance(renderer().useDarkAppearance());
3057 #endif
3058 
3059     // The dirtyRect is in the coords of the painting root.
3060     FloatRect adjustedClipRect = clip;
3061     adjustedClipRect.move(m_subpixelOffsetFromRenderer);
3062     IntRect dirtyRect = enclosingIntRect(adjustedClipRect);
3063 
3064     if (!graphicsLayer-&gt;repaintCount())
3065         layerPaintBehavior |= GraphicsLayerPaintFirstTilePaint;
3066 
3067     if (graphicsLayer == m_graphicsLayer.get()
3068         || graphicsLayer == m_foregroundLayer.get()
3069         || graphicsLayer == m_backgroundLayer.get()
3070         || graphicsLayer == m_maskLayer.get()
3071         || graphicsLayer == m_childClippingMaskLayer.get()
3072         || graphicsLayer == m_scrolledContentsLayer.get()) {
3073 
<span class="line-modified">3074         if (!graphicsLayer-&gt;paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
3075             dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
3076 
3077         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
3078         OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
3079         if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
3080             behavior.add(PaintBehavior::Snapshotting);
3081 
3082         if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
3083             behavior.add(PaintBehavior::TileFirstPaint);
3084 
<span class="line-modified">3085         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior);</span>
3086 
3087         if (renderer().settings().visibleDebugOverlayRegions() &amp; NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.
3088             paintDebugOverlays(graphicsLayer, context);
3089 
3090     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
3091         paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
3092     } else if (graphicsLayer == layerForVerticalScrollbar()) {
3093         paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
3094     } else if (graphicsLayer == layerForScrollCorner()) {
3095         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
3096         GraphicsContextStateSaver stateSaver(context);
3097         context.translate(-scrollCornerAndResizer.location());
3098         LayoutRect transformedClip = LayoutRect(clip);
3099         transformedClip.moveBy(scrollCornerAndResizer.location());
3100         m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
3101         m_owningLayer.paintResizer(context, IntPoint(), transformedClip);
3102     }
3103 #ifndef NDEBUG
3104     renderer().page().setIsPainting(false);
3105 #endif
</pre>
<hr />
<pre>
3266 
3267     if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
3268         return false;
3269 
3270     bool didAnimate = false;
3271 
3272     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), &amp;animation, keyframes.animationName(), timeOffset))
3273         didAnimate = true;
3274 
3275     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3276         didAnimate = true;
3277 
3278     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3279         didAnimate = true;
3280 
3281 #if ENABLE(FILTERS_LEVEL_2)
3282     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3283         didAnimate = true;
3284 #endif
3285 
<span class="line-modified">3286     if (didAnimate) {</span>
3287         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
<span class="line-added">3288         m_owningLayer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-added">3289     }</span>
3290 
3291     return didAnimate;
3292 }
3293 
3294 void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
3295 {
3296     m_graphicsLayer-&gt;pauseAnimation(animationName, timeOffset);
3297 }
3298 
3299 void RenderLayerBacking::animationSeeked(double timeOffset, const String&amp; animationName)
3300 {
3301     m_graphicsLayer-&gt;seekAnimation(animationName, timeOffset);
3302 }
3303 
3304 void RenderLayerBacking::animationFinished(const String&amp; animationName)
3305 {
3306     m_graphicsLayer-&gt;removeAnimation(animationName);
3307     m_owningLayer.setNeedsPostLayoutCompositingUpdate();
<span class="line-added">3308     m_owningLayer.setNeedsCompositingGeometryUpdate();</span>
3309 }
3310 
3311 bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
3312 {
3313     bool didAnimate = false;
3314 
3315     ASSERT(property != CSSPropertyInvalid);
3316 
3317     if (property == CSSPropertyOpacity) {
3318         const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
3319         if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
3320             KeyframeValueList opacityVector(AnimatedPropertyOpacity);
3321             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));
3322             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));
3323             // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
3324             if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
3325                 // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
3326                 updateOpacity(*toStyle);
3327                 didAnimate = true;
3328             }
</pre>
<hr />
<pre>
3380 }
3381 
3382 void RenderLayerBacking::transitionPaused(double timeOffset, CSSPropertyID property)
3383 {
3384     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
3385     if (animatedProperty != AnimatedPropertyInvalid)
3386         m_graphicsLayer-&gt;pauseAnimation(GraphicsLayer::animationNameForTransition(animatedProperty), timeOffset);
3387 }
3388 
3389 void RenderLayerBacking::transitionFinished(CSSPropertyID property)
3390 {
3391     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
3392     if (animatedProperty != AnimatedPropertyInvalid) {
3393         m_graphicsLayer-&gt;removeAnimation(GraphicsLayer::animationNameForTransition(animatedProperty));
3394         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3395     }
3396 }
3397 
3398 void RenderLayerBacking::notifyAnimationStarted(const GraphicsLayer*, const String&amp;, MonotonicTime time)
3399 {
<span class="line-modified">3400     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())</span>
<span class="line-added">3401         renderer().animation().notifyAnimationStarted(renderer(), time);</span>
3402 }
3403 
3404 void RenderLayerBacking::notifyFlushRequired(const GraphicsLayer* layer)
3405 {
3406     if (renderer().renderTreeBeingDestroyed())
3407         return;
3408     compositor().scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
3409 }
3410 
3411 void RenderLayerBacking::notifyFlushBeforeDisplayRefresh(const GraphicsLayer* layer)
3412 {
3413     compositor().notifyFlushBeforeDisplayRefresh(layer);
3414 }
3415 
3416 // This is used for the &#39;freeze&#39; API, for testing only.
3417 void RenderLayerBacking::suspendAnimations(MonotonicTime time)
3418 {
3419     m_graphicsLayer-&gt;suspendAnimations(time);
3420 }
3421 
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
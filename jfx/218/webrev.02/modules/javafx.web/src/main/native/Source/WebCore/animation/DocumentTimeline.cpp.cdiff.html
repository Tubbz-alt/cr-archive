<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeclarativeAnimation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentTimeline.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,26 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  
<span class="line-modified">! #include &quot;AnimationPlaybackEvent.h&quot;</span>
  #include &quot;CSSAnimation.h&quot;
<span class="line-removed">- #include &quot;CSSPropertyAnimation.h&quot;</span>
  #include &quot;CSSTransition.h&quot;
  #include &quot;DOMWindow.h&quot;
  #include &quot;DeclarativeAnimation.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;GraphicsLayer.h&quot;
  #include &quot;KeyframeEffect.h&quot;
<span class="line-modified">! #include &quot;Microtasks.h&quot;</span>
  #include &quot;Node.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PseudoElement.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderLayerBacking.h&quot;
  
  static const Seconds defaultAnimationInterval { 15_ms };
  static const Seconds throttledAnimationInterval { 30_ms };
  
  namespace WebCore {
<span class="line-new-header">--- 24,29 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  
<span class="line-modified">! #include &quot;AnimationEventBase.h&quot;</span>
  #include &quot;CSSAnimation.h&quot;
  #include &quot;CSSTransition.h&quot;
  #include &quot;DOMWindow.h&quot;
  #include &quot;DeclarativeAnimation.h&quot;
  #include &quot;Document.h&quot;
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
<span class="line-added">+ #include &quot;EventNames.h&quot;</span>
  #include &quot;GraphicsLayer.h&quot;
  #include &quot;KeyframeEffect.h&quot;
<span class="line-modified">! #include &quot;KeyframeEffectStack.h&quot;</span>
  #include &quot;Node.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PseudoElement.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderLayerBacking.h&quot;
<span class="line-added">+ #include &quot;Settings.h&quot;</span>
<span class="line-added">+ #include &lt;JavaScriptCore/VM.h&gt;</span>
  
  static const Seconds defaultAnimationInterval { 15_ms };
  static const Seconds throttledAnimationInterval { 30_ms };
  
  namespace WebCore {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,29 ***</span>
  }
  
  DocumentTimeline::DocumentTimeline(Document&amp; document, Seconds originTime)
      : AnimationTimeline()
      , m_tickScheduleTimer(*this, &amp;DocumentTimeline::scheduleAnimationResolution)
<span class="line-modified">!     , m_document(&amp;document)</span>
      , m_originTime(originTime)
  {
<span class="line-modified">!     if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; !m_document-&gt;page()-&gt;isVisible())</span>
<span class="line-modified">!         suspendAnimations();</span>
  }
  
<span class="line-modified">! DocumentTimeline::~DocumentTimeline() = default;</span>
  
  void DocumentTimeline::detachFromDocument()
  {
      m_currentTimeClearingTaskQueue.close();
      m_elementsWithRunningAcceleratedAnimations.clear();
  
      auto&amp; animationsToRemove = m_animations;
      while (!animationsToRemove.isEmpty())
          animationsToRemove.first()-&gt;remove();
  
<span class="line-modified">!     unscheduleAnimationResolution();</span>
      m_document = nullptr;
  }
  
  static inline bool compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(Element* lhsOwningElement, Element* rhsOwningElement)
  {
<span class="line-new-header">--- 62,41 ---</span>
  }
  
  DocumentTimeline::DocumentTimeline(Document&amp; document, Seconds originTime)
      : AnimationTimeline()
      , m_tickScheduleTimer(*this, &amp;DocumentTimeline::scheduleAnimationResolution)
<span class="line-modified">!     , m_document(makeWeakPtr(document))</span>
      , m_originTime(originTime)
  {
<span class="line-modified">!     document.addTimeline(*this);</span>
<span class="line-modified">!     if (auto* page = document.page()) {</span>
<span class="line-added">+         if (page-&gt;settings().hiddenPageCSSAnimationSuspensionEnabled() &amp;&amp; !page-&gt;isVisible())</span>
<span class="line-added">+             suspendAnimations();</span>
<span class="line-added">+     }</span>
  }
  
<span class="line-modified">! DocumentTimeline::~DocumentTimeline()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_document)</span>
<span class="line-added">+         m_document-&gt;removeTimeline(*this);</span>
<span class="line-added">+ }</span>
  
  void DocumentTimeline::detachFromDocument()
  {
<span class="line-added">+     Ref&lt;DocumentTimeline&gt; protectedThis(*this);</span>
<span class="line-added">+     if (m_document)</span>
<span class="line-added">+         m_document-&gt;removeTimeline(*this);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_pendingAnimationEvents.clear();</span>
      m_currentTimeClearingTaskQueue.close();
      m_elementsWithRunningAcceleratedAnimations.clear();
  
      auto&amp; animationsToRemove = m_animations;
      while (!animationsToRemove.isEmpty())
          animationsToRemove.first()-&gt;remove();
  
<span class="line-modified">!     clearTickScheduleTimer();</span>
      m_document = nullptr;
  }
  
  static inline bool compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(Element* lhsOwningElement, Element* rhsOwningElement)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,12 ***</span>
          // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
          if (lhsOwningElement != rhsOwningElement)
              return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
  
          // Otherwise, sort A and B based on their position in the computed value of the animation-name property of the (common) owning element.
<span class="line-modified">!         // In our case, this matches the time at which the animations were created and thus their relative position in m_allAnimations.</span>
<span class="line-modified">!         return false;</span>
      });
  
      // Finally, we can concatenate the sorted CSS Transitions, CSS Animations and Web Animations in their relative composite order.
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
      animations.appendRange(cssTransitions.begin(), cssTransitions.end());
<span class="line-new-header">--- 189,15 ---</span>
          // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
          if (lhsOwningElement != rhsOwningElement)
              return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
  
          // Otherwise, sort A and B based on their position in the computed value of the animation-name property of the (common) owning element.
<span class="line-modified">!         return compareAnimationsByCompositeOrder(*lhs, *rhs, lhsOwningElement-&gt;ensureKeyframeEffectStack().cssAnimationList());</span>
<span class="line-modified">!     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     std::sort(webAnimations.begin(), webAnimations.end(), [](auto&amp; lhs, auto&amp; rhs) {</span>
<span class="line-added">+         return lhs-&gt;globalPosition() &lt; rhs-&gt;globalPosition();</span>
      });
  
      // Finally, we can concatenate the sorted CSS Transitions, CSS Animations and Web Animations in their relative composite order.
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
      animations.appendRange(cssTransitions.begin(), cssTransitions.end());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,11 ***</span>
  
      m_isSuspended = true;
  
      applyPendingAcceleratedAnimations();
  
<span class="line-modified">!     unscheduleAnimationResolution();</span>
  }
  
  void DocumentTimeline::resumeAnimations()
  {
      if (!animationsAreSuspended())
<span class="line-new-header">--- 231,11 ---</span>
  
      m_isSuspended = true;
  
      applyPendingAcceleratedAnimations();
  
<span class="line-modified">!     clearTickScheduleTimer();</span>
  }
  
  void DocumentTimeline::resumeAnimations()
  {
      if (!animationsAreSuspended())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,10 ***</span>
<span class="line-new-header">--- 289,12 ---</span>
      return m_cachedCurrentTime.value() - m_originTime;
  }
  
  void DocumentTimeline::cacheCurrentTime(DOMHighResTimeStamp newCurrentTime)
  {
<span class="line-added">+     ASSERT(m_document);</span>
<span class="line-added">+ </span>
      m_cachedCurrentTime = Seconds(newCurrentTime);
      // We want to be sure to keep this time cached until we&#39;ve both finished running JS and finished updating
      // animations, so we schedule the invalidation task and register a whenIdle callback on the VM, which will
      // fire syncronously if no JS is running.
      m_waitingOnVMIdle = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,53 ***</span>
  void DocumentTimeline::removeAnimation(WebAnimation&amp; animation)
  {
      AnimationTimeline::removeAnimation(animation);
  
      if (m_animations.isEmpty())
<span class="line-modified">!         unscheduleAnimationResolution();</span>
  }
  
  void DocumentTimeline::scheduleAnimationResolution()
  {
<span class="line-modified">!     if (m_isSuspended || m_animations.isEmpty() || m_animationResolutionScheduled)</span>
          return;
  
<span class="line-modified">!     if (!m_document || !m_document-&gt;page())</span>
          return;
  
      m_document-&gt;page()-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
      m_animationResolutionScheduled = true;
  }
  
<span class="line-modified">! void DocumentTimeline::unscheduleAnimationResolution()</span>
  {
      m_tickScheduleTimer.stop();
<span class="line-removed">-     m_animationResolutionScheduled = false;</span>
  }
  
<span class="line-modified">! void DocumentTimeline::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)</span>
  {
      // We need to freeze the current time even if no animation is running.
      // document.timeline.currentTime may be called from a rAF callback and
      // it has to match the rAF timestamp.
<span class="line-modified">!     if (!m_isSuspended)</span>
          cacheCurrentTime(timestamp);
  
<span class="line-modified">!     if (m_isSuspended || m_animations.isEmpty() || !m_animationResolutionScheduled)</span>
          return;
  
      internalUpdateAnimationsAndSendEvents();
      applyPendingAcceleratedAnimations();
  
<span class="line-modified">!     m_animationResolutionScheduled = false;</span>
<span class="line-modified">!     scheduleNextTick();</span>
  }
  
  void DocumentTimeline::internalUpdateAnimationsAndSendEvents()
  {
      m_numberOfAnimationTimelineInvalidationsForTesting++;
  
      // https://drafts.csswg.org/web-animations/#update-animations-and-send-events
  
      // 1. Update the current time of all timelines associated with doc passing now as the timestamp.
  
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;
<span class="line-new-header">--- 325,74 ---</span>
  void DocumentTimeline::removeAnimation(WebAnimation&amp; animation)
  {
      AnimationTimeline::removeAnimation(animation);
  
      if (m_animations.isEmpty())
<span class="line-modified">!         clearTickScheduleTimer();</span>
  }
  
  void DocumentTimeline::scheduleAnimationResolution()
  {
<span class="line-modified">!     if (m_isSuspended || m_animationResolutionScheduled || !m_document || !m_document-&gt;page())</span>
          return;
  
<span class="line-modified">!     // We need some relevant animations or pending events to proceed.</span>
<span class="line-added">+     if (!shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
          return;
  
      m_document-&gt;page()-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
      m_animationResolutionScheduled = true;
  }
  
<span class="line-modified">! void DocumentTimeline::clearTickScheduleTimer()</span>
  {
      m_tickScheduleTimer.stop();
  }
  
<span class="line-modified">! bool DocumentTimeline::shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return !m_animations.isEmpty() || !m_pendingAnimationEvents.isEmpty() || !m_acceleratedAnimationsPendingRunningStateChange.isEmpty();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DocumentTimeline::updateCurrentTime(DOMHighResTimeStamp timestamp)</span>
  {
      // We need to freeze the current time even if no animation is running.
      // document.timeline.currentTime may be called from a rAF callback and
      // it has to match the rAF timestamp.
<span class="line-modified">!     if (!m_isSuspended || !shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
          cacheCurrentTime(timestamp);
<span class="line-added">+ }</span>
  
<span class="line-modified">! void DocumentTimeline::updateAnimationsAndSendEvents()</span>
<span class="line-added">+ {</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Updating animations and sending events may invalidate the timing of some animations, so we must set the m_animationResolutionScheduled</span>
<span class="line-added">+     // flag to false prior to running that procedure to allow animation with timing model updates to schedule updates.</span>
<span class="line-added">+     m_animationResolutionScheduled = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_isSuspended)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
          return;
  
      internalUpdateAnimationsAndSendEvents();
      applyPendingAcceleratedAnimations();
  
<span class="line-modified">!     if (!m_animationResolutionScheduled)</span>
<span class="line-modified">!         scheduleNextTick();</span>
  }
  
  void DocumentTimeline::internalUpdateAnimationsAndSendEvents()
  {
      m_numberOfAnimationTimelineInvalidationsForTesting++;
  
<span class="line-added">+     // enqueueAnimationEvent() calls scheduleAnimationResolution() to ensure that the &quot;update animations and send events&quot;</span>
<span class="line-added">+     // procedure is run and enqueued events are dispatched in the next frame. However, events that are enqueued while</span>
<span class="line-added">+     // this procedure is running should not schedule animation resolution until the event queue has been cleared.</span>
<span class="line-added">+     m_shouldScheduleAnimationResolutionForNewPendingEvents = false;</span>
<span class="line-added">+ </span>
      // https://drafts.csswg.org/web-animations/#update-animations-and-send-events
  
      // 1. Update the current time of all timelines associated with doc passing now as the timestamp.
  
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,19 ***</span>
              if (transition-&gt;owningElement())
                  completedTransitions.append(transition);
          }
      }
  
<span class="line-modified">!     // 2. Perform a microtask checkpoint.</span>
<span class="line-modified">!     MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
  
<span class="line-modified">!     // 3. Let events to dispatch be a copy of doc&#39;s pending animation event queue.</span>
<span class="line-modified">!     // 4. Clear doc&#39;s pending animation event queue.</span>
      auto pendingAnimationEvents = WTFMove(m_pendingAnimationEvents);
  
<span class="line-modified">!     // 5. Perform a stable sort of the animation events in events to dispatch as follows.</span>
<span class="line-modified">!     std::stable_sort(pendingAnimationEvents.begin(), pendingAnimationEvents.end(), [] (const Ref&lt;AnimationPlaybackEvent&gt;&amp; lhs, const Ref&lt;AnimationPlaybackEvent&gt;&amp; rhs) {</span>
          // 1. Sort the events by their scheduled event time such that events that were scheduled to occur earlier, sort before events scheduled to occur later
          // and events whose scheduled event time is unresolved sort before events with a resolved scheduled event time.
          // 2. Within events with equal scheduled event times, sort by their composite order. FIXME: We don&#39;t do this.
          if (lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
              return false;
<span class="line-new-header">--- 417,24 ---</span>
              if (transition-&gt;owningElement())
                  completedTransitions.append(transition);
          }
      }
  
<span class="line-modified">!     // 2. Remove replaced animations for doc.</span>
<span class="line-modified">!     removeReplacedAnimations();</span>
  
<span class="line-modified">!     // 3. Perform a microtask checkpoint.</span>
<span class="line-modified">!     if (auto document = makeRefPtr(this-&gt;document()))</span>
<span class="line-added">+         document-&gt;eventLoop().performMicrotaskCheckpoint();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 4. Let events to dispatch be a copy of doc&#39;s pending animation event queue.</span>
<span class="line-added">+     // 5. Clear doc&#39;s pending animation event queue.</span>
      auto pendingAnimationEvents = WTFMove(m_pendingAnimationEvents);
<span class="line-added">+     m_shouldScheduleAnimationResolutionForNewPendingEvents = true;</span>
  
<span class="line-modified">!     // 6. Perform a stable sort of the animation events in events to dispatch as follows.</span>
<span class="line-modified">!     std::stable_sort(pendingAnimationEvents.begin(), pendingAnimationEvents.end(), [] (const Ref&lt;AnimationEventBase&gt;&amp; lhs, const Ref&lt;AnimationEventBase&gt;&amp; rhs) {</span>
          // 1. Sort the events by their scheduled event time such that events that were scheduled to occur earlier, sort before events scheduled to occur later
          // and events whose scheduled event time is unresolved sort before events with a resolved scheduled event time.
          // 2. Within events with equal scheduled event times, sort by their composite order. FIXME: We don&#39;t do this.
          if (lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,25 ***</span>
          if (!lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
              return true;
          return lhs-&gt;timelineTime().value() &lt; rhs-&gt;timelineTime().value();
      });
  
<span class="line-modified">!     // 6. Dispatch each of the events in events to dispatch at their corresponding target using the order established in the previous step.</span>
<span class="line-modified">!     for (auto&amp; pendingEvent : pendingAnimationEvents)</span>
<span class="line-modified">!         pendingEvent-&gt;target()-&gt;dispatchEvent(pendingEvent);</span>
  
      // This will cancel any scheduled invalidation if we end up removing all animations.
<span class="line-modified">!     for (auto&amp; animation : animationsToRemove)</span>
<span class="line-modified">!         removeAnimation(*animation);</span>
  
      // Now that animations that needed removal have been removed, let&#39;s update the list of completed transitions.
      // This needs to happen after dealing with the list of animations to remove as the animation may have been
      // removed from the list of completed transitions otherwise.
      for (auto&amp; completedTransition : completedTransitions)
          transitionDidComplete(completedTransition);
  }
  
  void DocumentTimeline::transitionDidComplete(RefPtr&lt;CSSTransition&gt; transition)
  {
      ASSERT(transition);
      removeAnimation(*transition);
      if (is&lt;KeyframeEffect&gt;(transition-&gt;effect())) {
<span class="line-new-header">--- 443,106 ---</span>
          if (!lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
              return true;
          return lhs-&gt;timelineTime().value() &lt; rhs-&gt;timelineTime().value();
      });
  
<span class="line-modified">!     // 7. Dispatch each of the events in events to dispatch at their corresponding target using the order established in the previous step.</span>
<span class="line-modified">!     for (auto&amp; pendingAnimationEvent : pendingAnimationEvents)</span>
<span class="line-modified">!         pendingAnimationEvent-&gt;target()-&gt;dispatchEvent(pendingAnimationEvent);</span>
  
      // This will cancel any scheduled invalidation if we end up removing all animations.
<span class="line-modified">!     for (auto&amp; animation : animationsToRemove) {</span>
<span class="line-modified">!         // An animation that was initially marked as irrelevant may have changed while we were sending events, so we run the same</span>
<span class="line-added">+         // check that we ran to add it to animationsToRemove in the first place.</span>
<span class="line-added">+         if (!animation-&gt;isRelevant() &amp;&amp; !animation-&gt;needsTick())</span>
<span class="line-added">+             removeAnimation(*animation);</span>
<span class="line-added">+     }</span>
  
      // Now that animations that needed removal have been removed, let&#39;s update the list of completed transitions.
      // This needs to happen after dealing with the list of animations to remove as the animation may have been
      // removed from the list of completed transitions otherwise.
      for (auto&amp; completedTransition : completedTransitions)
          transitionDidComplete(completedTransition);
  }
  
<span class="line-added">+ bool DocumentTimeline::animationCanBeRemoved(WebAnimation&amp; animation)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // https://drafts.csswg.org/web-animations/#removing-replaced-animations</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(m_document);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // - is replaceable, and</span>
<span class="line-added">+     if (!animation.isReplaceable())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // - has a replace state of active, and</span>
<span class="line-added">+     if (animation.replaceState() != WebAnimation::ReplaceState::Active)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // - has an associated animation effect whose target element is a descendant of doc, and</span>
<span class="line-added">+     auto* effect = animation.effect();</span>
<span class="line-added">+     if (!is&lt;KeyframeEffect&gt;(effect))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);</span>
<span class="line-added">+     auto* target = keyframeEffect-&gt;target();</span>
<span class="line-added">+     if (!target || !target-&gt;isDescendantOf(*m_document))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     HashSet&lt;CSSPropertyID&gt; propertiesToMatch = keyframeEffect-&gt;animatedProperties();</span>
<span class="line-added">+     auto animations = animationsForElement(*target, AnimationTimeline::Ordering::Sorted);</span>
<span class="line-added">+     for (auto&amp; animationWithHigherCompositeOrder : WTF::makeReversedRange(animations)) {</span>
<span class="line-added">+         if (&amp;animation == animationWithHigherCompositeOrder)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (animationWithHigherCompositeOrder &amp;&amp; animationWithHigherCompositeOrder-&gt;isReplaceable()) {</span>
<span class="line-added">+             auto* effectWithHigherCompositeOrder = animationWithHigherCompositeOrder-&gt;effect();</span>
<span class="line-added">+             if (is&lt;KeyframeEffect&gt;(effectWithHigherCompositeOrder)) {</span>
<span class="line-added">+                 auto* keyframeEffectWithHigherCompositeOrder = downcast&lt;KeyframeEffect&gt;(effectWithHigherCompositeOrder);</span>
<span class="line-added">+                 for (auto cssPropertyId : keyframeEffectWithHigherCompositeOrder-&gt;animatedProperties()) {</span>
<span class="line-added">+                     if (propertiesToMatch.remove(cssPropertyId) &amp;&amp; propertiesToMatch.isEmpty())</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return propertiesToMatch.isEmpty();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DocumentTimeline::removeReplacedAnimations()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // https://drafts.csswg.org/web-animations/#removing-replaced-animations</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // When asked to remove replaced animations for a Document, doc, then for every animation, animation</span>
<span class="line-added">+     for (auto&amp; animation : m_allAnimations) {</span>
<span class="line-added">+         if (animation &amp;&amp; animationCanBeRemoved(*animation)) {</span>
<span class="line-added">+             // perform the following steps:</span>
<span class="line-added">+             // 1. Set animation&#39;s replace state to removed.</span>
<span class="line-added">+             animation-&gt;setReplaceState(WebAnimation::ReplaceState::Removed);</span>
<span class="line-added">+             // 2. Create an AnimationPlaybackEvent, removeEvent.</span>
<span class="line-added">+             // 3. Set removeEvent&#39;s type attribute to remove.</span>
<span class="line-added">+             // 4. Set removeEvent&#39;s currentTime attribute to the current time of animation.</span>
<span class="line-added">+             // 5. Set removeEvent&#39;s timelineTime attribute to the current time of the timeline with which animation is associated.</span>
<span class="line-added">+             // 6. If animation has a document for timing, then append removeEvent to its document for timing&#39;s pending animation</span>
<span class="line-added">+             //    event queue along with its target, animation. For the scheduled event time, use the result of applying the procedure</span>
<span class="line-added">+             //    to convert timeline time to origin-relative time to the current time of the timeline with which animation is associated.</span>
<span class="line-added">+             //    Otherwise, queue a task to dispatch removeEvent at animation. The task source for this task is the DOM manipulation task source.</span>
<span class="line-added">+             animation-&gt;enqueueAnimationPlaybackEvent(eventNames().removeEvent, animation-&gt;currentTime(), currentTime());</span>
<span class="line-added">+ </span>
<span class="line-added">+             animationsToRemove.append(animation.get());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; animation : animationsToRemove) {</span>
<span class="line-added">+         if (auto* timeline = animation-&gt;timeline())</span>
<span class="line-added">+             timeline-&gt;removeAnimation(*animation);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void DocumentTimeline::transitionDidComplete(RefPtr&lt;CSSTransition&gt; transition)
  {
      ASSERT(transition);
      removeAnimation(*transition);
      if (is&lt;KeyframeEffect&gt;(transition-&gt;effect())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,24 ***</span>
      }
  }
  
  void DocumentTimeline::scheduleNextTick()
  {
      // There is no tick to schedule if we don&#39;t have any relevant animations.
      if (m_animations.isEmpty())
          return;
  
<span class="line-removed">-     for (const auto&amp; animation : m_animations) {</span>
<span class="line-removed">-         if (!animation-&gt;isRunningAccelerated()) {</span>
<span class="line-removed">-             scheduleAnimationResolution();</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      Seconds scheduleDelay = Seconds::infinity();
  
      for (const auto&amp; animation : m_animations) {
          auto animationTimeToNextRequiredTick = animation-&gt;timeToNextTick();
          if (animationTimeToNextRequiredTick &lt; animationInterval()) {
              scheduleAnimationResolution();
              return;
          }
<span class="line-new-header">--- 554,23 ---</span>
      }
  }
  
  void DocumentTimeline::scheduleNextTick()
  {
<span class="line-added">+     // If we have pending animation events, we need to schedule an update right away.</span>
<span class="line-added">+     if (!m_pendingAnimationEvents.isEmpty())</span>
<span class="line-added">+         scheduleAnimationResolution();</span>
<span class="line-added">+ </span>
      // There is no tick to schedule if we don&#39;t have any relevant animations.
      if (m_animations.isEmpty())
          return;
  
      Seconds scheduleDelay = Seconds::infinity();
  
      for (const auto&amp; animation : m_animations) {
<span class="line-added">+         if (!animation-&gt;isRelevant())</span>
<span class="line-added">+             continue;</span>
          auto animationTimeToNextRequiredTick = animation-&gt;timeToNextTick();
          if (animationTimeToNextRequiredTick &lt; animationInterval()) {
              scheduleAnimationResolution();
              return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,11 ***</span>
          if (playState != WebAnimation::PlayState::Running &amp;&amp; playState != WebAnimation::PlayState::Paused)
              continue;
          auto* effect = animation-&gt;effect();
          if (is&lt;KeyframeEffect&gt;(effect)) {
              auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);
<span class="line-modified">!             if (keyframeEffect-&gt;isRunningAccelerated() &amp;&amp; keyframeEffect-&gt;animatedProperties().contains(property))</span>
                  return true;
          }
      }
  
      return false;
<span class="line-new-header">--- 629,11 ---</span>
          if (playState != WebAnimation::PlayState::Running &amp;&amp; playState != WebAnimation::PlayState::Paused)
              continue;
          auto* effect = animation-&gt;effect();
          if (is&lt;KeyframeEffect&gt;(effect)) {
              auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);
<span class="line-modified">!             if (keyframeEffect-&gt;isCurrentlyAffectingProperty(property, KeyframeEffect::Accelerated::Yes))</span>
                  return true;
          }
      }
  
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,10 ***</span>
<span class="line-new-header">--- 674,15 ---</span>
  
      if (is&lt;KeyframeEffect&gt;(animation.effect())) {
          if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())
              updateListOfElementsWithRunningAcceleratedAnimationsForElement(*target);
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
<span class="line-added">+         scheduleAnimationResolution();</span>
<span class="line-added">+     else</span>
<span class="line-added">+         clearTickScheduleTimer();</span>
  }
  
  void DocumentTimeline::updateListOfElementsWithRunningAcceleratedAnimationsForElement(Element&amp; element)
  {
      auto animations = animationsForElement(element);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,44 ***</span>
          }
          animation-&gt;applyPendingAcceleratedActions();
      }
  }
  
<span class="line-removed">- bool DocumentTimeline::resolveAnimationsForElement(Element&amp; element, RenderStyle&amp; targetStyle)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     bool hasNonAcceleratedAnimationProperty = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (const auto&amp; animation : animationsForElement(element)) {</span>
<span class="line-removed">-         animation-&gt;resolve(targetStyle);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (hasNonAcceleratedAnimationProperty)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* effect = animation-&gt;effect();</span>
<span class="line-removed">-         if (!effect || !is&lt;KeyframeEffect&gt;(effect))</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);</span>
<span class="line-removed">-         for (auto cssPropertyId : keyframeEffect-&gt;animatedProperties()) {</span>
<span class="line-removed">-             if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId)) {</span>
<span class="line-removed">-                 hasNonAcceleratedAnimationProperty = true;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return !hasNonAcceleratedAnimationProperty;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool DocumentTimeline::runningAnimationsForElementAreAllAccelerated(Element&amp; element) const
  {
      return m_elementsWithRunningAcceleratedAnimations.contains(&amp;element);
  }
  
<span class="line-modified">! void DocumentTimeline::enqueueAnimationPlaybackEvent(AnimationPlaybackEvent&amp; event)</span>
  {
      m_pendingAnimationEvents.append(event);
  }
  
  Vector&lt;std::pair&lt;String, double&gt;&gt; DocumentTimeline::acceleratedAnimationsForElement(Element&amp; element) const
  {
      auto* renderer = element.renderer();
<span class="line-new-header">--- 716,20 ---</span>
          }
          animation-&gt;applyPendingAcceleratedActions();
      }
  }
  
  bool DocumentTimeline::runningAnimationsForElementAreAllAccelerated(Element&amp; element) const
  {
      return m_elementsWithRunningAcceleratedAnimations.contains(&amp;element);
  }
  
<span class="line-modified">! void DocumentTimeline::enqueueAnimationEvent(AnimationEventBase&amp; event)</span>
  {
      m_pendingAnimationEvents.append(event);
<span class="line-added">+     if (m_shouldScheduleAnimationResolutionForNewPendingEvents)</span>
<span class="line-added">+         scheduleAnimationResolution();</span>
  }
  
  Vector&lt;std::pair&lt;String, double&gt;&gt; DocumentTimeline::acceleratedAnimationsForElement(Element&amp; element) const
  {
      auto* renderer = element.renderer();
</pre>
<center><a href="DeclarativeAnimation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentTimeline.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
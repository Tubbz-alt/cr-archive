<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/BlockDirectory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AtomIndices.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BlockDirectory.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/BlockDirectory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,13 +36,14 @@</span>
  #include &quot;SuperSampler.h&quot;
  #include &quot;VM.h&quot;
  
  namespace JSC {
  
<span class="udiff-line-modified-removed">- BlockDirectory::BlockDirectory(Heap* heap, size_t cellSize)</span>
<span class="udiff-line-modified-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BlockDirectory);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ BlockDirectory::BlockDirectory(size_t cellSize)</span>
      : m_cellSize(static_cast&lt;unsigned&gt;(cellSize))
<span class="udiff-line-removed">-     , m_heap(heap)</span>
  {
  }
  
  BlockDirectory::~BlockDirectory()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74,78 +75,69 @@</span>
      return false;
  }
  
  MarkedBlock::Handle* BlockDirectory::findEmptyBlockToSteal()
  {
<span class="udiff-line-modified-removed">-     m_emptyCursor = m_empty.findBit(m_emptyCursor, true);</span>
<span class="udiff-line-modified-added">+     m_emptyCursor = m_bits.empty().findBit(m_emptyCursor, true);</span>
      if (m_emptyCursor &gt;= m_blocks.size())
          return nullptr;
      return m_blocks[m_emptyCursor];
  }
  
  MarkedBlock::Handle* BlockDirectory::findBlockForAllocation(LocalAllocator&amp; allocator)
  {
      for (;;) {
<span class="udiff-line-modified-removed">-         allocator.m_allocationCursor = (m_canAllocateButNotEmpty | m_empty).findBit(allocator.m_allocationCursor, true);</span>
<span class="udiff-line-modified-added">+         allocator.m_allocationCursor = (m_bits.canAllocateButNotEmpty() | m_bits.empty()).findBit(allocator.m_allocationCursor, true);</span>
          if (allocator.m_allocationCursor &gt;= m_blocks.size())
              return nullptr;
  
<span class="udiff-line-modified-removed">-         size_t blockIndex = allocator.m_allocationCursor++;</span>
<span class="udiff-line-modified-added">+         unsigned blockIndex = allocator.m_allocationCursor++;</span>
          MarkedBlock::Handle* result = m_blocks[blockIndex];
          setIsCanAllocateButNotEmpty(NoLockingNecessary, blockIndex, false);
          return result;
      }
  }
  
<span class="udiff-line-modified-removed">- MarkedBlock::Handle* BlockDirectory::tryAllocateBlock()</span>
<span class="udiff-line-modified-added">+ MarkedBlock::Handle* BlockDirectory::tryAllocateBlock(Heap&amp; heap)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="udiff-line-modified-removed">-     MarkedBlock::Handle* handle = MarkedBlock::tryCreate(*m_heap, subspace()-&gt;alignedMemoryAllocator());</span>
<span class="udiff-line-modified-added">+     MarkedBlock::Handle* handle = MarkedBlock::tryCreate(heap, subspace()-&gt;alignedMemoryAllocator());</span>
      if (!handle)
          return nullptr;
  
      markedSpace().didAddBlock(handle);
  
      return handle;
  }
  
  void BlockDirectory::addBlock(MarkedBlock::Handle* block)
  {
<span class="udiff-line-modified-removed">-     size_t index;</span>
<span class="udiff-line-modified-added">+     unsigned index;</span>
      if (m_freeBlockIndices.isEmpty()) {
          index = m_blocks.size();
  
          size_t oldCapacity = m_blocks.capacity();
          m_blocks.append(block);
          if (m_blocks.capacity() != oldCapacity) {
<span class="udiff-line-modified-removed">-             forEachBitVector(</span>
<span class="udiff-line-removed">-                 NoLockingNecessary,</span>
<span class="udiff-line-removed">-                 [&amp;] (FastBitVector&amp; vector) {</span>
<span class="udiff-line-removed">-                     ASSERT_UNUSED(vector, vector.numBits() == oldCapacity);</span>
<span class="udiff-line-removed">-                 });</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+             ASSERT(m_bits.numBits() == oldCapacity);</span>
              ASSERT(m_blocks.capacity() &gt; oldCapacity);
  
              LockHolder locker(m_bitvectorLock);
              subspace()-&gt;didResizeBits(m_blocks.capacity());
<span class="udiff-line-modified-removed">-             forEachBitVector(</span>
<span class="udiff-line-removed">-                 locker,</span>
<span class="udiff-line-removed">-                 [&amp;] (FastBitVector&amp; vector) {</span>
<span class="udiff-line-removed">-                     vector.resize(m_blocks.capacity());</span>
<span class="udiff-line-removed">-                 });</span>
<span class="udiff-line-modified-added">+             m_bits.resize(m_blocks.capacity());</span>
          }
      } else {
          index = m_freeBlockIndices.takeLast();
          ASSERT(!m_blocks[index]);
          m_blocks[index] = block;
      }
  
      forEachBitVector(
          NoLockingNecessary,
<span class="udiff-line-modified-removed">-         [&amp;] (FastBitVector&amp; vector) {</span>
<span class="udiff-line-modified-removed">-             ASSERT_UNUSED(vector, !vector[index]);</span>
<span class="udiff-line-modified-added">+         [&amp;](auto vectorRef) {</span>
<span class="udiff-line-modified-added">+             ASSERT_UNUSED(vectorRef, !vectorRef[index]);</span>
          });
  
      // This is the point at which the block learns of its cellSize() and attributes().
      block-&gt;didAddToDirectory(this, index);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163,12 +155,12 @@</span>
      m_blocks[block-&gt;index()] = nullptr;
      m_freeBlockIndices.append(block-&gt;index());
  
      forEachBitVector(
          holdLock(m_bitvectorLock),
<span class="udiff-line-modified-removed">-         [&amp;] (FastBitVector&amp; vector) {</span>
<span class="udiff-line-modified-removed">-             vector[block-&gt;index()] = false;</span>
<span class="udiff-line-modified-added">+         [&amp;](auto vectorRef) {</span>
<span class="udiff-line-modified-added">+             vectorRef[block-&gt;index()] = false;</span>
          });
  
      block-&gt;didRemoveFromDirectory();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -190,11 +182,11 @@</span>
          });
  
      m_unsweptCursor = 0;
      m_emptyCursor = 0;
  
<span class="udiff-line-modified-removed">-     m_eden.clearAll();</span>
<span class="udiff-line-modified-added">+     m_bits.eden().clearAll();</span>
  
      if (UNLIKELY(Options::useImmortalObjects())) {
          // FIXME: Make this work again.
          // https://bugs.webkit.org/show_bug.cgi?id=162296
          RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -235,81 +227,81 @@</span>
  void BlockDirectory::beginMarkingForFullCollection()
  {
      // Mark bits are sticky and so is our summary of mark bits. We only clear these during full
      // collections, so if you survived the last collection you will survive the next one so long
      // as the next one is eden.
<span class="udiff-line-modified-removed">-     m_markingNotEmpty.clearAll();</span>
<span class="udiff-line-modified-removed">-     m_markingRetired.clearAll();</span>
<span class="udiff-line-modified-added">+     m_bits.markingNotEmpty().clearAll();</span>
<span class="udiff-line-modified-added">+     m_bits.markingRetired().clearAll();</span>
  }
  
  void BlockDirectory::endMarking()
  {
<span class="udiff-line-modified-removed">-     m_allocated.clearAll();</span>
<span class="udiff-line-modified-added">+     m_bits.allocated().clearAll();</span>
  
      // It&#39;s surprising and frustrating to comprehend, but the end-of-marking flip does not need to
      // know what kind of collection it is. That knowledge is already encoded in the m_markingXYZ
      // vectors.
  
<span class="udiff-line-modified-removed">-     m_empty = m_live &amp; ~m_markingNotEmpty;</span>
<span class="udiff-line-modified-removed">-     m_canAllocateButNotEmpty = m_live &amp; m_markingNotEmpty &amp; ~m_markingRetired;</span>
<span class="udiff-line-modified-added">+     m_bits.empty() = m_bits.live() &amp; ~m_bits.markingNotEmpty();</span>
<span class="udiff-line-modified-added">+     m_bits.canAllocateButNotEmpty() = m_bits.live() &amp; m_bits.markingNotEmpty() &amp; ~m_bits.markingRetired();</span>
  
      if (needsDestruction()) {
          // There are some blocks that we didn&#39;t allocate out of in the last cycle, but we swept them. This
          // will forget that we did that and we will end up sweeping them again and attempting to call their
          // destructors again. That&#39;s fine because of zapping. The only time when we cannot forget is when
          // we just allocate a block or when we move a block from one size class to another. That doesn&#39;t
          // happen here.
<span class="udiff-line-modified-removed">-         m_destructible = m_live;</span>
<span class="udiff-line-modified-added">+         m_bits.destructible() = m_bits.live();</span>
      }
  
      if (false) {
          dataLog(&quot;Bits for &quot;, m_cellSize, &quot;, &quot;, m_attributes, &quot; after endMarking:\n&quot;);
          dumpBits(WTF::dataFile());
      }
  }
  
  void BlockDirectory::snapshotUnsweptForEdenCollection()
  {
<span class="udiff-line-modified-removed">-     m_unswept |= m_eden;</span>
<span class="udiff-line-modified-added">+     m_bits.unswept() |= m_bits.eden();</span>
  }
  
  void BlockDirectory::snapshotUnsweptForFullCollection()
  {
<span class="udiff-line-modified-removed">-     m_unswept = m_live;</span>
<span class="udiff-line-modified-added">+     m_bits.unswept() = m_bits.live();</span>
  }
  
  MarkedBlock::Handle* BlockDirectory::findBlockToSweep()
  {
<span class="udiff-line-modified-removed">-     m_unsweptCursor = m_unswept.findBit(m_unsweptCursor, true);</span>
<span class="udiff-line-modified-added">+     m_unsweptCursor = m_bits.unswept().findBit(m_unsweptCursor, true);</span>
      if (m_unsweptCursor &gt;= m_blocks.size())
          return nullptr;
      return m_blocks[m_unsweptCursor];
  }
  
  void BlockDirectory::sweep()
  {
<span class="udiff-line-modified-removed">-     m_unswept.forEachSetBit(</span>
<span class="udiff-line-modified-added">+     m_bits.unswept().forEachSetBit(</span>
          [&amp;] (size_t index) {
              MarkedBlock::Handle* block = m_blocks[index];
              block-&gt;sweep(nullptr);
          });
  }
  
  void BlockDirectory::shrink()
  {
<span class="udiff-line-modified-removed">-     (m_empty &amp; ~m_destructible).forEachSetBit(</span>
<span class="udiff-line-modified-added">+     (m_bits.empty() &amp; ~m_bits.destructible()).forEachSetBit(</span>
          [&amp;] (size_t index) {
              markedSpace().freeBlock(m_blocks[index]);
          });
  }
  
  void BlockDirectory::assertNoUnswept()
  {
<span class="udiff-line-modified-removed">-     if (ASSERT_DISABLED)</span>
<span class="udiff-line-modified-added">+     if (!ASSERT_ENABLED)</span>
          return;
  
<span class="udiff-line-modified-removed">-     if (m_unswept.isEmpty())</span>
<span class="udiff-line-modified-added">+     if (m_bits.unswept().isEmpty())</span>
          return;
  
      dataLog(&quot;Assertion failed: unswept not empty in &quot;, *this, &quot;.\n&quot;);
      dumpBits();
      ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -327,11 +319,11 @@</span>
          MarkedBlock::Handle* run() override
          {
              if (m_done)
                  return nullptr;
              auto locker = holdLock(m_lock);
<span class="udiff-line-modified-removed">-             m_index = m_directory.m_markingNotEmpty.findBit(m_index, true);</span>
<span class="udiff-line-modified-added">+             m_index = m_directory.m_bits.markingNotEmpty().findBit(m_index, true);</span>
              if (m_index &gt;= m_directory.m_blocks.size()) {
                  m_done = true;
                  return nullptr;
              }
              return m_directory.m_blocks[m_index++];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -355,22 +347,23 @@</span>
  void BlockDirectory::dumpBits(PrintStream&amp; out)
  {
      unsigned maxNameLength = 0;
      forEachBitVectorWithName(
          NoLockingNecessary,
<span class="udiff-line-modified-removed">-         [&amp;] (FastBitVector&amp;, const char* name) {</span>
<span class="udiff-line-modified-added">+         [&amp;](auto vectorRef, const char* name) {</span>
<span class="udiff-line-added">+             UNUSED_PARAM(vectorRef);</span>
              unsigned length = strlen(name);
              maxNameLength = std::max(maxNameLength, length);
          });
  
      forEachBitVectorWithName(
          NoLockingNecessary,
<span class="udiff-line-modified-removed">-         [&amp;] (FastBitVector&amp; vector, const char* name) {</span>
<span class="udiff-line-modified-added">+         [&amp;](auto vectorRef, const char* name) {</span>
              out.print(&quot;    &quot;, name, &quot;: &quot;);
              for (unsigned i = maxNameLength - strlen(name); i--;)
                  out.print(&quot; &quot;);
<span class="udiff-line-modified-removed">-             out.print(vector, &quot;\n&quot;);</span>
<span class="udiff-line-modified-added">+             out.print(vectorRef, &quot;\n&quot;);</span>
          });
  }
  
  MarkedSpace&amp; BlockDirectory::markedSpace() const
  {
</pre>
<center><a href="AtomIndices.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BlockDirectory.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Stefan Schimanski (1Stein@gmx.de)
  5  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;HTMLPlugInElement.h&quot;
 25 
 26 #include &quot;BridgeJSC.h&quot;
 27 #include &quot;CSSPropertyNames.h&quot;
 28 #include &quot;Document.h&quot;
 29 #include &quot;Event.h&quot;
 30 #include &quot;EventHandler.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameLoader.h&quot;
 33 #include &quot;FrameTree.h&quot;
 34 #include &quot;HTMLNames.h&quot;
 35 #include &quot;HitTestResult.h&quot;
 36 #include &quot;Logging.h&quot;
 37 #include &quot;MIMETypeRegistry.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PluginData.h&quot;
 40 #include &quot;PluginReplacement.h&quot;
 41 #include &quot;PluginViewBase.h&quot;
 42 #include &quot;RenderEmbeddedObject.h&quot;
 43 #include &quot;RenderLayer.h&quot;
 44 #include &quot;RenderSnapshottedPlugIn.h&quot;
 45 #include &quot;RenderView.h&quot;
 46 #include &quot;RenderWidget.h&quot;
<a name="1" id="anc1"></a>
 47 #include &quot;ScriptController.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;ShadowRoot.h&quot;
 50 #include &quot;SubframeLoader.h&quot;
 51 #include &quot;Widget.h&quot;
 52 #include &lt;wtf/IsoMallocInlines.h&gt;
 53 
 54 #if ENABLE(NETSCAPE_PLUGIN_API)
 55 #include &quot;npruntime_impl.h&quot;
 56 #endif
 57 
 58 #if PLATFORM(COCOA)
 59 #include &quot;QuickTimePluginReplacement.h&quot;
 60 #include &quot;YouTubePluginReplacement.h&quot;
 61 #endif
 62 
 63 namespace WebCore {
 64 
 65 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLPlugInElement);
 66 
 67 using namespace HTMLNames;
 68 
 69 HTMLPlugInElement::HTMLPlugInElement(const QualifiedName&amp; tagName, Document&amp; document)
 70     : HTMLFrameOwnerElement(tagName, document)
 71     , m_inBeforeLoadEventHandler(false)
 72     , m_swapRendererTimer(*this, &amp;HTMLPlugInElement::swapRendererTimerFired)
 73     , m_isCapturingMouseEvents(false)
 74     , m_displayState(Playing)
 75 {
 76     setHasCustomStyleResolveCallbacks();
 77 }
 78 
 79 HTMLPlugInElement::~HTMLPlugInElement()
 80 {
 81     ASSERT(!m_instance); // cleared in detach()
 82 }
 83 
 84 bool HTMLPlugInElement::canProcessDrag() const
 85 {
 86     const PluginViewBase* plugin = is&lt;PluginViewBase&gt;(pluginWidget()) ? downcast&lt;PluginViewBase&gt;(pluginWidget()) : nullptr;
 87     return plugin ? plugin-&gt;canProcessDrag() : false;
 88 }
 89 
 90 bool HTMLPlugInElement::willRespondToMouseClickEvents()
 91 {
 92     if (isDisabledFormControl())
 93         return false;
 94     auto renderer = this-&gt;renderer();
 95     return renderer &amp;&amp; renderer-&gt;isWidget();
 96 }
 97 
 98 void HTMLPlugInElement::willDetachRenderers()
 99 {
100     m_instance = nullptr;
101 
102     if (m_isCapturingMouseEvents) {
103         if (RefPtr&lt;Frame&gt; frame = document().frame())
104             frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
105         m_isCapturingMouseEvents = false;
106     }
107 }
108 
109 void HTMLPlugInElement::resetInstance()
110 {
111     m_instance = nullptr;
112 }
113 
114 JSC::Bindings::Instance* HTMLPlugInElement::bindingsInstance()
115 {
116     auto frame = makeRefPtr(document().frame());
117     if (!frame)
118         return nullptr;
119 
120     // If the host dynamically turns off JavaScript (or Java) we will still return
121     // the cached allocated Bindings::Instance.  Not supporting this edge-case is OK.
122 
123     if (!m_instance) {
124         if (auto widget = makeRefPtr(pluginWidget()))
125             m_instance = frame-&gt;script().createScriptInstanceForWidget(widget.get());
126     }
127     return m_instance.get();
128 }
129 
130 bool HTMLPlugInElement::guardedDispatchBeforeLoadEvent(const String&amp; sourceURL)
131 {
132     // FIXME: Our current plug-in loading design can&#39;t guarantee the following
133     // assertion is true, since plug-in loading can be initiated during layout,
134     // and synchronous layout can be initiated in a beforeload event handler!
135     // See &lt;http://webkit.org/b/71264&gt;.
136     // ASSERT(!m_inBeforeLoadEventHandler);
137     m_inBeforeLoadEventHandler = true;
138     // static_cast is used to avoid a compile error since dispatchBeforeLoadEvent
139     // is intentionally undefined on this class.
140     bool beforeLoadAllowedLoad = static_cast&lt;HTMLFrameOwnerElement*&gt;(this)-&gt;dispatchBeforeLoadEvent(sourceURL);
141     m_inBeforeLoadEventHandler = false;
142     return beforeLoadAllowedLoad;
143 }
144 
145 Widget* HTMLPlugInElement::pluginWidget(PluginLoadingPolicy loadPolicy) const
146 {
147     if (m_inBeforeLoadEventHandler) {
148         // The plug-in hasn&#39;t loaded yet, and it makes no sense to try to load if beforeload handler happened to touch the plug-in element.
149         // That would recursively call beforeload for the same element.
150         return nullptr;
151     }
152 
153     RenderWidget* renderWidget = loadPolicy == PluginLoadingPolicy::Load ? renderWidgetLoadingPlugin() : this-&gt;renderWidget();
154     if (!renderWidget)
155         return nullptr;
156 
157     return renderWidget-&gt;widget();
158 }
159 
160 bool HTMLPlugInElement::isPresentationAttribute(const QualifiedName&amp; name) const
161 {
162     if (name == widthAttr || name == heightAttr || name == vspaceAttr || name == hspaceAttr || name == alignAttr)
163         return true;
164     return HTMLFrameOwnerElement::isPresentationAttribute(name);
165 }
166 
167 void HTMLPlugInElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
168 {
169     if (name == widthAttr)
170         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
171     else if (name == heightAttr)
172         addHTMLLengthToStyle(style, CSSPropertyHeight, value);
173     else if (name == vspaceAttr) {
174         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
175         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
176     } else if (name == hspaceAttr) {
177         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
178         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
179     } else if (name == alignAttr)
180         applyAlignmentAttributeToStyle(value, style);
181     else
182         HTMLFrameOwnerElement::collectStyleForPresentationAttribute(name, value, style);
183 }
184 
185 void HTMLPlugInElement::defaultEventHandler(Event&amp; event)
186 {
187     // Firefox seems to use a fake event listener to dispatch events to plug-in (tested with mouse events only).
188     // This is observable via different order of events - in Firefox, event listeners specified in HTML attributes fires first, then an event
189     // gets dispatched to plug-in, and only then other event listeners fire. Hopefully, this difference does not matter in practice.
190 
191     // FIXME: Mouse down and scroll events are passed down to plug-in via custom code in EventHandler; these code paths should be united.
192 
193     auto renderer = this-&gt;renderer();
194     if (!is&lt;RenderWidget&gt;(renderer))
195         return;
196 
197     if (is&lt;RenderEmbeddedObject&gt;(*renderer)) {
198         if (downcast&lt;RenderEmbeddedObject&gt;(*renderer).isPluginUnavailable()) {
199             downcast&lt;RenderEmbeddedObject&gt;(*renderer).handleUnavailablePluginIndicatorEvent(&amp;event);
200             return;
201         }
202 
203         if (is&lt;RenderSnapshottedPlugIn&gt;(*renderer) &amp;&amp; displayState() &lt; Restarting) {
204             downcast&lt;RenderSnapshottedPlugIn&gt;(*renderer).handleEvent(event);
205             HTMLFrameOwnerElement::defaultEventHandler(event);
206             return;
207         }
208 
209         if (displayState() &lt; Playing)
210             return;
211     }
212 
213     // Don&#39;t keep the widget alive over the defaultEventHandler call, since that can do things like navigate.
214     {
215         RefPtr&lt;Widget&gt; widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
216         if (!widget)
217             return;
218         widget-&gt;handleEvent(event);
219         if (event.defaultHandled())
220             return;
221     }
222     HTMLFrameOwnerElement::defaultEventHandler(event);
223 }
224 
225 bool HTMLPlugInElement::isKeyboardFocusable(KeyboardEvent*) const
226 {
227     // FIXME: Why is this check needed?
228     if (!document().page())
229         return false;
230 
231     RefPtr&lt;Widget&gt; widget = pluginWidget();
232     if (!is&lt;PluginViewBase&gt;(widget))
233         return false;
234 
235     return downcast&lt;PluginViewBase&gt;(*widget).supportsKeyboardFocus();
236 }
237 
238 bool HTMLPlugInElement::isPluginElement() const
239 {
240     return true;
241 }
242 
243 bool HTMLPlugInElement::isUserObservable() const
244 {
245     // No widget - can&#39;t be anything to see or hear here.
246     RefPtr&lt;Widget&gt; widget = pluginWidget(PluginLoadingPolicy::DoNotLoad);
247     if (!is&lt;PluginViewBase&gt;(widget))
248         return false;
249 
250     PluginViewBase&amp; pluginView = downcast&lt;PluginViewBase&gt;(*widget);
251 
252     // If audio is playing (or might be) then the plugin is detectable.
253     if (pluginView.audioHardwareActivity() != AudioHardwareActivityType::IsInactive)
254         return true;
255 
256     // If the plugin is visible and not vanishingly small in either dimension it is detectable.
257     return pluginView.isVisible() &amp;&amp; pluginView.width() &gt; 2 &amp;&amp; pluginView.height() &gt; 2;
258 }
259 
260 bool HTMLPlugInElement::supportsFocus() const
261 {
262     if (HTMLFrameOwnerElement::supportsFocus())
263         return true;
264 
265     if (useFallbackContent() || !is&lt;RenderEmbeddedObject&gt;(renderer()))
266         return false;
267     return !downcast&lt;RenderEmbeddedObject&gt;(*renderer()).isPluginUnavailable();
268 }
269 
270 RenderPtr&lt;RenderElement&gt; HTMLPlugInElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
271 {
272     if (m_pluginReplacement &amp;&amp; m_pluginReplacement-&gt;willCreateRenderer())
273         return m_pluginReplacement-&gt;createElementRenderer(*this, WTFMove(style), insertionPosition);
274 
275     return createRenderer&lt;RenderEmbeddedObject&gt;(*this, WTFMove(style));
276 }
277 
278 void HTMLPlugInElement::swapRendererTimerFired()
279 {
280     ASSERT(displayState() == PreparingPluginReplacement || displayState() == DisplayingSnapshot);
281     if (userAgentShadowRoot())
282         return;
283 
284     // Create a shadow root, which will trigger the code to add a snapshot container
285     // and reattach, thus making a new Renderer.
286     ensureUserAgentShadowRoot();
287 }
288 
289 void HTMLPlugInElement::setDisplayState(DisplayState state)
290 {
291     if (state == m_displayState)
292         return;
293 
294     m_displayState = state;
295 
296     m_swapRendererTimer.stop();
297     if (state == DisplayingSnapshot || displayState() == PreparingPluginReplacement)
298         m_swapRendererTimer.startOneShot(0_s);
299 }
300 
301 void HTMLPlugInElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
302 {
303     if (!m_pluginReplacement || !document().page() || displayState() != PreparingPluginReplacement)
304         return;
305 
306     root.setResetStyleInheritance(true);
307     if (m_pluginReplacement-&gt;installReplacement(root)) {
308         setDisplayState(DisplayingPluginReplacement);
309         invalidateStyleAndRenderersForSubtree();
310     }
311 }
312 
313 #if PLATFORM(COCOA)
314 static void registrar(const ReplacementPlugin&amp;);
315 #endif
316 
317 static Vector&lt;ReplacementPlugin*&gt;&amp; registeredPluginReplacements()
318 {
319     static NeverDestroyed&lt;Vector&lt;ReplacementPlugin*&gt;&gt; registeredReplacements;
320     static bool enginesQueried = false;
321 
322     if (enginesQueried)
323         return registeredReplacements;
324     enginesQueried = true;
325 
326 #if PLATFORM(COCOA)
327     QuickTimePluginReplacement::registerPluginReplacement(registrar);
328     YouTubePluginReplacement::registerPluginReplacement(registrar);
329 #endif
330 
331     return registeredReplacements;
332 }
333 
334 #if PLATFORM(COCOA)
335 static void registrar(const ReplacementPlugin&amp; replacement)
336 {
337     registeredPluginReplacements().append(new ReplacementPlugin(replacement));
338 }
339 #endif
340 
341 static ReplacementPlugin* pluginReplacementForType(const URL&amp; url, const String&amp; mimeType)
342 {
343     Vector&lt;ReplacementPlugin*&gt;&amp; replacements = registeredPluginReplacements();
344     if (replacements.isEmpty())
345         return nullptr;
346 
347     String extension;
348     String lastPathComponent = url.lastPathComponent();
349     size_t dotOffset = lastPathComponent.reverseFind(&#39;.&#39;);
350     if (dotOffset != notFound)
351         extension = lastPathComponent.substring(dotOffset + 1);
352 
353     String type = mimeType;
354     if (type.isEmpty() &amp;&amp; url.protocolIsData())
355         type = mimeTypeFromDataURL(url.string());
356 
357     if (type.isEmpty() &amp;&amp; !extension.isEmpty()) {
358         for (auto* replacement : replacements) {
359             if (replacement-&gt;supportsFileExtension(extension) &amp;&amp; replacement-&gt;supportsURL(url))
360                 return replacement;
361         }
362     }
363 
364     if (type.isEmpty()) {
365         if (extension.isEmpty())
366             return nullptr;
367         type = MIMETypeRegistry::getMediaMIMETypeForExtension(extension);
368     }
369 
370     if (type.isEmpty())
371         return nullptr;
372 
373     for (auto* replacement : replacements) {
374         if (replacement-&gt;supportsType(type) &amp;&amp; replacement-&gt;supportsURL(url))
375             return replacement;
376     }
377 
378     return nullptr;
379 }
380 
381 bool HTMLPlugInElement::requestObject(const String&amp; relativeURL, const String&amp; mimeType, const Vector&lt;String&gt;&amp; paramNames, const Vector&lt;String&gt;&amp; paramValues)
382 {
383     if (m_pluginReplacement)
384         return true;
385 
386     URL completedURL;
387     if (!relativeURL.isEmpty())
388         completedURL = document().completeURL(relativeURL);
389 
390     ReplacementPlugin* replacement = pluginReplacementForType(completedURL, mimeType);
391     if (!replacement || !replacement-&gt;isEnabledBySettings(document().settings()))
392         return false;
393 
394     LOG(Plugins, &quot;%p - Found plug-in replacement for %s.&quot;, this, completedURL.string().utf8().data());
395 
396     m_pluginReplacement = replacement-&gt;create(*this, paramNames, paramValues);
397     setDisplayState(PreparingPluginReplacement);
398     return true;
399 }
400 
401 JSC::JSObject* HTMLPlugInElement::scriptObjectForPluginReplacement()
402 {
403     if (m_pluginReplacement)
404         return m_pluginReplacement-&gt;scriptObject();
405     return nullptr;
406 }
407 
408 bool HTMLPlugInElement::isBelowSizeThreshold() const
409 {
410     auto* renderObject = renderer();
411     if (!is&lt;RenderEmbeddedObject&gt;(renderObject))
412         return true;
413     auto&amp; renderEmbeddedObject = downcast&lt;RenderEmbeddedObject&gt;(*renderObject);
414     return renderEmbeddedObject.isPluginUnavailable() &amp;&amp; renderEmbeddedObject.pluginUnavailabilityReason() == RenderEmbeddedObject::PluginTooSmall;
415 }
416 
417 bool HTMLPlugInElement::setReplacement(RenderEmbeddedObject::PluginUnavailabilityReason reason, const String&amp; unavailabilityDescription)
418 {
419     if (!is&lt;RenderEmbeddedObject&gt;(renderer()))
420         return false;
421 
422     if (reason == RenderEmbeddedObject::UnsupportedPlugin)
423         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Tried to use an unsupported plug-in.&quot;_s);
424 
425     Ref&lt;HTMLPlugInElement&gt; protectedThis(*this);
426     downcast&lt;RenderEmbeddedObject&gt;(*renderer()).setPluginUnavailabilityReasonWithDescription(reason, unavailabilityDescription);
427     bool replacementIsObscured = isReplacementObscured();
428     // hittest in isReplacementObscured() method could destroy the renderer. Let&#39;s refetch it.
429     if (is&lt;RenderEmbeddedObject&gt;(renderer()))
430         downcast&lt;RenderEmbeddedObject&gt;(*renderer()).setUnavailablePluginIndicatorIsHidden(replacementIsObscured);
431     return replacementIsObscured;
432 }
433 
434 bool HTMLPlugInElement::isReplacementObscured()
435 {
436     auto topDocument = makeRef(document().topDocument());
437     auto topFrameView = makeRefPtr(topDocument-&gt;view());
438     if (!topFrameView)
439         return false;
440 
441     topFrameView-&gt;updateLayoutAndStyleIfNeededRecursive();
442 
443     // Updating the layout may have detached this document from the top document.
444     auto* renderView = topDocument-&gt;renderView();
445     if (!renderView || !document().view() || &amp;document().topDocument() != topDocument.ptr())
446         return false;
447 
448     if (!renderer() || !is&lt;RenderEmbeddedObject&gt;(*renderer()))
449         return false;
450     auto&amp; pluginRenderer = downcast&lt;RenderEmbeddedObject&gt;(*renderer());
451     // Check the opacity of each layer containing the element or its ancestors.
452     float opacity = 1.0;
453     for (auto* layer = pluginRenderer.enclosingLayer(); layer; layer = layer-&gt;parent()) {
454         opacity *= layer-&gt;renderer().style().opacity();
455         if (opacity &lt; 0.1)
456             return true;
457     }
458     // Calculate the absolute rect for the blocked plugin replacement text.
459     LayoutPoint absoluteLocation(pluginRenderer.absoluteBoundingBoxRect().location());
460     LayoutRect rect = pluginRenderer.unavailablePluginIndicatorBounds(absoluteLocation);
461     if (rect.isEmpty())
462         return true;
463     auto viewRect = document().view()-&gt;convertToRootView(snappedIntRect(rect));
464     auto x = viewRect.x();
465     auto y = viewRect.y();
466     auto width = viewRect.width();
467     auto height = viewRect.height();
468     // Hit test the center and near the corners of the replacement text to ensure
469     // it is visible and is not masked by other elements.
470     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::IgnoreClipping | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowChildFrameContent);
471     HitTestResult result;
472     HitTestLocation location = LayoutPoint(x + width / 2, y + height / 2);
473     ASSERT(!renderView-&gt;needsLayout());
474     ASSERT(!renderView-&gt;document().needsStyleRecalc());
475     bool hit = topDocument-&gt;hitTest(request, location, result);
476     if (!hit || result.innerNode() != &amp;pluginRenderer.frameOwnerElement())
477         return true;
478 
479     location = LayoutPoint(x, y);
480     hit = topDocument-&gt;hitTest(request, location, result);
481     if (!hit || result.innerNode() != &amp;pluginRenderer.frameOwnerElement())
482         return true;
483 
484     location = LayoutPoint(x + width, y);
485     hit = topDocument-&gt;hitTest(request, location, result);
486     if (!hit || result.innerNode() != &amp;pluginRenderer.frameOwnerElement())
487         return true;
488 
489     location = LayoutPoint(x + width, y + height);
490     hit = topDocument-&gt;hitTest(request, location, result);
491     if (!hit || result.innerNode() != &amp;pluginRenderer.frameOwnerElement())
492         return true;
493 
494     location = LayoutPoint(x, y + height);
495     hit = topDocument-&gt;hitTest(request, location, result);
496     if (!hit || result.innerNode() != &amp;pluginRenderer.frameOwnerElement())
497         return true;
498     return false;
499 }
500 
501 bool HTMLPlugInElement::canLoadScriptURL(const URL&amp;) const
502 {
503     // FIXME: Probably want to at least check canAddSubframe.
504     return true;
505 }
506 
507 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
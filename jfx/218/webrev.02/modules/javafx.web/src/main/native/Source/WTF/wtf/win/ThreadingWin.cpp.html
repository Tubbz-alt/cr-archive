<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007, 2008, 2015 Apple Inc. All rights reserved.
  3  * Copyright (C) 2009 Google Inc. All rights reserved.
  4  * Copyright (C) 2009 Torch Mobile, Inc. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  * 1.  Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  * 2.  Redistributions in binary form must reproduce the above copyright
 13  *     notice, this list of conditions and the following disclaimer in the
 14  *     documentation and/or other materials provided with the distribution.
 15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 16  *     its contributors may be used to endorse or promote products derived
 17  *     from this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 /*
 32  * There are numerous academic and practical works on how to implement pthread_cond_wait/pthread_cond_signal/pthread_cond_broadcast
 33  * functions on Win32. Here is one example: http://www.cs.wustl.edu/~schmidt/win32-cv-1.html which is widely credited as a &#39;starting point&#39;
 34  * of modern attempts. There are several more or less proven implementations, one in Boost C++ library (http://www.boost.org) and another
 35  * in pthreads-win32 (http://sourceware.org/pthreads-win32/).
 36  *
 37  * The number of articles and discussions is the evidence of significant difficulties in implementing these primitives correctly.
 38  * The brief search of revisions, ChangeLog entries, discussions in comp.programming.threads and other places clearly documents
 39  * numerous pitfalls and performance problems the authors had to overcome to arrive to the suitable implementations.
 40  * Optimally, WebKit would use one of those supported/tested libraries directly. To roll out our own implementation is impractical,
 41  * if even for the lack of sufficient testing. However, a faithful reproduction of the code from one of the popular supported
 42  * libraries seems to be a good compromise.
 43  *
 44  * The early Boost implementation (http://www.boxbackup.org/trac/browser/box/nick/win/lib/win32/boost_1_32_0/libs/thread/src/condition.cpp?rev=30)
 45  * is identical to pthreads-win32 (http://sourceware.org/cgi-bin/cvsweb.cgi/pthreads/pthread_cond_wait.c?rev=1.10&amp;content-type=text/x-cvsweb-markup&amp;cvsroot=pthreads-win32).
 46  * Current Boost uses yet another (although seemingly equivalent) algorithm which came from their &#39;thread rewrite&#39; effort.
 47  *
 48  * This file includes timedWait/signal/broadcast implementations translated to WebKit coding style from the latest algorithm by
 49  * Alexander Terekhov and Louis Thomas, as captured here: http://sourceware.org/cgi-bin/cvsweb.cgi/pthreads/pthread_cond_wait.c?rev=1.10&amp;content-type=text/x-cvsweb-markup&amp;cvsroot=pthreads-win32
 50  * It replaces the implementation of their previous algorithm, also documented in the same source above.
 51  * The naming and comments are left very close to original to enable easy cross-check.
 52  *
 53  * The corresponding Pthreads-win32 License is included below, and CONTRIBUTORS file which it refers to is added to
 54  * source directory (as CONTRIBUTORS.pthreads-win32).
 55  */
 56 
 57 /*
 58  *      Pthreads-win32 - POSIX Threads Library for Win32
 59  *      Copyright(C) 1998 John E. Bossom
 60  *      Copyright(C) 1999,2005 Pthreads-win32 contributors
 61  *
 62  *      Contact Email: rpj@callisto.canberra.edu.au
 63  *
 64  *      The current list of contributors is contained
 65  *      in the file CONTRIBUTORS included with the source
 66  *      code distribution. The list can also be seen at the
 67  *      following World Wide Web location:
 68  *      http://sources.redhat.com/pthreads-win32/contributors.html
 69  *
 70  *      This library is free software; you can redistribute it and/or
 71  *      modify it under the terms of the GNU Lesser General Public
 72  *      License as published by the Free Software Foundation; either
 73  *      version 2 of the License, or (at your option) any later version.
 74  *
 75  *      This library is distributed in the hope that it will be useful,
 76  *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 77  *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 78  *      Lesser General Public License for more details.
 79  *
 80  *      You should have received a copy of the GNU Lesser General Public
 81  *      License along with this library in the file COPYING.LIB;
 82  *      if not, write to the Free Software Foundation, Inc.,
 83  *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 84  */
 85 
 86 #include &quot;config.h&quot;
 87 #include &lt;wtf/Threading.h&gt;
 88 
 89 #include &lt;errno.h&gt;
 90 #include &lt;process.h&gt;
 91 #include &lt;windows.h&gt;
 92 #include &lt;wtf/HashMap.h&gt;
 93 #include &lt;wtf/Lock.h&gt;
 94 #include &lt;wtf/MainThread.h&gt;
 95 #include &lt;wtf/MathExtras.h&gt;
 96 #include &lt;wtf/NeverDestroyed.h&gt;
 97 #include &lt;wtf/ThreadingPrimitives.h&gt;
 98 
 99 namespace WTF {
100 
101 static Lock globalSuspendLock;
102 
103 Thread::~Thread()
104 {
105     // It is OK because FLSAlloc&#39;s callback will be called even before there are some open handles.
106     // This easily ensures that all the thread resources are automatically closed.
107     if (m_handle != INVALID_HANDLE_VALUE)
108         CloseHandle(m_handle);
109 }
110 
111 void Thread::initializeCurrentThreadEvenIfNonWTFCreated()
112 {
113 }
114 
115 // MS_VC_EXCEPTION, THREADNAME_INFO, and setThreadNameInternal all come from &lt;http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx&gt;.
116 static const DWORD MS_VC_EXCEPTION = 0x406D1388;
117 
118 #pragma pack(push, 8)
119 typedef struct tagTHREADNAME_INFO {
120     DWORD dwType; // must be 0x1000
121     LPCSTR szName; // pointer to name (in user addr space)
122     DWORD dwThreadID; // thread ID (-1=caller thread)
123     DWORD dwFlags; // reserved for future use, must be zero
124 } THREADNAME_INFO;
125 #pragma pack(pop)
126 
127 void Thread::initializeCurrentThreadInternal(const char* szThreadName)
128 {
129 #if COMPILER(MINGW)
130     // FIXME: Implement thread name setting with MingW.
131     UNUSED_PARAM(szThreadName);
132 #else
133     THREADNAME_INFO info;
134     info.dwType = 0x1000;
135     info.szName = Thread::normalizeThreadName(szThreadName);
136     info.dwThreadID = GetCurrentThreadId();
137     info.dwFlags = 0;
138 
139     __try {
140         RaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), reinterpret_cast&lt;ULONG_PTR*&gt;(&amp;info));
141     } __except(EXCEPTION_CONTINUE_EXECUTION) { }
142 #endif
143     initializeCurrentThreadEvenIfNonWTFCreated();
144 }
145 
146 void Thread::initializePlatformThreading()
147 {
148 }
149 
150 static unsigned __stdcall wtfThreadEntryPoint(void* data)
151 {
152     Thread::entryPoint(reinterpret_cast&lt;Thread::NewThreadContext*&gt;(data));
153     return 0;
154 }
155 
156 bool Thread::establishHandle(NewThreadContext* data)
157 {
158     size_t stackSize = 0;
159 #if PLATFORM(JAVA) &amp;&amp; USE(JSVALUE32_64)
160     stackSize = 1024 * 1024;
161 #endif
162     unsigned threadIdentifier = 0;
163     unsigned initFlag = stackSize ? STACK_SIZE_PARAM_IS_A_RESERVATION : 0;
164 
165     HANDLE threadHandle = reinterpret_cast&lt;HANDLE&gt;(_beginthreadex(0, stackSize, wtfThreadEntryPoint, data, initFlag, &amp;threadIdentifier));
166     if (!threadHandle) {
167         LOG_ERROR(&quot;Failed to create thread at entry point %p with data %p: %ld&quot;, wtfThreadEntryPoint, data, errno);
168         return false;
169     }
170     establishPlatformSpecificHandle(threadHandle, threadIdentifier);
171     return true;
172 }
173 
174 void Thread::changePriority(int delta)
175 {
176     auto locker = holdLock(m_mutex);
177     SetThreadPriority(m_handle, THREAD_PRIORITY_NORMAL + delta);
178 }
179 
180 int Thread::waitForCompletion()
181 {
182     HANDLE handle;
183     {
184         auto locker = holdLock(m_mutex);
185         handle = m_handle;
186     }
187 
188     DWORD joinResult = WaitForSingleObject(handle, INFINITE);
189     if (joinResult == WAIT_FAILED)
190         LOG_ERROR(&quot;Thread %p was found to be deadlocked trying to quit&quot;, this);
191 
192     auto locker = holdLock(m_mutex);
193     ASSERT(joinableState() == Joinable);
194 
195     // The thread has already exited, do nothing.
196     // The thread hasn&#39;t exited yet, so don&#39;t clean anything up. Just signal that we&#39;ve already joined on it so that it will clean up after itself.
197     if (!hasExited())
198         didJoin();
199 
200     return joinResult;
201 }
202 
203 void Thread::detach()
204 {
205     // We follow the pthread semantics: even after the detach is called,
206     // we can still perform various operations onto the thread. For example,
207     // we can do pthread_kill for the detached thread. The problem in Windows
208     // is that closing HANDLE loses the way to do such operations.
209     // To do so, we do nothing here in Windows. Original detach&#39;s purpose,
210     // releasing thread resource when the thread exits, will be achieved by
211     // FlsCallback automatically. FlsCallback will call CloseHandle to clean up
212     // resource. So in this function, we just mark the thread as detached to
213     // avoid calling waitForCompletion for this thread.
214     auto locker = holdLock(m_mutex);
215     if (!hasExited())
216         didBecomeDetached();
217 }
218 
219 auto Thread::suspend() -&gt; Expected&lt;void, PlatformSuspendError&gt;
220 {
221     RELEASE_ASSERT_WITH_MESSAGE(this != &amp;Thread::current(), &quot;We do not support suspending the current thread itself.&quot;);
222     LockHolder locker(globalSuspendLock);
223     DWORD result = SuspendThread(m_handle);
224     if (result != (DWORD)-1)
225         return { };
226     return makeUnexpected(result);
227 }
228 
229 // During resume, suspend or resume should not be executed from the other threads.
230 void Thread::resume()
231 {
232     LockHolder locker(globalSuspendLock);
233     ResumeThread(m_handle);
234 }
235 
236 size_t Thread::getRegisters(PlatformRegisters&amp; registers)
237 {
238     LockHolder locker(globalSuspendLock);
239     registers.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
240     GetThreadContext(m_handle, &amp;registers);
241     return sizeof(CONTEXT);
242 }
243 
244 Thread&amp; Thread::initializeCurrentTLS()
245 {
246     // Not a WTF-created thread, ThreadIdentifier is not established yet.
247     Ref&lt;Thread&gt; thread = adoptRef(*new Thread());
248 
249     HANDLE handle;
250     bool isSuccessful = DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(), &amp;handle, 0, FALSE, DUPLICATE_SAME_ACCESS);
251     RELEASE_ASSERT(isSuccessful);
252 
253     thread-&gt;establishPlatformSpecificHandle(handle, currentID());
254     thread-&gt;initializeInThread();
255     initializeCurrentThreadEvenIfNonWTFCreated();
256 
257     return initializeTLS(WTFMove(thread));
258 }
259 
260 ThreadIdentifier Thread::currentID()
261 {
262     return static_cast&lt;ThreadIdentifier&gt;(GetCurrentThreadId());
263 }
264 
265 void Thread::establishPlatformSpecificHandle(HANDLE handle, ThreadIdentifier threadID)
266 {
267     auto locker = holdLock(m_mutex);
268     m_handle = handle;
269     m_id = threadID;
270 }
271 
272 struct Thread::ThreadHolder {
273     ~ThreadHolder()
274     {
275         if (thread) {
276             thread-&gt;specificStorage().destroySlots();
277             thread-&gt;didExit();
278         }
279     }
280 
281     RefPtr&lt;Thread&gt; thread;
282 };
283 
284 thread_local static Thread::ThreadHolder s_threadHolder;
285 
286 Thread* Thread::currentMayBeNull()
287 {
288     return s_threadHolder.thread.get();
289 }
290 
291 Thread&amp; Thread::initializeTLS(Ref&lt;Thread&gt;&amp;&amp; thread)
292 {
293     s_threadHolder.thread = WTFMove(thread);
294     return *s_threadHolder.thread;
295 }
296 
297 Atomic&lt;int&gt; Thread::SpecificStorage::s_numberOfKeys;
298 std::array&lt;Atomic&lt;Thread::SpecificStorage::DestroyFunction&gt;, Thread::SpecificStorage::s_maxKeys&gt; Thread::SpecificStorage::s_destroyFunctions;
299 
300 bool Thread::SpecificStorage::allocateKey(int&amp; key, DestroyFunction destroy)
301 {
302     int k = s_numberOfKeys.exchangeAdd(1);
303     if (k &gt;= s_maxKeys) {
304         s_numberOfKeys.exchangeSub(1);
305         return false;
306     }
307     key = k;
308     s_destroyFunctions[key].store(destroy);
309     return true;
310 }
311 
312 void* Thread::SpecificStorage::get(int key)
313 {
314     return m_slots[key];
315 }
316 
317 void Thread::SpecificStorage::set(int key, void* value)
318 {
319     m_slots[key] = value;
320 }
321 
322 void Thread::SpecificStorage::destroySlots()
323 {
324     auto numberOfKeys = s_numberOfKeys.load();
325     for (size_t i = 0; i &lt; numberOfKeys; i++) {
326         auto destroy = s_destroyFunctions[i].load();
327         if (destroy &amp;&amp; m_slots[i]) {
328             destroy(m_slots[i]);
329             m_slots[i] = nullptr;
330         }
331     }
332 }
333 
334 Mutex::~Mutex()
335 {
336 }
337 
338 void Mutex::lock()
339 {
340     AcquireSRWLockExclusive(&amp;m_mutex);
341 }
342 
343 bool Mutex::tryLock()
344 {
345     return TryAcquireSRWLockExclusive(&amp;m_mutex);
346 }
347 
348 void Mutex::unlock()
349 {
350     ReleaseSRWLockExclusive(&amp;m_mutex);
351 }
352 
353 // Returns an interval in milliseconds suitable for passing to one of the Win32 wait functions (e.g., ::WaitForSingleObject).
354 static DWORD absoluteTimeToWaitTimeoutInterval(WallTime absoluteTime)
355 {
356     WallTime currentTime = WallTime::now();
357 
358     // Time is in the past - return immediately.
359     if (absoluteTime &lt; currentTime)
360         return 0;
361 
362     // Time is too far in the future (and would overflow unsigned long) - wait forever.
363     if ((absoluteTime - currentTime) &gt; Seconds::fromMilliseconds(INT_MAX))
364         return INFINITE;
365 
366     return static_cast&lt;DWORD&gt;((absoluteTime - currentTime).milliseconds());
367 }
368 
369 ThreadCondition::~ThreadCondition()
370 {
371 }
372 
373 void ThreadCondition::wait(Mutex&amp; mutex)
374 {
375     SleepConditionVariableSRW(&amp;m_condition, &amp;mutex.impl(), INFINITE, 0);
376 }
377 
378 bool ThreadCondition::timedWait(Mutex&amp; mutex, WallTime absoluteTime)
379 {
380     // https://msdn.microsoft.com/en-us/library/windows/desktop/ms686304(v=vs.85).aspx
381     DWORD interval = absoluteTimeToWaitTimeoutInterval(absoluteTime);
382     if (!interval) {
383         // Consider the wait to have timed out, even if our condition has already been signaled, to
384         // match the pthreads implementation.
385         return false;
386     }
387 
388     if (SleepConditionVariableSRW(&amp;m_condition, &amp;mutex.impl(), interval, 0))
389         return true;
390     ASSERT(GetLastError() == ERROR_TIMEOUT);
391     return false;
392 }
393 
394 void ThreadCondition::signal()
395 {
396     WakeConditionVariable(&amp;m_condition);
397 }
398 
399 void ThreadCondition::broadcast()
400 {
401     WakeAllConditionVariable(&amp;m_condition);
402 }
403 
404 void Thread::yield()
405 {
406     SwitchToThread();
407 }
408 
409 } // namespace WTF
    </pre>
  </body>
</html>
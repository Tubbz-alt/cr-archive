<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/controls/auto-hide-controller.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 const AutoHideDelayMS = 4000;
 27 
 28 class AutoHideController
 29 {
 30 
 31     constructor(mediaControls)
 32     {
 33         this._mediaControls = mediaControls;
 34 
 35         if (GestureRecognizer.SupportsTouches) {
 36             this._touchIdentifiersPreventingAutoHide = new Set;
 37             this._tapGestureRecognizer = new TapGestureRecognizer(this._mediaControls.element, this);
 38         }
 39 
 40         this.autoHideDelay = AutoHideDelayMS;
 41     }
 42 
 43     // Public
 44 
 45     get fadesWhileIdle()
 46     {
 47         return this._fadesWhileIdle;
 48     }
 49 
 50     set fadesWhileIdle(flag)
 51     {
 52         if (this._fadesWhileIdle == flag)
 53             return;
 54 
 55         this._fadesWhileIdle = flag;
 56 
 57         if (GestureRecognizer.SupportsTouches) {
 58             if (flag) {
 59                 this._mediaControls.element.addEventListener(&quot;touchstart&quot;, this);
 60                 this._mediaControls.element.addEventListener(&quot;touchend&quot;, this);
 61             } else {
 62                 this._mediaControls.element.removeEventListener(&quot;touchstart&quot;, this);
 63                 this._mediaControls.element.removeEventListener(&quot;touchend&quot;, this);
 64             }
 65             this._tapGestureRecognizer.enabled = flag;
 66         } else {
 67             if (flag) {
 68                 this._mediaControls.element.addEventListener(&quot;mousemove&quot;, this);
 69                 this._mediaControls.element.addEventListener(&quot;mouseleave&quot;, this);
 70             } else {
 71                 this._mediaControls.element.removeEventListener(&quot;mousemove&quot;, this);
 72                 this._mediaControls.element.removeEventListener(&quot;mouseleave&quot;, this);
 73             }
 74         }
 75 
 76         if (flag &amp;&amp; !this._mediaControls.faded)
 77             this._resetAutoHideTimer(false);
 78         else if (!flag)
 79             this._mediaControls.faded = false;
 80     }
 81 
 82     // Protected
 83 
 84     handleEvent(event)
 85     {
 86         if (event.currentTarget !== this._mediaControls.element)
 87             return;
 88 
 89         if (event.type === &quot;mousemove&quot;) {
 90             this._mediaControls.faded = false;
 91             this._resetAutoHideTimer(true);
 92             if (this._mediaControls.isPointInControls(new DOMPoint(event.clientX, event.clientY))) {
 93                 this._disableAutoHiding = true;
 94                 this._cancelNonEnforcedAutoHideTimer();
 95             } else {
 96                 delete this._disableAutoHiding;
 97                 this._resetAutoHideTimer(true);
 98             }
 99         } else if (event.type === &quot;mouseleave&quot; &amp;&amp; this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached &amp;&amp; !this._enforceAutoHideTimer)
100             this._mediaControls.faded = !this._mediaControls.isPointInControls(new DOMPoint(event.clientX, event.clientY));
101 
102         if (event.type === &quot;touchstart&quot;) {
103             // Remember the current faded state so that we can determine,
104             // if we recognize a tap, if it should fade the controls out.
105             this._nextTapCanFadeControls = !this._mediaControls.faded;
106             for (var touch in event.changedTouches)
107                 this._touchIdentifiersPreventingAutoHide.add(touch.identifier);
108             this._mediaControls.faded = false;
109             this._disableAutoHiding = true;
110             this._cancelNonEnforcedAutoHideTimer();
111         } else if (event.type === &quot;touchend&quot;) {
112             for (var touch in event.changedTouches)
113                 this._touchIdentifiersPreventingAutoHide.delete(touch.identifier);
114             if (!this._touchIdentifiersPreventingAutoHide.size) {
115                 delete this._disableAutoHiding;
116                 this._resetAutoHideTimer(true);
117             }
118         }
119     }
120 
121     gestureRecognizerStateDidChange(recognizer)
122     {
123         if (this._tapGestureRecognizer !== recognizer || recognizer.state !== GestureRecognizer.States.Recognized)
124             return;
125 
126         this._mediaControls.faded = this._nextTapCanFadeControls &amp;&amp; !this._mediaControls.isPointInControls(recognizer.locationInClient());
127         delete this._nextTapCanFadeControls;
128     }
129 
130     mediaControlsFadedStateDidChange()
131     {
132         if (this._mediaControls.faded)
133             delete this._enforceAutoHideTimer;
134         else
135             this._resetAutoHideTimer(true);
136     }
137 
138     mediaControlsBecameInvisible()
139     {
140         this._cancelNonEnforcedAutoHideTimer();
141     }
142 
143     // Private
144 
145     _cancelNonEnforcedAutoHideTimer()
146     {
147         if (!this._enforceAutoHideTimer)
148             this._cancelAutoHideTimer();
149     }
150 
151     _cancelAutoHideTimer()
152     {
153         window.clearTimeout(this._autoHideTimer);
154         delete this._autoHideTimer;
155     }
156 
157     _resetAutoHideTimer(cancelable)
158     {
159         if (cancelable &amp;&amp; this._enforceAutoHideTimer)
160             return;
161 
162         this._cancelAutoHideTimer();
163 
164         if (cancelable)
165             delete this._enforceAutoHideTimer;
166         else
167             this._enforceAutoHideTimer = true;
168 
169         this._autoHideTimer = window.setTimeout(this._autoHideTimerFired.bind(this), this.autoHideDelay);
170     }
171 
172     _autoHideTimerFired()
173     {
174         delete this._enforceAutoHideTimer;
175         if (this._disableAutoHiding)
176             return;
177 
178         this._cancelAutoHideTimer();
179         this._mediaControls.faded = this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached;
180     }
181 
182 }
    </pre>
  </body>
</html>
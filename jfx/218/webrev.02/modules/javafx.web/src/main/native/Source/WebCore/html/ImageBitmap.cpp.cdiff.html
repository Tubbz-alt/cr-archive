<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLVideoElement.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageBitmap.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,28 ***</span>
  #include &quot;HTMLVideoElement.h&quot;
  #include &quot;ImageBitmapOptions.h&quot;
  #include &quot;ImageBuffer.h&quot;
  #include &quot;ImageData.h&quot;
  #include &quot;IntRect.h&quot;
  #include &quot;JSImageBitmap.h&quot;
  #include &quot;LayoutSize.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;SharedBuffer.h&quot;
  #include &quot;TypedOMCSSImageValue.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/Variant.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(ImageBitmap);
  
  #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
<span class="line-modified">! static RenderingMode bufferRenderingMode = Accelerated;</span>
  #else
<span class="line-modified">! static RenderingMode bufferRenderingMode = Unaccelerated;</span>
  #endif
  
  Ref&lt;ImageBitmap&gt; ImageBitmap::create(IntSize size)
  {
      return create(ImageBuffer::create(FloatSize(size.width(), size.height()), bufferRenderingMode));
<span class="line-new-header">--- 38,34 ---</span>
  #include &quot;HTMLVideoElement.h&quot;
  #include &quot;ImageBitmapOptions.h&quot;
  #include &quot;ImageBuffer.h&quot;
  #include &quot;ImageData.h&quot;
  #include &quot;IntRect.h&quot;
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;JSImageBitmap.h&quot;
  #include &quot;LayoutSize.h&quot;
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+ #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added">+ #endif</span>
  #include &quot;RenderElement.h&quot;
  #include &quot;SharedBuffer.h&quot;
<span class="line-added">+ #include &quot;SuspendableTimer.h&quot;</span>
  #include &quot;TypedOMCSSImageValue.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/Optional.h&gt;
<span class="line-added">+ #include &lt;wtf/Scope.h&gt;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/Variant.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(ImageBitmap);
  
  #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
<span class="line-modified">! static RenderingMode bufferRenderingMode = RenderingMode::Accelerated;</span>
  #else
<span class="line-modified">! static RenderingMode bufferRenderingMode = RenderingMode::Unaccelerated;</span>
  #endif
  
  Ref&lt;ImageBitmap&gt; ImageBitmap::create(IntSize size)
  {
      return create(ImageBuffer::create(FloatSize(size.width(), size.height()), bufferRenderingMode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,20 ***</span>
  
  static InterpolationQuality interpolationQualityForResizeQuality(ImageBitmapOptions::ResizeQuality resizeQuality)
  {
      switch (resizeQuality) {
      case ImageBitmapOptions::ResizeQuality::Pixelated:
<span class="line-modified">!         return InterpolationNone;</span>
      case ImageBitmapOptions::ResizeQuality::Low:
<span class="line-modified">!         return InterpolationDefault; // Low is the default.</span>
      case ImageBitmapOptions::ResizeQuality::Medium:
<span class="line-modified">!         return InterpolationMedium;</span>
      case ImageBitmapOptions::ResizeQuality::High:
<span class="line-modified">!         return InterpolationHigh;</span>
      }
      ASSERT_NOT_REACHED();
<span class="line-modified">!     return InterpolationDefault;</span>
  }
  
  // FIXME: More steps from https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#cropped-to-the-source-rectangle-with-formatting
  
  // 7. Place input on an infinite transparent black grid plane, positioned so that its
<span class="line-new-header">--- 204,20 ---</span>
  
  static InterpolationQuality interpolationQualityForResizeQuality(ImageBitmapOptions::ResizeQuality resizeQuality)
  {
      switch (resizeQuality) {
      case ImageBitmapOptions::ResizeQuality::Pixelated:
<span class="line-modified">!         return InterpolationQuality::DoNotInterpolate;</span>
      case ImageBitmapOptions::ResizeQuality::Low:
<span class="line-modified">!         return InterpolationQuality::Default; // Low is the default.</span>
      case ImageBitmapOptions::ResizeQuality::Medium:
<span class="line-modified">!         return InterpolationQuality::Medium;</span>
      case ImageBitmapOptions::ResizeQuality::High:
<span class="line-modified">!         return InterpolationQuality::High;</span>
      }
      ASSERT_NOT_REACHED();
<span class="line-modified">!     return InterpolationQuality::Default;</span>
  }
  
  // FIXME: More steps from https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#cropped-to-the-source-rectangle-with-formatting
  
  // 7. Place input on an infinite transparent black grid plane, positioned so that its
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,16 ***</span>
      // 11. Resolve the promise with the new ImageBitmap object as the value.
  
      promise.resolve(WTFMove(imageBitmap));
  }
  
<span class="line-modified">! void ImageBitmap::createPromise(ScriptExecutionContext&amp;, RefPtr&lt;HTMLCanvasElement&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>
  {
      // 2. If the canvas element&#39;s bitmap has either a horizontal dimension or a vertical
      //    dimension equal to zero, then return a promise rejected with an &quot;InvalidStateError&quot;
      //    DOMException and abort these steps.
<span class="line-modified">!     auto size = canvasElement-&gt;size();</span>
      if (!size.width() || !size.height()) {
          promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a canvas that has zero width or height&quot;);
          return;
      }
  
<span class="line-new-header">--- 344,28 ---</span>
      // 11. Resolve the promise with the new ImageBitmap object as the value.
  
      promise.resolve(WTFMove(imageBitmap));
  }
  
<span class="line-modified">! void ImageBitmap::createPromise(ScriptExecutionContext&amp; context, RefPtr&lt;HTMLCanvasElement&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+ void ImageBitmap::createPromise(ScriptExecutionContext&amp; context, RefPtr&lt;OffscreenCanvas&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ImageBitmap::createPromise(ScriptExecutionContext&amp;, CanvasBase&amp; canvas, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>
  {
      // 2. If the canvas element&#39;s bitmap has either a horizontal dimension or a vertical
      //    dimension equal to zero, then return a promise rejected with an &quot;InvalidStateError&quot;
      //    DOMException and abort these steps.
<span class="line-modified">!     auto size = canvas.size();</span>
      if (!size.width() || !size.height()) {
          promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a canvas that has zero width or height&quot;);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
      }
  
      auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
      auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
  
<span class="line-modified">!     auto imageForRender = canvasElement-&gt;copiedImage();</span>
      if (!imageForRender) {
          promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from canvas that can&#39;t be rendered&quot;);
          return;
      }
  
<span class="line-new-header">--- 379,11 ---</span>
      }
  
      auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
      auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
  
<span class="line-modified">!     auto imageForRender = canvas.copiedImage();</span>
      if (!imageForRender) {
          promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from canvas that can&#39;t be rendered&quot;);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,11 ***</span>
      auto imageBitmap = create(WTFMove(bitmapData));
  
      // 5. Set the origin-clean flag of the ImageBitmap object&#39;s bitmap to the same value as
      //    the origin-clean flag of the canvas element&#39;s bitmap.
  
<span class="line-modified">!     imageBitmap-&gt;m_originClean = canvasElement-&gt;originClean();</span>
  
      // 6. Return a new promise, but continue running these steps in parallel.
      // 7. Resolve the promise with the new ImageBitmap object as the value.
  
      promise.resolve(WTFMove(imageBitmap));
<span class="line-new-header">--- 394,11 ---</span>
      auto imageBitmap = create(WTFMove(bitmapData));
  
      // 5. Set the origin-clean flag of the ImageBitmap object&#39;s bitmap to the same value as
      //    the origin-clean flag of the canvas element&#39;s bitmap.
  
<span class="line-modified">!     imageBitmap-&gt;m_originClean = canvas.originClean();</span>
  
      // 6. Return a new promise, but continue running these steps in parallel.
      // 7. Resolve the promise with the new ImageBitmap object as the value.
  
      promise.resolve(WTFMove(imageBitmap));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,10 ***</span>
<span class="line-new-header">--- 540,11 ---</span>
      long long m_expectedContentLength;
      URL m_sourceUrl;
  };
  
  class PendingImageBitmap final : public ActiveDOMObject, public FileReaderLoaderClient {
<span class="line-added">+     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
      static void fetch(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
      {
          auto pendingImageBitmap = new PendingImageBitmap(scriptExecutionContext, WTFMove(blob), WTFMove(options), WTFMove(rect), WTFMove(promise));
          pendingImageBitmap-&gt;start(scriptExecutionContext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 537,30 ***</span>
          , m_blobLoader(FileReaderLoader::ReadAsArrayBuffer, this)
          , m_blob(WTFMove(blob))
          , m_options(WTFMove(options))
          , m_rect(WTFMove(rect))
          , m_promise(WTFMove(promise))
      {
          suspendIfNeeded();
      }
  
      void start(ScriptExecutionContext&amp; scriptExecutionContext)
      {
          m_blobLoader.start(&amp;scriptExecutionContext, *m_blob);
      }
  
      // ActiveDOMObject
  
<span class="line-modified">!     const char* activeDOMObjectName() const override</span>
      {
          return &quot;PendingImageBitmap&quot;;
      }
  
<span class="line-modified">!     bool canSuspendForDocumentSuspension() const override</span>
      {
<span class="line-modified">!         // FIXME: Deal with suspension.</span>
<span class="line-removed">-         return false;</span>
      }
  
      // FileReaderLoaderClient
  
      void didStartLoading() override
<span class="line-new-header">--- 556,31 ---</span>
          , m_blobLoader(FileReaderLoader::ReadAsArrayBuffer, this)
          , m_blob(WTFMove(blob))
          , m_options(WTFMove(options))
          , m_rect(WTFMove(rect))
          , m_promise(WTFMove(promise))
<span class="line-added">+         , m_createImageBitmapTimer(&amp;scriptExecutionContext, *this, &amp;PendingImageBitmap::createImageBitmapAndResolvePromise)</span>
      {
          suspendIfNeeded();
<span class="line-added">+         m_createImageBitmapTimer.suspendIfNeeded();</span>
      }
  
      void start(ScriptExecutionContext&amp; scriptExecutionContext)
      {
          m_blobLoader.start(&amp;scriptExecutionContext, *m_blob);
      }
  
      // ActiveDOMObject
  
<span class="line-modified">!     const char* activeDOMObjectName() const final</span>
      {
          return &quot;PendingImageBitmap&quot;;
      }
  
<span class="line-modified">!     void stop() final</span>
      {
<span class="line-modified">!         delete this;</span>
      }
  
      // FileReaderLoaderClient
  
      void didStartLoading() override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,35 ***</span>
      {
      }
  
      void didFinishLoading() override
      {
<span class="line-modified">!         createImageBitmap(m_blobLoader.arrayBufferResult());</span>
<span class="line-removed">-         delete this;</span>
      }
  
      void didFail(int) override
      {
<span class="line-modified">!         createImageBitmap(nullptr);</span>
<span class="line-removed">-         delete this;</span>
      }
  
<span class="line-modified">!     void createImageBitmap(RefPtr&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer)</span>
      {
<span class="line-modified">!         if (!arrayBuffer) {</span>
              m_promise.reject(InvalidStateError, &quot;An error occured reading the Blob argument to createImageBitmap&quot;);
              return;
          }
  
<span class="line-modified">!         ImageBitmap::createFromBuffer(arrayBuffer.releaseNonNull(), m_blob-&gt;type(), m_blob-&gt;size(), m_blobLoader.url(), WTFMove(m_options), WTFMove(m_rect), WTFMove(m_promise));</span>
      }
  
      FileReaderLoader m_blobLoader;
      RefPtr&lt;Blob&gt; m_blob;
      ImageBitmapOptions m_options;
      Optional&lt;IntRect&gt; m_rect;
      ImageBitmap::Promise m_promise;
  };
  
  void ImageBitmap::createFromBuffer(
      Ref&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer,
      String mimeType,
<span class="line-new-header">--- 591,46 ---</span>
      {
      }
  
      void didFinishLoading() override
      {
<span class="line-modified">!         createImageBitmapAndResolvePromiseSoon(m_blobLoader.arrayBufferResult());</span>
      }
  
      void didFail(int) override
      {
<span class="line-modified">!         createImageBitmapAndResolvePromiseSoon(nullptr);</span>
      }
  
<span class="line-modified">!     void createImageBitmapAndResolvePromiseSoon(RefPtr&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer)</span>
      {
<span class="line-modified">!         ASSERT(!m_createImageBitmapTimer.isActive());</span>
<span class="line-added">+         m_arrayBufferToProcess = WTFMove(arrayBuffer);</span>
<span class="line-added">+         m_createImageBitmapTimer.startOneShot(0_s);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void createImageBitmapAndResolvePromise()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         auto destroyOnExit = makeScopeExit([this] {</span>
<span class="line-added">+             delete this;</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!m_arrayBufferToProcess) {</span>
              m_promise.reject(InvalidStateError, &quot;An error occured reading the Blob argument to createImageBitmap&quot;);
              return;
          }
  
<span class="line-modified">!         ImageBitmap::createFromBuffer(m_arrayBufferToProcess.releaseNonNull(), m_blob-&gt;type(), m_blob-&gt;size(), m_blobLoader.url(), WTFMove(m_options), WTFMove(m_rect), WTFMove(m_promise));</span>
      }
  
      FileReaderLoader m_blobLoader;
      RefPtr&lt;Blob&gt; m_blob;
      ImageBitmapOptions m_options;
      Optional&lt;IntRect&gt; m_rect;
      ImageBitmap::Promise m_promise;
<span class="line-added">+     SuspendableTimer m_createImageBitmapTimer;</span>
<span class="line-added">+     RefPtr&lt;ArrayBuffer&gt; m_arrayBufferToProcess;</span>
  };
  
  void ImageBitmap::createFromBuffer(
      Ref&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer,
      String mimeType,
</pre>
<center><a href="HTMLVideoElement.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageBitmap.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
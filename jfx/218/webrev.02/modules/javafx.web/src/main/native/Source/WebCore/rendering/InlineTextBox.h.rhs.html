<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * (C) 1999 Lars Knoll (knoll@kde.org)
  3  * (C) 2000 Dirk Mueller (mueller@kde.org)
  4  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;InlineBox.h&quot;
 26 #include &quot;RenderText.h&quot;
 27 #include &quot;TextRun.h&quot;
 28 
 29 namespace WebCore {
 30 
 31 class RenderCombineText;
 32 class RenderedDocumentMarker;
 33 class TextPainter;
 34 struct CompositionUnderline;
 35 struct MarkedText;
 36 struct TextPaintStyle;
 37 
 38 const unsigned short cNoTruncation = USHRT_MAX;
 39 const unsigned short cFullTruncation = USHRT_MAX - 1;
 40 
 41 class InlineTextBox : public InlineBox {
 42     WTF_MAKE_ISO_ALLOCATED(InlineTextBox);
 43 public:
 44     explicit InlineTextBox(RenderText&amp; renderer)
 45         : InlineBox(renderer)
 46     {
 47         setBehavesLikeText(true);
 48     }
 49 
 50     virtual ~InlineTextBox();
 51 
 52     RenderText&amp; renderer() const { return downcast&lt;RenderText&gt;(InlineBox::renderer()); }
 53     const RenderStyle&amp; lineStyle() const { return isFirstLine() ? renderer().firstLineStyle() : renderer().style(); }
 54 
 55     InlineTextBox* prevTextBox() const { return m_prevTextBox; }
 56     InlineTextBox* nextTextBox() const { return m_nextTextBox; }
 57     void setNextTextBox(InlineTextBox* n) { m_nextTextBox = n; }
 58     void setPreviousTextBox(InlineTextBox* p) { m_prevTextBox = p; }
 59 
 60     bool hasTextContent() const;
 61 
 62     // These functions do not account for combined text. For combined text this box will always have len() == 1
 63     // regardless of whether the resulting composition is the empty string. Use hasTextContent() if you want to
 64     // know whether this box has text content.
 65     //
 66     // FIXME: These accessors should ASSERT(!isDirty()). See https://bugs.webkit.org/show_bug.cgi?id=97264
 67     // Note len() == 1 for combined text regardless of whether the composition is empty. Use hasTextContent() to
 68     unsigned start() const { return m_start; }
<a name="1" id="anc1"></a><span class="line-modified"> 69     unsigned end() const { return m_start + m_len; }</span>
 70     unsigned len() const { return m_len; }
 71 
 72     void setStart(unsigned start) { m_start = start; }
 73     void setLen(unsigned len) { m_len = len; }
 74 
 75     void offsetRun(int d) { ASSERT(!isDirty()); ASSERT(d &gt; 0 || m_start &gt;= static_cast&lt;unsigned&gt;(-d)); m_start += d; }
 76 
 77     unsigned short truncation() const { return m_truncation; }
 78 
 79     void markDirty(bool dirty = true) final;
 80 
 81     using InlineBox::hasHyphen;
 82     using InlineBox::setHasHyphen;
 83     using InlineBox::canHaveLeadingExpansion;
 84     using InlineBox::setCanHaveLeadingExpansion;
 85     using InlineBox::canHaveTrailingExpansion;
 86     using InlineBox::setCanHaveTrailingExpansion;
 87     using InlineBox::forceTrailingExpansion;
 88     using InlineBox::setForceTrailingExpansion;
 89     using InlineBox::forceLeadingExpansion;
 90     using InlineBox::setForceLeadingExpansion;
 91 
 92     static inline bool compareByStart(const InlineTextBox* first, const InlineTextBox* second) { return first-&gt;start() &lt; second-&gt;start(); }
 93 
 94     int baselinePosition(FontBaseline) const final;
 95     LayoutUnit lineHeight() const final;
 96 
 97     Optional&lt;bool&gt; emphasisMarkExistsAndIsAbove(const RenderStyle&amp;) const;
 98 
 99     LayoutRect logicalOverflowRect() const;
100     void setLogicalOverflowRect(const LayoutRect&amp;);
101     LayoutUnit logicalTopVisualOverflow() const { return logicalOverflowRect().y(); }
102     LayoutUnit logicalBottomVisualOverflow() const { return logicalOverflowRect().maxY(); }
103     LayoutUnit logicalLeftVisualOverflow() const { return logicalOverflowRect().x(); }
104     LayoutUnit logicalRightVisualOverflow() const { return logicalOverflowRect().maxX(); }
105 
106     virtual void dirtyOwnLineBoxes() { dirtyLineBoxes(); }
107 
108 #if ENABLE(TREE_DEBUGGING)
109     void outputLineBox(WTF::TextStream&amp;, bool mark, int depth) const final;
110     const char* boxName() const final;
111 #endif
112 
113 private:
114     LayoutUnit selectionTop() const;
115     LayoutUnit selectionBottom() const;
116     LayoutUnit selectionHeight() const;
117 
118 public:
119     FloatRect calculateBoundaries() const override { return FloatRect(x(), y(), width(), height()); }
120 
121     virtual LayoutRect localSelectionRect(unsigned startPos, unsigned endPos) const;
122     bool isSelected(unsigned startPosition, unsigned endPosition) const;
123     std::pair&lt;unsigned, unsigned&gt; selectionStartEnd() const;
<a name="2" id="anc2"></a><span class="line-added">124     std::pair&lt;unsigned, unsigned&gt; highlightStartEnd(SelectionRangeData&amp;) const;</span>
125 
126 protected:
127     void paint(PaintInfo&amp;, const LayoutPoint&amp;, LayoutUnit lineTop, LayoutUnit lineBottom) override;
128     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction) override;
129 
130     unsigned clampedOffset(unsigned) const;
131 
132 private:
133     void deleteLine() final;
134     void extractLine() final;
135     void attachLine() final;
136 
<a name="3" id="anc3"></a><span class="line-added">137     RenderObject::SelectionState verifySelectionState(RenderObject::SelectionState, SelectionRangeData&amp;) const;</span>
<span class="line-added">138     std::pair&lt;unsigned, unsigned&gt; clampedStartEndForState(unsigned, unsigned, RenderObject::SelectionState) const;</span>
<span class="line-added">139 </span>
140 public:
141     RenderObject::SelectionState selectionState() final;
142 
143 private:
144     void clearTruncation() final { m_truncation = cNoTruncation; }
145     float placeEllipsisBox(bool flowIsLTR, float visibleLeftEdge, float visibleRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox) final;
146 
147 public:
148     bool isLineBreak() const final;
149 
150 private:
151     bool isInlineTextBox() const final { return true; }
152 
153 public:
154     int caretMinOffset() const final;
155     int caretMaxOffset() const final;
156 
157 private:
158     float textPos() const; // returns the x position relative to the left start of the text line.
159 
160 public:
161     virtual int offsetForPosition(float x, bool includePartialGlyphs = true) const;
162     virtual float positionForOffset(unsigned offset) const;
163 
164     bool hasMarkers() const;
165     FloatRect calculateUnionOfAllDocumentMarkerBounds() const;
166     FloatRect calculateDocumentMarkerBounds(const MarkedText&amp;) const;
167 
168 private:
169     struct MarkedTextStyle;
170     struct StyledMarkedText;
171 
172     enum class TextPaintPhase { Background, Foreground, Decoration };
173 
174     Vector&lt;MarkedText&gt; collectMarkedTextsForDraggedContent();
175     Vector&lt;MarkedText&gt; collectMarkedTextsForDocumentMarkers(TextPaintPhase) const;
<a name="4" id="anc4"></a><span class="line-added">176     Vector&lt;MarkedText&gt; collectMarkedTextsForHighlights(TextPaintPhase) const;</span>
177 
178     MarkedTextStyle computeStyleForUnmarkedMarkedText(const PaintInfo&amp;) const;
179     StyledMarkedText resolveStyleForMarkedText(const MarkedText&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
180     Vector&lt;StyledMarkedText&gt; subdivideAndResolveStyle(const Vector&lt;MarkedText&gt;&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
181 
182     using MarkedTextStylesEqualityFunction = bool (*)(const MarkedTextStyle&amp;, const MarkedTextStyle&amp;);
183     Vector&lt;StyledMarkedText&gt; coalesceAdjacentMarkedTexts(const Vector&lt;StyledMarkedText&gt;&amp;, MarkedTextStylesEqualityFunction);
184 
185     FloatPoint textOriginFromBoxRect(const FloatRect&amp;) const;
186 
187     void paintMarkedTexts(PaintInfo&amp;, TextPaintPhase, const FloatRect&amp; boxRect, const Vector&lt;StyledMarkedText&gt;&amp;, const FloatRect&amp; decorationClipOutRect = { });
188 
189     void paintPlatformDocumentMarker(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin, const MarkedText&amp;);
190     void paintPlatformDocumentMarkers(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin);
191 
192     void paintCompositionBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin);
193     void paintCompositionUnderlines(PaintInfo&amp;, const FloatPoint&amp; boxOrigin) const;
194     void paintCompositionUnderline(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const CompositionUnderline&amp;) const;
195 
196     void paintMarkedTextBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const Color&amp;, unsigned clampedStartOffset, unsigned clampedEndOffset);
197     void paintMarkedTextForeground(PaintInfo&amp;, const FloatRect&amp; boxRect, const StyledMarkedText&amp;);
198     void paintMarkedTextDecoration(PaintInfo&amp;, const FloatRect&amp; boxRect, const FloatRect&amp; clipOutRect, const StyledMarkedText&amp;);
199 
200     const RenderCombineText* combinedText() const;
201     const FontCascade&amp; lineFont() const;
202 
203     String text(bool ignoreCombinedText = false, bool ignoreHyphen = false) const; // The effective text for the run.
204     TextRun createTextRun(bool ignoreCombinedText = false, bool ignoreHyphen = false) const;
205 
206     ExpansionBehavior expansionBehavior() const;
207 
208     void behavesLikeText() const = delete;
209 
210     InlineTextBox* m_prevTextBox { nullptr }; // The previous box that also uses our RenderObject
211     InlineTextBox* m_nextTextBox { nullptr }; // The next box that also uses our RenderObject
212 
213     unsigned m_start { 0 };
214     unsigned short m_len { 0 };
215 
216     // Where to truncate when text overflow is applied. We use special constants to
217     // denote no truncation (the whole run paints) and full truncation (nothing paints at all).
218     unsigned short m_truncation { cNoTruncation };
219 };
220 
<a name="5" id="anc5"></a><span class="line-added">221 LayoutRect snappedSelectionRect(const LayoutRect&amp;, float logicalRight, float selectionTop, float selectionHeight, bool isHorizontal);</span>
<span class="line-added">222 </span>
223 } // namespace WebCore
224 
225 SPECIALIZE_TYPE_TRAITS_INLINE_BOX(InlineTextBox, isInlineTextBox())
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
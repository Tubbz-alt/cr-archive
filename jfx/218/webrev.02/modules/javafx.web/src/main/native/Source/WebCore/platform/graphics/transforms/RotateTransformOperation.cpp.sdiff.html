<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/RotateTransformOperation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AffineTransform.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TransformationMatrix.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/RotateTransformOperation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RotateTransformOperation.h&quot;
 24 
 25 #include &quot;AnimationUtilities.h&quot;
 26 #include &lt;algorithm&gt;
 27 #include &lt;wtf/MathExtras.h&gt;
 28 #include &lt;wtf/text/TextStream.h&gt;
 29 




 30 namespace WebCore {
 31 
 32 bool RotateTransformOperation::operator==(const TransformOperation&amp; other) const
 33 {
 34     if (!isSameType(other))
 35         return false;
 36     const RotateTransformOperation&amp; r = downcast&lt;RotateTransformOperation&gt;(other);
 37     return m_x == r.m_x &amp;&amp; m_y == r.m_y &amp;&amp; m_z == r.m_z &amp;&amp; m_angle == r.m_angle;
 38 }
 39 
 40 Ref&lt;TransformOperation&gt; RotateTransformOperation::blend(const TransformOperation* from, double progress, bool blendToIdentity)
 41 {
 42     if (from &amp;&amp; !from-&gt;isSameType(*this))
 43         return *this;
 44 
 45     if (blendToIdentity)
 46         return RotateTransformOperation::create(m_x, m_y, m_z, m_angle - m_angle * progress, type());
 47 
 48     const RotateTransformOperation* fromOp = downcast&lt;RotateTransformOperation&gt;(from);
 49 
</pre>
<hr />
<pre>
 67         (fromOp ? fromOp-&gt;m_y : 0),
 68         (fromOp ? fromOp-&gt;m_z : 1),
 69         (fromOp ? fromOp-&gt;m_angle : 0));
 70 
 71     toT.rotate3d((toOp ? toOp-&gt;m_x : 0),
 72         (toOp ? toOp-&gt;m_y : 0),
 73         (toOp ? toOp-&gt;m_z : 1),
 74         (toOp ? toOp-&gt;m_angle : 0));
 75 
 76     // Blend them
 77     toT.blend(fromT, progress);
 78 
 79     // Extract the result as a quaternion
 80     TransformationMatrix::Decomposed4Type decomp;
 81     toT.decompose4(decomp);
 82 
 83     // Convert that to Axis/Angle form
 84     double x = -decomp.quaternionX;
 85     double y = -decomp.quaternionY;
 86     double z = -decomp.quaternionZ;
<span class="line-modified"> 87     double length = sqrt(x * x + y * y + z * z);</span>




 88     double angle = 0;
 89 
 90     if (length &gt; 0.00001) {
 91         x /= length;
 92         y /= length;
 93         z /= length;
 94         angle = rad2deg(acos(decomp.quaternionW) * 2);
 95     } else {
 96         x = 0;
 97         y = 0;
 98         z = 1;
 99     }
100     return RotateTransformOperation::create(x, y, z, angle, ROTATE_3D);
101 }
102 
103 void RotateTransformOperation::dump(TextStream&amp; ts) const
104 {
105     ts &lt;&lt; type() &lt;&lt; &quot;(&quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_x) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_y) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_z) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_angle) &lt;&lt; &quot;deg)&quot;;
106 }
107 
</pre>
</td>
<td>
<hr />
<pre>
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RotateTransformOperation.h&quot;
 24 
 25 #include &quot;AnimationUtilities.h&quot;
 26 #include &lt;algorithm&gt;
 27 #include &lt;wtf/MathExtras.h&gt;
 28 #include &lt;wtf/text/TextStream.h&gt;
 29 
<span class="line-added"> 30 #if PLATFORM(JAVA)</span>
<span class="line-added"> 31 #include &lt;wtf/java/JavaMath.h&gt;</span>
<span class="line-added"> 32 #endif</span>
<span class="line-added"> 33 </span>
 34 namespace WebCore {
 35 
 36 bool RotateTransformOperation::operator==(const TransformOperation&amp; other) const
 37 {
 38     if (!isSameType(other))
 39         return false;
 40     const RotateTransformOperation&amp; r = downcast&lt;RotateTransformOperation&gt;(other);
 41     return m_x == r.m_x &amp;&amp; m_y == r.m_y &amp;&amp; m_z == r.m_z &amp;&amp; m_angle == r.m_angle;
 42 }
 43 
 44 Ref&lt;TransformOperation&gt; RotateTransformOperation::blend(const TransformOperation* from, double progress, bool blendToIdentity)
 45 {
 46     if (from &amp;&amp; !from-&gt;isSameType(*this))
 47         return *this;
 48 
 49     if (blendToIdentity)
 50         return RotateTransformOperation::create(m_x, m_y, m_z, m_angle - m_angle * progress, type());
 51 
 52     const RotateTransformOperation* fromOp = downcast&lt;RotateTransformOperation&gt;(from);
 53 
</pre>
<hr />
<pre>
 71         (fromOp ? fromOp-&gt;m_y : 0),
 72         (fromOp ? fromOp-&gt;m_z : 1),
 73         (fromOp ? fromOp-&gt;m_angle : 0));
 74 
 75     toT.rotate3d((toOp ? toOp-&gt;m_x : 0),
 76         (toOp ? toOp-&gt;m_y : 0),
 77         (toOp ? toOp-&gt;m_z : 1),
 78         (toOp ? toOp-&gt;m_angle : 0));
 79 
 80     // Blend them
 81     toT.blend(fromT, progress);
 82 
 83     // Extract the result as a quaternion
 84     TransformationMatrix::Decomposed4Type decomp;
 85     toT.decompose4(decomp);
 86 
 87     // Convert that to Axis/Angle form
 88     double x = -decomp.quaternionX;
 89     double y = -decomp.quaternionY;
 90     double z = -decomp.quaternionZ;
<span class="line-modified"> 91 #if PLATFORM(JAVA)</span>
<span class="line-added"> 92     double length = javamath::hypot(x, y, z);</span>
<span class="line-added"> 93 #else</span>
<span class="line-added"> 94     double length = std::hypot(x, y, z);</span>
<span class="line-added"> 95 #endif</span>
 96     double angle = 0;
 97 
 98     if (length &gt; 0.00001) {
 99         x /= length;
100         y /= length;
101         z /= length;
102         angle = rad2deg(acos(decomp.quaternionW) * 2);
103     } else {
104         x = 0;
105         y = 0;
106         z = 1;
107     }
108     return RotateTransformOperation::create(x, y, z, angle, ROTATE_3D);
109 }
110 
111 void RotateTransformOperation::dump(TextStream&amp; ts) const
112 {
113     ts &lt;&lt; type() &lt;&lt; &quot;(&quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_x) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_y) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_z) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_angle) &lt;&lt; &quot;deg)&quot;;
114 }
115 
</pre>
</td>
</tr>
</table>
<center><a href="AffineTransform.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TransformationMatrix.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
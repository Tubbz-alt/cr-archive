<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Algorithm.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef Algorithm_h
 27 #define Algorithm_h
 28 
 29 #include &quot;BAssert.h&quot;
 30 #include &lt;algorithm&gt;
 31 #include &lt;climits&gt;
 32 #include &lt;cstdint&gt;
 33 #include &lt;cstddef&gt;
 34 #include &lt;limits&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;type_traits&gt;
 37 #include &lt;chrono&gt;
 38 
 39 namespace bmalloc {
 40 
 41 // Versions of min and max that are compatible with compile-time constants.
 42 template&lt;typename T&gt; constexpr T max(T a, T b)
 43 {
 44     return a &gt; b ? a : b;
 45 }
 46 
 47 template&lt;typename T&gt; constexpr T min(T a, T b)
 48 {
 49     return a &lt; b ? a : b;
 50 }
 51 
 52 template&lt;typename T&gt; constexpr T mask(T value, uintptr_t mask)
 53 {
 54     static_assert(sizeof(T) == sizeof(uintptr_t), &quot;sizeof(T) must be equal to sizeof(uintptr_t).&quot;);
 55     return static_cast&lt;T&gt;(static_cast&lt;uintptr_t&gt;(value) &amp; mask);
 56 }
 57 
 58 template&lt;typename T&gt; inline T* mask(T* value, uintptr_t mask)
 59 {
 60     return reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;uintptr_t&gt;(value) &amp; mask);
 61 }
 62 
 63 template&lt;typename T&gt; constexpr bool test(T value, uintptr_t mask)
 64 {
 65     return !!(reinterpret_cast&lt;uintptr_t&gt;(value) &amp; mask);
 66 }
 67 
 68 template &lt;typename T&gt;
 69 constexpr bool isPowerOfTwo(T size)
 70 {
 71     static_assert(std::is_integral&lt;T&gt;::value, &quot;&quot;);
 72     return size &amp;&amp; !(size &amp; (size - 1));
 73 }
 74 
 75 template&lt;typename T&gt; constexpr T roundUpToMultipleOfImpl(size_t divisor, T x)
 76 {
 77     static_assert(sizeof(T) == sizeof(uintptr_t), &quot;sizeof(T) must be equal to sizeof(uintptr_t).&quot;);
 78     return static_cast&lt;T&gt;((static_cast&lt;uintptr_t&gt;(x) + (divisor - 1)) &amp; ~(divisor - 1));
 79 }
 80 
 81 template&lt;typename T&gt; inline T roundUpToMultipleOf(size_t divisor, T x)
 82 {
 83     BASSERT(isPowerOfTwo(divisor));
 84     return roundUpToMultipleOfImpl(divisor, x);
 85 }
 86 
 87 template&lt;size_t divisor, typename T&gt; constexpr T roundUpToMultipleOf(T x)
 88 {
 89     static_assert(isPowerOfTwo(divisor), &quot;&#39;divisor&#39; must be a power of two.&quot;);
 90     return roundUpToMultipleOfImpl(divisor, x);
 91 }
 92 
 93 template&lt;typename T&gt; inline T* roundUpToMultipleOf(size_t divisor, T* x)
 94 {
 95     BASSERT(isPowerOfTwo(divisor));
 96     return reinterpret_cast&lt;T*&gt;((reinterpret_cast&lt;uintptr_t&gt;(x) + (divisor - 1)) &amp; ~(divisor - 1));
 97 }
 98 
 99 template&lt;size_t divisor, typename T&gt; inline T* roundUpToMultipleOf(T* x)
100 {
101     static_assert(isPowerOfTwo(divisor), &quot;&#39;divisor&#39; must be a power of two.&quot;);
102     return roundUpToMultipleOf(divisor, x);
103 }
104 
105 template&lt;typename T&gt; inline T roundDownToMultipleOf(size_t divisor, T x)
106 {
107     BASSERT(isPowerOfTwo(divisor));
108     static_assert(sizeof(T) == sizeof(uintptr_t), &quot;sizeof(T) must be equal to sizeof(uintptr_t).&quot;);
109     return static_cast&lt;T&gt;(mask(static_cast&lt;uintptr_t&gt;(x), ~(divisor - 1ul)));
110 }
111 
112 template&lt;typename T&gt; inline T* roundDownToMultipleOf(size_t divisor, T* x)
113 {
114     BASSERT(isPowerOfTwo(divisor));
115     return reinterpret_cast&lt;T*&gt;(mask(reinterpret_cast&lt;uintptr_t&gt;(x), ~(divisor - 1ul)));
116 }
117 
118 template&lt;size_t divisor, typename T&gt; constexpr T roundDownToMultipleOf(T x)
119 {
120     static_assert(isPowerOfTwo(divisor), &quot;&#39;divisor&#39; must be a power of two.&quot;);
121     return roundDownToMultipleOf(divisor, x);
122 }
123 
124 template&lt;typename T&gt; inline void divideRoundingUp(T numerator, T denominator, T&amp; quotient, T&amp; remainder)
125 {
126     // We expect the compiler to emit a single divide instruction to extract both the quotient and the remainder.
127     quotient = numerator / denominator;
128     remainder = numerator % denominator;
129     if (remainder)
130         quotient += 1;
131 }
132 
133 template&lt;typename T&gt; constexpr T divideRoundingUp(T numerator, T denominator)
134 {
135     return (numerator + denominator - 1) / denominator;
136 }
137 
138 template&lt;typename T&gt; inline T roundUpToMultipleOfNonPowerOfTwo(size_t divisor, T x)
139 {
140     return divideRoundingUp(x, divisor) * divisor;
141 }
142 
143 // Version of sizeof that returns 0 for empty classes.
144 
145 template&lt;typename T&gt; constexpr size_t sizeOf()
146 {
147     return std::is_empty&lt;T&gt;::value ? 0 : sizeof(T);
148 }
149 
150 template&lt;typename T&gt; constexpr size_t bitCount()
151 {
152     return sizeof(T) * 8;
153 }
154 
155 #if BOS(WINDOWS)
156 template&lt;int depth&gt; __forceinline constexpr unsigned long clzl(unsigned long value)
157 {
158     return value &amp; (1UL &lt;&lt; (bitCount&lt;unsigned long&gt;() - 1)) ? 0 : 1 + clzl&lt;depth - 1&gt;(value &lt;&lt; 1);
159 }
160 
161 template&lt;&gt; __forceinline constexpr unsigned long clzl&lt;1&gt;(unsigned long value)
162 {
163     return 0;
164 }
165 
166 __forceinline constexpr unsigned long __builtin_clzl(unsigned long value)
167 {
168     return value == 0 ? 32 : clzl&lt;bitCount&lt;unsigned long&gt;()&gt;(value);
169 }
170 #endif
171 
172 constexpr unsigned long log2(unsigned long value)
173 {
174     return bitCount&lt;unsigned long&gt;() - 1 - __builtin_clzl(value);
175 }
176 
177 #define BOFFSETOF(class, field) (reinterpret_cast&lt;ptrdiff_t&gt;(&amp;(reinterpret_cast&lt;class*&gt;(0x4000)-&gt;field)) - 0x4000)
178 
179 template&lt;typename T&gt;
180 bool findBitInWord(T word, size_t&amp; index, size_t endIndex, bool value)
181 {
182     static_assert(std::is_unsigned&lt;T&gt;::value, &quot;Type used in findBitInWord must be unsigned&quot;);
183 
184     word &gt;&gt;= index;
185 
186     while (index &lt; endIndex) {
187         if ((word &amp; 1) == static_cast&lt;T&gt;(value))
188             return true;
189         index++;
190         word &gt;&gt;= 1;
191     }
192 
193     index = endIndex;
194     return false;
195 }
196 
197 template &lt;typename T&gt;
198 constexpr unsigned ctzConstexpr(T value)
199 {
200     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;
201 
202     using UT = typename std::make_unsigned&lt;T&gt;::type;
203     UT uValue = value;
204 
205     unsigned zeroCount = 0;
206     for (unsigned i = 0; i &lt; bitSize; i++) {
207         if (uValue &amp; 1)
208             break;
209 
210         zeroCount++;
211         uValue &gt;&gt;= 1;
212     }
213     return zeroCount;
214 }
215 
216 template&lt;typename T&gt;
217 constexpr unsigned getLSBSetNonZeroConstexpr(T t)
218 {
219     return ctzConstexpr(t);
220 }
221 
222 } // namespace bmalloc
223 
224 #endif // Algorithm_h
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;
  29 #include &quot;BytecodeCacheError.h&quot;
<a name="1" id="anc1"></a>
  30 #include &quot;CatchScope.h&quot;
  31 #include &quot;CodeBlock.h&quot;
  32 #include &quot;CodeCache.h&quot;
<a name="2" id="anc2"></a>
  33 #include &quot;Completion.h&quot;
  34 #include &quot;ConfigFile.h&quot;
  35 #include &quot;Disassembler.h&quot;
  36 #include &quot;Exception.h&quot;
  37 #include &quot;ExceptionHelpers.h&quot;
  38 #include &quot;HeapProfiler.h&quot;
  39 #include &quot;HeapSnapshotBuilder.h&quot;
  40 #include &quot;InitializeThreading.h&quot;
  41 #include &quot;Interpreter.h&quot;
  42 #include &quot;JIT.h&quot;
  43 #include &quot;JSArray.h&quot;
  44 #include &quot;JSArrayBuffer.h&quot;
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
  47 #include &quot;JSFunction.h&quot;
  48 #include &quot;JSInternalPromise.h&quot;
<a name="3" id="anc3"></a><span class="line-removed">  49 #include &quot;JSInternalPromiseDeferred.h&quot;</span>
  50 #include &quot;JSLock.h&quot;
  51 #include &quot;JSModuleLoader.h&quot;
  52 #include &quot;JSNativeStdFunction.h&quot;
  53 #include &quot;JSONObject.h&quot;
<a name="4" id="anc4"></a>
  54 #include &quot;JSSourceCode.h&quot;
  55 #include &quot;JSString.h&quot;
  56 #include &quot;JSTypedArrays.h&quot;
  57 #include &quot;JSWebAssemblyInstance.h&quot;
  58 #include &quot;JSWebAssemblyMemory.h&quot;
  59 #include &quot;LLIntThunks.h&quot;
  60 #include &quot;ObjectConstructor.h&quot;
  61 #include &quot;ParserError.h&quot;
  62 #include &quot;ProfilerDatabase.h&quot;
<a name="5" id="anc5"></a><span class="line-modified">  63 #include &quot;PromiseDeferredTimer.h&quot;</span>
  64 #include &quot;ProtoCallFrame.h&quot;
  65 #include &quot;ReleaseHeapAccessScope.h&quot;
  66 #include &quot;SamplingProfiler.h&quot;
  67 #include &quot;StackVisitor.h&quot;
  68 #include &quot;StructureInlines.h&quot;
  69 #include &quot;StructureRareDataInlines.h&quot;
  70 #include &quot;SuperSampler.h&quot;
  71 #include &quot;TestRunnerUtils.h&quot;
  72 #include &quot;TypedArrayInlines.h&quot;
<a name="6" id="anc6"></a>
  73 #include &quot;WasmCapabilities.h&quot;
  74 #include &quot;WasmContext.h&quot;
  75 #include &quot;WasmFaultSignalHandler.h&quot;
  76 #include &quot;WasmMemory.h&quot;
  77 #include &lt;locale.h&gt;
  78 #include &lt;math.h&gt;
  79 #include &lt;stdio.h&gt;
  80 #include &lt;stdlib.h&gt;
  81 #include &lt;string.h&gt;
  82 #include &lt;sys/stat.h&gt;
  83 #include &lt;sys/types.h&gt;
  84 #include &lt;thread&gt;
  85 #include &lt;type_traits&gt;
  86 #include &lt;wtf/Box.h&gt;
<a name="7" id="anc7"></a>
  87 #include &lt;wtf/CommaPrinter.h&gt;
  88 #include &lt;wtf/FileSystem.h&gt;
  89 #include &lt;wtf/MainThread.h&gt;
  90 #include &lt;wtf/MemoryPressureHandler.h&gt;
  91 #include &lt;wtf/MonotonicTime.h&gt;
  92 #include &lt;wtf/NeverDestroyed.h&gt;
  93 #include &lt;wtf/Scope.h&gt;
  94 #include &lt;wtf/StringPrintStream.h&gt;
  95 #include &lt;wtf/URL.h&gt;
  96 #include &lt;wtf/WallTime.h&gt;
  97 #include &lt;wtf/text/StringBuilder.h&gt;
  98 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  99 
 100 #if OS(WINDOWS)
 101 #include &lt;direct.h&gt;
 102 #include &lt;fcntl.h&gt;
 103 #include &lt;io.h&gt;
 104 #else
 105 #include &lt;unistd.h&gt;
 106 #endif
 107 
 108 #if PLATFORM(COCOA)
 109 #include &lt;crt_externs.h&gt;
 110 #endif
 111 
 112 #if HAVE(READLINE)
 113 // readline/history.h has a Function typedef which conflicts with the WTF::Function template from WTF/Forward.h
 114 // We #define it to something else to avoid this conflict.
 115 #define Function ReadlineFunction
 116 #include &lt;readline/history.h&gt;
 117 #include &lt;readline/readline.h&gt;
 118 #undef Function
 119 #endif
 120 
 121 #if HAVE(SYS_TIME_H)
 122 #include &lt;sys/time.h&gt;
 123 #endif
 124 
 125 #if HAVE(SIGNAL_H)
 126 #include &lt;signal.h&gt;
 127 #endif
 128 
 129 #if COMPILER(MSVC)
 130 #include &lt;crtdbg.h&gt;
 131 #include &lt;mmsystem.h&gt;
 132 #include &lt;windows.h&gt;
 133 #endif
 134 
<a name="8" id="anc8"></a><span class="line-modified"> 135 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)</span>
 136 #include &lt;fenv.h&gt;
 137 #include &lt;arm/arch.h&gt;
 138 #endif
 139 
 140 #if OS(DARWIN)
 141 #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;
<a name="9" id="anc9"></a>




 142 struct MemoryFootprint : ProcessMemoryFootprint {
 143     MemoryFootprint(const ProcessMemoryFootprint&amp; src)
 144         : ProcessMemoryFootprint(src)
 145     {
 146     }
 147 };
 148 #else
 149 struct MemoryFootprint {
 150     uint64_t current;
 151     uint64_t peak;
 152 
 153     static MemoryFootprint now()
 154     {
 155         return { 0L, 0L };
 156     }
 157 
 158     static void resetPeak()
 159     {
 160     }
 161 };
 162 #endif
 163 
 164 #if !defined(PATH_MAX)
 165 #define PATH_MAX 4096
 166 #endif
 167 
 168 using namespace JSC;
 169 
 170 namespace {
 171 
 172 NO_RETURN_WITH_VALUE static void jscExit(int status)
 173 {
 174     waitForAsynchronousDisassembly();
 175 
 176 #if ENABLE(DFG_JIT)
 177     if (DFG::isCrashing()) {
 178         for (;;) {
 179 #if OS(WINDOWS)
 180             Sleep(1000);
 181 #else
 182             pause();
 183 #endif
 184         }
 185     }
 186 #endif // ENABLE(DFG_JIT)
 187     exit(status);
 188 }
 189 
 190 class Masquerader : public JSNonFinalObject {
 191 public:
 192     Masquerader(VM&amp; vm, Structure* structure)
 193         : Base(vm, structure)
 194     {
 195     }
 196 
 197     typedef JSNonFinalObject Base;
<a name="10" id="anc10"></a><span class="line-modified"> 198     static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;</span>
 199 
 200     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 201     {
 202         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 203         Structure* structure = createStructure(vm, globalObject, jsNull());
 204         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap)) Masquerader(vm, structure);
 205         result-&gt;finishCreation(vm);
 206         return result;
 207     }
 208 
 209     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 210     {
 211         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 212     }
 213 
 214     DECLARE_INFO;
 215 };
 216 
 217 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 218 static unsigned asyncTestPasses { 0 };
 219 static unsigned asyncTestExpectedPasses { 0 };
 220 
 221 }
 222 
 223 template&lt;typename Vector&gt;
 224 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
 225 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName);
 226 
 227 class CommandLine;
 228 class GlobalObject;
 229 class Workers;
 230 
 231 template&lt;typename Func&gt;
 232 int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
<a name="11" id="anc11"></a><span class="line-modified"> 233 static void checkException(ExecState*, GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);</span>
 234 
 235 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 236 public:
 237     Message(ArrayBufferContents&amp;&amp;, int32_t);
 238     ~Message();
 239 
 240     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 241     int32_t index() const { return m_index; }
 242 
 243 private:
 244     ArrayBufferContents m_contents;
 245     int32_t m_index { 0 };
 246 };
 247 
 248 class Worker : public BasicRawSentinelNode&lt;Worker&gt; {
 249 public:
 250     Worker(Workers&amp;);
 251     ~Worker();
 252 
 253     void enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt;);
 254     RefPtr&lt;Message&gt; dequeue();
 255 
 256     static Worker&amp; current();
 257 
 258 private:
 259     static ThreadSpecific&lt;Worker*&gt;&amp; currentWorker();
 260 
 261     Workers&amp; m_workers;
 262     Deque&lt;RefPtr&lt;Message&gt;&gt; m_messages;
 263 };
 264 
 265 class Workers {
 266     WTF_MAKE_FAST_ALLOCATED;
 267     WTF_MAKE_NONCOPYABLE(Workers);
 268 public:
 269     Workers();
 270     ~Workers();
 271 
 272     template&lt;typename Func&gt;
 273     void broadcast(const Func&amp;);
 274 
 275     void report(const String&amp;);
 276     String tryGetReport();
 277     String getReport();
 278 
 279     static Workers&amp; singleton();
 280 
 281 private:
 282     friend class Worker;
 283 
 284     Lock m_lock;
 285     Condition m_condition;
 286     SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
 287     Deque&lt;String&gt; m_reports;
 288 };
 289 
 290 
<a name="12" id="anc12"></a><span class="line-modified"> 291 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState*);</span>
<span class="line-modified"> 292 </span>
<span class="line-modified"> 293 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);</span>
<span class="line-modified"> 294 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);</span>
<span class="line-modified"> 295 static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);</span>
<span class="line-modified"> 296 static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);</span>
<span class="line-modified"> 297 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);</span>
<span class="line-modified"> 298 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);</span>
<span class="line-modified"> 299 static EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState*);</span>
<span class="line-modified"> 300 static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState*);</span>
<span class="line-modified"> 301 static EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState*);</span>
<span class="line-modified"> 302 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState*);</span>
<span class="line-modified"> 303 static EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*);</span>
<span class="line-modified"> 304 static EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState*);</span>
<span class="line-modified"> 305 static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState*);</span>
<span class="line-modified"> 306 static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*);</span>
<span class="line-modified"> 307 static EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState*);</span>
<span class="line-modified"> 308 static EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*);</span>
<span class="line-modified"> 309 static EncodedJSValue JSC_HOST_CALL functionRun(ExecState*);</span>
<span class="line-modified"> 310 static EncodedJSValue JSC_HOST_CALL functionRunString(ExecState*);</span>
<span class="line-modified"> 311 static EncodedJSValue JSC_HOST_CALL functionLoad(ExecState*);</span>
<span class="line-modified"> 312 static EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState*);</span>
<span class="line-modified"> 313 static EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState*);</span>
<span class="line-modified"> 314 static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState*);</span>
<span class="line-modified"> 315 static EncodedJSValue JSC_HOST_CALL functionReadline(ExecState*);</span>
<span class="line-modified"> 316 static EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*);</span>
<span class="line-modified"> 317 static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState*);</span>
<span class="line-modified"> 318 static EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState*);</span>
<span class="line-modified"> 319 static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);</span>
<span class="line-modified"> 320 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);</span>
<span class="line-modified"> 321 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);</span>
<span class="line-modified"> 322 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);</span>
<span class="line-modified"> 323 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);</span>
<span class="line-modified"> 324 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);</span>
<span class="line-modified"> 325 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);</span>
<span class="line-modified"> 326 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);</span>
<span class="line-modified"> 327 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);</span>
<span class="line-modified"> 328 static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);</span>
<span class="line-modified"> 329 static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);</span>
<span class="line-modified"> 330 static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);</span>
<span class="line-modified"> 331 static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);</span>
<span class="line-modified"> 332 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);</span>
<span class="line-modified"> 333 static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);</span>
<span class="line-modified"> 334 static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);</span>
<span class="line-modified"> 335 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);</span>
<span class="line-modified"> 336 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);</span>
<span class="line-modified"> 337 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);</span>
<span class="line-modified"> 338 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);</span>
<span class="line-modified"> 339 static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState*);</span>
<span class="line-modified"> 340 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);</span>
<span class="line-modified"> 341 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);</span>
<span class="line-modified"> 342 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);</span>
<span class="line-modified"> 343 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);</span>
<span class="line-modified"> 344 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);</span>
<span class="line-modified"> 345 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);</span>
<span class="line-modified"> 346 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);</span>
 347 #if ENABLE(SAMPLING_PROFILER)
<a name="13" id="anc13"></a><span class="line-modified"> 348 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);</span>
<span class="line-modified"> 349 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);</span>
 350 #endif
 351 
<a name="14" id="anc14"></a><span class="line-modified"> 352 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);</span>
<span class="line-modified"> 353 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);</span>
<span class="line-modified"> 354 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);</span>
 355 
 356 #if ENABLE(WEBASSEMBLY)
<a name="15" id="anc15"></a><span class="line-modified"> 357 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);</span>
 358 #endif
 359 
 360 #if ENABLE(SAMPLING_FLAGS)
<a name="16" id="anc16"></a><span class="line-modified"> 361 static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState*);</span>
<span class="line-modified"> 362 static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState*);</span>
 363 #endif
 364 
<a name="17" id="anc17"></a><span class="line-modified"> 365 static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState*);</span>
<span class="line-modified"> 366 static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState*);</span>
<span class="line-modified"> 367 static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);</span>
<span class="line-modified"> 368 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);</span>
<span class="line-modified"> 369 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);</span>
<span class="line-modified"> 370 static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);</span>
<span class="line-modified"> 371 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);</span>
<span class="line-modified"> 372 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);</span>
<span class="line-modified"> 373 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);</span>
<span class="line-modified"> 374 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);</span>
<span class="line-modified"> 375 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);</span>
<span class="line-modified"> 376 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);</span>
<span class="line-modified"> 377 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);</span>
<span class="line-modified"> 378 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);</span>
<span class="line-modified"> 379 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);</span>
<span class="line-modified"> 380 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);</span>
<span class="line-modified"> 381 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);</span>
<span class="line-modified"> 382 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);</span>
<span class="line-modified"> 383 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);</span>
<span class="line-modified"> 384 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);</span>
<span class="line-modified"> 385 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);</span>
<span class="line-modified"> 386 </span>
<span class="line-removed"> 387 static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState*);</span>
 388 
 389 struct Script {
 390     enum class StrictMode {
 391         Strict,
 392         Sloppy
 393     };
 394 
 395     enum class ScriptType {
 396         Script,
 397         Module
 398     };
 399 
 400     enum class CodeSource {
 401         File,
 402         CommandLine
 403     };
 404 
 405     StrictMode strictMode;
 406     CodeSource codeSource;
 407     ScriptType scriptType;
 408     char* argument;
 409 
 410     Script(StrictMode strictMode, CodeSource codeSource, ScriptType scriptType, char *argument)
 411         : strictMode(strictMode)
 412         , codeSource(codeSource)
 413         , scriptType(scriptType)
 414         , argument(argument)
 415     {
 416         if (strictMode == StrictMode::Strict)
 417             ASSERT(codeSource == CodeSource::File);
 418     }
 419 };
 420 
 421 class CommandLine {
 422 public:
 423     CommandLine(int argc, char** argv)
 424     {
 425         parseArguments(argc, argv);
 426     }
 427 
 428     Vector&lt;Script&gt; m_scripts;
 429     Vector&lt;String&gt; m_arguments;
 430     String m_profilerOutput;
 431     String m_uncaughtExceptionName;
 432     bool m_interactive { false };
 433     bool m_dump { false };
 434     bool m_module { false };
 435     bool m_exitCode { false };
 436     bool m_destroyVM { false };
 437     bool m_profile { false };
 438     bool m_treatWatchdogExceptionAsSuccess { false };
 439     bool m_alwaysDumpUncaughtException { false };
 440     bool m_dumpMemoryFootprint { false };
 441     bool m_dumpSamplingProfilerData { false };
 442     bool m_enableRemoteDebugging { false };
 443 
 444     void parseArguments(int, char**);
 445 };
 446 
 447 static const char interactivePrompt[] = &quot;&gt;&gt;&gt; &quot;;
 448 
 449 class StopWatch {
 450 public:
 451     void start();
 452     void stop();
 453     long getElapsedMS(); // call stop() first
 454 
 455 private:
 456     MonotonicTime m_startTime;
 457     MonotonicTime m_stopTime;
 458 };
 459 
 460 void StopWatch::start()
 461 {
 462     m_startTime = MonotonicTime::now();
 463 }
 464 
 465 void StopWatch::stop()
 466 {
 467     m_stopTime = MonotonicTime::now();
 468 }
 469 
 470 long StopWatch::getElapsedMS()
 471 {
 472     return (m_stopTime - m_startTime).millisecondsAs&lt;long&gt;();
 473 }
 474 
 475 template&lt;typename Vector&gt;
 476 static inline String stringFromUTF(const Vector&amp; utf8)
 477 {
 478     return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
 479 }
 480 
<a name="18" id="anc18"></a><span class="line-modified"> 481 class GlobalObject : public JSGlobalObject {</span>
 482 private:
 483     GlobalObject(VM&amp;, Structure*);
 484 
 485 public:
 486     typedef JSGlobalObject Base;
 487 
 488     static GlobalObject* create(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
 489     {
 490         GlobalObject* object = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure);
 491         object-&gt;finishCreation(vm, arguments);
 492         return object;
 493     }
 494 
<a name="19" id="anc19"></a><span class="line-removed"> 495     static const bool needsDestruction = false;</span>
<span class="line-removed"> 496 </span>
 497     DECLARE_INFO;
 498     static const GlobalObjectMethodTable s_globalObjectMethodTable;
 499 
 500     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 501     {
 502         return Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 503     }
 504 
 505     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags::createAllEnabled(); }
 506 
 507 protected:
 508     void finishCreation(VM&amp; vm, const Vector&lt;String&gt;&amp; arguments)
 509     {
 510         Base::finishCreation(vm);
 511 
 512         addFunction(vm, &quot;debug&quot;, functionDebug, 1);
 513         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);
 514         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);
 515         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);
 516         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
 517         addFunction(vm, &quot;quit&quot;, functionQuit, 0);
 518         addFunction(vm, &quot;gc&quot;, functionGCAndSweep, 0);
 519         addFunction(vm, &quot;fullGC&quot;, functionFullGC, 0);
 520         addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
<a name="20" id="anc20"></a><span class="line-removed"> 521         addFunction(vm, &quot;forceGCSlowPaths&quot;, functionForceGCSlowPaths, 0);</span>
 522         addFunction(vm, &quot;gcHeapSize&quot;, functionHeapSize, 0);
 523         addFunction(vm, &quot;MemoryFootprint&quot;, functionCreateMemoryFootprint, 0);
 524         addFunction(vm, &quot;resetMemoryPeak&quot;, functionResetMemoryPeak, 0);
 525         addFunction(vm, &quot;addressOf&quot;, functionAddressOf, 1);
 526         addFunction(vm, &quot;version&quot;, functionVersion, 1);
 527         addFunction(vm, &quot;run&quot;, functionRun, 1);
 528         addFunction(vm, &quot;runString&quot;, functionRunString, 1);
 529         addFunction(vm, &quot;load&quot;, functionLoad, 1);
 530         addFunction(vm, &quot;loadString&quot;, functionLoadString, 1);
 531         addFunction(vm, &quot;readFile&quot;, functionReadFile, 2);
 532         addFunction(vm, &quot;read&quot;, functionReadFile, 2);
 533         addFunction(vm, &quot;checkSyntax&quot;, functionCheckSyntax, 1);
 534         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 535         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 536         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 537         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 538         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 539         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 540         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 541         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 542         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 543         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
<a name="21" id="anc21"></a>
 544         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 545         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 546         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 547         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 548         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 549 #if ENABLE(SAMPLING_FLAGS)
 550         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 551         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 552 #endif
 553 
 554         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 555         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 556         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 557         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 558         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 559         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 560 
 561         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 562         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 563         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
 564 
 565         addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
 566 
 567         addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
 568 
 569         addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);
 570         addFunction(vm, &quot;releaseWeakRefs&quot;, functionReleaseWeakRefs, 0);
 571 
 572         addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
 573         addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
 574         addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
 575         addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
 576 
 577         addFunction(vm, &quot;is32BitPlatform&quot;, functionIs32BitPlatform, 0);
 578 
 579         addFunction(vm, &quot;checkModuleSyntax&quot;, functionCheckModuleSyntax, 1);
 580 
 581         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 582         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 583         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 584         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 585         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 586 #if ENABLE(SAMPLING_PROFILER)
 587         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 588         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 589 #endif
 590 
 591         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 592 
 593         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 594         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 595 
 596 #if ENABLE(WEBASSEMBLY)
 597         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 598 #endif
 599 
 600         if (!arguments.isEmpty()) {
<a name="22" id="anc22"></a><span class="line-modified"> 601             JSArray* array = constructEmptyArray(globalExec(), 0);</span>
 602             for (size_t i = 0; i &lt; arguments.size(); ++i)
<a name="23" id="anc23"></a><span class="line-modified"> 603                 array-&gt;putDirectIndex(globalExec(), i, jsString(vm, arguments[i]));</span>
 604             putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
 605         }
 606 
 607         putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());
 608 
 609         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 610 
 611         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
 612         putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);
 613         putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);
 614 
 615         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
<a name="24" id="anc24"></a><span class="line-modified"> 616         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);</span>
 617         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 618 
 619         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);
 620 
 621         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
 622         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;agent&quot;), agent);
 623 
 624         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 625         // thread and some are in the other threads. We just put them in all threads.
 626         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 627         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 628         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 629         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 630         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 631         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 632         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 633         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 634 
 635         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 636 
 637         addFunction(vm, &quot;heapCapacity&quot;, functionHeapCapacity, 0);
 638         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 639 
 640         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 641         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 642         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
 643 
 644         addFunction(vm, &quot;setUnhandledRejectionCallback&quot;, functionSetUnhandledRejectionCallback, 1);
 645     }
 646 
 647     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 648     {
 649         Identifier identifier = Identifier::fromString(vm, name);
 650         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 651     }
 652 
 653     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 654     {
 655         addFunction(vm, this, name, function, arguments);
 656     }
 657 
<a name="25" id="anc25"></a><span class="line-modified"> 658     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);</span>
<span class="line-modified"> 659     static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified"> 660     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified"> 661     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);</span>
 662 };
<a name="26" id="anc26"></a>
 663 
 664 static bool supportsRichSourceInfo = true;
 665 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 666 {
 667     return supportsRichSourceInfo;
 668 }
 669 
 670 const ClassInfo GlobalObject::s_info = { &quot;global&quot;, &amp;JSGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(GlobalObject) };
 671 const GlobalObjectMethodTable GlobalObject::s_globalObjectMethodTable = {
 672     &amp;shellSupportsRichSourceInfo,
 673     &amp;shouldInterruptScript,
 674     &amp;javaScriptRuntimeFlags,
 675     nullptr, // queueTaskToEventLoop
 676     &amp;shouldInterruptScriptBeforeTimeout,
 677     &amp;moduleLoaderImportModule,
 678     &amp;moduleLoaderResolve,
 679     &amp;moduleLoaderFetch,
 680     &amp;moduleLoaderCreateImportMetaProperties,
 681     nullptr, // moduleLoaderEvaluate
 682     nullptr, // promiseRejectionTracker
 683     nullptr, // defaultLanguage
 684     nullptr, // compileStreaming
 685     nullptr, // instantinateStreaming
 686 };
 687 
 688 GlobalObject::GlobalObject(VM&amp; vm, Structure* structure)
 689     : JSGlobalObject(vm, structure, &amp;s_globalObjectMethodTable)
 690 {
 691 }
 692 
 693 static UChar pathSeparator()
 694 {
 695 #if OS(WINDOWS)
 696     return &#39;\\&#39;;
 697 #else
 698     return &#39;/&#39;;
 699 #endif
 700 }
 701 
 702 struct DirectoryName {
 703     // In unix, it is &quot;/&quot;. In Windows, it becomes a drive letter like &quot;C:\&quot;
 704     String rootName;
 705 
 706     // If the directory name is &quot;/home/WebKit&quot;, this becomes &quot;home/WebKit&quot;. If the directory name is &quot;/&quot;, this becomes &quot;&quot;.
 707     String queryName;
 708 };
 709 
 710 struct ModuleName {
 711     ModuleName(const String&amp; moduleName);
 712 
 713     bool startsWithRoot() const
 714     {
 715         return !queries.isEmpty() &amp;&amp; queries[0].isEmpty();
 716     }
 717 
 718     Vector&lt;String&gt; queries;
 719 };
 720 
 721 ModuleName::ModuleName(const String&amp; moduleName)
 722 {
 723     // A module name given from code is represented as the UNIX style path. Like, `./A/B.js`.
 724     queries = moduleName.splitAllowingEmptyEntries(&#39;/&#39;);
 725 }
 726 
 727 static Optional&lt;DirectoryName&gt; extractDirectoryName(const String&amp; absolutePathToFile)
 728 {
 729     size_t firstSeparatorPosition = absolutePathToFile.find(pathSeparator());
 730     if (firstSeparatorPosition == notFound)
 731         return WTF::nullopt;
 732     DirectoryName directoryName;
 733     directoryName.rootName = absolutePathToFile.substring(0, firstSeparatorPosition + 1); // Include the separator.
 734     size_t lastSeparatorPosition = absolutePathToFile.reverseFind(pathSeparator());
 735     ASSERT_WITH_MESSAGE(lastSeparatorPosition != notFound, &quot;If the separator is not found, this function already returns when performing the forward search.&quot;);
 736     if (firstSeparatorPosition == lastSeparatorPosition)
 737         directoryName.queryName = StringImpl::empty();
 738     else {
 739         size_t queryStartPosition = firstSeparatorPosition + 1;
 740         size_t queryLength = lastSeparatorPosition - queryStartPosition; // Not include the last separator.
 741         directoryName.queryName = absolutePathToFile.substring(queryStartPosition, queryLength);
 742     }
 743     return directoryName;
 744 }
 745 
 746 static Optional&lt;DirectoryName&gt; currentWorkingDirectory()
 747 {
 748 #if OS(WINDOWS)
 749     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa364934.aspx
 750     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
 751     // The _MAX_PATH in Windows is 260. If the path of the current working directory is longer than that, _getcwd truncates the result.
 752     // And other I/O functions taking a path name also truncate it. To avoid this situation,
 753     //
 754     // (1). When opening the file in Windows for modules, we always use the abosolute path and add &quot;\\?\&quot; prefix to the path name.
 755     // (2). When retrieving the current working directory, use GetCurrentDirectory instead of _getcwd.
 756     //
 757     // In the path utility functions inside the JSC shell, we does not handle the UNC and UNCW including the network host name.
 758     DWORD bufferLength = ::GetCurrentDirectoryW(0, nullptr);
 759     if (!bufferLength)
 760         return WTF::nullopt;
 761     // In Windows, wchar_t is the UTF-16LE.
 762     // https://msdn.microsoft.com/en-us/library/dd374081.aspx
 763     // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
 764     Vector&lt;wchar_t&gt; buffer(bufferLength);
 765     DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
 766     String directoryString(buffer.data(), lengthNotIncludingNull);
 767     // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
 768     if (directoryString.startsWith(&quot;\\\\&quot;))
 769         return WTF::nullopt;
 770 #else
 771     Vector&lt;char&gt; buffer(PATH_MAX);
 772     if (!getcwd(buffer.data(), PATH_MAX))
 773         return WTF::nullopt;
 774     String directoryString = String::fromUTF8(buffer.data());
 775 #endif
 776     if (directoryString.isEmpty())
 777         return WTF::nullopt;
 778 
 779     if (directoryString[directoryString.length() - 1] == pathSeparator())
 780         return extractDirectoryName(directoryString);
 781     // Append the seperator to represents the file name. extractDirectoryName only accepts the absolute file name.
 782     return extractDirectoryName(makeString(directoryString, pathSeparator()));
 783 }
 784 
 785 static String resolvePath(const DirectoryName&amp; directoryName, const ModuleName&amp; moduleName)
 786 {
 787     Vector&lt;String&gt; directoryPieces = directoryName.queryName.split(pathSeparator());
 788 
 789     // Only first &#39;/&#39; is recognized as the path from the root.
 790     if (moduleName.startsWithRoot())
 791         directoryPieces.clear();
 792 
 793     for (const auto&amp; query : moduleName.queries) {
 794         if (query == String(&quot;..&quot;_s)) {
 795             if (!directoryPieces.isEmpty())
 796                 directoryPieces.removeLast();
 797         } else if (!query.isEmpty() &amp;&amp; query != String(&quot;.&quot;_s))
 798             directoryPieces.append(query);
 799     }
 800 
 801     StringBuilder builder;
 802     builder.append(directoryName.rootName);
 803     for (size_t i = 0; i &lt; directoryPieces.size(); ++i) {
 804         builder.append(directoryPieces[i]);
 805         if (i + 1 != directoryPieces.size())
 806             builder.append(pathSeparator());
 807     }
 808     return builder.toString();
 809 }
 810 
 811 static String absolutePath(const String&amp; fileName)
 812 {
 813     auto directoryName = currentWorkingDirectory();
 814     if (!directoryName)
 815         return fileName;
 816     return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
 817 }
 818 
<a name="27" id="anc27"></a><span class="line-modified"> 819 JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)</span>
 820 {
 821     VM&amp; vm = globalObject-&gt;vm();
 822     auto throwScope = DECLARE_THROW_SCOPE(vm);
 823 
<a name="28" id="anc28"></a><span class="line-modified"> 824     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed"> 825     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
 826 
 827     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 828     auto reject = [&amp;] (JSValue rejectionReason) {
 829         catchScope.clearException();
<a name="29" id="anc29"></a><span class="line-modified"> 830         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
 831         catchScope.clearException();
<a name="30" id="anc30"></a><span class="line-modified"> 832         return result;</span>
 833     };
 834 
 835     if (sourceOrigin.isNull())
<a name="31" id="anc31"></a><span class="line-modified"> 836         return reject(createError(exec, &quot;Could not resolve the module specifier.&quot;_s));</span>
 837 
<a name="32" id="anc32"></a><span class="line-modified"> 838     const auto&amp; referrer = sourceOrigin.string();</span>
<span class="line-modified"> 839     const auto&amp; moduleName = moduleNameValue-&gt;value(exec);</span>

 840     if (UNLIKELY(catchScope.exception()))
 841         return reject(catchScope.exception());
 842 
 843     auto directoryName = extractDirectoryName(referrer.impl());
 844     if (!directoryName)
<a name="33" id="anc33"></a><span class="line-modified"> 845         return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
 846 
<a name="34" id="anc34"></a><span class="line-modified"> 847     auto result = JSC::importModule(exec, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
 848     if (UNLIKELY(catchScope.exception()))
 849         return reject(catchScope.exception());
 850     return result;
 851 }
 852 
<a name="35" id="anc35"></a><span class="line-modified"> 853 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)</span>
 854 {
 855     VM&amp; vm = globalObject-&gt;vm();
 856     auto scope = DECLARE_THROW_SCOPE(vm);
 857 
 858     scope.releaseAssertNoException();
<a name="36" id="anc36"></a><span class="line-modified"> 859     const Identifier key = keyValue.toPropertyKey(exec);</span>
 860     RETURN_IF_EXCEPTION(scope, { });
 861 
 862     if (key.isSymbol())
 863         return key;
 864 
 865     if (referrerValue.isUndefined()) {
 866         auto directoryName = currentWorkingDirectory();
 867         if (!directoryName) {
<a name="37" id="anc37"></a><span class="line-modified"> 868             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));</span>
 869             return { };
 870         }
 871         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 872     }
 873 
<a name="38" id="anc38"></a><span class="line-modified"> 874     const Identifier referrer = referrerValue.toPropertyKey(exec);</span>
 875     RETURN_IF_EXCEPTION(scope, { });
 876 
 877     if (referrer.isSymbol()) {
 878         auto directoryName = currentWorkingDirectory();
 879         if (!directoryName) {
<a name="39" id="anc39"></a><span class="line-modified"> 880             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));</span>
 881             return { };
 882         }
 883         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 884     }
 885 
 886     // If the referrer exists, we assume that the referrer is the correct absolute path.
 887     auto directoryName = extractDirectoryName(referrer.impl());
 888     if (!directoryName) {
<a name="40" id="anc40"></a><span class="line-modified"> 889         throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
 890         return { };
 891     }
 892     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 893 }
 894 
 895 template&lt;typename Vector&gt;
 896 static void convertShebangToJSComment(Vector&amp; buffer)
 897 {
 898     if (buffer.size() &gt;= 2) {
 899         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 900             buffer[0] = buffer[1] = &#39;/&#39;;
 901     }
 902 }
 903 
 904 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 905 {
 906     if (fseek(file, 0, SEEK_END) == -1)
 907         return nullptr;
 908     long bufferCapacity = ftell(file);
 909     if (bufferCapacity == -1)
 910         return nullptr;
 911     if (fseek(file, 0, SEEK_SET) == -1)
 912         return nullptr;
 913     auto result = Uint8Array::tryCreate(bufferCapacity);
 914     if (!result)
 915         return nullptr;
 916     size_t readSize = fread(result-&gt;data(), 1, bufferCapacity, file);
 917     if (readSize != static_cast&lt;size_t&gt;(bufferCapacity))
 918         return nullptr;
 919     return result;
 920 }
 921 
 922 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName)
 923 {
 924     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 925     if (!f) {
 926         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 927         return nullptr;
 928     }
 929 
 930     RefPtr&lt;Uint8Array&gt; result = fillBufferWithContentsOfFile(f);
 931     fclose(f);
 932 
 933     return result;
 934 }
 935 
 936 template&lt;typename Vector&gt;
 937 static bool fillBufferWithContentsOfFile(FILE* file, Vector&amp; buffer)
 938 {
 939     // We might have injected &quot;use strict&quot;; at the top.
 940     size_t initialSize = buffer.size();
 941     if (fseek(file, 0, SEEK_END) == -1)
 942         return false;
 943     long bufferCapacity = ftell(file);
 944     if (bufferCapacity == -1)
 945         return false;
 946     if (fseek(file, 0, SEEK_SET) == -1)
 947         return false;
 948     buffer.resize(bufferCapacity + initialSize);
 949     size_t readSize = fread(buffer.data() + initialSize, 1, buffer.size(), file);
 950     return readSize == buffer.size() - initialSize;
 951 }
 952 
 953 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 954 {
 955     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 956     if (!f) {
 957         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 958         return false;
 959     }
 960 
 961     bool result = fillBufferWithContentsOfFile(f, buffer);
 962     fclose(f);
 963 
 964     return result;
 965 }
 966 
 967 static bool fetchScriptFromLocalFileSystem(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 968 {
 969     if (!fillBufferWithContentsOfFile(fileName, buffer))
 970         return false;
 971     convertShebangToJSComment(buffer);
 972     return true;
 973 }
 974 
 975 class ShellSourceProvider : public StringSourceProvider {
 976 public:
 977     static Ref&lt;ShellSourceProvider&gt; create(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
 978     {
 979         return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
 980     }
 981 
 982     ~ShellSourceProvider()
 983     {
 984         commitCachedBytecode();
 985     }
 986 
 987     RefPtr&lt;CachedBytecode&gt; cachedBytecode() const override
 988     {
 989         if (!m_cachedBytecode)
 990             loadBytecode();
 991         return m_cachedBytecode.copyRef();
 992     }
 993 
 994     void updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp;, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock) const override
 995     {
 996         if (!cacheEnabled() || !m_cachedBytecode)
 997             return;
 998         BytecodeCacheError error;
 999         RefPtr&lt;CachedBytecode&gt; cachedBytecode = encodeFunctionCodeBlock(executable-&gt;vm(), codeBlock, error);
1000         if (cachedBytecode &amp;&amp; !error.isValid())
1001             m_cachedBytecode-&gt;addFunctionUpdate(executable, kind, *cachedBytecode);
1002     }
1003 
1004     void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
1005     {
1006         if (!cacheEnabled())
1007             return;
1008         if (!m_cachedBytecode)
1009             m_cachedBytecode = CachedBytecode::create();
1010         auto update = generator();
1011         if (update)
1012             m_cachedBytecode-&gt;addGlobalUpdate(*update);
1013     }
1014 
1015     void commitCachedBytecode() const override
1016     {
1017         if (!cacheEnabled() || !m_cachedBytecode || !m_cachedBytecode-&gt;hasUpdates())
1018             return;
1019 
1020         auto clearBytecode = makeScopeExit([&amp;] {
1021             m_cachedBytecode = nullptr;
1022         });
1023 
1024         String filename = cachePath();
1025         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Write, {FileSystem::FileLockMode::Exclusive, FileSystem::FileLockMode::Nonblocking});
1026         if (!FileSystem::isHandleValid(fd))
1027             return;
1028 
1029         auto closeFD = makeScopeExit([&amp;] {
1030             FileSystem::unlockAndCloseFile(fd);
1031         });
1032 
1033         long long fileSize;
1034         if (!FileSystem::getFileSize(fd, fileSize))
1035             return;
1036 
1037         size_t cacheFileSize;
1038         if (!WTF::convertSafely(fileSize, cacheFileSize) || cacheFileSize != m_cachedBytecode-&gt;size()) {
1039             // The bytecode cache has already been updated
1040             return;
1041         }
1042 
1043         if (!FileSystem::truncateFile(fd, m_cachedBytecode-&gt;sizeForUpdate()))
1044             return;
1045 
1046         m_cachedBytecode-&gt;commitUpdates([&amp;] (off_t offset, const void* data, size_t size) {
1047             long long result = FileSystem::seekFile(fd, offset, FileSystem::FileSeekOrigin::Beginning);
1048             ASSERT_UNUSED(result, result != -1);
1049             size_t bytesWritten = static_cast&lt;size_t&gt;(FileSystem::writeToFile(fd, static_cast&lt;const char*&gt;(data), size));
1050             ASSERT_UNUSED(bytesWritten, bytesWritten == size);
1051         });
1052     }
1053 
1054 private:
1055     String cachePath() const
1056     {
1057         if (!cacheEnabled())
1058             return static_cast&lt;const char*&gt;(nullptr);
1059         const char* cachePath = Options::diskCachePath();
1060         String filename = FileSystem::encodeForFileName(FileSystem::lastComponentOfPathIgnoringTrailingSlash(sourceOrigin().string()));
1061         return FileSystem::pathByAppendingComponent(cachePath, makeString(source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;));
1062     }
1063 
1064     void loadBytecode() const
1065     {
1066         if (!cacheEnabled())
1067             return;
1068 
1069         String filename = cachePath();
1070         if (filename.isNull())
1071             return;
1072 
1073         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Read, {FileSystem::FileLockMode::Shared, FileSystem::FileLockMode::Nonblocking});
1074         if (!FileSystem::isHandleValid(fd))
1075             return;
1076 
1077         auto closeFD = makeScopeExit([&amp;] {
1078             FileSystem::unlockAndCloseFile(fd);
1079         });
1080 
1081         bool success;
1082         FileSystem::MappedFileData mappedFileData(fd, FileSystem::MappedFileMode::Private, success);
1083 
1084         if (!success)
1085             return;
1086 
1087         m_cachedBytecode = CachedBytecode::create(WTFMove(mappedFileData));
1088     }
1089 
1090     ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
1091         : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
1092     {
1093     }
1094 
1095     static bool cacheEnabled()
1096     {
1097         static bool enabled = !!Options::diskCachePath();
1098         return enabled;
1099     }
1100 
1101     mutable RefPtr&lt;CachedBytecode&gt; m_cachedBytecode;
1102 };
1103 
1104 static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
1105 {
1106     return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
1107 }
1108 
1109 template&lt;typename Vector&gt;
1110 static inline SourceCode jscSource(const Vector&amp; utf8, const SourceOrigin&amp; sourceOrigin, const String&amp; filename)
1111 {
1112     // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
1113     String str = stringFromUTF(utf8);
1114     return jscSource(str, sourceOrigin, URL({ }, filename));
1115 }
1116 
1117 template&lt;typename Vector&gt;
1118 static bool fetchModuleFromLocalFileSystem(const String&amp; fileName, Vector&amp; buffer)
1119 {
1120     // We assume that fileName is always an absolute path.
1121 #if OS(WINDOWS)
1122     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
1123     // Use long UNC to pass the long path name to the Windows APIs.
1124     auto pathName = makeString(&quot;\\\\?\\&quot;, fileName).wideCharacters();
1125     struct _stat status { };
1126     if (_wstat(pathName.data(), &amp;status))
1127         return false;
1128     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1129         return false;
1130 
1131     FILE* f = _wfopen(pathName.data(), L&quot;rb&quot;);
1132 #else
1133     auto pathName = fileName.utf8();
1134     struct stat status { };
1135     if (stat(pathName.data(), &amp;status))
1136         return false;
1137     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1138         return false;
1139 
1140     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1141 #endif
1142     if (!f) {
1143         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1144         return false;
1145     }
1146 
1147     bool result = fillBufferWithContentsOfFile(f, buffer);
1148     if (result)
1149         convertShebangToJSComment(buffer);
1150     fclose(f);
1151 
1152     return result;
1153 }
1154 
<a name="41" id="anc41"></a><span class="line-modified">1155 JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSValue, JSValue)</span>
1156 {
1157     VM&amp; vm = globalObject-&gt;vm();
<a name="42" id="anc42"></a><span class="line-modified">1158     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">1159     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">1160     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
1161 
1162     auto catchScope = DECLARE_CATCH_SCOPE(vm);
1163     auto reject = [&amp;] (JSValue rejectionReason) {
1164         catchScope.clearException();
<a name="43" id="anc43"></a><span class="line-modified">1165         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
1166         catchScope.clearException();
<a name="44" id="anc44"></a><span class="line-modified">1167         return result;</span>
1168     };
1169 
<a name="45" id="anc45"></a><span class="line-modified">1170     String moduleKey = key.toWTFString(exec);</span>
1171     if (UNLIKELY(catchScope.exception()))
1172         return reject(catchScope.exception());
1173 
1174     // Here, now we consider moduleKey as the fileName.
1175     Vector&lt;uint8_t&gt; buffer;
1176     if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
<a name="46" id="anc46"></a><span class="line-modified">1177         return reject(createError(exec, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
1178 
1179 
1180     URL moduleURL = URL({ }, moduleKey);
1181 #if ENABLE(WEBASSEMBLY)
1182     // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
1183     if (buffer.size() &gt;= 4) {
1184         if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
1185             auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
1186             catchScope.releaseAssertNoException();
1187             auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
1188             catchScope.releaseAssertNoException();
<a name="47" id="anc47"></a><span class="line-modified">1189             auto result = deferred-&gt;resolve(exec, sourceCode);</span>
1190             catchScope.clearException();
<a name="48" id="anc48"></a><span class="line-modified">1191             return result;</span>
1192         }
1193     }
1194 #endif
1195 
1196     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1197     catchScope.releaseAssertNoException();
<a name="49" id="anc49"></a><span class="line-modified">1198     auto result = deferred-&gt;resolve(exec, sourceCode);</span>
1199     catchScope.clearException();
<a name="50" id="anc50"></a><span class="line-modified">1200     return result;</span>
1201 }
1202 
<a name="51" id="anc51"></a><span class="line-modified">1203 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)</span>
1204 {
<a name="52" id="anc52"></a><span class="line-modified">1205     VM&amp; vm = exec-&gt;vm();</span>
1206     auto scope = DECLARE_THROW_SCOPE(vm);
1207 
<a name="53" id="anc53"></a><span class="line-modified">1208     JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());</span>
1209     RETURN_IF_EXCEPTION(scope, nullptr);
1210 
1211     metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);
1212     RETURN_IF_EXCEPTION(scope, nullptr);
1213 
1214     return metaProperties;
1215 }
1216 
<a name="54" id="anc54"></a><span class="line-modified">1217 static CString cStringFromViewWithString(ExecState* exec, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)</span>
1218 {
1219     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1220     if (expectedString)
1221         return expectedString.value();
1222     switch (expectedString.error()) {
1223     case UTF8ConversionError::OutOfMemory:
<a name="55" id="anc55"></a><span class="line-modified">1224         throwOutOfMemoryError(exec, scope);</span>
1225         break;
1226     case UTF8ConversionError::IllegalSource:
<a name="56" id="anc56"></a><span class="line-modified">1227         scope.throwException(exec, createError(exec, &quot;Illegal source encountered during UTF8 conversion&quot;));</span>
1228         break;
1229     case UTF8ConversionError::SourceExhausted:
<a name="57" id="anc57"></a><span class="line-modified">1230         scope.throwException(exec, createError(exec, &quot;Source exhausted during UTF8 conversion&quot;));</span>
1231         break;
1232     default:
1233         RELEASE_ASSERT_NOT_REACHED();
1234     }
1235     return { };
1236 }
1237 
<a name="58" id="anc58"></a><span class="line-modified">1238 static EncodedJSValue printInternal(ExecState* exec, FILE* out)</span>
1239 {
<a name="59" id="anc59"></a><span class="line-modified">1240     VM&amp; vm = exec-&gt;vm();</span>
1241     auto scope = DECLARE_THROW_SCOPE(vm);
1242 
1243     if (asyncTestExpectedPasses) {
<a name="60" id="anc60"></a><span class="line-modified">1244         JSValue value = exec-&gt;argument(0);</span>
<span class="line-modified">1245         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(exec).impl(), &quot;Test262:AsyncTestComplete&quot;)) {</span>
1246             asyncTestPasses++;
1247             return JSValue::encode(jsUndefined());
1248         }
1249     }
1250 
<a name="61" id="anc61"></a><span class="line-modified">1251     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
1252         if (i)
1253             if (EOF == fputc(&#39; &#39;, out))
1254                 goto fail;
1255 
<a name="62" id="anc62"></a><span class="line-modified">1256         auto viewWithString = exec-&gt;uncheckedArgument(i).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
1257         RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="63" id="anc63"></a><span class="line-modified">1258         auto string = cStringFromViewWithString(exec, scope, viewWithString);</span>
1259         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1260         if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
1261             goto fail;
1262     }
1263 
1264     fputc(&#39;\n&#39;, out);
1265 fail:
1266     fflush(out);
1267     return JSValue::encode(jsUndefined());
1268 }
1269 
<a name="64" id="anc64"></a><span class="line-modified">1270 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }</span>
<span class="line-modified">1271 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }</span>
1272 
<a name="65" id="anc65"></a><span class="line-modified">1273 EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)</span>
1274 {
<a name="66" id="anc66"></a><span class="line-modified">1275     VM&amp; vm = exec-&gt;vm();</span>
1276     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="67" id="anc67"></a><span class="line-modified">1277     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
1278     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="68" id="anc68"></a><span class="line-modified">1279     auto string = cStringFromViewWithString(exec, scope, viewWithString);</span>
1280     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1281     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1282     return JSValue::encode(jsUndefined());
1283 }
1284 
<a name="69" id="anc69"></a><span class="line-modified">1285 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)</span>
1286 {
<a name="70" id="anc70"></a><span class="line-modified">1287     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1288     if (exec-&gt;argumentCount() &lt; 1)</span>
1289         return JSValue::encode(jsUndefined());
<a name="71" id="anc71"></a><span class="line-modified">1290     return JSValue::encode(jsString(vm, toString(exec-&gt;argument(0))));</span>
1291 }
1292 
<a name="72" id="anc72"></a><span class="line-modified">1293 EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)</span>
1294 {
<a name="73" id="anc73"></a><span class="line-modified">1295     if (exec-&gt;argumentCount() &lt; 1)</span>
1296         return JSValue::encode(jsUndefined());
<a name="74" id="anc74"></a><span class="line-modified">1297     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1298     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));</span>
1299     if (!object)
1300         return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));
1301     return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));
1302 }
1303 
<a name="75" id="anc75"></a><span class="line-modified">1304 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)</span>
1305 {
<a name="76" id="anc76"></a><span class="line-modified">1306     VM&amp; vm = exec-&gt;vm();</span>
1307     auto scope = DECLARE_THROW_SCOPE(vm);
1308 
<a name="77" id="anc77"></a><span class="line-modified">1309     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1310         Seconds seconds = Seconds(exec-&gt;argument(0).toNumber(exec));</span>
1311         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1312         sleep(seconds);
1313     }
1314 
1315     return JSValue::encode(jsUndefined());
1316 }
1317 
1318 class FunctionJSCStackFunctor {
1319 public:
1320     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1321         : m_trace(trace)
1322     {
1323     }
1324 
1325     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1326     {
1327         m_trace.append(makeString(&quot;    &quot;, visitor-&gt;index(), &quot;   &quot;, visitor-&gt;toString(), &#39;\n&#39;));
1328         return StackVisitor::Continue;
1329     }
1330 
1331 private:
1332     StringBuilder&amp; m_trace;
1333 };
1334 
<a name="78" id="anc78"></a><span class="line-modified">1335 EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState* exec)</span>
1336 {
<a name="79" id="anc79"></a>
1337     StringBuilder trace;
1338     trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
1339 
1340     FunctionJSCStackFunctor functor(trace);
<a name="80" id="anc80"></a><span class="line-modified">1341     exec-&gt;iterate(functor);</span>
1342     fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
1343     return JSValue::encode(jsUndefined());
1344 }
1345 
<a name="81" id="anc81"></a><span class="line-modified">1346 EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState* exec)</span>
1347 {
<a name="82" id="anc82"></a><span class="line-modified">1348     VM&amp; vm = exec-&gt;vm();</span>
1349     JSLockHolder lock(vm);
1350     vm.heap.collectNow(Sync, CollectionScope::Full);
1351     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1352 }
1353 
<a name="83" id="anc83"></a><span class="line-modified">1354 EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState* exec)</span>
1355 {
<a name="84" id="anc84"></a><span class="line-modified">1356     VM&amp; vm = exec-&gt;vm();</span>
1357     JSLockHolder lock(vm);
1358     vm.heap.collectSync(CollectionScope::Full);
1359     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1360 }
1361 
<a name="85" id="anc85"></a><span class="line-modified">1362 EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)</span>
1363 {
<a name="86" id="anc86"></a><span class="line-modified">1364     VM&amp; vm = exec-&gt;vm();</span>
1365     JSLockHolder lock(vm);
1366     vm.heap.collectSync(CollectionScope::Eden);
1367     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
1368 }
1369 
<a name="87" id="anc87"></a><span class="line-modified">1370 EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*)</span>
1371 {
<a name="88" id="anc88"></a><span class="line-modified">1372     // It&#39;s best for this to be the first thing called in the</span>
<span class="line-removed">1373     // JS program so the option is set to true before we JIT.</span>
<span class="line-removed">1374     Options::forceGCSlowPaths() = true;</span>
<span class="line-removed">1375     return JSValue::encode(jsUndefined());</span>
<span class="line-removed">1376 }</span>
<span class="line-removed">1377 </span>
<span class="line-removed">1378 EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState* exec)</span>
<span class="line-removed">1379 {</span>
<span class="line-removed">1380     VM&amp; vm = exec-&gt;vm();</span>
1381     JSLockHolder lock(vm);
1382     return JSValue::encode(jsNumber(vm.heap.size()));
1383 }
1384 
1385 class JSCMemoryFootprint : public JSDestructibleObject {
1386     using Base = JSDestructibleObject;
1387 public:
1388     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1389         : Base(vm, structure)
1390     { }
1391 
1392     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1393     {
1394         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1395     }
1396 
1397     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1398     {
1399         Structure* structure = createStructure(vm, globalObject, jsNull());
1400         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap)) JSCMemoryFootprint(vm, structure);
1401         footprint-&gt;finishCreation(vm);
1402         return footprint;
1403     }
1404 
1405     void finishCreation(VM&amp; vm)
1406     {
1407         Base::finishCreation(vm);
1408 
1409         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
1410             JSCMemoryFootprint::addProperty(vm, name, value);
1411         };
1412 
1413         MemoryFootprint footprint = MemoryFootprint::now();
1414 
1415         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1416         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1417     }
1418 
1419     DECLARE_INFO;
1420 
1421 private:
1422     void addProperty(VM&amp; vm, const char* name, JSValue value)
1423     {
1424         Identifier identifier = Identifier::fromString(vm, name);
1425         putDirect(vm, identifier, value);
1426     }
1427 };
1428 
1429 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1430 
<a name="89" id="anc89"></a><span class="line-modified">1431 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)</span>
1432 {
<a name="90" id="anc90"></a><span class="line-modified">1433     VM&amp; vm = exec-&gt;vm();</span>
1434     JSLockHolder lock(vm);
<a name="91" id="anc91"></a><span class="line-modified">1435     return JSValue::encode(JSCMemoryFootprint::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1436 }
1437 
<a name="92" id="anc92"></a><span class="line-modified">1438 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)</span>
1439 {
1440     MemoryFootprint::resetPeak();
1441     return JSValue::encode(jsUndefined());
1442 }
1443 
1444 // This function is not generally very helpful in 64-bit code as the tag and payload
1445 // share a register. But in 32-bit JITed code the tag may not be checked if an
1446 // optimization removes type checking requirements, such as in ===.
<a name="93" id="anc93"></a><span class="line-modified">1447 EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState* exec)</span>
1448 {
<a name="94" id="anc94"></a><span class="line-modified">1449     JSValue value = exec-&gt;argument(0);</span>
1450     if (!value.isCell())
1451         return JSValue::encode(jsUndefined());
1452     // Need to cast to uint64_t so bitwise_cast will play along.
1453     uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
1454     EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
1455     return returnValue;
1456 }
1457 
<a name="95" id="anc95"></a><span class="line-modified">1458 EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*)</span>
1459 {
1460     // We need this function for compatibility with the Mozilla JS tests but for now
1461     // we don&#39;t actually do any version-specific handling
1462     return JSValue::encode(jsUndefined());
1463 }
1464 
<a name="96" id="anc96"></a><span class="line-modified">1465 EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)</span>
1466 {
<a name="97" id="anc97"></a><span class="line-modified">1467     VM&amp; vm = exec-&gt;vm();</span>
1468     auto scope = DECLARE_THROW_SCOPE(vm);
1469 
<a name="98" id="anc98"></a><span class="line-modified">1470     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1471     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1472     Vector&lt;char&gt; script;
1473     if (!fetchScriptFromLocalFileSystem(fileName, script))
<a name="99" id="anc99"></a><span class="line-modified">1474         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
1475 
<a name="100" id="anc100"></a><span class="line-modified">1476     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
1477 
<a name="101" id="anc101"></a><span class="line-modified">1478     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);</span>
1479     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="102" id="anc102"></a><span class="line-modified">1480     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1481         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));</span>
1482         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1483     }
<a name="103" id="anc103"></a><span class="line-modified">1484     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
1485 
1486     NakedPtr&lt;Exception&gt; exception;
1487     StopWatch stopWatch;
1488     stopWatch.start();
<a name="104" id="anc104"></a><span class="line-modified">1489     evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);</span>
1490     stopWatch.stop();
1491 
1492     if (exception) {
<a name="105" id="anc105"></a><span class="line-modified">1493         throwException(globalObject-&gt;globalExec(), scope, exception);</span>
1494         return JSValue::encode(jsUndefined());
1495     }
1496 
1497     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1498 }
1499 
<a name="106" id="anc106"></a><span class="line-modified">1500 EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)</span>
1501 {
<a name="107" id="anc107"></a><span class="line-modified">1502     VM&amp; vm = exec-&gt;vm();</span>
1503     auto scope = DECLARE_THROW_SCOPE(vm);
1504 
<a name="108" id="anc108"></a><span class="line-modified">1505     String source = exec-&gt;argument(0).toWTFString(exec);</span>
1506     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1507 
<a name="109" id="anc109"></a><span class="line-modified">1508     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
1509 
<a name="110" id="anc110"></a><span class="line-modified">1510     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);</span>
1511     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="111" id="anc111"></a><span class="line-modified">1512     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1513         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));</span>
1514         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1515     }
<a name="112" id="anc112"></a><span class="line-modified">1516     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
1517 
1518     NakedPtr&lt;Exception&gt; exception;
<a name="113" id="anc113"></a><span class="line-modified">1519     evaluate(globalObject-&gt;globalExec(), jscSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
1520 
1521     if (exception) {
<a name="114" id="anc114"></a><span class="line-modified">1522         scope.throwException(globalObject-&gt;globalExec(), exception);</span>
1523         return JSValue::encode(jsUndefined());
1524     }
1525 
<a name="115" id="anc115"></a><span class="line-modified">1526     return JSValue::encode(globalObject);</span>
1527 }
1528 
<a name="116" id="anc116"></a><span class="line-modified">1529 EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)</span>
1530 {
<a name="117" id="anc117"></a><span class="line-modified">1531     VM&amp; vm = exec-&gt;vm();</span>
1532     auto scope = DECLARE_THROW_SCOPE(vm);
1533 
<a name="118" id="anc118"></a><span class="line-modified">1534     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1535     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1536     Vector&lt;char&gt; script;
1537     if (!fetchScriptFromLocalFileSystem(fileName, script))
<a name="119" id="anc119"></a><span class="line-modified">1538         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
<span class="line-removed">1539 </span>
<span class="line-removed">1540     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1541 
1542     NakedPtr&lt;Exception&gt; evaluationException;
<a name="120" id="anc120"></a><span class="line-modified">1543     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
1544     if (evaluationException)
<a name="121" id="anc121"></a><span class="line-modified">1545         throwException(exec, scope, evaluationException);</span>
1546     return JSValue::encode(result);
1547 }
1548 
<a name="122" id="anc122"></a><span class="line-modified">1549 EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)</span>
1550 {
<a name="123" id="anc123"></a><span class="line-modified">1551     VM&amp; vm = exec-&gt;vm();</span>
1552     auto scope = DECLARE_THROW_SCOPE(vm);
1553 
<a name="124" id="anc124"></a><span class="line-modified">1554     String sourceCode = exec-&gt;argument(0).toWTFString(exec);</span>
1555     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="125" id="anc125"></a><span class="line-removed">1556     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1557 
1558     NakedPtr&lt;Exception&gt; evaluationException;
<a name="126" id="anc126"></a><span class="line-modified">1559     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1560     if (evaluationException)
<a name="127" id="anc127"></a><span class="line-modified">1561         throwException(exec, scope, evaluationException);</span>
1562     return JSValue::encode(result);
1563 }
1564 
<a name="128" id="anc128"></a><span class="line-modified">1565 EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)</span>
1566 {
<a name="129" id="anc129"></a><span class="line-modified">1567     VM&amp; vm = exec-&gt;vm();</span>
1568     auto scope = DECLARE_THROW_SCOPE(vm);
1569 
<a name="130" id="anc130"></a><span class="line-modified">1570     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1571     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1572 
1573     bool isBinary = false;
<a name="131" id="anc131"></a><span class="line-modified">1574     if (exec-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">1575         String type = exec-&gt;argument(1).toWTFString(exec);</span>
1576         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1577         if (type != &quot;binary&quot;)
<a name="132" id="anc132"></a><span class="line-modified">1578             return throwVMError(exec, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);</span>
1579         isBinary = true;
1580     }
1581 
1582     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1583     if (!content)
<a name="133" id="anc133"></a><span class="line-modified">1584         return throwVMError(exec, scope, &quot;Could not open file.&quot;);</span>
1585 
1586     if (!isBinary)
1587         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));
1588 
<a name="134" id="anc134"></a><span class="line-modified">1589     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);</span>
1590     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1591     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1592 
1593     return JSValue::encode(result);
1594 }
1595 
<a name="135" id="anc135"></a><span class="line-modified">1596 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)</span>
1597 {
<a name="136" id="anc136"></a><span class="line-modified">1598     VM&amp; vm = exec-&gt;vm();</span>
1599     auto scope = DECLARE_THROW_SCOPE(vm);
1600 
<a name="137" id="anc137"></a><span class="line-modified">1601     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1602     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1603     Vector&lt;char&gt; script;
1604     if (!fetchScriptFromLocalFileSystem(fileName, script))
<a name="138" id="anc138"></a><span class="line-modified">1605         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
<span class="line-removed">1606 </span>
<span class="line-removed">1607     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1608 
1609     StopWatch stopWatch;
1610     stopWatch.start();
1611 
1612     JSValue syntaxException;
<a name="139" id="anc139"></a><span class="line-modified">1613     bool validSyntax = checkSyntax(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);</span>
1614     stopWatch.stop();
1615 
1616     if (!validSyntax)
<a name="140" id="anc140"></a><span class="line-modified">1617         throwException(exec, scope, syntaxException);</span>
1618     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1619 }
1620 
1621 #if ENABLE(SAMPLING_FLAGS)
<a name="141" id="anc141"></a><span class="line-modified">1622 EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState* exec)</span>
1623 {
<a name="142" id="anc142"></a><span class="line-modified">1624     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1625         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));</span>
1626         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1627             SamplingFlags::setFlag(flag);
1628     }
1629     return JSValue::encode(jsNull());
1630 }
1631 
<a name="143" id="anc143"></a><span class="line-modified">1632 EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState* exec)</span>
1633 {
<a name="144" id="anc144"></a><span class="line-modified">1634     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1635         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));</span>
1636         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1637             SamplingFlags::clearFlag(flag);
1638     }
1639     return JSValue::encode(jsNull());
1640 }
1641 #endif
1642 
<a name="145" id="anc145"></a><span class="line-modified">1643 EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState* exec)</span>
1644 {
<a name="146" id="anc146"></a><span class="line-modified">1645     return JSValue::encode(jsNumber(exec-&gt;lexicalGlobalObject()-&gt;weakRandom().seed()));</span>
1646 }
1647 
<a name="147" id="anc147"></a><span class="line-modified">1648 EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState* exec)</span>
1649 {
<a name="148" id="anc148"></a><span class="line-modified">1650     VM&amp; vm = exec-&gt;vm();</span>
1651     auto scope = DECLARE_THROW_SCOPE(vm);
1652 
<a name="149" id="anc149"></a><span class="line-modified">1653     unsigned seed = exec-&gt;argument(0).toUInt32(exec);</span>
1654     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="150" id="anc150"></a><span class="line-modified">1655     exec-&gt;lexicalGlobalObject()-&gt;weakRandom().setSeed(seed);</span>
1656     return JSValue::encode(jsUndefined());
1657 }
1658 
<a name="151" id="anc151"></a><span class="line-modified">1659 EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)</span>
1660 {
<a name="152" id="anc152"></a><span class="line-modified">1661     JSValue argument = exec-&gt;argument(0);</span>
1662     if (!argument.isString())
1663         return JSValue::encode(jsBoolean(false));
1664     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1665     return JSValue::encode(jsBoolean(!impl));
1666 }
1667 
<a name="153" id="anc153"></a><span class="line-modified">1668 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)</span>
1669 {
<a name="154" id="anc154"></a><span class="line-modified">1670     SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();</span>

1671     if (sourceOrigin.isNull())
1672         return JSValue::encode(jsNull());
<a name="155" id="anc155"></a><span class="line-modified">1673     return JSValue::encode(jsString(state-&gt;vm(), sourceOrigin.string()));</span>
1674 }
1675 
<a name="156" id="anc156"></a><span class="line-modified">1676 EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)</span>
1677 {
1678     Vector&lt;char, 256&gt; line;
1679     int c;
1680     while ((c = getchar()) != EOF) {
1681         // FIXME: Should we also break on \r?
1682         if (c == &#39;\n&#39;)
1683             break;
1684         line.append(c);
1685     }
1686     line.append(&#39;\0&#39;);
<a name="157" id="anc157"></a><span class="line-modified">1687     return JSValue::encode(jsString(exec-&gt;vm(), line.data()));</span>
1688 }
1689 
<a name="158" id="anc158"></a><span class="line-modified">1690 EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)</span>
1691 {
1692     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1693 }
1694 
<a name="159" id="anc159"></a><span class="line-modified">1695 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)</span>
1696 {
<a name="160" id="anc160"></a><span class="line-modified">1697     return JSValue::encode(setNeverInline(exec));</span>
1698 }
1699 
<a name="161" id="anc161"></a><span class="line-modified">1700 EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)</span>
1701 {
<a name="162" id="anc162"></a><span class="line-modified">1702     return JSValue::encode(setNeverOptimize(exec));</span>
1703 }
1704 
<a name="163" id="anc163"></a><span class="line-modified">1705 EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)</span>
1706 {
<a name="164" id="anc164"></a><span class="line-modified">1707     if (exec-&gt;argumentCount()) {</span>
<span class="line-modified">1708         FunctionExecutable* executable = getExecutableForFunction(exec-&gt;argument(0));</span>
1709         if (executable)
1710             executable-&gt;setNeverFTLOptimize(true);
1711     }
1712     return JSValue::encode(jsUndefined());
1713 }
1714 
<a name="165" id="anc165"></a><span class="line-modified">1715 EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState* exec)</span>
1716 {
<a name="166" id="anc166"></a><span class="line-modified">1717     return JSValue::encode(setCannotUseOSRExitFuzzing(exec));</span>
1718 }
1719 
<a name="167" id="anc167"></a><span class="line-modified">1720 EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState* exec)</span>
1721 {
<a name="168" id="anc168"></a><span class="line-modified">1722     return JSValue::encode(optimizeNextInvocation(exec));</span>
1723 }
1724 
<a name="169" id="anc169"></a><span class="line-modified">1725 EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState* exec)</span>
1726 {
<a name="170" id="anc170"></a><span class="line-modified">1727     return JSValue::encode(numberOfDFGCompiles(exec));</span>

























1728 }
1729 
1730 Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
1731     : m_contents(WTFMove(contents))
1732     , m_index(index)
1733 {
1734 }
1735 
1736 Message::~Message()
1737 {
1738 }
1739 
1740 Worker::Worker(Workers&amp; workers)
1741     : m_workers(workers)
1742 {
1743     auto locker = holdLock(m_workers.m_lock);
1744     m_workers.m_workers.append(this);
1745 
1746     *currentWorker() = this;
1747 }
1748 
1749 Worker::~Worker()
1750 {
1751     auto locker = holdLock(m_workers.m_lock);
1752     RELEASE_ASSERT(isOnList());
1753     remove();
1754 }
1755 
1756 void Worker::enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt; message)
1757 {
1758     m_messages.append(message);
1759 }
1760 
1761 RefPtr&lt;Message&gt; Worker::dequeue()
1762 {
1763     auto locker = holdLock(m_workers.m_lock);
1764     while (m_messages.isEmpty())
1765         m_workers.m_condition.wait(m_workers.m_lock);
1766     return m_messages.takeFirst();
1767 }
1768 
1769 Worker&amp; Worker::current()
1770 {
1771     return **currentWorker();
1772 }
1773 
1774 ThreadSpecific&lt;Worker*&gt;&amp; Worker::currentWorker()
1775 {
1776     static ThreadSpecific&lt;Worker*&gt;* result;
1777     static std::once_flag flag;
1778     std::call_once(
1779         flag,
1780         [] () {
1781             result = new ThreadSpecific&lt;Worker*&gt;();
1782         });
1783     return *result;
1784 }
1785 
1786 Workers::Workers()
1787 {
1788 }
1789 
1790 Workers::~Workers()
1791 {
1792     UNREACHABLE_FOR_PLATFORM();
1793 }
1794 
1795 template&lt;typename Func&gt;
1796 void Workers::broadcast(const Func&amp; func)
1797 {
1798     auto locker = holdLock(m_lock);
1799     for (Worker* worker = m_workers.begin(); worker != m_workers.end(); worker = worker-&gt;next()) {
1800         if (worker != &amp;Worker::current())
1801             func(locker, *worker);
1802     }
1803     m_condition.notifyAll();
1804 }
1805 
1806 void Workers::report(const String&amp; string)
1807 {
1808     auto locker = holdLock(m_lock);
1809     m_reports.append(string.isolatedCopy());
1810     m_condition.notifyAll();
1811 }
1812 
1813 String Workers::tryGetReport()
1814 {
1815     auto locker = holdLock(m_lock);
1816     if (m_reports.isEmpty())
1817         return String();
1818     return m_reports.takeFirst();
1819 }
1820 
1821 String Workers::getReport()
1822 {
1823     auto locker = holdLock(m_lock);
1824     while (m_reports.isEmpty())
1825         m_condition.wait(m_lock);
1826     return m_reports.takeFirst();
1827 }
1828 
1829 Workers&amp; Workers::singleton()
1830 {
1831     static Workers* result;
1832     static std::once_flag flag;
1833     std::call_once(
1834         flag,
1835         [] {
1836             result = new Workers();
1837         });
1838     return *result;
1839 }
1840 
<a name="171" id="anc171"></a><span class="line-modified">1841 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)</span>
1842 {
<a name="172" id="anc172"></a><span class="line-modified">1843     VM&amp; vm = exec-&gt;vm();</span>
1844     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1845     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));
1846 }
1847 
<a name="173" id="anc173"></a><span class="line-modified">1848 EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)</span>
1849 {
<a name="174" id="anc174"></a><span class="line-modified">1850     return functionTransferArrayBuffer(exec);</span>
<span class="line-removed">1851 }</span>
<span class="line-removed">1852 </span>
<span class="line-removed">1853 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)</span>
<span class="line-removed">1854 {</span>
<span class="line-removed">1855     VM&amp; vm = exec-&gt;vm();</span>
1856     auto scope = DECLARE_THROW_SCOPE(vm);
1857 
<a name="175" id="anc175"></a><span class="line-modified">1858     String sourceCode = exec-&gt;argument(0).toWTFString(exec);</span>
1859     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1860 
<a name="176" id="anc176"></a><span class="line-modified">1861     GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,</span>
<span class="line-modified">1862         exec-&gt;thisValue().get(exec, Identifier::fromString(vm, &quot;global&quot;)));</span>
1863     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="177" id="anc177"></a><span class="line-modified">1864     if (!globalObject)</span>
<span class="line-modified">1865         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));</span>
1866 
1867     NakedPtr&lt;Exception&gt; evaluationException;
<a name="178" id="anc178"></a><span class="line-modified">1868     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1869     if (evaluationException)
<a name="179" id="anc179"></a><span class="line-modified">1870         throwException(exec, scope, evaluationException);</span>
1871     return JSValue::encode(result);
1872 }
1873 
<a name="180" id="anc180"></a><span class="line-modified">1874 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)</span>
1875 {
<a name="181" id="anc181"></a><span class="line-modified">1876     VM&amp; vm = exec-&gt;vm();</span>
1877     auto scope = DECLARE_THROW_SCOPE(vm);
1878 
<a name="182" id="anc182"></a><span class="line-modified">1879     String sourceCode = exec-&gt;argument(0).toWTFString(exec).isolatedCopy();</span>
1880     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1881 
1882     Lock didStartLock;
1883     Condition didStartCondition;
1884     bool didStart = false;
1885 
1886     Thread::create(
1887         &quot;JSC Agent&quot;,
1888         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1889             CommandLine commandLine(0, nullptr);
1890             commandLine.m_interactive = false;
1891             runJSC(
1892                 commandLine, true,
1893                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1894                     // Notify the thread that started us that we have registered a worker.
1895                     {
1896                         auto locker = holdLock(didStartLock);
1897                         didStart = true;
1898                         didStartCondition.notifyOne();
1899                     }
1900 
1901                     NakedPtr&lt;Exception&gt; evaluationException;
1902                     JSValue result;
<a name="183" id="anc183"></a><span class="line-modified">1903                     result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
1904                     if (evaluationException)
1905                         result = evaluationException-&gt;value();
<a name="184" id="anc184"></a><span class="line-modified">1906                     checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);</span>
1907                     if (!success)
1908                         exit(1);
1909                 });
1910         })-&gt;detach();
1911 
1912     {
1913         auto locker = holdLock(didStartLock);
1914         while (!didStart)
1915             didStartCondition.wait(didStartLock);
1916     }
1917 
1918     return JSValue::encode(jsUndefined());
1919 }
1920 
<a name="185" id="anc185"></a><span class="line-modified">1921 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)</span>
1922 {
<a name="186" id="anc186"></a><span class="line-modified">1923     VM&amp; vm = exec-&gt;vm();</span>
1924     auto scope = DECLARE_THROW_SCOPE(vm);
1925 
<a name="187" id="anc187"></a><span class="line-modified">1926     JSValue callback = exec-&gt;argument(0);</span>
1927     CallData callData;
1928     CallType callType = getCallData(vm, callback, callData);
1929     if (callType == CallType::None)
<a name="188" id="anc188"></a><span class="line-modified">1930         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected callback&quot;_s)));</span>
1931 
1932     RefPtr&lt;Message&gt; message;
1933     {
1934         ReleaseHeapAccessScope releaseAccess(vm.heap);
1935         message = Worker::current().dequeue();
1936     }
1937 
1938     auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
1939     ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
<a name="189" id="anc189"></a><span class="line-modified">1940     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));</span>
1941 
1942     MarkedArgumentBuffer args;
1943     args.append(jsBuffer);
1944     args.append(jsNumber(message-&gt;index()));
1945     if (UNLIKELY(args.hasOverflowed()))
<a name="190" id="anc190"></a><span class="line-modified">1946         return JSValue::encode(throwOutOfMemoryError(exec, scope));</span>
<span class="line-modified">1947     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, callback, callType, callData, jsNull(), args)));</span>
1948 }
1949 
<a name="191" id="anc191"></a><span class="line-modified">1950 EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState* exec)</span>
1951 {
<a name="192" id="anc192"></a><span class="line-modified">1952     VM&amp; vm = exec-&gt;vm();</span>
1953     auto scope = DECLARE_THROW_SCOPE(vm);
1954 
<a name="193" id="anc193"></a><span class="line-modified">1955     String report = exec-&gt;argument(0).toWTFString(exec);</span>
1956     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1957 
1958     Workers::singleton().report(report);
1959 
1960     return JSValue::encode(jsUndefined());
1961 }
1962 
<a name="194" id="anc194"></a><span class="line-modified">1963 EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState* exec)</span>
1964 {
<a name="195" id="anc195"></a><span class="line-modified">1965     VM&amp; vm = exec-&gt;vm();</span>
1966     auto scope = DECLARE_THROW_SCOPE(vm);
1967 
<a name="196" id="anc196"></a><span class="line-modified">1968     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1969         Seconds seconds = Seconds::fromMilliseconds(exec-&gt;argument(0).toNumber(exec));</span>
1970         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1971         sleep(seconds);
1972     }
1973     return JSValue::encode(jsUndefined());
1974 }
1975 
<a name="197" id="anc197"></a><span class="line-modified">1976 EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState* exec)</span>
1977 {
<a name="198" id="anc198"></a><span class="line-modified">1978     VM&amp; vm = exec-&gt;vm();</span>
1979     auto scope = DECLARE_THROW_SCOPE(vm);
1980 
<a name="199" id="anc199"></a><span class="line-modified">1981     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));</span>
1982     if (!jsBuffer || !jsBuffer-&gt;isShared())
<a name="200" id="anc200"></a><span class="line-modified">1983         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected SharedArrayBuffer&quot;_s)));</span>
1984 
<a name="201" id="anc201"></a><span class="line-modified">1985     int32_t index = exec-&gt;argument(1).toInt32(exec);</span>
1986     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1987 
1988     Workers::singleton().broadcast(
1989         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
1990             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
1991             ArrayBufferContents contents;
1992             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
1993             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
1994             worker.enqueue(locker, message);
1995         });
1996 
1997     return JSValue::encode(jsUndefined());
1998 }
1999 
<a name="202" id="anc202"></a><span class="line-modified">2000 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)</span>
2001 {
<a name="203" id="anc203"></a><span class="line-modified">2002     VM&amp; vm = exec-&gt;vm();</span>
2003 
2004     String string = Workers::singleton().tryGetReport();
2005     if (!string)
2006         return JSValue::encode(jsNull());
2007 
2008     return JSValue::encode(jsString(vm, string));
2009 }
2010 
<a name="204" id="anc204"></a><span class="line-modified">2011 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)</span>
2012 {
2013     return JSValue::encode(jsUndefined());
2014 }
2015 
<a name="205" id="anc205"></a><span class="line-modified">2016 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)</span>
2017 {
2018     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
2019 }
2020 
<a name="206" id="anc206"></a><span class="line-modified">2021 EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)</span>
2022 {
<a name="207" id="anc207"></a><span class="line-modified">2023     VM&amp; vm = exec-&gt;vm();</span>
2024 
2025     String string;
2026     {
2027         ReleaseHeapAccessScope releaseAccess(vm.heap);
2028         string = Workers::singleton().getReport();
2029     }
2030     if (!string)
2031         return JSValue::encode(jsNull());
2032 
2033     return JSValue::encode(jsString(vm, string));
2034 }
2035 
<a name="208" id="anc208"></a><span class="line-modified">2036 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)</span>
2037 {
<a name="209" id="anc209"></a><span class="line-modified">2038     VM&amp; vm = exec-&gt;vm();</span>
2039     return JSValue::encode(jsNumber(vm.heap.capacity()));
2040 }
2041 
<a name="210" id="anc210"></a><span class="line-modified">2042 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)</span>
2043 {
<a name="211" id="anc211"></a><span class="line-modified">2044     VM&amp; vm = exec-&gt;vm();</span>
2045     auto scope = DECLARE_THROW_SCOPE(vm);
2046 
2047     double sleepTimeMs = 0;
<a name="212" id="anc212"></a><span class="line-modified">2048     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">2049         sleepTimeMs = exec-&gt;argument(0).toNumber(exec);</span>
2050         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2051     }
2052 
2053     vm.heap.releaseAccess();
2054     if (sleepTimeMs)
2055         sleep(Seconds::fromMilliseconds(sleepTimeMs));
2056     vm.heap.acquireAccess();
2057     return JSValue::encode(jsUndefined());
2058 }
2059 
<a name="213" id="anc213"></a><span class="line-modified">2060 EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*)</span>
2061 {
2062     supportsRichSourceInfo = false;
2063     return JSValue::encode(jsUndefined());
2064 }
2065 
<a name="214" id="anc214"></a><span class="line-modified">2066 EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*)</span>
2067 {
2068     Vector&lt;void*&gt; ptrs;
2069     for (unsigned i = 0; i &lt; 5000; ++i)
2070         ptrs.append(fastMalloc(1024 * 2));
2071     for (void* ptr : ptrs)
2072         fastFree(ptr);
2073     return JSValue::encode(jsUndefined());
2074 }
2075 
<a name="215" id="anc215"></a><span class="line-modified">2076 EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*)</span>
2077 {
2078 #if ENABLE(JIT)
2079     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2080 #else
2081     return JSValue::encode(jsNumber(0));
2082 #endif
2083 }
2084 
2085 template&lt;typename ValueType&gt;
2086 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2087 
2088 template&lt;typename ValueType&gt;
2089 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2090 {
2091     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2092 }
2093 
<a name="216" id="anc216"></a><span class="line-modified">2094 EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)</span>
2095 {
<a name="217" id="anc217"></a><span class="line-modified">2096     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2097     JSObject* optionsObject = constructEmptyObject(exec);</span>
<span class="line-modified">2098 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
2099     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());
<a name="218" id="anc218"></a><span class="line-modified">2100     JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified">2101 #undef FOR_EACH_OPTION</span>
2102     return JSValue::encode(optionsObject);
2103 }
2104 
<a name="219" id="anc219"></a><span class="line-modified">2105 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)</span>
2106 {
<a name="220" id="anc220"></a><span class="line-modified">2107     if (exec-&gt;argumentCount() &lt; 1)</span>
2108         return JSValue::encode(jsUndefined());
2109 
<a name="221" id="anc221"></a><span class="line-modified">2110     CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec-&gt;argument(0));</span>
2111     if (!block)
2112         return JSValue::encode(jsNumber(0));
2113 
2114     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2115 }
2116 
<a name="222" id="anc222"></a><span class="line-modified">2117 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)</span>
2118 {
<a name="223" id="anc223"></a><span class="line-modified">2119     VM&amp; vm = exec-&gt;vm();</span>
2120     auto scope = DECLARE_THROW_SCOPE(vm);
2121 
<a name="224" id="anc224"></a><span class="line-modified">2122     if (exec-&gt;argumentCount() &lt; 1)</span>
<span class="line-modified">2123         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Not enough arguments&quot;_s)));</span>
2124 
<a name="225" id="anc225"></a><span class="line-modified">2125     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));</span>
2126     if (!buffer)
<a name="226" id="anc226"></a><span class="line-modified">2127         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected an array buffer&quot;_s)));</span>
2128 
2129     ArrayBufferContents dummyContents;
2130     buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
2131 
2132     return JSValue::encode(jsUndefined());
2133 }
2134 
<a name="227" id="anc227"></a><span class="line-modified">2135 EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState* exec)</span>
2136 {
<a name="228" id="anc228"></a><span class="line-modified">2137     VM&amp; vm = exec-&gt;vm();</span>
2138     vm.setFailNextNewCodeBlock();
2139     return JSValue::encode(jsUndefined());
2140 }
2141 
<a name="229" id="anc229"></a><span class="line-modified">2142 EncodedJSValue JSC_HOST_CALL functionQuit(ExecState* exec)</span>
2143 {
<a name="230" id="anc230"></a><span class="line-modified">2144     VM&amp; vm = exec-&gt;vm();</span>
2145     vm.codeCache()-&gt;write(vm);
2146 
2147     jscExit(EXIT_SUCCESS);
2148 
2149 #if COMPILER(MSVC)
2150     // Without this, Visual Studio will complain that this method does not return a value.
2151     return JSValue::encode(jsUndefined());
2152 #endif
2153 }
2154 
<a name="231" id="anc231"></a><span class="line-modified">2155 EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*) { return JSValue::encode(jsBoolean(false)); }</span>
2156 
<a name="232" id="anc232"></a><span class="line-modified">2157 EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">2158 EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">2159 EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState* exec)</span>
2160 {
<a name="233" id="anc233"></a><span class="line-modified">2161     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2162         if (!exec-&gt;argument(i).isInt32())</span>
2163             return JSValue::encode(jsBoolean(false));
2164     }
2165     return JSValue::encode(jsBoolean(true));
2166 }
2167 
<a name="234" id="anc234"></a><span class="line-modified">2168 EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState* exec)</span>
2169 {
<a name="235" id="anc235"></a><span class="line-modified">2170     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2171         JSValue value = exec-&gt;argument(i);</span>
2172         if (!value.isNumber())
2173             return JSValue::encode(jsBoolean(false));
2174         double number = value.asNumber();
2175         if (!std::isnan(number))
2176             return JSValue::encode(jsBoolean(false));
2177         if (isImpureNaN(number))
2178             return JSValue::encode(jsBoolean(false));
2179     }
2180     return JSValue::encode(jsBoolean(true));
2181 }
2182 
<a name="236" id="anc236"></a><span class="line-modified">2183 EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState* exec) { return JSValue::encode(exec-&gt;argument(0)); }</span>
2184 
<a name="237" id="anc237"></a><span class="line-modified">2185 EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*)</span>
2186 {
2187     return JSValue::encode(jsNumber(42));
2188 }
2189 
<a name="238" id="anc238"></a><span class="line-modified">2190 EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState* exec)</span>
2191 {
<a name="239" id="anc239"></a><span class="line-modified">2192     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2193     return JSValue::encode(Masquerader::create(vm, exec-&gt;lexicalGlobalObject()));</span>
2194 }
2195 
<a name="240" id="anc240"></a><span class="line-modified">2196 EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState* exec)</span>
2197 {
<a name="241" id="anc241"></a><span class="line-modified">2198     JSValue value = exec-&gt;argument(0);</span>
2199     if (value.isObject())
<a name="242" id="anc242"></a><span class="line-modified">2200         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(exec-&gt;vm())));</span>
2201     return JSValue::encode(jsBoolean(false));
2202 }
2203 
<a name="243" id="anc243"></a><span class="line-modified">2204 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)</span>
2205 {
<a name="244" id="anc244"></a><span class="line-modified">2206     VM&amp; vm = exec-&gt;vm();</span>
2207     vm.dumpTypeProfilerData();
2208     return JSValue::encode(jsUndefined());
2209 }
2210 
<a name="245" id="anc245"></a><span class="line-modified">2211 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)</span>
2212 {
<a name="246" id="anc246"></a><span class="line-modified">2213     VM&amp; vm = exec-&gt;vm();</span>
2214     vm.drainMicrotasks();
2215     return JSValue::encode(jsUndefined());
2216 }
2217 
<a name="247" id="anc247"></a><span class="line-modified">2218 EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState* exec)</span>
2219 {
<a name="248" id="anc248"></a><span class="line-modified">2220     VM&amp; vm = exec-&gt;vm();</span>
2221     vm.finalizeSynchronousJSExecution();
2222     return JSValue::encode(jsUndefined());
2223 }
2224 
<a name="249" id="anc249"></a><span class="line-modified">2225 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)</span>
2226 {
2227 #if USE(JSVALUE64)
2228     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2229 #else
2230     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2231 #endif
2232 }
2233 
<a name="250" id="anc250"></a><span class="line-modified">2234 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)</span>
2235 {
<a name="251" id="anc251"></a><span class="line-modified">2236     VM&amp; vm = exec-&gt;vm();</span>
2237     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2238 }
2239 
<a name="252" id="anc252"></a><span class="line-modified">2240 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)</span>
2241 {
<a name="253" id="anc253"></a><span class="line-modified">2242     VM&amp; vm = exec-&gt;vm();</span>
2243     auto scope = DECLARE_THROW_SCOPE(vm);
2244 
<a name="254" id="anc254"></a><span class="line-modified">2245     String source = exec-&gt;argument(0).toWTFString(exec);</span>
2246     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2247 
2248     StopWatch stopWatch;
2249     stopWatch.start();
2250 
2251     ParserError error;
<a name="255" id="anc255"></a><span class="line-modified">2252     bool validSyntax = checkModuleSyntax(exec, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
2253     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2254     stopWatch.stop();
2255 
2256     if (!validSyntax)
<a name="256" id="anc256"></a><span class="line-modified">2257         throwException(exec, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
2258     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2259 }
2260 
<a name="257" id="anc257"></a><span class="line-modified">2261 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)</span>
2262 {
2263 #if ENABLE(SAMPLING_PROFILER)
2264     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2265 #else
2266     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2267 #endif
2268 }
2269 
<a name="258" id="anc258"></a><span class="line-modified">2270 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)</span>
2271 {
<a name="259" id="anc259"></a><span class="line-modified">2272     VM&amp; vm = exec-&gt;vm();</span>
2273     JSLockHolder lock(vm);
2274     auto scope = DECLARE_THROW_SCOPE(vm);
2275 
2276     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2277     snapshotBuilder.buildSnapshot();
2278 
2279     String jsonString = snapshotBuilder.json();
<a name="260" id="anc260"></a><span class="line-modified">2280     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));</span>
2281     scope.releaseAssertNoException();
2282     return result;
2283 }
2284 
<a name="261" id="anc261"></a><span class="line-modified">2285 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)</span>
2286 {
<a name="262" id="anc262"></a><span class="line-modified">2287     VM&amp; vm = exec-&gt;vm();</span>
2288     JSLockHolder lock(vm);
2289     auto scope = DECLARE_THROW_SCOPE(vm);
2290     String jsonString;
2291     {
2292         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2293 
2294         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2295         snapshotBuilder.buildSnapshot();
2296 
2297         jsonString = snapshotBuilder.json();
2298     }
2299     scope.releaseAssertNoException();
2300     return JSValue::encode(jsString(vm, jsonString));
2301 }
2302 
<a name="263" id="anc263"></a><span class="line-modified">2303 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)</span>
2304 {
2305     resetSuperSamplerState();
2306     return JSValue::encode(jsUndefined());
2307 }
2308 
<a name="264" id="anc264"></a><span class="line-modified">2309 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)</span>
2310 {
<a name="265" id="anc265"></a><span class="line-modified">2311     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2312     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2313         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(i)))</span>
2314             object-&gt;ensureArrayStorage(vm);
2315     }
2316     return JSValue::encode(jsUndefined());
2317 }
2318 
2319 #if ENABLE(SAMPLING_PROFILER)
<a name="266" id="anc266"></a><span class="line-modified">2320 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)</span>
2321 {
<a name="267" id="anc267"></a><span class="line-modified">2322     VM&amp; vm = exec-&gt;vm();</span>
2323     SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
2324     samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
2325     samplingProfiler.start();
2326     return JSValue::encode(jsUndefined());
2327 }
2328 
<a name="268" id="anc268"></a><span class="line-modified">2329 EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState* exec)</span>
2330 {
<a name="269" id="anc269"></a><span class="line-modified">2331     VM&amp; vm = exec-&gt;vm();</span>
2332     auto scope = DECLARE_THROW_SCOPE(vm);
2333 
2334     if (!vm.samplingProfiler())
<a name="270" id="anc270"></a><span class="line-modified">2335         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Sampling profiler was never started&quot;_s)));</span>
2336 
2337     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
<a name="271" id="anc271"></a><span class="line-modified">2338     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));</span>
2339     scope.releaseAssertNoException();
2340     return result;
2341 }
2342 #endif // ENABLE(SAMPLING_PROFILER)
2343 
<a name="272" id="anc272"></a><span class="line-modified">2344 EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)</span>
2345 {
2346     return JSValue::encode(jsNumber(JSC::maxArguments));
2347 }
2348 
<a name="273" id="anc273"></a><span class="line-modified">2349 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)</span>
2350 {
<a name="274" id="anc274"></a><span class="line-modified">2351     VM&amp; vm = exec-&gt;vm();</span>
2352     auto scope = DECLARE_THROW_SCOPE(vm);
2353 
<a name="275" id="anc275"></a><span class="line-modified">2354     JSValue numberOfAsyncPasses = exec-&gt;argument(0);</span>
2355     if (!numberOfAsyncPasses.isUInt32())
<a name="276" id="anc276"></a><span class="line-modified">2356         return throwVMError(exec, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
2357 
2358     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2359     return encodedJSUndefined();
2360 }
2361 
<a name="277" id="anc277"></a><span class="line-modified">2362 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)</span>
2363 {
2364     asyncTestPasses++;
2365     return encodedJSUndefined();
2366 }
2367 
2368 #if ENABLE(WEBASSEMBLY)
2369 
<a name="278" id="anc278"></a><span class="line-modified">2370 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)</span>
2371 {
<a name="279" id="anc279"></a><span class="line-modified">2372     VM&amp; vm = exec-&gt;vm();</span>
2373     auto scope = DECLARE_THROW_SCOPE(vm);
2374 
2375     if (!Wasm::isSupported())
<a name="280" id="anc280"></a><span class="line-modified">2376         return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);</span>
2377 
<a name="281" id="anc281"></a><span class="line-modified">2378     if (JSObject* object = exec-&gt;argument(0).getObject()) {</span>
2379         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
2380             return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));
2381         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
2382             return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));
2383     }
2384 
<a name="282" id="anc282"></a><span class="line-modified">2385     return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);</span>
2386 }
2387 
2388 #endif // ENABLE(WEBASSEMBLY)
2389 
<a name="283" id="anc283"></a><span class="line-modified">2390 EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState* exec)</span>
2391 {
<a name="284" id="anc284"></a><span class="line-modified">2392     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2393     JSObject* object = exec-&gt;argument(0).getObject();</span>
2394     auto scope = DECLARE_THROW_SCOPE(vm);
2395 
2396     if (!object || !object-&gt;isFunction(vm))
<a name="285" id="anc285"></a><span class="line-modified">2397         return throwVMTypeError(exec, scope);</span>
2398 
<a name="286" id="anc286"></a><span class="line-modified">2399     exec-&gt;lexicalGlobalObject()-&gt;setUnhandledRejectionCallback(vm, object);</span>
2400     return JSValue::encode(jsUndefined());
2401 }
2402 
2403 // Use SEH for Release builds only to get rid of the crash report dialog
2404 // (luckily the same tests fail in Release and Debug builds so far). Need to
2405 // be in a separate main function because the jscmain function requires object
2406 // unwinding.
2407 
2408 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2409 #define TRY       __try {
2410 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2411 #else
2412 #define TRY
2413 #define EXCEPT(x)
2414 #endif
2415 
2416 int jscmain(int argc, char** argv);
2417 
2418 static double s_desiredTimeout;
2419 static double s_timeoutMultiplier = 1.0;
<a name="287" id="anc287"></a>















2420 
<a name="288" id="anc288"></a><span class="line-modified">2421 static void startTimeoutThreadIfNeeded()</span>












2422 {
2423     if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
2424         if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
2425             dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
2426                 &quot; but expected a number. Not using a timeout.\n&quot;);
<a name="289" id="anc289"></a><span class="line-modified">2427         } else {</span>
<span class="line-modified">2428             Thread::create(&quot;jsc Timeout Thread&quot;, [] () {</span>
<span class="line-removed">2429                 Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);</span>
<span class="line-removed">2430                 sleep(timeoutDuration);</span>
<span class="line-removed">2431                 dataLog(&quot;Timed out after &quot;, timeoutDuration, &quot; seconds!\n&quot;);</span>
<span class="line-removed">2432                 CRASH();</span>
<span class="line-removed">2433             });</span>
<span class="line-removed">2434         }</span>
2435     }
2436 }
2437 
<a name="290" id="anc290"></a>











2438 int main(int argc, char** argv)
2439 {
<a name="291" id="anc291"></a><span class="line-modified">2440 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)</span>
2441     // Enabled IEEE754 denormal support.
2442     fenv_t env;
2443     fegetenv( &amp;env );
2444     env.__fpscr &amp;= ~0x01000000u;
2445     fesetenv( &amp;env );
2446 #endif
2447 
2448 #if OS(WINDOWS)
2449     // Cygwin calls ::SetErrorMode(SEM_FAILCRITICALERRORS), which we will inherit. This is bad for
2450     // testing/debugging, as it causes the post-mortem debugger not to be invoked. We reset the
2451     // error mode here to work around Cygwin&#39;s behavior. See &lt;http://webkit.org/b/55222&gt;.
2452     ::SetErrorMode(0);
2453 
2454     _setmode(_fileno(stdout), _O_BINARY);
2455     _setmode(_fileno(stderr), _O_BINARY);
2456 
2457 #if defined(_DEBUG)
2458     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
2459     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
2460     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
2461     _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
2462     _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
2463     _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
2464 #endif
2465 
2466     timeBeginPeriod(1);
2467 #endif
2468 
2469 #if PLATFORM(GTK)
2470     if (!setlocale(LC_ALL, &quot;&quot;))
2471         WTFLogAlways(&quot;Locale not supported by C library.\n\tUsing the fallback &#39;C&#39; locale.&quot;);
2472 #endif
2473 
2474     // Need to initialize WTF threading before we start any threads. Cannot initialize JSC
2475     // threading yet, since that would do somethings that we&#39;d like to defer until after we
2476     // have a chance to parse options.
2477     WTF::initializeThreading();
2478 
2479 #if PLATFORM(IOS_FAMILY)
2480     Options::crashIfCantAllocateJITMemory() = true;
2481 #endif
2482 
2483     // We can&#39;t use destructors in the following code because it uses Windows
2484     // Structured Exception Handling
2485     int res = 0;
2486     TRY
2487         res = jscmain(argc, argv);
2488     EXCEPT(res = 3)
2489     finalizeStatsAtEndOfTesting();
2490 
2491     jscExit(res);
2492 }
2493 
2494 static void dumpException(GlobalObject* globalObject, JSValue exception)
2495 {
2496     VM&amp; vm = globalObject-&gt;vm();
2497     auto scope = DECLARE_CATCH_SCOPE(vm);
2498 
2499 #define CHECK_EXCEPTION() do { \
2500         if (scope.exception()) { \
2501             scope.clearException(); \
2502             return; \
2503         } \
2504     } while (false)
2505 
<a name="292" id="anc292"></a><span class="line-modified">2506     auto exceptionString = exception.toWTFString(globalObject-&gt;globalExec());</span>

2507     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2508     if (expectedCString)
2509         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2510     else
2511         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2512 
2513     Identifier nameID = Identifier::fromString(vm, &quot;name&quot;);
2514     CHECK_EXCEPTION();
2515     Identifier fileNameID = Identifier::fromString(vm, &quot;sourceURL&quot;);
2516     CHECK_EXCEPTION();
2517     Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);
2518     CHECK_EXCEPTION();
2519     Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);
2520     CHECK_EXCEPTION();
2521 
<a name="293" id="anc293"></a><span class="line-modified">2522     JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);</span>
2523     CHECK_EXCEPTION();
<a name="294" id="anc294"></a><span class="line-modified">2524     JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);</span>
2525     CHECK_EXCEPTION();
<a name="295" id="anc295"></a><span class="line-modified">2526     JSValue lineNumberValue = exception.get(globalObject-&gt;globalExec(), lineNumberID);</span>
2527     CHECK_EXCEPTION();
<a name="296" id="anc296"></a><span class="line-modified">2528     JSValue stackValue = exception.get(globalObject-&gt;globalExec(), stackID);</span>
2529     CHECK_EXCEPTION();
2530 
<a name="297" id="anc297"></a><span class="line-modified">2531     if (nameValue.toWTFString(globalObject-&gt;globalExec()) == &quot;SyntaxError&quot;</span>
<span class="line-modified">2532         &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {</span>
<span class="line-modified">2533         printf(</span>
<span class="line-modified">2534             &quot;at %s:%s\n&quot;,</span>
<span class="line-modified">2535             fileNameValue.toWTFString(globalObject-&gt;globalExec()).utf8().data(),</span>
<span class="line-modified">2536             lineNumberValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>



2537     }
2538 
2539     if (!stackValue.isUndefinedOrNull()) {
<a name="298" id="anc298"></a><span class="line-modified">2540         auto stackString = stackValue.toWTFString(globalObject-&gt;globalExec());</span>

2541         if (stackString.length())
2542             printf(&quot;%s\n&quot;, stackString.utf8().data());
2543     }
2544 
2545 #undef CHECK_EXCEPTION
2546 }
2547 
2548 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2549 {
2550     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2551     auto scope = DECLARE_CATCH_SCOPE(vm);
2552     scope.clearException();
2553     if (!exception) {
2554         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2555         return false;
2556     }
2557 
<a name="299" id="anc299"></a><span class="line-modified">2558     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">2559     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(vm, expectedExceptionName));</span>
2560     if (!exceptionClass.isObject() || scope.exception()) {
2561         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2562         return false;
2563     }
2564 
<a name="300" id="anc300"></a><span class="line-modified">2565     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(exec, exception);</span>
2566     if (scope.exception()) {
2567         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2568         return false;
2569     }
2570     if (isInstanceOfExpectedException) {
2571         if (options.m_alwaysDumpUncaughtException)
2572             dumpException(globalObject, exception);
2573         return true;
2574     }
2575 
2576     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2577     dumpException(globalObject, exception);
2578     return false;
2579 }
2580 
<a name="301" id="anc301"></a><span class="line-modified">2581 static void checkException(ExecState* exec, GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)</span>
2582 {
2583     VM&amp; vm = globalObject-&gt;vm();
2584 
2585     if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
2586         ASSERT(hasException);
2587         return;
2588     }
2589 
2590     if (!options.m_uncaughtExceptionName || !isLastFile) {
2591         success = success &amp;&amp; !hasException;
2592         if (options.m_dump &amp;&amp; !hasException)
<a name="302" id="anc302"></a><span class="line-modified">2593             printf(&quot;End: %s\n&quot;, value.toWTFString(exec).utf8().data());</span>
2594         if (hasException)
2595             dumpException(globalObject, value);
2596     } else
2597         success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
2598 }
2599 
2600 static void runWithOptions(GlobalObject* globalObject, CommandLine&amp; options, bool&amp; success)
2601 {
2602     Vector&lt;Script&gt;&amp; scripts = options.m_scripts;
2603     String fileName;
2604     Vector&lt;char&gt; scriptBuffer;
2605 
<a name="303" id="anc303"></a><span class="line-removed">2606     if (options.m_dump)</span>
<span class="line-removed">2607         JSC::Options::dumpGeneratedBytecodes() = true;</span>
<span class="line-removed">2608 </span>
2609     VM&amp; vm = globalObject-&gt;vm();
2610     auto scope = DECLARE_CATCH_SCOPE(vm);
2611 
2612 #if ENABLE(SAMPLING_FLAGS)
2613     SamplingFlags::start();
2614 #endif
2615 
2616     for (size_t i = 0; i &lt; scripts.size(); i++) {
2617         JSInternalPromise* promise = nullptr;
2618         bool isModule = options.m_module || scripts[i].scriptType == Script::ScriptType::Module;
2619         if (scripts[i].codeSource == Script::CodeSource::File) {
2620             fileName = scripts[i].argument;
2621             if (scripts[i].strictMode == Script::StrictMode::Strict)
2622                 scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
2623 
2624             if (isModule) {
<a name="304" id="anc304"></a><span class="line-modified">2625                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), fileName, jsUndefined(), jsUndefined());</span>
2626                 scope.releaseAssertNoException();
2627             } else {
2628                 if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
2629                     success = false; // fail early so we can catch missing files
2630                     return;
2631                 }
2632             }
2633         } else {
2634             size_t commandLineLength = strlen(scripts[i].argument);
2635             scriptBuffer.resize(commandLineLength);
2636             std::copy(scripts[i].argument, scripts[i].argument + commandLineLength, scriptBuffer.begin());
2637             fileName = &quot;[Command Line]&quot;_s;
2638         }
2639 
2640         bool isLastFile = i == scripts.size() - 1;
2641         if (isModule) {
2642             if (!promise) {
2643                 // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
<a name="305" id="anc305"></a><span class="line-modified">2644                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());</span>
2645             }
2646             scope.clearException();
2647 
<a name="306" id="anc306"></a><span class="line-modified">2648             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {</span>
<span class="line-modified">2649                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, false, exec-&gt;argument(0), options, success);</span>
2650                 return JSValue::encode(jsUndefined());
2651             });
2652 
<a name="307" id="anc307"></a><span class="line-modified">2653             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {</span>
<span class="line-modified">2654                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, true, exec-&gt;argument(0), options, success);</span>
2655                 return JSValue::encode(jsUndefined());
2656             });
2657 
<a name="308" id="anc308"></a><span class="line-modified">2658             promise-&gt;then(globalObject-&gt;globalExec(), fulfillHandler, rejectHandler);</span>
2659             scope.releaseAssertNoException();
2660             vm.drainMicrotasks();
2661         } else {
2662             NakedPtr&lt;Exception&gt; evaluationException;
<a name="309" id="anc309"></a><span class="line-modified">2663             JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
2664             scope.assertNoException();
2665             if (evaluationException)
2666                 returnValue = evaluationException-&gt;value();
<a name="310" id="anc310"></a><span class="line-modified">2667             checkException(globalObject-&gt;globalExec(), globalObject, isLastFile, evaluationException, returnValue, options, success);</span>
2668         }
2669 
2670         scriptBuffer.clear();
2671         scope.clearException();
2672     }
2673 
2674 #if ENABLE(REGEXP_TRACING)
2675     vm.dumpRegExpTrace();
2676 #endif
2677 }
2678 
2679 #define RUNNING_FROM_XCODE 0
2680 
2681 static void runInteractive(GlobalObject* globalObject)
2682 {
2683     VM&amp; vm = globalObject-&gt;vm();
2684     auto scope = DECLARE_CATCH_SCOPE(vm);
2685 
2686     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2687     if (!directoryName)
2688         return;
2689     SourceOrigin sourceOrigin(resolvePath(directoryName.value(), ModuleName(&quot;interpreter&quot;)));
2690 
2691     bool shouldQuit = false;
2692     while (!shouldQuit) {
2693 #if HAVE(READLINE) &amp;&amp; !RUNNING_FROM_XCODE
2694         ParserError error;
2695         String source;
2696         do {
2697             error = ParserError();
2698             char* line = readline(source.isEmpty() ? interactivePrompt : &quot;... &quot;);
2699             shouldQuit = !line;
2700             if (!line)
2701                 break;
2702             source = source + String::fromUTF8(line);
2703             source = source + &#39;\n&#39;;
2704             checkSyntax(vm, jscSource(source, sourceOrigin), error);
2705             if (!line[0]) {
2706                 free(line);
2707                 break;
2708             }
2709             add_history(line);
2710             free(line);
2711         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2712 
2713         if (error.isValid()) {
2714             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2715             continue;
2716         }
2717 
2718 
2719         NakedPtr&lt;Exception&gt; evaluationException;
<a name="311" id="anc311"></a><span class="line-modified">2720         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
2721 #else
2722         printf(&quot;%s&quot;, interactivePrompt);
2723         Vector&lt;char, 256&gt; line;
2724         int c;
2725         while ((c = getchar()) != EOF) {
2726             // FIXME: Should we also break on \r?
2727             if (c == &#39;\n&#39;)
2728                 break;
2729             line.append(c);
2730         }
2731         if (line.isEmpty())
2732             break;
2733 
2734         NakedPtr&lt;Exception&gt; evaluationException;
<a name="312" id="anc312"></a><span class="line-modified">2735         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);</span>
2736 #endif
2737         if (evaluationException)
<a name="313" id="anc313"></a><span class="line-modified">2738             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>
2739         else
<a name="314" id="anc314"></a><span class="line-modified">2740             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>
2741 
2742         scope.clearException();
2743         vm.drainMicrotasks();
2744     }
2745     printf(&quot;\n&quot;);
2746 }
2747 
2748 static NO_RETURN void printUsageStatement(bool help = false)
2749 {
2750     fprintf(stderr, &quot;Usage: jsc [options] [files] [-- arguments]\n&quot;);
2751     fprintf(stderr, &quot;  -d         Dumps bytecode (debug builds only)\n&quot;);
2752     fprintf(stderr, &quot;  -e         Evaluate argument as script code\n&quot;);
2753     fprintf(stderr, &quot;  -f         Specifies a source file (deprecated)\n&quot;);
2754     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2755     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2756     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2757 #if HAVE(SIGNAL_H)
2758     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2759 #endif
2760     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
2761     fprintf(stderr, &quot;  -x         Output exit code before terminating\n&quot;);
2762     fprintf(stderr, &quot;\n&quot;);
2763     fprintf(stderr, &quot;  --sample                   Collects and outputs sampling profiler data\n&quot;);
2764     fprintf(stderr, &quot;  --test262-async            Check that some script calls the print function with the string &#39;Test262:AsyncTestComplete&#39;\n&quot;);
2765     fprintf(stderr, &quot;  --strict-file=&lt;file&gt;       Parse the given file as if it were in strict mode (this option may be passed more than once)\n&quot;);
2766     fprintf(stderr, &quot;  --module-file=&lt;file&gt;       Parse and evaluate the given file as module (this option may be passed more than once)\n&quot;);
2767     fprintf(stderr, &quot;  --exception=&lt;name&gt;         Check the last script exits with an uncaught exception with the specified name\n&quot;);
2768     fprintf(stderr, &quot;  --watchdog-exception-ok    Uncaught watchdog exceptions exit with success\n&quot;);
2769     fprintf(stderr, &quot;  --dumpException            Dump uncaught exception text\n&quot;);
2770     fprintf(stderr, &quot;  --footprint                Dump memory footprint after done executing\n&quot;);
2771     fprintf(stderr, &quot;  --options                  Dumps all JSC VM options and exits\n&quot;);
2772     fprintf(stderr, &quot;  --dumpOptions              Dumps all non-default JSC VM options before continuing\n&quot;);
2773     fprintf(stderr, &quot;  --&lt;jsc VM option&gt;=&lt;value&gt;  Sets the specified JSC VM option\n&quot;);
2774     fprintf(stderr, &quot;  --destroy-vm               Destroy VM before exiting\n&quot;);
2775     fprintf(stderr, &quot;\n&quot;);
2776     fprintf(stderr, &quot;Files with a .mjs extension will always be evaluated as modules.\n&quot;);
2777     fprintf(stderr, &quot;\n&quot;);
2778 
2779     jscExit(help ? EXIT_SUCCESS : EXIT_FAILURE);
2780 }
2781 
2782 static bool isMJSFile(char *filename)
2783 {
2784     filename = strrchr(filename, &#39;.&#39;);
2785 
2786     if (filename)
2787         return !strcmp(filename, &quot;.mjs&quot;);
2788 
2789     return false;
2790 }
2791 
2792 void CommandLine::parseArguments(int argc, char** argv)
2793 {
2794     Options::initialize();
2795 
2796     if (Options::dumpOptions()) {
2797         printf(&quot;Command line:&quot;);
2798 #if PLATFORM(COCOA)
2799         for (char** envp = *_NSGetEnviron(); *envp; envp++) {
2800             const char* env = *envp;
2801             if (!strncmp(&quot;JSC_&quot;, env, 4))
2802                 printf(&quot; %s&quot;, env);
2803         }
2804 #endif // PLATFORM(COCOA)
2805         for (int i = 0; i &lt; argc; ++i)
2806             printf(&quot; %s&quot;, argv[i]);
2807         printf(&quot;\n&quot;);
2808     }
2809 
2810     int i = 1;
2811     JSC::Options::DumpLevel dumpOptionsLevel = JSC::Options::DumpLevel::None;
2812     bool needToExit = false;
2813 
2814     bool hasBadJSCOptions = false;
2815     for (; i &lt; argc; ++i) {
2816         const char* arg = argv[i];
2817         if (!strcmp(arg, &quot;-f&quot;)) {
2818             if (++i == argc)
2819                 printUsageStatement();
2820             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Script, argv[i]));
2821             continue;
2822         }
2823         if (!strcmp(arg, &quot;-e&quot;)) {
2824             if (++i == argc)
2825                 printUsageStatement();
2826             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::CommandLine, Script::ScriptType::Script, argv[i]));
2827             continue;
2828         }
2829         if (!strcmp(arg, &quot;-i&quot;)) {
2830             m_interactive = true;
2831             continue;
2832         }
2833         if (!strcmp(arg, &quot;-d&quot;)) {
2834             m_dump = true;
2835             continue;
2836         }
2837         if (!strcmp(arg, &quot;-p&quot;)) {
2838             if (++i == argc)
2839                 printUsageStatement();
2840             m_profile = true;
2841             m_profilerOutput = argv[i];
2842             continue;
2843         }
2844         if (!strcmp(arg, &quot;-m&quot;)) {
2845             m_module = true;
2846             continue;
2847         }
2848         if (!strcmp(arg, &quot;-s&quot;)) {
2849 #if HAVE(SIGNAL_H)
2850             signal(SIGILL, _exit);
2851             signal(SIGFPE, _exit);
2852             signal(SIGBUS, _exit);
2853             signal(SIGSEGV, _exit);
2854 #endif
2855             continue;
2856         }
2857         if (!strcmp(arg, &quot;-x&quot;)) {
2858             m_exitCode = true;
2859             continue;
2860         }
2861         if (!strcmp(arg, &quot;--&quot;)) {
2862             ++i;
2863             break;
2864         }
2865         if (!strcmp(arg, &quot;-h&quot;) || !strcmp(arg, &quot;--help&quot;))
2866             printUsageStatement(true);
2867 
2868         if (!strcmp(arg, &quot;--options&quot;)) {
2869             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2870             needToExit = true;
2871             continue;
2872         }
2873         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2874             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2875             continue;
2876         }
2877         if (!strcmp(arg, &quot;--sample&quot;)) {
2878             JSC::Options::useSamplingProfiler() = true;
2879             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2880             m_dumpSamplingProfilerData = true;
2881             continue;
2882         }
2883         if (!strcmp(arg, &quot;--destroy-vm&quot;)) {
2884             m_destroyVM = true;
2885             continue;
2886         }
<a name="315" id="anc315"></a>



2887 
2888         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2889         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2890         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2891             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2892             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2893                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2894             continue;
2895         }
2896 
2897         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2898             asyncTestExpectedPasses++;
2899             continue;
2900         }
2901 
2902         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2903             m_enableRemoteDebugging = true;
2904             continue;
2905         }
2906 
2907         static const unsigned strictFileStrLength = strlen(&quot;--strict-file=&quot;);
2908         if (!strncmp(arg, &quot;--strict-file=&quot;, strictFileStrLength)) {
2909             m_scripts.append(Script(Script::StrictMode::Strict, Script::CodeSource::File, Script::ScriptType::Script, argv[i] + strictFileStrLength));
2910             continue;
2911         }
2912 
2913         static const unsigned moduleFileStrLength = strlen(&quot;--module-file=&quot;);
2914         if (!strncmp(arg, &quot;--module-file=&quot;, moduleFileStrLength)) {
2915             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Module, argv[i] + moduleFileStrLength));
2916             continue;
2917         }
2918 
2919         if (!strcmp(arg, &quot;--dumpException&quot;)) {
2920             m_alwaysDumpUncaughtException = true;
2921             continue;
2922         }
2923 
2924         if (!strcmp(arg, &quot;--footprint&quot;)) {
2925             m_dumpMemoryFootprint = true;
2926             continue;
2927         }
2928 
2929         static const unsigned exceptionStrLength = strlen(&quot;--exception=&quot;);
2930         if (!strncmp(arg, &quot;--exception=&quot;, exceptionStrLength)) {
2931             m_uncaughtExceptionName = String(arg + exceptionStrLength);
2932             continue;
2933         }
2934 
2935         if (!strcmp(arg, &quot;--watchdog-exception-ok&quot;)) {
2936             m_treatWatchdogExceptionAsSuccess = true;
2937             continue;
2938         }
2939 
2940         // See if the -- option is a JSC VM option.
2941         if (strstr(arg, &quot;--&quot;) == arg) {
2942             if (!JSC::Options::setOption(&amp;arg[2])) {
2943                 hasBadJSCOptions = true;
2944                 dataLog(&quot;ERROR: invalid option: &quot;, arg, &quot;\n&quot;);
2945             }
2946             continue;
2947         }
2948 
2949         // This arg is not recognized by the VM nor by jsc. Pass it on to the
2950         // script.
2951         Script::ScriptType scriptType = isMJSFile(argv[i]) ? Script::ScriptType::Module : Script::ScriptType::Script;
2952         m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, scriptType, argv[i]));
2953     }
2954 
2955     if (hasBadJSCOptions &amp;&amp; JSC::Options::validateOptions())
2956         CRASH();
2957 
2958     if (m_scripts.isEmpty())
2959         m_interactive = true;
2960 
2961     for (; i &lt; argc; ++i)
2962         m_arguments.append(argv[i]);
2963 
2964     if (dumpOptionsLevel != JSC::Options::DumpLevel::None) {
2965         const char* optionsTitle = (dumpOptionsLevel == JSC::Options::DumpLevel::Overridden)
2966             ? &quot;Modified JSC runtime options:&quot;
2967             : &quot;All JSC runtime options:&quot;;
2968         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
2969     }
2970     JSC::Options::ensureOptionsAreCoherent();
2971     if (needToExit)
2972         jscExit(EXIT_SUCCESS);
2973 }
2974 
2975 template&lt;typename Func&gt;
2976 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
2977 {
2978     Worker worker(Workers::singleton());
2979 
2980     VM&amp; vm = VM::create(LargeHeap).leakRef();
2981     int result;
2982     bool success = true;
2983     GlobalObject* globalObject = nullptr;
2984     {
2985         JSLockHolder locker(vm);
2986 
<a name="316" id="anc316"></a>
2987         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
2988             vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);
2989 
2990         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
2991         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
2992         func(vm, globalObject, success);
2993         vm.drainMicrotasks();
2994     }
<a name="317" id="anc317"></a><span class="line-modified">2995     vm.promiseDeferredTimer-&gt;runRunLoop();</span>
2996     {
2997         JSLockHolder locker(vm);
2998         if (options.m_interactive &amp;&amp; success)
2999             runInteractive(globalObject);
3000     }
3001 
3002     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
3003 
3004     if (options.m_exitCode) {
3005         printf(&quot;jsc exiting %d&quot;, result);
3006         if (asyncTestExpectedPasses != asyncTestPasses)
3007             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
3008         printf(&quot;\n&quot;);
3009     }
3010 
3011     if (options.m_profile) {
3012         JSLockHolder locker(vm);
3013         if (!vm.m_perBytecodeProfiler-&gt;save(options.m_profilerOutput.utf8().data()))
3014             fprintf(stderr, &quot;could not save profiler output.\n&quot;);
3015     }
3016 
3017 #if ENABLE(JIT)
3018     {
3019         JSLockHolder locker(vm);
3020         if (Options::useExceptionFuzz())
3021             printf(&quot;JSC EXCEPTION FUZZ: encountered %u checks.\n&quot;, numberOfExceptionFuzzChecks());
3022         bool fireAtEnabled =
3023         Options::fireExecutableAllocationFuzzAt() || Options::fireExecutableAllocationFuzzAtOrAfter();
3024         if (Options::useExecutableAllocationFuzz() &amp;&amp; (!fireAtEnabled || Options::verboseExecutableAllocationFuzz()))
3025             printf(&quot;JSC EXECUTABLE ALLOCATION FUZZ: encountered %u checks.\n&quot;, numberOfExecutableAllocationFuzzChecks());
3026         if (Options::useOSRExitFuzz()) {
3027             printf(&quot;JSC OSR EXIT FUZZ: encountered %u static checks.\n&quot;, numberOfStaticOSRExitFuzzChecks());
3028             printf(&quot;JSC OSR EXIT FUZZ: encountered %u dynamic checks.\n&quot;, numberOfOSRExitFuzzChecks());
3029         }
3030 
3031 
3032         auto compileTimeStats = JIT::compileTimeStats();
3033         Vector&lt;CString&gt; compileTimeKeys;
3034         for (auto&amp; entry : compileTimeStats)
3035             compileTimeKeys.append(entry.key);
3036         std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
3037         for (const CString&amp; key : compileTimeKeys)
3038             printf(&quot;%40s: %.3lf ms\n&quot;, key.data(), compileTimeStats.get(key).milliseconds());
<a name="318" id="anc318"></a>


3039     }
3040 #endif
3041 
3042     if (Options::gcAtEnd()) {
3043         // We need to hold the API lock to do a GC.
3044         JSLockHolder locker(&amp;vm);
3045         vm.heap.collectNow(Sync, CollectionScope::Full);
3046     }
3047 
3048     if (options.m_dumpSamplingProfilerData) {
3049 #if ENABLE(SAMPLING_PROFILER)
3050         JSLockHolder locker(&amp;vm);
3051         vm.samplingProfiler()-&gt;reportTopFunctions();
3052         vm.samplingProfiler()-&gt;reportTopBytecodes();
3053 #else
3054         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
3055 #endif
3056     }
3057 
3058     vm.codeCache()-&gt;write(vm);
3059 
3060     if (options.m_destroyVM || isWorker) {
3061         JSLockHolder locker(vm);
3062         // This is needed because we don&#39;t want the worker&#39;s main
3063         // thread to die before its compilation threads finish.
3064         vm.deref();
3065     }
3066 
3067     return result;
3068 }
3069 
3070 int jscmain(int argc, char** argv)
3071 {
3072     // Need to override and enable restricted options before we start parsing options below.
<a name="319" id="anc319"></a><span class="line-modified">3073     Options::enableRestrictedOptions(true);</span>
3074 
3075     WTF::initializeMainThread();
3076 
3077     // Note that the options parsing can affect VM creation, and thus
3078     // comes first.
3079     CommandLine options(argc, argv);
3080 
3081     processConfigFile(Options::configFile(), &quot;jsc&quot;);
<a name="320" id="anc320"></a>

3082 
3083     // Initialize JSC before getting VM.
3084     JSC::initializeThreading();
<a name="321" id="anc321"></a><span class="line-modified">3085     startTimeoutThreadIfNeeded();</span>
3086 #if ENABLE(WEBASSEMBLY)
3087     JSC::Wasm::enableFastMemory();
3088 #endif
<a name="322" id="anc322"></a><span class="line-modified">3089     Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();</span>









3090 
3091 #if PLATFORM(COCOA)
3092     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3093     {
3094         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3095         memoryPressureHandler.setDispatchQueue(queue);
3096         dispatch_release(queue);
3097     }
3098     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3099     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3100     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3101         // We set these racily with respect to reading them from the JS execution thread.
3102         *memoryPressureCriticalState = critical;
3103         *memoryPressureSynchronousState = synchronous;
3104     });
3105     memoryPressureHandler.setShouldLogMemoryMemoryPressureEvents(false);
3106     memoryPressureHandler.install();
3107 
3108     auto onEachMicrotaskTick = [&amp;] (VM&amp; vm) {
3109         if (*memoryPressureCriticalState == Critical::No)
3110             return;
3111 
3112         *memoryPressureCriticalState = Critical::No;
3113         bool isSynchronous = *memoryPressureSynchronousState == Synchronous::Yes;
3114 
3115         WTF::releaseFastMallocFreeMemory();
3116         vm.deleteAllCode(DeleteAllCodeIfNotCollecting);
3117 
3118         if (!vm.heap.isCurrentThreadBusy()) {
3119             if (isSynchronous) {
3120                 vm.heap.collectNow(Sync, CollectionScope::Full);
3121                 WTF::releaseFastMallocFreeMemory();
3122             } else
3123                 vm.heap.collectNowFullIfNotDoneRecently(Async);
3124         }
3125     };
3126 #endif
3127 
3128     int result = runJSC(
3129         options, false,
3130         [&amp;] (VM&amp; vm, GlobalObject* globalObject, bool&amp; success) {
3131             UNUSED_PARAM(vm);
3132 #if PLATFORM(COCOA)
3133             vm.setOnEachMicrotaskTick(WTFMove(onEachMicrotaskTick));
3134 #endif
3135             runWithOptions(globalObject, options, success);
3136         });
3137 
3138     printSuperSamplerState();
3139 
3140     if (options.m_dumpMemoryFootprint) {
3141         MemoryFootprint footprint = MemoryFootprint::now();
3142 
3143         printf(&quot;Memory Footprint:\n    Current Footprint: %&quot; PRIu64 &quot;\n    Peak Footprint: %&quot; PRIu64 &quot;\n&quot;, footprint.current, footprint.peak);
3144     }
3145 
3146     return result;
3147 }
3148 
3149 #if OS(WINDOWS)
3150 extern &quot;C&quot; __declspec(dllexport) int WINAPI dllLauncherEntryPoint(int argc, const char* argv[])
3151 {
3152     return main(argc, const_cast&lt;char**&gt;(argv));
3153 }
3154 #endif
<a name="323" id="anc323"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="323" type="hidden" />
</body>
</html>
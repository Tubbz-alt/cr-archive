<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RotateTransformOperation.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../wayland/PlatformDisplayWayland.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,10 +36,14 @@</span>
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
<span class="udiff-line-added">+ #if PLATFORM(JAVA)</span>
<span class="udiff-line-added">+ #include &lt;wtf/java/JavaMath.h&gt;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #if CPU(X86_64)
  #include &lt;emmintrin.h&gt;
  #endif
  
  namespace WebCore {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -252,11 +256,15 @@</span>
                  (p[2] * m[2][3]) + (p[3] * m[3][3]);
  }
  
  static double v3Length(Vector3 a)
  {
<span class="udiff-line-modified-removed">-     return sqrt((a[0] * a[0]) + (a[1] * a[1]) + (a[2] * a[2]));</span>
<span class="udiff-line-modified-added">+ #if PLATFORM(JAVA)</span>
<span class="udiff-line-added">+     return javamath::hypot(a[0], a[1], a[2]);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     return std::hypot(a[0], a[1], a[2]);</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  static void v3Scale(Vector3 v, double desiredLength)
  {
      double len = v3Length(v);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,12 +306,12 @@</span>
      double row1y = matrix[1][1];
      result.translateX = matrix[3][0];
      result.translateY = matrix[3][1];
  
      // Compute scaling factors.
<span class="udiff-line-modified-removed">-     result.scaleX = sqrt(row0x * row0x + row0y * row0y);</span>
<span class="udiff-line-modified-removed">-     result.scaleY = sqrt(row1x * row1x + row1y * row1y);</span>
<span class="udiff-line-modified-added">+     result.scaleX = std::hypot(row0x, row0y);</span>
<span class="udiff-line-modified-added">+     result.scaleY = std::hypot(row1x, row1y);</span>
  
      // If determinant is negative, one axis was flipped.
      double determinant = row0x * row1y - row0y * row1x;
      if (determinant &lt; 0) {
          // Flip axis with minimum unit vector dot product.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -811,11 +819,15 @@</span>
  }
  
  TransformationMatrix&amp; TransformationMatrix::rotate3d(double x, double y, double z, double angle)
  {
      // Normalize the axis of rotation
<span class="udiff-line-modified-removed">-     double length = sqrt(x * x + y * y + z * z);</span>
<span class="udiff-line-modified-added">+ #if PLATFORM(JAVA)</span>
<span class="udiff-line-added">+     double length = javamath::hypot(x, y, z);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     double length = std::hypot(x, y, z);</span>
<span class="udiff-line-added">+ #endif</span>
      if (length == 0) {
          // A direction vector that cannot be normalized, such as [0, 0, 0], will cause the rotation to not be applied.
          return *this;
      } else if (length != 1) {
          x /= length;
</pre>
<center><a href="RotateTransformOperation.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../wayland/PlatformDisplayWayland.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
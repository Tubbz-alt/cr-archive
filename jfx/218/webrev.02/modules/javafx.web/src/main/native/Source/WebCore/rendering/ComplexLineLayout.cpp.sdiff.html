<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFilter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComplexLineLayout.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  41 #include &quot;RenderFragmentedFlow.h&quot;
  42 #include &quot;RenderLayoutState.h&quot;
  43 #include &quot;RenderLineBreak.h&quot;
  44 #include &quot;RenderRubyBase.h&quot;
  45 #include &quot;RenderRubyText.h&quot;
  46 #include &quot;RenderSVGText.h&quot;
  47 #include &quot;RenderView.h&quot;
  48 #include &quot;SVGRootInlineBox.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;TrailingFloatsRootInlineBox.h&quot;
  51 #include &quot;VerticalPositionCache.h&quot;
  52 #include &lt;wtf/StdLibExtras.h&gt;
  53 
  54 namespace WebCore {
  55 
  56 ComplexLineLayout::ComplexLineLayout(RenderBlockFlow&amp; flow)
  57     : m_flow(flow)
  58 {
  59 }
  60 
<span class="line-modified">  61 ComplexLineLayout::~ComplexLineLayout() = default;</span>






  62 
  63 static void determineDirectionality(TextDirection&amp; dir, InlineIterator iter)
  64 {
  65     while (!iter.atEnd()) {
  66         if (iter.atParagraphSeparator())
  67             return;
  68         if (UChar current = iter.current()) {
  69             UCharDirection charDirection = u_charDirection(current);
  70             if (charDirection == U_LEFT_TO_RIGHT) {
  71                 dir = TextDirection::LTR;
  72                 return;
  73             }
  74             if (charDirection == U_RIGHT_TO_LEFT || charDirection == U_RIGHT_TO_LEFT_ARABIC) {
  75                 dir = TextDirection::RTL;
  76                 return;
  77             }
  78         }
  79         iter.increment();
  80     }
  81 }
</pre>
<hr />
<pre>
 553         glyphOverflow.extendTo(visualOverflowForDecorations(run-&gt;box()-&gt;lineStyle(), downcast&lt;InlineTextBox&gt;(run-&gt;box())));
 554 
 555     if (!glyphOverflow.isEmpty()) {
 556         ASSERT(run-&gt;box()-&gt;behavesLikeText());
 557         GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.add(downcast&lt;InlineTextBox&gt;(run-&gt;box()), std::make_pair(Vector&lt;const Font*&gt;(), GlyphOverflow())).iterator;
 558         it-&gt;value.second = glyphOverflow;
 559         run-&gt;box()-&gt;clearKnownToHaveNoOverflow();
 560     }
 561 }
 562 
 563 void ComplexLineLayout::updateRubyForJustifiedText(RenderRubyRun&amp; rubyRun, BidiRun&amp; r, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned&amp; expansionOpportunityCount, float&amp; totalLogicalWidth, float availableLogicalWidth, size_t&amp; i)
 564 {
 565     if (!rubyRun.rubyBase() || !rubyRun.rubyBase()-&gt;firstRootBox() || rubyRun.rubyBase()-&gt;firstRootBox()-&gt;nextRootBox() || !r.renderer().style().collapseWhiteSpace())
 566         return;
 567 
 568     auto&amp; rubyBase = *rubyRun.rubyBase();
 569     auto&amp; rootBox = *rubyBase.firstRootBox();
 570 
 571     float totalExpansion = 0;
 572     unsigned totalOpportunitiesInRun = 0;
<span class="line-modified"> 573     for (auto* leafChild = rootBox.firstLeafChild(); leafChild; leafChild = leafChild-&gt;nextLeafChild()) {</span>
 574         if (!leafChild-&gt;isInlineTextBox())
 575             continue;
 576 
 577         unsigned opportunitiesInRun = expansionOpportunities[i++];
 578         ASSERT(opportunitiesInRun &lt;= expansionOpportunityCount);
 579         auto expansion = (availableLogicalWidth - totalLogicalWidth) * opportunitiesInRun / expansionOpportunityCount;
 580         totalExpansion += expansion;
 581         totalOpportunitiesInRun += opportunitiesInRun;
 582     }
 583 
 584     ASSERT(!rubyRun.hasOverrideContentLogicalWidth());
 585     float newBaseWidth = rubyRun.logicalWidth() + totalExpansion + m_flow.marginStartForChild(rubyRun) + m_flow.marginEndForChild(rubyRun);
 586     float newRubyRunWidth = rubyRun.logicalWidth() + totalExpansion;
 587     rubyBase.setInitialOffset((newRubyRunWidth - newBaseWidth) / 2);
 588     rubyRun.setOverrideContentLogicalWidth(LayoutUnit(newRubyRunWidth));
 589     rubyRun.setNeedsLayout(MarkOnlyThis);
 590     rootBox.markDirty();
 591     if (RenderRubyText* rubyText = rubyRun.rubyText()) {
 592         if (RootInlineBox* textRootBox = rubyText-&gt;firstRootBox())
 593             textRootBox-&gt;markDirty();
</pre>
<hr />
<pre>
 718     // The widths of all runs are now known. We can now place every inline box (and
 719     // compute accurate widths for the inline flow boxes).
 720     needsWordSpacing = false;
 721     lineBox-&gt;placeBoxesInInlineDirection(lineLogicalLeft, needsWordSpacing);
 722 }
 723 
 724 static inline ExpansionBehavior expansionBehaviorForInlineTextBox(RenderBlockFlow&amp; block, InlineTextBox&amp; textBox, BidiRun* previousRun, BidiRun* nextRun, TextAlignMode textAlign, bool isAfterExpansion)
 725 {
 726     // Tatechuyoko is modeled as the Object Replacement Character (U+FFFC), which can never have expansion opportunities inside nor intrinsically adjacent to it.
 727     if (textBox.renderer().style().textCombine() == TextCombine::Horizontal)
 728         return ForbidLeadingExpansion | ForbidTrailingExpansion;
 729 
 730     ExpansionBehavior result = 0;
 731     bool setLeadingExpansion = false;
 732     bool setTrailingExpansion = false;
 733     if (textAlign == TextAlignMode::Justify) {
 734         // If the next box is ruby, and we&#39;re justifying, and the first box in the ruby base has a leading expansion, and we are a text box, then force a trailing expansion.
 735         if (nextRun &amp;&amp; is&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase() &amp;&amp; nextRun-&gt;renderer().style().collapseWhiteSpace()) {
 736             auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase();
 737             if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified"> 738                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;firstLeafChild()) {</span>
 739                     if (is&lt;InlineTextBox&gt;(*leafChild)) {
 740                         // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
 741                         if (FontCascade::leadingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
 742                             setTrailingExpansion = true;
 743                             result |= ForceTrailingExpansion;
 744                         }
 745                     }
 746                 }
 747             }
 748         }
 749         // Same thing, except if we&#39;re following a ruby
 750         if (previousRun &amp;&amp; is&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase() &amp;&amp; previousRun-&gt;renderer().style().collapseWhiteSpace()) {
 751             auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase();
 752             if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified"> 753                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;lastLeafChild()) {</span>
 754                     if (is&lt;InlineTextBox&gt;(*leafChild)) {
 755                         // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
 756                         if (FontCascade::trailingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
 757                             setLeadingExpansion = true;
 758                             result |= ForceLeadingExpansion;
 759                         }
 760                     }
 761                 }
 762             }
 763         }
 764         // If we&#39;re the first box inside a ruby base, forbid a leading expansion, and vice-versa
 765         if (is&lt;RenderRubyBase&gt;(block)) {
 766             RenderRubyBase&amp; rubyBase = downcast&lt;RenderRubyBase&gt;(block);
<span class="line-modified"> 767             if (&amp;textBox == rubyBase.firstRootBox()-&gt;firstLeafChild()) {</span>
 768                 setLeadingExpansion = true;
 769                 result |= ForbidLeadingExpansion;
<span class="line-modified"> 770             } if (&amp;textBox == rubyBase.firstRootBox()-&gt;lastLeafChild()) {</span>
 771                 setTrailingExpansion = true;
 772                 result |= ForbidTrailingExpansion;
 773             }
 774         }
 775     }
 776     if (!setLeadingExpansion)
 777         result |= isAfterExpansion ? ForbidLeadingExpansion : AllowLeadingExpansion;
 778     if (!setTrailingExpansion)
 779         result |= AllowTrailingExpansion;
 780     return result;
 781 }
 782 
 783 static inline void applyExpansionBehavior(InlineTextBox&amp; textBox, ExpansionBehavior expansionBehavior)
 784 {
 785     switch (expansionBehavior &amp; LeadingExpansionMask) {
 786     case ForceLeadingExpansion:
 787         textBox.setForceLeadingExpansion();
 788         break;
 789     case ForbidLeadingExpansion:
 790         textBox.setCanHaveLeadingExpansion(false);
</pre>
<hr />
<pre>
 903 
 904             if (textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun)
 905                 computeExpansionOpportunities(m_flow, textBox, previousRun, run-&gt;next(), renderText.stringView(run-&gt;m_start, run-&gt;m_stop), run-&gt;box()-&gt;direction());
 906 
 907             if (unsigned length = renderText.text().length()) {
 908                 if (!run-&gt;m_start &amp;&amp; needsWordSpacing &amp;&amp; isSpaceOrNewline(renderText.characterAt(run-&gt;m_start)))
 909                     totalLogicalWidth += lineStyle(*renderText.parent(), lineInfo).fontCascade().wordSpacing();
 910                 // run-&gt;m_start == run-&gt;m_stop should only be true iff the run is a replaced run for bidi: isolate.
 911                 ASSERT(run-&gt;m_stop &gt; 0 || run-&gt;m_start == run-&gt;m_stop);
 912                 needsWordSpacing = run-&gt;m_stop == length &amp;&amp; !isSpaceOrNewline(renderText.characterAt(run-&gt;m_stop - 1));
 913             }
 914 
 915             setLogicalWidthForTextRun(lineBox, run, renderText, totalLogicalWidth, lineInfo, textBoxDataMap, verticalPositionCache, wordMeasurements);
 916         } else {
 917             canHangPunctuationAtStart = false;
 918             bool encounteredJustifiedRuby = false;
 919             if (is&lt;RenderRubyRun&gt;(run-&gt;renderer()) &amp;&amp; textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun &amp;&amp; downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase()) {
 920                 auto* rubyBase = downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase();
 921                 if (rubyBase-&gt;firstRootBox() &amp;&amp; !rubyBase-&gt;firstRootBox()-&gt;nextRootBox() &amp;&amp; run-&gt;renderer().style().collapseWhiteSpace()) {
 922                     rubyBase-&gt;setIsAfterExpansion(isAfterExpansion);
<span class="line-modified"> 923                     for (auto* leafChild = rubyBase-&gt;firstRootBox()-&gt;firstLeafChild(); leafChild; leafChild = leafChild-&gt;nextLeafChild()) {</span>
 924                         if (!is&lt;InlineTextBox&gt;(*leafChild))
 925                             continue;
 926                         encounteredJustifiedRuby = true;
 927                         computeExpansionOpportunities(*rubyBase, downcast&lt;InlineTextBox&gt;(*leafChild), nullptr, nullptr,
 928                             downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction());
 929                     }
 930                 }
 931             }
 932 
 933             if (!encounteredJustifiedRuby)
 934                 isAfterExpansion = false;
 935 
 936             if (!is&lt;RenderInline&gt;(run-&gt;renderer())) {
 937                 auto&amp; renderBox = downcast&lt;RenderBox&gt;(run-&gt;renderer());
 938                 if (is&lt;RenderRubyRun&gt;(renderBox))
 939                     setMarginsForRubyRun(run, downcast&lt;RenderRubyRun&gt;(renderBox), previousRun ? &amp;previousRun-&gt;renderer() : nullptr, lineInfo);
 940                 run-&gt;box()-&gt;setLogicalWidth(m_flow.logicalWidthForChild(renderBox));
 941                 totalLogicalWidth += m_flow.marginStartForChild(renderBox) + m_flow.marginEndForChild(renderBox);
 942             }
 943         }
</pre>
<hr />
<pre>
 954         if (lastValidExpansionOpportunitiesIndex &gt;= 0) {
 955             ASSERT(expansionOpportunities.at(lastValidExpansionOpportunitiesIndex));
 956             expansionOpportunities.at(lastValidExpansionOpportunitiesIndex)--;
 957             expansionOpportunityCount--;
 958         }
 959     }
 960 
 961     if (is&lt;RenderRubyBase&gt;(m_flow) &amp;&amp; !expansionOpportunityCount)
 962         textAlign = TextAlignMode::Center;
 963 
 964     updateLogicalWidthForAlignment(m_flow, textAlign, lineBox, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth, expansionOpportunityCount);
 965 
 966     computeExpansionForJustifiedText(firstRun, trailingSpaceRun, expansionOpportunities, expansionOpportunityCount, totalLogicalWidth, availableLogicalWidth);
 967 
 968     return run;
 969 }
 970 
 971 void ComplexLineLayout::removeInlineBox(BidiRun&amp; run, const RootInlineBox&amp; rootLineBox) const
 972 {
 973     auto* inlineBox = run.box();
<span class="line-modified"> 974 #if !ASSERT_DISABLED</span>
 975     auto* inlineParent = inlineBox-&gt;parent();
 976     while (inlineParent &amp;&amp; inlineParent != &amp;rootLineBox) {
 977         ASSERT(!inlineParent-&gt;isDirty());
 978         inlineParent = inlineParent-&gt;parent();
 979     }
 980     ASSERT(!rootLineBox.isDirty());
 981 #endif
 982     auto* parent = inlineBox-&gt;parent();
 983     inlineBox-&gt;removeFromParent();
 984 
 985     auto&amp; renderer = run.renderer();
 986     if (is&lt;RenderText&gt;(renderer))
 987         downcast&lt;RenderText&gt;(renderer).removeTextBox(downcast&lt;InlineTextBox&gt;(*inlineBox));
 988     delete inlineBox;
 989     run.setBox(nullptr);
 990     // removeFromParent() unnecessarily dirties the ancestor subtree.
 991     auto* ancestor = parent;
 992     while (ancestor) {
 993         ancestor-&gt;markDirty(false);
 994         if (ancestor == &amp;rootLineBox)
</pre>
<hr />
<pre>
1300     if (m_flow.containsFloats())
1301         layoutState.floatList().setLastFloat(m_flow.floatingObjects()-&gt;set().last().get());
1302 
1303     // We also find the first clean line and extract these lines. We will add them back
1304     // if we determine that we&#39;re able to synchronize after handling all our dirty lines.
1305     InlineIterator cleanLineStart;
1306     BidiStatus cleanLineBidiStatus;
1307     if (!layoutState.isFullLayout() &amp;&amp; startLine)
1308         determineEndPosition(layoutState, startLine, cleanLineStart, cleanLineBidiStatus);
1309 
1310     if (startLine) {
1311         if (!layoutState.usesRepaintBounds())
1312             layoutState.setRepaintRange(m_flow.logicalHeight());
1313         deleteLineRange(layoutState, startLine);
1314     }
1315 
1316     if (!layoutState.isFullLayout() &amp;&amp; lastRootBox() &amp;&amp; lastRootBox()-&gt;endsWithBreak()) {
1317         // If the last line before the start line ends with a line break that clear floats,
1318         // adjust the height accordingly.
1319         // A line break can be either the first or the last object on a line, depending on its direction.
<span class="line-modified">1320         if (InlineBox* lastLeafChild = lastRootBox()-&gt;lastLeafChild()) {</span>
<span class="line-modified">1321             RenderObject* lastObject = &amp;lastLeafChild-&gt;renderer();</span>
1322             if (!lastObject-&gt;isBR())
<span class="line-modified">1323                 lastObject = &amp;lastRootBox()-&gt;firstLeafChild()-&gt;renderer();</span>
1324             if (lastObject-&gt;isBR()) {
1325                 Clear clear = lastObject-&gt;style().clear();
1326                 if (clear != Clear::None)
1327                     m_flow.clearFloats(clear);
1328             }
1329         }
1330     }
1331 
1332     layoutRunsAndFloatsInRange(layoutState, resolver, cleanLineStart, cleanLineBidiStatus, consecutiveHyphenatedLines);
1333     linkToEndLineIfNeeded(layoutState);
1334     repaintDirtyFloats(layoutState.floatList());
1335 }
1336 
1337 // Before restarting the layout loop with a new logicalHeight, remove all floats that were added and reset the resolver.
1338 inline const InlineIterator&amp; ComplexLineLayout::restartLayoutRunsAndFloatsInRange(LayoutUnit oldLogicalHeight, LayoutUnit newLogicalHeight,  FloatingObject* lastFloatFromPreviousLine, InlineBidiResolver&amp; resolver,  const InlineIterator&amp; oldEnd)
1339 {
1340     m_flow.removeFloatingObjectsBelow(lastFloatFromPreviousLine, oldLogicalHeight);
1341     m_flow.setLogicalHeight(newLogicalHeight);
1342     resolver.setPositionIgnoringNestedIsolates(oldEnd);
1343     return oldEnd;
</pre>
<hr />
<pre>
1533                 lineBox = lineBox-&gt;prevRootBox();
1534             }
1535 
1536             // If there was an explicit value for orphans, respect that. If not, we still
1537             // shouldn&#39;t create a situation where we make an orphan bigger than the initial value.
1538             // This means that setting widows implies we also care about orphans, but given
1539             // the specification says the initial orphan value is non-zero, this is ok. The
1540             // author is always free to set orphans explicitly as well.
1541             int orphans = style().hasAutoOrphans() ? style().initialOrphans() : style().orphans();
1542             int numLinesAvailable = numLinesInPreviousPage - orphans;
1543             if (numLinesAvailable &lt;= 0)
1544                 return;
1545 
1546             int numLinesToTake = std::min(numLinesAvailable, numLinesNeeded);
1547             // Wind back from our first widowed line.
1548             lineBox = currentFirstLineOfNewPage;
1549             for (int i = 0; i &lt; numLinesToTake; ++i)
1550                 lineBox = lineBox-&gt;prevRootBox();
1551 
1552             // We now want to break at this line. Remember for next layout and trigger relayout.
<span class="line-modified">1553             m_flow.setBreakAtLineToAvoidWidow(m_flow.lineCount(lineBox));</span>
1554             m_flow.markLinesDirtyInBlockRange(lastRootBox()-&gt;lineBottomWithLeading(), lineBox-&gt;lineBottomWithLeading(), lineBox);
1555         }
1556     }
1557     m_flow.clearDidBreakAtLineToAvoidWidow();
1558 }
1559 
1560 void ComplexLineLayout::reattachCleanLineFloats(RootInlineBox&amp; cleanLine, LayoutUnit delta, bool isFirstCleanLine)
1561 {
1562     auto* cleanLineFloats = cleanLine.floatsPtr();
1563     if (!cleanLineFloats)
1564         return;
1565 
1566     for (auto&amp; floatingBox : *cleanLineFloats) {
1567         if (!floatingBox)
1568             continue;
1569         auto* floatingObject = m_flow.insertFloatingObject(*floatingBox);
1570         if (isFirstCleanLine &amp;&amp; floatingObject-&gt;originatingLine()) {
1571             // Float box does not belong to this line anymore.
1572             ASSERT_WITH_SECURITY_IMPLICATION(cleanLine.prevRootBox() == floatingObject-&gt;originatingLine());
1573             cleanLine.removeFloat(*floatingBox);
</pre>
<hr />
<pre>
2085     ASSERT(!m_flow.simpleLineLayout());
2086 
2087     LayoutUnit endPadding = m_flow.hasOverflowClip() ? m_flow.paddingEnd() : 0_lu;
2088     // FIXME: Need to find another way to do this, since scrollbars could show when we don&#39;t want them to.
2089     if (m_flow.hasOverflowClip() &amp;&amp; !endPadding &amp;&amp; m_flow.element() &amp;&amp; m_flow.element()-&gt;isRootEditableElement() &amp;&amp; style().isLeftToRightDirection())
2090         endPadding = 1;
2091     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
2092         m_flow.addLayoutOverflow(curr-&gt;paddedLayoutOverflowRect(endPadding));
2093         RenderFragmentContainer* fragment = m_flow.enclosingFragmentedFlow() ? curr-&gt;containingFragment() : nullptr;
2094         if (fragment)
2095             fragment-&gt;addLayoutOverflowForBox(&amp;m_flow, curr-&gt;paddedLayoutOverflowRect(endPadding));
2096         if (!m_flow.hasOverflowClip()) {
2097             LayoutRect childVisualOverflowRect = curr-&gt;visualOverflowRect(curr-&gt;lineTop(), curr-&gt;lineBottom());
2098             m_flow.addVisualOverflow(childVisualOverflowRect);
2099             if (fragment)
2100                 fragment-&gt;addVisualOverflowForBox(&amp;m_flow, childVisualOverflowRect);
2101         }
2102     }
2103 }
2104 





















2105 void ComplexLineLayout::deleteEllipsisLineBoxes()
2106 {
2107     TextAlignMode textAlign = style().textAlign();
2108     bool ltr = style().isLeftToRightDirection();
2109     IndentTextOrNot shouldIndentText = IndentText;
2110     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
2111         if (curr-&gt;hasEllipsisBox()) {
2112             curr-&gt;clearTruncation();
2113 
2114             // Shift the line back where it belongs if we cannot accomodate an ellipsis.
2115             float logicalLeft = m_flow.logicalLeftOffsetForLine(curr-&gt;lineTop(), shouldIndentText);
2116             float availableLogicalWidth = m_flow.logicalRightOffsetForLine(curr-&gt;lineTop(), DoNotIndentText) - logicalLeft;
2117             float totalLogicalWidth = curr-&gt;logicalWidth();
2118             updateLogicalWidthForAlignment(m_flow, textAlign, curr, 0, logicalLeft, totalLogicalWidth, availableLogicalWidth, 0);
2119 
2120             if (ltr)
2121                 curr-&gt;adjustLogicalPosition((logicalLeft - curr-&gt;logicalLeft()), 0);
2122             else
2123                 curr-&gt;adjustLogicalPosition(-(curr-&gt;logicalLeft() - logicalLeft), 0);
2124         }
</pre>
</td>
<td>
<hr />
<pre>
  41 #include &quot;RenderFragmentedFlow.h&quot;
  42 #include &quot;RenderLayoutState.h&quot;
  43 #include &quot;RenderLineBreak.h&quot;
  44 #include &quot;RenderRubyBase.h&quot;
  45 #include &quot;RenderRubyText.h&quot;
  46 #include &quot;RenderSVGText.h&quot;
  47 #include &quot;RenderView.h&quot;
  48 #include &quot;SVGRootInlineBox.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;TrailingFloatsRootInlineBox.h&quot;
  51 #include &quot;VerticalPositionCache.h&quot;
  52 #include &lt;wtf/StdLibExtras.h&gt;
  53 
  54 namespace WebCore {
  55 
  56 ComplexLineLayout::ComplexLineLayout(RenderBlockFlow&amp; flow)
  57     : m_flow(flow)
  58 {
  59 }
  60 
<span class="line-modified">  61 ComplexLineLayout::~ComplexLineLayout()</span>
<span class="line-added">  62 {</span>
<span class="line-added">  63     if (m_flow.containsFloats())</span>
<span class="line-added">  64         m_flow.floatingObjects()-&gt;clearLineBoxTreePointers();</span>
<span class="line-added">  65 </span>
<span class="line-added">  66     lineBoxes().deleteLineBoxTree();</span>
<span class="line-added">  67 };</span>
  68 
  69 static void determineDirectionality(TextDirection&amp; dir, InlineIterator iter)
  70 {
  71     while (!iter.atEnd()) {
  72         if (iter.atParagraphSeparator())
  73             return;
  74         if (UChar current = iter.current()) {
  75             UCharDirection charDirection = u_charDirection(current);
  76             if (charDirection == U_LEFT_TO_RIGHT) {
  77                 dir = TextDirection::LTR;
  78                 return;
  79             }
  80             if (charDirection == U_RIGHT_TO_LEFT || charDirection == U_RIGHT_TO_LEFT_ARABIC) {
  81                 dir = TextDirection::RTL;
  82                 return;
  83             }
  84         }
  85         iter.increment();
  86     }
  87 }
</pre>
<hr />
<pre>
 559         glyphOverflow.extendTo(visualOverflowForDecorations(run-&gt;box()-&gt;lineStyle(), downcast&lt;InlineTextBox&gt;(run-&gt;box())));
 560 
 561     if (!glyphOverflow.isEmpty()) {
 562         ASSERT(run-&gt;box()-&gt;behavesLikeText());
 563         GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.add(downcast&lt;InlineTextBox&gt;(run-&gt;box()), std::make_pair(Vector&lt;const Font*&gt;(), GlyphOverflow())).iterator;
 564         it-&gt;value.second = glyphOverflow;
 565         run-&gt;box()-&gt;clearKnownToHaveNoOverflow();
 566     }
 567 }
 568 
 569 void ComplexLineLayout::updateRubyForJustifiedText(RenderRubyRun&amp; rubyRun, BidiRun&amp; r, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned&amp; expansionOpportunityCount, float&amp; totalLogicalWidth, float availableLogicalWidth, size_t&amp; i)
 570 {
 571     if (!rubyRun.rubyBase() || !rubyRun.rubyBase()-&gt;firstRootBox() || rubyRun.rubyBase()-&gt;firstRootBox()-&gt;nextRootBox() || !r.renderer().style().collapseWhiteSpace())
 572         return;
 573 
 574     auto&amp; rubyBase = *rubyRun.rubyBase();
 575     auto&amp; rootBox = *rubyBase.firstRootBox();
 576 
 577     float totalExpansion = 0;
 578     unsigned totalOpportunitiesInRun = 0;
<span class="line-modified"> 579     for (auto* leafChild = rootBox.firstLeafDescendant(); leafChild; leafChild = leafChild-&gt;nextLeafOnLine()) {</span>
 580         if (!leafChild-&gt;isInlineTextBox())
 581             continue;
 582 
 583         unsigned opportunitiesInRun = expansionOpportunities[i++];
 584         ASSERT(opportunitiesInRun &lt;= expansionOpportunityCount);
 585         auto expansion = (availableLogicalWidth - totalLogicalWidth) * opportunitiesInRun / expansionOpportunityCount;
 586         totalExpansion += expansion;
 587         totalOpportunitiesInRun += opportunitiesInRun;
 588     }
 589 
 590     ASSERT(!rubyRun.hasOverrideContentLogicalWidth());
 591     float newBaseWidth = rubyRun.logicalWidth() + totalExpansion + m_flow.marginStartForChild(rubyRun) + m_flow.marginEndForChild(rubyRun);
 592     float newRubyRunWidth = rubyRun.logicalWidth() + totalExpansion;
 593     rubyBase.setInitialOffset((newRubyRunWidth - newBaseWidth) / 2);
 594     rubyRun.setOverrideContentLogicalWidth(LayoutUnit(newRubyRunWidth));
 595     rubyRun.setNeedsLayout(MarkOnlyThis);
 596     rootBox.markDirty();
 597     if (RenderRubyText* rubyText = rubyRun.rubyText()) {
 598         if (RootInlineBox* textRootBox = rubyText-&gt;firstRootBox())
 599             textRootBox-&gt;markDirty();
</pre>
<hr />
<pre>
 724     // The widths of all runs are now known. We can now place every inline box (and
 725     // compute accurate widths for the inline flow boxes).
 726     needsWordSpacing = false;
 727     lineBox-&gt;placeBoxesInInlineDirection(lineLogicalLeft, needsWordSpacing);
 728 }
 729 
 730 static inline ExpansionBehavior expansionBehaviorForInlineTextBox(RenderBlockFlow&amp; block, InlineTextBox&amp; textBox, BidiRun* previousRun, BidiRun* nextRun, TextAlignMode textAlign, bool isAfterExpansion)
 731 {
 732     // Tatechuyoko is modeled as the Object Replacement Character (U+FFFC), which can never have expansion opportunities inside nor intrinsically adjacent to it.
 733     if (textBox.renderer().style().textCombine() == TextCombine::Horizontal)
 734         return ForbidLeadingExpansion | ForbidTrailingExpansion;
 735 
 736     ExpansionBehavior result = 0;
 737     bool setLeadingExpansion = false;
 738     bool setTrailingExpansion = false;
 739     if (textAlign == TextAlignMode::Justify) {
 740         // If the next box is ruby, and we&#39;re justifying, and the first box in the ruby base has a leading expansion, and we are a text box, then force a trailing expansion.
 741         if (nextRun &amp;&amp; is&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase() &amp;&amp; nextRun-&gt;renderer().style().collapseWhiteSpace()) {
 742             auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase();
 743             if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified"> 744                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;firstLeafDescendant()) {</span>
 745                     if (is&lt;InlineTextBox&gt;(*leafChild)) {
 746                         // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
 747                         if (FontCascade::leadingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
 748                             setTrailingExpansion = true;
 749                             result |= ForceTrailingExpansion;
 750                         }
 751                     }
 752                 }
 753             }
 754         }
 755         // Same thing, except if we&#39;re following a ruby
 756         if (previousRun &amp;&amp; is&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase() &amp;&amp; previousRun-&gt;renderer().style().collapseWhiteSpace()) {
 757             auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase();
 758             if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified"> 759                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;lastLeafDescendant()) {</span>
 760                     if (is&lt;InlineTextBox&gt;(*leafChild)) {
 761                         // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
 762                         if (FontCascade::trailingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
 763                             setLeadingExpansion = true;
 764                             result |= ForceLeadingExpansion;
 765                         }
 766                     }
 767                 }
 768             }
 769         }
 770         // If we&#39;re the first box inside a ruby base, forbid a leading expansion, and vice-versa
 771         if (is&lt;RenderRubyBase&gt;(block)) {
 772             RenderRubyBase&amp; rubyBase = downcast&lt;RenderRubyBase&gt;(block);
<span class="line-modified"> 773             if (&amp;textBox == rubyBase.firstRootBox()-&gt;firstLeafDescendant()) {</span>
 774                 setLeadingExpansion = true;
 775                 result |= ForbidLeadingExpansion;
<span class="line-modified"> 776             } if (&amp;textBox == rubyBase.firstRootBox()-&gt;lastLeafDescendant()) {</span>
 777                 setTrailingExpansion = true;
 778                 result |= ForbidTrailingExpansion;
 779             }
 780         }
 781     }
 782     if (!setLeadingExpansion)
 783         result |= isAfterExpansion ? ForbidLeadingExpansion : AllowLeadingExpansion;
 784     if (!setTrailingExpansion)
 785         result |= AllowTrailingExpansion;
 786     return result;
 787 }
 788 
 789 static inline void applyExpansionBehavior(InlineTextBox&amp; textBox, ExpansionBehavior expansionBehavior)
 790 {
 791     switch (expansionBehavior &amp; LeadingExpansionMask) {
 792     case ForceLeadingExpansion:
 793         textBox.setForceLeadingExpansion();
 794         break;
 795     case ForbidLeadingExpansion:
 796         textBox.setCanHaveLeadingExpansion(false);
</pre>
<hr />
<pre>
 909 
 910             if (textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun)
 911                 computeExpansionOpportunities(m_flow, textBox, previousRun, run-&gt;next(), renderText.stringView(run-&gt;m_start, run-&gt;m_stop), run-&gt;box()-&gt;direction());
 912 
 913             if (unsigned length = renderText.text().length()) {
 914                 if (!run-&gt;m_start &amp;&amp; needsWordSpacing &amp;&amp; isSpaceOrNewline(renderText.characterAt(run-&gt;m_start)))
 915                     totalLogicalWidth += lineStyle(*renderText.parent(), lineInfo).fontCascade().wordSpacing();
 916                 // run-&gt;m_start == run-&gt;m_stop should only be true iff the run is a replaced run for bidi: isolate.
 917                 ASSERT(run-&gt;m_stop &gt; 0 || run-&gt;m_start == run-&gt;m_stop);
 918                 needsWordSpacing = run-&gt;m_stop == length &amp;&amp; !isSpaceOrNewline(renderText.characterAt(run-&gt;m_stop - 1));
 919             }
 920 
 921             setLogicalWidthForTextRun(lineBox, run, renderText, totalLogicalWidth, lineInfo, textBoxDataMap, verticalPositionCache, wordMeasurements);
 922         } else {
 923             canHangPunctuationAtStart = false;
 924             bool encounteredJustifiedRuby = false;
 925             if (is&lt;RenderRubyRun&gt;(run-&gt;renderer()) &amp;&amp; textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun &amp;&amp; downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase()) {
 926                 auto* rubyBase = downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase();
 927                 if (rubyBase-&gt;firstRootBox() &amp;&amp; !rubyBase-&gt;firstRootBox()-&gt;nextRootBox() &amp;&amp; run-&gt;renderer().style().collapseWhiteSpace()) {
 928                     rubyBase-&gt;setIsAfterExpansion(isAfterExpansion);
<span class="line-modified"> 929                     for (auto* leafChild = rubyBase-&gt;firstRootBox()-&gt;firstLeafDescendant(); leafChild; leafChild = leafChild-&gt;nextLeafOnLine()) {</span>
 930                         if (!is&lt;InlineTextBox&gt;(*leafChild))
 931                             continue;
 932                         encounteredJustifiedRuby = true;
 933                         computeExpansionOpportunities(*rubyBase, downcast&lt;InlineTextBox&gt;(*leafChild), nullptr, nullptr,
 934                             downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction());
 935                     }
 936                 }
 937             }
 938 
 939             if (!encounteredJustifiedRuby)
 940                 isAfterExpansion = false;
 941 
 942             if (!is&lt;RenderInline&gt;(run-&gt;renderer())) {
 943                 auto&amp; renderBox = downcast&lt;RenderBox&gt;(run-&gt;renderer());
 944                 if (is&lt;RenderRubyRun&gt;(renderBox))
 945                     setMarginsForRubyRun(run, downcast&lt;RenderRubyRun&gt;(renderBox), previousRun ? &amp;previousRun-&gt;renderer() : nullptr, lineInfo);
 946                 run-&gt;box()-&gt;setLogicalWidth(m_flow.logicalWidthForChild(renderBox));
 947                 totalLogicalWidth += m_flow.marginStartForChild(renderBox) + m_flow.marginEndForChild(renderBox);
 948             }
 949         }
</pre>
<hr />
<pre>
 960         if (lastValidExpansionOpportunitiesIndex &gt;= 0) {
 961             ASSERT(expansionOpportunities.at(lastValidExpansionOpportunitiesIndex));
 962             expansionOpportunities.at(lastValidExpansionOpportunitiesIndex)--;
 963             expansionOpportunityCount--;
 964         }
 965     }
 966 
 967     if (is&lt;RenderRubyBase&gt;(m_flow) &amp;&amp; !expansionOpportunityCount)
 968         textAlign = TextAlignMode::Center;
 969 
 970     updateLogicalWidthForAlignment(m_flow, textAlign, lineBox, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth, expansionOpportunityCount);
 971 
 972     computeExpansionForJustifiedText(firstRun, trailingSpaceRun, expansionOpportunities, expansionOpportunityCount, totalLogicalWidth, availableLogicalWidth);
 973 
 974     return run;
 975 }
 976 
 977 void ComplexLineLayout::removeInlineBox(BidiRun&amp; run, const RootInlineBox&amp; rootLineBox) const
 978 {
 979     auto* inlineBox = run.box();
<span class="line-modified"> 980 #if ASSERT_ENABLED</span>
 981     auto* inlineParent = inlineBox-&gt;parent();
 982     while (inlineParent &amp;&amp; inlineParent != &amp;rootLineBox) {
 983         ASSERT(!inlineParent-&gt;isDirty());
 984         inlineParent = inlineParent-&gt;parent();
 985     }
 986     ASSERT(!rootLineBox.isDirty());
 987 #endif
 988     auto* parent = inlineBox-&gt;parent();
 989     inlineBox-&gt;removeFromParent();
 990 
 991     auto&amp; renderer = run.renderer();
 992     if (is&lt;RenderText&gt;(renderer))
 993         downcast&lt;RenderText&gt;(renderer).removeTextBox(downcast&lt;InlineTextBox&gt;(*inlineBox));
 994     delete inlineBox;
 995     run.setBox(nullptr);
 996     // removeFromParent() unnecessarily dirties the ancestor subtree.
 997     auto* ancestor = parent;
 998     while (ancestor) {
 999         ancestor-&gt;markDirty(false);
1000         if (ancestor == &amp;rootLineBox)
</pre>
<hr />
<pre>
1306     if (m_flow.containsFloats())
1307         layoutState.floatList().setLastFloat(m_flow.floatingObjects()-&gt;set().last().get());
1308 
1309     // We also find the first clean line and extract these lines. We will add them back
1310     // if we determine that we&#39;re able to synchronize after handling all our dirty lines.
1311     InlineIterator cleanLineStart;
1312     BidiStatus cleanLineBidiStatus;
1313     if (!layoutState.isFullLayout() &amp;&amp; startLine)
1314         determineEndPosition(layoutState, startLine, cleanLineStart, cleanLineBidiStatus);
1315 
1316     if (startLine) {
1317         if (!layoutState.usesRepaintBounds())
1318             layoutState.setRepaintRange(m_flow.logicalHeight());
1319         deleteLineRange(layoutState, startLine);
1320     }
1321 
1322     if (!layoutState.isFullLayout() &amp;&amp; lastRootBox() &amp;&amp; lastRootBox()-&gt;endsWithBreak()) {
1323         // If the last line before the start line ends with a line break that clear floats,
1324         // adjust the height accordingly.
1325         // A line break can be either the first or the last object on a line, depending on its direction.
<span class="line-modified">1326         if (InlineBox* lastLeafDescendant = lastRootBox()-&gt;lastLeafDescendant()) {</span>
<span class="line-modified">1327             RenderObject* lastObject = &amp;lastLeafDescendant-&gt;renderer();</span>
1328             if (!lastObject-&gt;isBR())
<span class="line-modified">1329                 lastObject = &amp;lastRootBox()-&gt;firstLeafDescendant()-&gt;renderer();</span>
1330             if (lastObject-&gt;isBR()) {
1331                 Clear clear = lastObject-&gt;style().clear();
1332                 if (clear != Clear::None)
1333                     m_flow.clearFloats(clear);
1334             }
1335         }
1336     }
1337 
1338     layoutRunsAndFloatsInRange(layoutState, resolver, cleanLineStart, cleanLineBidiStatus, consecutiveHyphenatedLines);
1339     linkToEndLineIfNeeded(layoutState);
1340     repaintDirtyFloats(layoutState.floatList());
1341 }
1342 
1343 // Before restarting the layout loop with a new logicalHeight, remove all floats that were added and reset the resolver.
1344 inline const InlineIterator&amp; ComplexLineLayout::restartLayoutRunsAndFloatsInRange(LayoutUnit oldLogicalHeight, LayoutUnit newLogicalHeight,  FloatingObject* lastFloatFromPreviousLine, InlineBidiResolver&amp; resolver,  const InlineIterator&amp; oldEnd)
1345 {
1346     m_flow.removeFloatingObjectsBelow(lastFloatFromPreviousLine, oldLogicalHeight);
1347     m_flow.setLogicalHeight(newLogicalHeight);
1348     resolver.setPositionIgnoringNestedIsolates(oldEnd);
1349     return oldEnd;
</pre>
<hr />
<pre>
1539                 lineBox = lineBox-&gt;prevRootBox();
1540             }
1541 
1542             // If there was an explicit value for orphans, respect that. If not, we still
1543             // shouldn&#39;t create a situation where we make an orphan bigger than the initial value.
1544             // This means that setting widows implies we also care about orphans, but given
1545             // the specification says the initial orphan value is non-zero, this is ok. The
1546             // author is always free to set orphans explicitly as well.
1547             int orphans = style().hasAutoOrphans() ? style().initialOrphans() : style().orphans();
1548             int numLinesAvailable = numLinesInPreviousPage - orphans;
1549             if (numLinesAvailable &lt;= 0)
1550                 return;
1551 
1552             int numLinesToTake = std::min(numLinesAvailable, numLinesNeeded);
1553             // Wind back from our first widowed line.
1554             lineBox = currentFirstLineOfNewPage;
1555             for (int i = 0; i &lt; numLinesToTake; ++i)
1556                 lineBox = lineBox-&gt;prevRootBox();
1557 
1558             // We now want to break at this line. Remember for next layout and trigger relayout.
<span class="line-modified">1559             m_flow.setBreakAtLineToAvoidWidow(lineCountUntil(lineBox));</span>
1560             m_flow.markLinesDirtyInBlockRange(lastRootBox()-&gt;lineBottomWithLeading(), lineBox-&gt;lineBottomWithLeading(), lineBox);
1561         }
1562     }
1563     m_flow.clearDidBreakAtLineToAvoidWidow();
1564 }
1565 
1566 void ComplexLineLayout::reattachCleanLineFloats(RootInlineBox&amp; cleanLine, LayoutUnit delta, bool isFirstCleanLine)
1567 {
1568     auto* cleanLineFloats = cleanLine.floatsPtr();
1569     if (!cleanLineFloats)
1570         return;
1571 
1572     for (auto&amp; floatingBox : *cleanLineFloats) {
1573         if (!floatingBox)
1574             continue;
1575         auto* floatingObject = m_flow.insertFloatingObject(*floatingBox);
1576         if (isFirstCleanLine &amp;&amp; floatingObject-&gt;originatingLine()) {
1577             // Float box does not belong to this line anymore.
1578             ASSERT_WITH_SECURITY_IMPLICATION(cleanLine.prevRootBox() == floatingObject-&gt;originatingLine());
1579             cleanLine.removeFloat(*floatingBox);
</pre>
<hr />
<pre>
2091     ASSERT(!m_flow.simpleLineLayout());
2092 
2093     LayoutUnit endPadding = m_flow.hasOverflowClip() ? m_flow.paddingEnd() : 0_lu;
2094     // FIXME: Need to find another way to do this, since scrollbars could show when we don&#39;t want them to.
2095     if (m_flow.hasOverflowClip() &amp;&amp; !endPadding &amp;&amp; m_flow.element() &amp;&amp; m_flow.element()-&gt;isRootEditableElement() &amp;&amp; style().isLeftToRightDirection())
2096         endPadding = 1;
2097     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
2098         m_flow.addLayoutOverflow(curr-&gt;paddedLayoutOverflowRect(endPadding));
2099         RenderFragmentContainer* fragment = m_flow.enclosingFragmentedFlow() ? curr-&gt;containingFragment() : nullptr;
2100         if (fragment)
2101             fragment-&gt;addLayoutOverflowForBox(&amp;m_flow, curr-&gt;paddedLayoutOverflowRect(endPadding));
2102         if (!m_flow.hasOverflowClip()) {
2103             LayoutRect childVisualOverflowRect = curr-&gt;visualOverflowRect(curr-&gt;lineTop(), curr-&gt;lineBottom());
2104             m_flow.addVisualOverflow(childVisualOverflowRect);
2105             if (fragment)
2106                 fragment-&gt;addVisualOverflowForBox(&amp;m_flow, childVisualOverflowRect);
2107         }
2108     }
2109 }
2110 
<span class="line-added">2111 size_t ComplexLineLayout::lineCount() const</span>
<span class="line-added">2112 {</span>
<span class="line-added">2113     size_t count = 0;</span>
<span class="line-added">2114     for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox())</span>
<span class="line-added">2115         ++count;</span>
<span class="line-added">2116 </span>
<span class="line-added">2117     return count;</span>
<span class="line-added">2118 }</span>
<span class="line-added">2119 </span>
<span class="line-added">2120 size_t ComplexLineLayout::lineCountUntil(const RootInlineBox* stopRootInlineBox) const</span>
<span class="line-added">2121 {</span>
<span class="line-added">2122     size_t count = 0;</span>
<span class="line-added">2123     for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {</span>
<span class="line-added">2124         ++count;</span>
<span class="line-added">2125         if (box == stopRootInlineBox)</span>
<span class="line-added">2126             break;</span>
<span class="line-added">2127     }</span>
<span class="line-added">2128 </span>
<span class="line-added">2129     return count;</span>
<span class="line-added">2130 }</span>
<span class="line-added">2131 </span>
2132 void ComplexLineLayout::deleteEllipsisLineBoxes()
2133 {
2134     TextAlignMode textAlign = style().textAlign();
2135     bool ltr = style().isLeftToRightDirection();
2136     IndentTextOrNot shouldIndentText = IndentText;
2137     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
2138         if (curr-&gt;hasEllipsisBox()) {
2139             curr-&gt;clearTruncation();
2140 
2141             // Shift the line back where it belongs if we cannot accomodate an ellipsis.
2142             float logicalLeft = m_flow.logicalLeftOffsetForLine(curr-&gt;lineTop(), shouldIndentText);
2143             float availableLogicalWidth = m_flow.logicalRightOffsetForLine(curr-&gt;lineTop(), DoNotIndentText) - logicalLeft;
2144             float totalLogicalWidth = curr-&gt;logicalWidth();
2145             updateLogicalWidthForAlignment(m_flow, textAlign, curr, 0, logicalLeft, totalLogicalWidth, availableLogicalWidth, 0);
2146 
2147             if (ltr)
2148                 curr-&gt;adjustLogicalPosition((logicalLeft - curr-&gt;logicalLeft()), 0);
2149             else
2150                 curr-&gt;adjustLogicalPosition(-(curr-&gt;logicalLeft() - logicalLeft), 0);
2151         }
</pre>
</td>
</tr>
</table>
<center><a href="CSSFilter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComplexLineLayout.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
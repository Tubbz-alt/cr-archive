<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/mathml/MathMLPresentationElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009 Alex Milowski (alex@milowski.com). All rights reserved.
  3  * Copyright (C) 2010 Apple Inc. All rights reserved.
  4  * Copyright (C) 2016 Igalia S.L.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 16  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 17  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 18  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 19  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 20  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 21  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 22  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 23  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;MathMLPresentationElement.h&quot;
 30 
 31 #if ENABLE(MATHML)
 32 
 33 #include &quot;ElementIterator.h&quot;
 34 #include &quot;HTMLHtmlElement.h&quot;
 35 #include &quot;HTMLMapElement.h&quot;
 36 #include &quot;HTMLNames.h&quot;
 37 #include &quot;HTMLParserIdioms.h&quot;
 38 #include &quot;HTTPParsers.h&quot;
 39 #include &quot;MathMLMathElement.h&quot;
 40 #include &quot;MathMLNames.h&quot;
 41 #include &quot;RenderMathMLBlock.h&quot;
 42 #include &quot;RenderTableCell.h&quot;
 43 #include &quot;SVGSVGElement.h&quot;
 44 #include &lt;wtf/IsoMallocInlines.h&gt;
 45 
 46 namespace WebCore {
 47 
 48 WTF_MAKE_ISO_ALLOCATED_IMPL(MathMLPresentationElement);
 49 
 50 using namespace MathMLNames;
 51 
 52 MathMLPresentationElement::MathMLPresentationElement(const QualifiedName&amp; tagName, Document&amp; document)
 53     : MathMLElement(tagName, document)
 54 {
 55 }
 56 
 57 Ref&lt;MathMLPresentationElement&gt; MathMLPresentationElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 58 {
 59     return adoptRef(*new MathMLPresentationElement(tagName, document));
 60 }
 61 
 62 RenderPtr&lt;RenderElement&gt; MathMLPresentationElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
 63 {
 64     if (hasTagName(mtableTag))
 65         return createRenderer&lt;RenderMathMLTable&gt;(*this, WTFMove(style));
 66 
 67     return MathMLElement::createElementRenderer(WTFMove(style), insertionPosition);
 68 }
 69 
 70 bool MathMLPresentationElement::isPhrasingContent(const Node&amp; node)
 71 {
 72     // Phrasing content is described in the HTML 5 specification:
 73     // http://www.w3.org/TR/html5/dom.html#phrasing-content.
 74 
 75     if (!node.isElementNode())
 76         return node.isTextNode();
 77 
 78     if (is&lt;MathMLElement&gt;(node)) {
 79         auto&amp; mathmlElement = downcast&lt;MathMLElement&gt;(node);
 80         return is&lt;MathMLMathElement&gt;(mathmlElement);
 81     }
 82 
 83     if (is&lt;SVGElement&gt;(node)) {
 84         auto&amp; svgElement = downcast&lt;SVGElement&gt;(node);
 85         return is&lt;SVGSVGElement&gt;(svgElement);
 86     }
 87 
 88     if (is&lt;HTMLElement&gt;(node)) {
 89         auto&amp; htmlElement = downcast&lt;HTMLElement&gt;(node);
 90         return htmlElement.hasTagName(HTMLNames::aTag)
 91             || htmlElement.hasTagName(HTMLNames::abbrTag)
 92             || (htmlElement.hasTagName(HTMLNames::areaTag) &amp;&amp; ancestorsOfType&lt;HTMLMapElement&gt;(htmlElement).first())
 93             || htmlElement.hasTagName(HTMLNames::audioTag)
 94             || htmlElement.hasTagName(HTMLNames::bTag)
 95             || htmlElement.hasTagName(HTMLNames::bdiTag)
 96             || htmlElement.hasTagName(HTMLNames::bdoTag)
 97             || htmlElement.hasTagName(HTMLNames::brTag)
 98             || htmlElement.hasTagName(HTMLNames::buttonTag)
 99             || htmlElement.hasTagName(HTMLNames::canvasTag)
100             || htmlElement.hasTagName(HTMLNames::citeTag)
101             || htmlElement.hasTagName(HTMLNames::codeTag)
102             || htmlElement.hasTagName(HTMLNames::datalistTag)
103             || htmlElement.hasTagName(HTMLNames::dataTag)
104             || htmlElement.hasTagName(HTMLNames::delTag)
105             || htmlElement.hasTagName(HTMLNames::dfnTag)
106             || htmlElement.hasTagName(HTMLNames::emTag)
107             || htmlElement.hasTagName(HTMLNames::embedTag)
108             || htmlElement.hasTagName(HTMLNames::iTag)
109             || htmlElement.hasTagName(HTMLNames::iframeTag)
110             || htmlElement.hasTagName(HTMLNames::imgTag)
111             || htmlElement.hasTagName(HTMLNames::inputTag)
112             || htmlElement.hasTagName(HTMLNames::insTag)
113             || htmlElement.hasTagName(HTMLNames::kbdTag)
114             || htmlElement.hasTagName(HTMLNames::keygenTag)
115             || htmlElement.hasTagName(HTMLNames::labelTag)
116             || htmlElement.hasTagName(HTMLNames::mapTag)
117             || htmlElement.hasTagName(HTMLNames::markTag)
118             || htmlElement.hasTagName(HTMLNames::meterTag)
119             || htmlElement.hasTagName(HTMLNames::noscriptTag)
120             || htmlElement.hasTagName(HTMLNames::objectTag)
121             || htmlElement.hasTagName(HTMLNames::outputTag)
122             || htmlElement.hasTagName(HTMLNames::progressTag)
123             || htmlElement.hasTagName(HTMLNames::qTag)
124             || htmlElement.hasTagName(HTMLNames::rubyTag)
125             || htmlElement.hasTagName(HTMLNames::sTag)
126             || htmlElement.hasTagName(HTMLNames::sampTag)
127             || htmlElement.hasTagName(HTMLNames::scriptTag)
128             || htmlElement.hasTagName(HTMLNames::selectTag)
129             || htmlElement.hasTagName(HTMLNames::smallTag)
130             || htmlElement.hasTagName(HTMLNames::spanTag)
131             || htmlElement.hasTagName(HTMLNames::strongTag)
132             || htmlElement.hasTagName(HTMLNames::subTag)
133             || htmlElement.hasTagName(HTMLNames::supTag)
134             || htmlElement.hasTagName(HTMLNames::templateTag)
135             || htmlElement.hasTagName(HTMLNames::textareaTag)
136             || htmlElement.hasTagName(HTMLNames::timeTag)
137             || htmlElement.hasTagName(HTMLNames::uTag)
138             || htmlElement.hasTagName(HTMLNames::varTag)
139             || htmlElement.hasTagName(HTMLNames::videoTag)
140             || htmlElement.hasTagName(HTMLNames::wbrTag);
141     }
142 
143     return false;
144 }
145 
146 bool MathMLPresentationElement::isFlowContent(const Node&amp; node)
147 {
148     // Flow content is described in the HTML 5 specification:
149     // http://www.w3.org/TR/html5/dom.html#flow-content
150 
151     if (isPhrasingContent(node))
152         return true;
153 
154     if (!is&lt;HTMLElement&gt;(node))
155         return false;
156 
157     auto&amp; htmlElement = downcast&lt;HTMLElement&gt;(node);
158     return htmlElement.hasTagName(HTMLNames::addressTag)
159         || htmlElement.hasTagName(HTMLNames::articleTag)
160         || htmlElement.hasTagName(HTMLNames::asideTag)
161         || htmlElement.hasTagName(HTMLNames::blockquoteTag)
162         || htmlElement.hasTagName(HTMLNames::detailsTag)
163         || htmlElement.hasTagName(HTMLNames::dialogTag)
164         || htmlElement.hasTagName(HTMLNames::divTag)
165         || htmlElement.hasTagName(HTMLNames::dlTag)
166         || htmlElement.hasTagName(HTMLNames::fieldsetTag)
167         || htmlElement.hasTagName(HTMLNames::figureTag)
168         || htmlElement.hasTagName(HTMLNames::footerTag)
169         || htmlElement.hasTagName(HTMLNames::formTag)
170         || htmlElement.hasTagName(HTMLNames::h1Tag)
171         || htmlElement.hasTagName(HTMLNames::h2Tag)
172         || htmlElement.hasTagName(HTMLNames::h3Tag)
173         || htmlElement.hasTagName(HTMLNames::h4Tag)
174         || htmlElement.hasTagName(HTMLNames::h5Tag)
175         || htmlElement.hasTagName(HTMLNames::h6Tag)
176         || htmlElement.hasTagName(HTMLNames::headerTag)
177         || htmlElement.hasTagName(HTMLNames::hrTag)
178         || htmlElement.hasTagName(HTMLNames::mainTag)
179         || htmlElement.hasTagName(HTMLNames::navTag)
180         || htmlElement.hasTagName(HTMLNames::olTag)
181         || htmlElement.hasTagName(HTMLNames::pTag)
182         || htmlElement.hasTagName(HTMLNames::preTag)
183         || htmlElement.hasTagName(HTMLNames::sectionTag)
184         || (htmlElement.hasTagName(HTMLNames::styleTag) &amp;&amp; htmlElement.hasAttribute(&quot;scoped&quot;))
185         || htmlElement.hasTagName(HTMLNames::tableTag)
186         || htmlElement.hasTagName(HTMLNames::ulTag);
187 }
188 
189 const MathMLElement::BooleanValue&amp; MathMLPresentationElement::cachedBooleanAttribute(const QualifiedName&amp; name, Optional&lt;BooleanValue&gt;&amp; attribute)
190 {
191     if (attribute)
192         return attribute.value();
193 
194     // In MathML, attribute values are case-sensitive.
195     const AtomString&amp; value = attributeWithoutSynchronization(name);
196     if (value == &quot;true&quot;)
197         attribute = BooleanValue::True;
198     else if (value == &quot;false&quot;)
199         attribute = BooleanValue::False;
200     else
201         attribute = BooleanValue::Default;
202 
203     return attribute.value();
204 }
205 
206 MathMLElement::Length MathMLPresentationElement::parseNumberAndUnit(const StringView&amp; string)
207 {
208     LengthType lengthType = LengthType::UnitLess;
209     unsigned stringLength = string.length();
210     UChar lastChar = string[stringLength - 1];
211     if (lastChar == &#39;%&#39;) {
212         lengthType = LengthType::Percentage;
213         stringLength--;
214     } else if (stringLength &gt;= 2) {
215         UChar penultimateChar = string[stringLength - 2];
216         if (penultimateChar == &#39;c&#39; &amp;&amp; lastChar == &#39;m&#39;)
217             lengthType = LengthType::Cm;
218         if (penultimateChar == &#39;e&#39; &amp;&amp; lastChar == &#39;m&#39;)
219             lengthType = LengthType::Em;
220         else if (penultimateChar == &#39;e&#39; &amp;&amp; lastChar == &#39;x&#39;)
221             lengthType = LengthType::Ex;
222         else if (penultimateChar == &#39;i&#39; &amp;&amp; lastChar == &#39;n&#39;)
223             lengthType = LengthType::In;
224         else if (penultimateChar == &#39;m&#39; &amp;&amp; lastChar == &#39;m&#39;)
225             lengthType = LengthType::Mm;
226         else if (penultimateChar == &#39;p&#39; &amp;&amp; lastChar == &#39;c&#39;)
227             lengthType = LengthType::Pc;
228         else if (penultimateChar == &#39;p&#39; &amp;&amp; lastChar == &#39;t&#39;)
229             lengthType = LengthType::Pt;
230         else if (penultimateChar == &#39;p&#39; &amp;&amp; lastChar == &#39;x&#39;)
231             lengthType = LengthType::Px;
232 
233         if (lengthType != LengthType::UnitLess)
234             stringLength -= 2;
235     }
236 
237     bool ok;
238     float lengthValue = string.substring(0, stringLength).toFloat(ok);
239     if (!ok)
240         return Length();
241 
242     Length length;
243     length.type = lengthType;
244     length.value = lengthValue;
245     return length;
246 }
247 
248 MathMLElement::Length MathMLPresentationElement::parseNamedSpace(const StringView&amp; string)
249 {
250     // Named space values are case-sensitive.
251     int namedSpaceValue;
252     if (string == &quot;veryverythinmathspace&quot;)
253         namedSpaceValue = 1;
254     else if (string == &quot;verythinmathspace&quot;)
255         namedSpaceValue = 2;
256     else if (string == &quot;thinmathspace&quot;)
257         namedSpaceValue = 3;
258     else if (string == &quot;mediummathspace&quot;)
259         namedSpaceValue = 4;
260     else if (string == &quot;thickmathspace&quot;)
261         namedSpaceValue = 5;
262     else if (string == &quot;verythickmathspace&quot;)
263         namedSpaceValue = 6;
264     else if (string == &quot;veryverythickmathspace&quot;)
265         namedSpaceValue = 7;
266     else if (string == &quot;negativeveryverythinmathspace&quot;)
267         namedSpaceValue = -1;
268     else if (string == &quot;negativeverythinmathspace&quot;)
269         namedSpaceValue = -2;
270     else if (string == &quot;negativethinmathspace&quot;)
271         namedSpaceValue = -3;
272     else if (string == &quot;negativemediummathspace&quot;)
273         namedSpaceValue = -4;
274     else if (string == &quot;negativethickmathspace&quot;)
275         namedSpaceValue = -5;
276     else if (string == &quot;negativeverythickmathspace&quot;)
277         namedSpaceValue = -6;
278     else if (string == &quot;negativeveryverythickmathspace&quot;)
279         namedSpaceValue = -7;
280     else
281         return Length();
282 
283     Length length;
284     length.type = LengthType::MathUnit;
285     length.value = namedSpaceValue;
286     return length;
287 }
288 
289 MathMLElement::Length MathMLPresentationElement::parseMathMLLength(const String&amp; string)
290 {
291     // The regular expression from the MathML Relax NG schema is as follows:
292     //
293     //   pattern = &#39;\s*((-?[0-9]*([0-9]\.?|\.[0-9])[0-9]*(e[mx]|in|cm|mm|p[xtc]|%)?)|(negative)?((very){0,2}thi(n|ck)|medium)mathspace)\s*&#39;
294     //
295     // We do not perform a strict verification of the syntax of whitespaces and number.
296     // Instead, we just use isHTMLSpace and toFloat to parse these parts.
297 
298     // We first skip whitespace from both ends of the string.
299     StringView stringView = string;
300     StringView strippedLength = stripLeadingAndTrailingHTTPSpaces(stringView);
301 
302     if (strippedLength.isEmpty())
303         return Length();
304 
305     // We consider the most typical case: a number followed by an optional unit.
306     UChar firstChar = strippedLength[0];
307     if (isASCIIDigit(firstChar) || firstChar == &#39;-&#39; || firstChar == &#39;.&#39;)
308         return parseNumberAndUnit(strippedLength);
309 
310     // Otherwise, we try and parse a named space.
311     return parseNamedSpace(strippedLength);
312 }
313 
314 const MathMLElement::Length&amp; MathMLPresentationElement::cachedMathMLLength(const QualifiedName&amp; name, Optional&lt;Length&gt;&amp; length)
315 {
316     if (length)
317         return length.value();
318     length = parseMathMLLength(attributeWithoutSynchronization(name));
319     return length.value();
320 }
321 
322 bool MathMLPresentationElement::acceptsDisplayStyleAttribute()
323 {
324     return hasTagName(mtableTag);
325 }
326 
327 Optional&lt;bool&gt; MathMLPresentationElement::specifiedDisplayStyle()
328 {
329     if (!acceptsDisplayStyleAttribute())
330         return WTF::nullopt;
331     const MathMLElement::BooleanValue&amp; specifiedDisplayStyle = cachedBooleanAttribute(displaystyleAttr, m_displayStyle);
332     return toOptionalBool(specifiedDisplayStyle);
333 }
334 
335 MathMLElement::MathVariant MathMLPresentationElement::parseMathVariantAttribute(const AtomString&amp; attributeValue)
336 {
337     // The mathvariant attribute values is case-sensitive.
338     if (attributeValue == &quot;normal&quot;)
339         return MathVariant::Normal;
340     if (attributeValue == &quot;bold&quot;)
341         return MathVariant::Bold;
342     if (attributeValue == &quot;italic&quot;)
343         return MathVariant::Italic;
344     if (attributeValue == &quot;bold-italic&quot;)
345         return MathVariant::BoldItalic;
346     if (attributeValue == &quot;double-struck&quot;)
347         return MathVariant::DoubleStruck;
348     if (attributeValue == &quot;bold-fraktur&quot;)
349         return MathVariant::BoldFraktur;
350     if (attributeValue == &quot;script&quot;)
351         return MathVariant::Script;
352     if (attributeValue == &quot;bold-script&quot;)
353         return MathVariant::BoldScript;
354     if (attributeValue == &quot;fraktur&quot;)
355         return MathVariant::Fraktur;
356     if (attributeValue == &quot;sans-serif&quot;)
357         return MathVariant::SansSerif;
358     if (attributeValue == &quot;bold-sans-serif&quot;)
359         return MathVariant::BoldSansSerif;
360     if (attributeValue == &quot;sans-serif-italic&quot;)
361         return MathVariant::SansSerifItalic;
362     if (attributeValue == &quot;sans-serif-bold-italic&quot;)
363         return MathVariant::SansSerifBoldItalic;
364     if (attributeValue == &quot;monospace&quot;)
365         return MathVariant::Monospace;
366     if (attributeValue == &quot;initial&quot;)
367         return MathVariant::Initial;
368     if (attributeValue == &quot;tailed&quot;)
369         return MathVariant::Tailed;
370     if (attributeValue == &quot;looped&quot;)
371         return MathVariant::Looped;
372     if (attributeValue == &quot;stretched&quot;)
373         return MathVariant::Stretched;
374     return MathVariant::None;
375 }
376 
377 Optional&lt;MathMLElement::MathVariant&gt; MathMLPresentationElement::specifiedMathVariant()
378 {
379     if (!acceptsMathVariantAttribute())
380         return WTF::nullopt;
381     if (!m_mathVariant)
382         m_mathVariant = parseMathVariantAttribute(attributeWithoutSynchronization(mathvariantAttr));
383     return m_mathVariant.value() == MathVariant::None ? WTF::nullopt : m_mathVariant;
384 }
385 
386 void MathMLPresentationElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
387 {
388     bool displayStyleAttribute = name == displaystyleAttr &amp;&amp; acceptsDisplayStyleAttribute();
389     bool mathVariantAttribute = name == mathvariantAttr &amp;&amp; acceptsMathVariantAttribute();
390     if (displayStyleAttribute)
391         m_displayStyle = WTF::nullopt;
392     if (mathVariantAttribute)
393         m_mathVariant = WTF::nullopt;
394     if ((displayStyleAttribute || mathVariantAttribute) &amp;&amp; renderer())
395         MathMLStyle::resolveMathMLStyleTree(renderer());
396 
397     MathMLElement::parseAttribute(name, value);
398 }
399 
400 }
401 
402 #endif // ENABLE(MATHML)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/EventSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventHandler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventSource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/EventSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;EventSource.h&quot;
 35 
 36 #include &quot;CachedResourceRequestInitiators.h&quot;
 37 #include &quot;ContentSecurityPolicy.h&quot;
 38 #include &quot;EventNames.h&quot;
 39 #include &quot;MessageEvent.h&quot;
 40 #include &quot;ResourceError.h&quot;
 41 #include &quot;ResourceRequest.h&quot;
 42 #include &quot;ResourceResponse.h&quot;
 43 #include &quot;ScriptExecutionContext.h&quot;
 44 #include &quot;SecurityOrigin.h&quot;
 45 #include &quot;TextResourceDecoder.h&quot;
 46 #include &quot;ThreadableLoader.h&quot;
 47 #include &lt;wtf/IsoMallocInlines.h&gt;

 48 
 49 namespace WebCore {
 50 
 51 WTF_MAKE_ISO_ALLOCATED_IMPL(EventSource);
 52 
 53 const uint64_t EventSource::defaultReconnectDelay = 3000;
 54 
 55 inline EventSource::EventSource(ScriptExecutionContext&amp; context, const URL&amp; url, const Init&amp; eventSourceInit)
 56     : ActiveDOMObject(&amp;context)
 57     , m_url(url)
 58     , m_withCredentials(eventSourceInit.withCredentials)
 59     , m_decoder(TextResourceDecoder::create(&quot;text/plain&quot;_s, &quot;UTF-8&quot;))
<span class="line-modified"> 60     , m_connectTimer(*this, &amp;EventSource::connect)</span>
 61 {

 62 }
 63 
 64 ExceptionOr&lt;Ref&lt;EventSource&gt;&gt; EventSource::create(ScriptExecutionContext&amp; context, const String&amp; url, const Init&amp; eventSourceInit)
 65 {
 66     if (url.isEmpty())
 67         return Exception { SyntaxError };
 68 
 69     URL fullURL = context.completeURL(url);
 70     if (!fullURL.isValid())
 71         return Exception { SyntaxError };
 72 
 73     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is resolved.
 74     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(fullURL)) {
 75         // FIXME: Should this be throwing an exception?
 76         return Exception { SecurityError };
 77     }
 78 
 79     auto source = adoptRef(*new EventSource(context, fullURL, eventSourceInit));
 80     source-&gt;setPendingActivity(source.get());
 81     source-&gt;scheduleInitialConnect();
</pre>
<hr />
<pre>
124     ASSERT(m_requestInFlight);
125 
126     m_requestInFlight = false;
127 
128     if (m_state != CLOSED)
129         scheduleReconnect();
130     else
131         unsetPendingActivity(*this);
132 }
133 
134 void EventSource::scheduleInitialConnect()
135 {
136     ASSERT(m_state == CONNECTING);
137     ASSERT(!m_requestInFlight);
138 
139     m_connectTimer.startOneShot(0_s);
140 }
141 
142 void EventSource::scheduleReconnect()
143 {

144     m_state = CONNECTING;
145     m_connectTimer.startOneShot(1_ms * m_reconnectDelay);
<span class="line-modified">146     dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
147 }
148 
149 void EventSource::close()
150 {
151     if (m_state == CLOSED) {
152         ASSERT(!m_requestInFlight);
153         return;
154     }
155 
156     // Stop trying to connect/reconnect if EventSource was explicitly closed or if ActiveDOMObject::stop() was called.
157     if (m_connectTimer.isActive())
<span class="line-modified">158         m_connectTimer.stop();</span>
159 
160     if (m_requestInFlight)
<span class="line-modified">161         m_loader-&gt;cancel();</span>
162     else {
163         m_state = CLOSED;
164         unsetPendingActivity(*this);
165     }
166 }
167 
168 bool EventSource::responseIsValid(const ResourceResponse&amp; response) const
169 {
170     // Logs to the console as a side effect.
171 
172     // To keep the signal-to-noise ratio low, we don&#39;t log anything if the status code is not 200.
173     if (response.httpStatusCode() != 200)
174         return false;
175 
176     if (!equalLettersIgnoringASCIICase(response.mimeType(), &quot;text/event-stream&quot;)) {
177         auto message = makeString(&quot;EventSource&#39;s response has a MIME type (\&quot;&quot;, response.mimeType(), &quot;\&quot;) that is not \&quot;text/event-stream\&quot;. Aborting the connection.&quot;);
178         // FIXME: Console message would be better with a source code location; where would we get that?
179         scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, WTFMove(message));
180         return false;
181     }
182 
183     // If we have a charset, the only allowed value is UTF-8 (case-insensitive).
184     auto&amp; charset = response.textEncodingName();
185     if (!charset.isEmpty() &amp;&amp; !equalLettersIgnoringASCIICase(charset, &quot;utf-8&quot;)) {
186         auto message = makeString(&quot;EventSource&#39;s response has a charset (\&quot;&quot;, charset, &quot;\&quot;) that is not UTF-8. Aborting the connection.&quot;);
187         // FIXME: Console message would be better with a source code location; where would we get that?
188         scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, WTFMove(message));
189         return false;
190     }
191 
192     return true;
193 }
194 
195 void EventSource::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)
196 {
197     ASSERT(m_state == CONNECTING);
198     ASSERT(m_requestInFlight);

199 
200     if (!responseIsValid(response)) {
<span class="line-modified">201         m_loader-&gt;cancel();</span>
<span class="line-modified">202         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
203         return;
204     }
205 
206     m_eventStreamOrigin = SecurityOriginData::fromURL(response.url()).toString();
207     m_state = OPEN;
208     dispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
209 }
210 





211 void EventSource::didReceiveData(const char* data, int length)
212 {
213     ASSERT(m_state == OPEN);
214     ASSERT(m_requestInFlight);

215 
216     append(m_receiveBuffer, m_decoder-&gt;decode(data, length));
217     parseEventStream();
218 }
219 
220 void EventSource::didFinishLoading(unsigned long)
221 {
222     ASSERT(m_state == OPEN);
223     ASSERT(m_requestInFlight);

224 
225     append(m_receiveBuffer, m_decoder-&gt;flush());
226     parseEventStream();
227 
228     // Discard everything that has not been dispatched by now.
229     // FIXME: Why does this need to be done?
230     // If this is important, why isn&#39;t it important to clear other data members: m_decoder, m_lastEventId, m_loader?
231     m_receiveBuffer.clear();
232     m_data.clear();
233     m_eventName = { };
234     m_currentlyParsedEventId = { };
235 
236     networkRequestEnded();
237 }
238 
239 void EventSource::didFail(const ResourceError&amp; error)
240 {
241     ASSERT(m_state != CLOSED);
242 
243     if (error.isAccessControl()) {
244         abortConnectionAttempt();
245         return;
246     }
247 
248     ASSERT(m_requestInFlight);
249 








250     if (error.isCancellation())
251         m_state = CLOSED;
252 
253     // FIXME: Why don&#39;t we need to clear data members here as in didFinishLoading?
254 
255     networkRequestEnded();
256 }
257 
258 void EventSource::abortConnectionAttempt()
259 {
260     ASSERT(m_state == CONNECTING);

261 
262     if (m_requestInFlight)
<span class="line-modified">263         m_loader-&gt;cancel();</span>
264     else {
265         m_state = CLOSED;
266         unsetPendingActivity(*this);
267     }
268 
269     ASSERT(m_state == CLOSED);
270     dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
271 }
272 







273 void EventSource::parseEventStream()
274 {
275     unsigned position = 0;
276     unsigned size = m_receiveBuffer.size();
277     while (position &lt; size) {
278         if (m_discardTrailingNewline) {
279             if (m_receiveBuffer[position] == &#39;\n&#39;)
280                 ++position;
281             m_discardTrailingNewline = false;
282         }
283 
284         Optional&lt;unsigned&gt; lineLength;
285         Optional&lt;unsigned&gt; fieldLength;
286         for (unsigned i = position; !lineLength &amp;&amp; i &lt; size; ++i) {
287             switch (m_receiveBuffer[i]) {
288             case &#39;:&#39;:
289                 if (!fieldLength)
290                     fieldLength = i - position;
291                 break;
292             case &#39;\r&#39;:
</pre>
<hr />
<pre>
359             // FIXME: Do we really want to ignore trailing garbage here? Should we be using the strict version instead?
360             // FIXME: If we can&#39;t parse the value, should we leave m_reconnectDelay alone or set it to defaultReconnectDelay?
361             bool ok;
362             auto reconnectDelay = charactersToUInt64(&amp;m_receiveBuffer[position], valueLength, &amp;ok);
363             if (ok)
364                 m_reconnectDelay = reconnectDelay;
365         }
366     }
367 }
368 
369 void EventSource::stop()
370 {
371     close();
372 }
373 
374 const char* EventSource::activeDOMObjectName() const
375 {
376     return &quot;EventSource&quot;;
377 }
378 
<span class="line-modified">379 bool EventSource::canSuspendForDocumentSuspension() const</span>









380 {
<span class="line-modified">381     // FIXME: We should return true here when we can because this object is not actually currently active.</span>
<span class="line-modified">382     return false;</span>








383 }
384 
385 void EventSource::dispatchMessageEvent()
386 {


387     if (!m_currentlyParsedEventId.isNull())
388         m_lastEventId = WTFMove(m_currentlyParsedEventId);
389 
390     auto&amp; name = m_eventName.isEmpty() ? eventNames().messageEvent : m_eventName;
391 
392     // Omit the trailing &quot;\n&quot; character.
393     ASSERT(!m_data.isEmpty());
394     unsigned size = m_data.size() - 1;
395     auto data = SerializedScriptValue::create({ m_data.data(), size });
396     RELEASE_ASSERT(data);
397     m_data = { };
398 
399     dispatchEvent(MessageEvent::create(name, data.releaseNonNull(), m_eventStreamOrigin, m_lastEventId));
400 }
401 
402 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 28  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;EventSource.h&quot;
 35 
 36 #include &quot;CachedResourceRequestInitiators.h&quot;
 37 #include &quot;ContentSecurityPolicy.h&quot;
 38 #include &quot;EventNames.h&quot;
 39 #include &quot;MessageEvent.h&quot;
 40 #include &quot;ResourceError.h&quot;
 41 #include &quot;ResourceRequest.h&quot;
 42 #include &quot;ResourceResponse.h&quot;
 43 #include &quot;ScriptExecutionContext.h&quot;
 44 #include &quot;SecurityOrigin.h&quot;
 45 #include &quot;TextResourceDecoder.h&quot;
 46 #include &quot;ThreadableLoader.h&quot;
 47 #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="line-added"> 48 #include &lt;wtf/SetForScope.h&gt;</span>
 49 
 50 namespace WebCore {
 51 
 52 WTF_MAKE_ISO_ALLOCATED_IMPL(EventSource);
 53 
 54 const uint64_t EventSource::defaultReconnectDelay = 3000;
 55 
 56 inline EventSource::EventSource(ScriptExecutionContext&amp; context, const URL&amp; url, const Init&amp; eventSourceInit)
 57     : ActiveDOMObject(&amp;context)
 58     , m_url(url)
 59     , m_withCredentials(eventSourceInit.withCredentials)
 60     , m_decoder(TextResourceDecoder::create(&quot;text/plain&quot;_s, &quot;UTF-8&quot;))
<span class="line-modified"> 61     , m_connectTimer(&amp;context, *this, &amp;EventSource::connect)</span>
 62 {
<span class="line-added"> 63     m_connectTimer.suspendIfNeeded();</span>
 64 }
 65 
 66 ExceptionOr&lt;Ref&lt;EventSource&gt;&gt; EventSource::create(ScriptExecutionContext&amp; context, const String&amp; url, const Init&amp; eventSourceInit)
 67 {
 68     if (url.isEmpty())
 69         return Exception { SyntaxError };
 70 
 71     URL fullURL = context.completeURL(url);
 72     if (!fullURL.isValid())
 73         return Exception { SyntaxError };
 74 
 75     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is resolved.
 76     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(fullURL)) {
 77         // FIXME: Should this be throwing an exception?
 78         return Exception { SecurityError };
 79     }
 80 
 81     auto source = adoptRef(*new EventSource(context, fullURL, eventSourceInit));
 82     source-&gt;setPendingActivity(source.get());
 83     source-&gt;scheduleInitialConnect();
</pre>
<hr />
<pre>
126     ASSERT(m_requestInFlight);
127 
128     m_requestInFlight = false;
129 
130     if (m_state != CLOSED)
131         scheduleReconnect();
132     else
133         unsetPendingActivity(*this);
134 }
135 
136 void EventSource::scheduleInitialConnect()
137 {
138     ASSERT(m_state == CONNECTING);
139     ASSERT(!m_requestInFlight);
140 
141     m_connectTimer.startOneShot(0_s);
142 }
143 
144 void EventSource::scheduleReconnect()
145 {
<span class="line-added">146     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_isSuspendedForBackForwardCache);</span>
147     m_state = CONNECTING;
148     m_connectTimer.startOneShot(1_ms * m_reconnectDelay);
<span class="line-modified">149     dispatchErrorEvent();</span>
150 }
151 
152 void EventSource::close()
153 {
154     if (m_state == CLOSED) {
155         ASSERT(!m_requestInFlight);
156         return;
157     }
158 
159     // Stop trying to connect/reconnect if EventSource was explicitly closed or if ActiveDOMObject::stop() was called.
160     if (m_connectTimer.isActive())
<span class="line-modified">161         m_connectTimer.cancel();</span>
162 
163     if (m_requestInFlight)
<span class="line-modified">164         doExplicitLoadCancellation();</span>
165     else {
166         m_state = CLOSED;
167         unsetPendingActivity(*this);
168     }
169 }
170 
171 bool EventSource::responseIsValid(const ResourceResponse&amp; response) const
172 {
173     // Logs to the console as a side effect.
174 
175     // To keep the signal-to-noise ratio low, we don&#39;t log anything if the status code is not 200.
176     if (response.httpStatusCode() != 200)
177         return false;
178 
179     if (!equalLettersIgnoringASCIICase(response.mimeType(), &quot;text/event-stream&quot;)) {
180         auto message = makeString(&quot;EventSource&#39;s response has a MIME type (\&quot;&quot;, response.mimeType(), &quot;\&quot;) that is not \&quot;text/event-stream\&quot;. Aborting the connection.&quot;);
181         // FIXME: Console message would be better with a source code location; where would we get that?
182         scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, WTFMove(message));
183         return false;
184     }
185 
186     // If we have a charset, the only allowed value is UTF-8 (case-insensitive).
187     auto&amp; charset = response.textEncodingName();
188     if (!charset.isEmpty() &amp;&amp; !equalLettersIgnoringASCIICase(charset, &quot;utf-8&quot;)) {
189         auto message = makeString(&quot;EventSource&#39;s response has a charset (\&quot;&quot;, charset, &quot;\&quot;) that is not UTF-8. Aborting the connection.&quot;);
190         // FIXME: Console message would be better with a source code location; where would we get that?
191         scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, WTFMove(message));
192         return false;
193     }
194 
195     return true;
196 }
197 
198 void EventSource::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)
199 {
200     ASSERT(m_state == CONNECTING);
201     ASSERT(m_requestInFlight);
<span class="line-added">202     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_isSuspendedForBackForwardCache);</span>
203 
204     if (!responseIsValid(response)) {
<span class="line-modified">205         doExplicitLoadCancellation();</span>
<span class="line-modified">206         dispatchErrorEvent();</span>
207         return;
208     }
209 
210     m_eventStreamOrigin = SecurityOriginData::fromURL(response.url()).toString();
211     m_state = OPEN;
212     dispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
213 }
214 
<span class="line-added">215 void EventSource::dispatchErrorEvent()</span>
<span class="line-added">216 {</span>
<span class="line-added">217     dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">218 }</span>
<span class="line-added">219 </span>
220 void EventSource::didReceiveData(const char* data, int length)
221 {
222     ASSERT(m_state == OPEN);
223     ASSERT(m_requestInFlight);
<span class="line-added">224     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_isSuspendedForBackForwardCache);</span>
225 
226     append(m_receiveBuffer, m_decoder-&gt;decode(data, length));
227     parseEventStream();
228 }
229 
230 void EventSource::didFinishLoading(unsigned long)
231 {
232     ASSERT(m_state == OPEN);
233     ASSERT(m_requestInFlight);
<span class="line-added">234     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_isSuspendedForBackForwardCache);</span>
235 
236     append(m_receiveBuffer, m_decoder-&gt;flush());
237     parseEventStream();
238 
239     // Discard everything that has not been dispatched by now.
240     // FIXME: Why does this need to be done?
241     // If this is important, why isn&#39;t it important to clear other data members: m_decoder, m_lastEventId, m_loader?
242     m_receiveBuffer.clear();
243     m_data.clear();
244     m_eventName = { };
245     m_currentlyParsedEventId = { };
246 
247     networkRequestEnded();
248 }
249 
250 void EventSource::didFail(const ResourceError&amp; error)
251 {
252     ASSERT(m_state != CLOSED);
253 
254     if (error.isAccessControl()) {
255         abortConnectionAttempt();
256         return;
257     }
258 
259     ASSERT(m_requestInFlight);
260 
<span class="line-added">261     // This is the case where the load gets cancelled on navigating away. We only fire an error event and attempt to reconnect</span>
<span class="line-added">262     // if we end up getting resumed from back/forward cache.</span>
<span class="line-added">263     if (error.isCancellation() &amp;&amp; !m_isDoingExplicitCancellation) {</span>
<span class="line-added">264         m_shouldReconnectOnResume = true;</span>
<span class="line-added">265         m_requestInFlight = false;</span>
<span class="line-added">266         return;</span>
<span class="line-added">267     }</span>
<span class="line-added">268 </span>
269     if (error.isCancellation())
270         m_state = CLOSED;
271 
272     // FIXME: Why don&#39;t we need to clear data members here as in didFinishLoading?
273 
274     networkRequestEnded();
275 }
276 
277 void EventSource::abortConnectionAttempt()
278 {
279     ASSERT(m_state == CONNECTING);
<span class="line-added">280     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_isSuspendedForBackForwardCache);</span>
281 
282     if (m_requestInFlight)
<span class="line-modified">283         doExplicitLoadCancellation();</span>
284     else {
285         m_state = CLOSED;
286         unsetPendingActivity(*this);
287     }
288 
289     ASSERT(m_state == CLOSED);
290     dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
291 }
292 
<span class="line-added">293 void EventSource::doExplicitLoadCancellation()</span>
<span class="line-added">294 {</span>
<span class="line-added">295     ASSERT(m_requestInFlight);</span>
<span class="line-added">296     SetForScope&lt;bool&gt; explicitLoadCancellation(m_isDoingExplicitCancellation, true);</span>
<span class="line-added">297     m_loader-&gt;cancel();</span>
<span class="line-added">298 }</span>
<span class="line-added">299 </span>
300 void EventSource::parseEventStream()
301 {
302     unsigned position = 0;
303     unsigned size = m_receiveBuffer.size();
304     while (position &lt; size) {
305         if (m_discardTrailingNewline) {
306             if (m_receiveBuffer[position] == &#39;\n&#39;)
307                 ++position;
308             m_discardTrailingNewline = false;
309         }
310 
311         Optional&lt;unsigned&gt; lineLength;
312         Optional&lt;unsigned&gt; fieldLength;
313         for (unsigned i = position; !lineLength &amp;&amp; i &lt; size; ++i) {
314             switch (m_receiveBuffer[i]) {
315             case &#39;:&#39;:
316                 if (!fieldLength)
317                     fieldLength = i - position;
318                 break;
319             case &#39;\r&#39;:
</pre>
<hr />
<pre>
386             // FIXME: Do we really want to ignore trailing garbage here? Should we be using the strict version instead?
387             // FIXME: If we can&#39;t parse the value, should we leave m_reconnectDelay alone or set it to defaultReconnectDelay?
388             bool ok;
389             auto reconnectDelay = charactersToUInt64(&amp;m_receiveBuffer[position], valueLength, &amp;ok);
390             if (ok)
391                 m_reconnectDelay = reconnectDelay;
392         }
393     }
394 }
395 
396 void EventSource::stop()
397 {
398     close();
399 }
400 
401 const char* EventSource::activeDOMObjectName() const
402 {
403     return &quot;EventSource&quot;;
404 }
405 
<span class="line-modified">406 void EventSource::suspend(ReasonForSuspension reason)</span>
<span class="line-added">407 {</span>
<span class="line-added">408     if (reason != ReasonForSuspension::BackForwardCache)</span>
<span class="line-added">409         return;</span>
<span class="line-added">410 </span>
<span class="line-added">411     m_isSuspendedForBackForwardCache = true;</span>
<span class="line-added">412     RELEASE_ASSERT_WITH_MESSAGE(!m_requestInFlight, &quot;Loads get cancelled before entering the BackForwardCache.&quot;);</span>
<span class="line-added">413 }</span>
<span class="line-added">414 </span>
<span class="line-added">415 void EventSource::resume()</span>
416 {
<span class="line-modified">417     if (!m_isSuspendedForBackForwardCache)</span>
<span class="line-modified">418         return;</span>
<span class="line-added">419 </span>
<span class="line-added">420     m_isSuspendedForBackForwardCache = false;</span>
<span class="line-added">421     if (std::exchange(m_shouldReconnectOnResume, false)) {</span>
<span class="line-added">422         scriptExecutionContext()-&gt;postTask([this, pendingActivity = makePendingActivity(*this)](ScriptExecutionContext&amp;) {</span>
<span class="line-added">423             if (!isContextStopped())</span>
<span class="line-added">424                 scheduleReconnect();</span>
<span class="line-added">425         });</span>
<span class="line-added">426     }</span>
427 }
428 
429 void EventSource::dispatchMessageEvent()
430 {
<span class="line-added">431     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_isSuspendedForBackForwardCache);</span>
<span class="line-added">432 </span>
433     if (!m_currentlyParsedEventId.isNull())
434         m_lastEventId = WTFMove(m_currentlyParsedEventId);
435 
436     auto&amp; name = m_eventName.isEmpty() ? eventNames().messageEvent : m_eventName;
437 
438     // Omit the trailing &quot;\n&quot; character.
439     ASSERT(!m_data.isEmpty());
440     unsigned size = m_data.size() - 1;
441     auto data = SerializedScriptValue::create({ m_data.data(), size });
442     RELEASE_ASSERT(data);
443     m_data = { };
444 
445     dispatchEvent(MessageEvent::create(name, data.releaseNonNull(), m_eventStreamOrigin, m_lastEventId));
446 }
447 
448 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="EventHandler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventSource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
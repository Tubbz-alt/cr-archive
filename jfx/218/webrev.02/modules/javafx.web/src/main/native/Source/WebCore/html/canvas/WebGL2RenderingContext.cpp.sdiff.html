<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="OffscreenCanvasRenderingContext2D.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGL2RenderingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGL2RenderingContext.h&quot;
  28 
  29 #if ENABLE(WEBGL2)
  30 
  31 #include &quot;CachedImage.h&quot;
  32 #include &quot;EXTTextureFilterAnisotropic.h&quot;
<span class="line-modified">  33 #include &quot;Extensions3D.h&quot;</span>

  34 #include &quot;HTMLCanvasElement.h&quot;
  35 #include &quot;HTMLImageElement.h&quot;
  36 #include &quot;HTMLVideoElement.h&quot;
  37 #include &quot;ImageData.h&quot;
  38 #include &quot;InspectorInstrumentation.h&quot;
  39 #include &quot;Logging.h&quot;
  40 #include &quot;OESTextureFloat.h&quot;
  41 #include &quot;OESTextureFloatLinear.h&quot;
  42 #include &quot;OESTextureHalfFloat.h&quot;
  43 #include &quot;OESTextureHalfFloatLinear.h&quot;
  44 #include &quot;RenderBox.h&quot;
  45 #include &quot;WebGLActiveInfo.h&quot;
  46 #include &quot;WebGLCompressedTextureASTC.h&quot;
  47 #include &quot;WebGLCompressedTextureATC.h&quot;


  48 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  49 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  50 #include &quot;WebGLDebugRendererInfo.h&quot;
  51 #include &quot;WebGLDebugShaders.h&quot;
  52 #include &quot;WebGLDepthTexture.h&quot;
  53 #include &quot;WebGLLoseContext.h&quot;
  54 #include &quot;WebGLQuery.h&quot;
  55 #include &quot;WebGLSampler.h&quot;
  56 #include &quot;WebGLSync.h&quot;
  57 #include &quot;WebGLTransformFeedback.h&quot;
  58 #include &quot;WebGLVertexArrayObject.h&quot;
  59 #include &lt;JavaScriptCore/GenericTypedArrayViewInlines.h&gt;
  60 #include &lt;JavaScriptCore/HeapInlines.h&gt;
  61 #include &lt;JavaScriptCore/JSGenericTypedArrayViewInlines.h&gt;

  62 #include &lt;wtf/IsoMallocInlines.h&gt;
  63 
  64 namespace WebCore {
  65 
  66 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGL2RenderingContext);
  67 
<span class="line-modified">  68 std::unique_ptr&lt;WebGL2RenderingContext&gt; WebGL2RenderingContext::create(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)</span>
  69 {
  70     auto renderingContext = std::unique_ptr&lt;WebGL2RenderingContext&gt;(new WebGL2RenderingContext(canvas, attributes));
  71 
  72     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  73 
  74     return renderingContext;
  75 }
  76 
<span class="line-modified">  77 std::unique_ptr&lt;WebGL2RenderingContext&gt; WebGL2RenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)</span>
  78 {
  79     auto renderingContext = std::unique_ptr&lt;WebGL2RenderingContext&gt;(new WebGL2RenderingContext(canvas, WTFMove(context), attributes));
  80 
  81     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  82 
  83     return renderingContext;
  84 }
  85 
<span class="line-modified">  86 WebGL2RenderingContext::WebGL2RenderingContext(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)</span>
  87     : WebGLRenderingContextBase(canvas, attributes)
  88 {
  89 }
  90 
<span class="line-modified">  91 WebGL2RenderingContext::WebGL2RenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)</span>
  92     : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
  93 {
  94     initializeShaderExtensions();
  95     initializeVertexArrayObjects();











  96 }
  97 
  98 void WebGL2RenderingContext::initializeVertexArrayObjects()
  99 {
 100     m_defaultVertexArrayObject = WebGLVertexArrayObject::create(*this, WebGLVertexArrayObject::Type::Default);
 101     addContextObject(*m_defaultVertexArrayObject);
 102 #if USE(OPENGL_ES)
 103     m_boundVertexArrayObject = m_defaultVertexArrayObject;
 104 #else
 105     bindVertexArray(nullptr); // The default VAO was removed in OpenGL 3.3 but not from WebGL 2; bind the default for WebGL to use.
 106 #endif
 107     if (!isGLES2Compliant())
 108         initVertexAttrib0();
 109 }
 110 
 111 void WebGL2RenderingContext::initializeShaderExtensions()
 112 {
 113     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_OES_standard_derivatives&quot;);
 114     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;);
 115     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_shader_texture_lod&quot;);
 116     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_frag_depth&quot;);
 117 }
 118 
<span class="line-modified"> 119 inline static Optional&lt;unsigned&gt; arrayBufferViewElementSize(const ArrayBufferView&amp; data)</span>
 120 {
<span class="line-modified"> 121     switch (data.getType()) {</span>
<span class="line-modified"> 122     case JSC::NotTypedArray:</span>
<span class="line-modified"> 123     case JSC::TypeDataView:</span>
<span class="line-modified"> 124         return WTF::nullopt;</span>
<span class="line-removed"> 125     case JSC::TypeInt8:</span>
<span class="line-removed"> 126     case JSC::TypeUint8:</span>
<span class="line-removed"> 127     case JSC::TypeUint8Clamped:</span>
<span class="line-removed"> 128     case JSC::TypeInt16:</span>
<span class="line-removed"> 129     case JSC::TypeUint16:</span>
<span class="line-removed"> 130     case JSC::TypeInt32:</span>
<span class="line-removed"> 131     case JSC::TypeUint32:</span>
<span class="line-removed"> 132     case JSC::TypeFloat32:</span>
<span class="line-removed"> 133     case JSC::TypeFloat64:</span>
<span class="line-removed"> 134         return elementSize(data.getType());</span>
<span class="line-removed"> 135     }</span>
<span class="line-removed"> 136     RELEASE_ASSERT_NOT_REACHED();</span>
 137 }
 138 
<span class="line-modified"> 139 void WebGL2RenderingContext::bufferData(GC3Denum target, const ArrayBufferView&amp; data, GC3Denum usage, GC3Duint srcOffset, GC3Duint length)</span>
 140 {
<span class="line-modified"> 141     auto optionalElementSize = arrayBufferViewElementSize(data);</span>
<span class="line-modified"> 142     if (!optionalElementSize) {</span>
<span class="line-modified"> 143         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bufferData&quot;, &quot;Invalid type of Array Buffer View&quot;);</span>
<span class="line-removed"> 144         return;</span>
<span class="line-removed"> 145     }</span>
<span class="line-removed"> 146     auto elementSize = optionalElementSize.value();</span>
<span class="line-removed"> 147     Checked&lt;GC3Duint, RecordOverflow&gt; checkedElementSize(elementSize);</span>
 148 
<span class="line-modified"> 149     Checked&lt;GC3Duint, RecordOverflow&gt; checkedSrcOffset(srcOffset);</span>
<span class="line-modified"> 150     Checked&lt;GC3Duint, RecordOverflow&gt; checkedByteSrcOffset = checkedSrcOffset * checkedElementSize;</span>
<span class="line-modified"> 151     Checked&lt;GC3Duint, RecordOverflow&gt; checkedlength(length);</span>
<span class="line-removed"> 152     Checked&lt;GC3Duint, RecordOverflow&gt; checkedByteLength = checkedlength * checkedElementSize;</span>
 153 
<span class="line-modified"> 154     if (checkedByteSrcOffset.hasOverflowed()</span>
<span class="line-modified"> 155         || checkedByteLength.hasOverflowed()</span>
<span class="line-modified"> 156         || checkedByteSrcOffset.unsafeGet() &gt; data.byteLength()</span>
<span class="line-modified"> 157         || checkedByteLength.unsafeGet() &gt; data.byteLength() - checkedByteSrcOffset.unsafeGet()) {</span>
<span class="line-modified"> 158         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;srcOffset or length is out of bounds&quot;);</span>
<span class="line-removed"> 159         return;</span>
<span class="line-removed"> 160     }</span>
 161 
<span class="line-modified"> 162     auto slice = Uint8Array::tryCreate(data.possiblySharedBuffer(), data.byteOffset() + checkedByteSrcOffset.unsafeGet(), checkedByteLength.unsafeGet());</span>
<span class="line-modified"> 163     if (!slice) {</span>
<span class="line-modified"> 164         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;bufferData&quot;, &quot;Could not create intermediate ArrayBufferView&quot;);</span>
<span class="line-modified"> 165         return;</span>




 166     }
<span class="line-modified"> 167     WebGLRenderingContextBase::bufferData(target, BufferDataSource(slice.get()), usage);</span>




 168 }
 169 
<span class="line-modified"> 170 void WebGL2RenderingContext::bufferSubData(GC3Denum target, long long offset, const ArrayBufferView&amp; data, GC3Duint srcOffset, GC3Duint length)</span>
 171 {
<span class="line-modified"> 172     auto optionalElementSize = arrayBufferViewElementSize(data);</span>
<span class="line-modified"> 173     if (!optionalElementSize) {</span>
<span class="line-modified"> 174         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bufferSubData&quot;, &quot;Invalid type of Array Buffer View&quot;);</span>
<span class="line-removed"> 175         return;</span>
 176     }
<span class="line-removed"> 177     auto elementSize = optionalElementSize.value();</span>
<span class="line-removed"> 178     Checked&lt;GC3Duint, RecordOverflow&gt; checkedElementSize(elementSize);</span>
 179 
<span class="line-modified"> 180     Checked&lt;GC3Duint, RecordOverflow&gt; checkedSrcOffset(srcOffset);</span>
<span class="line-modified"> 181     Checked&lt;GC3Duint, RecordOverflow&gt; checkedByteSrcOffset = checkedSrcOffset * checkedElementSize;</span>
<span class="line-modified"> 182     Checked&lt;GC3Duint, RecordOverflow&gt; checkedlength(length);</span>
<span class="line-modified"> 183     Checked&lt;GC3Duint, RecordOverflow&gt; checkedByteLength = checkedlength * checkedElementSize;</span>



 184 
 185     if (checkedByteSrcOffset.hasOverflowed()
 186         || checkedByteLength.hasOverflowed()
 187         || checkedByteSrcOffset.unsafeGet() &gt; data.byteLength()
 188         || checkedByteLength.unsafeGet() &gt; data.byteLength() - checkedByteSrcOffset.unsafeGet()) {
<span class="line-modified"> 189         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;srcOffset or length is out of bounds&quot;);</span>
<span class="line-modified"> 190         return;</span>
 191     }
 192 
<span class="line-modified"> 193     auto slice = Uint8Array::tryCreate(data.possiblySharedBuffer(), data.byteOffset() + checkedByteSrcOffset.unsafeGet(), checkedByteLength.unsafeGet());</span>
<span class="line-modified"> 194     if (!slice) {</span>
<span class="line-removed"> 195         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;bufferSubData&quot;, &quot;Could not create intermediate ArrayBufferView&quot;);</span>
<span class="line-removed"> 196         return;</span>
<span class="line-removed"> 197     }</span>
 198 
<span class="line-modified"> 199     WebGLRenderingContextBase::bufferSubData(target, offset, BufferDataSource(slice.get()));</span>



 200 }
 201 
<span class="line-modified"> 202 void WebGL2RenderingContext::copyBufferSubData(GC3Denum readTarget, GC3Denum writeTarget, GC3Dint64 readOffset, GC3Dint64 writeOffset, GC3Dint64 size)</span>






 203 {
 204     if (isContextLostOrPending())
 205         return;
<span class="line-modified"> 206     if ((readTarget == GraphicsContext3D::ELEMENT_ARRAY_BUFFER &amp;&amp; writeTarget != GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
<span class="line-modified"> 207         || (writeTarget == GraphicsContext3D::ELEMENT_ARRAY_BUFFER &amp;&amp; readTarget != GraphicsContext3D::ELEMENT_ARRAY_BUFFER)) {</span>
<span class="line-modified"> 208         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyBufferSubData&quot;, &quot;Either both targets need to be ELEMENT_ARRAY_BUFFER or neither should be ELEMENT_ARRAY_BUFFER.&quot;);</span>
 209         return;
 210     }
 211     if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0) {
<span class="line-modified"> 212         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;offset &lt; 0&quot;);</span>
 213         return;
 214     }
<span class="line-modified"> 215     RefPtr&lt;WebGLBuffer&gt; readBuffer = validateBufferDataParameters(&quot;copyBufferSubData&quot;, readTarget, GraphicsContext3D::STATIC_DRAW);</span>
<span class="line-modified"> 216     RefPtr&lt;WebGLBuffer&gt; writeBuffer = validateBufferDataParameters(&quot;copyBufferSubData&quot;, writeTarget, GraphicsContext3D::STATIC_DRAW);</span>
 217     if (!readBuffer || !writeBuffer) {
<span class="line-modified"> 218         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;Invalid readTarget or writeTarget&quot;);</span>
 219         return;
 220     }
 221 
<span class="line-modified"> 222     Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedReadOffset(readOffset);</span>
<span class="line-modified"> 223     Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedWriteOffset(writeOffset);</span>
<span class="line-modified"> 224     Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; checkedSize(size);</span>
 225     if (checkedReadOffset.hasOverflowed() || checkedWriteOffset.hasOverflowed() || checkedSize.hasOverflowed()) {
<span class="line-modified"> 226         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;Offset or size is too big&quot;);</span>
 227         return;
 228     }
 229 
 230     if (!writeBuffer-&gt;associateCopyBufferSubData(*readBuffer, checkedReadOffset.unsafeGet(), checkedWriteOffset.unsafeGet(), checkedSize.unsafeGet())) {
<span class="line-modified"> 231         this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;offset out of range&quot;);</span>
 232         return;
 233     }
 234 
 235     m_context-&gt;moveErrorsToSyntheticErrorList();
 236 #if PLATFORM(COCOA)
 237     m_context-&gt;copyBufferSubData(readTarget, writeTarget, checkedReadOffset.unsafeGet(), checkedWriteOffset.unsafeGet(), checkedSize.unsafeGet());
 238 #endif
 239     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
 240         // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
 241         writeBuffer-&gt;disassociateBufferData();
 242     }
 243 }
 244 
<span class="line-modified"> 245 void WebGL2RenderingContext::getBufferSubData(GC3Denum target, long long srcByteOffset, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; dstData, GC3Duint dstOffset, GC3Duint length)</span>
 246 {
 247     if (isContextLostOrPending())
 248         return;
<span class="line-modified"> 249     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContext3D::STATIC_DRAW);</span>
 250     if (!buffer) {
<span class="line-modified"> 251         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;No WebGLBuffer is bound to target&quot;);</span>
 252         return;
 253     }
 254 
 255     // FIXME: Implement &quot;If target is TRANSFORM_FEEDBACK_BUFFER, and any transform feedback object is currently active, an INVALID_OPERATION error is generated.&quot;
 256 
 257     if (!dstData) {
<span class="line-modified"> 258         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Null dstData&quot;);</span>
 259         return;
 260     }
 261 
<span class="line-modified"> 262     auto optionalElementSize = arrayBufferViewElementSize(*dstData);</span>
<span class="line-modified"> 263     if (!optionalElementSize) {</span>
<span class="line-removed"> 264         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Invalid type of Array Buffer View&quot;);</span>
 265         return;
 266     }
<span class="line-modified"> 267     auto elementSize = optionalElementSize.value();</span>

 268     auto dstDataLength = dstData-&gt;byteLength() / elementSize;
 269 
 270     if (dstOffset &gt; dstDataLength) {
<span class="line-modified"> 271         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;dstOffset is larger than the length of the destination buffer.&quot;);</span>
 272         return;
 273     }
 274 
<span class="line-modified"> 275     GC3Duint copyLength = length ? length : dstDataLength - dstOffset;</span>
 276 
<span class="line-modified"> 277     Checked&lt;GC3Duint, RecordOverflow&gt; checkedDstOffset(dstOffset);</span>
<span class="line-modified"> 278     Checked&lt;GC3Duint, RecordOverflow&gt; checkedCopyLength(copyLength);</span>
 279     auto checkedDestinationEnd = checkedDstOffset + checkedCopyLength;
 280     if (checkedDestinationEnd.hasOverflowed()) {
<span class="line-modified"> 281         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;dstOffset + copyLength is too high&quot;);</span>
 282         return;
 283     }
 284 
 285     if (checkedDestinationEnd.unsafeGet() &gt; dstDataLength) {
<span class="line-modified"> 286         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;end of written destination is past the end of the buffer&quot;);</span>
 287         return;
 288     }
 289 
 290     if (srcByteOffset &lt; 0) {
<span class="line-modified"> 291         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;srcByteOffset is less than 0&quot;);</span>
 292         return;
 293     }
 294 
<span class="line-modified"> 295     Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedSrcByteOffset(srcByteOffset);</span>
<span class="line-modified"> 296     Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedCopyLengthPtr(copyLength);</span>
<span class="line-modified"> 297     Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedElementSize(elementSize);</span>
 298     auto checkedSourceEnd = checkedSrcByteOffset + checkedCopyLengthPtr * checkedElementSize;
 299     if (checkedSourceEnd.hasOverflowed() || checkedSourceEnd.unsafeGet() &gt; buffer-&gt;byteLength()) {
<span class="line-modified"> 300         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Parameters would read outside the bounds of the source buffer&quot;);</span>
 301         return;
 302     }
 303 
 304     m_context-&gt;moveErrorsToSyntheticErrorList();
 305 #if PLATFORM(COCOA)
 306     // FIXME: Coalesce multiple getBufferSubData() calls to use a single map() call
<span class="line-modified"> 307     void* ptr = m_context-&gt;mapBufferRange(target, checkedSrcByteOffset.unsafeGet(), static_cast&lt;GC3Dsizeiptr&gt;(checkedCopyLengthPtr.unsafeGet() * checkedElementSize.unsafeGet()), GraphicsContext3D::MAP_READ_BIT);</span>
<span class="line-modified"> 308     memcpy(static_cast&lt;char*&gt;(dstData-&gt;baseAddress()) + dstData-&gt;byteOffset() + dstOffset * elementSize, ptr, copyLength * elementSize);</span>
<span class="line-modified"> 309     bool success = m_context-&gt;unmapBuffer(target);</span>
<span class="line-modified"> 310     ASSERT_UNUSED(success, success);</span>


 311 #endif
 312     m_context-&gt;moveErrorsToSyntheticErrorList();
 313 }
 314 
<span class="line-modified"> 315 void WebGL2RenderingContext::blitFramebuffer(GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dbitfield, GC3Denum)</span>
 316 {
 317     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] blitFramebuffer()&quot;);
 318 }
 319 
<span class="line-modified"> 320 void WebGL2RenderingContext::framebufferTextureLayer(GC3Denum, GC3Denum, WebGLTexture*, GC3Dint, GC3Dint)</span>
 321 {
 322     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] framebufferTextureLayer()&quot;);
 323 }
 324 
 325 #if !USE(OPENGL_ES)
<span class="line-modified"> 326 static bool isRenderableInternalformat(GC3Denum internalformat)</span>
 327 {
 328     // OpenGL ES 3: internalformat must be a color-renderable, depth-renderable, or stencil-renderable format, as shown in Table 1 below.
 329     switch (internalformat) {
<span class="line-modified"> 330     case GraphicsContext3D::R8:</span>
<span class="line-modified"> 331     case GraphicsContext3D::R8UI:</span>
<span class="line-modified"> 332     case GraphicsContext3D::R16UI:</span>
<span class="line-modified"> 333     case GraphicsContext3D::R16I:</span>
<span class="line-modified"> 334     case GraphicsContext3D::R32UI:</span>
<span class="line-modified"> 335     case GraphicsContext3D::R32I:</span>
<span class="line-modified"> 336     case GraphicsContext3D::RG8:</span>
<span class="line-modified"> 337     case GraphicsContext3D::RG8UI:</span>
<span class="line-modified"> 338     case GraphicsContext3D::RG8I:</span>
<span class="line-modified"> 339     case GraphicsContext3D::RG16UI:</span>
<span class="line-modified"> 340     case GraphicsContext3D::RG16I:</span>
<span class="line-modified"> 341     case GraphicsContext3D::RG32UI:</span>
<span class="line-modified"> 342     case GraphicsContext3D::RG32I:</span>
<span class="line-modified"> 343     case GraphicsContext3D::RGB8:</span>
<span class="line-modified"> 344     case GraphicsContext3D::RGB565:</span>
<span class="line-modified"> 345     case GraphicsContext3D::RGBA8:</span>
<span class="line-modified"> 346     case GraphicsContext3D::SRGB8_ALPHA8:</span>
<span class="line-modified"> 347     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified"> 348     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified"> 349     case GraphicsContext3D::RGB10_A2:</span>
<span class="line-modified"> 350     case GraphicsContext3D::RGBA8UI:</span>
<span class="line-modified"> 351     case GraphicsContext3D::RGBA8I:</span>
<span class="line-modified"> 352     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="line-modified"> 353     case GraphicsContext3D::RGBA16UI:</span>
<span class="line-modified"> 354     case GraphicsContext3D::RGBA16I:</span>
<span class="line-modified"> 355     case GraphicsContext3D::RGBA32I:</span>
<span class="line-modified"> 356     case GraphicsContext3D::RGBA32UI:</span>
<span class="line-modified"> 357     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified"> 358     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="line-modified"> 359     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified"> 360     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
<span class="line-modified"> 361     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
<span class="line-modified"> 362     case GraphicsContext3D::STENCIL_INDEX8:</span>
 363         return true;
 364     }
 365     return false;
 366 }
 367 #endif
 368 
<span class="line-modified"> 369 WebGLAny WebGL2RenderingContext::getInternalformatParameter(GC3Denum target, GC3Denum internalformat, GC3Denum pname)</span>
 370 {
 371     if (isContextLostOrPending())
 372         return nullptr;
 373 
<span class="line-modified"> 374     if (pname != GraphicsContext3D::SAMPLES) {</span>
<span class="line-modified"> 375         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid parameter name&quot;);</span>
 376         return nullptr;
 377     }
 378 
 379     int numValues = 0;
 380 #if USE(OPENGL_ES)
<span class="line-modified"> 381     m_context-&gt;getInternalformativ(target, internalformat, GraphicsContext3D::NUM_SAMPLE_COUNTS, 1, &amp;numValues);</span>
 382 
<span class="line-modified"> 383     GC3Dint params[numValues];</span>
 384     m_context-&gt;getInternalformativ(target, internalformat, pname, numValues, params);
 385 #else
 386     // On desktop OpenGL 4.1 or below we must emulate glGetInternalformativ.
 387 
 388     // GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER.
<span class="line-modified"> 389     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="line-modified"> 390         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid target&quot;);</span>
 391         return nullptr;
 392     }
 393 
 394     // GL_INVALID_ENUM is generated if internalformat is not color-, depth-, or stencil-renderable.
 395     if (!isRenderableInternalformat(internalformat)) {
<span class="line-modified"> 396         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid internal format&quot;);</span>
 397         return nullptr;
 398     }
 399 
<span class="line-modified"> 400     Vector&lt;GC3Dint&gt; samples;</span>
 401     // The way I understand this is that this will return a MINIMUM numSamples for all accepeted internalformats.
 402     // However, the true value of this on supported GL versions is gleaned via a getInternalformativ call that depends on internalformat.
<span class="line-modified"> 403     int numSamplesMask = getIntParameter(GraphicsContext3D::MAX_SAMPLES);</span>
 404 
 405     while (numSamplesMask &gt; 0) {
 406         samples.append(numSamplesMask);
 407         numSamplesMask = numSamplesMask &gt;&gt; 1;
 408     }
 409 
 410     // Since multisampling is not supported for signed and unsigned integer internal formats,
 411     // the value of GL_NUM_SAMPLE_COUNTS will be zero for such formats.
 412     numValues = isIntegerFormat(internalformat) ? 0 : samples.size();
<span class="line-modified"> 413     GC3Dint params[numValues];</span>
 414     for (size_t i = 0; i &lt; samples.size(); ++i)
 415         params[i] = samples[i];
 416 #endif
 417 
 418     return Int32Array::tryCreate(params, numValues);
 419 }
 420 
<span class="line-modified"> 421 void WebGL2RenderingContext::invalidateFramebuffer(GC3Denum, const Vector&lt;GC3Denum&gt;&amp;)</span>
 422 {
 423     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] invalidateFramebuffer()&quot;);
 424 }
 425 
<span class="line-modified"> 426 void WebGL2RenderingContext::invalidateSubFramebuffer(GC3Denum, const Vector&lt;GC3Denum&gt;&amp;, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei)</span>
 427 {
 428     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] invalidateSubFramebuffer()&quot;);
 429 }
 430 
<span class="line-modified"> 431 void WebGL2RenderingContext::readBuffer(GC3Denum)</span>
 432 {
 433     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] readBuffer()&quot;);
 434 }
 435 
<span class="line-modified"> 436 void WebGL2RenderingContext::renderbufferStorageMultisample(GC3Denum target, GC3Dsizei samples, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)</span>
 437 {
 438     // To be backward compatible with WebGL 1, also accepts internal format DEPTH_STENCIL,
 439     // which should be mapped to DEPTH24_STENCIL8 by implementations.
<span class="line-modified"> 440     if (internalformat == GraphicsContext3D::DEPTH_STENCIL)</span>
<span class="line-modified"> 441         internalformat = GraphicsContext3D::DEPTH24_STENCIL8;</span>
 442 
 443     // ES 3: GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than 0.
 444     if (isIntegerFormat(internalformat) &amp;&amp; samples &gt; 0) {
<span class="line-modified"> 445         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;renderbufferStorageMultisample&quot;, &quot;multisampling not supported for this format&quot;);</span>
 446         return;
 447     }
 448 
 449     switch (internalformat) {
<span class="line-modified"> 450     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified"> 451     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified"> 452     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="line-modified"> 453     case GraphicsContext3D::RGBA32I:</span>
<span class="line-modified"> 454     case GraphicsContext3D::RGBA32UI:</span>
<span class="line-modified"> 455     case GraphicsContext3D::RGBA16I:</span>
<span class="line-modified"> 456     case GraphicsContext3D::RGBA16UI:</span>
<span class="line-modified"> 457     case GraphicsContext3D::RGBA8:</span>
<span class="line-modified"> 458     case GraphicsContext3D::RGBA8I:</span>
<span class="line-modified"> 459     case GraphicsContext3D::RGBA8UI:</span>
<span class="line-modified"> 460     case GraphicsContext3D::RGB10_A2:</span>
<span class="line-modified"> 461     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="line-modified"> 462     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified"> 463     case GraphicsContext3D::RG32I:</span>
<span class="line-modified"> 464     case GraphicsContext3D::RG32UI:</span>
<span class="line-modified"> 465     case GraphicsContext3D::RG16I:</span>
<span class="line-modified"> 466     case GraphicsContext3D::RG16UI:</span>
<span class="line-modified"> 467     case GraphicsContext3D::RG8:</span>
<span class="line-modified"> 468     case GraphicsContext3D::RG8I:</span>
<span class="line-modified"> 469     case GraphicsContext3D::RG8UI:</span>
<span class="line-modified"> 470     case GraphicsContext3D::R32I:</span>
<span class="line-modified"> 471     case GraphicsContext3D::R32UI:</span>
<span class="line-modified"> 472     case GraphicsContext3D::R16I:</span>
<span class="line-modified"> 473     case GraphicsContext3D::R16UI:</span>
<span class="line-modified"> 474     case GraphicsContext3D::R8:</span>
<span class="line-modified"> 475     case GraphicsContext3D::R8I:</span>
<span class="line-modified"> 476     case GraphicsContext3D::R8UI:</span>
<span class="line-modified"> 477     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified"> 478     case GraphicsContext3D::RGB565:</span>
<span class="line-modified"> 479     case GraphicsContext3D::RGB8:</span>
<span class="line-modified"> 480     case GraphicsContext3D::STENCIL_INDEX8:</span>
<span class="line-modified"> 481     case GraphicsContext3D::SRGB8_ALPHA8:</span>
 482         m_context-&gt;renderbufferStorageMultisample(target, samples, internalformat, width, height);
 483         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
 484         m_renderbufferBinding-&gt;setIsValid(true);
 485         m_renderbufferBinding-&gt;setSize(width, height);
 486         break;
<span class="line-modified"> 487     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
<span class="line-modified"> 488     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
 489         if (!isDepthStencilSupported()) {
<span class="line-modified"> 490             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
 491             return;
 492         }
 493         m_context-&gt;renderbufferStorageMultisample(target, samples, internalformat, width, height);
 494         m_renderbufferBinding-&gt;setSize(width, height);
 495         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
 496         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
 497         break;
 498     default:
<span class="line-modified"> 499         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
 500         return;
 501     }
 502     applyStencilTest();
 503 }
 504 
<span class="line-modified"> 505 bool WebGL2RenderingContext::validateTexStorageFuncParameters(GC3Denum target, GC3Dsizei levels, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, const char* functionName)</span>
 506 {
 507     if (width &lt; 0 || height &lt; 0) {
<span class="line-modified"> 508         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
 509         return false;
 510     }
 511 
 512     if (width &gt; m_maxTextureSize || height &gt; m_maxTextureSize) {
<span class="line-modified"> 513         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;texture dimensions are larger than the maximum texture size&quot;);</span>
 514         return false;
 515     }
 516 
<span class="line-modified"> 517     if (target == GraphicsContext3D::TEXTURE_CUBE_MAP) {</span>
 518         if (width != height) {
<span class="line-modified"> 519             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);</span>
 520             return false;
 521         }
<span class="line-modified"> 522     } else if (target != GraphicsContext3D::TEXTURE_2D) {</span>
<span class="line-modified"> 523         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
 524         return false;
 525     }
 526 
 527     if (levels &lt; 0 || levels &gt; m_maxTextureLevel) {
<span class="line-modified"> 528         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;number of levels is out of bounds&quot;);</span>
 529         return false;
 530     }
 531 
 532     switch (internalFormat) {
<span class="line-modified"> 533     case GraphicsContext3D::R8:</span>
<span class="line-modified"> 534     case GraphicsContext3D::R8_SNORM:</span>
<span class="line-modified"> 535     case GraphicsContext3D::R16F:</span>
<span class="line-modified"> 536     case GraphicsContext3D::R32F:</span>
<span class="line-modified"> 537     case GraphicsContext3D::R8UI:</span>
<span class="line-modified"> 538     case GraphicsContext3D::R8I:</span>
<span class="line-modified"> 539     case GraphicsContext3D::R16UI:</span>
<span class="line-modified"> 540     case GraphicsContext3D::R16I:</span>
<span class="line-modified"> 541     case GraphicsContext3D::R32UI:</span>
<span class="line-modified"> 542     case GraphicsContext3D::R32I:</span>
<span class="line-modified"> 543     case GraphicsContext3D::RG8:</span>
<span class="line-modified"> 544     case GraphicsContext3D::RG8_SNORM:</span>
<span class="line-modified"> 545     case GraphicsContext3D::RG16F:</span>
<span class="line-modified"> 546     case GraphicsContext3D::RG32F:</span>
<span class="line-modified"> 547     case GraphicsContext3D::RG8UI:</span>
<span class="line-modified"> 548     case GraphicsContext3D::RG8I:</span>
<span class="line-modified"> 549     case GraphicsContext3D::RG16UI:</span>
<span class="line-modified"> 550     case GraphicsContext3D::RG16I:</span>
<span class="line-modified"> 551     case GraphicsContext3D::RG32UI:</span>
<span class="line-modified"> 552     case GraphicsContext3D::RG32I:</span>
<span class="line-modified"> 553     case GraphicsContext3D::RGB8:</span>
<span class="line-modified"> 554     case GraphicsContext3D::SRGB8:</span>
<span class="line-modified"> 555     case GraphicsContext3D::RGB565:</span>
<span class="line-modified"> 556     case GraphicsContext3D::RGB8_SNORM:</span>
<span class="line-modified"> 557     case GraphicsContext3D::R11F_G11F_B10F:</span>
<span class="line-modified"> 558     case GraphicsContext3D::RGB9_E5:</span>
<span class="line-modified"> 559     case GraphicsContext3D::RGB16F:</span>
<span class="line-modified"> 560     case GraphicsContext3D::RGB32F:</span>
<span class="line-modified"> 561     case GraphicsContext3D::RGB8UI:</span>
<span class="line-modified"> 562     case GraphicsContext3D::RGB8I:</span>
<span class="line-modified"> 563     case GraphicsContext3D::RGB16UI:</span>
<span class="line-modified"> 564     case GraphicsContext3D::RGB16I:</span>
<span class="line-modified"> 565     case GraphicsContext3D::RGB32UI:</span>
<span class="line-modified"> 566     case GraphicsContext3D::RGB32I:</span>
<span class="line-modified"> 567     case GraphicsContext3D::RGBA8:</span>
<span class="line-modified"> 568     case GraphicsContext3D::SRGB8_ALPHA8:</span>
<span class="line-modified"> 569     case GraphicsContext3D::RGBA8_SNORM:</span>
<span class="line-modified"> 570     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified"> 571     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified"> 572     case GraphicsContext3D::RGB10_A2:</span>
<span class="line-modified"> 573     case GraphicsContext3D::RGBA16F:</span>
<span class="line-modified"> 574     case GraphicsContext3D::RGBA32F:</span>
<span class="line-modified"> 575     case GraphicsContext3D::RGBA8UI:</span>
<span class="line-modified"> 576     case GraphicsContext3D::RGBA8I:</span>
<span class="line-modified"> 577     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="line-modified"> 578     case GraphicsContext3D::RGBA16UI:</span>
<span class="line-modified"> 579     case GraphicsContext3D::RGBA16I:</span>
<span class="line-modified"> 580     case GraphicsContext3D::RGBA32I:</span>
<span class="line-modified"> 581     case GraphicsContext3D::RGBA32UI:</span>
<span class="line-modified"> 582     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified"> 583     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="line-modified"> 584     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified"> 585     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
<span class="line-modified"> 586     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
 587         break;
 588     default:
<span class="line-modified"> 589         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;Unknown internalFormat&quot;);</span>
 590         return false;
 591     }
 592 
 593     return true;
 594 }
 595 
<span class="line-modified"> 596 void WebGL2RenderingContext::texStorage2D(GC3Denum target, GC3Dsizei levels, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height)</span>
 597 {
 598     if (isContextLostOrPending())
 599         return;
 600 
 601     auto texture = validateTextureBinding(&quot;texStorage2D&quot;, target, false);
 602     if (!texture)
 603         return;
 604 
 605     if (!validateTexStorageFuncParameters(target, levels, internalFormat, width, height, &quot;texStorage2D&quot;))
 606         return;
 607 
 608     if (!validateNPOTTextureLevel(width, height, levels, &quot;texStorage2D&quot;))
 609         return;
 610 
 611     if (texture-&gt;immutable()) {
<span class="line-modified"> 612         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;texStorage2D&quot;, &quot;texStorage2D already called on this texture&quot;);</span>
 613         return;
 614     }
 615     texture-&gt;setImmutable();
 616 
 617     m_context-&gt;texStorage2D(target, levels, internalFormat, width, height);
 618 
 619     {
<span class="line-modified"> 620         GC3Denum format;</span>
<span class="line-modified"> 621         GC3Denum type;</span>
<span class="line-modified"> 622         if (!GraphicsContext3D::possibleFormatAndTypeForInternalFormat(internalFormat, format, type)) {</span>
<span class="line-modified"> 623             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texStorage2D&quot;, &quot;Texture has unknown internal format&quot;);</span>
 624             return;
 625         }
 626 
<span class="line-modified"> 627         GC3Dsizei levelWidth = width;</span>
<span class="line-modified"> 628         GC3Dsizei levelHeight = height;</span>
 629 
 630         unsigned size;
<span class="line-modified"> 631         GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);</span>
<span class="line-modified"> 632         if (error != GraphicsContext3D::NO_ERROR) {</span>
 633             synthesizeGLError(error, &quot;texStorage2D&quot;, &quot;bad dimensions&quot;);
 634             return;
 635         }
 636 
 637         Vector&lt;char&gt; data(size);
 638         memset(data.data(), 0, size);
 639 
<span class="line-modified"> 640         for (GC3Dsizei level = 0; level &lt; levels; ++level) {</span>
<span class="line-modified"> 641             if (target == GraphicsContext3D::TEXTURE_CUBE_MAP) {</span>
<span class="line-modified"> 642                 m_context-&gt;texSubImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 643                 m_context-&gt;texSubImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 644                 m_context-&gt;texSubImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 645                 m_context-&gt;texSubImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 646                 m_context-&gt;texSubImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 647                 m_context-&gt;texSubImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
 648             } else
 649                 m_context-&gt;texSubImage2D(target, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 650             levelWidth = std::max(1, levelWidth / 2);
 651             levelHeight = std::max(1, levelHeight / 2);
 652         }
 653     }
 654 
<span class="line-modified"> 655     for (GC3Dsizei level = 0; level &lt; levels; ++level) {</span>
<span class="line-modified"> 656         if (target == GraphicsContext3D::TEXTURE_CUBE_MAP) {</span>
<span class="line-modified"> 657             texture-&gt;setLevelInfo(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
<span class="line-modified"> 658             texture-&gt;setLevelInfo(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
<span class="line-modified"> 659             texture-&gt;setLevelInfo(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
<span class="line-modified"> 660             texture-&gt;setLevelInfo(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
<span class="line-modified"> 661             texture-&gt;setLevelInfo(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
<span class="line-modified"> 662             texture-&gt;setLevelInfo(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
 663         } else
<span class="line-modified"> 664             texture-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
 665     }
 666 }
 667 
<span class="line-modified"> 668 void WebGL2RenderingContext::texStorage3D(GC3Denum, GC3Dsizei, GC3Denum, GC3Dsizei, GC3Dsizei, GC3Dsizei)</span>
 669 {
 670     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texStorage3D()&quot;);
 671 }
 672 
<span class="line-modified"> 673 void WebGL2RenderingContext::texImage2D(GC3Denum, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Denum, GC3Denum, GC3Dint64)</span>
 674 {
<span class="line-modified"> 675     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage2D()&quot;);</span>

 676 }
 677 
<span class="line-modified"> 678 void WebGL2RenderingContext::texImage2D(GC3Denum, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Denum, GC3Denum, TexImageSource&amp;&amp;)</span>
 679 {
<span class="line-modified"> 680     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage2D()&quot;);</span>


 681 }
 682 
<span class="line-modified"> 683 void WebGL2RenderingContext::texImage2D(GC3Denum, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Denum, GC3Denum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GC3Duint)</span>
 684 {
<span class="line-modified"> 685     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage2D()&quot;);</span>
<span class="line-modified"> 686 }</span>
 687 
<span class="line-modified"> 688 void WebGL2RenderingContext::texImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Denum, GC3Denum, GC3Dint64)</span>
<span class="line-modified"> 689 {</span>
<span class="line-modified"> 690     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D()&quot;);</span>












 691 }
 692 
<span class="line-modified"> 693 void WebGL2RenderingContext::texImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Denum, GC3Denum, TexImageSource&amp;&amp;)</span>
 694 {
<span class="line-modified"> 695     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D()&quot;);</span>





 696 }
 697 
<span class="line-modified"> 698 void WebGL2RenderingContext::texImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Denum, GC3Denum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;)</span>
 699 {
<span class="line-modified"> 700     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D()&quot;);</span>
 701 }
 702 
<span class="line-modified"> 703 void WebGL2RenderingContext::texImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Denum, GC3Denum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GC3Duint)</span>
 704 {
<span class="line-modified"> 705     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D()&quot;);</span>

 706 }
 707 
<span class="line-modified"> 708 void WebGL2RenderingContext::texSubImage2D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Denum, GC3Denum, GC3Dint64)</span>
 709 {
<span class="line-modified"> 710     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage2D()&quot;);</span>
 711 }
 712 
<span class="line-modified"> 713 void WebGL2RenderingContext::texSubImage2D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Denum, GC3Denum, TexImageSource&amp;&amp;)</span>
 714 {
<span class="line-modified"> 715     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage2D()&quot;);</span>
 716 }
 717 
<span class="line-modified"> 718 void WebGL2RenderingContext::texSubImage2D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Denum, GC3Denum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GC3Duint)</span>
 719 {
<span class="line-modified"> 720     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage2D()&quot;);</span>
 721 }
 722 
<span class="line-modified"> 723 void WebGL2RenderingContext::texSubImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Denum, GC3Denum, GC3Dint64)</span>
 724 {
<span class="line-modified"> 725     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D()&quot;);</span>

 726 }
 727 
<span class="line-modified"> 728 void WebGL2RenderingContext::texSubImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Denum, GC3Denum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GC3Duint)</span>
 729 {
<span class="line-modified"> 730     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D()&quot;);</span>





 731 }
 732 
<span class="line-modified"> 733 void WebGL2RenderingContext::texSubImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Denum, GC3Denum, TexImageSource&amp;&amp;)</span>
 734 {
<span class="line-modified"> 735     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D()&quot;);</span>
 736 }
 737 
<span class="line-modified"> 738 void WebGL2RenderingContext::copyTexSubImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei)</span>
 739 {
<span class="line-modified"> 740     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] copyTexSubImage3D()&quot;);</span>
 741 }
 742 
<span class="line-modified"> 743 void WebGL2RenderingContext::compressedTexImage2D(GC3Denum, GC3Dint, GC3Denum, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Dsizei, GC3Dint64)</span>
 744 {
<span class="line-modified"> 745     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage2D()&quot;);</span>

 746 }
 747 
<span class="line-modified"> 748 void WebGL2RenderingContext::compressedTexImage2D(GC3Denum, GC3Dint, GC3Denum, GC3Dsizei, GC3Dsizei, GC3Dint, ArrayBufferView&amp;, GC3Duint, GC3Duint)</span>
 749 {
<span class="line-modified"> 750     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage2D()&quot;);</span>
 751 }
 752 
<span class="line-modified"> 753 void WebGL2RenderingContext::compressedTexImage3D(GC3Denum, GC3Dint, GC3Denum, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Dint, GC3Dsizei, GC3Dint64)</span>
 754 {
<span class="line-modified"> 755     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage3D()&quot;);</span>
 756 }
 757 
<span class="line-modified"> 758 void WebGL2RenderingContext::compressedTexImage3D(GC3Denum, GC3Dint, GC3Denum, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Dint, ArrayBufferView&amp;, GC3Duint, GC3Duint)</span>
 759 {
<span class="line-modified"> 760     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage3D()&quot;);</span>
 761 }
 762 
<span class="line-modified"> 763 void WebGL2RenderingContext::compressedTexSubImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Denum, GC3Dsizei, GC3Dint64)</span>
 764 {
<span class="line-modified"> 765     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage3D()&quot;);</span>
 766 }
 767 
<span class="line-modified"> 768 void WebGL2RenderingContext::compressedTexSubImage3D(GC3Denum, GC3Dint, GC3Dint, GC3Dint, GC3Dint, GC3Dsizei, GC3Dsizei, GC3Dsizei, GC3Denum, ArrayBufferView&amp;, GC3Duint, GC3Duint)</span>
 769 {
<span class="line-modified"> 770     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage3D()&quot;);</span>
 771 }
 772 
<span class="line-modified"> 773 GC3Dint WebGL2RenderingContext::getFragDataLocation(WebGLProgram&amp;, const String&amp;)</span>
 774 {
 775     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getFragDataLocation()&quot;);
 776     return 0;
 777 }
 778 
<span class="line-modified"> 779 void WebGL2RenderingContext::uniform1ui(WebGLUniformLocation*, GC3Duint)</span>
 780 {
 781     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1ui()&quot;);
 782 }
 783 
<span class="line-modified"> 784 void WebGL2RenderingContext::uniform2ui(WebGLUniformLocation*, GC3Duint, GC3Duint)</span>
 785 {
 786     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2ui()&quot;);
 787 }
 788 
<span class="line-modified"> 789 void WebGL2RenderingContext::uniform3ui(WebGLUniformLocation*, GC3Duint, GC3Duint, GC3Duint)</span>
 790 {
 791     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3ui()&quot;);
 792 }
 793 
<span class="line-modified"> 794 void WebGL2RenderingContext::uniform4ui(WebGLUniformLocation*, GC3Duint, GC3Duint, GC3Duint, GC3Duint)</span>
 795 {
 796     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4ui()&quot;);
 797 }
 798 
<span class="line-modified"> 799 void WebGL2RenderingContext::uniform1uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 800 {
 801     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1uiv()&quot;);
 802 }
 803 
<span class="line-modified"> 804 void WebGL2RenderingContext::uniform2uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 805 {
 806     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2uiv()&quot;);
 807 }
 808 
<span class="line-modified"> 809 void WebGL2RenderingContext::uniform3uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 810 {
 811     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3uiv()&quot;);
 812 }
 813 
<span class="line-modified"> 814 void WebGL2RenderingContext::uniform4uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 815 {
 816     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4uiv()&quot;);
 817 }
 818 
<span class="line-modified"> 819 void WebGL2RenderingContext::uniformMatrix2x3fv(WebGLUniformLocation*, GC3Dboolean, Float32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 820 {
 821     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2x3fv()&quot;);
 822 }
 823 
<span class="line-modified"> 824 void WebGL2RenderingContext::uniformMatrix3x2fv(WebGLUniformLocation*, GC3Dboolean, Float32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 825 {
 826     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3x2fv()&quot;);
 827 }
 828 
<span class="line-modified"> 829 void WebGL2RenderingContext::uniformMatrix2x4fv(WebGLUniformLocation*, GC3Dboolean, Float32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 830 {
 831     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2x4fv()&quot;);
 832 }
 833 
<span class="line-modified"> 834 void WebGL2RenderingContext::uniformMatrix4x2fv(WebGLUniformLocation*, GC3Dboolean, Float32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 835 {
 836     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4x2fv()&quot;);
 837 }
 838 
<span class="line-modified"> 839 void WebGL2RenderingContext::uniformMatrix3x4fv(WebGLUniformLocation*, GC3Dboolean, Float32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 840 {
 841     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3x4fv()&quot;);
 842 }
 843 
<span class="line-modified"> 844 void WebGL2RenderingContext::uniformMatrix4x3fv(WebGLUniformLocation*, GC3Dboolean, Float32List&amp;&amp;, GC3Duint, GC3Duint)</span>
 845 {
 846     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4x3fv()&quot;);
 847 }
 848 
<span class="line-modified"> 849 void WebGL2RenderingContext::vertexAttribI4i(GC3Duint, GC3Dint, GC3Dint, GC3Dint, GC3Dint)</span>
 850 {
 851     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4i()&quot;);
 852 }
 853 
<span class="line-modified"> 854 void WebGL2RenderingContext::vertexAttribI4iv(GC3Duint, Int32List&amp;&amp;)</span>
 855 {
 856     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4iv()&quot;);
 857 }
 858 
<span class="line-modified"> 859 void WebGL2RenderingContext::vertexAttribI4ui(GC3Duint, GC3Duint, GC3Duint, GC3Duint, GC3Duint)</span>
 860 {
 861     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4ui()&quot;);
 862 }
 863 
<span class="line-modified"> 864 void WebGL2RenderingContext::vertexAttribI4uiv(GC3Duint, Uint32List&amp;&amp;)</span>
 865 {
 866     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4uiv()&quot;);
 867 }
 868 
<span class="line-modified"> 869 void WebGL2RenderingContext::vertexAttribIPointer(GC3Duint, GC3Dint, GC3Denum, GC3Dsizei, GC3Dint64)</span>
 870 {
<span class="line-modified"> 871     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribIPointer()&quot;);</span>



 872 }
 873 
<span class="line-modified"> 874 void WebGL2RenderingContext::clear(GC3Dbitfield mask)</span>
 875 {
 876     if (isContextLostOrPending())
 877         return;
<span class="line-modified"> 878     if (mask &amp; ~(GraphicsContext3D::COLOR_BUFFER_BIT | GraphicsContext3D::DEPTH_BUFFER_BIT | GraphicsContext3D::STENCIL_BUFFER_BIT)) {</span>
<span class="line-modified"> 879         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);</span>
 880         return;
 881     }
<span class="line-modified"> 882     if (m_framebufferBinding &amp;&amp; (mask &amp; GraphicsContext3D::COLOR_BUFFER_BIT) &amp;&amp; isIntegerFormat(m_framebufferBinding-&gt;getColorBufferFormat())) {</span>
<span class="line-modified"> 883         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;clear&quot;, &quot;cannot clear an integer buffer&quot;);</span>

 884         return;
 885     }
<span class="line-modified"> 886     const char* reason = &quot;framebuffer incomplete&quot;;</span>
<span class="line-modified"> 887     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="line-removed"> 888         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);</span>
 889         return;
 890     }
 891     if (!clearIfComposited(mask))
 892         m_context-&gt;clear(mask);
 893     markContextChangedAndNotifyCanvasObserver();
 894 }
 895 
<span class="line-modified"> 896 void WebGL2RenderingContext::vertexAttribDivisor(GC3Duint index, GC3Duint divisor)</span>
 897 {
 898     if (isContextLostOrPending())
 899         return;
 900 
 901     WebGLRenderingContextBase::vertexAttribDivisor(index, divisor);
 902 }
 903 
<span class="line-modified"> 904 void WebGL2RenderingContext::drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei instanceCount)</span>
 905 {
 906     if (isContextLostOrPending())
 907         return;
 908 
 909     WebGLRenderingContextBase::drawArraysInstanced(mode, first, count, instanceCount);
 910 }
 911 
<span class="line-modified"> 912 void WebGL2RenderingContext::drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dint64 offset, GC3Dsizei instanceCount)</span>
 913 {
 914     if (isContextLostOrPending())
 915         return;
 916 
 917     WebGLRenderingContextBase::drawElementsInstanced(mode, count, type, offset, instanceCount);
 918 }
 919 
<span class="line-modified"> 920 void WebGL2RenderingContext::drawRangeElements(GC3Denum, GC3Duint, GC3Duint, GC3Dsizei, GC3Denum, GC3Dint64)</span>
 921 {
 922     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] drawRangeElements()&quot;);
 923 }
 924 
<span class="line-modified"> 925 void WebGL2RenderingContext::drawBuffers(const Vector&lt;GC3Denum&gt;&amp; buffers)</span>
 926 {
 927     if (isContextLost())
 928         return;
<span class="line-modified"> 929     GC3Dsizei n = buffers.size();</span>
<span class="line-modified"> 930     const GC3Denum* bufs = buffers.data();</span>
 931     if (!m_framebufferBinding) {
 932         if (n != 1) {
<span class="line-modified"> 933             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffers&quot;, &quot;more than one buffer&quot;);</span>
 934             return;
 935         }
<span class="line-modified"> 936         if (bufs[0] != GraphicsContext3D::BACK &amp;&amp; bufs[0] != GraphicsContext3D::NONE) {</span>
<span class="line-modified"> 937             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffers&quot;, &quot;BACK or NONE&quot;);</span>
 938             return;
 939         }
 940         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified"> 941         GC3Denum value = (bufs[0] == GraphicsContext3D::BACK) ? GraphicsContext3D::COLOR_ATTACHMENT0 : GraphicsContext3D::NONE;</span>
<span class="line-modified"> 942         graphicsContext3D()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);</span>
 943         setBackDrawBuffer(bufs[0]);
 944     } else {
 945         if (n &gt; getMaxDrawBuffers()) {
<span class="line-modified"> 946             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffers&quot;, &quot;more than max draw buffers&quot;);</span>
 947             return;
 948         }
<span class="line-modified"> 949         for (GC3Dsizei i = 0; i &lt; n; ++i) {</span>
<span class="line-modified"> 950             if (bufs[i] != GraphicsContext3D::NONE &amp;&amp; bufs[i] != static_cast&lt;GC3Denum&gt;(GraphicsContext3D::COLOR_ATTACHMENT0 + i)) {</span>
<span class="line-modified"> 951                 synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffers&quot;, &quot;COLOR_ATTACHMENTi or NONE&quot;);</span>
 952                 return;
 953             }
 954         }
 955         m_framebufferBinding-&gt;drawBuffers(buffers);
 956     }
 957 }
 958 
<span class="line-modified"> 959 void WebGL2RenderingContext::clearBufferiv(GC3Denum buffer, GC3Dint drawbuffer, Int32List&amp;&amp;, GC3Duint)</span>
 960 {
 961     switch (buffer) {
<span class="line-modified"> 962     case GraphicsContext3D::COLOR:</span>
 963         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
<span class="line-modified"> 964             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clearBufferiv&quot;, &quot;buffer index out of range&quot;);</span>
 965             return;
 966         }
 967         // TODO: Call clearBufferiv, requires gl3.h and ES3/gl.h
 968         break;
<span class="line-modified"> 969     case GraphicsContext3D::STENCIL:</span>
 970         if (drawbuffer) {
<span class="line-modified"> 971             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clearBufferiv&quot;, &quot;buffer index must be 0&quot;);</span>
 972             return;
 973         }
 974         // TODO: Call clearBufferiv, requires gl3.h and ES3/gl.h
 975         break;
<span class="line-modified"> 976     case GraphicsContext3D::DEPTH:</span>
<span class="line-modified"> 977     case GraphicsContext3D::DEPTH_STENCIL:</span>
 978     default:
<span class="line-modified"> 979         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;clearBufferiv&quot;, &quot;buffer argument must be COLOR or STENCIL&quot;);</span>
 980         break;
 981     }
 982 }
 983 
<span class="line-modified"> 984 void WebGL2RenderingContext::clearBufferuiv(GC3Denum buffer, GC3Dint drawbuffer, Uint32List&amp;&amp;, GC3Duint)</span>
 985 {
 986     switch (buffer) {
<span class="line-modified"> 987     case GraphicsContext3D::COLOR:</span>
 988         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
<span class="line-modified"> 989             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clearBufferuiv&quot;, &quot;buffer index out of range&quot;);</span>
 990             return;
 991         }
 992         // TODO: Call clearBufferuiv, requires gl3.h and ES3/gl.h
 993         break;
<span class="line-modified"> 994     case GraphicsContext3D::DEPTH:</span>
<span class="line-modified"> 995     case GraphicsContext3D::STENCIL:</span>
<span class="line-modified"> 996     case GraphicsContext3D::DEPTH_STENCIL:</span>
 997     default:
<span class="line-modified"> 998         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;clearBufferuiv&quot;, &quot;buffer argument must be COLOR&quot;);</span>
 999         break;
1000     }
1001 }
1002 
<span class="line-modified">1003 void WebGL2RenderingContext::clearBufferfv(GC3Denum buffer, GC3Dint drawbuffer, Float32List&amp;&amp;, GC3Duint)</span>
1004 {
1005     switch (buffer) {
<span class="line-modified">1006     case GraphicsContext3D::COLOR:</span>
1007         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
<span class="line-modified">1008             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index out of range&quot;);</span>
1009             return;
1010         }
1011         // TODO: Call clearBufferfv, requires gl3.h and ES3/gl.h
1012         break;
<span class="line-modified">1013     case GraphicsContext3D::DEPTH:</span>
1014         if (drawbuffer) {
<span class="line-modified">1015             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index must be 0&quot;);</span>
1016             return;
1017         }
1018         // TODO: Call clearBufferfv, requires gl3.h and ES3/gl.h
1019         break;
<span class="line-modified">1020     case GraphicsContext3D::STENCIL:</span>
<span class="line-modified">1021     case GraphicsContext3D::DEPTH_STENCIL:</span>
1022     default:
<span class="line-modified">1023         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;clearBufferfv&quot;, &quot;buffer argument must be COLOR OR DEPTH&quot;);</span>
1024         break;
1025     }
1026 }
1027 
<span class="line-modified">1028 void WebGL2RenderingContext::clearBufferfi(GC3Denum buffer, GC3Dint drawbuffer, GC3Dfloat, GC3Dint)</span>
1029 {
1030     switch (buffer) {
<span class="line-modified">1031     case GraphicsContext3D::DEPTH_STENCIL:</span>
1032         if (drawbuffer) {
<span class="line-modified">1033             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index must be 0&quot;);</span>
1034             return;
1035         }
1036         // TODO: Call clearBufferfi, requires gl3.h and ES3/gl.h
1037         break;
<span class="line-modified">1038     case GraphicsContext3D::COLOR:</span>
<span class="line-modified">1039     case GraphicsContext3D::DEPTH:</span>
<span class="line-modified">1040     case GraphicsContext3D::STENCIL:</span>
1041     default:
<span class="line-modified">1042         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;clearBufferfv&quot;, &quot;buffer argument must be DEPTH_STENCIL&quot;);</span>
1043         break;
1044     }
1045 }
1046 
1047 RefPtr&lt;WebGLQuery&gt; WebGL2RenderingContext::createQuery()
1048 {
<span class="line-modified">1049     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] createQuery()&quot;);</span>
<span class="line-modified">1050     return nullptr;</span>




1051 }
1052 
1053 void WebGL2RenderingContext::deleteQuery(WebGLQuery*)
1054 {
1055     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteQuery()&quot;);
1056 }
1057 
<span class="line-modified">1058 GC3Dboolean WebGL2RenderingContext::isQuery(WebGLQuery*)</span>
1059 {
1060     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isQuery()&quot;);
1061     return false;
1062 }
1063 
<span class="line-modified">1064 void WebGL2RenderingContext::beginQuery(GC3Denum, WebGLQuery&amp;)</span>
1065 {
<span class="line-modified">1066     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] beginQuery()&quot;);</span>















1067 }
1068 
<span class="line-modified">1069 void WebGL2RenderingContext::endQuery(GC3Denum)</span>
1070 {
<span class="line-modified">1071     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] endQuery()&quot;);</span>
















1072 }
1073 
<span class="line-modified">1074 RefPtr&lt;WebGLQuery&gt; WebGL2RenderingContext::getQuery(GC3Denum, GC3Denum)</span>
1075 {
1076     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getquery()&quot;);
1077     return nullptr;
1078 }
1079 
<span class="line-modified">1080 WebGLAny WebGL2RenderingContext::getQueryParameter(WebGLQuery&amp;, GC3Denum)</span>
1081 {
<span class="line-modified">1082     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getQueryParameter)&quot;);</span>
<span class="line-modified">1083     return nullptr;</span>















1084 }
1085 
1086 RefPtr&lt;WebGLSampler&gt; WebGL2RenderingContext::createSampler()
1087 {
<span class="line-modified">1088     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] createSampler()&quot;);</span>
<span class="line-modified">1089     return nullptr;</span>




1090 }
1091 
<span class="line-modified">1092 void WebGL2RenderingContext::deleteSampler(WebGLSampler*)</span>
1093 {
<span class="line-modified">1094     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteSampler()&quot;);</span>











1095 }
1096 
<span class="line-modified">1097 GC3Dboolean WebGL2RenderingContext::isSampler(WebGLSampler*)</span>
1098 {
<span class="line-modified">1099     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isSampler()&quot;);</span>
<span class="line-modified">1100     return false;</span>


1101 }
1102 
<span class="line-modified">1103 void WebGL2RenderingContext::bindSampler(GC3Duint, WebGLSampler*)</span>
1104 {
<span class="line-modified">1105     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] bindSampler()&quot;);</span>









1106 }
1107 
<span class="line-modified">1108 void WebGL2RenderingContext::samplerParameteri(WebGLSampler&amp;, GC3Denum, GC3Dint)</span>
1109 {
<span class="line-modified">1110     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] samplerParameteri()&quot;);</span>



1111 }
1112 
<span class="line-modified">1113 void WebGL2RenderingContext::samplerParameterf(WebGLSampler&amp;, GC3Denum, GC3Dfloat)</span>
1114 {
<span class="line-modified">1115     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] samplerParameterf()&quot;);</span>



1116 }
1117 
<span class="line-modified">1118 WebGLAny WebGL2RenderingContext::getSamplerParameter(WebGLSampler&amp;, GC3Denum)</span>
1119 {
<span class="line-modified">1120     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getSamplerParameter()&quot;);</span>
<span class="line-modified">1121     return nullptr;</span>























1122 }
1123 
<span class="line-modified">1124 RefPtr&lt;WebGLSync&gt; WebGL2RenderingContext::fenceSync(GC3Denum, GC3Dbitfield)</span>
1125 {
1126     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] fenceSync()&quot;);
1127     return nullptr;
1128 }
1129 
<span class="line-modified">1130 GC3Dboolean WebGL2RenderingContext::isSync(WebGLSync*)</span>
1131 {
1132     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isSync()&quot;);
1133     return false;
1134 }
1135 
1136 void WebGL2RenderingContext::deleteSync(WebGLSync*)
1137 {
1138     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteSync()&quot;);
1139 }
1140 
<span class="line-modified">1141 GC3Denum WebGL2RenderingContext::clientWaitSync(WebGLSync&amp;, GC3Dbitfield, GC3Duint64)</span>
1142 {
1143     // Note: Do not implement this function without consulting webkit-dev and WebGL
1144     // reviewers beforehand. Apple folks, see &lt;rdar://problem/36666458&gt;.
1145     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] clientWaitSync()&quot;);
1146     return 0;
1147 }
1148 
<span class="line-modified">1149 void WebGL2RenderingContext::waitSync(WebGLSync&amp;, GC3Dbitfield, GC3Dint64)</span>
1150 {
1151     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] waitSync()&quot;);
1152 }
1153 
<span class="line-modified">1154 WebGLAny WebGL2RenderingContext::getSyncParameter(WebGLSync&amp;, GC3Denum)</span>
1155 {
1156     // Note: Do not implement this function without consulting webkit-dev and WebGL
1157     // reviewers beforehand. Apple folks, see &lt;rdar://problem/36666458&gt;.
1158     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getSyncParameter()&quot;);
1159     return nullptr;
1160 }
1161 
1162 RefPtr&lt;WebGLTransformFeedback&gt; WebGL2RenderingContext::createTransformFeedback()
1163 {
<span class="line-modified">1164     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] createTransformFeedback()&quot;);</span>
<span class="line-modified">1165     return nullptr;</span>




1166 }
1167 
<span class="line-modified">1168 void WebGL2RenderingContext::deleteTransformFeedback(WebGLTransformFeedback*)</span>
1169 {
<span class="line-modified">1170     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteTransformFeedback()&quot;);</span>






1171 }
1172 
<span class="line-modified">1173 GC3Dboolean WebGL2RenderingContext::isTransformFeedback(WebGLTransformFeedback*)</span>
1174 {
<span class="line-modified">1175     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isTransformFeedback()&quot;);</span>
<span class="line-modified">1176     return false;</span>


1177 }
1178 
<span class="line-modified">1179 void WebGL2RenderingContext::bindTransformFeedback(GC3Denum, WebGLTransformFeedback*)</span>
1180 {
<span class="line-modified">1181     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] bindTransformFeedback()&quot;);</span>














1182 }
1183 
<span class="line-modified">1184 void WebGL2RenderingContext::beginTransformFeedback(GC3Denum)</span>
1185 {
<span class="line-modified">1186     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] beginTransformFeedback()&quot;);</span>



1187 }
1188 
1189 void WebGL2RenderingContext::endTransformFeedback()
1190 {
<span class="line-modified">1191     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] endTransformFeedback()&quot;);</span>



1192 }
1193 
<span class="line-modified">1194 void WebGL2RenderingContext::transformFeedbackVaryings(WebGLProgram&amp;, const Vector&lt;String&gt;&amp;, GC3Denum)</span>
1195 {
<span class="line-modified">1196     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] transformFeedbackVaryings()&quot;);</span>



1197 }
1198 
<span class="line-modified">1199 RefPtr&lt;WebGLActiveInfo&gt; WebGL2RenderingContext::getTransformFeedbackVarying(WebGLProgram&amp;, GC3Duint)</span>
1200 {
<span class="line-modified">1201     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getTransformFeedbackVarying()&quot;);</span>
<span class="line-modified">1202     return nullptr;</span>








1203 }
1204 
1205 void WebGL2RenderingContext::pauseTransformFeedback()
1206 {
1207     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] pauseTransformFeedback()&quot;);
1208 }
1209 
1210 void WebGL2RenderingContext::resumeTransformFeedback()
1211 {
1212     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] resumeTransformFeedback()&quot;);
1213 }
1214 
<span class="line-modified">1215 void WebGL2RenderingContext::bindBufferBase(GC3Denum, GC3Duint, WebGLBuffer*)</span>
1216 {
<span class="line-modified">1217     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] bindBufferBase()&quot;);</span>





















1218 }
1219 
<span class="line-modified">1220 void WebGL2RenderingContext::bindBufferRange(GC3Denum, GC3Duint, WebGLBuffer*, GC3Dint64, GC3Dint64)</span>
1221 {
1222     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] bindBufferRange()&quot;);
1223 }
1224 
<span class="line-modified">1225 WebGLAny WebGL2RenderingContext::getIndexedParameter(GC3Denum target, GC3Duint)</span>
1226 {



1227     switch (target) {
<span class="line-modified">1228     case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER_BINDING:</span>
<span class="line-modified">1229     case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER_SIZE:</span>
<span class="line-modified">1230     case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER_START:</span>
<span class="line-modified">1231     case GraphicsContext3D::UNIFORM_BUFFER_BINDING:</span>
<span class="line-modified">1232     case GraphicsContext3D::UNIFORM_BUFFER_SIZE:</span>
<span class="line-modified">1233     case GraphicsContext3D::UNIFORM_BUFFER_START:</span>
<span class="line-modified">1234         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getIndexedParameter&quot;, &quot;parameter name not yet supported&quot;);</span>





1235         return nullptr;
1236     default:
<span class="line-modified">1237         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getIndexedParameter&quot;, &quot;invalid parameter name&quot;);</span>
1238         return nullptr;
1239     }
1240 }
1241 
<span class="line-modified">1242 Optional&lt;Vector&lt;GC3Duint&gt;&gt; WebGL2RenderingContext::getUniformIndices(WebGLProgram&amp;, const Vector&lt;String&gt;&amp;)</span>
1243 {
1244     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getUniformIndices()&quot;);
1245     return WTF::nullopt;
1246 }
1247 
<span class="line-modified">1248 WebGLAny WebGL2RenderingContext::getActiveUniforms(WebGLProgram&amp; program, const Vector&lt;GC3Duint&gt;&amp; uniformIndices, GC3Denum pname)</span>
1249 {
1250     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniforms&quot;, &amp;program))
1251         return nullptr;
1252 
1253     switch (pname) {
<span class="line-modified">1254     case GraphicsContext3D::UNIFORM_TYPE:</span>
<span class="line-modified">1255     case GraphicsContext3D::UNIFORM_SIZE:</span>
<span class="line-modified">1256     case GraphicsContext3D::UNIFORM_BLOCK_INDEX:</span>
<span class="line-modified">1257     case GraphicsContext3D::UNIFORM_OFFSET:</span>
<span class="line-modified">1258     case GraphicsContext3D::UNIFORM_ARRAY_STRIDE:</span>
<span class="line-modified">1259     case GraphicsContext3D::UNIFORM_MATRIX_STRIDE:</span>
<span class="line-modified">1260     case GraphicsContext3D::UNIFORM_IS_ROW_MAJOR:</span>
1261         {
<span class="line-modified">1262             Vector&lt;GC3Dint&gt; params(uniformIndices.size(), 0);</span>
1263             m_context-&gt;getActiveUniforms(program.object(), uniformIndices, pname, params);
1264             return WTFMove(params);
1265         }
1266     default:
<span class="line-modified">1267         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getActiveUniforms&quot;, &quot;invalid parameter name&quot;);</span>
1268         return nullptr;
1269     }
1270 }
1271 
<span class="line-modified">1272 GC3Duint WebGL2RenderingContext::getUniformBlockIndex(WebGLProgram&amp;, const String&amp;)</span>
1273 {
1274     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getUniformBlockIndex()&quot;);
1275     return 0;
1276 }
1277 
<span class="line-modified">1278 WebGLAny WebGL2RenderingContext::getActiveUniformBlockParameter(WebGLProgram&amp;, GC3Duint, GC3Denum)</span>
1279 {
1280     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getActiveUniformBlockParameter()&quot;);
1281     return nullptr;
1282 }
1283 
<span class="line-modified">1284 WebGLAny WebGL2RenderingContext::getActiveUniformBlockName(WebGLProgram&amp;, GC3Duint)</span>
1285 {
1286     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getActiveUniformBlockName()&quot;);
1287     return nullptr;
1288 }
1289 
<span class="line-modified">1290 void WebGL2RenderingContext::uniformBlockBinding(WebGLProgram&amp;, GC3Duint, GC3Duint)</span>
1291 {
1292     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformBlockBinding()&quot;);
1293 }
1294 
1295 RefPtr&lt;WebGLVertexArrayObject&gt; WebGL2RenderingContext::createVertexArray()
1296 {
1297     if (isContextLost())
1298         return nullptr;
1299 
1300     auto object = WebGLVertexArrayObject::create(*this, WebGLVertexArrayObject::Type::User);
1301     addContextObject(object.get());
1302     return WTFMove(object);
1303 }
1304 
1305 void WebGL2RenderingContext::deleteVertexArray(WebGLVertexArrayObject* arrayObject)
1306 {
1307     if (!arrayObject || isContextLost())
1308         return;
1309 
1310     if (arrayObject-&gt;isDeleted())
1311         return;
1312 
1313     if (!arrayObject-&gt;isDefaultObject() &amp;&amp; arrayObject == m_boundVertexArrayObject)
1314 #if USE(OPENGL_ES)
1315         setBoundVertexArrayObject(nullptr);
1316 #else
1317         bindVertexArray(nullptr); // The default VAO was removed in OpenGL 3.3 but not from WebGL 2; bind the default for WebGL to use.
1318 #endif
1319 
<span class="line-modified">1320     arrayObject-&gt;deleteObject(graphicsContext3D());</span>
1321 }
1322 
<span class="line-modified">1323 GC3Dboolean WebGL2RenderingContext::isVertexArray(WebGLVertexArrayObject* arrayObject)</span>
1324 {
1325     if (!arrayObject || isContextLost())
1326         return false;
1327 
1328     if (!arrayObject-&gt;hasEverBeenBound() || !arrayObject-&gt;validate(0, *this))
1329         return false;
1330 
1331     return m_context-&gt;isVertexArray(arrayObject-&gt;object());
1332 }
1333 
1334 void WebGL2RenderingContext::bindVertexArray(WebGLVertexArrayObject* arrayObject)
1335 {
1336     if (isContextLost())
1337         return;
1338 
1339     if (arrayObject &amp;&amp; (arrayObject-&gt;isDeleted() || !arrayObject-&gt;validate(0, *this) || !m_contextObjects.contains(arrayObject))) {
<span class="line-modified">1340         m_context-&gt;synthesizeGLError(GraphicsContext3D::INVALID_OPERATION);</span>
1341         return;
1342     }
1343     if (arrayObject &amp;&amp; !arrayObject-&gt;isDefaultObject() &amp;&amp; arrayObject-&gt;object()) {
1344         m_context-&gt;bindVertexArray(arrayObject-&gt;object());
1345 
1346         arrayObject-&gt;setHasEverBeenBound();
1347         setBoundVertexArrayObject(arrayObject);
1348     } else {
1349         m_context-&gt;bindVertexArray(m_defaultVertexArrayObject-&gt;object());
1350         setBoundVertexArrayObject(m_defaultVertexArrayObject.get());
1351     }
1352 }
1353 
1354 WebGLExtension* WebGL2RenderingContext::getExtension(const String&amp; name)
1355 {
1356     if (isContextLostOrPending())
1357         return nullptr;
1358 
1359 #define ENABLE_IF_REQUESTED(type, variable, nameLiteral, canEnable) \
1360     if (equalIgnoringASCIICase(name, nameLiteral)) { \
1361         if (!variable) { \
1362             variable = (canEnable) ? makeUnique&lt;type&gt;(*this) : nullptr; \
1363             if (variable != nullptr) \
1364                 InspectorInstrumentation::didEnableExtension(*this, name); \
1365         } \
1366         return variable.get(); \
1367     }
1368 
1369     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
<span class="line-removed">1370     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));</span>
1371     ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
1372     ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
1373     ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
1374     ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
1375     ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);

1376     ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));


1377     ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
1378     ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
<span class="line-modified">1379     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));</span>
<span class="line-removed">1380     ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*graphicsContext3D()));</span>
1381     ENABLE_IF_REQUESTED(WebGLDebugRendererInfo, m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;, true);
1382     ENABLE_IF_REQUESTED(WebGLDebugShaders, m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;, m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s));
1383     return nullptr;
1384 }
1385 
1386 Optional&lt;Vector&lt;String&gt;&gt; WebGL2RenderingContext::getSupportedExtensions()
1387 {
1388     if (isContextLost())
1389         return WTF::nullopt;
1390 
1391     Vector&lt;String&gt; result;
1392 
1393     if (m_isPendingPolicyResolution)
1394         return result;
1395 
1396     auto&amp; extensions = m_context-&gt;getExtensions();
1397     if (extensions.supports(&quot;GL_OES_texture_float&quot;_s))
1398         result.append(&quot;OES_texture_float&quot;_s);
1399     if (extensions.supports(&quot;GL_OES_texture_float_linear&quot;_s))
1400         result.append(&quot;OES_texture_float_linear&quot;_s);
1401     if (extensions.supports(&quot;GL_OES_texture_half_float&quot;_s))
1402         result.append(&quot;OES_texture_half_float&quot;_s);
1403     if (extensions.supports(&quot;GL_OES_texture_half_float_linear&quot;_s))
1404         result.append(&quot;OES_texture_half_float_linear&quot;_s);
1405     if (extensions.supports(&quot;GL_EXT_texture_filter_anisotropic&quot;_s))
<span class="line-modified">1406         result.append(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;_s);</span>


1407     if (WebGLCompressedTextureATC::supported(*this))
1408         result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);




1409     if (WebGLCompressedTexturePVRTC::supported(*this))
1410         result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
1411     if (WebGLCompressedTextureS3TC::supported(*this))
1412         result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
<span class="line-modified">1413     if (WebGLCompressedTextureASTC::supported(*this))</span>
<span class="line-removed">1414         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);</span>
<span class="line-removed">1415     if (WebGLDepthTexture::supported(*graphicsContext3D()))</span>
1416         result.append(&quot;WEBGL_depth_texture&quot;_s);
1417     result.append(&quot;WEBGL_lose_context&quot;_s);
1418     if (extensions.supports(&quot;GL_ANGLE_translated_shader_source&quot;_s))
1419         result.append(&quot;WEBGL_debug_shaders&quot;_s);
1420     result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
1421 
1422     return result;
1423 }
1424 
<span class="line-modified">1425 static bool validateDefaultFramebufferAttachment(GC3Denum&amp; attachment)</span>
1426 {
1427     switch (attachment) {
<span class="line-modified">1428     case GraphicsContext3D::BACK:</span>
1429         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified">1430         attachment = GraphicsContext3D::COLOR_ATTACHMENT0;</span>
1431         return true;
<span class="line-modified">1432     case GraphicsContext3D::DEPTH:</span>
<span class="line-modified">1433     case GraphicsContext3D::STENCIL:</span>
1434         return true;
1435     }
1436 
1437     return false;
1438 }
1439 
<span class="line-modified">1440 WebGLAny WebGL2RenderingContext::getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname)</span>
1441 {
1442     const char* functionName = &quot;getFramebufferAttachmentParameter&quot;;
1443     if (isContextLostOrPending() || !validateFramebufferTarget(functionName, target))
1444         return nullptr;
1445 
<span class="line-modified">1446     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
1447 
1448     if (!targetFramebuffer) {
1449         // OpenGL ES 3: Default framebuffer is bound.
1450         if (!validateDefaultFramebufferAttachment(attachment)) {
<span class="line-modified">1451             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
1452             return nullptr;
1453         }
<span class="line-modified">1454         GC3Dint value = 0;</span>
1455         m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1456         return value;
1457     }
1458     if (!validateNonDefaultFramebufferAttachment(functionName, attachment))
1459         return nullptr;
1460 
1461     auto object = makeRefPtr(targetFramebuffer-&gt;getAttachmentObject(attachment));
1462     if (!object) {
<span class="line-modified">1463         if (pname == GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)</span>
<span class="line-modified">1464             return static_cast&lt;unsigned&gt;(GraphicsContext3D::NONE);</span>
<span class="line-modified">1465         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid parameter name&quot;);</span>
1466         return nullptr;
1467     }
1468 
1469     switch (pname) {
<span class="line-modified">1470     case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_RED_SIZE:</span>
<span class="line-modified">1471     case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:</span>
<span class="line-modified">1472     case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:</span>
<span class="line-modified">1473     case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:</span>
<span class="line-modified">1474     case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:</span>
<span class="line-modified">1475     case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:</span>
<span class="line-modified">1476     case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: {</span>
<span class="line-modified">1477         GC3Dint value = 0;</span>
1478         m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1479         return value;
1480     }
1481     }
1482 
1483     if (object-&gt;isTexture()) {
1484         switch (pname) {
<span class="line-modified">1485         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">1486             return static_cast&lt;unsigned&gt;(GraphicsContext3D::TEXTURE);</span>
<span class="line-modified">1487         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
1488             return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
<span class="line-modified">1489         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:</span>
<span class="line-modified">1490         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:</span>
<span class="line-modified">1491         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: {</span>
<span class="line-modified">1492             GC3Dint value = 0;</span>
1493             m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1494             return value;
1495         }
1496         default:
<span class="line-modified">1497             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid parameter name for texture attachment&quot;);</span>
1498             return nullptr;
1499         }
1500     } else {
1501         ASSERT(object-&gt;isRenderbuffer());
1502         switch (pname) {
<span class="line-modified">1503         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">1504             return static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER);</span>
<span class="line-modified">1505         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
1506             return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
<span class="line-modified">1507         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING : {</span>
1508             auto&amp; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object);
1509             auto format = renderBuffer.getInternalFormat();
<span class="line-modified">1510             if (format == GraphicsContext3D::SRGB8_ALPHA8</span>
<span class="line-modified">1511                 || format == GraphicsContext3D::COMPRESSED_SRGB8_ETC2</span>
<span class="line-modified">1512                 || format == GraphicsContext3D::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC</span>
<span class="line-modified">1513                 || format == GraphicsContext3D::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2) {</span>
<span class="line-modified">1514                 return static_cast&lt;unsigned&gt;(GraphicsContext3D::SRGB);</span>
1515             }
<span class="line-modified">1516             return static_cast&lt;unsigned&gt;(GraphicsContext3D::LINEAR);</span>
1517         }
1518         default:
<span class="line-modified">1519             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
1520             return nullptr;
1521         }
1522     }
1523 }
1524 
<span class="line-modified">1525 bool WebGL2RenderingContext::validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment)</span>
1526 {
1527     return validateFramebufferTarget(functionName, target) &amp;&amp; validateNonDefaultFramebufferAttachment(functionName, attachment);
1528 }
1529 
<span class="line-modified">1530 bool WebGL2RenderingContext::validateFramebufferTarget(const char* functionName, GC3Denum target)</span>
1531 {
1532     switch (target) {
<span class="line-modified">1533     case GraphicsContext3D::FRAMEBUFFER:</span>
<span class="line-modified">1534     case GraphicsContext3D::DRAW_FRAMEBUFFER:</span>
<span class="line-modified">1535     case GraphicsContext3D::READ_FRAMEBUFFER:</span>
1536         return true;
1537     }
1538 
<span class="line-modified">1539     synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
1540     return false;
1541 }
1542 
<span class="line-modified">1543 bool WebGL2RenderingContext::validateNonDefaultFramebufferAttachment(const char* functionName, GC3Denum attachment)</span>
1544 {
1545     switch (attachment) {
<span class="line-modified">1546     case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
<span class="line-modified">1547     case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
<span class="line-modified">1548     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
1549         return true;
1550     default:
<span class="line-modified">1551         if (attachment &gt;= GraphicsContext3D::COLOR_ATTACHMENT0 &amp;&amp; attachment &lt; static_cast&lt;GC3Denum&gt;(GraphicsContext3D::COLOR_ATTACHMENT0 + getMaxColorAttachments()))</span>
1552             return true;
1553     }
1554 
<span class="line-modified">1555     synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
1556     return false;
1557 }
1558 
<span class="line-modified">1559 GC3Dint WebGL2RenderingContext::getMaxDrawBuffers()</span>
1560 {
1561     if (!m_maxDrawBuffers)
<span class="line-modified">1562         m_context-&gt;getIntegerv(GraphicsContext3D::MAX_DRAW_BUFFERS, &amp;m_maxDrawBuffers);</span>
1563     return m_maxDrawBuffers;
1564 }
1565 
<span class="line-modified">1566 GC3Dint WebGL2RenderingContext::getMaxColorAttachments()</span>
1567 {
1568     // DrawBuffers requires MAX_COLOR_ATTACHMENTS == MAX_DRAW_BUFFERS
1569     if (!m_maxColorAttachments)
<span class="line-modified">1570         m_context-&gt;getIntegerv(GraphicsContext3D::MAX_DRAW_BUFFERS, &amp;m_maxColorAttachments);</span>
1571     return m_maxColorAttachments;
1572 }
1573 
<span class="line-modified">1574 void WebGL2RenderingContext::renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)</span>
1575 {
1576     if (isContextLostOrPending())
1577         return;
<span class="line-modified">1578     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="line-modified">1579         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);</span>
1580         return;
1581     }
1582     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">1583         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);</span>
1584         return;
1585     }
1586     if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
1587         return;
1588     switch (internalformat) {
<span class="line-modified">1589     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified">1590     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified">1591     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="line-modified">1592     case GraphicsContext3D::RGBA32I:</span>
<span class="line-modified">1593     case GraphicsContext3D::RGBA32UI:</span>
<span class="line-modified">1594     case GraphicsContext3D::RGBA16I:</span>
<span class="line-modified">1595     case GraphicsContext3D::RGBA16UI:</span>
<span class="line-modified">1596     case GraphicsContext3D::RGBA8:</span>
<span class="line-modified">1597     case GraphicsContext3D::RGBA8I:</span>
<span class="line-modified">1598     case GraphicsContext3D::RGBA8UI:</span>
<span class="line-modified">1599     case GraphicsContext3D::RGB10_A2:</span>
<span class="line-modified">1600     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="line-modified">1601     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified">1602     case GraphicsContext3D::RG32I:</span>
<span class="line-modified">1603     case GraphicsContext3D::RG32UI:</span>
<span class="line-modified">1604     case GraphicsContext3D::RG16I:</span>
<span class="line-modified">1605     case GraphicsContext3D::RG16UI:</span>
<span class="line-modified">1606     case GraphicsContext3D::RG8:</span>
<span class="line-modified">1607     case GraphicsContext3D::RG8I:</span>
<span class="line-modified">1608     case GraphicsContext3D::RG8UI:</span>
<span class="line-modified">1609     case GraphicsContext3D::R32I:</span>
<span class="line-modified">1610     case GraphicsContext3D::R32UI:</span>
<span class="line-modified">1611     case GraphicsContext3D::R16I:</span>
<span class="line-modified">1612     case GraphicsContext3D::R16UI:</span>
<span class="line-modified">1613     case GraphicsContext3D::R8:</span>
<span class="line-modified">1614     case GraphicsContext3D::R8I:</span>
<span class="line-modified">1615     case GraphicsContext3D::R8UI:</span>
<span class="line-modified">1616     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified">1617     case GraphicsContext3D::RGB565:</span>
<span class="line-modified">1618     case GraphicsContext3D::RGB8:</span>
<span class="line-modified">1619     case GraphicsContext3D::STENCIL_INDEX8:</span>
<span class="line-modified">1620     case GraphicsContext3D::SRGB8_ALPHA8:</span>
1621         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
1622         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
1623         m_renderbufferBinding-&gt;setIsValid(true);
1624         m_renderbufferBinding-&gt;setSize(width, height);
1625         break;
<span class="line-modified">1626     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
<span class="line-modified">1627     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
1628         if (!isDepthStencilSupported()) {
<span class="line-modified">1629             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
1630             return;
1631         }
1632         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
1633         m_renderbufferBinding-&gt;setSize(width, height);
1634         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
1635         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
1636         break;
1637     default:
<span class="line-modified">1638         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
1639         return;
1640     }
1641     applyStencilTest();
1642 }
1643 
<span class="line-modified">1644 void WebGL2RenderingContext::hint(GC3Denum target, GC3Denum mode)</span>
1645 {
1646     if (isContextLostOrPending())
1647         return;
1648     bool isValid = false;
1649     switch (target) {
<span class="line-modified">1650     case GraphicsContext3D::GENERATE_MIPMAP_HINT:</span>
<span class="line-modified">1651     case GraphicsContext3D::FRAGMENT_SHADER_DERIVATIVE_HINT:</span>
1652         isValid = true;
1653         break;
1654     }
1655     if (!isValid) {
<span class="line-modified">1656         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);</span>
1657         return;
1658     }
1659     m_context-&gt;hint(target, mode);
1660 }
1661 
<span class="line-modified">1662 GC3Denum WebGL2RenderingContext::baseInternalFormatFromInternalFormat(GC3Denum internalformat)</span>
1663 {
1664     // Handles sized, unsized, and compressed internal formats.
1665     switch (internalformat) {
<span class="line-modified">1666     case GraphicsContext3D::R8:</span>
<span class="line-modified">1667     case GraphicsContext3D::R8_SNORM:</span>
<span class="line-modified">1668     case GraphicsContext3D::R16F:</span>
<span class="line-modified">1669     case GraphicsContext3D::R32F:</span>
<span class="line-modified">1670     case GraphicsContext3D::COMPRESSED_R11_EAC:</span>
<span class="line-modified">1671     case GraphicsContext3D::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-modified">1672         return GraphicsContext3D::RED;</span>
<span class="line-modified">1673     case GraphicsContext3D::R8I:</span>
<span class="line-modified">1674     case GraphicsContext3D::R8UI:</span>
<span class="line-modified">1675     case GraphicsContext3D::R16I:</span>
<span class="line-modified">1676     case GraphicsContext3D::R16UI:</span>
<span class="line-modified">1677     case GraphicsContext3D::R32I:</span>
<span class="line-modified">1678     case GraphicsContext3D::R32UI:</span>
<span class="line-modified">1679         return GraphicsContext3D::RED_INTEGER;</span>
<span class="line-modified">1680     case GraphicsContext3D::RG8:</span>
<span class="line-modified">1681     case GraphicsContext3D::RG8_SNORM:</span>
<span class="line-modified">1682     case GraphicsContext3D::RG16F:</span>
<span class="line-modified">1683     case GraphicsContext3D::RG32F:</span>
<span class="line-modified">1684     case GraphicsContext3D::COMPRESSED_RG11_EAC:</span>
<span class="line-modified">1685     case GraphicsContext3D::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-modified">1686         return GraphicsContext3D::RG;</span>
<span class="line-modified">1687     case GraphicsContext3D::RG8I:</span>
<span class="line-modified">1688     case GraphicsContext3D::RG8UI:</span>
<span class="line-modified">1689     case GraphicsContext3D::RG16I:</span>
<span class="line-modified">1690     case GraphicsContext3D::RG16UI:</span>
<span class="line-modified">1691     case GraphicsContext3D::RG32I:</span>
<span class="line-modified">1692     case GraphicsContext3D::RG32UI:</span>
<span class="line-modified">1693         return GraphicsContext3D::RG_INTEGER;</span>
<span class="line-modified">1694     case GraphicsContext3D::RGB8:</span>
<span class="line-modified">1695     case GraphicsContext3D::RGB8_SNORM:</span>
<span class="line-modified">1696     case GraphicsContext3D::RGB565:</span>
<span class="line-modified">1697     case GraphicsContext3D::SRGB8:</span>
<span class="line-modified">1698     case GraphicsContext3D::RGB16F:</span>
<span class="line-modified">1699     case GraphicsContext3D::RGB32F:</span>
<span class="line-modified">1700     case GraphicsContext3D::RGB:</span>
<span class="line-modified">1701     case GraphicsContext3D::COMPRESSED_RGB8_ETC2:</span>
<span class="line-modified">1702     case GraphicsContext3D::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-modified">1703         return GraphicsContext3D::RGB;</span>
<span class="line-modified">1704     case GraphicsContext3D::RGB8I:</span>
<span class="line-modified">1705     case GraphicsContext3D::RGB8UI:</span>
<span class="line-modified">1706     case GraphicsContext3D::RGB16I:</span>
<span class="line-modified">1707     case GraphicsContext3D::RGB16UI:</span>
<span class="line-modified">1708     case GraphicsContext3D::RGB32I:</span>
<span class="line-modified">1709     case GraphicsContext3D::RGB32UI:</span>
<span class="line-modified">1710         return GraphicsContext3D::RGB_INTEGER;</span>
<span class="line-modified">1711     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified">1712     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified">1713     case GraphicsContext3D::RGBA8:</span>
<span class="line-modified">1714     case GraphicsContext3D::RGBA8_SNORM:</span>
<span class="line-modified">1715     case GraphicsContext3D::RGB10_A2:</span>
<span class="line-modified">1716     case GraphicsContext3D::SRGB8_ALPHA8:</span>
<span class="line-modified">1717     case GraphicsContext3D::RGBA16F:</span>
<span class="line-modified">1718     case GraphicsContext3D::RGBA32F:</span>
<span class="line-modified">1719     case GraphicsContext3D::RGBA:</span>
<span class="line-modified">1720     case GraphicsContext3D::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-modified">1721     case GraphicsContext3D::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-modified">1722     case GraphicsContext3D::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-modified">1723     case GraphicsContext3D::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:</span>
<span class="line-modified">1724         return GraphicsContext3D::RGBA;</span>
<span class="line-modified">1725     case GraphicsContext3D::RGBA8I:</span>
<span class="line-modified">1726     case GraphicsContext3D::RGBA8UI:</span>
<span class="line-modified">1727     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="line-modified">1728     case GraphicsContext3D::RGBA16I:</span>
<span class="line-modified">1729     case GraphicsContext3D::RGBA16UI:</span>
<span class="line-modified">1730     case GraphicsContext3D::RGBA32I:</span>
<span class="line-modified">1731     case GraphicsContext3D::RGBA32UI:</span>
<span class="line-modified">1732         return GraphicsContext3D::RGBA_INTEGER;</span>
<span class="line-modified">1733     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified">1734     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="line-modified">1735     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified">1736         return GraphicsContext3D::DEPTH_COMPONENT;</span>
<span class="line-modified">1737     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
<span class="line-modified">1738     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
<span class="line-modified">1739         return GraphicsContext3D::DEPTH_STENCIL;</span>
<span class="line-modified">1740     case GraphicsContext3D::LUMINANCE:</span>
<span class="line-modified">1741     case GraphicsContext3D::LUMINANCE_ALPHA:</span>
<span class="line-modified">1742     case GraphicsContext3D::ALPHA:</span>
1743         return internalformat;
1744     default:
1745         ASSERT_NOT_REACHED();
<span class="line-modified">1746         return GraphicsContext3D::NONE;</span>
1747     }
1748 }
1749 
<span class="line-modified">1750 bool WebGL2RenderingContext::isIntegerFormat(GC3Denum internalformat)</span>
1751 {
1752     switch (baseInternalFormatFromInternalFormat(internalformat)) {
<span class="line-modified">1753     case GraphicsContext3D::RED_INTEGER:</span>
<span class="line-modified">1754     case GraphicsContext3D::RG_INTEGER:</span>
<span class="line-modified">1755     case GraphicsContext3D::RGB_INTEGER:</span>
<span class="line-modified">1756     case GraphicsContext3D::RGBA_INTEGER:</span>
1757         return true;
1758     }
1759     return false;
1760 }
1761 
<span class="line-modified">1762 WebGLAny WebGL2RenderingContext::getParameter(GC3Denum pname)</span>
1763 {
1764     if (isContextLostOrPending())
1765         return nullptr;
1766     switch (pname) {
<span class="line-modified">1767     case GraphicsContext3D::ACTIVE_TEXTURE:</span>
1768         return getUnsignedIntParameter(pname);
<span class="line-modified">1769     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:</span>
1770         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">1771     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:</span>
1772         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">1773     case GraphicsContext3D::ALPHA_BITS:</span>
1774         if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
1775             return 0;
1776         return getIntParameter(pname);
<span class="line-modified">1777     case GraphicsContext3D::ARRAY_BUFFER_BINDING:</span>
1778         return m_boundArrayBuffer;
<span class="line-modified">1779     case GraphicsContext3D::BLEND:</span>
1780         return getBooleanParameter(pname);
<span class="line-modified">1781     case GraphicsContext3D::BLEND_COLOR:</span>
1782         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">1783     case GraphicsContext3D::BLEND_DST_ALPHA:</span>
1784         return getUnsignedIntParameter(pname);
<span class="line-modified">1785     case GraphicsContext3D::BLEND_DST_RGB:</span>
1786         return getUnsignedIntParameter(pname);
<span class="line-modified">1787     case GraphicsContext3D::BLEND_EQUATION_ALPHA:</span>
1788         return getUnsignedIntParameter(pname);
<span class="line-modified">1789     case GraphicsContext3D::BLEND_EQUATION_RGB:</span>
1790         return getUnsignedIntParameter(pname);
<span class="line-modified">1791     case GraphicsContext3D::BLEND_SRC_ALPHA:</span>
1792         return getUnsignedIntParameter(pname);
<span class="line-modified">1793     case GraphicsContext3D::BLEND_SRC_RGB:</span>
1794         return getUnsignedIntParameter(pname);
<span class="line-modified">1795     case GraphicsContext3D::BLUE_BITS:</span>
1796         return getIntParameter(pname);
<span class="line-modified">1797     case GraphicsContext3D::COLOR_CLEAR_VALUE:</span>
1798         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">1799     case GraphicsContext3D::COLOR_WRITEMASK:</span>
1800         return getBooleanArrayParameter(pname);
<span class="line-modified">1801     case GraphicsContext3D::COMPRESSED_TEXTURE_FORMATS:</span>
1802         return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
<span class="line-modified">1803     case GraphicsContext3D::CULL_FACE:</span>
1804         return getBooleanParameter(pname);
<span class="line-modified">1805     case GraphicsContext3D::CULL_FACE_MODE:</span>
1806         return getUnsignedIntParameter(pname);
<span class="line-modified">1807     case GraphicsContext3D::CURRENT_PROGRAM:</span>
1808         return m_currentProgram;
<span class="line-modified">1809     case GraphicsContext3D::DEPTH_BITS:</span>
1810         if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
1811             return 0;
1812         return getIntParameter(pname);
<span class="line-modified">1813     case GraphicsContext3D::DEPTH_CLEAR_VALUE:</span>
1814         return getFloatParameter(pname);
<span class="line-modified">1815     case GraphicsContext3D::DEPTH_FUNC:</span>
1816         return getUnsignedIntParameter(pname);
<span class="line-modified">1817     case GraphicsContext3D::DEPTH_RANGE:</span>
1818         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">1819     case GraphicsContext3D::DEPTH_TEST:</span>
1820         return getBooleanParameter(pname);
<span class="line-modified">1821     case GraphicsContext3D::DEPTH_WRITEMASK:</span>
1822         return getBooleanParameter(pname);
<span class="line-modified">1823     case GraphicsContext3D::DITHER:</span>
1824         return getBooleanParameter(pname);
<span class="line-modified">1825     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER_BINDING:</span>
1826         return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
<span class="line-modified">1827     case GraphicsContext3D::FRAMEBUFFER_BINDING:</span>
1828         return m_framebufferBinding;
<span class="line-modified">1829     case GraphicsContext3D::FRONT_FACE:</span>
1830         return getUnsignedIntParameter(pname);
<span class="line-modified">1831     case GraphicsContext3D::GENERATE_MIPMAP_HINT:</span>
1832         return getUnsignedIntParameter(pname);
<span class="line-modified">1833     case GraphicsContext3D::GREEN_BITS:</span>
1834         return getIntParameter(pname);
<span class="line-modified">1835     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_FORMAT:</span>
1836         return getIntParameter(pname);
<span class="line-modified">1837     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_TYPE:</span>
1838         return getIntParameter(pname);
<span class="line-modified">1839     case GraphicsContext3D::LINE_WIDTH:</span>
1840         return getFloatParameter(pname);
<span class="line-modified">1841     case GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS:</span>
1842         return getIntParameter(pname);
<span class="line-modified">1843     case GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE:</span>
1844         return getIntParameter(pname);
<span class="line-modified">1845     case GraphicsContext3D::MAX_FRAGMENT_UNIFORM_VECTORS:</span>
1846         return getIntParameter(pname);
<span class="line-modified">1847     case GraphicsContext3D::MAX_RENDERBUFFER_SIZE:</span>
1848         return getIntParameter(pname);
<span class="line-modified">1849     case GraphicsContext3D::MAX_TEXTURE_IMAGE_UNITS:</span>
1850         return getIntParameter(pname);
<span class="line-modified">1851     case GraphicsContext3D::MAX_TEXTURE_SIZE:</span>
1852         return getIntParameter(pname);
<span class="line-modified">1853     case GraphicsContext3D::MAX_VARYING_VECTORS:</span>
1854         return getIntParameter(pname);
<span class="line-modified">1855     case GraphicsContext3D::MAX_VERTEX_ATTRIBS:</span>
1856         return getIntParameter(pname);
<span class="line-modified">1857     case GraphicsContext3D::MAX_VERTEX_TEXTURE_IMAGE_UNITS:</span>
1858         return getIntParameter(pname);
<span class="line-modified">1859     case GraphicsContext3D::MAX_VERTEX_UNIFORM_VECTORS:</span>
1860         return getIntParameter(pname);
<span class="line-modified">1861     case GraphicsContext3D::MAX_VIEWPORT_DIMS:</span>
1862         return getWebGLIntArrayParameter(pname);
<span class="line-modified">1863     case GraphicsContext3D::NUM_SHADER_BINARY_FORMATS:</span>
1864         return getIntParameter(pname);
<span class="line-modified">1865     case GraphicsContext3D::PACK_ALIGNMENT:</span>
1866         return getIntParameter(pname);
<span class="line-modified">1867     case GraphicsContext3D::POLYGON_OFFSET_FACTOR:</span>
1868         return getFloatParameter(pname);
<span class="line-modified">1869     case GraphicsContext3D::POLYGON_OFFSET_FILL:</span>
1870         return getBooleanParameter(pname);
<span class="line-modified">1871     case GraphicsContext3D::POLYGON_OFFSET_UNITS:</span>
1872         return getFloatParameter(pname);
<span class="line-modified">1873     case GraphicsContext3D::RED_BITS:</span>
1874         return getIntParameter(pname);
<span class="line-modified">1875     case GraphicsContext3D::RENDERBUFFER_BINDING:</span>
1876         return m_renderbufferBinding;
<span class="line-modified">1877     case GraphicsContext3D::RENDERER:</span>
1878         return &quot;WebKit WebGL&quot;_str;
<span class="line-modified">1879     case GraphicsContext3D::SAMPLE_BUFFERS:</span>
1880         return getIntParameter(pname);
<span class="line-modified">1881     case GraphicsContext3D::SAMPLE_COVERAGE_INVERT:</span>
1882         return getBooleanParameter(pname);
<span class="line-modified">1883     case GraphicsContext3D::SAMPLE_COVERAGE_VALUE:</span>
1884         return getFloatParameter(pname);
<span class="line-modified">1885     case GraphicsContext3D::SAMPLES:</span>
1886         return getIntParameter(pname);
<span class="line-modified">1887     case GraphicsContext3D::SCISSOR_BOX:</span>
1888         return getWebGLIntArrayParameter(pname);
<span class="line-modified">1889     case GraphicsContext3D::SCISSOR_TEST:</span>
1890         return getBooleanParameter(pname);
<span class="line-modified">1891     case GraphicsContext3D::SHADING_LANGUAGE_VERSION:</span>
<span class="line-modified">1892         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContext3D::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;</span>
<span class="line-modified">1893     case GraphicsContext3D::STENCIL_BACK_FAIL:</span>
1894         return getUnsignedIntParameter(pname);
<span class="line-modified">1895     case GraphicsContext3D::STENCIL_BACK_FUNC:</span>
1896         return getUnsignedIntParameter(pname);
<span class="line-modified">1897     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_FAIL:</span>
1898         return getUnsignedIntParameter(pname);
<span class="line-modified">1899     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_PASS:</span>
1900         return getUnsignedIntParameter(pname);
<span class="line-modified">1901     case GraphicsContext3D::STENCIL_BACK_REF:</span>
1902         return getIntParameter(pname);
<span class="line-modified">1903     case GraphicsContext3D::STENCIL_BACK_VALUE_MASK:</span>
1904         return getUnsignedIntParameter(pname);
<span class="line-modified">1905     case GraphicsContext3D::STENCIL_BACK_WRITEMASK:</span>
1906         return getUnsignedIntParameter(pname);
<span class="line-modified">1907     case GraphicsContext3D::STENCIL_BITS:</span>
1908         if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
1909             return 0;
1910         return getIntParameter(pname);
<span class="line-modified">1911     case GraphicsContext3D::STENCIL_CLEAR_VALUE:</span>
1912         return getIntParameter(pname);
<span class="line-modified">1913     case GraphicsContext3D::STENCIL_FAIL:</span>
1914         return getUnsignedIntParameter(pname);
<span class="line-modified">1915     case GraphicsContext3D::STENCIL_FUNC:</span>
1916         return getUnsignedIntParameter(pname);
<span class="line-modified">1917     case GraphicsContext3D::STENCIL_PASS_DEPTH_FAIL:</span>
1918         return getUnsignedIntParameter(pname);
<span class="line-modified">1919     case GraphicsContext3D::STENCIL_PASS_DEPTH_PASS:</span>
1920         return getUnsignedIntParameter(pname);
<span class="line-modified">1921     case GraphicsContext3D::STENCIL_REF:</span>
1922         return getIntParameter(pname);
<span class="line-modified">1923     case GraphicsContext3D::STENCIL_TEST:</span>
1924         return getBooleanParameter(pname);
<span class="line-modified">1925     case GraphicsContext3D::STENCIL_VALUE_MASK:</span>
1926         return getUnsignedIntParameter(pname);
<span class="line-modified">1927     case GraphicsContext3D::STENCIL_WRITEMASK:</span>
1928         return getUnsignedIntParameter(pname);
<span class="line-modified">1929     case GraphicsContext3D::SUBPIXEL_BITS:</span>
1930         return getIntParameter(pname);
<span class="line-modified">1931     case GraphicsContext3D::TEXTURE_BINDING_2D:</span>
1932         return m_textureUnits[m_activeTextureUnit].texture2DBinding;
<span class="line-modified">1933     case GraphicsContext3D::TEXTURE_BINDING_CUBE_MAP:</span>
1934         return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
<span class="line-modified">1935     case GraphicsContext3D::UNPACK_ALIGNMENT:</span>
1936         return getIntParameter(pname);
<span class="line-modified">1937     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:</span>
1938         return m_unpackFlipY;
<span class="line-modified">1939     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
1940         return m_unpackPremultiplyAlpha;
<span class="line-modified">1941     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
1942         return m_unpackColorspaceConversion;
<span class="line-modified">1943     case GraphicsContext3D::VENDOR:</span>
1944         return &quot;WebKit&quot;_str;
<span class="line-modified">1945     case GraphicsContext3D::VERSION:</span>
1946         return &quot;WebGL 2.0&quot;_str;
<span class="line-modified">1947     case GraphicsContext3D::VIEWPORT:</span>
1948         return getWebGLIntArrayParameter(pname);
1949     case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
1950         if (m_webglDebugRendererInfo) {
1951 #if PLATFORM(IOS_FAMILY)
1952             return &quot;Apple GPU&quot;_str;
1953 #else
<span class="line-modified">1954             return m_context-&gt;getString(GraphicsContext3D::RENDERER);</span>
1955 #endif
1956         }
<span class="line-modified">1957         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
1958         return nullptr;
1959     case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
1960         if (m_webglDebugRendererInfo)
<span class="line-modified">1961             return m_context-&gt;getString(GraphicsContext3D::VENDOR);</span>
<span class="line-modified">1962         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
1963         return nullptr;
<span class="line-modified">1964     case Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
1965         if (m_extTextureFilterAnisotropic)
<span class="line-modified">1966             return getUnsignedIntParameter(Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT);</span>
<span class="line-modified">1967         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
1968         return nullptr;
<span class="line-modified">1969     case GraphicsContext3D::FRAGMENT_SHADER_DERIVATIVE_HINT:</span>
1970         return getIntParameter(pname);
<span class="line-modified">1971     case GraphicsContext3D::MAX_3D_TEXTURE_SIZE:</span>
1972         return getIntParameter(pname);
<span class="line-modified">1973     case GraphicsContext3D::MAX_ARRAY_TEXTURE_LAYERS:</span>
1974         return getIntParameter(pname);
<span class="line-modified">1975     case GraphicsContext3D::MAX_COLOR_ATTACHMENTS:</span>
1976         return getIntParameter(pname);
<span class="line-modified">1977     case GraphicsContext3D::MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:</span>
1978         return getInt64Parameter(pname);
<span class="line-modified">1979     case GraphicsContext3D::MAX_COMBINED_UNIFORM_BLOCKS:</span>
1980         return getIntParameter(pname);
<span class="line-modified">1981     case GraphicsContext3D::MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:</span>
1982         return getInt64Parameter(pname);
<span class="line-modified">1983     case GraphicsContext3D::MAX_DRAW_BUFFERS:</span>
1984         return getIntParameter(pname);
<span class="line-modified">1985     case GraphicsContext3D::MAX_ELEMENT_INDEX:</span>
1986         return getInt64Parameter(pname);
<span class="line-modified">1987     case GraphicsContext3D::MAX_ELEMENTS_INDICES:</span>
1988         return getIntParameter(pname);
<span class="line-modified">1989     case GraphicsContext3D::MAX_ELEMENTS_VERTICES:</span>
1990         return getIntParameter(pname);
<span class="line-modified">1991     case GraphicsContext3D::MAX_FRAGMENT_UNIFORM_COMPONENTS:</span>
1992         return getIntParameter(pname);
<span class="line-modified">1993     case GraphicsContext3D::MAX_FRAGMENT_UNIFORM_BLOCKS:</span>
1994         return getIntParameter(pname);
<span class="line-modified">1995     case GraphicsContext3D::MAX_PROGRAM_TEXEL_OFFSET:</span>
1996         return getIntParameter(pname);
<span class="line-modified">1997     case GraphicsContext3D::MAX_SAMPLES:</span>
1998         return getIntParameter(pname);
<span class="line-modified">1999     case GraphicsContext3D::MAX_SERVER_WAIT_TIMEOUT:</span>
2000         return getInt64Parameter(pname);
<span class="line-modified">2001     case GraphicsContext3D::MAX_TEXTURE_LOD_BIAS:</span>
2002         return getIntParameter(pname);
<span class="line-modified">2003     case GraphicsContext3D::MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:</span>
2004         return getIntParameter(pname);
<span class="line-modified">2005     case GraphicsContext3D::MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:</span>
2006         return getIntParameter(pname);
<span class="line-modified">2007     case GraphicsContext3D::MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:</span>
2008         return getIntParameter(pname);
<span class="line-modified">2009     case GraphicsContext3D::MAX_UNIFORM_BLOCK_SIZE:</span>
2010         return getInt64Parameter(pname);
<span class="line-modified">2011     case GraphicsContext3D::MAX_UNIFORM_BUFFER_BINDINGS:</span>
2012         return getIntParameter(pname);
<span class="line-modified">2013     case GraphicsContext3D::MAX_VARYING_COMPONENTS:</span>
2014         return getIntParameter(pname);
<span class="line-modified">2015     case GraphicsContext3D::MAX_VERTEX_OUTPUT_COMPONENTS:</span>
2016         return getIntParameter(pname);
<span class="line-modified">2017     case GraphicsContext3D::MAX_VERTEX_UNIFORM_BLOCKS:</span>
2018         return getIntParameter(pname);
<span class="line-modified">2019     case GraphicsContext3D::MAX_VERTEX_UNIFORM_COMPONENTS:</span>
2020         return getIntParameter(pname);
<span class="line-modified">2021     case GraphicsContext3D::MIN_PROGRAM_TEXEL_OFFSET:</span>
2022         return getIntParameter(pname);
<span class="line-modified">2023     case GraphicsContext3D::PACK_ROW_LENGTH:</span>
2024         return getIntParameter(pname);
<span class="line-modified">2025     case GraphicsContext3D::PACK_SKIP_PIXELS:</span>
2026         return getIntParameter(pname);
<span class="line-modified">2027     case GraphicsContext3D::PACK_SKIP_ROWS:</span>
2028         return getIntParameter(pname);
<span class="line-modified">2029     case GraphicsContext3D::UNPACK_IMAGE_HEIGHT:</span>
2030         return getIntParameter(pname);
<span class="line-modified">2031     case GraphicsContext3D::UNPACK_ROW_LENGTH:</span>
2032         return getIntParameter(pname);
<span class="line-modified">2033     case GraphicsContext3D::UNPACK_SKIP_IMAGES:</span>
2034         return getIntParameter(pname);
<span class="line-modified">2035     case GraphicsContext3D::UNPACK_SKIP_PIXELS:</span>
2036         return getIntParameter(pname);
<span class="line-modified">2037     case GraphicsContext3D::UNPACK_SKIP_ROWS:</span>
2038         return getIntParameter(pname);
<span class="line-modified">2039     case GraphicsContext3D::RASTERIZER_DISCARD:</span>
2040         return getBooleanParameter(pname);
<span class="line-modified">2041     case GraphicsContext3D::SAMPLE_ALPHA_TO_COVERAGE:</span>
2042         return getBooleanParameter(pname);
<span class="line-modified">2043     case GraphicsContext3D::SAMPLE_COVERAGE:</span>
2044         return getBooleanParameter(pname);
<span class="line-modified">2045     case GraphicsContext3D::TRANSFORM_FEEDBACK_ACTIVE:</span>
2046         return getBooleanParameter(pname);
<span class="line-modified">2047     case GraphicsContext3D::TRANSFORM_FEEDBACK_PAUSED:</span>
2048         return getBooleanParameter(pname);
<span class="line-modified">2049     case GraphicsContext3D::UNIFORM_BUFFER_OFFSET_ALIGNMENT:</span>
2050         return getIntParameter(pname);
<span class="line-modified">2051     case GraphicsContext3D::VERTEX_ARRAY_BINDING:</span>
2052         if (m_boundVertexArrayObject-&gt;isDefaultObject())
2053             return nullptr;
2054         return makeRefPtr(static_cast&lt;WebGLVertexArrayObject&amp;&gt;(*m_boundVertexArrayObject));
<span class="line-modified">2055     case GraphicsContext3D::DRAW_BUFFER0:</span>
<span class="line-modified">2056     case GraphicsContext3D::DRAW_BUFFER1:</span>
<span class="line-modified">2057     case GraphicsContext3D::DRAW_BUFFER2:</span>
<span class="line-modified">2058     case GraphicsContext3D::DRAW_BUFFER3:</span>
<span class="line-modified">2059     case GraphicsContext3D::DRAW_BUFFER4:</span>
<span class="line-modified">2060     case GraphicsContext3D::DRAW_BUFFER5:</span>
<span class="line-modified">2061     case GraphicsContext3D::DRAW_BUFFER6:</span>
<span class="line-modified">2062     case GraphicsContext3D::DRAW_BUFFER7:</span>
<span class="line-modified">2063     case GraphicsContext3D::DRAW_BUFFER8:</span>
<span class="line-modified">2064     case GraphicsContext3D::DRAW_BUFFER9:</span>
<span class="line-modified">2065     case GraphicsContext3D::DRAW_BUFFER10:</span>
<span class="line-modified">2066     case GraphicsContext3D::DRAW_BUFFER11:</span>
<span class="line-modified">2067     case GraphicsContext3D::DRAW_BUFFER12:</span>
<span class="line-modified">2068     case GraphicsContext3D::DRAW_BUFFER13:</span>
<span class="line-modified">2069     case GraphicsContext3D::DRAW_BUFFER14:</span>
<span class="line-modified">2070     case GraphicsContext3D::DRAW_BUFFER15:</span>
2071         if (m_framebufferBinding)
2072             return m_framebufferBinding-&gt;getDrawBuffer(pname);
2073         return m_backDrawBuffer; // emulated backbuffer
<span class="line-modified">2074     case GraphicsContext3D::READ_FRAMEBUFFER_BINDING:</span>
2075         return m_readFramebufferBinding;
<span class="line-modified">2076     case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified">2077     case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified">2078     case GraphicsContext3D::PIXEL_PACK_BUFFER_BINDING:</span>
<span class="line-modified">2079     case GraphicsContext3D::PIXEL_UNPACK_BUFFER_BINDING:</span>
<span class="line-modified">2080     case GraphicsContext3D::READ_BUFFER:</span>
<span class="line-modified">2081     case GraphicsContext3D::SAMPLER_BINDING:</span>
<span class="line-modified">2082     case GraphicsContext3D::TEXTURE_BINDING_2D_ARRAY:</span>
<span class="line-modified">2083     case GraphicsContext3D::TEXTURE_BINDING_3D:</span>
<span class="line-modified">2084     case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER_BINDING:</span>
<span class="line-modified">2085     case GraphicsContext3D::UNIFORM_BUFFER_BINDING:</span>
<span class="line-modified">2086         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;parameter name not yet supported&quot;);</span>




2087         return nullptr;
2088     default:
<span class="line-modified">2089         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);</span>
2090         return nullptr;
2091     }
2092 }
2093 
<span class="line-modified">2094 bool WebGL2RenderingContext::validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired)</span>
2095 {
2096     // Performs conservative validation by caching a maximum index of
2097     // the given type per element array buffer. If all of the bound
2098     // array buffers have enough elements to satisfy that maximum
2099     // index, skips the expensive per-draw-call iteration in
2100     // validateIndexArrayPrecise.
2101 
2102     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2103 
2104     if (!elementArrayBuffer)
2105         return false;
2106 
<span class="line-modified">2107     GC3Dsizeiptr numElements = elementArrayBuffer-&gt;byteLength();</span>
2108     // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
2109     if (!numElements)
2110         return false;
2111     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2112     ASSERT(buffer);
2113 
2114     Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
2115     if (!maxIndex) {
2116         // Compute the maximum index in the entire buffer for the given type of index.
2117         switch (type) {
<span class="line-modified">2118         case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">2119             maxIndex = getMaxIndex&lt;GC3Dubyte&gt;(buffer, 0, numElements);</span>
2120             break;
<span class="line-modified">2121         case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="line-modified">2122             maxIndex = getMaxIndex&lt;GC3Dushort&gt;(buffer, 0, numElements / sizeof(GC3Dushort));</span>
2123             break;
<span class="line-modified">2124         case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="line-modified">2125             maxIndex = getMaxIndex&lt;GC3Duint&gt;(buffer, 0, numElements / sizeof(GC3Duint));</span>
2126             break;
2127         default:
2128             return false;
2129         }
2130         if (maxIndex)
2131             elementArrayBuffer-&gt;setCachedMaxIndex(type, maxIndex.value());
2132     }
2133 
2134     if (!maxIndex)
2135         return false;
2136 
2137     // The number of required elements is one more than the maximum
2138     // index that will be accessed.
2139     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex.value(), 1, 1);
2140     if (!checkedNumElementsRequired)
2141         return false;
2142     numElementsRequired = checkedNumElementsRequired.value();
2143 
2144     return true;
2145 }
2146 
<span class="line-modified">2147 bool WebGL2RenderingContext::validateBlendEquation(const char* functionName, GC3Denum mode)</span>
2148 {
2149     switch (mode) {
<span class="line-modified">2150     case GraphicsContext3D::FUNC_ADD:</span>
<span class="line-modified">2151     case GraphicsContext3D::FUNC_SUBTRACT:</span>
<span class="line-modified">2152     case GraphicsContext3D::FUNC_REVERSE_SUBTRACT:</span>
<span class="line-modified">2153     case GraphicsContext3D::MIN:</span>
<span class="line-modified">2154     case GraphicsContext3D::MAX:</span>
2155         return true;
2156     default:
<span class="line-modified">2157         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
2158         return false;
2159     }
2160 }
2161 
<span class="line-modified">2162 bool WebGL2RenderingContext::validateCapability(const char* functionName, GC3Denum cap)</span>
2163 {
2164     switch (cap) {
<span class="line-modified">2165     case GraphicsContext3D::BLEND:</span>
<span class="line-modified">2166     case GraphicsContext3D::CULL_FACE:</span>
<span class="line-modified">2167     case GraphicsContext3D::DEPTH_TEST:</span>
<span class="line-modified">2168     case GraphicsContext3D::DITHER:</span>
<span class="line-modified">2169     case GraphicsContext3D::POLYGON_OFFSET_FILL:</span>
<span class="line-modified">2170     case GraphicsContext3D::SAMPLE_ALPHA_TO_COVERAGE:</span>
<span class="line-modified">2171     case GraphicsContext3D::SAMPLE_COVERAGE:</span>
<span class="line-modified">2172     case GraphicsContext3D::SCISSOR_TEST:</span>
<span class="line-modified">2173     case GraphicsContext3D::STENCIL_TEST:</span>
<span class="line-modified">2174     case GraphicsContext3D::RASTERIZER_DISCARD:</span>
2175         return true;
2176     default:
<span class="line-modified">2177         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid capability&quot;);</span>
2178         return false;
2179     }
2180 }
2181 




















































































































































































































2182 } // namespace WebCore
2183 
2184 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGL2RenderingContext.h&quot;
  28 
  29 #if ENABLE(WEBGL2)
  30 
  31 #include &quot;CachedImage.h&quot;
  32 #include &quot;EXTTextureFilterAnisotropic.h&quot;
<span class="line-modified">  33 #include &quot;EventLoop.h&quot;</span>
<span class="line-added">  34 #include &quot;ExtensionsGL.h&quot;</span>
  35 #include &quot;HTMLCanvasElement.h&quot;
  36 #include &quot;HTMLImageElement.h&quot;
  37 #include &quot;HTMLVideoElement.h&quot;
  38 #include &quot;ImageData.h&quot;
  39 #include &quot;InspectorInstrumentation.h&quot;
  40 #include &quot;Logging.h&quot;
  41 #include &quot;OESTextureFloat.h&quot;
  42 #include &quot;OESTextureFloatLinear.h&quot;
  43 #include &quot;OESTextureHalfFloat.h&quot;
  44 #include &quot;OESTextureHalfFloatLinear.h&quot;
  45 #include &quot;RenderBox.h&quot;
  46 #include &quot;WebGLActiveInfo.h&quot;
  47 #include &quot;WebGLCompressedTextureASTC.h&quot;
  48 #include &quot;WebGLCompressedTextureATC.h&quot;
<span class="line-added">  49 #include &quot;WebGLCompressedTextureETC.h&quot;</span>
<span class="line-added">  50 #include &quot;WebGLCompressedTextureETC1.h&quot;</span>
  51 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  52 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  53 #include &quot;WebGLDebugRendererInfo.h&quot;
  54 #include &quot;WebGLDebugShaders.h&quot;
  55 #include &quot;WebGLDepthTexture.h&quot;
  56 #include &quot;WebGLLoseContext.h&quot;
  57 #include &quot;WebGLQuery.h&quot;
  58 #include &quot;WebGLSampler.h&quot;
  59 #include &quot;WebGLSync.h&quot;
  60 #include &quot;WebGLTransformFeedback.h&quot;
  61 #include &quot;WebGLVertexArrayObject.h&quot;
  62 #include &lt;JavaScriptCore/GenericTypedArrayViewInlines.h&gt;
  63 #include &lt;JavaScriptCore/HeapInlines.h&gt;
  64 #include &lt;JavaScriptCore/JSGenericTypedArrayViewInlines.h&gt;
<span class="line-added">  65 #include &lt;JavaScriptCore/TypedArrayType.h&gt;</span>
  66 #include &lt;wtf/IsoMallocInlines.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGL2RenderingContext);
  71 
<span class="line-modified">  72 std::unique_ptr&lt;WebGL2RenderingContext&gt; WebGL2RenderingContext::create(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)</span>
  73 {
  74     auto renderingContext = std::unique_ptr&lt;WebGL2RenderingContext&gt;(new WebGL2RenderingContext(canvas, attributes));
  75 
  76     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  77 
  78     return renderingContext;
  79 }
  80 
<span class="line-modified">  81 std::unique_ptr&lt;WebGL2RenderingContext&gt; WebGL2RenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)</span>
  82 {
  83     auto renderingContext = std::unique_ptr&lt;WebGL2RenderingContext&gt;(new WebGL2RenderingContext(canvas, WTFMove(context), attributes));
  84 
  85     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  86 
  87     return renderingContext;
  88 }
  89 
<span class="line-modified">  90 WebGL2RenderingContext::WebGL2RenderingContext(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)</span>
  91     : WebGLRenderingContextBase(canvas, attributes)
  92 {
  93 }
  94 
<span class="line-modified">  95 WebGL2RenderingContext::WebGL2RenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)</span>
  96     : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
  97 {
  98     initializeShaderExtensions();
  99     initializeVertexArrayObjects();
<span class="line-added"> 100     initializeTransformFeedbackBufferCache();</span>
<span class="line-added"> 101     initializeSamplerCache();</span>
<span class="line-added"> 102 }</span>
<span class="line-added"> 103 </span>
<span class="line-added"> 104 WebGL2RenderingContext::~WebGL2RenderingContext()</span>
<span class="line-added"> 105 {</span>
<span class="line-added"> 106     // Remove all references to WebGLObjects so if they are the last reference</span>
<span class="line-added"> 107     // they will be freed before the last context is removed from the context group.</span>
<span class="line-added"> 108     m_boundTransformFeedback = nullptr;</span>
<span class="line-added"> 109     m_boundTransformFeedbackBuffers.clear();</span>
<span class="line-added"> 110     m_activeQueries.clear();</span>
 111 }
 112 
 113 void WebGL2RenderingContext::initializeVertexArrayObjects()
 114 {
 115     m_defaultVertexArrayObject = WebGLVertexArrayObject::create(*this, WebGLVertexArrayObject::Type::Default);
 116     addContextObject(*m_defaultVertexArrayObject);
 117 #if USE(OPENGL_ES)
 118     m_boundVertexArrayObject = m_defaultVertexArrayObject;
 119 #else
 120     bindVertexArray(nullptr); // The default VAO was removed in OpenGL 3.3 but not from WebGL 2; bind the default for WebGL to use.
 121 #endif
 122     if (!isGLES2Compliant())
 123         initVertexAttrib0();
 124 }
 125 
 126 void WebGL2RenderingContext::initializeShaderExtensions()
 127 {
 128     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_OES_standard_derivatives&quot;);
 129     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;);
 130     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_shader_texture_lod&quot;);
 131     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_frag_depth&quot;);
 132 }
 133 
<span class="line-modified"> 134 void WebGL2RenderingContext::initializeTransformFeedbackBufferCache()</span>
 135 {
<span class="line-modified"> 136     int maxTransformFeedbackAttribs = getIntParameter(GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);</span>
<span class="line-modified"> 137     ASSERT(maxTransformFeedbackAttribs &gt;= 4);</span>
<span class="line-modified"> 138 </span>
<span class="line-modified"> 139     m_boundTransformFeedbackBuffers.resize(maxTransformFeedbackAttribs);</span>












 140 }
 141 
<span class="line-modified"> 142 void WebGL2RenderingContext::initializeSamplerCache()</span>
 143 {
<span class="line-modified"> 144     ASSERT(m_textureUnits.size() &gt;= 8);</span>
<span class="line-modified"> 145     m_boundSamplers.resize(m_textureUnits.size());</span>
<span class="line-modified"> 146 }</span>




 147 
<span class="line-modified"> 148 RefPtr&lt;ArrayBufferView&gt; WebGL2RenderingContext::arrayBufferViewSliceFactory(const char* const functionName, const ArrayBufferView&amp; data, unsigned startByte,  unsigned numElements)</span>
<span class="line-modified"> 149 {</span>
<span class="line-modified"> 150     RefPtr&lt;ArrayBufferView&gt; slice;</span>

 151 
<span class="line-modified"> 152     switch (data.getType()) {</span>
<span class="line-modified"> 153 #define FACTORY_CASE(type) \</span>
<span class="line-modified"> 154     case JSC::Type##type: \</span>
<span class="line-modified"> 155         slice = JSC::type##Array::tryCreate(data.possiblySharedBuffer(), startByte, numElements); \</span>
<span class="line-modified"> 156         break;</span>


 157 
<span class="line-modified"> 158     FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(FACTORY_CASE);</span>
<span class="line-modified"> 159 #undef FACTORY_CASE</span>
<span class="line-modified"> 160     case JSC::TypeDataView:</span>
<span class="line-modified"> 161         slice = Uint8Array::tryCreate(data.possiblySharedBuffer(), startByte, numElements);</span>
<span class="line-added"> 162         break;</span>
<span class="line-added"> 163     default:</span>
<span class="line-added"> 164         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 165         return nullptr;</span>
 166     }
<span class="line-modified"> 167 </span>
<span class="line-added"> 168     if (!slice)</span>
<span class="line-added"> 169         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, functionName, &quot;Could not create intermediate ArrayBufferView&quot;);</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171     return slice;</span>
 172 }
 173 
<span class="line-modified"> 174 RefPtr&lt;ArrayBufferView&gt; WebGL2RenderingContext::sliceArrayBufferView(const char* const functionName, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length)</span>
 175 {
<span class="line-modified"> 176     if (data.getType() == JSC::NotTypedArray) {</span>
<span class="line-modified"> 177         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Invalid type of Array Buffer View&quot;);</span>
<span class="line-modified"> 178         return nullptr;</span>

 179     }


 180 
<span class="line-modified"> 181     auto elementSize = JSC::elementSize(data.getType());</span>
<span class="line-modified"> 182     Checked&lt;GCGLuint, RecordOverflow&gt; checkedElementSize(elementSize);</span>
<span class="line-modified"> 183 </span>
<span class="line-modified"> 184     Checked&lt;GCGLuint, RecordOverflow&gt; checkedSrcOffset(srcOffset);</span>
<span class="line-added"> 185     Checked&lt;GCGLuint, RecordOverflow&gt; checkedByteSrcOffset = checkedSrcOffset * checkedElementSize;</span>
<span class="line-added"> 186     Checked&lt;GCGLuint, RecordOverflow&gt; checkedLength(length);</span>
<span class="line-added"> 187     Checked&lt;GCGLuint, RecordOverflow&gt; checkedByteLength = checkedLength * checkedElementSize;</span>
 188 
 189     if (checkedByteSrcOffset.hasOverflowed()
 190         || checkedByteLength.hasOverflowed()
 191         || checkedByteSrcOffset.unsafeGet() &gt; data.byteLength()
 192         || checkedByteLength.unsafeGet() &gt; data.byteLength() - checkedByteSrcOffset.unsafeGet()) {
<span class="line-modified"> 193         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;srcOffset or length is out of bounds&quot;);</span>
<span class="line-modified"> 194         return nullptr;</span>
 195     }
 196 
<span class="line-modified"> 197     return arrayBufferViewSliceFactory(functionName, data, data.byteOffset() + checkedByteSrcOffset.unsafeGet(), length);</span>
<span class="line-modified"> 198 }</span>



 199 
<span class="line-modified"> 200 void WebGL2RenderingContext::bufferData(GCGLenum target, const ArrayBufferView&amp; data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length)</span>
<span class="line-added"> 201 {</span>
<span class="line-added"> 202     if (auto slice = sliceArrayBufferView(&quot;bufferData&quot;, data, srcOffset, length))</span>
<span class="line-added"> 203         WebGLRenderingContextBase::bufferData(target, BufferDataSource(slice.get()), usage);</span>
 204 }
 205 
<span class="line-modified"> 206 void WebGL2RenderingContext::bufferSubData(GCGLenum target, long long offset, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length)</span>
<span class="line-added"> 207 {</span>
<span class="line-added"> 208     if (auto slice = sliceArrayBufferView(&quot;bufferSubData&quot;, data, srcOffset, length))</span>
<span class="line-added"> 209         WebGLRenderingContextBase::bufferSubData(target, offset, BufferDataSource(slice.get()));</span>
<span class="line-added"> 210 }</span>
<span class="line-added"> 211 </span>
<span class="line-added"> 212 void WebGL2RenderingContext::copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLint64 readOffset, GCGLint64 writeOffset, GCGLint64 size)</span>
 213 {
 214     if (isContextLostOrPending())
 215         return;
<span class="line-modified"> 216     if ((readTarget == GraphicsContextGL::ELEMENT_ARRAY_BUFFER &amp;&amp; writeTarget != GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
<span class="line-modified"> 217         || (writeTarget == GraphicsContextGL::ELEMENT_ARRAY_BUFFER &amp;&amp; readTarget != GraphicsContextGL::ELEMENT_ARRAY_BUFFER)) {</span>
<span class="line-modified"> 218         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyBufferSubData&quot;, &quot;Either both targets need to be ELEMENT_ARRAY_BUFFER or neither should be ELEMENT_ARRAY_BUFFER.&quot;);</span>
 219         return;
 220     }
 221     if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0) {
<span class="line-modified"> 222         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;offset &lt; 0&quot;);</span>
 223         return;
 224     }
<span class="line-modified"> 225     RefPtr&lt;WebGLBuffer&gt; readBuffer = validateBufferDataParameters(&quot;copyBufferSubData&quot;, readTarget, GraphicsContextGL::STATIC_DRAW);</span>
<span class="line-modified"> 226     RefPtr&lt;WebGLBuffer&gt; writeBuffer = validateBufferDataParameters(&quot;copyBufferSubData&quot;, writeTarget, GraphicsContextGL::STATIC_DRAW);</span>
 227     if (!readBuffer || !writeBuffer) {
<span class="line-modified"> 228         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;Invalid readTarget or writeTarget&quot;);</span>
 229         return;
 230     }
 231 
<span class="line-modified"> 232     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadOffset(readOffset);</span>
<span class="line-modified"> 233     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteOffset(writeOffset);</span>
<span class="line-modified"> 234     Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedSize(size);</span>
 235     if (checkedReadOffset.hasOverflowed() || checkedWriteOffset.hasOverflowed() || checkedSize.hasOverflowed()) {
<span class="line-modified"> 236         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;Offset or size is too big&quot;);</span>
 237         return;
 238     }
 239 
 240     if (!writeBuffer-&gt;associateCopyBufferSubData(*readBuffer, checkedReadOffset.unsafeGet(), checkedWriteOffset.unsafeGet(), checkedSize.unsafeGet())) {
<span class="line-modified"> 241         this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;offset out of range&quot;);</span>
 242         return;
 243     }
 244 
 245     m_context-&gt;moveErrorsToSyntheticErrorList();
 246 #if PLATFORM(COCOA)
 247     m_context-&gt;copyBufferSubData(readTarget, writeTarget, checkedReadOffset.unsafeGet(), checkedWriteOffset.unsafeGet(), checkedSize.unsafeGet());
 248 #endif
 249     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
 250         // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
 251         writeBuffer-&gt;disassociateBufferData();
 252     }
 253 }
 254 
<span class="line-modified"> 255 void WebGL2RenderingContext::getBufferSubData(GCGLenum target, long long srcByteOffset, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; dstData, GCGLuint dstOffset, GCGLuint length)</span>
 256 {
 257     if (isContextLostOrPending())
 258         return;
<span class="line-modified"> 259     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContextGL::STATIC_DRAW);</span>
 260     if (!buffer) {
<span class="line-modified"> 261         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;No WebGLBuffer is bound to target&quot;);</span>
 262         return;
 263     }
 264 
 265     // FIXME: Implement &quot;If target is TRANSFORM_FEEDBACK_BUFFER, and any transform feedback object is currently active, an INVALID_OPERATION error is generated.&quot;
 266 
 267     if (!dstData) {
<span class="line-modified"> 268         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Null dstData&quot;);</span>
 269         return;
 270     }
 271 
<span class="line-modified"> 272     if (dstData-&gt;getType() == JSC::NotTypedArray) {</span>
<span class="line-modified"> 273         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Invalid type of Array Buffer View&quot;);</span>

 274         return;
 275     }
<span class="line-modified"> 276 </span>
<span class="line-added"> 277     auto elementSize = JSC::elementSize(dstData-&gt;getType());</span>
 278     auto dstDataLength = dstData-&gt;byteLength() / elementSize;
 279 
 280     if (dstOffset &gt; dstDataLength) {
<span class="line-modified"> 281         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;dstOffset is larger than the length of the destination buffer.&quot;);</span>
 282         return;
 283     }
 284 
<span class="line-modified"> 285     GCGLuint copyLength = length ? length : dstDataLength - dstOffset;</span>
 286 
<span class="line-modified"> 287     Checked&lt;GCGLuint, RecordOverflow&gt; checkedDstOffset(dstOffset);</span>
<span class="line-modified"> 288     Checked&lt;GCGLuint, RecordOverflow&gt; checkedCopyLength(copyLength);</span>
 289     auto checkedDestinationEnd = checkedDstOffset + checkedCopyLength;
 290     if (checkedDestinationEnd.hasOverflowed()) {
<span class="line-modified"> 291         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;dstOffset + copyLength is too high&quot;);</span>
 292         return;
 293     }
 294 
 295     if (checkedDestinationEnd.unsafeGet() &gt; dstDataLength) {
<span class="line-modified"> 296         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;end of written destination is past the end of the buffer&quot;);</span>
 297         return;
 298     }
 299 
 300     if (srcByteOffset &lt; 0) {
<span class="line-modified"> 301         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;srcByteOffset is less than 0&quot;);</span>
 302         return;
 303     }
 304 
<span class="line-modified"> 305     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedSrcByteOffset(srcByteOffset);</span>
<span class="line-modified"> 306     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedCopyLengthPtr(copyLength);</span>
<span class="line-modified"> 307     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedElementSize(elementSize);</span>
 308     auto checkedSourceEnd = checkedSrcByteOffset + checkedCopyLengthPtr * checkedElementSize;
 309     if (checkedSourceEnd.hasOverflowed() || checkedSourceEnd.unsafeGet() &gt; buffer-&gt;byteLength()) {
<span class="line-modified"> 310         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Parameters would read outside the bounds of the source buffer&quot;);</span>
 311         return;
 312     }
 313 
 314     m_context-&gt;moveErrorsToSyntheticErrorList();
 315 #if PLATFORM(COCOA)
 316     // FIXME: Coalesce multiple getBufferSubData() calls to use a single map() call
<span class="line-modified"> 317     void* ptr = m_context-&gt;mapBufferRange(target, checkedSrcByteOffset.unsafeGet(), static_cast&lt;GCGLsizeiptr&gt;(checkedCopyLengthPtr.unsafeGet() * checkedElementSize.unsafeGet()), GraphicsContextGL::MAP_READ_BIT);</span>
<span class="line-modified"> 318     if (ptr)</span>
<span class="line-modified"> 319         memcpy(static_cast&lt;char*&gt;(dstData-&gt;baseAddress()) + dstData-&gt;byteOffset() + dstOffset * elementSize, ptr, copyLength * elementSize);</span>
<span class="line-modified"> 320 </span>
<span class="line-added"> 321     if (!m_context-&gt;unmapBuffer(target))</span>
<span class="line-added"> 322         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Failed while unmapping buffer&quot;);</span>
 323 #endif
 324     m_context-&gt;moveErrorsToSyntheticErrorList();
 325 }
 326 
<span class="line-modified"> 327 void WebGL2RenderingContext::blitFramebuffer(GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLbitfield, GCGLenum)</span>
 328 {
 329     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] blitFramebuffer()&quot;);
 330 }
 331 
<span class="line-modified"> 332 void WebGL2RenderingContext::framebufferTextureLayer(GCGLenum, GCGLenum, WebGLTexture*, GCGLint, GCGLint)</span>
 333 {
 334     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] framebufferTextureLayer()&quot;);
 335 }
 336 
 337 #if !USE(OPENGL_ES)
<span class="line-modified"> 338 static bool isRenderableInternalformat(GCGLenum internalformat)</span>
 339 {
 340     // OpenGL ES 3: internalformat must be a color-renderable, depth-renderable, or stencil-renderable format, as shown in Table 1 below.
 341     switch (internalformat) {
<span class="line-modified"> 342     case GraphicsContextGL::R8:</span>
<span class="line-modified"> 343     case GraphicsContextGL::R8UI:</span>
<span class="line-modified"> 344     case GraphicsContextGL::R16UI:</span>
<span class="line-modified"> 345     case GraphicsContextGL::R16I:</span>
<span class="line-modified"> 346     case GraphicsContextGL::R32UI:</span>
<span class="line-modified"> 347     case GraphicsContextGL::R32I:</span>
<span class="line-modified"> 348     case GraphicsContextGL::RG8:</span>
<span class="line-modified"> 349     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified"> 350     case GraphicsContextGL::RG8I:</span>
<span class="line-modified"> 351     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified"> 352     case GraphicsContextGL::RG16I:</span>
<span class="line-modified"> 353     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified"> 354     case GraphicsContextGL::RG32I:</span>
<span class="line-modified"> 355     case GraphicsContextGL::RGB8:</span>
<span class="line-modified"> 356     case GraphicsContextGL::RGB565:</span>
<span class="line-modified"> 357     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified"> 358     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="line-modified"> 359     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified"> 360     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified"> 361     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified"> 362     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified"> 363     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified"> 364     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="line-modified"> 365     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified"> 366     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified"> 367     case GraphicsContextGL::RGBA32I:</span>
<span class="line-modified"> 368     case GraphicsContextGL::RGBA32UI:</span>
<span class="line-modified"> 369     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified"> 370     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified"> 371     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified"> 372     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="line-modified"> 373     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
<span class="line-modified"> 374     case GraphicsContextGL::STENCIL_INDEX8:</span>
 375         return true;
 376     }
 377     return false;
 378 }
 379 #endif
 380 
<span class="line-modified"> 381 WebGLAny WebGL2RenderingContext::getInternalformatParameter(GCGLenum target, GCGLenum internalformat, GCGLenum pname)</span>
 382 {
 383     if (isContextLostOrPending())
 384         return nullptr;
 385 
<span class="line-modified"> 386     if (pname != GraphicsContextGL::SAMPLES) {</span>
<span class="line-modified"> 387         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid parameter name&quot;);</span>
 388         return nullptr;
 389     }
 390 
 391     int numValues = 0;
 392 #if USE(OPENGL_ES)
<span class="line-modified"> 393     m_context-&gt;getInternalformativ(target, internalformat, GraphicsContextGL::NUM_SAMPLE_COUNTS, 1, &amp;numValues);</span>
 394 
<span class="line-modified"> 395     GCGLint params[numValues];</span>
 396     m_context-&gt;getInternalformativ(target, internalformat, pname, numValues, params);
 397 #else
 398     // On desktop OpenGL 4.1 or below we must emulate glGetInternalformativ.
 399 
 400     // GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER.
<span class="line-modified"> 401     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified"> 402         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid target&quot;);</span>
 403         return nullptr;
 404     }
 405 
 406     // GL_INVALID_ENUM is generated if internalformat is not color-, depth-, or stencil-renderable.
 407     if (!isRenderableInternalformat(internalformat)) {
<span class="line-modified"> 408         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid internal format&quot;);</span>
 409         return nullptr;
 410     }
 411 
<span class="line-modified"> 412     Vector&lt;GCGLint&gt; samples;</span>
 413     // The way I understand this is that this will return a MINIMUM numSamples for all accepeted internalformats.
 414     // However, the true value of this on supported GL versions is gleaned via a getInternalformativ call that depends on internalformat.
<span class="line-modified"> 415     int numSamplesMask = getIntParameter(GraphicsContextGL::MAX_SAMPLES);</span>
 416 
 417     while (numSamplesMask &gt; 0) {
 418         samples.append(numSamplesMask);
 419         numSamplesMask = numSamplesMask &gt;&gt; 1;
 420     }
 421 
 422     // Since multisampling is not supported for signed and unsigned integer internal formats,
 423     // the value of GL_NUM_SAMPLE_COUNTS will be zero for such formats.
 424     numValues = isIntegerFormat(internalformat) ? 0 : samples.size();
<span class="line-modified"> 425     GCGLint params[numValues];</span>
 426     for (size_t i = 0; i &lt; samples.size(); ++i)
 427         params[i] = samples[i];
 428 #endif
 429 
 430     return Int32Array::tryCreate(params, numValues);
 431 }
 432 
<span class="line-modified"> 433 void WebGL2RenderingContext::invalidateFramebuffer(GCGLenum, const Vector&lt;GCGLenum&gt;&amp;)</span>
 434 {
 435     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] invalidateFramebuffer()&quot;);
 436 }
 437 
<span class="line-modified"> 438 void WebGL2RenderingContext::invalidateSubFramebuffer(GCGLenum, const Vector&lt;GCGLenum&gt;&amp;, GCGLint, GCGLint, GCGLsizei, GCGLsizei)</span>
 439 {
 440     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] invalidateSubFramebuffer()&quot;);
 441 }
 442 
<span class="line-modified"> 443 void WebGL2RenderingContext::readBuffer(GCGLenum)</span>
 444 {
 445     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] readBuffer()&quot;);
 446 }
 447 
<span class="line-modified"> 448 void WebGL2RenderingContext::renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)</span>
 449 {
 450     // To be backward compatible with WebGL 1, also accepts internal format DEPTH_STENCIL,
 451     // which should be mapped to DEPTH24_STENCIL8 by implementations.
<span class="line-modified"> 452     if (internalformat == GraphicsContextGL::DEPTH_STENCIL)</span>
<span class="line-modified"> 453         internalformat = GraphicsContextGL::DEPTH24_STENCIL8;</span>
 454 
 455     // ES 3: GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than 0.
 456     if (isIntegerFormat(internalformat) &amp;&amp; samples &gt; 0) {
<span class="line-modified"> 457         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;renderbufferStorageMultisample&quot;, &quot;multisampling not supported for this format&quot;);</span>
 458         return;
 459     }
 460 
 461     switch (internalformat) {
<span class="line-modified"> 462     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified"> 463     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified"> 464     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified"> 465     case GraphicsContextGL::RGBA32I:</span>
<span class="line-modified"> 466     case GraphicsContextGL::RGBA32UI:</span>
<span class="line-modified"> 467     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified"> 468     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified"> 469     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified"> 470     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified"> 471     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified"> 472     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified"> 473     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="line-modified"> 474     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified"> 475     case GraphicsContextGL::RG32I:</span>
<span class="line-modified"> 476     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified"> 477     case GraphicsContextGL::RG16I:</span>
<span class="line-modified"> 478     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified"> 479     case GraphicsContextGL::RG8:</span>
<span class="line-modified"> 480     case GraphicsContextGL::RG8I:</span>
<span class="line-modified"> 481     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified"> 482     case GraphicsContextGL::R32I:</span>
<span class="line-modified"> 483     case GraphicsContextGL::R32UI:</span>
<span class="line-modified"> 484     case GraphicsContextGL::R16I:</span>
<span class="line-modified"> 485     case GraphicsContextGL::R16UI:</span>
<span class="line-modified"> 486     case GraphicsContextGL::R8:</span>
<span class="line-modified"> 487     case GraphicsContextGL::R8I:</span>
<span class="line-modified"> 488     case GraphicsContextGL::R8UI:</span>
<span class="line-modified"> 489     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified"> 490     case GraphicsContextGL::RGB565:</span>
<span class="line-modified"> 491     case GraphicsContextGL::RGB8:</span>
<span class="line-modified"> 492     case GraphicsContextGL::STENCIL_INDEX8:</span>
<span class="line-modified"> 493     case GraphicsContextGL::SRGB8_ALPHA8:</span>
 494         m_context-&gt;renderbufferStorageMultisample(target, samples, internalformat, width, height);
 495         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
 496         m_renderbufferBinding-&gt;setIsValid(true);
 497         m_renderbufferBinding-&gt;setSize(width, height);
 498         break;
<span class="line-modified"> 499     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
<span class="line-modified"> 500     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
 501         if (!isDepthStencilSupported()) {
<span class="line-modified"> 502             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
 503             return;
 504         }
 505         m_context-&gt;renderbufferStorageMultisample(target, samples, internalformat, width, height);
 506         m_renderbufferBinding-&gt;setSize(width, height);
 507         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
 508         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
 509         break;
 510     default:
<span class="line-modified"> 511         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
 512         return;
 513     }
 514     applyStencilTest();
 515 }
 516 
<span class="line-modified"> 517 bool WebGL2RenderingContext::validateTexStorageFuncParameters(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, const char* functionName)</span>
 518 {
 519     if (width &lt; 0 || height &lt; 0) {
<span class="line-modified"> 520         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
 521         return false;
 522     }
 523 
 524     if (width &gt; m_maxTextureSize || height &gt; m_maxTextureSize) {
<span class="line-modified"> 525         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;texture dimensions are larger than the maximum texture size&quot;);</span>
 526         return false;
 527     }
 528 
<span class="line-modified"> 529     if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
 530         if (width != height) {
<span class="line-modified"> 531             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);</span>
 532             return false;
 533         }
<span class="line-modified"> 534     } else if (target != GraphicsContextGL::TEXTURE_2D) {</span>
<span class="line-modified"> 535         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
 536         return false;
 537     }
 538 
 539     if (levels &lt; 0 || levels &gt; m_maxTextureLevel) {
<span class="line-modified"> 540         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;number of levels is out of bounds&quot;);</span>
 541         return false;
 542     }
 543 
 544     switch (internalFormat) {
<span class="line-modified"> 545     case GraphicsContextGL::R8:</span>
<span class="line-modified"> 546     case GraphicsContextGL::R8_SNORM:</span>
<span class="line-modified"> 547     case GraphicsContextGL::R16F:</span>
<span class="line-modified"> 548     case GraphicsContextGL::R32F:</span>
<span class="line-modified"> 549     case GraphicsContextGL::R8UI:</span>
<span class="line-modified"> 550     case GraphicsContextGL::R8I:</span>
<span class="line-modified"> 551     case GraphicsContextGL::R16UI:</span>
<span class="line-modified"> 552     case GraphicsContextGL::R16I:</span>
<span class="line-modified"> 553     case GraphicsContextGL::R32UI:</span>
<span class="line-modified"> 554     case GraphicsContextGL::R32I:</span>
<span class="line-modified"> 555     case GraphicsContextGL::RG8:</span>
<span class="line-modified"> 556     case GraphicsContextGL::RG8_SNORM:</span>
<span class="line-modified"> 557     case GraphicsContextGL::RG16F:</span>
<span class="line-modified"> 558     case GraphicsContextGL::RG32F:</span>
<span class="line-modified"> 559     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified"> 560     case GraphicsContextGL::RG8I:</span>
<span class="line-modified"> 561     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified"> 562     case GraphicsContextGL::RG16I:</span>
<span class="line-modified"> 563     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified"> 564     case GraphicsContextGL::RG32I:</span>
<span class="line-modified"> 565     case GraphicsContextGL::RGB8:</span>
<span class="line-modified"> 566     case GraphicsContextGL::SRGB8:</span>
<span class="line-modified"> 567     case GraphicsContextGL::RGB565:</span>
<span class="line-modified"> 568     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="line-modified"> 569     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified"> 570     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified"> 571     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified"> 572     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified"> 573     case GraphicsContextGL::RGB8UI:</span>
<span class="line-modified"> 574     case GraphicsContextGL::RGB8I:</span>
<span class="line-modified"> 575     case GraphicsContextGL::RGB16UI:</span>
<span class="line-modified"> 576     case GraphicsContextGL::RGB16I:</span>
<span class="line-modified"> 577     case GraphicsContextGL::RGB32UI:</span>
<span class="line-modified"> 578     case GraphicsContextGL::RGB32I:</span>
<span class="line-modified"> 579     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified"> 580     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="line-modified"> 581     case GraphicsContextGL::RGBA8_SNORM:</span>
<span class="line-modified"> 582     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified"> 583     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified"> 584     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified"> 585     case GraphicsContextGL::RGBA16F:</span>
<span class="line-modified"> 586     case GraphicsContextGL::RGBA32F:</span>
<span class="line-modified"> 587     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified"> 588     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified"> 589     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="line-modified"> 590     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified"> 591     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified"> 592     case GraphicsContextGL::RGBA32I:</span>
<span class="line-modified"> 593     case GraphicsContextGL::RGBA32UI:</span>
<span class="line-modified"> 594     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified"> 595     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified"> 596     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified"> 597     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="line-modified"> 598     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
 599         break;
 600     default:
<span class="line-modified"> 601         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;Unknown internalFormat&quot;);</span>
 602         return false;
 603     }
 604 
 605     return true;
 606 }
 607 
<span class="line-modified"> 608 void WebGL2RenderingContext::texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height)</span>
 609 {
 610     if (isContextLostOrPending())
 611         return;
 612 
 613     auto texture = validateTextureBinding(&quot;texStorage2D&quot;, target, false);
 614     if (!texture)
 615         return;
 616 
 617     if (!validateTexStorageFuncParameters(target, levels, internalFormat, width, height, &quot;texStorage2D&quot;))
 618         return;
 619 
 620     if (!validateNPOTTextureLevel(width, height, levels, &quot;texStorage2D&quot;))
 621         return;
 622 
 623     if (texture-&gt;immutable()) {
<span class="line-modified"> 624         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;texStorage2D&quot;, &quot;texStorage2D already called on this texture&quot;);</span>
 625         return;
 626     }
 627     texture-&gt;setImmutable();
 628 
 629     m_context-&gt;texStorage2D(target, levels, internalFormat, width, height);
 630 
 631     {
<span class="line-modified"> 632         GCGLenum format;</span>
<span class="line-modified"> 633         GCGLenum type;</span>
<span class="line-modified"> 634         if (!GraphicsContextGLOpenGL::possibleFormatAndTypeForInternalFormat(internalFormat, format, type)) {</span>
<span class="line-modified"> 635             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texStorage2D&quot;, &quot;Texture has unknown internal format&quot;);</span>
 636             return;
 637         }
 638 
<span class="line-modified"> 639         GCGLsizei levelWidth = width;</span>
<span class="line-modified"> 640         GCGLsizei levelHeight = height;</span>
 641 
 642         unsigned size;
<span class="line-modified"> 643         GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);</span>
<span class="line-modified"> 644         if (error != GraphicsContextGL::NO_ERROR) {</span>
 645             synthesizeGLError(error, &quot;texStorage2D&quot;, &quot;bad dimensions&quot;);
 646             return;
 647         }
 648 
 649         Vector&lt;char&gt; data(size);
 650         memset(data.data(), 0, size);
 651 
<span class="line-modified"> 652         for (GCGLsizei level = 0; level &lt; levels; ++level) {</span>
<span class="line-modified"> 653             if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
<span class="line-modified"> 654                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 655                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 656                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 657                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 658                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
<span class="line-modified"> 659                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, level, 0, 0, levelWidth, levelHeight, format, type, data.data());</span>
 660             } else
 661                 m_context-&gt;texSubImage2D(target, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 662             levelWidth = std::max(1, levelWidth / 2);
 663             levelHeight = std::max(1, levelHeight / 2);
 664         }
 665     }
 666 
<span class="line-modified"> 667     for (GCGLsizei level = 0; level &lt; levels; ++level) {</span>
<span class="line-modified"> 668         if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
<span class="line-modified"> 669             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
<span class="line-modified"> 670             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
<span class="line-modified"> 671             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
<span class="line-modified"> 672             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
<span class="line-modified"> 673             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
<span class="line-modified"> 674             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
 675         } else
<span class="line-modified"> 676             texture-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
 677     }
 678 }
 679 
<span class="line-modified"> 680 void WebGL2RenderingContext::texStorage3D(GCGLenum, GCGLsizei, GCGLenum, GCGLsizei, GCGLsizei, GCGLsizei)</span>
 681 {
 682     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texStorage3D()&quot;);
 683 }
 684 
<span class="line-modified"> 685 void WebGL2RenderingContext::texImage2D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, GCGLintptr)</span>
 686 {
<span class="line-modified"> 687     // Covered by textures/misc/tex-unpack-params.html.</span>
<span class="line-added"> 688     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage2D(PIXEL_UNPACK_BUFFER)&quot;);</span>
 689 }
 690 
<span class="line-modified"> 691 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texImage2D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)</span>
 692 {
<span class="line-modified"> 693     // Covered by textures/misc/origin-clean-conformance-offscreencanvas.html?</span>
<span class="line-added"> 694     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage2D(TexImageSource)&quot;);</span>
<span class="line-added"> 695     return { };</span>
 696 }
 697 
<span class="line-modified"> 698 RefPtr&lt;ArrayBufferView&gt; WebGL2RenderingContext::sliceTypedArrayBufferView(const char* const functionName, RefPtr&lt;ArrayBufferView&gt;&amp; srcData, GCGLuint srcOffset)</span>
 699 {
<span class="line-modified"> 700     if (!srcData)</span>
<span class="line-modified"> 701         return nullptr;</span>
 702 
<span class="line-modified"> 703     if (!isTypedView(srcData-&gt;getType())) {</span>
<span class="line-modified"> 704         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Invalid type of ArrayBufferView&quot;);</span>
<span class="line-modified"> 705         return nullptr;</span>
<span class="line-added"> 706     }</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708     auto elementSize = JSC::elementSize(srcData-&gt;getType());</span>
<span class="line-added"> 709     auto startingByte = WTF::checkedProduct&lt;unsigned&gt;(elementSize, srcOffset);</span>
<span class="line-added"> 710     if (startingByte.hasOverflowed() || startingByte &gt;= srcData-&gt;byteLength()) {</span>
<span class="line-added"> 711         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Invalid element offset!&quot;);</span>
<span class="line-added"> 712         return nullptr;</span>
<span class="line-added"> 713     }</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715     auto numElements = (srcData-&gt;byteLength() - startingByte.unsafeGet()) / elementSize;</span>
<span class="line-added"> 716 </span>
<span class="line-added"> 717     return arrayBufferViewSliceFactory(functionName, *srcData, startingByte.unsafeGet(), numElements);</span>
 718 }
 719 
<span class="line-modified"> 720 void WebGL2RenderingContext::texImage2D(GCGLenum target, GCGLint level, GCGLint internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset)</span>
 721 {
<span class="line-modified"> 722     if (isContextLostOrPending())</span>
<span class="line-added"> 723         return;</span>
<span class="line-added"> 724 </span>
<span class="line-added"> 725     auto slicedData = sliceTypedArrayBufferView(&quot;texImage2D&quot;, srcData, srcOffset);</span>
<span class="line-added"> 726 </span>
<span class="line-added"> 727     WebGLRenderingContextBase::texImage2D(target, level, internalFormat, width, height, border, format, type, WTFMove(slicedData));</span>
 728 }
 729 
<span class="line-modified"> 730 void WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, GCGLint64)</span>
 731 {
<span class="line-modified"> 732     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(PIXEL_UNPACK_BUFFER)&quot;);</span>
 733 }
 734 
<span class="line-modified"> 735 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)</span>
 736 {
<span class="line-modified"> 737     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(TexImageSource)&quot;);</span>
<span class="line-added"> 738     return { };</span>
 739 }
 740 
<span class="line-modified"> 741 void WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;)</span>
 742 {
<span class="line-modified"> 743     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(ArrayBufferView?)&quot;);</span>
 744 }
 745 
<span class="line-modified"> 746 void WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GCGLuint)</span>
 747 {
<span class="line-modified"> 748     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(ArrayBufferView, srcOffset)&quot;);</span>
 749 }
 750 
<span class="line-modified"> 751 void WebGL2RenderingContext::texSubImage2D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, GCGLintptr)</span>
 752 {
<span class="line-modified"> 753     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage2D(PIXEL_UNPACK_BUFFER)&quot;);</span>
 754 }
 755 
<span class="line-modified"> 756 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texSubImage2D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)</span>
 757 {
<span class="line-modified"> 758     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage2D(TexImageSource)&quot;);</span>
<span class="line-added"> 759     return { };</span>
 760 }
 761 
<span class="line-modified"> 762 void WebGL2RenderingContext::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset)</span>
 763 {
<span class="line-modified"> 764     if (isContextLostOrPending())</span>
<span class="line-added"> 765         return;</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767     auto slicedData = sliceTypedArrayBufferView(&quot;texSubImage2D&quot;, srcData, srcOffset);</span>
<span class="line-added"> 768 </span>
<span class="line-added"> 769     WebGLRenderingContextBase::texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, WTFMove(slicedData));</span>
 770 }
 771 
<span class="line-modified"> 772 void WebGL2RenderingContext::texSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, GCGLint64)</span>
 773 {
<span class="line-modified"> 774     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D(PIXEL_UNPACK_BUFFER)&quot;);</span>
 775 }
 776 
<span class="line-modified"> 777 void WebGL2RenderingContext::texSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GCGLuint)</span>
 778 {
<span class="line-modified"> 779     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D(ArrayBufferView, srcOffset)&quot;);</span>
 780 }
 781 
<span class="line-modified"> 782 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)</span>
 783 {
<span class="line-modified"> 784     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D(TexImageSource)&quot;);</span>
<span class="line-added"> 785     return { };</span>
 786 }
 787 
<span class="line-modified"> 788 void WebGL2RenderingContext::copyTexSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei)</span>
 789 {
<span class="line-modified"> 790     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] copyTexSubImage3D()&quot;);</span>
 791 }
 792 
<span class="line-modified"> 793 void WebGL2RenderingContext::compressedTexImage3D(GCGLenum, GCGLint, GCGLenum, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLsizei, GCGLint64)</span>
 794 {
<span class="line-modified"> 795     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage3D(PIXEL_UNPACK_BUFFER)&quot;);</span>
 796 }
 797 
<span class="line-modified"> 798 void WebGL2RenderingContext::compressedTexImage3D(GCGLenum, GCGLint, GCGLenum, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, ArrayBufferView&amp;, GCGLuint, GCGLuint)</span>
 799 {
<span class="line-modified"> 800     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage3D(ArrayBufferView)&quot;);</span>
 801 }
 802 
<span class="line-modified"> 803 void WebGL2RenderingContext::compressedTexSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLsizei, GCGLint64)</span>
 804 {
<span class="line-modified"> 805     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage3D(PIXEL_UNPACK_BUFFER)&quot;);</span>
 806 }
 807 
<span class="line-modified"> 808 void WebGL2RenderingContext::compressedTexSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, ArrayBufferView&amp;, GCGLuint, GCGLuint)</span>
 809 {
<span class="line-modified"> 810     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage3D(ArrayBufferView)&quot;);</span>
 811 }
 812 
<span class="line-modified"> 813 GCGLint WebGL2RenderingContext::getFragDataLocation(WebGLProgram&amp;, const String&amp;)</span>
 814 {
 815     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getFragDataLocation()&quot;);
 816     return 0;
 817 }
 818 
<span class="line-modified"> 819 void WebGL2RenderingContext::uniform1ui(WebGLUniformLocation*, GCGLuint)</span>
 820 {
 821     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1ui()&quot;);
 822 }
 823 
<span class="line-modified"> 824 void WebGL2RenderingContext::uniform2ui(WebGLUniformLocation*, GCGLuint, GCGLuint)</span>
 825 {
 826     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2ui()&quot;);
 827 }
 828 
<span class="line-modified"> 829 void WebGL2RenderingContext::uniform3ui(WebGLUniformLocation*, GCGLuint, GCGLuint, GCGLuint)</span>
 830 {
 831     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3ui()&quot;);
 832 }
 833 
<span class="line-modified"> 834 void WebGL2RenderingContext::uniform4ui(WebGLUniformLocation*, GCGLuint, GCGLuint, GCGLuint, GCGLuint)</span>
 835 {
 836     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4ui()&quot;);
 837 }
 838 
<span class="line-modified"> 839 void WebGL2RenderingContext::uniform1uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 840 {
 841     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1uiv()&quot;);
 842 }
 843 
<span class="line-modified"> 844 void WebGL2RenderingContext::uniform2uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 845 {
 846     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2uiv()&quot;);
 847 }
 848 
<span class="line-modified"> 849 void WebGL2RenderingContext::uniform3uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 850 {
 851     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3uiv()&quot;);
 852 }
 853 
<span class="line-modified"> 854 void WebGL2RenderingContext::uniform4uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 855 {
 856     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4uiv()&quot;);
 857 }
 858 
<span class="line-modified"> 859 void WebGL2RenderingContext::uniformMatrix2x3fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 860 {
 861     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2x3fv()&quot;);
 862 }
 863 
<span class="line-modified"> 864 void WebGL2RenderingContext::uniformMatrix3x2fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 865 {
 866     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3x2fv()&quot;);
 867 }
 868 
<span class="line-modified"> 869 void WebGL2RenderingContext::uniformMatrix2x4fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 870 {
 871     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2x4fv()&quot;);
 872 }
 873 
<span class="line-modified"> 874 void WebGL2RenderingContext::uniformMatrix4x2fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 875 {
 876     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4x2fv()&quot;);
 877 }
 878 
<span class="line-modified"> 879 void WebGL2RenderingContext::uniformMatrix3x4fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 880 {
 881     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3x4fv()&quot;);
 882 }
 883 
<span class="line-modified"> 884 void WebGL2RenderingContext::uniformMatrix4x3fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)</span>
 885 {
 886     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4x3fv()&quot;);
 887 }
 888 
<span class="line-modified"> 889 void WebGL2RenderingContext::vertexAttribI4i(GCGLuint, GCGLint, GCGLint, GCGLint, GCGLint)</span>
 890 {
 891     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4i()&quot;);
 892 }
 893 
<span class="line-modified"> 894 void WebGL2RenderingContext::vertexAttribI4iv(GCGLuint, Int32List&amp;&amp;)</span>
 895 {
 896     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4iv()&quot;);
 897 }
 898 
<span class="line-modified"> 899 void WebGL2RenderingContext::vertexAttribI4ui(GCGLuint, GCGLuint, GCGLuint, GCGLuint, GCGLuint)</span>
 900 {
 901     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4ui()&quot;);
 902 }
 903 
<span class="line-modified"> 904 void WebGL2RenderingContext::vertexAttribI4uiv(GCGLuint, Uint32List&amp;&amp;)</span>
 905 {
 906     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4uiv()&quot;);
 907 }
 908 
<span class="line-modified"> 909 void WebGL2RenderingContext::vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLint64 offset)</span>
 910 {
<span class="line-modified"> 911     if (isContextLostOrPending())</span>
<span class="line-added"> 912         return;</span>
<span class="line-added"> 913 </span>
<span class="line-added"> 914     m_context-&gt;vertexAttribIPointer(index, size, type, stride, offset);</span>
 915 }
 916 
<span class="line-modified"> 917 void WebGL2RenderingContext::clear(GCGLbitfield mask)</span>
 918 {
 919     if (isContextLostOrPending())
 920         return;
<span class="line-modified"> 921     if (mask &amp; ~(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT)) {</span>
<span class="line-modified"> 922         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);</span>
 923         return;
 924     }
<span class="line-modified"> 925     const char* reason = &quot;framebuffer incomplete&quot;;</span>
<span class="line-modified"> 926     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-added"> 927         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);</span>
 928         return;
 929     }
<span class="line-modified"> 930     if (m_framebufferBinding &amp;&amp; (mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT) &amp;&amp; isIntegerFormat(m_framebufferBinding-&gt;getColorBufferFormat())) {</span>
<span class="line-modified"> 931         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clear&quot;, &quot;cannot clear an integer buffer&quot;);</span>

 932         return;
 933     }
 934     if (!clearIfComposited(mask))
 935         m_context-&gt;clear(mask);
 936     markContextChangedAndNotifyCanvasObserver();
 937 }
 938 
<span class="line-modified"> 939 void WebGL2RenderingContext::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)</span>
 940 {
 941     if (isContextLostOrPending())
 942         return;
 943 
 944     WebGLRenderingContextBase::vertexAttribDivisor(index, divisor);
 945 }
 946 
<span class="line-modified"> 947 void WebGL2RenderingContext::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei instanceCount)</span>
 948 {
 949     if (isContextLostOrPending())
 950         return;
 951 
 952     WebGLRenderingContextBase::drawArraysInstanced(mode, first, count, instanceCount);
 953 }
 954 
<span class="line-modified"> 955 void WebGL2RenderingContext::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLint64 offset, GCGLsizei instanceCount)</span>
 956 {
 957     if (isContextLostOrPending())
 958         return;
 959 
 960     WebGLRenderingContextBase::drawElementsInstanced(mode, count, type, offset, instanceCount);
 961 }
 962 
<span class="line-modified"> 963 void WebGL2RenderingContext::drawRangeElements(GCGLenum, GCGLuint, GCGLuint, GCGLsizei, GCGLenum, GCGLint64)</span>
 964 {
 965     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] drawRangeElements()&quot;);
 966 }
 967 
<span class="line-modified"> 968 void WebGL2RenderingContext::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers)</span>
 969 {
 970     if (isContextLost())
 971         return;
<span class="line-modified"> 972     GCGLsizei n = buffers.size();</span>
<span class="line-modified"> 973     const GCGLenum* bufs = buffers.data();</span>
 974     if (!m_framebufferBinding) {
 975         if (n != 1) {
<span class="line-modified"> 976             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffers&quot;, &quot;more than one buffer&quot;);</span>
 977             return;
 978         }
<span class="line-modified"> 979         if (bufs[0] != GraphicsContextGL::BACK &amp;&amp; bufs[0] != GraphicsContextGL::NONE) {</span>
<span class="line-modified"> 980             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffers&quot;, &quot;BACK or NONE&quot;);</span>
 981             return;
 982         }
 983         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified"> 984         GCGLenum value = (bufs[0] == GraphicsContextGL::BACK) ? GraphicsContextGL::COLOR_ATTACHMENT0 : GraphicsContextGL::NONE;</span>
<span class="line-modified"> 985         graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);</span>
 986         setBackDrawBuffer(bufs[0]);
 987     } else {
 988         if (n &gt; getMaxDrawBuffers()) {
<span class="line-modified"> 989             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffers&quot;, &quot;more than max draw buffers&quot;);</span>
 990             return;
 991         }
<span class="line-modified"> 992         for (GCGLsizei i = 0; i &lt; n; ++i) {</span>
<span class="line-modified"> 993             if (bufs[i] != GraphicsContextGL::NONE &amp;&amp; bufs[i] != static_cast&lt;GCGLenum&gt;(GraphicsContextGL::COLOR_ATTACHMENT0 + i)) {</span>
<span class="line-modified"> 994                 synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffers&quot;, &quot;COLOR_ATTACHMENTi or NONE&quot;);</span>
 995                 return;
 996             }
 997         }
 998         m_framebufferBinding-&gt;drawBuffers(buffers);
 999     }
1000 }
1001 
<span class="line-modified">1002 void WebGL2RenderingContext::clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, Int32List&amp;&amp;, GCGLuint)</span>
1003 {
1004     switch (buffer) {
<span class="line-modified">1005     case GraphicsContextGL::COLOR:</span>
1006         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
<span class="line-modified">1007             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferiv&quot;, &quot;buffer index out of range&quot;);</span>
1008             return;
1009         }
1010         // TODO: Call clearBufferiv, requires gl3.h and ES3/gl.h
1011         break;
<span class="line-modified">1012     case GraphicsContextGL::STENCIL:</span>
1013         if (drawbuffer) {
<span class="line-modified">1014             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferiv&quot;, &quot;buffer index must be 0&quot;);</span>
1015             return;
1016         }
1017         // TODO: Call clearBufferiv, requires gl3.h and ES3/gl.h
1018         break;
<span class="line-modified">1019     case GraphicsContextGL::DEPTH:</span>
<span class="line-modified">1020     case GraphicsContextGL::DEPTH_STENCIL:</span>
1021     default:
<span class="line-modified">1022         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferiv&quot;, &quot;buffer argument must be COLOR or STENCIL&quot;);</span>
1023         break;
1024     }
1025 }
1026 
<span class="line-modified">1027 void WebGL2RenderingContext::clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, Uint32List&amp;&amp;, GCGLuint)</span>
1028 {
1029     switch (buffer) {
<span class="line-modified">1030     case GraphicsContextGL::COLOR:</span>
1031         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
<span class="line-modified">1032             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferuiv&quot;, &quot;buffer index out of range&quot;);</span>
1033             return;
1034         }
1035         // TODO: Call clearBufferuiv, requires gl3.h and ES3/gl.h
1036         break;
<span class="line-modified">1037     case GraphicsContextGL::DEPTH:</span>
<span class="line-modified">1038     case GraphicsContextGL::STENCIL:</span>
<span class="line-modified">1039     case GraphicsContextGL::DEPTH_STENCIL:</span>
1040     default:
<span class="line-modified">1041         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferuiv&quot;, &quot;buffer argument must be COLOR&quot;);</span>
1042         break;
1043     }
1044 }
1045 
<span class="line-modified">1046 void WebGL2RenderingContext::clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, Float32List&amp;&amp;, GCGLuint)</span>
1047 {
1048     switch (buffer) {
<span class="line-modified">1049     case GraphicsContextGL::COLOR:</span>
1050         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
<span class="line-modified">1051             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index out of range&quot;);</span>
1052             return;
1053         }
1054         // TODO: Call clearBufferfv, requires gl3.h and ES3/gl.h
1055         break;
<span class="line-modified">1056     case GraphicsContextGL::DEPTH:</span>
1057         if (drawbuffer) {
<span class="line-modified">1058             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index must be 0&quot;);</span>
1059             return;
1060         }
1061         // TODO: Call clearBufferfv, requires gl3.h and ES3/gl.h
1062         break;
<span class="line-modified">1063     case GraphicsContextGL::STENCIL:</span>
<span class="line-modified">1064     case GraphicsContextGL::DEPTH_STENCIL:</span>
1065     default:
<span class="line-modified">1066         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferfv&quot;, &quot;buffer argument must be COLOR OR DEPTH&quot;);</span>
1067         break;
1068     }
1069 }
1070 
<span class="line-modified">1071 void WebGL2RenderingContext::clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat, GCGLint)</span>
1072 {
1073     switch (buffer) {
<span class="line-modified">1074     case GraphicsContextGL::DEPTH_STENCIL:</span>
1075         if (drawbuffer) {
<span class="line-modified">1076             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index must be 0&quot;);</span>
1077             return;
1078         }
1079         // TODO: Call clearBufferfi, requires gl3.h and ES3/gl.h
1080         break;
<span class="line-modified">1081     case GraphicsContextGL::COLOR:</span>
<span class="line-modified">1082     case GraphicsContextGL::DEPTH:</span>
<span class="line-modified">1083     case GraphicsContextGL::STENCIL:</span>
1084     default:
<span class="line-modified">1085         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferfv&quot;, &quot;buffer argument must be DEPTH_STENCIL&quot;);</span>
1086         break;
1087     }
1088 }
1089 
1090 RefPtr&lt;WebGLQuery&gt; WebGL2RenderingContext::createQuery()
1091 {
<span class="line-modified">1092     if (isContextLostOrPending())</span>
<span class="line-modified">1093         return nullptr;</span>
<span class="line-added">1094 </span>
<span class="line-added">1095     auto query = WebGLQuery::create(*this);</span>
<span class="line-added">1096     addSharedObject(query.get());</span>
<span class="line-added">1097     return query;</span>
1098 }
1099 
1100 void WebGL2RenderingContext::deleteQuery(WebGLQuery*)
1101 {
1102     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteQuery()&quot;);
1103 }
1104 
<span class="line-modified">1105 GCGLboolean WebGL2RenderingContext::isQuery(WebGLQuery*)</span>
1106 {
1107     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isQuery()&quot;);
1108     return false;
1109 }
1110 
<span class="line-modified">1111 void WebGL2RenderingContext::beginQuery(GCGLenum target, WebGLQuery&amp; query)</span>
1112 {
<span class="line-modified">1113     if (isContextLostOrPending())</span>
<span class="line-added">1114         return;</span>
<span class="line-added">1115 </span>
<span class="line-added">1116     // FIXME: Add validation to prevent bad caching.</span>
<span class="line-added">1117 </span>
<span class="line-added">1118     // Only one query object can be active per target.</span>
<span class="line-added">1119     auto targetKey = (target == GraphicsContextGL::ANY_SAMPLES_PASSED_CONSERVATIVE) ? GraphicsContextGL::ANY_SAMPLES_PASSED : target;</span>
<span class="line-added">1120 </span>
<span class="line-added">1121     auto addResult = m_activeQueries.add(targetKey, makeRefPtr(&amp;query));</span>
<span class="line-added">1122 </span>
<span class="line-added">1123     if (!addResult.isNewEntry) {</span>
<span class="line-added">1124         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;beginQuery&quot;, &quot;Query object of target is already active&quot;);</span>
<span class="line-added">1125         return;</span>
<span class="line-added">1126     }</span>
<span class="line-added">1127 </span>
<span class="line-added">1128     m_context-&gt;beginQuery(target, query.object());</span>
1129 }
1130 
<span class="line-modified">1131 void WebGL2RenderingContext::endQuery(GCGLenum target)</span>
1132 {
<span class="line-modified">1133     if (isContextLostOrPending() || !scriptExecutionContext())</span>
<span class="line-added">1134         return;</span>
<span class="line-added">1135 </span>
<span class="line-added">1136     auto targetKey = (target == GraphicsContextGL::ANY_SAMPLES_PASSED_CONSERVATIVE) ? GraphicsContextGL::ANY_SAMPLES_PASSED : target;</span>
<span class="line-added">1137 </span>
<span class="line-added">1138     auto query = m_activeQueries.take(targetKey);</span>
<span class="line-added">1139     if (!query) {</span>
<span class="line-added">1140         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;endQuery&quot;, &quot;Query object of target is not active&quot;);</span>
<span class="line-added">1141         return;</span>
<span class="line-added">1142     }</span>
<span class="line-added">1143 </span>
<span class="line-added">1144     m_context-&gt;endQuery(target);</span>
<span class="line-added">1145 </span>
<span class="line-added">1146     // A query&#39;s result must not be made available until control has returned to the user agent&#39;s main loop.</span>
<span class="line-added">1147     scriptExecutionContext()-&gt;eventLoop().queueMicrotask([query] {</span>
<span class="line-added">1148         query-&gt;makeResultAvailable();</span>
<span class="line-added">1149     });</span>
1150 }
1151 
<span class="line-modified">1152 RefPtr&lt;WebGLQuery&gt; WebGL2RenderingContext::getQuery(GCGLenum, GCGLenum)</span>
1153 {
1154     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getquery()&quot;);
1155     return nullptr;
1156 }
1157 
<span class="line-modified">1158 WebGLAny WebGL2RenderingContext::getQueryParameter(WebGLQuery&amp; query, GCGLenum pname)</span>
1159 {
<span class="line-modified">1160     if (isContextLostOrPending())</span>
<span class="line-modified">1161         return nullptr;</span>
<span class="line-added">1162 </span>
<span class="line-added">1163     switch (pname) {</span>
<span class="line-added">1164     case GraphicsContextGL::QUERY_RESULT:</span>
<span class="line-added">1165     case GraphicsContextGL::QUERY_RESULT_AVAILABLE:</span>
<span class="line-added">1166         if (!query.isResultAvailable())</span>
<span class="line-added">1167             return 0;</span>
<span class="line-added">1168         break;</span>
<span class="line-added">1169     default:</span>
<span class="line-added">1170         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getQueryParameter&quot;, &quot;Invalid pname&quot;);</span>
<span class="line-added">1171         return nullptr;</span>
<span class="line-added">1172     }</span>
<span class="line-added">1173 </span>
<span class="line-added">1174     unsigned result = 0;</span>
<span class="line-added">1175     m_context-&gt;getQueryObjectuiv(query.object(), pname, &amp;result);</span>
<span class="line-added">1176     return result;</span>
1177 }
1178 
1179 RefPtr&lt;WebGLSampler&gt; WebGL2RenderingContext::createSampler()
1180 {
<span class="line-modified">1181     if (isContextLostOrPending())</span>
<span class="line-modified">1182         return nullptr;</span>
<span class="line-added">1183 </span>
<span class="line-added">1184     auto sampler = WebGLSampler::create(*this);</span>
<span class="line-added">1185     addSharedObject(sampler.get());</span>
<span class="line-added">1186     return sampler;</span>
1187 }
1188 
<span class="line-modified">1189 void WebGL2RenderingContext::deleteSampler(WebGLSampler* sampler)</span>
1190 {
<span class="line-modified">1191     if (isContextLostOrPending())</span>
<span class="line-added">1192         return;</span>
<span class="line-added">1193 </span>
<span class="line-added">1194     // One sampler can be bound to multiple texture units.</span>
<span class="line-added">1195     if (sampler) {</span>
<span class="line-added">1196         for (auto&amp; samplerSlot : m_boundSamplers) {</span>
<span class="line-added">1197             if (samplerSlot == sampler)</span>
<span class="line-added">1198                 samplerSlot = nullptr;</span>
<span class="line-added">1199         }</span>
<span class="line-added">1200     }</span>
<span class="line-added">1201 </span>
<span class="line-added">1202     deleteObject(sampler);</span>
1203 }
1204 
<span class="line-modified">1205 GCGLboolean WebGL2RenderingContext::isSampler(WebGLSampler* sampler)</span>
1206 {
<span class="line-modified">1207     if (isContextLostOrPending() || !sampler || sampler-&gt;isDeleted() || !validateWebGLObject(&quot;isSampler&quot;, sampler))</span>
<span class="line-modified">1208         return false;</span>
<span class="line-added">1209 </span>
<span class="line-added">1210     return m_context-&gt;isSampler(sampler-&gt;object());</span>
1211 }
1212 
<span class="line-modified">1213 void WebGL2RenderingContext::bindSampler(GCGLuint unit, WebGLSampler* sampler)</span>
1214 {
<span class="line-modified">1215     if (isContextLostOrPending() || m_boundSamplers[unit] == sampler)</span>
<span class="line-added">1216         return;</span>
<span class="line-added">1217 </span>
<span class="line-added">1218     if (sampler &amp;&amp; sampler-&gt;isDeleted()) {</span>
<span class="line-added">1219         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindSampler&quot;, &quot;cannot bind a deleted Sampler object&quot;);</span>
<span class="line-added">1220         return;</span>
<span class="line-added">1221     }</span>
<span class="line-added">1222 </span>
<span class="line-added">1223     m_context-&gt;bindSampler(unit, objectOrZero(sampler));</span>
<span class="line-added">1224     m_boundSamplers[unit] = sampler;</span>
1225 }
1226 
<span class="line-modified">1227 void WebGL2RenderingContext::samplerParameteri(WebGLSampler&amp; sampler, GCGLenum pname, GCGLint value)</span>
1228 {
<span class="line-modified">1229     if (isContextLostOrPending())</span>
<span class="line-added">1230         return;</span>
<span class="line-added">1231 </span>
<span class="line-added">1232     m_context-&gt;samplerParameteri(sampler.object(), pname, value);</span>
1233 }
1234 
<span class="line-modified">1235 void WebGL2RenderingContext::samplerParameterf(WebGLSampler&amp; sampler, GCGLenum pname, GCGLfloat value)</span>
1236 {
<span class="line-modified">1237     if (isContextLostOrPending())</span>
<span class="line-added">1238         return;</span>
<span class="line-added">1239 </span>
<span class="line-added">1240     m_context-&gt;samplerParameterf(sampler.object(), pname, value);</span>
1241 }
1242 
<span class="line-modified">1243 WebGLAny WebGL2RenderingContext::getSamplerParameter(WebGLSampler&amp; sampler, GCGLenum pname)</span>
1244 {
<span class="line-modified">1245     if (isContextLostOrPending())</span>
<span class="line-modified">1246         return nullptr;</span>
<span class="line-added">1247 </span>
<span class="line-added">1248     switch (pname) {</span>
<span class="line-added">1249     case GraphicsContextGL::TEXTURE_COMPARE_FUNC:</span>
<span class="line-added">1250     case GraphicsContextGL::TEXTURE_COMPARE_MODE:</span>
<span class="line-added">1251     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
<span class="line-added">1252     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
<span class="line-added">1253     case GraphicsContextGL::TEXTURE_WRAP_R:</span>
<span class="line-added">1254     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
<span class="line-added">1255     case GraphicsContextGL::TEXTURE_WRAP_T: {</span>
<span class="line-added">1256         int value = 0;</span>
<span class="line-added">1257         m_context-&gt;getSamplerParameteriv(sampler.object(), pname, &amp;value);</span>
<span class="line-added">1258         return value;</span>
<span class="line-added">1259     }</span>
<span class="line-added">1260     case GraphicsContextGL::TEXTURE_MAX_LOD:</span>
<span class="line-added">1261     case GraphicsContextGL::TEXTURE_MIN_LOD: {</span>
<span class="line-added">1262         float value = 0;</span>
<span class="line-added">1263         m_context-&gt;getSamplerParameterfv(sampler.object(), pname, &amp;value);</span>
<span class="line-added">1264         return value;</span>
<span class="line-added">1265     }</span>
<span class="line-added">1266     default:</span>
<span class="line-added">1267         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getSamplerParameter&quot;, &quot;Invalid pname&quot;);</span>
<span class="line-added">1268         return nullptr;</span>
<span class="line-added">1269     }</span>
1270 }
1271 
<span class="line-modified">1272 RefPtr&lt;WebGLSync&gt; WebGL2RenderingContext::fenceSync(GCGLenum, GCGLbitfield)</span>
1273 {
1274     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] fenceSync()&quot;);
1275     return nullptr;
1276 }
1277 
<span class="line-modified">1278 GCGLboolean WebGL2RenderingContext::isSync(WebGLSync*)</span>
1279 {
1280     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isSync()&quot;);
1281     return false;
1282 }
1283 
1284 void WebGL2RenderingContext::deleteSync(WebGLSync*)
1285 {
1286     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteSync()&quot;);
1287 }
1288 
<span class="line-modified">1289 GCGLenum WebGL2RenderingContext::clientWaitSync(WebGLSync&amp;, GCGLbitfield, GCGLuint64)</span>
1290 {
1291     // Note: Do not implement this function without consulting webkit-dev and WebGL
1292     // reviewers beforehand. Apple folks, see &lt;rdar://problem/36666458&gt;.
1293     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] clientWaitSync()&quot;);
1294     return 0;
1295 }
1296 
<span class="line-modified">1297 void WebGL2RenderingContext::waitSync(WebGLSync&amp;, GCGLbitfield, GCGLint64)</span>
1298 {
1299     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] waitSync()&quot;);
1300 }
1301 
<span class="line-modified">1302 WebGLAny WebGL2RenderingContext::getSyncParameter(WebGLSync&amp;, GCGLenum)</span>
1303 {
1304     // Note: Do not implement this function without consulting webkit-dev and WebGL
1305     // reviewers beforehand. Apple folks, see &lt;rdar://problem/36666458&gt;.
1306     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getSyncParameter()&quot;);
1307     return nullptr;
1308 }
1309 
1310 RefPtr&lt;WebGLTransformFeedback&gt; WebGL2RenderingContext::createTransformFeedback()
1311 {
<span class="line-modified">1312     if (isContextLostOrPending())</span>
<span class="line-modified">1313         return nullptr;</span>
<span class="line-added">1314 </span>
<span class="line-added">1315     auto transformFeedback = WebGLTransformFeedback::create(*this);</span>
<span class="line-added">1316     addSharedObject(transformFeedback.get());</span>
<span class="line-added">1317     return transformFeedback;</span>
1318 }
1319 
<span class="line-modified">1320 void WebGL2RenderingContext::deleteTransformFeedback(WebGLTransformFeedback* feedbackObject)</span>
1321 {
<span class="line-modified">1322     if (isContextLostOrPending())</span>
<span class="line-added">1323         return;</span>
<span class="line-added">1324 </span>
<span class="line-added">1325     if (m_boundTransformFeedback == feedbackObject)</span>
<span class="line-added">1326         m_boundTransformFeedback = nullptr;</span>
<span class="line-added">1327 </span>
<span class="line-added">1328     deleteObject(feedbackObject);</span>
1329 }
1330 
<span class="line-modified">1331 GCGLboolean WebGL2RenderingContext::isTransformFeedback(WebGLTransformFeedback* feedbackObject)</span>
1332 {
<span class="line-modified">1333     if (isContextLostOrPending() || !feedbackObject || feedbackObject-&gt;isDeleted() || !validateWebGLObject(&quot;isTransformFeedback&quot;, feedbackObject))</span>
<span class="line-modified">1334         return false;</span>
<span class="line-added">1335 </span>
<span class="line-added">1336     return m_context-&gt;isTransformFeedback(feedbackObject-&gt;object());</span>
1337 }
1338 
<span class="line-modified">1339 void WebGL2RenderingContext::bindTransformFeedback(GCGLenum target, WebGLTransformFeedback* feedbackObject)</span>
1340 {
<span class="line-modified">1341     if (isContextLostOrPending())</span>
<span class="line-added">1342         return;</span>
<span class="line-added">1343 </span>
<span class="line-added">1344     if (feedbackObject) {</span>
<span class="line-added">1345         if (feedbackObject-&gt;isDeleted()) {</span>
<span class="line-added">1346             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindTransformFeedback&quot;, &quot;cannot bind a deleted Transform Feedback object&quot;);</span>
<span class="line-added">1347             return;</span>
<span class="line-added">1348         }</span>
<span class="line-added">1349 </span>
<span class="line-added">1350         if (!validateWebGLObject(&quot;bindTransformFeedback&quot;, feedbackObject))</span>
<span class="line-added">1351             return;</span>
<span class="line-added">1352     }</span>
<span class="line-added">1353 </span>
<span class="line-added">1354     m_context-&gt;bindTransformFeedback(target, objectOrZero(feedbackObject));</span>
<span class="line-added">1355     m_boundTransformFeedback = feedbackObject;</span>
1356 }
1357 
<span class="line-modified">1358 void WebGL2RenderingContext::beginTransformFeedback(GCGLenum primitiveMode)</span>
1359 {
<span class="line-modified">1360     if (isContextLostOrPending())</span>
<span class="line-added">1361         return;</span>
<span class="line-added">1362 </span>
<span class="line-added">1363     m_context-&gt;beginTransformFeedback(primitiveMode);</span>
1364 }
1365 
1366 void WebGL2RenderingContext::endTransformFeedback()
1367 {
<span class="line-modified">1368     if (isContextLostOrPending())</span>
<span class="line-added">1369         return;</span>
<span class="line-added">1370 </span>
<span class="line-added">1371     m_context-&gt;endTransformFeedback();</span>
1372 }
1373 
<span class="line-modified">1374 void WebGL2RenderingContext::transformFeedbackVaryings(WebGLProgram&amp; program, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode)</span>
1375 {
<span class="line-modified">1376     if (isContextLostOrPending() || varyings.isEmpty() || !validateWebGLObject(&quot;transformFeedbackVaryings&quot;, &amp;program))</span>
<span class="line-added">1377         return;</span>
<span class="line-added">1378 </span>
<span class="line-added">1379     m_context-&gt;transformFeedbackVaryings(program.object(), varyings, bufferMode);</span>
1380 }
1381 
<span class="line-modified">1382 RefPtr&lt;WebGLActiveInfo&gt; WebGL2RenderingContext::getTransformFeedbackVarying(WebGLProgram&amp; program, GCGLuint index)</span>
1383 {
<span class="line-modified">1384     if (isContextLostOrPending() || !validateWebGLObject(&quot;getTransformFeedbackVarying&quot;, &amp;program))</span>
<span class="line-modified">1385         return nullptr;</span>
<span class="line-added">1386 </span>
<span class="line-added">1387     GraphicsContextGL::ActiveInfo info;</span>
<span class="line-added">1388     m_context-&gt;getTransformFeedbackVarying(program.object(), index, info);</span>
<span class="line-added">1389 </span>
<span class="line-added">1390     if (!info.name || !info.type || !info.size)</span>
<span class="line-added">1391         return nullptr;</span>
<span class="line-added">1392 </span>
<span class="line-added">1393     return WebGLActiveInfo::create(info.name, info.type, info.size);</span>
1394 }
1395 
1396 void WebGL2RenderingContext::pauseTransformFeedback()
1397 {
1398     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] pauseTransformFeedback()&quot;);
1399 }
1400 
1401 void WebGL2RenderingContext::resumeTransformFeedback()
1402 {
1403     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] resumeTransformFeedback()&quot;);
1404 }
1405 
<span class="line-modified">1406 void WebGL2RenderingContext::bindBufferBase(GCGLenum target, GCGLuint index, WebGLBuffer* buffer)</span>
1407 {
<span class="line-modified">1408     if (isContextLostOrPending())</span>
<span class="line-added">1409         return;</span>
<span class="line-added">1410 </span>
<span class="line-added">1411     switch (target) {</span>
<span class="line-added">1412     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-added">1413         if (index &gt;= m_boundTransformFeedbackBuffers.size()) {</span>
<span class="line-added">1414             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bindBufferBase&quot;, &quot;index out of range&quot;);</span>
<span class="line-added">1415             return;</span>
<span class="line-added">1416         }</span>
<span class="line-added">1417         break;</span>
<span class="line-added">1418     case GraphicsContextGL::UNIFORM_BUFFER:</span>
<span class="line-added">1419         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBufferBase&quot;, &quot;target not yet supported&quot;);</span>
<span class="line-added">1420         return;</span>
<span class="line-added">1421     default:</span>
<span class="line-added">1422         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBufferBase&quot;, &quot;invalid target&quot;);</span>
<span class="line-added">1423         return;</span>
<span class="line-added">1424     }</span>
<span class="line-added">1425 </span>
<span class="line-added">1426     if (!validateAndCacheBufferBinding(&quot;bindBufferBase&quot;, target, buffer))</span>
<span class="line-added">1427         return;</span>
<span class="line-added">1428 </span>
<span class="line-added">1429     m_context-&gt;bindBufferBase(target, index, objectOrZero(buffer));</span>
1430 }
1431 
<span class="line-modified">1432 void WebGL2RenderingContext::bindBufferRange(GCGLenum, GCGLuint, WebGLBuffer*, GCGLint64, GCGLint64)</span>
1433 {
1434     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] bindBufferRange()&quot;);
1435 }
1436 
<span class="line-modified">1437 WebGLAny WebGL2RenderingContext::getIndexedParameter(GCGLenum target, GCGLuint index)</span>
1438 {
<span class="line-added">1439     if (isContextLostOrPending())</span>
<span class="line-added">1440         return nullptr;</span>
<span class="line-added">1441 </span>
1442     switch (target) {
<span class="line-modified">1443     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_BINDING:</span>
<span class="line-modified">1444         if (index &gt;= m_boundTransformFeedbackBuffers.size()) {</span>
<span class="line-modified">1445             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getIndexedParameter&quot;, &quot;index out of range&quot;);</span>
<span class="line-modified">1446             return nullptr;</span>
<span class="line-modified">1447         }</span>
<span class="line-modified">1448         return m_boundTransformFeedbackBuffers[index];</span>
<span class="line-modified">1449     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_SIZE:</span>
<span class="line-added">1450     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_START:</span>
<span class="line-added">1451     case GraphicsContextGL::UNIFORM_BUFFER_BINDING:</span>
<span class="line-added">1452     case GraphicsContextGL::UNIFORM_BUFFER_SIZE:</span>
<span class="line-added">1453     case GraphicsContextGL::UNIFORM_BUFFER_START:</span>
<span class="line-added">1454         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getIndexedParameter&quot;, &quot;parameter name not yet supported&quot;);</span>
1455         return nullptr;
1456     default:
<span class="line-modified">1457         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getIndexedParameter&quot;, &quot;invalid parameter name&quot;);</span>
1458         return nullptr;
1459     }
1460 }
1461 
<span class="line-modified">1462 Optional&lt;Vector&lt;GCGLuint&gt;&gt; WebGL2RenderingContext::getUniformIndices(WebGLProgram&amp;, const Vector&lt;String&gt;&amp;)</span>
1463 {
1464     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getUniformIndices()&quot;);
1465     return WTF::nullopt;
1466 }
1467 
<span class="line-modified">1468 WebGLAny WebGL2RenderingContext::getActiveUniforms(WebGLProgram&amp; program, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname)</span>
1469 {
1470     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniforms&quot;, &amp;program))
1471         return nullptr;
1472 
1473     switch (pname) {
<span class="line-modified">1474     case GraphicsContextGL::UNIFORM_TYPE:</span>
<span class="line-modified">1475     case GraphicsContextGL::UNIFORM_SIZE:</span>
<span class="line-modified">1476     case GraphicsContextGL::UNIFORM_BLOCK_INDEX:</span>
<span class="line-modified">1477     case GraphicsContextGL::UNIFORM_OFFSET:</span>
<span class="line-modified">1478     case GraphicsContextGL::UNIFORM_ARRAY_STRIDE:</span>
<span class="line-modified">1479     case GraphicsContextGL::UNIFORM_MATRIX_STRIDE:</span>
<span class="line-modified">1480     case GraphicsContextGL::UNIFORM_IS_ROW_MAJOR:</span>
1481         {
<span class="line-modified">1482             Vector&lt;GCGLint&gt; params(uniformIndices.size(), 0);</span>
1483             m_context-&gt;getActiveUniforms(program.object(), uniformIndices, pname, params);
1484             return WTFMove(params);
1485         }
1486     default:
<span class="line-modified">1487         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getActiveUniforms&quot;, &quot;invalid parameter name&quot;);</span>
1488         return nullptr;
1489     }
1490 }
1491 
<span class="line-modified">1492 GCGLuint WebGL2RenderingContext::getUniformBlockIndex(WebGLProgram&amp;, const String&amp;)</span>
1493 {
1494     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getUniformBlockIndex()&quot;);
1495     return 0;
1496 }
1497 
<span class="line-modified">1498 WebGLAny WebGL2RenderingContext::getActiveUniformBlockParameter(WebGLProgram&amp;, GCGLuint, GCGLenum)</span>
1499 {
1500     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getActiveUniformBlockParameter()&quot;);
1501     return nullptr;
1502 }
1503 
<span class="line-modified">1504 WebGLAny WebGL2RenderingContext::getActiveUniformBlockName(WebGLProgram&amp;, GCGLuint)</span>
1505 {
1506     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getActiveUniformBlockName()&quot;);
1507     return nullptr;
1508 }
1509 
<span class="line-modified">1510 void WebGL2RenderingContext::uniformBlockBinding(WebGLProgram&amp;, GCGLuint, GCGLuint)</span>
1511 {
1512     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformBlockBinding()&quot;);
1513 }
1514 
1515 RefPtr&lt;WebGLVertexArrayObject&gt; WebGL2RenderingContext::createVertexArray()
1516 {
1517     if (isContextLost())
1518         return nullptr;
1519 
1520     auto object = WebGLVertexArrayObject::create(*this, WebGLVertexArrayObject::Type::User);
1521     addContextObject(object.get());
1522     return WTFMove(object);
1523 }
1524 
1525 void WebGL2RenderingContext::deleteVertexArray(WebGLVertexArrayObject* arrayObject)
1526 {
1527     if (!arrayObject || isContextLost())
1528         return;
1529 
1530     if (arrayObject-&gt;isDeleted())
1531         return;
1532 
1533     if (!arrayObject-&gt;isDefaultObject() &amp;&amp; arrayObject == m_boundVertexArrayObject)
1534 #if USE(OPENGL_ES)
1535         setBoundVertexArrayObject(nullptr);
1536 #else
1537         bindVertexArray(nullptr); // The default VAO was removed in OpenGL 3.3 but not from WebGL 2; bind the default for WebGL to use.
1538 #endif
1539 
<span class="line-modified">1540     arrayObject-&gt;deleteObject(graphicsContextGL());</span>
1541 }
1542 
<span class="line-modified">1543 GCGLboolean WebGL2RenderingContext::isVertexArray(WebGLVertexArrayObject* arrayObject)</span>
1544 {
1545     if (!arrayObject || isContextLost())
1546         return false;
1547 
1548     if (!arrayObject-&gt;hasEverBeenBound() || !arrayObject-&gt;validate(0, *this))
1549         return false;
1550 
1551     return m_context-&gt;isVertexArray(arrayObject-&gt;object());
1552 }
1553 
1554 void WebGL2RenderingContext::bindVertexArray(WebGLVertexArrayObject* arrayObject)
1555 {
1556     if (isContextLost())
1557         return;
1558 
1559     if (arrayObject &amp;&amp; (arrayObject-&gt;isDeleted() || !arrayObject-&gt;validate(0, *this) || !m_contextObjects.contains(arrayObject))) {
<span class="line-modified">1560         m_context-&gt;synthesizeGLError(GraphicsContextGL::INVALID_OPERATION);</span>
1561         return;
1562     }
1563     if (arrayObject &amp;&amp; !arrayObject-&gt;isDefaultObject() &amp;&amp; arrayObject-&gt;object()) {
1564         m_context-&gt;bindVertexArray(arrayObject-&gt;object());
1565 
1566         arrayObject-&gt;setHasEverBeenBound();
1567         setBoundVertexArrayObject(arrayObject);
1568     } else {
1569         m_context-&gt;bindVertexArray(m_defaultVertexArrayObject-&gt;object());
1570         setBoundVertexArrayObject(m_defaultVertexArrayObject.get());
1571     }
1572 }
1573 
1574 WebGLExtension* WebGL2RenderingContext::getExtension(const String&amp; name)
1575 {
1576     if (isContextLostOrPending())
1577         return nullptr;
1578 
1579 #define ENABLE_IF_REQUESTED(type, variable, nameLiteral, canEnable) \
1580     if (equalIgnoringASCIICase(name, nameLiteral)) { \
1581         if (!variable) { \
1582             variable = (canEnable) ? makeUnique&lt;type&gt;(*this) : nullptr; \
1583             if (variable != nullptr) \
1584                 InspectorInstrumentation::didEnableExtension(*this, name); \
1585         } \
1586         return variable.get(); \
1587     }
1588 
1589     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));

1590     ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
1591     ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
1592     ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
1593     ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
1594     ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);
<span class="line-added">1595     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));</span>
1596     ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));
<span class="line-added">1597     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC, m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;, WebGLCompressedTextureETC::supported(*this));</span>
<span class="line-added">1598     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC1, m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;, WebGLCompressedTextureETC1::supported(*this));</span>
1599     ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
1600     ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
<span class="line-modified">1601     ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*graphicsContextGL()));</span>

1602     ENABLE_IF_REQUESTED(WebGLDebugRendererInfo, m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;, true);
1603     ENABLE_IF_REQUESTED(WebGLDebugShaders, m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;, m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s));
1604     return nullptr;
1605 }
1606 
1607 Optional&lt;Vector&lt;String&gt;&gt; WebGL2RenderingContext::getSupportedExtensions()
1608 {
1609     if (isContextLost())
1610         return WTF::nullopt;
1611 
1612     Vector&lt;String&gt; result;
1613 
1614     if (m_isPendingPolicyResolution)
1615         return result;
1616 
1617     auto&amp; extensions = m_context-&gt;getExtensions();
1618     if (extensions.supports(&quot;GL_OES_texture_float&quot;_s))
1619         result.append(&quot;OES_texture_float&quot;_s);
1620     if (extensions.supports(&quot;GL_OES_texture_float_linear&quot;_s))
1621         result.append(&quot;OES_texture_float_linear&quot;_s);
1622     if (extensions.supports(&quot;GL_OES_texture_half_float&quot;_s))
1623         result.append(&quot;OES_texture_half_float&quot;_s);
1624     if (extensions.supports(&quot;GL_OES_texture_half_float_linear&quot;_s))
1625         result.append(&quot;OES_texture_half_float_linear&quot;_s);
1626     if (extensions.supports(&quot;GL_EXT_texture_filter_anisotropic&quot;_s))
<span class="line-modified">1627         result.append(&quot;EXT_texture_filter_anisotropic&quot;_s);</span>
<span class="line-added">1628     if (WebGLCompressedTextureASTC::supported(*this))</span>
<span class="line-added">1629         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);</span>
1630     if (WebGLCompressedTextureATC::supported(*this))
1631         result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);
<span class="line-added">1632     if (WebGLCompressedTextureETC::supported(*this))</span>
<span class="line-added">1633         result.append(&quot;WEBGL_compressed_texture_etc&quot;_s);</span>
<span class="line-added">1634     if (WebGLCompressedTextureETC1::supported(*this))</span>
<span class="line-added">1635         result.append(&quot;WEBGL_compressed_texture_etc1&quot;_s);</span>
1636     if (WebGLCompressedTexturePVRTC::supported(*this))
1637         result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
1638     if (WebGLCompressedTextureS3TC::supported(*this))
1639         result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
<span class="line-modified">1640     if (WebGLDepthTexture::supported(*graphicsContextGL()))</span>


1641         result.append(&quot;WEBGL_depth_texture&quot;_s);
1642     result.append(&quot;WEBGL_lose_context&quot;_s);
1643     if (extensions.supports(&quot;GL_ANGLE_translated_shader_source&quot;_s))
1644         result.append(&quot;WEBGL_debug_shaders&quot;_s);
1645     result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
1646 
1647     return result;
1648 }
1649 
<span class="line-modified">1650 static bool validateDefaultFramebufferAttachment(GCGLenum&amp; attachment)</span>
1651 {
1652     switch (attachment) {
<span class="line-modified">1653     case GraphicsContextGL::BACK:</span>
1654         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified">1655         attachment = GraphicsContextGL::COLOR_ATTACHMENT0;</span>
1656         return true;
<span class="line-modified">1657     case GraphicsContextGL::DEPTH:</span>
<span class="line-modified">1658     case GraphicsContextGL::STENCIL:</span>
1659         return true;
1660     }
1661 
1662     return false;
1663 }
1664 
<span class="line-modified">1665 WebGLAny WebGL2RenderingContext::getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname)</span>
1666 {
1667     const char* functionName = &quot;getFramebufferAttachmentParameter&quot;;
1668     if (isContextLostOrPending() || !validateFramebufferTarget(functionName, target))
1669         return nullptr;
1670 
<span class="line-modified">1671     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
1672 
1673     if (!targetFramebuffer) {
1674         // OpenGL ES 3: Default framebuffer is bound.
1675         if (!validateDefaultFramebufferAttachment(attachment)) {
<span class="line-modified">1676             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
1677             return nullptr;
1678         }
<span class="line-modified">1679         GCGLint value = 0;</span>
1680         m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1681         return value;
1682     }
1683     if (!validateNonDefaultFramebufferAttachment(functionName, attachment))
1684         return nullptr;
1685 
1686     auto object = makeRefPtr(targetFramebuffer-&gt;getAttachmentObject(attachment));
1687     if (!object) {
<span class="line-modified">1688         if (pname == GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)</span>
<span class="line-modified">1689             return static_cast&lt;unsigned&gt;(GraphicsContextGL::NONE);</span>
<span class="line-modified">1690         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid parameter name&quot;);</span>
1691         return nullptr;
1692     }
1693 
1694     switch (pname) {
<span class="line-modified">1695     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_RED_SIZE:</span>
<span class="line-modified">1696     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:</span>
<span class="line-modified">1697     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:</span>
<span class="line-modified">1698     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:</span>
<span class="line-modified">1699     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:</span>
<span class="line-modified">1700     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:</span>
<span class="line-modified">1701     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: {</span>
<span class="line-modified">1702         GCGLint value = 0;</span>
1703         m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1704         return value;
1705     }
1706     }
1707 
1708     if (object-&gt;isTexture()) {
1709         switch (pname) {
<span class="line-modified">1710         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">1711             return static_cast&lt;unsigned&gt;(GraphicsContextGL::TEXTURE);</span>
<span class="line-modified">1712         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
1713             return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
<span class="line-modified">1714         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:</span>
<span class="line-modified">1715         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:</span>
<span class="line-modified">1716         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: {</span>
<span class="line-modified">1717             GCGLint value = 0;</span>
1718             m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1719             return value;
1720         }
1721         default:
<span class="line-modified">1722             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid parameter name for texture attachment&quot;);</span>
1723             return nullptr;
1724         }
1725     } else {
1726         ASSERT(object-&gt;isRenderbuffer());
1727         switch (pname) {
<span class="line-modified">1728         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">1729             return static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER);</span>
<span class="line-modified">1730         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
1731             return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
<span class="line-modified">1732         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING : {</span>
1733             auto&amp; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object);
1734             auto format = renderBuffer.getInternalFormat();
<span class="line-modified">1735             if (format == GraphicsContextGL::SRGB8_ALPHA8</span>
<span class="line-modified">1736                 || format == GraphicsContextGL::COMPRESSED_SRGB8_ETC2</span>
<span class="line-modified">1737                 || format == GraphicsContextGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC</span>
<span class="line-modified">1738                 || format == GraphicsContextGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2) {</span>
<span class="line-modified">1739                 return static_cast&lt;unsigned&gt;(GraphicsContextGL::SRGB);</span>
1740             }
<span class="line-modified">1741             return static_cast&lt;unsigned&gt;(GraphicsContextGL::LINEAR);</span>
1742         }
1743         default:
<span class="line-modified">1744             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
1745             return nullptr;
1746         }
1747     }
1748 }
1749 
<span class="line-modified">1750 bool WebGL2RenderingContext::validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment)</span>
1751 {
1752     return validateFramebufferTarget(functionName, target) &amp;&amp; validateNonDefaultFramebufferAttachment(functionName, attachment);
1753 }
1754 
<span class="line-modified">1755 bool WebGL2RenderingContext::validateFramebufferTarget(const char* functionName, GCGLenum target)</span>
1756 {
1757     switch (target) {
<span class="line-modified">1758     case GraphicsContextGL::FRAMEBUFFER:</span>
<span class="line-modified">1759     case GraphicsContextGL::DRAW_FRAMEBUFFER:</span>
<span class="line-modified">1760     case GraphicsContextGL::READ_FRAMEBUFFER:</span>
1761         return true;
1762     }
1763 
<span class="line-modified">1764     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
1765     return false;
1766 }
1767 
<span class="line-modified">1768 bool WebGL2RenderingContext::validateNonDefaultFramebufferAttachment(const char* functionName, GCGLenum attachment)</span>
1769 {
1770     switch (attachment) {
<span class="line-modified">1771     case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
<span class="line-modified">1772     case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
<span class="line-modified">1773     case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
1774         return true;
1775     default:
<span class="line-modified">1776         if (attachment &gt;= GraphicsContextGL::COLOR_ATTACHMENT0 &amp;&amp; attachment &lt; static_cast&lt;GCGLenum&gt;(GraphicsContextGL::COLOR_ATTACHMENT0 + getMaxColorAttachments()))</span>
1777             return true;
1778     }
1779 
<span class="line-modified">1780     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
1781     return false;
1782 }
1783 
<span class="line-modified">1784 GCGLint WebGL2RenderingContext::getMaxDrawBuffers()</span>
1785 {
1786     if (!m_maxDrawBuffers)
<span class="line-modified">1787         m_context-&gt;getIntegerv(GraphicsContextGL::MAX_DRAW_BUFFERS, &amp;m_maxDrawBuffers);</span>
1788     return m_maxDrawBuffers;
1789 }
1790 
<span class="line-modified">1791 GCGLint WebGL2RenderingContext::getMaxColorAttachments()</span>
1792 {
1793     // DrawBuffers requires MAX_COLOR_ATTACHMENTS == MAX_DRAW_BUFFERS
1794     if (!m_maxColorAttachments)
<span class="line-modified">1795         m_context-&gt;getIntegerv(GraphicsContextGL::MAX_DRAW_BUFFERS, &amp;m_maxColorAttachments);</span>
1796     return m_maxColorAttachments;
1797 }
1798 
<span class="line-modified">1799 void WebGL2RenderingContext::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)</span>
1800 {
1801     if (isContextLostOrPending())
1802         return;
<span class="line-modified">1803     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">1804         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);</span>
1805         return;
1806     }
1807     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">1808         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);</span>
1809         return;
1810     }
1811     if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
1812         return;
1813     switch (internalformat) {
<span class="line-modified">1814     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">1815     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified">1816     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified">1817     case GraphicsContextGL::RGBA32I:</span>
<span class="line-modified">1818     case GraphicsContextGL::RGBA32UI:</span>
<span class="line-modified">1819     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified">1820     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified">1821     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified">1822     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified">1823     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified">1824     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified">1825     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="line-modified">1826     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">1827     case GraphicsContextGL::RG32I:</span>
<span class="line-modified">1828     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified">1829     case GraphicsContextGL::RG16I:</span>
<span class="line-modified">1830     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified">1831     case GraphicsContextGL::RG8:</span>
<span class="line-modified">1832     case GraphicsContextGL::RG8I:</span>
<span class="line-modified">1833     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified">1834     case GraphicsContextGL::R32I:</span>
<span class="line-modified">1835     case GraphicsContextGL::R32UI:</span>
<span class="line-modified">1836     case GraphicsContextGL::R16I:</span>
<span class="line-modified">1837     case GraphicsContextGL::R16UI:</span>
<span class="line-modified">1838     case GraphicsContextGL::R8:</span>
<span class="line-modified">1839     case GraphicsContextGL::R8I:</span>
<span class="line-modified">1840     case GraphicsContextGL::R8UI:</span>
<span class="line-modified">1841     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">1842     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">1843     case GraphicsContextGL::RGB8:</span>
<span class="line-modified">1844     case GraphicsContextGL::STENCIL_INDEX8:</span>
<span class="line-modified">1845     case GraphicsContextGL::SRGB8_ALPHA8:</span>
1846         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
1847         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
1848         m_renderbufferBinding-&gt;setIsValid(true);
1849         m_renderbufferBinding-&gt;setSize(width, height);
1850         break;
<span class="line-modified">1851     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
<span class="line-modified">1852     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
1853         if (!isDepthStencilSupported()) {
<span class="line-modified">1854             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
1855             return;
1856         }
1857         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
1858         m_renderbufferBinding-&gt;setSize(width, height);
1859         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
1860         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
1861         break;
1862     default:
<span class="line-modified">1863         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
1864         return;
1865     }
1866     applyStencilTest();
1867 }
1868 
<span class="line-modified">1869 void WebGL2RenderingContext::hint(GCGLenum target, GCGLenum mode)</span>
1870 {
1871     if (isContextLostOrPending())
1872         return;
1873     bool isValid = false;
1874     switch (target) {
<span class="line-modified">1875     case GraphicsContextGL::GENERATE_MIPMAP_HINT:</span>
<span class="line-modified">1876     case GraphicsContextGL::FRAGMENT_SHADER_DERIVATIVE_HINT:</span>
1877         isValid = true;
1878         break;
1879     }
1880     if (!isValid) {
<span class="line-modified">1881         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);</span>
1882         return;
1883     }
1884     m_context-&gt;hint(target, mode);
1885 }
1886 
<span class="line-modified">1887 GCGLenum WebGL2RenderingContext::baseInternalFormatFromInternalFormat(GCGLenum internalformat)</span>
1888 {
1889     // Handles sized, unsized, and compressed internal formats.
1890     switch (internalformat) {
<span class="line-modified">1891     case GraphicsContextGL::R8:</span>
<span class="line-modified">1892     case GraphicsContextGL::R8_SNORM:</span>
<span class="line-modified">1893     case GraphicsContextGL::R16F:</span>
<span class="line-modified">1894     case GraphicsContextGL::R32F:</span>
<span class="line-modified">1895     case GraphicsContextGL::COMPRESSED_R11_EAC:</span>
<span class="line-modified">1896     case GraphicsContextGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-modified">1897         return GraphicsContextGL::RED;</span>
<span class="line-modified">1898     case GraphicsContextGL::R8I:</span>
<span class="line-modified">1899     case GraphicsContextGL::R8UI:</span>
<span class="line-modified">1900     case GraphicsContextGL::R16I:</span>
<span class="line-modified">1901     case GraphicsContextGL::R16UI:</span>
<span class="line-modified">1902     case GraphicsContextGL::R32I:</span>
<span class="line-modified">1903     case GraphicsContextGL::R32UI:</span>
<span class="line-modified">1904         return GraphicsContextGL::RED_INTEGER;</span>
<span class="line-modified">1905     case GraphicsContextGL::RG8:</span>
<span class="line-modified">1906     case GraphicsContextGL::RG8_SNORM:</span>
<span class="line-modified">1907     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">1908     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">1909     case GraphicsContextGL::COMPRESSED_RG11_EAC:</span>
<span class="line-modified">1910     case GraphicsContextGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-modified">1911         return GraphicsContextGL::RG;</span>
<span class="line-modified">1912     case GraphicsContextGL::RG8I:</span>
<span class="line-modified">1913     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified">1914     case GraphicsContextGL::RG16I:</span>
<span class="line-modified">1915     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified">1916     case GraphicsContextGL::RG32I:</span>
<span class="line-modified">1917     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified">1918         return GraphicsContextGL::RG_INTEGER;</span>
<span class="line-modified">1919     case GraphicsContextGL::RGB8:</span>
<span class="line-modified">1920     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="line-modified">1921     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">1922     case GraphicsContextGL::SRGB8:</span>
<span class="line-modified">1923     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">1924     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">1925     case GraphicsContextGL::RGB:</span>
<span class="line-modified">1926     case GraphicsContextGL::COMPRESSED_RGB8_ETC2:</span>
<span class="line-modified">1927     case GraphicsContextGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-modified">1928         return GraphicsContextGL::RGB;</span>
<span class="line-modified">1929     case GraphicsContextGL::RGB8I:</span>
<span class="line-modified">1930     case GraphicsContextGL::RGB8UI:</span>
<span class="line-modified">1931     case GraphicsContextGL::RGB16I:</span>
<span class="line-modified">1932     case GraphicsContextGL::RGB16UI:</span>
<span class="line-modified">1933     case GraphicsContextGL::RGB32I:</span>
<span class="line-modified">1934     case GraphicsContextGL::RGB32UI:</span>
<span class="line-modified">1935         return GraphicsContextGL::RGB_INTEGER;</span>
<span class="line-modified">1936     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">1937     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">1938     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified">1939     case GraphicsContextGL::RGBA8_SNORM:</span>
<span class="line-modified">1940     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified">1941     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="line-modified">1942     case GraphicsContextGL::RGBA16F:</span>
<span class="line-modified">1943     case GraphicsContextGL::RGBA32F:</span>
<span class="line-modified">1944     case GraphicsContextGL::RGBA:</span>
<span class="line-modified">1945     case GraphicsContextGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-modified">1946     case GraphicsContextGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-modified">1947     case GraphicsContextGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-modified">1948     case GraphicsContextGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:</span>
<span class="line-modified">1949         return GraphicsContextGL::RGBA;</span>
<span class="line-modified">1950     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified">1951     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified">1952     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="line-modified">1953     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified">1954     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified">1955     case GraphicsContextGL::RGBA32I:</span>
<span class="line-modified">1956     case GraphicsContextGL::RGBA32UI:</span>
<span class="line-modified">1957         return GraphicsContextGL::RGBA_INTEGER;</span>
<span class="line-modified">1958     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">1959     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified">1960     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified">1961         return GraphicsContextGL::DEPTH_COMPONENT;</span>
<span class="line-modified">1962     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="line-modified">1963     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
<span class="line-modified">1964         return GraphicsContextGL::DEPTH_STENCIL;</span>
<span class="line-modified">1965     case GraphicsContextGL::LUMINANCE:</span>
<span class="line-modified">1966     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="line-modified">1967     case GraphicsContextGL::ALPHA:</span>
1968         return internalformat;
1969     default:
1970         ASSERT_NOT_REACHED();
<span class="line-modified">1971         return GraphicsContextGL::NONE;</span>
1972     }
1973 }
1974 
<span class="line-modified">1975 bool WebGL2RenderingContext::isIntegerFormat(GCGLenum internalformat)</span>
1976 {
1977     switch (baseInternalFormatFromInternalFormat(internalformat)) {
<span class="line-modified">1978     case GraphicsContextGL::RED_INTEGER:</span>
<span class="line-modified">1979     case GraphicsContextGL::RG_INTEGER:</span>
<span class="line-modified">1980     case GraphicsContextGL::RGB_INTEGER:</span>
<span class="line-modified">1981     case GraphicsContextGL::RGBA_INTEGER:</span>
1982         return true;
1983     }
1984     return false;
1985 }
1986 
<span class="line-modified">1987 WebGLAny WebGL2RenderingContext::getParameter(GCGLenum pname)</span>
1988 {
1989     if (isContextLostOrPending())
1990         return nullptr;
1991     switch (pname) {
<span class="line-modified">1992     case GraphicsContextGL::ACTIVE_TEXTURE:</span>
1993         return getUnsignedIntParameter(pname);
<span class="line-modified">1994     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:</span>
1995         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">1996     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:</span>
1997         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">1998     case GraphicsContextGL::ALPHA_BITS:</span>
1999         if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
2000             return 0;
2001         return getIntParameter(pname);
<span class="line-modified">2002     case GraphicsContextGL::ARRAY_BUFFER_BINDING:</span>
2003         return m_boundArrayBuffer;
<span class="line-modified">2004     case GraphicsContextGL::BLEND:</span>
2005         return getBooleanParameter(pname);
<span class="line-modified">2006     case GraphicsContextGL::BLEND_COLOR:</span>
2007         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">2008     case GraphicsContextGL::BLEND_DST_ALPHA:</span>
2009         return getUnsignedIntParameter(pname);
<span class="line-modified">2010     case GraphicsContextGL::BLEND_DST_RGB:</span>
2011         return getUnsignedIntParameter(pname);
<span class="line-modified">2012     case GraphicsContextGL::BLEND_EQUATION_ALPHA:</span>
2013         return getUnsignedIntParameter(pname);
<span class="line-modified">2014     case GraphicsContextGL::BLEND_EQUATION_RGB:</span>
2015         return getUnsignedIntParameter(pname);
<span class="line-modified">2016     case GraphicsContextGL::BLEND_SRC_ALPHA:</span>
2017         return getUnsignedIntParameter(pname);
<span class="line-modified">2018     case GraphicsContextGL::BLEND_SRC_RGB:</span>
2019         return getUnsignedIntParameter(pname);
<span class="line-modified">2020     case GraphicsContextGL::BLUE_BITS:</span>
2021         return getIntParameter(pname);
<span class="line-modified">2022     case GraphicsContextGL::COLOR_CLEAR_VALUE:</span>
2023         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">2024     case GraphicsContextGL::COLOR_WRITEMASK:</span>
2025         return getBooleanArrayParameter(pname);
<span class="line-modified">2026     case GraphicsContextGL::COMPRESSED_TEXTURE_FORMATS:</span>
2027         return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
<span class="line-modified">2028     case GraphicsContextGL::CULL_FACE:</span>
2029         return getBooleanParameter(pname);
<span class="line-modified">2030     case GraphicsContextGL::CULL_FACE_MODE:</span>
2031         return getUnsignedIntParameter(pname);
<span class="line-modified">2032     case GraphicsContextGL::CURRENT_PROGRAM:</span>
2033         return m_currentProgram;
<span class="line-modified">2034     case GraphicsContextGL::DEPTH_BITS:</span>
2035         if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
2036             return 0;
2037         return getIntParameter(pname);
<span class="line-modified">2038     case GraphicsContextGL::DEPTH_CLEAR_VALUE:</span>
2039         return getFloatParameter(pname);
<span class="line-modified">2040     case GraphicsContextGL::DEPTH_FUNC:</span>
2041         return getUnsignedIntParameter(pname);
<span class="line-modified">2042     case GraphicsContextGL::DEPTH_RANGE:</span>
2043         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">2044     case GraphicsContextGL::DEPTH_TEST:</span>
2045         return getBooleanParameter(pname);
<span class="line-modified">2046     case GraphicsContextGL::DEPTH_WRITEMASK:</span>
2047         return getBooleanParameter(pname);
<span class="line-modified">2048     case GraphicsContextGL::DITHER:</span>
2049         return getBooleanParameter(pname);
<span class="line-modified">2050     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER_BINDING:</span>
2051         return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
<span class="line-modified">2052     case GraphicsContextGL::FRAMEBUFFER_BINDING:</span>
2053         return m_framebufferBinding;
<span class="line-modified">2054     case GraphicsContextGL::FRONT_FACE:</span>
2055         return getUnsignedIntParameter(pname);
<span class="line-modified">2056     case GraphicsContextGL::GENERATE_MIPMAP_HINT:</span>
2057         return getUnsignedIntParameter(pname);
<span class="line-modified">2058     case GraphicsContextGL::GREEN_BITS:</span>
2059         return getIntParameter(pname);
<span class="line-modified">2060     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_FORMAT:</span>
2061         return getIntParameter(pname);
<span class="line-modified">2062     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_TYPE:</span>
2063         return getIntParameter(pname);
<span class="line-modified">2064     case GraphicsContextGL::LINE_WIDTH:</span>
2065         return getFloatParameter(pname);
<span class="line-modified">2066     case GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS:</span>
2067         return getIntParameter(pname);
<span class="line-modified">2068     case GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE:</span>
2069         return getIntParameter(pname);
<span class="line-modified">2070     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_VECTORS:</span>
2071         return getIntParameter(pname);
<span class="line-modified">2072     case GraphicsContextGL::MAX_RENDERBUFFER_SIZE:</span>
2073         return getIntParameter(pname);
<span class="line-modified">2074     case GraphicsContextGL::MAX_TEXTURE_IMAGE_UNITS:</span>
2075         return getIntParameter(pname);
<span class="line-modified">2076     case GraphicsContextGL::MAX_TEXTURE_SIZE:</span>
2077         return getIntParameter(pname);
<span class="line-modified">2078     case GraphicsContextGL::MAX_VARYING_VECTORS:</span>
2079         return getIntParameter(pname);
<span class="line-modified">2080     case GraphicsContextGL::MAX_VERTEX_ATTRIBS:</span>
2081         return getIntParameter(pname);
<span class="line-modified">2082     case GraphicsContextGL::MAX_VERTEX_TEXTURE_IMAGE_UNITS:</span>
2083         return getIntParameter(pname);
<span class="line-modified">2084     case GraphicsContextGL::MAX_VERTEX_UNIFORM_VECTORS:</span>
2085         return getIntParameter(pname);
<span class="line-modified">2086     case GraphicsContextGL::MAX_VIEWPORT_DIMS:</span>
2087         return getWebGLIntArrayParameter(pname);
<span class="line-modified">2088     case GraphicsContextGL::NUM_SHADER_BINARY_FORMATS:</span>
2089         return getIntParameter(pname);
<span class="line-modified">2090     case GraphicsContextGL::PACK_ALIGNMENT:</span>
2091         return getIntParameter(pname);
<span class="line-modified">2092     case GraphicsContextGL::POLYGON_OFFSET_FACTOR:</span>
2093         return getFloatParameter(pname);
<span class="line-modified">2094     case GraphicsContextGL::POLYGON_OFFSET_FILL:</span>
2095         return getBooleanParameter(pname);
<span class="line-modified">2096     case GraphicsContextGL::POLYGON_OFFSET_UNITS:</span>
2097         return getFloatParameter(pname);
<span class="line-modified">2098     case GraphicsContextGL::RED_BITS:</span>
2099         return getIntParameter(pname);
<span class="line-modified">2100     case GraphicsContextGL::RENDERBUFFER_BINDING:</span>
2101         return m_renderbufferBinding;
<span class="line-modified">2102     case GraphicsContextGL::RENDERER:</span>
2103         return &quot;WebKit WebGL&quot;_str;
<span class="line-modified">2104     case GraphicsContextGL::SAMPLE_BUFFERS:</span>
2105         return getIntParameter(pname);
<span class="line-modified">2106     case GraphicsContextGL::SAMPLE_COVERAGE_INVERT:</span>
2107         return getBooleanParameter(pname);
<span class="line-modified">2108     case GraphicsContextGL::SAMPLE_COVERAGE_VALUE:</span>
2109         return getFloatParameter(pname);
<span class="line-modified">2110     case GraphicsContextGL::SAMPLES:</span>
2111         return getIntParameter(pname);
<span class="line-modified">2112     case GraphicsContextGL::SCISSOR_BOX:</span>
2113         return getWebGLIntArrayParameter(pname);
<span class="line-modified">2114     case GraphicsContextGL::SCISSOR_TEST:</span>
2115         return getBooleanParameter(pname);
<span class="line-modified">2116     case GraphicsContextGL::SHADING_LANGUAGE_VERSION:</span>
<span class="line-modified">2117         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContextGL::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;</span>
<span class="line-modified">2118     case GraphicsContextGL::STENCIL_BACK_FAIL:</span>
2119         return getUnsignedIntParameter(pname);
<span class="line-modified">2120     case GraphicsContextGL::STENCIL_BACK_FUNC:</span>
2121         return getUnsignedIntParameter(pname);
<span class="line-modified">2122     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_FAIL:</span>
2123         return getUnsignedIntParameter(pname);
<span class="line-modified">2124     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_PASS:</span>
2125         return getUnsignedIntParameter(pname);
<span class="line-modified">2126     case GraphicsContextGL::STENCIL_BACK_REF:</span>
2127         return getIntParameter(pname);
<span class="line-modified">2128     case GraphicsContextGL::STENCIL_BACK_VALUE_MASK:</span>
2129         return getUnsignedIntParameter(pname);
<span class="line-modified">2130     case GraphicsContextGL::STENCIL_BACK_WRITEMASK:</span>
2131         return getUnsignedIntParameter(pname);
<span class="line-modified">2132     case GraphicsContextGL::STENCIL_BITS:</span>
2133         if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
2134             return 0;
2135         return getIntParameter(pname);
<span class="line-modified">2136     case GraphicsContextGL::STENCIL_CLEAR_VALUE:</span>
2137         return getIntParameter(pname);
<span class="line-modified">2138     case GraphicsContextGL::STENCIL_FAIL:</span>
2139         return getUnsignedIntParameter(pname);
<span class="line-modified">2140     case GraphicsContextGL::STENCIL_FUNC:</span>
2141         return getUnsignedIntParameter(pname);
<span class="line-modified">2142     case GraphicsContextGL::STENCIL_PASS_DEPTH_FAIL:</span>
2143         return getUnsignedIntParameter(pname);
<span class="line-modified">2144     case GraphicsContextGL::STENCIL_PASS_DEPTH_PASS:</span>
2145         return getUnsignedIntParameter(pname);
<span class="line-modified">2146     case GraphicsContextGL::STENCIL_REF:</span>
2147         return getIntParameter(pname);
<span class="line-modified">2148     case GraphicsContextGL::STENCIL_TEST:</span>
2149         return getBooleanParameter(pname);
<span class="line-modified">2150     case GraphicsContextGL::STENCIL_VALUE_MASK:</span>
2151         return getUnsignedIntParameter(pname);
<span class="line-modified">2152     case GraphicsContextGL::STENCIL_WRITEMASK:</span>
2153         return getUnsignedIntParameter(pname);
<span class="line-modified">2154     case GraphicsContextGL::SUBPIXEL_BITS:</span>
2155         return getIntParameter(pname);
<span class="line-modified">2156     case GraphicsContextGL::TEXTURE_BINDING_2D:</span>
2157         return m_textureUnits[m_activeTextureUnit].texture2DBinding;
<span class="line-modified">2158     case GraphicsContextGL::TEXTURE_BINDING_CUBE_MAP:</span>
2159         return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
<span class="line-modified">2160     case GraphicsContextGL::UNPACK_ALIGNMENT:</span>
2161         return getIntParameter(pname);
<span class="line-modified">2162     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:</span>
2163         return m_unpackFlipY;
<span class="line-modified">2164     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
2165         return m_unpackPremultiplyAlpha;
<span class="line-modified">2166     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
2167         return m_unpackColorspaceConversion;
<span class="line-modified">2168     case GraphicsContextGL::VENDOR:</span>
2169         return &quot;WebKit&quot;_str;
<span class="line-modified">2170     case GraphicsContextGL::VERSION:</span>
2171         return &quot;WebGL 2.0&quot;_str;
<span class="line-modified">2172     case GraphicsContextGL::VIEWPORT:</span>
2173         return getWebGLIntArrayParameter(pname);
2174     case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
2175         if (m_webglDebugRendererInfo) {
2176 #if PLATFORM(IOS_FAMILY)
2177             return &quot;Apple GPU&quot;_str;
2178 #else
<span class="line-modified">2179             return m_context-&gt;getString(GraphicsContextGL::RENDERER);</span>
2180 #endif
2181         }
<span class="line-modified">2182         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
2183         return nullptr;
2184     case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
2185         if (m_webglDebugRendererInfo)
<span class="line-modified">2186             return m_context-&gt;getString(GraphicsContextGL::VENDOR);</span>
<span class="line-modified">2187         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
2188         return nullptr;
<span class="line-modified">2189     case ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
2190         if (m_extTextureFilterAnisotropic)
<span class="line-modified">2191             return getFloatParameter(ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT);</span>
<span class="line-modified">2192         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
2193         return nullptr;
<span class="line-modified">2194     case GraphicsContextGL::FRAGMENT_SHADER_DERIVATIVE_HINT:</span>
2195         return getIntParameter(pname);
<span class="line-modified">2196     case GraphicsContextGL::MAX_3D_TEXTURE_SIZE:</span>
2197         return getIntParameter(pname);
<span class="line-modified">2198     case GraphicsContextGL::MAX_ARRAY_TEXTURE_LAYERS:</span>
2199         return getIntParameter(pname);
<span class="line-modified">2200     case GraphicsContextGL::MAX_COLOR_ATTACHMENTS:</span>
2201         return getIntParameter(pname);
<span class="line-modified">2202     case GraphicsContextGL::MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:</span>
2203         return getInt64Parameter(pname);
<span class="line-modified">2204     case GraphicsContextGL::MAX_COMBINED_UNIFORM_BLOCKS:</span>
2205         return getIntParameter(pname);
<span class="line-modified">2206     case GraphicsContextGL::MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:</span>
2207         return getInt64Parameter(pname);
<span class="line-modified">2208     case GraphicsContextGL::MAX_DRAW_BUFFERS:</span>
2209         return getIntParameter(pname);
<span class="line-modified">2210     case GraphicsContextGL::MAX_ELEMENT_INDEX:</span>
2211         return getInt64Parameter(pname);
<span class="line-modified">2212     case GraphicsContextGL::MAX_ELEMENTS_INDICES:</span>
2213         return getIntParameter(pname);
<span class="line-modified">2214     case GraphicsContextGL::MAX_ELEMENTS_VERTICES:</span>
2215         return getIntParameter(pname);
<span class="line-modified">2216     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_COMPONENTS:</span>
2217         return getIntParameter(pname);
<span class="line-modified">2218     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_BLOCKS:</span>
2219         return getIntParameter(pname);
<span class="line-modified">2220     case GraphicsContextGL::MAX_PROGRAM_TEXEL_OFFSET:</span>
2221         return getIntParameter(pname);
<span class="line-modified">2222     case GraphicsContextGL::MAX_SAMPLES:</span>
2223         return getIntParameter(pname);
<span class="line-modified">2224     case GraphicsContextGL::MAX_SERVER_WAIT_TIMEOUT:</span>
2225         return getInt64Parameter(pname);
<span class="line-modified">2226     case GraphicsContextGL::MAX_TEXTURE_LOD_BIAS:</span>
2227         return getIntParameter(pname);
<span class="line-modified">2228     case GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:</span>
2229         return getIntParameter(pname);
<span class="line-modified">2230     case GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:</span>
2231         return getIntParameter(pname);
<span class="line-modified">2232     case GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:</span>
2233         return getIntParameter(pname);
<span class="line-modified">2234     case GraphicsContextGL::MAX_UNIFORM_BLOCK_SIZE:</span>
2235         return getInt64Parameter(pname);
<span class="line-modified">2236     case GraphicsContextGL::MAX_UNIFORM_BUFFER_BINDINGS:</span>
2237         return getIntParameter(pname);
<span class="line-modified">2238     case GraphicsContextGL::MAX_VARYING_COMPONENTS:</span>
2239         return getIntParameter(pname);
<span class="line-modified">2240     case GraphicsContextGL::MAX_VERTEX_OUTPUT_COMPONENTS:</span>
2241         return getIntParameter(pname);
<span class="line-modified">2242     case GraphicsContextGL::MAX_VERTEX_UNIFORM_BLOCKS:</span>
2243         return getIntParameter(pname);
<span class="line-modified">2244     case GraphicsContextGL::MAX_VERTEX_UNIFORM_COMPONENTS:</span>
2245         return getIntParameter(pname);
<span class="line-modified">2246     case GraphicsContextGL::MIN_PROGRAM_TEXEL_OFFSET:</span>
2247         return getIntParameter(pname);
<span class="line-modified">2248     case GraphicsContextGL::PACK_ROW_LENGTH:</span>
2249         return getIntParameter(pname);
<span class="line-modified">2250     case GraphicsContextGL::PACK_SKIP_PIXELS:</span>
2251         return getIntParameter(pname);
<span class="line-modified">2252     case GraphicsContextGL::PACK_SKIP_ROWS:</span>
2253         return getIntParameter(pname);
<span class="line-modified">2254     case GraphicsContextGL::UNPACK_IMAGE_HEIGHT:</span>
2255         return getIntParameter(pname);
<span class="line-modified">2256     case GraphicsContextGL::UNPACK_ROW_LENGTH:</span>
2257         return getIntParameter(pname);
<span class="line-modified">2258     case GraphicsContextGL::UNPACK_SKIP_IMAGES:</span>
2259         return getIntParameter(pname);
<span class="line-modified">2260     case GraphicsContextGL::UNPACK_SKIP_PIXELS:</span>
2261         return getIntParameter(pname);
<span class="line-modified">2262     case GraphicsContextGL::UNPACK_SKIP_ROWS:</span>
2263         return getIntParameter(pname);
<span class="line-modified">2264     case GraphicsContextGL::RASTERIZER_DISCARD:</span>
2265         return getBooleanParameter(pname);
<span class="line-modified">2266     case GraphicsContextGL::SAMPLE_ALPHA_TO_COVERAGE:</span>
2267         return getBooleanParameter(pname);
<span class="line-modified">2268     case GraphicsContextGL::SAMPLE_COVERAGE:</span>
2269         return getBooleanParameter(pname);
<span class="line-modified">2270     case GraphicsContextGL::TRANSFORM_FEEDBACK_ACTIVE:</span>
2271         return getBooleanParameter(pname);
<span class="line-modified">2272     case GraphicsContextGL::TRANSFORM_FEEDBACK_PAUSED:</span>
2273         return getBooleanParameter(pname);
<span class="line-modified">2274     case GraphicsContextGL::UNIFORM_BUFFER_OFFSET_ALIGNMENT:</span>
2275         return getIntParameter(pname);
<span class="line-modified">2276     case GraphicsContextGL::VERTEX_ARRAY_BINDING:</span>
2277         if (m_boundVertexArrayObject-&gt;isDefaultObject())
2278             return nullptr;
2279         return makeRefPtr(static_cast&lt;WebGLVertexArrayObject&amp;&gt;(*m_boundVertexArrayObject));
<span class="line-modified">2280     case GraphicsContextGL::DRAW_BUFFER0:</span>
<span class="line-modified">2281     case GraphicsContextGL::DRAW_BUFFER1:</span>
<span class="line-modified">2282     case GraphicsContextGL::DRAW_BUFFER2:</span>
<span class="line-modified">2283     case GraphicsContextGL::DRAW_BUFFER3:</span>
<span class="line-modified">2284     case GraphicsContextGL::DRAW_BUFFER4:</span>
<span class="line-modified">2285     case GraphicsContextGL::DRAW_BUFFER5:</span>
<span class="line-modified">2286     case GraphicsContextGL::DRAW_BUFFER6:</span>
<span class="line-modified">2287     case GraphicsContextGL::DRAW_BUFFER7:</span>
<span class="line-modified">2288     case GraphicsContextGL::DRAW_BUFFER8:</span>
<span class="line-modified">2289     case GraphicsContextGL::DRAW_BUFFER9:</span>
<span class="line-modified">2290     case GraphicsContextGL::DRAW_BUFFER10:</span>
<span class="line-modified">2291     case GraphicsContextGL::DRAW_BUFFER11:</span>
<span class="line-modified">2292     case GraphicsContextGL::DRAW_BUFFER12:</span>
<span class="line-modified">2293     case GraphicsContextGL::DRAW_BUFFER13:</span>
<span class="line-modified">2294     case GraphicsContextGL::DRAW_BUFFER14:</span>
<span class="line-modified">2295     case GraphicsContextGL::DRAW_BUFFER15:</span>
2296         if (m_framebufferBinding)
2297             return m_framebufferBinding-&gt;getDrawBuffer(pname);
2298         return m_backDrawBuffer; // emulated backbuffer
<span class="line-modified">2299     case GraphicsContextGL::READ_FRAMEBUFFER_BINDING:</span>
2300         return m_readFramebufferBinding;
<span class="line-modified">2301     case GraphicsContextGL::TRANSFORM_FEEDBACK_BINDING:</span>
<span class="line-modified">2302         return m_boundTransformFeedback;</span>
<span class="line-modified">2303     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_BINDING:</span>
<span class="line-modified">2304         return m_boundTransformFeedbackBuffer;</span>
<span class="line-modified">2305     case GraphicsContextGL::SAMPLER_BINDING:</span>
<span class="line-modified">2306         return m_boundSamplers[m_activeTextureUnit];</span>
<span class="line-modified">2307     case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">2308     case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">2309     case GraphicsContextGL::PIXEL_PACK_BUFFER_BINDING:</span>
<span class="line-modified">2310     case GraphicsContextGL::PIXEL_UNPACK_BUFFER_BINDING:</span>
<span class="line-modified">2311     case GraphicsContextGL::READ_BUFFER:</span>
<span class="line-added">2312     case GraphicsContextGL::TEXTURE_BINDING_2D_ARRAY:</span>
<span class="line-added">2313     case GraphicsContextGL::TEXTURE_BINDING_3D:</span>
<span class="line-added">2314     case GraphicsContextGL::UNIFORM_BUFFER_BINDING:</span>
<span class="line-added">2315         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;parameter name not yet supported&quot;);</span>
2316         return nullptr;
2317     default:
<span class="line-modified">2318         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);</span>
2319         return nullptr;
2320     }
2321 }
2322 
<span class="line-modified">2323 bool WebGL2RenderingContext::validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired)</span>
2324 {
2325     // Performs conservative validation by caching a maximum index of
2326     // the given type per element array buffer. If all of the bound
2327     // array buffers have enough elements to satisfy that maximum
2328     // index, skips the expensive per-draw-call iteration in
2329     // validateIndexArrayPrecise.
2330 
2331     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2332 
2333     if (!elementArrayBuffer)
2334         return false;
2335 
<span class="line-modified">2336     GCGLsizeiptr numElements = elementArrayBuffer-&gt;byteLength();</span>
2337     // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
2338     if (!numElements)
2339         return false;
2340     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2341     ASSERT(buffer);
2342 
2343     Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
2344     if (!maxIndex) {
2345         // Compute the maximum index in the entire buffer for the given type of index.
2346         switch (type) {
<span class="line-modified">2347         case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">2348             maxIndex = getMaxIndex&lt;GCGLubyte&gt;(buffer, 0, numElements);</span>
2349             break;
<span class="line-modified">2350         case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">2351             maxIndex = getMaxIndex&lt;GCGLushort&gt;(buffer, 0, numElements / sizeof(GCGLushort));</span>
2352             break;
<span class="line-modified">2353         case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">2354             maxIndex = getMaxIndex&lt;GCGLuint&gt;(buffer, 0, numElements / sizeof(GCGLuint));</span>
2355             break;
2356         default:
2357             return false;
2358         }
2359         if (maxIndex)
2360             elementArrayBuffer-&gt;setCachedMaxIndex(type, maxIndex.value());
2361     }
2362 
2363     if (!maxIndex)
2364         return false;
2365 
2366     // The number of required elements is one more than the maximum
2367     // index that will be accessed.
2368     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex.value(), 1, 1);
2369     if (!checkedNumElementsRequired)
2370         return false;
2371     numElementsRequired = checkedNumElementsRequired.value();
2372 
2373     return true;
2374 }
2375 
<span class="line-modified">2376 bool WebGL2RenderingContext::validateBlendEquation(const char* functionName, GCGLenum mode)</span>
2377 {
2378     switch (mode) {
<span class="line-modified">2379     case GraphicsContextGL::FUNC_ADD:</span>
<span class="line-modified">2380     case GraphicsContextGL::FUNC_SUBTRACT:</span>
<span class="line-modified">2381     case GraphicsContextGL::FUNC_REVERSE_SUBTRACT:</span>
<span class="line-modified">2382     case GraphicsContextGL::MIN:</span>
<span class="line-modified">2383     case GraphicsContextGL::MAX:</span>
2384         return true;
2385     default:
<span class="line-modified">2386         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
2387         return false;
2388     }
2389 }
2390 
<span class="line-modified">2391 bool WebGL2RenderingContext::validateCapability(const char* functionName, GCGLenum cap)</span>
2392 {
2393     switch (cap) {
<span class="line-modified">2394     case GraphicsContextGL::BLEND:</span>
<span class="line-modified">2395     case GraphicsContextGL::CULL_FACE:</span>
<span class="line-modified">2396     case GraphicsContextGL::DEPTH_TEST:</span>
<span class="line-modified">2397     case GraphicsContextGL::DITHER:</span>
<span class="line-modified">2398     case GraphicsContextGL::POLYGON_OFFSET_FILL:</span>
<span class="line-modified">2399     case GraphicsContextGL::SAMPLE_ALPHA_TO_COVERAGE:</span>
<span class="line-modified">2400     case GraphicsContextGL::SAMPLE_COVERAGE:</span>
<span class="line-modified">2401     case GraphicsContextGL::SCISSOR_TEST:</span>
<span class="line-modified">2402     case GraphicsContextGL::STENCIL_TEST:</span>
<span class="line-modified">2403     case GraphicsContextGL::RASTERIZER_DISCARD:</span>
2404         return true;
2405     default:
<span class="line-modified">2406         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid capability&quot;);</span>
2407         return false;
2408     }
2409 }
2410 
<span class="line-added">2411 void WebGL2RenderingContext::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLint64 offset)</span>
<span class="line-added">2412 {</span>
<span class="line-added">2413     UNUSED_PARAM(target);</span>
<span class="line-added">2414     UNUSED_PARAM(level);</span>
<span class="line-added">2415     UNUSED_PARAM(internalformat);</span>
<span class="line-added">2416     UNUSED_PARAM(width);</span>
<span class="line-added">2417     UNUSED_PARAM(height);</span>
<span class="line-added">2418     UNUSED_PARAM(border);</span>
<span class="line-added">2419     UNUSED_PARAM(imageSize);</span>
<span class="line-added">2420     UNUSED_PARAM(offset);</span>
<span class="line-added">2421 </span>
<span class="line-added">2422     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage2D(PIXEL_UNPACK_BUFFER)&quot;);</span>
<span class="line-added">2423 }</span>
<span class="line-added">2424 </span>
<span class="line-added">2425 void WebGL2RenderingContext::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)</span>
<span class="line-added">2426 {</span>
<span class="line-added">2427     UNUSED_PARAM(target);</span>
<span class="line-added">2428     UNUSED_PARAM(level);</span>
<span class="line-added">2429     UNUSED_PARAM(internalformat);</span>
<span class="line-added">2430     UNUSED_PARAM(width);</span>
<span class="line-added">2431     UNUSED_PARAM(height);</span>
<span class="line-added">2432     UNUSED_PARAM(border);</span>
<span class="line-added">2433     UNUSED_PARAM(srcData);</span>
<span class="line-added">2434     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2435     UNUSED_PARAM(srcLengthOverride);</span>
<span class="line-added">2436 </span>
<span class="line-added">2437     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage2D(ArrayBufferView)&quot;);</span>
<span class="line-added">2438 }</span>
<span class="line-added">2439 </span>
<span class="line-added">2440 void WebGL2RenderingContext::compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset)</span>
<span class="line-added">2441 {</span>
<span class="line-added">2442     UNUSED_PARAM(target);</span>
<span class="line-added">2443     UNUSED_PARAM(level);</span>
<span class="line-added">2444     UNUSED_PARAM(xoffset);</span>
<span class="line-added">2445     UNUSED_PARAM(yoffset);</span>
<span class="line-added">2446     UNUSED_PARAM(width);</span>
<span class="line-added">2447     UNUSED_PARAM(height);</span>
<span class="line-added">2448     UNUSED_PARAM(format);</span>
<span class="line-added">2449     UNUSED_PARAM(imageSize);</span>
<span class="line-added">2450     UNUSED_PARAM(offset);</span>
<span class="line-added">2451 </span>
<span class="line-added">2452     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage2D(PIXEL_UNPACK_BUFFER)&quot;);</span>
<span class="line-added">2453 }</span>
<span class="line-added">2454 </span>
<span class="line-added">2455 void WebGL2RenderingContext::compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView&amp; srcData, GLuint srcOffset, GLuint srcLengthOverride)</span>
<span class="line-added">2456 {</span>
<span class="line-added">2457     UNUSED_PARAM(target);</span>
<span class="line-added">2458     UNUSED_PARAM(level);</span>
<span class="line-added">2459     UNUSED_PARAM(xoffset);</span>
<span class="line-added">2460     UNUSED_PARAM(yoffset);</span>
<span class="line-added">2461     UNUSED_PARAM(width);</span>
<span class="line-added">2462     UNUSED_PARAM(height);</span>
<span class="line-added">2463     UNUSED_PARAM(format);</span>
<span class="line-added">2464     UNUSED_PARAM(srcData);</span>
<span class="line-added">2465     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2466     UNUSED_PARAM(srcLengthOverride);</span>
<span class="line-added">2467 </span>
<span class="line-added">2468     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage2D(ArrayBufferView)&quot;);</span>
<span class="line-added">2469 </span>
<span class="line-added">2470 }</span>
<span class="line-added">2471 </span>
<span class="line-added">2472 void WebGL2RenderingContext::uniform1fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2473 {</span>
<span class="line-added">2474     UNUSED_PARAM(location);</span>
<span class="line-added">2475     UNUSED_PARAM(data);</span>
<span class="line-added">2476     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2477     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2478 </span>
<span class="line-added">2479     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1fv()&quot;);</span>
<span class="line-added">2480 }</span>
<span class="line-added">2481 </span>
<span class="line-added">2482 void WebGL2RenderingContext::uniform2fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2483 {</span>
<span class="line-added">2484     UNUSED_PARAM(location);</span>
<span class="line-added">2485     UNUSED_PARAM(data);</span>
<span class="line-added">2486     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2487     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2488 </span>
<span class="line-added">2489     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2fv()&quot;);</span>
<span class="line-added">2490 }</span>
<span class="line-added">2491 </span>
<span class="line-added">2492 void WebGL2RenderingContext::uniform3fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2493 {</span>
<span class="line-added">2494     UNUSED_PARAM(location);</span>
<span class="line-added">2495     UNUSED_PARAM(data);</span>
<span class="line-added">2496     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2497     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2498 </span>
<span class="line-added">2499     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3fv()&quot;);</span>
<span class="line-added">2500 }</span>
<span class="line-added">2501 </span>
<span class="line-added">2502 void WebGL2RenderingContext::uniform4fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2503 {</span>
<span class="line-added">2504     UNUSED_PARAM(location);</span>
<span class="line-added">2505     UNUSED_PARAM(data);</span>
<span class="line-added">2506     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2507     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2508 </span>
<span class="line-added">2509     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4fv()&quot;);</span>
<span class="line-added">2510 }</span>
<span class="line-added">2511 </span>
<span class="line-added">2512 void WebGL2RenderingContext::uniform1iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2513 {</span>
<span class="line-added">2514     UNUSED_PARAM(location);</span>
<span class="line-added">2515     UNUSED_PARAM(data);</span>
<span class="line-added">2516     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2517     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2518 </span>
<span class="line-added">2519     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1iv()&quot;);</span>
<span class="line-added">2520 }</span>
<span class="line-added">2521 </span>
<span class="line-added">2522 void WebGL2RenderingContext::uniform2iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2523 {</span>
<span class="line-added">2524     UNUSED_PARAM(location);</span>
<span class="line-added">2525     UNUSED_PARAM(data);</span>
<span class="line-added">2526     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2527     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2528 </span>
<span class="line-added">2529     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2iv()&quot;);</span>
<span class="line-added">2530 }</span>
<span class="line-added">2531 </span>
<span class="line-added">2532 void WebGL2RenderingContext::uniform3iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2533 {</span>
<span class="line-added">2534     UNUSED_PARAM(location);</span>
<span class="line-added">2535     UNUSED_PARAM(data);</span>
<span class="line-added">2536     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2537     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2538 </span>
<span class="line-added">2539     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3iv()&quot;);</span>
<span class="line-added">2540 }</span>
<span class="line-added">2541 </span>
<span class="line-added">2542 void WebGL2RenderingContext::uniform4iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2543 {</span>
<span class="line-added">2544     UNUSED_PARAM(location);</span>
<span class="line-added">2545     UNUSED_PARAM(data);</span>
<span class="line-added">2546     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2547     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2548 </span>
<span class="line-added">2549     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4iv()&quot;);</span>
<span class="line-added">2550 }</span>
<span class="line-added">2551 </span>
<span class="line-added">2552 void WebGL2RenderingContext::uniformMatrix2fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2553 {</span>
<span class="line-added">2554     UNUSED_PARAM(location);</span>
<span class="line-added">2555     UNUSED_PARAM(transpose);</span>
<span class="line-added">2556     UNUSED_PARAM(data);</span>
<span class="line-added">2557     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2558     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2559 </span>
<span class="line-added">2560     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2fv()&quot;);</span>
<span class="line-added">2561 }</span>
<span class="line-added">2562 </span>
<span class="line-added">2563 void WebGL2RenderingContext::uniformMatrix3fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2564 {</span>
<span class="line-added">2565     UNUSED_PARAM(location);</span>
<span class="line-added">2566     UNUSED_PARAM(transpose);</span>
<span class="line-added">2567     UNUSED_PARAM(data);</span>
<span class="line-added">2568     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2569     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2570 </span>
<span class="line-added">2571     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3fv()&quot;);</span>
<span class="line-added">2572 }</span>
<span class="line-added">2573 </span>
<span class="line-added">2574 void WebGL2RenderingContext::uniformMatrix4fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength)</span>
<span class="line-added">2575 {</span>
<span class="line-added">2576     UNUSED_PARAM(location);</span>
<span class="line-added">2577     UNUSED_PARAM(transpose);</span>
<span class="line-added">2578     UNUSED_PARAM(data);</span>
<span class="line-added">2579     UNUSED_PARAM(srcOffset);</span>
<span class="line-added">2580     UNUSED_PARAM(srcLength);</span>
<span class="line-added">2581 </span>
<span class="line-added">2582     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4fv()&quot;);</span>
<span class="line-added">2583 }</span>
<span class="line-added">2584 </span>
<span class="line-added">2585 void WebGL2RenderingContext::readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset)</span>
<span class="line-added">2586 {</span>
<span class="line-added">2587     UNUSED_PARAM(x);</span>
<span class="line-added">2588     UNUSED_PARAM(y);</span>
<span class="line-added">2589     UNUSED_PARAM(width);</span>
<span class="line-added">2590     UNUSED_PARAM(height);</span>
<span class="line-added">2591     UNUSED_PARAM(format);</span>
<span class="line-added">2592     UNUSED_PARAM(type);</span>
<span class="line-added">2593     UNUSED_PARAM(offset);</span>
<span class="line-added">2594 </span>
<span class="line-added">2595     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] readPixels()&quot;);</span>
<span class="line-added">2596 }</span>
<span class="line-added">2597 </span>
<span class="line-added">2598 void WebGL2RenderingContext::readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView&amp; dstData, GLuint dstOffset)</span>
<span class="line-added">2599 {</span>
<span class="line-added">2600     UNUSED_PARAM(x);</span>
<span class="line-added">2601     UNUSED_PARAM(y);</span>
<span class="line-added">2602     UNUSED_PARAM(width);</span>
<span class="line-added">2603     UNUSED_PARAM(height);</span>
<span class="line-added">2604     UNUSED_PARAM(format);</span>
<span class="line-added">2605     UNUSED_PARAM(type);</span>
<span class="line-added">2606     UNUSED_PARAM(dstData);</span>
<span class="line-added">2607     UNUSED_PARAM(dstOffset);</span>
<span class="line-added">2608 </span>
<span class="line-added">2609     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] readPixels(ArrayBufferView)&quot;);</span>
<span class="line-added">2610 }</span>
<span class="line-added">2611 </span>
<span class="line-added">2612 void WebGL2RenderingContext::uncacheDeletedBuffer(WebGLBuffer* buffer)</span>
<span class="line-added">2613 {</span>
<span class="line-added">2614     ASSERT(buffer);</span>
<span class="line-added">2615 </span>
<span class="line-added">2616     WebGLRenderingContextBase::uncacheDeletedBuffer(buffer);</span>
<span class="line-added">2617 </span>
<span class="line-added">2618     size_t index = m_boundTransformFeedbackBuffers.find(buffer);</span>
<span class="line-added">2619     if (index &lt; m_boundTransformFeedbackBuffers.size())</span>
<span class="line-added">2620         m_boundTransformFeedbackBuffers[index] = nullptr;</span>
<span class="line-added">2621 }</span>
<span class="line-added">2622 </span>
2623 } // namespace WebCore
2624 
2625 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="OffscreenCanvasRenderingContext2D.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGL2RenderingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
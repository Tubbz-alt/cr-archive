diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp
@@ -52,47 +52,48 @@
     m_center = FloatPoint();
     m_radii = FloatSize();
 
     calculateRadiiAndCenter();
 
-    // Element is invalid if either dimension is negative.
-    if (m_radii.width() < 0 || m_radii.height() < 0)
+    // Spec: "A negative value is illegal. A value of zero disables rendering of the element."
+    if (m_radii.isEmpty())
         return;
 
-    // Spec: "A value of zero disables rendering of the element."
-    if (!m_radii.isEmpty()) {
-        if (hasNonScalingStroke()) {
-            // Fallback to RenderSVGShape if shape has a non-scaling stroke.
-            RenderSVGShape::updateShapeFromElement();
-            m_usePathFallback = true;
-            return;
-        }
-        m_usePathFallback = false;
+    if (hasNonScalingStroke()) {
+        // Fallback to RenderSVGShape if shape has a non-scaling stroke.
+        RenderSVGShape::updateShapeFromElement();
+        m_usePathFallback = true;
+        return;
     }
 
+    m_usePathFallback = false;
+
     m_fillBoundingBox = FloatRect(m_center.x() - m_radii.width(), m_center.y() - m_radii.height(), 2 * m_radii.width(), 2 * m_radii.height());
     m_strokeBoundingBox = m_fillBoundingBox;
     if (style().svgStyle().hasStroke())
         m_strokeBoundingBox.inflate(strokeWidth() / 2);
 }
 
 void RenderSVGEllipse::calculateRadiiAndCenter()
 {
     SVGLengthContext lengthContext(&graphicsElement());
     m_center = FloatPoint(
-        lengthContext.valueForLength(style().svgStyle().cx(), LengthModeWidth),
-        lengthContext.valueForLength(style().svgStyle().cy(), LengthModeHeight));
+        lengthContext.valueForLength(style().svgStyle().cx(), SVGLengthMode::Width),
+        lengthContext.valueForLength(style().svgStyle().cy(), SVGLengthMode::Height));
     if (is<SVGCircleElement>(graphicsElement())) {
         float radius = lengthContext.valueForLength(style().svgStyle().r());
         m_radii = FloatSize(radius, radius);
         return;
     }
 
     ASSERT(is<SVGEllipseElement>(graphicsElement()));
+
+    Length rx = style().svgStyle().rx();
+    Length ry = style().svgStyle().ry();
     m_radii = FloatSize(
-        lengthContext.valueForLength(style().svgStyle().rx(), LengthModeWidth),
-        lengthContext.valueForLength(style().svgStyle().ry(), LengthModeHeight));
+        lengthContext.valueForLength(rx.isAuto() ? ry : rx, SVGLengthMode::Width),
+        lengthContext.valueForLength(ry.isAuto() ? rx : ry, SVGLengthMode::Height));
 }
 
 void RenderSVGEllipse::fillShape(GraphicsContext& context) const
 {
     if (m_usePathFallback) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BytecodeBasicBlock.h&quot;
 28 
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;InterpreterInlines.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;PreciseJumpTargets.h&quot;
 33 #include &quot;UnlinkedCodeBlockGenerator.h&quot;
 34 
 35 namespace JSC {
 36 
 37 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BytecodeBasicBlock);
 38 
 39 BytecodeBasicBlock::BytecodeBasicBlock(const InstructionStream::Ref&amp; instruction, unsigned blockIndex)
 40     : m_leaderOffset(instruction.offset())
 41     , m_totalLength(0)
 42     , m_index(blockIndex)
 43 {
 44     addLength(instruction-&gt;size());
 45 }
 46 
 47 BytecodeBasicBlock::BytecodeBasicBlock(BytecodeBasicBlock::SpecialBlockType blockType, unsigned blockIndex)
 48     : m_leaderOffset(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)
 49     , m_totalLength(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)
 50     , m_index(blockIndex)
 51 {
 52 }
 53 
 54 void BytecodeBasicBlock::addLength(unsigned bytecodeLength)
 55 {
 56     m_delta.append(bytecodeLength);
 57     m_totalLength += bytecodeLength;
 58 }
 59 
 60 void BytecodeBasicBlock::shrinkToFit()
 61 {
 62     m_delta.shrinkToFit();
 63     m_successors.shrinkToFit();
 64 }
 65 
 66 static bool isJumpTarget(OpcodeID opcodeID, const Vector&lt;InstructionStream::Offset, 32&gt;&amp; jumpTargets, unsigned bytecodeOffset)
 67 {
 68     if (opcodeID == op_catch)
 69         return true;
 70 
 71     return std::binary_search(jumpTargets.begin(), jumpTargets.end(), bytecodeOffset);
 72 }
 73 
 74 template&lt;typename Block&gt;
 75 auto BytecodeBasicBlock::computeImpl(Block* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector
 76 {
 77     BasicBlockVector basicBlocks;
 78     Vector&lt;InstructionStream::Offset, 32&gt; jumpTargets;
 79     computePreciseJumpTargets(codeBlock, instructions, jumpTargets);
 80 
 81     auto linkBlocks = [&amp;] (BytecodeBasicBlock&amp; from, BytecodeBasicBlock&amp; to) {
 82         from.addSuccessor(to);
 83     };
 84 
 85     {
 86         // Create the entry and exit basic blocks.
 87         basicBlocks.reserveCapacity(jumpTargets.size() + 2);
 88         {
 89             // Entry block.
 90             basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());
 91             // First block.
 92             basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());
 93             linkBlocks(basicBlocks[0], basicBlocks[1]);
 94         }
 95 
 96         BytecodeBasicBlock* current = &amp;basicBlocks.last();
 97         auto appendBlock = [&amp;] (const InstructionStream::Ref&amp; instruction) -&gt; BytecodeBasicBlock* {
 98             basicBlocks.constructAndAppend(instruction, basicBlocks.size());
 99             return &amp;basicBlocks.last();
100         };
101         bool nextInstructionIsLeader = false;
102         for (const auto&amp; instruction : instructions) {
103             auto bytecodeOffset = instruction.offset();
104             OpcodeID opcodeID = instruction-&gt;opcodeID();
105 
106             bool createdBlock = false;
107             // If the current bytecode is a jump target, then it&#39;s the leader of its own basic block.
108             if (nextInstructionIsLeader || isJumpTarget(opcodeID, jumpTargets, bytecodeOffset)) {
109                 current = appendBlock(instruction);
110                 createdBlock = true;
111                 nextInstructionIsLeader = false;
112             }
113 
114             // If the current bytecode is a branch or a return, then the next instruction is the leader of its own basic block.
115             if (isBranch(opcodeID) || isTerminal(opcodeID) || isThrow(opcodeID))
116                 nextInstructionIsLeader = true;
117 
118             if (createdBlock)
119                 continue;
120 
121             // Otherwise, just add to the length of the current block.
122             current-&gt;addLength(instruction-&gt;size());
123         }
124         // Exit block.
125         basicBlocks.constructAndAppend(BytecodeBasicBlock::ExitBlock, basicBlocks.size());
126         basicBlocks.shrinkToFit();
127         ASSERT(basicBlocks.last().isExitBlock());
128     }
129     // After this point, we never change basicBlocks.
130 
131     // Link basic blocks together.
132     for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {
133         BytecodeBasicBlock&amp; block = basicBlocks[i];
134 
135         if (block.isEntryBlock() || block.isExitBlock())
136             continue;
137 
138         bool fallsThrough = true;
139         for (unsigned visitedLength = 0; visitedLength &lt; block.totalLength();) {
140             InstructionStream::Ref instruction = instructions.at(block.leaderOffset() + visitedLength);
141             OpcodeID opcodeID = instruction-&gt;opcodeID();
142 
143             visitedLength += instruction-&gt;size();
144 
145             // If we found a terminal bytecode, link to the exit block.
146             if (isTerminal(opcodeID)) {
147                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());
148                 linkBlocks(block, basicBlocks.last());
149                 fallsThrough = false;
150                 break;
151             }
152 
153             // If we found a throw, get the HandlerInfo for this instruction to see where we will jump.
154             // If there isn&#39;t one, treat this throw as a terminal. This is true even if we have a finally
155             // block because the finally block will create its own catch, which will generate a HandlerInfo.
156             if (isThrow(opcodeID)) {
157                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());
158                 auto* handler = codeBlock-&gt;handlerForBytecodeIndex(BytecodeIndex(instruction.offset()));
159                 fallsThrough = false;
160                 if (!handler) {
161                     linkBlocks(block, basicBlocks.last());
162                     break;
163                 }
164                 for (auto&amp; otherBlock : basicBlocks) {
165                     if (handler-&gt;target == otherBlock.leaderOffset()) {
166                         linkBlocks(block, otherBlock);
167                         break;
168                     }
169                 }
170                 break;
171             }
172 
173             // If we found a branch, link to the block(s) that we jump to.
174             if (isBranch(opcodeID)) {
175                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());
176                 Vector&lt;InstructionStream::Offset, 1&gt; bytecodeOffsetsJumpedTo;
177                 findJumpTargetsForInstruction(codeBlock, instruction, bytecodeOffsetsJumpedTo);
178 
179                 size_t numberOfJumpTargets = bytecodeOffsetsJumpedTo.size();
180                 ASSERT(numberOfJumpTargets);
181                 for (auto&amp; otherBlock : basicBlocks) {
182                     if (bytecodeOffsetsJumpedTo.contains(otherBlock.leaderOffset())) {
183                         linkBlocks(block, otherBlock);
184                         --numberOfJumpTargets;
185                         if (!numberOfJumpTargets)
186                             break;
187                     }
188                 }
189                 // numberOfJumpTargets may not be 0 here if there are multiple jumps targeting the same
190                 // basic blocks (e.g. in a switch type opcode). Since we only decrement numberOfJumpTargets
191                 // once per basic block, the duplicates are not accounted for. For our purpose here,
192                 // that doesn&#39;t matter because we only need to link to the target block once regardless
193                 // of how many ways this block can jump there.
194 
195                 if (isUnconditionalBranch(opcodeID))
196                     fallsThrough = false;
197 
198                 break;
199             }
200         }
201 
202         // If we fall through then link to the next block in program order.
203         if (fallsThrough) {
204             ASSERT(i + 1 &lt; basicBlocks.size());
205             BytecodeBasicBlock&amp; nextBlock = basicBlocks[i + 1];
206             linkBlocks(block, nextBlock);
207         }
208     }
209 
210     unsigned index = 0;
211     for (auto&amp; basicBlock : basicBlocks) {
212         basicBlock.shrinkToFit();
213         ASSERT_UNUSED(index, basicBlock.index() == index++);
214     }
215 
216     return basicBlocks;
217 }
218 
219 auto BytecodeBasicBlock::compute(CodeBlock* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector
220 {
221     return computeImpl(codeBlock, instructions);
222 }
223 
224 auto BytecodeBasicBlock::compute(UnlinkedCodeBlockGenerator* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector
225 {
226     return computeImpl(codeBlock, instructions);
227 }
228 
229 } // namespace JSC
    </pre>
  </body>
</html>
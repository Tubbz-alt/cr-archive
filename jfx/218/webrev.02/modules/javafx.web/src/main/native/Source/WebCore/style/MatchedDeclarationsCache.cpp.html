<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/MatchedDeclarationsCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012, 2013 Google Inc. All rights reserved.
 12  * Copyright (C) 2014 Igalia S.L.
 13  *
 14  * This library is free software; you can redistribute it and/or
 15  * modify it under the terms of the GNU Library General Public
 16  * License as published by the Free Software Foundation; either
 17  * version 2 of the License, or (at your option) any later version.
 18  *
 19  * This library is distributed in the hope that it will be useful,
 20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 22  * Library General Public License for more details.
 23  *
 24  * You should have received a copy of the GNU Library General Public License
 25  * along with this library; see the file COPYING.LIB.  If not, write to
 26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 27  * Boston, MA 02110-1301, USA.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;MatchedDeclarationsCache.h&quot;
 32 
 33 #include &quot;CSSFontSelector.h&quot;
 34 #include &quot;FontCascade.h&quot;
 35 #include &lt;wtf/text/StringHash.h&gt;
 36 
 37 namespace WebCore {
 38 namespace Style {
 39 
 40 MatchedDeclarationsCache::MatchedDeclarationsCache()
 41     : m_sweepTimer(*this, &amp;MatchedDeclarationsCache::sweep)
 42 {
 43 }
 44 
 45 MatchedDeclarationsCache::~MatchedDeclarationsCache() = default;
 46 
 47 bool MatchedDeclarationsCache::isCacheable(const Element&amp; element, const RenderStyle&amp; style, const RenderStyle&amp; parentStyle)
 48 {
 49     // FIXME: Writing mode and direction properties modify state when applying to document element by calling
 50     // Document::setWritingMode/DirectionSetOnDocumentElement. We can&#39;t skip the applying by caching.
 51     if (&amp;element == element.document().documentElement())
 52         return false;
 53     // content:attr() value depends on the element it is being applied to.
 54     if (style.hasAttrContent() || (style.styleType() != PseudoId::None &amp;&amp; parentStyle.hasAttrContent()))
 55         return false;
 56     if (style.hasAppearance())
 57         return false;
 58     if (style.zoom() != RenderStyle::initialZoom())
 59         return false;
 60     if (style.writingMode() != RenderStyle::initialWritingMode() || style.direction() != RenderStyle::initialDirection())
 61         return false;
 62     // The cache assumes static knowledge about which properties are inherited.
 63     if (style.hasExplicitlyInheritedProperties())
 64         return false;
 65 
 66     // Getting computed style after a font environment change but before full style resolution may involve styles with non-current fonts.
 67     // Avoid caching them.
 68     auto&amp; fontSelector = element.document().fontSelector();
 69     if (!style.fontCascade().isCurrent(fontSelector))
 70         return false;
 71     if (!parentStyle.fontCascade().isCurrent(fontSelector))
 72         return false;
 73 
 74     return true;
 75 }
 76 
 77 bool MatchedDeclarationsCache::Entry::isUsableAfterHighPriorityProperties(const RenderStyle&amp; style) const
 78 {
 79     if (style.effectiveZoom() != renderStyle-&gt;effectiveZoom())
 80         return false;
 81 
 82     return CSSPrimitiveValue::equalForLengthResolution(style, *renderStyle);
 83 }
 84 
 85 unsigned MatchedDeclarationsCache::computeHash(const MatchResult&amp; matchResult)
 86 {
 87     if (!matchResult.isCacheable)
 88         return 0;
 89 
 90     return StringHasher::hashMemory(matchResult.userAgentDeclarations.data(), sizeof(MatchedProperties) * matchResult.userAgentDeclarations.size())
 91         ^ StringHasher::hashMemory(matchResult.userDeclarations.data(), sizeof(MatchedProperties) * matchResult.userDeclarations.size())
 92         ^ StringHasher::hashMemory(matchResult.authorDeclarations.data(), sizeof(MatchedProperties) * matchResult.authorDeclarations.size());
 93 }
 94 
 95 const MatchedDeclarationsCache::Entry* MatchedDeclarationsCache::find(unsigned hash, const MatchResult&amp; matchResult)
 96 {
 97     if (!hash)
 98         return nullptr;
 99 
100     auto it = m_entries.find(hash);
101     if (it == m_entries.end())
102         return nullptr;
103 
104     auto&amp; entry = it-&gt;value;
105     if (matchResult != entry.matchResult)
106         return nullptr;
107 
108     return &amp;entry;
109 }
110 
111 void MatchedDeclarationsCache::add(const RenderStyle&amp; style, const RenderStyle&amp; parentStyle, unsigned hash, const MatchResult&amp; matchResult)
112 {
113     constexpr unsigned additionsBetweenSweeps = 100;
114     if (++m_additionsSinceLastSweep &gt;= additionsBetweenSweeps &amp;&amp; !m_sweepTimer.isActive()) {
115         constexpr auto sweepDelay = 1_min;
116         m_sweepTimer.startOneShot(sweepDelay);
117     }
118 
119     ASSERT(hash);
120     // Note that we don&#39;t cache the original RenderStyle instance. It may be further modified.
121     // The RenderStyle in the cache is really just a holder for the substructures and never used as-is.
122     m_entries.add(hash, Entry { matchResult, RenderStyle::clonePtr(style), RenderStyle::clonePtr(parentStyle) });
123 }
124 
125 void MatchedDeclarationsCache::invalidate()
126 {
127     m_entries.clear();
128 }
129 
130 void MatchedDeclarationsCache::clearEntriesAffectedByViewportUnits()
131 {
132     m_entries.removeIf([](auto&amp; keyValue) {
133         return keyValue.value.renderStyle-&gt;hasViewportUnits();
134     });
135 }
136 
137 void MatchedDeclarationsCache::sweep()
138 {
139     // Look for cache entries containing a style declaration with a single ref and remove them.
140     // This may happen when an element attribute mutation causes it to generate a new inlineStyle()
141     // or presentationAttributeStyle(), potentially leaving this cache with the last ref on the old one.
142     auto hasOneRef = [](auto&amp; declarations) {
143         for (auto&amp; matchedProperties : declarations) {
144             if (matchedProperties.properties-&gt;hasOneRef())
145                 return true;
146         }
147         return false;
148     };
149 
150     m_entries.removeIf([&amp;](auto&amp; keyValue) {
151         auto&amp; matchResult = keyValue.value.matchResult;
152         return hasOneRef(matchResult.userAgentDeclarations) || hasOneRef(matchResult.userDeclarations) || hasOneRef(matchResult.authorDeclarations);
153     });
154 
155     m_additionsSinceLastSweep = 0;
156 }
157 
158 }
159 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VisibleSelection.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebContentReader.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 822,20 ***</span>
          if (!startNode)
              return VisiblePosition();
      } else {
          // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
          // and so cannot be represented by a VisiblePosition. Use whatever follows instead.
<span class="line-modified">!         startBox = rootBox-&gt;firstLeafChild();</span>
          while (true) {
              if (!startBox)
                  return VisiblePosition();
  
              startNode = startBox-&gt;renderer().nonPseudoNode();
              if (startNode)
                  break;
  
<span class="line-modified">!             startBox = startBox-&gt;nextLeafChild();</span>
          }
      }
  
      return is&lt;Text&gt;(*startNode) ? Position(downcast&lt;Text&gt;(startNode), downcast&lt;InlineTextBox&gt;(*startBox).start())
          : positionBeforeNode(startNode);
<span class="line-new-header">--- 822,20 ---</span>
          if (!startNode)
              return VisiblePosition();
      } else {
          // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
          // and so cannot be represented by a VisiblePosition. Use whatever follows instead.
<span class="line-modified">!         startBox = rootBox-&gt;firstLeafDescendant();</span>
          while (true) {
              if (!startBox)
                  return VisiblePosition();
  
              startNode = startBox-&gt;renderer().nonPseudoNode();
              if (startNode)
                  break;
  
<span class="line-modified">!             startBox = startBox-&gt;nextLeafOnLine();</span>
          }
      }
  
      return is&lt;Text&gt;(*startNode) ? Position(downcast&lt;Text&gt;(startNode), downcast&lt;InlineTextBox&gt;(*startBox).start())
          : positionBeforeNode(startNode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 896,20 ***</span>
          if (!endNode)
              return VisiblePosition();
      } else {
          // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
          // and so cannot be represented by a VisiblePosition. Use whatever precedes instead.
<span class="line-modified">!         endBox = rootBox-&gt;lastLeafChild();</span>
          while (true) {
              if (!endBox)
                  return VisiblePosition();
  
              endNode = endBox-&gt;renderer().nonPseudoNode();
              if (endNode)
                  break;
  
<span class="line-modified">!             endBox = endBox-&gt;prevLeafChild();</span>
          }
      }
  
      Position pos;
      if (is&lt;HTMLBRElement&gt;(*endNode))
<span class="line-new-header">--- 896,20 ---</span>
          if (!endNode)
              return VisiblePosition();
      } else {
          // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
          // and so cannot be represented by a VisiblePosition. Use whatever precedes instead.
<span class="line-modified">!         endBox = rootBox-&gt;lastLeafDescendant();</span>
          while (true) {
              if (!endBox)
                  return VisiblePosition();
  
              endNode = endBox-&gt;renderer().nonPseudoNode();
              if (endNode)
                  break;
  
<span class="line-modified">!             endBox = endBox-&gt;previousLeafOnLine();</span>
          }
      }
  
      Position pos;
      if (is&lt;HTMLBRElement&gt;(*endNode))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1044,11 ***</span>
      visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
      if (box) {
          root = box-&gt;root().prevRootBox();
          // We want to skip zero height boxes.
          // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">!         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafChild())</span>
              root = nullptr;
      }
  
      if (!root) {
          Position position = previousRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
<span class="line-new-header">--- 1044,11 ---</span>
      visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
      if (box) {
          root = box-&gt;root().prevRootBox();
          // We want to skip zero height boxes.
          // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">!         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafDescendant())</span>
              root = nullptr;
      }
  
      if (!root) {
          Position position = previousRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1099,11 ***</span>
      visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
      if (box) {
          root = box-&gt;root().nextRootBox();
          // We want to skip zero height boxes.
          // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">!         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafChild())</span>
              root = nullptr;
      }
  
      if (!root) {
          // FIXME: We need do the same in previousLinePosition.
<span class="line-new-header">--- 1099,11 ---</span>
      visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
      if (box) {
          root = box-&gt;root().nextRootBox();
          // We want to skip zero height boxes.
          // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">!         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafDescendant())</span>
              root = nullptr;
      }
  
      if (!root) {
          // FIXME: We need do the same in previousLinePosition.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1589,11 ***</span>
          // Note that &quot;Left&quot; and &quot;Right&quot; in this context apparently mean &quot;upstream/previous&quot; and &quot;downstream/next&quot;.
          boundary = useDownstream ? endOfWord(vp, LeftWordIfOnBoundary) : startOfWord(vp, RightWordIfOnBoundary);
          break;
  
      case SentenceGranularity:
<span class="line-modified">!         boundary = useDownstream ? endOfSentence(vp) : startOfSentence(vp);</span>
          break;
  
      case LineGranularity:
          // Affinity has to be set to get right boundary of the line.
          boundary = vp;
<span class="line-new-header">--- 1589,11 ---</span>
          // Note that &quot;Left&quot; and &quot;Right&quot; in this context apparently mean &quot;upstream/previous&quot; and &quot;downstream/next&quot;.
          boundary = useDownstream ? endOfWord(vp, LeftWordIfOnBoundary) : startOfWord(vp, RightWordIfOnBoundary);
          break;
  
      case SentenceGranularity:
<span class="line-modified">!         boundary = useDownstream ? endOfSentence(previousSentencePosition(vp)) : startOfSentence(nextSentencePosition(vp));</span>
          break;
  
      case LineGranularity:
          // Affinity has to be set to get right boundary of the line.
          boundary = vp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1774,11 ***</span>
      }
  
      if (result == vp)
          return VisiblePosition();
  
<span class="line-modified">!     ASSERT(useDownstream ? (result &gt; vp) : (result &lt; vp));</span>
  
      return result;
  }
  
  static VisiblePosition nextLineBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
<span class="line-new-header">--- 1774,12 ---</span>
      }
  
      if (result == vp)
          return VisiblePosition();
  
<span class="line-modified">!     // Positions can only be compared if they are in the same tree scope.</span>
<span class="line-added">+     ASSERT_IMPLIES(areVisiblePositionsInSameTreeScope(result, vp), useDownstream ? (result &gt; vp) : (result &lt; vp));</span>
  
      return result;
  }
  
  static VisiblePosition nextLineBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1795,22 ***</span>
      }
  
      return result;
  }
  
<span class="line-modified">! static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)</span>
  {
<span class="line-modified">!     bool useDownstream = directionIsDownstream(direction);</span>
<span class="line-modified">!     bool withinUnitOfGranularity = withinTextUnitOfGranularity(vp, ParagraphGranularity, direction);</span>
<span class="line-modified">!     VisiblePosition result;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!withinUnitOfGranularity)</span>
<span class="line-modified">!         result =  useDownstream ? startOfParagraph(nextParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation())) : endOfParagraph(previousParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation()));</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         result = useDownstream ? endOfParagraph(vp) : startOfParagraph(vp);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return result;</span>
  }
  
  static VisiblePosition nextDocumentBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
  {
      return directionIsDownstream(direction) ? endOfDocument(vp) : startOfDocument(vp);
<span class="line-new-header">--- 1796,18 ---</span>
      }
  
      return result;
  }
  
<span class="line-modified">! static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition&amp; position, SelectionDirection direction)</span>
  {
<span class="line-modified">!     auto useDownstream = directionIsDownstream(direction);</span>
<span class="line-modified">!     auto lineDirection = position.lineDirectionPointForBlockDirectionNavigation();</span>
<span class="line-modified">!     if (atBoundaryOfGranularity(position, ParagraphGranularity, direction))</span>
<span class="line-modified">!         return useDownstream ? startOfParagraph(nextParagraphPosition(position, lineDirection)) : endOfParagraph(previousParagraphPosition(position, lineDirection));</span>
<span class="line-modified">!     ASSERT(withinTextUnitOfGranularity(position, ParagraphGranularity, direction));</span>
<span class="line-modified">!     return useDownstream ? endOfParagraph(position) : startOfParagraph(position);</span>
  }
  
  static VisiblePosition nextDocumentBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
  {
      return directionIsDownstream(direction) ? endOfDocument(vp) : startOfDocument(vp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1967,37 ***</span>
  
      if (!range) {
          // We could be at the start of a word, try forward.
          range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
      }
      if (range)
          return range;
  
      VisiblePosition currentPosition = position;
      do {
          currentPosition = positionOfNextBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward);
      } while (currentPosition.isNotNull() &amp;&amp; !atBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward));
  
<span class="line-removed">-     // If the position is an empty paragraph and at the end of the document</span>
<span class="line-removed">-     // the word iterator could not pass the paragraph boundary, therefore iterating to</span>
<span class="line-removed">-     // the previous line is required.</span>
<span class="line-removed">-     if (currentPosition.isNull() &amp;&amp; isEndOfDocument(position)) {</span>
<span class="line-removed">-         VisiblePosition previousLinePosition = positionOfNextBoundaryOfGranularity(position, LineGranularity, DirectionBackward);</span>
<span class="line-removed">-         if (previousLinePosition.isNotNull()) {</span>
<span class="line-removed">-             currentPosition = positionOfNextBoundaryOfGranularity(previousLinePosition, WordGranularity, DirectionBackward);</span>
<span class="line-removed">-             if (currentPosition.isNull())</span>
<span class="line-removed">-                 currentPosition = previousLinePosition;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      if (currentPosition.isNull())
          currentPosition = positionOfNextBoundaryOfGranularity(position, WordGranularity, DirectionForward);
  
      if (currentPosition.isNotNull()) {
          range = Range::create(position.deepEquivalent().deprecatedNode()-&gt;document(), currentPosition, position);
          ASSERT(range);
      }
      return range;
  }
  
  VisiblePosition closestWordBoundaryForPosition(const VisiblePosition&amp; position)
  {
<span class="line-new-header">--- 1964,27 ---</span>
  
      if (!range) {
          // We could be at the start of a word, try forward.
          range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
      }
<span class="line-added">+ </span>
      if (range)
          return range;
  
      VisiblePosition currentPosition = position;
      do {
          currentPosition = positionOfNextBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward);
      } while (currentPosition.isNotNull() &amp;&amp; !atBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward));
  
      if (currentPosition.isNull())
          currentPosition = positionOfNextBoundaryOfGranularity(position, WordGranularity, DirectionForward);
  
      if (currentPosition.isNotNull()) {
          range = Range::create(position.deepEquivalent().deprecatedNode()-&gt;document(), currentPosition, position);
          ASSERT(range);
      }
<span class="line-added">+ </span>
      return range;
  }
  
  VisiblePosition closestWordBoundaryForPosition(const VisiblePosition&amp; position)
  {
</pre>
<center><a href="VisibleSelection.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebContentReader.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
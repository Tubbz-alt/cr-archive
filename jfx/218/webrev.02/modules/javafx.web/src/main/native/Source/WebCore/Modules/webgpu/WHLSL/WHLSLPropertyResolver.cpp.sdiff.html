<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPropertyResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLProgram.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLPruneUnreachableStandardLibraryFunctions.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPropertyResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLPropertyResolver.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-modified"> 31 #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-modified"> 32 #include &quot;WHLSLAssignmentExpression.h&quot;</span>
<span class="line-removed"> 33 #include &quot;WHLSLCallExpression.h&quot;</span>
<span class="line-removed"> 34 #include &quot;WHLSLCommaExpression.h&quot;</span>
<span class="line-removed"> 35 #include &quot;WHLSLDereferenceExpression.h&quot;</span>
<span class="line-removed"> 36 #include &quot;WHLSLDotExpression.h&quot;</span>
<span class="line-removed"> 37 #include &quot;WHLSLFunctionDeclaration.h&quot;</span>
<span class="line-removed"> 38 #include &quot;WHLSLFunctionDefinition.h&quot;</span>
<span class="line-removed"> 39 #include &quot;WHLSLIndexExpression.h&quot;</span>
<span class="line-removed"> 40 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;</span>
<span class="line-removed"> 41 #include &quot;WHLSLMakePointerExpression.h&quot;</span>
<span class="line-removed"> 42 #include &quot;WHLSLPointerType.h&quot;</span>
<span class="line-removed"> 43 #include &quot;WHLSLReadModifyWriteExpression.h&quot;</span>
 44 #include &quot;WHLSLReplaceWith.h&quot;
<span class="line-removed"> 45 #include &quot;WHLSLVariableDeclaration.h&quot;</span>
<span class="line-removed"> 46 #include &quot;WHLSLVariableReference.h&quot;</span>
 47 #include &quot;WHLSLVisitor.h&quot;
 48 
 49 namespace WebCore {
 50 
 51 namespace WHLSL {
 52 
 53 class PropertyResolver : public Visitor {
<span class="line-modified"> 54 public:</span>
<span class="line-modified"> 55 private:</span>
<span class="line-modified"> 56     void visit(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified"> 57     void visit(AST::DotExpression&amp;) override;</span>
<span class="line-modified"> 58     void visit(AST::IndexExpression&amp;) override;</span>
<span class="line-modified"> 59     void visit(AST::AssignmentExpression&amp;) override;</span>
<span class="line-removed"> 60     void visit(AST::ReadModifyWriteExpression&amp;) override;</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62     void simplifyRightValue(AST::PropertyAccessExpression&amp;);</span>
<span class="line-removed"> 63     bool simplifyAbstractLeftValue(AST::AssignmentExpression&amp;, AST::DotExpression&amp;, UniqueRef&lt;AST::Expression&gt;&amp;&amp; right);</span>
<span class="line-removed"> 64     void simplifyLeftValue(AST::Expression&amp;);</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66     AST::VariableDeclarations m_variableDeclarations;</span>
<span class="line-removed"> 67 };</span>
<span class="line-removed"> 68 </span>
<span class="line-removed"> 69 void PropertyResolver::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed"> 70 {</span>
<span class="line-removed"> 71     // Unless we&#39;re inside an AssignmentExpression or a ReadModifyWriteExpression, we&#39;re a right value.</span>
<span class="line-removed"> 72     simplifyRightValue(dotExpression);</span>
<span class="line-removed"> 73 }</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75 void PropertyResolver::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-removed"> 76 {</span>
<span class="line-removed"> 77     checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-removed"> 78     // Unless we&#39;re inside an AssignmentExpression or a ReadModifyWriteExpression, we&#39;re a right value.</span>
<span class="line-removed"> 79     simplifyRightValue(indexExpression);</span>
<span class="line-removed"> 80 }</span>
 81 
<span class="line-modified"> 82 void PropertyResolver::visit(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified"> 83 {</span>
<span class="line-modified"> 84     Visitor::visit(functionDefinition);</span>
<span class="line-modified"> 85     if (!m_variableDeclarations.isEmpty())</span>
<span class="line-modified"> 86         functionDefinition.block().statements().insert(0, makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.codeLocation(), WTFMove(m_variableDeclarations)));</span>
<span class="line-removed"> 87 }</span>
 88 
<span class="line-modified"> 89 enum class WhichAnder {</span>
<span class="line-removed"> 90     ThreadAnder,</span>
<span class="line-removed"> 91     Ander</span>
<span class="line-removed"> 92 };</span>
 93 
<span class="line-modified"> 94 struct AnderCallArgumentResult {</span>
<span class="line-modified"> 95     UniqueRef&lt;AST::Expression&gt; expression;</span>
<span class="line-modified"> 96     Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclaration;</span>
<span class="line-modified"> 97     WhichAnder whichAnder;</span>
<span class="line-modified"> 98 };</span>

 99 
<span class="line-modified">100 template &lt;typename ExpressionConstructor, typename TypeConstructor&gt;</span>
<span class="line-modified">101 static Optional&lt;AnderCallArgumentResult&gt; wrapAnderCallArgument(UniqueRef&lt;AST::Expression&gt;&amp; expression, Ref&lt;AST::UnnamedType&gt; baseType, AST::FunctionDeclaration* anderFunction, AST::FunctionDeclaration* threadAnderFunction)</span>
<span class="line-modified">102 {</span>
<span class="line-modified">103     auto functionEscapeMode = [] (AST::FunctionDeclaration&amp; functionDeclaration) {</span>
<span class="line-removed">104         if (functionDeclaration.isNativeFunctionDeclaration() || functionDeclaration.parsingMode() == ParsingMode::StandardLibrary)</span>
<span class="line-removed">105             return AST::AddressEscapeMode::DoesNotEscape;</span>
<span class="line-removed">106         return AST::AddressEscapeMode::Escapes;</span>
<span class="line-removed">107     };</span>
<span class="line-removed">108 </span>
<span class="line-removed">109     auto location = expression-&gt;codeLocation();</span>
<span class="line-removed">110     if (auto addressSpace = expression-&gt;typeAnnotation().leftAddressSpace()) {</span>
<span class="line-removed">111         if (!anderFunction)</span>
<span class="line-removed">112             return WTF::nullopt;</span>
<span class="line-removed">113         auto makeArrayReference = makeUniqueRef&lt;ExpressionConstructor&gt;(location, WTFMove(expression), functionEscapeMode(*anderFunction));</span>
<span class="line-removed">114         makeArrayReference-&gt;setType(TypeConstructor::create(location, *addressSpace, WTFMove(baseType)));</span>
<span class="line-removed">115         makeArrayReference-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">116         return {{ WTFMove(makeArrayReference), WTF::nullopt, WhichAnder::Ander }};</span>
<span class="line-removed">117     }</span>
<span class="line-removed">118     if (threadAnderFunction) {</span>
<span class="line-removed">119         auto variableDeclaration = makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), baseType.copyRef(), String(), nullptr, nullptr);</span>
120 
<span class="line-modified">121         auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-modified">122         variableReference1-&gt;setType(baseType.copyRef());</span>
<span class="line-modified">123         variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
124 
<span class="line-modified">125         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference1), WTFMove(expression));</span>
<span class="line-modified">126         assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">127         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
128 
<span class="line-modified">129         auto variableReference2 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-modified">130         variableReference2-&gt;setType(baseType.copyRef());</span>
<span class="line-modified">131         variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>

132 
<span class="line-modified">133         auto expression = makeUniqueRef&lt;ExpressionConstructor&gt;(location, WTFMove(variableReference2), functionEscapeMode(*threadAnderFunction));</span>
<span class="line-modified">134         auto resultType = TypeConstructor::create(location, AST::AddressSpace::Thread, WTFMove(baseType));</span>
<span class="line-removed">135         expression-&gt;setType(resultType.copyRef());</span>
<span class="line-removed">136         expression-&gt;setTypeAnnotation(AST::RightValue());</span>
137 
<span class="line-modified">138         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">139         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">140         expressions.append(WTFMove(expression));</span>
<span class="line-removed">141         auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));</span>
<span class="line-removed">142         commaExpression-&gt;setType(WTFMove(resultType));</span>
<span class="line-removed">143         commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">144         return {{ WTFMove(commaExpression), { WTFMove(variableDeclaration) }, WhichAnder::ThreadAnder}};</span>
145     }
<span class="line-removed">146     return WTF::nullopt;</span>
<span class="line-removed">147 }</span>
148 
<span class="line-modified">149 static Optional&lt;AnderCallArgumentResult&gt; anderCallArgument(UniqueRef&lt;AST::Expression&gt;&amp; expression, AST::FunctionDeclaration* anderFunction, AST::FunctionDeclaration* threadAnderFunction)</span>
<span class="line-modified">150 {</span>
<span class="line-modified">151     if (!anderFunction &amp;&amp; !threadAnderFunction)</span>
<span class="line-modified">152         return WTF::nullopt;</span>
<span class="line-modified">153     auto&amp; unifyNode = expression-&gt;resolvedType().unifyNode();</span>
<span class="line-modified">154     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {</span>
<span class="line-modified">155         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">156         ASSERT(!is&lt;AST::PointerType&gt;(unnamedType));</span>
<span class="line-modified">157         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified">158             return {{ WTFMove(expression), WTF::nullopt, WhichAnder::Ander }};</span>
<span class="line-modified">159         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified">160             return wrapAnderCallArgument&lt;AST::MakeArrayReferenceExpression, AST::ArrayReferenceType&gt;(expression, downcast&lt;AST::ArrayType&gt;(unnamedType).type(), anderFunction, threadAnderFunction);</span>
<span class="line-modified">161     }</span>
<span class="line-modified">162     return wrapAnderCallArgument&lt;AST::MakePointerExpression, AST::PointerType&gt;(expression, expression-&gt;resolvedType(), anderFunction, threadAnderFunction);</span>
<span class="line-modified">163 }</span>
164 
<span class="line-modified">165 static UniqueRef&lt;AST::Expression&gt; setterCall(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::FunctionDeclaration* relevantAnder, UniqueRef&lt;AST::Expression&gt;&amp;&amp; newValue, const std::function&lt;UniqueRef&lt;AST::Expression&gt;()&gt;&amp; leftValueFactory, AST::VariableDeclaration* indexVariable)</span>
<span class="line-removed">166 {</span>
<span class="line-removed">167     auto maybeAddIndexArgument = [&amp;](Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; arguments) {</span>
<span class="line-removed">168         if (!indexVariable)</span>
<span class="line-removed">169             return;</span>
<span class="line-removed">170         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));</span>
<span class="line-removed">171         ASSERT(indexVariable-&gt;type());</span>
<span class="line-removed">172         variableReference-&gt;setType(*indexVariable-&gt;type());</span>
<span class="line-removed">173         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">174         arguments.append(WTFMove(variableReference));</span>
<span class="line-removed">175     };</span>
<span class="line-removed">176 </span>
<span class="line-removed">177     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">178     if (relevantAnder) {</span>
<span class="line-removed">179         // *operator&amp;.foo(&amp;v) = newValue</span>
<span class="line-removed">180         auto leftValue = leftValueFactory();</span>
<span class="line-removed">181         auto argument = anderCallArgument(leftValue, relevantAnder, relevantAnder);</span>
<span class="line-removed">182         ASSERT(argument);</span>
<span class="line-removed">183         ASSERT(!argument-&gt;variableDeclaration);</span>
<span class="line-removed">184         ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);</span>
<span class="line-removed">185         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">186         arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">187         maybeAddIndexArgument(arguments);</span>
<span class="line-removed">188 </span>
<span class="line-removed">189         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(relevantAnder-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">190         callExpression-&gt;setType(relevantAnder-&gt;type());</span>
<span class="line-removed">191         callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">192         callExpression-&gt;setFunction(*relevantAnder);</span>
<span class="line-removed">193 </span>
<span class="line-removed">194         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(callExpression));</span>
<span class="line-removed">195         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());</span>
<span class="line-removed">196         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-removed">197 </span>
<span class="line-removed">198         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(dereferenceExpression), WTFMove(newValue));</span>
<span class="line-removed">199         assignmentExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());</span>
<span class="line-removed">200         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">201 </span>
<span class="line-removed">202         return UniqueRef&lt;AST::Expression&gt;(WTFMove(assignmentExpression));</span>
<span class="line-removed">203     }</span>
204 
<span class="line-modified">205     // v = operator.foo=(v, newValue)</span>
<span class="line-removed">206     ASSERT(propertyAccessExpression.setterFunction());</span>
207 
<span class="line-modified">208     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">209     arguments.append(leftValueFactory());</span>
<span class="line-removed">210     maybeAddIndexArgument(arguments);</span>
<span class="line-removed">211     arguments.append(WTFMove(newValue));</span>
212 
<span class="line-modified">213     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(propertyAccessExpression.setterFunction()-&gt;name()), WTFMove(arguments));</span>
<span class="line-modified">214     callExpression-&gt;setType(propertyAccessExpression.setterFunction()-&gt;type());</span>
<span class="line-modified">215     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">216     callExpression-&gt;setFunction(*propertyAccessExpression.setterFunction());</span>
217 
<span class="line-modified">218     auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, leftValueFactory(), WTFMove(callExpression));</span>
<span class="line-modified">219     assignmentExpression-&gt;setType(propertyAccessExpression.setterFunction()-&gt;type());</span>
<span class="line-modified">220     assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>



221 
<span class="line-modified">222     return UniqueRef&lt;AST::Expression&gt;(WTFMove(assignmentExpression));</span>
<span class="line-modified">223 }</span>

224 
<span class="line-modified">225 static UniqueRef&lt;AST::Expression&gt; getterCall(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::FunctionDeclaration* relevantAnder, const std::function&lt;UniqueRef&lt;AST::Expression&gt;()&gt;&amp; leftValueFactory, AST::VariableDeclaration* indexVariable)</span>
<span class="line-removed">226 {</span>
<span class="line-removed">227     auto maybeAddIndexArgument = [&amp;](Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; arguments) {</span>
<span class="line-removed">228         if (!indexVariable)</span>
<span class="line-removed">229             return;</span>
<span class="line-removed">230         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));</span>
<span class="line-removed">231         ASSERT(indexVariable-&gt;type());</span>
<span class="line-removed">232         variableReference-&gt;setType(*indexVariable-&gt;type());</span>
<span class="line-removed">233         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">234         arguments.append(WTFMove(variableReference));</span>
<span class="line-removed">235     };</span>
<span class="line-removed">236 </span>
<span class="line-removed">237     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">238 </span>
<span class="line-removed">239     if (relevantAnder) {</span>
<span class="line-removed">240         // *operator&amp;.foo(&amp;v)</span>
<span class="line-removed">241         auto leftValue = leftValueFactory();</span>
<span class="line-removed">242         auto argument = anderCallArgument(leftValue, relevantAnder, relevantAnder);</span>
<span class="line-removed">243         ASSERT(argument);</span>
<span class="line-removed">244         ASSERT(!argument-&gt;variableDeclaration);</span>
<span class="line-removed">245         ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);</span>
<span class="line-removed">246         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">247         arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">248         maybeAddIndexArgument(arguments);</span>
<span class="line-removed">249 </span>
<span class="line-removed">250         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(relevantAnder-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">251         callExpression-&gt;setType(relevantAnder-&gt;type());</span>
<span class="line-removed">252         callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">253         callExpression-&gt;setFunction(*relevantAnder);</span>
<span class="line-removed">254 </span>
<span class="line-removed">255         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(callExpression));</span>
<span class="line-removed">256         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());</span>
<span class="line-removed">257         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-removed">258 </span>
<span class="line-removed">259         return UniqueRef&lt;AST::Expression&gt;(WTFMove(dereferenceExpression));</span>
<span class="line-removed">260     }</span>
261 
<span class="line-modified">262     // operator.foo(v)</span>
<span class="line-removed">263     ASSERT(propertyAccessExpression.getterFunction());</span>
264 
<span class="line-modified">265     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-modified">266     arguments.append(leftValueFactory());</span>
<span class="line-modified">267     maybeAddIndexArgument(arguments);</span>
268 
<span class="line-modified">269     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(propertyAccessExpression.getterFunction()-&gt;name()), WTFMove(arguments));</span>
<span class="line-modified">270     callExpression-&gt;setType(propertyAccessExpression.getterFunction()-&gt;type());</span>
<span class="line-modified">271     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-modified">272     callExpression-&gt;setFunction(*propertyAccessExpression.getterFunction());</span>
273 
<span class="line-modified">274     return UniqueRef&lt;AST::Expression&gt;(WTFMove(callExpression));</span>
<span class="line-removed">275 }</span>
276 
<span class="line-modified">277 struct ModifyResult {</span>
<span class="line-removed">278     AST::Expression&amp; innerLeftValue;</span>
<span class="line-removed">279     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">280     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclarations;</span>
<span class="line-removed">281 };</span>
<span class="line-removed">282 struct ModificationResult {</span>
<span class="line-removed">283     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">284     UniqueRef&lt;AST::Expression&gt; result;</span>
<span class="line-removed">285 };</span>
<span class="line-removed">286 static ModifyResult modify(AST::PropertyAccessExpression&amp; propertyAccessExpression, std::function&lt;ModificationResult(UniqueRef&lt;AST::Expression&gt;&amp;&amp;)&gt; modification)</span>
<span class="line-removed">287 {</span>
<span class="line-removed">288     // Consider a.b.c.d++;</span>
<span class="line-removed">289     // This would get transformed into:</span>
<span class="line-removed">290     //</span>
<span class="line-removed">291     // Step 1:</span>
<span class="line-removed">292     // p = &amp;a;</span>
<span class="line-removed">293     //</span>
<span class="line-removed">294     // Step 2:</span>
<span class="line-removed">295     // q = operator.b(*p);</span>
<span class="line-removed">296     // r = operator.c(q);</span>
<span class="line-removed">297     //</span>
<span class="line-removed">298     // Step 3:</span>
<span class="line-removed">299     // oldValue = operator.d(r);</span>
<span class="line-removed">300     // newValue = ...;</span>
<span class="line-removed">301     //</span>
<span class="line-removed">302     // Step 4:</span>
<span class="line-removed">303     // r = operator.d=(r, newValue);</span>
<span class="line-removed">304     // q = operator.c=(q, r);</span>
<span class="line-removed">305     //</span>
<span class="line-removed">306     // Step 5:</span>
<span class="line-removed">307     // *p = operator.b=(*p, q);</span>
308 
<span class="line-modified">309     // If the expression is a.b.c.d = e, Step 3 disappears and &quot;newValue&quot; in step 4 becomes &quot;e&quot;.</span>





310 




311 
<span class="line-modified">312     // Find the &quot;.b&quot; &quot;.c&quot; and &quot;.d&quot; expressions. They end up in the order [&quot;.d&quot;, &quot;.c&quot;, &quot;.b&quot;].</span>
<span class="line-modified">313     Vector&lt;std::reference_wrapper&lt;AST::PropertyAccessExpression&gt;&gt; chain;</span>
<span class="line-removed">314     AST::PropertyAccessExpression* iterator = &amp;propertyAccessExpression;</span>
<span class="line-removed">315     while (true) {</span>
<span class="line-removed">316         chain.append(*iterator);</span>
<span class="line-removed">317         if (iterator-&gt;base().typeAnnotation().leftAddressSpace())</span>
<span class="line-removed">318             break;</span>
<span class="line-removed">319         ASSERT(!iterator-&gt;base().typeAnnotation().isRightValue());</span>
<span class="line-removed">320         iterator = &amp;downcast&lt;AST::PropertyAccessExpression&gt;(iterator-&gt;base());</span>
<span class="line-removed">321     }</span>
<span class="line-removed">322     auto leftExpression = iterator-&gt;takeBase();</span>
<span class="line-removed">323     AST::Expression&amp; innerLeftExpression = leftExpression;</span>
<span class="line-removed">324 </span>
<span class="line-removed">325     // Create &quot;p&quot; variable.</span>
<span class="line-removed">326     auto pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(leftExpression-&gt;codeLocation(), AST::Qualifiers(), AST::PointerType::create(leftExpression-&gt;codeLocation(), *leftExpression-&gt;typeAnnotation().leftAddressSpace(), leftExpression-&gt;resolvedType()), String(), nullptr, nullptr);</span>
<span class="line-removed">327 </span>
<span class="line-removed">328     // Create &quot;q&quot; and &quot;r&quot; variables.</span>
<span class="line-removed">329     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; intermediateVariables;</span>
<span class="line-removed">330     intermediateVariables.reserveInitialCapacity(chain.size() - 1);</span>
<span class="line-removed">331     for (size_t i = 1; i &lt; chain.size(); ++i) {</span>
<span class="line-removed">332         auto&amp; propertyAccessExpression = static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(chain[i]);</span>
<span class="line-removed">333         intermediateVariables.uncheckedAppend(makeUniqueRef&lt;AST::VariableDeclaration&gt;(propertyAccessExpression.codeLocation(), AST::Qualifiers(), &amp;propertyAccessExpression.resolvedType(), String(), nullptr, nullptr));</span>
<span class="line-removed">334     }</span>
335 
<span class="line-modified">336     // Consider a[foo()][b] = c;</span>
<span class="line-modified">337     // Naively, This would get expanded to:</span>
<span class="line-modified">338     //</span>
<span class="line-modified">339     // temp = operator[](a, foo());</span>
<span class="line-removed">340     // temp = operator[]=(temp, b, c);</span>
<span class="line-removed">341     // a = operator[]=(a, foo(), temp);</span>
<span class="line-removed">342     //</span>
<span class="line-removed">343     // However, if we did this, we would have to run foo() twice, which would be incorrect.</span>
<span class="line-removed">344     // Instead, we need to save foo() and b into more temporary variables.</span>
<span class="line-removed">345     // These temporary variables are parallel to &quot;chain&quot; above, with nullopt referring to a DotExpression (which doesn&#39;t have an index value to save to a variable).</span>
<span class="line-removed">346     //</span>
<span class="line-removed">347     // Instead, this gets expanded to:</span>
<span class="line-removed">348     //</span>
<span class="line-removed">349     // p = &amp;a;</span>
<span class="line-removed">350     // temp = foo();</span>
<span class="line-removed">351     // q = operator[](*p, temp);</span>
<span class="line-removed">352     // temp2 = b;</span>
<span class="line-removed">353     // q = operator[]=(q, temp2, c);</span>
<span class="line-removed">354     // *p = operator[]=(*p, temp, q);</span>
<span class="line-removed">355 </span>
<span class="line-removed">356     Vector&lt;Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&gt; indexVariables;</span>
<span class="line-removed">357     indexVariables.reserveInitialCapacity(chain.size());</span>
<span class="line-removed">358     for (AST::PropertyAccessExpression&amp; propertyAccessExpression : chain) {</span>
<span class="line-removed">359         if (!is&lt;AST::IndexExpression&gt;(propertyAccessExpression)) {</span>
<span class="line-removed">360             indexVariables.append(WTF::nullopt);</span>
<span class="line-removed">361             continue;</span>
362         }
<span class="line-removed">363         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">364         indexVariables.uncheckedAppend(makeUniqueRef&lt;AST::VariableDeclaration&gt;(propertyAccessExpression.codeLocation(), AST::Qualifiers(), &amp;indexExpression.indexExpression().resolvedType(), String(), nullptr, nullptr));</span>
365     }
366 
<span class="line-modified">367     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">368 </span>
<span class="line-removed">369     // Step 1:</span>
370     {
<span class="line-modified">371         auto makePointerExpression = makeUniqueRef&lt;AST::MakePointerExpression&gt;(innerLeftExpression.codeLocation(), WTFMove(leftExpression), AST::AddressEscapeMode::DoesNotEscape);</span>
<span class="line-removed">372         makePointerExpression-&gt;setType(AST::PointerType::create(innerLeftExpression.codeLocation(), *innerLeftExpression.typeAnnotation().leftAddressSpace(), innerLeftExpression.resolvedType()));</span>
<span class="line-removed">373         makePointerExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">374 </span>
<span class="line-removed">375         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">376         ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">377         variableReference-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">378         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">379 </span>
<span class="line-removed">380         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(innerLeftExpression.codeLocation(), WTFMove(variableReference), WTFMove(makePointerExpression));</span>
<span class="line-removed">381         assignmentExpression-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">382         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">383 </span>
<span class="line-removed">384         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">385     }</span>
<span class="line-removed">386 </span>
<span class="line-removed">387     // Step 2:</span>
<span class="line-removed">388     AST::VariableDeclaration* previous = nullptr;</span>
<span class="line-removed">389     auto previousLeftValue = [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {</span>
<span class="line-removed">390         if (previous) {</span>
<span class="line-removed">391             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*previous));</span>
<span class="line-removed">392             ASSERT(previous-&gt;type());</span>
<span class="line-removed">393             variableReference-&gt;setType(*previous-&gt;type());</span>
<span class="line-removed">394             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">395             return variableReference;</span>
<span class="line-removed">396         }</span>
<span class="line-removed">397 </span>
<span class="line-removed">398         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">399         ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">400         variableReference-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">401         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">402 </span>
<span class="line-removed">403         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference));</span>
<span class="line-removed">404         ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">405         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).elementType());</span>
<span class="line-removed">406         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).addressSpace() });</span>
<span class="line-removed">407         return dereferenceExpression;</span>
<span class="line-removed">408     };</span>
<span class="line-removed">409     auto appendIndexAssignment = [&amp;](AST::PropertyAccessExpression&amp; propertyAccessExpression, Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable) {</span>
<span class="line-removed">410         if (!indexVariable)</span>
<span class="line-removed">411             return;</span>
<span class="line-removed">412 </span>
<span class="line-removed">413         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">414 </span>
<span class="line-removed">415         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));</span>
<span class="line-removed">416         ASSERT(indexVariable-&gt;get().type());</span>
<span class="line-removed">417         variableReference-&gt;setType(*indexVariable-&gt;get().type());</span>
<span class="line-removed">418         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
419 
<span class="line-modified">420         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference), indexExpression.takeIndex());</span>
<span class="line-removed">421         assignmentExpression-&gt;setType(*indexVariable-&gt;get().type());</span>
<span class="line-removed">422         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
423 
<span class="line-modified">424         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">425     };</span>
<span class="line-removed">426     for (size_t i = chain.size(); --i; ) {</span>
<span class="line-removed">427         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[i];</span>
<span class="line-removed">428         AST::VariableDeclaration&amp; variableDeclaration = intermediateVariables[i - 1];</span>
<span class="line-removed">429         Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable = indexVariables[i];</span>
430 
<span class="line-modified">431         appendIndexAssignment(propertyAccessExpression, indexVariable);</span>



432 
<span class="line-modified">433         AST::FunctionDeclaration* relevantAnder = i == chain.size() - 1 ? propertyAccessExpression.anderFunction() : propertyAccessExpression.threadAnderFunction();</span>
<span class="line-modified">434         auto callExpression = getterCall(propertyAccessExpression, relevantAnder, previousLeftValue, indexVariable ? &amp;*indexVariable : nullptr);</span>

435 
<span class="line-modified">436         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-removed">437         ASSERT(variableDeclaration.type());</span>
<span class="line-removed">438         variableReference-&gt;setType(*variableDeclaration.type());</span>
<span class="line-removed">439         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
440 
<span class="line-modified">441         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference), WTFMove(callExpression));</span>
<span class="line-modified">442         assignmentExpression-&gt;setType(*variableDeclaration.type());</span>
<span class="line-modified">443         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>

444 
<span class="line-modified">445         expressions.append(WTFMove(assignmentExpression));</span>


446 
<span class="line-modified">447         previous = &amp;variableDeclaration;</span>
<span class="line-removed">448     }</span>
<span class="line-removed">449     appendIndexAssignment(chain[0], indexVariables[0]);</span>
<span class="line-removed">450     AST::FunctionDeclaration* relevantAnder = chain.size() == 1 ? propertyAccessExpression.anderFunction() : propertyAccessExpression.threadAnderFunction();</span>
<span class="line-removed">451     auto lastGetterCallExpression = getterCall(chain[0], relevantAnder, previousLeftValue, indexVariables[0] ? &amp;*(indexVariables[0]) : nullptr);</span>
<span class="line-removed">452 </span>
<span class="line-removed">453     // Step 3:</span>
<span class="line-removed">454     auto modificationResult = modification(WTFMove(lastGetterCallExpression));</span>
<span class="line-removed">455     for (size_t i = 0; i &lt; modificationResult.expressions.size(); ++i)</span>
<span class="line-removed">456         expressions.append(WTFMove(modificationResult.expressions[i]));</span>
<span class="line-removed">457 </span>
<span class="line-removed">458     // Step 4:</span>
<span class="line-removed">459     UniqueRef&lt;AST::Expression&gt; rightValue = WTFMove(modificationResult.result);</span>
<span class="line-removed">460     for (size_t i = 0; i &lt; chain.size() - 1; ++i) {</span>
<span class="line-removed">461         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[i];</span>
<span class="line-removed">462         AST::VariableDeclaration&amp; variableDeclaration = intermediateVariables[i];</span>
<span class="line-removed">463         Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable = indexVariables[i];</span>
<span class="line-removed">464 </span>
<span class="line-removed">465         auto assignmentExpression = setterCall(propertyAccessExpression, propertyAccessExpression.threadAnderFunction(), WTFMove(rightValue), [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {</span>
<span class="line-removed">466             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-removed">467             ASSERT(variableDeclaration.type());</span>
<span class="line-removed">468             variableReference-&gt;setType(*variableDeclaration.type());</span>
<span class="line-removed">469             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">470             return variableReference;</span>
<span class="line-removed">471         }, indexVariable ? &amp;*indexVariable : nullptr);</span>
472 
<span class="line-modified">473         expressions.append(WTFMove(assignmentExpression));</span>

474 
<span class="line-modified">475         rightValue = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));</span>
<span class="line-modified">476         ASSERT(variableDeclaration.type());</span>
<span class="line-removed">477         rightValue-&gt;setType(*variableDeclaration.type());</span>
<span class="line-removed">478         rightValue-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
479     }
480 
<span class="line-modified">481     // Step 5:</span>

482     {
<span class="line-modified">483         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[chain.size() - 1];</span>
<span class="line-removed">484         auto assignmentExpression = setterCall(propertyAccessExpression, propertyAccessExpression.anderFunction(), WTFMove(rightValue), [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {</span>
<span class="line-removed">485             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">486             ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">487             variableReference-&gt;setType(*pointerVariable-&gt;type());</span>
<span class="line-removed">488             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">489 </span>
<span class="line-removed">490             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference));</span>
<span class="line-removed">491             ASSERT(pointerVariable-&gt;type());</span>
<span class="line-removed">492             dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).elementType());</span>
<span class="line-removed">493             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).addressSpace() });</span>
<span class="line-removed">494             return dereferenceExpression;</span>
<span class="line-removed">495         }, indexVariables[indexVariables.size() - 1] ? &amp;*(indexVariables[indexVariables.size() - 1]) : nullptr);</span>
<span class="line-removed">496 </span>
<span class="line-removed">497         expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">498     }</span>
<span class="line-removed">499 </span>
<span class="line-removed">500     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclarations;</span>
<span class="line-removed">501     variableDeclarations.append(WTFMove(pointerVariable));</span>
<span class="line-removed">502     for (auto&amp; intermediateVariable : intermediateVariables)</span>
<span class="line-removed">503         variableDeclarations.append(WTFMove(intermediateVariable));</span>
<span class="line-removed">504     for (auto&amp; indexVariable : indexVariables) {</span>
<span class="line-removed">505         if (indexVariable)</span>
<span class="line-removed">506             variableDeclarations.append(WTFMove(*indexVariable));</span>
507     }
508 
<span class="line-modified">509     return { innerLeftExpression, WTFMove(expressions), WTFMove(variableDeclarations) };</span>
<span class="line-modified">510 }</span>
<span class="line-modified">511 </span>
<span class="line-removed">512 void PropertyResolver::visit(AST::AssignmentExpression&amp; assignmentExpression)</span>
<span class="line-removed">513 {</span>
<span class="line-removed">514     if (assignmentExpression.left().typeAnnotation().leftAddressSpace()) {</span>
<span class="line-removed">515         simplifyLeftValue(assignmentExpression.left());</span>
<span class="line-removed">516         checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-removed">517         return;</span>
518     }
<span class="line-removed">519     ASSERT(!assignmentExpression.left().typeAnnotation().isRightValue());</span>
<span class="line-removed">520 </span>
<span class="line-removed">521     Ref&lt;AST::UnnamedType&gt; type = assignmentExpression.right().resolvedType();</span>
522 
<span class="line-modified">523     checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-modified">524 </span>
<span class="line-modified">525     auto modifyResult = modify(downcast&lt;AST::PropertyAccessExpression&gt;(assignmentExpression.left()), [&amp;](UniqueRef&lt;AST::Expression&gt;&amp;&amp;) -&gt; ModificationResult {</span>
<span class="line-modified">526         return { Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;(), assignmentExpression.takeRight() };</span>
<span class="line-removed">527     });</span>
<span class="line-removed">528 </span>
<span class="line-removed">529     simplifyLeftValue(modifyResult.innerLeftValue);</span>
<span class="line-removed">530 </span>
<span class="line-removed">531     auto location = assignmentExpression.codeLocation();</span>
<span class="line-removed">532     auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(assignmentExpression, location, WTFMove(modifyResult.expressions));</span>
<span class="line-removed">533     commaExpression-&gt;setType(WTFMove(type));</span>
<span class="line-removed">534     commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">535 </span>
<span class="line-removed">536     for (auto&amp; variableDeclaration : modifyResult.variableDeclarations)</span>
<span class="line-removed">537         m_variableDeclarations.append(WTFMove(variableDeclaration));</span>
<span class="line-removed">538 }</span>
<span class="line-removed">539 </span>
<span class="line-removed">540 void PropertyResolver::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)</span>
<span class="line-removed">541 {</span>
<span class="line-removed">542     checkErrorAndVisit(readModifyWriteExpression.newValueExpression());</span>
<span class="line-removed">543     if (hasError())</span>
<span class="line-removed">544         return;</span>
<span class="line-removed">545 </span>
<span class="line-removed">546     auto location = readModifyWriteExpression.codeLocation();</span>
<span class="line-removed">547     auto leftValueLocation = readModifyWriteExpression.leftValue().codeLocation();</span>
<span class="line-removed">548 </span>
<span class="line-removed">549     if (readModifyWriteExpression.leftValue().typeAnnotation().leftAddressSpace()) {</span>
<span class="line-removed">550         // Consider a++;</span>
<span class="line-removed">551         // This would get transformed into:</span>
<span class="line-removed">552         //</span>
<span class="line-removed">553         // p = &amp;a;</span>
<span class="line-removed">554         // oldValue = *p;</span>
<span class="line-removed">555         // newValue = ...;</span>
<span class="line-removed">556         // *p = newValue;</span>
<span class="line-removed">557 </span>
<span class="line-removed">558         simplifyLeftValue(readModifyWriteExpression.leftValue());</span>
<span class="line-removed">559 </span>
<span class="line-removed">560         Ref&lt;AST::UnnamedType&gt; baseType = readModifyWriteExpression.leftValue().resolvedType();</span>
<span class="line-removed">561         Ref&lt;AST::UnnamedType&gt; pointerType = AST::PointerType::create(leftValueLocation, *readModifyWriteExpression.leftValue().typeAnnotation().leftAddressSpace(), baseType.copyRef());</span>
<span class="line-removed">562 </span>
<span class="line-removed">563         auto pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(leftValueLocation, AST::Qualifiers(), pointerType.copyRef(), String(), nullptr, nullptr);</span>
564 
565         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
566 
<span class="line-modified">567         {</span>
<span class="line-removed">568             auto makePointerExpression = makeUniqueRef&lt;AST::MakePointerExpression&gt;(leftValueLocation, readModifyWriteExpression.takeLeftValue(), AST::AddressEscapeMode::DoesNotEscape);</span>
<span class="line-removed">569             makePointerExpression-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">570             makePointerExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">571 </span>
<span class="line-removed">572             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">573             variableReference-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">574             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
575 
<span class="line-modified">576             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(makePointerExpression));</span>
<span class="line-removed">577             assignmentExpression-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">578             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
579 
<span class="line-modified">580             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-modified">581         }</span>


582 
583         {
<span class="line-modified">584             auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-modified">585             variableReference1-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified">586             variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-modified">587 </span>
<span class="line-modified">588             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(variableReference1));</span>
<span class="line-modified">589             dereferenceExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-modified">590             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-modified">591 </span>
<span class="line-removed">592             auto variableReference2 = readModifyWriteExpression.oldVariableReference();</span>
<span class="line-removed">593             variableReference2-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">594             variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">595 </span>
<span class="line-removed">596             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference2), WTFMove(dereferenceExpression));</span>
<span class="line-removed">597             assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">598             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">599 </span>
<span class="line-removed">600             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">601         }</span>
<span class="line-removed">602 </span>
<span class="line-removed">603         {</span>
<span class="line-removed">604             auto variableReference = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">605             variableReference-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">606             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">607 </span>
<span class="line-removed">608             auto newValueExpression = readModifyWriteExpression.takeNewValueExpression();</span>
<span class="line-removed">609             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference), WTFMove(newValueExpression));</span>
<span class="line-removed">610             assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">611             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">612 </span>
<span class="line-removed">613             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">614         }</span>
<span class="line-removed">615 </span>
<span class="line-removed">616         {</span>
<span class="line-removed">617             auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-removed">618             variableReference1-&gt;setType(pointerType.copyRef());</span>
<span class="line-removed">619             variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">620 </span>
<span class="line-removed">621             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(variableReference1));</span>
<span class="line-removed">622             dereferenceExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">623             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">624 </span>
<span class="line-removed">625             auto variableReference2 = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">626             variableReference2-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">627             variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">628 </span>
<span class="line-removed">629             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(dereferenceExpression), WTFMove(variableReference2));</span>
<span class="line-removed">630             assignmentExpression-&gt;setType(baseType.copyRef());</span>
<span class="line-removed">631             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">632 </span>
<span class="line-removed">633             expressions.append(WTFMove(assignmentExpression));</span>
634         }
635 
<span class="line-modified">636         auto resultExpression = readModifyWriteExpression.takeResultExpression();</span>
<span class="line-modified">637         Ref&lt;AST::UnnamedType&gt; type = resultExpression-&gt;resolvedType();</span>
<span class="line-modified">638         expressions.append(WTFMove(resultExpression));</span>
<span class="line-removed">639 </span>
<span class="line-removed">640         UniqueRef&lt;AST::VariableDeclaration&gt; oldVariableDeclaration = readModifyWriteExpression.takeOldValue();</span>
<span class="line-removed">641         UniqueRef&lt;AST::VariableDeclaration&gt; newVariableDeclaration = readModifyWriteExpression.takeNewValue();</span>
<span class="line-removed">642 </span>
<span class="line-removed">643         auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWriteExpression, location, WTFMove(expressions));</span>
<span class="line-removed">644         commaExpression-&gt;setType(WTFMove(type));</span>
<span class="line-removed">645         commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">646 </span>
<span class="line-removed">647         m_variableDeclarations.append(WTFMove(pointerVariable));</span>
<span class="line-removed">648         m_variableDeclarations.append(WTFMove(oldVariableDeclaration));</span>
<span class="line-removed">649         m_variableDeclarations.append(WTFMove(newVariableDeclaration));</span>
<span class="line-removed">650         return;</span>
651     }
652 
<span class="line-modified">653     ASSERT(!readModifyWriteExpression.leftValue().typeAnnotation().isRightValue());</span>
<span class="line-modified">654     if (!is&lt;AST::PropertyAccessExpression&gt;(readModifyWriteExpression.leftValue())) {</span>
<span class="line-modified">655         setError(Error(&quot;Base of read modify write expression is a right-value.&quot;, readModifyWriteExpression.leftValue().codeLocation()));</span>
<span class="line-removed">656         return;</span>
<span class="line-removed">657     }</span>
<span class="line-removed">658     auto modifyResult = modify(downcast&lt;AST::PropertyAccessExpression&gt;(readModifyWriteExpression.leftValue()), [&amp;](UniqueRef&lt;AST::Expression&gt;&amp;&amp; lastGetterCallExpression) -&gt; ModificationResult {</span>
<span class="line-removed">659         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>
<span class="line-removed">660 </span>
<span class="line-removed">661         {</span>
<span class="line-removed">662             auto variableReference = readModifyWriteExpression.oldVariableReference();</span>
<span class="line-removed">663             variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">664             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">665 </span>
<span class="line-removed">666             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(lastGetterCallExpression));</span>
<span class="line-removed">667             assignmentExpression-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">668             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">669 </span>
<span class="line-removed">670             expressions.append(WTFMove(assignmentExpression));</span>
<span class="line-removed">671         }</span>
<span class="line-removed">672 </span>
<span class="line-removed">673         {</span>
<span class="line-removed">674             auto variableReference = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">675             variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">676             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
677 
<span class="line-modified">678             auto newValueExpression = readModifyWriteExpression.takeNewValueExpression();</span>
<span class="line-modified">679             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(newValueExpression));</span>
<span class="line-removed">680             assignmentExpression-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">681             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
682 
<span class="line-modified">683             expressions.append(WTFMove(assignmentExpression));</span>


684         }
<span class="line-removed">685 </span>
<span class="line-removed">686         auto variableReference = readModifyWriteExpression.newVariableReference();</span>
<span class="line-removed">687         variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());</span>
<span class="line-removed">688         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?</span>
<span class="line-removed">689 </span>
<span class="line-removed">690         return { WTFMove(expressions),  WTFMove(variableReference) };</span>
<span class="line-removed">691     });</span>
<span class="line-removed">692 </span>
<span class="line-removed">693     simplifyLeftValue(modifyResult.innerLeftValue);</span>
<span class="line-removed">694 </span>
<span class="line-removed">695     auto resultExpression = readModifyWriteExpression.takeResultExpression();</span>
<span class="line-removed">696     Ref&lt;AST::UnnamedType&gt; type = resultExpression-&gt;resolvedType();</span>
<span class="line-removed">697     modifyResult.expressions.append(WTFMove(resultExpression));</span>
<span class="line-removed">698 </span>
<span class="line-removed">699     UniqueRef&lt;AST::VariableDeclaration&gt; oldVariableDeclaration = readModifyWriteExpression.takeOldValue();</span>
<span class="line-removed">700     UniqueRef&lt;AST::VariableDeclaration&gt; newVariableDeclaration = readModifyWriteExpression.takeNewValue();</span>
<span class="line-removed">701 </span>
<span class="line-removed">702     auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWriteExpression, location, WTFMove(modifyResult.expressions));</span>
<span class="line-removed">703     commaExpression-&gt;setType(WTFMove(type));</span>
<span class="line-removed">704     commaExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">705 </span>
<span class="line-removed">706     for (auto&amp; variableDeclaration : modifyResult.variableDeclarations)</span>
<span class="line-removed">707         m_variableDeclarations.append(WTFMove(variableDeclaration));</span>
<span class="line-removed">708     m_variableDeclarations.append(WTFMove(oldVariableDeclaration));</span>
<span class="line-removed">709     m_variableDeclarations.append(WTFMove(newVariableDeclaration));</span>
<span class="line-removed">710 }</span>
<span class="line-removed">711 </span>
<span class="line-removed">712 static Optional&lt;AnderCallArgumentResult&gt; anderCallArgument(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-removed">713 {</span>
<span class="line-removed">714     return anderCallArgument(propertyAccessExpression.baseReference(), propertyAccessExpression.anderFunction(), propertyAccessExpression.threadAnderFunction());</span>
<span class="line-removed">715 }</span>
<span class="line-removed">716 </span>
<span class="line-removed">717 void PropertyResolver::simplifyRightValue(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-removed">718 {</span>
<span class="line-removed">719     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">720 </span>
<span class="line-removed">721     checkErrorAndVisit(propertyAccessExpression.base());</span>
<span class="line-removed">722 </span>
<span class="line-removed">723     if (auto argument = anderCallArgument(propertyAccessExpression)) {</span>
<span class="line-removed">724         auto* anderFunction = argument-&gt;whichAnder == WhichAnder::ThreadAnder ? propertyAccessExpression.threadAnderFunction() : propertyAccessExpression.anderFunction();</span>
<span class="line-removed">725         ASSERT(anderFunction);</span>
<span class="line-removed">726         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">727         arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">728         if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression))</span>
<span class="line-removed">729             arguments.append(downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression).takeIndex());</span>
<span class="line-removed">730         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(anderFunction-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">731         callExpression-&gt;setType(anderFunction-&gt;type());</span>
<span class="line-removed">732         callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">733         callExpression-&gt;setFunction(*anderFunction);</span>
<span class="line-removed">734 </span>
<span class="line-removed">735         auto* dereferenceExpression = AST::replaceWith&lt;AST::DereferenceExpression&gt;(propertyAccessExpression, location, WTFMove(callExpression));</span>
<span class="line-removed">736         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType());</span>
<span class="line-removed">737         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).addressSpace() });</span>
<span class="line-removed">738 </span>
<span class="line-removed">739         if (auto&amp; variableDeclaration = argument-&gt;variableDeclaration)</span>
<span class="line-removed">740             m_variableDeclarations.append(WTFMove(*variableDeclaration));</span>
<span class="line-removed">741 </span>
<span class="line-removed">742         return;</span>
<span class="line-removed">743     }</span>
<span class="line-removed">744 </span>
<span class="line-removed">745     ASSERT(propertyAccessExpression.getterFunction());</span>
<span class="line-removed">746     auto&amp; getterFunction = *propertyAccessExpression.getterFunction();</span>
<span class="line-removed">747     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">748     arguments.append(propertyAccessExpression.takeBase());</span>
<span class="line-removed">749     AST::CallExpression* callExpression;</span>
<span class="line-removed">750     if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression)) {</span>
<span class="line-removed">751         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">752         arguments.append(indexExpression.takeIndex());</span>
<span class="line-removed">753         callExpression = AST::replaceWith&lt;AST::CallExpression&gt;(indexExpression, location, String(getterFunction.name()), WTFMove(arguments));</span>
<span class="line-removed">754     } else {</span>
<span class="line-removed">755         ASSERT(is&lt;AST::DotExpression&gt;(propertyAccessExpression));</span>
<span class="line-removed">756         auto&amp; dotExpression = downcast&lt;AST::DotExpression&gt;(propertyAccessExpression);</span>
<span class="line-removed">757         callExpression = AST::replaceWith&lt;AST::CallExpression&gt;(dotExpression, location, String(getterFunction.name()), WTFMove(arguments));</span>
758     }
<span class="line-removed">759     callExpression-&gt;setFunction(getterFunction);</span>
<span class="line-removed">760     callExpression-&gt;setType(getterFunction.type());</span>
<span class="line-removed">761     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">762 }</span>
763 
<span class="line-removed">764 class LeftValueSimplifier : public Visitor {</span>
765 private:
<span class="line-modified">766     void visit(AST::DotExpression&amp;) override;</span>
<span class="line-removed">767     void visit(AST::IndexExpression&amp;) override;</span>
<span class="line-removed">768     void visit(AST::DereferenceExpression&amp;) override;</span>
<span class="line-removed">769 </span>
<span class="line-removed">770     void finishVisiting(AST::PropertyAccessExpression&amp;);</span>
771 };
772 
<span class="line-removed">773 void LeftValueSimplifier::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-removed">774 {</span>
<span class="line-removed">775     ASSERT(propertyAccessExpression.base().typeAnnotation().leftAddressSpace());</span>
<span class="line-removed">776     ASSERT(propertyAccessExpression.anderFunction());</span>
<span class="line-removed">777 </span>
<span class="line-removed">778     Visitor::visit(propertyAccessExpression.base());</span>
<span class="line-removed">779 </span>
<span class="line-removed">780     auto location = propertyAccessExpression.codeLocation();</span>
<span class="line-removed">781     auto* anderFunction = propertyAccessExpression.anderFunction();</span>
<span class="line-removed">782 </span>
<span class="line-removed">783     auto argument = anderCallArgument(propertyAccessExpression);</span>
<span class="line-removed">784     ASSERT(argument);</span>
<span class="line-removed">785     ASSERT(!argument-&gt;variableDeclaration);</span>
<span class="line-removed">786     ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);</span>
<span class="line-removed">787 </span>
<span class="line-removed">788     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;</span>
<span class="line-removed">789     arguments.append(WTFMove(argument-&gt;expression));</span>
<span class="line-removed">790     if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression))</span>
<span class="line-removed">791         arguments.append(downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression).takeIndex());</span>
<span class="line-removed">792     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(anderFunction-&gt;name()), WTFMove(arguments));</span>
<span class="line-removed">793     callExpression-&gt;setType(anderFunction-&gt;type());</span>
<span class="line-removed">794     callExpression-&gt;setTypeAnnotation(AST::RightValue());</span>
<span class="line-removed">795     callExpression-&gt;setFunction(*anderFunction);</span>
<span class="line-removed">796 </span>
<span class="line-removed">797     auto* dereferenceExpression = AST::replaceWith&lt;AST::DereferenceExpression&gt;(propertyAccessExpression, location, WTFMove(callExpression));</span>
<span class="line-removed">798     dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType());</span>
<span class="line-removed">799     dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).addressSpace() });</span>
<span class="line-removed">800 }</span>
<span class="line-removed">801 </span>
<span class="line-removed">802 void LeftValueSimplifier::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed">803 {</span>
<span class="line-removed">804     Visitor::visit(dotExpression);</span>
<span class="line-removed">805     finishVisiting(dotExpression);</span>
<span class="line-removed">806 }</span>
<span class="line-removed">807 </span>
<span class="line-removed">808 void LeftValueSimplifier::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-removed">809 {</span>
<span class="line-removed">810     PropertyResolver().Visitor::visit(indexExpression.indexExpression());</span>
<span class="line-removed">811     finishVisiting(indexExpression);</span>
<span class="line-removed">812 }</span>
<span class="line-removed">813 </span>
<span class="line-removed">814 void LeftValueSimplifier::visit(AST::DereferenceExpression&amp; dereferenceExpression)</span>
<span class="line-removed">815 {</span>
<span class="line-removed">816     // Dereference expressions are the only expressions where the children might be more-right than we are.</span>
<span class="line-removed">817     // For example, a dereference expression may be a left value but its child may be a call expression which is a right value.</span>
<span class="line-removed">818     // LeftValueSimplifier doesn&#39;t handle right values, so we instead need to use PropertyResolver.</span>
<span class="line-removed">819     PropertyResolver().Visitor::visit(dereferenceExpression);</span>
<span class="line-removed">820 }</span>
<span class="line-removed">821 </span>
<span class="line-removed">822 void PropertyResolver::simplifyLeftValue(AST::Expression&amp; expression)</span>
<span class="line-removed">823 {</span>
<span class="line-removed">824     LeftValueSimplifier().Visitor::visit(expression);</span>
<span class="line-removed">825 }</span>
<span class="line-removed">826 </span>
827 void resolveProperties(Program&amp; program)
828 {
<span class="line-modified">829     PropertyResolver().Visitor::visit(program);</span>














830 }
831 
832 } // namespace WHLSL
833 
834 } // namespace WebCore
835 
836 #endif // ENABLE(WEBGPU)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLPropertyResolver.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-modified"> 31 #include &quot;WHLSLAST.h&quot;</span>
<span class="line-modified"> 32 #include &quot;WHLSLProgram.h&quot;</span>











 33 #include &quot;WHLSLReplaceWith.h&quot;


 34 #include &quot;WHLSLVisitor.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 namespace WHLSL {
 39 
 40 class PropertyResolver : public Visitor {
<span class="line-modified"> 41     void handleLeftHandSideBase(UniqueRef&lt;AST::Expression&gt; base, UniqueRef&lt;AST::Expression&gt;&amp; slot, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)</span>
<span class="line-modified"> 42     {</span>
<span class="line-modified"> 43         if (!base-&gt;mayBeEffectful()) {</span>
<span class="line-modified"> 44             slot = WTFMove(base);</span>
<span class="line-modified"> 45             return;</span>
<span class="line-modified"> 46         }</span>





















 47 
<span class="line-modified"> 48         auto leftAddressSpace = base-&gt;typeAnnotation().leftAddressSpace();</span>
<span class="line-modified"> 49         RELEASE_ASSERT(leftAddressSpace);</span>
<span class="line-modified"> 50         CodeLocation codeLocation = base-&gt;codeLocation();</span>
<span class="line-modified"> 51         Ref&lt;AST::UnnamedType&gt; baseType = base-&gt;resolvedType();</span>
<span class="line-modified"> 52         Ref&lt;AST::PointerType&gt; pointerType = AST::PointerType::create(codeLocation, *leftAddressSpace, baseType.copyRef());</span>

 53 
<span class="line-modified"> 54         UniqueRef&lt;AST::VariableDeclaration&gt; pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(codeLocation, AST::Qualifiers { }, pointerType.ptr(), String(), nullptr, nullptr);</span>



 55 
<span class="line-modified"> 56         auto makeVariableReference = [&amp;] {</span>
<span class="line-modified"> 57             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));</span>
<span class="line-modified"> 58             variableReference-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified"> 59             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-modified"> 60             return variableReference;</span>
<span class="line-added"> 61         };</span>
 62 
<span class="line-modified"> 63         {</span>
<span class="line-modified"> 64             auto pointerOfBase = makeUniqueRef&lt;AST::MakePointerExpression&gt;(codeLocation, WTFMove(base), AST::AddressEscapeMode::DoesNotEscape);</span>
<span class="line-modified"> 65             pointerOfBase-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified"> 66             pointerOfBase-&gt;setTypeAnnotation(AST::RightValue());</span>
















 67 
<span class="line-modified"> 68             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(codeLocation, makeVariableReference(), WTFMove(pointerOfBase));</span>
<span class="line-modified"> 69             assignment-&gt;setType(pointerType.copyRef());</span>
<span class="line-modified"> 70             assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
 71 
<span class="line-modified"> 72             expressions.append(WTFMove(assignment));</span>
<span class="line-modified"> 73         }</span>

 74 
<span class="line-modified"> 75         {</span>
<span class="line-modified"> 76             auto dereference = makeUniqueRef&lt;AST::DereferenceExpression&gt;(codeLocation, makeVariableReference());</span>
<span class="line-modified"> 77             dereference-&gt;setType(baseType.copyRef());</span>
<span class="line-added"> 78             dereference-&gt;setTypeAnnotation(AST::LeftValue { *leftAddressSpace });</span>
 79 
<span class="line-modified"> 80             slot = WTFMove(dereference);</span>
<span class="line-modified"> 81         }</span>


 82 
<span class="line-modified"> 83         m_variables.append(WTFMove(pointerVariable));</span>






 84     }


 85 
<span class="line-modified"> 86     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)</span>
<span class="line-modified"> 87     {</span>
<span class="line-modified"> 88         AST::PropertyAccessExpression* currentPtr = &amp;propertyAccess;</span>
<span class="line-modified"> 89         // a.b[c].d will go into this array as [.d, [c], .b]</span>
<span class="line-modified"> 90         Vector&lt;std::reference_wrapper&lt;AST::PropertyAccessExpression&gt;&gt; chain;</span>
<span class="line-modified"> 91 </span>
<span class="line-modified"> 92         while (true) {</span>
<span class="line-modified"> 93             AST::PropertyAccessExpression&amp; current = *currentPtr;</span>
<span class="line-modified"> 94             chain.append(current);</span>
<span class="line-modified"> 95             if (is&lt;AST::IndexExpression&gt;(current))</span>
<span class="line-modified"> 96                 checkErrorAndVisit(downcast&lt;AST::IndexExpression&gt;(current).indexExpression());</span>
<span class="line-modified"> 97             if (!is&lt;AST::PropertyAccessExpression&gt;(current.base()))</span>
<span class="line-modified"> 98                 break;</span>
<span class="line-modified"> 99             currentPtr = &amp;downcast&lt;AST::PropertyAccessExpression&gt;(current.base());</span>
<span class="line-modified">100         }</span>
101 
<span class="line-modified">102         AST::PropertyAccessExpression&amp; current = *currentPtr;</span>






































103 
<span class="line-modified">104         checkErrorAndVisit(current.base());</span>

105 
<span class="line-modified">106         CodeLocation baseCodeLocation = current.base().codeLocation();</span>



107 
<span class="line-modified">108         if (current.base().typeAnnotation().isRightValue()) {</span>
<span class="line-modified">109             UniqueRef&lt;AST::VariableDeclaration&gt; copy = makeUniqueRef&lt;AST::VariableDeclaration&gt;(baseCodeLocation, AST::Qualifiers { }, &amp;current.base().resolvedType(), String(), nullptr, nullptr);</span>
<span class="line-modified">110             Ref&lt;AST::UnnamedType&gt; baseType = current.base().resolvedType();</span>

111 
<span class="line-modified">112             auto makeVariableReference = [&amp;] {</span>
<span class="line-modified">113                 auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(copy));</span>
<span class="line-modified">114                 variableReference-&gt;setType(baseType.copyRef());</span>
<span class="line-added">115                 variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-added">116                 return variableReference;</span>
<span class="line-added">117             };</span>
118 
<span class="line-modified">119             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), current.takeBase());</span>
<span class="line-modified">120             assignment-&gt;setType(baseType.copyRef());</span>
<span class="line-added">121             assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
122 
<span class="line-modified">123             expressions.append(WTFMove(assignment));</span>



































124 
<span class="line-modified">125             current.baseReference() = makeVariableReference();</span>

126 
<span class="line-modified">127             m_variables.append(WTFMove(copy));</span>
<span class="line-modified">128         } else</span>
<span class="line-modified">129             handleLeftHandSideBase(current.takeBase(), current.baseReference(), expressions);</span>
130 
<span class="line-modified">131         for (size_t i = chain.size(); i--; ) {</span>
<span class="line-modified">132             auto&amp; access = chain[i].get();</span>
<span class="line-modified">133             if (is&lt;AST::IndexExpression&gt;(access) &amp;&amp; downcast&lt;AST::IndexExpression&gt;(access).indexExpression().mayBeEffectful()) {</span>
<span class="line-modified">134                 auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(access);</span>
135 
<span class="line-modified">136                 Ref&lt;AST::UnnamedType&gt; indexType = indexExpression.indexExpression().resolvedType();</span>

137 
<span class="line-modified">138                 UniqueRef&lt;AST::VariableDeclaration&gt; indexVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(access.codeLocation(), AST::Qualifiers { }, indexType.ptr(), String(), nullptr, nullptr);</span>






























139 
<span class="line-modified">140                 auto makeVariableReference = [&amp;] {</span>
<span class="line-added">141                     auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(indexVariable));</span>
<span class="line-added">142                     variableReference-&gt;setType(indexType.copyRef());</span>
<span class="line-added">143                     variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });</span>
<span class="line-added">144                     return variableReference;</span>
<span class="line-added">145                 };</span>
146 
<span class="line-added">147                 {</span>
<span class="line-added">148                     auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), indexExpression.takeIndex());</span>
<span class="line-added">149                     assignment-&gt;setType(indexType.copyRef());</span>
<span class="line-added">150                     assignment-&gt;setTypeAnnotation(AST::RightValue());</span>
151 
<span class="line-modified">152                     expressions.append(WTFMove(assignment));</span>
<span class="line-modified">153                 }</span>





















154 
<span class="line-modified">155                 indexExpression.indexReference() = makeVariableReference();</span>
<span class="line-modified">156 </span>
<span class="line-modified">157                 m_variables.append(WTFMove(indexVariable));</span>
<span class="line-modified">158             }</span>






















159         }


160     }
161 
<span class="line-modified">162     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess)</span>


163     {
<span class="line-modified">164         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;</span>















































165 
<span class="line-modified">166         handlePropertyAccess(propertyAccess, expressions);</span>


167 
<span class="line-modified">168         Ref&lt;AST::UnnamedType&gt; accessType = propertyAccess.resolvedType();</span>





169 
<span class="line-modified">170         AST::CommaExpression* comma;</span>
<span class="line-added">171         CodeLocation codeLocation = propertyAccess.codeLocation();</span>
<span class="line-added">172         if (is&lt;AST::IndexExpression&gt;(propertyAccess)) {</span>
<span class="line-added">173             auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccess);</span>
174 
<span class="line-modified">175             auto newIndexExpression = makeUniqueRef&lt;AST::IndexExpression&gt;(codeLocation, indexExpression.takeBase(), indexExpression.takeIndex());</span>
<span class="line-modified">176             newIndexExpression-&gt;setType(indexExpression.resolvedType());</span>
<span class="line-added">177             newIndexExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(indexExpression.typeAnnotation()));</span>
178 
<span class="line-modified">179             expressions.append(WTFMove(newIndexExpression));</span>



180 
<span class="line-modified">181             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(indexExpression, codeLocation, WTFMove(expressions));</span>
<span class="line-modified">182         } else {</span>
<span class="line-modified">183             RELEASE_ASSERT(is&lt;AST::DotExpression&gt;(propertyAccess));</span>
<span class="line-added">184             auto&amp; dotExpression = downcast&lt;AST::DotExpression&gt;(propertyAccess);</span>
185 
<span class="line-modified">186             auto newDotExpression = makeUniqueRef&lt;AST::DotExpression&gt;(codeLocation, dotExpression.takeBase(), String(dotExpression.fieldName()));</span>
<span class="line-added">187             newDotExpression-&gt;setType(dotExpression.resolvedType());</span>
<span class="line-added">188             newDotExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(dotExpression.typeAnnotation()));</span>
189 
<span class="line-modified">190             expressions.append(WTFMove(newDotExpression));</span>
























191 
<span class="line-modified">192             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(dotExpression, codeLocation, WTFMove(expressions));</span>
<span class="line-added">193         }</span>
194 
<span class="line-modified">195         comma-&gt;setType(WTFMove(accessType));</span>
<span class="line-modified">196         comma-&gt;setTypeAnnotation(AST::RightValue());</span>


197     }
198 
<span class="line-modified">199 public:</span>
<span class="line-added">200     void visit(AST::DotExpression&amp; dotExpression) override</span>
201     {
<span class="line-modified">202         handlePropertyAccess(dotExpression);</span>























203     }
204 
<span class="line-modified">205     void visit(AST::IndexExpression&amp; indexExpression) override</span>
<span class="line-modified">206     {</span>
<span class="line-modified">207         handlePropertyAccess(indexExpression);</span>






208     }



209 
<span class="line-modified">210     void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override</span>
<span class="line-modified">211     {</span>
<span class="line-modified">212         checkErrorAndVisit(readModifyWrite.newValueExpression());</span>
<span class="line-modified">213         checkErrorAndVisit(readModifyWrite.resultExpression());</span>





































214 
215         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
216 
<span class="line-modified">217         CodeLocation codeLocation = readModifyWrite.codeLocation();</span>







218 
<span class="line-modified">219         Ref&lt;AST::UnnamedType&gt; type = readModifyWrite.resolvedType();</span>


220 
<span class="line-modified">221         if (is&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()))</span>
<span class="line-modified">222             handlePropertyAccess(downcast&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()), expressions);</span>
<span class="line-added">223         else</span>
<span class="line-added">224             handleLeftHandSideBase(readModifyWrite.takeLeftValue(), readModifyWrite.leftValueReference(), expressions);</span>
225 
226         {
<span class="line-modified">227             UniqueRef&lt;AST::ReadModifyWriteExpression&gt; newReadModifyWrite = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(</span>
<span class="line-modified">228                 readModifyWrite.codeLocation(), readModifyWrite.takeLeftValue(), readModifyWrite.takeOldValue(), readModifyWrite.takeNewValue());</span>
<span class="line-modified">229             newReadModifyWrite-&gt;setNewValueExpression(readModifyWrite.takeNewValueExpression());</span>
<span class="line-modified">230             newReadModifyWrite-&gt;setResultExpression(readModifyWrite.takeResultExpression());</span>
<span class="line-modified">231             newReadModifyWrite-&gt;setType(type.copyRef());</span>
<span class="line-modified">232             newReadModifyWrite-&gt;setTypeAnnotation(AST::TypeAnnotation(readModifyWrite.typeAnnotation()));</span>
<span class="line-modified">233 </span>
<span class="line-modified">234             expressions.append(WTFMove(newReadModifyWrite));</span>










































235         }
236 
<span class="line-modified">237         auto* comma = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWrite, codeLocation, WTFMove(expressions));</span>
<span class="line-modified">238         comma-&gt;setType(WTFMove(type));</span>
<span class="line-modified">239         comma-&gt;setTypeAnnotation(AST::RightValue());</span>












240     }
241 
<span class="line-modified">242     void visit(AST::FunctionDefinition&amp; functionDefinition) override</span>
<span class="line-modified">243     {</span>
<span class="line-modified">244         RELEASE_ASSERT(m_variables.isEmpty());</span>





















245 
<span class="line-modified">246         checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));</span>
<span class="line-modified">247         checkErrorAndVisit(functionDefinition.block());</span>


248 
<span class="line-modified">249         if (!m_variables.isEmpty()) {</span>
<span class="line-added">250             functionDefinition.block().statements().insert(0,</span>
<span class="line-added">251                 makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.block().codeLocation(), WTFMove(m_variables)));</span>
252         }









































































253     }




254 

255 private:
<span class="line-modified">256     AST::VariableDeclarations m_variables;</span>




257 };
258 






















































259 void resolveProperties(Program&amp; program)
260 {
<span class="line-modified">261     // The goal of this phase is two allow two things:</span>
<span class="line-added">262     // 1. For property access expressions, metal codegen should be allowed to evaluate</span>
<span class="line-added">263     // the base, and if it&#39;s an index expression, the index, as many times as needed.</span>
<span class="line-added">264     // So this patch ensures that if Metal evaluates such things, effects aren&#39;t performed</span>
<span class="line-added">265     // more than once.</span>
<span class="line-added">266     //</span>
<span class="line-added">267     // 2. For ReadModifyWrite expressions, metal codegen should be able to evaluate the</span>
<span class="line-added">268     // leftValueExpression as many times as it&#39;d like without performing the effects of</span>
<span class="line-added">269     // leftValueExpression more than once.</span>
<span class="line-added">270     //</span>
<span class="line-added">271     // We do these things because it&#39;s convenient for metal codegen to be able to rely on</span>
<span class="line-added">272     // this with the way it structures the generated code.</span>
<span class="line-added">273     PropertyResolver resolver;</span>
<span class="line-added">274     for (auto&amp; function : program.functionDefinitions())</span>
<span class="line-added">275         resolver.visit(function);</span>
276 }
277 
278 } // namespace WHLSL
279 
280 } // namespace WebCore
281 
282 #endif // ENABLE(WEBGPU)
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLProgram.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLPruneUnreachableStandardLibraryFunctions.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
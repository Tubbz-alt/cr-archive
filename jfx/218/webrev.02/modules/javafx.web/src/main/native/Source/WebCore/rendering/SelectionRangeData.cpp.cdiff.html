<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RootInlineBox.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 47,12 ***</span>
  
  struct SelectionData {
      using RendererMap = HashMap&lt;RenderObject*, std::unique_ptr&lt;RenderSelectionInfo&gt;&gt;;
      using RenderBlockMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockSelectionInfo&gt;&gt;;
  
<span class="line-modified">!     Optional&lt;unsigned&gt; startPosition;</span>
<span class="line-modified">!     Optional&lt;unsigned&gt; endPosition;</span>
      RendererMap renderers;
      RenderBlockMap blocks;
  };
  
  class SelectionIterator {
<span class="line-new-header">--- 47,12 ---</span>
  
  struct SelectionData {
      using RendererMap = HashMap&lt;RenderObject*, std::unique_ptr&lt;RenderSelectionInfo&gt;&gt;;
      using RenderBlockMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockSelectionInfo&gt;&gt;;
  
<span class="line-modified">!     Optional&lt;unsigned&gt; startOffset;</span>
<span class="line-modified">!     Optional&lt;unsigned&gt; endOffset;</span>
      RendererMap renderers;
      RenderBlockMap blocks;
  };
  
  class SelectionIterator {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,11 ***</span>
      Vector&lt;RenderMultiColumnSpannerPlaceholder*&gt; m_spannerStack;
  };
  
  } // anonymous namespace
  
<span class="line-modified">! static RenderObject* rendererAfterPosition(const RenderObject&amp; renderer, unsigned offset)</span>
  {
      auto* child = renderer.childAt(offset);
      return child ? child : renderer.nextInPreOrderAfterChildren();
  }
  
<span class="line-new-header">--- 96,11 ---</span>
      Vector&lt;RenderMultiColumnSpannerPlaceholder*&gt; m_spannerStack;
  };
  
  } // anonymous namespace
  
<span class="line-modified">! static RenderObject* rendererAfterOffset(const RenderObject&amp; renderer, unsigned offset)</span>
  {
      auto* child = renderer.childAt(offset);
      return child ? child : renderer.nextInPreOrderAfterChildren();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,18 ***</span>
      return is&lt;RenderView&gt;(containingBlock) ? nullptr : containingBlock;
  }
  
  static SelectionData collect(const SelectionRangeData::Context&amp; selection, bool repaintDifference)
  {
<span class="line-modified">!     SelectionData oldSelectionData { selection.startPosition(), selection.endPosition(), { }, { } };</span>
      // Blocks contain selected objects and fill gaps between them, either on the left, right, or in between lines and blocks.
      // In order to get the repaint rect right, we have to examine left, middle, and right rects individually, since otherwise
      // the union of those rects might remain the same even when changes have occurred.
      auto* start = selection.start();
      RenderObject* stop = nullptr;
      if (selection.end())
<span class="line-modified">!         stop = rendererAfterPosition(*selection.end(), selection.endPosition().value());</span>
      SelectionIterator selectionIterator(start);
      while (start &amp;&amp; start != stop) {
          if (isValidRendererForSelection(*start, selection)) {
              // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
              oldSelectionData.renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, true));
<span class="line-new-header">--- 117,18 ---</span>
      return is&lt;RenderView&gt;(containingBlock) ? nullptr : containingBlock;
  }
  
  static SelectionData collect(const SelectionRangeData::Context&amp; selection, bool repaintDifference)
  {
<span class="line-modified">!     SelectionData oldSelectionData { selection.startOffset(), selection.endOffset(), { }, { } };</span>
      // Blocks contain selected objects and fill gaps between them, either on the left, right, or in between lines and blocks.
      // In order to get the repaint rect right, we have to examine left, middle, and right rects individually, since otherwise
      // the union of those rects might remain the same even when changes have occurred.
      auto* start = selection.start();
      RenderObject* stop = nullptr;
      if (selection.end())
<span class="line-modified">!         stop = rendererAfterOffset(*selection.end(), selection.endOffset().value());</span>
      SelectionIterator selectionIterator(start);
      while (start &amp;&amp; start != stop) {
          if (isValidRendererForSelection(*start, selection)) {
              // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
              oldSelectionData.renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, true));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,14 ***</span>
      , m_selectionRectGatherer(view)
  #endif
  {
  }
  
  void SelectionRangeData::set(const Context&amp; selection, RepaintMode blockRepaintMode)
  {
<span class="line-removed">-     // Make sure both our start and end objects are defined.</span>
<span class="line-removed">-     // Check www.msnbc.com and try clicking around to find the case where this happened.</span>
      if ((selection.start() &amp;&amp; !selection.end()) || (selection.end() &amp;&amp; !selection.start()))
          return;
      // Just return if the selection hasn&#39;t changed.
      auto isCaret = m_renderView.frame().selection().isCaret();
      if (selection == m_selectionContext &amp;&amp; m_selectionWasCaret == isCaret)
<span class="line-new-header">--- 152,51 ---</span>
      , m_selectionRectGatherer(view)
  #endif
  {
  }
  
<span class="line-added">+ void SelectionRangeData::setContext(const Context&amp; context)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(context.start() &amp;&amp; context.end());</span>
<span class="line-added">+     m_selectionContext = context;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RenderObject::SelectionState SelectionRangeData::selectionStateForRenderer(RenderObject&amp; renderer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: we shouldln&#39;t have to check that a renderer is a descendant of the render node</span>
<span class="line-added">+     // from the range. This is likely because we aren&#39;t using VisiblePositions yet.</span>
<span class="line-added">+     // Planned fix in a followup: &lt;rdar://problem/58095923&gt;</span>
<span class="line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=205529</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (&amp;renderer == m_selectionContext.start()) {</span>
<span class="line-added">+         if (m_selectionContext.start() &amp;&amp; m_selectionContext.end() &amp;&amp; m_selectionContext.start() == m_selectionContext.end())</span>
<span class="line-added">+             return RenderObject::SelectionBoth;</span>
<span class="line-added">+         if (m_selectionContext.start())</span>
<span class="line-added">+             return RenderObject::SelectionStart;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (&amp;renderer == m_selectionContext.end())</span>
<span class="line-added">+         return RenderObject::SelectionEnd;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RenderObject* selectionEnd = nullptr;</span>
<span class="line-added">+     auto* selectionDataEnd = m_selectionContext.end();</span>
<span class="line-added">+     if (selectionDataEnd)</span>
<span class="line-added">+         selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());</span>
<span class="line-added">+     SelectionIterator selectionIterator(m_selectionContext.start());</span>
<span class="line-added">+     for (auto* currentRenderer = m_selectionContext.start(); currentRenderer &amp;&amp; currentRenderer != m_selectionContext.end(); currentRenderer = selectionIterator.next()) {</span>
<span class="line-added">+         if (currentRenderer == m_selectionContext.start() || currentRenderer == m_selectionContext.end())</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         if (!currentRenderer-&gt;canBeSelectionLeaf())</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         if (&amp;renderer == currentRenderer)</span>
<span class="line-added">+             return RenderObject::SelectionInside;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return RenderObject::SelectionNone;</span>
<span class="line-added">+ </span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void SelectionRangeData::set(const Context&amp; selection, RepaintMode blockRepaintMode)
  {
      if ((selection.start() &amp;&amp; !selection.end()) || (selection.end() &amp;&amp; !selection.start()))
          return;
      // Just return if the selection hasn&#39;t changed.
      auto isCaret = m_renderView.frame().selection().isCaret();
      if (selection == m_selectionContext &amp;&amp; m_selectionWasCaret == isCaret)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,11 ***</span>
  void SelectionRangeData::repaint() const
  {
      HashSet&lt;RenderBlock*&gt; processedBlocks;
      RenderObject* end = nullptr;
      if (m_selectionContext.end())
<span class="line-modified">!         end = rendererAfterPosition(*m_selectionContext.end(), m_selectionContext.endPosition().value());</span>
      SelectionIterator selectionIterator(m_selectionContext.start());
      for (auto* renderer = selectionIterator.current(); renderer &amp;&amp; renderer != end; renderer = selectionIterator.next()) {
          if (!renderer-&gt;canBeSelectionLeaf() &amp;&amp; renderer != m_selectionContext.start() &amp;&amp; renderer != m_selectionContext.end())
              continue;
          if (renderer-&gt;selectionState() == RenderObject::SelectionNone)
<span class="line-new-header">--- 219,11 ---</span>
  void SelectionRangeData::repaint() const
  {
      HashSet&lt;RenderBlock*&gt; processedBlocks;
      RenderObject* end = nullptr;
      if (m_selectionContext.end())
<span class="line-modified">!         end = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());</span>
      SelectionIterator selectionIterator(m_selectionContext.start());
      for (auto* renderer = selectionIterator.current(); renderer &amp;&amp; renderer != end; renderer = selectionIterator.next()) {
          if (!renderer-&gt;canBeSelectionLeaf() &amp;&amp; renderer != m_selectionContext.start() &amp;&amp; renderer != m_selectionContext.end())
              continue;
          if (renderer-&gt;selectionState() == RenderObject::SelectionNone)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,11 ***</span>
  {
      SelectionData::RendererMap renderers;
      auto* start = m_selectionContext.start();
      RenderObject* stop = nullptr;
      if (m_selectionContext.end())
<span class="line-modified">!         stop = rendererAfterPosition(*m_selectionContext.end(), m_selectionContext.endPosition().value());</span>
      SelectionIterator selectionIterator(start);
      while (start &amp;&amp; start != stop) {
          if ((start-&gt;canBeSelectionLeaf() || start == m_selectionContext.start() || start == m_selectionContext.end())
              &amp;&amp; start-&gt;selectionState() != RenderObject::SelectionNone) {
              // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
<span class="line-new-header">--- 242,11 ---</span>
  {
      SelectionData::RendererMap renderers;
      auto* start = m_selectionContext.start();
      RenderObject* stop = nullptr;
      if (m_selectionContext.end())
<span class="line-modified">!         stop = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());</span>
      SelectionIterator selectionIterator(start);
      while (start &amp;&amp; start != stop) {
          if ((start-&gt;canBeSelectionLeaf() || start == m_selectionContext.start() || start == m_selectionContext.end())
              &amp;&amp; start-&gt;selectionState() != RenderObject::SelectionNone) {
              // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,11 ***</span>
      }
  
      RenderObject* selectionEnd = nullptr;
      auto* selectionDataEnd = m_selectionContext.end();
      if (selectionDataEnd)
<span class="line-modified">!         selectionEnd = rendererAfterPosition(*selectionDataEnd, m_selectionContext.endPosition().value());</span>
      SelectionIterator selectionIterator(selectionStart);
      for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
          if (currentRenderer == selectionStart || currentRenderer == m_selectionContext.end())
              continue;
          if (!currentRenderer-&gt;canBeSelectionLeaf())
<span class="line-new-header">--- 296,11 ---</span>
      }
  
      RenderObject* selectionEnd = nullptr;
      auto* selectionDataEnd = m_selectionContext.end();
      if (selectionDataEnd)
<span class="line-modified">!         selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());</span>
      SelectionIterator selectionIterator(selectionStart);
      for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
          if (currentRenderer == selectionStart || currentRenderer == m_selectionContext.end())
              continue;
          if (!currentRenderer-&gt;canBeSelectionLeaf())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,12 ***</span>
      for (auto&amp; selectedRendererInfo : oldSelectionData.renderers) {
          auto* renderer = selectedRendererInfo.key;
          auto* newInfo = newSelectedRenderers.get(renderer);
          auto* oldInfo = selectedRendererInfo.value.get();
          if (!newInfo || oldInfo-&gt;rect() != newInfo-&gt;rect() || oldInfo-&gt;state() != newInfo-&gt;state()
<span class="line-modified">!             || (m_selectionContext.start() == renderer &amp;&amp; oldSelectionData.startPosition != m_selectionContext.startPosition())</span>
<span class="line-modified">!             || (m_selectionContext.end() == renderer &amp;&amp; oldSelectionData.endPosition != m_selectionContext.endPosition())) {</span>
              oldInfo-&gt;repaint();
              if (newInfo) {
                  newInfo-&gt;repaint();
                  newSelectedRenderers.remove(renderer);
              }
<span class="line-new-header">--- 347,12 ---</span>
      for (auto&amp; selectedRendererInfo : oldSelectionData.renderers) {
          auto* renderer = selectedRendererInfo.key;
          auto* newInfo = newSelectedRenderers.get(renderer);
          auto* oldInfo = selectedRendererInfo.value.get();
          if (!newInfo || oldInfo-&gt;rect() != newInfo-&gt;rect() || oldInfo-&gt;state() != newInfo-&gt;state()
<span class="line-modified">!             || (m_selectionContext.start() == renderer &amp;&amp; oldSelectionData.startOffset != m_selectionContext.startOffset())</span>
<span class="line-modified">!             || (m_selectionContext.end() == renderer &amp;&amp; oldSelectionData.endOffset != m_selectionContext.endOffset())) {</span>
              oldInfo-&gt;repaint();
              if (newInfo) {
                  newInfo-&gt;repaint();
                  newSelectedRenderers.remove(renderer);
              }
</pre>
<center><a href="RootInlineBox.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
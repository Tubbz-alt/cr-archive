<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/InsertListCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameSelection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InsertListCommand.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/InsertListCommand.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 
 38 namespace WebCore {
 39 
 40 using namespace HTMLNames;
 41 
 42 static Node* enclosingListChild(Node* node, Node* listNode)
 43 {
 44     Node* listChild = enclosingListChild(node);
 45     while (listChild &amp;&amp; enclosingList(listChild) != listNode)
 46         listChild = enclosingListChild(listChild-&gt;parentNode());
 47     return listChild;
 48 }
 49 
 50 RefPtr&lt;HTMLElement&gt; InsertListCommand::insertList(Document&amp; document, Type type)
 51 {
 52     RefPtr&lt;InsertListCommand&gt; insertCommand = create(document, type);
 53     insertCommand-&gt;apply();
 54     return insertCommand-&gt;m_listElement;
 55 }
 56 
<span class="line-modified"> 57 HTMLElement&amp; InsertListCommand::fixOrphanedListChild(Node&amp; node)</span>
 58 {
 59     auto listElement = HTMLUListElement::create(document());
 60     insertNodeBefore(listElement.copyRef(), node);



 61     removeNode(node);
 62     appendNode(node, listElement.copyRef());
 63     m_listElement = WTFMove(listElement);
<span class="line-modified"> 64     return *m_listElement;</span>
 65 }
 66 
 67 Ref&lt;HTMLElement&gt; InsertListCommand::mergeWithNeighboringLists(HTMLElement&amp; list)
 68 {
 69     Ref&lt;HTMLElement&gt; protectedList = list;
 70     Element* previousList = list.previousElementSibling();
 71     if (canMergeLists(previousList, &amp;list))
 72         mergeIdenticalElements(*previousList, list);
 73 
 74     Element* sibling = ElementTraversal::nextSibling(list);
 75     if (!is&lt;HTMLElement&gt;(sibling))
 76         return protectedList;
 77 
 78     Ref&lt;HTMLElement&gt; nextList = downcast&lt;HTMLElement&gt;(*sibling);
 79     if (canMergeLists(&amp;list, nextList.ptr())) {
 80         mergeIdenticalElements(list, nextList);
 81         return nextList;
 82     }
 83     return protectedList;
 84 }
</pre>
<hr />
<pre>
189 
190     doApplyForSingleParagraph(false, listTag, endingSelection().firstRange().get());
191 }
192 
193 EditAction InsertListCommand::editingAction() const
194 {
195     return m_type == Type::OrderedList ? EditAction::InsertOrderedList : EditAction::InsertUnorderedList;
196 }
197 
198 void InsertListCommand::doApplyForSingleParagraph(bool forceCreateList, const HTMLQualifiedName&amp; listTag, Range* currentSelection)
199 {
200     // FIXME: This will produce unexpected results for a selection that starts just before a
201     // table and ends inside the first cell, selectionForParagraphIteration should probably
202     // be renamed and deployed inside setEndingSelection().
203     Node* selectionNode = endingSelection().start().deprecatedNode();
204     Node* listChildNode = enclosingListChild(selectionNode);
205     bool switchListType = false;
206     if (listChildNode) {
207         // Remove the list chlild.
208         RefPtr&lt;HTMLElement&gt; listNode = enclosingList(listChildNode);
<span class="line-modified">209         if (!listNode)</span>
<span class="line-modified">210             listNode = mergeWithNeighboringLists(fixOrphanedListChild(*listChildNode));</span>





211 
212         if (!listNode-&gt;hasTagName(listTag)) {
213             // listChildNode will be removed from the list and a list of type m_type will be created.
214             switchListType = true;
215         }
216 
217         // If the list is of the desired type, and we are not removing the list, then exit early.
218         if (!switchListType &amp;&amp; forceCreateList)
219             return;
220 
221         // If the entire list is selected, then convert the whole list.
222         if (switchListType &amp;&amp; isNodeVisiblyContainedWithin(*listNode, *currentSelection)) {
223             bool rangeStartIsInList = visiblePositionBeforeNode(*listNode) == currentSelection-&gt;startPosition();
224             bool rangeEndIsInList = visiblePositionAfterNode(*listNode) == currentSelection-&gt;endPosition();
225 
226             RefPtr&lt;HTMLElement&gt; newList = createHTMLElement(document(), listTag);
227             insertNodeBefore(*newList, *listNode);


228 
229             auto* firstChildInList = enclosingListChild(VisiblePosition(firstPositionInNode(listNode.get())).deepEquivalent().deprecatedNode(), listNode.get());
230             Node* outerBlock = firstChildInList &amp;&amp; isBlockFlowElement(*firstChildInList) ? firstChildInList : listNode.get();
231 
232             moveParagraphWithClones(firstPositionInNode(listNode.get()), lastPositionInNode(listNode.get()), newList.get(), outerBlock);
233 
234             // Manually remove listNode because moveParagraphWithClones sometimes leaves it behind in the document.
235             // See the bug 33668 and editing/execCommand/insert-list-orphaned-item-with-nested-lists.html.
236             // FIXME: This might be a bug in moveParagraphWithClones or deleteSelection.
237             if (listNode &amp;&amp; listNode-&gt;isConnected())
238                 removeNode(*listNode);
239 
240             newList = mergeWithNeighboringLists(*newList);
241 
242             // Restore the start and the end of current selection if they started inside listNode
243             // because moveParagraphWithClones could have removed them.
244             if (rangeStartIsInList &amp;&amp; newList)
245                 currentSelection-&gt;setStart(*newList, 0);
246             if (rangeEndIsInList &amp;&amp; newList)
247                 currentSelection-&gt;setEnd(*newList, lastOffsetInNode(newList.get()));
</pre>
<hr />
<pre>
321     if (!listNode)
322         return 0;
323 
324     Node* previousCell = enclosingTableCell(pos.deepEquivalent());
325     Node* currentCell = enclosingTableCell(adjacentPos.deepEquivalent());
326 
327     if (!listNode-&gt;hasTagName(listTag)
328         || listNode-&gt;contains(pos.deepEquivalent().deprecatedNode())
329         || previousCell != currentCell
330         || enclosingList(listNode) != enclosingList(pos.deepEquivalent().deprecatedNode()))
331         return 0;
332 
333     return listNode;
334 }
335 
336 RefPtr&lt;HTMLElement&gt; InsertListCommand::listifyParagraph(const VisiblePosition&amp; originalStart, const QualifiedName&amp; listTag)
337 {
338     VisiblePosition start = startOfParagraph(originalStart, CanSkipOverEditingBoundary);
339     VisiblePosition end = endOfParagraph(start, CanSkipOverEditingBoundary);
340 
<span class="line-modified">341     if (start.isNull() || end.isNull())</span>
342         return 0;
343 
344     // Check for adjoining lists.
345     auto listItemElement = HTMLLIElement::create(document());
346     auto placeholder = HTMLBRElement::create(document());
347     appendNode(placeholder.copyRef(), listItemElement.copyRef());
348 
349     // Place list item into adjoining lists.
350     Element* previousList = adjacentEnclosingList(start.deepEquivalent(), start.previous(CannotCrossEditingBoundary), listTag);
351     Element* nextList = adjacentEnclosingList(start.deepEquivalent(), end.next(CannotCrossEditingBoundary), listTag);
352     RefPtr&lt;HTMLElement&gt; listElement;
353     if (previousList)
354         appendNode(WTFMove(listItemElement), *previousList);
355     else if (nextList)
356         insertNodeAt(WTFMove(listItemElement), positionBeforeNode(nextList));
357     else {
358         // Create the list.
359         listElement = createHTMLElement(document(), listTag);
360         appendNode(WTFMove(listItemElement), *listElement);
361 
</pre>
</td>
<td>
<hr />
<pre>
 37 
 38 namespace WebCore {
 39 
 40 using namespace HTMLNames;
 41 
 42 static Node* enclosingListChild(Node* node, Node* listNode)
 43 {
 44     Node* listChild = enclosingListChild(node);
 45     while (listChild &amp;&amp; enclosingList(listChild) != listNode)
 46         listChild = enclosingListChild(listChild-&gt;parentNode());
 47     return listChild;
 48 }
 49 
 50 RefPtr&lt;HTMLElement&gt; InsertListCommand::insertList(Document&amp; document, Type type)
 51 {
 52     RefPtr&lt;InsertListCommand&gt; insertCommand = create(document, type);
 53     insertCommand-&gt;apply();
 54     return insertCommand-&gt;m_listElement;
 55 }
 56 
<span class="line-modified"> 57 HTMLElement* InsertListCommand::fixOrphanedListChild(Node&amp; node)</span>
 58 {
 59     auto listElement = HTMLUListElement::create(document());
 60     insertNodeBefore(listElement.copyRef(), node);
<span class="line-added"> 61     if (!listElement-&gt;hasEditableStyle())</span>
<span class="line-added"> 62         return nullptr;</span>
<span class="line-added"> 63 </span>
 64     removeNode(node);
 65     appendNode(node, listElement.copyRef());
 66     m_listElement = WTFMove(listElement);
<span class="line-modified"> 67     return m_listElement.get();</span>
 68 }
 69 
 70 Ref&lt;HTMLElement&gt; InsertListCommand::mergeWithNeighboringLists(HTMLElement&amp; list)
 71 {
 72     Ref&lt;HTMLElement&gt; protectedList = list;
 73     Element* previousList = list.previousElementSibling();
 74     if (canMergeLists(previousList, &amp;list))
 75         mergeIdenticalElements(*previousList, list);
 76 
 77     Element* sibling = ElementTraversal::nextSibling(list);
 78     if (!is&lt;HTMLElement&gt;(sibling))
 79         return protectedList;
 80 
 81     Ref&lt;HTMLElement&gt; nextList = downcast&lt;HTMLElement&gt;(*sibling);
 82     if (canMergeLists(&amp;list, nextList.ptr())) {
 83         mergeIdenticalElements(list, nextList);
 84         return nextList;
 85     }
 86     return protectedList;
 87 }
</pre>
<hr />
<pre>
192 
193     doApplyForSingleParagraph(false, listTag, endingSelection().firstRange().get());
194 }
195 
196 EditAction InsertListCommand::editingAction() const
197 {
198     return m_type == Type::OrderedList ? EditAction::InsertOrderedList : EditAction::InsertUnorderedList;
199 }
200 
201 void InsertListCommand::doApplyForSingleParagraph(bool forceCreateList, const HTMLQualifiedName&amp; listTag, Range* currentSelection)
202 {
203     // FIXME: This will produce unexpected results for a selection that starts just before a
204     // table and ends inside the first cell, selectionForParagraphIteration should probably
205     // be renamed and deployed inside setEndingSelection().
206     Node* selectionNode = endingSelection().start().deprecatedNode();
207     Node* listChildNode = enclosingListChild(selectionNode);
208     bool switchListType = false;
209     if (listChildNode) {
210         // Remove the list chlild.
211         RefPtr&lt;HTMLElement&gt; listNode = enclosingList(listChildNode);
<span class="line-modified">212         if (!listNode) {</span>
<span class="line-modified">213             RefPtr&lt;HTMLElement&gt; listElement = fixOrphanedListChild(*listChildNode);</span>
<span class="line-added">214             if (!listElement)</span>
<span class="line-added">215                 return;</span>
<span class="line-added">216 </span>
<span class="line-added">217             listNode = mergeWithNeighboringLists(*listElement);</span>
<span class="line-added">218         }</span>
219 
220         if (!listNode-&gt;hasTagName(listTag)) {
221             // listChildNode will be removed from the list and a list of type m_type will be created.
222             switchListType = true;
223         }
224 
225         // If the list is of the desired type, and we are not removing the list, then exit early.
226         if (!switchListType &amp;&amp; forceCreateList)
227             return;
228 
229         // If the entire list is selected, then convert the whole list.
230         if (switchListType &amp;&amp; isNodeVisiblyContainedWithin(*listNode, *currentSelection)) {
231             bool rangeStartIsInList = visiblePositionBeforeNode(*listNode) == currentSelection-&gt;startPosition();
232             bool rangeEndIsInList = visiblePositionAfterNode(*listNode) == currentSelection-&gt;endPosition();
233 
234             RefPtr&lt;HTMLElement&gt; newList = createHTMLElement(document(), listTag);
235             insertNodeBefore(*newList, *listNode);
<span class="line-added">236             if (!newList-&gt;hasEditableStyle())</span>
<span class="line-added">237                 return;</span>
238 
239             auto* firstChildInList = enclosingListChild(VisiblePosition(firstPositionInNode(listNode.get())).deepEquivalent().deprecatedNode(), listNode.get());
240             Node* outerBlock = firstChildInList &amp;&amp; isBlockFlowElement(*firstChildInList) ? firstChildInList : listNode.get();
241 
242             moveParagraphWithClones(firstPositionInNode(listNode.get()), lastPositionInNode(listNode.get()), newList.get(), outerBlock);
243 
244             // Manually remove listNode because moveParagraphWithClones sometimes leaves it behind in the document.
245             // See the bug 33668 and editing/execCommand/insert-list-orphaned-item-with-nested-lists.html.
246             // FIXME: This might be a bug in moveParagraphWithClones or deleteSelection.
247             if (listNode &amp;&amp; listNode-&gt;isConnected())
248                 removeNode(*listNode);
249 
250             newList = mergeWithNeighboringLists(*newList);
251 
252             // Restore the start and the end of current selection if they started inside listNode
253             // because moveParagraphWithClones could have removed them.
254             if (rangeStartIsInList &amp;&amp; newList)
255                 currentSelection-&gt;setStart(*newList, 0);
256             if (rangeEndIsInList &amp;&amp; newList)
257                 currentSelection-&gt;setEnd(*newList, lastOffsetInNode(newList.get()));
</pre>
<hr />
<pre>
331     if (!listNode)
332         return 0;
333 
334     Node* previousCell = enclosingTableCell(pos.deepEquivalent());
335     Node* currentCell = enclosingTableCell(adjacentPos.deepEquivalent());
336 
337     if (!listNode-&gt;hasTagName(listTag)
338         || listNode-&gt;contains(pos.deepEquivalent().deprecatedNode())
339         || previousCell != currentCell
340         || enclosingList(listNode) != enclosingList(pos.deepEquivalent().deprecatedNode()))
341         return 0;
342 
343     return listNode;
344 }
345 
346 RefPtr&lt;HTMLElement&gt; InsertListCommand::listifyParagraph(const VisiblePosition&amp; originalStart, const QualifiedName&amp; listTag)
347 {
348     VisiblePosition start = startOfParagraph(originalStart, CanSkipOverEditingBoundary);
349     VisiblePosition end = endOfParagraph(start, CanSkipOverEditingBoundary);
350 
<span class="line-modified">351     if (start.isNull() || end.isNull() || !start.deepEquivalent().containerNode()-&gt;hasEditableStyle() || !end.deepEquivalent().containerNode()-&gt;hasEditableStyle())</span>
352         return 0;
353 
354     // Check for adjoining lists.
355     auto listItemElement = HTMLLIElement::create(document());
356     auto placeholder = HTMLBRElement::create(document());
357     appendNode(placeholder.copyRef(), listItemElement.copyRef());
358 
359     // Place list item into adjoining lists.
360     Element* previousList = adjacentEnclosingList(start.deepEquivalent(), start.previous(CannotCrossEditingBoundary), listTag);
361     Element* nextList = adjacentEnclosingList(start.deepEquivalent(), end.next(CannotCrossEditingBoundary), listTag);
362     RefPtr&lt;HTMLElement&gt; listElement;
363     if (previousList)
364         appendNode(WTFMove(listItemElement), *previousList);
365     else if (nextList)
366         insertNodeAt(WTFMove(listItemElement), positionBeforeNode(nextList));
367     else {
368         // Create the list.
369         listElement = createHTMLElement(document(), listTag);
370         appendNode(WTFMove(listItemElement), *listElement);
371 
</pre>
</td>
</tr>
</table>
<center><a href="FrameSelection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InsertListCommand.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderView.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  77 
  78 void RootInlineBox::detachEllipsisBox()
  79 {
  80     if (hasEllipsisBox()) {
  81         auto box = gEllipsisBoxMap-&gt;take(this);
  82         box-&gt;setParent(nullptr);
  83         setHasEllipsisBox(false);
  84     }
  85 }
  86 
  87 void RootInlineBox::clearTruncation()
  88 {
  89     if (hasEllipsisBox()) {
  90         detachEllipsisBox();
  91         InlineFlowBox::clearTruncation();
  92     }
  93 }
  94 
  95 bool RootInlineBox::isHyphenated() const
  96 {
<span class="line-modified">  97     for (InlineBox* box = firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
  98         if (is&lt;InlineTextBox&gt;(*box) &amp;&amp; downcast&lt;InlineTextBox&gt;(*box).hasHyphen())
  99             return true;
 100     }
 101     return false;
 102 }
 103 
 104 int RootInlineBox::baselinePosition(FontBaseline baselineType) const
 105 {
 106     return renderer().baselinePosition(baselineType, isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
 107 }
 108 
 109 LayoutUnit RootInlineBox::lineHeight() const
 110 {
 111     return renderer().lineHeight(isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
 112 }
 113 
 114 bool RootInlineBox::lineCanAccommodateEllipsis(bool ltr, int blockEdge, int lineBoxEdge, int ellipsisWidth)
 115 {
 116     // First sanity-check the unoverflowed width of the whole line to see if there is sufficient room.
 117     int delta = ltr ? lineBoxEdge - blockEdge : blockEdge - lineBoxEdge;
</pre>
<hr />
<pre>
 435     if (leftGap) {
 436         result.uniteLeft(blockFlow().logicalLeftSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, &amp;firstBox-&gt;parent()-&gt;renderer(), LayoutUnit(firstBox-&gt;logicalLeft()),
 437             selTop, selHeight, cache, paintInfo));
 438     }
 439     if (rightGap) {
 440         result.uniteRight(blockFlow().logicalRightSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, &amp;lastBox-&gt;parent()-&gt;renderer(), LayoutUnit(lastBox-&gt;logicalRight()),
 441             selTop, selHeight, cache, paintInfo));
 442     }
 443 
 444     // When dealing with bidi text, a non-contiguous selection region is possible.
 445     // e.g. The logical text aaaAAAbbb (capitals denote RTL text and non-capitals LTR) is layed out
 446     // visually as 3 text runs |aaa|bbb|AAA| if we select 4 characters from the start of the text the
 447     // selection will look like (underline denotes selection):
 448     // |aaa|bbb|AAA|
 449     //  ___       _
 450     // We can see that the |bbb| run is not part of the selection while the runs around it are.
 451     if (firstBox &amp;&amp; firstBox != lastBox) {
 452         // Now fill in any gaps on the line that occurred between two selected elements.
 453         LayoutUnit lastLogicalLeft { firstBox-&gt;logicalRight() };
 454         bool isPreviousBoxSelected = firstBox-&gt;selectionState() != RenderObject::SelectionNone;
<span class="line-modified"> 455         for (InlineBox* box = firstBox-&gt;nextLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
 456             if (box-&gt;selectionState() != RenderObject::SelectionNone) {
 457                 LayoutRect logicalRect { lastLogicalLeft, selTop, LayoutUnit(box-&gt;logicalLeft() - lastLogicalLeft), selHeight };
 458                 logicalRect.move(renderer().isHorizontalWritingMode() ? offsetFromRootBlock : LayoutSize(offsetFromRootBlock.height(), offsetFromRootBlock.width()));
 459                 LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
 460                 if (isPreviousBoxSelected &amp;&amp; gapRect.width() &gt; 0 &amp;&amp; gapRect.height() &gt; 0) {
 461                     if (paintInfo &amp;&amp; box-&gt;parent()-&gt;renderer().style().visibility() == Visibility::Visible)
 462                         paintInfo-&gt;context().fillRect(gapRect, box-&gt;parent()-&gt;renderer().selectionBackgroundColor());
 463                     // VisibleSelection may be non-contiguous, see comment above.
 464                     result.uniteCenter(gapRect);
 465                 }
 466                 lastLogicalLeft = box-&gt;logicalRight();
 467             }
 468             if (box == lastBox)
 469                 break;
 470             isPreviousBoxSelected = box-&gt;selectionState() != RenderObject::SelectionNone;
 471         }
 472     }
 473 
 474     return result;
 475 }
</pre>
<hr />
<pre>
 514         break;
 515     }
 516 
 517     float leftEdge = std::min&lt;float&gt;(0, rootLeft);
 518     float rightEdge = std::max&lt;float&gt;(blockFlow().logicalWidth(), rootRight);
 519 
 520     if (rightAligned) {
 521         left = std::max(left, leftEdge);
 522         left = std::min(left, rootRight - caretWidth);
 523     } else {
 524         left = std::min(left, rightEdge - caretWidthRightOfOffset);
 525         left = std::max(left, rootLeft);
 526     }
 527     return blockStyle.isHorizontalWritingMode() ? IntRect(left, top, caretWidth, height) : IntRect(top, left, height, caretWidth);
 528 }
 529 
 530 RenderObject::SelectionState RootInlineBox::selectionState()
 531 {
 532     // Walk over all of the selected boxes.
 533     RenderObject::SelectionState state = RenderObject::SelectionNone;
<span class="line-modified"> 534     for (InlineBox* box = firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
 535         RenderObject::SelectionState boxState = box-&gt;selectionState();
 536         if ((boxState == RenderObject::SelectionStart &amp;&amp; state == RenderObject::SelectionEnd) ||
 537             (boxState == RenderObject::SelectionEnd &amp;&amp; state == RenderObject::SelectionStart))
 538             state = RenderObject::SelectionBoth;
 539         else if (state == RenderObject::SelectionNone ||
 540                  ((boxState == RenderObject::SelectionStart || boxState == RenderObject::SelectionEnd) &amp;&amp;
 541                   (state == RenderObject::SelectionNone || state == RenderObject::SelectionInside)))
 542             state = boxState;
 543         else if (boxState == RenderObject::SelectionNone &amp;&amp; state == RenderObject::SelectionStart) {
 544             // We are past the end of the selection.
 545             state = RenderObject::SelectionBoth;
 546         }
 547         if (state == RenderObject::SelectionBoth)
 548             break;
 549     }
 550 
 551     return state;
 552 }
 553 
 554 InlineBox* RootInlineBox::firstSelectedBox()
 555 {
<span class="line-modified"> 556     for (auto* box = firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
 557         if (box-&gt;selectionState() != RenderObject::SelectionNone)
 558             return box;
 559     }
 560     return nullptr;
 561 }
 562 
 563 InlineBox* RootInlineBox::lastSelectedBox()
 564 {
<span class="line-modified"> 565     for (auto* box = lastLeafChild(); box; box = box-&gt;prevLeafChild()) {</span>
 566         if (box-&gt;selectionState() != RenderObject::SelectionNone)
 567             return box;
 568     }
 569     return nullptr;
 570 }
 571 
 572 LayoutUnit RootInlineBox::selectionTop() const
 573 {
 574     LayoutUnit selectionTop = m_lineTop;
 575 
 576     if (m_hasAnnotationsBefore)
 577         selectionTop -= !renderer().style().isFlippedLinesWritingMode() ? computeOverAnnotationAdjustment(m_lineTop) : computeUnderAnnotationAdjustment(m_lineTop);
 578 
 579     if (renderer().style().isFlippedLinesWritingMode())
 580         return selectionTop;
 581 
 582 #if !PLATFORM(IOS_FAMILY)
 583     // See rdar://problem/19692206 ... don&#39;t want to do this adjustment for iOS where overlap is ok and handled.
 584     if (renderer().isRubyBase()) {
 585         // The ruby base selection should avoid intruding into the ruby text. This is only the case if there is an actual ruby text above us.
</pre>
<hr />
<pre>
 749     return !blockFlow().style().isFlippedBlocksWritingMode() ? std::max(lineTop(), selectionTop()) : std::min(lineBottom(), selectionBottom());
 750 }
 751 
 752 RenderBlockFlow&amp; RootInlineBox::blockFlow() const
 753 {
 754     return downcast&lt;RenderBlockFlow&gt;(renderer());
 755 }
 756 
 757 static bool isEditableLeaf(InlineBox* leaf)
 758 {
 759     return leaf &amp;&amp; leaf-&gt;renderer().node() &amp;&amp; leaf-&gt;renderer().node()-&gt;hasEditableStyle();
 760 }
 761 
 762 InlineBox* RootInlineBox::closestLeafChildForPoint(const IntPoint&amp; pointInContents, bool onlyEditableLeaves)
 763 {
 764     return closestLeafChildForLogicalLeftPosition(blockFlow().isHorizontalWritingMode() ? pointInContents.x() : pointInContents.y(), onlyEditableLeaves);
 765 }
 766 
 767 InlineBox* RootInlineBox::closestLeafChildForLogicalLeftPosition(int leftPosition, bool onlyEditableLeaves)
 768 {
<span class="line-modified"> 769     InlineBox* firstLeaf = firstLeafChild();</span>
<span class="line-modified"> 770     InlineBox* lastLeaf = lastLeafChild();</span>
 771 
 772     if (firstLeaf != lastLeaf) {
 773         if (firstLeaf-&gt;isLineBreak())
<span class="line-modified"> 774             firstLeaf = firstLeaf-&gt;nextLeafChildIgnoringLineBreak();</span>
 775         else if (lastLeaf-&gt;isLineBreak())
<span class="line-modified"> 776             lastLeaf = lastLeaf-&gt;prevLeafChildIgnoringLineBreak();</span>
 777     }
 778 
 779     if (firstLeaf == lastLeaf &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
 780         return firstLeaf;
 781 
 782     // Avoid returning a list marker when possible.
 783     if (firstLeaf &amp;&amp; leftPosition &lt;= firstLeaf-&gt;logicalLeft() &amp;&amp; !firstLeaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
 784         // The leftPosition coordinate is less or equal to left edge of the firstLeaf.
 785         // Return it.
 786         return firstLeaf;
 787 
 788     if (lastLeaf &amp;&amp; leftPosition &gt;= lastLeaf-&gt;logicalRight() &amp;&amp; !lastLeaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(lastLeaf)))
 789         // The leftPosition coordinate is greater or equal to right edge of the lastLeaf.
 790         // Return it.
 791         return lastLeaf;
 792 
 793     InlineBox* closestLeaf = nullptr;
<span class="line-modified"> 794     for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf-&gt;nextLeafChildIgnoringLineBreak()) {</span>
 795         if (!leaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(leaf))) {
 796             closestLeaf = leaf;
 797             if (leftPosition &lt; leaf-&gt;logicalRight())
 798                 // The x coordinate is less than the right edge of the box.
 799                 // Return it.
 800                 return leaf;
 801         }
 802     }
 803 
 804     return closestLeaf ? closestLeaf : lastLeaf;
 805 }
 806 
 807 BidiStatus RootInlineBox::lineBreakBidiStatus() const
 808 {
 809     return { static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusEor), static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusLastStrong), static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusLast), m_lineBreakContext.copyRef() };
 810 }
 811 
 812 void RootInlineBox::setLineBreakInfo(RenderObject* object, unsigned breakPosition, const BidiStatus&amp; status)
 813 {
 814     m_lineBreakObj = makeWeakPtr(object);
 815     m_lineBreakPos = breakPosition;
 816     m_lineBreakBidiStatusEor = status.eor;
 817     m_lineBreakBidiStatusLastStrong = status.lastStrong;
 818     m_lineBreakBidiStatusLast = status.last;
 819     m_lineBreakContext = status.context;
 820 }
 821 
 822 EllipsisBox* RootInlineBox::ellipsisBox() const
 823 {
 824     if (!hasEllipsisBox())
 825         return nullptr;
 826     return gEllipsisBoxMap-&gt;get(this);
 827 }
 828 
 829 void RootInlineBox::removeLineBoxFromRenderObject()
 830 {
<span class="line-modified"> 831     blockFlow().complexLineLayout()-&gt;lineBoxes().removeLineBox(this);</span>


 832 }
 833 
 834 void RootInlineBox::extractLineBoxFromRenderObject()
 835 {
 836     blockFlow().complexLineLayout()-&gt;lineBoxes().extractLineBox(this);
 837 }
 838 
 839 void RootInlineBox::attachLineBoxToRenderObject()
 840 {
 841     blockFlow().complexLineLayout()-&gt;lineBoxes().attachLineBox(this);
 842 }
 843 
 844 LayoutRect RootInlineBox::paddedLayoutOverflowRect(LayoutUnit endPadding) const
 845 {
 846     LayoutRect lineLayoutOverflow = layoutOverflowRect(lineTop(), lineBottom());
 847     if (!endPadding)
 848         return lineLayoutOverflow;
 849 
 850     if (isHorizontal()) {
 851         if (isLeftToRightDirection())
</pre>
<hr />
<pre>
 865 static void setAscentAndDescent(int&amp; ascent, int&amp; descent, int newAscent, int newDescent, bool&amp; ascentDescentSet)
 866 {
 867     if (!ascentDescentSet) {
 868         ascentDescentSet = true;
 869         ascent = newAscent;
 870         descent = newDescent;
 871     } else {
 872         ascent = std::max(ascent, newAscent);
 873         descent = std::max(descent, newDescent);
 874     }
 875 }
 876 
 877 void RootInlineBox::ascentAndDescentForBox(InlineBox&amp; box, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, int&amp; ascent, int&amp; descent,
 878                                            bool&amp; affectsAscent, bool&amp; affectsDescent) const
 879 {
 880     bool ascentDescentSet = false;
 881 
 882     // Replaced boxes will return 0 for the line-height if line-box-contain says they are
 883     // not to be included.
 884     if (box.renderer().isReplaced()) {
<span class="line-modified"> 885         if (lineStyle().lineBoxContain() &amp; LineBoxContainReplaced) {</span>
 886             ascent = box.baselinePosition(baselineType());
 887             descent = box.lineHeight() - ascent;
 888 
 889             // Replaced elements always affect both the ascent and descent.
 890             affectsAscent = true;
 891             affectsDescent = true;
 892         }
 893         return;
 894     }
 895 
 896     Vector&lt;const Font*&gt;* usedFonts = nullptr;
 897     GlyphOverflow* glyphOverflow = nullptr;
 898     if (is&lt;InlineTextBox&gt;(box)) {
 899         GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.find(&amp;downcast&lt;InlineTextBox&gt;(box));
 900         usedFonts = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.first;
 901         glyphOverflow = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.second;
 902     }
 903 
 904     bool includeLeading = includeLeadingForBox(box);
 905     bool includeFont = includeFontForBox(box);
</pre>
<hr />
<pre>
1051             if (renderer-&gt;style().verticalAlignLength().isPercentOrCalculated())
1052                 lineHeight = renderer-&gt;style().computedLineHeight();
1053             else
1054                 lineHeight = renderer-&gt;lineHeight(firstLine, lineDirection);
1055             verticalPosition -= valueForLength(renderer-&gt;style().verticalAlignLength(), lineHeight);
1056         }
1057     }
1058 
1059     // Store the cached value.
1060     if (isRenderInline &amp;&amp; !firstLine)
1061         verticalPositionCache.set(renderer, baselineType(), verticalPosition);
1062 
1063     return verticalPosition;
1064 }
1065 
1066 bool RootInlineBox::includeLeadingForBox(InlineBox&amp; box) const
1067 {
1068     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1069         return false;
1070 
<span class="line-modified">1071     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-modified">1072     return (lineBoxContain &amp; LineBoxContainInline) || (&amp;box == this &amp;&amp; (lineBoxContain &amp; LineBoxContainBlock));</span>
1073 }
1074 
1075 bool RootInlineBox::includeFontForBox(InlineBox&amp; box) const
1076 {
1077     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1078         return false;
1079 
1080     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1081         return false;
1082 
<span class="line-modified">1083     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">1084     return (lineBoxContain &amp; LineBoxContainFont);</span>
1085 }
1086 
1087 bool RootInlineBox::includeGlyphsForBox(InlineBox&amp; box) const
1088 {
1089     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1090         return false;
1091 
1092     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1093         return false;
1094 
<span class="line-modified">1095     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">1096     return (lineBoxContain &amp; LineBoxContainGlyphs);</span>
1097 }
1098 
1099 bool RootInlineBox::includeInitialLetterForBox(InlineBox&amp; box) const
1100 {
1101     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1102         return false;
1103 
1104     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1105         return false;
1106 
<span class="line-modified">1107     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">1108     return (lineBoxContain &amp; LineBoxContainInitialLetter);</span>
1109 }
1110 
1111 bool RootInlineBox::includeMarginForBox(InlineBox&amp; box) const
1112 {
1113     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1114         return false;
1115 
<span class="line-modified">1116     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">1117     return lineBoxContain &amp; LineBoxContainInlineBox;</span>
1118 }
1119 
<span class="line-removed">1120 </span>
1121 bool RootInlineBox::fitsToGlyphs() const
1122 {
<span class="line-modified">1123     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">1124     return ((lineBoxContain &amp; LineBoxContainGlyphs) || (lineBoxContain &amp; LineBoxContainInitialLetter));</span>
1125 }
1126 
1127 bool RootInlineBox::includesRootLineBoxFontOrLeading() const
1128 {
<span class="line-modified">1129     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">1130     return (lineBoxContain &amp; LineBoxContainBlock) || (lineBoxContain &amp; LineBoxContainInline) || (lineBoxContain &amp; LineBoxContainFont);</span>
1131 }
1132 
1133 Node* RootInlineBox::getLogicalStartBoxWithNode(InlineBox*&amp; startBox) const
1134 {
1135     Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
1136     collectLeafBoxesInLogicalOrder(leafBoxesInLogicalOrder);
1137     for (size_t i = 0; i &lt; leafBoxesInLogicalOrder.size(); ++i) {
1138         if (leafBoxesInLogicalOrder[i]-&gt;renderer().node()) {
1139             startBox = leafBoxesInLogicalOrder[i];
1140             return startBox-&gt;renderer().node();
1141         }
1142     }
1143     startBox = nullptr;
1144     return nullptr;
1145 }
1146 
1147 Node* RootInlineBox::getLogicalEndBoxWithNode(InlineBox*&amp; endBox) const
1148 {
1149     Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
1150     collectLeafBoxesInLogicalOrder(leafBoxesInLogicalOrder);
</pre>
</td>
<td>
<hr />
<pre>
  77 
  78 void RootInlineBox::detachEllipsisBox()
  79 {
  80     if (hasEllipsisBox()) {
  81         auto box = gEllipsisBoxMap-&gt;take(this);
  82         box-&gt;setParent(nullptr);
  83         setHasEllipsisBox(false);
  84     }
  85 }
  86 
  87 void RootInlineBox::clearTruncation()
  88 {
  89     if (hasEllipsisBox()) {
  90         detachEllipsisBox();
  91         InlineFlowBox::clearTruncation();
  92     }
  93 }
  94 
  95 bool RootInlineBox::isHyphenated() const
  96 {
<span class="line-modified">  97     for (InlineBox* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
  98         if (is&lt;InlineTextBox&gt;(*box) &amp;&amp; downcast&lt;InlineTextBox&gt;(*box).hasHyphen())
  99             return true;
 100     }
 101     return false;
 102 }
 103 
 104 int RootInlineBox::baselinePosition(FontBaseline baselineType) const
 105 {
 106     return renderer().baselinePosition(baselineType, isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
 107 }
 108 
 109 LayoutUnit RootInlineBox::lineHeight() const
 110 {
 111     return renderer().lineHeight(isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
 112 }
 113 
 114 bool RootInlineBox::lineCanAccommodateEllipsis(bool ltr, int blockEdge, int lineBoxEdge, int ellipsisWidth)
 115 {
 116     // First sanity-check the unoverflowed width of the whole line to see if there is sufficient room.
 117     int delta = ltr ? lineBoxEdge - blockEdge : blockEdge - lineBoxEdge;
</pre>
<hr />
<pre>
 435     if (leftGap) {
 436         result.uniteLeft(blockFlow().logicalLeftSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, &amp;firstBox-&gt;parent()-&gt;renderer(), LayoutUnit(firstBox-&gt;logicalLeft()),
 437             selTop, selHeight, cache, paintInfo));
 438     }
 439     if (rightGap) {
 440         result.uniteRight(blockFlow().logicalRightSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, &amp;lastBox-&gt;parent()-&gt;renderer(), LayoutUnit(lastBox-&gt;logicalRight()),
 441             selTop, selHeight, cache, paintInfo));
 442     }
 443 
 444     // When dealing with bidi text, a non-contiguous selection region is possible.
 445     // e.g. The logical text aaaAAAbbb (capitals denote RTL text and non-capitals LTR) is layed out
 446     // visually as 3 text runs |aaa|bbb|AAA| if we select 4 characters from the start of the text the
 447     // selection will look like (underline denotes selection):
 448     // |aaa|bbb|AAA|
 449     //  ___       _
 450     // We can see that the |bbb| run is not part of the selection while the runs around it are.
 451     if (firstBox &amp;&amp; firstBox != lastBox) {
 452         // Now fill in any gaps on the line that occurred between two selected elements.
 453         LayoutUnit lastLogicalLeft { firstBox-&gt;logicalRight() };
 454         bool isPreviousBoxSelected = firstBox-&gt;selectionState() != RenderObject::SelectionNone;
<span class="line-modified"> 455         for (InlineBox* box = firstBox-&gt;nextLeafOnLine(); box; box = box-&gt;nextLeafOnLine()) {</span>
 456             if (box-&gt;selectionState() != RenderObject::SelectionNone) {
 457                 LayoutRect logicalRect { lastLogicalLeft, selTop, LayoutUnit(box-&gt;logicalLeft() - lastLogicalLeft), selHeight };
 458                 logicalRect.move(renderer().isHorizontalWritingMode() ? offsetFromRootBlock : LayoutSize(offsetFromRootBlock.height(), offsetFromRootBlock.width()));
 459                 LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
 460                 if (isPreviousBoxSelected &amp;&amp; gapRect.width() &gt; 0 &amp;&amp; gapRect.height() &gt; 0) {
 461                     if (paintInfo &amp;&amp; box-&gt;parent()-&gt;renderer().style().visibility() == Visibility::Visible)
 462                         paintInfo-&gt;context().fillRect(gapRect, box-&gt;parent()-&gt;renderer().selectionBackgroundColor());
 463                     // VisibleSelection may be non-contiguous, see comment above.
 464                     result.uniteCenter(gapRect);
 465                 }
 466                 lastLogicalLeft = box-&gt;logicalRight();
 467             }
 468             if (box == lastBox)
 469                 break;
 470             isPreviousBoxSelected = box-&gt;selectionState() != RenderObject::SelectionNone;
 471         }
 472     }
 473 
 474     return result;
 475 }
</pre>
<hr />
<pre>
 514         break;
 515     }
 516 
 517     float leftEdge = std::min&lt;float&gt;(0, rootLeft);
 518     float rightEdge = std::max&lt;float&gt;(blockFlow().logicalWidth(), rootRight);
 519 
 520     if (rightAligned) {
 521         left = std::max(left, leftEdge);
 522         left = std::min(left, rootRight - caretWidth);
 523     } else {
 524         left = std::min(left, rightEdge - caretWidthRightOfOffset);
 525         left = std::max(left, rootLeft);
 526     }
 527     return blockStyle.isHorizontalWritingMode() ? IntRect(left, top, caretWidth, height) : IntRect(top, left, height, caretWidth);
 528 }
 529 
 530 RenderObject::SelectionState RootInlineBox::selectionState()
 531 {
 532     // Walk over all of the selected boxes.
 533     RenderObject::SelectionState state = RenderObject::SelectionNone;
<span class="line-modified"> 534     for (InlineBox* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
 535         RenderObject::SelectionState boxState = box-&gt;selectionState();
 536         if ((boxState == RenderObject::SelectionStart &amp;&amp; state == RenderObject::SelectionEnd) ||
 537             (boxState == RenderObject::SelectionEnd &amp;&amp; state == RenderObject::SelectionStart))
 538             state = RenderObject::SelectionBoth;
 539         else if (state == RenderObject::SelectionNone ||
 540                  ((boxState == RenderObject::SelectionStart || boxState == RenderObject::SelectionEnd) &amp;&amp;
 541                   (state == RenderObject::SelectionNone || state == RenderObject::SelectionInside)))
 542             state = boxState;
 543         else if (boxState == RenderObject::SelectionNone &amp;&amp; state == RenderObject::SelectionStart) {
 544             // We are past the end of the selection.
 545             state = RenderObject::SelectionBoth;
 546         }
 547         if (state == RenderObject::SelectionBoth)
 548             break;
 549     }
 550 
 551     return state;
 552 }
 553 
 554 InlineBox* RootInlineBox::firstSelectedBox()
 555 {
<span class="line-modified"> 556     for (auto* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
 557         if (box-&gt;selectionState() != RenderObject::SelectionNone)
 558             return box;
 559     }
 560     return nullptr;
 561 }
 562 
 563 InlineBox* RootInlineBox::lastSelectedBox()
 564 {
<span class="line-modified"> 565     for (auto* box = lastLeafDescendant(); box; box = box-&gt;previousLeafOnLine()) {</span>
 566         if (box-&gt;selectionState() != RenderObject::SelectionNone)
 567             return box;
 568     }
 569     return nullptr;
 570 }
 571 
 572 LayoutUnit RootInlineBox::selectionTop() const
 573 {
 574     LayoutUnit selectionTop = m_lineTop;
 575 
 576     if (m_hasAnnotationsBefore)
 577         selectionTop -= !renderer().style().isFlippedLinesWritingMode() ? computeOverAnnotationAdjustment(m_lineTop) : computeUnderAnnotationAdjustment(m_lineTop);
 578 
 579     if (renderer().style().isFlippedLinesWritingMode())
 580         return selectionTop;
 581 
 582 #if !PLATFORM(IOS_FAMILY)
 583     // See rdar://problem/19692206 ... don&#39;t want to do this adjustment for iOS where overlap is ok and handled.
 584     if (renderer().isRubyBase()) {
 585         // The ruby base selection should avoid intruding into the ruby text. This is only the case if there is an actual ruby text above us.
</pre>
<hr />
<pre>
 749     return !blockFlow().style().isFlippedBlocksWritingMode() ? std::max(lineTop(), selectionTop()) : std::min(lineBottom(), selectionBottom());
 750 }
 751 
 752 RenderBlockFlow&amp; RootInlineBox::blockFlow() const
 753 {
 754     return downcast&lt;RenderBlockFlow&gt;(renderer());
 755 }
 756 
 757 static bool isEditableLeaf(InlineBox* leaf)
 758 {
 759     return leaf &amp;&amp; leaf-&gt;renderer().node() &amp;&amp; leaf-&gt;renderer().node()-&gt;hasEditableStyle();
 760 }
 761 
 762 InlineBox* RootInlineBox::closestLeafChildForPoint(const IntPoint&amp; pointInContents, bool onlyEditableLeaves)
 763 {
 764     return closestLeafChildForLogicalLeftPosition(blockFlow().isHorizontalWritingMode() ? pointInContents.x() : pointInContents.y(), onlyEditableLeaves);
 765 }
 766 
 767 InlineBox* RootInlineBox::closestLeafChildForLogicalLeftPosition(int leftPosition, bool onlyEditableLeaves)
 768 {
<span class="line-modified"> 769     InlineBox* firstLeaf = firstLeafDescendant();</span>
<span class="line-modified"> 770     InlineBox* lastLeaf = lastLeafDescendant();</span>
 771 
 772     if (firstLeaf != lastLeaf) {
 773         if (firstLeaf-&gt;isLineBreak())
<span class="line-modified"> 774             firstLeaf = firstLeaf-&gt;nextLeafOnLineIgnoringLineBreak();</span>
 775         else if (lastLeaf-&gt;isLineBreak())
<span class="line-modified"> 776             lastLeaf = lastLeaf-&gt;previousLeafOnLineIgnoringLineBreak();</span>
 777     }
 778 
 779     if (firstLeaf == lastLeaf &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
 780         return firstLeaf;
 781 
 782     // Avoid returning a list marker when possible.
 783     if (firstLeaf &amp;&amp; leftPosition &lt;= firstLeaf-&gt;logicalLeft() &amp;&amp; !firstLeaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
 784         // The leftPosition coordinate is less or equal to left edge of the firstLeaf.
 785         // Return it.
 786         return firstLeaf;
 787 
 788     if (lastLeaf &amp;&amp; leftPosition &gt;= lastLeaf-&gt;logicalRight() &amp;&amp; !lastLeaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(lastLeaf)))
 789         // The leftPosition coordinate is greater or equal to right edge of the lastLeaf.
 790         // Return it.
 791         return lastLeaf;
 792 
 793     InlineBox* closestLeaf = nullptr;
<span class="line-modified"> 794     for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf-&gt;nextLeafOnLineIgnoringLineBreak()) {</span>
 795         if (!leaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(leaf))) {
 796             closestLeaf = leaf;
 797             if (leftPosition &lt; leaf-&gt;logicalRight())
 798                 // The x coordinate is less than the right edge of the box.
 799                 // Return it.
 800                 return leaf;
 801         }
 802     }
 803 
 804     return closestLeaf ? closestLeaf : lastLeaf;
 805 }
 806 
 807 BidiStatus RootInlineBox::lineBreakBidiStatus() const
 808 {
 809     return { static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusEor), static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusLastStrong), static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusLast), m_lineBreakContext.copyRef() };
 810 }
 811 
 812 void RootInlineBox::setLineBreakInfo(RenderObject* object, unsigned breakPosition, const BidiStatus&amp; status)
 813 {
 814     m_lineBreakObj = makeWeakPtr(object);
 815     m_lineBreakPos = breakPosition;
 816     m_lineBreakBidiStatusEor = status.eor;
 817     m_lineBreakBidiStatusLastStrong = status.lastStrong;
 818     m_lineBreakBidiStatusLast = status.last;
 819     m_lineBreakContext = status.context;
 820 }
 821 
 822 EllipsisBox* RootInlineBox::ellipsisBox() const
 823 {
 824     if (!hasEllipsisBox())
 825         return nullptr;
 826     return gEllipsisBoxMap-&gt;get(this);
 827 }
 828 
 829 void RootInlineBox::removeLineBoxFromRenderObject()
 830 {
<span class="line-modified"> 831     // Null if we are destroying ComplexLineLayout.</span>
<span class="line-added"> 832     if (auto* complexLineLayout = blockFlow().complexLineLayout())</span>
<span class="line-added"> 833         complexLineLayout-&gt;lineBoxes().removeLineBox(this);</span>
 834 }
 835 
 836 void RootInlineBox::extractLineBoxFromRenderObject()
 837 {
 838     blockFlow().complexLineLayout()-&gt;lineBoxes().extractLineBox(this);
 839 }
 840 
 841 void RootInlineBox::attachLineBoxToRenderObject()
 842 {
 843     blockFlow().complexLineLayout()-&gt;lineBoxes().attachLineBox(this);
 844 }
 845 
 846 LayoutRect RootInlineBox::paddedLayoutOverflowRect(LayoutUnit endPadding) const
 847 {
 848     LayoutRect lineLayoutOverflow = layoutOverflowRect(lineTop(), lineBottom());
 849     if (!endPadding)
 850         return lineLayoutOverflow;
 851 
 852     if (isHorizontal()) {
 853         if (isLeftToRightDirection())
</pre>
<hr />
<pre>
 867 static void setAscentAndDescent(int&amp; ascent, int&amp; descent, int newAscent, int newDescent, bool&amp; ascentDescentSet)
 868 {
 869     if (!ascentDescentSet) {
 870         ascentDescentSet = true;
 871         ascent = newAscent;
 872         descent = newDescent;
 873     } else {
 874         ascent = std::max(ascent, newAscent);
 875         descent = std::max(descent, newDescent);
 876     }
 877 }
 878 
 879 void RootInlineBox::ascentAndDescentForBox(InlineBox&amp; box, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, int&amp; ascent, int&amp; descent,
 880                                            bool&amp; affectsAscent, bool&amp; affectsDescent) const
 881 {
 882     bool ascentDescentSet = false;
 883 
 884     // Replaced boxes will return 0 for the line-height if line-box-contain says they are
 885     // not to be included.
 886     if (box.renderer().isReplaced()) {
<span class="line-modified"> 887         if (lineStyle().lineBoxContain().contains(LineBoxContain::Replaced)) {</span>
 888             ascent = box.baselinePosition(baselineType());
 889             descent = box.lineHeight() - ascent;
 890 
 891             // Replaced elements always affect both the ascent and descent.
 892             affectsAscent = true;
 893             affectsDescent = true;
 894         }
 895         return;
 896     }
 897 
 898     Vector&lt;const Font*&gt;* usedFonts = nullptr;
 899     GlyphOverflow* glyphOverflow = nullptr;
 900     if (is&lt;InlineTextBox&gt;(box)) {
 901         GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.find(&amp;downcast&lt;InlineTextBox&gt;(box));
 902         usedFonts = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.first;
 903         glyphOverflow = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.second;
 904     }
 905 
 906     bool includeLeading = includeLeadingForBox(box);
 907     bool includeFont = includeFontForBox(box);
</pre>
<hr />
<pre>
1053             if (renderer-&gt;style().verticalAlignLength().isPercentOrCalculated())
1054                 lineHeight = renderer-&gt;style().computedLineHeight();
1055             else
1056                 lineHeight = renderer-&gt;lineHeight(firstLine, lineDirection);
1057             verticalPosition -= valueForLength(renderer-&gt;style().verticalAlignLength(), lineHeight);
1058         }
1059     }
1060 
1061     // Store the cached value.
1062     if (isRenderInline &amp;&amp; !firstLine)
1063         verticalPositionCache.set(renderer, baselineType(), verticalPosition);
1064 
1065     return verticalPosition;
1066 }
1067 
1068 bool RootInlineBox::includeLeadingForBox(InlineBox&amp; box) const
1069 {
1070     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1071         return false;
1072 
<span class="line-modified">1073     auto lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-modified">1074     return lineBoxContain.contains(LineBoxContain::Inline) || (&amp;box == this &amp;&amp; lineBoxContain.contains(LineBoxContain::Block));</span>
1075 }
1076 
1077 bool RootInlineBox::includeFontForBox(InlineBox&amp; box) const
1078 {
1079     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1080         return false;
1081 
1082     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1083         return false;
1084 
<span class="line-modified">1085     return renderer().style().lineBoxContain().contains(LineBoxContain::Font);</span>

1086 }
1087 
1088 bool RootInlineBox::includeGlyphsForBox(InlineBox&amp; box) const
1089 {
1090     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1091         return false;
1092 
1093     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1094         return false;
1095 
<span class="line-modified">1096     return renderer().style().lineBoxContain().contains(LineBoxContain::Glyphs);</span>

1097 }
1098 
1099 bool RootInlineBox::includeInitialLetterForBox(InlineBox&amp; box) const
1100 {
1101     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1102         return false;
1103 
1104     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1105         return false;
1106 
<span class="line-modified">1107     return renderer().style().lineBoxContain().contains(LineBoxContain::InitialLetter);</span>

1108 }
1109 
1110 bool RootInlineBox::includeMarginForBox(InlineBox&amp; box) const
1111 {
1112     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1113         return false;
1114 
<span class="line-modified">1115     return renderer().style().lineBoxContain().contains(LineBoxContain::InlineBox);</span>

1116 }
1117 

1118 bool RootInlineBox::fitsToGlyphs() const
1119 {
<span class="line-modified">1120     return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Glyphs, LineBoxContain::InitialLetter });</span>

1121 }
1122 
1123 bool RootInlineBox::includesRootLineBoxFontOrLeading() const
1124 {
<span class="line-modified">1125     return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Block, LineBoxContain::Inline, LineBoxContain::Font });</span>

1126 }
1127 
1128 Node* RootInlineBox::getLogicalStartBoxWithNode(InlineBox*&amp; startBox) const
1129 {
1130     Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
1131     collectLeafBoxesInLogicalOrder(leafBoxesInLogicalOrder);
1132     for (size_t i = 0; i &lt; leafBoxesInLogicalOrder.size(); ++i) {
1133         if (leafBoxesInLogicalOrder[i]-&gt;renderer().node()) {
1134             startBox = leafBoxesInLogicalOrder[i];
1135             return startBox-&gt;renderer().node();
1136         }
1137     }
1138     startBox = nullptr;
1139     return nullptr;
1140 }
1141 
1142 Node* RootInlineBox::getLogicalEndBoxWithNode(InlineBox*&amp; endBox) const
1143 {
1144     Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
1145     collectLeafBoxesInLogicalOrder(leafBoxesInLogicalOrder);
</pre>
</td>
</tr>
</table>
<center><a href="RenderView.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
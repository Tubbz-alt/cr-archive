<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderInline.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.

   3  *
   4  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   5  *
   6  * Other contributors:
   7  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   8  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
   9  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  10  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  11  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  12  *   Josh Soref &lt;timeless@mac.com&gt;
  13  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  14  *
  15  * This library is free software; you can redistribute it and/or
  16  * modify it under the terms of the GNU Lesser General Public
  17  * License as published by the Free Software Foundation; either
  18  * version 2.1 of the License, or (at your option) any later version.
  19  *
  20  * This library is distributed in the hope that it will be useful,
  21  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  22  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</pre>
<hr />
<pre>
  35  * version of this file only under the terms of one of those two
  36  * licenses (the MPL or the GPL) and not to allow others to use your
  37  * version of this file under the LGPL, indicate your decision by
  38  * deletingthe provisions above and replace them with the notice and
  39  * other provisions required by the MPL or the GPL, as the case may be.
  40  * If you do not delete the provisions above, a recipient may use your
  41  * version of this file under any of the LGPL, the MPL or the GPL.
  42  */
  43 
  44 #include &quot;config.h&quot;
  45 #include &quot;RenderLayer.h&quot;
  46 
  47 #include &quot;BoxShape.h&quot;
  48 #include &quot;CSSAnimationController.h&quot;
  49 #include &quot;CSSFilter.h&quot;
  50 #include &quot;CSSPropertyNames.h&quot;
  51 #include &quot;Chrome.h&quot;
  52 #include &quot;DebugPageOverlays.h&quot;
  53 #include &quot;DeprecatedGlobalSettings.h&quot;
  54 #include &quot;Document.h&quot;
<span class="line-removed">  55 #include &quot;DocumentEventQueue.h&quot;</span>
  56 #include &quot;DocumentMarkerController.h&quot;
  57 #include &quot;DocumentTimeline.h&quot;

  58 #include &quot;Element.h&quot;
  59 #include &quot;EventHandler.h&quot;
  60 #include &quot;FEColorMatrix.h&quot;
  61 #include &quot;FEMerge.h&quot;
  62 #include &quot;FloatConversion.h&quot;
  63 #include &quot;FloatPoint3D.h&quot;
  64 #include &quot;FloatRect.h&quot;
  65 #include &quot;FloatRoundedRect.h&quot;
  66 #include &quot;FocusController.h&quot;
  67 #include &quot;Frame.h&quot;
  68 #include &quot;FrameLoader.h&quot;
  69 #include &quot;FrameLoaderClient.h&quot;
  70 #include &quot;FrameSelection.h&quot;
  71 #include &quot;FrameTree.h&quot;
  72 #include &quot;FrameView.h&quot;
  73 #include &quot;Gradient.h&quot;
  74 #include &quot;GraphicsContext.h&quot;
  75 #include &quot;HTMLFormControlElement.h&quot;
  76 #include &quot;HTMLFrameElement.h&quot;
  77 #include &quot;HTMLFrameOwnerElement.h&quot;
</pre>
<hr />
<pre>
 107 #include &quot;RenderTableRow.h&quot;
 108 #include &quot;RenderText.h&quot;
 109 #include &quot;RenderTheme.h&quot;
 110 #include &quot;RenderTreeAsText.h&quot;
 111 #include &quot;RenderView.h&quot;
 112 #include &quot;RuntimeEnabledFeatures.h&quot;
 113 #include &quot;SVGNames.h&quot;
 114 #include &quot;ScaleTransformOperation.h&quot;
 115 #include &quot;ScriptDisallowedScope.h&quot;
 116 #include &quot;ScrollAnimator.h&quot;
 117 #include &quot;Scrollbar.h&quot;
 118 #include &quot;ScrollbarTheme.h&quot;
 119 #include &quot;ScrollingCoordinator.h&quot;
 120 #include &quot;Settings.h&quot;
 121 #include &quot;ShadowRoot.h&quot;
 122 #include &quot;SourceGraphic.h&quot;
 123 #include &quot;StyleProperties.h&quot;
 124 #include &quot;StyleResolver.h&quot;
 125 #include &quot;TransformationMatrix.h&quot;
 126 #include &quot;TranslateTransformOperation.h&quot;
<span class="line-modified"> 127 #include &quot;WheelEventTestTrigger.h&quot;</span>
 128 #include &lt;stdio.h&gt;
 129 #include &lt;wtf/MonotonicTime.h&gt;
 130 #include &lt;wtf/StdLibExtras.h&gt;
 131 #include &lt;wtf/text/CString.h&gt;
 132 #include &lt;wtf/text/TextStream.h&gt;
 133 
 134 #if ENABLE(CSS_SCROLL_SNAP)
 135 #include &quot;AxisScrollSnapOffsets.h&quot;
 136 #endif
 137 
 138 #define MIN_INTERSECT_FOR_REVEAL 32
 139 
 140 namespace WebCore {
 141 
 142 using namespace HTMLNames;
 143 
 144 class ClipRects : public RefCounted&lt;ClipRects&gt; {
 145     WTF_MAKE_FAST_ALLOCATED;
 146 public:
 147     static Ref&lt;ClipRects&gt; create()
</pre>
<hr />
<pre>
 204     ClipRects(const ClipRects&amp; other)
 205         : RefCounted()
 206         , m_fixed(other.fixed())
 207         , m_overflowClipRect(other.overflowClipRect())
 208         , m_fixedClipRect(other.fixedClipRect())
 209         , m_posClipRect(other.posClipRect())
 210     {
 211     }
 212 
 213     bool m_fixed { false };
 214     ClipRect m_overflowClipRect;
 215     ClipRect m_fixedClipRect;
 216     ClipRect m_posClipRect;
 217 };
 218 
 219 class ClipRectsCache {
 220     WTF_MAKE_FAST_ALLOCATED;
 221 public:
 222     ClipRectsCache()
 223     {
<span class="line-modified"> 224 #ifndef NDEBUG</span>
 225         for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
 226             m_clipRectsRoot[i] = 0;
 227             m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
 228         }
 229 #endif
 230     }
 231 
 232     ClipRects* getClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 233     {
 234         return m_clipRects[getIndex(clipRectsType, respectOverflow)].get();
 235     }
 236 
 237     void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
 238     {
 239         m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
 240     }
 241 
<span class="line-modified"> 242 #ifndef NDEBUG</span>
 243     const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
 244     OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
 245 #endif
 246 
 247 private:
 248     unsigned getIndex(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 249     {
 250         unsigned index = static_cast&lt;unsigned&gt;(clipRectsType);
 251         if (respectOverflow == RespectOverflowClip)
 252             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 253         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 254         return index;
 255     }
 256 
 257     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 258 };
 259 
 260 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 261 {
 262 #if !ENABLE(3D_TRANSFORMS)
</pre>
<hr />
<pre>
 265 #else
 266     if (!has3DRendering)
 267         matrix.makeAffine();
 268 #endif
 269 }
 270 
 271 #if !LOG_DISABLED
 272 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipRects&amp; clipRects)
 273 {
 274     TextStream::GroupScope scope(ts);
 275     ts &lt;&lt; indent &lt;&lt; &quot;ClipRects\n&quot;;
 276     ts &lt;&lt; indent &lt;&lt; &quot;  overflow  : &quot; &lt;&lt; clipRects.overflowClipRect() &lt;&lt; &quot;\n&quot;;
 277     ts &lt;&lt; indent &lt;&lt; &quot;  fixed     : &quot; &lt;&lt; clipRects.fixedClipRect() &lt;&lt; &quot;\n&quot;;
 278     ts &lt;&lt; indent &lt;&lt; &quot;  positioned: &quot; &lt;&lt; clipRects.posClipRect() &lt;&lt; &quot;\n&quot;;
 279 
 280     return ts;
 281 }
 282 
 283 #endif
 284 


 285 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 286     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 287     , m_forcedStackingContext(rendererLayerModelObject.isMedia())


 288     , m_isOpportunisticStackingContext(false)
 289     , m_zOrderListsDirty(false)
 290     , m_normalFlowListDirty(true)
 291     , m_hadNegativeZOrderList(false)
 292     , m_inResizeMode(false)
 293     , m_scrollDimensionsDirty(true)
 294     , m_hasSelfPaintingLayerDescendant(false)
 295     , m_hasSelfPaintingLayerDescendantDirty(false)
 296     , m_usedTransparency(false)
 297     , m_paintingInsideReflection(false)
 298     , m_inOverflowRelayout(false)
 299     , m_repaintStatus(NeedsNormalRepaint)
 300     , m_visibleContentStatusDirty(true)
 301     , m_hasVisibleContent(false)
 302     , m_visibleDescendantStatusDirty(false)
 303     , m_hasVisibleDescendant(false)
 304     , m_registeredScrollableArea(false)
 305     , m_isFixedIntersectingViewport(false)
 306     , m_behavesAsFixed(false)
 307     , m_3DTransformedDescendantStatusDirty(true)
 308     , m_has3DTransformedDescendant(false)
 309     , m_hasCompositingDescendant(false)
 310     , m_hasCompositedScrollingAncestor(false)
 311     , m_hasCompositedScrollableOverflow(false)
 312     , m_hasTransformedAncestor(false)
 313     , m_has3DTransformedAncestor(false)
 314     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 315     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 316 #if PLATFORM(IOS_FAMILY)
 317 #if ENABLE(IOS_TOUCH_EVENTS)
 318     , m_registeredAsTouchEventListenerForScrolling(false)
 319 #endif
 320     , m_adjustForIOSCaretWhenScrolling(false)
 321 #endif
 322     , m_requiresScrollPositionReconciliation(false)
 323     , m_containsDirtyOverlayScrollbars(false)
 324     , m_updatingMarqueePosition(false)
<span class="line-modified"> 325 #if !ASSERT_DISABLED</span>
 326     , m_layerListMutationAllowed(true)
 327 #endif
 328 #if ENABLE(CSS_COMPOSITING)
 329     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 330     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 331     , m_hasNotIsolatedBlendingDescendants(false)
 332     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 333 #endif
 334     , m_renderer(rendererLayerModelObject)
 335 {
 336     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
 337     setIsCSSStackingContext(shouldBeCSSStackingContext());
 338 
 339     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 340 
 341     if (!renderer().firstChild()) {
 342         m_visibleContentStatusDirty = false;
 343         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 344     }
 345 
</pre>
<hr />
<pre>
 477 
 478 #if ENABLE(CSS_COMPOSITING)
 479     if (oldChild.hasBlendMode() || (oldChild.hasNotIsolatedBlendingDescendants() &amp;&amp; !oldChild.isolatesBlending()))
 480         dirtyAncestorChainHasBlendingDescendants();
 481 #endif
 482 }
 483 
 484 void RenderLayer::dirtyPaintOrderListsOnChildChange(RenderLayer&amp; child)
 485 {
 486     if (child.isNormalFlowOnly())
 487         dirtyNormalFlowList();
 488 
 489     if (!child.isNormalFlowOnly() || child.firstChild()) {
 490         // Dirty the z-order list in which we are contained. The stackingContext() can be null in the
 491         // case where we&#39;re building up generated content layers. This is ok, since the lists will start
 492         // off dirty in that case anyway.
 493         child.dirtyStackingContextZOrderLists();
 494     }
 495 }
 496 
<span class="line-modified"> 497 void RenderLayer::insertOnlyThisLayer()</span>
 498 {
 499     if (!m_parent &amp;&amp; renderer().parent()) {
 500         // We need to connect ourselves when our renderer() has a parent.
 501         // Find our enclosingLayer and add ourselves.
 502         RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
 503         ASSERT(parentLayer);
 504         RenderLayer* beforeChild = parentLayer-&gt;reflectionLayer() != this ? renderer().parent()-&gt;findNextLayer(parentLayer, &amp;renderer()) : nullptr;
 505         parentLayer-&gt;addChild(*this, beforeChild);
 506     }
 507 
 508     // Remove all descendant layers from the hierarchy and add them to the new position.
 509     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
 510         child.moveLayers(m_parent, this);
 511 





 512     // Clear out all the clip rects.
 513     clearClipRectsIncludingDescendants();
 514 }
 515 
<span class="line-modified"> 516 void RenderLayer::removeOnlyThisLayer()</span>
 517 {
 518     if (!m_parent)
 519         return;
 520 



 521     // Mark that we are about to lose our layer. This makes render tree
 522     // walks ignore this layer while we&#39;re removing it.
 523     renderer().setHasLayer(false);
 524 
 525     compositor().layerWillBeRemoved(*m_parent, *this);
 526 
 527     // Dirty the clip rects.
 528     clearClipRectsIncludingDescendants();
 529 
 530     RenderLayer* nextSib = nextSibling();
 531 
 532     // Remove the child reflection layer before moving other child layers.
 533     // The reflection layer should not be moved to the parent.
 534     if (reflection())
 535         removeChild(*reflectionLayer());
 536 
 537     // Now walk our kids and reattach them to our parent.
 538     RenderLayer* current = m_first;
 539     while (current) {
 540         RenderLayer* next = current-&gt;nextSibling();
</pre>
<hr />
<pre>
 547     // Remove us from the parent.
 548     m_parent-&gt;removeChild(*this);
 549     renderer().destroyLayer();
 550 }
 551 
 552 static bool canCreateStackingContext(const RenderLayer&amp; layer)
 553 {
 554     auto&amp; renderer = layer.renderer();
 555     return renderer.hasTransformRelatedProperty()
 556         || renderer.hasClipPath()
 557         || renderer.hasFilter()
 558         || renderer.hasMask()
 559         || renderer.hasBackdropFilter()
 560 #if ENABLE(CSS_COMPOSITING)
 561         || renderer.hasBlendMode()
 562 #endif
 563         || renderer.isTransparent()
 564         || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
 565         || renderer.hasReflection()
 566         || renderer.style().hasIsolation()
<span class="line-modified"> 567         || !renderer.style().hasAutoZIndex()</span>
 568         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 569 }
 570 
 571 bool RenderLayer::shouldBeNormalFlowOnly() const
 572 {
 573     if (canCreateStackingContext(*this))
 574         return false;
 575 
 576     return renderer().hasOverflowClip()
 577         || renderer().isCanvas()
 578         || renderer().isVideo()
 579         || renderer().isEmbeddedObject()
 580         || renderer().isRenderIFrame()
 581         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 582         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 583         || renderer().isInFlowRenderFragmentedFlow();
 584 }
 585 
 586 bool RenderLayer::shouldBeCSSStackingContext() const
 587 {
<span class="line-modified"> 588     return !renderer().style().hasAutoZIndex() || isRenderViewLayer();</span>
 589 }
 590 
 591 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 592 {
 593     if (isNormalFlowOnly == m_isNormalFlowOnly)
 594         return false;
 595 
 596     m_isNormalFlowOnly = isNormalFlowOnly;
 597 
 598     if (auto* p = parent())
 599         p-&gt;dirtyNormalFlowList();
 600     dirtyStackingContextZOrderLists();
 601     return true;
 602 }
 603 
 604 void RenderLayer::isStackingContextChanged()
 605 {
 606     dirtyStackingContextZOrderLists();
 607     if (isStackingContext())
 608         dirtyZOrderLists();
</pre>
<hr />
<pre>
 696         return;
 697 
 698     ASSERT(layerListMutationAllowed());
 699 
 700     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 701         // Ignore non-overflow layers and reflections.
 702         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 703             if (!m_normalFlowList)
 704                 m_normalFlowList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 705             m_normalFlowList-&gt;append(child);
 706         }
 707     }
 708 
 709     m_normalFlowListDirty = false;
 710 }
 711 
 712 void RenderLayer::rebuildZOrderLists()
 713 {
 714     ASSERT(layerListMutationAllowed());
 715     ASSERT(isDirtyStackingContext());
<span class="line-modified"> 716     rebuildZOrderLists(m_posZOrderList, m_negZOrderList);</span>


 717     m_zOrderListsDirty = false;
 718 
 719     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 720     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 721     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 722     // lists on dirtying so we don&#39;t know the old state.
 723     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 724         m_hadNegativeZOrderList = hasNegativeZOrderList;
 725         if (isComposited())
 726             setNeedsCompositingConfigurationUpdate();
 727     }










 728 }
 729 
<span class="line-modified"> 730 void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList)</span>
 731 {
 732     bool includeHiddenLayers = compositor().usesCompositing();
 733     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 734         if (!isReflectionLayer(*child))
<span class="line-modified"> 735             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList);</span>
 736     }
 737 
 738     auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
 739         return first-&gt;zIndex() &lt; second-&gt;zIndex();
 740     };
 741 
 742     // Sort the two lists.
 743     if (posZOrderList)
 744         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 745 
 746     if (negZOrderList)
 747         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 748 }
 749 
<span class="line-modified"> 750 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList)</span>
 751 {
 752     updateDescendantDependentFlags();
 753 
 754     bool isStacking = isStackingContext();
 755     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 756     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 757     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 758         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 759         if (!layerList)
 760             layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 761         layerList-&gt;append(this);

 762     }
 763 
 764     // Recur into our children to collect more layers, but only if we don&#39;t establish
 765     // a stacking context/container.
 766     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 767         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 768             // Ignore reflections.
 769             if (!isReflectionLayer(*child))
<span class="line-modified"> 770                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList);</span>
 771         }
 772     }
 773 }
 774 
 775 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 776 {
 777     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 778         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 779             break;
 780         layer-&gt;m_compositingDirtyBits.add(flag);
 781     }
 782 }
 783 
 784 void RenderLayer::updateLayerListsIfNeeded()
 785 {
 786     updateZOrderLists();
 787     updateNormalFlowList();
 788 
 789     if (RenderLayer* reflectionLayer = this-&gt;reflectionLayer()) {
 790         reflectionLayer-&gt;updateZOrderLists();
</pre>
<hr />
<pre>
1225 
1226         if (layer-&gt;isCSSStackingContext())
1227             break;
1228     }
1229 }
1230 
1231 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1232 {
1233     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1234         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1235             break;
1236 
1237         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1238 
1239         if (layer-&gt;isCSSStackingContext())
1240             break;
1241     }
1242 }
1243 #endif
1244 



























































1245 void RenderLayer::updateTransform()
1246 {
1247     bool hasTransform = renderer().hasTransform();
1248     bool had3DTransform = has3DTransform();
1249 
1250     bool hadTransform = !!m_transform;
1251     if (hasTransform != hadTransform) {
1252         if (hasTransform)
1253             m_transform = makeUnique&lt;TransformationMatrix&gt;();
1254         else
1255             m_transform = nullptr;
1256 
1257         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1258         clearClipRectsIncludingDescendants();
1259     }
1260 
1261     if (hasTransform) {
1262         RenderBox* box = renderBox();
1263         ASSERT(box);
1264         m_transform-&gt;makeIdentity();
<span class="line-modified">1265         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);</span>


1266         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1267     }
1268 
1269     if (had3DTransform != has3DTransform()) {
1270         dirty3DTransformedDescendantStatus();
1271         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1272         setNeedsPostLayoutCompositingUpdateOnAncestors();
1273     }
1274 }
1275 
1276 TransformationMatrix RenderLayer::currentTransform(RenderStyle::ApplyTransformOrigin applyOrigin) const
1277 {
1278     if (!m_transform)
1279         return TransformationMatrix();
1280 
1281     RenderBox* box = renderBox();
1282 
1283     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1284         if (auto* timeline = renderer().documentTimeline()) {
1285             if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1286                 TransformationMatrix currTransform;
<span class="line-modified">1287                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());</span>
1288                 std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());


1289                 style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1290                 makeMatrixRenderable(currTransform, canRender3DTransforms());
1291                 return currTransform;
1292             }
1293         }
1294     } else {
1295         if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1296             TransformationMatrix currTransform;
<span class="line-removed">1297             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());</span>
1298             std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());



1299             style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1300             makeMatrixRenderable(currTransform, canRender3DTransforms());
1301             return currTransform;
1302         }
1303     }
1304 
1305 
1306     // m_transform includes transform-origin, so we need to recompute the transform here.
1307     if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
1308         TransformationMatrix currTransform;
<span class="line-modified">1309         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());</span>



1310         box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
1311         makeMatrixRenderable(currTransform, canRender3DTransforms());
1312         return currTransform;
1313     }
1314 
1315     return *m_transform;
1316 }
1317 
1318 TransformationMatrix RenderLayer::renderableTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
1319 {
1320     if (!m_transform)
1321         return TransformationMatrix();
1322 
1323     if (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) {
1324         TransformationMatrix matrix = *m_transform;
1325         makeMatrixRenderable(matrix, false /* flatten 3d */);
1326         return matrix;
1327     }
1328 
1329     return *m_transform;
</pre>
<hr />
<pre>
1911 
1912 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
1913 {
1914     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1915         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
1916             return const_cast&lt;RenderLayer*&gt;(curr);
1917     }
1918     return nullptr;
1919 }
1920 
1921 // FIXME: This neeeds a better name.
1922 void RenderLayer::setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp; rect)
1923 {
1924     ASSERT(requiresFullLayerImageForFilters());
1925     ASSERT(m_filters);
1926 
1927     if (rect.isEmpty())
1928         return;
1929 
1930     LayoutRect rectForRepaint = rect;
<span class="line-modified">1931     renderer().style().filterOutsets().expandRect(rectForRepaint);</span>
1932 
1933     m_filters-&gt;expandDirtySourceRect(rectForRepaint);
1934 
1935     RenderLayer* parentLayer = enclosingFilterRepaintLayer();
1936     ASSERT(parentLayer);
1937     FloatQuad repaintQuad(rectForRepaint);
1938     LayoutRect parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
1939 
1940     if (parentLayer-&gt;isComposited()) {
1941         if (!parentLayer-&gt;backing()-&gt;paintsIntoWindow()) {
1942             parentLayer-&gt;setBackingNeedsRepaintInRect(parentLayerRect);
1943             return;
1944         }
1945         // If the painting goes to window, redirect the painting to the parent RenderView.
1946         parentLayer = renderer().view().layer();
1947         parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
1948     }
1949 
1950     if (parentLayer-&gt;paintsWithFilters()) {
1951         parentLayer-&gt;setFilterBackendNeedsRepaintingInRect(parentLayerRect);
1952         return;
1953     }
1954 
1955     if (parentLayer-&gt;isRenderViewLayer()) {
1956         downcast&lt;RenderView&gt;(parentLayer-&gt;renderer()).repaintViewRectangle(parentLayerRect);
1957         return;
1958     }
1959 
1960     ASSERT_NOT_REACHED();
1961 }
1962 
1963 bool RenderLayer::hasAncestorWithFilterOutsets() const
1964 {
1965     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
<span class="line-modified">1966         if (curr-&gt;renderer().style().hasFilterOutsets())</span>
1967             return true;
1968     }
1969     return false;
1970 }
1971 
1972 RenderLayer* RenderLayer::clippingRootForPainting() const
1973 {
1974     if (isComposited())
1975         return const_cast&lt;RenderLayer*&gt;(this);
1976 
1977     if (paintsIntoProvidedBacking())
1978         return backingProviderLayer();
1979 
1980     const RenderLayer* current = this;
1981     while (current) {
1982         if (current-&gt;isRenderViewLayer())
1983             return const_cast&lt;RenderLayer*&gt;(current);
1984 
1985         current = current-&gt;paintOrderParent();
1986         ASSERT(current);
</pre>
<hr />
<pre>
2069     // paintDirtyRect, and that should cut down on the amount we have to paint.  Still it
2070     // would be better to respect clips.
2071 
2072     if (rootLayer != &amp;layer &amp;&amp; ((transparencyBehavior == PaintingTransparencyClipBox &amp;&amp; layer.paintsWithTransform(paintBehavior))
2073         || (transparencyBehavior == HitTestingTransparencyClipBox &amp;&amp; layer.hasTransform()))) {
2074         // The best we can do here is to use enclosed bounding boxes to establish a &quot;fuzzy&quot; enough clip to encompass
2075         // the transformed layer and all of its children.
2076         RenderLayer::PaginationInclusionMode mode = transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::IncludeCompositedPaginatedLayers : RenderLayer::ExcludeCompositedPaginatedLayers;
2077         const RenderLayer* paginationLayer = transparencyMode == DescendantsOfTransparencyClipBox ? layer.enclosingPaginationLayer(mode) : nullptr;
2078         const RenderLayer* rootLayerForTransform = paginationLayer ? paginationLayer : rootLayer;
2079         LayoutSize delta = layer.offsetFromAncestor(rootLayerForTransform);
2080 
2081         TransformationMatrix transform;
2082         transform.translate(delta.width(), delta.height());
2083         transform.multiply(*layer.transform());
2084 
2085         // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
2086         // paints unfragmented.
2087         LayoutRect clipRect = layer.boundingBox(&amp;layer);
2088         expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
<span class="line-modified">2089         layer.renderer().style().filterOutsets().expandRect(clipRect);</span>
2090         LayoutRect result = transform.mapRect(clipRect);
2091         if (!paginationLayer)
2092             return result;
2093 
2094         // We have to break up the transformed extent across our columns.
2095         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
2096         // get our true bounding box.
2097         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
2098         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
2099         result.move(paginationLayer-&gt;offsetFromAncestor(rootLayer));
2100         return result;
2101     }
2102 
2103     LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
2104     expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
<span class="line-modified">2105     layer.renderer().style().filterOutsets().expandRect(clipRect);</span>
2106 
2107     return clipRect;
2108 }
2109 
2110 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2111 {
2112     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
2113 }
2114 
2115 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
2116 {
2117     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
2118         return;
2119 
2120     RenderLayer* ancestor = transparentPaintingAncestor();
2121     if (ancestor)
2122         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
2123 
2124     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
2125         ASSERT(isCSSStackingContext());
</pre>
<hr />
<pre>
2150     }
2151 }
2152 
2153 #if PLATFORM(IOS_FAMILY)
2154 void RenderLayer::willBeDestroyed()
2155 {
2156     if (RenderLayerBacking* layerBacking = backing())
2157         layerBacking-&gt;layerWillBeDestroyed();
2158 }
2159 #endif
2160 
2161 bool RenderLayer::isDescendantOf(const RenderLayer&amp; layer) const
2162 {
2163     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parent()) {
2164         if (&amp;layer == ancestor)
2165             return true;
2166     }
2167     return false;
2168 }
2169 





















2170 void RenderLayer::convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; roundedLocation, ColumnOffsetAdjustment adjustForColumns) const
2171 {
2172     LayoutPoint location = convertToLayerCoords(ancestorLayer, roundedLocation, adjustForColumns);
2173     roundedLocation = roundedIntPoint(location);
2174 }
2175 
2176 // Returns the layer reached on the walk up towards the ancestor.
2177 static inline const RenderLayer* accumulateOffsetTowardsAncestor(const RenderLayer* layer, const RenderLayer* ancestorLayer, LayoutPoint&amp; location, RenderLayer::ColumnOffsetAdjustment adjustForColumns)
2178 {
2179     ASSERT(ancestorLayer != layer);
2180 
2181     const RenderLayerModelObject&amp; renderer = layer-&gt;renderer();
2182     auto position = renderer.style().position();
2183 
2184     // FIXME: Special casing RenderFragmentedFlow so much for fixed positioning here is not great.
2185     RenderFragmentedFlow* fixedFragmentedFlowContainer = position == PositionType::Fixed ? renderer.enclosingFragmentedFlow() : nullptr;
2186     if (fixedFragmentedFlowContainer &amp;&amp; !fixedFragmentedFlowContainer-&gt;isOutOfFlowPositioned())
2187         fixedFragmentedFlowContainer = nullptr;
2188 
2189     // FIXME: Positioning of out-of-flow(fixed, absolute) elements collected in a RenderFragmentedFlow
</pre>
<hr />
<pre>
2464     m_postLayoutScrollPosition = WTF::nullopt;
2465 }
2466 
2467 void RenderLayer::scrollToXPosition(int x, ScrollType scrollType, ScrollClamping clamping)
2468 {
2469     ScrollPosition position(x, m_scrollPosition.y());
2470     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2471 }
2472 
2473 void RenderLayer::scrollToYPosition(int y, ScrollType scrollType, ScrollClamping clamping)
2474 {
2475     ScrollPosition position(m_scrollPosition.x(), y);
2476     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2477 }
2478 
2479 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2480 {
2481     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2482 }
2483 









2484 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)
2485 {
2486     ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;
2487     if (clampedScrollOffset == this-&gt;scrollOffset())
2488         return;
2489 
2490     auto previousScrollType = currentScrollType();
2491     setCurrentScrollType(scrollType);
2492 
<span class="line-modified">2493     bool handled = false;</span>
<span class="line-removed">2494 #if ENABLE(ASYNC_SCROLLING)</span>
<span class="line-removed">2495     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())</span>
<span class="line-removed">2496         handled = scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, scrollPositionFromOffset(clampedScrollOffset));</span>
<span class="line-removed">2497 #endif</span>
<span class="line-removed">2498 </span>
<span class="line-removed">2499     if (!handled)</span>
2500         scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);
2501 
2502     setCurrentScrollType(previousScrollType);
2503 }
2504 
2505 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2506 {
2507     RenderBox* box = renderBox();
2508     if (!box)
2509         return;
2510 
2511     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (is user scroll &quot; &lt;&lt; (currentScrollType() == ScrollType::User) &lt;&lt; &quot;)&quot;);
2512 
2513     ScrollPosition newPosition = position;
2514     if (!box-&gt;isHTMLMarquee()) {
2515         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2516         if (m_scrollDimensionsDirty)
2517             computeScrollDimensions();
2518 #if PLATFORM(IOS_FAMILY)
2519         if (adjustForIOSCaretWhenScrolling()) {
</pre>
<hr />
<pre>
2586     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2587 
2588     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2589     if (repaintContainer)
2590         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2591     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2592 
2593     bool requiresRepaint = true;
2594     if (usesCompositedScrolling()) {
2595         setNeedsCompositingGeometryUpdate();
2596         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2597         requiresRepaint = false;
2598     }
2599 
2600     // Just schedule a full repaint of our object.
2601     if (requiresRepaint)
2602         renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
2603 
2604     // Schedule the scroll and scroll-related DOM events.
2605     if (Element* element = renderer().element())
<span class="line-modified">2606         element-&gt;document().eventQueue().enqueueOrDispatchScrollEvent(*element);</span>
2607 
2608     if (scrollsOverflow())
2609         view.frameView().didChangeScrollOffset();
2610 
2611     view.frameView().viewportContentsChanged();

2612 }
2613 
2614 static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
2615 {
2616     // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
2617     if (frameElementBase &amp;&amp; frameElementBase-&gt;scrollingMode() != ScrollbarAlwaysOff)
2618         return true;
2619 
2620     // If scrollbars are forbidden, user initiated scrolls should obviously be ignored.
2621     if (frameView.wasScrolledByUser())
2622         return false;
2623 
2624     // Forbid autoscrolls when scrollbars are off, but permits other programmatic scrolls,
2625     // like navigation to an anchor.
2626     return !frameView.frame().eventHandler().autoscrollInProgress();
2627 }
2628 
2629 bool RenderLayer::allowsCurrentScroll() const
2630 {
2631     if (!renderer().hasOverflowClip())
</pre>
<hr />
<pre>
2916 
2917     LayoutSize currentSize = LayoutSize(renderer-&gt;width() / zoomFactor, renderer-&gt;height() / zoomFactor);
2918     LayoutSize minimumSize = element-&gt;minimumSizeForResizing().shrunkTo(currentSize);
2919     element-&gt;setMinimumSizeForResizing(minimumSize);
2920 
2921     LayoutSize adjustedOldOffset = LayoutSize(oldOffset.width() / zoomFactor, oldOffset.height() / zoomFactor);
2922     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
2923         newOffset.setWidth(-newOffset.width());
2924         adjustedOldOffset.setWidth(-adjustedOldOffset.width());
2925     }
2926 
2927     LayoutSize difference = (currentSize + newOffset - adjustedOldOffset).expandedTo(minimumSize) - currentSize;
2928 
2929     StyledElement* styledElement = downcast&lt;StyledElement&gt;(element);
2930     bool isBoxSizingBorder = renderer-&gt;style().boxSizing() == BoxSizing::BorderBox;
2931 
2932     Resize resize = renderer-&gt;style().resize();
2933     if (resize != Resize::Vertical &amp;&amp; difference.width()) {
2934         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2935             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">2936             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified">2937             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
2938         }
2939         LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
2940         baseWidth = baseWidth / zoomFactor;
<span class="line-modified">2941         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSPrimitiveValue::CSS_PX);</span>
2942     }
2943 
2944     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
2945         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2946             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">2947             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified">2948             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
2949         }
2950         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
2951         baseHeight = baseHeight / zoomFactor;
<span class="line-modified">2952         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSPrimitiveValue::CSS_PX);</span>
2953     }
2954 
2955     document.updateLayout();
2956 
2957     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
2958 }
2959 
2960 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
2961 {
2962     scrollTo(scrollPositionFromOffset(offset));
2963 }
2964 
2965 ScrollingNodeID RenderLayer::scrollingNodeID() const
2966 {
2967     if (!isComposited())
2968         return 0;
2969 
2970     return backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
2971 }
2972 
</pre>
<hr />
<pre>
3276 }
3277 
3278 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3279 {
3280     if (!showsOverflowControls())
3281         return;
3282 
3283     if (GraphicsLayer* layer = layerForScrollCorner()) {
3284         layer-&gt;setNeedsDisplayInRect(rect);
3285         return;
3286     }
3287 
3288     if (m_scrollCorner)
3289         m_scrollCorner-&gt;repaintRectangle(rect);
3290     if (m_resizer)
3291         m_resizer-&gt;repaintRectangle(rect);
3292 }
3293 
3294 static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)
3295 {
<span class="line-modified">3296     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())</span>
<span class="line-removed">3297         return false;</span>
<span class="line-removed">3298 </span>
<span class="line-removed">3299     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);</span>
<span class="line-removed">3300 </span>
<span class="line-removed">3301     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
3302 }
3303 
3304 bool RenderLayer::horizontalScrollbarHiddenByStyle() const
3305 {
3306     return scrollbarHiddenByStyle(horizontalScrollbar());
3307 }
3308 
3309 bool RenderLayer::verticalScrollbarHiddenByStyle() const
3310 {
3311     return scrollbarHiddenByStyle(verticalScrollbar());
3312 }
3313 
3314 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3315 {
3316     if (Element* element = renderer.element()) {
3317         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3318             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3319                 return shadowRoot-&gt;host()-&gt;renderer();
3320         }
3321     }
3322 
3323     return &amp;renderer;
3324 }
3325 
3326 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3327 {
3328     RefPtr&lt;Scrollbar&gt; widget;
3329     ASSERT(rendererForScrollbar(renderer()));
3330     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3331     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3332     if (hasCustomScrollbarStyle)
3333         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
3334     else {
3335         widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
3336         didAddScrollbar(widget.get(), orientation);
<span class="line-modified">3337         if (page().expectsWheelEventTriggers())</span>
<span class="line-modified">3338             scrollAnimator().setWheelEventTestTrigger(page().testTrigger());</span>
3339     }
3340     renderer().view().frameView().addChild(*widget);
3341     return widget.releaseNonNull();
3342 }
3343 
3344 void RenderLayer::destroyScrollbar(ScrollbarOrientation orientation)
3345 {
3346     RefPtr&lt;Scrollbar&gt;&amp; scrollbar = orientation == HorizontalScrollbar ? m_hBar : m_vBar;
3347     if (!scrollbar)
3348         return;
3349 
3350     if (!scrollbar-&gt;isCustomScrollbar())
3351         willRemoveScrollbar(scrollbar.get(), orientation);
3352 
3353     scrollbar-&gt;removeFromParent();
3354     scrollbar = nullptr;
3355 }
3356 
3357 bool RenderLayer::scrollsOverflow() const
3358 {
</pre>
<hr />
<pre>
4254         return false;
4255 
4256     bool scrollingOnMainThread = true;
4257 #if ENABLE(ASYNC_SCROLLING)
4258     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
4259         scrollingOnMainThread = scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(renderer().view().frameView());
4260 #endif
4261 
4262     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4263     // things on the scrolling thread.
4264     bool contentsScrollByPainting = (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling()) || (renderer().frame().ownerElement());
4265     bool isZooming = !page().chrome().client().hasStablePageScaleFactor();
4266     if (scrollingOnMainThread || contentsScrollByPainting || isZooming) {
4267         didQuantizeFonts = context.shouldSubpixelQuantizeFonts();
4268         context.setShouldSubpixelQuantizeFonts(false);
4269         return true;
4270     }
4271     return false;
4272 }
4273 
<span class="line-removed">4274 static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)</span>
<span class="line-removed">4275 {</span>
<span class="line-removed">4276     // FIXME: Support different reference boxes for inline content.</span>
<span class="line-removed">4277     // https://bugs.webkit.org/show_bug.cgi?id=129047</span>
<span class="line-removed">4278     if (!renderer.isBox())</span>
<span class="line-removed">4279         return rootRelativeBounds;</span>
<span class="line-removed">4280 </span>
<span class="line-removed">4281     LayoutRect referenceBox;</span>
<span class="line-removed">4282     const auto&amp; box = downcast&lt;RenderBox&gt;(renderer);</span>
<span class="line-removed">4283     switch (boxType) {</span>
<span class="line-removed">4284     case CSSBoxType::ContentBox:</span>
<span class="line-removed">4285     case CSSBoxType::FillBox:</span>
<span class="line-removed">4286         referenceBox = box.contentBoxRect();</span>
<span class="line-removed">4287         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">4288         break;</span>
<span class="line-removed">4289     case CSSBoxType::PaddingBox:</span>
<span class="line-removed">4290         referenceBox = box.paddingBoxRect();</span>
<span class="line-removed">4291         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">4292         break;</span>
<span class="line-removed">4293     case CSSBoxType::MarginBox:</span>
<span class="line-removed">4294         referenceBox = box.marginBoxRect();</span>
<span class="line-removed">4295         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">4296         break;</span>
<span class="line-removed">4297     // stroke-box, view-box compute to border-box for HTML elements.</span>
<span class="line-removed">4298     case CSSBoxType::StrokeBox:</span>
<span class="line-removed">4299     case CSSBoxType::ViewBox:</span>
<span class="line-removed">4300     case CSSBoxType::BorderBox:</span>
<span class="line-removed">4301     case CSSBoxType::BoxMissing:</span>
<span class="line-removed">4302         referenceBox = box.borderBoxRect();</span>
<span class="line-removed">4303         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">4304         break;</span>
<span class="line-removed">4305     }</span>
<span class="line-removed">4306 </span>
<span class="line-removed">4307     return referenceBox;</span>
<span class="line-removed">4308 }</span>
<span class="line-removed">4309 </span>
4310 Path RenderLayer::computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp; windRule) const
4311 {
4312     const RenderStyle&amp; style = renderer().style();
4313     float deviceSaleFactor = renderer().document().deviceScaleFactor();
4314 
4315     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath())) {
4316         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style.clipPath());
4317         FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), clipPath.referenceBox(), offsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4318 
4319         windRule = clipPath.windRule();
4320         return clipPath.pathForReferenceRect(referenceBox);
4321     }
4322 
4323     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4324 
4325         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4326 
4327         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4328         shapeRect.move(offsetFromRoot);
4329 
</pre>
<hr />
<pre>
4442     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4443     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4444     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4445     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4446     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4447     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4448     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
4449     bool isCollectingEventRegion = paintFlags.contains(PaintLayerCollectingEventRegion);
4450     // Outline always needs to be painted even if we have no visible content. Also,
4451     // the outline is painted in the background phase during composited scrolling.
4452     // If it were painted in the foreground phase, it would move with the scrolled
4453     // content. When not composited scrolling, the outline is painted in the
4454     // foreground phase. Since scrolled contents are moved by repainting in this
4455     // case, the outline won&#39;t get &#39;dragged along&#39;.
4456     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion
4457         &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())
4458         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4459         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
4460     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;
4461 
<span class="line-modified">4462     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())</span>







4463         return;

4464 
4465     updateLayerListsIfNeeded();
4466 
4467     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4468     LayoutRect rootRelativeBounds;
4469     bool rootRelativeBoundsComputed = false;
4470 
4471     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4472     // things on the scrolling thread.
4473     bool didQuantizeFonts = true;
4474     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4475 
4476     // Apply clip-path to context.
4477     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4478     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4479         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4480 
4481     bool hasClipPath = false;
4482     if (shouldApplyClipPath(paintingInfo.paintBehavior, localPaintFlags))
4483         hasClipPath = setupClipPath(context, paintingInfo, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
</pre>
<hr />
<pre>
4663     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4664     transformedPaintingInfo.rootLayer = this;
4665     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4666     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4667     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
4668 
4669     if (paintingInfo.eventRegionContext)
4670         paintingInfo.eventRegionContext-&gt;popTransform();
4671 
4672     context.setCTM(oldTransform);
4673 }
4674 
4675 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4676 {
4677     if (layerIterator.begin() == layerIterator.end())
4678         return;
4679 
4680     if (!hasSelfPaintingLayerDescendant())
4681         return;
4682 
<span class="line-modified">4683 #if !ASSERT_DISABLED</span>
4684     LayerListMutationDetector mutationChecker(*this);
4685 #endif
4686 
4687     for (auto* childLayer : layerIterator)
4688         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4689 }
4690 
4691 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4692 {
4693     // If we don&#39;t have an enclosing layer, or if the root layer is the same as the enclosing layer,
4694     // then just return the enclosing pagination layer (it will be 0 in the former case and the rootLayer in the latter case).
4695     RenderLayer* paginationLayer = enclosingPaginationLayer(mode);
4696     if (!paginationLayer || rootLayer == paginationLayer)
4697         return paginationLayer;
4698 
4699     // Walk up the layer tree and see which layer we hit first. If it&#39;s the root, then the enclosing pagination
4700     // layer isn&#39;t in our subtree and we return nullptr. If we hit the enclosing pagination layer first, then
4701     // we can return it.
4702     for (const RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
4703         if (layer == rootLayer)
</pre>
<hr />
<pre>
5278     // The following are used for keeping track of the z-depth of the hit point of 3d-transformed
5279     // descendants.
5280     double localZOffset = -std::numeric_limits&lt;double&gt;::infinity();
5281     double* zOffsetForDescendantsPtr = nullptr;
5282     double* zOffsetForContentsPtr = nullptr;
5283 
5284     bool depthSortDescendants = false;
5285     if (preserves3D()) {
5286         depthSortDescendants = true;
5287         // Our layers can depth-test with our container, so share the z depth pointer with the container, if it passed one down.
5288         zOffsetForDescendantsPtr = zOffset ? zOffset : &amp;localZOffset;
5289         zOffsetForContentsPtr = zOffset ? zOffset : &amp;localZOffset;
5290     } else if (zOffset) {
5291         zOffsetForDescendantsPtr = nullptr;
5292         // Container needs us to give back a z offset for the hit layer.
5293         zOffsetForContentsPtr = zOffset;
5294     }
5295 
5296     // This variable tracks which layer the mouse ends up being inside.
5297     RenderLayer* candidateLayer = nullptr;
<span class="line-modified">5298 #if !ASSERT_DISABLED</span>
5299     LayerListMutationDetector mutationChecker(*this);
5300 #endif
5301 
5302     // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
5303     auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5304                                         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5305     if (hitLayer) {
5306         if (!depthSortDescendants)
5307             return hitLayer;
5308         candidateLayer = hitLayer;
5309     }
5310 
5311     // Now check our overflow objects.
5312     hitLayer = hitTestList(normalFlowLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5313                            localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5314     if (hitLayer) {
5315         if (!depthSortDescendants)
5316             return hitLayer;
5317         candidateLayer = hitLayer;
5318     }
</pre>
<hr />
<pre>
5559     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5560     if (m_clipRectsCache) {
5561         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5562             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5563             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5564 
5565 #ifdef CHECK_CACHED_CLIP_RECTS
5566             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5567             ClipRectsContext tempContext(clipRectsContext);
5568             tempContext.clipRectsType = TemporaryClipRects;
5569             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5570             calculateClipRects(tempContext, tempClipRects);
5571             ASSERT(tempClipRects.get() == *clipRects);
5572 #endif
5573             return *clipRects; // We have the correct cached value.
5574         }
5575     }
5576 
5577     if (!m_clipRectsCache)
5578         m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();
<span class="line-modified">5579 #ifndef NDEBUG</span>
5580     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5581     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5582 #endif
5583 
5584     RefPtr&lt;ClipRects&gt; parentClipRects;
5585     // For transformed layers, the root layer was shifted to be us, so there is no need to
5586     // examine the parent. We want to cache clip rects with us as the root.
5587     if (clipRectsContext.rootLayer != this &amp;&amp; parent())
5588         parentClipRects = this-&gt;parentClipRects(clipRectsContext);
5589 
5590     auto clipRects = ClipRects::create();
5591     calculateClipRects(clipRectsContext, clipRects);
5592 
5593     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5594         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5595         return parentClipRects.releaseNonNull();
5596     }
5597     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5598     return clipRects;
5599 }
</pre>
<hr />
<pre>
6072 
6073             localClipRect.move(offsetFromAncestor(ancestorLayer));
6074             return localClipRect;
6075         }
6076     }
6077 
6078     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
6079     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
6080 
6081     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
6082 
6083     if (RenderLayer* reflection = reflectionLayer()) {
6084         if (!reflection-&gt;isComposited()) {
6085             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
6086             unionBounds.unite(childUnionBounds);
6087         }
6088     }
6089 
6090     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
6091 
<span class="line-modified">6092 #if !ASSERT_DISABLED</span>
6093     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
6094 #endif
6095 
6096     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
6097         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))
6098             return;
6099         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
6100         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
6101         // that we hit the max LayoutUnit value.
6102         unionBounds.checkedUnite(childBounds);
6103     };
6104 
6105     for (auto* childLayer : negativeZOrderLayers())
6106         computeLayersUnion(*childLayer);
6107 
6108     for (auto* childLayer : positiveZOrderLayers())
6109         computeLayersUnion(*childLayer);
6110 
6111     for (auto* childLayer : normalFlowLayers())
6112         computeLayersUnion(*childLayer);
6113 
6114     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
<span class="line-modified">6115         renderer().style().filterOutsets().expandRect(unionBounds);</span>
6116 
6117     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
6118         TransformationMatrix* affineTrans = transform();
6119         boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
6120         unionBounds = affineTrans-&gt;mapRect(unionBounds);
6121     }
6122     unionBounds.move(offsetFromRoot);
6123     return unionBounds;
6124 }
6125 
6126 void RenderLayer::clearClipRectsIncludingDescendants(ClipRectsType typeToClear)
6127 {
6128     // FIXME: it&#39;s not clear how this layer not having clip rects guarantees that no descendants have any.
6129     if (!m_clipRectsCache)
6130         return;
6131 
6132     clearClipRects(typeToClear);
6133 
6134     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
6135         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
</pre>
<hr />
<pre>
6538 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6539 {
6540     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6541 
6542     if (setIsCSSStackingContext(shouldBeCSSStackingContext())) {
6543 #if ENABLE(CSS_COMPOSITING)
6544         if (parent()) {
6545             if (isCSSStackingContext()) {
6546                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6547                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6548             } else {
6549                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6550                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6551                 else if (hasNotIsolatedBlendingDescendants())
6552                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6553             }
6554         }
6555 #endif
6556     }
6557 
<span class="line-modified">6558     // FIXME: RenderLayer already handles visibility changes through our visiblity dirty bits. This logic could</span>
6559     // likely be folded along with the rest.
6560     if (oldStyle) {
<span class="line-modified">6561         if (oldStyle-&gt;zIndex() != renderer().style().zIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {</span>
6562             dirtyStackingContextZOrderLists();
6563             if (isStackingContext())
6564                 dirtyZOrderLists();
6565         }
6566     }
6567 
6568     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6569         if (!m_marquee)
6570             m_marquee = makeUnique&lt;RenderMarquee&gt;(this);
6571         m_marquee-&gt;updateMarqueeStyle();
6572     } else if (m_marquee)
6573         m_marquee = nullptr;
6574 
6575     updateScrollbarsAfterStyleChange(oldStyle);
6576     // Overlay scrollbars can make this layer self-painting so we need
6577     // to recompute the bit once scrollbars have been updated.
6578     updateSelfPaintingLayer();
6579 
6580     if (!hasReflection() &amp;&amp; m_reflection)
6581         removeReflection();
</pre>
<hr />
<pre>
6638     }
6639 
6640 #if ENABLE(IOS_TOUCH_EVENTS)
6641     if (addedOrRemoved) {
6642         if (isScrollable &amp;&amp; !canUseCompositedScrolling())
6643             registerAsTouchEventListenerForScrolling();
6644         else {
6645             // We only need the touch listener for unaccelerated overflow scrolling, so if we became
6646             // accelerated, remove ourselves as a touch event listener.
6647             unregisterAsTouchEventListenerForScrolling();
6648         }
6649     }
6650 #else
6651     UNUSED_VARIABLE(addedOrRemoved);
6652 #endif
6653 }
6654 
6655 void RenderLayer::updateScrollCornerStyle()
6656 {
6657     RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">6658     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;actualRenderer-&gt;style()) : nullptr;</span>
6659 
6660     if (!corner) {
6661         clearScrollCorner();
6662         return;
6663     }
6664 
6665     if (!m_scrollCorner) {
6666         m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*corner));
6667         // FIXME: A renderer should be a child of its parent!
6668         m_scrollCorner-&gt;setParent(&amp;renderer());
6669         m_scrollCorner-&gt;initializeStyle();
6670     } else
6671         m_scrollCorner-&gt;setStyle(WTFMove(*corner));
6672 }
6673 
6674 void RenderLayer::clearScrollCorner()
6675 {
6676     if (!m_scrollCorner)
6677         return;
6678     m_scrollCorner-&gt;setParent(nullptr);
6679     m_scrollCorner = nullptr;
6680 }
6681 
6682 void RenderLayer::updateResizerStyle()
6683 {
6684     RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">6685     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Resizer), &amp;actualRenderer-&gt;style()) : nullptr;</span>
6686 
6687     if (!resizer) {
6688         clearResizer();
6689         return;
6690     }
6691 
6692     if (!m_resizer) {
6693         m_resizer = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*resizer));
6694         // FIXME: A renderer should be a child of its parent!
6695         m_resizer-&gt;setParent(&amp;renderer());
6696         m_resizer-&gt;initializeStyle();
6697     } else
6698         m_resizer-&gt;setStyle(WTFMove(*resizer));
6699 }
6700 
6701 void RenderLayer::clearResizer()
6702 {
6703     if (!m_resizer)
6704         return;
6705     m_resizer-&gt;setParent(nullptr);
</pre>
<hr />
<pre>
6725     m_reflection-&gt;initializeStyle();
6726 }
6727 
6728 void RenderLayer::removeReflection()
6729 {
6730     if (!m_reflection-&gt;renderTreeBeingDestroyed())
6731         m_reflection-&gt;removeLayers(this);
6732 
6733     m_reflection-&gt;setParent(nullptr);
6734     m_reflection = nullptr;
6735 }
6736 
6737 RenderStyle RenderLayer::createReflectionStyle()
6738 {
6739     auto newStyle = RenderStyle::create();
6740     newStyle.inheritFrom(renderer().style());
6741 
6742     // Map in our transform.
6743     TransformOperations transform;
6744     switch (renderer().style().boxReflect()-&gt;direction()) {
<span class="line-modified">6745         case ReflectionBelow:</span>
<span class="line-modified">6746             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6747             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6748             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6749             break;</span>
<span class="line-modified">6750         case ReflectionAbove:</span>
<span class="line-modified">6751             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6752             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6753             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6754             break;</span>
<span class="line-modified">6755         case ReflectionRight:</span>
<span class="line-modified">6756             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6757             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6758             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6759             break;</span>
<span class="line-modified">6760         case ReflectionLeft:</span>
<span class="line-modified">6761             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6762             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6763             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6764             break;</span>
6765     }
6766     newStyle.setTransform(transform);
6767 
6768     // Map in our mask.
6769     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6770 
6771     // Style has transform and mask, so needs to be stacking context.
<span class="line-modified">6772     newStyle.setZIndex(0);</span>
6773 
6774     return newStyle;
6775 }
6776 
6777 void RenderLayer::ensureLayerFilters()
6778 {
6779     if (m_filters)
6780         return;
6781 
6782     m_filters = makeUnique&lt;RenderLayerFilters&gt;(*this);
6783 }
6784 
6785 void RenderLayer::clearLayerFilters()
6786 {
6787     m_filters = nullptr;
6788 }
6789 
6790 void RenderLayer::updateFiltersAfterStyleChange()
6791 {
6792     if (!hasFilter()) {
</pre>
<hr />
<pre>
6805 
6806 void RenderLayer::updateFilterPaintingStrategy()
6807 {
6808     // RenderLayerFilters is only used to render the filters in software mode,
6809     // so we always need to run updateFilterPaintingStrategy() after the composited
6810     // mode might have changed for this layer.
6811     if (!paintsWithFilters()) {
6812         // Don&#39;t delete the whole filter info here, because we might use it
6813         // for loading SVG reference filter files.
6814         if (m_filters)
6815             m_filters-&gt;setFilter(nullptr);
6816 
6817         // Early-return only if we *don&#39;t* have reference filters.
6818         // For reference filters, we still want the FilterEffect graph built
6819         // for us, even if we&#39;re composited.
6820         if (!renderer().style().filter().hasReferenceFilter())
6821             return;
6822     }
6823 
6824     ensureLayerFilters();
<span class="line-modified">6825     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? Accelerated : Unaccelerated);</span>
6826 }
6827 
6828 void RenderLayer::filterNeedsRepaint()
6829 {
6830     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
6831     if (Element* element = enclosingElement()) {
6832         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.
6833         element-&gt;invalidateStyleAndLayerComposition();
6834     }
6835     renderer().repaint();
6836 }
6837 
<span class="line-modified">6838 bool RenderLayer::isTransparentOrFullyClippedRespectingParentFrames() const</span>







6839 {
6840     static const double minimumVisibleOpacity = 0.01;
6841 
6842     float currentOpacity = 1;
6843     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
6844         currentOpacity *= layer-&gt;renderer().style().opacity();
6845         if (currentOpacity &lt; minimumVisibleOpacity)
6846             return true;
6847     }
6848 
<span class="line-removed">6849     auto hasEmptyClipRect = [] (const RenderLayer&amp; layer) -&gt; bool {</span>
<span class="line-removed">6850         auto* frameView = layer.renderer().document().view();</span>
<span class="line-removed">6851         if (!frameView)</span>
<span class="line-removed">6852             return false;</span>
<span class="line-removed">6853 </span>
<span class="line-removed">6854         auto* renderView = frameView-&gt;renderView();</span>
<span class="line-removed">6855         if (!renderView)</span>
<span class="line-removed">6856             return false;</span>
<span class="line-removed">6857 </span>
<span class="line-removed">6858         auto* renderViewLayer = renderView-&gt;layer();</span>
<span class="line-removed">6859         if (!renderViewLayer)</span>
<span class="line-removed">6860             return false;</span>
<span class="line-removed">6861 </span>
<span class="line-removed">6862         if (is&lt;HTMLFrameOwnerElement&gt;(layer.renderer().element()) &amp;&amp; layer.visibleSize().isEmpty())</span>
<span class="line-removed">6863             return true;</span>
<span class="line-removed">6864 </span>
<span class="line-removed">6865         LayoutRect layerBounds;</span>
<span class="line-removed">6866         ClipRect backgroundRect;</span>
<span class="line-removed">6867         ClipRect foregroundRect;</span>
<span class="line-removed">6868         layer.calculateRects({ renderViewLayer, TemporaryClipRects }, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, layer.offsetFromAncestor(renderViewLayer));</span>
<span class="line-removed">6869         return backgroundRect.isEmpty();</span>
<span class="line-removed">6870     };</span>
<span class="line-removed">6871 </span>
<span class="line-removed">6872     for (auto* layer = this; layer; layer = enclosingFrameRenderLayer(*layer)) {</span>
<span class="line-removed">6873         if (hasEmptyClipRect(*layer))</span>
<span class="line-removed">6874             return true;</span>
<span class="line-removed">6875     }</span>
<span class="line-removed">6876 </span>
6877     return false;
6878 }
6879 
6880 void RenderLayer::invalidateEventRegion()
6881 {
6882 #if PLATFORM(IOS_FAMILY)
6883     auto* compositingLayer = enclosingCompositingLayerForRepaint();
6884     if (!compositingLayer)
6885         return;
6886 
6887     auto maintainsEventRegion = [&amp;] {
6888         // UI side scroll overlap testing.
6889         if (!compositingLayer-&gt;isRenderViewLayer())
6890             return true;
6891 #if ENABLE(POINTER_EVENTS)
6892         // UI side touch-action resolution.
6893         if (renderer().document().mayHaveElementsWithNonAutoTouchAction())
6894             return true;
6895 #endif
6896         return false;
</pre>
<hr />
<pre>
6932     if (layer.isolatesBlending())
6933         ts &lt;&lt; &quot; isolates blending&quot;;
6934     if (layer.isComposited())
6935         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
6936     return ts;
6937 }
6938 
6939 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer::ClipRectsContext&amp; context)
6940 {
6941     ts.dumpProperty(&quot;root layer:&quot;, context.rootLayer);
6942     ts.dumpProperty(&quot;type:&quot;, context.clipRectsType);
6943     ts.dumpProperty(&quot;overflow-clip:&quot;, context.respectOverflowClip == IgnoreOverflowClip ? &quot;ignore&quot; : &quot;respect&quot;);
6944 
6945     return ts;
6946 }
6947 
6948 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)
6949 {
6950     switch (reason) {
6951     case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;

6952     case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;
6953     case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;
6954     case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;
6955     case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;
6956     case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;
6957     case IndirectCompositingReason::Perspective: ts &lt;&lt; &quot;perspective&quot;; break;
6958     case IndirectCompositingReason::Preserve3D: ts &lt;&lt; &quot;preserve-3d&quot;; break;
6959     }
6960 
6961     return ts;
6962 }
6963 
6964 } // namespace WebCore
6965 
6966 #if ENABLE(TREE_DEBUGGING)
6967 
6968 void showLayerTree(const WebCore::RenderLayer* layer)
6969 {
6970     if (!layer)
6971         return;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
<span class="line-added">   3  * Copyright (C) 2019 Adobe. All rights reserved.</span>
   4  *
   5  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   6  *
   7  * Other contributors:
   8  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   9  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
  10  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  11  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  12  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  13  *   Josh Soref &lt;timeless@mac.com&gt;
  14  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Lesser General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2.1 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</pre>
<hr />
<pre>
  36  * version of this file only under the terms of one of those two
  37  * licenses (the MPL or the GPL) and not to allow others to use your
  38  * version of this file under the LGPL, indicate your decision by
  39  * deletingthe provisions above and replace them with the notice and
  40  * other provisions required by the MPL or the GPL, as the case may be.
  41  * If you do not delete the provisions above, a recipient may use your
  42  * version of this file under any of the LGPL, the MPL or the GPL.
  43  */
  44 
  45 #include &quot;config.h&quot;
  46 #include &quot;RenderLayer.h&quot;
  47 
  48 #include &quot;BoxShape.h&quot;
  49 #include &quot;CSSAnimationController.h&quot;
  50 #include &quot;CSSFilter.h&quot;
  51 #include &quot;CSSPropertyNames.h&quot;
  52 #include &quot;Chrome.h&quot;
  53 #include &quot;DebugPageOverlays.h&quot;
  54 #include &quot;DeprecatedGlobalSettings.h&quot;
  55 #include &quot;Document.h&quot;

  56 #include &quot;DocumentMarkerController.h&quot;
  57 #include &quot;DocumentTimeline.h&quot;
<span class="line-added">  58 #include &quot;Editor.h&quot;</span>
  59 #include &quot;Element.h&quot;
  60 #include &quot;EventHandler.h&quot;
  61 #include &quot;FEColorMatrix.h&quot;
  62 #include &quot;FEMerge.h&quot;
  63 #include &quot;FloatConversion.h&quot;
  64 #include &quot;FloatPoint3D.h&quot;
  65 #include &quot;FloatRect.h&quot;
  66 #include &quot;FloatRoundedRect.h&quot;
  67 #include &quot;FocusController.h&quot;
  68 #include &quot;Frame.h&quot;
  69 #include &quot;FrameLoader.h&quot;
  70 #include &quot;FrameLoaderClient.h&quot;
  71 #include &quot;FrameSelection.h&quot;
  72 #include &quot;FrameTree.h&quot;
  73 #include &quot;FrameView.h&quot;
  74 #include &quot;Gradient.h&quot;
  75 #include &quot;GraphicsContext.h&quot;
  76 #include &quot;HTMLFormControlElement.h&quot;
  77 #include &quot;HTMLFrameElement.h&quot;
  78 #include &quot;HTMLFrameOwnerElement.h&quot;
</pre>
<hr />
<pre>
 108 #include &quot;RenderTableRow.h&quot;
 109 #include &quot;RenderText.h&quot;
 110 #include &quot;RenderTheme.h&quot;
 111 #include &quot;RenderTreeAsText.h&quot;
 112 #include &quot;RenderView.h&quot;
 113 #include &quot;RuntimeEnabledFeatures.h&quot;
 114 #include &quot;SVGNames.h&quot;
 115 #include &quot;ScaleTransformOperation.h&quot;
 116 #include &quot;ScriptDisallowedScope.h&quot;
 117 #include &quot;ScrollAnimator.h&quot;
 118 #include &quot;Scrollbar.h&quot;
 119 #include &quot;ScrollbarTheme.h&quot;
 120 #include &quot;ScrollingCoordinator.h&quot;
 121 #include &quot;Settings.h&quot;
 122 #include &quot;ShadowRoot.h&quot;
 123 #include &quot;SourceGraphic.h&quot;
 124 #include &quot;StyleProperties.h&quot;
 125 #include &quot;StyleResolver.h&quot;
 126 #include &quot;TransformationMatrix.h&quot;
 127 #include &quot;TranslateTransformOperation.h&quot;
<span class="line-modified"> 128 #include &quot;WheelEventTestMonitor.h&quot;</span>
 129 #include &lt;stdio.h&gt;
 130 #include &lt;wtf/MonotonicTime.h&gt;
 131 #include &lt;wtf/StdLibExtras.h&gt;
 132 #include &lt;wtf/text/CString.h&gt;
 133 #include &lt;wtf/text/TextStream.h&gt;
 134 
 135 #if ENABLE(CSS_SCROLL_SNAP)
 136 #include &quot;AxisScrollSnapOffsets.h&quot;
 137 #endif
 138 
 139 #define MIN_INTERSECT_FOR_REVEAL 32
 140 
 141 namespace WebCore {
 142 
 143 using namespace HTMLNames;
 144 
 145 class ClipRects : public RefCounted&lt;ClipRects&gt; {
 146     WTF_MAKE_FAST_ALLOCATED;
 147 public:
 148     static Ref&lt;ClipRects&gt; create()
</pre>
<hr />
<pre>
 205     ClipRects(const ClipRects&amp; other)
 206         : RefCounted()
 207         , m_fixed(other.fixed())
 208         , m_overflowClipRect(other.overflowClipRect())
 209         , m_fixedClipRect(other.fixedClipRect())
 210         , m_posClipRect(other.posClipRect())
 211     {
 212     }
 213 
 214     bool m_fixed { false };
 215     ClipRect m_overflowClipRect;
 216     ClipRect m_fixedClipRect;
 217     ClipRect m_posClipRect;
 218 };
 219 
 220 class ClipRectsCache {
 221     WTF_MAKE_FAST_ALLOCATED;
 222 public:
 223     ClipRectsCache()
 224     {
<span class="line-modified"> 225 #if ASSERT_ENABLED</span>
 226         for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
 227             m_clipRectsRoot[i] = 0;
 228             m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
 229         }
 230 #endif
 231     }
 232 
 233     ClipRects* getClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 234     {
 235         return m_clipRects[getIndex(clipRectsType, respectOverflow)].get();
 236     }
 237 
 238     void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
 239     {
 240         m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
 241     }
 242 
<span class="line-modified"> 243 #if ASSERT_ENABLED</span>
 244     const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
 245     OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
 246 #endif
 247 
 248 private:
 249     unsigned getIndex(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 250     {
 251         unsigned index = static_cast&lt;unsigned&gt;(clipRectsType);
 252         if (respectOverflow == RespectOverflowClip)
 253             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 254         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 255         return index;
 256     }
 257 
 258     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 259 };
 260 
 261 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 262 {
 263 #if !ENABLE(3D_TRANSFORMS)
</pre>
<hr />
<pre>
 266 #else
 267     if (!has3DRendering)
 268         matrix.makeAffine();
 269 #endif
 270 }
 271 
 272 #if !LOG_DISABLED
 273 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipRects&amp; clipRects)
 274 {
 275     TextStream::GroupScope scope(ts);
 276     ts &lt;&lt; indent &lt;&lt; &quot;ClipRects\n&quot;;
 277     ts &lt;&lt; indent &lt;&lt; &quot;  overflow  : &quot; &lt;&lt; clipRects.overflowClipRect() &lt;&lt; &quot;\n&quot;;
 278     ts &lt;&lt; indent &lt;&lt; &quot;  fixed     : &quot; &lt;&lt; clipRects.fixedClipRect() &lt;&lt; &quot;\n&quot;;
 279     ts &lt;&lt; indent &lt;&lt; &quot;  positioned: &quot; &lt;&lt; clipRects.posClipRect() &lt;&lt; &quot;\n&quot;;
 280 
 281     return ts;
 282 }
 283 
 284 #endif
 285 
<span class="line-added"> 286 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
<span class="line-added"> 287 </span>
 288 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 289     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 290     , m_forcedStackingContext(rendererLayerModelObject.isMedia())
<span class="line-added"> 291     , m_isNormalFlowOnly(false)</span>
<span class="line-added"> 292     , m_isCSSStackingContext(false)</span>
 293     , m_isOpportunisticStackingContext(false)
 294     , m_zOrderListsDirty(false)
 295     , m_normalFlowListDirty(true)
 296     , m_hadNegativeZOrderList(false)
 297     , m_inResizeMode(false)
 298     , m_scrollDimensionsDirty(true)
 299     , m_hasSelfPaintingLayerDescendant(false)
 300     , m_hasSelfPaintingLayerDescendantDirty(false)
 301     , m_usedTransparency(false)
 302     , m_paintingInsideReflection(false)
 303     , m_inOverflowRelayout(false)
 304     , m_repaintStatus(NeedsNormalRepaint)
 305     , m_visibleContentStatusDirty(true)
 306     , m_hasVisibleContent(false)
 307     , m_visibleDescendantStatusDirty(false)
 308     , m_hasVisibleDescendant(false)
 309     , m_registeredScrollableArea(false)
 310     , m_isFixedIntersectingViewport(false)
 311     , m_behavesAsFixed(false)
 312     , m_3DTransformedDescendantStatusDirty(true)
 313     , m_has3DTransformedDescendant(false)
 314     , m_hasCompositingDescendant(false)
 315     , m_hasCompositedScrollingAncestor(false)
 316     , m_hasCompositedScrollableOverflow(false)
 317     , m_hasTransformedAncestor(false)
 318     , m_has3DTransformedAncestor(false)
 319     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 320     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 321 #if PLATFORM(IOS_FAMILY)
 322 #if ENABLE(IOS_TOUCH_EVENTS)
 323     , m_registeredAsTouchEventListenerForScrolling(false)
 324 #endif
 325     , m_adjustForIOSCaretWhenScrolling(false)
 326 #endif
 327     , m_requiresScrollPositionReconciliation(false)
 328     , m_containsDirtyOverlayScrollbars(false)
 329     , m_updatingMarqueePosition(false)
<span class="line-modified"> 330 #if ASSERT_ENABLED</span>
 331     , m_layerListMutationAllowed(true)
 332 #endif
 333 #if ENABLE(CSS_COMPOSITING)
 334     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 335     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 336     , m_hasNotIsolatedBlendingDescendants(false)
 337     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 338 #endif
 339     , m_renderer(rendererLayerModelObject)
 340 {
 341     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
 342     setIsCSSStackingContext(shouldBeCSSStackingContext());
 343 
 344     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 345 
 346     if (!renderer().firstChild()) {
 347         m_visibleContentStatusDirty = false;
 348         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 349     }
 350 
</pre>
<hr />
<pre>
 482 
 483 #if ENABLE(CSS_COMPOSITING)
 484     if (oldChild.hasBlendMode() || (oldChild.hasNotIsolatedBlendingDescendants() &amp;&amp; !oldChild.isolatesBlending()))
 485         dirtyAncestorChainHasBlendingDescendants();
 486 #endif
 487 }
 488 
 489 void RenderLayer::dirtyPaintOrderListsOnChildChange(RenderLayer&amp; child)
 490 {
 491     if (child.isNormalFlowOnly())
 492         dirtyNormalFlowList();
 493 
 494     if (!child.isNormalFlowOnly() || child.firstChild()) {
 495         // Dirty the z-order list in which we are contained. The stackingContext() can be null in the
 496         // case where we&#39;re building up generated content layers. This is ok, since the lists will start
 497         // off dirty in that case anyway.
 498         child.dirtyStackingContextZOrderLists();
 499     }
 500 }
 501 
<span class="line-modified"> 502 void RenderLayer::insertOnlyThisLayer(LayerChangeTiming timing)</span>
 503 {
 504     if (!m_parent &amp;&amp; renderer().parent()) {
 505         // We need to connect ourselves when our renderer() has a parent.
 506         // Find our enclosingLayer and add ourselves.
 507         RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
 508         ASSERT(parentLayer);
 509         RenderLayer* beforeChild = parentLayer-&gt;reflectionLayer() != this ? renderer().parent()-&gt;findNextLayer(parentLayer, &amp;renderer()) : nullptr;
 510         parentLayer-&gt;addChild(*this, beforeChild);
 511     }
 512 
 513     // Remove all descendant layers from the hierarchy and add them to the new position.
 514     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
 515         child.moveLayers(m_parent, this);
 516 
<span class="line-added"> 517     if (parent()) {</span>
<span class="line-added"> 518         if (timing == LayerChangeTiming::StyleChange)</span>
<span class="line-added"> 519             renderer().view().layerChildrenChangedDuringStyleChange(*parent());</span>
<span class="line-added"> 520     }</span>
<span class="line-added"> 521 </span>
 522     // Clear out all the clip rects.
 523     clearClipRectsIncludingDescendants();
 524 }
 525 
<span class="line-modified"> 526 void RenderLayer::removeOnlyThisLayer(LayerChangeTiming timing)</span>
 527 {
 528     if (!m_parent)
 529         return;
 530 
<span class="line-added"> 531     if (timing == LayerChangeTiming::StyleChange)</span>
<span class="line-added"> 532         renderer().view().layerChildrenChangedDuringStyleChange(*parent());</span>
<span class="line-added"> 533 </span>
 534     // Mark that we are about to lose our layer. This makes render tree
 535     // walks ignore this layer while we&#39;re removing it.
 536     renderer().setHasLayer(false);
 537 
 538     compositor().layerWillBeRemoved(*m_parent, *this);
 539 
 540     // Dirty the clip rects.
 541     clearClipRectsIncludingDescendants();
 542 
 543     RenderLayer* nextSib = nextSibling();
 544 
 545     // Remove the child reflection layer before moving other child layers.
 546     // The reflection layer should not be moved to the parent.
 547     if (reflection())
 548         removeChild(*reflectionLayer());
 549 
 550     // Now walk our kids and reattach them to our parent.
 551     RenderLayer* current = m_first;
 552     while (current) {
 553         RenderLayer* next = current-&gt;nextSibling();
</pre>
<hr />
<pre>
 560     // Remove us from the parent.
 561     m_parent-&gt;removeChild(*this);
 562     renderer().destroyLayer();
 563 }
 564 
 565 static bool canCreateStackingContext(const RenderLayer&amp; layer)
 566 {
 567     auto&amp; renderer = layer.renderer();
 568     return renderer.hasTransformRelatedProperty()
 569         || renderer.hasClipPath()
 570         || renderer.hasFilter()
 571         || renderer.hasMask()
 572         || renderer.hasBackdropFilter()
 573 #if ENABLE(CSS_COMPOSITING)
 574         || renderer.hasBlendMode()
 575 #endif
 576         || renderer.isTransparent()
 577         || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
 578         || renderer.hasReflection()
 579         || renderer.style().hasIsolation()
<span class="line-modified"> 580         || !renderer.style().hasAutoUsedZIndex()</span>
 581         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 582 }
 583 
 584 bool RenderLayer::shouldBeNormalFlowOnly() const
 585 {
 586     if (canCreateStackingContext(*this))
 587         return false;
 588 
 589     return renderer().hasOverflowClip()
 590         || renderer().isCanvas()
 591         || renderer().isVideo()
 592         || renderer().isEmbeddedObject()
 593         || renderer().isRenderIFrame()
 594         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 595         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 596         || renderer().isInFlowRenderFragmentedFlow();
 597 }
 598 
 599 bool RenderLayer::shouldBeCSSStackingContext() const
 600 {
<span class="line-modified"> 601     return !renderer().style().hasAutoUsedZIndex() || isRenderViewLayer();</span>
 602 }
 603 
 604 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 605 {
 606     if (isNormalFlowOnly == m_isNormalFlowOnly)
 607         return false;
 608 
 609     m_isNormalFlowOnly = isNormalFlowOnly;
 610 
 611     if (auto* p = parent())
 612         p-&gt;dirtyNormalFlowList();
 613     dirtyStackingContextZOrderLists();
 614     return true;
 615 }
 616 
 617 void RenderLayer::isStackingContextChanged()
 618 {
 619     dirtyStackingContextZOrderLists();
 620     if (isStackingContext())
 621         dirtyZOrderLists();
</pre>
<hr />
<pre>
 709         return;
 710 
 711     ASSERT(layerListMutationAllowed());
 712 
 713     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 714         // Ignore non-overflow layers and reflections.
 715         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 716             if (!m_normalFlowList)
 717                 m_normalFlowList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 718             m_normalFlowList-&gt;append(child);
 719         }
 720     }
 721 
 722     m_normalFlowListDirty = false;
 723 }
 724 
 725 void RenderLayer::rebuildZOrderLists()
 726 {
 727     ASSERT(layerListMutationAllowed());
 728     ASSERT(isDirtyStackingContext());
<span class="line-modified"> 729 </span>
<span class="line-added"> 730     OptionSet&lt;Compositing&gt; childDirtyFlags;</span>
<span class="line-added"> 731     rebuildZOrderLists(m_posZOrderList, m_negZOrderList, childDirtyFlags);</span>
 732     m_zOrderListsDirty = false;
 733 
 734     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 735     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 736     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 737     // lists on dirtying so we don&#39;t know the old state.
 738     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 739         m_hadNegativeZOrderList = hasNegativeZOrderList;
 740         if (isComposited())
 741             setNeedsCompositingConfigurationUpdate();
 742     }
<span class="line-added"> 743 </span>
<span class="line-added"> 744     // Building lists may have added layers with dirty flags, so make sure we propagate dirty bits up the tree.</span>
<span class="line-added"> 745     if (m_compositingDirtyBits.containsAll({ Compositing::DescendantsNeedRequirementsTraversal, Compositing::DescendantsNeedBackingAndHierarchyTraversal }))</span>
<span class="line-added"> 746         return;</span>
<span class="line-added"> 747 </span>
<span class="line-added"> 748     if (childDirtyFlags.containsAny(computeCompositingRequirementsFlags()))</span>
<span class="line-added"> 749         setDescendantsNeedCompositingRequirementsTraversal();</span>
<span class="line-added"> 750 </span>
<span class="line-added"> 751     if (childDirtyFlags.containsAny(updateBackingOrHierarchyFlags()))</span>
<span class="line-added"> 752         setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
 753 }
 754 
<span class="line-modified"> 755 void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)</span>
 756 {
 757     bool includeHiddenLayers = compositor().usesCompositing();
 758     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 759         if (!isReflectionLayer(*child))
<span class="line-modified"> 760             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList, accumulatedDirtyFlags);</span>
 761     }
 762 
 763     auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
 764         return first-&gt;zIndex() &lt; second-&gt;zIndex();
 765     };
 766 
 767     // Sort the two lists.
 768     if (posZOrderList)
 769         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 770 
 771     if (negZOrderList)
 772         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 773 }
 774 
<span class="line-modified"> 775 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)</span>
 776 {
 777     updateDescendantDependentFlags();
 778 
 779     bool isStacking = isStackingContext();
 780     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 781     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 782     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 783         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 784         if (!layerList)
 785             layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 786         layerList-&gt;append(this);
<span class="line-added"> 787         accumulatedDirtyFlags.add(m_compositingDirtyBits);</span>
 788     }
 789 
 790     // Recur into our children to collect more layers, but only if we don&#39;t establish
 791     // a stacking context/container.
 792     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 793         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 794             // Ignore reflections.
 795             if (!isReflectionLayer(*child))
<span class="line-modified"> 796                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList, accumulatedDirtyFlags);</span>
 797         }
 798     }
 799 }
 800 
 801 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 802 {
 803     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 804         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 805             break;
 806         layer-&gt;m_compositingDirtyBits.add(flag);
 807     }
 808 }
 809 
 810 void RenderLayer::updateLayerListsIfNeeded()
 811 {
 812     updateZOrderLists();
 813     updateNormalFlowList();
 814 
 815     if (RenderLayer* reflectionLayer = this-&gt;reflectionLayer()) {
 816         reflectionLayer-&gt;updateZOrderLists();
</pre>
<hr />
<pre>
1251 
1252         if (layer-&gt;isCSSStackingContext())
1253             break;
1254     }
1255 }
1256 
1257 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1258 {
1259     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1260         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1261             break;
1262 
1263         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1264 
1265         if (layer-&gt;isCSSStackingContext())
1266             break;
1267     }
1268 }
1269 #endif
1270 
<span class="line-added">1271 static inline LayoutRect computeReferenceRectFromBox(const RenderBox&amp; box, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot)</span>
<span class="line-added">1272 {</span>
<span class="line-added">1273     LayoutRect referenceBox;</span>
<span class="line-added">1274     switch (boxType) {</span>
<span class="line-added">1275     case CSSBoxType::ContentBox:</span>
<span class="line-added">1276     case CSSBoxType::FillBox:</span>
<span class="line-added">1277         referenceBox = box.contentBoxRect();</span>
<span class="line-added">1278         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">1279         break;</span>
<span class="line-added">1280     case CSSBoxType::PaddingBox:</span>
<span class="line-added">1281         referenceBox = box.paddingBoxRect();</span>
<span class="line-added">1282         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">1283         break;</span>
<span class="line-added">1284     case CSSBoxType::MarginBox:</span>
<span class="line-added">1285         referenceBox = box.marginBoxRect();</span>
<span class="line-added">1286         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">1287         break;</span>
<span class="line-added">1288     // stroke-box, view-box compute to border-box for HTML elements.</span>
<span class="line-added">1289     case CSSBoxType::StrokeBox:</span>
<span class="line-added">1290     case CSSBoxType::ViewBox:</span>
<span class="line-added">1291     case CSSBoxType::BorderBox:</span>
<span class="line-added">1292     case CSSBoxType::BoxMissing:</span>
<span class="line-added">1293         referenceBox = box.borderBoxRect();</span>
<span class="line-added">1294         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">1295         break;</span>
<span class="line-added">1296     }</span>
<span class="line-added">1297 </span>
<span class="line-added">1298     return referenceBox;</span>
<span class="line-added">1299 }</span>
<span class="line-added">1300 </span>
<span class="line-added">1301 static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)</span>
<span class="line-added">1302 {</span>
<span class="line-added">1303     // FIXME: Support different reference boxes for inline content.</span>
<span class="line-added">1304     // https://bugs.webkit.org/show_bug.cgi?id=129047</span>
<span class="line-added">1305     if (!renderer.isBox())</span>
<span class="line-added">1306         return rootRelativeBounds;</span>
<span class="line-added">1307 </span>
<span class="line-added">1308     return computeReferenceRectFromBox(downcast&lt;RenderBox&gt;(renderer), boxType, offsetFromRoot);</span>
<span class="line-added">1309 }</span>
<span class="line-added">1310 </span>
<span class="line-added">1311 static inline CSSBoxType transformBoxToCSSBoxType(TransformBox transformBox)</span>
<span class="line-added">1312 {</span>
<span class="line-added">1313     switch (transformBox) {</span>
<span class="line-added">1314     case TransformBox::StrokeBox:</span>
<span class="line-added">1315         return CSSBoxType::StrokeBox;</span>
<span class="line-added">1316     case TransformBox::ContentBox:</span>
<span class="line-added">1317         return CSSBoxType::ContentBox;</span>
<span class="line-added">1318     case TransformBox::BorderBox:</span>
<span class="line-added">1319         return CSSBoxType::BorderBox;</span>
<span class="line-added">1320     case TransformBox::FillBox:</span>
<span class="line-added">1321         return CSSBoxType::FillBox;</span>
<span class="line-added">1322     case TransformBox::ViewBox:</span>
<span class="line-added">1323         return CSSBoxType::ViewBox;</span>
<span class="line-added">1324     default:</span>
<span class="line-added">1325         ASSERT_NOT_REACHED();</span>
<span class="line-added">1326         return CSSBoxType::BorderBox;</span>
<span class="line-added">1327     }</span>
<span class="line-added">1328 }</span>
<span class="line-added">1329 </span>
1330 void RenderLayer::updateTransform()
1331 {
1332     bool hasTransform = renderer().hasTransform();
1333     bool had3DTransform = has3DTransform();
1334 
1335     bool hadTransform = !!m_transform;
1336     if (hasTransform != hadTransform) {
1337         if (hasTransform)
1338             m_transform = makeUnique&lt;TransformationMatrix&gt;();
1339         else
1340             m_transform = nullptr;
1341 
1342         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1343         clearClipRectsIncludingDescendants();
1344     }
1345 
1346     if (hasTransform) {
1347         RenderBox* box = renderBox();
1348         ASSERT(box);
1349         m_transform-&gt;makeIdentity();
<span class="line-modified">1350         LayoutSize offsetFromRoot;</span>
<span class="line-added">1351         auto computedReferenceBox = computeReferenceRectFromBox(*box, transformBoxToCSSBoxType(box-&gt;style().transformBox()), offsetFromRoot);</span>
<span class="line-added">1352         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);</span>
1353         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1354     }
1355 
1356     if (had3DTransform != has3DTransform()) {
1357         dirty3DTransformedDescendantStatus();
1358         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1359         setNeedsPostLayoutCompositingUpdateOnAncestors();
1360     }
1361 }
1362 
1363 TransformationMatrix RenderLayer::currentTransform(RenderStyle::ApplyTransformOrigin applyOrigin) const
1364 {
1365     if (!m_transform)
1366         return TransformationMatrix();
1367 
1368     RenderBox* box = renderBox();
1369 
1370     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1371         if (auto* timeline = renderer().documentTimeline()) {
1372             if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1373                 TransformationMatrix currTransform;
<span class="line-modified">1374                 LayoutSize offsetFromRoot;</span>
1375                 std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());
<span class="line-added">1376                 auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());</span>
<span class="line-added">1377                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());</span>
1378                 style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1379                 makeMatrixRenderable(currTransform, canRender3DTransforms());
1380                 return currTransform;
1381             }
1382         }
1383     } else {
1384         if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1385             TransformationMatrix currTransform;

1386             std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
<span class="line-added">1387             LayoutSize offsetFromRoot;</span>
<span class="line-added">1388             auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());</span>
<span class="line-added">1389             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());</span>
1390             style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1391             makeMatrixRenderable(currTransform, canRender3DTransforms());
1392             return currTransform;
1393         }
1394     }
1395 
1396 
1397     // m_transform includes transform-origin, so we need to recompute the transform here.
1398     if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
1399         TransformationMatrix currTransform;
<span class="line-modified">1400         LayoutSize offsetFromRoot;</span>
<span class="line-added">1401         std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());</span>
<span class="line-added">1402         auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());</span>
<span class="line-added">1403         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());</span>
1404         box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
1405         makeMatrixRenderable(currTransform, canRender3DTransforms());
1406         return currTransform;
1407     }
1408 
1409     return *m_transform;
1410 }
1411 
1412 TransformationMatrix RenderLayer::renderableTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
1413 {
1414     if (!m_transform)
1415         return TransformationMatrix();
1416 
1417     if (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) {
1418         TransformationMatrix matrix = *m_transform;
1419         makeMatrixRenderable(matrix, false /* flatten 3d */);
1420         return matrix;
1421     }
1422 
1423     return *m_transform;
</pre>
<hr />
<pre>
2005 
2006 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
2007 {
2008     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
2009         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
2010             return const_cast&lt;RenderLayer*&gt;(curr);
2011     }
2012     return nullptr;
2013 }
2014 
2015 // FIXME: This neeeds a better name.
2016 void RenderLayer::setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp; rect)
2017 {
2018     ASSERT(requiresFullLayerImageForFilters());
2019     ASSERT(m_filters);
2020 
2021     if (rect.isEmpty())
2022         return;
2023 
2024     LayoutRect rectForRepaint = rect;
<span class="line-modified">2025     rectForRepaint += filterOutsets();</span>
2026 
2027     m_filters-&gt;expandDirtySourceRect(rectForRepaint);
2028 
2029     RenderLayer* parentLayer = enclosingFilterRepaintLayer();
2030     ASSERT(parentLayer);
2031     FloatQuad repaintQuad(rectForRepaint);
2032     LayoutRect parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
2033 
2034     if (parentLayer-&gt;isComposited()) {
2035         if (!parentLayer-&gt;backing()-&gt;paintsIntoWindow()) {
2036             parentLayer-&gt;setBackingNeedsRepaintInRect(parentLayerRect);
2037             return;
2038         }
2039         // If the painting goes to window, redirect the painting to the parent RenderView.
2040         parentLayer = renderer().view().layer();
2041         parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
2042     }
2043 
2044     if (parentLayer-&gt;paintsWithFilters()) {
2045         parentLayer-&gt;setFilterBackendNeedsRepaintingInRect(parentLayerRect);
2046         return;
2047     }
2048 
2049     if (parentLayer-&gt;isRenderViewLayer()) {
2050         downcast&lt;RenderView&gt;(parentLayer-&gt;renderer()).repaintViewRectangle(parentLayerRect);
2051         return;
2052     }
2053 
2054     ASSERT_NOT_REACHED();
2055 }
2056 
2057 bool RenderLayer::hasAncestorWithFilterOutsets() const
2058 {
2059     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
<span class="line-modified">2060         if (curr-&gt;hasFilterOutsets())</span>
2061             return true;
2062     }
2063     return false;
2064 }
2065 
2066 RenderLayer* RenderLayer::clippingRootForPainting() const
2067 {
2068     if (isComposited())
2069         return const_cast&lt;RenderLayer*&gt;(this);
2070 
2071     if (paintsIntoProvidedBacking())
2072         return backingProviderLayer();
2073 
2074     const RenderLayer* current = this;
2075     while (current) {
2076         if (current-&gt;isRenderViewLayer())
2077             return const_cast&lt;RenderLayer*&gt;(current);
2078 
2079         current = current-&gt;paintOrderParent();
2080         ASSERT(current);
</pre>
<hr />
<pre>
2163     // paintDirtyRect, and that should cut down on the amount we have to paint.  Still it
2164     // would be better to respect clips.
2165 
2166     if (rootLayer != &amp;layer &amp;&amp; ((transparencyBehavior == PaintingTransparencyClipBox &amp;&amp; layer.paintsWithTransform(paintBehavior))
2167         || (transparencyBehavior == HitTestingTransparencyClipBox &amp;&amp; layer.hasTransform()))) {
2168         // The best we can do here is to use enclosed bounding boxes to establish a &quot;fuzzy&quot; enough clip to encompass
2169         // the transformed layer and all of its children.
2170         RenderLayer::PaginationInclusionMode mode = transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::IncludeCompositedPaginatedLayers : RenderLayer::ExcludeCompositedPaginatedLayers;
2171         const RenderLayer* paginationLayer = transparencyMode == DescendantsOfTransparencyClipBox ? layer.enclosingPaginationLayer(mode) : nullptr;
2172         const RenderLayer* rootLayerForTransform = paginationLayer ? paginationLayer : rootLayer;
2173         LayoutSize delta = layer.offsetFromAncestor(rootLayerForTransform);
2174 
2175         TransformationMatrix transform;
2176         transform.translate(delta.width(), delta.height());
2177         transform.multiply(*layer.transform());
2178 
2179         // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
2180         // paints unfragmented.
2181         LayoutRect clipRect = layer.boundingBox(&amp;layer);
2182         expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
<span class="line-modified">2183         clipRect += layer.filterOutsets();</span>
2184         LayoutRect result = transform.mapRect(clipRect);
2185         if (!paginationLayer)
2186             return result;
2187 
2188         // We have to break up the transformed extent across our columns.
2189         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
2190         // get our true bounding box.
2191         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
2192         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
2193         result.move(paginationLayer-&gt;offsetFromAncestor(rootLayer));
2194         return result;
2195     }
2196 
2197     LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
2198     expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
<span class="line-modified">2199     clipRect += layer.filterOutsets();</span>
2200 
2201     return clipRect;
2202 }
2203 
2204 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2205 {
2206     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
2207 }
2208 
2209 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
2210 {
2211     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
2212         return;
2213 
2214     RenderLayer* ancestor = transparentPaintingAncestor();
2215     if (ancestor)
2216         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
2217 
2218     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
2219         ASSERT(isCSSStackingContext());
</pre>
<hr />
<pre>
2244     }
2245 }
2246 
2247 #if PLATFORM(IOS_FAMILY)
2248 void RenderLayer::willBeDestroyed()
2249 {
2250     if (RenderLayerBacking* layerBacking = backing())
2251         layerBacking-&gt;layerWillBeDestroyed();
2252 }
2253 #endif
2254 
2255 bool RenderLayer::isDescendantOf(const RenderLayer&amp; layer) const
2256 {
2257     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parent()) {
2258         if (&amp;layer == ancestor)
2259             return true;
2260     }
2261     return false;
2262 }
2263 
<span class="line-added">2264 static RenderLayer* findCommonAncestor(const RenderLayer&amp; firstLayer, const RenderLayer&amp; secondLayer)</span>
<span class="line-added">2265 {</span>
<span class="line-added">2266     if (&amp;firstLayer == &amp;secondLayer)</span>
<span class="line-added">2267         return const_cast&lt;RenderLayer*&gt;(&amp;firstLayer);</span>
<span class="line-added">2268 </span>
<span class="line-added">2269     HashSet&lt;const RenderLayer*&gt; ancestorChain;</span>
<span class="line-added">2270     for (auto* currLayer = &amp;firstLayer; currLayer; currLayer = currLayer-&gt;parent())</span>
<span class="line-added">2271         ancestorChain.add(currLayer);</span>
<span class="line-added">2272 </span>
<span class="line-added">2273     for (auto* currLayer = &amp;secondLayer; currLayer; currLayer = currLayer-&gt;parent()) {</span>
<span class="line-added">2274         if (ancestorChain.contains(currLayer))</span>
<span class="line-added">2275             return const_cast&lt;RenderLayer*&gt;(currLayer);</span>
<span class="line-added">2276     }</span>
<span class="line-added">2277     return nullptr;</span>
<span class="line-added">2278 }</span>
<span class="line-added">2279 </span>
<span class="line-added">2280 RenderLayer* RenderLayer::commonAncestorWithLayer(const RenderLayer&amp; layer) const</span>
<span class="line-added">2281 {</span>
<span class="line-added">2282     return findCommonAncestor(*this, layer);</span>
<span class="line-added">2283 }</span>
<span class="line-added">2284 </span>
2285 void RenderLayer::convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; roundedLocation, ColumnOffsetAdjustment adjustForColumns) const
2286 {
2287     LayoutPoint location = convertToLayerCoords(ancestorLayer, roundedLocation, adjustForColumns);
2288     roundedLocation = roundedIntPoint(location);
2289 }
2290 
2291 // Returns the layer reached on the walk up towards the ancestor.
2292 static inline const RenderLayer* accumulateOffsetTowardsAncestor(const RenderLayer* layer, const RenderLayer* ancestorLayer, LayoutPoint&amp; location, RenderLayer::ColumnOffsetAdjustment adjustForColumns)
2293 {
2294     ASSERT(ancestorLayer != layer);
2295 
2296     const RenderLayerModelObject&amp; renderer = layer-&gt;renderer();
2297     auto position = renderer.style().position();
2298 
2299     // FIXME: Special casing RenderFragmentedFlow so much for fixed positioning here is not great.
2300     RenderFragmentedFlow* fixedFragmentedFlowContainer = position == PositionType::Fixed ? renderer.enclosingFragmentedFlow() : nullptr;
2301     if (fixedFragmentedFlowContainer &amp;&amp; !fixedFragmentedFlowContainer-&gt;isOutOfFlowPositioned())
2302         fixedFragmentedFlowContainer = nullptr;
2303 
2304     // FIXME: Positioning of out-of-flow(fixed, absolute) elements collected in a RenderFragmentedFlow
</pre>
<hr />
<pre>
2579     m_postLayoutScrollPosition = WTF::nullopt;
2580 }
2581 
2582 void RenderLayer::scrollToXPosition(int x, ScrollType scrollType, ScrollClamping clamping)
2583 {
2584     ScrollPosition position(x, m_scrollPosition.y());
2585     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2586 }
2587 
2588 void RenderLayer::scrollToYPosition(int y, ScrollType scrollType, ScrollClamping clamping)
2589 {
2590     ScrollPosition position(m_scrollPosition.x(), y);
2591     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2592 }
2593 
2594 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2595 {
2596     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2597 }
2598 
<span class="line-added">2599 bool RenderLayer::requestScrollPositionUpdate(const ScrollPosition&amp; position, ScrollType scrollType, ScrollClamping clamping)</span>
<span class="line-added">2600 {</span>
<span class="line-added">2601 #if ENABLE(ASYNC_SCROLLING)</span>
<span class="line-added">2602     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())</span>
<span class="line-added">2603         return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position, scrollType, clamping);</span>
<span class="line-added">2604 #endif</span>
<span class="line-added">2605     return false;</span>
<span class="line-added">2606 }</span>
<span class="line-added">2607 </span>
2608 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)
2609 {
2610     ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;
2611     if (clampedScrollOffset == this-&gt;scrollOffset())
2612         return;
2613 
2614     auto previousScrollType = currentScrollType();
2615     setCurrentScrollType(scrollType);
2616 
<span class="line-modified">2617     if (!requestScrollPositionUpdate(scrollPositionFromOffset(clampedScrollOffset), scrollType, clamping))</span>






2618         scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);
2619 
2620     setCurrentScrollType(previousScrollType);
2621 }
2622 
2623 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2624 {
2625     RenderBox* box = renderBox();
2626     if (!box)
2627         return;
2628 
2629     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (is user scroll &quot; &lt;&lt; (currentScrollType() == ScrollType::User) &lt;&lt; &quot;)&quot;);
2630 
2631     ScrollPosition newPosition = position;
2632     if (!box-&gt;isHTMLMarquee()) {
2633         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2634         if (m_scrollDimensionsDirty)
2635             computeScrollDimensions();
2636 #if PLATFORM(IOS_FAMILY)
2637         if (adjustForIOSCaretWhenScrolling()) {
</pre>
<hr />
<pre>
2704     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2705 
2706     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2707     if (repaintContainer)
2708         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2709     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2710 
2711     bool requiresRepaint = true;
2712     if (usesCompositedScrolling()) {
2713         setNeedsCompositingGeometryUpdate();
2714         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2715         requiresRepaint = false;
2716     }
2717 
2718     // Just schedule a full repaint of our object.
2719     if (requiresRepaint)
2720         renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
2721 
2722     // Schedule the scroll and scroll-related DOM events.
2723     if (Element* element = renderer().element())
<span class="line-modified">2724         element-&gt;document().addPendingScrollEventTarget(*element);</span>
2725 
2726     if (scrollsOverflow())
2727         view.frameView().didChangeScrollOffset();
2728 
2729     view.frameView().viewportContentsChanged();
<span class="line-added">2730     frame.editor().renderLayerDidScroll(*this);</span>
2731 }
2732 
2733 static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
2734 {
2735     // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
2736     if (frameElementBase &amp;&amp; frameElementBase-&gt;scrollingMode() != ScrollbarAlwaysOff)
2737         return true;
2738 
2739     // If scrollbars are forbidden, user initiated scrolls should obviously be ignored.
2740     if (frameView.wasScrolledByUser())
2741         return false;
2742 
2743     // Forbid autoscrolls when scrollbars are off, but permits other programmatic scrolls,
2744     // like navigation to an anchor.
2745     return !frameView.frame().eventHandler().autoscrollInProgress();
2746 }
2747 
2748 bool RenderLayer::allowsCurrentScroll() const
2749 {
2750     if (!renderer().hasOverflowClip())
</pre>
<hr />
<pre>
3035 
3036     LayoutSize currentSize = LayoutSize(renderer-&gt;width() / zoomFactor, renderer-&gt;height() / zoomFactor);
3037     LayoutSize minimumSize = element-&gt;minimumSizeForResizing().shrunkTo(currentSize);
3038     element-&gt;setMinimumSizeForResizing(minimumSize);
3039 
3040     LayoutSize adjustedOldOffset = LayoutSize(oldOffset.width() / zoomFactor, oldOffset.height() / zoomFactor);
3041     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
3042         newOffset.setWidth(-newOffset.width());
3043         adjustedOldOffset.setWidth(-adjustedOldOffset.width());
3044     }
3045 
3046     LayoutSize difference = (currentSize + newOffset - adjustedOldOffset).expandedTo(minimumSize) - currentSize;
3047 
3048     StyledElement* styledElement = downcast&lt;StyledElement&gt;(element);
3049     bool isBoxSizingBorder = renderer-&gt;style().boxSizing() == BoxSizing::BorderBox;
3050 
3051     Resize resize = renderer-&gt;style().resize();
3052     if (resize != Resize::Vertical &amp;&amp; difference.width()) {
3053         if (is&lt;HTMLFormControlElement&gt;(*element)) {
3054             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">3055             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSUnitType::CSS_PX);</span>
<span class="line-modified">3056             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSUnitType::CSS_PX);</span>
3057         }
3058         LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
3059         baseWidth = baseWidth / zoomFactor;
<span class="line-modified">3060         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSUnitType::CSS_PX);</span>
3061     }
3062 
3063     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
3064         if (is&lt;HTMLFormControlElement&gt;(*element)) {
3065             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">3066             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSUnitType::CSS_PX);</span>
<span class="line-modified">3067             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSUnitType::CSS_PX);</span>
3068         }
3069         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
3070         baseHeight = baseHeight / zoomFactor;
<span class="line-modified">3071         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSUnitType::CSS_PX);</span>
3072     }
3073 
3074     document.updateLayout();
3075 
3076     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
3077 }
3078 
3079 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
3080 {
3081     scrollTo(scrollPositionFromOffset(offset));
3082 }
3083 
3084 ScrollingNodeID RenderLayer::scrollingNodeID() const
3085 {
3086     if (!isComposited())
3087         return 0;
3088 
3089     return backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
3090 }
3091 
</pre>
<hr />
<pre>
3395 }
3396 
3397 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3398 {
3399     if (!showsOverflowControls())
3400         return;
3401 
3402     if (GraphicsLayer* layer = layerForScrollCorner()) {
3403         layer-&gt;setNeedsDisplayInRect(rect);
3404         return;
3405     }
3406 
3407     if (m_scrollCorner)
3408         m_scrollCorner-&gt;repaintRectangle(rect);
3409     if (m_resizer)
3410         m_resizer-&gt;repaintRectangle(rect);
3411 }
3412 
3413 static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)
3414 {
<span class="line-modified">3415     return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>





3416 }
3417 
3418 bool RenderLayer::horizontalScrollbarHiddenByStyle() const
3419 {
3420     return scrollbarHiddenByStyle(horizontalScrollbar());
3421 }
3422 
3423 bool RenderLayer::verticalScrollbarHiddenByStyle() const
3424 {
3425     return scrollbarHiddenByStyle(verticalScrollbar());
3426 }
3427 
3428 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3429 {
3430     if (Element* element = renderer.element()) {
3431         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3432             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3433                 return shadowRoot-&gt;host()-&gt;renderer();
3434         }
3435     }
3436 
3437     return &amp;renderer;
3438 }
3439 
3440 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3441 {
3442     RefPtr&lt;Scrollbar&gt; widget;
3443     ASSERT(rendererForScrollbar(renderer()));
3444     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3445     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3446     if (hasCustomScrollbarStyle)
3447         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
3448     else {
3449         widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
3450         didAddScrollbar(widget.get(), orientation);
<span class="line-modified">3451         if (page().isMonitoringWheelEvents())</span>
<span class="line-modified">3452             scrollAnimator().setWheelEventTestMonitor(page().wheelEventTestMonitor());</span>
3453     }
3454     renderer().view().frameView().addChild(*widget);
3455     return widget.releaseNonNull();
3456 }
3457 
3458 void RenderLayer::destroyScrollbar(ScrollbarOrientation orientation)
3459 {
3460     RefPtr&lt;Scrollbar&gt;&amp; scrollbar = orientation == HorizontalScrollbar ? m_hBar : m_vBar;
3461     if (!scrollbar)
3462         return;
3463 
3464     if (!scrollbar-&gt;isCustomScrollbar())
3465         willRemoveScrollbar(scrollbar.get(), orientation);
3466 
3467     scrollbar-&gt;removeFromParent();
3468     scrollbar = nullptr;
3469 }
3470 
3471 bool RenderLayer::scrollsOverflow() const
3472 {
</pre>
<hr />
<pre>
4368         return false;
4369 
4370     bool scrollingOnMainThread = true;
4371 #if ENABLE(ASYNC_SCROLLING)
4372     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
4373         scrollingOnMainThread = scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(renderer().view().frameView());
4374 #endif
4375 
4376     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4377     // things on the scrolling thread.
4378     bool contentsScrollByPainting = (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling()) || (renderer().frame().ownerElement());
4379     bool isZooming = !page().chrome().client().hasStablePageScaleFactor();
4380     if (scrollingOnMainThread || contentsScrollByPainting || isZooming) {
4381         didQuantizeFonts = context.shouldSubpixelQuantizeFonts();
4382         context.setShouldSubpixelQuantizeFonts(false);
4383         return true;
4384     }
4385     return false;
4386 }
4387 




































4388 Path RenderLayer::computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp; windRule) const
4389 {
4390     const RenderStyle&amp; style = renderer().style();
4391     float deviceSaleFactor = renderer().document().deviceScaleFactor();
4392 
4393     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath())) {
4394         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style.clipPath());
4395         FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), clipPath.referenceBox(), offsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4396 
4397         windRule = clipPath.windRule();
4398         return clipPath.pathForReferenceRect(referenceBox);
4399     }
4400 
4401     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4402 
4403         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4404 
4405         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4406         shapeRect.move(offsetFromRoot);
4407 
</pre>
<hr />
<pre>
4520     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4521     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4522     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4523     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4524     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4525     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4526     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
4527     bool isCollectingEventRegion = paintFlags.contains(PaintLayerCollectingEventRegion);
4528     // Outline always needs to be painted even if we have no visible content. Also,
4529     // the outline is painted in the background phase during composited scrolling.
4530     // If it were painted in the foreground phase, it would move with the scrolled
4531     // content. When not composited scrolling, the outline is painted in the
4532     // foreground phase. Since scrolled contents are moved by repainting in this
4533     // case, the outline won&#39;t get &#39;dragged along&#39;.
4534     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion
4535         &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())
4536         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4537         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
4538     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;
4539 
<span class="line-modified">4540     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer()) {</span>
<span class="line-added">4541         // If beginTransparencyLayers was called prior to this, ensure the transparency state is cleaned up before returning.</span>
<span class="line-added">4542         if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {</span>
<span class="line-added">4543             context.endTransparencyLayer();</span>
<span class="line-added">4544             context.restore();</span>
<span class="line-added">4545             m_usedTransparency = false;</span>
<span class="line-added">4546         }</span>
<span class="line-added">4547 </span>
4548         return;
<span class="line-added">4549     }</span>
4550 
4551     updateLayerListsIfNeeded();
4552 
4553     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4554     LayoutRect rootRelativeBounds;
4555     bool rootRelativeBoundsComputed = false;
4556 
4557     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4558     // things on the scrolling thread.
4559     bool didQuantizeFonts = true;
4560     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4561 
4562     // Apply clip-path to context.
4563     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4564     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4565         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4566 
4567     bool hasClipPath = false;
4568     if (shouldApplyClipPath(paintingInfo.paintBehavior, localPaintFlags))
4569         hasClipPath = setupClipPath(context, paintingInfo, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
</pre>
<hr />
<pre>
4749     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4750     transformedPaintingInfo.rootLayer = this;
4751     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4752     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4753     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
4754 
4755     if (paintingInfo.eventRegionContext)
4756         paintingInfo.eventRegionContext-&gt;popTransform();
4757 
4758     context.setCTM(oldTransform);
4759 }
4760 
4761 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4762 {
4763     if (layerIterator.begin() == layerIterator.end())
4764         return;
4765 
4766     if (!hasSelfPaintingLayerDescendant())
4767         return;
4768 
<span class="line-modified">4769 #if ASSERT_ENABLED</span>
4770     LayerListMutationDetector mutationChecker(*this);
4771 #endif
4772 
4773     for (auto* childLayer : layerIterator)
4774         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4775 }
4776 
4777 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4778 {
4779     // If we don&#39;t have an enclosing layer, or if the root layer is the same as the enclosing layer,
4780     // then just return the enclosing pagination layer (it will be 0 in the former case and the rootLayer in the latter case).
4781     RenderLayer* paginationLayer = enclosingPaginationLayer(mode);
4782     if (!paginationLayer || rootLayer == paginationLayer)
4783         return paginationLayer;
4784 
4785     // Walk up the layer tree and see which layer we hit first. If it&#39;s the root, then the enclosing pagination
4786     // layer isn&#39;t in our subtree and we return nullptr. If we hit the enclosing pagination layer first, then
4787     // we can return it.
4788     for (const RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
4789         if (layer == rootLayer)
</pre>
<hr />
<pre>
5364     // The following are used for keeping track of the z-depth of the hit point of 3d-transformed
5365     // descendants.
5366     double localZOffset = -std::numeric_limits&lt;double&gt;::infinity();
5367     double* zOffsetForDescendantsPtr = nullptr;
5368     double* zOffsetForContentsPtr = nullptr;
5369 
5370     bool depthSortDescendants = false;
5371     if (preserves3D()) {
5372         depthSortDescendants = true;
5373         // Our layers can depth-test with our container, so share the z depth pointer with the container, if it passed one down.
5374         zOffsetForDescendantsPtr = zOffset ? zOffset : &amp;localZOffset;
5375         zOffsetForContentsPtr = zOffset ? zOffset : &amp;localZOffset;
5376     } else if (zOffset) {
5377         zOffsetForDescendantsPtr = nullptr;
5378         // Container needs us to give back a z offset for the hit layer.
5379         zOffsetForContentsPtr = zOffset;
5380     }
5381 
5382     // This variable tracks which layer the mouse ends up being inside.
5383     RenderLayer* candidateLayer = nullptr;
<span class="line-modified">5384 #if ASSERT_ENABLED</span>
5385     LayerListMutationDetector mutationChecker(*this);
5386 #endif
5387 
5388     // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
5389     auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5390                                         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5391     if (hitLayer) {
5392         if (!depthSortDescendants)
5393             return hitLayer;
5394         candidateLayer = hitLayer;
5395     }
5396 
5397     // Now check our overflow objects.
5398     hitLayer = hitTestList(normalFlowLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5399                            localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5400     if (hitLayer) {
5401         if (!depthSortDescendants)
5402             return hitLayer;
5403         candidateLayer = hitLayer;
5404     }
</pre>
<hr />
<pre>
5645     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5646     if (m_clipRectsCache) {
5647         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5648             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5649             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5650 
5651 #ifdef CHECK_CACHED_CLIP_RECTS
5652             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5653             ClipRectsContext tempContext(clipRectsContext);
5654             tempContext.clipRectsType = TemporaryClipRects;
5655             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5656             calculateClipRects(tempContext, tempClipRects);
5657             ASSERT(tempClipRects.get() == *clipRects);
5658 #endif
5659             return *clipRects; // We have the correct cached value.
5660         }
5661     }
5662 
5663     if (!m_clipRectsCache)
5664         m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();
<span class="line-modified">5665 #if ASSERT_ENABLED</span>
5666     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5667     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5668 #endif
5669 
5670     RefPtr&lt;ClipRects&gt; parentClipRects;
5671     // For transformed layers, the root layer was shifted to be us, so there is no need to
5672     // examine the parent. We want to cache clip rects with us as the root.
5673     if (clipRectsContext.rootLayer != this &amp;&amp; parent())
5674         parentClipRects = this-&gt;parentClipRects(clipRectsContext);
5675 
5676     auto clipRects = ClipRects::create();
5677     calculateClipRects(clipRectsContext, clipRects);
5678 
5679     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5680         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5681         return parentClipRects.releaseNonNull();
5682     }
5683     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5684     return clipRects;
5685 }
</pre>
<hr />
<pre>
6158 
6159             localClipRect.move(offsetFromAncestor(ancestorLayer));
6160             return localClipRect;
6161         }
6162     }
6163 
6164     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
6165     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
6166 
6167     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
6168 
6169     if (RenderLayer* reflection = reflectionLayer()) {
6170         if (!reflection-&gt;isComposited()) {
6171             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
6172             unionBounds.unite(childUnionBounds);
6173         }
6174     }
6175 
6176     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
6177 
<span class="line-modified">6178 #if ASSERT_ENABLED</span>
6179     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
6180 #endif
6181 
6182     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
6183         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))
6184             return;
6185         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
6186         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
6187         // that we hit the max LayoutUnit value.
6188         unionBounds.checkedUnite(childBounds);
6189     };
6190 
6191     for (auto* childLayer : negativeZOrderLayers())
6192         computeLayersUnion(*childLayer);
6193 
6194     for (auto* childLayer : positiveZOrderLayers())
6195         computeLayersUnion(*childLayer);
6196 
6197     for (auto* childLayer : normalFlowLayers())
6198         computeLayersUnion(*childLayer);
6199 
6200     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
<span class="line-modified">6201         unionBounds += filterOutsets();</span>
6202 
6203     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
6204         TransformationMatrix* affineTrans = transform();
6205         boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
6206         unionBounds = affineTrans-&gt;mapRect(unionBounds);
6207     }
6208     unionBounds.move(offsetFromRoot);
6209     return unionBounds;
6210 }
6211 
6212 void RenderLayer::clearClipRectsIncludingDescendants(ClipRectsType typeToClear)
6213 {
6214     // FIXME: it&#39;s not clear how this layer not having clip rects guarantees that no descendants have any.
6215     if (!m_clipRectsCache)
6216         return;
6217 
6218     clearClipRects(typeToClear);
6219 
6220     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
6221         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
</pre>
<hr />
<pre>
6624 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6625 {
6626     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6627 
6628     if (setIsCSSStackingContext(shouldBeCSSStackingContext())) {
6629 #if ENABLE(CSS_COMPOSITING)
6630         if (parent()) {
6631             if (isCSSStackingContext()) {
6632                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6633                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6634             } else {
6635                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6636                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6637                 else if (hasNotIsolatedBlendingDescendants())
6638                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6639             }
6640         }
6641 #endif
6642     }
6643 
<span class="line-modified">6644     // FIXME: RenderLayer already handles visibility changes through our visibility dirty bits. This logic could</span>
6645     // likely be folded along with the rest.
6646     if (oldStyle) {
<span class="line-modified">6647         if (oldStyle-&gt;usedZIndex() != renderer().style().usedZIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {</span>
6648             dirtyStackingContextZOrderLists();
6649             if (isStackingContext())
6650                 dirtyZOrderLists();
6651         }
6652     }
6653 
6654     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6655         if (!m_marquee)
6656             m_marquee = makeUnique&lt;RenderMarquee&gt;(this);
6657         m_marquee-&gt;updateMarqueeStyle();
6658     } else if (m_marquee)
6659         m_marquee = nullptr;
6660 
6661     updateScrollbarsAfterStyleChange(oldStyle);
6662     // Overlay scrollbars can make this layer self-painting so we need
6663     // to recompute the bit once scrollbars have been updated.
6664     updateSelfPaintingLayer();
6665 
6666     if (!hasReflection() &amp;&amp; m_reflection)
6667         removeReflection();
</pre>
<hr />
<pre>
6724     }
6725 
6726 #if ENABLE(IOS_TOUCH_EVENTS)
6727     if (addedOrRemoved) {
6728         if (isScrollable &amp;&amp; !canUseCompositedScrolling())
6729             registerAsTouchEventListenerForScrolling();
6730         else {
6731             // We only need the touch listener for unaccelerated overflow scrolling, so if we became
6732             // accelerated, remove ourselves as a touch event listener.
6733             unregisterAsTouchEventListenerForScrolling();
6734         }
6735     }
6736 #else
6737     UNUSED_VARIABLE(addedOrRemoved);
6738 #endif
6739 }
6740 
6741 void RenderLayer::updateScrollCornerStyle()
6742 {
6743     RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">6744     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;actualRenderer-&gt;style()) : nullptr;</span>
6745 
6746     if (!corner) {
6747         clearScrollCorner();
6748         return;
6749     }
6750 
6751     if (!m_scrollCorner) {
6752         m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*corner));
6753         // FIXME: A renderer should be a child of its parent!
6754         m_scrollCorner-&gt;setParent(&amp;renderer());
6755         m_scrollCorner-&gt;initializeStyle();
6756     } else
6757         m_scrollCorner-&gt;setStyle(WTFMove(*corner));
6758 }
6759 
6760 void RenderLayer::clearScrollCorner()
6761 {
6762     if (!m_scrollCorner)
6763         return;
6764     m_scrollCorner-&gt;setParent(nullptr);
6765     m_scrollCorner = nullptr;
6766 }
6767 
6768 void RenderLayer::updateResizerStyle()
6769 {
6770     RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">6771     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::Resizer }, &amp;actualRenderer-&gt;style()) : nullptr;</span>
6772 
6773     if (!resizer) {
6774         clearResizer();
6775         return;
6776     }
6777 
6778     if (!m_resizer) {
6779         m_resizer = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*resizer));
6780         // FIXME: A renderer should be a child of its parent!
6781         m_resizer-&gt;setParent(&amp;renderer());
6782         m_resizer-&gt;initializeStyle();
6783     } else
6784         m_resizer-&gt;setStyle(WTFMove(*resizer));
6785 }
6786 
6787 void RenderLayer::clearResizer()
6788 {
6789     if (!m_resizer)
6790         return;
6791     m_resizer-&gt;setParent(nullptr);
</pre>
<hr />
<pre>
6811     m_reflection-&gt;initializeStyle();
6812 }
6813 
6814 void RenderLayer::removeReflection()
6815 {
6816     if (!m_reflection-&gt;renderTreeBeingDestroyed())
6817         m_reflection-&gt;removeLayers(this);
6818 
6819     m_reflection-&gt;setParent(nullptr);
6820     m_reflection = nullptr;
6821 }
6822 
6823 RenderStyle RenderLayer::createReflectionStyle()
6824 {
6825     auto newStyle = RenderStyle::create();
6826     newStyle.inheritFrom(renderer().style());
6827 
6828     // Map in our transform.
6829     TransformOperations transform;
6830     switch (renderer().style().boxReflect()-&gt;direction()) {
<span class="line-modified">6831     case ReflectionDirection::Below:</span>
<span class="line-modified">6832         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6833         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6834         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6835         break;</span>
<span class="line-modified">6836     case ReflectionDirection::Above:</span>
<span class="line-modified">6837         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6838         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6839         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6840         break;</span>
<span class="line-modified">6841     case ReflectionDirection::Right:</span>
<span class="line-modified">6842         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6843         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6844         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6845         break;</span>
<span class="line-modified">6846     case ReflectionDirection::Left:</span>
<span class="line-modified">6847         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">6848         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6849         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">6850         break;</span>
6851     }
6852     newStyle.setTransform(transform);
6853 
6854     // Map in our mask.
6855     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6856 
6857     // Style has transform and mask, so needs to be stacking context.
<span class="line-modified">6858     newStyle.setUsedZIndex(0);</span>
6859 
6860     return newStyle;
6861 }
6862 
6863 void RenderLayer::ensureLayerFilters()
6864 {
6865     if (m_filters)
6866         return;
6867 
6868     m_filters = makeUnique&lt;RenderLayerFilters&gt;(*this);
6869 }
6870 
6871 void RenderLayer::clearLayerFilters()
6872 {
6873     m_filters = nullptr;
6874 }
6875 
6876 void RenderLayer::updateFiltersAfterStyleChange()
6877 {
6878     if (!hasFilter()) {
</pre>
<hr />
<pre>
6891 
6892 void RenderLayer::updateFilterPaintingStrategy()
6893 {
6894     // RenderLayerFilters is only used to render the filters in software mode,
6895     // so we always need to run updateFilterPaintingStrategy() after the composited
6896     // mode might have changed for this layer.
6897     if (!paintsWithFilters()) {
6898         // Don&#39;t delete the whole filter info here, because we might use it
6899         // for loading SVG reference filter files.
6900         if (m_filters)
6901             m_filters-&gt;setFilter(nullptr);
6902 
6903         // Early-return only if we *don&#39;t* have reference filters.
6904         // For reference filters, we still want the FilterEffect graph built
6905         // for us, even if we&#39;re composited.
6906         if (!renderer().style().filter().hasReferenceFilter())
6907             return;
6908     }
6909 
6910     ensureLayerFilters();
<span class="line-modified">6911     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);</span>
6912 }
6913 
6914 void RenderLayer::filterNeedsRepaint()
6915 {
6916     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
6917     if (Element* element = enclosingElement()) {
6918         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.
6919         element-&gt;invalidateStyleAndLayerComposition();
6920     }
6921     renderer().repaint();
6922 }
6923 
<span class="line-modified">6924 IntOutsets RenderLayer::filterOutsets() const</span>
<span class="line-added">6925 {</span>
<span class="line-added">6926     if (m_filters)</span>
<span class="line-added">6927         return m_filters-&gt;filter() ? m_filters-&gt;filter()-&gt;outsets() : IntOutsets();</span>
<span class="line-added">6928     return renderer().style().filterOutsets();</span>
<span class="line-added">6929 }</span>
<span class="line-added">6930 </span>
<span class="line-added">6931 bool RenderLayer::isTransparentRespectingParentFrames() const</span>
6932 {
6933     static const double minimumVisibleOpacity = 0.01;
6934 
6935     float currentOpacity = 1;
6936     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
6937         currentOpacity *= layer-&gt;renderer().style().opacity();
6938         if (currentOpacity &lt; minimumVisibleOpacity)
6939             return true;
6940     }
6941 




























6942     return false;
6943 }
6944 
6945 void RenderLayer::invalidateEventRegion()
6946 {
6947 #if PLATFORM(IOS_FAMILY)
6948     auto* compositingLayer = enclosingCompositingLayerForRepaint();
6949     if (!compositingLayer)
6950         return;
6951 
6952     auto maintainsEventRegion = [&amp;] {
6953         // UI side scroll overlap testing.
6954         if (!compositingLayer-&gt;isRenderViewLayer())
6955             return true;
6956 #if ENABLE(POINTER_EVENTS)
6957         // UI side touch-action resolution.
6958         if (renderer().document().mayHaveElementsWithNonAutoTouchAction())
6959             return true;
6960 #endif
6961         return false;
</pre>
<hr />
<pre>
6997     if (layer.isolatesBlending())
6998         ts &lt;&lt; &quot; isolates blending&quot;;
6999     if (layer.isComposited())
7000         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
7001     return ts;
7002 }
7003 
7004 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer::ClipRectsContext&amp; context)
7005 {
7006     ts.dumpProperty(&quot;root layer:&quot;, context.rootLayer);
7007     ts.dumpProperty(&quot;type:&quot;, context.clipRectsType);
7008     ts.dumpProperty(&quot;overflow-clip:&quot;, context.respectOverflowClip == IgnoreOverflowClip ? &quot;ignore&quot; : &quot;respect&quot;);
7009 
7010     return ts;
7011 }
7012 
7013 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)
7014 {
7015     switch (reason) {
7016     case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;
<span class="line-added">7017     case IndirectCompositingReason::Clipping: ts &lt;&lt; &quot;clipping&quot;; break;</span>
7018     case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;
7019     case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;
7020     case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;
7021     case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;
7022     case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;
7023     case IndirectCompositingReason::Perspective: ts &lt;&lt; &quot;perspective&quot;; break;
7024     case IndirectCompositingReason::Preserve3D: ts &lt;&lt; &quot;preserve-3d&quot;; break;
7025     }
7026 
7027     return ts;
7028 }
7029 
7030 } // namespace WebCore
7031 
7032 #if ENABLE(TREE_DEBUGGING)
7033 
7034 void showLayerTree(const WebCore::RenderLayer* layer)
7035 {
7036     if (!layer)
7037         return;
</pre>
</td>
</tr>
</table>
<center><a href="RenderInline.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
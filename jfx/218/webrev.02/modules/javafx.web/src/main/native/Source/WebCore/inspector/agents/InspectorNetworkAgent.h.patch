diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.h b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.h
@@ -35,13 +35,12 @@
 #include "InspectorPageAgent.h"
 #include "InspectorWebAgentBase.h"
 #include <JavaScriptCore/InspectorBackendDispatchers.h>
 #include <JavaScriptCore/InspectorFrontendDispatchers.h>
 #include <JavaScriptCore/RegularExpression.h>
-#include <wtf/HashSet.h>
+#include <wtf/Forward.h>
 #include <wtf/JSONValues.h>
-#include <wtf/text/WTFString.h>
 
 namespace Inspector {
 class InjectedScriptManager;
 }
 
@@ -66,11 +65,11 @@
 
 class InspectorNetworkAgent : public InspectorAgentBase, public Inspector::NetworkBackendDispatcherHandler {
     WTF_MAKE_NONCOPYABLE(InspectorNetworkAgent);
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    virtual ~InspectorNetworkAgent();
+    ~InspectorNetworkAgent() override;
 
     static bool shouldTreatAsText(const String& mimeType);
     static Ref<TextResourceDecoder> createTextDecoder(const String& mimeType, const String& textEncodingName);
     static Optional<String> textContentForCachedResource(CachedResource&);
     static bool cachedResourceContent(CachedResource&, String* result, bool* base64Encoded);
@@ -86,10 +85,15 @@
     void getResponseBody(ErrorString&, const String& requestId, String* content, bool* base64Encoded) final;
     void setResourceCachingDisabled(ErrorString&, bool disabled) final;
     void loadResource(const String& frameId, const String& url, Ref<LoadResourceCallback>&&) final;
     void getSerializedCertificate(ErrorString&, const String& requestId, String* serializedCertificate) final;
     void resolveWebSocket(ErrorString&, const String& requestId, const String* objectGroup, RefPtr<Inspector::Protocol::Runtime::RemoteObject>&) final;
+    void setInterceptionEnabled(ErrorString&, bool enabled) final;
+    void addInterception(ErrorString&, const String& url, const bool* caseSensitive, const bool* isRegex, const String* networkStageString) final;
+    void removeInterception(ErrorString&, const String& url, const bool* caseSensitive, const bool* isRegex, const String* networkStageString) final;
+    void interceptContinue(ErrorString&, const String& requestId) final;
+    void interceptWithResponse(ErrorString&, const String& requestId, const String& content, bool base64Encoded, const String* mimeType, const int* status, const String* statusText, const JSON::Object* headers) final;
 
     // InspectorInstrumentation
     void willRecalculateStyle();
     void didRecalculateStyle();
     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&, const ResourceResponse& redirectResponse);
@@ -112,10 +116,13 @@
     void didSendWebSocketFrame(unsigned long identifier, const WebSocketFrame&);
     void didReceiveWebSocketFrameError(unsigned long identifier, const String&);
     void mainFrameNavigated(DocumentLoader&);
     void setInitialScriptContent(unsigned long identifier, const String& sourceString);
     void didScheduleStyleRecalculation(Document&);
+    bool willInterceptRequest(const ResourceRequest&);
+    bool shouldInterceptResponse(const ResourceResponse&);
+    void interceptResponse(const ResourceResponse&, unsigned long identifier, CompletionHandler<void(const ResourceResponse&, RefPtr<SharedBuffer>)>&&);
 
     void searchOtherRequests(const JSC::Yarr::RegularExpression&, RefPtr<JSON::ArrayOf<Inspector::Protocol::Page::SearchResult>>&);
     void searchInRequest(ErrorString&, const String& requestId, const String& query, bool caseSensitive, bool isRegex, RefPtr<JSON::ArrayOf<Inspector::Protocol::GenericTypes::SearchMatch>>&);
 
 protected:
@@ -131,31 +138,90 @@
 private:
     void enable();
 
     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&, const ResourceResponse& redirectResponse, InspectorPageAgent::ResourceType);
 
+    bool shouldIntercept(URL);
+    void continuePendingResponses();
+
     WebSocket* webSocketForRequestId(const String& requestId);
 
     RefPtr<Inspector::Protocol::Network::Initiator> buildInitiatorObject(Document*, Optional<const ResourceRequest&> = WTF::nullopt);
     Ref<Inspector::Protocol::Network::ResourceTiming> buildObjectForTiming(const NetworkLoadMetrics&, ResourceLoader&);
     Ref<Inspector::Protocol::Network::Metrics> buildObjectForMetrics(const NetworkLoadMetrics&);
     RefPtr<Inspector::Protocol::Network::Response> buildObjectForResourceResponse(const ResourceResponse&, ResourceLoader*);
     Ref<Inspector::Protocol::Network::CachedResource> buildObjectForCachedResource(CachedResource*);
 
     double timestamp();
 
+    class PendingInterceptResponse {
+        WTF_MAKE_NONCOPYABLE(PendingInterceptResponse);
+        WTF_MAKE_FAST_ALLOCATED;
+    public:
+        PendingInterceptResponse(const ResourceResponse& originalResponse, CompletionHandler<void(const ResourceResponse&, RefPtr<SharedBuffer>)>&& completionHandler)
+            : m_originalResponse(originalResponse)
+            , m_completionHandler(WTFMove(completionHandler))
+        { }
+
+        ~PendingInterceptResponse()
+        {
+            ASSERT(m_responded);
+        }
+
+        ResourceResponse originalResponse() { return m_originalResponse; }
+
+        void respondWithOriginalResponse()
+        {
+            respond(m_originalResponse, nullptr);
+        }
+
+        void respond(const ResourceResponse& response, RefPtr<SharedBuffer> data)
+        {
+            ASSERT(!m_responded);
+            if (m_responded)
+                return;
+
+            m_responded = true;
+
+            m_completionHandler(response, data);
+        }
+
+    private:
+        ResourceResponse m_originalResponse;
+        CompletionHandler<void(const ResourceResponse&, RefPtr<SharedBuffer>)> m_completionHandler;
+        bool m_responded { false };
+    };
+
     std::unique_ptr<Inspector::NetworkFrontendDispatcher> m_frontendDispatcher;
     RefPtr<Inspector::NetworkBackendDispatcher> m_backendDispatcher;
     Inspector::InjectedScriptManager& m_injectedScriptManager;
 
+    std::unique_ptr<NetworkResourcesData> m_resourcesData;
+
+    HashMap<String, String> m_extraRequestHeaders;
+    HashSet<unsigned long> m_hiddenRequestIdentifiers;
+
+    struct Intercept {
+        String url;
+        bool caseSensitive { true };
+        bool isRegex { false };
+
+        inline bool operator==(const Intercept& other) const
+        {
+            return url == other.url
+                && caseSensitive == other.caseSensitive
+                && isRegex == other.isRegex;
+        }
+    };
+    Vector<Intercept> m_intercepts;
+    HashMap<String, std::unique_ptr<PendingInterceptResponse>> m_pendingInterceptResponses;
+
     // FIXME: InspectorNetworkAgent should not be aware of style recalculation.
     RefPtr<Inspector::Protocol::Network::Initiator> m_styleRecalculationInitiator;
     bool m_isRecalculatingStyle { false };
 
-    std::unique_ptr<NetworkResourcesData> m_resourcesData;
     bool m_enabled { false };
     bool m_loadingXHRSynchronously { false };
-    HashMap<String, String> m_extraRequestHeaders;
-    HashSet<unsigned long> m_hiddenRequestIdentifiers;
+    bool m_interceptionEnabled { false };
 };
 
 } // namespace WebCore

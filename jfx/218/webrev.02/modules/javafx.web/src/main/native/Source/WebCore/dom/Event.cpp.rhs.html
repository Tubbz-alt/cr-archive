<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Event.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2001 Peter Kelly (pmk@post.com)
  3  * Copyright (C) 2001 Tobias Anton (anton@stud.fbi.fh-darmstadt.de)
  4  * Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;Event.h&quot;
 25 
 26 #include &quot;DOMWindow.h&quot;
 27 #include &quot;Document.h&quot;
 28 #include &quot;EventNames.h&quot;
 29 #include &quot;EventPath.h&quot;
 30 #include &quot;EventTarget.h&quot;
 31 #include &quot;InspectorInstrumentation.h&quot;
 32 #include &quot;Performance.h&quot;
 33 #include &quot;UserGestureIndicator.h&quot;
 34 #include &quot;WorkerGlobalScope.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 35 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
 36 
 37 namespace WebCore {
 38 
<a name="2" id="anc2"></a><span class="line-added"> 39 WTF_MAKE_ISO_ALLOCATED_IMPL(Event);</span>
<span class="line-added"> 40 </span>
 41 ALWAYS_INLINE Event::Event(MonotonicTime createTime, const AtomString&amp; type, IsTrusted isTrusted, CanBubble canBubble, IsCancelable cancelable, IsComposed composed)
 42     : m_isInitialized { !type.isNull() }
 43     , m_canBubble { canBubble == CanBubble::Yes }
 44     , m_cancelable { cancelable == IsCancelable::Yes }
 45     , m_composed { composed == IsComposed::Yes }
 46     , m_propagationStopped { false }
 47     , m_immediatePropagationStopped { false }
 48     , m_wasCanceled { false }
 49     , m_defaultHandled { false }
 50     , m_isDefaultEventHandlerIgnored { false }
 51     , m_isTrusted { isTrusted == IsTrusted::Yes }
 52     , m_isExecutingPassiveEventListener { false }
 53     , m_eventPhase { NONE }
 54     , m_type { type }
 55     , m_createTime { createTime }
 56 {
 57 }
 58 
 59 Event::Event(IsTrusted isTrusted)
 60     : Event { MonotonicTime::now(), { }, isTrusted, CanBubble::No, IsCancelable::No, IsComposed::No }
 61 {
 62 }
 63 
 64 Event::Event(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed)
 65     : Event { MonotonicTime::now(), eventType, IsTrusted::Yes, canBubble, isCancelable, isComposed }
 66 {
 67     ASSERT(!eventType.isNull());
 68 }
 69 
 70 Event::Event(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, MonotonicTime timestamp, IsTrusted isTrusted)
 71     : Event { timestamp, eventType, isTrusted, canBubble, isCancelable, isComposed }
 72 {
 73     ASSERT(!eventType.isNull());
 74 }
 75 
 76 Event::Event(const AtomString&amp; eventType, const EventInit&amp; initializer, IsTrusted isTrusted)
 77     : Event { MonotonicTime::now(), eventType, isTrusted,
 78         initializer.bubbles ? CanBubble::Yes : CanBubble::No,
 79         initializer.cancelable ? IsCancelable::Yes : IsCancelable::No,
 80         initializer.composed ? IsComposed::Yes : IsComposed::No }
 81 {
 82     ASSERT(!eventType.isNull());
 83 }
 84 
 85 Event::~Event() = default;
 86 
 87 Ref&lt;Event&gt; Event::create(const AtomString&amp; type, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed)
 88 {
 89     return adoptRef(*new Event(type, canBubble, isCancelable, isComposed));
 90 }
 91 
 92 Ref&lt;Event&gt; Event::createForBindings()
 93 {
 94     return adoptRef(*new Event);
 95 }
 96 
 97 Ref&lt;Event&gt; Event::create(const AtomString&amp; type, const EventInit&amp; initializer, IsTrusted isTrusted)
 98 {
 99     return adoptRef(*new Event(type, initializer, isTrusted));
100 }
101 
102 void Event::initEvent(const AtomString&amp; eventTypeArg, bool canBubbleArg, bool cancelableArg)
103 {
104     if (isBeingDispatched())
105         return;
106 
107     m_isInitialized = true;
108     m_propagationStopped = false;
109     m_immediatePropagationStopped = false;
110     m_wasCanceled = false;
111     m_isTrusted = false;
112     m_target = nullptr;
113     m_type = eventTypeArg;
114     m_canBubble = canBubbleArg;
115     m_cancelable = cancelableArg;
116 
117     m_underlyingEvent = nullptr;
118 }
119 
120 void Event::setTarget(RefPtr&lt;EventTarget&gt;&amp;&amp; target)
121 {
122     if (m_target == target)
123         return;
124 
125     m_target = WTFMove(target);
126     if (m_target)
127         receivedTarget();
128 }
129 
130 void Event::setCurrentTarget(EventTarget* currentTarget)
131 {
132     m_currentTarget = currentTarget;
133 }
134 
135 Vector&lt;EventTarget*&gt; Event::composedPath() const
136 {
137     if (!m_eventPath)
138         return Vector&lt;EventTarget*&gt;();
139     return m_eventPath-&gt;computePathUnclosedToTarget(*m_currentTarget);
140 }
141 
142 void Event::setUnderlyingEvent(Event* underlyingEvent)
143 {
144     // Prohibit creation of a cycle by doing nothing if a cycle would be created.
145     for (Event* event = underlyingEvent; event; event = event-&gt;underlyingEvent()) {
146         if (event == this)
147             return;
148     }
149     m_underlyingEvent = underlyingEvent;
150 }
151 
152 DOMHighResTimeStamp Event::timeStampForBindings(ScriptExecutionContext&amp; context) const
153 {
154     Performance* performance = nullptr;
155     if (is&lt;WorkerGlobalScope&gt;(context))
156         performance = &amp;downcast&lt;WorkerGlobalScope&gt;(context).performance();
157     else if (auto* window = downcast&lt;Document&gt;(context).domWindow())
158         performance = &amp;window-&gt;performance();
159 
160     if (!performance)
161         return 0;
162 
163     return std::max(performance-&gt;relativeTimeFromTimeOriginInReducedResolution(m_createTime), 0.);
164 }
165 
166 void Event::resetBeforeDispatch()
167 {
168     m_defaultHandled = false;
169 }
170 
171 void Event::resetAfterDispatch()
172 {
173     m_eventPath = nullptr;
174     m_currentTarget = nullptr;
175     m_eventPhase = NONE;
176     m_propagationStopped = false;
177     m_immediatePropagationStopped = false;
178 
179     InspectorInstrumentation::eventDidResetAfterDispatch(*this);
180 }
181 
182 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/HEVCUtilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HEVCUtilities.h&quot;
 28 
 29 #include &lt;wtf/HashMap.h&gt;
 30 #include &lt;wtf/HashSet.h&gt;
 31 #include &lt;wtf/NeverDestroyed.h&gt;
 32 #include &lt;wtf/text/StringHash.h&gt;
 33 #include &lt;wtf/text/StringToIntegerConversion.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 Optional&lt;HEVCParameterSet&gt; parseHEVCCodecParameters(const String&amp; codecString)
 38 {
 39     // The format of the &#39;hevc&#39; codec string is specified in ISO/IEC 14496-15:2014, Annex E.3.
 40     StringView codecView(codecString);
 41     auto codecSplit = codecView.split(&#39;.&#39;);
 42     auto nextElement = codecSplit.begin();
 43     if (nextElement == codecSplit.end())
 44         return WTF::nullopt;
 45 
 46     HEVCParameterSet parameters;
 47 
 48     // Codec identifier: legal values are specified in ISO/IEC 14496-15:2014, section 8:
 49     parameters.codecName = (*nextElement).toString();
 50     if (!equal(parameters.codecName, &quot;hvc1&quot;) &amp;&amp; !equal(parameters.codecName, &quot;hev1&quot;))
 51         return WTF::nullopt;
 52 
 53     if (++nextElement == codecSplit.end())
 54         return WTF::nullopt;
 55 
 56     // First element: Optional General Profile Space parameter [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], mapping to [1, 2, 3]
 57     // and [0] for absent, then General Profile IDC as a 5-bit decimal number.
 58     auto profileSpace = *nextElement;
 59     if (!profileSpace.length())
 60         return WTF::nullopt;
 61 
 62     auto firstCharacter = profileSpace[0];
 63     bool hasProfileSpace = firstCharacter &gt;= &#39;A&#39; &amp;&amp; firstCharacter &lt;= &#39;C&#39;;
 64     if (hasProfileSpace) {
 65         parameters.generalProfileSpace = 1 + (firstCharacter - &#39;A&#39;);
 66         profileSpace = profileSpace.substring(1);
 67     }
 68 
 69     bool isValidProfileIDC = false;
 70     parameters.generalProfileIDC = toIntegralType&lt;uint8_t&gt;(profileSpace, &amp;isValidProfileIDC);
 71     if (!isValidProfileIDC)
 72         return WTF::nullopt;
 73 
 74     if (++nextElement == codecSplit.end())
 75         return WTF::nullopt;
 76 
 77     // Second element: 32 bit of General Profile Compatibility Flags, in reverse bit order,
 78     // in hex with leading zeros omitted.
 79     auto compatibilityFlags = *nextElement;
 80     bool isValidCompatibilityFlags = false;
 81     parameters.generalProfileCompatibilityFlags = toIntegralType&lt;uint32_t&gt;(compatibilityFlags, &amp;isValidCompatibilityFlags, 16);
 82     if (!isValidCompatibilityFlags)
 83         return WTF::nullopt;
 84 
 85     if (++nextElement == codecSplit.end())
 86         return WTF::nullopt;
 87 
 88     // Third element: General Tier Flag [&#39;L&#39;, &#39;H&#39;], mapping to [false, true], followed by
 89     // General Level IDC as a 8-bit decimal number.
 90     auto generalTier = *nextElement;
 91     firstCharacter = generalTier[0];
 92     if (firstCharacter != &#39;L&#39; &amp;&amp; firstCharacter != &#39;H&#39;)
 93         return WTF::nullopt;
 94 
 95     parameters.generalTierFlag = firstCharacter == &#39;H&#39;;
 96     bool isValidGeneralLevelIDC = false;
 97     parameters.generalLevelIDC = toIntegralType&lt;uint8_t&gt;(generalTier.substring(1), &amp;isValidGeneralLevelIDC);
 98     if (!isValidGeneralLevelIDC)
 99         return WTF::nullopt;
100 
101     // Optional fourth and remaning elements: a sequence of 6 1-byte constraint flags, each byte encoded
102     // in hex, and separated by a period, with trailing zero bytes omitted.
103     parameters.constraintFlags.fill(0, 6);
104     for (auto&amp; flag : parameters.constraintFlags) {
105         if (++nextElement == codecSplit.end())
106             break;
107 
108         bool isValidFlag = false;
109         flag = toIntegralType&lt;uint8_t&gt;(*nextElement, &amp;isValidFlag, 16);
110         if (!isValidFlag)
111             return WTF::nullopt;
112     }
113 
114     return parameters;
115 }
116 
117 static String codecStringForDoViCodecType(const String&amp; codec)
118 {
119     using MapType = HashMap&lt;String, String&gt;;
120     static NeverDestroyed&lt;MapType&gt; types = std::initializer_list&lt;MapType::KeyValuePairType&gt;({
121         { &quot;dvhe&quot;, &quot;hev1&quot; },
122         { &quot;dvh1&quot;, &quot;hvc1&quot; },
123         { &quot;dvav&quot;, &quot;avc3&quot; },
124         { &quot;dva1&quot;, &quot;avc1&quot; }
125     });
126 
127     auto findResults = types.get().find(codec);
128     if (findResults == types.get().end())
129         return nullString();
130     return findResults-&gt;value;
131 }
132 
133 static Optional&lt;unsigned short&gt; profileIDForAlphabeticDoViProfile(const String&amp; profile)
134 {
135     // See Table 7 of &quot;Dolby Vision Profiles and Levels Version 1.3.2&quot;
136     using MapType = HashMap&lt;String, unsigned short&gt;;
137     static NeverDestroyed&lt;MapType&gt; map = std::initializer_list&lt;MapType::KeyValuePairType&gt;({
138         { &quot;dvhe.dtr&quot;, 4 },
139         { &quot;dvhe.stn&quot;, 5 },
140         { &quot;dvhe.dtb&quot;, 7 },
141         { &quot;dvhe.st&quot;, 8 },
142         { &quot;dvav.se&quot;, 9 }
143     });
144 
145     auto findResults = map.get().find(profile);
146     if (findResults == map.get().end())
147         return WTF::nullopt;
148     return findResults-&gt;value;
149 }
150 
151 static bool isValidDoViProfileID(unsigned short profileID)
152 {
153     switch (profileID) {
154     case 4:
155     case 5:
156     case 7:
157     case 8:
158     case 9:
159         return true;
160     default:
161         return false;
162     }
163 }
164 
165 static Optional&lt;unsigned short&gt; maximumLevelIDForDoViProfileID(unsigned short profileID)
166 {
167     // See Section 4.1 of &quot;Dolby Vision Profiles and Levels Version 1.3.2&quot;
168     switch (profileID) {
169     case 4: return 9;
170     case 5: return 13;
171     case 7: return 9;
172     case 8: return 13;
173     case 9: return 5;
174     default: return WTF::nullopt;
175     }
176 }
177 
178 static bool isValidProfileIDForCodecName(unsigned short profileID, const String&amp; codecName)
179 {
180     if (profileID == 9)
181         return codecName == &quot;avc1&quot; || codecName == &quot;avc3&quot;;
182     return codecName == &quot;hvc1&quot; || codecName == &quot;hev1&quot;;
183 }
184 
185 Optional&lt;DoViParameterSet&gt; parseDoViCodecParameters(const String&amp; codecString)
186 {
187     // The format of the DoVi codec string is specified in &quot;Dolby Vision Profiles and Levels Version 1.3.2&quot;
188     StringView codecView(codecString);
189     auto codecSplit = codecView.split(&#39;.&#39;);
190     auto nextElement = codecSplit.begin();
191     if (nextElement == codecSplit.end())
192         return WTF::nullopt;
193 
194     DoViParameterSet parameters;
195 
196     parameters.codecName = codecStringForDoViCodecType((*nextElement).toString());
197     if (!parameters.codecName)
198         return WTF::nullopt;
199 
200     if (++nextElement == codecSplit.end())
201         return WTF::nullopt;
202 
203     auto profileID = *nextElement;
204     if (!profileID.length())
205         return WTF::nullopt;
206 
207     bool isIntegral = false;
208     auto firstCharacter = profileID[0];
209     // Profile definition can either be numeric or alpha:
210     if (firstCharacter == &#39;0&#39;) {
211         parameters.bitstreamProfileID = toIntegralType&lt;uint8_t&gt;(profileID, &amp;isIntegral, 10);
212         if (!isIntegral)
213             return WTF::nullopt;
214     } else {
215         auto alphanumericProfileString = codecView.left(5 + profileID.length()).toString();
216         auto profileID = profileIDForAlphabeticDoViProfile(alphanumericProfileString);
217         if (!profileID)
218             return WTF::nullopt;
219         parameters.bitstreamProfileID = profileID.value();
220     }
221 
222     if (!isValidDoViProfileID(parameters.bitstreamProfileID))
223         return WTF::nullopt;
224 
225     if (!isValidProfileIDForCodecName(parameters.bitstreamProfileID, parameters.codecName))
226         return WTF::nullopt;
227 
228     if (++nextElement == codecSplit.end())
229         return WTF::nullopt;
230 
231     auto levelID = *nextElement;
232     if (!levelID.length())
233         return WTF::nullopt;
234 
235     parameters.bitstreamLevelID = toIntegralType&lt;uint8_t&gt;(levelID, &amp;isIntegral, 10);
236     if (!isIntegral)
237         return WTF::nullopt;
238 
239     auto maximumLevelID = maximumLevelIDForDoViProfileID(parameters.bitstreamProfileID);
240     if (!maximumLevelID || parameters.bitstreamLevelID &gt; maximumLevelID.value())
241         return WTF::nullopt;
242 
243     return parameters;
244 }
245 
246 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CodeCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<a name="1" id="anc1"></a>
 28 #include &quot;CachedTypes.h&quot;
 29 #include &quot;ExecutableInfo.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;Parser.h&quot;
 32 #include &quot;ParserModes.h&quot;
 33 #include &quot;SourceCodeKey.h&quot;
 34 #include &quot;Strong.h&quot;
 35 #include &quot;StrongInlines.h&quot;
 36 #include &quot;UnlinkedCodeBlock.h&quot;
 37 #include &quot;UnlinkedEvalCodeBlock.h&quot;
 38 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
 39 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 40 #include &quot;UnlinkedProgramCodeBlock.h&quot;
 41 
 42 namespace JSC {
 43 
 44 class EvalExecutable;
 45 class IndirectEvalExecutable;
 46 class Identifier;
 47 class DirectEvalExecutable;
 48 class ModuleProgramExecutable;
 49 class ParserError;
 50 class ProgramExecutable;
 51 class SourceCode;
<a name="2" id="anc2"></a>




 52 class VM;
 53 class VariableEnvironment;
 54 
 55 namespace CodeCacheInternal {
<a name="3" id="anc3"></a><span class="line-modified"> 56 static constexpr bool verbose = false;</span>
 57 } // namespace CodeCacheInternal
 58 
 59 struct SourceCodeValue {
 60     SourceCodeValue()
 61     {
 62     }
 63 
 64     SourceCodeValue(VM&amp; vm, JSCell* cell, int64_t age)
 65         : cell(vm, cell)
 66         , age(age)
 67     {
 68     }
 69 
 70     Strong&lt;JSCell&gt; cell;
 71     int64_t age;
 72 };
 73 
 74 class CodeCacheMap {
 75 public:
 76     typedef HashMap&lt;SourceCodeKey, SourceCodeValue, SourceCodeKey::Hash, SourceCodeKey::HashTraits&gt; MapType;
 77     typedef MapType::iterator iterator;
 78     typedef MapType::AddResult AddResult;
 79 
 80     CodeCacheMap()
 81         : m_size(0)
 82         , m_sizeAtLastPrune(0)
 83         , m_timeAtLastPrune(MonotonicTime::now())
 84         , m_minCapacity(0)
 85         , m_capacity(0)
 86         , m_age(0)
 87     {
 88     }
 89 
 90     iterator begin() { return m_map.begin(); }
 91     iterator end() { return m_map.end(); }
 92 
 93     template&lt;typename UnlinkedCodeBlockType&gt;
 94     UnlinkedCodeBlockType* findCacheAndUpdateAge(VM&amp; vm, const SourceCodeKey&amp; key)
 95     {
 96         prune();
 97 
 98         iterator findResult = m_map.find(key);
 99         if (findResult == m_map.end())
100             return fetchFromDisk&lt;UnlinkedCodeBlockType&gt;(vm, key);
101 
102         int64_t age = m_age - findResult-&gt;value.age;
103         if (age &gt; m_capacity) {
104             // A requested object is older than the cache&#39;s capacity. We can
105             // infer that requested objects are subject to high eviction probability,
106             // so we grow the cache to improve our hit rate.
107             m_capacity += recencyBias * oldObjectSamplingMultiplier * key.length();
108         } else if (age &lt; m_capacity / 2) {
109             // A requested object is much younger than the cache&#39;s capacity. We can
110             // infer that requested objects are subject to low eviction probability,
111             // so we shrink the cache to save memory.
112             m_capacity -= recencyBias * key.length();
113             if (m_capacity &lt; m_minCapacity)
114                 m_capacity = m_minCapacity;
115         }
116 
117         findResult-&gt;value.age = m_age;
118         m_age += key.length();
119 
120         return jsCast&lt;UnlinkedCodeBlockType*&gt;(findResult-&gt;value.cell.get());
121     }
122 
123     AddResult addCache(const SourceCodeKey&amp; key, const SourceCodeValue&amp; value)
124     {
125         prune();
126 
127         AddResult addResult = m_map.add(key, value);
128         ASSERT(addResult.isNewEntry);
129 
130         m_size += key.length();
131         m_age += key.length();
132         return addResult;
133     }
134 
135     void remove(iterator it)
136     {
137         m_size -= it-&gt;key.length();
138         m_map.remove(it);
139     }
140 
141     void clear()
142     {
143         m_size = 0;
144         m_age = 0;
145         m_map.clear();
146     }
147 
148     int64_t age() { return m_age; }
149 
150 private:
151     template&lt;typename UnlinkedCodeBlockType&gt;
152     UnlinkedCodeBlockType* fetchFromDiskImpl(VM&amp; vm, const SourceCodeKey&amp; key)
153     {
154         RefPtr&lt;CachedBytecode&gt; cachedBytecode = key.source().provider().cachedBytecode();
155         if (!cachedBytecode || !cachedBytecode-&gt;size())
156             return nullptr;
157         return decodeCodeBlock&lt;UnlinkedCodeBlockType&gt;(vm, key, *cachedBytecode);
158     }
159 
160     template&lt;typename UnlinkedCodeBlockType&gt;
161     std::enable_if_t&lt;std::is_base_of&lt;UnlinkedCodeBlock, UnlinkedCodeBlockType&gt;::value &amp;&amp; !std::is_same&lt;UnlinkedCodeBlockType, UnlinkedEvalCodeBlock&gt;::value, UnlinkedCodeBlockType*&gt;
162     fetchFromDisk(VM&amp; vm, const SourceCodeKey&amp; key)
163     {
164         UnlinkedCodeBlockType* codeBlock = fetchFromDiskImpl&lt;UnlinkedCodeBlockType&gt;(vm, key);
165         if (UNLIKELY(Options::forceDiskCache()))
166             RELEASE_ASSERT(codeBlock);
167         return codeBlock;
168     }
169 
170     template&lt;typename T&gt;
171     std::enable_if_t&lt;!std::is_base_of&lt;UnlinkedCodeBlock, T&gt;::value || std::is_same&lt;T, UnlinkedEvalCodeBlock&gt;::value, T*&gt;
172     fetchFromDisk(VM&amp;, const SourceCodeKey&amp;) { return nullptr; }
173 
174     // This constant factor biases cache capacity toward allowing a minimum
175     // working set to enter the cache before it starts evicting.
<a name="4" id="anc4"></a><span class="line-modified">176     static constexpr Seconds workingSetTime = 10_s;</span>
<span class="line-modified">177     static constexpr int64_t workingSetMaxBytes = 16000000;</span>
<span class="line-modified">178     static constexpr size_t workingSetMaxEntries = 2000;</span>
179 
180     // This constant factor biases cache capacity toward recent activity. We
181     // want to adapt to changing workloads.
<a name="5" id="anc5"></a><span class="line-modified">182     static constexpr int64_t recencyBias = 4;</span>
183 
184     // This constant factor treats a sampled event for one old object as if it
185     // happened for many old objects. Most old objects are evicted before we can
186     // sample them, so we need to extrapolate from the ones we do sample.
<a name="6" id="anc6"></a><span class="line-modified">187     static constexpr int64_t oldObjectSamplingMultiplier = 32;</span>
188 
189     size_t numberOfEntries() const { return static_cast&lt;size_t&gt;(m_map.size()); }
190     bool canPruneQuickly() const { return numberOfEntries() &lt; workingSetMaxEntries; }
191 
192     void pruneSlowCase();
193     void prune()
194     {
195         if (m_size &lt;= m_capacity &amp;&amp; canPruneQuickly())
196             return;
197 
198         if (MonotonicTime::now() - m_timeAtLastPrune &lt; workingSetTime
199             &amp;&amp; m_size - m_sizeAtLastPrune &lt; workingSetMaxBytes
200             &amp;&amp; canPruneQuickly())
201                 return;
202 
203         pruneSlowCase();
204     }
205 
206     MapType m_map;
207     int64_t m_size;
208     int64_t m_sizeAtLastPrune;
209     MonotonicTime m_timeAtLastPrune;
210     int64_t m_minCapacity;
211     int64_t m_capacity;
212     int64_t m_age;
213 };
214 
215 // Caches top-level code such as &lt;script&gt;, window.eval(), new Function, and JSEvaluateScript().
216 class CodeCache {
217     WTF_MAKE_FAST_ALLOCATED;
218 public:
219     UnlinkedProgramCodeBlock* getUnlinkedProgramCodeBlock(VM&amp;, ProgramExecutable*, const SourceCode&amp;, JSParserStrictMode, OptionSet&lt;CodeGenerationMode&gt;, ParserError&amp;);
220     UnlinkedEvalCodeBlock* getUnlinkedEvalCodeBlock(VM&amp;, IndirectEvalExecutable*, const SourceCode&amp;, JSParserStrictMode, OptionSet&lt;CodeGenerationMode&gt;, ParserError&amp;, EvalContextType);
221     UnlinkedModuleProgramCodeBlock* getUnlinkedModuleProgramCodeBlock(VM&amp;, ModuleProgramExecutable*, const SourceCode&amp;, OptionSet&lt;CodeGenerationMode&gt;, ParserError&amp;);
222     UnlinkedFunctionExecutable* getUnlinkedGlobalFunctionExecutable(VM&amp;, const Identifier&amp;, const SourceCode&amp;, OptionSet&lt;CodeGenerationMode&gt;, Optional&lt;int&gt; functionConstructorParametersEndPosition, ParserError&amp;);
223 
224     void updateCache(const UnlinkedFunctionExecutable*, const SourceCode&amp;, CodeSpecializationKind, const UnlinkedFunctionCodeBlock*);
225 
226     void clear() { m_sourceCode.clear(); }
227     JS_EXPORT_PRIVATE void write(VM&amp;);
228 
229 private:
230     template &lt;class UnlinkedCodeBlockType, class ExecutableType&gt;
231     UnlinkedCodeBlockType* getUnlinkedGlobalCodeBlock(VM&amp;, ExecutableType*, const SourceCode&amp;, JSParserStrictMode, JSParserScriptMode, OptionSet&lt;CodeGenerationMode&gt;, ParserError&amp;, EvalContextType);
232 
233     CodeCacheMap m_sourceCode;
234 };
235 
236 template &lt;typename T&gt; struct CacheTypes { };
237 
238 template &lt;&gt; struct CacheTypes&lt;UnlinkedProgramCodeBlock&gt; {
239     typedef JSC::ProgramNode RootNode;
<a name="7" id="anc7"></a><span class="line-modified">240     static constexpr SourceCodeType codeType = SourceCodeType::ProgramType;</span>
<span class="line-modified">241     static constexpr SourceParseMode parseMode = SourceParseMode::ProgramMode;</span>
242 };
243 
244 template &lt;&gt; struct CacheTypes&lt;UnlinkedEvalCodeBlock&gt; {
245     typedef JSC::EvalNode RootNode;
<a name="8" id="anc8"></a><span class="line-modified">246     static constexpr SourceCodeType codeType = SourceCodeType::EvalType;</span>
<span class="line-modified">247     static constexpr SourceParseMode parseMode = SourceParseMode::ProgramMode;</span>
248 };
249 
250 template &lt;&gt; struct CacheTypes&lt;UnlinkedModuleProgramCodeBlock&gt; {
251     typedef JSC::ModuleProgramNode RootNode;
<a name="9" id="anc9"></a><span class="line-modified">252     static constexpr SourceCodeType codeType = SourceCodeType::ModuleType;</span>
<span class="line-modified">253     static constexpr SourceParseMode parseMode = SourceParseMode::ModuleEvaluateMode;</span>
254 };
255 
<a name="10" id="anc10"></a><span class="line-modified">256 UnlinkedEvalCodeBlock* generateUnlinkedCodeBlockForDirectEval(VM&amp;, DirectEvalExecutable*, const SourceCode&amp;, JSParserStrictMode, JSParserScriptMode, OptionSet&lt;CodeGenerationMode&gt;, ParserError&amp;, EvalContextType, const VariableEnvironment* variablesUnderTDZ);</span>
<span class="line-modified">257 UnlinkedProgramCodeBlock* recursivelyGenerateUnlinkedCodeBlockForProgram(VM&amp;, const SourceCode&amp;, JSParserStrictMode, JSParserScriptMode, OptionSet&lt;CodeGenerationMode&gt;, ParserError&amp;, EvalContextType, const VariableEnvironment* variablesUnderTDZ);</span>
<span class="line-modified">258 UnlinkedModuleProgramCodeBlock* recursivelyGenerateUnlinkedCodeBlockForModuleProgram(VM&amp;, const SourceCode&amp;, JSParserStrictMode, JSParserScriptMode, OptionSet&lt;CodeGenerationMode&gt;, ParserError&amp;, EvalContextType, const VariableEnvironment* variablesUnderTDZ);</span>






















































259 
260 void writeCodeBlock(VM&amp;, const SourceCodeKey&amp;, const SourceCodeValue&amp;);
261 RefPtr&lt;CachedBytecode&gt; serializeBytecode(VM&amp;, UnlinkedCodeBlock*, const SourceCode&amp;, SourceCodeType, JSParserStrictMode, JSParserScriptMode, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp;, OptionSet&lt;CodeGenerationMode&gt;);
262 SourceCodeKey sourceCodeKeyForSerializedProgram(VM&amp;, const SourceCode&amp;);
263 SourceCodeKey sourceCodeKeyForSerializedModule(VM&amp;, const SourceCode&amp;);
264 
265 } // namespace JSC
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
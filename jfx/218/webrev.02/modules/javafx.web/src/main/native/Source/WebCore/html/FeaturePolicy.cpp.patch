diff a/modules/javafx.web/src/main/native/Source/WebCore/html/FeaturePolicy.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/FeaturePolicy.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/FeaturePolicy.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/FeaturePolicy.cpp
@@ -24,16 +24,68 @@
  */
 
 #include "config.h"
 #include "FeaturePolicy.h"
 
+#include "DOMWindow.h"
 #include "Document.h"
+#include "HTMLIFrameElement.h"
+#include "HTMLNames.h"
 #include "HTMLParserIdioms.h"
 #include "SecurityOrigin.h"
 
 namespace WebCore {
 
+using namespace HTMLNames;
+
+static const char* policyTypeName(FeaturePolicy::Type type)
+{
+    switch (type) {
+    case FeaturePolicy::Type::Camera:
+        return "Camera";
+    case FeaturePolicy::Type::Microphone:
+        return "Microphone";
+    case FeaturePolicy::Type::DisplayCapture:
+        return "DisplayCapture";
+    case FeaturePolicy::Type::SyncXHR:
+        return "SyncXHR";
+    case FeaturePolicy::Type::Fullscreen:
+        return "Fullscreen";
+    }
+    ASSERT_NOT_REACHED();
+    return "";
+}
+
+bool isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type type, const Document& document, LogFeaturePolicyFailure logFailure)
+{
+    auto& topDocument = document.topDocument();
+    auto* ancestorDocument = &document;
+    while (ancestorDocument != &topDocument) {
+        if (!ancestorDocument) {
+            if (logFailure == LogFeaturePolicyFailure::Yes && document.domWindow())
+                document.domWindow()->printErrorMessage(makeString("Feature policy '", policyTypeName(type), "' check failed."));
+            return false;
+        }
+
+        auto* ownerElement = ancestorDocument->ownerElement();
+        if (is<HTMLIFrameElement>(ownerElement)) {
+            const auto& featurePolicy = downcast<HTMLIFrameElement>(ownerElement)->featurePolicy();
+            if (!featurePolicy.allows(type, ancestorDocument->securityOrigin().data())) {
+                if (logFailure == LogFeaturePolicyFailure::Yes && document.domWindow()) {
+                    auto& allowValue = downcast<HTMLIFrameElement>(ownerElement)->attributeWithoutSynchronization(HTMLNames::allowAttr);
+                    document.domWindow()->printErrorMessage(makeString("Feature policy '", policyTypeName(type), "' check failed for iframe with origin '", document.securityOrigin().toString(), "' and allow attribute '", allowValue, "'."));
+                }
+                return false;
+            }
+        }
+
+        ancestorDocument = ancestorDocument->parentDocument();
+    }
+
+    return true;
+}
+
 static bool isAllowedByFeaturePolicy(const FeaturePolicy::AllowRule& rule, const SecurityOriginData& origin)
 {
     switch (rule.type) {
     case FeaturePolicy::AllowRule::Type::None:
         return false;
@@ -92,16 +144,18 @@
         processOriginItem(document, rule, value.substring(0, position));
         value = value.substring(position + 1).stripLeadingAndTrailingMatchedCharacters(isHTMLSpace<UChar>);
     }
 }
 
-FeaturePolicy FeaturePolicy::parse(Document& document, StringView allowAttributeValue)
+FeaturePolicy FeaturePolicy::parse(Document& document, const HTMLIFrameElement& iframe, StringView allowAttributeValue)
 {
     FeaturePolicy policy;
     bool isCameraInitialized = false;
     bool isMicrophoneInitialized = false;
     bool isDisplayCaptureInitialized = false;
+    bool isSyncXHRInitialized = false;
+    bool isFullscreenInitialized = false;
     for (auto allowItem : allowAttributeValue.split(';')) {
         auto item = allowItem.stripLeadingAndTrailingMatchedCharacters(isHTMLSpace<UChar>);
         if (item.startsWith("camera")) {
             isCameraInitialized = true;
             updateList(document, policy.m_cameraRule, item.substring(7));
@@ -115,20 +169,48 @@
         if (item.startsWith("display-capture")) {
             isDisplayCaptureInitialized = true;
             updateList(document, policy.m_displayCaptureRule, item.substring(16));
             continue;
         }
+        if (item.startsWith("sync-xhr")) {
+            isSyncXHRInitialized = true;
+            updateList(document, policy.m_syncXHRRule, item.substring(8));
+            continue;
+        }
+        if (item.startsWith("fullscreen")) {
+            isFullscreenInitialized = true;
+            updateList(document, policy.m_fullscreenRule, item.substring(11));
+            continue;
+        }
     }
 
-    // By default, camera, microphone and display-capture policy is 'self'
+    // By default, camera, microphone, display-capture, and fullscreen policy is 'self'
     if (!isCameraInitialized)
         policy.m_cameraRule.allowedList.add(document.securityOrigin().data());
     if (!isMicrophoneInitialized)
         policy.m_microphoneRule.allowedList.add(document.securityOrigin().data());
     if (!isDisplayCaptureInitialized)
         policy.m_displayCaptureRule.allowedList.add(document.securityOrigin().data());
 
+    // https://w3c.github.io/webappsec-feature-policy/#process-feature-policy-attributes
+    // 9.5 Process Feature Policy Attributes
+    // 3.1 If elementâ€™s allowfullscreen attribute is specified, and container policy does
+    //     not contain an allowlist for fullscreen,
+    if (!isFullscreenInitialized) {
+        if (iframe.hasAttribute(allowfullscreenAttr) || iframe.hasAttribute(webkitallowfullscreenAttr)) {
+            // 3.1.1 Construct a new declaration for fullscreen, whose allowlist is the special value *.
+            policy.m_fullscreenRule.type = FeaturePolicy::AllowRule::Type::All;
+        } else {
+            // https://fullscreen.spec.whatwg.org/#feature-policy-integration
+            // The default allowlist is 'self'.
+            policy.m_fullscreenRule.allowedList.add(document.securityOrigin().data());
+        }
+    }
+
+    if (!isSyncXHRInitialized)
+        policy.m_syncXHRRule.type = AllowRule::Type::All;
+
     return policy;
 }
 
 bool FeaturePolicy::allows(Type type, const SecurityOriginData& origin) const
 {
@@ -137,10 +219,14 @@
         return isAllowedByFeaturePolicy(m_cameraRule, origin);
     case Type::Microphone:
         return isAllowedByFeaturePolicy(m_microphoneRule, origin);
     case Type::DisplayCapture:
         return isAllowedByFeaturePolicy(m_displayCaptureRule, origin);
+    case Type::SyncXHR:
+        return isAllowedByFeaturePolicy(m_syncXHRRule, origin);
+    case Type::Fullscreen:
+        return isAllowedByFeaturePolicy(m_fullscreenRule, origin);
     }
     ASSERT_NOT_REACHED();
     return false;
 }
 

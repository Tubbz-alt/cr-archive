<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpConstructor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpCachedResult.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpConstructor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpConstructor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RegExpConstructor.h&quot;
 24 
 25 #include &quot;Error.h&quot;
 26 #include &quot;GetterSetter.h&quot;
 27 #include &quot;JSCInlines.h&quot;
 28 #include &quot;RegExpGlobalDataInlines.h&quot;
 29 #include &quot;RegExpPrototype.h&quot;
 30 #include &quot;YarrFlags.h&quot;
 31 
 32 namespace JSC {
 33 
<span class="line-modified"> 34 static EncodedJSValue regExpConstructorInput(ExecState*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 35 static EncodedJSValue regExpConstructorMultiline(ExecState*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 36 static EncodedJSValue regExpConstructorLastMatch(ExecState*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 37 static EncodedJSValue regExpConstructorLastParen(ExecState*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 38 static EncodedJSValue regExpConstructorLeftContext(ExecState*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 39 static EncodedJSValue regExpConstructorRightContext(ExecState*, EncodedJSValue, PropertyName);</span>
 40 template&lt;int N&gt;
<span class="line-modified"> 41 static EncodedJSValue regExpConstructorDollar(ExecState*, EncodedJSValue, PropertyName);</span>
 42 
<span class="line-modified"> 43 static bool setRegExpConstructorInput(ExecState*, EncodedJSValue, EncodedJSValue);</span>
<span class="line-modified"> 44 static bool setRegExpConstructorMultiline(ExecState*, EncodedJSValue, EncodedJSValue);</span>
 45 
 46 } // namespace JSC
 47 
 48 #include &quot;RegExpConstructor.lut.h&quot;
 49 
 50 namespace JSC {
 51 
 52 const ClassInfo RegExpConstructor::s_info = { &quot;Function&quot;, &amp;InternalFunction::s_info, &amp;regExpConstructorTable, nullptr, CREATE_METHOD_TABLE(RegExpConstructor) };
 53 
 54 /* Source for RegExpConstructor.lut.h
 55 @begin regExpConstructorTable
 56     input           regExpConstructorInput          None
 57     $_              regExpConstructorInput          DontEnum
 58     multiline       regExpConstructorMultiline      None
 59     $*              regExpConstructorMultiline      DontEnum
 60     lastMatch       regExpConstructorLastMatch      DontDelete|ReadOnly
 61     $&amp;              regExpConstructorLastMatch      DontDelete|ReadOnly|DontEnum
 62     lastParen       regExpConstructorLastParen      DontDelete|ReadOnly
 63     $+              regExpConstructorLastParen      DontDelete|ReadOnly|DontEnum
 64     leftContext     regExpConstructorLeftContext    DontDelete|ReadOnly
 65     $`              regExpConstructorLeftContext    DontDelete|ReadOnly|DontEnum
 66     rightContext    regExpConstructorRightContext   DontDelete|ReadOnly
 67     $&#39;              regExpConstructorRightContext   DontDelete|ReadOnly|DontEnum
 68     $1              regExpConstructorDollar&lt;1&gt;      DontDelete|ReadOnly
 69     $2              regExpConstructorDollar&lt;2&gt;      DontDelete|ReadOnly
 70     $3              regExpConstructorDollar&lt;3&gt;      DontDelete|ReadOnly
 71     $4              regExpConstructorDollar&lt;4&gt;      DontDelete|ReadOnly
 72     $5              regExpConstructorDollar&lt;5&gt;      DontDelete|ReadOnly
 73     $6              regExpConstructorDollar&lt;6&gt;      DontDelete|ReadOnly
 74     $7              regExpConstructorDollar&lt;7&gt;      DontDelete|ReadOnly
 75     $8              regExpConstructorDollar&lt;8&gt;      DontDelete|ReadOnly
 76     $9              regExpConstructorDollar&lt;9&gt;      DontDelete|ReadOnly
 77 @end
 78 */
 79 
 80 
<span class="line-modified"> 81 static EncodedJSValue JSC_HOST_CALL callRegExpConstructor(ExecState*);</span>
<span class="line-modified"> 82 static EncodedJSValue JSC_HOST_CALL constructWithRegExpConstructor(ExecState*);</span>
 83 
 84 RegExpConstructor::RegExpConstructor(VM&amp; vm, Structure* structure)
 85     : InternalFunction(vm, structure, callRegExpConstructor, constructWithRegExpConstructor)
 86 {
 87 }
 88 
 89 void RegExpConstructor::finishCreation(VM&amp; vm, RegExpPrototype* regExpPrototype, GetterSetter* speciesSymbol)
 90 {
<span class="line-modified"> 91     Base::finishCreation(vm, vm.propertyNames-&gt;RegExp.string(), NameVisibility::Visible, NameAdditionMode::WithoutStructureTransition);</span>
 92     ASSERT(inherits(vm, info()));
 93 
 94     putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, regExpPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
 95     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(2), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 96 
 97     putDirectNonIndexAccessorWithoutTransition(vm, vm.propertyNames-&gt;speciesSymbol, speciesSymbol, PropertyAttribute::Accessor | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 98 }
 99 
100 template&lt;int N&gt;
<span class="line-modified">101 EncodedJSValue regExpConstructorDollar(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
102 {
<span class="line-modified">103     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">104     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject(vm);</span>
<span class="line-removed">105     return JSValue::encode(globalObject-&gt;regExpGlobalData().getBackref(exec, globalObject, N));</span>
106 }
107 
<span class="line-modified">108 EncodedJSValue regExpConstructorInput(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
109 {
<span class="line-modified">110     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">111     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject(vm);</span>
112     return JSValue::encode(globalObject-&gt;regExpGlobalData().input());
113 }
114 
<span class="line-modified">115 EncodedJSValue regExpConstructorMultiline(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
116 {
<span class="line-modified">117     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">118     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject(vm);</span>
119     return JSValue::encode(jsBoolean(globalObject-&gt;regExpGlobalData().multiline()));
120 }
121 
<span class="line-modified">122 EncodedJSValue regExpConstructorLastMatch(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
123 {
<span class="line-modified">124     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">125     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject(vm);</span>
<span class="line-removed">126     return JSValue::encode(globalObject-&gt;regExpGlobalData().getBackref(exec, globalObject, 0));</span>
127 }
128 
<span class="line-modified">129 EncodedJSValue regExpConstructorLastParen(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
130 {
<span class="line-modified">131     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">132     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject(vm);</span>
<span class="line-removed">133     return JSValue::encode(globalObject-&gt;regExpGlobalData().getLastParen(exec, globalObject));</span>
134 }
135 
<span class="line-modified">136 EncodedJSValue regExpConstructorLeftContext(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
137 {
<span class="line-modified">138     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">139     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject(vm);</span>
<span class="line-removed">140     return JSValue::encode(globalObject-&gt;regExpGlobalData().getLeftContext(exec, globalObject));</span>
141 }
142 
<span class="line-modified">143 EncodedJSValue regExpConstructorRightContext(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
144 {
<span class="line-modified">145     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">146     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject(vm);</span>
<span class="line-removed">147     return JSValue::encode(globalObject-&gt;regExpGlobalData().getRightContext(exec, globalObject));</span>
148 }
149 
<span class="line-modified">150 bool setRegExpConstructorInput(ExecState* exec, EncodedJSValue thisValue, EncodedJSValue value)</span>
151 {
<span class="line-modified">152     VM&amp; vm = exec-&gt;vm();</span>
153     auto scope = DECLARE_THROW_SCOPE(vm);
154     if (auto constructor = jsDynamicCast&lt;RegExpConstructor*&gt;(vm, JSValue::decode(thisValue))) {
<span class="line-modified">155         auto* string = JSValue::decode(value).toString(exec);</span>
156         RETURN_IF_EXCEPTION(scope, { });
157         scope.release();
<span class="line-modified">158         JSGlobalObject* globalObject = constructor-&gt;globalObject(vm);</span>
<span class="line-modified">159         globalObject-&gt;regExpGlobalData().setInput(exec, globalObject, string);</span>
160         return true;
161     }
162     return false;
163 }
164 
<span class="line-modified">165 bool setRegExpConstructorMultiline(ExecState* exec, EncodedJSValue thisValue, EncodedJSValue value)</span>
166 {
<span class="line-modified">167     VM&amp; vm = exec-&gt;vm();</span>
168     auto scope = DECLARE_THROW_SCOPE(vm);
169     if (auto constructor = jsDynamicCast&lt;RegExpConstructor*&gt;(vm, JSValue::decode(thisValue))) {
<span class="line-modified">170         bool multiline = JSValue::decode(value).toBoolean(exec);</span>
171         RETURN_IF_EXCEPTION(scope, { });
172         scope.release();
<span class="line-modified">173         JSGlobalObject* globalObject = constructor-&gt;globalObject(vm);</span>
174         globalObject-&gt;regExpGlobalData().setMultiline(multiline);
175         return true;
176     }
177     return false;
178 }
179 
<span class="line-modified">180 inline Structure* getRegExpStructure(ExecState* exec, JSGlobalObject* globalObject, JSValue newTarget)</span>
181 {
182     Structure* structure = globalObject-&gt;regExpStructure();
183     if (newTarget != jsUndefined())
<span class="line-modified">184         structure = InternalFunction::createSubclassStructure(exec, newTarget, structure);</span>
185     return structure;
186 }
187 
<span class="line-modified">188 inline OptionSet&lt;Yarr::Flags&gt; toFlags(ExecState* exec, JSValue flags)</span>
189 {
<span class="line-modified">190     VM&amp; vm = exec-&gt;vm();</span>
191     auto scope = DECLARE_THROW_SCOPE(vm);
192 
193     if (flags.isUndefined())
194         return { };
195 
<span class="line-modified">196     auto result = Yarr::parseFlags(flags.toWTFString(exec));</span>
197     RETURN_IF_EXCEPTION(scope, { });
198     if (!result) {
<span class="line-modified">199         throwSyntaxError(exec, scope, &quot;Invalid flags supplied to RegExp constructor.&quot;_s);</span>
200         return { };
201     }
202 
203     return result.value();
204 }
205 
<span class="line-modified">206 static JSObject* regExpCreate(ExecState* exec, JSGlobalObject* globalObject, JSValue newTarget, JSValue patternArg, JSValue flagsArg)</span>
207 {
<span class="line-modified">208     VM&amp; vm = exec-&gt;vm();</span>
209     auto scope = DECLARE_THROW_SCOPE(vm);
210 
<span class="line-modified">211     String pattern = patternArg.isUndefined() ? emptyString() : patternArg.toWTFString(exec);</span>
212     RETURN_IF_EXCEPTION(scope, nullptr);
213 
<span class="line-modified">214     auto flags = toFlags(exec, flagsArg);</span>
215     RETURN_IF_EXCEPTION(scope, nullptr);
216 
217     RegExp* regExp = RegExp::create(vm, pattern, flags);
218     if (UNLIKELY(!regExp-&gt;isValid())) {
<span class="line-modified">219         throwException(exec, scope, regExp-&gt;errorToThrow(exec));</span>
220         return nullptr;
221     }
222 
<span class="line-modified">223     Structure* structure = getRegExpStructure(exec, globalObject, newTarget);</span>
224     RETURN_IF_EXCEPTION(scope, nullptr);
225     return RegExpObject::create(vm, structure, regExp);
226 }
227 
<span class="line-modified">228 JSObject* constructRegExp(ExecState* exec, JSGlobalObject* globalObject, const ArgList&amp; args,  JSObject* callee, JSValue newTarget)</span>
229 {
<span class="line-modified">230     VM&amp; vm = exec-&gt;vm();</span>
231     auto scope = DECLARE_THROW_SCOPE(vm);
232     JSValue patternArg = args.at(0);
233     JSValue flagsArg = args.at(1);
234 
235     bool isPatternRegExp = patternArg.inherits&lt;RegExpObject&gt;(vm);
<span class="line-modified">236     bool constructAsRegexp = isRegExp(vm, exec, patternArg);</span>
237     RETURN_IF_EXCEPTION(scope, nullptr);
238 
239     if (newTarget.isUndefined() &amp;&amp; constructAsRegexp &amp;&amp; flagsArg.isUndefined()) {
<span class="line-modified">240         JSValue constructor = patternArg.get(exec, vm.propertyNames-&gt;constructor);</span>
241         RETURN_IF_EXCEPTION(scope, nullptr);
242         if (callee == constructor) {
243             // We know that patternArg is a object otherwise constructAsRegexp would be false.
244             return patternArg.getObject();
245         }
246     }
247 
248     if (isPatternRegExp) {
249         RegExp* regExp = jsCast&lt;RegExpObject*&gt;(patternArg)-&gt;regExp();
<span class="line-modified">250         Structure* structure = getRegExpStructure(exec, globalObject, newTarget);</span>
251         RETURN_IF_EXCEPTION(scope, nullptr);
252 
253         if (!flagsArg.isUndefined()) {
<span class="line-modified">254             auto flags = toFlags(exec, flagsArg);</span>
255             RETURN_IF_EXCEPTION(scope, nullptr);
256 
257             regExp = RegExp::create(vm, regExp-&gt;pattern(), flags);
258             if (UNLIKELY(!regExp-&gt;isValid())) {
<span class="line-modified">259                 throwException(exec, scope, regExp-&gt;errorToThrow(exec));</span>
260                 return nullptr;
261             }
262         }
263 
264         return RegExpObject::create(vm, structure, regExp);
265     }
266 
267     if (constructAsRegexp) {
<span class="line-modified">268         JSValue pattern = patternArg.get(exec, vm.propertyNames-&gt;source);</span>
269         RETURN_IF_EXCEPTION(scope, nullptr);
270         if (flagsArg.isUndefined()) {
<span class="line-modified">271             flagsArg = patternArg.get(exec, vm.propertyNames-&gt;flags);</span>
272             RETURN_IF_EXCEPTION(scope, nullptr);
273         }
274         patternArg = pattern;
275     }
276 
<span class="line-modified">277     RELEASE_AND_RETURN(scope, regExpCreate(exec, globalObject, newTarget, patternArg, flagsArg));</span>
278 }
279 
<span class="line-modified">280 EncodedJSValue JSC_HOST_CALL esSpecRegExpCreate(ExecState* exec)</span>
281 {
<span class="line-modified">282     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-modified">283     JSValue patternArg = exec-&gt;argument(0);</span>
<span class="line-modified">284     JSValue flagsArg = exec-&gt;argument(1);</span>
<span class="line-removed">285     return JSValue::encode(regExpCreate(exec, globalObject, jsUndefined(), patternArg, flagsArg));</span>
286 }
287 
<span class="line-modified">288 static EncodedJSValue JSC_HOST_CALL constructWithRegExpConstructor(ExecState* exec)</span>
289 {
<span class="line-modified">290     ArgList args(exec);</span>
<span class="line-modified">291     return JSValue::encode(constructRegExp(exec, jsCast&lt;InternalFunction*&gt;(exec-&gt;jsCallee())-&gt;globalObject(exec-&gt;vm()), args, exec-&gt;jsCallee(), exec-&gt;newTarget()));</span>
292 }
293 
<span class="line-modified">294 static EncodedJSValue JSC_HOST_CALL callRegExpConstructor(ExecState* exec)</span>
295 {
<span class="line-modified">296     ArgList args(exec);</span>
<span class="line-modified">297     return JSValue::encode(constructRegExp(exec, jsCast&lt;InternalFunction*&gt;(exec-&gt;jsCallee())-&gt;globalObject(exec-&gt;vm()), args, exec-&gt;jsCallee()));</span>






298 }
299 
300 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RegExpConstructor.h&quot;
 24 
 25 #include &quot;Error.h&quot;
 26 #include &quot;GetterSetter.h&quot;
 27 #include &quot;JSCInlines.h&quot;
 28 #include &quot;RegExpGlobalDataInlines.h&quot;
 29 #include &quot;RegExpPrototype.h&quot;
 30 #include &quot;YarrFlags.h&quot;
 31 
 32 namespace JSC {
 33 
<span class="line-modified"> 34 static EncodedJSValue regExpConstructorInput(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 35 static EncodedJSValue regExpConstructorMultiline(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 36 static EncodedJSValue regExpConstructorLastMatch(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 37 static EncodedJSValue regExpConstructorLastParen(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 38 static EncodedJSValue regExpConstructorLeftContext(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
<span class="line-modified"> 39 static EncodedJSValue regExpConstructorRightContext(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
 40 template&lt;int N&gt;
<span class="line-modified"> 41 static EncodedJSValue regExpConstructorDollar(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
 42 
<span class="line-modified"> 43 static bool setRegExpConstructorInput(JSGlobalObject*, EncodedJSValue, EncodedJSValue);</span>
<span class="line-modified"> 44 static bool setRegExpConstructorMultiline(JSGlobalObject*, EncodedJSValue, EncodedJSValue);</span>
 45 
 46 } // namespace JSC
 47 
 48 #include &quot;RegExpConstructor.lut.h&quot;
 49 
 50 namespace JSC {
 51 
 52 const ClassInfo RegExpConstructor::s_info = { &quot;Function&quot;, &amp;InternalFunction::s_info, &amp;regExpConstructorTable, nullptr, CREATE_METHOD_TABLE(RegExpConstructor) };
 53 
 54 /* Source for RegExpConstructor.lut.h
 55 @begin regExpConstructorTable
 56     input           regExpConstructorInput          None
 57     $_              regExpConstructorInput          DontEnum
 58     multiline       regExpConstructorMultiline      None
 59     $*              regExpConstructorMultiline      DontEnum
 60     lastMatch       regExpConstructorLastMatch      DontDelete|ReadOnly
 61     $&amp;              regExpConstructorLastMatch      DontDelete|ReadOnly|DontEnum
 62     lastParen       regExpConstructorLastParen      DontDelete|ReadOnly
 63     $+              regExpConstructorLastParen      DontDelete|ReadOnly|DontEnum
 64     leftContext     regExpConstructorLeftContext    DontDelete|ReadOnly
 65     $`              regExpConstructorLeftContext    DontDelete|ReadOnly|DontEnum
 66     rightContext    regExpConstructorRightContext   DontDelete|ReadOnly
 67     $&#39;              regExpConstructorRightContext   DontDelete|ReadOnly|DontEnum
 68     $1              regExpConstructorDollar&lt;1&gt;      DontDelete|ReadOnly
 69     $2              regExpConstructorDollar&lt;2&gt;      DontDelete|ReadOnly
 70     $3              regExpConstructorDollar&lt;3&gt;      DontDelete|ReadOnly
 71     $4              regExpConstructorDollar&lt;4&gt;      DontDelete|ReadOnly
 72     $5              regExpConstructorDollar&lt;5&gt;      DontDelete|ReadOnly
 73     $6              regExpConstructorDollar&lt;6&gt;      DontDelete|ReadOnly
 74     $7              regExpConstructorDollar&lt;7&gt;      DontDelete|ReadOnly
 75     $8              regExpConstructorDollar&lt;8&gt;      DontDelete|ReadOnly
 76     $9              regExpConstructorDollar&lt;9&gt;      DontDelete|ReadOnly
 77 @end
 78 */
 79 
 80 
<span class="line-modified"> 81 static EncodedJSValue JSC_HOST_CALL callRegExpConstructor(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 82 static EncodedJSValue JSC_HOST_CALL constructWithRegExpConstructor(JSGlobalObject*, CallFrame*);</span>
 83 
 84 RegExpConstructor::RegExpConstructor(VM&amp; vm, Structure* structure)
 85     : InternalFunction(vm, structure, callRegExpConstructor, constructWithRegExpConstructor)
 86 {
 87 }
 88 
 89 void RegExpConstructor::finishCreation(VM&amp; vm, RegExpPrototype* regExpPrototype, GetterSetter* speciesSymbol)
 90 {
<span class="line-modified"> 91     Base::finishCreation(vm, vm.propertyNames-&gt;RegExp.string(), NameAdditionMode::WithoutStructureTransition);</span>
 92     ASSERT(inherits(vm, info()));
 93 
 94     putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, regExpPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
 95     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(2), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 96 
 97     putDirectNonIndexAccessorWithoutTransition(vm, vm.propertyNames-&gt;speciesSymbol, speciesSymbol, PropertyAttribute::Accessor | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 98 }
 99 
100 template&lt;int N&gt;
<span class="line-modified">101 EncodedJSValue regExpConstructorDollar(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
102 {
<span class="line-modified">103     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject();</span>
<span class="line-modified">104     return JSValue::encode(globalObject-&gt;regExpGlobalData().getBackref(globalObject, N));</span>

105 }
106 
<span class="line-modified">107 EncodedJSValue regExpConstructorInput(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
108 {
<span class="line-modified">109     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject();</span>

110     return JSValue::encode(globalObject-&gt;regExpGlobalData().input());
111 }
112 
<span class="line-modified">113 EncodedJSValue regExpConstructorMultiline(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
114 {
<span class="line-modified">115     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject();</span>

116     return JSValue::encode(jsBoolean(globalObject-&gt;regExpGlobalData().multiline()));
117 }
118 
<span class="line-modified">119 EncodedJSValue regExpConstructorLastMatch(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
120 {
<span class="line-modified">121     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject();</span>
<span class="line-modified">122     return JSValue::encode(globalObject-&gt;regExpGlobalData().getBackref(globalObject, 0));</span>

123 }
124 
<span class="line-modified">125 EncodedJSValue regExpConstructorLastParen(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
126 {
<span class="line-modified">127     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject();</span>
<span class="line-modified">128     return JSValue::encode(globalObject-&gt;regExpGlobalData().getLastParen(globalObject));</span>

129 }
130 
<span class="line-modified">131 EncodedJSValue regExpConstructorLeftContext(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
132 {
<span class="line-modified">133     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject();</span>
<span class="line-modified">134     return JSValue::encode(globalObject-&gt;regExpGlobalData().getLeftContext(globalObject));</span>

135 }
136 
<span class="line-modified">137 EncodedJSValue regExpConstructorRightContext(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
138 {
<span class="line-modified">139     JSGlobalObject* globalObject = jsCast&lt;RegExpConstructor*&gt;(JSValue::decode(thisValue))-&gt;globalObject();</span>
<span class="line-modified">140     return JSValue::encode(globalObject-&gt;regExpGlobalData().getRightContext(globalObject));</span>

141 }
142 
<span class="line-modified">143 bool setRegExpConstructorInput(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
144 {
<span class="line-modified">145     VM&amp; vm = globalObject-&gt;vm();</span>
146     auto scope = DECLARE_THROW_SCOPE(vm);
147     if (auto constructor = jsDynamicCast&lt;RegExpConstructor*&gt;(vm, JSValue::decode(thisValue))) {
<span class="line-modified">148         auto* string = JSValue::decode(value).toString(globalObject);</span>
149         RETURN_IF_EXCEPTION(scope, { });
150         scope.release();
<span class="line-modified">151         JSGlobalObject* globalObject = constructor-&gt;globalObject();</span>
<span class="line-modified">152         globalObject-&gt;regExpGlobalData().setInput(globalObject, string);</span>
153         return true;
154     }
155     return false;
156 }
157 
<span class="line-modified">158 bool setRegExpConstructorMultiline(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
159 {
<span class="line-modified">160     VM&amp; vm = globalObject-&gt;vm();</span>
161     auto scope = DECLARE_THROW_SCOPE(vm);
162     if (auto constructor = jsDynamicCast&lt;RegExpConstructor*&gt;(vm, JSValue::decode(thisValue))) {
<span class="line-modified">163         bool multiline = JSValue::decode(value).toBoolean(globalObject);</span>
164         RETURN_IF_EXCEPTION(scope, { });
165         scope.release();
<span class="line-modified">166         JSGlobalObject* globalObject = constructor-&gt;globalObject();</span>
167         globalObject-&gt;regExpGlobalData().setMultiline(multiline);
168         return true;
169     }
170     return false;
171 }
172 
<span class="line-modified">173 inline Structure* getRegExpStructure(JSGlobalObject* globalObject, JSValue newTarget)</span>
174 {
175     Structure* structure = globalObject-&gt;regExpStructure();
176     if (newTarget != jsUndefined())
<span class="line-modified">177         structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;regExpConstructor(), newTarget, structure);</span>
178     return structure;
179 }
180 
<span class="line-modified">181 inline OptionSet&lt;Yarr::Flags&gt; toFlags(JSGlobalObject* globalObject, JSValue flags)</span>
182 {
<span class="line-modified">183     VM&amp; vm = globalObject-&gt;vm();</span>
184     auto scope = DECLARE_THROW_SCOPE(vm);
185 
186     if (flags.isUndefined())
187         return { };
188 
<span class="line-modified">189     auto result = Yarr::parseFlags(flags.toWTFString(globalObject));</span>
190     RETURN_IF_EXCEPTION(scope, { });
191     if (!result) {
<span class="line-modified">192         throwSyntaxError(globalObject, scope, &quot;Invalid flags supplied to RegExp constructor.&quot;_s);</span>
193         return { };
194     }
195 
196     return result.value();
197 }
198 
<span class="line-modified">199 static JSObject* regExpCreate(JSGlobalObject* globalObject, JSValue newTarget, JSValue patternArg, JSValue flagsArg)</span>
200 {
<span class="line-modified">201     VM&amp; vm = globalObject-&gt;vm();</span>
202     auto scope = DECLARE_THROW_SCOPE(vm);
203 
<span class="line-modified">204     String pattern = patternArg.isUndefined() ? emptyString() : patternArg.toWTFString(globalObject);</span>
205     RETURN_IF_EXCEPTION(scope, nullptr);
206 
<span class="line-modified">207     auto flags = toFlags(globalObject, flagsArg);</span>
208     RETURN_IF_EXCEPTION(scope, nullptr);
209 
210     RegExp* regExp = RegExp::create(vm, pattern, flags);
211     if (UNLIKELY(!regExp-&gt;isValid())) {
<span class="line-modified">212         throwException(globalObject, scope, regExp-&gt;errorToThrow(globalObject));</span>
213         return nullptr;
214     }
215 
<span class="line-modified">216     Structure* structure = getRegExpStructure(globalObject, newTarget);</span>
217     RETURN_IF_EXCEPTION(scope, nullptr);
218     return RegExpObject::create(vm, structure, regExp);
219 }
220 
<span class="line-modified">221 JSObject* constructRegExp(JSGlobalObject* globalObject, const ArgList&amp; args,  JSObject* callee, JSValue newTarget)</span>
222 {
<span class="line-modified">223     VM&amp; vm = globalObject-&gt;vm();</span>
224     auto scope = DECLARE_THROW_SCOPE(vm);
225     JSValue patternArg = args.at(0);
226     JSValue flagsArg = args.at(1);
227 
228     bool isPatternRegExp = patternArg.inherits&lt;RegExpObject&gt;(vm);
<span class="line-modified">229     bool constructAsRegexp = isRegExp(vm, globalObject, patternArg);</span>
230     RETURN_IF_EXCEPTION(scope, nullptr);
231 
232     if (newTarget.isUndefined() &amp;&amp; constructAsRegexp &amp;&amp; flagsArg.isUndefined()) {
<span class="line-modified">233         JSValue constructor = patternArg.get(globalObject, vm.propertyNames-&gt;constructor);</span>
234         RETURN_IF_EXCEPTION(scope, nullptr);
235         if (callee == constructor) {
236             // We know that patternArg is a object otherwise constructAsRegexp would be false.
237             return patternArg.getObject();
238         }
239     }
240 
241     if (isPatternRegExp) {
242         RegExp* regExp = jsCast&lt;RegExpObject*&gt;(patternArg)-&gt;regExp();
<span class="line-modified">243         Structure* structure = getRegExpStructure(globalObject, newTarget);</span>
244         RETURN_IF_EXCEPTION(scope, nullptr);
245 
246         if (!flagsArg.isUndefined()) {
<span class="line-modified">247             auto flags = toFlags(globalObject, flagsArg);</span>
248             RETURN_IF_EXCEPTION(scope, nullptr);
249 
250             regExp = RegExp::create(vm, regExp-&gt;pattern(), flags);
251             if (UNLIKELY(!regExp-&gt;isValid())) {
<span class="line-modified">252                 throwException(globalObject, scope, regExp-&gt;errorToThrow(globalObject));</span>
253                 return nullptr;
254             }
255         }
256 
257         return RegExpObject::create(vm, structure, regExp);
258     }
259 
260     if (constructAsRegexp) {
<span class="line-modified">261         JSValue pattern = patternArg.get(globalObject, vm.propertyNames-&gt;source);</span>
262         RETURN_IF_EXCEPTION(scope, nullptr);
263         if (flagsArg.isUndefined()) {
<span class="line-modified">264             flagsArg = patternArg.get(globalObject, vm.propertyNames-&gt;flags);</span>
265             RETURN_IF_EXCEPTION(scope, nullptr);
266         }
267         patternArg = pattern;
268     }
269 
<span class="line-modified">270     RELEASE_AND_RETURN(scope, regExpCreate(globalObject, newTarget, patternArg, flagsArg));</span>
271 }
272 
<span class="line-modified">273 EncodedJSValue JSC_HOST_CALL esSpecRegExpCreate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
274 {
<span class="line-modified">275     JSValue patternArg = callFrame-&gt;argument(0);</span>
<span class="line-modified">276     JSValue flagsArg = callFrame-&gt;argument(1);</span>
<span class="line-modified">277     return JSValue::encode(regExpCreate(globalObject, jsUndefined(), patternArg, flagsArg));</span>

278 }
279 
<span class="line-modified">280 EncodedJSValue JSC_HOST_CALL esSpecIsRegExp(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
281 {
<span class="line-modified">282     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">283     return JSValue::encode(jsBoolean(isRegExp(vm, globalObject, callFrame-&gt;argument(0))));</span>
284 }
285 
<span class="line-modified">286 static EncodedJSValue JSC_HOST_CALL constructWithRegExpConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
287 {
<span class="line-modified">288     ArgList args(callFrame);</span>
<span class="line-modified">289     return JSValue::encode(constructRegExp(globalObject, args, callFrame-&gt;jsCallee(), callFrame-&gt;newTarget()));</span>
<span class="line-added">290 }</span>
<span class="line-added">291 </span>
<span class="line-added">292 static EncodedJSValue JSC_HOST_CALL callRegExpConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">293 {</span>
<span class="line-added">294     ArgList args(callFrame);</span>
<span class="line-added">295     return JSValue::encode(constructRegExp(globalObject, args, callFrame-&gt;jsCallee()));</span>
296 }
297 
298 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="RegExpCachedResult.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpConstructor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
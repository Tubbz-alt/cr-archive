<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGGraph.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGForAllKills.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGGraph.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,25 ***</span>
      out.print(prefix);
      printNodeWhiteSpace(out, node);
  
      // Example/explanation of dataflow dump output
      //
<span class="line-modified">!     //   14:   &lt;!2:7&gt;  GetByVal(@3, @13)</span>
<span class="line-modified">!     //   ^1     ^2 ^3     ^4       ^5</span>
      //
      // (1) The nodeIndex of this operation.
      // (2) The reference count. The number printed is the &#39;real&#39; count,
      //     not including the &#39;mustGenerate&#39; ref. If the node is
      //     &#39;mustGenerate&#39; then the count it prefixed with &#39;!&#39;.
      // (3) The virtual register slot assigned to this node.
      // (4) The name of the operation.
      // (5) The arguments to the operation. The may be of the form:
<span class="line-modified">!     //         @#   - a NodeIndex referencing a prior node in the graph.</span>
      //         arg# - an argument number.
      //         id#  - the index in the CodeBlock of an identifier { if codeBlock is passed to dump(), the string representation is displayed }.
      //         var# - the index of a var on the global object, used by GetGlobalVar/GetGlobalLexicalVariable/PutGlobalVariable operations.
<span class="line-modified">!     out.printf(&quot;% 4d:&lt;%c%u:&quot;, (int)node-&gt;index(), mustGenerate ? &#39;!&#39; : &#39; &#39;, refCount);</span>
      if (node-&gt;hasResult() &amp;&amp; node-&gt;hasVirtualRegister() &amp;&amp; node-&gt;virtualRegister().isValid())
          out.print(node-&gt;virtualRegister());
      else
          out.print(&quot;-&quot;);
      out.print(&quot;&gt;\t&quot;, opName(op), &quot;(&quot;);
<span class="line-new-header">--- 183,27 ---</span>
      out.print(prefix);
      printNodeWhiteSpace(out, node);
  
      // Example/explanation of dataflow dump output
      //
<span class="line-modified">!     //   D@14:   &lt;!2:7&gt;  GetByVal(@3, @13)</span>
<span class="line-modified">!     //     ^1     ^2 ^3     ^4       ^5</span>
      //
      // (1) The nodeIndex of this operation.
      // (2) The reference count. The number printed is the &#39;real&#39; count,
      //     not including the &#39;mustGenerate&#39; ref. If the node is
      //     &#39;mustGenerate&#39; then the count it prefixed with &#39;!&#39;.
      // (3) The virtual register slot assigned to this node.
      // (4) The name of the operation.
      // (5) The arguments to the operation. The may be of the form:
<span class="line-modified">!     //         D@#  - a NodeIndex referencing a prior node in the graph.</span>
      //         arg# - an argument number.
      //         id#  - the index in the CodeBlock of an identifier { if codeBlock is passed to dump(), the string representation is displayed }.
      //         var# - the index of a var on the global object, used by GetGlobalVar/GetGlobalLexicalVariable/PutGlobalVariable operations.
<span class="line-modified">!     int nodeIndex = node-&gt;index();</span>
<span class="line-added">+     const char* prefixPadding = nodeIndex &lt; 10 ? &quot;   &quot; : nodeIndex &lt; 100 ? &quot;  &quot; : &quot; &quot;;</span>
<span class="line-added">+     out.printf(&quot;%sD@%d:&lt;%c%u:&quot;, prefixPadding, nodeIndex, mustGenerate ? &#39;!&#39; : &#39; &#39;, refCount);</span>
      if (node-&gt;hasResult() &amp;&amp; node-&gt;hasVirtualRegister() &amp;&amp; node-&gt;virtualRegister().isValid())
          out.print(node-&gt;virtualRegister());
      else
          out.print(&quot;-&quot;);
      out.print(&quot;&gt;\t&quot;, opName(op), &quot;(&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,11 ***</span>
          out.print(comma, node-&gt;capturedArgumentsOffset());
      if (node-&gt;hasArgumentIndex())
          out.print(comma, node-&gt;argumentIndex());
      if (node-&gt;hasRegisterPointer())
          out.print(comma, &quot;global&quot;, &quot;(&quot;, RawPointer(node-&gt;variablePointer()), &quot;)&quot;);
<span class="line-modified">!     if (node-&gt;hasIdentifier())</span>
          out.print(comma, &quot;id&quot;, node-&gt;identifierNumber(), &quot;{&quot;, identifiers()[node-&gt;identifierNumber()], &quot;}&quot;);
      if (node-&gt;hasPromotedLocationDescriptor())
          out.print(comma, node-&gt;promotedLocationDescriptor());
      if (node-&gt;hasClassInfo())
          out.print(comma, *node-&gt;classInfo());
<span class="line-new-header">--- 243,11 ---</span>
          out.print(comma, node-&gt;capturedArgumentsOffset());
      if (node-&gt;hasArgumentIndex())
          out.print(comma, node-&gt;argumentIndex());
      if (node-&gt;hasRegisterPointer())
          out.print(comma, &quot;global&quot;, &quot;(&quot;, RawPointer(node-&gt;variablePointer()), &quot;)&quot;);
<span class="line-modified">!     if (node-&gt;hasIdentifier() &amp;&amp; node-&gt;identifierNumber() != UINT32_MAX)</span>
          out.print(comma, &quot;id&quot;, node-&gt;identifierNumber(), &quot;{&quot;, identifiers()[node-&gt;identifierNumber()], &quot;}&quot;);
      if (node-&gt;hasPromotedLocationDescriptor())
          out.print(comma, node-&gt;promotedLocationDescriptor());
      if (node-&gt;hasClassInfo())
          out.print(comma, *node-&gt;classInfo());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,12 ***</span>
                          out.print(comma, &quot;&lt;non-function executable&gt;&quot;);
                  }
              }
          }
      }
<span class="line-modified">!     if (node-&gt;hasSpeculatedTypeForQuery())</span>
<span class="line-modified">!         out.print(comma, SpeculationDump(node-&gt;speculatedTypeForQuery()));</span>
      if (node-&gt;hasStorageAccessData()) {
          StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
          out.print(comma, &quot;id&quot;, storageAccessData.identifierNumber, &quot;{&quot;, identifiers()[storageAccessData.identifierNumber], &quot;}&quot;);
          out.print(&quot;, &quot;, static_cast&lt;ptrdiff_t&gt;(storageAccessData.offset));
      }
<span class="line-new-header">--- 281,12 ---</span>
                          out.print(comma, &quot;&lt;non-function executable&gt;&quot;);
                  }
              }
          }
      }
<span class="line-modified">!     if (node-&gt;hasQueriedType())</span>
<span class="line-modified">!         out.print(comma, node-&gt;queriedType());</span>
      if (node-&gt;hasStorageAccessData()) {
          StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
          out.print(comma, &quot;id&quot;, storageAccessData.identifierNumber, &quot;{&quot;, identifiers()[storageAccessData.identifierNumber], &quot;}&quot;);
          out.print(&quot;, &quot;, static_cast&lt;ptrdiff_t&gt;(storageAccessData.offset));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,26 ***</span>
      }
      ASSERT(node-&gt;hasVariableAccessData(*this) == node-&gt;accessesStack(*this));
      if (node-&gt;hasVariableAccessData(*this)) {
          VariableAccessData* variableAccessData = node-&gt;tryGetVariableAccessData();
          if (variableAccessData) {
<span class="line-modified">!             VirtualRegister operand = variableAccessData-&gt;local();</span>
<span class="line-modified">!             out.print(comma, variableAccessData-&gt;local(), &quot;(&quot;, VariableAccessDataDump(*this, variableAccessData), &quot;)&quot;);</span>
              operand = variableAccessData-&gt;machineLocal();
              if (operand.isValid())
                  out.print(comma, &quot;machine:&quot;, operand);
          }
      }
      if (node-&gt;hasStackAccessData()) {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         out.print(comma, data-&gt;local);</span>
          if (data-&gt;machineLocal.isValid())
              out.print(comma, &quot;machine:&quot;, data-&gt;machineLocal);
          out.print(comma, data-&gt;format);
      }
<span class="line-modified">!     if (node-&gt;hasUnlinkedLocal())</span>
<span class="line-modified">!         out.print(comma, node-&gt;unlinkedLocal());</span>
      if (node-&gt;hasVectorLengthHint())
          out.print(comma, &quot;vectorLengthHint = &quot;, node-&gt;vectorLengthHint());
      if (node-&gt;hasLazyJSValue())
          out.print(comma, node-&gt;lazyJSValue());
      if (node-&gt;hasIndexingType())
<span class="line-new-header">--- 308,26 ---</span>
      }
      ASSERT(node-&gt;hasVariableAccessData(*this) == node-&gt;accessesStack(*this));
      if (node-&gt;hasVariableAccessData(*this)) {
          VariableAccessData* variableAccessData = node-&gt;tryGetVariableAccessData();
          if (variableAccessData) {
<span class="line-modified">!             Operand operand = variableAccessData-&gt;operand();</span>
<span class="line-modified">!             out.print(comma, variableAccessData-&gt;operand(), &quot;(&quot;, VariableAccessDataDump(*this, variableAccessData), &quot;)&quot;);</span>
              operand = variableAccessData-&gt;machineLocal();
              if (operand.isValid())
                  out.print(comma, &quot;machine:&quot;, operand);
          }
      }
      if (node-&gt;hasStackAccessData()) {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         out.print(comma, data-&gt;operand);</span>
          if (data-&gt;machineLocal.isValid())
              out.print(comma, &quot;machine:&quot;, data-&gt;machineLocal);
          out.print(comma, data-&gt;format);
      }
<span class="line-modified">!     if (node-&gt;hasUnlinkedOperand())</span>
<span class="line-modified">!         out.print(comma, node-&gt;unlinkedOperand());</span>
      if (node-&gt;hasVectorLengthHint())
          out.print(comma, &quot;vectorLengthHint = &quot;, node-&gt;vectorLengthHint());
      if (node-&gt;hasLazyJSValue())
          out.print(comma, node-&gt;lazyJSValue());
      if (node-&gt;hasIndexingType())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 352,23 ***</span>
          if (data-&gt;machineCount.isValid())
              out.print(&quot;, machineCount = &quot;, data-&gt;machineCount);
          out.print(&quot;, offset = &quot;, data-&gt;offset, &quot;, mandatoryMinimum = &quot;, data-&gt;mandatoryMinimum);
          out.print(&quot;, limit = &quot;, data-&gt;limit);
      }
      if (node-&gt;hasCallDOMGetterData()) {
          CallDOMGetterData* data = node-&gt;callDOMGetterData();
          out.print(comma, &quot;id&quot;, data-&gt;identifierNumber, &quot;{&quot;, identifiers()[data-&gt;identifierNumber], &quot;}&quot;);
          out.print(&quot;, domJIT = &quot;, RawPointer(data-&gt;domJIT));
      }
      if (node-&gt;hasIgnoreLastIndexIsWritable())
          out.print(comma, &quot;ignoreLastIndexIsWritable = &quot;, node-&gt;ignoreLastIndexIsWritable());
      if (node-&gt;isConstant())
          out.print(comma, pointerDumpInContext(node-&gt;constant(), context));
      if (node-&gt;hasCallLinkStatus())
          out.print(comma, *node-&gt;callLinkStatus());
<span class="line-modified">!     if (node-&gt;hasGetByIdStatus())</span>
<span class="line-modified">!         out.print(comma, *node-&gt;getByIdStatus());</span>
      if (node-&gt;hasInByIdStatus())
          out.print(comma, *node-&gt;inByIdStatus());
      if (node-&gt;hasPutByIdStatus())
          out.print(comma, *node-&gt;putByIdStatus());
      if (node-&gt;isJump())
<span class="line-new-header">--- 354,29 ---</span>
          if (data-&gt;machineCount.isValid())
              out.print(&quot;, machineCount = &quot;, data-&gt;machineCount);
          out.print(&quot;, offset = &quot;, data-&gt;offset, &quot;, mandatoryMinimum = &quot;, data-&gt;mandatoryMinimum);
          out.print(&quot;, limit = &quot;, data-&gt;limit);
      }
<span class="line-added">+     if (node-&gt;hasIsInternalPromise())</span>
<span class="line-added">+         out.print(comma, &quot;isInternalPromise = &quot;, node-&gt;isInternalPromise());</span>
<span class="line-added">+     if (node-&gt;hasInternalFieldIndex())</span>
<span class="line-added">+         out.print(comma, &quot;internalFieldIndex = &quot;, node-&gt;internalFieldIndex());</span>
      if (node-&gt;hasCallDOMGetterData()) {
          CallDOMGetterData* data = node-&gt;callDOMGetterData();
          out.print(comma, &quot;id&quot;, data-&gt;identifierNumber, &quot;{&quot;, identifiers()[data-&gt;identifierNumber], &quot;}&quot;);
          out.print(&quot;, domJIT = &quot;, RawPointer(data-&gt;domJIT));
      }
      if (node-&gt;hasIgnoreLastIndexIsWritable())
          out.print(comma, &quot;ignoreLastIndexIsWritable = &quot;, node-&gt;ignoreLastIndexIsWritable());
<span class="line-added">+     if (node-&gt;hasIntrinsic())</span>
<span class="line-added">+         out.print(comma, &quot;intrinsic = &quot;, node-&gt;intrinsic());</span>
      if (node-&gt;isConstant())
          out.print(comma, pointerDumpInContext(node-&gt;constant(), context));
      if (node-&gt;hasCallLinkStatus())
          out.print(comma, *node-&gt;callLinkStatus());
<span class="line-modified">!     if (node-&gt;hasGetByStatus())</span>
<span class="line-modified">!         out.print(comma, *node-&gt;getByStatus());</span>
      if (node-&gt;hasInByIdStatus())
          out.print(comma, *node-&gt;inByIdStatus());
      if (node-&gt;hasPutByIdStatus())
          out.print(comma, *node-&gt;putByIdStatus());
      if (node-&gt;isJump())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 398,11 ***</span>
      if (exitMode != DoesNotExit)
          out.print(comma, exitMode);
      if (clobbersExitState(*this, node))
          out.print(comma, &quot;ClobbersExit&quot;);
      if (node-&gt;origin.isSet()) {
<span class="line-modified">!         out.print(comma, &quot;bc#&quot;, node-&gt;origin.semantic.bytecodeIndex());</span>
          if (node-&gt;origin.semantic != node-&gt;origin.forExit &amp;&amp; node-&gt;origin.forExit.isSet())
              out.print(comma, &quot;exit: &quot;, node-&gt;origin.forExit);
      }
      out.print(comma, node-&gt;origin.exitOK ? &quot;ExitValid&quot; : &quot;ExitInvalid&quot;);
      if (node-&gt;origin.wasHoisted)
<span class="line-new-header">--- 406,11 ---</span>
      if (exitMode != DoesNotExit)
          out.print(comma, exitMode);
      if (clobbersExitState(*this, node))
          out.print(comma, &quot;ClobbersExit&quot;);
      if (node-&gt;origin.isSet()) {
<span class="line-modified">!         out.print(comma, node-&gt;origin.semantic.bytecodeIndex());</span>
          if (node-&gt;origin.semantic != node-&gt;origin.forExit &amp;&amp; node-&gt;origin.forExit.isSet())
              out.print(comma, &quot;exit: &quot;, node-&gt;origin.forExit);
      }
      out.print(comma, node-&gt;origin.exitOK ? &quot;ExitValid&quot; : &quot;ExitInvalid&quot;);
      if (node-&gt;origin.wasHoisted)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,19 ***</span>
  
      if (!block-&gt;phis.isEmpty()) {
          out.print(prefix, &quot;  Phi Nodes:&quot;);
          for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
              Node* phiNode = block-&gt;phis[i];
              if (!phiNode-&gt;shouldGenerate() &amp;&amp; phiNodeDumpMode == DumpLivePhisOnly)
                  continue;
<span class="line-modified">!             out.print(&quot; @&quot;, phiNode-&gt;index(), &quot;&lt;&quot;, phiNode-&gt;local(), &quot;,&quot;, phiNode-&gt;refCount(), &quot;&gt;-&gt;(&quot;);</span>
              if (phiNode-&gt;child1()) {
<span class="line-modified">!                 out.print(&quot;@&quot;, phiNode-&gt;child1()-&gt;index());</span>
                  if (phiNode-&gt;child2()) {
<span class="line-modified">!                     out.print(&quot;, @&quot;, phiNode-&gt;child2()-&gt;index());</span>
                      if (phiNode-&gt;child3())
<span class="line-modified">!                         out.print(&quot;, @&quot;, phiNode-&gt;child3()-&gt;index());</span>
                  }
              }
              out.print(&quot;)&quot;, i + 1 &lt; block-&gt;phis.size() ? &quot;,&quot; : &quot;&quot;);
          }
          out.print(&quot;\n&quot;);
<span class="line-new-header">--- 515,20 ---</span>
  
      if (!block-&gt;phis.isEmpty()) {
          out.print(prefix, &quot;  Phi Nodes:&quot;);
          for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
              Node* phiNode = block-&gt;phis[i];
<span class="line-added">+             ASSERT(phiNode-&gt;op() == Phi);</span>
              if (!phiNode-&gt;shouldGenerate() &amp;&amp; phiNodeDumpMode == DumpLivePhisOnly)
                  continue;
<span class="line-modified">!             out.print(&quot; D@&quot;, phiNode-&gt;index(), &quot;&lt;&quot;, phiNode-&gt;operand(), &quot;,&quot;, phiNode-&gt;refCount(), &quot;&gt;-&gt;(&quot;);</span>
              if (phiNode-&gt;child1()) {
<span class="line-modified">!                 out.print(&quot;D@&quot;, phiNode-&gt;child1()-&gt;index());</span>
                  if (phiNode-&gt;child2()) {
<span class="line-modified">!                     out.print(&quot;, D@&quot;, phiNode-&gt;child2()-&gt;index());</span>
                      if (phiNode-&gt;child3())
<span class="line-modified">!                         out.print(&quot;, D@&quot;, phiNode-&gt;child3()-&gt;index());</span>
                  }
              }
              out.print(&quot;)&quot;, i + 1 &lt; block-&gt;phis.size() ? &quot;,&quot; : &quot;&quot;);
          }
          out.print(&quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 540,11 ***</span>
      if (m_form == SSA) {
          for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_argumentFormats.size(); ++entrypointIndex)
              out.print(prefix, &quot;  Argument formats for entrypoint index: &quot;, entrypointIndex, &quot; : &quot;, listDump(m_argumentFormats[entrypointIndex]), &quot;\n&quot;);
      }
      else {
<span class="line-modified">!         for (auto pair : m_rootToArguments)</span>
              out.print(prefix, &quot;  Arguments for block#&quot;, pair.key-&gt;index, &quot;: &quot;, listDump(pair.value), &quot;\n&quot;);
      }
      out.print(&quot;\n&quot;);
  
      Node* lastNode = nullptr;
<span class="line-new-header">--- 549,11 ---</span>
      if (m_form == SSA) {
          for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_argumentFormats.size(); ++entrypointIndex)
              out.print(prefix, &quot;  Argument formats for entrypoint index: &quot;, entrypointIndex, &quot; : &quot;, listDump(m_argumentFormats[entrypointIndex]), &quot;\n&quot;);
      }
      else {
<span class="line-modified">!         for (const auto&amp; pair : m_rootToArguments)</span>
              out.print(prefix, &quot;  Arguments for block#&quot;, pair.key-&gt;index, &quot;: &quot;, listDump(pair.value), &quot;\n&quot;);
      }
      out.print(&quot;\n&quot;);
  
      Node* lastNode = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 876,22 ***</span>
      for (unsigned indexInBlock = startIndexInBlock; indexInBlock &lt; block.size(); ++indexInBlock) {
          Node* node = block[indexInBlock];
          bool shouldContinue = true;
          switch (node-&gt;op()) {
          case SetLocal: {
<span class="line-modified">!             if (node-&gt;local() == variableAccessData-&gt;local())</span>
                  shouldContinue = false;
              break;
          }
  
          case GetLocal: {
              if (node-&gt;variableAccessData() != variableAccessData)
                  continue;
              substitute(block, indexInBlock, node, newGetLocal);
<span class="line-modified">!             Node* oldTailNode = block.variablesAtTail.operand(variableAccessData-&gt;local());</span>
              if (oldTailNode == node)
<span class="line-modified">!                 block.variablesAtTail.operand(variableAccessData-&gt;local()) = newGetLocal;</span>
              shouldContinue = false;
              break;
          }
  
          default:
<span class="line-new-header">--- 885,22 ---</span>
      for (unsigned indexInBlock = startIndexInBlock; indexInBlock &lt; block.size(); ++indexInBlock) {
          Node* node = block[indexInBlock];
          bool shouldContinue = true;
          switch (node-&gt;op()) {
          case SetLocal: {
<span class="line-modified">!             if (node-&gt;operand() == variableAccessData-&gt;operand())</span>
                  shouldContinue = false;
              break;
          }
  
          case GetLocal: {
              if (node-&gt;variableAccessData() != variableAccessData)
                  continue;
              substitute(block, indexInBlock, node, newGetLocal);
<span class="line-modified">!             Node* oldTailNode = block.variablesAtTail.operand(variableAccessData-&gt;operand());</span>
              if (oldTailNode == node)
<span class="line-modified">!                 block.variablesAtTail.operand(variableAccessData-&gt;operand()) = newGetLocal;</span>
              shouldContinue = false;
              break;
          }
  
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1125,84 ***</span>
  BytecodeKills&amp; Graph::killsFor(InlineCallFrame* inlineCallFrame)
  {
      return killsFor(baselineCodeBlockFor(inlineCallFrame));
  }
  
<span class="line-modified">! bool Graph::isLiveInBytecode(VirtualRegister operand, CodeOrigin codeOrigin)</span>
  {
<span class="line-modified">!     static const bool verbose = false;</span>
  
      if (verbose)
          dataLog(&quot;Checking of operand is live: &quot;, operand, &quot;\n&quot;);
      CodeOrigin* codeOriginPtr = &amp;codeOrigin;
<span class="line-modified">!     for (;;) {</span>
<span class="line-modified">!         VirtualRegister reg = VirtualRegister(</span>
<span class="line-modified">!             operand.offset() - codeOriginPtr-&gt;stackOffset());</span>
  
          if (verbose)
              dataLog(&quot;reg = &quot;, reg, &quot;\n&quot;);
  
<span class="line-modified">!         auto* inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
<span class="line-removed">-         if (operand.offset() &lt; codeOriginPtr-&gt;stackOffset() + CallFrame::headerSizeInRegisters) {</span>
              if (reg.isArgument()) {
                  RELEASE_ASSERT(reg.offset() &lt; CallFrame::headerSizeInRegisters);
  
  
                  if (inlineCallFrame-&gt;isClosureCall
<span class="line-modified">!                     &amp;&amp; reg.offset() == CallFrameSlot::callee) {</span>
                      if (verbose)
                          dataLog(&quot;Looks like a callee.\n&quot;);
                      return true;
                  }
  
                  if (inlineCallFrame-&gt;isVarargs()
<span class="line-modified">!                     &amp;&amp; reg.offset() == CallFrameSlot::argumentCount) {</span>
                      if (verbose)
                          dataLog(&quot;Looks like the argument count.\n&quot;);
                      return true;
                  }
  
                  return false;
              }
  
              if (verbose)
                  dataLog(&quot;Asking the bytecode liveness.\n&quot;);
<span class="line-modified">!             return livenessFor(inlineCallFrame).operandIsLive(reg.offset(), codeOriginPtr-&gt;bytecodeIndex());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (!inlineCallFrame) {</span>
<span class="line-removed">-             if (verbose)</span>
<span class="line-removed">-                 dataLog(&quot;Ran out of stack, returning true.\n&quot;);</span>
<span class="line-removed">-             return true;</span>
          }
  
          // Arguments are always live. This would be redundant if it wasn&#39;t for our
          // op_call_varargs inlining.
<span class="line-modified">!         if (reg.isArgument()</span>
              &amp;&amp; static_cast&lt;size_t&gt;(reg.toArgument()) &lt; inlineCallFrame-&gt;argumentsWithFixup.size()) {
              if (verbose)
                  dataLog(&quot;Argument is live.\n&quot;);
              return true;
          }
  
<span class="line-modified">!         // We need to handle tail callers because we may decide to exit to the</span>
<span class="line-removed">-         // the return bytecode following the tail call.</span>
<span class="line-removed">-         codeOriginPtr = &amp;inlineCallFrame-&gt;directCaller;</span>
      }
  
<span class="line-modified">!     RELEASE_ASSERT_NOT_REACHED();</span>
  }
  
<span class="line-modified">! BitVector Graph::localsLiveInBytecode(CodeOrigin codeOrigin)</span>
  {
      BitVector result;
<span class="line-modified">!     result.ensureSize(block(0)-&gt;variablesAtHead.numberOfLocals());</span>
<span class="line-modified">!     forAllLocalsLiveInBytecode(</span>
          codeOrigin,
<span class="line-modified">!         [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified">!             ASSERT(reg.isLocal());</span>
<span class="line-modified">!             result.quickSet(reg.toLocal());</span>
          });
      return result;
  }
  
  unsigned Graph::parameterSlotsForArgCount(unsigned argCount)
<span class="line-new-header">--- 1134,106 ---</span>
  BytecodeKills&amp; Graph::killsFor(InlineCallFrame* inlineCallFrame)
  {
      return killsFor(baselineCodeBlockFor(inlineCallFrame));
  }
  
<span class="line-modified">! bool Graph::isLiveInBytecode(Operand operand, CodeOrigin codeOrigin)</span>
  {
<span class="line-modified">!     static constexpr bool verbose = false;</span>
  
      if (verbose)
          dataLog(&quot;Checking of operand is live: &quot;, operand, &quot;\n&quot;);
<span class="line-added">+     bool isCallerOrigin = false;</span>
<span class="line-added">+ </span>
      CodeOrigin* codeOriginPtr = &amp;codeOrigin;
<span class="line-modified">!     auto* inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
<span class="line-modified">!     // We need to handle tail callers because we may decide to exit to the</span>
<span class="line-modified">!     // the return bytecode following the tail call.</span>
<span class="line-added">+     for (; codeOriginPtr; codeOriginPtr = inlineCallFrame ? &amp;inlineCallFrame-&gt;directCaller : nullptr) {</span>
<span class="line-added">+         inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
<span class="line-added">+         if (operand.isTmp()) {</span>
<span class="line-added">+             unsigned tmpOffset = inlineCallFrame ? inlineCallFrame-&gt;tmpOffset : 0;</span>
<span class="line-added">+             unsigned operandIndex = static_cast&lt;unsigned&gt;(operand.value());</span>
<span class="line-added">+ </span>
<span class="line-added">+             ASSERT(operand.value() &gt;= 0);</span>
<span class="line-added">+             // This tmp should have belonged to someone we inlined.</span>
<span class="line-added">+             if (operandIndex &gt; tmpOffset + maxNumCheckpointTmps)</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);</span>
<span class="line-added">+             if (!codeBlock-&gt;numTmps() || operandIndex &lt; tmpOffset)</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto bitMap = tmpLivenessForCheckpoint(*codeBlock, codeOriginPtr-&gt;bytecodeIndex());</span>
<span class="line-added">+             return bitMap.get(operandIndex - tmpOffset);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         VirtualRegister reg = operand.virtualRegister() - codeOriginPtr-&gt;stackOffset();</span>
  
          if (verbose)
              dataLog(&quot;reg = &quot;, reg, &quot;\n&quot;);
  
<span class="line-modified">!         if (operand.virtualRegister().offset() &lt; codeOriginPtr-&gt;stackOffset() + CallFrame::headerSizeInRegisters) {</span>
              if (reg.isArgument()) {
                  RELEASE_ASSERT(reg.offset() &lt; CallFrame::headerSizeInRegisters);
  
  
                  if (inlineCallFrame-&gt;isClosureCall
<span class="line-modified">!                     &amp;&amp; reg == CallFrameSlot::callee) {</span>
                      if (verbose)
                          dataLog(&quot;Looks like a callee.\n&quot;);
                      return true;
                  }
  
                  if (inlineCallFrame-&gt;isVarargs()
<span class="line-modified">!                     &amp;&amp; reg == CallFrameSlot::argumentCountIncludingThis) {</span>
                      if (verbose)
                          dataLog(&quot;Looks like the argument count.\n&quot;);
                      return true;
                  }
  
                  return false;
              }
  
              if (verbose)
                  dataLog(&quot;Asking the bytecode liveness.\n&quot;);
<span class="line-modified">!             CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);</span>
<span class="line-modified">!             FullBytecodeLiveness&amp; fullLiveness = livenessFor(codeBlock);</span>
<span class="line-modified">!             BytecodeIndex bytecodeIndex = codeOriginPtr-&gt;bytecodeIndex();</span>
<span class="line-modified">!             return fullLiveness.virtualRegisterIsLive(reg, bytecodeIndex, appropriateLivenessCalculationPoint(*codeOriginPtr, isCallerOrigin));</span>
          }
  
          // Arguments are always live. This would be redundant if it wasn&#39;t for our
          // op_call_varargs inlining.
<span class="line-modified">!         if (inlineCallFrame &amp;&amp; reg.isArgument()</span>
              &amp;&amp; static_cast&lt;size_t&gt;(reg.toArgument()) &lt; inlineCallFrame-&gt;argumentsWithFixup.size()) {
              if (verbose)
                  dataLog(&quot;Argument is live.\n&quot;);
              return true;
          }
  
<span class="line-modified">!         isCallerOrigin = true;</span>
      }
  
<span class="line-modified">!     if (operand.isTmp())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (verbose)</span>
<span class="line-added">+         dataLog(&quot;Ran out of stack, returning true.\n&quot;);</span>
<span class="line-added">+     return true;</span>
  }
  
<span class="line-modified">! BitVector Graph::localsAndTmpsLiveInBytecode(CodeOrigin codeOrigin)</span>
  {
      BitVector result;
<span class="line-modified">!     unsigned numLocals = block(0)-&gt;variablesAtHead.numberOfLocals();</span>
<span class="line-modified">!     result.ensureSize(numLocals + block(0)-&gt;variablesAtHead.numberOfTmps());</span>
<span class="line-added">+     forAllLocalsAndTmpsLiveInBytecode(</span>
          codeOrigin,
<span class="line-modified">!         [&amp;] (Operand operand) {</span>
<span class="line-modified">!             unsigned offset = operand.isTmp() ? numLocals + operand.value() : operand.toLocal();</span>
<span class="line-modified">!             result.quickSet(offset);</span>
          });
      return result;
  }
  
  unsigned Graph::parameterSlotsForArgCount(unsigned argCount)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1386,10 ***</span>
<span class="line-new-header">--- 1417,11 ---</span>
      if (!view)
          return nullptr;
      if (!view-&gt;length())
          return nullptr;
      WTF::loadLoadFence();
<span class="line-added">+     freeze(view);</span>
      watchpoints().addLazily(view);
      return view;
  }
  
  JSArrayBufferView* Graph::tryGetFoldableView(JSValue value, ArrayMode arrayMode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1399,10 ***</span>
<span class="line-new-header">--- 1431,11 ---</span>
      return tryGetFoldableView(value);
  }
  
  void Graph::registerFrozenValues()
  {
<span class="line-added">+     ConcurrentJSLocker locker(m_codeBlock-&gt;m_lock);</span>
      m_codeBlock-&gt;constants().shrink(0);
      m_codeBlock-&gt;constantsSourceCodeRepresentation().resize(0);
      for (FrozenValue* value : m_frozenValues) {
          if (!value-&gt;pointsToHeap())
              continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1414,11 ***</span>
          case WeakValue: {
              m_plan.weakReferences().addLazily(value-&gt;value().asCell());
              break;
          }
          case StrongValue: {
<span class="line-modified">!             unsigned constantIndex = m_codeBlock-&gt;addConstantLazily();</span>
              // We already have a barrier on the code block.
              m_codeBlock-&gt;constants()[constantIndex].setWithoutWriteBarrier(value-&gt;value());
              break;
          } }
      }
<span class="line-new-header">--- 1447,11 ---</span>
          case WeakValue: {
              m_plan.weakReferences().addLazily(value-&gt;value().asCell());
              break;
          }
          case StrongValue: {
<span class="line-modified">!             unsigned constantIndex = m_codeBlock-&gt;addConstantLazily(locker);</span>
              // We already have a barrier on the code block.
              m_codeBlock-&gt;constants()[constantIndex].setWithoutWriteBarrier(value-&gt;value());
              break;
          } }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1619,37 ***</span>
  MethodOfGettingAValueProfile Graph::methodOfGettingAValueProfileFor(Node* currentNode, Node* operandNode)
  {
      // This represents IR like `CurrentNode(@operandNode)`. For example: `GetByVal(..., Int32:@GetLocal)`.
  
      for (Node* node = operandNode; node;) {
          // currentNode is null when we&#39;re doing speculation checks for checkArgumentTypes().
          if (!currentNode || node-&gt;origin.semantic != currentNode-&gt;origin.semantic || !currentNode-&gt;hasResult()) {
              CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);
  
              if (node-&gt;accessesStack(*this)) {
<span class="line-removed">-                 if (m_form != SSA &amp;&amp; node-&gt;local().isArgument()) {</span>
<span class="line-removed">-                     int argument = node-&gt;local().toArgument();</span>
<span class="line-removed">-                     Node* argumentNode = m_rootToArguments.find(block(0))-&gt;value[argument];</span>
<span class="line-removed">-                     // FIXME: We should match SetArgumentDefinitely nodes at other entrypoints as well:</span>
<span class="line-removed">-                     // https://bugs.webkit.org/show_bug.cgi?id=175841</span>
<span class="line-removed">-                     if (argumentNode &amp;&amp; node-&gt;variableAccessData() == argumentNode-&gt;variableAccessData())</span>
<span class="line-removed">-                         return &amp;profiledBlock-&gt;valueProfileForArgument(argument);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
                  if (node-&gt;op() == GetLocal) {
                      return MethodOfGettingAValueProfile::fromLazyOperand(
                          profiledBlock,
                          LazyOperandValueProfileKey(
<span class="line-modified">!                             node-&gt;origin.semantic.bytecodeIndex(), node-&gt;local()));</span>
                  }
              }
  
              if (node-&gt;hasHeapPrediction())
<span class="line-modified">!                 return &amp;profiledBlock-&gt;valueProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex());</span>
  
              if (profiledBlock-&gt;hasBaselineJITProfiling()) {
<span class="line-modified">!                 if (ArithProfile* result = profiledBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex()))</span>
                      return result;
              }
          }
  
          switch (node-&gt;op()) {
<span class="line-new-header">--- 1652,43 ---</span>
  MethodOfGettingAValueProfile Graph::methodOfGettingAValueProfileFor(Node* currentNode, Node* operandNode)
  {
      // This represents IR like `CurrentNode(@operandNode)`. For example: `GetByVal(..., Int32:@GetLocal)`.
  
      for (Node* node = operandNode; node;) {
<span class="line-added">+         if (node-&gt;accessesStack(*this)) {</span>
<span class="line-added">+             if (m_form != SSA &amp;&amp; node-&gt;operand().isArgument()) {</span>
<span class="line-added">+                 int argument = node-&gt;operand().toArgument();</span>
<span class="line-added">+                 Node* argumentNode = m_rootToArguments.find(block(0))-&gt;value[argument];</span>
<span class="line-added">+                 // FIXME: We should match SetArgumentDefinitely nodes at other entrypoints as well:</span>
<span class="line-added">+                 // https://bugs.webkit.org/show_bug.cgi?id=175841</span>
<span class="line-added">+                 if (argumentNode &amp;&amp; node-&gt;variableAccessData() == argumentNode-&gt;variableAccessData()) {</span>
<span class="line-added">+                     CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);</span>
<span class="line-added">+                     return &amp;profiledBlock-&gt;valueProfileForArgument(argument);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // currentNode is null when we&#39;re doing speculation checks for checkArgumentTypes().
          if (!currentNode || node-&gt;origin.semantic != currentNode-&gt;origin.semantic || !currentNode-&gt;hasResult()) {
              CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);
  
              if (node-&gt;accessesStack(*this)) {
                  if (node-&gt;op() == GetLocal) {
                      return MethodOfGettingAValueProfile::fromLazyOperand(
                          profiledBlock,
                          LazyOperandValueProfileKey(
<span class="line-modified">!                             node-&gt;origin.semantic.bytecodeIndex(), node-&gt;operand()));</span>
                  }
              }
  
              if (node-&gt;hasHeapPrediction())
<span class="line-modified">!                 return &amp;profiledBlock-&gt;valueProfileForBytecodeIndex(node-&gt;origin.semantic.bytecodeIndex());</span>
  
              if (profiledBlock-&gt;hasBaselineJITProfiling()) {
<span class="line-modified">!                 if (BinaryArithProfile* result = profiledBlock-&gt;binaryArithProfileForBytecodeIndex(node-&gt;origin.semantic.bytecodeIndex()))</span>
<span class="line-added">+                     return result;</span>
<span class="line-added">+                 if (UnaryArithProfile* result = profiledBlock-&gt;unaryArithProfileForBytecodeIndex(node-&gt;origin.semantic.bytecodeIndex()))</span>
                      return result;
              }
          }
  
          switch (node-&gt;op()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1743,16 ***</span>
  bool Graph::willCatchExceptionInMachineFrame(CodeOrigin codeOrigin, CodeOrigin&amp; opCatchOriginOut, HandlerInfo*&amp; catchHandlerOut)
  {
      if (!m_hasExceptionHandlers)
          return false;
  
<span class="line-modified">!     unsigned bytecodeIndexToCheck = codeOrigin.bytecodeIndex();</span>
      while (1) {
          InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame();
          CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);
<span class="line-modified">!         if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeOffset(bytecodeIndexToCheck)) {</span>
<span class="line-modified">!             opCatchOriginOut = CodeOrigin(handler-&gt;target, inlineCallFrame);</span>
              catchHandlerOut = handler;
              return true;
          }
  
          if (!inlineCallFrame)
<span class="line-new-header">--- 1782,16 ---</span>
  bool Graph::willCatchExceptionInMachineFrame(CodeOrigin codeOrigin, CodeOrigin&amp; opCatchOriginOut, HandlerInfo*&amp; catchHandlerOut)
  {
      if (!m_hasExceptionHandlers)
          return false;
  
<span class="line-modified">!     BytecodeIndex bytecodeIndexToCheck = codeOrigin.bytecodeIndex();</span>
      while (1) {
          InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame();
          CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);
<span class="line-modified">!         if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeIndex(bytecodeIndexToCheck)) {</span>
<span class="line-modified">!             opCatchOriginOut = CodeOrigin(BytecodeIndex(handler-&gt;target), inlineCallFrame);</span>
              catchHandlerOut = handler;
              return true;
          }
  
          if (!inlineCallFrame)
</pre>
<center><a href="DFGForAllKills.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
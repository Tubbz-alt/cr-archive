<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmPlan.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSectionParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40 
 41 namespace JSC { namespace Wasm {
 42 
 43 auto SectionParser::parseType() -&gt; PartialResult
 44 {
 45     uint32_t count;
 46 
 47     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Type section&#39;s count&quot;);
 48     WASM_PARSER_FAIL_IF(count &gt; maxTypes, &quot;Type section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxTypes);
 49     WASM_PARSER_FAIL_IF(!m_info-&gt;usedSignatures.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, count, &quot; entries&quot;);
 50 
 51     for (uint32_t i = 0; i &lt; count; ++i) {
 52         int8_t type;
 53         uint32_t argumentCount;
 54         Vector&lt;Type&gt; argumentTypes;
 55 
 56         WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s type&quot;);
 57         WASM_PARSER_FAIL_IF(type != Func, i, &quot;th Type is non-Func &quot;, type);
 58         WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s argument count&quot;);
 59         WASM_PARSER_FAIL_IF(argumentCount &gt; maxFunctionParams, i, &quot;th argument count is too big &quot;, argumentCount, &quot; maximum &quot;, maxFunctionParams);
<span class="line-modified"> 60         RefPtr&lt;Signature&gt; maybeSignature = Signature::tryCreate(argumentCount);</span>
<span class="line-modified"> 61         WASM_PARSER_FAIL_IF(!maybeSignature, &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>
<span class="line-removed"> 62         Ref&lt;Signature&gt; signature = maybeSignature.releaseNonNull();</span>
 63 
 64         for (unsigned i = 0; i &lt; argumentCount; ++i) {
 65             Type argumentType;
 66             WASM_PARSER_FAIL_IF(!parseValueType(argumentType), &quot;can&#39;t get &quot;, i, &quot;th argument Type&quot;);
<span class="line-modified"> 67             signature-&gt;argument(i) = argumentType;</span>
 68         }
 69 
<span class="line-modified"> 70         uint8_t returnCount;</span>
<span class="line-modified"> 71         WASM_PARSER_FAIL_IF(!parseVarUInt1(returnCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return count&quot;);</span>
<span class="line-modified"> 72         Type returnType;</span>
<span class="line-modified"> 73         if (returnCount) {</span>



 74             Type value;
 75             WASM_PARSER_FAIL_IF(!parseValueType(value), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return value&quot;);
<span class="line-modified"> 76             returnType = static_cast&lt;Type&gt;(value);</span>
<span class="line-modified"> 77         } else</span>
<span class="line-modified"> 78             returnType = Type::Void;</span>
<span class="line-modified"> 79         signature-&gt;returnType() = returnType;</span>

 80 
<span class="line-modified"> 81         m_info-&gt;usedSignatures.uncheckedAppend(SignatureInformation::adopt(WTFMove(signature)));</span>
 82     }
 83     return { };
 84 }
 85 
 86 auto SectionParser::parseImport() -&gt; PartialResult
 87 {
 88     uint32_t importCount;
 89     WASM_PARSER_FAIL_IF(!parseVarUInt32(importCount), &quot;can&#39;t get Import section&#39;s count&quot;);
 90     WASM_PARSER_FAIL_IF(importCount &gt; maxImports, &quot;Import section&#39;s count is too big &quot;, importCount, &quot; maximum &quot;, maxImports);
 91     WASM_PARSER_FAIL_IF(!m_info-&gt;globals.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; globals&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 92     WASM_PARSER_FAIL_IF(!m_info-&gt;imports.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; imports&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 93     WASM_PARSER_FAIL_IF(!m_info-&gt;importFunctionSignatureIndices.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; import function signatures&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 94 
 95     for (uint32_t importNumber = 0; importNumber &lt; importCount; ++importNumber) {
 96         uint32_t moduleLen;
 97         uint32_t fieldLen;
 98         Name moduleString;
 99         Name fieldString;
100         ExternalKind kind;
101         unsigned kindIndex { 0 };
</pre>
<hr />
<pre>
116             SignatureIndex signatureIndex = SignatureInformation::get(m_info-&gt;usedSignatures[functionSignatureIndex]);
117             m_info-&gt;importFunctionSignatureIndices.uncheckedAppend(signatureIndex);
118             break;
119         }
120         case ExternalKind::Table: {
121             bool isImport = true;
122             kindIndex = m_info-&gt;tables.size();
123             PartialResult result = parseTableHelper(isImport);
124             if (UNLIKELY(!result))
125                 return makeUnexpected(WTFMove(result.error()));
126             break;
127         }
128         case ExternalKind::Memory: {
129             bool isImport = true;
130             PartialResult result = parseMemoryHelper(isImport);
131             if (UNLIKELY(!result))
132                 return makeUnexpected(WTFMove(result.error()));
133             break;
134         }
135         case ExternalKind::Global: {
<span class="line-modified">136             Global global;</span>
137             WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
<span class="line-modified">138             WASM_PARSER_FAIL_IF(global.mutability == Global::Mutable, &quot;Mutable Globals aren&#39;t supported&quot;);</span>
<span class="line-modified">139 </span>

140             kindIndex = m_info-&gt;globals.size();
141             m_info-&gt;globals.uncheckedAppend(WTFMove(global));
142             break;
143         }
144         }
145 
146         m_info-&gt;imports.uncheckedAppend({ WTFMove(moduleString), WTFMove(fieldString), kind, kindIndex });
147     }
148 
149     m_info-&gt;firstInternalGlobal = m_info-&gt;globals.size();
150     return { };
151 }
152 
153 auto SectionParser::parseFunction() -&gt; PartialResult
154 {
155     uint32_t count;
156     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Function section&#39;s count&quot;);
157     WASM_PARSER_FAIL_IF(count &gt; maxFunctions, &quot;Function section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxFunctions);
158     WASM_PARSER_FAIL_IF(!m_info-&gt;internalFunctionSignatureIndices.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for &quot;, count, &quot; Function signatures&quot;);
159     WASM_PARSER_FAIL_IF(!m_info-&gt;functions.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for &quot;, count, &quot;Function locations&quot;);
</pre>
<hr />
<pre>
265     WASM_PARSER_FAIL_IF(!parseVarUInt1(count), &quot;can&#39;t parse Memory section&#39;s count&quot;);
266 
267     if (!count)
268         return { };
269 
270     WASM_PARSER_FAIL_IF(count != 1, &quot;Memory section has more than one memory, WebAssembly currently only allows zero or one&quot;);
271 
272     bool isImport = false;
273     return parseMemoryHelper(isImport);
274 }
275 
276 auto SectionParser::parseGlobal() -&gt; PartialResult
277 {
278     uint32_t globalCount;
279     WASM_PARSER_FAIL_IF(!parseVarUInt32(globalCount), &quot;can&#39;t get Global section&#39;s count&quot;);
280     WASM_PARSER_FAIL_IF(globalCount &gt; maxGlobals, &quot;Global section&#39;s count is too big &quot;, globalCount, &quot; maximum &quot;, maxGlobals);
281     size_t totalBytes = globalCount + m_info-&gt;firstInternalGlobal;
282     WASM_PARSER_FAIL_IF((static_cast&lt;uint32_t&gt;(totalBytes) &lt; globalCount) || !m_info-&gt;globals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; globals&quot;);
283 
284     for (uint32_t globalIndex = 0; globalIndex &lt; globalCount; ++globalIndex) {
<span class="line-modified">285         Global global;</span>
286         uint8_t initOpcode;
287 
288         WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
289         Type typeForInitOpcode;
290         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
291         if (initOpcode == GetGlobal)
<span class="line-modified">292             global.initializationType = Global::FromGlobalImport;</span>
293         else if (initOpcode == RefFunc)
<span class="line-modified">294             global.initializationType = Global::FromRefFunc;</span>
295         else
<span class="line-modified">296             global.initializationType = Global::FromExpression;</span>
297         WASM_PARSER_FAIL_IF(!isSubtype(typeForInitOpcode, global.type), &quot;Global init_expr opcode of type &quot;, typeForInitOpcode, &quot; doesn&#39;t match global&#39;s type &quot;, global.type);
298 
299         m_info-&gt;globals.uncheckedAppend(WTFMove(global));
300     }
301 
302     return { };
303 }
304 
305 auto SectionParser::parseExport() -&gt; PartialResult
306 {
307     uint32_t exportCount;
308     WASM_PARSER_FAIL_IF(!parseVarUInt32(exportCount), &quot;can&#39;t get Export section&#39;s count&quot;);
309     WASM_PARSER_FAIL_IF(exportCount &gt; maxExports, &quot;Export section&#39;s count is too big &quot;, exportCount, &quot; maximum &quot;, maxExports);
310     WASM_PARSER_FAIL_IF(!m_info-&gt;exports.tryReserveCapacity(exportCount), &quot;can&#39;t allocate enough memory for &quot;, exportCount, &quot; exports&quot;);
311 
312     HashSet&lt;String&gt; exportNames;
313     for (uint32_t exportNumber = 0; exportNumber &lt; exportCount; ++exportNumber) {
314         uint32_t fieldLen;
315         Name fieldString;
316         ExternalKind kind;
</pre>
<hr />
<pre>
323         exportNames.add(fieldName);
324 
325         WASM_PARSER_FAIL_IF(!parseExternalKind(kind), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s kind, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
326         WASM_PARSER_FAIL_IF(!parseVarUInt32(kindIndex), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s kind index, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
327         switch (kind) {
328         case ExternalKind::Function: {
329             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;functionIndexSpaceSize(), exportNumber, &quot;th Export has invalid function number &quot;, kindIndex, &quot; it exceeds the function index space &quot;, m_info-&gt;functionIndexSpaceSize(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
330             break;
331         }
332         case ExternalKind::Table: {
333             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;tableCount(), &quot;can&#39;t export Table &quot;, kindIndex, &quot; there are &quot;, m_info-&gt;tableCount(), &quot; Tables&quot;);
334             break;
335         }
336         case ExternalKind::Memory: {
337             WASM_PARSER_FAIL_IF(!m_info-&gt;memory, &quot;can&#39;t export a non-existent Memory&quot;);
338             WASM_PARSER_FAIL_IF(kindIndex, &quot;can&#39;t export Memory &quot;, kindIndex, &quot; only one Table is currently supported&quot;);
339             break;
340         }
341         case ExternalKind::Global: {
342             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;globals.size(), exportNumber, &quot;th Export has invalid global number &quot;, kindIndex, &quot; it exceeds the globals count &quot;, m_info-&gt;globals.size(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
<span class="line-modified">343             WASM_PARSER_FAIL_IF(m_info-&gt;globals[kindIndex].mutability != Global::Immutable, exportNumber, &quot;th Export isn&#39;t immutable, named &#39;&quot;, fieldString, &quot;&#39;&quot;);</span>



344             break;
345         }
346         }
347 
348         m_info-&gt;exports.uncheckedAppend({ WTFMove(fieldString), kind, kindIndex });
349     }
350 
351     return { };
352 }
353 
354 auto SectionParser::parseStart() -&gt; PartialResult
355 {
356     uint32_t startFunctionIndex;
357     WASM_PARSER_FAIL_IF(!parseVarUInt32(startFunctionIndex), &quot;can&#39;t get Start index&quot;);
358     WASM_PARSER_FAIL_IF(startFunctionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Start index &quot;, startFunctionIndex, &quot; exceeds function index space &quot;, m_info-&gt;functionIndexSpaceSize());
359     SignatureIndex signatureIndex = m_info-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndex);
360     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
361     WASM_PARSER_FAIL_IF(signature.argumentCount(), &quot;Start function can&#39;t have arguments&quot;);
<span class="line-modified">362     WASM_PARSER_FAIL_IF(signature.returnType() != Void, &quot;Start function can&#39;t return a value&quot;);</span>
363     m_info-&gt;startFunctionIndexSpace = startFunctionIndex;
364     return { };
365 }
366 
367 auto SectionParser::parseElement() -&gt; PartialResult
368 {
369     uint32_t elementCount;
370     WASM_PARSER_FAIL_IF(!parseVarUInt32(elementCount), &quot;can&#39;t get Element section&#39;s count&quot;);
371     WASM_PARSER_FAIL_IF(elementCount &gt; maxTableEntries, &quot;Element section&#39;s count is too big &quot;, elementCount, &quot; maximum &quot;, maxTableEntries);
372     WASM_PARSER_FAIL_IF(!m_info-&gt;elements.tryReserveCapacity(elementCount), &quot;can&#39;t allocate memory for &quot;, elementCount, &quot; Elements&quot;);
373     for (unsigned elementNum = 0; elementNum &lt; elementCount; ++elementNum) {
374         uint32_t tableIndex;
375         uint64_t initExprBits;
376         uint8_t initOpcode;
377         uint32_t indexCount;
378 
379         uint8_t magic;
380         WASM_PARSER_FAIL_IF(!parseUInt8(magic) || (magic &amp;&amp; magic != 2), &quot;can&#39;t get &quot;, elementNum, &quot;th Element reserved byte, which should be either 0x00 or 0x02 followed by a table index&quot;);
381 
382         if (magic == 2)
</pre>
<hr />
<pre>
394 
395         ASSERT(!!m_info-&gt;tables[tableIndex]);
396 
397         Element element(tableIndex, makeI32InitExpr(initOpcode, initExprBits));
398         WASM_PARSER_FAIL_IF(!element.functionIndices.tryReserveCapacity(indexCount), &quot;can&#39;t allocate memory for &quot;, indexCount, &quot; Element indices&quot;);
399 
400         for (unsigned index = 0; index &lt; indexCount; ++index) {
401             uint32_t functionIndex;
402             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t get Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index&quot;);
403             WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index is &quot;, functionIndex, &quot; which exceeds the function index space size of &quot;, m_info-&gt;functionIndexSpaceSize());
404 
405             element.functionIndices.uncheckedAppend(functionIndex);
406         }
407 
408         m_info-&gt;elements.uncheckedAppend(WTFMove(element));
409     }
410 
411     return { };
412 }
413 
<span class="line-removed">414 // This function will be changed to be RELEASE_ASSERT_NOT_REACHED once we switch our parsing infrastructure to the streaming parser.</span>
415 auto SectionParser::parseCode() -&gt; PartialResult
416 {
<span class="line-modified">417     m_info-&gt;codeSectionSize = length();</span>
<span class="line-modified">418     uint32_t count;</span>
<span class="line-removed">419     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Code section&#39;s count&quot;);</span>
<span class="line-removed">420     WASM_PARSER_FAIL_IF(count == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, count);</span>
<span class="line-removed">421     WASM_PARSER_FAIL_IF(count != m_info-&gt;functions.size(), &quot;Code section count &quot;, count, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());</span>
<span class="line-removed">422 </span>
<span class="line-removed">423     for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-removed">424         uint32_t functionSize;</span>
<span class="line-removed">425         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSize), &quot;can&#39;t get &quot;, i, &quot;th Code function&#39;s size&quot;);</span>
<span class="line-removed">426         WASM_PARSER_FAIL_IF(functionSize &gt; length(), &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s size &quot;, length());</span>
<span class="line-removed">427         WASM_PARSER_FAIL_IF(functionSize &gt; length() - m_offset, &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s remaining size&quot;, length() - m_offset);</span>
<span class="line-removed">428         WASM_PARSER_FAIL_IF(functionSize &gt; maxFunctionSize, &quot;Code function&#39;s size &quot;, functionSize, &quot; is too big&quot;);</span>
<span class="line-removed">429 </span>
<span class="line-removed">430         Vector&lt;uint8_t&gt; data(functionSize);</span>
<span class="line-removed">431         std::memcpy(data.data(), source() + m_offset, functionSize);</span>
<span class="line-removed">432         m_info-&gt;functions[i].start = m_offsetInSource + m_offset;</span>
<span class="line-removed">433         m_info-&gt;functions[i].end = m_offsetInSource + m_offset + functionSize;</span>
<span class="line-removed">434         m_info-&gt;functions[i].data = WTFMove(data);</span>
<span class="line-removed">435         m_offset += functionSize;</span>
<span class="line-removed">436     }</span>
<span class="line-removed">437 </span>
438     return { };
439 }
440 
441 auto SectionParser::parseInitExpr(uint8_t&amp; opcode, uint64_t&amp; bitsOrImportNumber, Type&amp; resultType) -&gt; PartialResult
442 {
443     WASM_PARSER_FAIL_IF(!parseUInt8(opcode), &quot;can&#39;t get init_expr&#39;s opcode&quot;);
444 
445     switch (opcode) {
446     case I32Const: {
447         int32_t constant;
448         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t get constant value for init_expr&#39;s i32.const&quot;);
449         bitsOrImportNumber = static_cast&lt;uint64_t&gt;(constant);
450         resultType = I32;
451         break;
452     }
453 
454     case I64Const: {
455         int64_t constant;
456         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s i64.const&quot;);
457         bitsOrImportNumber = constant;
</pre>
<hr />
<pre>
464         WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t get constant value for init_expr&#39;s f32.const&quot;);
465         bitsOrImportNumber = constant;
466         resultType = F32;
467         break;
468     }
469 
470     case F64Const: {
471         uint64_t constant;
472         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s f64.const&quot;);
473         bitsOrImportNumber = constant;
474         resultType = F64;
475         break;
476     }
477 
478     case GetGlobal: {
479         uint32_t index;
480         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
481 
482         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;globals.size(), &quot;get_global&#39;s index &quot;, index, &quot; exceeds the number of globals &quot;, m_info-&gt;globals.size());
483         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;firstInternalGlobal, &quot;get_global import kind index &quot;, index, &quot; exceeds the first internal global &quot;, m_info-&gt;firstInternalGlobal);

484 
<span class="line-removed">485         ASSERT(m_info-&gt;globals[index].mutability == Global::Immutable);</span>
486         resultType = m_info-&gt;globals[index].type;
487         bitsOrImportNumber = index;
488         break;
489     }
490 
491     case RefNull: {
492         resultType = Funcref;
493         bitsOrImportNumber = JSValue::encode(jsNull());
494         break;
495     }
496 
497     case RefFunc: {
498         uint32_t index;
499         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get ref.func index&quot;);
500         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;functions.size(), &quot;ref.func index&quot;, index, &quot; exceeds the number of functions &quot;, m_info-&gt;functions.size());
501 
502         resultType = Funcref;
503         bitsOrImportNumber = index;
504         break;
505     }
506 
507     default:
508         WASM_PARSER_FAIL_IF(true, &quot;unknown init_expr opcode &quot;, opcode);
509     }
510 
511     uint8_t endOpcode;
512     WASM_PARSER_FAIL_IF(!parseUInt8(endOpcode), &quot;can&#39;t get init_expr&#39;s end opcode&quot;);
513     WASM_PARSER_FAIL_IF(endOpcode != OpType::End, &quot;init_expr should end with end, ended with &quot;, endOpcode);
514 
515     return { };
516 }
517 
<span class="line-modified">518 auto SectionParser::parseGlobalType(Global&amp; global) -&gt; PartialResult</span>
519 {
520     uint8_t mutability;
521     WASM_PARSER_FAIL_IF(!parseValueType(global.type), &quot;can&#39;t get Global&#39;s value type&quot;);
522     WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), &quot;can&#39;t get Global type&#39;s mutability&quot;);
<span class="line-modified">523     global.mutability = static_cast&lt;Global::Mutability&gt;(mutability);</span>
524     return { };
525 }
526 
527 auto SectionParser::parseData() -&gt; PartialResult
528 {
529     uint32_t segmentCount;
530     WASM_PARSER_FAIL_IF(!parseVarUInt32(segmentCount), &quot;can&#39;t get Data section&#39;s count&quot;);
531     WASM_PARSER_FAIL_IF(segmentCount &gt; maxDataSegments, &quot;Data section&#39;s count is too big &quot;, segmentCount, &quot; maximum &quot;, maxDataSegments);
532     WASM_PARSER_FAIL_IF(!m_info-&gt;data.tryReserveCapacity(segmentCount), &quot;can&#39;t allocate enough memory for Data section&#39;s &quot;, segmentCount, &quot; segments&quot;);
533 
534     for (uint32_t segmentNumber = 0; segmentNumber &lt; segmentCount; ++segmentNumber) {
535         uint32_t memoryIndex;
536         uint64_t initExprBits;
537         uint8_t initOpcode;
538         uint32_t dataByteLength;
539 
540         WASM_PARSER_FAIL_IF(!parseVarUInt32(memoryIndex), &quot;can&#39;t get &quot;, segmentNumber, &quot;th Data segment&#39;s index&quot;);
541         WASM_PARSER_FAIL_IF(memoryIndex &gt;= m_info-&gt;memoryCount(), segmentNumber, &quot;th Data segment has index &quot;, memoryIndex, &quot; which exceeds the number of Memories &quot;, m_info-&gt;memoryCount());
542         Type initExprType;
543         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, initExprBits, initExprType));
</pre>
</td>
<td>
<hr />
<pre>
 40 
 41 namespace JSC { namespace Wasm {
 42 
 43 auto SectionParser::parseType() -&gt; PartialResult
 44 {
 45     uint32_t count;
 46 
 47     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Type section&#39;s count&quot;);
 48     WASM_PARSER_FAIL_IF(count &gt; maxTypes, &quot;Type section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxTypes);
 49     WASM_PARSER_FAIL_IF(!m_info-&gt;usedSignatures.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, count, &quot; entries&quot;);
 50 
 51     for (uint32_t i = 0; i &lt; count; ++i) {
 52         int8_t type;
 53         uint32_t argumentCount;
 54         Vector&lt;Type&gt; argumentTypes;
 55 
 56         WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s type&quot;);
 57         WASM_PARSER_FAIL_IF(type != Func, i, &quot;th Type is non-Func &quot;, type);
 58         WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s argument count&quot;);
 59         WASM_PARSER_FAIL_IF(argumentCount &gt; maxFunctionParams, i, &quot;th argument count is too big &quot;, argumentCount, &quot; maximum &quot;, maxFunctionParams);
<span class="line-modified"> 60         Vector&lt;Type&gt; arguments;</span>
<span class="line-modified"> 61         WASM_PARSER_FAIL_IF(!arguments.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>

 62 
 63         for (unsigned i = 0; i &lt; argumentCount; ++i) {
 64             Type argumentType;
 65             WASM_PARSER_FAIL_IF(!parseValueType(argumentType), &quot;can&#39;t get &quot;, i, &quot;th argument Type&quot;);
<span class="line-modified"> 66             arguments.append(argumentType);</span>
 67         }
 68 
<span class="line-modified"> 69         uint32_t returnCount;</span>
<span class="line-modified"> 70         WASM_PARSER_FAIL_IF(!parseVarUInt32(returnCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return count&quot;);</span>
<span class="line-modified"> 71         WASM_PARSER_FAIL_IF(returnCount &gt; 1 &amp;&amp; !Options::useWebAssemblyMultiValues(), &quot;Signatures cannot have more than one result type yet.&quot;);</span>
<span class="line-modified"> 72 </span>
<span class="line-added"> 73         Vector&lt;Type, 1&gt; returnTypes;</span>
<span class="line-added"> 74         WASM_PARSER_FAIL_IF(!returnTypes.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>
<span class="line-added"> 75         for (unsigned i = 0; i &lt; returnCount; ++i) {</span>
 76             Type value;
 77             WASM_PARSER_FAIL_IF(!parseValueType(value), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return value&quot;);
<span class="line-modified"> 78             returnTypes.append(value);</span>
<span class="line-modified"> 79         }</span>
<span class="line-modified"> 80 </span>
<span class="line-modified"> 81         RefPtr&lt;Signature&gt; signature = SignatureInformation::signatureFor(returnTypes, arguments);</span>
<span class="line-added"> 82         WASM_PARSER_FAIL_IF(!signature, &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>
 83 
<span class="line-modified"> 84         m_info-&gt;usedSignatures.uncheckedAppend(signature.releaseNonNull());</span>
 85     }
 86     return { };
 87 }
 88 
 89 auto SectionParser::parseImport() -&gt; PartialResult
 90 {
 91     uint32_t importCount;
 92     WASM_PARSER_FAIL_IF(!parseVarUInt32(importCount), &quot;can&#39;t get Import section&#39;s count&quot;);
 93     WASM_PARSER_FAIL_IF(importCount &gt; maxImports, &quot;Import section&#39;s count is too big &quot;, importCount, &quot; maximum &quot;, maxImports);
 94     WASM_PARSER_FAIL_IF(!m_info-&gt;globals.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; globals&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 95     WASM_PARSER_FAIL_IF(!m_info-&gt;imports.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; imports&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 96     WASM_PARSER_FAIL_IF(!m_info-&gt;importFunctionSignatureIndices.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; import function signatures&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 97 
 98     for (uint32_t importNumber = 0; importNumber &lt; importCount; ++importNumber) {
 99         uint32_t moduleLen;
100         uint32_t fieldLen;
101         Name moduleString;
102         Name fieldString;
103         ExternalKind kind;
104         unsigned kindIndex { 0 };
</pre>
<hr />
<pre>
119             SignatureIndex signatureIndex = SignatureInformation::get(m_info-&gt;usedSignatures[functionSignatureIndex]);
120             m_info-&gt;importFunctionSignatureIndices.uncheckedAppend(signatureIndex);
121             break;
122         }
123         case ExternalKind::Table: {
124             bool isImport = true;
125             kindIndex = m_info-&gt;tables.size();
126             PartialResult result = parseTableHelper(isImport);
127             if (UNLIKELY(!result))
128                 return makeUnexpected(WTFMove(result.error()));
129             break;
130         }
131         case ExternalKind::Memory: {
132             bool isImport = true;
133             PartialResult result = parseMemoryHelper(isImport);
134             if (UNLIKELY(!result))
135                 return makeUnexpected(WTFMove(result.error()));
136             break;
137         }
138         case ExternalKind::Global: {
<span class="line-modified">139             GlobalInformation global;</span>
140             WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
<span class="line-modified">141             // Only mutable globals need floating bindings.</span>
<span class="line-modified">142             if (global.mutability == GlobalInformation::Mutability::Mutable)</span>
<span class="line-added">143                 global.bindingMode = GlobalInformation::BindingMode::Portable;</span>
144             kindIndex = m_info-&gt;globals.size();
145             m_info-&gt;globals.uncheckedAppend(WTFMove(global));
146             break;
147         }
148         }
149 
150         m_info-&gt;imports.uncheckedAppend({ WTFMove(moduleString), WTFMove(fieldString), kind, kindIndex });
151     }
152 
153     m_info-&gt;firstInternalGlobal = m_info-&gt;globals.size();
154     return { };
155 }
156 
157 auto SectionParser::parseFunction() -&gt; PartialResult
158 {
159     uint32_t count;
160     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Function section&#39;s count&quot;);
161     WASM_PARSER_FAIL_IF(count &gt; maxFunctions, &quot;Function section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxFunctions);
162     WASM_PARSER_FAIL_IF(!m_info-&gt;internalFunctionSignatureIndices.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for &quot;, count, &quot; Function signatures&quot;);
163     WASM_PARSER_FAIL_IF(!m_info-&gt;functions.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for &quot;, count, &quot;Function locations&quot;);
</pre>
<hr />
<pre>
269     WASM_PARSER_FAIL_IF(!parseVarUInt1(count), &quot;can&#39;t parse Memory section&#39;s count&quot;);
270 
271     if (!count)
272         return { };
273 
274     WASM_PARSER_FAIL_IF(count != 1, &quot;Memory section has more than one memory, WebAssembly currently only allows zero or one&quot;);
275 
276     bool isImport = false;
277     return parseMemoryHelper(isImport);
278 }
279 
280 auto SectionParser::parseGlobal() -&gt; PartialResult
281 {
282     uint32_t globalCount;
283     WASM_PARSER_FAIL_IF(!parseVarUInt32(globalCount), &quot;can&#39;t get Global section&#39;s count&quot;);
284     WASM_PARSER_FAIL_IF(globalCount &gt; maxGlobals, &quot;Global section&#39;s count is too big &quot;, globalCount, &quot; maximum &quot;, maxGlobals);
285     size_t totalBytes = globalCount + m_info-&gt;firstInternalGlobal;
286     WASM_PARSER_FAIL_IF((static_cast&lt;uint32_t&gt;(totalBytes) &lt; globalCount) || !m_info-&gt;globals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; globals&quot;);
287 
288     for (uint32_t globalIndex = 0; globalIndex &lt; globalCount; ++globalIndex) {
<span class="line-modified">289         GlobalInformation global;</span>
290         uint8_t initOpcode;
291 
292         WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
293         Type typeForInitOpcode;
294         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
295         if (initOpcode == GetGlobal)
<span class="line-modified">296             global.initializationType = GlobalInformation::FromGlobalImport;</span>
297         else if (initOpcode == RefFunc)
<span class="line-modified">298             global.initializationType = GlobalInformation::FromRefFunc;</span>
299         else
<span class="line-modified">300             global.initializationType = GlobalInformation::FromExpression;</span>
301         WASM_PARSER_FAIL_IF(!isSubtype(typeForInitOpcode, global.type), &quot;Global init_expr opcode of type &quot;, typeForInitOpcode, &quot; doesn&#39;t match global&#39;s type &quot;, global.type);
302 
303         m_info-&gt;globals.uncheckedAppend(WTFMove(global));
304     }
305 
306     return { };
307 }
308 
309 auto SectionParser::parseExport() -&gt; PartialResult
310 {
311     uint32_t exportCount;
312     WASM_PARSER_FAIL_IF(!parseVarUInt32(exportCount), &quot;can&#39;t get Export section&#39;s count&quot;);
313     WASM_PARSER_FAIL_IF(exportCount &gt; maxExports, &quot;Export section&#39;s count is too big &quot;, exportCount, &quot; maximum &quot;, maxExports);
314     WASM_PARSER_FAIL_IF(!m_info-&gt;exports.tryReserveCapacity(exportCount), &quot;can&#39;t allocate enough memory for &quot;, exportCount, &quot; exports&quot;);
315 
316     HashSet&lt;String&gt; exportNames;
317     for (uint32_t exportNumber = 0; exportNumber &lt; exportCount; ++exportNumber) {
318         uint32_t fieldLen;
319         Name fieldString;
320         ExternalKind kind;
</pre>
<hr />
<pre>
327         exportNames.add(fieldName);
328 
329         WASM_PARSER_FAIL_IF(!parseExternalKind(kind), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s kind, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
330         WASM_PARSER_FAIL_IF(!parseVarUInt32(kindIndex), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s kind index, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
331         switch (kind) {
332         case ExternalKind::Function: {
333             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;functionIndexSpaceSize(), exportNumber, &quot;th Export has invalid function number &quot;, kindIndex, &quot; it exceeds the function index space &quot;, m_info-&gt;functionIndexSpaceSize(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
334             break;
335         }
336         case ExternalKind::Table: {
337             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;tableCount(), &quot;can&#39;t export Table &quot;, kindIndex, &quot; there are &quot;, m_info-&gt;tableCount(), &quot; Tables&quot;);
338             break;
339         }
340         case ExternalKind::Memory: {
341             WASM_PARSER_FAIL_IF(!m_info-&gt;memory, &quot;can&#39;t export a non-existent Memory&quot;);
342             WASM_PARSER_FAIL_IF(kindIndex, &quot;can&#39;t export Memory &quot;, kindIndex, &quot; only one Table is currently supported&quot;);
343             break;
344         }
345         case ExternalKind::Global: {
346             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;globals.size(), exportNumber, &quot;th Export has invalid global number &quot;, kindIndex, &quot; it exceeds the globals count &quot;, m_info-&gt;globals.size(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
<span class="line-modified">347             // Only mutable globals need floating bindings.</span>
<span class="line-added">348             GlobalInformation&amp; global = m_info-&gt;globals[kindIndex];</span>
<span class="line-added">349             if (global.mutability == GlobalInformation::Mutability::Mutable)</span>
<span class="line-added">350                 global.bindingMode = GlobalInformation::BindingMode::Portable;</span>
351             break;
352         }
353         }
354 
355         m_info-&gt;exports.uncheckedAppend({ WTFMove(fieldString), kind, kindIndex });
356     }
357 
358     return { };
359 }
360 
361 auto SectionParser::parseStart() -&gt; PartialResult
362 {
363     uint32_t startFunctionIndex;
364     WASM_PARSER_FAIL_IF(!parseVarUInt32(startFunctionIndex), &quot;can&#39;t get Start index&quot;);
365     WASM_PARSER_FAIL_IF(startFunctionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Start index &quot;, startFunctionIndex, &quot; exceeds function index space &quot;, m_info-&gt;functionIndexSpaceSize());
366     SignatureIndex signatureIndex = m_info-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndex);
367     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
368     WASM_PARSER_FAIL_IF(signature.argumentCount(), &quot;Start function can&#39;t have arguments&quot;);
<span class="line-modified">369     WASM_PARSER_FAIL_IF(!signature.returnsVoid(), &quot;Start function can&#39;t return a value&quot;);</span>
370     m_info-&gt;startFunctionIndexSpace = startFunctionIndex;
371     return { };
372 }
373 
374 auto SectionParser::parseElement() -&gt; PartialResult
375 {
376     uint32_t elementCount;
377     WASM_PARSER_FAIL_IF(!parseVarUInt32(elementCount), &quot;can&#39;t get Element section&#39;s count&quot;);
378     WASM_PARSER_FAIL_IF(elementCount &gt; maxTableEntries, &quot;Element section&#39;s count is too big &quot;, elementCount, &quot; maximum &quot;, maxTableEntries);
379     WASM_PARSER_FAIL_IF(!m_info-&gt;elements.tryReserveCapacity(elementCount), &quot;can&#39;t allocate memory for &quot;, elementCount, &quot; Elements&quot;);
380     for (unsigned elementNum = 0; elementNum &lt; elementCount; ++elementNum) {
381         uint32_t tableIndex;
382         uint64_t initExprBits;
383         uint8_t initOpcode;
384         uint32_t indexCount;
385 
386         uint8_t magic;
387         WASM_PARSER_FAIL_IF(!parseUInt8(magic) || (magic &amp;&amp; magic != 2), &quot;can&#39;t get &quot;, elementNum, &quot;th Element reserved byte, which should be either 0x00 or 0x02 followed by a table index&quot;);
388 
389         if (magic == 2)
</pre>
<hr />
<pre>
401 
402         ASSERT(!!m_info-&gt;tables[tableIndex]);
403 
404         Element element(tableIndex, makeI32InitExpr(initOpcode, initExprBits));
405         WASM_PARSER_FAIL_IF(!element.functionIndices.tryReserveCapacity(indexCount), &quot;can&#39;t allocate memory for &quot;, indexCount, &quot; Element indices&quot;);
406 
407         for (unsigned index = 0; index &lt; indexCount; ++index) {
408             uint32_t functionIndex;
409             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t get Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index&quot;);
410             WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index is &quot;, functionIndex, &quot; which exceeds the function index space size of &quot;, m_info-&gt;functionIndexSpaceSize());
411 
412             element.functionIndices.uncheckedAppend(functionIndex);
413         }
414 
415         m_info-&gt;elements.uncheckedAppend(WTFMove(element));
416     }
417 
418     return { };
419 }
420 

421 auto SectionParser::parseCode() -&gt; PartialResult
422 {
<span class="line-modified">423     // The Code section is handled specially in StreamingParser.</span>
<span class="line-modified">424     RELEASE_ASSERT_NOT_REACHED();</span>



















425     return { };
426 }
427 
428 auto SectionParser::parseInitExpr(uint8_t&amp; opcode, uint64_t&amp; bitsOrImportNumber, Type&amp; resultType) -&gt; PartialResult
429 {
430     WASM_PARSER_FAIL_IF(!parseUInt8(opcode), &quot;can&#39;t get init_expr&#39;s opcode&quot;);
431 
432     switch (opcode) {
433     case I32Const: {
434         int32_t constant;
435         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t get constant value for init_expr&#39;s i32.const&quot;);
436         bitsOrImportNumber = static_cast&lt;uint64_t&gt;(constant);
437         resultType = I32;
438         break;
439     }
440 
441     case I64Const: {
442         int64_t constant;
443         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s i64.const&quot;);
444         bitsOrImportNumber = constant;
</pre>
<hr />
<pre>
451         WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t get constant value for init_expr&#39;s f32.const&quot;);
452         bitsOrImportNumber = constant;
453         resultType = F32;
454         break;
455     }
456 
457     case F64Const: {
458         uint64_t constant;
459         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s f64.const&quot;);
460         bitsOrImportNumber = constant;
461         resultType = F64;
462         break;
463     }
464 
465     case GetGlobal: {
466         uint32_t index;
467         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
468 
469         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;globals.size(), &quot;get_global&#39;s index &quot;, index, &quot; exceeds the number of globals &quot;, m_info-&gt;globals.size());
470         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;firstInternalGlobal, &quot;get_global import kind index &quot;, index, &quot; exceeds the first internal global &quot;, m_info-&gt;firstInternalGlobal);
<span class="line-added">471         WASM_PARSER_FAIL_IF(m_info-&gt;globals[index].mutability != GlobalInformation::Immutable, &quot;get_global import kind index &quot;, index, &quot; is mutable &quot;);</span>
472 

473         resultType = m_info-&gt;globals[index].type;
474         bitsOrImportNumber = index;
475         break;
476     }
477 
478     case RefNull: {
479         resultType = Funcref;
480         bitsOrImportNumber = JSValue::encode(jsNull());
481         break;
482     }
483 
484     case RefFunc: {
485         uint32_t index;
486         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get ref.func index&quot;);
487         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;functions.size(), &quot;ref.func index&quot;, index, &quot; exceeds the number of functions &quot;, m_info-&gt;functions.size());
488 
489         resultType = Funcref;
490         bitsOrImportNumber = index;
491         break;
492     }
493 
494     default:
495         WASM_PARSER_FAIL_IF(true, &quot;unknown init_expr opcode &quot;, opcode);
496     }
497 
498     uint8_t endOpcode;
499     WASM_PARSER_FAIL_IF(!parseUInt8(endOpcode), &quot;can&#39;t get init_expr&#39;s end opcode&quot;);
500     WASM_PARSER_FAIL_IF(endOpcode != OpType::End, &quot;init_expr should end with end, ended with &quot;, endOpcode);
501 
502     return { };
503 }
504 
<span class="line-modified">505 auto SectionParser::parseGlobalType(GlobalInformation&amp; global) -&gt; PartialResult</span>
506 {
507     uint8_t mutability;
508     WASM_PARSER_FAIL_IF(!parseValueType(global.type), &quot;can&#39;t get Global&#39;s value type&quot;);
509     WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), &quot;can&#39;t get Global type&#39;s mutability&quot;);
<span class="line-modified">510     global.mutability = static_cast&lt;GlobalInformation::Mutability&gt;(mutability);</span>
511     return { };
512 }
513 
514 auto SectionParser::parseData() -&gt; PartialResult
515 {
516     uint32_t segmentCount;
517     WASM_PARSER_FAIL_IF(!parseVarUInt32(segmentCount), &quot;can&#39;t get Data section&#39;s count&quot;);
518     WASM_PARSER_FAIL_IF(segmentCount &gt; maxDataSegments, &quot;Data section&#39;s count is too big &quot;, segmentCount, &quot; maximum &quot;, maxDataSegments);
519     WASM_PARSER_FAIL_IF(!m_info-&gt;data.tryReserveCapacity(segmentCount), &quot;can&#39;t allocate enough memory for Data section&#39;s &quot;, segmentCount, &quot; segments&quot;);
520 
521     for (uint32_t segmentNumber = 0; segmentNumber &lt; segmentCount; ++segmentNumber) {
522         uint32_t memoryIndex;
523         uint64_t initExprBits;
524         uint8_t initOpcode;
525         uint32_t dataByteLength;
526 
527         WASM_PARSER_FAIL_IF(!parseVarUInt32(memoryIndex), &quot;can&#39;t get &quot;, segmentNumber, &quot;th Data segment&#39;s index&quot;);
528         WASM_PARSER_FAIL_IF(memoryIndex &gt;= m_info-&gt;memoryCount(), segmentNumber, &quot;th Data segment has index &quot;, memoryIndex, &quot; which exceeds the number of Memories &quot;, m_info-&gt;memoryCount());
529         Type initExprType;
530         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, initExprBits, initExprType));
</pre>
</td>
</tr>
</table>
<center><a href="WasmPlan.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSectionParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
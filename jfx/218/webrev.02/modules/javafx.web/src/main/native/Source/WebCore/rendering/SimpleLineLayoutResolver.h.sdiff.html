<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimpleLineLayoutResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TableLayout.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41     class Iterator;
 42 
 43     class Run {
 44     public:
 45         explicit Run(const Iterator&amp;);
 46 
 47         // Position relative to the enclosing flow block.
 48         unsigned start() const;
 49         unsigned end() const;
 50         // Position relative to the actual renderer.
 51         unsigned localStart() const;
 52         unsigned localEnd() const;
 53 
 54         float logicalLeft() const;
 55         float logicalRight() const;
 56 
 57         FloatRect rect() const;
 58         float expansion() const;
 59         ExpansionBehavior expansionBehavior() const;
 60         int baselinePosition() const;

 61         StringView text() const;
 62         String textWithHyphen() const;
 63         const RenderObject&amp; renderer() const;
 64         bool isEndOfLine() const;
 65         bool hasHyphen() const { return m_iterator.simpleRun().hasHyphen; }

 66         const SimpleLineLayout::Run&amp; simpleRun() const { return m_iterator.simpleRun(); }
 67 
 68         unsigned lineIndex() const;
 69 
 70     private:
 71         float computeBaselinePosition() const;
 72         void constructStringForHyphenIfNeeded();
 73 
 74         const Iterator&amp; m_iterator;
 75     };
 76 
 77     class Iterator {
 78     friend class Run;
 79     friend class RunResolver;
 80     friend class LineResolver;
 81     public:
 82         Iterator(const RunResolver&amp;, unsigned runIndex, unsigned lineIndex);
 83 
 84         Iterator&amp; operator++();
 85         Iterator&amp; operator--();
 86 
 87         bool operator==(const Iterator&amp;) const;
 88         bool operator!=(const Iterator&amp;) const;
 89 
 90         Run operator*() const;
 91 


 92     private:
 93         const SimpleLineLayout::Run&amp; simpleRun() const;
 94         unsigned lineIndex() const { return m_lineIndex; }
 95         Iterator&amp; advance();
 96         Iterator&amp; advanceLines(unsigned);
<span class="line-modified"> 97         const RunResolver&amp; resolver() const { return m_resolver; }</span>
<span class="line-modified"> 98         bool inQuirksMode() const { return m_resolver.m_inQuirksMode; }</span>
 99 
<span class="line-modified">100         const RunResolver&amp; m_resolver;</span>

101         unsigned m_runIndex;
102         unsigned m_lineIndex;
103     };
104 
105     RunResolver(const RenderBlockFlow&amp;, const Layout&amp;);
106 
107     const RenderBlockFlow&amp; flow() const { return m_flowRenderer; }
108     const FlowContents&amp; flowContents() const { return m_flowContents; }
109     Iterator begin() const;
110     Iterator end() const;
111 
112     WTF::IteratorRange&lt;Iterator&gt; rangeForRect(const LayoutRect&amp;) const;
113     WTF::IteratorRange&lt;Iterator&gt; rangeForRenderer(const RenderObject&amp;) const;
114     WTF::IteratorRange&lt;Iterator&gt; rangeForLine(unsigned lineIndex) const;
115     Iterator runForPoint(const LayoutPoint&amp;) const;
116     WTF::IteratorRange&lt;Iterator&gt; rangeForRendererWithOffsets(const RenderObject&amp;, unsigned start, unsigned end) const;
117 
118 private:
119     enum class IndexType { First, Last };
120     unsigned lineIndexForHeight(LayoutUnit, IndexType) const;
121     unsigned adjustLineIndexForStruts(LayoutUnit, IndexType, unsigned lineIndexCandidate) const;
122 
123     const RenderBlockFlow&amp; m_flowRenderer;
124     const Layout&amp; m_layout;
125     const FlowContents m_flowContents;
126     const LayoutUnit m_lineHeight;
127     const LayoutUnit m_baseline;
128     const LayoutUnit m_borderAndPaddingBefore;
129     const float m_ascent;
130     const float m_descent;
131     const float m_visualOverflowOffset;
<span class="line-removed">132     const bool m_inQuirksMode;</span>
133 };
134 
135 class LineResolver {
136 public:
137     class Iterator {
138     public:
139         explicit Iterator(RunResolver::Iterator);
140 
141         Iterator&amp; operator++();
142         bool operator==(const Iterator&amp;) const;
143         bool operator!=(const Iterator&amp;) const;
144 
145         FloatRect operator*() const;
146         // FIXME: Use a list to support multiple renderers per line.
147         const RenderObject&amp; renderer() const;
148 
149     private:
150         RunResolver::Iterator m_runIterator;
151     };
152 
</pre>
<hr />
<pre>
201 
202 inline bool RunResolver::Run::isEndOfLine() const
203 {
204     return m_iterator.simpleRun().isEndOfLine;
205 }
206 
207 inline unsigned RunResolver::Run::lineIndex() const
208 {
209     return m_iterator.lineIndex();
210 }
211 
212 inline RunResolver::Iterator&amp; RunResolver::Iterator::operator++()
213 {
214     return advance();
215 }
216 
217 inline float RunResolver::Run::computeBaselinePosition() const
218 {
219     auto&amp; resolver = m_iterator.resolver();
220     auto offset = resolver.m_borderAndPaddingBefore + resolver.m_lineHeight * lineIndex();
<span class="line-modified">221     if (!resolver.m_layout.hasLineStruts())</span>
222         return offset + resolver.m_baseline;
223     for (auto&amp; strutEntry : resolver.m_layout.struts()) {
224         if (strutEntry.lineBreak &gt; lineIndex())
225             break;
226         offset += strutEntry.offset;
227     }
228     return offset + resolver.m_baseline;
229 }
230 
231 inline RunResolver::Iterator&amp; RunResolver::Iterator::operator--()
232 {
233     --m_runIndex;
234     if (simpleRun().isEndOfLine)
235         --m_lineIndex;
236     return *this;
237 }
238 
239 inline bool RunResolver::Iterator::operator==(const Iterator&amp; other) const
240 {
<span class="line-modified">241     ASSERT(&amp;m_resolver == &amp;other.m_resolver);</span>
242     return m_runIndex == other.m_runIndex;
243 }
244 
245 inline bool RunResolver::Iterator::operator!=(const Iterator&amp; other) const
246 {
247     return !(*this == other);
248 }
249 
250 inline RunResolver::Run RunResolver::Iterator::operator*() const
251 {
252     return Run(*this);
253 }
254 





255 inline const SimpleLineLayout::Run&amp; RunResolver::Iterator::simpleRun() const
256 {
<span class="line-modified">257     return m_resolver.m_layout.runAt(m_runIndex);</span>
258 }
259 
260 inline RunResolver::Iterator RunResolver::begin() const
261 {
262     return Iterator(*this, 0, 0);
263 }
264 
265 inline RunResolver::Iterator RunResolver::end() const
266 {
267     return Iterator(*this, m_layout.runCount(), m_layout.lineCount());
268 }
269 
270 inline LineResolver::Iterator&amp; LineResolver::Iterator::operator++()
271 {
272     m_runIterator.advanceLines(1);
273     return *this;
274 }
275 
276 inline bool LineResolver::Iterator::operator==(const Iterator&amp; other) const
277 {
</pre>
<hr />
<pre>
282 {
283     return m_runIterator != other.m_runIterator;
284 }
285 
286 inline LineResolver::Iterator LineResolver::begin() const
287 {
288     return Iterator(m_runResolver.begin());
289 }
290 
291 inline LineResolver::Iterator LineResolver::end() const
292 {
293     return Iterator(m_runResolver.end());
294 }
295 
296 inline WTF::IteratorRange&lt;LineResolver::Iterator&gt; LineResolver::rangeForRect(const LayoutRect&amp; rect) const
297 {
298     auto runRange = m_runResolver.rangeForRect(rect);
299     return { Iterator(runRange.begin()), Iterator(runRange.end()) };
300 }
301 
<span class="line-removed">302 inline RunResolver runResolver(const RenderBlockFlow&amp; flow, const Layout&amp; layout)</span>
<span class="line-removed">303 {</span>
<span class="line-removed">304     return RunResolver(flow, layout);</span>
<span class="line-removed">305 }</span>
<span class="line-removed">306 </span>
307 inline LineResolver lineResolver(const RunResolver&amp; runResolver)
308 {
309     return LineResolver(runResolver);
310 }
311 
312 }
313 }
</pre>
</td>
<td>
<hr />
<pre>
 41     class Iterator;
 42 
 43     class Run {
 44     public:
 45         explicit Run(const Iterator&amp;);
 46 
 47         // Position relative to the enclosing flow block.
 48         unsigned start() const;
 49         unsigned end() const;
 50         // Position relative to the actual renderer.
 51         unsigned localStart() const;
 52         unsigned localEnd() const;
 53 
 54         float logicalLeft() const;
 55         float logicalRight() const;
 56 
 57         FloatRect rect() const;
 58         float expansion() const;
 59         ExpansionBehavior expansionBehavior() const;
 60         int baselinePosition() const;
<span class="line-added"> 61         int baselineOffset() const { return m_iterator.resolver().m_baseline; }</span>
 62         StringView text() const;
 63         String textWithHyphen() const;
 64         const RenderObject&amp; renderer() const;
 65         bool isEndOfLine() const;
 66         bool hasHyphen() const { return m_iterator.simpleRun().hasHyphen; }
<span class="line-added"> 67         bool isLineBreak() const { return m_iterator.simpleRun().isLineBreak; }</span>
 68         const SimpleLineLayout::Run&amp; simpleRun() const { return m_iterator.simpleRun(); }
 69 
 70         unsigned lineIndex() const;
 71 
 72     private:
 73         float computeBaselinePosition() const;
 74         void constructStringForHyphenIfNeeded();
 75 
 76         const Iterator&amp; m_iterator;
 77     };
 78 
 79     class Iterator {
 80     friend class Run;
 81     friend class RunResolver;
 82     friend class LineResolver;
 83     public:
 84         Iterator(const RunResolver&amp;, unsigned runIndex, unsigned lineIndex);
 85 
 86         Iterator&amp; operator++();
 87         Iterator&amp; operator--();
 88 
 89         bool operator==(const Iterator&amp;) const;
 90         bool operator!=(const Iterator&amp;) const;
 91 
 92         Run operator*() const;
 93 
<span class="line-added"> 94         bool atBegin() const;</span>
<span class="line-added"> 95 </span>
 96     private:
 97         const SimpleLineLayout::Run&amp; simpleRun() const;
 98         unsigned lineIndex() const { return m_lineIndex; }
 99         Iterator&amp; advance();
100         Iterator&amp; advanceLines(unsigned);
<span class="line-modified">101         const RunResolver&amp; resolver() const { return *m_resolver; }</span>
<span class="line-modified">102         const Layout&amp; layout() const { return *m_layout; }</span>
103 
<span class="line-modified">104         RefPtr&lt;const Layout&gt; m_layout;</span>
<span class="line-added">105         const RunResolver* m_resolver;</span>
106         unsigned m_runIndex;
107         unsigned m_lineIndex;
108     };
109 
110     RunResolver(const RenderBlockFlow&amp;, const Layout&amp;);
111 
112     const RenderBlockFlow&amp; flow() const { return m_flowRenderer; }
113     const FlowContents&amp; flowContents() const { return m_flowContents; }
114     Iterator begin() const;
115     Iterator end() const;
116 
117     WTF::IteratorRange&lt;Iterator&gt; rangeForRect(const LayoutRect&amp;) const;
118     WTF::IteratorRange&lt;Iterator&gt; rangeForRenderer(const RenderObject&amp;) const;
119     WTF::IteratorRange&lt;Iterator&gt; rangeForLine(unsigned lineIndex) const;
120     Iterator runForPoint(const LayoutPoint&amp;) const;
121     WTF::IteratorRange&lt;Iterator&gt; rangeForRendererWithOffsets(const RenderObject&amp;, unsigned start, unsigned end) const;
122 
123 private:
124     enum class IndexType { First, Last };
125     unsigned lineIndexForHeight(LayoutUnit, IndexType) const;
126     unsigned adjustLineIndexForStruts(LayoutUnit, IndexType, unsigned lineIndexCandidate) const;
127 
128     const RenderBlockFlow&amp; m_flowRenderer;
129     const Layout&amp; m_layout;
130     const FlowContents m_flowContents;
131     const LayoutUnit m_lineHeight;
132     const LayoutUnit m_baseline;
133     const LayoutUnit m_borderAndPaddingBefore;
134     const float m_ascent;
135     const float m_descent;
136     const float m_visualOverflowOffset;

137 };
138 
139 class LineResolver {
140 public:
141     class Iterator {
142     public:
143         explicit Iterator(RunResolver::Iterator);
144 
145         Iterator&amp; operator++();
146         bool operator==(const Iterator&amp;) const;
147         bool operator!=(const Iterator&amp;) const;
148 
149         FloatRect operator*() const;
150         // FIXME: Use a list to support multiple renderers per line.
151         const RenderObject&amp; renderer() const;
152 
153     private:
154         RunResolver::Iterator m_runIterator;
155     };
156 
</pre>
<hr />
<pre>
205 
206 inline bool RunResolver::Run::isEndOfLine() const
207 {
208     return m_iterator.simpleRun().isEndOfLine;
209 }
210 
211 inline unsigned RunResolver::Run::lineIndex() const
212 {
213     return m_iterator.lineIndex();
214 }
215 
216 inline RunResolver::Iterator&amp; RunResolver::Iterator::operator++()
217 {
218     return advance();
219 }
220 
221 inline float RunResolver::Run::computeBaselinePosition() const
222 {
223     auto&amp; resolver = m_iterator.resolver();
224     auto offset = resolver.m_borderAndPaddingBefore + resolver.m_lineHeight * lineIndex();
<span class="line-modified">225     if (!m_iterator.layout().hasLineStruts())</span>
226         return offset + resolver.m_baseline;
227     for (auto&amp; strutEntry : resolver.m_layout.struts()) {
228         if (strutEntry.lineBreak &gt; lineIndex())
229             break;
230         offset += strutEntry.offset;
231     }
232     return offset + resolver.m_baseline;
233 }
234 
235 inline RunResolver::Iterator&amp; RunResolver::Iterator::operator--()
236 {
237     --m_runIndex;
238     if (simpleRun().isEndOfLine)
239         --m_lineIndex;
240     return *this;
241 }
242 
243 inline bool RunResolver::Iterator::operator==(const Iterator&amp; other) const
244 {
<span class="line-modified">245     ASSERT(m_resolver == other.m_resolver);</span>
246     return m_runIndex == other.m_runIndex;
247 }
248 
249 inline bool RunResolver::Iterator::operator!=(const Iterator&amp; other) const
250 {
251     return !(*this == other);
252 }
253 
254 inline RunResolver::Run RunResolver::Iterator::operator*() const
255 {
256     return Run(*this);
257 }
258 
<span class="line-added">259 inline bool RunResolver::Iterator::atBegin() const</span>
<span class="line-added">260 {</span>
<span class="line-added">261     return *this == resolver().begin();</span>
<span class="line-added">262 }</span>
<span class="line-added">263 </span>
264 inline const SimpleLineLayout::Run&amp; RunResolver::Iterator::simpleRun() const
265 {
<span class="line-modified">266     return layout().runAt(m_runIndex);</span>
267 }
268 
269 inline RunResolver::Iterator RunResolver::begin() const
270 {
271     return Iterator(*this, 0, 0);
272 }
273 
274 inline RunResolver::Iterator RunResolver::end() const
275 {
276     return Iterator(*this, m_layout.runCount(), m_layout.lineCount());
277 }
278 
279 inline LineResolver::Iterator&amp; LineResolver::Iterator::operator++()
280 {
281     m_runIterator.advanceLines(1);
282     return *this;
283 }
284 
285 inline bool LineResolver::Iterator::operator==(const Iterator&amp; other) const
286 {
</pre>
<hr />
<pre>
291 {
292     return m_runIterator != other.m_runIterator;
293 }
294 
295 inline LineResolver::Iterator LineResolver::begin() const
296 {
297     return Iterator(m_runResolver.begin());
298 }
299 
300 inline LineResolver::Iterator LineResolver::end() const
301 {
302     return Iterator(m_runResolver.end());
303 }
304 
305 inline WTF::IteratorRange&lt;LineResolver::Iterator&gt; LineResolver::rangeForRect(const LayoutRect&amp; rect) const
306 {
307     auto runRange = m_runResolver.rangeForRect(rect);
308     return { Iterator(runRange.begin()), Iterator(runRange.end()) };
309 }
310 





311 inline LineResolver lineResolver(const RunResolver&amp; runResolver)
312 {
313     return LineResolver(runResolver);
314 }
315 
316 }
317 }
</pre>
</td>
</tr>
</table>
<center><a href="SimpleLineLayoutResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TableLayout.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
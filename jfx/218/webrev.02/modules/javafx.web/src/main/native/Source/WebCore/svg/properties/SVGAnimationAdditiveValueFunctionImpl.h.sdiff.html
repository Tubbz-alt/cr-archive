<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimationAdditiveValueFunctionImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGAnimationAdditiveListFunctionImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGDecoratedEnumeration.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimationAdditiveValueFunctionImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Color.h&quot;
 29 #include &quot;FloatRect.h&quot;
 30 #include &quot;SVGAngleValue.h&quot;
 31 #include &quot;SVGAnimationAdditiveValueFunction.h&quot;

 32 #include &quot;SVGLengthValue.h&quot;
 33 #include &quot;SVGPathByteStream.h&quot;
 34 #include &quot;SVGPropertyTraits.h&quot;
 35 




 36 namespace WebCore {
 37 
 38 class SVGAnimationAngleFunction : public SVGAnimationAdditiveValueFunction&lt;SVGAngleValue&gt; {
 39 public:
 40     using Base = SVGAnimationAdditiveValueFunction&lt;SVGAngleValue&gt;;
 41     using Base::Base;
 42 
 43     void setFromAndToValues(SVGElement*, const String&amp;, const String&amp;) override
 44     {
 45         // Values will be set by SVGAnimatedAngleOrientAnimator.
 46         ASSERT_NOT_REACHED();
 47     }
 48 
 49     void animate(SVGElement*, float progress, unsigned repeatCount, SVGAngleValue&amp; animated)
 50     {
 51         float number = animated.value();
 52         number = Base::animate(progress, repeatCount, m_from.value(), m_to.value(), toAtEndOfDuration().value(), number);
 53         animated.setValue(number);
 54     }
 55 
</pre>
<hr />
<pre>
 84 
 85         float red = Base::animate(progress, repeatCount, from.red(), m_to.red(), toAtEndOfDuration().red(), animated.red());
 86         float green = Base::animate(progress, repeatCount, from.green(), m_to.green(), toAtEndOfDuration().green(), animated.green());
 87         float blue = Base::animate(progress, repeatCount, from.blue(), m_to.blue(), toAtEndOfDuration().blue(), animated.blue());
 88         float alpha = Base::animate(progress, repeatCount, from.alpha(), m_to.alpha(), toAtEndOfDuration().alpha(), animated.alpha());
 89 
 90         animated = { roundAndClampColorChannel(red), roundAndClampColorChannel(green), roundAndClampColorChannel(blue), roundAndClampColorChannel(alpha) };
 91     }
 92 
 93     Optional&lt;float&gt; calculateDistance(SVGElement*, const String&amp; from, const String&amp; to) const override
 94     {
 95         Color fromColor = CSSParser::parseColor(from.stripWhiteSpace());
 96         if (!fromColor.isValid())
 97             return { };
 98         Color toColor = CSSParser::parseColor(to.stripWhiteSpace());
 99         if (!toColor.isValid())
100             return { };
101         float red = fromColor.red() - toColor.red();
102         float green = fromColor.green() - toColor.green();
103         float blue = fromColor.blue() - toColor.blue();
<span class="line-modified">104         return sqrtf(red * red + green * green + blue * blue);</span>




105     }
106 
107 private:
108     void addFromAndToValues(SVGElement*) override
109     {
110         // Ignores any alpha and sets alpha on result to 100% opaque.
111         m_to = {
112             roundAndClampColorChannel(m_to.red() + m_from.red()),
113             roundAndClampColorChannel(m_to.green() + m_from.green()),
114             roundAndClampColorChannel(m_to.blue() + m_from.blue())
115         };
116     }
117 
118     static Color colorFromString(SVGElement*, const String&amp;);
119 };
120 
121 class SVGAnimationIntegerFunction : public SVGAnimationAdditiveValueFunction&lt;int&gt; {
122     friend class SVGAnimatedIntegerPairAnimator;
123 
124 public:
</pre>
<hr />
<pre>
160     SVGAnimationLengthFunction(AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive, SVGLengthMode lengthMode)
161         : Base(animationMode, calcMode, isAccumulated, isAdditive)
162         , m_lengthMode(lengthMode)
163     {
164     }
165 
166     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
167     {
168         m_from = SVGLengthValue(m_lengthMode, from);
169         m_to = SVGLengthValue(m_lengthMode, to);
170     }
171 
172     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
173     {
174         m_toAtEndOfDuration = SVGLengthValue(m_lengthMode, toAtEndOfDuration);
175     }
176 
177     void animate(SVGElement* targetElement, float progress, unsigned repeatCount, SVGLengthValue&amp; animated)
178     {
179         SVGLengthContext lengthContext(targetElement);
<span class="line-modified">180         SVGLengthType unitType = progress &lt; 0.5 ? m_from.unitType() : m_to.unitType();</span>
181 
182         float from = (m_animationMode == AnimationMode::To ? animated : m_from).value(lengthContext);
183         float to = m_to.value(lengthContext);
184         float toAtEndOfDuration = this-&gt;toAtEndOfDuration().value(lengthContext);
185         float value = animated.value(lengthContext);
186 
187         value = Base::animate(progress, repeatCount, from, to, toAtEndOfDuration, value);
<span class="line-modified">188         animated = { lengthContext, value, m_lengthMode, unitType };</span>
189     }
190 
191     Optional&lt;float&gt; calculateDistance(SVGElement* targetElement, const String&amp; from, const String&amp; to) const override
192     {
193         SVGLengthContext lengthContext(targetElement);
194         auto fromLength = SVGLengthValue(m_lengthMode, from);
195         auto toLength = SVGLengthValue(m_lengthMode, to);
196         return fabsf(toLength.value(lengthContext) - fromLength.value(lengthContext));
197     }
198 
199 private:
200     void addFromAndToValues(SVGElement* targetElement) override
201     {
202         SVGLengthContext lengthContext(targetElement);
<span class="line-modified">203         m_to.setValue(m_to.value(lengthContext) + m_from.value(lengthContext), lengthContext);</span>
204     }
205 
206     SVGLengthMode m_lengthMode;
207 };
208 
209 class SVGAnimationNumberFunction : public SVGAnimationAdditiveValueFunction&lt;float&gt; {
210     friend class SVGAnimatedNumberPairAnimator;
211 
212 public:
213     using Base = SVGAnimationAdditiveValueFunction&lt;float&gt;;
214     using Base::Base;
215 
216     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
217     {
218         m_from = SVGPropertyTraits&lt;float&gt;::fromString(from);
219         m_to = SVGPropertyTraits&lt;float&gt;::fromString(to);
220     }
221 
222     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
223     {
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Color.h&quot;
 29 #include &quot;FloatRect.h&quot;
 30 #include &quot;SVGAngleValue.h&quot;
 31 #include &quot;SVGAnimationAdditiveValueFunction.h&quot;
<span class="line-added"> 32 #include &quot;SVGLengthContext.h&quot;</span>
 33 #include &quot;SVGLengthValue.h&quot;
 34 #include &quot;SVGPathByteStream.h&quot;
 35 #include &quot;SVGPropertyTraits.h&quot;
 36 
<span class="line-added"> 37 #if PLATFORM(JAVA)</span>
<span class="line-added"> 38 #include &lt;wtf/java/JavaMath.h&gt;</span>
<span class="line-added"> 39 #endif</span>
<span class="line-added"> 40 </span>
 41 namespace WebCore {
 42 
 43 class SVGAnimationAngleFunction : public SVGAnimationAdditiveValueFunction&lt;SVGAngleValue&gt; {
 44 public:
 45     using Base = SVGAnimationAdditiveValueFunction&lt;SVGAngleValue&gt;;
 46     using Base::Base;
 47 
 48     void setFromAndToValues(SVGElement*, const String&amp;, const String&amp;) override
 49     {
 50         // Values will be set by SVGAnimatedAngleOrientAnimator.
 51         ASSERT_NOT_REACHED();
 52     }
 53 
 54     void animate(SVGElement*, float progress, unsigned repeatCount, SVGAngleValue&amp; animated)
 55     {
 56         float number = animated.value();
 57         number = Base::animate(progress, repeatCount, m_from.value(), m_to.value(), toAtEndOfDuration().value(), number);
 58         animated.setValue(number);
 59     }
 60 
</pre>
<hr />
<pre>
 89 
 90         float red = Base::animate(progress, repeatCount, from.red(), m_to.red(), toAtEndOfDuration().red(), animated.red());
 91         float green = Base::animate(progress, repeatCount, from.green(), m_to.green(), toAtEndOfDuration().green(), animated.green());
 92         float blue = Base::animate(progress, repeatCount, from.blue(), m_to.blue(), toAtEndOfDuration().blue(), animated.blue());
 93         float alpha = Base::animate(progress, repeatCount, from.alpha(), m_to.alpha(), toAtEndOfDuration().alpha(), animated.alpha());
 94 
 95         animated = { roundAndClampColorChannel(red), roundAndClampColorChannel(green), roundAndClampColorChannel(blue), roundAndClampColorChannel(alpha) };
 96     }
 97 
 98     Optional&lt;float&gt; calculateDistance(SVGElement*, const String&amp; from, const String&amp; to) const override
 99     {
100         Color fromColor = CSSParser::parseColor(from.stripWhiteSpace());
101         if (!fromColor.isValid())
102             return { };
103         Color toColor = CSSParser::parseColor(to.stripWhiteSpace());
104         if (!toColor.isValid())
105             return { };
106         float red = fromColor.red() - toColor.red();
107         float green = fromColor.green() - toColor.green();
108         float blue = fromColor.blue() - toColor.blue();
<span class="line-modified">109 #if PLATFORM(JAVA)</span>
<span class="line-added">110         return javamath::hypot(red, green, blue);</span>
<span class="line-added">111 #else</span>
<span class="line-added">112         return std::hypot(red, green, blue);</span>
<span class="line-added">113 #endif</span>
114     }
115 
116 private:
117     void addFromAndToValues(SVGElement*) override
118     {
119         // Ignores any alpha and sets alpha on result to 100% opaque.
120         m_to = {
121             roundAndClampColorChannel(m_to.red() + m_from.red()),
122             roundAndClampColorChannel(m_to.green() + m_from.green()),
123             roundAndClampColorChannel(m_to.blue() + m_from.blue())
124         };
125     }
126 
127     static Color colorFromString(SVGElement*, const String&amp;);
128 };
129 
130 class SVGAnimationIntegerFunction : public SVGAnimationAdditiveValueFunction&lt;int&gt; {
131     friend class SVGAnimatedIntegerPairAnimator;
132 
133 public:
</pre>
<hr />
<pre>
169     SVGAnimationLengthFunction(AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive, SVGLengthMode lengthMode)
170         : Base(animationMode, calcMode, isAccumulated, isAdditive)
171         , m_lengthMode(lengthMode)
172     {
173     }
174 
175     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
176     {
177         m_from = SVGLengthValue(m_lengthMode, from);
178         m_to = SVGLengthValue(m_lengthMode, to);
179     }
180 
181     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
182     {
183         m_toAtEndOfDuration = SVGLengthValue(m_lengthMode, toAtEndOfDuration);
184     }
185 
186     void animate(SVGElement* targetElement, float progress, unsigned repeatCount, SVGLengthValue&amp; animated)
187     {
188         SVGLengthContext lengthContext(targetElement);
<span class="line-modified">189         SVGLengthType lengthType = progress &lt; 0.5 ? m_from.lengthType() : m_to.lengthType();</span>
190 
191         float from = (m_animationMode == AnimationMode::To ? animated : m_from).value(lengthContext);
192         float to = m_to.value(lengthContext);
193         float toAtEndOfDuration = this-&gt;toAtEndOfDuration().value(lengthContext);
194         float value = animated.value(lengthContext);
195 
196         value = Base::animate(progress, repeatCount, from, to, toAtEndOfDuration, value);
<span class="line-modified">197         animated = { lengthContext, value, lengthType, m_lengthMode };</span>
198     }
199 
200     Optional&lt;float&gt; calculateDistance(SVGElement* targetElement, const String&amp; from, const String&amp; to) const override
201     {
202         SVGLengthContext lengthContext(targetElement);
203         auto fromLength = SVGLengthValue(m_lengthMode, from);
204         auto toLength = SVGLengthValue(m_lengthMode, to);
205         return fabsf(toLength.value(lengthContext) - fromLength.value(lengthContext));
206     }
207 
208 private:
209     void addFromAndToValues(SVGElement* targetElement) override
210     {
211         SVGLengthContext lengthContext(targetElement);
<span class="line-modified">212         m_to.setValue(lengthContext, m_to.value(lengthContext) + m_from.value(lengthContext));</span>
213     }
214 
215     SVGLengthMode m_lengthMode;
216 };
217 
218 class SVGAnimationNumberFunction : public SVGAnimationAdditiveValueFunction&lt;float&gt; {
219     friend class SVGAnimatedNumberPairAnimator;
220 
221 public:
222     using Base = SVGAnimationAdditiveValueFunction&lt;float&gt;;
223     using Base::Base;
224 
225     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
226     {
227         m_from = SVGPropertyTraits&lt;float&gt;::fromString(from);
228         m_to = SVGPropertyTraits&lt;float&gt;::fromString(to);
229     }
230 
231     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
232     {
</pre>
</td>
</tr>
</table>
<center><a href="SVGAnimationAdditiveListFunctionImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGDecoratedEnumeration.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
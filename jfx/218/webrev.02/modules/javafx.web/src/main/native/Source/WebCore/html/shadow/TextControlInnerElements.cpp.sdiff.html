<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SliderThumbElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextControlInnerElements.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 63     : HTMLDivElement(divTag, document)
 64 {
 65     setHasCustomStyleResolveCallbacks();
 66 }
 67 
 68 Ref&lt;TextControlInnerContainer&gt; TextControlInnerContainer::create(Document&amp; document)
 69 {
 70     return adoptRef(*new TextControlInnerContainer(document));
 71 }
 72 
 73 RenderPtr&lt;RenderElement&gt; TextControlInnerContainer::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 74 {
 75     return createRenderer&lt;RenderTextControlInnerContainer&gt;(*this, WTFMove(style));
 76 }
 77 
 78 static inline bool isStrongPasswordTextField(const Element* element)
 79 {
 80     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element)-&gt;hasAutoFillStrongPasswordButton();
 81 }
 82 
<span class="line-modified"> 83 Optional&lt;ElementStyle&gt; TextControlInnerContainer::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
 84 {
 85     auto elementStyle = resolveStyle(&amp;parentStyle);
 86     if (isStrongPasswordTextField(shadowHost())) {
 87         elementStyle.renderStyle-&gt;setFlexWrap(FlexWrap::Wrap);
 88         elementStyle.renderStyle-&gt;setOverflowX(Overflow::Hidden);
 89         elementStyle.renderStyle-&gt;setOverflowY(Overflow::Hidden);
 90     }
 91     return elementStyle;
 92 }
 93 
 94 TextControlInnerElement::TextControlInnerElement(Document&amp; document)
 95     : HTMLDivElement(divTag, document)
 96 {
 97     setHasCustomStyleResolveCallbacks();
 98 }
 99 
100 Ref&lt;TextControlInnerElement&gt; TextControlInnerElement::create(Document&amp; document)
101 {
102     return adoptRef(*new TextControlInnerElement(document));
103 }
104 
<span class="line-modified">105 Optional&lt;ElementStyle&gt; TextControlInnerElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
106 {
107     auto newStyle = RenderStyle::createPtr();
108     newStyle-&gt;inheritFrom(*shadowHostStyle);
109     newStyle-&gt;setFlexGrow(1);
110     newStyle-&gt;setMinWidth(Length { 0, Fixed }); // Needed for correct shrinking.
111     newStyle-&gt;setDisplay(DisplayType::Block);
112     newStyle-&gt;setDirection(TextDirection::LTR);
113     // We don&#39;t want the shadow DOM to be editable, so we set this block to read-only in case the input itself is editable.
114     newStyle-&gt;setUserModify(UserModify::ReadOnly);
115 
116     if (isStrongPasswordTextField(shadowHost())) {
117         newStyle-&gt;setFlexShrink(0);
118         newStyle-&gt;setTextOverflow(TextOverflow::Clip);
119         newStyle-&gt;setOverflowX(Overflow::Hidden);
120         newStyle-&gt;setOverflowY(Overflow::Hidden);
121 
122         // Set &quot;flex-basis: 1em&quot;. Note that CSSPrimitiveValue::computeLengthInt() only needs the element&#39;s
123         // style to calculate em lengths. Since the element might not be in a document, just pass nullptr
124         // for the root element style and the render view.
<span class="line-modified">125         auto emSize = CSSPrimitiveValue::create(1, CSSPrimitiveValue::CSS_EMS);</span>
126         int pixels = emSize-&gt;computeLength&lt;int&gt;(CSSToLengthConversionData { newStyle.get(), nullptr, nullptr, 1.0, false });
127         newStyle-&gt;setFlexBasis(Length { pixels, Fixed });
128     }
129 
<span class="line-modified">130     return ElementStyle { WTFMove(newStyle) };</span>
131 }
132 
133 // MARK: TextControlInnerTextElement
134 
135 inline TextControlInnerTextElement::TextControlInnerTextElement(Document&amp; document)
136     : HTMLDivElement(divTag, document)
137 {
138     setHasCustomStyleResolveCallbacks();
139 }
140 
141 Ref&lt;TextControlInnerTextElement&gt; TextControlInnerTextElement::create(Document&amp; document)
142 {
143     return adoptRef(*new TextControlInnerTextElement(document));
144 }
145 
146 void TextControlInnerTextElement::defaultEventHandler(Event&amp; event)
147 {
148     // FIXME: In the future, we should add a way to have default event listeners.
149     // Then we would add one to the text field&#39;s inner div, and we wouldn&#39;t need this subclass.
150     // Or possibly we could just use a normal event listener.
</pre>
<hr />
<pre>
154         // cause events to be sent to the TextControlInnerTextElement. To
155         // prevent an infinite loop, we must check for this case before sending
156         // the event up the chain.
157         if (auto host = makeRefPtr(shadowHost()))
158             host-&gt;defaultEventHandler(event);
159     }
160     if (!event.defaultHandled())
161         HTMLDivElement::defaultEventHandler(event);
162 }
163 
164 RenderPtr&lt;RenderElement&gt; TextControlInnerTextElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
165 {
166     return createRenderer&lt;RenderTextControlInnerBlock&gt;(*this, WTFMove(style));
167 }
168 
169 RenderTextControlInnerBlock* TextControlInnerTextElement::renderer() const
170 {
171     return downcast&lt;RenderTextControlInnerBlock&gt;(HTMLDivElement::renderer());
172 }
173 
<span class="line-modified">174 Optional&lt;ElementStyle&gt; TextControlInnerTextElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
175 {
176     auto style = downcast&lt;HTMLTextFormControlElement&gt;(*shadowHost()).createInnerTextStyle(*shadowHostStyle);
<span class="line-modified">177     return ElementStyle(makeUnique&lt;RenderStyle&gt;(WTFMove(style)));</span>
178 }
179 
180 // MARK: TextControlPlaceholderElement
181 
182 inline TextControlPlaceholderElement::TextControlPlaceholderElement(Document&amp; document)
183     : HTMLDivElement(divTag, document)
184 {
185     setPseudo(AtomString(&quot;placeholder&quot;, AtomString::ConstructFromLiteral));
186     setHasCustomStyleResolveCallbacks();
187 }
188 
189 Ref&lt;TextControlPlaceholderElement&gt; TextControlPlaceholderElement::create(Document&amp; document)
190 {
191     return adoptRef(*new TextControlPlaceholderElement(document));
192 }
193 
<span class="line-modified">194 Optional&lt;ElementStyle&gt; TextControlPlaceholderElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle)</span>
195 {
196     auto style = resolveStyle(&amp;parentStyle);
197 
198     auto&amp; controlElement = downcast&lt;HTMLTextFormControlElement&gt;(*containingShadowRoot()-&gt;host());
199     style.renderStyle-&gt;setDisplay(controlElement.isPlaceholderVisible() ? DisplayType::Block : DisplayType::None);
200 
201     if (is&lt;HTMLInputElement&gt;(controlElement)) {
202         auto&amp; inputElement = downcast&lt;HTMLInputElement&gt;(controlElement);
203         style.renderStyle-&gt;setTextOverflow(inputElement.shouldTruncateText(*shadowHostStyle) ? TextOverflow::Ellipsis : TextOverflow::Clip);
204     }
205     return style;
206 }
207 
208 // MARK: SearchFieldResultsButtonElement
209 
210 inline SearchFieldResultsButtonElement::SearchFieldResultsButtonElement(Document&amp; document)
211     : HTMLDivElement(divTag, document)
212 {
213 }
214 
</pre>
</td>
<td>
<hr />
<pre>
 63     : HTMLDivElement(divTag, document)
 64 {
 65     setHasCustomStyleResolveCallbacks();
 66 }
 67 
 68 Ref&lt;TextControlInnerContainer&gt; TextControlInnerContainer::create(Document&amp; document)
 69 {
 70     return adoptRef(*new TextControlInnerContainer(document));
 71 }
 72 
 73 RenderPtr&lt;RenderElement&gt; TextControlInnerContainer::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 74 {
 75     return createRenderer&lt;RenderTextControlInnerContainer&gt;(*this, WTFMove(style));
 76 }
 77 
 78 static inline bool isStrongPasswordTextField(const Element* element)
 79 {
 80     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element)-&gt;hasAutoFillStrongPasswordButton();
 81 }
 82 
<span class="line-modified"> 83 Optional&lt;Style::ElementStyle&gt; TextControlInnerContainer::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
 84 {
 85     auto elementStyle = resolveStyle(&amp;parentStyle);
 86     if (isStrongPasswordTextField(shadowHost())) {
 87         elementStyle.renderStyle-&gt;setFlexWrap(FlexWrap::Wrap);
 88         elementStyle.renderStyle-&gt;setOverflowX(Overflow::Hidden);
 89         elementStyle.renderStyle-&gt;setOverflowY(Overflow::Hidden);
 90     }
 91     return elementStyle;
 92 }
 93 
 94 TextControlInnerElement::TextControlInnerElement(Document&amp; document)
 95     : HTMLDivElement(divTag, document)
 96 {
 97     setHasCustomStyleResolveCallbacks();
 98 }
 99 
100 Ref&lt;TextControlInnerElement&gt; TextControlInnerElement::create(Document&amp; document)
101 {
102     return adoptRef(*new TextControlInnerElement(document));
103 }
104 
<span class="line-modified">105 Optional&lt;Style::ElementStyle&gt; TextControlInnerElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
106 {
107     auto newStyle = RenderStyle::createPtr();
108     newStyle-&gt;inheritFrom(*shadowHostStyle);
109     newStyle-&gt;setFlexGrow(1);
110     newStyle-&gt;setMinWidth(Length { 0, Fixed }); // Needed for correct shrinking.
111     newStyle-&gt;setDisplay(DisplayType::Block);
112     newStyle-&gt;setDirection(TextDirection::LTR);
113     // We don&#39;t want the shadow DOM to be editable, so we set this block to read-only in case the input itself is editable.
114     newStyle-&gt;setUserModify(UserModify::ReadOnly);
115 
116     if (isStrongPasswordTextField(shadowHost())) {
117         newStyle-&gt;setFlexShrink(0);
118         newStyle-&gt;setTextOverflow(TextOverflow::Clip);
119         newStyle-&gt;setOverflowX(Overflow::Hidden);
120         newStyle-&gt;setOverflowY(Overflow::Hidden);
121 
122         // Set &quot;flex-basis: 1em&quot;. Note that CSSPrimitiveValue::computeLengthInt() only needs the element&#39;s
123         // style to calculate em lengths. Since the element might not be in a document, just pass nullptr
124         // for the root element style and the render view.
<span class="line-modified">125         auto emSize = CSSPrimitiveValue::create(1, CSSUnitType::CSS_EMS);</span>
126         int pixels = emSize-&gt;computeLength&lt;int&gt;(CSSToLengthConversionData { newStyle.get(), nullptr, nullptr, 1.0, false });
127         newStyle-&gt;setFlexBasis(Length { pixels, Fixed });
128     }
129 
<span class="line-modified">130     return { WTFMove(newStyle) };</span>
131 }
132 
133 // MARK: TextControlInnerTextElement
134 
135 inline TextControlInnerTextElement::TextControlInnerTextElement(Document&amp; document)
136     : HTMLDivElement(divTag, document)
137 {
138     setHasCustomStyleResolveCallbacks();
139 }
140 
141 Ref&lt;TextControlInnerTextElement&gt; TextControlInnerTextElement::create(Document&amp; document)
142 {
143     return adoptRef(*new TextControlInnerTextElement(document));
144 }
145 
146 void TextControlInnerTextElement::defaultEventHandler(Event&amp; event)
147 {
148     // FIXME: In the future, we should add a way to have default event listeners.
149     // Then we would add one to the text field&#39;s inner div, and we wouldn&#39;t need this subclass.
150     // Or possibly we could just use a normal event listener.
</pre>
<hr />
<pre>
154         // cause events to be sent to the TextControlInnerTextElement. To
155         // prevent an infinite loop, we must check for this case before sending
156         // the event up the chain.
157         if (auto host = makeRefPtr(shadowHost()))
158             host-&gt;defaultEventHandler(event);
159     }
160     if (!event.defaultHandled())
161         HTMLDivElement::defaultEventHandler(event);
162 }
163 
164 RenderPtr&lt;RenderElement&gt; TextControlInnerTextElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
165 {
166     return createRenderer&lt;RenderTextControlInnerBlock&gt;(*this, WTFMove(style));
167 }
168 
169 RenderTextControlInnerBlock* TextControlInnerTextElement::renderer() const
170 {
171     return downcast&lt;RenderTextControlInnerBlock&gt;(HTMLDivElement::renderer());
172 }
173 
<span class="line-modified">174 Optional&lt;Style::ElementStyle&gt; TextControlInnerTextElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
175 {
176     auto style = downcast&lt;HTMLTextFormControlElement&gt;(*shadowHost()).createInnerTextStyle(*shadowHostStyle);
<span class="line-modified">177     return { makeUnique&lt;RenderStyle&gt;(WTFMove(style)) };</span>
178 }
179 
180 // MARK: TextControlPlaceholderElement
181 
182 inline TextControlPlaceholderElement::TextControlPlaceholderElement(Document&amp; document)
183     : HTMLDivElement(divTag, document)
184 {
185     setPseudo(AtomString(&quot;placeholder&quot;, AtomString::ConstructFromLiteral));
186     setHasCustomStyleResolveCallbacks();
187 }
188 
189 Ref&lt;TextControlPlaceholderElement&gt; TextControlPlaceholderElement::create(Document&amp; document)
190 {
191     return adoptRef(*new TextControlPlaceholderElement(document));
192 }
193 
<span class="line-modified">194 Optional&lt;Style::ElementStyle&gt; TextControlPlaceholderElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle)</span>
195 {
196     auto style = resolveStyle(&amp;parentStyle);
197 
198     auto&amp; controlElement = downcast&lt;HTMLTextFormControlElement&gt;(*containingShadowRoot()-&gt;host());
199     style.renderStyle-&gt;setDisplay(controlElement.isPlaceholderVisible() ? DisplayType::Block : DisplayType::None);
200 
201     if (is&lt;HTMLInputElement&gt;(controlElement)) {
202         auto&amp; inputElement = downcast&lt;HTMLInputElement&gt;(controlElement);
203         style.renderStyle-&gt;setTextOverflow(inputElement.shouldTruncateText(*shadowHostStyle) ? TextOverflow::Ellipsis : TextOverflow::Clip);
204     }
205     return style;
206 }
207 
208 // MARK: SearchFieldResultsButtonElement
209 
210 inline SearchFieldResultsButtonElement::SearchFieldResultsButtonElement(Document&amp; document)
211     : HTMLDivElement(divTag, document)
212 {
213 }
214 
</pre>
</td>
</tr>
</table>
<center><a href="SliderThumbElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextControlInnerElements.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
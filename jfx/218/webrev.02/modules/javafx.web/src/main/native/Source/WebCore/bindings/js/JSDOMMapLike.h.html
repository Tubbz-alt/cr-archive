<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMMapLike.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSDOMBinding.h&quot;
 29 #include &quot;JSDOMConvert.h&quot;
 30 #include &lt;JavaScriptCore/BuiltinNames.h&gt;
 31 #include &lt;JavaScriptCore/CommonIdentifiers.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 WEBCORE_EXPORT std::pair&lt;bool, std::reference_wrapper&lt;JSC::JSObject&gt;&gt; getBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp; mapLike);
 36 WEBCORE_EXPORT JSC::JSValue forwardAttributeGetterToBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;, const JSC::Identifier&amp;);
 37 WEBCORE_EXPORT JSC::JSValue forwardFunctionCallToBackingMap(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, JSC::JSObject&amp;, const JSC::Identifier&amp;);
 38 WEBCORE_EXPORT JSC::JSValue forwardForEachCallToBackingMap(JSDOMGlobalObject&amp;, JSC::CallFrame&amp;, JSC::JSObject&amp;);
 39 WEBCORE_EXPORT void clearBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);
 40 WEBCORE_EXPORT void setToBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;, JSC::JSValue, JSC::JSValue);
 41 
 42 template&lt;typename WrapperClass&gt; JSC::JSValue forwardSizeToMapLike(JSC::JSGlobalObject&amp;, WrapperClass&amp;);
 43 template&lt;typename WrapperClass&gt; JSC::JSValue forwardEntriesToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);
 44 template&lt;typename WrapperClass&gt; JSC::JSValue forwardKeysToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);
 45 template&lt;typename WrapperClass&gt; JSC::JSValue forwardValuesToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);
 46 template&lt;typename WrapperClass&gt; JSC::JSValue forwardClearToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);
 47 template&lt;typename WrapperClass, typename Callback&gt; JSC::JSValue forwardForEachToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, Callback&amp;&amp;);
 48 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardGetToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;);
 49 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardHasToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;);
 50 template&lt;typename WrapperClass, typename ItemType, typename ValueType&gt; JSC::JSValue forwardSetToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;, ValueType&amp;&amp;);
 51 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardDeleteToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;);
 52 
 53 class DOMMapAdapter {
 54 public:
 55     DOMMapAdapter(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);
 56     template&lt;typename IDLKeyType, typename IDLValueType&gt; void set(typename IDLKeyType::ParameterType, typename IDLValueType::ParameterType);
 57     void clear();
 58 
 59 private:
 60     JSC::JSGlobalObject&amp; m_lexicalGlobalObject;
 61     JSC::JSObject&amp; m_backingMap;
 62 };
 63 
 64 inline DOMMapAdapter::DOMMapAdapter(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; backingMap)
 65     : m_lexicalGlobalObject(lexicalGlobalObject)
 66     , m_backingMap(backingMap)
 67 {
 68 }
 69 
 70 template&lt;typename IDLKeyType, typename IDLValueType&gt;
 71 void DOMMapAdapter::set(typename IDLKeyType::ParameterType key, typename IDLValueType::ParameterType value)
 72 {
 73     JSC::JSLockHolder locker(&amp;m_lexicalGlobalObject);
 74     auto jsKey = toJS&lt;IDLKeyType&gt;(m_lexicalGlobalObject, *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;m_lexicalGlobalObject), std::forward&lt;typename IDLKeyType::ParameterType&gt;(key));
 75     auto jsValue = toJS&lt;IDLValueType&gt;(m_lexicalGlobalObject, *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;m_lexicalGlobalObject), std::forward&lt;typename IDLValueType::ParameterType&gt;(value));
 76     setToBackingMap(m_lexicalGlobalObject, m_backingMap, jsKey, jsValue);
 77 }
 78 
 79 template&lt;typename WrapperClass&gt; JSC::JSObject&amp; getAndInitializeBackingMap(JSC::JSGlobalObject&amp; lexicalGlobalObject, WrapperClass&amp; mapLike)
 80 {
 81     auto pair = getBackingMap(lexicalGlobalObject, mapLike);
 82     if (pair.first) {
 83         DOMMapAdapter adapter { lexicalGlobalObject, pair.second.get() };
 84         mapLike.wrapped().initializeMapLike(adapter);
 85     }
 86     return pair.second.get();
 87 }
 88 
 89 template&lt;typename WrapperClass&gt; JSC::JSValue forwardSizeToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, WrapperClass&amp; mapLike)
 90 {
 91     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
 92     return forwardAttributeGetterToBackingMap(lexicalGlobalObject, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;size);
 93 }
 94 
 95 template&lt;typename WrapperClass&gt; JSC::JSValue forwardEntriesToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)
 96 {
 97     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
 98     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().entriesPublicName());
 99 }
100 
101 template&lt;typename WrapperClass&gt; JSC::JSValue forwardKeysToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)
102 {
103     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
104     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().keysPublicName());
105 }
106 
107 template&lt;typename WrapperClass&gt; JSC::JSValue forwardValuesToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)
108 {
109     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
110     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().valuesPublicName());
111 }
112 
113 template&lt;typename WrapperClass&gt; JSC::JSValue forwardClearToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)
114 {
115     mapLike.wrapped().clear();
116     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
117     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;clear);
118 }
119 
120 template&lt;typename WrapperClass, typename Callback&gt; JSC::JSValue forwardForEachToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, Callback&amp;&amp;)
121 {
122     getAndInitializeBackingMap(lexicalGlobalObject, mapLike);
123     return forwardForEachCallToBackingMap(*JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), callFrame, mapLike);
124 }
125 
126 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardGetToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, ItemType&amp;&amp;)
127 {
128     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
129     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().getPublicName());
130 }
131 
132 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardHasToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, ItemType&amp;&amp;)
133 {
134     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
135     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().hasPublicName());
136 }
137 
138 template&lt;typename WrapperClass, typename KeyType, typename ValueType&gt; JSC::JSValue forwardSetToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, KeyType&amp;&amp; key, ValueType&amp;&amp; value)
139 {
140     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
141     mapLike.wrapped().setFromMapLike(std::forward&lt;KeyType&gt;(key), std::forward&lt;ValueType&gt;(value));
142     forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;set);
143     return &amp;mapLike;
144 }
145 
146 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardDeleteToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, ItemType&amp;&amp; item)
147 {
148     auto isDeleted = mapLike.wrapped().remove(std::forward&lt;ItemType&gt;(item));
149     UNUSED_PARAM(isDeleted);
150 
151     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
152     auto result = forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;deleteKeyword);
153 
154     ASSERT_UNUSED(result, result.asBoolean() == isDeleted);
155     return result;
156 }
157 
158 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocketHandshake.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc.  All rights reserved.
  3  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  4  * Copyright (C) 2018 Apple Inc. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions are
  8  * met:
  9  *
 10  *     * Redistributions of source code must retain the above copyright
 11  * notice, this list of conditions and the following disclaimer.
 12  *     * Redistributions in binary form must reproduce the above
 13  * copyright notice, this list of conditions and the following disclaimer
 14  * in the documentation and/or other materials provided with the
 15  * distribution.
 16  *     * Neither the name of Google Inc. nor the names of its
 17  * contributors may be used to endorse or promote products derived from
 18  * this software without specific prior written permission.
 19  *
 20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;WebSocketHandshake.h&quot;
 35 
 36 #include &quot;Cookie.h&quot;
 37 #include &quot;CookieJar.h&quot;
 38 #include &quot;HTTPHeaderMap.h&quot;
 39 #include &quot;HTTPHeaderNames.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 40 #include &quot;HTTPHeaderValues.h&quot;</span>
 41 #include &quot;HTTPParsers.h&quot;
 42 #include &quot;InspectorInstrumentation.h&quot;
 43 #include &quot;Logging.h&quot;
 44 #include &quot;ResourceRequest.h&quot;
 45 #include &quot;ScriptExecutionContext.h&quot;
 46 #include &quot;SecurityOrigin.h&quot;
 47 #include &lt;wtf/URL.h&gt;
 48 #include &quot;WebSocket.h&quot;
 49 #include &lt;wtf/ASCIICType.h&gt;
 50 #include &lt;wtf/CryptographicallyRandomNumber.h&gt;
 51 #include &lt;wtf/MD5.h&gt;
 52 #include &lt;wtf/SHA1.h&gt;
 53 #include &lt;wtf/StdLibExtras.h&gt;
 54 #include &lt;wtf/StringExtras.h&gt;
 55 #include &lt;wtf/Vector.h&gt;
 56 #include &lt;wtf/text/Base64.h&gt;
 57 #include &lt;wtf/text/CString.h&gt;
 58 #include &lt;wtf/text/StringBuilder.h&gt;
 59 #include &lt;wtf/text/StringView.h&gt;
 60 #include &lt;wtf/text/WTFString.h&gt;
 61 #include &lt;wtf/unicode/CharacterNames.h&gt;
 62 
 63 namespace WebCore {
 64 
 65 static String resourceName(const URL&amp; url)
 66 {
 67     StringBuilder name;
 68     name.append(url.path());
 69     if (name.isEmpty())
 70         name.append(&#39;/&#39;);
 71     if (!url.query().isNull()) {
 72         name.append(&#39;?&#39;);
 73         name.append(url.query());
 74     }
 75     String result = name.toString();
 76     ASSERT(!result.isEmpty());
 77     ASSERT(!result.contains(&#39; &#39;));
 78     return result;
 79 }
 80 
 81 static String hostName(const URL&amp; url, bool secure)
 82 {
 83     ASSERT(url.protocolIs(&quot;wss&quot;) == secure);
 84     StringBuilder builder;
 85     builder.append(url.host().convertToASCIILowercase());
 86     if (url.port() &amp;&amp; ((!secure &amp;&amp; url.port().value() != 80) || (secure &amp;&amp; url.port().value() != 443))) {
 87         builder.append(&#39;:&#39;);
 88         builder.appendNumber(url.port().value());
 89     }
 90     return builder.toString();
 91 }
 92 
 93 static const size_t maxInputSampleSize = 128;
 94 static String trimInputSample(const char* p, size_t len)
 95 {
 96     String s = String(p, std::min&lt;size_t&gt;(len, maxInputSampleSize));
 97     if (len &gt; maxInputSampleSize)
 98         s.append(horizontalEllipsis);
 99     return s;
100 }
101 
102 static String generateSecWebSocketKey()
103 {
104     static const size_t nonceSize = 16;
105     unsigned char key[nonceSize];
106     cryptographicallyRandomValues(key, nonceSize);
107     return base64Encode(key, nonceSize);
108 }
109 
110 String WebSocketHandshake::getExpectedWebSocketAccept(const String&amp; secWebSocketKey)
111 {
112     static const char* const webSocketKeyGUID = &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;;
113     SHA1 sha1;
114     CString keyData = secWebSocketKey.ascii();
115     sha1.addBytes(reinterpret_cast&lt;const uint8_t*&gt;(keyData.data()), keyData.length());
116     sha1.addBytes(reinterpret_cast&lt;const uint8_t*&gt;(webSocketKeyGUID), strlen(webSocketKeyGUID));
117     SHA1::Digest hash;
118     sha1.computeHash(hash);
119     return base64Encode(hash.data(), SHA1::hashSize);
120 }
121 
122 WebSocketHandshake::WebSocketHandshake(const URL&amp; url, const String&amp; protocol, const String&amp; userAgent, const String&amp; clientOrigin, bool allowCookies)
123     : m_url(url)
124     , m_clientProtocol(protocol)
125     , m_secure(m_url.protocolIs(&quot;wss&quot;))
126     , m_mode(Incomplete)
127     , m_userAgent(userAgent)
128     , m_clientOrigin(clientOrigin)
129     , m_allowCookies(allowCookies)
130 {
131     m_secWebSocketKey = generateSecWebSocketKey();
132     m_expectedAccept = getExpectedWebSocketAccept(m_secWebSocketKey);
133 }
134 
135 WebSocketHandshake::~WebSocketHandshake() = default;
136 
137 const URL&amp; WebSocketHandshake::url() const
138 {
139     return m_url;
140 }
141 
142 void WebSocketHandshake::setURL(const URL&amp; url)
143 {
144     m_url = url.isolatedCopy();
145 }
146 
147 // FIXME: Return type should just be String, not const String.
148 const String WebSocketHandshake::host() const
149 {
150     return m_url.host().convertToASCIILowercase();
151 }
152 
153 const String&amp; WebSocketHandshake::clientProtocol() const
154 {
155     return m_clientProtocol;
156 }
157 
158 void WebSocketHandshake::setClientProtocol(const String&amp; protocol)
159 {
160     m_clientProtocol = protocol;
161 }
162 
163 bool WebSocketHandshake::secure() const
164 {
165     return m_secure;
166 }
167 
168 String WebSocketHandshake::clientLocation() const
169 {
170     return makeString(m_secure ? &quot;wss&quot; : &quot;ws&quot;, &quot;://&quot;, hostName(m_url, m_secure), resourceName(m_url));
171 }
172 
173 CString WebSocketHandshake::clientHandshakeMessage() const
174 {
175     // Keep the following consistent with clientHandshakeRequest().
176     StringBuilder builder;
177 
178     builder.appendLiteral(&quot;GET &quot;);
179     builder.append(resourceName(m_url));
180     builder.appendLiteral(&quot; HTTP/1.1\r\n&quot;);
181 
182     Vector&lt;String&gt; fields;
183     fields.append(&quot;Upgrade: websocket&quot;);
184     fields.append(&quot;Connection: Upgrade&quot;);
185     fields.append(&quot;Host: &quot; + hostName(m_url, m_secure));
186     fields.append(&quot;Origin: &quot; + m_clientOrigin);
187     if (!m_clientProtocol.isEmpty())
188         fields.append(&quot;Sec-WebSocket-Protocol: &quot; + m_clientProtocol);
189 
190     // Note: Cookies are not retrieved in the WebContent process. Instead, a proxy object is
191     // added in the handshake, and is exchanged for actual cookies in the Network process.
192 
193     // Add no-cache headers to avoid compatibility issue.
194     // There are some proxies that rewrite &quot;Connection: upgrade&quot;
195     // to &quot;Connection: close&quot; in the response if a request doesn&#39;t contain
196     // these headers.
197     fields.append(&quot;Pragma: no-cache&quot;);
198     fields.append(&quot;Cache-Control: no-cache&quot;);
199 
200     fields.append(&quot;Sec-WebSocket-Key: &quot; + m_secWebSocketKey);
201     fields.append(&quot;Sec-WebSocket-Version: 13&quot;);
202     const String extensionValue = m_extensionDispatcher.createHeaderValue();
203     if (extensionValue.length())
204         fields.append(&quot;Sec-WebSocket-Extensions: &quot; + extensionValue);
205 
206     // Add a User-Agent header.
207     fields.append(makeString(&quot;User-Agent: &quot;, m_userAgent));
208 
209     // Fields in the handshake are sent by the client in a random order; the
210     // order is not meaningful.  Thus, it&#39;s ok to send the order we constructed
211     // the fields.
212 
213     for (auto&amp; field : fields) {
214         builder.append(field);
215         builder.appendLiteral(&quot;\r\n&quot;);
216     }
217 
218     builder.appendLiteral(&quot;\r\n&quot;);
219 
220     return builder.toString().utf8();
221 }
222 
223 ResourceRequest WebSocketHandshake::clientHandshakeRequest(Function&lt;String(const URL&amp;)&gt;&amp;&amp; cookieRequestHeaderFieldValue) const
224 {
225     // Keep the following consistent with clientHandshakeMessage().
226     ResourceRequest request(m_url);
227     request.setHTTPMethod(&quot;GET&quot;);
228 
229     request.setHTTPHeaderField(HTTPHeaderName::Connection, &quot;Upgrade&quot;);
230     request.setHTTPHeaderField(HTTPHeaderName::Host, hostName(m_url, m_secure));
231     request.setHTTPHeaderField(HTTPHeaderName::Origin, m_clientOrigin);
232     if (!m_clientProtocol.isEmpty())
233         request.setHTTPHeaderField(HTTPHeaderName::SecWebSocketProtocol, m_clientProtocol);
234 
235     URL url = httpURLForAuthenticationAndCookies();
236     if (m_allowCookies) {
237         String cookie = cookieRequestHeaderFieldValue(url);
238         if (!cookie.isEmpty())
239             request.setHTTPHeaderField(HTTPHeaderName::Cookie, cookie);
240     }
241 
<a name="2" id="anc2"></a><span class="line-modified">242     request.setHTTPHeaderField(HTTPHeaderName::Pragma, HTTPHeaderValues::noCache());</span>
<span class="line-modified">243     request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::noCache());</span>
244 
245     request.setHTTPHeaderField(HTTPHeaderName::SecWebSocketKey, m_secWebSocketKey);
246     request.setHTTPHeaderField(HTTPHeaderName::SecWebSocketVersion, &quot;13&quot;);
247     const String extensionValue = m_extensionDispatcher.createHeaderValue();
248     if (extensionValue.length())
249         request.setHTTPHeaderField(HTTPHeaderName::SecWebSocketExtensions, extensionValue);
250 
251     // Add a User-Agent header.
252     request.setHTTPUserAgent(m_userAgent);
253 
254     return request;
255 }
256 
257 void WebSocketHandshake::reset()
258 {
259     m_mode = Incomplete;
260     m_extensionDispatcher.reset();
261 }
262 
263 int WebSocketHandshake::readServerHandshake(const char* header, size_t len)
264 {
265     m_mode = Incomplete;
266     int statusCode;
267     String statusText;
268     int lineLength = readStatusLine(header, len, statusCode, statusText);
269     if (lineLength == -1)
270         return -1;
271     if (statusCode == -1) {
272         m_mode = Failed; // m_failureReason is set inside readStatusLine().
273         return len;
274     }
275     LOG(Network, &quot;WebSocketHandshake %p readServerHandshake() Status code is %d&quot;, this, statusCode);
276 
277     m_serverHandshakeResponse = ResourceResponse();
278     m_serverHandshakeResponse.setHTTPStatusCode(statusCode);
279     m_serverHandshakeResponse.setHTTPStatusText(statusText);
280 
281     if (statusCode != 101) {
282         m_mode = Failed;
283         m_failureReason = makeString(&quot;Unexpected response code: &quot;, statusCode);
284         return len;
285     }
286     m_mode = Normal;
287     if (!strnstr(header, &quot;\r\n\r\n&quot;, len)) {
288         // Just hasn&#39;t been received fully yet.
289         m_mode = Incomplete;
290         return -1;
291     }
292     const char* p = readHTTPHeaders(header + lineLength, header + len);
293     if (!p) {
294         LOG(Network, &quot;WebSocketHandshake %p readServerHandshake() readHTTPHeaders() failed&quot;, this);
295         m_mode = Failed; // m_failureReason is set inside readHTTPHeaders().
296         return len;
297     }
298     if (!checkResponseHeaders()) {
299         LOG(Network, &quot;WebSocketHandshake %p readServerHandshake() checkResponseHeaders() failed&quot;, this);
300         m_mode = Failed;
301         return p - header;
302     }
303 
304     m_mode = Connected;
305     return p - header;
306 }
307 
308 WebSocketHandshake::Mode WebSocketHandshake::mode() const
309 {
310     return m_mode;
311 }
312 
313 String WebSocketHandshake::failureReason() const
314 {
315     return m_failureReason;
316 }
317 
318 String WebSocketHandshake::serverWebSocketProtocol() const
319 {
320     return m_serverHandshakeResponse.httpHeaderFields().get(HTTPHeaderName::SecWebSocketProtocol);
321 }
322 
323 String WebSocketHandshake::serverSetCookie() const
324 {
325     return m_serverHandshakeResponse.httpHeaderFields().get(HTTPHeaderName::SetCookie);
326 }
327 
328 String WebSocketHandshake::serverUpgrade() const
329 {
330     return m_serverHandshakeResponse.httpHeaderFields().get(HTTPHeaderName::Upgrade);
331 }
332 
333 String WebSocketHandshake::serverConnection() const
334 {
335     return m_serverHandshakeResponse.httpHeaderFields().get(HTTPHeaderName::Connection);
336 }
337 
338 String WebSocketHandshake::serverWebSocketAccept() const
339 {
340     return m_serverHandshakeResponse.httpHeaderFields().get(HTTPHeaderName::SecWebSocketAccept);
341 }
342 
343 String WebSocketHandshake::acceptedExtensions() const
344 {
345     return m_extensionDispatcher.acceptedExtensions();
346 }
347 
348 const ResourceResponse&amp; WebSocketHandshake::serverHandshakeResponse() const
349 {
350     return m_serverHandshakeResponse;
351 }
352 
353 void WebSocketHandshake::addExtensionProcessor(std::unique_ptr&lt;WebSocketExtensionProcessor&gt; processor)
354 {
355     m_extensionDispatcher.addProcessor(WTFMove(processor));
356 }
357 
358 URL WebSocketHandshake::httpURLForAuthenticationAndCookies() const
359 {
360     URL url = m_url.isolatedCopy();
361     bool couldSetProtocol = url.setProtocol(m_secure ? &quot;https&quot; : &quot;http&quot;);
362     ASSERT_UNUSED(couldSetProtocol, couldSetProtocol);
363     return url;
364 }
365 
366 // https://tools.ietf.org/html/rfc6455#section-4.1
367 // &quot;The HTTP version MUST be at least 1.1.&quot;
368 static inline bool headerHasValidHTTPVersion(StringView httpStatusLine)
369 {
370     const char* httpVersionStaticPreambleLiteral = &quot;HTTP/&quot;;
371     StringView httpVersionStaticPreamble(reinterpret_cast&lt;const LChar*&gt;(httpVersionStaticPreambleLiteral), strlen(httpVersionStaticPreambleLiteral));
372     if (!httpStatusLine.startsWith(httpVersionStaticPreamble))
373         return false;
374 
375     // Check that there is a version number which should be at least three characters after &quot;HTTP/&quot;
376     unsigned preambleLength = httpVersionStaticPreamble.length();
377     if (httpStatusLine.length() &lt; preambleLength + 3)
378         return false;
379 
380     auto dotPosition = httpStatusLine.find(&#39;.&#39;, preambleLength);
381     if (dotPosition == notFound)
382         return false;
383 
384     StringView majorVersionView = httpStatusLine.substring(preambleLength, dotPosition - preambleLength);
385     bool isValid;
386     int majorVersion = majorVersionView.toIntStrict(isValid);
387     if (!isValid)
388         return false;
389 
390     unsigned minorVersionLength;
391     unsigned charactersLeftAfterDotPosition = httpStatusLine.length() - dotPosition;
392     for (minorVersionLength = 1; minorVersionLength &lt; charactersLeftAfterDotPosition; minorVersionLength++) {
393         if (!isASCIIDigit(httpStatusLine[dotPosition + minorVersionLength]))
394             break;
395     }
396     int minorVersion = (httpStatusLine.substring(dotPosition + 1, minorVersionLength)).toIntStrict(isValid);
397     if (!isValid)
398         return false;
399 
400     return (majorVersion &gt;= 1 &amp;&amp; minorVersion &gt;= 1) || majorVersion &gt;= 2;
401 }
402 
403 // Returns the header length (including &quot;\r\n&quot;), or -1 if we have not received enough data yet.
404 // If the line is malformed or the status code is not a 3-digit number,
405 // statusCode and statusText will be set to -1 and a null string, respectively.
406 int WebSocketHandshake::readStatusLine(const char* header, size_t headerLength, int&amp; statusCode, String&amp; statusText)
407 {
408     // Arbitrary size limit to prevent the server from sending an unbounded
409     // amount of data with no newlines and forcing us to buffer it all.
410     static const int maximumLength = 1024;
411 
412     statusCode = -1;
413     statusText = String();
414 
415     const char* space1 = nullptr;
416     const char* space2 = nullptr;
417     const char* p;
418     size_t consumedLength;
419 
420     for (p = header, consumedLength = 0; consumedLength &lt; headerLength; p++, consumedLength++) {
421         if (*p == &#39; &#39;) {
422             if (!space1)
423                 space1 = p;
424             else if (!space2)
425                 space2 = p;
426         } else if (*p == &#39;\0&#39;) {
427             // The caller isn&#39;t prepared to deal with null bytes in status
428             // line. WebSockets specification doesn&#39;t prohibit this, but HTTP
429             // does, so we&#39;ll just treat this as an error.
430             m_failureReason = &quot;Status line contains embedded null&quot;_s;
431             return p + 1 - header;
432         } else if (!isASCII(*p)) {
433             m_failureReason = &quot;Status line contains non-ASCII character&quot;_s;
434             return p + 1 - header;
435         } else if (*p == &#39;\n&#39;)
436             break;
437     }
438     if (consumedLength == headerLength)
439         return -1; // We have not received &#39;\n&#39; yet.
440 
441     const char* end = p + 1;
442     int lineLength = end - header;
443     if (lineLength &gt; maximumLength) {
444         m_failureReason = &quot;Status line is too long&quot;_s;
445         return maximumLength;
446     }
447 
448     // The line must end with &quot;\r\n&quot;.
449     if (lineLength &lt; 2 || *(end - 2) != &#39;\r&#39;) {
450         m_failureReason = &quot;Status line does not end with CRLF&quot;_s;
451         return lineLength;
452     }
453 
454     if (!space1 || !space2) {
455         m_failureReason = makeString(&quot;No response code found: &quot;, trimInputSample(header, lineLength - 2));
456         return lineLength;
457     }
458 
459     StringView httpStatusLine(reinterpret_cast&lt;const LChar*&gt;(header), space1 - header);
460     if (!headerHasValidHTTPVersion(httpStatusLine)) {
461         m_failureReason = makeString(&quot;Invalid HTTP version string: &quot;, httpStatusLine);
462         return lineLength;
463     }
464 
465     StringView statusCodeString(reinterpret_cast&lt;const LChar*&gt;(space1 + 1), space2 - space1 - 1);
466     if (statusCodeString.length() != 3) // Status code must consist of three digits.
467         return lineLength;
468     for (int i = 0; i &lt; 3; ++i)
469         if (!isASCIIDigit(statusCodeString[i])) {
470             m_failureReason = makeString(&quot;Invalid status code: &quot;, statusCodeString);
471             return lineLength;
472         }
473 
474     bool ok = false;
475     statusCode = statusCodeString.toIntStrict(ok);
476     ASSERT(ok);
477 
478     statusText = String(space2 + 1, end - space2 - 3); // Exclude &quot;\r\n&quot;.
479     return lineLength;
480 }
481 
482 const char* WebSocketHandshake::readHTTPHeaders(const char* start, const char* end)
483 {
484     StringView name;
485     String value;
486     bool sawSecWebSocketExtensionsHeaderField = false;
487     bool sawSecWebSocketAcceptHeaderField = false;
488     bool sawSecWebSocketProtocolHeaderField = false;
489     const char* p = start;
490     for (; p &lt; end; p++) {
491         size_t consumedLength = parseHTTPHeader(p, end - p, m_failureReason, name, value);
492         if (!consumedLength)
493             return nullptr;
494         p += consumedLength;
495 
496         // Stop once we consumed an empty line.
497         if (name.isEmpty())
498             break;
499 
500         HTTPHeaderName headerName;
501         if (!findHTTPHeaderName(name, headerName)) {
502             // Evidence in the wild shows that services make use of custom headers in the handshake
503             m_serverHandshakeResponse.addHTTPHeaderField(name.toString(), value);
504             continue;
505         }
506 
507         // https://tools.ietf.org/html/rfc7230#section-3.2.4
508         // &quot;Newly defined header fields SHOULD limit their field values to US-ASCII octets.&quot;
509         if ((headerName == HTTPHeaderName::SecWebSocketExtensions
510             || headerName == HTTPHeaderName::SecWebSocketAccept
511             || headerName == HTTPHeaderName::SecWebSocketProtocol)
512             &amp;&amp; !value.isAllASCII()) {
513             m_failureReason = makeString(name, &quot; header value should only contain ASCII characters&quot;);
514             return nullptr;
515         }
516 
517         if (headerName == HTTPHeaderName::SecWebSocketExtensions) {
518             if (sawSecWebSocketExtensionsHeaderField) {
519                 m_failureReason = &quot;The Sec-WebSocket-Extensions header must not appear more than once in an HTTP response&quot;_s;
520                 return nullptr;
521             }
522             if (!m_extensionDispatcher.processHeaderValue(value)) {
523                 m_failureReason = m_extensionDispatcher.failureReason();
524                 return nullptr;
525             }
526             sawSecWebSocketExtensionsHeaderField = true;
527         } else {
528             if (headerName == HTTPHeaderName::SecWebSocketAccept) {
529                 if (sawSecWebSocketAcceptHeaderField) {
530                     m_failureReason = &quot;The Sec-WebSocket-Accept header must not appear more than once in an HTTP response&quot;_s;
531                     return nullptr;
532                 }
533                 sawSecWebSocketAcceptHeaderField = true;
534             } else if (headerName == HTTPHeaderName::SecWebSocketProtocol) {
535                 if (sawSecWebSocketProtocolHeaderField) {
536                     m_failureReason = &quot;The Sec-WebSocket-Protocol header must not appear more than once in an HTTP response&quot;_s;
537                     return nullptr;
538                 }
539                 sawSecWebSocketProtocolHeaderField = true;
540             }
541 
542             m_serverHandshakeResponse.addHTTPHeaderField(headerName, value);
543         }
544     }
545     return p;
546 }
547 
548 bool WebSocketHandshake::checkResponseHeaders()
549 {
550     const String&amp; serverWebSocketProtocol = this-&gt;serverWebSocketProtocol();
551     const String&amp; serverUpgrade = this-&gt;serverUpgrade();
552     const String&amp; serverConnection = this-&gt;serverConnection();
553     const String&amp; serverWebSocketAccept = this-&gt;serverWebSocketAccept();
554 
555     if (serverUpgrade.isNull()) {
556         m_failureReason = &quot;Error during WebSocket handshake: &#39;Upgrade&#39; header is missing&quot;_s;
557         return false;
558     }
559     if (serverConnection.isNull()) {
560         m_failureReason = &quot;Error during WebSocket handshake: &#39;Connection&#39; header is missing&quot;_s;
561         return false;
562     }
563     if (serverWebSocketAccept.isNull()) {
564         m_failureReason = &quot;Error during WebSocket handshake: &#39;Sec-WebSocket-Accept&#39; header is missing&quot;_s;
565         return false;
566     }
567 
568     if (!equalLettersIgnoringASCIICase(serverUpgrade, &quot;websocket&quot;)) {
569         m_failureReason = &quot;Error during WebSocket handshake: &#39;Upgrade&#39; header value is not &#39;WebSocket&#39;&quot;_s;
570         return false;
571     }
572     if (!equalLettersIgnoringASCIICase(serverConnection, &quot;upgrade&quot;)) {
573         m_failureReason = &quot;Error during WebSocket handshake: &#39;Connection&#39; header value is not &#39;Upgrade&#39;&quot;_s;
574         return false;
575     }
576 
577     if (serverWebSocketAccept != m_expectedAccept) {
578         m_failureReason = &quot;Error during WebSocket handshake: Sec-WebSocket-Accept mismatch&quot;_s;
579         return false;
580     }
581     if (!serverWebSocketProtocol.isNull()) {
582         if (m_clientProtocol.isEmpty()) {
583             m_failureReason = &quot;Error during WebSocket handshake: Sec-WebSocket-Protocol mismatch&quot;_s;
584             return false;
585         }
586         Vector&lt;String&gt; result = m_clientProtocol.split(WebSocket::subprotocolSeparator());
587         if (!result.contains(serverWebSocketProtocol)) {
588             m_failureReason = &quot;Error during WebSocket handshake: Sec-WebSocket-Protocol mismatch&quot;_s;
589             return false;
590         }
591     }
592     return true;
593 }
594 
595 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
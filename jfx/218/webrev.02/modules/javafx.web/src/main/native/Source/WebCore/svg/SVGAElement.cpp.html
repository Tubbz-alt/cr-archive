<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2007 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  5  * Copyright (C) 2010-2019 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;SVGAElement.h&quot;
 25 
 26 #include &quot;Document.h&quot;
 27 #include &quot;EventHandler.h&quot;
 28 #include &quot;Frame.h&quot;
 29 #include &quot;FrameLoader.h&quot;
 30 #include &quot;FrameLoaderTypes.h&quot;
 31 #include &quot;HTMLAnchorElement.h&quot;
 32 #include &quot;HTMLParserIdioms.h&quot;
 33 #include &quot;KeyboardEvent.h&quot;
 34 #include &quot;MouseEvent.h&quot;
 35 #include &quot;PlatformMouseEvent.h&quot;
 36 #include &quot;RenderSVGInline.h&quot;
 37 #include &quot;RenderSVGText.h&quot;
 38 #include &quot;RenderSVGTransformableContainer.h&quot;
 39 #include &quot;ResourceRequest.h&quot;
 40 #include &quot;SVGNames.h&quot;
 41 #include &quot;SVGSMILElement.h&quot;
 42 #include &quot;XLinkNames.h&quot;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGAElement);
 48 
 49 inline SVGAElement::SVGAElement(const QualifiedName&amp; tagName, Document&amp; document)
 50     : SVGGraphicsElement(tagName, document)
 51     , SVGURIReference(this)
 52 {
 53     ASSERT(hasTagName(SVGNames::aTag));
 54 
 55     static std::once_flag onceFlag;
 56     std::call_once(onceFlag, [] {
 57         PropertyRegistry::registerProperty&lt;SVGNames::targetAttr, &amp;SVGAElement::m_target&gt;();
 58     });
 59 }
 60 
 61 Ref&lt;SVGAElement&gt; SVGAElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 62 {
 63     return adoptRef(*new SVGAElement(tagName, document));
 64 }
 65 
 66 String SVGAElement::title() const
 67 {
 68     // If the xlink:title is set (non-empty string), use it.
 69     const AtomString&amp; title = attributeWithoutSynchronization(XLinkNames::titleAttr);
 70     if (!title.isEmpty())
 71         return title;
 72 
 73     // Otherwise, use the title of this element.
 74     return SVGElement::title();
 75 }
 76 
 77 void SVGAElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 78 {
 79     if (name == SVGNames::targetAttr) {
 80         m_target-&gt;setBaseValInternal(value);
 81         return;
 82     }
 83 
 84     SVGGraphicsElement::parseAttribute(name, value);
 85     SVGURIReference::parseAttribute(name, value);
 86 }
 87 
 88 void SVGAElement::svgAttributeChanged(const QualifiedName&amp; attrName)
 89 {
 90     if (SVGURIReference::isKnownAttribute(attrName)) {
 91         bool wasLink = isLink();
 92         setIsLink(!href().isNull() &amp;&amp; !shouldProhibitLinks(this));
 93         if (wasLink != isLink()) {
 94             InstanceInvalidationGuard guard(*this);
 95             invalidateStyleForSubtree();
 96         }
 97         return;
 98     }
 99 
100     SVGGraphicsElement::svgAttributeChanged(attrName);
101 }
102 
103 RenderPtr&lt;RenderElement&gt; SVGAElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
104 {
105     if (parentNode() &amp;&amp; parentNode()-&gt;isSVGElement() &amp;&amp; downcast&lt;SVGElement&gt;(*parentNode()).isTextContent())
106         return createRenderer&lt;RenderSVGInline&gt;(*this, WTFMove(style));
107 
108     return createRenderer&lt;RenderSVGTransformableContainer&gt;(*this, WTFMove(style));
109 }
110 
111 void SVGAElement::defaultEventHandler(Event&amp; event)
112 {
113     if (isLink()) {
114         if (focused() &amp;&amp; isEnterKeyKeydownEvent(event)) {
115             event.setDefaultHandled();
116             dispatchSimulatedClick(&amp;event);
117             return;
118         }
119 
120         if (MouseEvent::canTriggerActivationBehavior(event)) {
121             String url = stripLeadingAndTrailingHTMLSpaces(href());
122 
123             if (url[0] == &#39;#&#39;) {
124                 auto targetElement = makeRefPtr(treeScope().getElementById(url.substringSharingImpl(1)));
125                 if (is&lt;SVGSMILElement&gt;(targetElement)) {
126                     downcast&lt;SVGSMILElement&gt;(*targetElement).beginByLinkActivation();
127                     event.setDefaultHandled();
128                     return;
129                 }
130                 // Only allow navigation to internal &lt;view&gt; anchors.
131                 if (targetElement &amp;&amp; !targetElement-&gt;hasTagName(SVGNames::viewTag))
132                     return;
133             }
134 
135             String target = this-&gt;target();
136             if (target.isEmpty() &amp;&amp; attributeWithoutSynchronization(XLinkNames::showAttr) == &quot;new&quot;)
137                 target = &quot;_blank&quot;;
138             event.setDefaultHandled();
139 
140             auto frame = makeRefPtr(document().frame());
141             if (!frame)
142                 return;
143             frame-&gt;loader().urlSelected(document().completeURL(url), target, &amp;event, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, document().shouldOpenExternalURLsPolicyToPropagate());
144             return;
145         }
146     }
147 
148     SVGGraphicsElement::defaultEventHandler(event);
149 }
150 
151 int SVGAElement::defaultTabIndex() const
152 {
153     return 0;
154 }
155 
156 bool SVGAElement::supportsFocus() const
157 {
158     if (hasEditableStyle())
159         return SVGGraphicsElement::supportsFocus();
160     // If not a link we should still be able to focus the element if it has a tabIndex.
161     return isLink() || SVGGraphicsElement::supportsFocus();
162 }
163 
164 bool SVGAElement::isURLAttribute(const Attribute&amp; attribute) const
165 {
166     return SVGURIReference::isKnownAttribute(attribute.name()) || SVGGraphicsElement::isURLAttribute(attribute);
167 }
168 
169 bool SVGAElement::isMouseFocusable() const
170 {
171     // Links are focusable by default, but only allow links with tabindex or contenteditable to be mouse focusable.
172     // https://bugs.webkit.org/show_bug.cgi?id=26856
173     if (isLink())
174         return Element::supportsFocus();
175 
176     return SVGElement::isMouseFocusable();
177 }
178 
179 bool SVGAElement::isKeyboardFocusable(KeyboardEvent* event) const
180 {
181     if (isFocusable() &amp;&amp; Element::supportsFocus())
182         return SVGElement::isKeyboardFocusable(event);
183 
184     if (isLink())
185         return document().frame()-&gt;eventHandler().tabsToLinks(event);
186 
187     return SVGElement::isKeyboardFocusable(event);
188 }
189 
190 bool SVGAElement::canStartSelection() const
191 {
192     if (!isLink())
193         return SVGElement::canStartSelection();
194 
195     return hasEditableStyle();
196 }
197 
198 bool SVGAElement::childShouldCreateRenderer(const Node&amp; child) const
199 {
200     // http://www.w3.org/2003/01/REC-SVG11-20030114-errata#linking-text-environment
201     // The &#39;a&#39; element may contain any element that its parent may contain, except itself.
202     if (child.hasTagName(SVGNames::aTag))
203         return false;
204 
205     if (parentElement() &amp;&amp; parentElement()-&gt;isSVGElement())
206         return parentElement()-&gt;childShouldCreateRenderer(child);
207 
208     return SVGElement::childShouldCreateRenderer(child);
209 }
210 
211 bool SVGAElement::willRespondToMouseClickEvents()
212 {
213     return isLink() || SVGGraphicsElement::willRespondToMouseClickEvents();
214 }
215 
216 SharedStringHash SVGAElement::visitedLinkHash() const
217 {
218     ASSERT(isLink());
219     if (!m_storedVisitedLinkHash)
220         m_storedVisitedLinkHash = computeVisitedLinkHash(document().baseURL(), getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr));
221     return *m_storedVisitedLinkHash;
222 }
223 
224 } // namespace WebCore
    </pre>
  </body>
</html>
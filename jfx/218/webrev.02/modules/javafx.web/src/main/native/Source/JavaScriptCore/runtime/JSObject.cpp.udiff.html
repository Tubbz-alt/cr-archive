<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSONObject.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -73,13 +73,13 @@</span>
  
  const ClassInfo JSObject::s_info = { &quot;Object&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSObject) };
  
  const ClassInfo JSFinalObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFinalObject) };
  
<span class="udiff-line-modified-removed">- static inline void getClassPropertyNames(ExecState* exec, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
<span class="udiff-line-modified-added">+ static inline void getClassPropertyNames(JSGlobalObject* globalObject, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
  
      // Add properties from the static hashtables of properties
      for (; classInfo; classInfo = classInfo-&gt;parentClass) {
          const HashTable* table = classInfo-&gt;staticPropHashTable;
          if (!table)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,11 +90,11 @@</span>
                  propertyNames.add(Identifier::fromString(vm, iter.key()));
          }
      }
  }
  
<span class="udiff-line-modified-removed">- ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset lastOffset)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset maxOffset)</span>
  {
      // We call this when we found everything without races.
      ASSERT(structure);
  
      if (!butterfly)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111,17 +111,17 @@</span>
          preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
      else
          preCapacity = 0;
  
      HeapCell* base = bitwise_cast&lt;HeapCell*&gt;(
<span class="udiff-line-modified-removed">-         butterfly-&gt;base(preCapacity, Structure::outOfLineCapacity(lastOffset)));</span>
<span class="udiff-line-modified-added">+         butterfly-&gt;base(preCapacity, Structure::outOfLineCapacity(maxOffset)));</span>
  
      ASSERT(Heap::heap(base) == visitor.heap());
  
      visitor.markAuxiliary(base);
  
<span class="udiff-line-modified-removed">-     unsigned outOfLineSize = Structure::outOfLineSize(lastOffset);</span>
<span class="udiff-line-modified-added">+     unsigned outOfLineSize = Structure::outOfLineSize(maxOffset);</span>
      visitor.appendValuesHidden(butterfly-&gt;propertyStorage() - outOfLineSize, outOfLineSize);
  }
  
  ALWAYS_INLINE Structure* JSObject::visitButterfly(SlotVisitor&amp; visitor)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136,11 +136,11 @@</span>
  {
      VM&amp; vm = visitor.vm();
  
      Butterfly* butterfly;
      Structure* structure;
<span class="udiff-line-modified-removed">-     PropertyOffset lastOffset;</span>
<span class="udiff-line-modified-added">+     PropertyOffset maxOffset;</span>
  
      auto visitElements = [&amp;] (IndexingType indexingMode) {
          switch (indexingMode) {
          // We don&#39;t need to visit the elements for CopyOnWrite butterflies since they we marked the JSImmutableButterfly acting as out butterfly.
          case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -157,13 +157,13 @@</span>
      };
  
      if (visitor.mutatorIsStopped()) {
          butterfly = this-&gt;butterfly();
          structure = this-&gt;structure(vm);
<span class="udiff-line-modified-removed">-         lastOffset = structure-&gt;lastOffset();</span>
<span class="udiff-line-modified-added">+         maxOffset = structure-&gt;maxOffset();</span>
  
<span class="udiff-line-modified-removed">-         markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, lastOffset);</span>
<span class="udiff-line-modified-added">+         markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, maxOffset);</span>
          visitElements(structure-&gt;indexingMode());
  
          return structure;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -172,11 +172,11 @@</span>
      // reallocating the butterfly with a concurrent collector, with all fencing necessary to ensure
      // that this executes as if under sequential consistency:
      //
      //     object-&gt;structure = nuke(object-&gt;structure)
      //     object-&gt;butterfly = newButterfly
<span class="udiff-line-modified-removed">-     //     structure-&gt;m_offset = newLastOffset</span>
<span class="udiff-line-modified-added">+     //     structure-&gt;m_offset = newMaxOffset</span>
      //     object-&gt;structure = newStructure
      //
      // It&#39;s OK to skip this when reallocating the butterfly in a way that does not affect the m_offset.
      // We have other protocols in place for that.
      //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -228,147 +228,147 @@</span>
      //
      // But we additionally have to worry about the size changing. We make this work by requiring that
      // the collector reads the size early and late as well. Lets consider the interleaving of the
      // mutator changing the size without changing the structure:
      //
<span class="udiff-line-modified-removed">-     //     NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure</span>
<span class="udiff-line-modified-added">+     //     NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure</span>
      //
      // Meanwhile the collector does:
      //
<span class="udiff-line-modified-removed">-     //     ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate</span>
<span class="udiff-line-modified-added">+     //     ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate</span>
      //
      // The collector can detect races by not only comparing the early structure to the late structure
      // (which will be the same before and after the algorithm runs) but also by comparing the early and
<span class="udiff-line-modified-removed">-     // late lastOffsets.  Note: the IGNORE proofs do not cite all of the reasons why the collector will</span>
<span class="udiff-line-modified-added">+     // late maxOffsets. Note: the IGNORE proofs do not cite all of the reasons why the collector will</span>
      // ignore the case, since we only need to identify one to say that we&#39;re in the ignore case.
      //
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, trivially</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, the ReadStructureEarly sees the same structure as after and everything else runs after.</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, as above and the ReadLastOffsetEarly sees the lastOffset after.</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: AFTER, as above and the ReadButterfly sees the right butterfly after.</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="udiff-line-modified-removed">-     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure: BEFORE, trivially</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, trivially</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, the ReadStructureEarly sees the same structure as after and everything else runs after.</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, as above and the ReadMaxOffsetEarly sees the maxOffset after.</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: AFTER, as above and the ReadButterfly sees the right butterfly after.</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="udiff-line-modified-added">+     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure: BEFORE, trivially</span>
      //
      // Whew.
      //
      // What the collector is doing is just the &quot;double collect&quot; snapshot from &quot;The Unbounded Single-
      // Writer Algorithm&quot; from Yehuda Afek et al&#39;s &quot;Atomic Snapshots of Shared Memory&quot; in JACM 1993,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -390,11 +390,11 @@</span>
  
      StructureID structureID = this-&gt;structureID();
      if (isNuked(structureID))
          return nullptr;
      structure = vm.getStructure(structureID);
<span class="udiff-line-modified-removed">-     lastOffset = structure-&gt;lastOffset();</span>
<span class="udiff-line-modified-added">+     maxOffset = structure-&gt;maxOffset();</span>
      IndexingType indexingMode = structure-&gt;indexingMode();
      Dependency indexingModeDependency = Dependency::fence(indexingMode);
      Locker&lt;JSCellLock&gt; locker(NoLockingNecessary);
      switch (indexingMode) {
      case ALL_ARRAY_STORAGE_INDEXING_TYPES:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -413,14 +413,14 @@</span>
      Dependency butterflyDependency = Dependency::fence(butterfly);
      if (!butterfly)
          return structure;
      if (butterflyDependency.consume(this)-&gt;structureID() != structureID)
          return nullptr;
<span class="udiff-line-modified-removed">-     if (butterflyDependency.consume(structure)-&gt;lastOffset() != lastOffset)</span>
<span class="udiff-line-modified-added">+     if (butterflyDependency.consume(structure)-&gt;maxOffset() != maxOffset)</span>
          return nullptr;
  
<span class="udiff-line-modified-removed">-     markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, lastOffset);</span>
<span class="udiff-line-modified-added">+     markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, maxOffset);</span>
      ASSERT(indexingMode == structure-&gt;indexingMode());
      visitElements(indexingMode);
  
      return structure;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -434,20 +434,20 @@</span>
  
  void JSObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
      visitor.m_isCheckingForDefaultMarkViolation = false;
  #endif
  
      JSCell::visitChildren(thisObject, visitor);
  
      thisObject-&gt;visitButterfly(visitor);
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
  #endif
  }
  
  void JSObject::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -490,11 +490,11 @@</span>
  
  void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      JSFinalObject* thisObject = jsCast&lt;JSFinalObject*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
      visitor.m_isCheckingForDefaultMarkViolation = false;
  #endif
  
      JSCell::visitChildren(thisObject, visitor);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -502,11 +502,11 @@</span>
      if (Structure* structure = thisObject-&gt;visitButterfly(visitor)) {
          if (unsigned storageSize = structure-&gt;inlineSize())
              visitor.appendValuesHidden(thisObject-&gt;inlineStorage(), storageSize);
      }
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
  #endif
  }
  
  String JSObject::className(const JSObject* object, VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -514,13 +514,13 @@</span>
      const ClassInfo* info = object-&gt;classInfo(vm);
      ASSERT(info);
      return info-&gt;className;
  }
  
<span class="udiff-line-modified-removed">- String JSObject::toStringName(const JSObject* object, ExecState* exec)</span>
<span class="udiff-line-modified-added">+ String JSObject::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      const ClassInfo* info = object-&gt;classInfo(vm);
      ASSERT(info);
      return info-&gt;className;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -529,19 +529,18 @@</span>
      String constructorFunctionName;
      auto* structure = object-&gt;structure();
      auto* globalObject = structure-&gt;globalObject();
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="udiff-line-removed">-     auto* exec = globalObject-&gt;globalExec();</span>
  
      // Check for a display name of obj.constructor.
      // This is useful to get `Foo` for the `(class Foo).prototype` object.
      PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="udiff-line-modified-removed">-     if (object-&gt;getOwnPropertySlot(object, exec, vm.propertyNames-&gt;constructor, slot)) {</span>
<span class="udiff-line-modified-added">+     if (object-&gt;getOwnPropertySlot(object, globalObject, vm.propertyNames-&gt;constructor, slot)) {</span>
          EXCEPTION_ASSERT(!scope.exception());
          if (slot.isValue()) {
<span class="udiff-line-modified-removed">-             if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
<span class="udiff-line-modified-added">+             if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(globalObject, vm.propertyNames-&gt;constructor))) {</span>
                  if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
                      constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
                  else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
                      constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -559,14 +558,14 @@</span>
          if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype)) {
              JSValue protoValue = object-&gt;getPrototypeDirect(vm);
              if (protoValue.isObject()) {
                  JSObject* protoObject = asObject(protoValue);
                  PropertySlot slot(protoValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="udiff-line-modified-removed">-                 if (protoObject-&gt;getPropertySlot(exec, vm.propertyNames-&gt;constructor, slot)) {</span>
<span class="udiff-line-modified-added">+                 if (protoObject-&gt;getPropertySlot(globalObject, vm.propertyNames-&gt;constructor, slot)) {</span>
                      EXCEPTION_ASSERT(!scope.exception());
                      if (slot.isValue()) {
<span class="udiff-line-modified-removed">-                         if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
<span class="udiff-line-modified-added">+                         if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(globalObject, vm.propertyNames-&gt;constructor))) {</span>
                              if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
                                  constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
                              else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
                                  constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
                          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -594,20 +593,20 @@</span>
      }
  
      return constructorFunctionName;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, ExecState* exec, unsigned i, PropertySlot&amp; slot)</span>
<span class="udiff-line-modified-added">+ bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, JSGlobalObject* globalObject, unsigned i, PropertySlot&amp; slot)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
  
      // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
      // legal for anyone to override getOwnPropertySlot() without also overriding
      // getOwnPropertySlotByIndex().
  
      if (i &gt; MAX_ARRAY_INDEX)
<span class="udiff-line-modified-removed">-         return thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, Identifier::from(vm, i), slot);</span>
<span class="udiff-line-modified-added">+         return thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, globalObject, Identifier::from(vm, i), slot);</span>
  
      switch (thisObject-&gt;indexingType()) {
      case ALL_BLANK_INDEXING_TYPES:
      case ALL_UNDECIDED_INDEXING_TYPES:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,36 +668,36 @@</span>
  
      return false;
  }
  
  // https://tc39.github.io/ecma262/#sec-ordinaryset
<span class="udiff-line-modified-removed">- bool ordinarySetSlow(ExecState* exec, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)</span>
<span class="udiff-line-modified-added">+ bool ordinarySetSlow(JSGlobalObject* globalObject, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)</span>
  {
      // If we find the receiver is not the same to the object, we fall to this slow path.
      // Currently, there are 3 candidates.
      // 1. Reflect.set can alter the receiver with an arbitrary value.
      // 2. Window Proxy.
      // 3. ES6 Proxy.
  
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSObject* current = object;
      PropertyDescriptor ownDescriptor;
      while (true) {
          if (current-&gt;type() == ProxyObjectType) {
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
              PutPropertySlot slot(receiver, shouldThrow);
<span class="udiff-line-modified-removed">-             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));</span>
<span class="udiff-line-modified-added">+             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, globalObject, propertyName, value, slot));</span>
          }
  
          // 9.1.9.1-2 Let ownDesc be ? O.[[GetOwnProperty]](P).
<span class="udiff-line-modified-removed">-         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(exec, propertyName, ownDescriptor);</span>
<span class="udiff-line-modified-added">+         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(globalObject, propertyName, ownDescriptor);</span>
          RETURN_IF_EXCEPTION(scope, false);
  
          if (!ownDescriptorFound) {
              // 9.1.9.1-3-a Let parent be ? O.[[GetPrototypeOf]]().
<span class="udiff-line-modified-removed">-             JSValue prototype = current-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+             JSValue prototype = current-&gt;getPrototype(vm, globalObject);</span>
              RETURN_IF_EXCEPTION(scope, false);
  
              // 9.1.9.1-3-b If parent is not null, then
              if (!prototype.isNull()) {
                  // 9.1.9.1-3-b-i Return ? parent.[[Set]](P, V, Receiver).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -713,118 +712,118 @@</span>
  
      // 9.1.9.1-4 If IsDataDescriptor(ownDesc) is true, then
      if (ownDescriptor.isDataDescriptor()) {
          // 9.1.9.1-4-a If ownDesc.[[Writable]] is false, return false.
          if (!ownDescriptor.writable())
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
  
          // 9.1.9.1-4-b If Type(Receiver) is not Object, return false.
          if (!receiver.isObject())
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
  
          // In OrdinarySet, the receiver may not be the same to the object.
          // So, we perform [[GetOwnProperty]] onto the receiver while we already perform [[GetOwnProperty]] onto the object.
  
          // 9.1.9.1-4-c Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
          JSObject* receiverObject = asObject(receiver);
          PropertyDescriptor existingDescriptor;
<span class="udiff-line-modified-removed">-         bool existingDescriptorFound = receiverObject-&gt;getOwnPropertyDescriptor(exec, propertyName, existingDescriptor);</span>
<span class="udiff-line-modified-added">+         bool existingDescriptorFound = receiverObject-&gt;getOwnPropertyDescriptor(globalObject, propertyName, existingDescriptor);</span>
          RETURN_IF_EXCEPTION(scope, false);
  
          // 9.1.9.1-4-d If existingDescriptor is not undefined, then
          if (existingDescriptorFound) {
              // 9.1.9.1-4-d-i If IsAccessorDescriptor(existingDescriptor) is true, return false.
              if (existingDescriptor.isAccessorDescriptor())
<span class="udiff-line-modified-removed">-                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+                 return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
  
              // 9.1.9.1-4-d-ii If existingDescriptor.[[Writable]] is false, return false.
              if (!existingDescriptor.writable())
<span class="udiff-line-modified-removed">-                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+                 return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
  
              // 9.1.9.1-4-d-iii Let valueDesc be the PropertyDescriptor{[[Value]]: V}.
              PropertyDescriptor valueDescriptor;
              valueDescriptor.setValue(value);
  
              // 9.1.9.1-4-d-iv Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
<span class="udiff-line-modified-removed">-             RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, exec, propertyName, valueDescriptor, shouldThrow));</span>
<span class="udiff-line-modified-added">+             RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, globalObject, propertyName, valueDescriptor, shouldThrow));</span>
          }
  
          // 9.1.9.1-4-e Else Receiver does not currently have a property P,
          // 9.1.9.1-4-e-i Return ? CreateDataProperty(Receiver, P, V).
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, exec, propertyName, PropertyDescriptor(value, static_cast&lt;unsigned&gt;(PropertyAttribute::None)), shouldThrow));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, globalObject, propertyName, PropertyDescriptor(value, static_cast&lt;unsigned&gt;(PropertyAttribute::None)), shouldThrow));</span>
      }
  
      // 9.1.9.1-5 Assert: IsAccessorDescriptor(ownDesc) is true.
      ASSERT(ownDescriptor.isAccessorDescriptor());
  
      // 9.1.9.1-6 Let setter be ownDesc.[[Set]].
      // 9.1.9.1-7 If setter is undefined, return false.
      JSValue setter = ownDescriptor.setter();
      if (!setter.isObject())
<span class="udiff-line-modified-removed">-         return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+         return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
  
      // 9.1.9.1-8 Perform ? Call(setter, Receiver, &lt;&lt; V &gt;&gt;).
      JSObject* setterObject = asObject(setter);
      MarkedArgumentBuffer args;
      args.append(value);
      ASSERT(!args.hasOverflowed());
  
      CallData callData;
      CallType callType = setterObject-&gt;methodTable(vm)-&gt;getCallData(setterObject, callData);
      scope.release();
<span class="udiff-line-modified-removed">-     call(exec, setterObject, callType, callData, receiver, args);</span>
<span class="udiff-line-modified-added">+     call(globalObject, setterObject, callType, callData, receiver, args);</span>
  
      // 9.1.9.1-9 Return true.
      return true;
  }
  
  // ECMA 8.6.2.2
<span class="udiff-line-modified-removed">- bool JSObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="udiff-line-modified-added">+ bool JSObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="udiff-line-modified-removed">-     return putInlineForJSObject(cell, exec, propertyName, value, slot);</span>
<span class="udiff-line-modified-added">+     return putInlineForJSObject(cell, globalObject, propertyName, value, slot);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putInlineSlow(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putInlineSlow(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
      ASSERT(!isThisValueAltered(slot, this));
  
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* obj = this;
      for (;;) {
          Structure* structure = obj-&gt;structure(vm);
          if (UNLIKELY(structure-&gt;typeInfo().hasPutPropertySecurityCheck())) {
<span class="udiff-line-modified-removed">-             obj-&gt;methodTable(vm)-&gt;doPutPropertySecurityCheck(obj, exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+             obj-&gt;methodTable(vm)-&gt;doPutPropertySecurityCheck(obj, globalObject, propertyName, slot);</span>
              RETURN_IF_EXCEPTION(scope, false);
          }
          unsigned attributes;
          PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
          if (isValidOffset(offset)) {
              if (attributes &amp; PropertyAttribute::ReadOnly) {
                  ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
<span class="udiff-line-modified-removed">-                 return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+                 return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
              }
  
              JSValue gs = obj-&gt;getDirect(offset);
              if (gs.isGetterSetter()) {
                  // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
                  if (!this-&gt;structure(vm)-&gt;isDictionary())
                      slot.setCacheableSetter(obj, offset);
  
<span class="udiff-line-modified-removed">-                 bool result = callSetter(exec, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);</span>
<span class="udiff-line-modified-added">+                 bool result = callSetter(globalObject, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);</span>
                  RETURN_IF_EXCEPTION(scope, false);
                  return result;
              }
              if (gs.isCustomGetterSetter()) {
                  // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
                  if (attributes &amp; PropertyAttribute::CustomAccessor)
                      slot.setCustomAccessor(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
                  else
                      slot.setCustomValue(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
  
<span class="udiff-line-modified-removed">-                 bool result = callCustomSetter(exec, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);</span>
<span class="udiff-line-modified-added">+                 bool result = callCustomSetter(globalObject, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);</span>
                  RETURN_IF_EXCEPTION(scope, false);
                  return result;
              }
              ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -833,40 +832,37 @@</span>
              break;
          }
          if (!obj-&gt;staticPropertiesReified(vm)) {
              if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
                  if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
<span class="udiff-line-modified-removed">-                     RELEASE_AND_RETURN(scope, putEntry(exec, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));</span>
<span class="udiff-line-modified-added">+                     RELEASE_AND_RETURN(scope, putEntry(globalObject, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));</span>
              }
          }
          if (obj-&gt;type() == ProxyObjectType) {
<span class="udiff-line-removed">-             // FIXME: We shouldn&#39;t unconditionally perform [[Set]] here.</span>
<span class="udiff-line-removed">-             // We need to do more because this is observable behavior.</span>
<span class="udiff-line-removed">-             // https://bugs.webkit.org/show_bug.cgi?id=155012</span>
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
<span class="udiff-line-modified-removed">-             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));</span>
<span class="udiff-line-modified-added">+             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, globalObject, propertyName, value, slot));</span>
          }
<span class="udiff-line-modified-removed">-         JSValue prototype = obj-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+         JSValue prototype = obj-&gt;getPrototype(vm, globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (prototype.isNull())
              break;
          obj = asObject(prototype);
      }
  
      if (!putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<span class="udiff-line-modified-removed">-         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+         return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
  
      if (propertyName &gt; MAX_ARRAY_INDEX) {
          PutPropertySlot slot(cell, shouldThrow);
<span class="udiff-line-modified-removed">-         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, exec, Identifier::from(vm, propertyName), value, slot);</span>
<span class="udiff-line-modified-added">+         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, globalObject, Identifier::from(vm, propertyName), value, slot);</span>
      }
  
      thisObject-&gt;ensureWritable(vm);
  
      switch (thisObject-&gt;indexingType()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -874,43 +870,44 @@</span>
          break;
  
      case ALL_UNDECIDED_INDEXING_TYPES: {
          thisObject-&gt;convertUndecidedForValue(vm, value);
          // Reloop.
<span class="udiff-line-modified-removed">-         return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
<span class="udiff-line-modified-added">+         return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
      }
  
      case ALL_INT32_INDEXING_TYPES: {
          if (!value.isInt32()) {
              thisObject-&gt;convertInt32ForValue(vm, value);
<span class="udiff-line-modified-removed">-             return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
<span class="udiff-line-modified-added">+             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
          }
          FALLTHROUGH;
      }
  
      case ALL_CONTIGUOUS_INDEXING_TYPES: {
          Butterfly* butterfly = thisObject-&gt;butterfly();
          if (propertyName &gt;= butterfly-&gt;vectorLength())
              break;
<span class="udiff-line-modified-removed">-         butterfly-&gt;contiguous().at(thisObject, propertyName).set(vm, thisObject, value);</span>
<span class="udiff-line-modified-added">+         butterfly-&gt;contiguous().at(thisObject, propertyName).setWithoutWriteBarrier(value);</span>
          if (propertyName &gt;= butterfly-&gt;publicLength())
              butterfly-&gt;setPublicLength(propertyName + 1);
<span class="udiff-line-added">+         vm.heap.writeBarrier(thisObject, value);</span>
          return true;
      }
  
      case ALL_DOUBLE_INDEXING_TYPES: {
          if (!value.isNumber()) {
              thisObject-&gt;convertDoubleToContiguous(vm);
              // Reloop.
<span class="udiff-line-modified-removed">-             return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
<span class="udiff-line-modified-added">+             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
          }
  
          double valueAsDouble = value.asNumber();
          if (valueAsDouble != valueAsDouble) {
              thisObject-&gt;convertDoubleToContiguous(vm);
              // Reloop.
<span class="udiff-line-modified-removed">-             return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
<span class="udiff-line-modified-added">+             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
          }
          Butterfly* butterfly = thisObject-&gt;butterfly();
          if (propertyName &gt;= butterfly-&gt;vectorLength())
              break;
          butterfly-&gt;contiguousDouble().at(thisObject, propertyName) = valueAsDouble;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -954,20 +951,20 @@</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          // Update length &amp; m_numValuesInVector as necessary.
          if (propertyName &gt;= length) {
              bool putResult = false;
<span class="udiff-line-modified-removed">-             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
<span class="udiff-line-modified-added">+             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(globalObject, propertyName, value, shouldThrow, putResult);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (result)
                  return putResult;
              length = propertyName + 1;
              storage-&gt;setLength(length);
              ++storage-&gt;m_numValuesInVector;
          } else if (!valueSlot) {
              bool putResult = false;
<span class="udiff-line-modified-removed">-             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
<span class="udiff-line-modified-added">+             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(globalObject, propertyName, value, shouldThrow, putResult);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (result)
                  return putResult;
              ++storage-&gt;m_numValuesInVector;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -978,11 +975,11 @@</span>
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
  
<span class="udiff-line-modified-removed">-     return thisObject-&gt;putByIndexBeyondVectorLength(exec, propertyName, value, shouldThrow);</span>
<span class="udiff-line-modified-added">+     return thisObject-&gt;putByIndexBeyondVectorLength(globalObject, propertyName, value, shouldThrow);</span>
  }
  
  ArrayStorage* JSObject::enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp; vm, ArrayStorage* storage)
  {
      SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1208,13 +1205,13 @@</span>
      unsigned publicLength = m_butterfly-&gt;publicLength();
      unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
  
      Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, true, ArrayStorage::sizeFor(neededLength));
  
<span class="udiff-line-modified-removed">-     memcpy(</span>
<span class="udiff-line-modified-removed">-         newButterfly-&gt;base(0, propertyCapacity),</span>
<span class="udiff-line-modified-removed">-         m_butterfly-&gt;base(0, propertyCapacity),</span>
<span class="udiff-line-modified-added">+     gcSafeMemcpy(</span>
<span class="udiff-line-modified-added">+         static_cast&lt;JSValue*&gt;(newButterfly-&gt;base(0, propertyCapacity)),</span>
<span class="udiff-line-modified-added">+         static_cast&lt;JSValue*&gt;(m_butterfly-&gt;base(0, propertyCapacity)),</span>
          propertyCapacity * sizeof(EncodedJSValue));
  
      ArrayStorage* newStorage = newButterfly-&gt;arrayStorage();
      newStorage-&gt;setVectorLength(neededLength);
      newStorage-&gt;setLength(publicLength);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1501,11 +1498,11 @@</span>
      Butterfly* oldButterfly = butterfly();
      size_t propertyCapacity = 0;
      unsigned newVectorLength = Butterfly::optimalContiguousVectorLength(propertyCapacity, std::min(oldButterfly-&gt;vectorLength() * 2, MAX_STORAGE_VECTOR_LENGTH));
      Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, hasIndexingHeader, newVectorLength * sizeof(JSValue));
  
<span class="udiff-line-modified-removed">-     memcpy(newButterfly-&gt;propertyStorage(), oldButterfly-&gt;propertyStorage(), oldButterfly-&gt;vectorLength() * sizeof(JSValue) + sizeof(IndexingHeader));</span>
<span class="udiff-line-modified-added">+     gcSafeMemcpy(newButterfly-&gt;propertyStorage(), oldButterfly-&gt;propertyStorage(), oldButterfly-&gt;vectorLength() * sizeof(JSValue) + sizeof(IndexingHeader));</span>
  
      WTF::storeStoreFence();
      NonPropertyTransition transition = ([&amp;] () {
          switch (indexingType()) {
          case ArrayWithInt32:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1807,37 +1804,37 @@</span>
          return;
  
      switchToSlowPutArrayStorage(vm);
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::setPrototypeWithCycleCheck(VM&amp; vm, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
<span class="udiff-line-modified-added">+ bool JSObject::setPrototypeWithCycleCheck(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (this-&gt;structure(vm)-&gt;isImmutablePrototypeExoticObject()) {
          // This implements https://tc39.github.io/ecma262/#sec-set-immutable-prototype.
<span class="udiff-line-modified-removed">-         if (this-&gt;getPrototype(vm, exec) == prototype)</span>
<span class="udiff-line-modified-added">+         if (this-&gt;getPrototype(vm, globalObject) == prototype)</span>
              return true;
  
<span class="udiff-line-modified-removed">-         return typeError(exec, scope, shouldThrowIfCantSet, &quot;Cannot set prototype of immutable prototype object&quot;_s);</span>
<span class="udiff-line-modified-added">+         return typeError(globalObject, scope, shouldThrowIfCantSet, &quot;Cannot set prototype of immutable prototype object&quot;_s);</span>
      }
  
<span class="udiff-line-modified-removed">-     ASSERT(methodTable(vm)-&gt;toThis(this, exec, NotStrictMode) == this);</span>
<span class="udiff-line-modified-added">+     ASSERT(methodTable(vm)-&gt;toThis(this, globalObject, NotStrictMode) == this);</span>
  
      if (this-&gt;getPrototypeDirect(vm) == prototype)
          return true;
  
<span class="udiff-line-modified-removed">-     bool isExtensible = this-&gt;isExtensible(exec);</span>
<span class="udiff-line-modified-added">+     bool isExtensible = this-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!isExtensible)
<span class="udiff-line-modified-removed">-         return typeError(exec, scope, shouldThrowIfCantSet, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+         return typeError(globalObject, scope, shouldThrowIfCantSet, ReadonlyPropertyWriteError);</span>
  
      JSValue nextPrototype = prototype;
      while (nextPrototype &amp;&amp; nextPrototype.isObject()) {
          if (nextPrototype == this)
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, shouldThrowIfCantSet, &quot;cyclic __proto__ value&quot;_s);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, shouldThrowIfCantSet, &quot;cyclic __proto__ value&quot;_s);</span>
          // FIXME: The specification currently says we should check if the [[GetPrototypeOf]] internal method of nextPrototype
          // is not the ordinary object internal method. However, we currently restrict this to Proxy objects as it would allow
          // for cycles with certain HTML objects (WindowProxy, Location) otherwise.
          // https://bugs.webkit.org/show_bug.cgi?id=161534
          if (UNLIKELY(asObject(nextPrototype)-&gt;type() == ProxyObjectType))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1846,61 +1843,61 @@</span>
      }
      setPrototypeDirect(vm, prototype);
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::setPrototype(JSObject* object, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
<span class="udiff-line-modified-added">+ bool JSObject::setPrototype(JSObject* object, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
  {
<span class="udiff-line-modified-removed">-     return object-&gt;setPrototypeWithCycleCheck(exec-&gt;vm(), exec, prototype, shouldThrowIfCantSet);</span>
<span class="udiff-line-modified-added">+     return object-&gt;setPrototypeWithCycleCheck(globalObject-&gt;vm(), globalObject, prototype, shouldThrowIfCantSet);</span>
  }
  
<span class="udiff-line-modified-removed">- JSValue JSObject::getPrototype(JSObject* object, ExecState* exec)</span>
<span class="udiff-line-modified-added">+ JSValue JSObject::getPrototype(JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="udiff-line-modified-removed">-     return object-&gt;getPrototypeDirect(exec-&gt;vm());</span>
<span class="udiff-line-modified-added">+     return object-&gt;getPrototypeDirect(globalObject-&gt;vm());</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::setPrototype(VM&amp; vm, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
<span class="udiff-line-modified-added">+ bool JSObject::setPrototype(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
  {
<span class="udiff-line-modified-removed">-     return methodTable(vm)-&gt;setPrototype(this, exec, prototype, shouldThrowIfCantSet);</span>
<span class="udiff-line-modified-added">+     return methodTable(vm)-&gt;setPrototype(this, globalObject, prototype, shouldThrowIfCantSet);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putGetter(ExecState* exec, PropertyName propertyName, JSValue getter, unsigned attributes)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putGetter(JSGlobalObject* globalObject, PropertyName propertyName, JSValue getter, unsigned attributes)</span>
  {
      PropertyDescriptor descriptor;
      descriptor.setGetter(getter);
  
      ASSERT(attributes &amp; PropertyAttribute::Accessor);
      if (!(attributes &amp; PropertyAttribute::ReadOnly))
          descriptor.setConfigurable(true);
      if (!(attributes &amp; PropertyAttribute::DontEnum))
          descriptor.setEnumerable(true);
  
<span class="udiff-line-modified-removed">-     return defineOwnProperty(this, exec, propertyName, descriptor, true);</span>
<span class="udiff-line-modified-added">+     return defineOwnProperty(this, globalObject, propertyName, descriptor, true);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putSetter(ExecState* exec, PropertyName propertyName, JSValue setter, unsigned attributes)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putSetter(JSGlobalObject* globalObject, PropertyName propertyName, JSValue setter, unsigned attributes)</span>
  {
      PropertyDescriptor descriptor;
      descriptor.setSetter(setter);
  
      ASSERT(attributes &amp; PropertyAttribute::Accessor);
      if (!(attributes &amp; PropertyAttribute::ReadOnly))
          descriptor.setConfigurable(true);
      if (!(attributes &amp; PropertyAttribute::DontEnum))
          descriptor.setEnumerable(true);
  
<span class="udiff-line-modified-removed">-     return defineOwnProperty(this, exec, propertyName, descriptor, true);</span>
<span class="udiff-line-modified-added">+     return defineOwnProperty(this, globalObject, propertyName, descriptor, true);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putDirectAccessor(ExecState* exec, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putDirectAccessor(JSGlobalObject* globalObject, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)</span>
  {
      ASSERT(attributes &amp; PropertyAttribute::Accessor);
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="udiff-line-modified-removed">-         return putDirectIndex(exec, index.value(), accessor, attributes, PutDirectIndexLikePutDirect);</span>
<span class="udiff-line-modified-added">+         return putDirectIndex(globalObject, index.value(), accessor, attributes, PutDirectIndexLikePutDirect);</span>
  
<span class="udiff-line-modified-removed">-     return putDirectNonIndexAccessor(exec-&gt;vm(), propertyName, accessor, attributes);</span>
<span class="udiff-line-modified-added">+     return putDirectNonIndexAccessor(globalObject-&gt;vm(), propertyName, accessor, attributes);</span>
  }
  
  // FIXME: Introduce a JSObject::putDirectCustomValue() method instead of using
  // JSObject::putDirectCustomAccessor() to put CustomValues.
  // https://bugs.webkit.org/show_bug.cgi?id=192576
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1950,40 +1947,40 @@</span>
      structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
  }
  
  // HasProperty(O, P) from Section 7.3.10 of the spec.
  // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
<span class="udiff-line-modified-removed">- bool JSObject::hasProperty(ExecState* exec, PropertyName propertyName) const</span>
<span class="udiff-line-modified-added">+ bool JSObject::hasProperty(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
  {
<span class="udiff-line-modified-removed">-     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
<span class="udiff-line-modified-added">+     return hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::hasProperty(ExecState* exec, unsigned propertyName) const</span>
<span class="udiff-line-modified-added">+ bool JSObject::hasProperty(JSGlobalObject* globalObject, unsigned propertyName) const</span>
  {
<span class="udiff-line-modified-removed">-     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
<span class="udiff-line-modified-added">+     return hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::hasPropertyGeneric(ExecState* exec, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
<span class="udiff-line-modified-added">+ bool JSObject::hasPropertyGeneric(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
  {
      PropertySlot slot(this, internalMethodType);
<span class="udiff-line-modified-removed">-     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::hasPropertyGeneric(ExecState* exec, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
<span class="udiff-line-modified-added">+ bool JSObject::hasPropertyGeneric(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
  {
      PropertySlot slot(this, internalMethodType);
<span class="udiff-line-modified-removed">-     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
  }
  
  // ECMA 8.6.2.5
<span class="udiff-line-modified-removed">- bool JSObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
<span class="udiff-line-modified-added">+ bool JSObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="udiff-line-modified-removed">-         return thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, index.value());</span>
<span class="udiff-line-modified-added">+         return thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, globalObject, index.value());</span>
  
      unsigned attributes;
  
      if (!thisObject-&gt;staticPropertiesReified(vm)) {
          if (auto entry = thisObject-&gt;findPropertyHashEntry(vm, propertyName)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1992,41 +1989,51 @@</span>
              // not allow repacement of a non-configurable property with a configurable one).
              if (entry-&gt;value-&gt;attributes() &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {
                  ASSERT(!isValidOffset(thisObject-&gt;structure(vm)-&gt;get(vm, propertyName, attributes)) || attributes &amp; PropertyAttribute::DontDelete);
                  return false;
              }
<span class="udiff-line-modified-removed">-             thisObject-&gt;reifyAllStaticProperties(exec);</span>
<span class="udiff-line-modified-added">+             thisObject-&gt;reifyAllStaticProperties(globalObject);</span>
          }
      }
  
      Structure* structure = thisObject-&gt;structure(vm);
  
      bool propertyIsPresent = isValidOffset(structure-&gt;get(vm, propertyName, attributes));
      if (propertyIsPresent) {
          if (attributes &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable)
              return false;
<span class="udiff-line-added">+         DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure);</span>
  
<span class="udiff-line-modified-removed">-         PropertyOffset offset;</span>
<span class="udiff-line-modified-added">+         PropertyOffset offset = invalidOffset;</span>
          if (structure-&gt;isUncacheableDictionary())
<span class="udiff-line-modified-removed">-             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });</span>
<span class="udiff-line-modified-removed">-         else</span>
<span class="udiff-line-modified-removed">-             thisObject-&gt;setStructure(vm, Structure::removePropertyTransition(vm, structure, propertyName, offset));</span>
<span class="udiff-line-modified-added">+             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset) { });</span>
<span class="udiff-line-modified-added">+         else {</span>
<span class="udiff-line-modified-added">+             structure = Structure::removePropertyTransition(vm, structure, propertyName, offset, &amp;deferredWatchpointFire);</span>
<span class="udiff-line-added">+             if (thisObject-&gt;m_butterfly &amp;&amp; !structure-&gt;outOfLineCapacity() &amp;&amp; !structure-&gt;hasIndexingHeader(thisObject)) {</span>
<span class="udiff-line-added">+                 thisObject-&gt;nukeStructureAndSetButterfly(vm, thisObject-&gt;structureID(), nullptr);</span>
<span class="udiff-line-added">+                 offset = invalidOffset;</span>
<span class="udiff-line-added">+                 ASSERT(structure-&gt;maxOffset() == invalidOffset);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             thisObject-&gt;setStructure(vm, structure);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ASSERT(!isValidOffset(structure-&gt;get(vm, propertyName, attributes)));</span>
  
          if (offset != invalidOffset)
              thisObject-&gt;locationForOffset(offset)-&gt;clear();
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned i)</span>
<span class="udiff-line-modified-added">+ bool JSObject::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned i)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
  
      if (i &gt; MAX_ARRAY_INDEX)
<span class="udiff-line-modified-removed">-         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(vm, i));</span>
<span class="udiff-line-modified-added">+         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, globalObject, Identifier::from(vm, i));</span>
  
      switch (thisObject-&gt;indexingMode()) {
      case ALL_BLANK_INDEXING_TYPES:
      case ALL_UNDECIDED_INDEXING_TYPES:
          return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2093,30 +2100,30 @@</span>
  }
  
  enum class TypeHintMode { TakesHint, DoesNotTakeHint };
  
  template&lt;TypeHintMode mode = TypeHintMode::DoesNotTakeHint&gt;
<span class="udiff-line-modified-removed">- static ALWAYS_INLINE JSValue callToPrimitiveFunction(ExecState* exec, const JSObject* object, PropertyName propertyName, PreferredPrimitiveType hint)</span>
<span class="udiff-line-modified-added">+ static ALWAYS_INLINE JSValue callToPrimitiveFunction(JSGlobalObject* globalObject, const JSObject* object, PropertyName propertyName, PreferredPrimitiveType hint)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
      // FIXME: Remove this when we have fixed: rdar://problem/33451840
      // https://bugs.webkit.org/show_bug.cgi?id=187109.
      constexpr bool debugNullStructure = mode == TypeHintMode::TakesHint;
<span class="udiff-line-modified-removed">-     bool hasProperty = const_cast&lt;JSObject*&gt;(object)-&gt;getPropertySlot&lt;debugNullStructure&gt;(exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+     bool hasProperty = const_cast&lt;JSObject*&gt;(object)-&gt;getPropertySlot&lt;debugNullStructure&gt;(globalObject, propertyName, slot);</span>
      RETURN_IF_EXCEPTION(scope, scope.exception());
<span class="udiff-line-modified-removed">-     JSValue function = hasProperty ? slot.getValue(exec, propertyName) : jsUndefined();</span>
<span class="udiff-line-modified-added">+     JSValue function = hasProperty ? slot.getValue(globalObject, propertyName) : jsUndefined();</span>
      RETURN_IF_EXCEPTION(scope, scope.exception());
      if (function.isUndefinedOrNull() &amp;&amp; mode == TypeHintMode::TakesHint)
          return JSValue();
      CallData callData;
      CallType callType = getCallData(vm, function, callData);
      if (callType == CallType::None) {
          if (mode == TypeHintMode::TakesHint)
<span class="udiff-line-modified-removed">-             throwTypeError(exec, scope, &quot;Symbol.toPrimitive is not a function, undefined, or null&quot;_s);</span>
<span class="udiff-line-modified-added">+             throwTypeError(globalObject, scope, &quot;Symbol.toPrimitive is not a function, undefined, or null&quot;_s);</span>
          return scope.exception();
      }
  
      MarkedArgumentBuffer callArgs;
      if (mode == TypeHintMode::TakesHint) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2134,82 +2141,82 @@</span>
          }
          callArgs.append(hintString);
      }
      ASSERT(!callArgs.hasOverflowed());
  
<span class="udiff-line-modified-removed">-     JSValue result = call(exec, function, callType, callData, const_cast&lt;JSObject*&gt;(object), callArgs);</span>
<span class="udiff-line-modified-added">+     JSValue result = call(globalObject, function, callType, callData, const_cast&lt;JSObject*&gt;(object), callArgs);</span>
      RETURN_IF_EXCEPTION(scope, scope.exception());
      ASSERT(!result.isGetterSetter());
      if (result.isObject())
<span class="udiff-line-modified-removed">-         return mode == TypeHintMode::DoesNotTakeHint ? JSValue() : throwTypeError(exec, scope, &quot;Symbol.toPrimitive returned an object&quot;_s);</span>
<span class="udiff-line-modified-added">+         return mode == TypeHintMode::DoesNotTakeHint ? JSValue() : throwTypeError(globalObject, scope, &quot;Symbol.toPrimitive returned an object&quot;_s);</span>
      return result;
  }
  
  // ECMA 7.1.1
<span class="udiff-line-modified-removed">- JSValue JSObject::ordinaryToPrimitive(ExecState* exec, PreferredPrimitiveType hint) const</span>
<span class="udiff-line-modified-added">+ JSValue JSObject::ordinaryToPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType hint) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // Make sure that whatever default value methods there are on object&#39;s prototype chain are
      // being watched.
      for (const JSObject* object = this; object; object = object-&gt;structure(vm)-&gt;storedPrototypeObject(object))
          object-&gt;structure(vm)-&gt;startWatchingInternalPropertiesIfNecessary(vm);
  
      JSValue value;
      if (hint == PreferString) {
<span class="udiff-line-modified-removed">-         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;toString, hint);</span>
<span class="udiff-line-modified-added">+         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;toString, hint);</span>
          EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
          if (value)
              return value;
<span class="udiff-line-modified-removed">-         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;valueOf, hint);</span>
<span class="udiff-line-modified-added">+         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;valueOf, hint);</span>
          EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
          if (value)
              return value;
      } else {
<span class="udiff-line-modified-removed">-         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;valueOf, hint);</span>
<span class="udiff-line-modified-added">+         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;valueOf, hint);</span>
          EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
          if (value)
              return value;
<span class="udiff-line-modified-removed">-         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;toString, hint);</span>
<span class="udiff-line-modified-added">+         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;toString, hint);</span>
          EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
          if (value)
              return value;
      }
  
      scope.assertNoException();
  
<span class="udiff-line-modified-removed">-     return throwTypeError(exec, scope, &quot;No default value&quot;_s);</span>
<span class="udiff-line-modified-added">+     return throwTypeError(globalObject, scope, &quot;No default value&quot;_s);</span>
  }
  
<span class="udiff-line-modified-removed">- JSValue JSObject::defaultValue(const JSObject* object, ExecState* exec, PreferredPrimitiveType hint)</span>
<span class="udiff-line-modified-added">+ JSValue JSObject::defaultValue(const JSObject* object, JSGlobalObject* globalObject, PreferredPrimitiveType hint)</span>
  {
<span class="udiff-line-modified-removed">-     return object-&gt;ordinaryToPrimitive(exec, hint);</span>
<span class="udiff-line-modified-added">+     return object-&gt;ordinaryToPrimitive(globalObject, hint);</span>
  }
  
<span class="udiff-line-modified-removed">- JSValue JSObject::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const</span>
<span class="udiff-line-modified-added">+ JSValue JSObject::toPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType preferredType) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     JSValue value = callToPrimitiveFunction&lt;TypeHintMode::TakesHint&gt;(exec, this, vm.propertyNames-&gt;toPrimitiveSymbol, preferredType);</span>
<span class="udiff-line-modified-added">+     JSValue value = callToPrimitiveFunction&lt;TypeHintMode::TakesHint&gt;(globalObject, this, vm.propertyNames-&gt;toPrimitiveSymbol, preferredType);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (value)
          return value;
  
<span class="udiff-line-modified-removed">-     RELEASE_AND_RETURN(scope, this-&gt;methodTable(vm)-&gt;defaultValue(this, exec, preferredType));</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, this-&gt;methodTable(vm)-&gt;defaultValue(this, globalObject, preferredType));</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const</span>
<span class="udiff-line-modified-added">+ bool JSObject::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     result = toPrimitive(exec, PreferNumber);</span>
<span class="udiff-line-modified-added">+     result = toPrimitive(globalObject, PreferNumber);</span>
      RETURN_IF_EXCEPTION(scope, false);
      scope.release();
<span class="udiff-line-modified-removed">-     number = result.toNumber(exec);</span>
<span class="udiff-line-modified-added">+     number = result.toNumber(globalObject);</span>
      return !result.isString();
  }
  
  bool JSObject::getOwnStaticPropertySlot(VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2220,139 +2227,133 @@</span>
          }
      }
      return false;
  }
  
<span class="udiff-line-modified-removed">- auto JSObject::findPropertyHashEntry(VM&amp; vm, PropertyName propertyName) const -&gt; Optional&lt;PropertyHashEntry&gt;</span>
<span class="udiff-line-modified-added">+ Optional&lt;Structure::PropertyHashEntry&gt; JSObject::findPropertyHashEntry(VM&amp; vm, PropertyName propertyName) const</span>
  {
<span class="udiff-line-modified-removed">-     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {</span>
<span class="udiff-line-removed">-         if (const HashTable* propHashTable = info-&gt;staticPropHashTable) {</span>
<span class="udiff-line-removed">-             if (const HashTableValue* entry = propHashTable-&gt;entry(propertyName))</span>
<span class="udiff-line-removed">-                 return PropertyHashEntry { propHashTable, entry };</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return WTF::nullopt;</span>
<span class="udiff-line-modified-added">+     return structure(vm)-&gt;findPropertyHashEntry(propertyName);</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::hasInstance(ExecState* exec, JSValue value, JSValue hasInstanceValue)</span>
<span class="udiff-line-modified-added">+ bool JSObject::hasInstance(JSGlobalObject* globalObject, JSValue value, JSValue hasInstanceValue)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     if (!hasInstanceValue.isUndefinedOrNull() &amp;&amp; hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction()) {</span>
<span class="udiff-line-modified-added">+     if (!hasInstanceValue.isUndefinedOrNull() &amp;&amp; hasInstanceValue != globalObject-&gt;functionProtoHasInstanceSymbolFunction()) {</span>
          CallData callData;
          CallType callType = JSC::getCallData(vm, hasInstanceValue, callData);
          if (callType == CallType::None) {
<span class="udiff-line-modified-removed">-             throwException(exec, scope, createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(exec, this));</span>
<span class="udiff-line-modified-added">+             throwException(globalObject, scope, createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(globalObject, this));</span>
              return false;
          }
  
          MarkedArgumentBuffer args;
          args.append(value);
          ASSERT(!args.hasOverflowed());
<span class="udiff-line-modified-removed">-         JSValue result = call(exec, hasInstanceValue, callType, callData, this, args);</span>
<span class="udiff-line-modified-added">+         JSValue result = call(globalObject, hasInstanceValue, callType, callData, this, args);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="udiff-line-modified-removed">-         return result.toBoolean(exec);</span>
<span class="udiff-line-modified-added">+         return result.toBoolean(globalObject);</span>
      }
  
      TypeInfo info = structure(vm)-&gt;typeInfo();
      if (info.implementsDefaultHasInstance()) {
<span class="udiff-line-modified-removed">-         JSValue prototype = get(exec, vm.propertyNames-&gt;prototype);</span>
<span class="udiff-line-modified-added">+         JSValue prototype = get(globalObject, vm.propertyNames-&gt;prototype);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, defaultHasInstance(exec, value, prototype));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, defaultHasInstance(globalObject, value, prototype));</span>
      }
      if (info.implementsHasInstance()) {
          if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="udiff-line-modified-removed">-             throwStackOverflowError(exec, scope);</span>
<span class="udiff-line-modified-added">+             throwStackOverflowError(globalObject, scope);</span>
              return false;
          }
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, methodTable(vm)-&gt;customHasInstance(this, exec, value));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, methodTable(vm)-&gt;customHasInstance(this, globalObject, value));</span>
      }
  
<span class="udiff-line-modified-removed">-     throwException(exec, scope, createInvalidInstanceofParameterErrorNotFunction(exec, this));</span>
<span class="udiff-line-modified-added">+     throwException(globalObject, scope, createInvalidInstanceofParameterErrorNotFunction(globalObject, this));</span>
      return false;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::hasInstance(ExecState* exec, JSValue value)</span>
<span class="udiff-line-modified-added">+ bool JSObject::hasInstance(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     JSValue hasInstanceValue = get(exec, vm.propertyNames-&gt;hasInstanceSymbol);</span>
<span class="udiff-line-modified-added">+     JSValue hasInstanceValue = get(globalObject, vm.propertyNames-&gt;hasInstanceSymbol);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="udiff-line-modified-removed">-     RELEASE_AND_RETURN(scope, hasInstance(exec, value, hasInstanceValue));</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, hasInstance(globalObject, value, hasInstanceValue));</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::defaultHasInstance(ExecState* exec, JSValue value, JSValue proto)</span>
<span class="udiff-line-modified-added">+ bool JSObject::defaultHasInstance(JSGlobalObject* globalObject, JSValue value, JSValue proto)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!value.isObject())
          return false;
  
      if (!proto.isObject()) {
<span class="udiff-line-modified-removed">-         throwTypeError(exec, scope, &quot;instanceof called on an object with an invalid prototype property.&quot;_s);</span>
<span class="udiff-line-modified-added">+         throwTypeError(globalObject, scope, &quot;instanceof called on an object with an invalid prototype property.&quot;_s);</span>
          return false;
      }
  
      JSObject* object = asObject(value);
      while (true) {
<span class="udiff-line-modified-removed">-         JSValue objectValue = object-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+         JSValue objectValue = object-&gt;getPrototype(vm, globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!objectValue.isObject())
              return false;
          object = asObject(objectValue);
          if (proto == object)
              return true;
      }
      ASSERT_NOT_REACHED();
  }
  
<span class="udiff-line-modified-removed">- EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(ExecState* exec)</span>
<span class="udiff-line-modified-added">+ EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="udiff-line-modified-removed">-     JSValue value = exec-&gt;uncheckedArgument(0);</span>
<span class="udiff-line-modified-removed">-     JSValue proto = exec-&gt;uncheckedArgument(1);</span>
<span class="udiff-line-modified-added">+     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
<span class="udiff-line-modified-added">+     JSValue proto = callFrame-&gt;uncheckedArgument(1);</span>
  
<span class="udiff-line-modified-removed">-     return JSValue::encode(jsBoolean(JSObject::defaultHasInstance(exec, value, proto)));</span>
<span class="udiff-line-modified-added">+     return JSValue::encode(jsBoolean(JSObject::defaultHasInstance(globalObject, value, proto)));</span>
  }
  
<span class="udiff-line-modified-removed">- void JSObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
<span class="udiff-line-modified-added">+ void JSObject::getPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, propertyNames, mode);</span>
<span class="udiff-line-modified-added">+     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, propertyNames, mode);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="udiff-line-modified-removed">-     JSValue nextProto = object-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+     JSValue nextProto = object-&gt;getPrototype(vm, globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (nextProto.isNull())
          return;
  
      JSObject* prototype = asObject(nextProto);
      while(1) {
          if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
              scope.release();
<span class="udiff-line-modified-removed">-             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, exec, propertyNames, mode);</span>
<span class="udiff-line-modified-added">+             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, globalObject, propertyNames, mode);</span>
              return;
          }
<span class="udiff-line-modified-removed">-         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, exec, propertyNames, mode);</span>
<span class="udiff-line-modified-added">+         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, globalObject, propertyNames, mode);</span>
          RETURN_IF_EXCEPTION(scope, void());
<span class="udiff-line-modified-removed">-         nextProto = prototype-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+         nextProto = prototype-&gt;getPrototype(vm, globalObject);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (nextProto.isNull())
              break;
          prototype = asObject(nextProto);
      }
  }
  
<span class="udiff-line-modified-removed">- void JSObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
<span class="udiff-line-modified-added">+ void JSObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      if (!mode.includeJSObjectProperties()) {
          // We still have to get non-indexed properties from any subclasses of JSObject that have them.
<span class="udiff-line-modified-removed">-         object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);</span>
<span class="udiff-line-modified-added">+         object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);</span>
          return;
      }
  
      if (propertyNames.includeStringProperties()) {
          // Add numeric properties first. That appears to be the accepted convention.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2417,44 +2418,44 @@</span>
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
<span class="udiff-line-modified-removed">-     object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);</span>
<span class="udiff-line-modified-added">+     object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);</span>
  }
  
<span class="udiff-line-modified-removed">- void JSObject::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
<span class="udiff-line-modified-added">+ void JSObject::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      if (!object-&gt;staticPropertiesReified(vm))
<span class="udiff-line-modified-removed">-         getClassPropertyNames(exec, object-&gt;classInfo(vm), propertyNames, mode);</span>
<span class="udiff-line-modified-added">+         getClassPropertyNames(globalObject, object-&gt;classInfo(vm), propertyNames, mode);</span>
  
      if (!mode.includeJSObjectProperties())
          return;
  
      object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
  }
  
<span class="udiff-line-modified-removed">- double JSObject::toNumber(ExecState* exec) const</span>
<span class="udiff-line-modified-added">+ double JSObject::toNumber(JSGlobalObject* globalObject) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     JSValue primitive = toPrimitive(exec, PreferNumber);</span>
<span class="udiff-line-modified-added">+     JSValue primitive = toPrimitive(globalObject, PreferNumber);</span>
      RETURN_IF_EXCEPTION(scope, 0.0); // should be picked up soon in Nodes.cpp
<span class="udiff-line-modified-removed">-     RELEASE_AND_RETURN(scope, primitive.toNumber(exec));</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, primitive.toNumber(globalObject));</span>
  }
  
<span class="udiff-line-modified-removed">- JSString* JSObject::toString(ExecState* exec) const</span>
<span class="udiff-line-modified-added">+ JSString* JSObject::toString(JSGlobalObject* globalObject) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     JSValue primitive = toPrimitive(exec, PreferString);</span>
<span class="udiff-line-modified-added">+     JSValue primitive = toPrimitive(globalObject, PreferString);</span>
      RETURN_IF_EXCEPTION(scope, jsEmptyString(vm));
<span class="udiff-line-modified-removed">-     RELEASE_AND_RETURN(scope, primitive.toString(exec));</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, primitive.toString(globalObject));</span>
  }
  
<span class="udiff-line-modified-removed">- JSValue JSObject::toThis(JSCell* cell, ExecState*, ECMAMode)</span>
<span class="udiff-line-modified-added">+ JSValue JSObject::toThis(JSCell* cell, JSGlobalObject*, ECMAMode)</span>
  {
      return jsCast&lt;JSObject*&gt;(cell);
  }
  
  void JSObject::seal(VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2471,13 +2472,13 @@</span>
          return;
      enterDictionaryIndexingMode(vm);
      setStructure(vm, Structure::freezeTransition(vm, structure(vm)));
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::preventExtensions(JSObject* object, ExecState* exec)</span>
<span class="udiff-line-modified-added">+ bool JSObject::preventExtensions(JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      if (!object-&gt;isStructureExtensible(vm)) {
          // We&#39;ve already set the internal [[PreventExtensions]] field to false.
          // We don&#39;t call the methodTable isExtensible here because it&#39;s not defined
          // that way in the specification. We are just doing an optimization here.
          return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2486,24 +2487,24 @@</span>
      object-&gt;enterDictionaryIndexingMode(vm);
      object-&gt;setStructure(vm, Structure::preventExtensionsTransition(vm, object-&gt;structure(vm)));
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::isExtensible(JSObject* obj, ExecState* exec)</span>
<span class="udiff-line-modified-added">+ bool JSObject::isExtensible(JSObject* obj, JSGlobalObject* globalObject)</span>
  {
<span class="udiff-line-modified-removed">-     return obj-&gt;isStructureExtensible(exec-&gt;vm());</span>
<span class="udiff-line-modified-added">+     return obj-&gt;isStructureExtensible(globalObject-&gt;vm());</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::isExtensible(ExecState* exec)</span>
<span class="udiff-line-modified-added">+ bool JSObject::isExtensible(JSGlobalObject* globalObject)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     return methodTable(vm)-&gt;isExtensible(this, exec);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="udiff-line-modified-added">+     return methodTable(vm)-&gt;isExtensible(this, globalObject);</span>
  }
  
<span class="udiff-line-modified-removed">- void JSObject::reifyAllStaticProperties(ExecState* exec)</span>
<span class="udiff-line-modified-added">+ void JSObject::reifyAllStaticProperties(JSGlobalObject* globalObject)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      ASSERT(!staticPropertiesReified(vm));
  
      // If this object&#39;s ClassInfo has no static properties, then nothing to reify!
      // We can safely set the flag to avoid the expensive check again in the future.
      if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2541,13 +2542,13 @@</span>
      // This access is cacheable because Structure requires an attributeChangedTransition
      // if this property stops being an accessor.
      slot.setCacheableGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter), offset);
  }
  
<span class="udiff-line-modified-removed">- static bool putIndexedDescriptor(ExecState* exec, SparseArrayValueMap* map, SparseArrayEntry* entryInMap, const PropertyDescriptor&amp; descriptor, PropertyDescriptor&amp; oldDescriptor)</span>
<span class="udiff-line-modified-added">+ static bool putIndexedDescriptor(JSGlobalObject* globalObject, SparseArrayValueMap* map, SparseArrayEntry* entryInMap, const PropertyDescriptor&amp; descriptor, PropertyDescriptor&amp; oldDescriptor)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
  
      if (descriptor.isDataDescriptor()) {
          unsigned attributes = descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::Accessor;
          if (descriptor.value())
              entryInMap-&gt;forceSet(vm, map, descriptor.value(), attributes);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2568,11 +2569,11 @@</span>
          if (descriptor.setterPresent())
              setter = descriptor.setterObject();
          else if (oldDescriptor.isAccessorDescriptor())
              setter = oldDescriptor.setterObject();
  
<span class="udiff-line-modified-removed">-         GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
<span class="udiff-line-modified-added">+         GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
          entryInMap-&gt;forceSet(vm, map, accessor, descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::ReadOnly);
          return true;
      }
  
      ASSERT(descriptor.isGenericDescriptor());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2586,13 +2587,13 @@</span>
          || jsDynamicCast&lt;JSFinalObject*&gt;(vm, object)
          || TypeInfo::isArgumentsType(object-&gt;type());
  }
  
  // Defined in ES5.1 8.12.9
<span class="udiff-line-modified-removed">- bool JSObject::defineOwnIndexedProperty(ExecState* exec, unsigned index, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
<span class="udiff-line-modified-added">+ bool JSObject::defineOwnIndexedProperty(JSGlobalObject* globalObject, unsigned index, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(index &lt;= MAX_ARRAY_INDEX);
  
      ensureWritable(vm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2602,11 +2603,11 @@</span>
          // FIXME: this will pessimistically assume that if attributes are missing then they&#39;ll default to false
          // however if the property currently exists missing attributes will override from their current &#39;true&#39;
          // state (i.e. defineOwnProperty could be used to set a value without needing to entering &#39;SparseMode&#39;).
          if (!descriptor.attributes() &amp;&amp; descriptor.value() &amp;&amp; canDoFastPutDirectIndex(vm, this)) {
              ASSERT(!descriptor.isAccessorDescriptor());
<span class="udiff-line-modified-removed">-             RELEASE_AND_RETURN(scope, putDirectIndex(exec, index, descriptor.value(), 0, throwException ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow));</span>
<span class="udiff-line-modified-added">+             RELEASE_AND_RETURN(scope, putDirectIndex(globalObject, index, descriptor.value(), 0, throwException ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow));</span>
          }
  
          ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2624,11 +2625,11 @@</span>
      // 3. If current is undefined and extensible is false, then Reject.
      // 4. If current is undefined and extensible is true, then
      if (result.isNewEntry) {
          if (!isStructureExtensible(vm)) {
              map-&gt;remove(result.iterator);
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
          }
  
          // 4.a. If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then create an own data property
          // named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values
          // are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2638,43 +2639,43 @@</span>
          // Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property
          // is set to its default value.
          // 4.c. Return true.
  
          PropertyDescriptor defaults(jsUndefined(), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
<span class="udiff-line-modified-removed">-         putIndexedDescriptor(exec, map, entryInMap, descriptor, defaults);</span>
<span class="udiff-line-modified-added">+         putIndexedDescriptor(globalObject, map, entryInMap, descriptor, defaults);</span>
          Butterfly* butterfly = m_butterfly.get();
          if (index &gt;= butterfly-&gt;arrayStorage()-&gt;length())
              butterfly-&gt;arrayStorage()-&gt;setLength(index + 1);
          return true;
      }
  
      // 5. Return true, if every field in Desc is absent.
      // 6. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the same value as the corresponding field in current when compared using the SameValue algorithm (9.12).
      PropertyDescriptor current;
      entryInMap-&gt;get(current);
<span class="udiff-line-modified-removed">-     bool isEmptyOrEqual = descriptor.isEmpty() || descriptor.equalTo(exec, current);</span>
<span class="udiff-line-modified-added">+     bool isEmptyOrEqual = descriptor.isEmpty() || descriptor.equalTo(globalObject, current);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (isEmptyOrEqual)
          return true;
  
      // 7. If the [[Configurable]] field of current is false then
      if (!current.configurable()) {
          // 7.a. Reject, if the [[Configurable]] field of Desc is true.
          if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
          // 7.b. Reject, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.
          if (descriptor.enumerablePresent() &amp;&amp; current.enumerable() != descriptor.enumerable())
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
      }
  
      // 8. If IsGenericDescriptor(Desc) is true, then no further validation is required.
      if (!descriptor.isGenericDescriptor()) {
          // 9. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
          if (current.isDataDescriptor() != descriptor.isDataDescriptor()) {
              // 9.a. Reject, if the [[Configurable]] field of current is false.
              if (!current.configurable())
<span class="udiff-line-modified-removed">-                 return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
<span class="udiff-line-modified-added">+                 return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
              // 9.b. If IsDataDescriptor(current) is true, then convert the property named P of object O from a
              // data property to an accessor property. Preserve the existing values of the converted property&#39;s
              // [[Configurable]] and [[Enumerable]] attributes and set the rest of the property&#39;s attributes to
              // their default values.
              // 9.c. Else, convert the property named P of object O from an accessor property to a data property.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2684,33 +2685,37 @@</span>
              // 10. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
              // 10.a. If the [[Configurable]] field of current is false, then
              if (!current.configurable() &amp;&amp; !current.writable()) {
                  // 10.a.i. Reject, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.
                  if (descriptor.writable())
<span class="udiff-line-modified-removed">-                     return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
<span class="udiff-line-modified-added">+                     return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
                  // 10.a.ii. If the [[Writable]] field of current is false, then
                  // 10.a.ii.1. Reject, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.
<span class="udiff-line-modified-removed">-                 if (descriptor.value() &amp;&amp; !sameValue(exec, descriptor.value(), current.value()))</span>
<span class="udiff-line-modified-removed">-                     return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>
<span class="udiff-line-modified-added">+                 if (descriptor.value()) {</span>
<span class="udiff-line-modified-added">+                     bool isSame = sameValue(globalObject, descriptor.value(), current.value());</span>
<span class="udiff-line-added">+                     RETURN_IF_EXCEPTION(scope, false);</span>
<span class="udiff-line-added">+                     if (!isSame)</span>
<span class="udiff-line-added">+                         return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);</span>
<span class="udiff-line-added">+                 }</span>
              }
              // 10.b. else, the [[Configurable]] field of current is true, so any change is acceptable.
          } else {
              ASSERT(current.isAccessorDescriptor() &amp;&amp; current.getterPresent() &amp;&amp; current.setterPresent());
              // 11. Else, IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true so, if the [[Configurable]] field of current is false, then
              if (!current.configurable()) {
                  // 11.i. Reject, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.
                  if (descriptor.setterPresent() &amp;&amp; descriptor.setter() != current.setter())
<span class="udiff-line-modified-removed">-                     return typeError(exec, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
<span class="udiff-line-modified-added">+                     return typeError(globalObject, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
                  // 11.ii. Reject, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.
                  if (descriptor.getterPresent() &amp;&amp; descriptor.getter() != current.getter())
<span class="udiff-line-modified-removed">-                     return typeError(exec, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
<span class="udiff-line-modified-added">+                     return typeError(globalObject, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
              }
          }
      }
  
      // 12. For each attribute field of Desc that is present, set the correspondingly named attribute of the property named P of object O to the value of the field.
<span class="udiff-line-modified-removed">-     putIndexedDescriptor(exec, map, entryInMap, descriptor, current);</span>
<span class="udiff-line-modified-added">+     putIndexedDescriptor(globalObject, map, entryInMap, descriptor, current);</span>
      // 13. Return true.
      return true;
  }
  
  SparseArrayValueMap* JSObject::allocateSparseIndexMap(VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2724,13 +2729,13 @@</span>
  {
      if (ArrayStorage* arrayStorage = arrayStorageOrNull())
          arrayStorage-&gt;m_sparseMap.clear();
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(ExecState* exec, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
<span class="udiff-line-modified-added">+ bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(JSGlobalObject* globalObject, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      for (JSObject* current = this; ;) {
          // This has the same behavior with respect to prototypes as JSObject::put(). It only
          // allows a prototype to intercept a put if (a) the prototype declares the property
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2740,48 +2745,48 @@</span>
          ArrayStorage* storage = current-&gt;arrayStorageOrNull();
          if (storage &amp;&amp; storage-&gt;m_sparseMap) {
              SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
              if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
                  scope.release();
<span class="udiff-line-modified-removed">-                 putResult = iter-&gt;value.put(exec, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);</span>
<span class="udiff-line-modified-added">+                 putResult = iter-&gt;value.put(globalObject, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);</span>
                  return true;
              }
          }
  
          if (current-&gt;type() == ProxyObjectType) {
              scope.release();
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
<span class="udiff-line-modified-removed">-             putResult = proxy-&gt;putByIndexCommon(exec, thisValue, i, value, shouldThrow);</span>
<span class="udiff-line-modified-added">+             putResult = proxy-&gt;putByIndexCommon(globalObject, thisValue, i, value, shouldThrow);</span>
              return true;
          }
  
<span class="udiff-line-modified-removed">-         JSValue prototypeValue = current-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+         JSValue prototypeValue = current-&gt;getPrototype(vm, globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (prototypeValue.isNull())
              return false;
  
          current = asObject(prototypeValue);
      }
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::attemptToInterceptPutByIndexOnHole(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
<span class="udiff-line-modified-added">+ bool JSObject::attemptToInterceptPutByIndexOnHole(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     JSValue prototypeValue = getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+     JSValue prototypeValue = getPrototype(vm, globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (prototypeValue.isNull())
          return false;
  
<span class="udiff-line-modified-removed">-     RELEASE_AND_RETURN(scope, asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(exec, this, i, value, shouldThrow, putResult));</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(scope, asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(globalObject, this, i, value, shouldThrow, putResult));</span>
  }
  
  template&lt;IndexingType indexingShape&gt;
<span class="udiff-line-modified-removed">- bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(ExecState* exec, unsigned i, JSValue value)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(JSGlobalObject* globalObject, unsigned i, JSValue value)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
      ASSERT((indexingType() &amp; IndexingShapeMask) == indexingShape);
      ASSERT(!indexingShouldBeSparse(vm));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2796,19 +2801,19 @@</span>
          || (i &gt;= MIN_SPARSE_ARRAY_INDEX &amp;&amp; !isDenseEnoughForVector(i, countElements&lt;indexingShape&gt;(butterfly)))
          || indexIsSufficientlyBeyondLengthForSparseMap(i, butterfly-&gt;vectorLength())) {
          ASSERT(i &lt;= MAX_ARRAY_INDEX);
          ensureArrayStorageSlow(vm);
          SparseArrayValueMap* map = allocateSparseIndexMap(vm);
<span class="udiff-line-modified-removed">-         bool result = map-&gt;putEntry(exec, this, i, value, false);</span>
<span class="udiff-line-modified-added">+         bool result = map-&gt;putEntry(globalObject, this, i, value, false);</span>
          RETURN_IF_EXCEPTION(scope, false);
          ASSERT(i &gt;= arrayStorage()-&gt;length());
          arrayStorage()-&gt;setLength(i + 1);
          return result;
      }
  
      if (!ensureLength(vm, i + 1)) {
<span class="udiff-line-modified-removed">-         throwOutOfMemoryError(exec, scope);</span>
<span class="udiff-line-modified-added">+         throwOutOfMemoryError(globalObject, scope);</span>
          return false;
      }
      butterfly = m_butterfly.get();
  
      RELEASE_ASSERT(i &lt; butterfly-&gt;vectorLength());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2835,17 +2840,17 @@</span>
          return false;
      }
  }
  
  // Explicit instantiations needed by JSArray.cpp.
<span class="udiff-line-modified-removed">- template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(ExecState*, unsigned, JSValue);</span>
<span class="udiff-line-modified-removed">- template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(ExecState*, unsigned, JSValue);</span>
<span class="udiff-line-modified-removed">- template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(ExecState*, unsigned, JSValue);</span>
<span class="udiff-line-modified-added">+ template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(JSGlobalObject*, unsigned, JSValue);</span>
<span class="udiff-line-modified-added">+ template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(JSGlobalObject*, unsigned, JSValue);</span>
<span class="udiff-line-modified-added">+ template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(JSGlobalObject*, unsigned, JSValue);</span>
  
<span class="udiff-line-modified-removed">- bool JSObject::putByIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, ArrayStorage* storage)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putByIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow, ArrayStorage* storage)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!isCopyOnWrite(indexingMode()));
      // i should be a valid array index that is outside of the current vector.
      ASSERT(i &lt;= MAX_ARRAY_INDEX);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2872,28 +2877,28 @@</span>
              ++storage-&gt;m_numValuesInVector;
              return true;
          }
          // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
          map = allocateSparseIndexMap(vm);
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, map-&gt;putEntry(exec, this, i, value, shouldThrow));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, map-&gt;putEntry(globalObject, this, i, value, shouldThrow));</span>
      }
  
      // Update m_length if necessary.
      unsigned length = storage-&gt;length();
      if (i &gt;= length) {
          // Prohibit growing the array if length is not writable.
          if (map-&gt;lengthIsReadOnly() || !isStructureExtensible(vm))
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
          length = i + 1;
          storage-&gt;setLength(length);
      }
  
      // We are currently using a map - check whether we still want to be doing so.
      // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
      unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
      if (map-&gt;sparseMode() || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, map-&gt;putEntry(exec, this, i, value, shouldThrow));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, map-&gt;putEntry(globalObject, this, i, value, shouldThrow));</span>
  
      // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
      storage = arrayStorage();
      storage-&gt;m_numValuesInVector = numValuesInArray;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2910,13 +2915,13 @@</span>
          ++storage-&gt;m_numValuesInVector;
      valueSlot.set(vm, this, value);
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putByIndexBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, bool shouldThrow)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putByIndexBeyondVectorLength(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
  
      // i should be a valid array index that is outside of the current vector.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2924,20 +2929,20 @@</span>
  
      switch (indexingType()) {
      case ALL_BLANK_INDEXING_TYPES: {
          if (indexingShouldBeSparse(vm)) {
              RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(
<span class="udiff-line-modified-removed">-                 exec, i, value, shouldThrow,</span>
<span class="udiff-line-modified-added">+                 globalObject, i, value, shouldThrow,</span>
                  ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm)));
          }
          if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="udiff-line-modified-removed">-             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, createArrayStorage(vm, 0, 0)));</span>
<span class="udiff-line-modified-added">+             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, shouldThrow, createArrayStorage(vm, 0, 0)));</span>
          }
          if (needsSlowPutIndexing(vm)) {
              // Convert the indexing type to the SlowPutArrayStorage and retry.
              createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="udiff-line-modified-removed">-             RELEASE_AND_RETURN(scope, putByIndex(this, exec, i, value, shouldThrow));</span>
<span class="udiff-line-modified-added">+             RELEASE_AND_RETURN(scope, putByIndex(this, globalObject, i, value, shouldThrow));</span>
          }
  
          createInitialForValueAndSet(vm, i, value);
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2946,45 +2951,45 @@</span>
          CRASH();
          break;
      }
  
      case ALL_INT32_INDEXING_TYPES:
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(globalObject, i, value));</span>
  
      case ALL_DOUBLE_INDEXING_TYPES:
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(globalObject, i, value));</span>
  
      case ALL_CONTIGUOUS_INDEXING_TYPES:
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(globalObject, i, value));</span>
  
      case NonArrayWithSlowPutArrayStorage:
      case ArrayWithSlowPutArrayStorage: {
          // No own property present in the vector, but there might be in the sparse map!
          SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
          bool putResult = false;
          if (!(map &amp;&amp; map-&gt;contains(i))) {
<span class="udiff-line-modified-removed">-             bool result = attemptToInterceptPutByIndexOnHole(exec, i, value, shouldThrow, putResult);</span>
<span class="udiff-line-modified-added">+             bool result = attemptToInterceptPutByIndexOnHole(globalObject, i, value, shouldThrow, putResult);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (result)
                  return putResult;
          }
          FALLTHROUGH;
      }
  
      case NonArrayWithArrayStorage:
      case ArrayWithArrayStorage:
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, arrayStorage()));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, shouldThrow, arrayStorage()));</span>
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
      return false;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // i should be a valid array index that is outside of the current vector.
      ASSERT(hasAnyArrayStorage(indexingType()));
      ASSERT(arrayStorage() == storage);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3014,32 +3019,32 @@</span>
              ++storage-&gt;m_numValuesInVector;
              return true;
          }
          // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
          map = allocateSparseIndexMap(vm);
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, map-&gt;putDirect(exec, this, i, value, attributes, mode));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, map-&gt;putDirect(globalObject, this, i, value, attributes, mode));</span>
      }
  
      // Update m_length if necessary.
      unsigned length = storage-&gt;length();
      if (i &gt;= length) {
          if (mode != PutDirectIndexLikePutDirect) {
              // Prohibit growing the array if length is not writable.
              if (map-&gt;lengthIsReadOnly())
<span class="udiff-line-modified-removed">-                 return typeError(exec, scope, mode == PutDirectIndexShouldThrow, ReadonlyPropertyWriteError);</span>
<span class="udiff-line-modified-added">+                 return typeError(globalObject, scope, mode == PutDirectIndexShouldThrow, ReadonlyPropertyWriteError);</span>
              if (!isStructureExtensible(vm))
<span class="udiff-line-modified-removed">-                 return typeError(exec, scope, mode == PutDirectIndexShouldThrow, NonExtensibleObjectPropertyDefineError);</span>
<span class="udiff-line-modified-added">+                 return typeError(globalObject, scope, mode == PutDirectIndexShouldThrow, NonExtensibleObjectPropertyDefineError);</span>
          }
          length = i + 1;
          storage-&gt;setLength(length);
      }
  
      // We are currently using a map - check whether we still want to be doing so.
      // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
      unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
      if (map-&gt;sparseMode() || attributes || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, map-&gt;putDirect(exec, this, i, value, attributes, mode));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, map-&gt;putDirect(globalObject, this, i, value, attributes, mode));</span>
  
      // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
      storage = arrayStorage();
      storage-&gt;m_numValuesInVector = numValuesInArray;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3056,19 +3061,19 @@</span>
          ++storage-&gt;m_numValuesInVector;
      valueSlot.set(vm, this, value);
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putDirectIndexSlowOrBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putDirectIndexSlowOrBeyondVectorLength(JSGlobalObject* globalObject, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      ASSERT(!value.isCustomGetterSetter());
  
      if (!canDoFastPutDirectIndex(vm, this)) {
          PropertyDescriptor descriptor;
          descriptor.setDescriptor(value, attributes);
<span class="udiff-line-modified-removed">-         return methodTable(vm)-&gt;defineOwnProperty(this, exec, Identifier::from(vm, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
<span class="udiff-line-modified-added">+         return methodTable(vm)-&gt;defineOwnProperty(this, globalObject, Identifier::from(vm, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
      }
  
      // i should be a valid array index that is outside of the current vector.
      ASSERT(i &lt;= MAX_ARRAY_INDEX);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3077,16 +3082,16 @@</span>
  
      switch (indexingType()) {
      case ALL_BLANK_INDEXING_TYPES: {
          if (indexingShouldBeSparse(vm) || attributes) {
              return putDirectIndexBeyondVectorLengthWithArrayStorage(
<span class="udiff-line-modified-removed">-                 exec, i, value, attributes, mode,</span>
<span class="udiff-line-modified-added">+                 globalObject, i, value, attributes, mode,</span>
                  ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
          }
          if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
              return putDirectIndexBeyondVectorLengthWithArrayStorage(
<span class="udiff-line-modified-removed">-                 exec, i, value, attributes, mode, createArrayStorage(vm, 0, 0));</span>
<span class="udiff-line-modified-added">+                 globalObject, i, value, attributes, mode, createArrayStorage(vm, 0, 0));</span>
          }
          if (needsSlowPutIndexing(vm)) {
              ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
              storage-&gt;m_vector[i].set(vm, this, value);
              storage-&gt;m_numValuesInVector++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3098,54 +3103,54 @@</span>
      }
  
      case ALL_UNDECIDED_INDEXING_TYPES: {
          convertUndecidedForValue(vm, value);
          // Reloop.
<span class="udiff-line-modified-removed">-         return putDirectIndex(exec, i, value, attributes, mode);</span>
<span class="udiff-line-modified-added">+         return putDirectIndex(globalObject, i, value, attributes, mode);</span>
      }
  
      case ALL_INT32_INDEXING_TYPES: {
          ASSERT(!indexingShouldBeSparse(vm));
          if (attributes)
<span class="udiff-line-modified-removed">-             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="udiff-line-modified-added">+             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
          if (!value.isInt32()) {
              convertInt32ForValue(vm, value);
<span class="udiff-line-modified-removed">-             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);</span>
<span class="udiff-line-modified-added">+             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);</span>
          }
<span class="udiff-line-modified-removed">-         putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value);</span>
<span class="udiff-line-modified-added">+         putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(globalObject, i, value);</span>
          return true;
      }
  
      case ALL_DOUBLE_INDEXING_TYPES: {
          ASSERT(!indexingShouldBeSparse(vm));
          if (attributes)
<span class="udiff-line-modified-removed">-             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="udiff-line-modified-added">+             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
          if (!value.isNumber()) {
              convertDoubleToContiguous(vm);
<span class="udiff-line-modified-removed">-             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);</span>
<span class="udiff-line-modified-added">+             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);</span>
          }
          double valueAsDouble = value.asNumber();
          if (valueAsDouble != valueAsDouble) {
              convertDoubleToContiguous(vm);
<span class="udiff-line-modified-removed">-             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);</span>
<span class="udiff-line-modified-added">+             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);</span>
          }
<span class="udiff-line-modified-removed">-         putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value);</span>
<span class="udiff-line-modified-added">+         putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(globalObject, i, value);</span>
          return true;
      }
  
      case ALL_CONTIGUOUS_INDEXING_TYPES: {
          ASSERT(!indexingShouldBeSparse(vm));
          if (attributes)
<span class="udiff-line-modified-removed">-             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="udiff-line-modified-removed">-         putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value);</span>
<span class="udiff-line-modified-added">+             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="udiff-line-modified-added">+         putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(globalObject, i, value);</span>
          return true;
      }
  
      case ALL_ARRAY_STORAGE_INDEXING_TYPES:
          if (attributes)
<span class="udiff-line-modified-removed">-             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="udiff-line-modified-removed">-         return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, arrayStorage());</span>
<span class="udiff-line-modified-added">+             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="udiff-line-modified-added">+         return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, arrayStorage());</span>
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
          return false;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3429,10 +3434,11 @@</span>
  void JSObject::reallocateAndShrinkButterfly(VM&amp; vm, unsigned length)
  {
      ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
      ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
      ASSERT(m_butterfly-&gt;vectorLength() &gt; length);
<span class="udiff-line-added">+     ASSERT(m_butterfly-&gt;publicLength() &gt;= length);</span>
      ASSERT(!m_butterfly-&gt;indexingHeader()-&gt;preCapacity(structure(vm)));
  
      DeferGC deferGC(vm.heap);
      Butterfly* newButterfly = butterfly()-&gt;resizeArray(vm, this, structure(vm), 0, ArrayStorage::sizeFor(length));
      newButterfly-&gt;setVectorLength(length);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3450,29 +3456,29 @@</span>
      // capacity, since we might have already mutated the structure in-place.
  
      return Butterfly::createOrGrowPropertyStorage(butterfly(), vm, this, structure(vm), oldSize, newSize);
  }
  
<span class="udiff-line-modified-removed">- static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(ExecState* exec, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)</span>
<span class="udiff-line-modified-added">+ static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(JSGlobalObject* globalObject, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto key = std::make_pair(getterSetter, (int)type);
      JSCustomGetterSetterFunction* customGetterSetterFunction = vm.customGetterSetterFunctionMap.get(key);
      if (!customGetterSetterFunction) {
<span class="udiff-line-modified-removed">-         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, exec-&gt;lexicalGlobalObject(), getterSetter, type, propertyName.publicName());</span>
<span class="udiff-line-modified-added">+         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, globalObject, getterSetter, type, propertyName.publicName());</span>
          vm.customGetterSetterFunctionMap.set(key, customGetterSetterFunction);
      }
      return customGetterSetterFunction;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::getOwnPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
<span class="udiff-line-modified-added">+ bool JSObject::getOwnPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
  
<span class="udiff-line-modified-removed">-     bool result = methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+     bool result = methodTable(vm)-&gt;getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !result);
      if (!result)
          return false;
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3506,11 +3512,11 @@</span>
          if (slot.isCustomAccessor())
              getterSetter = slot.customGetterSetter();
          else {
              JSValue maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
              if (!maybeGetterSetter) {
<span class="udiff-line-modified-removed">-                 thisObject-&gt;reifyAllStaticProperties(exec);</span>
<span class="udiff-line-modified-added">+                 thisObject-&gt;reifyAllStaticProperties(globalObject);</span>
                  maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
              }
  
              ASSERT(maybeGetterSetter);
              getterSetter = jsDynamicCast&lt;CustomGetterSetter*&gt;(vm, maybeGetterSetter);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3518,31 +3524,31 @@</span>
          ASSERT(getterSetter);
          if (!getterSetter)
              return false;
  
          if (getterSetter-&gt;getter())
<span class="udiff-line-modified-removed">-             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));</span>
<span class="udiff-line-modified-added">+             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));</span>
          if (getterSetter-&gt;setter())
<span class="udiff-line-modified-removed">-             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));</span>
<span class="udiff-line-modified-added">+             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));</span>
      } else {
<span class="udiff-line-modified-removed">-         JSValue value = slot.getValue(exec, propertyName);</span>
<span class="udiff-line-modified-added">+         JSValue value = slot.getValue(globalObject, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, false);
          descriptor.setDescriptor(value, slot.attributes());
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- static bool putDescriptor(ExecState* exec, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)</span>
<span class="udiff-line-modified-added">+ static bool putDescriptor(JSGlobalObject* globalObject, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      if (descriptor.isGenericDescriptor() || descriptor.isDataDescriptor()) {
          if (descriptor.isGenericDescriptor() &amp;&amp; oldDescriptor.isAccessorDescriptor()) {
              JSObject* getter = oldDescriptor.getterPresent() ? oldDescriptor.getterObject() : nullptr;
              JSObject* setter = oldDescriptor.setterPresent() ? oldDescriptor.setterObject() : nullptr;
<span class="udiff-line-modified-removed">-             GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
<span class="udiff-line-modified-removed">-             target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
<span class="udiff-line-modified-added">+             GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
<span class="udiff-line-modified-added">+             target-&gt;putDirectAccessor(globalObject, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
              return true;
          }
          JSValue newValue = jsUndefined();
          if (descriptor.value())
              newValue = descriptor.value();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3559,119 +3565,123 @@</span>
          ? descriptor.getterObject() : oldDescriptor.getterPresent()
          ? oldDescriptor.getterObject() : nullptr;
      JSObject* setter = descriptor.setterPresent()
          ? descriptor.setterObject() : oldDescriptor.setterPresent()
          ? oldDescriptor.setterObject() : nullptr;
<span class="udiff-line-modified-removed">-     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
<span class="udiff-line-modified-added">+     GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
  
<span class="udiff-line-modified-removed">-     target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
<span class="udiff-line-modified-added">+     target-&gt;putDirectAccessor(globalObject, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::putDirectMayBeIndex(ExecState* exec, PropertyName propertyName, JSValue value)</span>
<span class="udiff-line-modified-added">+ bool JSObject::putDirectMayBeIndex(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value)</span>
  {
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="udiff-line-modified-removed">-         return putDirectIndex(exec, index.value(), value);</span>
<span class="udiff-line-modified-removed">-     return putDirect(exec-&gt;vm(), propertyName, value);</span>
<span class="udiff-line-modified-added">+         return putDirectIndex(globalObject, index.value(), value);</span>
<span class="udiff-line-modified-added">+     return putDirect(globalObject-&gt;vm(), propertyName, value);</span>
  }
  
  // 9.1.6.3 of the spec
  // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-validateandapplypropertydescriptor
<span class="udiff-line-modified-removed">- bool validateAndApplyPropertyDescriptor(ExecState* exec, JSObject* object, PropertyName propertyName, bool isExtensible,</span>
<span class="udiff-line-modified-added">+ bool validateAndApplyPropertyDescriptor(JSGlobalObject* globalObject, JSObject* object, PropertyName propertyName, bool isExtensible,</span>
      const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException)
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // If we have a new property we can just put it on normally
      // Step 2.
      if (!isCurrentDefined) {
          // unless extensions are prevented!
          // Step 2.a
          if (!isExtensible)
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
          if (!object)
              return true;
          // Step 2.c/d
          PropertyDescriptor oldDescriptor;
          oldDescriptor.setValue(jsUndefined());
          // FIXME: spec says to always return true here.
<span class="udiff-line-modified-removed">-         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributes(), oldDescriptor);</span>
<span class="udiff-line-modified-added">+         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributes(), oldDescriptor);</span>
      }
      // Step 3.
      if (descriptor.isEmpty())
          return true;
      // Step 4.
<span class="udiff-line-modified-removed">-     bool isEqual = current.equalTo(exec, descriptor);</span>
<span class="udiff-line-modified-added">+     bool isEqual = current.equalTo(globalObject, descriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (isEqual)
          return true;
  
      // Step 5.
      // Filter out invalid changes
      if (!current.configurable()) {
          if (descriptor.configurable())
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
          if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable() != current.enumerable())
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
      }
  
      // Step 6.
      // A generic descriptor is simply changing the attributes of an existing property
      if (descriptor.isGenericDescriptor()) {
          if (!current.attributesEqual(descriptor) &amp;&amp; object) {
<span class="udiff-line-modified-removed">-             object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
<span class="udiff-line-modified-added">+             object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
              RETURN_IF_EXCEPTION(scope, false);
<span class="udiff-line-modified-removed">-             return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
<span class="udiff-line-modified-added">+             return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
          }
          return true;
      }
  
      // Step 7.
      // Changing between a normal property or an accessor property
      if (descriptor.isDataDescriptor() != current.isDataDescriptor()) {
          if (!current.configurable())
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
  
          if (!object)
              return true;
  
<span class="udiff-line-modified-removed">-         object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
<span class="udiff-line-modified-added">+         object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="udiff-line-modified-removed">-         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
<span class="udiff-line-modified-added">+         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
      }
  
      // Step 8.
      // Changing the value and attributes of an existing property
      if (descriptor.isDataDescriptor()) {
          if (!current.configurable()) {
              if (!current.writable() &amp;&amp; descriptor.writable())
<span class="udiff-line-modified-removed">-                 return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
<span class="udiff-line-modified-added">+                 return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
              if (!current.writable()) {
<span class="udiff-line-modified-removed">-                 if (descriptor.value() &amp;&amp; !sameValue(exec, current.value(), descriptor.value()))</span>
<span class="udiff-line-modified-removed">-                     return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>
<span class="udiff-line-modified-added">+                 if (descriptor.value()) {</span>
<span class="udiff-line-modified-added">+                     bool isSame = sameValue(globalObject, current.value(), descriptor.value());</span>
<span class="udiff-line-added">+                     RETURN_IF_EXCEPTION(scope, false);</span>
<span class="udiff-line-added">+                     if (!isSame)</span>
<span class="udiff-line-added">+                         return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);</span>
<span class="udiff-line-added">+                 }</span>
              }
          }
          if (current.attributesEqual(descriptor) &amp;&amp; !descriptor.value())
              return true;
          if (!object)
              return true;
<span class="udiff-line-modified-removed">-         object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
<span class="udiff-line-modified-added">+         object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="udiff-line-modified-removed">-         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
<span class="udiff-line-modified-added">+         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
      }
  
      // Step 9.
      // Changing the accessor functions of an existing accessor property
      ASSERT(descriptor.isAccessorDescriptor());
      if (!current.configurable()) {
<span class="udiff-line-modified-removed">-         if (descriptor.setterPresent() &amp;&amp; !(current.setterPresent() &amp;&amp; JSValue::strictEqual(exec, current.setter(), descriptor.setter())))</span>
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
<span class="udiff-line-modified-removed">-         if (descriptor.getterPresent() &amp;&amp; !(current.getterPresent() &amp;&amp; JSValue::strictEqual(exec, current.getter(), descriptor.getter())))</span>
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
<span class="udiff-line-modified-added">+         if (descriptor.setterPresent() &amp;&amp; !(current.setterPresent() &amp;&amp; JSValue::strictEqual(globalObject, current.setter(), descriptor.setter())))</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
<span class="udiff-line-modified-added">+         if (descriptor.getterPresent() &amp;&amp; !(current.getterPresent() &amp;&amp; JSValue::strictEqual(globalObject, current.getter(), descriptor.getter())))</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
          if (current.attributes() &amp; PropertyAttribute::CustomAccessor)
<span class="udiff-line-modified-removed">-             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
<span class="udiff-line-modified-added">+             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
      }
  
      // Step 10/11.
      if (!object)
          return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3683,13 +3693,13 @@</span>
      bool getterSetterChanged = false;
  
      if (accessor.isCustomGetterSetter()) {
          auto* customGetterSetter = jsCast&lt;CustomGetterSetter*&gt;(accessor);
          if (customGetterSetter-&gt;setter())
<span class="udiff-line-modified-removed">-             setter = getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Setter);</span>
<span class="udiff-line-modified-added">+             setter = getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Setter);</span>
          if (customGetterSetter-&gt;getter())
<span class="udiff-line-modified-removed">-             getter = getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Getter);</span>
<span class="udiff-line-modified-added">+             getter = getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Getter);</span>
      } else {
          ASSERT(accessor.isGetterSetter());
          auto* getterSetter = jsCast&lt;GetterSetter*&gt;(accessor);
          getter = getterSetter-&gt;getter();
          setter = getterSetter-&gt;setter();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3704,50 +3714,51 @@</span>
      }
  
      if (current.attributesEqual(descriptor) &amp;&amp; !getterSetterChanged)
          return true;
  
<span class="udiff-line-modified-removed">-     GetterSetter* getterSetter = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
<span class="udiff-line-modified-added">+     GetterSetter* getterSetter = GetterSetter::create(vm, globalObject, getter, setter);</span>
  
<span class="udiff-line-modified-removed">-     object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
<span class="udiff-line-modified-added">+     object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
      RETURN_IF_EXCEPTION(scope, false);
      unsigned attrs = descriptor.attributesOverridingCurrent(current);
<span class="udiff-line-modified-removed">-     object-&gt;putDirectAccessor(exec, propertyName, getterSetter, attrs | PropertyAttribute::Accessor);</span>
<span class="udiff-line-modified-added">+     object-&gt;putDirectAccessor(globalObject, propertyName, getterSetter, attrs | PropertyAttribute::Accessor);</span>
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::defineOwnNonIndexProperty(ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
<span class="udiff-line-modified-added">+ bool JSObject::defineOwnNonIndexProperty(JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm  = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm  = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      // Track on the globaldata that we&#39;re in define property.
      // Currently DefineOwnProperty uses delete to remove properties when they are being replaced
      // (particularly when changing attributes), however delete won&#39;t allow non-configurable (i.e.
      // DontDelete) properties to be deleted. For now, we can use this flag to make this work.
      VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
      PropertyDescriptor current;
<span class="udiff-line-modified-removed">-     bool isCurrentDefined = getOwnPropertyDescriptor(exec, propertyName, current);</span>
<span class="udiff-line-modified-removed">-     bool isExtensible = this-&gt;isExtensible(exec);</span>
<span class="udiff-line-modified-added">+     bool isCurrentDefined = getOwnPropertyDescriptor(globalObject, propertyName, current);</span>
<span class="udiff-line-modified-added">+     RETURN_IF_EXCEPTION(throwScope, false);</span>
<span class="udiff-line-added">+     bool isExtensible = this-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(throwScope, false);
<span class="udiff-line-modified-removed">-     RELEASE_AND_RETURN(throwScope, validateAndApplyPropertyDescriptor(exec, this, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));</span>
<span class="udiff-line-modified-added">+     RELEASE_AND_RETURN(throwScope, validateAndApplyPropertyDescriptor(globalObject, this, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
<span class="udiff-line-modified-added">+ bool JSObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
  {
      // If it&#39;s an array index, then use the indexed property storage.
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
          // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
          // d. Reject if succeeded is false.
          // e. If index &gt;= oldLen
          // e.i. Set oldLenDesc.[[Value]] to index + 1.
          // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
          // f. Return true.
<span class="udiff-line-modified-removed">-         return object-&gt;defineOwnIndexedProperty(exec, index.value(), descriptor, throwException);</span>
<span class="udiff-line-modified-added">+         return object-&gt;defineOwnIndexedProperty(globalObject, index.value(), descriptor, throwException);</span>
      }
  
<span class="udiff-line-modified-removed">-     return object-&gt;defineOwnNonIndexProperty(exec, propertyName, descriptor, throwException);</span>
<span class="udiff-line-modified-added">+     return object-&gt;defineOwnNonIndexProperty(globalObject, propertyName, descriptor, throwException);</span>
  }
  
  void JSObject::convertToDictionary(VM&amp; vm)
  {
      DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure(vm));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3777,18 +3788,18 @@</span>
  
      // No need to copy the precapacity.
      void* currentBase = oldButterfly-&gt;base(0, outOfLineCapacityAfter);
      void* newBase = newButterfly-&gt;base(0, outOfLineCapacityAfter);
  
<span class="udiff-line-modified-removed">-     memcpy(newBase, currentBase, Butterfly::totalSize(0, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes));</span>
<span class="udiff-line-modified-added">+     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(newBase), static_cast&lt;JSValue*&gt;(currentBase), Butterfly::totalSize(0, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes));</span>
  
      setButterfly(vm, newButterfly);
  }
  
<span class="udiff-line-modified-removed">- uint32_t JSObject::getEnumerableLength(ExecState* exec, JSObject* object)</span>
<span class="udiff-line-modified-added">+ uint32_t JSObject::getEnumerableLength(JSGlobalObject* globalObject, JSObject* object)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      Structure* structure = object-&gt;structure(vm);
      if (structure-&gt;holesMustForwardToPrototype(vm, object))
          return 0;
      switch (object-&gt;indexingType()) {
      case ALL_BLANK_INDEXING_TYPES:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3834,66 +3845,66 @@</span>
          RELEASE_ASSERT_NOT_REACHED();
          return 0;
      }
  }
  
<span class="udiff-line-modified-removed">- void JSObject::getStructurePropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
<span class="udiff-line-modified-added">+ void JSObject::getStructurePropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
  }
  
<span class="udiff-line-modified-removed">- void JSObject::getGenericPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
<span class="udiff-line-modified-added">+ void JSObject::getGenericPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, propertyNames, EnumerationMode(mode, JSObjectPropertiesMode::Exclude));</span>
<span class="udiff-line-modified-added">+     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, propertyNames, EnumerationMode(mode, JSObjectPropertiesMode::Exclude));</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="udiff-line-modified-removed">-     JSValue nextProto = object-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+     JSValue nextProto = object-&gt;getPrototype(vm, globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (nextProto.isNull())
          return;
  
      JSObject* prototype = asObject(nextProto);
      while (true) {
          if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
              scope.release();
<span class="udiff-line-modified-removed">-             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, exec, propertyNames, mode);</span>
<span class="udiff-line-modified-added">+             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, globalObject, propertyNames, mode);</span>
              return;
          }
<span class="udiff-line-modified-removed">-         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, exec, propertyNames, mode);</span>
<span class="udiff-line-modified-added">+         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, globalObject, propertyNames, mode);</span>
          RETURN_IF_EXCEPTION(scope, void());
<span class="udiff-line-modified-removed">-         nextProto = prototype-&gt;getPrototype(vm, exec);</span>
<span class="udiff-line-modified-added">+         nextProto = prototype-&gt;getPrototype(vm, globalObject);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (nextProto.isNull())
              break;
          prototype = asObject(nextProto);
      }
  }
  
  // Implements GetMethod(O, P) in section 7.3.9 of the spec.
  // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-getmethod
<span class="udiff-line-modified-removed">- JSValue JSObject::getMethod(ExecState* exec, CallData&amp; callData, CallType&amp; callType, const Identifier&amp; ident, const String&amp; errorMessage)</span>
<span class="udiff-line-modified-added">+ JSValue JSObject::getMethod(JSGlobalObject* globalObject, CallData&amp; callData, CallType&amp; callType, const Identifier&amp; ident, const String&amp; errorMessage)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     JSValue method = get(exec, ident);</span>
<span class="udiff-line-modified-added">+     JSValue method = get(globalObject, ident);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      if (!method.isCell()) {
          if (method.isUndefinedOrNull())
              return jsUndefined();
  
<span class="udiff-line-modified-removed">-         throwVMTypeError(exec, scope, errorMessage);</span>
<span class="udiff-line-modified-added">+         throwVMTypeError(globalObject, scope, errorMessage);</span>
          return jsUndefined();
      }
  
      callType = method.asCell()-&gt;methodTable(vm)-&gt;getCallData(method.asCell(), callData);
      if (callType == CallType::None) {
<span class="udiff-line-modified-removed">-         throwVMTypeError(exec, scope, errorMessage);</span>
<span class="udiff-line-modified-added">+         throwVMTypeError(globalObject, scope, errorMessage);</span>
          return jsUndefined();
      }
  
      return method;
  }
</pre>
<center><a href="JSONObject.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
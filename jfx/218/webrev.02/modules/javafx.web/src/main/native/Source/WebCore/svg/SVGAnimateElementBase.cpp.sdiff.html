<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateElementBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGAngleValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimateElementBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateElementBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58 {
 59     if (!targetElement() || hasInvalidCSSAttributeType())
 60         return false;
 61 
 62     return targetElement()-&gt;isAnimatedAttribute(attributeName());
 63 }
 64 
 65 bool SVGAnimateElementBase::hasInvalidCSSAttributeType() const
 66 {
 67     if (!targetElement())
 68         return false;
 69 
 70     if (!m_hasInvalidCSSAttributeType)
 71         m_hasInvalidCSSAttributeType = hasValidAttributeName() &amp;&amp; attributeType() == AttributeType::CSS &amp;&amp; !isTargetAttributeCSSProperty(targetElement(), attributeName());
 72 
 73     return m_hasInvalidCSSAttributeType.value();
 74 }
 75 
 76 bool SVGAnimateElementBase::isDiscreteAnimator() const
 77 {
<span class="line-modified"> 78     return hasValidAttributeType() &amp;&amp; animatorIfExists() &amp;&amp; animatorIfExists()-&gt;isDiscrete();</span>




 79 }
 80 
 81 void SVGAnimateElementBase::setTargetElement(SVGElement* target)
 82 {
 83     SVGAnimationElement::setTargetElement(target);
 84     resetAnimation();
 85 }
 86 
 87 void SVGAnimateElementBase::setAttributeName(const QualifiedName&amp; attributeName)
 88 {
 89     SVGSMILElement::setAttributeName(attributeName);
 90     resetAnimation();
 91 }
 92 
 93 void SVGAnimateElementBase::resetAnimation()
 94 {
 95     SVGAnimationElement::resetAnimation();
 96     m_animator = nullptr;
 97     m_hasInvalidCSSAttributeType = { };
 98 }
</pre>
<hr />
<pre>
125         return true;
126     }
127     return false;
128 }
129 
130 bool SVGAnimateElementBase::calculateToAtEndOfDurationValue(const String&amp; toAtEndOfDurationString)
131 {
132     if (!targetElement() || toAtEndOfDurationString.isEmpty())
133         return false;
134 
135     if (isDiscreteAnimator())
136         return true;
137 
138     if (auto* animator = this-&gt;animator()) {
139         animator-&gt;setToAtEndOfDurationValue(animateRangeString(toAtEndOfDurationString));
140         return true;
141     }
142     return false;
143 }
144 
<span class="line-modified">145 void SVGAnimateElementBase::resetAnimatedType()</span>
146 {
147     if (!targetElement())
148         return;
149 
150     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))
151         protectedAnimator-&gt;start(targetElement());
152 }
153 
<span class="line-modified">154 void SVGAnimateElementBase::calculateAnimatedValue(float progress, unsigned repeatCount, SVGSMILElement*)</span>
155 {
156     if (!targetElement())
157         return;
158 
159     ASSERT(progress &gt;= 0 &amp;&amp; progress &lt;= 1);
160     if (hasTagName(SVGNames::setTag))
161         progress = 1;
162 
163     if (calcMode() == CalcMode::Discrete)
164         progress = progress &lt; 0.5 ? 0 : 1;
165 
166     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))
167         protectedAnimator-&gt;animate(targetElement(), progress, repeatCount);
168 }
169 
170 void SVGAnimateElementBase::applyResultsToTarget()
171 {
172     if (!targetElement())
173         return;
174 
175     if (auto* animator = this-&gt;animator())
176         animator-&gt;apply(targetElement());
177 }
178 
<span class="line-modified">179 void SVGAnimateElementBase::clearAnimatedType(SVGElement* targetElement)</span>
180 {
181     if (!targetElement)
182         return;
183 
184     if (auto* animator = this-&gt;animatorIfExists())
185         animator-&gt;stop(targetElement);
186 }
187 
188 Optional&lt;float&gt; SVGAnimateElementBase::calculateDistance(const String&amp; fromString, const String&amp; toString)
189 {
190     // FIXME: A return value of float is not enough to support paced animations on lists.
191     if (!targetElement())
192         return { };
193 
194     if (auto* animator = this-&gt;animator())
195         return animator-&gt;calculateDistance(targetElement(), fromString, toString);
196 
197     return { };
198 }
199 
</pre>
</td>
<td>
<hr />
<pre>
 58 {
 59     if (!targetElement() || hasInvalidCSSAttributeType())
 60         return false;
 61 
 62     return targetElement()-&gt;isAnimatedAttribute(attributeName());
 63 }
 64 
 65 bool SVGAnimateElementBase::hasInvalidCSSAttributeType() const
 66 {
 67     if (!targetElement())
 68         return false;
 69 
 70     if (!m_hasInvalidCSSAttributeType)
 71         m_hasInvalidCSSAttributeType = hasValidAttributeName() &amp;&amp; attributeType() == AttributeType::CSS &amp;&amp; !isTargetAttributeCSSProperty(targetElement(), attributeName());
 72 
 73     return m_hasInvalidCSSAttributeType.value();
 74 }
 75 
 76 bool SVGAnimateElementBase::isDiscreteAnimator() const
 77 {
<span class="line-modified"> 78     if (!hasValidAttributeType())</span>
<span class="line-added"> 79         return false;</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81     auto* animator = this-&gt;animator();</span>
<span class="line-added"> 82     return animator &amp;&amp; animator-&gt;isDiscrete();</span>
 83 }
 84 
 85 void SVGAnimateElementBase::setTargetElement(SVGElement* target)
 86 {
 87     SVGAnimationElement::setTargetElement(target);
 88     resetAnimation();
 89 }
 90 
 91 void SVGAnimateElementBase::setAttributeName(const QualifiedName&amp; attributeName)
 92 {
 93     SVGSMILElement::setAttributeName(attributeName);
 94     resetAnimation();
 95 }
 96 
 97 void SVGAnimateElementBase::resetAnimation()
 98 {
 99     SVGAnimationElement::resetAnimation();
100     m_animator = nullptr;
101     m_hasInvalidCSSAttributeType = { };
102 }
</pre>
<hr />
<pre>
129         return true;
130     }
131     return false;
132 }
133 
134 bool SVGAnimateElementBase::calculateToAtEndOfDurationValue(const String&amp; toAtEndOfDurationString)
135 {
136     if (!targetElement() || toAtEndOfDurationString.isEmpty())
137         return false;
138 
139     if (isDiscreteAnimator())
140         return true;
141 
142     if (auto* animator = this-&gt;animator()) {
143         animator-&gt;setToAtEndOfDurationValue(animateRangeString(toAtEndOfDurationString));
144         return true;
145     }
146     return false;
147 }
148 
<span class="line-modified">149 void SVGAnimateElementBase::startAnimation()</span>
150 {
151     if (!targetElement())
152         return;
153 
154     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))
155         protectedAnimator-&gt;start(targetElement());
156 }
157 
<span class="line-modified">158 void SVGAnimateElementBase::calculateAnimatedValue(float progress, unsigned repeatCount)</span>
159 {
160     if (!targetElement())
161         return;
162 
163     ASSERT(progress &gt;= 0 &amp;&amp; progress &lt;= 1);
164     if (hasTagName(SVGNames::setTag))
165         progress = 1;
166 
167     if (calcMode() == CalcMode::Discrete)
168         progress = progress &lt; 0.5 ? 0 : 1;
169 
170     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))
171         protectedAnimator-&gt;animate(targetElement(), progress, repeatCount);
172 }
173 
174 void SVGAnimateElementBase::applyResultsToTarget()
175 {
176     if (!targetElement())
177         return;
178 
179     if (auto* animator = this-&gt;animator())
180         animator-&gt;apply(targetElement());
181 }
182 
<span class="line-modified">183 void SVGAnimateElementBase::stopAnimation(SVGElement* targetElement)</span>
184 {
185     if (!targetElement)
186         return;
187 
188     if (auto* animator = this-&gt;animatorIfExists())
189         animator-&gt;stop(targetElement);
190 }
191 
192 Optional&lt;float&gt; SVGAnimateElementBase::calculateDistance(const String&amp; fromString, const String&amp; toString)
193 {
194     // FIXME: A return value of float is not enough to support paced animations on lists.
195     if (!targetElement())
196         return { };
197 
198     if (auto* animator = this-&gt;animator())
199         return animator-&gt;calculateDistance(targetElement(), fromString, toString);
200 
201     return { };
202 }
203 
</pre>
</td>
</tr>
</table>
<center><a href="SVGAngleValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimateElementBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertNumbers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertNullable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertNumbers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertNumbers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 30 #include &lt;wtf/text/WTFString.h&gt;
 31 
 32 namespace WebCore {
 33 using namespace JSC;
 34 
 35 enum class IntegerConversionConfiguration { Normal, EnforceRange, Clamp };
 36 
 37 static const int32_t kMaxInt32 = 0x7fffffff;
 38 static const int32_t kMinInt32 = -kMaxInt32 - 1;
 39 static const uint32_t kMaxUInt32 = 0xffffffffU;
 40 static const int64_t kJSMaxInteger = 0x20000000000000LL - 1; // 2^53 - 1, largest integer exactly representable in ECMAScript.
 41 
 42 static String rangeErrorString(double value, double min, double max)
 43 {
 44     return makeString(&quot;Value &quot;, value, &quot; is outside the range [&quot;, min, &quot;, &quot;, max, &#39;]&#39;);
 45 }
 46 
<span class="line-modified"> 47 static double enforceRange(ExecState&amp; state, double x, double minimum, double maximum)</span>
 48 {
<span class="line-modified"> 49     VM&amp; vm = state.vm();</span>
 50     auto scope = DECLARE_THROW_SCOPE(vm);
 51 
 52     if (std::isnan(x) || std::isinf(x)) {
<span class="line-modified"> 53         throwTypeError(&amp;state, scope, rangeErrorString(x, minimum, maximum));</span>
 54         return 0;
 55     }
 56     x = trunc(x);
 57     if (x &lt; minimum || x &gt; maximum) {
<span class="line-modified"> 58         throwTypeError(&amp;state, scope, rangeErrorString(x, minimum, maximum));</span>
 59         return 0;
 60     }
 61     return x;
 62 }
 63 
 64 namespace {
 65 
 66 template &lt;typename T&gt;
 67 struct IntTypeLimits {
 68 };
 69 
 70 template &lt;&gt;
 71 struct IntTypeLimits&lt;int8_t&gt; {
 72     static const int8_t minValue = -128;
 73     static const int8_t maxValue = 127;
 74     static const unsigned numberOfValues = 256; // 2^8
 75 };
 76 
 77 template &lt;&gt;
 78 struct IntTypeLimits&lt;uint8_t&gt; {
 79     static const uint8_t maxValue = 255;
 80     static const unsigned numberOfValues = 256; // 2^8
 81 };
 82 
 83 template &lt;&gt;
 84 struct IntTypeLimits&lt;int16_t&gt; {
 85     static const short minValue = -32768;
 86     static const short maxValue = 32767;
 87     static const unsigned numberOfValues = 65536; // 2^16
 88 };
 89 
 90 template &lt;&gt;
 91 struct IntTypeLimits&lt;uint16_t&gt; {
 92     static const unsigned short maxValue = 65535;
 93     static const unsigned numberOfValues = 65536; // 2^16
 94 };
 95 
 96 }
 97 
 98 template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified"> 99 static inline T toSmallerInt(ExecState&amp; state, JSValue value)</span>
100 {
<span class="line-modified">101     VM&amp; vm = state.vm();</span>
102     auto scope = DECLARE_THROW_SCOPE(vm);
103 
104     static_assert(std::is_signed&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for signed integral types&quot;);
105 
106     typedef IntTypeLimits&lt;T&gt; LimitsTrait;
107     // Fast path if the value is already a 32-bit signed integer in the right range.
108     if (value.isInt32()) {
109         int32_t d = value.asInt32();
110         if (d &gt;= LimitsTrait::minValue &amp;&amp; d &lt;= LimitsTrait::maxValue)
111             return static_cast&lt;T&gt;(d);
112         switch (configuration) {
113         case IntegerConversionConfiguration::Normal:
114             break;
115         case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">116             throwTypeError(&amp;state, scope);</span>
117             return 0;
118         case IntegerConversionConfiguration::Clamp:
119             return d &lt; LimitsTrait::minValue ? LimitsTrait::minValue : LimitsTrait::maxValue;
120         }
121         d %= LimitsTrait::numberOfValues;
122         return static_cast&lt;T&gt;(d &gt; LimitsTrait::maxValue ? d - LimitsTrait::numberOfValues : d);
123     }
124 
<span class="line-modified">125     double x = value.toNumber(&amp;state);</span>
126     RETURN_IF_EXCEPTION(scope, 0);
127 
128     switch (configuration) {
129     case IntegerConversionConfiguration::Normal:
130         break;
131     case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">132         return enforceRange(state, x, LimitsTrait::minValue, LimitsTrait::maxValue);</span>
133     case IntegerConversionConfiguration::Clamp:
134         return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
135     }
136 
137     if (std::isnan(x) || std::isinf(x) || !x)
138         return 0;
139 
140     x = x &lt; 0 ? -floor(fabs(x)) : floor(fabs(x));
141     x = fmod(x, LimitsTrait::numberOfValues);
142 
143     return static_cast&lt;T&gt;(x &gt; LimitsTrait::maxValue ? x - LimitsTrait::numberOfValues : x);
144 }
145 
146 template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified">147 static inline T toSmallerUInt(ExecState&amp; state, JSValue value)</span>
148 {
<span class="line-modified">149     VM&amp; vm = state.vm();</span>
150     auto scope = DECLARE_THROW_SCOPE(vm);
151 
152     static_assert(std::is_unsigned&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for unsigned integral types&quot;);
153 
154     typedef IntTypeLimits&lt;T&gt; LimitsTrait;
155     // Fast path if the value is already a 32-bit unsigned integer in the right range.
156     if (value.isUInt32()) {
157         uint32_t d = value.asUInt32();
158         if (d &lt;= LimitsTrait::maxValue)
159             return static_cast&lt;T&gt;(d);
160         switch (configuration) {
161         case IntegerConversionConfiguration::Normal:
162             return static_cast&lt;T&gt;(d);
163         case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">164             throwTypeError(&amp;state, scope);</span>
165             return 0;
166         case IntegerConversionConfiguration::Clamp:
167             return LimitsTrait::maxValue;
168         }
169     }
170 
<span class="line-modified">171     double x = value.toNumber(&amp;state);</span>
172     RETURN_IF_EXCEPTION(scope, 0);
173 
174     switch (configuration) {
175     case IntegerConversionConfiguration::Normal:
176         break;
177     case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">178         return enforceRange(state, x, 0, LimitsTrait::maxValue);</span>
179     case IntegerConversionConfiguration::Clamp:
180         return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
181     }
182 
183     if (std::isnan(x) || std::isinf(x) || !x)
184         return 0;
185 
186     x = x &lt; 0 ? -floor(fabs(x)) : floor(fabs(x));
187     return static_cast&lt;T&gt;(fmod(x, LimitsTrait::numberOfValues));
188 }
189 
<span class="line-modified">190 template&lt;&gt; int8_t convertToIntegerEnforceRange&lt;int8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
191 {
<span class="line-modified">192     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
193 }
194 
<span class="line-modified">195 template&lt;&gt; uint8_t convertToIntegerEnforceRange&lt;uint8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
196 {
<span class="line-modified">197     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
198 }
199 
<span class="line-modified">200 template&lt;&gt; int8_t convertToIntegerClamp&lt;int8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
201 {
<span class="line-modified">202     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
203 }
204 
<span class="line-modified">205 template&lt;&gt; uint8_t convertToIntegerClamp&lt;uint8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
206 {
<span class="line-modified">207     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
208 }
209 
<span class="line-modified">210 template&lt;&gt; int8_t convertToInteger&lt;int8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
211 {
<span class="line-modified">212     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
213 }
214 
<span class="line-modified">215 template&lt;&gt; uint8_t convertToInteger&lt;uint8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
216 {
<span class="line-modified">217     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
218 }
219 
<span class="line-modified">220 template&lt;&gt; int16_t convertToIntegerEnforceRange&lt;int16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
221 {
<span class="line-modified">222     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
223 }
224 
<span class="line-modified">225 template&lt;&gt; uint16_t convertToIntegerEnforceRange&lt;uint16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
226 {
<span class="line-modified">227     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
228 }
229 
<span class="line-modified">230 template&lt;&gt; int16_t convertToIntegerClamp&lt;int16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
231 {
<span class="line-modified">232     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
233 }
234 
<span class="line-modified">235 template&lt;&gt; uint16_t convertToIntegerClamp&lt;uint16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
236 {
<span class="line-modified">237     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
238 }
239 
<span class="line-modified">240 template&lt;&gt; int16_t convertToInteger&lt;int16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
241 {
<span class="line-modified">242     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
243 }
244 
<span class="line-modified">245 template&lt;&gt; uint16_t convertToInteger&lt;uint16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
246 {
<span class="line-modified">247     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
248 }
249 
<span class="line-modified">250 template&lt;&gt; int32_t convertToIntegerEnforceRange&lt;int32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
251 {
252     if (value.isInt32())
253         return value.asInt32();
254 
<span class="line-modified">255     VM&amp; vm = state.vm();</span>
256     auto scope = DECLARE_THROW_SCOPE(vm);
257 
<span class="line-modified">258     double x = value.toNumber(&amp;state);</span>
259     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">260     return enforceRange(state, x, kMinInt32, kMaxInt32);</span>
261 }
262 
<span class="line-modified">263 template&lt;&gt; uint32_t convertToIntegerEnforceRange&lt;uint32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
264 {
265     if (value.isUInt32())
266         return value.asUInt32();
267 
<span class="line-modified">268     VM&amp; vm = state.vm();</span>
269     auto scope = DECLARE_THROW_SCOPE(vm);
270 
<span class="line-modified">271     double x = value.toNumber(&amp;state);</span>
272     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">273     return enforceRange(state, x, 0, kMaxUInt32);</span>
274 }
275 
<span class="line-modified">276 template&lt;&gt; int32_t convertToIntegerClamp&lt;int32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
277 {
278     if (value.isInt32())
279         return value.asInt32();
280 
<span class="line-modified">281     double x = value.toNumber(&amp;state);</span>
282     return std::isnan(x) ? 0 : clampTo&lt;int32_t&gt;(x);
283 }
284 
<span class="line-modified">285 template&lt;&gt; uint32_t convertToIntegerClamp&lt;uint32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
286 {
287     if (value.isUInt32())
288         return value.asUInt32();
289 
<span class="line-modified">290     double x = value.toNumber(&amp;state);</span>
291     return std::isnan(x) ? 0 : clampTo&lt;uint32_t&gt;(x);
292 }
293 
<span class="line-modified">294 template&lt;&gt; int32_t convertToInteger&lt;int32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
295 {
<span class="line-modified">296     return value.toInt32(&amp;state);</span>
297 }
298 
<span class="line-modified">299 template&lt;&gt; uint32_t convertToInteger&lt;uint32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
300 {
<span class="line-modified">301     return value.toUInt32(&amp;state);</span>
302 }
303 
<span class="line-modified">304 template&lt;&gt; int64_t convertToIntegerEnforceRange&lt;int64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
305 {
306     if (value.isInt32())
307         return value.asInt32();
308 
<span class="line-modified">309     VM&amp; vm = state.vm();</span>
310     auto scope = DECLARE_THROW_SCOPE(vm);
311 
<span class="line-modified">312     double x = value.toNumber(&amp;state);</span>
313     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">314     return enforceRange(state, x, -kJSMaxInteger, kJSMaxInteger);</span>
315 }
316 
<span class="line-modified">317 template&lt;&gt; uint64_t convertToIntegerEnforceRange&lt;uint64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
318 {
319     if (value.isUInt32())
320         return value.asUInt32();
321 
<span class="line-modified">322     VM&amp; vm = state.vm();</span>
323     auto scope = DECLARE_THROW_SCOPE(vm);
324 
<span class="line-modified">325     double x = value.toNumber(&amp;state);</span>
326     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">327     return enforceRange(state, x, 0, kJSMaxInteger);</span>
328 }
329 
<span class="line-modified">330 template&lt;&gt; int64_t convertToIntegerClamp&lt;int64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
331 {
332     if (value.isInt32())
333         return value.asInt32();
334 
<span class="line-modified">335     double x = value.toNumber(&amp;state);</span>
336     return std::isnan(x) ? 0 : static_cast&lt;int64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, -kJSMaxInteger), kJSMaxInteger));
337 }
338 
<span class="line-modified">339 template&lt;&gt; uint64_t convertToIntegerClamp&lt;uint64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
340 {
341     if (value.isUInt32())
342         return value.asUInt32();
343 
<span class="line-modified">344     double x = value.toNumber(&amp;state);</span>
345     return std::isnan(x) ? 0 : static_cast&lt;uint64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, 0), kJSMaxInteger));
346 }
347 
<span class="line-modified">348 template&lt;&gt; int64_t convertToInteger&lt;int64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
349 {
350     if (value.isInt32())
351         return value.asInt32();
352 
<span class="line-modified">353     double x = value.toNumber(&amp;state);</span>
354 
355     // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
356     unsigned long long n;
357     doubleToInteger(x, n);
358     return n;
359 }
360 
<span class="line-modified">361 template&lt;&gt; uint64_t convertToInteger&lt;uint64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
362 {
363     if (value.isUInt32())
364         return value.asUInt32();
365 
<span class="line-modified">366     double x = value.toNumber(&amp;state);</span>
367 
368     // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
369     unsigned long long n;
370     doubleToInteger(x, n);
371     return n;
372 }
373 
374 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 30 #include &lt;wtf/text/WTFString.h&gt;
 31 
 32 namespace WebCore {
 33 using namespace JSC;
 34 
 35 enum class IntegerConversionConfiguration { Normal, EnforceRange, Clamp };
 36 
 37 static const int32_t kMaxInt32 = 0x7fffffff;
 38 static const int32_t kMinInt32 = -kMaxInt32 - 1;
 39 static const uint32_t kMaxUInt32 = 0xffffffffU;
 40 static const int64_t kJSMaxInteger = 0x20000000000000LL - 1; // 2^53 - 1, largest integer exactly representable in ECMAScript.
 41 
 42 static String rangeErrorString(double value, double min, double max)
 43 {
 44     return makeString(&quot;Value &quot;, value, &quot; is outside the range [&quot;, min, &quot;, &quot;, max, &#39;]&#39;);
 45 }
 46 
<span class="line-modified"> 47 static double enforceRange(JSGlobalObject&amp; lexicalGlobalObject, double x, double minimum, double maximum)</span>
 48 {
<span class="line-modified"> 49     VM&amp; vm = lexicalGlobalObject.vm();</span>
 50     auto scope = DECLARE_THROW_SCOPE(vm);
 51 
 52     if (std::isnan(x) || std::isinf(x)) {
<span class="line-modified"> 53         throwTypeError(&amp;lexicalGlobalObject, scope, rangeErrorString(x, minimum, maximum));</span>
 54         return 0;
 55     }
 56     x = trunc(x);
 57     if (x &lt; minimum || x &gt; maximum) {
<span class="line-modified"> 58         throwTypeError(&amp;lexicalGlobalObject, scope, rangeErrorString(x, minimum, maximum));</span>
 59         return 0;
 60     }
 61     return x;
 62 }
 63 
 64 namespace {
 65 
 66 template &lt;typename T&gt;
 67 struct IntTypeLimits {
 68 };
 69 
 70 template &lt;&gt;
 71 struct IntTypeLimits&lt;int8_t&gt; {
 72     static const int8_t minValue = -128;
 73     static const int8_t maxValue = 127;
 74     static const unsigned numberOfValues = 256; // 2^8
 75 };
 76 
 77 template &lt;&gt;
 78 struct IntTypeLimits&lt;uint8_t&gt; {
 79     static const uint8_t maxValue = 255;
 80     static const unsigned numberOfValues = 256; // 2^8
 81 };
 82 
 83 template &lt;&gt;
 84 struct IntTypeLimits&lt;int16_t&gt; {
 85     static const short minValue = -32768;
 86     static const short maxValue = 32767;
 87     static const unsigned numberOfValues = 65536; // 2^16
 88 };
 89 
 90 template &lt;&gt;
 91 struct IntTypeLimits&lt;uint16_t&gt; {
 92     static const unsigned short maxValue = 65535;
 93     static const unsigned numberOfValues = 65536; // 2^16
 94 };
 95 
 96 }
 97 
 98 template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified"> 99 static inline T toSmallerInt(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)</span>
100 {
<span class="line-modified">101     VM&amp; vm = lexicalGlobalObject.vm();</span>
102     auto scope = DECLARE_THROW_SCOPE(vm);
103 
104     static_assert(std::is_signed&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for signed integral types&quot;);
105 
106     typedef IntTypeLimits&lt;T&gt; LimitsTrait;
107     // Fast path if the value is already a 32-bit signed integer in the right range.
108     if (value.isInt32()) {
109         int32_t d = value.asInt32();
110         if (d &gt;= LimitsTrait::minValue &amp;&amp; d &lt;= LimitsTrait::maxValue)
111             return static_cast&lt;T&gt;(d);
112         switch (configuration) {
113         case IntegerConversionConfiguration::Normal:
114             break;
115         case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">116             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
117             return 0;
118         case IntegerConversionConfiguration::Clamp:
119             return d &lt; LimitsTrait::minValue ? LimitsTrait::minValue : LimitsTrait::maxValue;
120         }
121         d %= LimitsTrait::numberOfValues;
122         return static_cast&lt;T&gt;(d &gt; LimitsTrait::maxValue ? d - LimitsTrait::numberOfValues : d);
123     }
124 
<span class="line-modified">125     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
126     RETURN_IF_EXCEPTION(scope, 0);
127 
128     switch (configuration) {
129     case IntegerConversionConfiguration::Normal:
130         break;
131     case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">132         return enforceRange(lexicalGlobalObject, x, LimitsTrait::minValue, LimitsTrait::maxValue);</span>
133     case IntegerConversionConfiguration::Clamp:
134         return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
135     }
136 
137     if (std::isnan(x) || std::isinf(x) || !x)
138         return 0;
139 
140     x = x &lt; 0 ? -floor(fabs(x)) : floor(fabs(x));
141     x = fmod(x, LimitsTrait::numberOfValues);
142 
143     return static_cast&lt;T&gt;(x &gt; LimitsTrait::maxValue ? x - LimitsTrait::numberOfValues : x);
144 }
145 
146 template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified">147 static inline T toSmallerUInt(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)</span>
148 {
<span class="line-modified">149     VM&amp; vm = lexicalGlobalObject.vm();</span>
150     auto scope = DECLARE_THROW_SCOPE(vm);
151 
152     static_assert(std::is_unsigned&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for unsigned integral types&quot;);
153 
154     typedef IntTypeLimits&lt;T&gt; LimitsTrait;
155     // Fast path if the value is already a 32-bit unsigned integer in the right range.
156     if (value.isUInt32()) {
157         uint32_t d = value.asUInt32();
158         if (d &lt;= LimitsTrait::maxValue)
159             return static_cast&lt;T&gt;(d);
160         switch (configuration) {
161         case IntegerConversionConfiguration::Normal:
162             return static_cast&lt;T&gt;(d);
163         case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">164             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
165             return 0;
166         case IntegerConversionConfiguration::Clamp:
167             return LimitsTrait::maxValue;
168         }
169     }
170 
<span class="line-modified">171     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
172     RETURN_IF_EXCEPTION(scope, 0);
173 
174     switch (configuration) {
175     case IntegerConversionConfiguration::Normal:
176         break;
177     case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">178         return enforceRange(lexicalGlobalObject, x, 0, LimitsTrait::maxValue);</span>
179     case IntegerConversionConfiguration::Clamp:
180         return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
181     }
182 
183     if (std::isnan(x) || std::isinf(x) || !x)
184         return 0;
185 
186     x = x &lt; 0 ? -floor(fabs(x)) : floor(fabs(x));
187     return static_cast&lt;T&gt;(fmod(x, LimitsTrait::numberOfValues));
188 }
189 
<span class="line-modified">190 template&lt;&gt; int8_t convertToIntegerEnforceRange&lt;int8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
191 {
<span class="line-modified">192     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
193 }
194 
<span class="line-modified">195 template&lt;&gt; uint8_t convertToIntegerEnforceRange&lt;uint8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
196 {
<span class="line-modified">197     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
198 }
199 
<span class="line-modified">200 template&lt;&gt; int8_t convertToIntegerClamp&lt;int8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
201 {
<span class="line-modified">202     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
203 }
204 
<span class="line-modified">205 template&lt;&gt; uint8_t convertToIntegerClamp&lt;uint8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
206 {
<span class="line-modified">207     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
208 }
209 
<span class="line-modified">210 template&lt;&gt; int8_t convertToInteger&lt;int8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
211 {
<span class="line-modified">212     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
213 }
214 
<span class="line-modified">215 template&lt;&gt; uint8_t convertToInteger&lt;uint8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
216 {
<span class="line-modified">217     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
218 }
219 
<span class="line-modified">220 template&lt;&gt; int16_t convertToIntegerEnforceRange&lt;int16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
221 {
<span class="line-modified">222     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
223 }
224 
<span class="line-modified">225 template&lt;&gt; uint16_t convertToIntegerEnforceRange&lt;uint16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
226 {
<span class="line-modified">227     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
228 }
229 
<span class="line-modified">230 template&lt;&gt; int16_t convertToIntegerClamp&lt;int16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
231 {
<span class="line-modified">232     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
233 }
234 
<span class="line-modified">235 template&lt;&gt; uint16_t convertToIntegerClamp&lt;uint16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
236 {
<span class="line-modified">237     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
238 }
239 
<span class="line-modified">240 template&lt;&gt; int16_t convertToInteger&lt;int16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
241 {
<span class="line-modified">242     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
243 }
244 
<span class="line-modified">245 template&lt;&gt; uint16_t convertToInteger&lt;uint16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
246 {
<span class="line-modified">247     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
248 }
249 
<span class="line-modified">250 template&lt;&gt; int32_t convertToIntegerEnforceRange&lt;int32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
251 {
252     if (value.isInt32())
253         return value.asInt32();
254 
<span class="line-modified">255     VM&amp; vm = lexicalGlobalObject.vm();</span>
256     auto scope = DECLARE_THROW_SCOPE(vm);
257 
<span class="line-modified">258     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
259     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">260     return enforceRange(lexicalGlobalObject, x, kMinInt32, kMaxInt32);</span>
261 }
262 
<span class="line-modified">263 template&lt;&gt; uint32_t convertToIntegerEnforceRange&lt;uint32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
264 {
265     if (value.isUInt32())
266         return value.asUInt32();
267 
<span class="line-modified">268     VM&amp; vm = lexicalGlobalObject.vm();</span>
269     auto scope = DECLARE_THROW_SCOPE(vm);
270 
<span class="line-modified">271     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
272     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">273     return enforceRange(lexicalGlobalObject, x, 0, kMaxUInt32);</span>
274 }
275 
<span class="line-modified">276 template&lt;&gt; int32_t convertToIntegerClamp&lt;int32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
277 {
278     if (value.isInt32())
279         return value.asInt32();
280 
<span class="line-modified">281     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
282     return std::isnan(x) ? 0 : clampTo&lt;int32_t&gt;(x);
283 }
284 
<span class="line-modified">285 template&lt;&gt; uint32_t convertToIntegerClamp&lt;uint32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
286 {
287     if (value.isUInt32())
288         return value.asUInt32();
289 
<span class="line-modified">290     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
291     return std::isnan(x) ? 0 : clampTo&lt;uint32_t&gt;(x);
292 }
293 
<span class="line-modified">294 template&lt;&gt; int32_t convertToInteger&lt;int32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
295 {
<span class="line-modified">296     return value.toInt32(&amp;lexicalGlobalObject);</span>
297 }
298 
<span class="line-modified">299 template&lt;&gt; uint32_t convertToInteger&lt;uint32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
300 {
<span class="line-modified">301     return value.toUInt32(&amp;lexicalGlobalObject);</span>
302 }
303 
<span class="line-modified">304 template&lt;&gt; int64_t convertToIntegerEnforceRange&lt;int64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
305 {
306     if (value.isInt32())
307         return value.asInt32();
308 
<span class="line-modified">309     VM&amp; vm = lexicalGlobalObject.vm();</span>
310     auto scope = DECLARE_THROW_SCOPE(vm);
311 
<span class="line-modified">312     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
313     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">314     return enforceRange(lexicalGlobalObject, x, -kJSMaxInteger, kJSMaxInteger);</span>
315 }
316 
<span class="line-modified">317 template&lt;&gt; uint64_t convertToIntegerEnforceRange&lt;uint64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
318 {
319     if (value.isUInt32())
320         return value.asUInt32();
321 
<span class="line-modified">322     VM&amp; vm = lexicalGlobalObject.vm();</span>
323     auto scope = DECLARE_THROW_SCOPE(vm);
324 
<span class="line-modified">325     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
326     RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">327     return enforceRange(lexicalGlobalObject, x, 0, kJSMaxInteger);</span>
328 }
329 
<span class="line-modified">330 template&lt;&gt; int64_t convertToIntegerClamp&lt;int64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
331 {
332     if (value.isInt32())
333         return value.asInt32();
334 
<span class="line-modified">335     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
336     return std::isnan(x) ? 0 : static_cast&lt;int64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, -kJSMaxInteger), kJSMaxInteger));
337 }
338 
<span class="line-modified">339 template&lt;&gt; uint64_t convertToIntegerClamp&lt;uint64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
340 {
341     if (value.isUInt32())
342         return value.asUInt32();
343 
<span class="line-modified">344     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
345     return std::isnan(x) ? 0 : static_cast&lt;uint64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, 0), kJSMaxInteger));
346 }
347 
<span class="line-modified">348 template&lt;&gt; int64_t convertToInteger&lt;int64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
349 {
350     if (value.isInt32())
351         return value.asInt32();
352 
<span class="line-modified">353     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
354 
355     // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
356     unsigned long long n;
357     doubleToInteger(x, n);
358     return n;
359 }
360 
<span class="line-modified">361 template&lt;&gt; uint64_t convertToInteger&lt;uint64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
362 {
363     if (value.isUInt32())
364         return value.asUInt32();
365 
<span class="line-modified">366     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
367 
368     // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
369     unsigned long long n;
370     doubleToInteger(x, n);
371     return n;
372 }
373 
374 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMConvertNullable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertNumbers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
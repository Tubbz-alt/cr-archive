<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetterSetterAccessCase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GetterSetterAccessCase.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;AccessCaseSnippetParams.h&quot;
 32 #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
 33 #include &quot;DOMJITGetterSetter.h&quot;
 34 #include &quot;HeapInlines.h&quot;
 35 #include &quot;JSCJSValueInlines.h&quot;
 36 #include &quot;PolymorphicAccess.h&quot;
 37 #include &quot;StructureStubInfo.h&quot;
 38 
 39 namespace JSC {
 40 
 41 namespace GetterSetterAccessCaseInternal {
 42 static constexpr bool verbose = false;
 43 }
 44 
 45 GetterSetterAccessCase::GetterSetterAccessCase(VM&amp; vm, JSCell* owner, AccessType accessType, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, bool viaProxy, WatchpointSet* additionalSet, JSObject* customSlotBase, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
 46     : Base(vm, owner, accessType, identifier, offset, structure, conditionSet, viaProxy, additionalSet, WTFMove(prototypeAccessChain))
 47 {
 48     m_customSlotBase.setMayBeNull(vm, owner, customSlotBase);
 49 }
 50 
 51 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::create(
 52     VM&amp; vm, JSCell* owner, AccessType type, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet,
 53     bool viaProxy, WatchpointSet* additionalSet, FunctionPtr&lt;OperationPtrTag&gt; customGetter, JSObject* customSlotBase,
 54     Optional&lt;DOMAttributeAnnotation&gt; domAttribute, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
 55 {
 56     switch (type) {
 57     case Getter:
 58     case CustomAccessorGetter:
 59     case CustomValueGetter:
 60         break;
 61     default:
 62         ASSERT_NOT_REACHED();
 63     };
 64 
 65     std::unique_ptr&lt;GetterSetterAccessCase&gt; result(new GetterSetterAccessCase(vm, owner, type, identifier, offset, structure, conditionSet, viaProxy, additionalSet, customSlotBase, WTFMove(prototypeAccessChain)));
 66     result-&gt;m_domAttribute = domAttribute;
 67     result-&gt;m_customAccessor = customGetter ? FunctionPtr&lt;OperationPtrTag&gt;(customGetter) : nullptr;
 68     return result;
 69 }
 70 
 71 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::create(VM&amp; vm, JSCell* owner, AccessType type, Structure* structure, CacheableIdentifier identifier, PropertyOffset offset,
 72     const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain, FunctionPtr&lt;OperationPtrTag&gt; customSetter,
 73     JSObject* customSlotBase)
 74 {
 75     ASSERT(type == Setter || type == CustomValueSetter || type == CustomAccessorSetter);
 76     std::unique_ptr&lt;GetterSetterAccessCase&gt; result(new GetterSetterAccessCase(vm, owner, type, identifier, offset, structure, conditionSet, false, nullptr, customSlotBase, WTFMove(prototypeAccessChain)));
 77     result-&gt;m_customAccessor = customSetter ? FunctionPtr&lt;OperationPtrTag&gt;(customSetter) : nullptr;
 78     return result;
 79 }
 80 
 81 
 82 GetterSetterAccessCase::~GetterSetterAccessCase()
 83 {
 84 }
 85 
 86 
 87 GetterSetterAccessCase::GetterSetterAccessCase(const GetterSetterAccessCase&amp; other)
 88     : Base(other)
 89     , m_customSlotBase(other.m_customSlotBase)
 90 {
 91     m_customAccessor = other.m_customAccessor;
 92     m_domAttribute = other.m_domAttribute;
 93 }
 94 
 95 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::clone() const
 96 {
 97     std::unique_ptr&lt;GetterSetterAccessCase&gt; result(new GetterSetterAccessCase(*this));
 98     result-&gt;resetState();
 99     return result;
100 }
101 
102 bool GetterSetterAccessCase::hasAlternateBase() const
103 {
104     if (customSlotBase())
105         return true;
106     return Base::hasAlternateBase();
107 }
108 
109 JSObject* GetterSetterAccessCase::alternateBase() const
110 {
111     if (customSlotBase())
112         return customSlotBase();
113     return Base::alternateBase();
114 }
115 
116 void GetterSetterAccessCase::dumpImpl(PrintStream&amp; out, CommaPrinter&amp; comma) const
117 {
118     Base::dumpImpl(out, comma);
119     out.print(comma, &quot;customSlotBase = &quot;, RawPointer(customSlotBase()));
120     if (callLinkInfo())
121         out.print(comma, &quot;callLinkInfo = &quot;, RawPointer(callLinkInfo()));
122     out.print(comma, &quot;customAccessor = &quot;, RawPointer(m_customAccessor.executableAddress()));
123 }
124 
125 void GetterSetterAccessCase::emitDOMJITGetter(AccessGenerationState&amp; state, const DOMJIT::GetterSetter* domJIT, GPRReg baseForGetGPR)
126 {
127     CCallHelpers&amp; jit = *state.jit;
128     StructureStubInfo&amp; stubInfo = *state.stubInfo;
129     JSValueRegs valueRegs = state.valueRegs;
130     GPRReg baseGPR = state.baseGPR;
131     GPRReg scratchGPR = state.scratchGPR;
132 
133     // We construct the environment that can execute the DOMJIT::Snippet here.
134     Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = domJIT-&gt;compiler()();
135 
136     Vector&lt;GPRReg&gt; gpScratch;
137     Vector&lt;FPRReg&gt; fpScratch;
138     Vector&lt;SnippetParams::Value&gt; regs;
139 
140     ScratchRegisterAllocator allocator(stubInfo.usedRegisters);
141     allocator.lock(stubInfo.baseRegs());
142     allocator.lock(valueRegs);
143     allocator.lock(scratchGPR);
144 
145     GPRReg paramBaseGPR = InvalidGPRReg;
146     GPRReg paramGlobalObjectGPR = InvalidGPRReg;
147     JSValueRegs paramValueRegs = valueRegs;
148     GPRReg remainingScratchGPR = InvalidGPRReg;
149 
150     // valueRegs and baseForGetGPR may be the same. For example, in Baseline JIT, we pass the same regT0 for baseGPR and valueRegs.
151     // In FTL, there is no constraint that the baseForGetGPR interferes with the result. To make implementation simple in
152     // Snippet, Snippet assumes that result registers always early interfere with input registers, in this case,
153     // baseForGetGPR. So we move baseForGetGPR to the other register if baseForGetGPR == valueRegs.
154     if (baseForGetGPR != valueRegs.payloadGPR()) {
155         paramBaseGPR = baseForGetGPR;
156         if (!snippet-&gt;requireGlobalObject)
157             remainingScratchGPR = scratchGPR;
158         else
159             paramGlobalObjectGPR = scratchGPR;
160     } else {
161         jit.move(valueRegs.payloadGPR(), scratchGPR);
162         paramBaseGPR = scratchGPR;
163         if (snippet-&gt;requireGlobalObject)
164             paramGlobalObjectGPR = allocator.allocateScratchGPR();
165     }
166 
167     JSGlobalObject* globalObjectForDOMJIT = structure()-&gt;globalObject();
168 
169     regs.append(paramValueRegs);
170     regs.append(paramBaseGPR);
171     if (snippet-&gt;requireGlobalObject) {
172         ASSERT(paramGlobalObjectGPR != InvalidGPRReg);
173         regs.append(SnippetParams::Value(paramGlobalObjectGPR, globalObjectForDOMJIT));
174     }
175 
176     if (snippet-&gt;numGPScratchRegisters) {
177         unsigned i = 0;
178         if (remainingScratchGPR != InvalidGPRReg) {
179             gpScratch.append(remainingScratchGPR);
180             ++i;
181         }
182         for (; i &lt; snippet-&gt;numGPScratchRegisters; ++i)
183             gpScratch.append(allocator.allocateScratchGPR());
184     }
185 
186     for (unsigned i = 0; i &lt; snippet-&gt;numFPScratchRegisters; ++i)
187         fpScratch.append(allocator.allocateScratchFPR());
188 
189     // Let&#39;s store the reused registers to the stack. After that, we can use allocated scratch registers.
190     ScratchRegisterAllocator::PreservedState preservedState =
191     allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::SpaceForCCall);
192 
193     if (GetterSetterAccessCaseInternal::verbose) {
194         dataLog(&quot;baseGPR = &quot;, baseGPR, &quot;\n&quot;);
195         dataLog(&quot;valueRegs = &quot;, valueRegs, &quot;\n&quot;);
196         dataLog(&quot;scratchGPR = &quot;, scratchGPR, &quot;\n&quot;);
197         dataLog(&quot;paramBaseGPR = &quot;, paramBaseGPR, &quot;\n&quot;);
198         if (paramGlobalObjectGPR != InvalidGPRReg)
199             dataLog(&quot;paramGlobalObjectGPR = &quot;, paramGlobalObjectGPR, &quot;\n&quot;);
200         dataLog(&quot;paramValueRegs = &quot;, paramValueRegs, &quot;\n&quot;);
201         for (unsigned i = 0; i &lt; snippet-&gt;numGPScratchRegisters; ++i)
202             dataLog(&quot;gpScratch[&quot;, i, &quot;] = &quot;, gpScratch[i], &quot;\n&quot;);
203     }
204 
205     if (snippet-&gt;requireGlobalObject)
206         jit.move(CCallHelpers::TrustedImmPtr(globalObjectForDOMJIT), paramGlobalObjectGPR);
207 
208     // We just spill the registers used in Snippet here. For not spilled registers here explicitly,
209     // they must be in the used register set passed by the callers (Baseline, DFG, and FTL) if they need to be kept.
210     // Some registers can be locked, but not in the used register set. For example, the caller could make baseGPR
211     // same to valueRegs, and not include it in the used registers since it will be changed.
212     RegisterSet registersToSpillForCCall;
213     for (auto&amp; value : regs) {
214         SnippetReg reg = value.reg();
215         if (reg.isJSValueRegs())
216             registersToSpillForCCall.set(reg.jsValueRegs());
217         else if (reg.isGPR())
218             registersToSpillForCCall.set(reg.gpr());
219         else
220             registersToSpillForCCall.set(reg.fpr());
221     }
222     for (GPRReg reg : gpScratch)
223         registersToSpillForCCall.set(reg);
224     for (FPRReg reg : fpScratch)
225         registersToSpillForCCall.set(reg);
226     registersToSpillForCCall.exclude(RegisterSet::registersToNotSaveForCCall());
227 
228     AccessCaseSnippetParams params(state.m_vm, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
229     snippet-&gt;generator()-&gt;run(jit, params);
230     allocator.restoreReusedRegistersByPopping(jit, preservedState);
231     state.succeed();
232 
233     CCallHelpers::JumpList exceptions = params.emitSlowPathCalls(state, registersToSpillForCCall, jit);
234     if (!exceptions.empty()) {
235         exceptions.link(&amp;jit);
236         allocator.restoreReusedRegistersByPopping(jit, preservedState);
237         state.emitExplicitExceptionHandler();
238     }
239 }
240 
241 } // namespace JSC
242 
243 #endif // ENABLE(JIT)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlockFormattingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../displaytree/DisplayBox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BlockFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 


 31 #include &quot;InlineFormattingState.h&quot;
 32 #include &quot;LayoutBox.h&quot;
 33 #include &quot;LayoutContainer.h&quot;
 34 #include &quot;LayoutUnit.h&quot;
 35 #include &quot;RenderStyle.h&quot;
 36 
 37 namespace WebCore {
 38 namespace Layout {
 39 
 40 static bool hasBorder(const BorderValue&amp; borderValue)
 41 {
 42     if (borderValue.style() == BorderStyle::None || borderValue.style() == BorderStyle::Hidden)
 43         return false;
 44     return !!borderValue.width();
 45 }
 46 
 47 static bool hasPadding(const Length&amp; paddingValue)
 48 {
 49     // FIXME: Check if percent value needs to be resolved.
 50     return !paddingValue.isZero();
</pre>
<hr />
<pre>
 53 static bool hasBorderBefore(const Box&amp; layoutBox)
 54 {
 55     return hasBorder(layoutBox.style().borderBefore());
 56 }
 57 
 58 static bool hasBorderAfter(const Box&amp; layoutBox)
 59 {
 60     return hasBorder(layoutBox.style().borderAfter());
 61 }
 62 
 63 static bool hasPaddingBefore(const Box&amp; layoutBox)
 64 {
 65     return hasPadding(layoutBox.style().paddingBefore());
 66 }
 67 
 68 static bool hasPaddingAfter(const Box&amp; layoutBox)
 69 {
 70     return hasPadding(layoutBox.style().paddingAfter());
 71 }
 72 
<span class="line-removed"> 73 static bool hasClearance(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="line-removed"> 74 {</span>
<span class="line-removed"> 75     if (!layoutBox.hasFloatClear())</span>
<span class="line-removed"> 76         return false;</span>
<span class="line-removed"> 77     return layoutState.displayBoxForLayoutBox(layoutBox).hasClearance();</span>
<span class="line-removed"> 78 }</span>
<span class="line-removed"> 79 </span>
 80 static bool establishesBlockFormattingContext(const Box&amp; layoutBox)
 81 {
 82     // WebKit treats the document element renderer as a block formatting context root. It probably only impacts margin collapsing, so let&#39;s not do
 83     // a layout wide quirk on this for now.
 84     if (layoutBox.isDocumentBox())
 85         return true;
 86     return layoutBox.establishesBlockFormattingContext();
 87 }
 88 
<span class="line-modified"> 89 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>











 90 {
 91     // 1. This is the last in-flow child and its margins collapse through and the margin after collapses with parent&#39;s margin after or
 92     // 2. This box&#39;s margin after collapses with the next sibling&#39;s margin before and that sibling collapses through and
 93     // we can get to the last in-flow child like that.
 94     auto* lastInFlowChild = layoutBox.parent()-&gt;lastInFlowChild();
 95     for (auto* currentBox = &amp;layoutBox; currentBox; currentBox = currentBox-&gt;nextInFlowSibling()) {
<span class="line-modified"> 96         if (!marginsCollapseThrough(layoutState, *currentBox))</span>
 97             return false;
 98         if (currentBox == lastInFlowChild)
<span class="line-modified"> 99             return marginAfterCollapsesWithParentMarginAfter(layoutState, *currentBox);</span>
<span class="line-modified">100         if (!marginAfterCollapsesWithNextSiblingMarginBefore(layoutState, *currentBox))</span>
101             return false;
102     }
103     ASSERT_NOT_REACHED();
104     return false;
105 }
106 
<span class="line-modified">107 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
108 {
109     // The first inflow child could propagate its top margin to parent.
110     // https://www.w3.org/TR/CSS21/box.html#collapsing-margins
<span class="line-removed">111     if (layoutBox.isAnonymous())</span>
<span class="line-removed">112         return false;</span>
<span class="line-removed">113 </span>
114     ASSERT(layoutBox.isBlockLevelBox());
115 
116     // Margins between a floated box and any other box do not collapse.
117     if (layoutBox.isFloatingPositioned())
118         return false;
119 
120     // Margins of absolutely positioned boxes do not collapse.
121     if (layoutBox.isOutOfFlowPositioned())
122         return false;
123 
124     // Margins of inline-block boxes do not collapse.
125     if (layoutBox.isInlineBlockBox())
126         return false;
127 
128     // Only the first inlflow child collapses with parent.
129     if (layoutBox.previousInFlowSibling())
130         return false;
131 
132     auto&amp; parent = *layoutBox.parent();
133     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children
134     if (establishesBlockFormattingContext(parent))
135         return false;
136 
137     if (hasBorderBefore(parent))
138         return false;
139 
140     if (hasPaddingBefore(parent))
141         return false;
142 
143     // ...and the child has no clearance.
<span class="line-modified">144     if (hasClearance(layoutState, layoutBox))</span>
145         return false;
146 
147     return true;
148 }
149 
<span class="line-modified">150 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithPreviousSiblingMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
151 {
152     ASSERT(layoutBox.isBlockLevelBox());
153 
<span class="line-removed">154     if (layoutBox.isAnonymous())</span>
<span class="line-removed">155         return false;</span>
<span class="line-removed">156 </span>
157     if (!layoutBox.previousInFlowSibling())
158         return false;
159 
160     auto&amp; previousInFlowSibling = *layoutBox.previousInFlowSibling();
<span class="line-removed">161     if (previousInFlowSibling.isAnonymous())</span>
<span class="line-removed">162         return false;</span>
<span class="line-removed">163 </span>
164     // Margins between a floated box and any other box do not collapse.
165     if (layoutBox.isFloatingPositioned() || previousInFlowSibling.isFloatingPositioned())
166         return false;
167 
168     // Margins of absolutely positioned boxes do not collapse.
169     if ((layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.style().top().isAuto())
170         || (previousInFlowSibling.isOutOfFlowPositioned() &amp;&amp; !previousInFlowSibling.style().bottom().isAuto()))
171         return false;
172 
173     // Margins of inline-block boxes do not collapse.
174     if (layoutBox.isInlineBlockBox() || previousInFlowSibling.isInlineBlockBox())
175         return false;
176 
177     // The bottom margin of an in-flow block-level element always collapses with the top margin of
178     // its next in-flow block-level sibling, unless that sibling has clearance.
<span class="line-modified">179     if (hasClearance(layoutState, layoutBox))</span>
180         return false;
181 
182     return true;
183 }
184 
<span class="line-modified">185 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
186 {
<span class="line-removed">187     if (layoutBox.isAnonymous())</span>
<span class="line-removed">188         return false;</span>
<span class="line-removed">189 </span>
190     ASSERT(layoutBox.isBlockLevelBox());
191     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
192     if (establishesBlockFormattingContext(layoutBox))
193         return false;
194 
195     // The top margin of an in-flow block element collapses with its first in-flow block-level
196     // child&#39;s top margin if the element has no top border...
197     if (hasBorderBefore(layoutBox))
198         return false;
199 
200     // ...no top padding
201     if (hasPaddingBefore(layoutBox))
202         return false;
203 
204     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
205         return false;
206 
207     auto&amp; firstInFlowChild = *downcast&lt;Container&gt;(layoutBox).firstInFlowChild();
208     if (!firstInFlowChild.isBlockLevelBox())
209         return false;
210 
211     // ...and the child has no clearance.
<span class="line-modified">212     if (hasClearance(layoutState, firstInFlowChild))</span>
213         return false;
214 
215     // Margins of inline-block boxes do not collapse.
216     if (firstInFlowChild.isInlineBlockBox())
217         return false;
218 
219     return true;
220 }
221 
<span class="line-modified">222 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
223 {
224     // If the top and bottom margins of an element with clearance are adjoining, its margins collapse with the adjoining margins
225     // of following siblings but that resulting margin does not collapse with the bottom margin of the parent block.
<span class="line-modified">226     if (!marginsCollapseThrough(layoutState, layoutBox))</span>
227         return false;
228 
229     for (auto* previousSibling = layoutBox.previousInFlowSibling(); previousSibling; previousSibling = previousSibling-&gt;previousInFlowSibling()) {
<span class="line-modified">230         if (!marginsCollapseThrough(layoutState, *previousSibling))</span>
231             return false;
<span class="line-modified">232         if (hasClearance(layoutState, *previousSibling))</span>
233             return true;
234     }
235     return false;
236 }
237 
<span class="line-modified">238 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
239 {
240     // 1. This is the first in-flow child and its margins collapse through and the margin before collapses with parent&#39;s margin before or
241     // 2. This box&#39;s margin before collapses with the previous sibling&#39;s margin after and that sibling collapses through and
242     // we can get to the first in-flow child like that.
243     auto* firstInFlowChild = layoutBox.parent()-&gt;firstInFlowChild();
244     for (auto* currentBox = &amp;layoutBox; currentBox; currentBox = currentBox-&gt;previousInFlowSibling()) {
<span class="line-modified">245         if (!marginsCollapseThrough(layoutState, *currentBox))</span>
246             return false;
247         if (currentBox == firstInFlowChild)
<span class="line-modified">248             return marginBeforeCollapsesWithParentMarginBefore(layoutState, *currentBox);</span>
<span class="line-modified">249         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *currentBox))</span>
250             return false;
251     }
252     ASSERT_NOT_REACHED();
253     return false;
254 }
255 
<span class="line-modified">256 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
257 {
<span class="line-removed">258     if (layoutBox.isAnonymous())</span>
<span class="line-removed">259         return false;</span>
<span class="line-removed">260 </span>
261     ASSERT(layoutBox.isBlockLevelBox());
262 
263     // Margins between a floated box and any other box do not collapse.
264     if (layoutBox.isFloatingPositioned())
265         return false;
266 
267     // Margins of absolutely positioned boxes do not collapse.
268     if (layoutBox.isOutOfFlowPositioned())
269         return false;
270 
271     // Margins of inline-block boxes do not collapse.
272     if (layoutBox.isInlineBlockBox())
273         return false;
274 
275     // Only the last inlflow child collapses with parent.
276     if (layoutBox.nextInFlowSibling())
277         return false;
278 
279     auto&amp; parent = *layoutBox.parent();
280     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
281     if (establishesBlockFormattingContext(parent))
282         return false;
283 
284     // The bottom margin of an in-flow block box with a &#39;height&#39; of &#39;auto&#39; collapses with its last in-flow block-level child&#39;s bottom margin, if:
285     if (!parent.style().height().isAuto())
286         return false;
287 
288     // the box has no bottom padding, and
289     if (hasPaddingAfter(parent))
290         return false;
291 
292     // the box has no bottom border, and
293     if (hasBorderAfter(parent))
294         return false;
295 
296     // the child&#39;s bottom margin neither collapses with a top margin that has clearance...
<span class="line-modified">297     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutState, layoutBox))</span>
298         return false;
299 
300     // nor (if the box&#39;s min-height is non-zero) with the box&#39;s top margin.
301     auto computedMinHeight = parent.style().logicalMinHeight();
<span class="line-modified">302     if (!computedMinHeight.isAuto() &amp;&amp; computedMinHeight.value() &amp;&amp; marginAfterCollapsesWithParentMarginBefore(layoutState, layoutBox))</span>
303         return false;
304 
305     return true;
306 }
307 
<span class="line-modified">308 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithLastInFlowChildMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
309 {
310     ASSERT(layoutBox.isBlockLevelBox());
311 
312     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
313     if (establishesBlockFormattingContext(layoutBox))
314         return false;
315 
316     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
317         return false;
318 
319     auto&amp; lastInFlowChild = *downcast&lt;Container&gt;(layoutBox).lastInFlowChild();
320     if (!lastInFlowChild.isBlockLevelBox())
321         return false;
322 
323     // The bottom margin of an in-flow block box with a &#39;height&#39; of &#39;auto&#39; collapses with its last in-flow block-level child&#39;s bottom margin, if:
324     if (!layoutBox.style().height().isAuto())
325         return false;
326 
327     // the box has no bottom padding, and
328     if (hasPaddingAfter(layoutBox))
329         return false;
330 
331     // the box has no bottom border, and
332     if (hasBorderAfter(layoutBox))
333         return false;
334 
335     // the child&#39;s bottom margin neither collapses with a top margin that has clearance...
<span class="line-modified">336     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutState, lastInFlowChild))</span>
337         return false;
338 
339     // nor (if the box&#39;s min-height is non-zero) with the box&#39;s top margin.
340     auto computedMinHeight = layoutBox.style().logicalMinHeight();
341     if (!computedMinHeight.isAuto() &amp;&amp; computedMinHeight.value()
<span class="line-modified">342         &amp;&amp; (marginAfterCollapsesWithParentMarginBefore(layoutState, lastInFlowChild) || hasClearance(layoutState, lastInFlowChild)))</span>
343         return false;
344 
345     // Margins of inline-block boxes do not collapse.
346     if (lastInFlowChild.isInlineBlockBox())
347         return false;
348 





349     return true;
350 }
351 
<span class="line-modified">352 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithNextSiblingMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
353 {
354     ASSERT(layoutBox.isBlockLevelBox());
355 
356     if (!layoutBox.nextInFlowSibling())
357         return false;
358 
<span class="line-modified">359     return marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *layoutBox.nextInFlowSibling());</span>
360 }
361 
<span class="line-modified">362 bool BlockFormattingContext::MarginCollapse::marginsCollapseThrough(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
363 {
364     ASSERT(layoutBox.isBlockLevelBox());
365 
366     // A box&#39;s own margins collapse if the &#39;min-height&#39; property is zero, and it has neither top or bottom borders nor top or bottom padding,
367     // and it has a &#39;height&#39; of either 0 or &#39;auto&#39;, and it does not contain a line box, and all of its in-flow children&#39;s margins (if any) collapse.
368     if (hasBorderBefore(layoutBox) || hasBorderAfter(layoutBox))
369         return false;
370 
371     if (hasPaddingBefore(layoutBox) || hasPaddingAfter(layoutBox))
372         return false;
373 
374     auto&amp; style = layoutBox.style();
375     auto computedHeightValueIsZero = style.height().isFixed() &amp;&amp; !style.height().value();
376     if (!(style.height().isAuto() || computedHeightValueIsZero))
377         return false;
378 
379     // FIXME: Check for computed 0 height.
380     if (!style.minHeight().isAuto())
381         return false;
382 
383     // FIXME: Block replaced boxes clearly don&#39;t collapse through their margins, but I couldn&#39;t find it in the spec yet (and no, it&#39;s not a quirk).
384     if (layoutBox.replaced())
385         return false;
386 
387     if (!is&lt;Container&gt;(layoutBox))
388         return true;
389 
390     if (!downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
391         return !establishesBlockFormattingContext(layoutBox);
392 
393     if (layoutBox.establishesFormattingContext()) {
394         if (layoutBox.establishesInlineFormattingContext()) {

395             // If we get here through margin estimation, we don&#39;t necessarily have an actual state for this layout box since
396             // we haven&#39;t started laying it out yet.
<span class="line-modified">397             if (!layoutState.hasFormattingState(layoutBox))</span>
<span class="line-modified">398                 return false;</span>
<span class="line-removed">399             auto&amp; formattingState = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox));</span>
<span class="line-removed">400             if (!formattingState.inlineRuns().isEmpty())</span>
401                 return false;
<span class="line-modified">402             // Any float box in this formatting context prevents collapsing through.</span>
<span class="line-modified">403             auto&amp; floats = formattingState.floatingState().floats();</span>
<span class="line-modified">404             for (auto&amp; floatItem : floats) {</span>
<span class="line-modified">405                 if (floatItem.isDescendantOfFormattingRoot(downcast&lt;Container&gt;(layoutBox)))</span>
<span class="line-modified">406                     return false;</span>
<span class="line-modified">407             }</span>
<span class="line-modified">408             return true;</span>











409         }
410 
411         // A root of a non-inline formatting context (table, flex etc) with inflow descendants should not collapse through.
412         return false;
413     }
414 
415     for (auto* inflowChild = downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild(); inflowChild; inflowChild = inflowChild-&gt;nextInFlowOrFloatingSibling()) {
416         if (establishesBlockFormattingContext(*inflowChild))
417             return false;
<span class="line-modified">418         if (!marginsCollapseThrough(layoutState, *inflowChild))</span>
419             return false;
420     }
421     return true;
422 }
423 
424 static PositiveAndNegativeVerticalMargin::Values computedPositiveAndNegativeMargin(PositiveAndNegativeVerticalMargin::Values a, PositiveAndNegativeVerticalMargin::Values b)
425 {
426     PositiveAndNegativeVerticalMargin::Values computedValues;
427     if (a.positive &amp;&amp; b.positive)
428         computedValues.positive = std::max(*a.positive, *b.positive);
429     else
430         computedValues.positive = a.positive ? a.positive : b.positive;
431 
432     if (a.negative &amp;&amp; b.negative)
433         computedValues.negative = std::min(*a.negative, *b.negative);
434     else
435         computedValues.negative = a.negative ? a.negative : b.negative;
436 
437     if (a.isNonZero() &amp;&amp; b.isNonZero())
438         computedValues.isQuirk = a.isQuirk || b.isQuirk;
</pre>
<hr />
<pre>
441     else
442         computedValues.isQuirk = b.isQuirk;
443 
444     return computedValues;
445 }
446 
447 static Optional&lt;LayoutUnit&gt; marginValue(PositiveAndNegativeVerticalMargin::Values marginValues)
448 {
449     // When two or more margins collapse, the resulting margin width is the maximum of the collapsing margins&#39; widths.
450     // In the case of negative margins, the maximum of the absolute values of the negative adjoining margins is deducted from the maximum
451     // of the positive adjoining margins. If there are no positive margins, the maximum of the absolute values of the adjoining margins is deducted from zero.
452     if (!marginValues.negative)
453         return marginValues.positive;
454 
455     if (!marginValues.positive)
456         return marginValues.negative;
457 
458     return *marginValues.positive + *marginValues.negative;
459 }
460 
<span class="line-modified">461 void BlockFormattingContext::MarginCollapse::updateMarginAfterForPreviousSibling(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
462 {
463     // 1. Get the margin before value from the next in-flow sibling. This is the same as this box&#39;s margin after value now since they are collapsed.
464     // 2. Update the collapsed margin after value as well as the positive/negative cache.
465     // 3. Check if the box&#39;s margins collapse through.
<span class="line-modified">466     // 4. If so, update the collapsed margin before value as well as the positive/negative cache.</span>
467     // 5. In case of collapsed through margins check if the before margin collapes with the previous inflow sibling&#39;s after margin.
468     // 6. If so, jump to #2.
<span class="line-modified">469     // 7. No need to propagate to parent because its margin is not computed yet (estimated at most).</span>
470     auto* currentBox = &amp;layoutBox;
<span class="line-modified">471     while (marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *currentBox)) {</span>

472         auto&amp; previousSibling = *currentBox-&gt;previousInFlowSibling();
<span class="line-modified">473         auto&amp; previousSiblingDisplayBox = layoutState.displayBoxForLayoutBox(previousSibling);</span>
474         auto previousSiblingVerticalMargin = previousSiblingDisplayBox.verticalMargin();
475 
476         auto collapsedVerticalMarginBefore = previousSiblingVerticalMargin.collapsedValues().before;
<span class="line-modified">477         auto collapsedVerticalMarginAfter = layoutState.displayBoxForLayoutBox(*currentBox).verticalMargin().before();</span>
478 
<span class="line-modified">479         auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, previousSibling);</span>
480         if (marginsCollapseThrough)
481             collapsedVerticalMarginBefore = collapsedVerticalMarginAfter;
482 
<span class="line-removed">483         // Update collapsed vertical margin values.</span>
<span class="line-removed">484         previousSiblingVerticalMargin.setCollapsedValues({ collapsedVerticalMarginBefore, collapsedVerticalMarginAfter });</span>
<span class="line-removed">485         previousSiblingDisplayBox.setVerticalMargin(previousSiblingVerticalMargin);</span>
<span class="line-removed">486 </span>
487         // Update positive/negative cache.
<span class="line-removed">488         auto&amp; blockFormattingState = downcast&lt;BlockFormattingState&gt;(layoutState.formattingStateForBox(previousSibling));</span>
489         auto previousSiblingPositiveNegativeMargin = blockFormattingState.positiveAndNegativeVerticalMargin(previousSibling);
490         auto positiveNegativeMarginBefore = blockFormattingState.positiveAndNegativeVerticalMargin(*currentBox).before;
491 
492         previousSiblingPositiveNegativeMargin.after = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, previousSiblingPositiveNegativeMargin.after);
493         if (marginsCollapseThrough) {
494             previousSiblingPositiveNegativeMargin.before = computedPositiveAndNegativeMargin(previousSiblingPositiveNegativeMargin.before, previousSiblingPositiveNegativeMargin.after);
495             previousSiblingPositiveNegativeMargin.after = previousSiblingPositiveNegativeMargin.before;
496         }
497         blockFormattingState.setPositiveAndNegativeVerticalMargin(previousSibling, previousSiblingPositiveNegativeMargin);
498 
499         if (!marginsCollapseThrough)
500             break;
501 
502         currentBox = &amp;previousSibling;
503     }
504 }
505 
<span class="line-modified">506 PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeValues(const LayoutState&amp; layoutState, const Box&amp; layoutBox, MarginType marginType)</span>
507 {

508     auto&amp; blockFormattingState = downcast&lt;BlockFormattingState&gt;(layoutState.formattingStateForBox(layoutBox));
509     if (blockFormattingState.hasPositiveAndNegativeVerticalMargin(layoutBox)) {
510         auto positiveAndNegativeVerticalMargin = blockFormattingState.positiveAndNegativeVerticalMargin(layoutBox);
511         return marginType == MarginType::Before ? positiveAndNegativeVerticalMargin.before : positiveAndNegativeVerticalMargin.after;
512     }
<span class="line-modified">513     // This is the estimate path. We don&#39;t yet have positive/negative margin computed.</span>
<span class="line-modified">514     auto usedValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };</span>
<span class="line-removed">515     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedValues);</span>
516     auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
517 
518     if (marginType == MarginType::Before)
<span class="line-modified">519         return positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedMargin);</span>
<span class="line-modified">520     return positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedMargin);</span>
521 }
522 
<span class="line-modified">523 PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
524 {
525     auto firstChildCollapsedMarginBefore = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="line-modified">526         if (!marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutState, layoutBox))</span>
527             return { };
<span class="line-modified">528         return positiveNegativeValues(layoutState, *downcast&lt;Container&gt;(layoutBox).firstInFlowChild(), MarginType::Before);</span>
529     };
530 
531     auto previouSiblingCollapsedMarginAfter = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="line-modified">532         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, layoutBox))</span>
533             return { };
<span class="line-modified">534         return positiveNegativeValues(layoutState, *layoutBox.previousInFlowSibling(), MarginType::After);</span>
535     };
536 
537     // 1. Gather positive and negative margin values from first child if margins are adjoining.
538     // 2. Gather positive and negative margin values from previous inflow sibling if margins are adjoining.
539     // 3. Compute min/max positive and negative collapsed margin values using non-collpased computed margin before.
540     auto collapsedMarginBefore = computedPositiveAndNegativeMargin(firstChildCollapsedMarginBefore(), previouSiblingCollapsedMarginAfter());
<span class="line-modified">541     if (collapsedMarginBefore.isQuirk &amp;&amp; Quirks::shouldIgnoreCollapsedQuirkMargin(layoutState, layoutBox))</span>
542         collapsedMarginBefore = { };
543 
544     PositiveAndNegativeVerticalMargin::Values nonCollapsedBefore;
545     if (nonCollapsedValues.before &gt; 0)
546         nonCollapsedBefore = { nonCollapsedValues.before, { }, layoutBox.style().hasMarginBeforeQuirk() };
547     else if (nonCollapsedValues.before &lt; 0)
548         nonCollapsedBefore = { { }, nonCollapsedValues.before, layoutBox.style().hasMarginBeforeQuirk() };
549 
550     return computedPositiveAndNegativeMargin(collapsedMarginBefore, nonCollapsedBefore);
551 }
552 
<span class="line-modified">553 PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
554 {
555     auto lastChildCollapsedMarginAfter = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="line-modified">556         if (!marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutState, layoutBox))</span>
557             return { };
<span class="line-modified">558         return positiveNegativeValues(layoutState, *downcast&lt;Container&gt;(layoutBox).lastInFlowChild(), MarginType::After);</span>
559     };
560 
561     // We don&#39;t know yet the margin before value of the next sibling. Let&#39;s just pretend it does not have one and
<span class="line-modified">562     // update it later when we compute the next sibling&#39;s margin before. See updateCollapsedMarginAfter.</span>
563     PositiveAndNegativeVerticalMargin::Values nonCollapsedAfter;
564     if (nonCollapsedValues.after &gt; 0)
565         nonCollapsedAfter = { nonCollapsedValues.after, { }, layoutBox.style().hasMarginAfterQuirk() };
566     else if (nonCollapsedValues.after &lt; 0)
567         nonCollapsedAfter = { { }, nonCollapsedValues.after, layoutBox.style().hasMarginAfterQuirk() };
568 
569     return computedPositiveAndNegativeMargin(lastChildCollapsedMarginAfter(), nonCollapsedAfter);
570 }
571 
<span class="line-modified">572 EstimatedMarginBefore BlockFormattingContext::MarginCollapse::estimatedMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
573 {
<span class="line-removed">574     if (layoutBox.isAnonymous())</span>
<span class="line-removed">575         return { };</span>
<span class="line-removed">576 </span>
577     ASSERT(layoutBox.isBlockLevelBox());
<span class="line-modified">578     // Don&#39;t estimate vertical margins for out of flow boxes.</span>
579     ASSERT(layoutBox.isInFlow() || layoutBox.isFloatingPositioned());
580     ASSERT(!layoutBox.replaced());
581 
<span class="line-modified">582     auto usedValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };</span>
<span class="line-modified">583     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedValues);</span>
<span class="line-removed">584     auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };</span>
<span class="line-removed">585     auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, layoutBox);</span>
<span class="line-removed">586     auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedMargin);</span>
587 
588     auto collapsedMarginBefore = marginValue(!marginsCollapseThrough ? positiveNegativeMarginBefore
<span class="line-modified">589         : computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedMargin)));</span>
590 
<span class="line-modified">591     return { nonCollapsedMargin.before, collapsedMarginBefore, marginsCollapseThrough };</span>
592 }
593 
<span class="line-modified">594 LayoutUnit BlockFormattingContext::MarginCollapse::marginBeforeIgnoringCollapsingThrough(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
595 {
<span class="line-removed">596     ASSERT(!layoutBox.isAnonymous());</span>
597     ASSERT(layoutBox.isBlockLevelBox());
<span class="line-modified">598     return marginValue(positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues)).valueOr(nonCollapsedValues.before);</span>
599 }
600 
<span class="line-modified">601 void BlockFormattingContext::MarginCollapse::updatePositiveNegativeMarginValues(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
602 {
603     ASSERT(layoutBox.isBlockLevelBox());
<span class="line-modified">604     auto nonCollapsedValues = layoutState.displayBoxForLayoutBox(layoutBox).verticalMargin().nonCollapsedValues();</span>
<span class="line-modified">605 </span>
<span class="line-removed">606     auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues);</span>
<span class="line-removed">607     auto positiveNegativeMarginAfter = MarginCollapse::positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedValues);</span>
608 
<span class="line-modified">609     if (MarginCollapse::marginsCollapseThrough(layoutState, layoutBox)) {</span>
610         positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
611         positiveNegativeMarginAfter = positiveNegativeMarginBefore;
612     }
<span class="line-modified">613     auto&amp; blockFormattingState = downcast&lt;BlockFormattingState&gt;(layoutState.formattingStateForBox(layoutBox));</span>
<span class="line-removed">614     blockFormattingState.setPositiveAndNegativeVerticalMargin(layoutBox, { positiveNegativeMarginBefore, positiveNegativeMarginAfter });</span>
615 }
616 
<span class="line-modified">617 UsedVerticalMargin::CollapsedValues BlockFormattingContext::MarginCollapse::collapsedVerticalValues(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
618 {
<span class="line-removed">619     if (layoutBox.isAnonymous())</span>
<span class="line-removed">620         return { };</span>
<span class="line-removed">621 </span>
622     ASSERT(layoutBox.isBlockLevelBox());
623     // 1. Get min/max margin top values from the first in-flow child if we are collapsing margin top with it.
624     // 2. Get min/max margin top values from the previous in-flow sibling, if we are collapsing margin top with it.
625     // 3. Get this layout box&#39;s computed margin top value.
626     // 4. Update the min/max value and compute the final margin.
<span class="line-modified">627     auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues);</span>
<span class="line-modified">628     auto positiveNegativeMarginAfter = MarginCollapse::positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedValues);</span>
629 
<span class="line-modified">630     auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, layoutBox);</span>
631     if (marginsCollapseThrough) {
632         positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
633         positiveNegativeMarginAfter = positiveNegativeMarginBefore;
634     }
635 
<span class="line-modified">636     auto beforeMarginIsCollapsedValue = marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutState, layoutBox) || marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, layoutBox);</span>
<span class="line-modified">637     auto afterMarginIsCollapsedValue = marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutState, layoutBox);</span>
638 
639     if ((beforeMarginIsCollapsedValue &amp;&amp; afterMarginIsCollapsedValue) || marginsCollapseThrough)
640         return { marginValue(positiveNegativeMarginBefore), marginValue(positiveNegativeMarginAfter), marginsCollapseThrough };
641     if (beforeMarginIsCollapsedValue)
642         return { marginValue(positiveNegativeMarginBefore), { }, false };
643     return { { }, marginValue(positiveNegativeMarginAfter), false };
644 }
645 
646 }
647 }
648 #endif
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BlockFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<span class="line-added"> 31 #include &quot;BlockFormattingState.h&quot;</span>
<span class="line-added"> 32 #include &quot;FloatingState.h&quot;</span>
 33 #include &quot;InlineFormattingState.h&quot;
 34 #include &quot;LayoutBox.h&quot;
 35 #include &quot;LayoutContainer.h&quot;
 36 #include &quot;LayoutUnit.h&quot;
 37 #include &quot;RenderStyle.h&quot;
 38 
 39 namespace WebCore {
 40 namespace Layout {
 41 
 42 static bool hasBorder(const BorderValue&amp; borderValue)
 43 {
 44     if (borderValue.style() == BorderStyle::None || borderValue.style() == BorderStyle::Hidden)
 45         return false;
 46     return !!borderValue.width();
 47 }
 48 
 49 static bool hasPadding(const Length&amp; paddingValue)
 50 {
 51     // FIXME: Check if percent value needs to be resolved.
 52     return !paddingValue.isZero();
</pre>
<hr />
<pre>
 55 static bool hasBorderBefore(const Box&amp; layoutBox)
 56 {
 57     return hasBorder(layoutBox.style().borderBefore());
 58 }
 59 
 60 static bool hasBorderAfter(const Box&amp; layoutBox)
 61 {
 62     return hasBorder(layoutBox.style().borderAfter());
 63 }
 64 
 65 static bool hasPaddingBefore(const Box&amp; layoutBox)
 66 {
 67     return hasPadding(layoutBox.style().paddingBefore());
 68 }
 69 
 70 static bool hasPaddingAfter(const Box&amp; layoutBox)
 71 {
 72     return hasPadding(layoutBox.style().paddingAfter());
 73 }
 74 







 75 static bool establishesBlockFormattingContext(const Box&amp; layoutBox)
 76 {
 77     // WebKit treats the document element renderer as a block formatting context root. It probably only impacts margin collapsing, so let&#39;s not do
 78     // a layout wide quirk on this for now.
 79     if (layoutBox.isDocumentBox())
 80         return true;
 81     return layoutBox.establishesBlockFormattingContext();
 82 }
 83 
<span class="line-modified"> 84 bool BlockFormattingContext::MarginCollapse::hasClearance(const Box&amp; layoutBox) const</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     if (!layoutBox.hasFloatClear())</span>
<span class="line-added"> 87         return false;</span>
<span class="line-added"> 88     // FIXME: precomputedVerticalPositionForFormattingRoot logic ends up calling into this function when the layoutBox (first inflow child) has</span>
<span class="line-added"> 89     // not been laid out.</span>
<span class="line-added"> 90     if (!layoutState().hasDisplayBox(layoutBox))</span>
<span class="line-added"> 91         return false;</span>
<span class="line-added"> 92     return formattingContext().geometryForBox(layoutBox).hasClearance();</span>
<span class="line-added"> 93 }</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(const Box&amp; layoutBox) const</span>
 96 {
 97     // 1. This is the last in-flow child and its margins collapse through and the margin after collapses with parent&#39;s margin after or
 98     // 2. This box&#39;s margin after collapses with the next sibling&#39;s margin before and that sibling collapses through and
 99     // we can get to the last in-flow child like that.
100     auto* lastInFlowChild = layoutBox.parent()-&gt;lastInFlowChild();
101     for (auto* currentBox = &amp;layoutBox; currentBox; currentBox = currentBox-&gt;nextInFlowSibling()) {
<span class="line-modified">102         if (!marginsCollapseThrough(*currentBox))</span>
103             return false;
104         if (currentBox == lastInFlowChild)
<span class="line-modified">105             return marginAfterCollapsesWithParentMarginAfter(*currentBox);</span>
<span class="line-modified">106         if (!marginAfterCollapsesWithNextSiblingMarginBefore(*currentBox))</span>
107             return false;
108     }
109     ASSERT_NOT_REACHED();
110     return false;
111 }
112 
<span class="line-modified">113 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(const Box&amp; layoutBox) const</span>
114 {
115     // The first inflow child could propagate its top margin to parent.
116     // https://www.w3.org/TR/CSS21/box.html#collapsing-margins



117     ASSERT(layoutBox.isBlockLevelBox());
118 
119     // Margins between a floated box and any other box do not collapse.
120     if (layoutBox.isFloatingPositioned())
121         return false;
122 
123     // Margins of absolutely positioned boxes do not collapse.
124     if (layoutBox.isOutOfFlowPositioned())
125         return false;
126 
127     // Margins of inline-block boxes do not collapse.
128     if (layoutBox.isInlineBlockBox())
129         return false;
130 
131     // Only the first inlflow child collapses with parent.
132     if (layoutBox.previousInFlowSibling())
133         return false;
134 
135     auto&amp; parent = *layoutBox.parent();
136     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children
137     if (establishesBlockFormattingContext(parent))
138         return false;
139 
140     if (hasBorderBefore(parent))
141         return false;
142 
143     if (hasPaddingBefore(parent))
144         return false;
145 
146     // ...and the child has no clearance.
<span class="line-modified">147     if (hasClearance(layoutBox))</span>
148         return false;
149 
150     return true;
151 }
152 
<span class="line-modified">153 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithPreviousSiblingMarginAfter(const Box&amp; layoutBox) const</span>
154 {
155     ASSERT(layoutBox.isBlockLevelBox());
156 



157     if (!layoutBox.previousInFlowSibling())
158         return false;
159 
160     auto&amp; previousInFlowSibling = *layoutBox.previousInFlowSibling();



161     // Margins between a floated box and any other box do not collapse.
162     if (layoutBox.isFloatingPositioned() || previousInFlowSibling.isFloatingPositioned())
163         return false;
164 
165     // Margins of absolutely positioned boxes do not collapse.
166     if ((layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.style().top().isAuto())
167         || (previousInFlowSibling.isOutOfFlowPositioned() &amp;&amp; !previousInFlowSibling.style().bottom().isAuto()))
168         return false;
169 
170     // Margins of inline-block boxes do not collapse.
171     if (layoutBox.isInlineBlockBox() || previousInFlowSibling.isInlineBlockBox())
172         return false;
173 
174     // The bottom margin of an in-flow block-level element always collapses with the top margin of
175     // its next in-flow block-level sibling, unless that sibling has clearance.
<span class="line-modified">176     if (hasClearance(layoutBox))</span>
177         return false;
178 
179     return true;
180 }
181 
<span class="line-modified">182 bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const Box&amp; layoutBox) const</span>
183 {



184     ASSERT(layoutBox.isBlockLevelBox());
185     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
186     if (establishesBlockFormattingContext(layoutBox))
187         return false;
188 
189     // The top margin of an in-flow block element collapses with its first in-flow block-level
190     // child&#39;s top margin if the element has no top border...
191     if (hasBorderBefore(layoutBox))
192         return false;
193 
194     // ...no top padding
195     if (hasPaddingBefore(layoutBox))
196         return false;
197 
198     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
199         return false;
200 
201     auto&amp; firstInFlowChild = *downcast&lt;Container&gt;(layoutBox).firstInFlowChild();
202     if (!firstInFlowChild.isBlockLevelBox())
203         return false;
204 
205     // ...and the child has no clearance.
<span class="line-modified">206     if (hasClearance(firstInFlowChild))</span>
207         return false;
208 
209     // Margins of inline-block boxes do not collapse.
210     if (firstInFlowChild.isInlineBlockBox())
211         return false;
212 
213     return true;
214 }
215 
<span class="line-modified">216 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const Box&amp; layoutBox) const</span>
217 {
218     // If the top and bottom margins of an element with clearance are adjoining, its margins collapse with the adjoining margins
219     // of following siblings but that resulting margin does not collapse with the bottom margin of the parent block.
<span class="line-modified">220     if (!marginsCollapseThrough(layoutBox))</span>
221         return false;
222 
223     for (auto* previousSibling = layoutBox.previousInFlowSibling(); previousSibling; previousSibling = previousSibling-&gt;previousInFlowSibling()) {
<span class="line-modified">224         if (!marginsCollapseThrough(*previousSibling))</span>
225             return false;
<span class="line-modified">226         if (hasClearance(*previousSibling))</span>
227             return true;
228     }
229     return false;
230 }
231 
<span class="line-modified">232 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginBefore(const Box&amp; layoutBox) const</span>
233 {
234     // 1. This is the first in-flow child and its margins collapse through and the margin before collapses with parent&#39;s margin before or
235     // 2. This box&#39;s margin before collapses with the previous sibling&#39;s margin after and that sibling collapses through and
236     // we can get to the first in-flow child like that.
237     auto* firstInFlowChild = layoutBox.parent()-&gt;firstInFlowChild();
238     for (auto* currentBox = &amp;layoutBox; currentBox; currentBox = currentBox-&gt;previousInFlowSibling()) {
<span class="line-modified">239         if (!marginsCollapseThrough(*currentBox))</span>
240             return false;
241         if (currentBox == firstInFlowChild)
<span class="line-modified">242             return marginBeforeCollapsesWithParentMarginBefore(*currentBox);</span>
<span class="line-modified">243         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(*currentBox))</span>
244             return false;
245     }
246     ASSERT_NOT_REACHED();
247     return false;
248 }
249 
<span class="line-modified">250 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginAfter(const Box&amp; layoutBox) const</span>
251 {



252     ASSERT(layoutBox.isBlockLevelBox());
253 
254     // Margins between a floated box and any other box do not collapse.
255     if (layoutBox.isFloatingPositioned())
256         return false;
257 
258     // Margins of absolutely positioned boxes do not collapse.
259     if (layoutBox.isOutOfFlowPositioned())
260         return false;
261 
262     // Margins of inline-block boxes do not collapse.
263     if (layoutBox.isInlineBlockBox())
264         return false;
265 
266     // Only the last inlflow child collapses with parent.
267     if (layoutBox.nextInFlowSibling())
268         return false;
269 
270     auto&amp; parent = *layoutBox.parent();
271     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
272     if (establishesBlockFormattingContext(parent))
273         return false;
274 
275     // The bottom margin of an in-flow block box with a &#39;height&#39; of &#39;auto&#39; collapses with its last in-flow block-level child&#39;s bottom margin, if:
276     if (!parent.style().height().isAuto())
277         return false;
278 
279     // the box has no bottom padding, and
280     if (hasPaddingAfter(parent))
281         return false;
282 
283     // the box has no bottom border, and
284     if (hasBorderAfter(parent))
285         return false;
286 
287     // the child&#39;s bottom margin neither collapses with a top margin that has clearance...
<span class="line-modified">288     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutBox))</span>
289         return false;
290 
291     // nor (if the box&#39;s min-height is non-zero) with the box&#39;s top margin.
292     auto computedMinHeight = parent.style().logicalMinHeight();
<span class="line-modified">293     if (!computedMinHeight.isAuto() &amp;&amp; computedMinHeight.value() &amp;&amp; marginAfterCollapsesWithParentMarginBefore(layoutBox))</span>
294         return false;
295 
296     return true;
297 }
298 
<span class="line-modified">299 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithLastInFlowChildMarginAfter(const Box&amp; layoutBox) const</span>
300 {
301     ASSERT(layoutBox.isBlockLevelBox());
302 
303     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
304     if (establishesBlockFormattingContext(layoutBox))
305         return false;
306 
307     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
308         return false;
309 
310     auto&amp; lastInFlowChild = *downcast&lt;Container&gt;(layoutBox).lastInFlowChild();
311     if (!lastInFlowChild.isBlockLevelBox())
312         return false;
313 
314     // The bottom margin of an in-flow block box with a &#39;height&#39; of &#39;auto&#39; collapses with its last in-flow block-level child&#39;s bottom margin, if:
315     if (!layoutBox.style().height().isAuto())
316         return false;
317 
318     // the box has no bottom padding, and
319     if (hasPaddingAfter(layoutBox))
320         return false;
321 
322     // the box has no bottom border, and
323     if (hasBorderAfter(layoutBox))
324         return false;
325 
326     // the child&#39;s bottom margin neither collapses with a top margin that has clearance...
<span class="line-modified">327     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(lastInFlowChild))</span>
328         return false;
329 
330     // nor (if the box&#39;s min-height is non-zero) with the box&#39;s top margin.
331     auto computedMinHeight = layoutBox.style().logicalMinHeight();
332     if (!computedMinHeight.isAuto() &amp;&amp; computedMinHeight.value()
<span class="line-modified">333         &amp;&amp; (marginAfterCollapsesWithParentMarginBefore(lastInFlowChild) || hasClearance(lastInFlowChild)))</span>
334         return false;
335 
336     // Margins of inline-block boxes do not collapse.
337     if (lastInFlowChild.isInlineBlockBox())
338         return false;
339 
<span class="line-added">340     // This is a quirk behavior: When the margin after of the last inflow child (or a previous sibling with collapsed through margins)</span>
<span class="line-added">341     // collapses with a quirk parent&#39;s the margin before, then the same margin after does not collapses with the parent&#39;s margin after.</span>
<span class="line-added">342     if (formattingContext().quirks().shouldIgnoreCollapsedQuirkMargin(layoutBox) &amp;&amp; marginAfterCollapsesWithParentMarginBefore(lastInFlowChild))</span>
<span class="line-added">343         return false;</span>
<span class="line-added">344 </span>
345     return true;
346 }
347 
<span class="line-modified">348 bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithNextSiblingMarginBefore(const Box&amp; layoutBox) const</span>
349 {
350     ASSERT(layoutBox.isBlockLevelBox());
351 
352     if (!layoutBox.nextInFlowSibling())
353         return false;
354 
<span class="line-modified">355     return marginBeforeCollapsesWithPreviousSiblingMarginAfter(*layoutBox.nextInFlowSibling());</span>
356 }
357 
<span class="line-modified">358 bool BlockFormattingContext::MarginCollapse::marginsCollapseThrough(const Box&amp; layoutBox) const</span>
359 {
360     ASSERT(layoutBox.isBlockLevelBox());
361 
362     // A box&#39;s own margins collapse if the &#39;min-height&#39; property is zero, and it has neither top or bottom borders nor top or bottom padding,
363     // and it has a &#39;height&#39; of either 0 or &#39;auto&#39;, and it does not contain a line box, and all of its in-flow children&#39;s margins (if any) collapse.
364     if (hasBorderBefore(layoutBox) || hasBorderAfter(layoutBox))
365         return false;
366 
367     if (hasPaddingBefore(layoutBox) || hasPaddingAfter(layoutBox))
368         return false;
369 
370     auto&amp; style = layoutBox.style();
371     auto computedHeightValueIsZero = style.height().isFixed() &amp;&amp; !style.height().value();
372     if (!(style.height().isAuto() || computedHeightValueIsZero))
373         return false;
374 
375     // FIXME: Check for computed 0 height.
376     if (!style.minHeight().isAuto())
377         return false;
378 
379     // FIXME: Block replaced boxes clearly don&#39;t collapse through their margins, but I couldn&#39;t find it in the spec yet (and no, it&#39;s not a quirk).
380     if (layoutBox.replaced())
381         return false;
382 
383     if (!is&lt;Container&gt;(layoutBox))
384         return true;
385 
386     if (!downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
387         return !establishesBlockFormattingContext(layoutBox);
388 
389     if (layoutBox.establishesFormattingContext()) {
390         if (layoutBox.establishesInlineFormattingContext()) {
<span class="line-added">391             auto&amp; layoutState = this-&gt;layoutState();</span>
392             // If we get here through margin estimation, we don&#39;t necessarily have an actual state for this layout box since
393             // we haven&#39;t started laying it out yet.
<span class="line-modified">394             auto&amp; layoutContainer = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified">395             if (!layoutState.hasInlineFormattingState(layoutContainer))</span>


396                 return false;
<span class="line-modified">397 </span>
<span class="line-modified">398             auto isConsideredEmpty = [&amp;] {</span>
<span class="line-modified">399                 auto&amp; formattingState = layoutState.establishedInlineFormattingState(layoutContainer);</span>
<span class="line-modified">400                 if (auto* inlineContent = formattingState.displayInlineContent()) {</span>
<span class="line-modified">401                     for (auto&amp; lineBox : inlineContent-&gt;lineBoxes) {</span>
<span class="line-modified">402                         if (!lineBox.isConsideredEmpty())</span>
<span class="line-modified">403                             return false;</span>
<span class="line-added">404                     }</span>
<span class="line-added">405                 }</span>
<span class="line-added">406                 // Any float box in this formatting context prevents collapsing through.</span>
<span class="line-added">407                 auto&amp; floats = formattingState.floatingState().floats();</span>
<span class="line-added">408                 for (auto&amp; floatItem : floats) {</span>
<span class="line-added">409                     if (floatItem.isDescendantOfFormattingRoot(layoutContainer))</span>
<span class="line-added">410                         return false;</span>
<span class="line-added">411                 }</span>
<span class="line-added">412                 return true;</span>
<span class="line-added">413             };</span>
<span class="line-added">414             return isConsideredEmpty();</span>
415         }
416 
417         // A root of a non-inline formatting context (table, flex etc) with inflow descendants should not collapse through.
418         return false;
419     }
420 
421     for (auto* inflowChild = downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild(); inflowChild; inflowChild = inflowChild-&gt;nextInFlowOrFloatingSibling()) {
422         if (establishesBlockFormattingContext(*inflowChild))
423             return false;
<span class="line-modified">424         if (!marginsCollapseThrough(*inflowChild))</span>
425             return false;
426     }
427     return true;
428 }
429 
430 static PositiveAndNegativeVerticalMargin::Values computedPositiveAndNegativeMargin(PositiveAndNegativeVerticalMargin::Values a, PositiveAndNegativeVerticalMargin::Values b)
431 {
432     PositiveAndNegativeVerticalMargin::Values computedValues;
433     if (a.positive &amp;&amp; b.positive)
434         computedValues.positive = std::max(*a.positive, *b.positive);
435     else
436         computedValues.positive = a.positive ? a.positive : b.positive;
437 
438     if (a.negative &amp;&amp; b.negative)
439         computedValues.negative = std::min(*a.negative, *b.negative);
440     else
441         computedValues.negative = a.negative ? a.negative : b.negative;
442 
443     if (a.isNonZero() &amp;&amp; b.isNonZero())
444         computedValues.isQuirk = a.isQuirk || b.isQuirk;
</pre>
<hr />
<pre>
447     else
448         computedValues.isQuirk = b.isQuirk;
449 
450     return computedValues;
451 }
452 
453 static Optional&lt;LayoutUnit&gt; marginValue(PositiveAndNegativeVerticalMargin::Values marginValues)
454 {
455     // When two or more margins collapse, the resulting margin width is the maximum of the collapsing margins&#39; widths.
456     // In the case of negative margins, the maximum of the absolute values of the negative adjoining margins is deducted from the maximum
457     // of the positive adjoining margins. If there are no positive margins, the maximum of the absolute values of the adjoining margins is deducted from zero.
458     if (!marginValues.negative)
459         return marginValues.positive;
460 
461     if (!marginValues.positive)
462         return marginValues.negative;
463 
464     return *marginValues.positive + *marginValues.negative;
465 }
466 
<span class="line-modified">467 void BlockFormattingContext::MarginCollapse::updateMarginAfterForPreviousSibling(BlockFormattingContext&amp; blockFormattingContext, const MarginCollapse&amp; marginCollapse, const Box&amp; layoutBox)</span>
468 {
469     // 1. Get the margin before value from the next in-flow sibling. This is the same as this box&#39;s margin after value now since they are collapsed.
470     // 2. Update the collapsed margin after value as well as the positive/negative cache.
471     // 3. Check if the box&#39;s margins collapse through.
<span class="line-modified">472     // 4. If so, update the positive/negative cache.</span>
473     // 5. In case of collapsed through margins check if the before margin collapes with the previous inflow sibling&#39;s after margin.
474     // 6. If so, jump to #2.
<span class="line-modified">475     // 7. No need to propagate to parent because its margin is not computed yet (pre-computed at most).</span>
476     auto* currentBox = &amp;layoutBox;
<span class="line-modified">477     auto&amp; blockFormattingState = blockFormattingContext.formattingState();</span>
<span class="line-added">478     while (marginCollapse.marginBeforeCollapsesWithPreviousSiblingMarginAfter(*currentBox)) {</span>
479         auto&amp; previousSibling = *currentBox-&gt;previousInFlowSibling();
<span class="line-modified">480         auto&amp; previousSiblingDisplayBox = blockFormattingState.displayBox(previousSibling);</span>
481         auto previousSiblingVerticalMargin = previousSiblingDisplayBox.verticalMargin();
482 
483         auto collapsedVerticalMarginBefore = previousSiblingVerticalMargin.collapsedValues().before;
<span class="line-modified">484         auto collapsedVerticalMarginAfter = blockFormattingContext.geometryForBox(*currentBox).verticalMargin().before();</span>
485 
<span class="line-modified">486         auto marginsCollapseThrough = marginCollapse.marginsCollapseThrough(previousSibling);</span>
487         if (marginsCollapseThrough)
488             collapsedVerticalMarginBefore = collapsedVerticalMarginAfter;
489 




490         // Update positive/negative cache.

491         auto previousSiblingPositiveNegativeMargin = blockFormattingState.positiveAndNegativeVerticalMargin(previousSibling);
492         auto positiveNegativeMarginBefore = blockFormattingState.positiveAndNegativeVerticalMargin(*currentBox).before;
493 
494         previousSiblingPositiveNegativeMargin.after = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, previousSiblingPositiveNegativeMargin.after);
495         if (marginsCollapseThrough) {
496             previousSiblingPositiveNegativeMargin.before = computedPositiveAndNegativeMargin(previousSiblingPositiveNegativeMargin.before, previousSiblingPositiveNegativeMargin.after);
497             previousSiblingPositiveNegativeMargin.after = previousSiblingPositiveNegativeMargin.before;
498         }
499         blockFormattingState.setPositiveAndNegativeVerticalMargin(previousSibling, previousSiblingPositiveNegativeMargin);
500 
501         if (!marginsCollapseThrough)
502             break;
503 
504         currentBox = &amp;previousSibling;
505     }
506 }
507 
<span class="line-modified">508 PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeValues(const Box&amp; layoutBox, MarginType marginType) const</span>
509 {
<span class="line-added">510     auto&amp; layoutState = this-&gt;layoutState();</span>
511     auto&amp; blockFormattingState = downcast&lt;BlockFormattingState&gt;(layoutState.formattingStateForBox(layoutBox));
512     if (blockFormattingState.hasPositiveAndNegativeVerticalMargin(layoutBox)) {
513         auto positiveAndNegativeVerticalMargin = blockFormattingState.positiveAndNegativeVerticalMargin(layoutBox);
514         return marginType == MarginType::Before ? positiveAndNegativeVerticalMargin.before : positiveAndNegativeVerticalMargin.after;
515     }
<span class="line-modified">516     // This is the pre-computed path. We don&#39;t yet have positive/negative margin computed.</span>
<span class="line-modified">517     auto computedVerticalMargin = formattingContext().geometry().computedVerticalMargin(layoutBox, Geometry::horizontalConstraintsForInFlow(formattingContext().geometryForBox(*layoutBox.containingBlock())));</span>

518     auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
519 
520     if (marginType == MarginType::Before)
<span class="line-modified">521         return positiveNegativeMarginBefore(layoutBox, nonCollapsedMargin);</span>
<span class="line-modified">522     return positiveNegativeMarginAfter(layoutBox, nonCollapsedMargin);</span>
523 }
524 
<span class="line-modified">525 PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginBefore(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues) const</span>
526 {
527     auto firstChildCollapsedMarginBefore = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="line-modified">528         if (!marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutBox))</span>
529             return { };
<span class="line-modified">530         return positiveNegativeValues(*downcast&lt;Container&gt;(layoutBox).firstInFlowChild(), MarginType::Before);</span>
531     };
532 
533     auto previouSiblingCollapsedMarginAfter = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="line-modified">534         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutBox))</span>
535             return { };
<span class="line-modified">536         return positiveNegativeValues(*layoutBox.previousInFlowSibling(), MarginType::After);</span>
537     };
538 
539     // 1. Gather positive and negative margin values from first child if margins are adjoining.
540     // 2. Gather positive and negative margin values from previous inflow sibling if margins are adjoining.
541     // 3. Compute min/max positive and negative collapsed margin values using non-collpased computed margin before.
542     auto collapsedMarginBefore = computedPositiveAndNegativeMargin(firstChildCollapsedMarginBefore(), previouSiblingCollapsedMarginAfter());
<span class="line-modified">543     if (collapsedMarginBefore.isQuirk &amp;&amp; formattingContext().quirks().shouldIgnoreCollapsedQuirkMargin(layoutBox))</span>
544         collapsedMarginBefore = { };
545 
546     PositiveAndNegativeVerticalMargin::Values nonCollapsedBefore;
547     if (nonCollapsedValues.before &gt; 0)
548         nonCollapsedBefore = { nonCollapsedValues.before, { }, layoutBox.style().hasMarginBeforeQuirk() };
549     else if (nonCollapsedValues.before &lt; 0)
550         nonCollapsedBefore = { { }, nonCollapsedValues.before, layoutBox.style().hasMarginBeforeQuirk() };
551 
552     return computedPositiveAndNegativeMargin(collapsedMarginBefore, nonCollapsedBefore);
553 }
554 
<span class="line-modified">555 PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginAfter(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues) const</span>
556 {
557     auto lastChildCollapsedMarginAfter = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="line-modified">558         if (!marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutBox))</span>
559             return { };
<span class="line-modified">560         return positiveNegativeValues(*downcast&lt;Container&gt;(layoutBox).lastInFlowChild(), MarginType::After);</span>
561     };
562 
563     // We don&#39;t know yet the margin before value of the next sibling. Let&#39;s just pretend it does not have one and
<span class="line-modified">564     // update it later when we compute the next sibling&#39;s margin before. See updateMarginAfterForPreviousSibling.</span>
565     PositiveAndNegativeVerticalMargin::Values nonCollapsedAfter;
566     if (nonCollapsedValues.after &gt; 0)
567         nonCollapsedAfter = { nonCollapsedValues.after, { }, layoutBox.style().hasMarginAfterQuirk() };
568     else if (nonCollapsedValues.after &lt; 0)
569         nonCollapsedAfter = { { }, nonCollapsedValues.after, layoutBox.style().hasMarginAfterQuirk() };
570 
571     return computedPositiveAndNegativeMargin(lastChildCollapsedMarginAfter(), nonCollapsedAfter);
572 }
573 
<span class="line-modified">574 PrecomputedMarginBefore BlockFormattingContext::MarginCollapse::precomputedMarginBefore(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues usedNonCollapsedMargin)</span>
575 {



576     ASSERT(layoutBox.isBlockLevelBox());
<span class="line-modified">577     // Don&#39;t pre-compute vertical margins for out of flow boxes.</span>
578     ASSERT(layoutBox.isInFlow() || layoutBox.isFloatingPositioned());
579     ASSERT(!layoutBox.replaced());
580 
<span class="line-modified">581     auto marginsCollapseThrough = this-&gt;marginsCollapseThrough(layoutBox);</span>
<span class="line-modified">582     auto positiveNegativeMarginBefore = this-&gt;positiveNegativeMarginBefore(layoutBox, usedNonCollapsedMargin);</span>



583 
584     auto collapsedMarginBefore = marginValue(!marginsCollapseThrough ? positiveNegativeMarginBefore
<span class="line-modified">585         : computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter(layoutBox, usedNonCollapsedMargin)));</span>
586 
<span class="line-modified">587     return { usedNonCollapsedMargin.before, collapsedMarginBefore, marginsCollapseThrough };</span>
588 }
589 
<span class="line-modified">590 LayoutUnit BlockFormattingContext::MarginCollapse::marginBeforeIgnoringCollapsingThrough(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues)</span>
591 {

592     ASSERT(layoutBox.isBlockLevelBox());
<span class="line-modified">593     return marginValue(positiveNegativeMarginBefore(layoutBox, nonCollapsedValues)).valueOr(nonCollapsedValues.before);</span>
594 }
595 
<span class="line-modified">596 PositiveAndNegativeVerticalMargin BlockFormattingContext::MarginCollapse::resolvedPositiveNegativeMarginValues(const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
597 {
598     ASSERT(layoutBox.isBlockLevelBox());
<span class="line-modified">599     auto positiveNegativeMarginBefore = this-&gt;positiveNegativeMarginBefore(layoutBox, nonCollapsedValues);</span>
<span class="line-modified">600     auto positiveNegativeMarginAfter = this-&gt;positiveNegativeMarginAfter(layoutBox, nonCollapsedValues);</span>


601 
<span class="line-modified">602     if (marginsCollapseThrough(layoutBox)) {</span>
603         positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
604         positiveNegativeMarginAfter = positiveNegativeMarginBefore;
605     }
<span class="line-modified">606     return { positiveNegativeMarginBefore, positiveNegativeMarginAfter };</span>

607 }
608 
<span class="line-modified">609 UsedVerticalMargin::CollapsedValues BlockFormattingContext::MarginCollapse::collapsedVerticalValues(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues)</span>
610 {



611     ASSERT(layoutBox.isBlockLevelBox());
612     // 1. Get min/max margin top values from the first in-flow child if we are collapsing margin top with it.
613     // 2. Get min/max margin top values from the previous in-flow sibling, if we are collapsing margin top with it.
614     // 3. Get this layout box&#39;s computed margin top value.
615     // 4. Update the min/max value and compute the final margin.
<span class="line-modified">616     auto positiveNegativeMarginBefore = this-&gt;positiveNegativeMarginBefore(layoutBox, nonCollapsedValues);</span>
<span class="line-modified">617     auto positiveNegativeMarginAfter = this-&gt;positiveNegativeMarginAfter(layoutBox, nonCollapsedValues);</span>
618 
<span class="line-modified">619     auto marginsCollapseThrough = this-&gt;marginsCollapseThrough(layoutBox);</span>
620     if (marginsCollapseThrough) {
621         positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
622         positiveNegativeMarginAfter = positiveNegativeMarginBefore;
623     }
624 
<span class="line-modified">625     auto beforeMarginIsCollapsedValue = marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutBox) || marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutBox);</span>
<span class="line-modified">626     auto afterMarginIsCollapsedValue = marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutBox);</span>
627 
628     if ((beforeMarginIsCollapsedValue &amp;&amp; afterMarginIsCollapsedValue) || marginsCollapseThrough)
629         return { marginValue(positiveNegativeMarginBefore), marginValue(positiveNegativeMarginAfter), marginsCollapseThrough };
630     if (beforeMarginIsCollapsedValue)
631         return { marginValue(positiveNegativeMarginBefore), { }, false };
632     return { { }, marginValue(positiveNegativeMarginAfter), false };
633 }
634 
635 }
636 }
637 #endif
</pre>
</td>
</tr>
</table>
<center><a href="BlockFormattingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../displaytree/DisplayBox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectionRangeData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayout.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 145     }
 146     return reasons;
 147 }
 148 
 149 static AvoidanceReasonFlags canUseForText(StringView text, const FontCascade&amp; fontCascade, Optional&lt;float&gt; lineHeightConstraint, bool textIsJustified, IncludeReasons includeReasons)
 150 {
 151     if (text.is8Bit())
 152         return canUseForText(text.characters8(), text.length(), fontCascade, lineHeightConstraint, textIsJustified, includeReasons);
 153     return canUseForText(text.characters16(), text.length(), fontCascade, lineHeightConstraint, textIsJustified, includeReasons);
 154 }
 155 
 156 static AvoidanceReasonFlags canUseForFontAndText(const RenderBlockFlow&amp; flow, IncludeReasons includeReasons)
 157 {
 158     AvoidanceReasonFlags reasons = { };
 159     // We assume that all lines have metrics based purely on the primary font.
 160     const auto&amp; style = flow.style();
 161     auto&amp; fontCascade = style.fontCascade();
 162     if (fontCascade.primaryFont().isInterstitial())
 163         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsMissingPrimaryFont, reasons, includeReasons);
 164     Optional&lt;float&gt; lineHeightConstraint;
<span class="line-modified"> 165     if (style.lineBoxContain() &amp; LineBoxContainGlyphs)</span>
 166         lineHeightConstraint = lineHeightFromFlow(flow).toFloat();
 167     bool flowIsJustified = style.textAlign() == TextAlignMode::Justify;
 168     for (const auto&amp; textRenderer : childrenOfType&lt;RenderText&gt;(flow)) {
 169         // FIXME: Do not return until after checking all children.
 170         if (textRenderer.text().isEmpty())
 171             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsEmpty, reasons, includeReasons);
 172         if (textRenderer.isCombineText())
 173             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsCombineText, reasons, includeReasons);
 174         if (textRenderer.isCounter())
 175             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsRenderCounter, reasons, includeReasons);
 176         if (textRenderer.isQuote())
 177             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsRenderQuote, reasons, includeReasons);
 178         if (textRenderer.isTextFragment())
 179             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsTextFragment, reasons, includeReasons);
 180         if (textRenderer.isSVGInlineText())
 181             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsSVGInlineText, reasons, includeReasons);
 182         if (!textRenderer.canUseSimpleFontCodePath()) {
 183             // No need to check the code path at this point. We already know it can&#39;t be simple.
 184             SET_REASON_AND_RETURN_IF_NEEDED(FlowHasComplexFontCodePath, reasons, includeReasons);
 185         } else {
</pre>
<hr />
<pre>
 191 
 192         auto textReasons = canUseForText(textRenderer.stringView(), fontCascade, lineHeightConstraint, flowIsJustified, includeReasons);
 193         if (textReasons != NoReason)
 194             SET_REASON_AND_RETURN_IF_NEEDED(textReasons, reasons, includeReasons);
 195     }
 196     return reasons;
 197 }
 198 
 199 static AvoidanceReasonFlags canUseForStyle(const RenderStyle&amp; style, IncludeReasons includeReasons)
 200 {
 201     AvoidanceReasonFlags reasons = { };
 202     if (style.textOverflow() == TextOverflow::Ellipsis)
 203         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextOverflow, reasons, includeReasons);
 204     if (style.textUnderlinePosition() != TextUnderlinePosition::Auto || !style.textUnderlineOffset().isAuto() || !style.textDecorationThickness().isAuto())
 205         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedUnderlineDecoration, reasons, includeReasons);
 206     // Non-visible overflow should be pretty easy to support.
 207     if (style.overflowX() != Overflow::Visible || style.overflowY() != Overflow::Visible)
 208         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasOverflowNotVisible, reasons, includeReasons);
 209     if (!style.isLeftToRightDirection())
 210         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotLTR, reasons, includeReasons);
<span class="line-modified"> 211     if (!(style.lineBoxContain() &amp; LineBoxContainBlock))</span>
 212         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBoxContainProperty, reasons, includeReasons);
 213     if (style.writingMode() != TopToBottomWritingMode)
 214         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotTopToBottom, reasons, includeReasons);
 215     if (style.lineBreak() != LineBreak::Auto)
 216         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBreak, reasons, includeReasons);
 217     if (style.unicodeBidi() != UBNormal)
 218         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasNonNormalUnicodeBiDi, reasons, includeReasons);
 219     if (style.rtlOrdering() != Order::Logical)
 220         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasRTLOrdering, reasons, includeReasons);
 221     if (style.lineAlign() != LineAlign::None)
 222         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineAlignEdges, reasons, includeReasons);
 223     if (style.lineSnap() != LineSnap::None)
 224         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineSnap, reasons, includeReasons);
 225     if (style.textEmphasisFill() != TextEmphasisFill::Filled || style.textEmphasisMark() != TextEmphasisMark::None)
 226         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextEmphasisFillOrMark, reasons, includeReasons);
 227     if (style.textShadow())
 228         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextShadow, reasons, includeReasons);
 229     if (style.hasPseudoStyle(PseudoId::FirstLine))
 230         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasPseudoFirstLine, reasons, includeReasons);
 231     if (style.hasPseudoStyle(PseudoId::FirstLetter))
</pre>
<hr />
<pre>
 338                 // since the amount of space is not uniform for the height of the float.
 339                 if (floatingObject-&gt;renderer().shapeOutsideInfo())
 340                     SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedFloat, reasons, includeReasons);
 341                 float availableWidth = flow.availableLogicalWidthForLine(floatingObject-&gt;y(), DoNotIndentText);
 342                 if (availableWidth &lt; minimumWidthNeeded)
 343                     SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedFloat, reasons, includeReasons);
 344             }
 345         }
 346     }
 347     auto fontAndTextReasons = canUseForFontAndText(flow, includeReasons);
 348     if (fontAndTextReasons != NoReason)
 349         SET_REASON_AND_RETURN_IF_NEEDED(fontAndTextReasons, reasons, includeReasons);
 350     return reasons;
 351 }
 352 
 353 bool canUseFor(const RenderBlockFlow&amp; flow)
 354 {
 355     return canUseForWithReason(flow, IncludeReasons::First) == NoReason;
 356 }
 357 
<span class="line-removed"> 358 static float computeLineLeft(TextAlignMode textAlign, float availableWidth, float committedWidth, float logicalLeftOffset)</span>
<span class="line-removed"> 359 {</span>
<span class="line-removed"> 360     float remainingWidth = availableWidth - committedWidth;</span>
<span class="line-removed"> 361     float left = logicalLeftOffset;</span>
<span class="line-removed"> 362     switch (textAlign) {</span>
<span class="line-removed"> 363     case TextAlignMode::Left:</span>
<span class="line-removed"> 364     case TextAlignMode::WebKitLeft:</span>
<span class="line-removed"> 365     case TextAlignMode::Start:</span>
<span class="line-removed"> 366         return left;</span>
<span class="line-removed"> 367     case TextAlignMode::Right:</span>
<span class="line-removed"> 368     case TextAlignMode::WebKitRight:</span>
<span class="line-removed"> 369     case TextAlignMode::End:</span>
<span class="line-removed"> 370         return left + std::max&lt;float&gt;(remainingWidth, 0);</span>
<span class="line-removed"> 371     case TextAlignMode::Center:</span>
<span class="line-removed"> 372     case TextAlignMode::WebKitCenter:</span>
<span class="line-removed"> 373         return left + std::max&lt;float&gt;(remainingWidth / 2, 0);</span>
<span class="line-removed"> 374     case TextAlignMode::Justify:</span>
<span class="line-removed"> 375         ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 376         break;</span>
<span class="line-removed"> 377     }</span>
<span class="line-removed"> 378     ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 379     return 0;</span>
<span class="line-removed"> 380 }</span>
<span class="line-removed"> 381 </span>
 382 static void revertAllRunsOnCurrentLine(Layout::RunVector&amp; runs)
 383 {
 384     while (!runs.isEmpty() &amp;&amp; !runs.last().isEndOfLine)
 385         runs.removeLast();
 386 }
 387 
 388 static void revertRuns(Layout::RunVector&amp; runs, unsigned positionToRevertTo, float width)
 389 {
 390     while (runs.size()) {
 391         auto&amp; lastRun = runs.last();
 392         if (lastRun.end &lt;= positionToRevertTo)
 393             break;
 394         if (lastRun.start &gt;= positionToRevertTo) {
 395             // Revert this run completely.
 396             width -= (lastRun.logicalRight - lastRun.logicalLeft);
 397             runs.removeLast();
 398         } else {
 399             lastRun.logicalRight -= width;
 400             width = 0;
 401             lastRun.end = positionToRevertTo;
</pre>
<hr />
<pre>
 456     {
 457         if (!m_lastFragment.isValid())
 458             return true;
 459         if (!m_lastCompleteFragment.isEmpty())
 460             return false;
 461         return m_lastFragment.overlapsToNextRenderer();
 462     }
 463 
 464     static inline unsigned endPositionForCollapsedFragment(const TextFragmentIterator::TextFragment&amp; fragment)
 465     {
 466         return fragment.isCollapsed() ? fragment.start() + 1 : fragment.end();
 467     }
 468 
 469     void appendFragmentAndCreateRunIfNeeded(const TextFragmentIterator::TextFragment&amp; fragment, Layout::RunVector&amp; runs)
 470     {
 471         // Adjust end position while collapsing.
 472         unsigned endPosition = endPositionForCollapsedFragment(fragment);
 473         // New line needs new run.
 474         if (!m_runsWidth) {
 475             ASSERT(!m_uncompletedWidth);
<span class="line-modified"> 476             runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));</span>
 477         } else {
 478             // Advance last completed fragment when the previous fragment is all set (including multiple parts across renderers)
 479             if ((m_lastFragment.type() != fragment.type()) || !m_lastFragment.overlapsToNextRenderer()) {
 480                 m_lastCompleteFragment = m_lastFragment;
 481                 m_uncompletedWidth = fragment.width();
 482             } else
 483                 m_uncompletedWidth += fragment.width();
 484             // Collapse neighbouring whitespace, if they are across multiple renderers and are not collapsed yet.
 485             if (m_lastFragment.isCollapsible() &amp;&amp; fragment.isCollapsible()) {
 486                 ASSERT(m_lastFragment.isLastInRenderer());
 487                 if (!m_lastFragment.isCollapsed()) {
 488                     // Line width needs to be adjusted so that now it takes collapsing into consideration.
 489                     m_runsWidth -= (m_lastFragment.width() - m_collapsedWhitespaceWidth);
 490                 }
 491                 // This fragment is collapsed completely. No run is needed.
 492                 return;
 493             }
<span class="line-modified"> 494             if (m_lastFragment.isLastInRenderer() || m_lastFragment.isCollapsed())</span>
<span class="line-modified"> 495                 runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));</span>

 496             else {
<span class="line-removed"> 497                 Run&amp; lastRun = runs.last();</span>
 498                 lastRun.end = endPosition;
 499                 lastRun.logicalRight += fragment.width();
 500                 ASSERT(!lastRun.hasHyphen);
 501                 lastRun.hasHyphen = fragment.hasHyphen();
 502             }
 503         }
 504         m_runsWidth += fragment.width();
 505         m_lastFragment = fragment;
 506         if (m_fragments)
 507             (*m_fragments).append(fragment);
 508 
 509         if (fragment.type() == TextFragmentIterator::TextFragment::Whitespace) {
 510             m_trailingWhitespaceWidth += fragment.width();
 511             m_lastWhitespaceFragment = fragment;
 512         } else {
 513             m_trailingWhitespaceWidth = 0;
 514             m_lastNonWhitespaceFragment = fragment;
 515         }
 516 
 517         if (!m_firstCharacterFits)
 518             m_firstCharacterFits = fragment.start() + 1 &gt; endPosition || m_runsWidth &lt;= m_availableWidth;
 519     }
 520 
 521     TextFragmentIterator::TextFragment revertToLastCompleteFragment(Layout::RunVector&amp; runs)
 522     {
 523         if (!m_uncompletedWidth) {
 524             ASSERT(m_lastFragment == m_lastCompleteFragment);
 525             return m_lastFragment;
 526         }
 527         ASSERT(m_lastFragment.isValid());
 528         m_runsWidth -= m_uncompletedWidth;
 529         revertRuns(runs, endPositionForCollapsedFragment(m_lastCompleteFragment), m_uncompletedWidth);
 530         m_uncompletedWidth = 0;
 531         ASSERT(m_lastCompleteFragment.isValid());
 532         return m_lastCompleteFragment;
 533     }
 534 
 535     void removeTrailingWhitespace(Layout::RunVector&amp; runs)
 536     {
<span class="line-modified"> 537         if (m_lastFragment.type() != TextFragmentIterator::TextFragment::Whitespace)</span>
 538             return;
 539         if (m_lastNonWhitespaceFragment) {
 540             auto needsReverting = m_lastNonWhitespaceFragment-&gt;end() != m_lastFragment.end();
 541             // Trailing whitespace fragment might actually have zero length.
 542             ASSERT(needsReverting || !m_trailingWhitespaceWidth);
 543             if (needsReverting) {
 544                 revertRuns(runs, m_lastNonWhitespaceFragment-&gt;end(), m_trailingWhitespaceWidth);
 545                 m_runsWidth -= m_trailingWhitespaceWidth;
 546             }
 547             m_trailingWhitespaceWidth = 0;
 548             m_lastFragment = *m_lastNonWhitespaceFragment;
 549             return;
 550         }
 551         // This line is all whitespace.
 552         revertAllRunsOnCurrentLine(runs);
 553         m_runsWidth = 0;
 554         m_trailingWhitespaceWidth = 0;
 555         // FIXME: Make m_lastFragment optional.
 556         m_lastFragment = TextFragmentIterator::TextFragment();
 557     }
 558 


 559 private:
 560     bool expansionOpportunity(TextFragmentIterator::TextFragment::Type currentFragmentType, TextFragmentIterator::TextFragment::Type previousFragmentType) const
 561     {
 562         return (currentFragmentType == TextFragmentIterator::TextFragment::Whitespace
 563             || (currentFragmentType == TextFragmentIterator::TextFragment::NonWhitespace &amp;&amp; previousFragmentType == TextFragmentIterator::TextFragment::NonWhitespace));
 564     }
 565 
 566     float m_availableWidth { 0 };
 567     float m_logicalLeftOffset { 0 };
 568     float m_runsWidth { 0 };
 569     TextFragmentIterator::TextFragment m_overflowedFragment;
 570     TextFragmentIterator::TextFragment m_lastFragment;
 571     Optional&lt;TextFragmentIterator::TextFragment&gt; m_lastNonWhitespaceFragment;
 572     Optional&lt;TextFragmentIterator::TextFragment&gt; m_lastWhitespaceFragment;
 573     TextFragmentIterator::TextFragment m_lastCompleteFragment;
 574     float m_uncompletedWidth { 0 };
 575     float m_trailingWhitespaceWidth { 0 }; // Use this to remove trailing whitespace without re-mesuring the text.
 576     float m_collapsedWhitespaceWidth { 0 };
 577     // Having one character on the line does not necessarily mean it actually fits.
 578     // First character of the first fragment might be forced on to the current line even if it does not fit.
 579     bool m_firstCharacterFits { false };
 580     bool m_hyphenationDisabled { false };
 581     Optional&lt;Vector&lt;TextFragmentIterator::TextFragment, 30&gt;&gt; m_fragments;
 582 };
 583 
<span class="line-modified"> 584 static bool preWrap(const TextFragmentIterator::Style&amp; style)</span>
 585 {
<span class="line-modified"> 586     return style.wrapLines &amp;&amp; !style.collapseWhitespace;</span>























 587 }
 588 
<span class="line-modified"> 589 static void removeTrailingWhitespace(LineState&amp; lineState, Layout::RunVector&amp; runs, const TextFragmentIterator&amp; textFragmentIterator)</span>
 590 {
<span class="line-modified"> 591     if (!lineState.hasTrailingWhitespace())</span>
<span class="line-removed"> 592         return;</span>
<span class="line-removed"> 593     // Remove collapsed whitespace, or non-collapsed pre-wrap whitespace, unless it&#39;s the only content on the line -so removing the whitesapce</span>
<span class="line-removed"> 594     // would produce an empty line.</span>
<span class="line-removed"> 595     const auto&amp; style = textFragmentIterator.style();</span>
<span class="line-removed"> 596     bool collapseWhitespace = style.collapseWhitespace || (!style.breakSpaces &amp;&amp; preWrap(style));</span>
<span class="line-removed"> 597     if (!collapseWhitespace)</span>
<span class="line-removed"> 598         return;</span>
<span class="line-removed"> 599     if (preWrap(style) &amp;&amp; lineState.isWhitespaceOnly())</span>
<span class="line-removed"> 600         return;</span>
<span class="line-removed"> 601     lineState.removeTrailingWhitespace(runs);</span>
 602 }
 603 
 604 static void updateLineConstrains(const RenderBlockFlow&amp; flow, LineState&amp; line, const LineState&amp; previousLine, unsigned&amp; numberOfPrecedingLinesWithHyphen, const TextFragmentIterator::Style&amp; style, bool isFirstLine)
 605 {
 606     bool shouldApplyTextIndent = !flow.isAnonymous() || flow.parent()-&gt;firstChild() == &amp;flow;
 607     LayoutUnit height = flow.logicalHeight();
 608     LayoutUnit logicalHeight = flow.minLineHeightForReplacedRenderer(false, 0);
 609     line.setLogicalLeftOffset(flow.logicalLeftOffsetForLine(height, DoNotIndentText, logicalHeight) + (shouldApplyTextIndent &amp;&amp; isFirstLine ? flow.textIndentOffset() : 0_lu));
 610     float logicalRightOffset = flow.logicalRightOffsetForLine(height, DoNotIndentText, logicalHeight);
 611     line.setAvailableWidth(std::max&lt;float&gt;(0, logicalRightOffset - line.logicalLeftOffset()));
 612     if (style.textAlign == TextAlignMode::Justify)
 613         line.setNeedsAllFragments();
 614     numberOfPrecedingLinesWithHyphen = (previousLine.isEmpty() || !previousLine.lastFragment().hasHyphen()) ? 0 : numberOfPrecedingLinesWithHyphen + 1;
 615     if (style.hyphenLimitLines &amp;&amp; numberOfPrecedingLinesWithHyphen &gt;= *style.hyphenLimitLines)
 616         line.setHyphenationDisabled();
 617     line.setCollapedWhitespaceWidth(style.font.spaceWidth() + style.wordSpacing);
 618 }
 619 
 620 struct SplitFragmentData {
 621     unsigned position;
</pre>
<hr />
<pre>
 741 static TextFragmentIterator::TextFragment firstFragment(TextFragmentIterator&amp; textFragmentIterator, LineState&amp; currentLine, const LineState&amp; previousLine, Layout::RunVector&amp; runs)
 742 {
 743     // Handle overflow fragment from previous line.
 744     auto overflowedFragment = previousLine.overflowedFragment();
 745     if (overflowedFragment.isEmpty())
 746         return skipWhitespaceIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator);
 747 
 748     if (overflowedFragment.type() != TextFragmentIterator::TextFragment::Whitespace)
 749         return overflowedFragment;
 750 
 751     // Leading whitespace handling.
 752     auto&amp; style = textFragmentIterator.style();
 753     if (style.breakSpaces) {
 754         // Leading whitespace created after breaking the previous line.
 755         // Breaking before the first space after a word is only allowed in combination with break-all or break-word.
 756         if (style.breakFirstWordOnOverflow || previousLine.hasTrailingWhitespace())
 757             return overflowedFragment;
 758     }
 759     // Special overflow pre-wrap whitespace handling: skip the overflowed whitespace (even when style says not-collapsible)
 760     // if we manage to fit at least one character on the previous line.
<span class="line-modified"> 761     auto preWrapIsOn = preWrap(style);</span>
<span class="line-removed"> 762     if ((style.collapseWhitespace || preWrapIsOn) &amp;&amp; previousLine.firstCharacterFits()) {</span>
 763         // If skipping the whitespace puts us on a newline, skip the newline too as we already wrapped the line.
 764         auto firstFragmentCandidate = consumeLineBreakIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator, currentLine, runs,
<span class="line-modified"> 765             preWrapIsOn ? PreWrapLineBreakRule::Ignore : PreWrapLineBreakRule::Preserve);</span>
 766         return skipWhitespaceIfNeeded(firstFragmentCandidate, textFragmentIterator);
 767     }
 768     return skipWhitespaceIfNeeded(overflowedFragment, textFragmentIterator);
 769 }
 770 
 771 static void forceFragmentToLine(LineState&amp; line, TextFragmentIterator&amp; textFragmentIterator, Layout::RunVector&amp; runs, const TextFragmentIterator::TextFragment&amp; fragment)
 772 {
 773     line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 774     // Check if there are more fragments to add to the current line.
 775     auto nextFragment = textFragmentIterator.nextTextFragment();
 776     if (fragment.overlapsToNextRenderer()) {
 777         while (true) {
 778             if (nextFragment.type() != fragment.type())
 779                 break;
 780             line.appendFragmentAndCreateRunIfNeeded(nextFragment, runs);
 781             // Does it overlap to the next segment?
 782             if (!nextFragment.overlapsToNextRenderer())
 783                 return;
 784             nextFragment = textFragmentIterator.nextTextFragment();
 785         }
 786     }
 787     // When the forced fragment is followed by either whitespace and/or line break, consume them too, otherwise we end up with an extra whitespace and/or line break.
 788     nextFragment = skipWhitespaceIfNeeded(nextFragment, textFragmentIterator);
 789     nextFragment = consumeLineBreakIfNeeded(nextFragment, textFragmentIterator, line, runs);
 790     line.setOverflowedFragment(nextFragment);
 791 }
 792 
 793 static bool createLineRuns(LineState&amp; line, const LineState&amp; previousLine, Layout::RunVector&amp; runs, TextFragmentIterator&amp; textFragmentIterator)
 794 {
 795     const auto&amp; style = textFragmentIterator.style();
 796     bool lineCanBeWrapped = style.wrapLines || style.breakFirstWordOnOverflow || style.breakAnyWordOnOverflow;
 797     auto fragment = firstFragment(textFragmentIterator, line, previousLine, runs);
 798     while (fragment.type() != TextFragmentIterator::TextFragment::ContentEnd) {
 799         // Hard and soft linebreaks.
 800         if (fragment.isLineBreak()) {
 801             // Add the new line fragment only if there&#39;s nothing on the line. (otherwise the extra new line character would show up at the end of the content.)
<span class="line-modified"> 802             if (line.isEmpty() || fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak) {</span>
 803                 if (style.textAlign == TextAlignMode::Right || style.textAlign == TextAlignMode::WebKitRight)
 804                     line.removeTrailingWhitespace(runs);
 805                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 806             }
 807             break;
 808         }
 809         if (lineCanBeWrapped &amp;&amp; !line.fits(fragment.width())) {
 810             // Overflow wrapping behaviour:
 811             // 1. Whitesapce collapse on: whitespace is skipped. Jump to next line.
 812             // 2. Whitespace collapse off: whitespace is wrapped.
 813             // 3. First, non-whitespace fragment is either wrapped or kept on the line. (depends on overflow-wrap)
 814             // 5. Non-whitespace fragment when there&#39;s already another fragment on the line either gets wrapped (word-break: break-all)
 815             // or gets pushed to the next line.
 816             bool emptyLine = line.isEmpty();
 817             // Whitespace fragment.
 818             if (fragment.type() == TextFragmentIterator::TextFragment::Whitespace) {
 819                 if (style.collapseWhitespace) {
 820                     // Push collapased whitespace to the next line.
 821                     line.setOverflowedFragment(fragment);
 822                     break;
 823                 }
 824                 if (style.breakSpaces &amp;&amp; line.hasWhitespaceFragments() &amp;&amp; fragment.length() == 1) {
 825                     // Breaking before the first space after a word is not allowed if there are previous breaking opportunities in the line.
 826                     textFragmentIterator.revertToEndOfFragment(line.revertToLastCompleteFragment(runs));
 827                     break;
 828                 }








 829                 // Split the whitespace; left part stays on this line, right is pushed to next line.
 830                 line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
 831                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 832                 break;
 833             }
 834             // Non-whitespace fragment. (!style.wrapLines: bug138102(preserve existing behavior)
 835             if (((emptyLine &amp;&amp; style.breakFirstWordOnOverflow) || style.breakAnyWordOnOverflow) || !style.wrapLines) {
 836                 // Split the fragment; (modified)fragment stays on this line, overflowedFragment is pushed to next line.
 837                 line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
 838                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 839                 break;
 840             }
 841             ASSERT(fragment.type() == TextFragmentIterator::TextFragment::NonWhitespace);
 842             // Find out if this non-whitespace fragment has a hyphen where we can break.
 843             if (style.shouldHyphenate) {
 844                 auto fragmentToSplit = fragment;
 845                 // Split and check if we actually ended up with a hyphen.
 846                 auto overflowFragment = splitFragmentToFitLine(fragmentToSplit, line, textFragmentIterator);
 847                 if (fragmentToSplit.hasHyphen()) {
 848                     line.setOverflowedFragment(overflowFragment);
</pre>
<hr />
<pre>
 914         run.logicalLeft += accumulatedExpansion;
 915         run.logicalRight += (accumulatedExpansion + run.expansion);
 916         accumulatedExpansion += run.expansion;
 917     }
 918 }
 919 
 920 static TextAlignMode textAlignForLine(const TextFragmentIterator::Style&amp; style, bool lastLine)
 921 {
 922     // Fallback to TextAlignMode::Left (START) alignment for non-collapsable content and for the last line before a forced break or the end of the block.
 923     auto textAlign = style.textAlign;
 924     if (textAlign == TextAlignMode::Justify &amp;&amp; (!style.collapseWhitespace || lastLine))
 925         textAlign = TextAlignMode::Left;
 926     return textAlign;
 927 }
 928 
 929 static void closeLineEndingAndAdjustRuns(LineState&amp; line, Layout::RunVector&amp; runs, Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine, unsigned&amp; lineCount,
 930     const TextFragmentIterator&amp; textFragmentIterator, bool lastLineInFlow)
 931 {
 932     if (!runs.size() || (lastRunIndexOfPreviousLine &amp;&amp; runs.size() - 1 == lastRunIndexOfPreviousLine.value()))
 933         return;
<span class="line-modified"> 934     removeTrailingWhitespace(line, runs, textFragmentIterator);</span>





 935     if (!runs.size())
 936         return;

 937     // Adjust runs&#39; position by taking line&#39;s alignment into account.
<span class="line-removed"> 938     const auto&amp; style = textFragmentIterator.style();</span>
 939     auto firstRunIndex = lastRunIndexOfPreviousLine ? lastRunIndexOfPreviousLine.value() + 1 : 0;
 940     auto lineLogicalLeft = line.logicalLeftOffset();
 941     auto textAlign = textAlignForLine(style, lastLineInFlow || (line.lastFragment().isValid() &amp;&amp; line.lastFragment().type() == TextFragmentIterator::TextFragment::HardLineBreak));
<span class="line-modified"> 942     if (textAlign == TextAlignMode::Justify)</span>





 943         justifyRuns(line, runs, firstRunIndex);
<span class="line-modified"> 944     else</span>
<span class="line-modified"> 945         lineLogicalLeft = computeLineLeft(textAlign, line.availableWidth(), line.width(), line.logicalLeftOffset());</span>


 946     for (auto i = firstRunIndex; i &lt; runs.size(); ++i) {
 947         runs[i].logicalLeft += lineLogicalLeft;
 948         runs[i].logicalRight += lineLogicalLeft;
 949     }




 950     runs.last().isEndOfLine = true;
 951     ++lineCount;
 952 }
 953 
 954 static void createTextRuns(Layout::RunVector&amp; runs, RenderBlockFlow&amp; flow, unsigned&amp; lineCount)
 955 {
 956     LayoutUnit borderAndPaddingBefore = flow.borderAndPaddingBefore();
 957     LayoutUnit lineHeight = lineHeightFromFlow(flow);
 958     LineState line;
 959     unsigned numberOfPrecedingLinesWithHyphen = 0;
 960     bool isEndOfContent = false;
 961     TextFragmentIterator textFragmentIterator = TextFragmentIterator(flow);
 962     Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine;
 963     do {
 964         flow.setLogicalHeight(lineHeight * lineCount + borderAndPaddingBefore);
 965         LineState previousLine = line;
 966         line = LineState();
 967         updateLineConstrains(flow, line, previousLine, numberOfPrecedingLinesWithHyphen, textFragmentIterator.style(), !lineCount);
 968         isEndOfContent = createLineRuns(line, previousLine, runs, textFragmentIterator);
 969         closeLineEndingAndAdjustRuns(line, runs, lastRunIndexOfPreviousLine, lineCount, textFragmentIterator, isEndOfContent);
 970         if (runs.size())
 971             lastRunIndexOfPreviousLine = runs.size() - 1;
 972     } while (!isEndOfContent);
 973 }
 974 
<span class="line-modified"> 975 std::unique_ptr&lt;Layout&gt; create(RenderBlockFlow&amp; flow)</span>
 976 {
 977     unsigned lineCount = 0;
 978     Layout::RunVector runs;
 979     createTextRuns(runs, flow, lineCount);
 980     return Layout::create(runs, lineCount, flow);
 981 }
 982 
<span class="line-modified"> 983 std::unique_ptr&lt;Layout&gt; Layout::create(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)</span>
 984 {
 985     void* slot = WTF::fastMalloc(sizeof(Layout) + sizeof(Run) * runVector.size());
<span class="line-modified"> 986     return std::unique_ptr&lt;Layout&gt;(new (NotNull, slot) Layout(runVector, lineCount, blockFlow));</span>
 987 }
 988 
 989 Layout::Layout(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)
 990     : m_lineCount(lineCount)
 991     , m_runCount(runVector.size())
 992     , m_blockFlowRenderer(blockFlow)
 993 {
 994     memcpy(m_runs, runVector.data(), m_runCount * sizeof(Run));
 995 }
 996 
 997 const RunResolver&amp; Layout::runResolver() const
 998 {
 999     if (!m_runResolver)
1000         m_runResolver = makeUnique&lt;RunResolver&gt;(m_blockFlowRenderer, *this);
1001     return *m_runResolver;
1002 }
1003 
1004 Layout::~Layout()
1005 {
1006     simpleLineLayoutWillBeDeleted(*this);
</pre>
</td>
<td>
<hr />
<pre>
 145     }
 146     return reasons;
 147 }
 148 
 149 static AvoidanceReasonFlags canUseForText(StringView text, const FontCascade&amp; fontCascade, Optional&lt;float&gt; lineHeightConstraint, bool textIsJustified, IncludeReasons includeReasons)
 150 {
 151     if (text.is8Bit())
 152         return canUseForText(text.characters8(), text.length(), fontCascade, lineHeightConstraint, textIsJustified, includeReasons);
 153     return canUseForText(text.characters16(), text.length(), fontCascade, lineHeightConstraint, textIsJustified, includeReasons);
 154 }
 155 
 156 static AvoidanceReasonFlags canUseForFontAndText(const RenderBlockFlow&amp; flow, IncludeReasons includeReasons)
 157 {
 158     AvoidanceReasonFlags reasons = { };
 159     // We assume that all lines have metrics based purely on the primary font.
 160     const auto&amp; style = flow.style();
 161     auto&amp; fontCascade = style.fontCascade();
 162     if (fontCascade.primaryFont().isInterstitial())
 163         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsMissingPrimaryFont, reasons, includeReasons);
 164     Optional&lt;float&gt; lineHeightConstraint;
<span class="line-modified"> 165     if (style.lineBoxContain().contains(LineBoxContain::Glyphs))</span>
 166         lineHeightConstraint = lineHeightFromFlow(flow).toFloat();
 167     bool flowIsJustified = style.textAlign() == TextAlignMode::Justify;
 168     for (const auto&amp; textRenderer : childrenOfType&lt;RenderText&gt;(flow)) {
 169         // FIXME: Do not return until after checking all children.
 170         if (textRenderer.text().isEmpty())
 171             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsEmpty, reasons, includeReasons);
 172         if (textRenderer.isCombineText())
 173             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsCombineText, reasons, includeReasons);
 174         if (textRenderer.isCounter())
 175             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsRenderCounter, reasons, includeReasons);
 176         if (textRenderer.isQuote())
 177             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsRenderQuote, reasons, includeReasons);
 178         if (textRenderer.isTextFragment())
 179             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsTextFragment, reasons, includeReasons);
 180         if (textRenderer.isSVGInlineText())
 181             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsSVGInlineText, reasons, includeReasons);
 182         if (!textRenderer.canUseSimpleFontCodePath()) {
 183             // No need to check the code path at this point. We already know it can&#39;t be simple.
 184             SET_REASON_AND_RETURN_IF_NEEDED(FlowHasComplexFontCodePath, reasons, includeReasons);
 185         } else {
</pre>
<hr />
<pre>
 191 
 192         auto textReasons = canUseForText(textRenderer.stringView(), fontCascade, lineHeightConstraint, flowIsJustified, includeReasons);
 193         if (textReasons != NoReason)
 194             SET_REASON_AND_RETURN_IF_NEEDED(textReasons, reasons, includeReasons);
 195     }
 196     return reasons;
 197 }
 198 
 199 static AvoidanceReasonFlags canUseForStyle(const RenderStyle&amp; style, IncludeReasons includeReasons)
 200 {
 201     AvoidanceReasonFlags reasons = { };
 202     if (style.textOverflow() == TextOverflow::Ellipsis)
 203         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextOverflow, reasons, includeReasons);
 204     if (style.textUnderlinePosition() != TextUnderlinePosition::Auto || !style.textUnderlineOffset().isAuto() || !style.textDecorationThickness().isAuto())
 205         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedUnderlineDecoration, reasons, includeReasons);
 206     // Non-visible overflow should be pretty easy to support.
 207     if (style.overflowX() != Overflow::Visible || style.overflowY() != Overflow::Visible)
 208         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasOverflowNotVisible, reasons, includeReasons);
 209     if (!style.isLeftToRightDirection())
 210         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotLTR, reasons, includeReasons);
<span class="line-modified"> 211     if (!(style.lineBoxContain().contains(LineBoxContain::Block)))</span>
 212         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBoxContainProperty, reasons, includeReasons);
 213     if (style.writingMode() != TopToBottomWritingMode)
 214         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotTopToBottom, reasons, includeReasons);
 215     if (style.lineBreak() != LineBreak::Auto)
 216         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBreak, reasons, includeReasons);
 217     if (style.unicodeBidi() != UBNormal)
 218         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasNonNormalUnicodeBiDi, reasons, includeReasons);
 219     if (style.rtlOrdering() != Order::Logical)
 220         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasRTLOrdering, reasons, includeReasons);
 221     if (style.lineAlign() != LineAlign::None)
 222         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineAlignEdges, reasons, includeReasons);
 223     if (style.lineSnap() != LineSnap::None)
 224         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineSnap, reasons, includeReasons);
 225     if (style.textEmphasisFill() != TextEmphasisFill::Filled || style.textEmphasisMark() != TextEmphasisMark::None)
 226         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextEmphasisFillOrMark, reasons, includeReasons);
 227     if (style.textShadow())
 228         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextShadow, reasons, includeReasons);
 229     if (style.hasPseudoStyle(PseudoId::FirstLine))
 230         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasPseudoFirstLine, reasons, includeReasons);
 231     if (style.hasPseudoStyle(PseudoId::FirstLetter))
</pre>
<hr />
<pre>
 338                 // since the amount of space is not uniform for the height of the float.
 339                 if (floatingObject-&gt;renderer().shapeOutsideInfo())
 340                     SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedFloat, reasons, includeReasons);
 341                 float availableWidth = flow.availableLogicalWidthForLine(floatingObject-&gt;y(), DoNotIndentText);
 342                 if (availableWidth &lt; minimumWidthNeeded)
 343                     SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedFloat, reasons, includeReasons);
 344             }
 345         }
 346     }
 347     auto fontAndTextReasons = canUseForFontAndText(flow, includeReasons);
 348     if (fontAndTextReasons != NoReason)
 349         SET_REASON_AND_RETURN_IF_NEEDED(fontAndTextReasons, reasons, includeReasons);
 350     return reasons;
 351 }
 352 
 353 bool canUseFor(const RenderBlockFlow&amp; flow)
 354 {
 355     return canUseForWithReason(flow, IncludeReasons::First) == NoReason;
 356 }
 357 
























 358 static void revertAllRunsOnCurrentLine(Layout::RunVector&amp; runs)
 359 {
 360     while (!runs.isEmpty() &amp;&amp; !runs.last().isEndOfLine)
 361         runs.removeLast();
 362 }
 363 
 364 static void revertRuns(Layout::RunVector&amp; runs, unsigned positionToRevertTo, float width)
 365 {
 366     while (runs.size()) {
 367         auto&amp; lastRun = runs.last();
 368         if (lastRun.end &lt;= positionToRevertTo)
 369             break;
 370         if (lastRun.start &gt;= positionToRevertTo) {
 371             // Revert this run completely.
 372             width -= (lastRun.logicalRight - lastRun.logicalLeft);
 373             runs.removeLast();
 374         } else {
 375             lastRun.logicalRight -= width;
 376             width = 0;
 377             lastRun.end = positionToRevertTo;
</pre>
<hr />
<pre>
 432     {
 433         if (!m_lastFragment.isValid())
 434             return true;
 435         if (!m_lastCompleteFragment.isEmpty())
 436             return false;
 437         return m_lastFragment.overlapsToNextRenderer();
 438     }
 439 
 440     static inline unsigned endPositionForCollapsedFragment(const TextFragmentIterator::TextFragment&amp; fragment)
 441     {
 442         return fragment.isCollapsed() ? fragment.start() + 1 : fragment.end();
 443     }
 444 
 445     void appendFragmentAndCreateRunIfNeeded(const TextFragmentIterator::TextFragment&amp; fragment, Layout::RunVector&amp; runs)
 446     {
 447         // Adjust end position while collapsing.
 448         unsigned endPosition = endPositionForCollapsedFragment(fragment);
 449         // New line needs new run.
 450         if (!m_runsWidth) {
 451             ASSERT(!m_uncompletedWidth);
<span class="line-modified"> 452             runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen(), fragment.isLineBreak()));</span>
 453         } else {
 454             // Advance last completed fragment when the previous fragment is all set (including multiple parts across renderers)
 455             if ((m_lastFragment.type() != fragment.type()) || !m_lastFragment.overlapsToNextRenderer()) {
 456                 m_lastCompleteFragment = m_lastFragment;
 457                 m_uncompletedWidth = fragment.width();
 458             } else
 459                 m_uncompletedWidth += fragment.width();
 460             // Collapse neighbouring whitespace, if they are across multiple renderers and are not collapsed yet.
 461             if (m_lastFragment.isCollapsible() &amp;&amp; fragment.isCollapsible()) {
 462                 ASSERT(m_lastFragment.isLastInRenderer());
 463                 if (!m_lastFragment.isCollapsed()) {
 464                     // Line width needs to be adjusted so that now it takes collapsing into consideration.
 465                     m_runsWidth -= (m_lastFragment.width() - m_collapsedWhitespaceWidth);
 466                 }
 467                 // This fragment is collapsed completely. No run is needed.
 468                 return;
 469             }
<span class="line-modified"> 470             Run&amp; lastRun = runs.last();</span>
<span class="line-modified"> 471             if (m_lastFragment.isLastInRenderer() || m_lastFragment.isCollapsed() || fragment.isLineBreak() || lastRun.isLineBreak)</span>
<span class="line-added"> 472                 runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen(), fragment.isLineBreak()));</span>
 473             else {

 474                 lastRun.end = endPosition;
 475                 lastRun.logicalRight += fragment.width();
 476                 ASSERT(!lastRun.hasHyphen);
 477                 lastRun.hasHyphen = fragment.hasHyphen();
 478             }
 479         }
 480         m_runsWidth += fragment.width();
 481         m_lastFragment = fragment;
 482         if (m_fragments)
 483             (*m_fragments).append(fragment);
 484 
 485         if (fragment.type() == TextFragmentIterator::TextFragment::Whitespace) {
 486             m_trailingWhitespaceWidth += fragment.width();
 487             m_lastWhitespaceFragment = fragment;
 488         } else {
 489             m_trailingWhitespaceWidth = 0;
 490             m_lastNonWhitespaceFragment = fragment;
 491         }
 492 
 493         if (!m_firstCharacterFits)
 494             m_firstCharacterFits = fragment.start() + 1 &gt; endPosition || m_runsWidth &lt;= m_availableWidth;
 495     }
 496 
 497     TextFragmentIterator::TextFragment revertToLastCompleteFragment(Layout::RunVector&amp; runs)
 498     {
 499         if (!m_uncompletedWidth) {
 500             ASSERT(m_lastFragment == m_lastCompleteFragment);
 501             return m_lastFragment;
 502         }
 503         ASSERT(m_lastFragment.isValid());
 504         m_runsWidth -= m_uncompletedWidth;
 505         revertRuns(runs, endPositionForCollapsedFragment(m_lastCompleteFragment), m_uncompletedWidth);
 506         m_uncompletedWidth = 0;
 507         ASSERT(m_lastCompleteFragment.isValid());
 508         return m_lastCompleteFragment;
 509     }
 510 
 511     void removeTrailingWhitespace(Layout::RunVector&amp; runs)
 512     {
<span class="line-modified"> 513         if (!hasTrailingWhitespace())</span>
 514             return;
 515         if (m_lastNonWhitespaceFragment) {
 516             auto needsReverting = m_lastNonWhitespaceFragment-&gt;end() != m_lastFragment.end();
 517             // Trailing whitespace fragment might actually have zero length.
 518             ASSERT(needsReverting || !m_trailingWhitespaceWidth);
 519             if (needsReverting) {
 520                 revertRuns(runs, m_lastNonWhitespaceFragment-&gt;end(), m_trailingWhitespaceWidth);
 521                 m_runsWidth -= m_trailingWhitespaceWidth;
 522             }
 523             m_trailingWhitespaceWidth = 0;
 524             m_lastFragment = *m_lastNonWhitespaceFragment;
 525             return;
 526         }
 527         // This line is all whitespace.
 528         revertAllRunsOnCurrentLine(runs);
 529         m_runsWidth = 0;
 530         m_trailingWhitespaceWidth = 0;
 531         // FIXME: Make m_lastFragment optional.
 532         m_lastFragment = TextFragmentIterator::TextFragment();
 533     }
 534 
<span class="line-added"> 535     float trailingWhitespaceWidth() const { return m_trailingWhitespaceWidth; }</span>
<span class="line-added"> 536 </span>
 537 private:
 538     bool expansionOpportunity(TextFragmentIterator::TextFragment::Type currentFragmentType, TextFragmentIterator::TextFragment::Type previousFragmentType) const
 539     {
 540         return (currentFragmentType == TextFragmentIterator::TextFragment::Whitespace
 541             || (currentFragmentType == TextFragmentIterator::TextFragment::NonWhitespace &amp;&amp; previousFragmentType == TextFragmentIterator::TextFragment::NonWhitespace));
 542     }
 543 
 544     float m_availableWidth { 0 };
 545     float m_logicalLeftOffset { 0 };
 546     float m_runsWidth { 0 };
 547     TextFragmentIterator::TextFragment m_overflowedFragment;
 548     TextFragmentIterator::TextFragment m_lastFragment;
 549     Optional&lt;TextFragmentIterator::TextFragment&gt; m_lastNonWhitespaceFragment;
 550     Optional&lt;TextFragmentIterator::TextFragment&gt; m_lastWhitespaceFragment;
 551     TextFragmentIterator::TextFragment m_lastCompleteFragment;
 552     float m_uncompletedWidth { 0 };
 553     float m_trailingWhitespaceWidth { 0 }; // Use this to remove trailing whitespace without re-mesuring the text.
 554     float m_collapsedWhitespaceWidth { 0 };
 555     // Having one character on the line does not necessarily mean it actually fits.
 556     // First character of the first fragment might be forced on to the current line even if it does not fit.
 557     bool m_firstCharacterFits { false };
 558     bool m_hyphenationDisabled { false };
 559     Optional&lt;Vector&lt;TextFragmentIterator::TextFragment, 30&gt;&gt; m_fragments;
 560 };
 561 
<span class="line-modified"> 562 static float computeLineLeft(const LineState&amp; line, TextAlignMode textAlign, float&amp; hangingWhitespaceWidth)</span>
 563 {
<span class="line-modified"> 564     float totalWidth = line.width() - hangingWhitespaceWidth;</span>
<span class="line-added"> 565     float remainingWidth = line.availableWidth() - totalWidth;</span>
<span class="line-added"> 566     float left = line.logicalLeftOffset();</span>
<span class="line-added"> 567     switch (textAlign) {</span>
<span class="line-added"> 568     case TextAlignMode::Left:</span>
<span class="line-added"> 569     case TextAlignMode::WebKitLeft:</span>
<span class="line-added"> 570     case TextAlignMode::Start:</span>
<span class="line-added"> 571         hangingWhitespaceWidth = std::max(0.f, std::min(hangingWhitespaceWidth, remainingWidth));</span>
<span class="line-added"> 572         return left;</span>
<span class="line-added"> 573     case TextAlignMode::Right:</span>
<span class="line-added"> 574     case TextAlignMode::WebKitRight:</span>
<span class="line-added"> 575     case TextAlignMode::End:</span>
<span class="line-added"> 576         hangingWhitespaceWidth = 0;</span>
<span class="line-added"> 577         return left + std::max&lt;float&gt;(remainingWidth, 0);</span>
<span class="line-added"> 578     case TextAlignMode::Center:</span>
<span class="line-added"> 579     case TextAlignMode::WebKitCenter:</span>
<span class="line-added"> 580         hangingWhitespaceWidth = std::max(0.f, std::min(hangingWhitespaceWidth, (remainingWidth + 1) / 2));</span>
<span class="line-added"> 581         return left + std::max&lt;float&gt;(remainingWidth / 2, 0);</span>
<span class="line-added"> 582     case TextAlignMode::Justify:</span>
<span class="line-added"> 583         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 584         break;</span>
<span class="line-added"> 585     }</span>
<span class="line-added"> 586     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 587     return 0;</span>
 588 }
 589 
<span class="line-modified"> 590 static bool preWrap(const TextFragmentIterator::Style&amp; style)</span>
 591 {
<span class="line-modified"> 592     return style.wrapLines &amp;&amp; !style.collapseWhitespace &amp;&amp; !style.breakSpaces;</span>










 593 }
 594 
 595 static void updateLineConstrains(const RenderBlockFlow&amp; flow, LineState&amp; line, const LineState&amp; previousLine, unsigned&amp; numberOfPrecedingLinesWithHyphen, const TextFragmentIterator::Style&amp; style, bool isFirstLine)
 596 {
 597     bool shouldApplyTextIndent = !flow.isAnonymous() || flow.parent()-&gt;firstChild() == &amp;flow;
 598     LayoutUnit height = flow.logicalHeight();
 599     LayoutUnit logicalHeight = flow.minLineHeightForReplacedRenderer(false, 0);
 600     line.setLogicalLeftOffset(flow.logicalLeftOffsetForLine(height, DoNotIndentText, logicalHeight) + (shouldApplyTextIndent &amp;&amp; isFirstLine ? flow.textIndentOffset() : 0_lu));
 601     float logicalRightOffset = flow.logicalRightOffsetForLine(height, DoNotIndentText, logicalHeight);
 602     line.setAvailableWidth(std::max&lt;float&gt;(0, logicalRightOffset - line.logicalLeftOffset()));
 603     if (style.textAlign == TextAlignMode::Justify)
 604         line.setNeedsAllFragments();
 605     numberOfPrecedingLinesWithHyphen = (previousLine.isEmpty() || !previousLine.lastFragment().hasHyphen()) ? 0 : numberOfPrecedingLinesWithHyphen + 1;
 606     if (style.hyphenLimitLines &amp;&amp; numberOfPrecedingLinesWithHyphen &gt;= *style.hyphenLimitLines)
 607         line.setHyphenationDisabled();
 608     line.setCollapedWhitespaceWidth(style.font.spaceWidth() + style.wordSpacing);
 609 }
 610 
 611 struct SplitFragmentData {
 612     unsigned position;
</pre>
<hr />
<pre>
 732 static TextFragmentIterator::TextFragment firstFragment(TextFragmentIterator&amp; textFragmentIterator, LineState&amp; currentLine, const LineState&amp; previousLine, Layout::RunVector&amp; runs)
 733 {
 734     // Handle overflow fragment from previous line.
 735     auto overflowedFragment = previousLine.overflowedFragment();
 736     if (overflowedFragment.isEmpty())
 737         return skipWhitespaceIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator);
 738 
 739     if (overflowedFragment.type() != TextFragmentIterator::TextFragment::Whitespace)
 740         return overflowedFragment;
 741 
 742     // Leading whitespace handling.
 743     auto&amp; style = textFragmentIterator.style();
 744     if (style.breakSpaces) {
 745         // Leading whitespace created after breaking the previous line.
 746         // Breaking before the first space after a word is only allowed in combination with break-all or break-word.
 747         if (style.breakFirstWordOnOverflow || previousLine.hasTrailingWhitespace())
 748             return overflowedFragment;
 749     }
 750     // Special overflow pre-wrap whitespace handling: skip the overflowed whitespace (even when style says not-collapsible)
 751     // if we manage to fit at least one character on the previous line.
<span class="line-modified"> 752     if ((style.collapseWhitespace || style.wrapLines) &amp;&amp; previousLine.firstCharacterFits()) {</span>

 753         // If skipping the whitespace puts us on a newline, skip the newline too as we already wrapped the line.
 754         auto firstFragmentCandidate = consumeLineBreakIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator, currentLine, runs,
<span class="line-modified"> 755             preWrap(style) ? PreWrapLineBreakRule::Ignore : PreWrapLineBreakRule::Preserve);</span>
 756         return skipWhitespaceIfNeeded(firstFragmentCandidate, textFragmentIterator);
 757     }
 758     return skipWhitespaceIfNeeded(overflowedFragment, textFragmentIterator);
 759 }
 760 
 761 static void forceFragmentToLine(LineState&amp; line, TextFragmentIterator&amp; textFragmentIterator, Layout::RunVector&amp; runs, const TextFragmentIterator::TextFragment&amp; fragment)
 762 {
 763     line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 764     // Check if there are more fragments to add to the current line.
 765     auto nextFragment = textFragmentIterator.nextTextFragment();
 766     if (fragment.overlapsToNextRenderer()) {
 767         while (true) {
 768             if (nextFragment.type() != fragment.type())
 769                 break;
 770             line.appendFragmentAndCreateRunIfNeeded(nextFragment, runs);
 771             // Does it overlap to the next segment?
 772             if (!nextFragment.overlapsToNextRenderer())
 773                 return;
 774             nextFragment = textFragmentIterator.nextTextFragment();
 775         }
 776     }
 777     // When the forced fragment is followed by either whitespace and/or line break, consume them too, otherwise we end up with an extra whitespace and/or line break.
 778     nextFragment = skipWhitespaceIfNeeded(nextFragment, textFragmentIterator);
 779     nextFragment = consumeLineBreakIfNeeded(nextFragment, textFragmentIterator, line, runs);
 780     line.setOverflowedFragment(nextFragment);
 781 }
 782 
 783 static bool createLineRuns(LineState&amp; line, const LineState&amp; previousLine, Layout::RunVector&amp; runs, TextFragmentIterator&amp; textFragmentIterator)
 784 {
 785     const auto&amp; style = textFragmentIterator.style();
 786     bool lineCanBeWrapped = style.wrapLines || style.breakFirstWordOnOverflow || style.breakAnyWordOnOverflow;
 787     auto fragment = firstFragment(textFragmentIterator, line, previousLine, runs);
 788     while (fragment.type() != TextFragmentIterator::TextFragment::ContentEnd) {
 789         // Hard and soft linebreaks.
 790         if (fragment.isLineBreak()) {
 791             // Add the new line fragment only if there&#39;s nothing on the line. (otherwise the extra new line character would show up at the end of the content.)
<span class="line-modified"> 792             if (line.isEmpty() || fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak || preWrap(style) || style.preserveNewline) {</span>
 793                 if (style.textAlign == TextAlignMode::Right || style.textAlign == TextAlignMode::WebKitRight)
 794                     line.removeTrailingWhitespace(runs);
 795                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 796             }
 797             break;
 798         }
 799         if (lineCanBeWrapped &amp;&amp; !line.fits(fragment.width())) {
 800             // Overflow wrapping behaviour:
 801             // 1. Whitesapce collapse on: whitespace is skipped. Jump to next line.
 802             // 2. Whitespace collapse off: whitespace is wrapped.
 803             // 3. First, non-whitespace fragment is either wrapped or kept on the line. (depends on overflow-wrap)
 804             // 5. Non-whitespace fragment when there&#39;s already another fragment on the line either gets wrapped (word-break: break-all)
 805             // or gets pushed to the next line.
 806             bool emptyLine = line.isEmpty();
 807             // Whitespace fragment.
 808             if (fragment.type() == TextFragmentIterator::TextFragment::Whitespace) {
 809                 if (style.collapseWhitespace) {
 810                     // Push collapased whitespace to the next line.
 811                     line.setOverflowedFragment(fragment);
 812                     break;
 813                 }
 814                 if (style.breakSpaces &amp;&amp; line.hasWhitespaceFragments() &amp;&amp; fragment.length() == 1) {
 815                     // Breaking before the first space after a word is not allowed if there are previous breaking opportunities in the line.
 816                     textFragmentIterator.revertToEndOfFragment(line.revertToLastCompleteFragment(runs));
 817                     break;
 818                 }
<span class="line-added"> 819                 if (preWrap(style)) {</span>
<span class="line-added"> 820                     line.appendFragmentAndCreateRunIfNeeded(fragment, runs);</span>
<span class="line-added"> 821                     fragment = textFragmentIterator.nextTextFragment(line.width());</span>
<span class="line-added"> 822                     if (fragment.isLineBreak())</span>
<span class="line-added"> 823                         continue;</span>
<span class="line-added"> 824                     line.setOverflowedFragment(fragment);</span>
<span class="line-added"> 825                     break;</span>
<span class="line-added"> 826                 }</span>
 827                 // Split the whitespace; left part stays on this line, right is pushed to next line.
 828                 line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
 829                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 830                 break;
 831             }
 832             // Non-whitespace fragment. (!style.wrapLines: bug138102(preserve existing behavior)
 833             if (((emptyLine &amp;&amp; style.breakFirstWordOnOverflow) || style.breakAnyWordOnOverflow) || !style.wrapLines) {
 834                 // Split the fragment; (modified)fragment stays on this line, overflowedFragment is pushed to next line.
 835                 line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
 836                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
 837                 break;
 838             }
 839             ASSERT(fragment.type() == TextFragmentIterator::TextFragment::NonWhitespace);
 840             // Find out if this non-whitespace fragment has a hyphen where we can break.
 841             if (style.shouldHyphenate) {
 842                 auto fragmentToSplit = fragment;
 843                 // Split and check if we actually ended up with a hyphen.
 844                 auto overflowFragment = splitFragmentToFitLine(fragmentToSplit, line, textFragmentIterator);
 845                 if (fragmentToSplit.hasHyphen()) {
 846                     line.setOverflowedFragment(overflowFragment);
</pre>
<hr />
<pre>
 912         run.logicalLeft += accumulatedExpansion;
 913         run.logicalRight += (accumulatedExpansion + run.expansion);
 914         accumulatedExpansion += run.expansion;
 915     }
 916 }
 917 
 918 static TextAlignMode textAlignForLine(const TextFragmentIterator::Style&amp; style, bool lastLine)
 919 {
 920     // Fallback to TextAlignMode::Left (START) alignment for non-collapsable content and for the last line before a forced break or the end of the block.
 921     auto textAlign = style.textAlign;
 922     if (textAlign == TextAlignMode::Justify &amp;&amp; (!style.collapseWhitespace || lastLine))
 923         textAlign = TextAlignMode::Left;
 924     return textAlign;
 925 }
 926 
 927 static void closeLineEndingAndAdjustRuns(LineState&amp; line, Layout::RunVector&amp; runs, Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine, unsigned&amp; lineCount,
 928     const TextFragmentIterator&amp; textFragmentIterator, bool lastLineInFlow)
 929 {
 930     if (!runs.size() || (lastRunIndexOfPreviousLine &amp;&amp; runs.size() - 1 == lastRunIndexOfPreviousLine.value()))
 931         return;
<span class="line-modified"> 932 </span>
<span class="line-added"> 933     const auto&amp; style = textFragmentIterator.style();</span>
<span class="line-added"> 934 </span>
<span class="line-added"> 935     if (style.collapseWhitespace)</span>
<span class="line-added"> 936         line.removeTrailingWhitespace(runs);</span>
<span class="line-added"> 937 </span>
 938     if (!runs.size())
 939         return;
<span class="line-added"> 940 </span>
 941     // Adjust runs&#39; position by taking line&#39;s alignment into account.

 942     auto firstRunIndex = lastRunIndexOfPreviousLine ? lastRunIndexOfPreviousLine.value() + 1 : 0;
 943     auto lineLogicalLeft = line.logicalLeftOffset();
 944     auto textAlign = textAlignForLine(style, lastLineInFlow || (line.lastFragment().isValid() &amp;&amp; line.lastFragment().type() == TextFragmentIterator::TextFragment::HardLineBreak));
<span class="line-modified"> 945 </span>
<span class="line-added"> 946     // https://www.w3.org/TR/css-text-3/#white-space-phase-2</span>
<span class="line-added"> 947     bool shouldHangTrailingWhitespace = style.wrapLines &amp;&amp; line.trailingWhitespaceWidth();</span>
<span class="line-added"> 948     auto hangingWhitespaceWidth = shouldHangTrailingWhitespace ? line.trailingWhitespaceWidth() : 0;</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     if (textAlign == TextAlignMode::Justify) {</span>
 951         justifyRuns(line, runs, firstRunIndex);
<span class="line-modified"> 952         hangingWhitespaceWidth = 0;</span>
<span class="line-modified"> 953     } else</span>
<span class="line-added"> 954         lineLogicalLeft = computeLineLeft(line, textAlign, hangingWhitespaceWidth);</span>
<span class="line-added"> 955 </span>
 956     for (auto i = firstRunIndex; i &lt; runs.size(); ++i) {
 957         runs[i].logicalLeft += lineLogicalLeft;
 958         runs[i].logicalRight += lineLogicalLeft;
 959     }
<span class="line-added"> 960 </span>
<span class="line-added"> 961     if (shouldHangTrailingWhitespace &amp;&amp; hangingWhitespaceWidth &lt; line.trailingWhitespaceWidth())</span>
<span class="line-added"> 962         runs.last().logicalRight = runs.last().logicalRight - (line.trailingWhitespaceWidth() - hangingWhitespaceWidth);</span>
<span class="line-added"> 963 </span>
 964     runs.last().isEndOfLine = true;
 965     ++lineCount;
 966 }
 967 
 968 static void createTextRuns(Layout::RunVector&amp; runs, RenderBlockFlow&amp; flow, unsigned&amp; lineCount)
 969 {
 970     LayoutUnit borderAndPaddingBefore = flow.borderAndPaddingBefore();
 971     LayoutUnit lineHeight = lineHeightFromFlow(flow);
 972     LineState line;
 973     unsigned numberOfPrecedingLinesWithHyphen = 0;
 974     bool isEndOfContent = false;
 975     TextFragmentIterator textFragmentIterator = TextFragmentIterator(flow);
 976     Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine;
 977     do {
 978         flow.setLogicalHeight(lineHeight * lineCount + borderAndPaddingBefore);
 979         LineState previousLine = line;
 980         line = LineState();
 981         updateLineConstrains(flow, line, previousLine, numberOfPrecedingLinesWithHyphen, textFragmentIterator.style(), !lineCount);
 982         isEndOfContent = createLineRuns(line, previousLine, runs, textFragmentIterator);
 983         closeLineEndingAndAdjustRuns(line, runs, lastRunIndexOfPreviousLine, lineCount, textFragmentIterator, isEndOfContent);
 984         if (runs.size())
 985             lastRunIndexOfPreviousLine = runs.size() - 1;
 986     } while (!isEndOfContent);
 987 }
 988 
<span class="line-modified"> 989 Ref&lt;Layout&gt; create(RenderBlockFlow&amp; flow)</span>
 990 {
 991     unsigned lineCount = 0;
 992     Layout::RunVector runs;
 993     createTextRuns(runs, flow, lineCount);
 994     return Layout::create(runs, lineCount, flow);
 995 }
 996 
<span class="line-modified"> 997 Ref&lt;Layout&gt; Layout::create(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)</span>
 998 {
 999     void* slot = WTF::fastMalloc(sizeof(Layout) + sizeof(Run) * runVector.size());
<span class="line-modified">1000     return adoptRef(*new (NotNull, slot) Layout(runVector, lineCount, blockFlow));</span>
1001 }
1002 
1003 Layout::Layout(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)
1004     : m_lineCount(lineCount)
1005     , m_runCount(runVector.size())
1006     , m_blockFlowRenderer(blockFlow)
1007 {
1008     memcpy(m_runs, runVector.data(), m_runCount * sizeof(Run));
1009 }
1010 
1011 const RunResolver&amp; Layout::runResolver() const
1012 {
1013     if (!m_runResolver)
1014         m_runResolver = makeUnique&lt;RunResolver&gt;(m_blockFlowRenderer, *this);
1015     return *m_runResolver;
1016 }
1017 
1018 Layout::~Layout()
1019 {
1020     simpleLineLayoutWillBeDeleted(*this);
</pre>
</td>
</tr>
</table>
<center><a href="SelectionRangeData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayout.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
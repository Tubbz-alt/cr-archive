diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCacheStorage.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCacheStorage.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCacheStorage.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCacheStorage.cpp
@@ -26,25 +26,27 @@
 #include "config.h"
 #include "DOMCacheStorage.h"
 
 #include "CacheQueryOptions.h"
 #include "ClientOrigin.h"
+#include "EventLoop.h"
 #include "JSDOMCache.h"
 #include "JSFetchResponse.h"
 #include "ScriptExecutionContext.h"
 
-
 namespace WebCore {
 using namespace WebCore::DOMCacheEngine;
 
 DOMCacheStorage::DOMCacheStorage(ScriptExecutionContext& context, Ref<CacheStorageConnection>&& connection)
     : ActiveDOMObject(&context)
     , m_connection(WTFMove(connection))
 {
     suspendIfNeeded();
 }
 
+DOMCacheStorage::~DOMCacheStorage() = default;
+
 Optional<ClientOrigin> DOMCacheStorage::origin() const
 {
     auto* origin = scriptExecutionContext() ? scriptExecutionContext()->securityOrigin() : nullptr;
     if (!origin)
         return WTF::nullopt;
@@ -58,17 +60,17 @@
         completionHandler(nullptr);
         return;
     }
 
     auto& cache = caches[index].get();
-    cache.doMatch(WTFMove(info), WTFMove(options), [caches = WTFMove(caches), info, options, completionHandler = WTFMove(completionHandler), index](ExceptionOr<FetchResponse*>&& result) mutable {
+    cache.doMatch(WTFMove(info), WTFMove(options), [caches = WTFMove(caches), info, options, completionHandler = WTFMove(completionHandler), index](auto&& result) mutable {
         if (result.hasException()) {
             completionHandler(result.releaseException());
             return;
         }
         if (result.returnValue()) {
-            completionHandler(result.returnValue());
+            completionHandler(result.releaseReturnValue());
             return;
         }
         doSequentialMatch(++index, WTFMove(caches), WTFMove(info), WTFMove(options), WTFMove(completionHandler));
     });
 }
@@ -83,13 +85,11 @@
     return cache.copyRef();
 }
 
 void DOMCacheStorage::doSequentialMatch(DOMCache::RequestInfo&& info, CacheQueryOptions&& options, Ref<DeferredPromise>&& promise)
 {
-    startSequentialMatch(WTF::map(m_caches, copyCache), WTFMove(info), WTFMove(options), [this, pendingActivity = makePendingActivity(*this), promise = WTFMove(promise)](ExceptionOr<FetchResponse*>&& result) mutable {
-        if (m_isStopped)
-            return;
+    startSequentialMatch(WTF::map(m_caches, copyCache), WTFMove(info), WTFMove(options), [pendingActivity = makePendingActivity(*this), promise = WTFMove(promise)](auto&& result) mutable {
         if (result.hasException()) {
             promise->reject(result.releaseException());
             return;
         }
         if (!result.returnValue()) {
@@ -102,11 +102,11 @@
 
 void DOMCacheStorage::match(DOMCache::RequestInfo&& info, CacheQueryOptions&& options, Ref<DeferredPromise>&& promise)
 {
     retrieveCaches([this, info = WTFMove(info), options = WTFMove(options), promise = WTFMove(promise)](Optional<Exception>&& exception) mutable {
         if (exception) {
-            promise->reject(WTFMove(exception.value()));
+            promise->reject(WTFMove(*exception));
             return;
         }
 
         if (!options.cacheName.isNull()) {
             auto position = m_caches.findMatching([&](auto& item) { return item->name() == options.cacheName; });
@@ -139,34 +139,38 @@
    if (position != notFound)
        return m_caches[position].copyRef();
    return DOMCache::create(*scriptExecutionContext(), WTFMove(info.name), info.identifier, m_connection.copyRef());
 }
 
-void DOMCacheStorage::retrieveCaches(WTF::Function<void(Optional<Exception>&&)>&& callback)
+void DOMCacheStorage::retrieveCaches(CompletionHandler<void(Optional<Exception>&&)>&& callback)
 {
     auto origin = this->origin();
-    if (!origin)
+    if (!origin) {
+        callback(convertToExceptionAndLog(scriptExecutionContext(), DOMCacheEngine::Error::Stopped));
         return;
+    }
 
     m_connection->retrieveCaches(*origin, m_updateCounter, [this, callback = WTFMove(callback), pendingActivity = makePendingActivity(*this)](CacheInfosOrError&& result) mutable {
-        if (!m_isStopped) {
-            if (!result.has_value()) {
-                callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
-                return;
-            }
+        if (m_isStopped) {
+            callback(DOMCacheEngine::convertToException(DOMCacheEngine::Error::Stopped));
+            return;
+        }
+        if (!result.has_value()) {
+            callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
+            return;
+        }
 
-            auto& cachesInfo = result.value();
+        auto& cachesInfo = result.value();
 
-            if (m_updateCounter != cachesInfo.updateCounter) {
-                m_updateCounter = cachesInfo.updateCounter;
+        if (m_updateCounter != cachesInfo.updateCounter) {
+            m_updateCounter = cachesInfo.updateCounter;
 
-                m_caches = WTF::map(WTFMove(cachesInfo.infos), [this] (CacheInfo&& info) {
-                    return findCacheOrCreate(WTFMove(info));
-                });
-            }
-            callback(WTF::nullopt);
+            m_caches = WTF::map(WTFMove(cachesInfo.infos), [this] (CacheInfo&& info) {
+                return findCacheOrCreate(WTFMove(info));
+            });
         }
+        callback(WTF::nullopt);
     });
 }
 
 static void logConsolePersistencyError(ScriptExecutionContext* context, const String& cacheName)
 {
@@ -178,47 +182,44 @@
 
 void DOMCacheStorage::open(const String& name, DOMPromiseDeferred<IDLInterface<DOMCache>>&& promise)
 {
     retrieveCaches([this, name, promise = WTFMove(promise)](Optional<Exception>&& exception) mutable {
         if (exception) {
-            promise.reject(WTFMove(exception.value()));
+            promise.reject(WTFMove(*exception));
             return;
         }
         doOpen(name, WTFMove(promise));
     });
 }
 
 void DOMCacheStorage::doOpen(const String& name, DOMPromiseDeferred<IDLInterface<DOMCache>>&& promise)
 {
     auto position = m_caches.findMatching([&](auto& item) { return item->name() == name; });
     if (position != notFound) {
-        auto& cache = m_caches[position];
-        promise.resolve(DOMCache::create(*scriptExecutionContext(), String { cache->name() }, cache->identifier(), m_connection.copyRef()));
+        promise.resolve(DOMCache::create(*scriptExecutionContext(), String { m_caches[position]->name() }, m_caches[position]->identifier(), m_connection.copyRef()));
         return;
     }
 
     m_connection->open(*origin(), name, [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError& result) mutable {
-        if (!m_isStopped) {
-            if (!result.has_value())
-                promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
-            else {
-                if (result.value().hadStorageError)
-                    logConsolePersistencyError(scriptExecutionContext(), name);
-
-                auto cache = DOMCache::create(*scriptExecutionContext(), String { name }, result.value().identifier, m_connection.copyRef());
-                promise.resolve(cache);
-                m_caches.append(WTFMove(cache));
-            }
+        if (!result.has_value())
+            promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
+        else {
+            if (result.value().hadStorageError)
+                logConsolePersistencyError(scriptExecutionContext(), name);
+
+            auto cache = DOMCache::create(*scriptExecutionContext(), String { name }, result.value().identifier, m_connection.copyRef());
+            promise.resolve(cache);
+            m_caches.append(WTFMove(cache));
         }
     });
 }
 
 void DOMCacheStorage::remove(const String& name, DOMPromiseDeferred<IDLBoolean>&& promise)
 {
     retrieveCaches([this, name, promise = WTFMove(promise)](Optional<Exception>&& exception) mutable {
         if (exception) {
-            promise.reject(WTFMove(exception.value()));
+            promise.reject(WTFMove(*exception));
             return;
         }
         doRemove(name, WTFMove(promise));
     });
 }
@@ -230,18 +231,16 @@
         promise.resolve(false);
         return;
     }
 
     m_connection->remove(m_caches[position]->identifier(), [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError& result) mutable {
-        if (!m_isStopped) {
-            if (!result.has_value())
-                promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
-            else {
-                if (result.value().hadStorageError)
-                    logConsolePersistencyError(scriptExecutionContext(), name);
-                promise.resolve(!!result.value().identifier);
-            }
+        if (!result.has_value())
+            promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
+        else {
+            if (result.value().hadStorageError)
+                logConsolePersistencyError(scriptExecutionContext(), name);
+            promise.resolve(!!result.value().identifier);
         }
     });
 }
 
 void DOMCacheStorage::keys(KeysPromise&& promise)
@@ -266,11 +265,6 @@
 const char* DOMCacheStorage::activeDOMObjectName() const
 {
     return "CacheStorage";
 }
 
-bool DOMCacheStorage::canSuspendForDocumentSuspension() const
-{
-    return !hasPendingActivity();
-}
-
 } // namespace WebCore

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseOperations.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PromiseConstructor.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PromisePrototype.js.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseOperations.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
<span class="line-modified">  3  * Copyright (C) 2016 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 // @internal
 28 
 29 @globalPrivate
<span class="line-modified"> 30 function isPromise(promise)</span>
<span class="line-removed"> 31 {</span>
<span class="line-removed"> 32     &quot;use strict&quot;;</span>
<span class="line-removed"> 33 </span>
<span class="line-removed"> 34     return @isObject(promise) &amp;&amp; !!@getByIdDirectPrivate(promise, &quot;promiseState&quot;);</span>
<span class="line-removed"> 35 }</span>
<span class="line-removed"> 36 </span>
<span class="line-removed"> 37 @globalPrivate</span>
<span class="line-removed"> 38 function newPromiseReaction(capability, onFulfilled, onRejected)</span>
 39 {
 40     &quot;use strict&quot;;
 41 
 42     return {
<span class="line-modified"> 43         @capabilities: capability,</span>
 44         @onFulfilled: onFulfilled,
 45         @onRejected: onRejected,

 46     };
 47 }
 48 
 49 @globalPrivate
<span class="line-modified"> 50 function newPromiseCapability(constructor)</span>
 51 {
<span class="line-removed"> 52     &quot;use strict&quot;;</span>
<span class="line-removed"> 53 </span>
<span class="line-removed"> 54     if (!@isConstructor(constructor))</span>
<span class="line-removed"> 55         @throwTypeError(&quot;promise capability requires a constructor function&quot;);</span>
<span class="line-removed"> 56 </span>
 57     var promiseCapability = {
<span class="line-removed"> 58         @promise: @undefined,</span>
 59         @resolve: @undefined,
<span class="line-modified"> 60         @reject: @undefined</span>

 61     };
 62 
<span class="line-modified"> 63     function @executor(resolve, reject)</span>
<span class="line-modified"> 64     {</span>


 65         if (promiseCapability.@resolve !== @undefined)
 66             @throwTypeError(&quot;resolve function is already set&quot;);
 67         if (promiseCapability.@reject !== @undefined)
 68             @throwTypeError(&quot;reject function is already set&quot;);
 69 
 70         promiseCapability.@resolve = resolve;
 71         promiseCapability.@reject = reject;
<span class="line-modified"> 72     }</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74     var promise = new constructor(@executor);</span>
 75 
 76     if (typeof promiseCapability.@resolve !== &quot;function&quot;)
 77         @throwTypeError(&quot;executor did not take a resolve function&quot;);
 78 
 79     if (typeof promiseCapability.@reject !== &quot;function&quot;)
 80         @throwTypeError(&quot;executor did not take a reject function&quot;);
 81 
 82     promiseCapability.@promise = promise;
 83 
 84     return promiseCapability;
 85 }
 86 






































 87 @globalPrivate
 88 function newHandledRejectedPromise(error)
 89 {
 90     &quot;use strict&quot;;
<span class="line-modified"> 91     let promise = @Promise.@reject(error);</span>
<span class="line-modified"> 92     @putByIdDirectPrivate(promise, &quot;promiseIsHandled&quot;, true);</span>

 93     return promise;
 94 }
 95 
 96 @globalPrivate
 97 function triggerPromiseReactions(state, reactions, argument)
 98 {
 99     &quot;use strict&quot;;
100 
<span class="line-modified">101     for (var index = 0, length = reactions.length; index &lt; length; ++index)</span>
<span class="line-modified">102         @enqueueJob(@promiseReactionJob, [state, reactions[index], argument]);</span>













































103 }
104 
105 @globalPrivate
106 function rejectPromise(promise, reason)
107 {
108     &quot;use strict&quot;;
109 
<span class="line-modified">110     var reactions = @getByIdDirectPrivate(promise, &quot;promiseReactions&quot;);</span>
<span class="line-modified">111     @putByIdDirectPrivate(promise, &quot;promiseResult&quot;, reason);</span>
<span class="line-modified">112     @putByIdDirectPrivate(promise, &quot;promiseReactions&quot;, @undefined);</span>
<span class="line-modified">113     @putByIdDirectPrivate(promise, &quot;promiseState&quot;, @promiseStateRejected);</span>



114 
115     @InspectorInstrumentation.promiseRejected(promise, reason, reactions);
116 
<span class="line-modified">117     if (!@getByIdDirectPrivate(promise, &quot;promiseIsHandled&quot;))</span>
118         @hostPromiseRejectionTracker(promise, @promiseRejectionReject);
119 
120     @triggerPromiseReactions(@promiseStateRejected, reactions, reason);
121 }
122 
123 @globalPrivate
124 function fulfillPromise(promise, value)
125 {
126     &quot;use strict&quot;;
127 
<span class="line-modified">128     var reactions = @getByIdDirectPrivate(promise, &quot;promiseReactions&quot;);</span>
<span class="line-modified">129     @putByIdDirectPrivate(promise, &quot;promiseResult&quot;, value);</span>
<span class="line-modified">130     @putByIdDirectPrivate(promise, &quot;promiseReactions&quot;, @undefined);</span>
<span class="line-modified">131     @putByIdDirectPrivate(promise, &quot;promiseState&quot;, @promiseStateFulfilled);</span>



132 
133     @InspectorInstrumentation.promiseFulfilled(promise, value, reactions);
134 
135     @triggerPromiseReactions(@promiseStateFulfilled, reactions, value);
136 }
137 






















138 @globalPrivate
139 function createResolvingFunctions(promise)
140 {
141     &quot;use strict&quot;;
142 


143     var alreadyResolved = false;
144 
145     function @resolve(resolution) {
146         if (alreadyResolved)
147             return @undefined;
148         alreadyResolved = true;
149 
<span class="line-modified">150         if (resolution === promise)</span>
<span class="line-modified">151             return @rejectPromise(promise, @makeTypeError(&quot;Resolve a promise with itself&quot;));</span>
152 
<span class="line-modified">153         if (!@isObject(resolution))</span>
<span class="line-modified">154             return @fulfillPromise(promise, resolution);</span>


155 
<span class="line-modified">156         var then;</span>
<span class="line-modified">157         try {</span>
<span class="line-modified">158             then = resolution.then;</span>
<span class="line-modified">159         } catch (error) {</span>
<span class="line-modified">160             return @rejectPromise(promise, error);</span>
<span class="line-modified">161         }</span>






















162 
<span class="line-modified">163         if (typeof then !== &#39;function&#39;)</span>
<span class="line-modified">164             return @fulfillPromise(promise, resolution);</span>





165 
<span class="line-modified">166         @enqueueJob(@promiseResolveThenableJob, [promise, resolution, then]);</span>



167 
<span class="line-modified">168         return @undefined;</span>







































169     }
170 
171     function @reject(reason) {
172         if (alreadyResolved)
173             return @undefined;
174         alreadyResolved = true;
175 
<span class="line-modified">176         return @rejectPromise(promise, reason);</span>
177     }
178 
179     return { @resolve, @reject };
180 }
181 
182 @globalPrivate
183 function promiseReactionJob(state, reaction, argument)
184 {









185     &quot;use strict&quot;;
186 
<span class="line-modified">187     var promiseCapability = reaction.@capabilities;</span>















188 
<span class="line-removed">189     var result;</span>
190     var handler = (state === @promiseStateFulfilled) ? reaction.@onFulfilled: reaction.@onRejected;









191     try {
192         result = handler(argument);
193     } catch (error) {
<span class="line-modified">194         return promiseCapability.@reject.@call(@undefined, error);</span>





195     }
196 
<span class="line-modified">197     return promiseCapability.@resolve.@call(@undefined, result);</span>




198 }
199 
200 @globalPrivate
<span class="line-modified">201 function promiseResolveThenableJob(promiseToResolve, thenable, then)</span>
202 {
203     &quot;use strict&quot;;
204 
<span class="line-modified">205     var resolvingFunctions = @createResolvingFunctions(promiseToResolve);</span>
<span class="line-modified">206 </span>
<span class="line-modified">207     try {</span>
<span class="line-modified">208         return then.@call(thenable, resolvingFunctions.@resolve, resolvingFunctions.@reject);</span>
<span class="line-modified">209     } catch (error) {</span>
<span class="line-modified">210         return resolvingFunctions.@reject.@call(@undefined, error);</span>







211     }

212 }
213 
214 @globalPrivate
<span class="line-modified">215 function initializePromise(executor)</span>
216 {
217     &quot;use strict&quot;;
218 
<span class="line-modified">219     @putByIdDirectPrivate(this, &quot;promiseState&quot;, @promiseStatePending);</span>
<span class="line-modified">220     @putByIdDirectPrivate(this, &quot;promiseReactions&quot;, []);</span>
<span class="line-modified">221     @putByIdDirectPrivate(this, &quot;promiseIsHandled&quot;, false);</span>





















222 
<span class="line-removed">223     var resolvingFunctions = @createResolvingFunctions(this);</span>
224     try {
<span class="line-modified">225         executor(resolvingFunctions.@resolve, resolvingFunctions.@reject);</span>
226     } catch (error) {
227         return resolvingFunctions.@reject.@call(@undefined, error);
228     }
<span class="line-removed">229 </span>
<span class="line-removed">230     return this;</span>
231 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
<span class="line-modified">  3  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 // @internal
 28 
 29 @globalPrivate
<span class="line-modified"> 30 function newPromiseReaction(promiseOrCapability, onFulfilled, onRejected)</span>








 31 {
 32     &quot;use strict&quot;;
 33 
 34     return {
<span class="line-modified"> 35         @promiseOrCapability: promiseOrCapability,</span>
 36         @onFulfilled: onFulfilled,
 37         @onRejected: onRejected,
<span class="line-added"> 38         @next: @undefined,</span>
 39     };
 40 }
 41 
 42 @globalPrivate
<span class="line-modified"> 43 function newPromiseCapabilitySlow(constructor)</span>
 44 {





 45     var promiseCapability = {

 46         @resolve: @undefined,
<span class="line-modified"> 47         @reject: @undefined,</span>
<span class="line-added"> 48         @promise: @undefined,</span>
 49     };
 50 
<span class="line-modified"> 51     if (!@isConstructor(constructor))</span>
<span class="line-modified"> 52         @throwTypeError(&quot;promise capability requires a constructor function&quot;);</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54     var promise = new constructor(function (resolve, reject) {</span>
 55         if (promiseCapability.@resolve !== @undefined)
 56             @throwTypeError(&quot;resolve function is already set&quot;);
 57         if (promiseCapability.@reject !== @undefined)
 58             @throwTypeError(&quot;reject function is already set&quot;);
 59 
 60         promiseCapability.@resolve = resolve;
 61         promiseCapability.@reject = reject;
<span class="line-modified"> 62     });</span>


 63 
 64     if (typeof promiseCapability.@resolve !== &quot;function&quot;)
 65         @throwTypeError(&quot;executor did not take a resolve function&quot;);
 66 
 67     if (typeof promiseCapability.@reject !== &quot;function&quot;)
 68         @throwTypeError(&quot;executor did not take a reject function&quot;);
 69 
 70     promiseCapability.@promise = promise;
 71 
 72     return promiseCapability;
 73 }
 74 
<span class="line-added"> 75 @globalPrivate</span>
<span class="line-added"> 76 function newPromiseCapability(constructor)</span>
<span class="line-added"> 77 {</span>
<span class="line-added"> 78     &quot;use strict&quot;;</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80     if (constructor === @Promise) {</span>
<span class="line-added"> 81         var promise = @newPromise();</span>
<span class="line-added"> 82         var capturedPromise = promise;</span>
<span class="line-added"> 83         function @resolve(resolution) {</span>
<span class="line-added"> 84             return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);</span>
<span class="line-added"> 85         }</span>
<span class="line-added"> 86         function @reject(reason) {</span>
<span class="line-added"> 87             return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);</span>
<span class="line-added"> 88         }</span>
<span class="line-added"> 89         return { @resolve, @reject, @promise: promise };</span>
<span class="line-added"> 90     }</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92     return @newPromiseCapabilitySlow(constructor);</span>
<span class="line-added"> 93 }</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95 @globalPrivate</span>
<span class="line-added"> 96 function promiseResolveSlow(constructor, value)</span>
<span class="line-added"> 97 {</span>
<span class="line-added"> 98     @assert(constructor !== @Promise);</span>
<span class="line-added"> 99     var promiseCapability = @newPromiseCapabilitySlow(constructor);</span>
<span class="line-added">100     promiseCapability.@resolve.@call(@undefined, value);</span>
<span class="line-added">101     return promiseCapability.@promise;</span>
<span class="line-added">102 }</span>
<span class="line-added">103 </span>
<span class="line-added">104 @globalPrivate</span>
<span class="line-added">105 function promiseRejectSlow(constructor, reason)</span>
<span class="line-added">106 {</span>
<span class="line-added">107     @assert(constructor !== @Promise);</span>
<span class="line-added">108     var promiseCapability = @newPromiseCapabilitySlow(constructor);</span>
<span class="line-added">109     promiseCapability.@reject.@call(@undefined, reason);</span>
<span class="line-added">110     return promiseCapability.@promise;</span>
<span class="line-added">111 }</span>
<span class="line-added">112 </span>
113 @globalPrivate
114 function newHandledRejectedPromise(error)
115 {
116     &quot;use strict&quot;;
<span class="line-modified">117     var promise = @newPromise();</span>
<span class="line-modified">118     @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);</span>
<span class="line-added">119     @putPromiseInternalField(promise, @promiseFieldFlags, @getPromiseInternalField(promise, @promiseFieldFlags) | @promiseFlagsIsHandled);</span>
120     return promise;
121 }
122 
123 @globalPrivate
124 function triggerPromiseReactions(state, reactions, argument)
125 {
126     &quot;use strict&quot;;
127 
<span class="line-modified">128     // Reverse the order of singly-linked-list.</span>
<span class="line-modified">129     var previous = @undefined;</span>
<span class="line-added">130     var current = reactions;</span>
<span class="line-added">131     while (current) {</span>
<span class="line-added">132         var next = current.@next;</span>
<span class="line-added">133         current.@next = previous;</span>
<span class="line-added">134         previous = current;</span>
<span class="line-added">135         current = next;</span>
<span class="line-added">136     }</span>
<span class="line-added">137     reactions = previous;</span>
<span class="line-added">138 </span>
<span class="line-added">139     current = reactions;</span>
<span class="line-added">140     while (current) {</span>
<span class="line-added">141         @enqueueJob(@promiseReactionJob, state, current, argument);</span>
<span class="line-added">142         current = current.@next;</span>
<span class="line-added">143     }</span>
<span class="line-added">144 }</span>
<span class="line-added">145 </span>
<span class="line-added">146 @globalPrivate</span>
<span class="line-added">147 function resolvePromise(promise, resolution)</span>
<span class="line-added">148 {</span>
<span class="line-added">149     &quot;use strict&quot;;</span>
<span class="line-added">150 </span>
<span class="line-added">151     @assert(@isPromise(promise));</span>
<span class="line-added">152 </span>
<span class="line-added">153     if (resolution === promise)</span>
<span class="line-added">154         return @rejectPromise(promise, @makeTypeError(&quot;Cannot resolve a promise with itself&quot;));</span>
<span class="line-added">155 </span>
<span class="line-added">156     if (!@isObject(resolution))</span>
<span class="line-added">157         return @fulfillPromise(promise, resolution);</span>
<span class="line-added">158 </span>
<span class="line-added">159     var then;</span>
<span class="line-added">160     try {</span>
<span class="line-added">161         then = resolution.then;</span>
<span class="line-added">162     } catch (error) {</span>
<span class="line-added">163         return @rejectPromise(promise, error);</span>
<span class="line-added">164     }</span>
<span class="line-added">165 </span>
<span class="line-added">166     if (@isPromise(resolution) &amp;&amp; then === @defaultPromiseThen) {</span>
<span class="line-added">167         @enqueueJob(@promiseResolveThenableJobFast, resolution, promise);</span>
<span class="line-added">168         return;</span>
<span class="line-added">169     }</span>
<span class="line-added">170 </span>
<span class="line-added">171     if (typeof then !== &#39;function&#39;)</span>
<span class="line-added">172         return @fulfillPromise(promise, resolution);</span>
<span class="line-added">173 </span>
<span class="line-added">174     @enqueueJob(@promiseResolveThenableJob, resolution, then, @createResolvingFunctions(promise));</span>
175 }
176 
177 @globalPrivate
178 function rejectPromise(promise, reason)
179 {
180     &quot;use strict&quot;;
181 
<span class="line-modified">182     @assert(@isPromise(promise));</span>
<span class="line-modified">183     @assert((@getPromiseInternalField(promise, @promiseFieldFlags) &amp; @promiseStateMask) == @promiseStatePending);</span>
<span class="line-modified">184 </span>
<span class="line-modified">185     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">186     var reactions = @getPromiseInternalField(promise, @promiseFieldReactionsOrResult);</span>
<span class="line-added">187     @putPromiseInternalField(promise, @promiseFieldReactionsOrResult, reason);</span>
<span class="line-added">188     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseStateRejected);</span>
189 
190     @InspectorInstrumentation.promiseRejected(promise, reason, reactions);
191 
<span class="line-modified">192     if (!(flags &amp; @promiseFlagsIsHandled))</span>
193         @hostPromiseRejectionTracker(promise, @promiseRejectionReject);
194 
195     @triggerPromiseReactions(@promiseStateRejected, reactions, reason);
196 }
197 
198 @globalPrivate
199 function fulfillPromise(promise, value)
200 {
201     &quot;use strict&quot;;
202 
<span class="line-modified">203     @assert(@isPromise(promise));</span>
<span class="line-modified">204     @assert((@getPromiseInternalField(promise, @promiseFieldFlags) &amp; @promiseStateMask) == @promiseStatePending);</span>
<span class="line-modified">205 </span>
<span class="line-modified">206     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">207     var reactions = @getPromiseInternalField(promise, @promiseFieldReactionsOrResult);</span>
<span class="line-added">208     @putPromiseInternalField(promise, @promiseFieldReactionsOrResult, value);</span>
<span class="line-added">209     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseStateFulfilled);</span>
210 
211     @InspectorInstrumentation.promiseFulfilled(promise, value, reactions);
212 
213     @triggerPromiseReactions(@promiseStateFulfilled, reactions, value);
214 }
215 
<span class="line-added">216 @globalPrivate</span>
<span class="line-added">217 function resolvePromiseWithFirstResolvingFunctionCallCheck(promise, value)</span>
<span class="line-added">218 {</span>
<span class="line-added">219     @assert(@isPromise(promise));</span>
<span class="line-added">220     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">221     if (flags &amp; @promiseFlagsIsFirstResolvingFunctionCalled)</span>
<span class="line-added">222         return;</span>
<span class="line-added">223     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseFlagsIsFirstResolvingFunctionCalled);</span>
<span class="line-added">224     return @resolvePromise(promise, value);</span>
<span class="line-added">225 }</span>
<span class="line-added">226 </span>
<span class="line-added">227 @globalPrivate</span>
<span class="line-added">228 function rejectPromiseWithFirstResolvingFunctionCallCheck(promise, reason)</span>
<span class="line-added">229 {</span>
<span class="line-added">230     @assert(@isPromise(promise));</span>
<span class="line-added">231     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">232     if (flags &amp; @promiseFlagsIsFirstResolvingFunctionCalled)</span>
<span class="line-added">233         return;</span>
<span class="line-added">234     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseFlagsIsFirstResolvingFunctionCalled);</span>
<span class="line-added">235     return @rejectPromise(promise, reason);</span>
<span class="line-added">236 }</span>
<span class="line-added">237 </span>
238 @globalPrivate
239 function createResolvingFunctions(promise)
240 {
241     &quot;use strict&quot;;
242 
<span class="line-added">243     @assert(@isPromise(promise));</span>
<span class="line-added">244 </span>
245     var alreadyResolved = false;
246 
247     function @resolve(resolution) {
248         if (alreadyResolved)
249             return @undefined;
250         alreadyResolved = true;
251 
<span class="line-modified">252         return @resolvePromise(promise, resolution);</span>
<span class="line-modified">253     }</span>
254 
<span class="line-modified">255     function @reject(reason) {</span>
<span class="line-modified">256         if (alreadyResolved)</span>
<span class="line-added">257             return @undefined;</span>
<span class="line-added">258         alreadyResolved = true;</span>
259 
<span class="line-modified">260         return @rejectPromise(promise, reason);</span>
<span class="line-modified">261     }</span>
<span class="line-modified">262 </span>
<span class="line-modified">263     return { @resolve, @reject };</span>
<span class="line-modified">264 }</span>
<span class="line-modified">265 </span>
<span class="line-added">266 @globalPrivate</span>
<span class="line-added">267 function promiseReactionJobWithoutPromise(handler, argument)</span>
<span class="line-added">268 {</span>
<span class="line-added">269     &quot;use strict&quot;;</span>
<span class="line-added">270 </span>
<span class="line-added">271     try {</span>
<span class="line-added">272         handler(argument);</span>
<span class="line-added">273     } catch {</span>
<span class="line-added">274         // This is user-uncatchable promise. We just ignore the error here.</span>
<span class="line-added">275     }</span>
<span class="line-added">276 }</span>
<span class="line-added">277 </span>
<span class="line-added">278 // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.</span>
<span class="line-added">279 @globalPrivate</span>
<span class="line-added">280 function resolveWithoutPromise(resolution, onFulfilled, onRejected)</span>
<span class="line-added">281 {</span>
<span class="line-added">282     &quot;use strict&quot;;</span>
<span class="line-added">283 </span>
<span class="line-added">284     if (!@isObject(resolution)) {</span>
<span class="line-added">285         @fulfillWithoutPromise(resolution, onFulfilled, onRejected);</span>
<span class="line-added">286         return;</span>
<span class="line-added">287     }</span>
288 
<span class="line-modified">289     var then;</span>
<span class="line-modified">290     try {</span>
<span class="line-added">291         then = resolution.then;</span>
<span class="line-added">292     } catch (error) {</span>
<span class="line-added">293         @rejectWithoutPromise(error, onFulfilled, onRejected);</span>
<span class="line-added">294         return;</span>
<span class="line-added">295     }</span>
296 
<span class="line-modified">297     if (@isPromise(resolution) &amp;&amp; then === @defaultPromiseThen) {</span>
<span class="line-added">298         @enqueueJob(@promiseResolveThenableJobWithoutPromiseFast, resolution, onFulfilled, onRejected);</span>
<span class="line-added">299         return;</span>
<span class="line-added">300     }</span>
301 
<span class="line-modified">302     if (typeof then !== &#39;function&#39;) {</span>
<span class="line-added">303         @fulfillWithoutPromise(resolution, onFulfilled, onRejected);</span>
<span class="line-added">304         return;</span>
<span class="line-added">305     }</span>
<span class="line-added">306 </span>
<span class="line-added">307     // Wrap onFulfilled and onRejected with @createResolvingFunctionsWithoutPromise to ensure that each function will be called at most once.</span>
<span class="line-added">308     @enqueueJob(@promiseResolveThenableJob, resolution, then, @createResolvingFunctionsWithoutPromise(onFulfilled, onRejected));</span>
<span class="line-added">309 }</span>
<span class="line-added">310 </span>
<span class="line-added">311 // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.</span>
<span class="line-added">312 @globalPrivate</span>
<span class="line-added">313 function rejectWithoutPromise(reason, onFulfilled, onRejected)</span>
<span class="line-added">314 {</span>
<span class="line-added">315     &quot;use strict&quot;;</span>
<span class="line-added">316 </span>
<span class="line-added">317     @enqueueJob(@promiseReactionJobWithoutPromise, onRejected, reason);</span>
<span class="line-added">318 }</span>
<span class="line-added">319 </span>
<span class="line-added">320 // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.</span>
<span class="line-added">321 @globalPrivate</span>
<span class="line-added">322 function fulfillWithoutPromise(value, onFulfilled, onRejected)</span>
<span class="line-added">323 {</span>
<span class="line-added">324     &quot;use strict&quot;;</span>
<span class="line-added">325 </span>
<span class="line-added">326     @enqueueJob(@promiseReactionJobWithoutPromise, onFulfilled, value);</span>
<span class="line-added">327 }</span>
<span class="line-added">328 </span>
<span class="line-added">329 @globalPrivate</span>
<span class="line-added">330 function createResolvingFunctionsWithoutPromise(onFulfilled, onRejected)</span>
<span class="line-added">331 {</span>
<span class="line-added">332     &quot;use strict&quot;;</span>
<span class="line-added">333 </span>
<span class="line-added">334     var alreadyResolved = false;</span>
<span class="line-added">335 </span>
<span class="line-added">336     function @resolve(resolution) {</span>
<span class="line-added">337         if (alreadyResolved)</span>
<span class="line-added">338             return @undefined;</span>
<span class="line-added">339         alreadyResolved = true;</span>
<span class="line-added">340 </span>
<span class="line-added">341         @resolveWithoutPromise(resolution, onFulfilled, onRejected);</span>
342     }
343 
344     function @reject(reason) {
345         if (alreadyResolved)
346             return @undefined;
347         alreadyResolved = true;
348 
<span class="line-modified">349         @rejectWithoutPromise(reason, onFulfilled, onRejected);</span>
350     }
351 
352     return { @resolve, @reject };
353 }
354 
355 @globalPrivate
356 function promiseReactionJob(state, reaction, argument)
357 {
<span class="line-added">358     // Promise Reaction has four types.</span>
<span class="line-added">359     // 1. @promiseOrCapability is PromiseCapability, and having handlers.</span>
<span class="line-added">360     //     The most generic one.</span>
<span class="line-added">361     // 2. @promiseOrCapability is Promise, and having handlers.</span>
<span class="line-added">362     //     We just have promise.</span>
<span class="line-added">363     // 3. @promiseOrCapability is Promise, and not having handlers.</span>
<span class="line-added">364     //     It only has promise. Just resolving it with the value.</span>
<span class="line-added">365     // 4. Only having @onFulfilled and @onRejected</span>
<span class="line-added">366     //     It does not have promise capability. Just handlers are passed.</span>
367     &quot;use strict&quot;;
368 
<span class="line-modified">369     var promiseOrCapability = reaction.@promiseOrCapability;</span>
<span class="line-added">370 </span>
<span class="line-added">371     // Case (3).</span>
<span class="line-added">372     if (!reaction.@onRejected) {</span>
<span class="line-added">373         @assert(!reaction.@onFulfilled);</span>
<span class="line-added">374         try {</span>
<span class="line-added">375             @assert(@isPromise(promiseOrCapability));</span>
<span class="line-added">376             if (state === @promiseStateFulfilled)</span>
<span class="line-added">377                 @resolvePromise(promiseOrCapability, argument);</span>
<span class="line-added">378             else</span>
<span class="line-added">379                 @rejectPromise(promiseOrCapability, argument);</span>
<span class="line-added">380         } catch {</span>
<span class="line-added">381             // This is user-uncatchable promise. We just ignore the error here.</span>
<span class="line-added">382         }</span>
<span class="line-added">383         return;</span>
<span class="line-added">384     }</span>
385 

386     var handler = (state === @promiseStateFulfilled) ? reaction.@onFulfilled: reaction.@onRejected;
<span class="line-added">387 </span>
<span class="line-added">388     // Case (4).</span>
<span class="line-added">389     if (!promiseOrCapability) {</span>
<span class="line-added">390         @promiseReactionJobWithoutPromise(handler, argument);</span>
<span class="line-added">391         return;</span>
<span class="line-added">392     }</span>
<span class="line-added">393 </span>
<span class="line-added">394     // Case (1), or (2).</span>
<span class="line-added">395     var result;</span>
396     try {
397         result = handler(argument);
398     } catch (error) {
<span class="line-modified">399         if (@isPromise(promiseOrCapability)) {</span>
<span class="line-added">400             @rejectPromise(promiseOrCapability, error);</span>
<span class="line-added">401             return;</span>
<span class="line-added">402         }</span>
<span class="line-added">403         promiseOrCapability.@reject.@call(@undefined, error);</span>
<span class="line-added">404         return;</span>
405     }
406 
<span class="line-modified">407     if (@isPromise(promiseOrCapability)) {</span>
<span class="line-added">408         @resolvePromise(promiseOrCapability, result);</span>
<span class="line-added">409         return;</span>
<span class="line-added">410     }</span>
<span class="line-added">411     promiseOrCapability.@resolve.@call(@undefined, result);</span>
412 }
413 
414 @globalPrivate
<span class="line-modified">415 function promiseResolveThenableJobFast(thenable, promiseToResolve)</span>
416 {
417     &quot;use strict&quot;;
418 
<span class="line-modified">419     @assert(@isPromise(thenable));</span>
<span class="line-modified">420     @assert(@isPromise(promiseToResolve));</span>
<span class="line-modified">421 </span>
<span class="line-modified">422     var flags = @getPromiseInternalField(thenable, @promiseFieldFlags);</span>
<span class="line-modified">423     var state = flags &amp; @promiseStateMask;</span>
<span class="line-modified">424     var reaction = @newPromiseReaction(promiseToResolve, @undefined, @undefined);</span>
<span class="line-added">425     if (state === @promiseStatePending) {</span>
<span class="line-added">426         reaction.@next = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);</span>
<span class="line-added">427         @putPromiseInternalField(thenable, @promiseFieldReactionsOrResult, reaction);</span>
<span class="line-added">428     } else {</span>
<span class="line-added">429         if (state === @promiseStateRejected &amp;&amp; !(flags &amp; @promiseFlagsIsHandled))</span>
<span class="line-added">430             @hostPromiseRejectionTracker(thenable, @promiseRejectionHandle);</span>
<span class="line-added">431         @enqueueJob(@promiseReactionJob, state, reaction, @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult));</span>
432     }
<span class="line-added">433     @putPromiseInternalField(thenable, @promiseFieldFlags, @getPromiseInternalField(thenable, @promiseFieldFlags) | @promiseFlagsIsHandled);</span>
434 }
435 
436 @globalPrivate
<span class="line-modified">437 function promiseResolveThenableJobWithoutPromiseFast(thenable, onFulfilled, onRejected)</span>
438 {
439     &quot;use strict&quot;;
440 
<span class="line-modified">441     @assert(@isPromise(thenable));</span>
<span class="line-modified">442 </span>
<span class="line-modified">443     var flags = @getPromiseInternalField(thenable, @promiseFieldFlags);</span>
<span class="line-added">444     var state = flags &amp; @promiseStateMask;</span>
<span class="line-added">445     if (state === @promiseStatePending) {</span>
<span class="line-added">446         var reaction = @newPromiseReaction(@undefined, onFulfilled, onRejected);</span>
<span class="line-added">447         reaction.@next = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);</span>
<span class="line-added">448         @putPromiseInternalField(thenable, @promiseFieldReactionsOrResult, reaction);</span>
<span class="line-added">449     } else {</span>
<span class="line-added">450         var result = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);</span>
<span class="line-added">451         if (state === @promiseStateRejected) {</span>
<span class="line-added">452             if (!(flags &amp; @promiseFlagsIsHandled))</span>
<span class="line-added">453                 @hostPromiseRejectionTracker(thenable, @promiseRejectionHandle);</span>
<span class="line-added">454             @rejectWithoutPromise(result, onFulfilled, onRejected);</span>
<span class="line-added">455         } else</span>
<span class="line-added">456             @fulfillWithoutPromise(result, onFulfilled, onRejected);</span>
<span class="line-added">457     }</span>
<span class="line-added">458     @putPromiseInternalField(thenable, @promiseFieldFlags, @getPromiseInternalField(thenable, @promiseFieldFlags) | @promiseFlagsIsHandled);</span>
<span class="line-added">459 }</span>
<span class="line-added">460 </span>
<span class="line-added">461 @globalPrivate</span>
<span class="line-added">462 function promiseResolveThenableJob(thenable, then, resolvingFunctions)</span>
<span class="line-added">463 {</span>
<span class="line-added">464     &quot;use strict&quot;;</span>
465 

466     try {
<span class="line-modified">467         return then.@call(thenable, resolvingFunctions.@resolve, resolvingFunctions.@reject);</span>
468     } catch (error) {
469         return resolvingFunctions.@reject.@call(@undefined, error);
470     }


471 }
</pre>
</td>
</tr>
</table>
<center><a href="PromiseConstructor.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PromisePrototype.js.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
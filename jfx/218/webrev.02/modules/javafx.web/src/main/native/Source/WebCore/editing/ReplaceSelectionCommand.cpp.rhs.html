<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2009, 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;ReplaceSelectionCommand.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ApplyStyleCommand.h&quot;
  32 #include &quot;BeforeTextInsertedEvent.h&quot;
  33 #include &quot;BreakBlockquoteCommand.h&quot;
  34 #include &quot;CSSComputedStyleDeclaration.h&quot;
  35 #include &quot;CSSStyleDeclaration.h&quot;
  36 #include &quot;DOMWrapperWorld.h&quot;
  37 #include &quot;DataTransfer.h&quot;
  38 #include &quot;Document.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Editing.h&quot;
  41 #include &quot;EditingBehavior.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;EventNames.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameSelection.h&quot;
  46 #include &quot;HTMLBRElement.h&quot;
  47 #include &quot;HTMLBaseElement.h&quot;
  48 #include &quot;HTMLBodyElement.h&quot;
  49 #include &quot;HTMLInputElement.h&quot;
  50 #include &quot;HTMLLIElement.h&quot;
  51 #include &quot;HTMLLinkElement.h&quot;
  52 #include &quot;HTMLMetaElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;HTMLTitleElement.h&quot;
  56 #include &quot;NodeList.h&quot;
  57 #include &quot;NodeRenderStyle.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  58 #include &quot;Position.h&quot;</span>
  59 #include &quot;RenderInline.h&quot;
  60 #include &quot;RenderText.h&quot;
  61 #include &quot;ScriptElement.h&quot;
  62 #include &quot;SimplifyMarkupCommand.h&quot;
  63 #include &quot;SmartReplace.h&quot;
  64 #include &quot;StyleProperties.h&quot;
  65 #include &quot;Text.h&quot;
  66 #include &quot;TextIterator.h&quot;
  67 #include &quot;VisibleUnits.h&quot;
  68 #include &quot;markup.h&quot;
  69 #include &lt;wtf/NeverDestroyed.h&gt;
  70 #include &lt;wtf/StdLibExtras.h&gt;
  71 
  72 namespace WebCore {
  73 
  74 using namespace HTMLNames;
  75 
  76 enum EFragmentType { EmptyFragment, SingleTextNodeFragment, TreeFragment };
  77 
  78 // --- ReplacementFragment helper class
  79 
  80 class ReplacementFragment {
  81     WTF_MAKE_FAST_ALLOCATED;
  82     WTF_MAKE_NONCOPYABLE(ReplacementFragment);
  83 public:
  84     ReplacementFragment(DocumentFragment*, const VisibleSelection&amp;);
  85 
  86     DocumentFragment* fragment() { return m_fragment.get(); }
  87 
  88     Node* firstChild() const;
  89     Node* lastChild() const;
  90 
  91     bool isEmpty() const;
  92 
  93     bool hasInterchangeNewlineAtStart() const { return m_hasInterchangeNewlineAtStart; }
  94     bool hasInterchangeNewlineAtEnd() const { return m_hasInterchangeNewlineAtEnd; }
  95 
  96     void removeNode(Node&amp;);
  97     void removeNodePreservingChildren(Node&amp;);
  98 
  99 private:
 100     void removeContentsWithSideEffects();
 101     Ref&lt;HTMLElement&gt; insertFragmentForTestRendering(Node* rootEditableNode);
 102     void removeUnrenderedNodes(Node*);
 103     void restoreAndRemoveTestRenderingNodesToFragment(StyledElement*);
 104     void removeInterchangeNodes(Node*);
 105 
 106     void insertNodeBefore(Node&amp;, Node&amp; refNode);
 107 
 108     RefPtr&lt;DocumentFragment&gt; m_fragment;
 109     bool m_hasInterchangeNewlineAtStart;
 110     bool m_hasInterchangeNewlineAtEnd;
 111 };
 112 
 113 static bool isInterchangeNewlineNode(const Node* node)
 114 {
 115     static NeverDestroyed&lt;String&gt; interchangeNewlineClassString(AppleInterchangeNewline);
 116     return is&lt;HTMLBRElement&gt;(node) &amp;&amp; downcast&lt;HTMLBRElement&gt;(*node).attributeWithoutSynchronization(classAttr) == interchangeNewlineClassString;
 117 }
 118 
 119 static bool isInterchangeConvertedSpaceSpan(const Node* node)
 120 {
 121     static NeverDestroyed&lt;String&gt; convertedSpaceSpanClassString(AppleConvertedSpace);
 122     return is&lt;HTMLElement&gt;(node) &amp;&amp; downcast&lt;HTMLElement&gt;(*node).attributeWithoutSynchronization(classAttr) == convertedSpaceSpanClassString;
 123 }
 124 
 125 static Position positionAvoidingPrecedingNodes(Position position)
 126 {
 127     ASSERT(position.isNotNull());
 128 
 129     // If we&#39;re already on a break, it&#39;s probably a placeholder and we shouldn&#39;t change our position.
 130     if (editingIgnoresContent(*position.deprecatedNode()))
 131         return position;
 132 
 133     // We also stop when changing block flow elements because even though the visual position is the
 134     // same.  E.g.,
 135     //   &lt;div&gt;foo^&lt;/div&gt;^
 136     // The two positions above are the same visual position, but we want to stay in the same block.
 137     auto* enclosingBlockNode = enclosingBlock(position.containerNode());
 138     for (Position nextPosition = position; nextPosition.containerNode() != enclosingBlockNode; position = nextPosition) {
 139         if (lineBreakExistsAtPosition(position))
 140             break;
 141 
 142         if (position.containerNode()-&gt;nonShadowBoundaryParentNode())
 143             nextPosition = positionInParentAfterNode(position.containerNode());
 144 
 145         if (nextPosition == position)
 146             break;
 147         if (enclosingBlock(nextPosition.containerNode()) != enclosingBlockNode)
 148             break;
 149         if (VisiblePosition(position) != VisiblePosition(nextPosition))
 150             break;
 151     }
 152     return position;
 153 }
 154 
 155 ReplacementFragment::ReplacementFragment(DocumentFragment* fragment, const VisibleSelection&amp; selection)
 156     : m_fragment(fragment)
 157     , m_hasInterchangeNewlineAtStart(false)
 158     , m_hasInterchangeNewlineAtEnd(false)
 159 {
 160     if (!m_fragment)
 161         return;
 162     if (!m_fragment-&gt;firstChild())
 163         return;
 164 
 165     removeContentsWithSideEffects();
 166 
 167     RefPtr&lt;Element&gt; editableRoot = selection.rootEditableElement();
 168     ASSERT(editableRoot);
 169     if (!editableRoot)
 170         return;
 171 
 172     auto* shadowHost = editableRoot-&gt;shadowHost();
 173     if (!editableRoot-&gt;attributeEventListener(eventNames().webkitBeforeTextInsertedEvent, mainThreadNormalWorld())
 174         &amp;&amp; !(shadowHost &amp;&amp; shadowHost-&gt;renderer() &amp;&amp; shadowHost-&gt;renderer()-&gt;isTextControl())
 175         &amp;&amp; editableRoot-&gt;hasRichlyEditableStyle()) {
 176         removeInterchangeNodes(m_fragment.get());
 177         return;
 178     }
 179 
 180     auto page = createPageForSanitizingWebContent();
 181     Document* stagingDocument = page-&gt;mainFrame().document();
 182     ASSERT(stagingDocument-&gt;body());
 183 
 184     ComputedStyleExtractor computedStyleOfEditableRoot(editableRoot.get());
 185     stagingDocument-&gt;body()-&gt;setAttributeWithoutSynchronization(styleAttr, computedStyleOfEditableRoot.copyProperties()-&gt;asText());
 186 
 187     RefPtr&lt;StyledElement&gt; holder = insertFragmentForTestRendering(stagingDocument-&gt;body());
 188     if (!holder) {
 189         removeInterchangeNodes(m_fragment.get());
 190         return;
 191     }
 192 
 193     RefPtr&lt;Range&gt; range = VisibleSelection::selectionFromContentsOfNode(holder.get()).toNormalizedRange();
 194     String text = plainText(range.get(), static_cast&lt;TextIteratorBehavior&gt;(TextIteratorEmitsOriginalText | TextIteratorIgnoresStyleVisibility));
 195 
 196     removeInterchangeNodes(holder.get());
 197     removeUnrenderedNodes(holder.get());
 198     restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 199 
 200     // Give the root a chance to change the text.
 201     auto event = BeforeTextInsertedEvent::create(text);
 202     editableRoot-&gt;dispatchEvent(event);
 203     if (text != event-&gt;text() || !editableRoot-&gt;hasRichlyEditableStyle()) {
 204         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 205 
 206         RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
 207         if (!range)
 208             return;
 209 
 210         m_fragment = createFragmentFromText(*range, event-&gt;text());
 211         if (!m_fragment-&gt;firstChild())
 212             return;
 213 
 214         holder = insertFragmentForTestRendering(stagingDocument-&gt;body());
 215         removeInterchangeNodes(holder.get());
 216         removeUnrenderedNodes(holder.get());
 217         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 218     }
 219 }
 220 
 221 void ReplacementFragment::removeContentsWithSideEffects()
 222 {
 223     Vector&lt;Ref&lt;Element&gt;&gt; elementsToRemove;
 224     Vector&lt;std::pair&lt;Ref&lt;Element&gt;, QualifiedName&gt;&gt; attributesToRemove;
 225 
 226     auto it = descendantsOfType&lt;Element&gt;(*m_fragment).begin();
 227     auto end = descendantsOfType&lt;Element&gt;(*m_fragment).end();
 228     while (it != end) {
 229         auto element = makeRef(*it);
 230         if (isScriptElement(element) || (is&lt;HTMLStyleElement&gt;(element) &amp;&amp; element-&gt;getAttribute(classAttr) != WebKitMSOListQuirksStyle)
 231             || is&lt;HTMLBaseElement&gt;(element) || is&lt;HTMLLinkElement&gt;(element) || is&lt;HTMLMetaElement&gt;(element) || is&lt;HTMLTitleElement&gt;(element)) {
 232             elementsToRemove.append(WTFMove(element));
 233             it.traverseNextSkippingChildren();
 234             continue;
 235         }
 236         if (element-&gt;hasAttributes()) {
 237             for (auto&amp; attribute : element-&gt;attributesIterator()) {
 238                 if (element-&gt;isEventHandlerAttribute(attribute) || element-&gt;isJavaScriptURLAttribute(attribute))
 239                     attributesToRemove.append({ element.copyRef(), attribute.name() });
 240             }
 241         }
 242         ++it;
 243     }
 244 
 245     for (auto&amp; element : elementsToRemove)
 246         removeNode(WTFMove(element));
 247 
 248     for (auto&amp; item : attributesToRemove)
 249         item.first-&gt;removeAttribute(item.second);
 250 }
 251 
 252 bool ReplacementFragment::isEmpty() const
 253 {
 254     return (!m_fragment || !m_fragment-&gt;firstChild()) &amp;&amp; !m_hasInterchangeNewlineAtStart &amp;&amp; !m_hasInterchangeNewlineAtEnd;
 255 }
 256 
 257 Node *ReplacementFragment::firstChild() const
 258 {
 259     return m_fragment ? m_fragment-&gt;firstChild() : 0;
 260 }
 261 
 262 Node *ReplacementFragment::lastChild() const
 263 {
 264     return m_fragment ? m_fragment-&gt;lastChild() : 0;
 265 }
 266 
 267 void ReplacementFragment::removeNodePreservingChildren(Node&amp; node)
 268 {
 269     Ref&lt;Node&gt; protectedNode = node;
 270     while (RefPtr&lt;Node&gt; n = node.firstChild()) {
 271         removeNode(*n);
 272         insertNodeBefore(*n, node);
 273     }
 274     removeNode(node);
 275 }
 276 
 277 void ReplacementFragment::removeNode(Node&amp; node)
 278 {
 279     ContainerNode* parent = node.nonShadowBoundaryParentNode();
 280     if (!parent)
 281         return;
 282 
 283     parent-&gt;removeChild(node);
 284 }
 285 
 286 void ReplacementFragment::insertNodeBefore(Node&amp; node, Node&amp; refNode)
 287 {
 288     ContainerNode* parent = refNode.nonShadowBoundaryParentNode();
 289     if (!parent)
 290         return;
 291 
 292     parent-&gt;insertBefore(node, &amp;refNode);
 293 }
 294 
 295 Ref&lt;HTMLElement&gt; ReplacementFragment::insertFragmentForTestRendering(Node* rootNode)
 296 {
 297     auto document = makeRef(rootNode-&gt;document());
 298     auto holder = createDefaultParagraphElement(document.get());
 299 
 300     holder-&gt;appendChild(*m_fragment);
 301     rootNode-&gt;appendChild(holder);
 302     document-&gt;updateLayoutIgnorePendingStylesheets();
 303 
 304     return holder;
 305 }
 306 
 307 void ReplacementFragment::restoreAndRemoveTestRenderingNodesToFragment(StyledElement* holder)
 308 {
 309     if (!holder)
 310         return;
 311 
 312     while (RefPtr&lt;Node&gt; node = holder-&gt;firstChild()) {
 313         holder-&gt;removeChild(*node);
 314         m_fragment-&gt;appendChild(*node);
 315     }
 316 
 317     removeNode(*holder);
 318 }
 319 
 320 void ReplacementFragment::removeUnrenderedNodes(Node* holder)
 321 {
 322     Vector&lt;Ref&lt;Node&gt;&gt; unrendered;
 323 
 324     for (Node* node = holder-&gt;firstChild(); node; node = NodeTraversal::next(*node, holder)) {
 325         if (!isNodeRendered(*node) &amp;&amp; !isTableStructureNode(node))
 326             unrendered.append(*node);
 327     }
 328 
 329     for (auto&amp; node : unrendered)
 330         removeNode(node);
 331 }
 332 
 333 void ReplacementFragment::removeInterchangeNodes(Node* container)
 334 {
 335     m_hasInterchangeNewlineAtStart = false;
 336     m_hasInterchangeNewlineAtEnd = false;
 337 
 338     // Interchange newlines at the &quot;start&quot; of the incoming fragment must be
 339     // either the first node in the fragment or the first leaf in the fragment.
 340     Node* node = container-&gt;firstChild();
 341     while (node) {
 342         if (isInterchangeNewlineNode(node)) {
 343             m_hasInterchangeNewlineAtStart = true;
 344             removeNode(*node);
 345             break;
 346         }
 347         node = node-&gt;firstChild();
 348     }
 349     if (!container-&gt;hasChildNodes())
 350         return;
 351     // Interchange newlines at the &quot;end&quot; of the incoming fragment must be
 352     // either the last node in the fragment or the last leaf in the fragment.
 353     node = container-&gt;lastChild();
 354     while (node) {
 355         if (isInterchangeNewlineNode(node)) {
 356             m_hasInterchangeNewlineAtEnd = true;
 357             removeNode(*node);
 358             break;
 359         }
 360         node = node-&gt;lastChild();
 361     }
 362 
 363     node = container-&gt;firstChild();
 364     while (node) {
 365         RefPtr&lt;Node&gt; next = NodeTraversal::next(*node);
 366         if (isInterchangeConvertedSpaceSpan(node)) {
 367             next = NodeTraversal::nextSkippingChildren(*node);
 368             removeNodePreservingChildren(*node);
 369         }
 370         node = next.get();
 371     }
 372 }
 373 
 374 inline void ReplaceSelectionCommand::InsertedNodes::respondToNodeInsertion(Node* node)
 375 {
 376     if (!node)
 377         return;
 378 
 379     if (!m_firstNodeInserted)
 380         m_firstNodeInserted = node;
 381 
 382     m_lastNodeInserted = node;
 383 }
 384 
 385 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNodePreservingChildren(Node* node)
 386 {
 387     if (m_firstNodeInserted == node)
 388         m_firstNodeInserted = NodeTraversal::next(*node);
 389     if (m_lastNodeInserted == node) {
 390         m_lastNodeInserted = node-&gt;lastChild() ? node-&gt;lastChild() : NodeTraversal::nextSkippingChildren(*node);
<a name="2" id="anc2"></a><span class="line-modified"> 391         if (!m_lastNodeInserted &amp;&amp; m_firstNodeInserted) {</span>
 392             // If the last inserted node is at the end of the document and doesn&#39;t have any children, look backwards for the
 393             // previous node as the last inserted node, clamping to the first inserted node if needed to ensure that the
 394             // document position of the last inserted node is not behind the first inserted node.
 395             auto* previousNode = NodeTraversal::previousSkippingChildren(*node);
 396             ASSERT(previousNode);
 397             m_lastNodeInserted = m_firstNodeInserted-&gt;compareDocumentPosition(*previousNode) &amp; Node::DOCUMENT_POSITION_FOLLOWING ? previousNode : m_firstNodeInserted;
 398         }
 399     }
 400 }
 401 
 402 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNode(Node* node)
 403 {
 404     if (m_firstNodeInserted == node &amp;&amp; m_lastNodeInserted == node) {
 405         m_firstNodeInserted = nullptr;
 406         m_lastNodeInserted = nullptr;
 407     } else if (m_firstNodeInserted == node)
 408         m_firstNodeInserted = NodeTraversal::nextSkippingChildren(*m_firstNodeInserted);
 409     else if (m_lastNodeInserted == node)
 410         m_lastNodeInserted = NodeTraversal::previousSkippingChildren(*m_lastNodeInserted);
 411 }
 412 
 413 inline void ReplaceSelectionCommand::InsertedNodes::didReplaceNode(Node* node, Node* newNode)
 414 {
 415     if (m_firstNodeInserted == node)
 416         m_firstNodeInserted = newNode;
 417     if (m_lastNodeInserted == node)
 418         m_lastNodeInserted = newNode;
 419 }
 420 
 421 ReplaceSelectionCommand::ReplaceSelectionCommand(Document&amp; document, RefPtr&lt;DocumentFragment&gt;&amp;&amp; fragment, OptionSet&lt;CommandOption&gt; options, EditAction editAction)
 422     : CompositeEditCommand(document, editAction)
 423     , m_selectReplacement(options &amp; SelectReplacement)
 424     , m_smartReplace(options &amp; SmartReplace)
 425     , m_matchStyle(options &amp; MatchStyle)
 426     , m_documentFragment(fragment)
 427     , m_preventNesting(options &amp; PreventNesting)
 428     , m_movingParagraph(options &amp; MovingParagraph)
 429     , m_sanitizeFragment(options &amp; SanitizeFragment)
 430     , m_shouldMergeEnd(false)
 431     , m_ignoreMailBlockquote(options &amp; IgnoreMailBlockquote)
 432 {
 433 }
 434 
 435 static bool hasMatchingQuoteLevel(VisiblePosition endOfExistingContent, VisiblePosition endOfInsertedContent)
 436 {
 437     Position existing = endOfExistingContent.deepEquivalent();
 438     Position inserted = endOfInsertedContent.deepEquivalent();
 439     bool isInsideMailBlockquote = enclosingNodeOfType(inserted, isMailBlockquote, CanCrossEditingBoundary);
 440     return isInsideMailBlockquote &amp;&amp; (numEnclosingMailBlockquotes(existing) == numEnclosingMailBlockquotes(inserted));
 441 }
 442 
 443 bool ReplaceSelectionCommand::shouldMergeStart(bool selectionStartWasStartOfParagraph, bool fragmentHasInterchangeNewlineAtStart, bool selectionStartWasInsideMailBlockquote)
 444 {
 445     if (m_movingParagraph)
 446         return false;
 447 
 448     VisiblePosition startOfInsertedContent(positionAtStartOfInsertedContent());
 449     VisiblePosition prev = startOfInsertedContent.previous(CannotCrossEditingBoundary);
 450     if (prev.isNull())
 451         return false;
 452 
 453     // When we have matching quote levels, its ok to merge more frequently.
 454     // For a successful merge, we still need to make sure that the inserted content starts with the beginning of a paragraph.
 455     // And we should only merge here if the selection start was inside a mail blockquote.  This prevents against removing a
 456     // blockquote from newly pasted quoted content that was pasted into an unquoted position.  If that unquoted position happens
 457     // to be right after another blockquote, we don&#39;t want to merge and risk stripping a valid block (and newline) from the pasted content.
 458     if (isStartOfParagraph(startOfInsertedContent) &amp;&amp; selectionStartWasInsideMailBlockquote &amp;&amp; hasMatchingQuoteLevel(prev, positionAtEndOfInsertedContent()))
 459         return true;
 460 
 461     return !selectionStartWasStartOfParagraph
 462         &amp;&amp; !fragmentHasInterchangeNewlineAtStart
 463         &amp;&amp; isStartOfParagraph(startOfInsertedContent)
 464         &amp;&amp; !startOfInsertedContent.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag)
 465         &amp;&amp; shouldMerge(startOfInsertedContent, prev);
 466 }
 467 
 468 bool ReplaceSelectionCommand::shouldMergeEnd(bool selectionEndWasEndOfParagraph)
 469 {
 470     VisiblePosition endOfInsertedContent(positionAtEndOfInsertedContent());
 471     VisiblePosition next = endOfInsertedContent.next(CannotCrossEditingBoundary);
 472     if (next.isNull())
 473         return false;
 474 
 475     return !selectionEndWasEndOfParagraph
 476         &amp;&amp; isEndOfParagraph(endOfInsertedContent)
 477         &amp;&amp; !endOfInsertedContent.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag)
 478         &amp;&amp; shouldMerge(endOfInsertedContent, next);
 479 }
 480 
 481 static bool isMailPasteAsQuotationNode(const Node* node)
 482 {
 483     return node &amp;&amp; node-&gt;hasTagName(blockquoteTag) &amp;&amp; downcast&lt;Element&gt;(node)-&gt;attributeWithoutSynchronization(classAttr) == ApplePasteAsQuotation;
 484 }
 485 
 486 static bool isHeaderElement(const Node* a)
 487 {
 488     if (!a)
 489         return false;
 490 
 491     return a-&gt;hasTagName(h1Tag)
 492         || a-&gt;hasTagName(h2Tag)
 493         || a-&gt;hasTagName(h3Tag)
 494         || a-&gt;hasTagName(h4Tag)
 495         || a-&gt;hasTagName(h5Tag)
 496         || a-&gt;hasTagName(h6Tag);
 497 }
 498 
 499 static bool haveSameTagName(Node* a, Node* b)
 500 {
 501     return is&lt;Element&gt;(a) &amp;&amp; is&lt;Element&gt;(b) &amp;&amp; downcast&lt;Element&gt;(*a).tagName() == downcast&lt;Element&gt;(*b).tagName();
 502 }
 503 
 504 bool ReplaceSelectionCommand::shouldMerge(const VisiblePosition&amp; source, const VisiblePosition&amp; destination)
 505 {
 506     if (source.isNull() || destination.isNull())
 507         return false;
 508 
 509     auto* sourceNode = source.deepEquivalent().deprecatedNode();
 510     auto* destinationNode = destination.deepEquivalent().deprecatedNode();
 511     auto* sourceBlock = enclosingBlock(sourceNode);
 512     auto* destinationBlock = enclosingBlock(destinationNode);
 513     return !enclosingNodeOfType(source.deepEquivalent(), &amp;isMailPasteAsQuotationNode)
 514         &amp;&amp; sourceBlock
 515         &amp;&amp; (!sourceBlock-&gt;hasTagName(blockquoteTag) || isMailBlockquote(sourceBlock))
 516         &amp;&amp; enclosingListChild(sourceBlock) == enclosingListChild(destinationNode)
 517         &amp;&amp; enclosingTableCell(source.deepEquivalent()) == enclosingTableCell(destination.deepEquivalent())
 518         &amp;&amp; (!isHeaderElement(sourceBlock) || haveSameTagName(sourceBlock, destinationBlock))
 519         // Don&#39;t merge to or from a position before or after a block because it would
 520         // be a no-op and cause infinite recursion.
 521         &amp;&amp; !isBlock(sourceNode) &amp;&amp; !isBlock(destinationNode);
 522 }
 523 
<a name="3" id="anc3"></a><span class="line-added"> 524 static bool fragmentNeedsColorTransformed(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)</span>
<span class="line-added"> 525 {</span>
<span class="line-added"> 526     // Dark mode content that is inserted should have the inline styles inverse color</span>
<span class="line-added"> 527     // transformed by the color filter to match the color filtered document contents.</span>
<span class="line-added"> 528     // This applies to Mail and Notes when pasting from Xcode. &lt;rdar://problem/40529867&gt;</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530     RefPtr&lt;Element&gt; editableRoot = insertionPos.rootEditableElement();</span>
<span class="line-added"> 531     ASSERT(editableRoot);</span>
<span class="line-added"> 532     if (!editableRoot)</span>
<span class="line-added"> 533         return false;</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535     auto* editableRootRenderer = editableRoot-&gt;renderer();</span>
<span class="line-added"> 536     if (!editableRootRenderer || !editableRootRenderer-&gt;style().hasAppleColorFilter())</span>
<span class="line-added"> 537         return false;</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539     const auto&amp; colorFilter = editableRootRenderer-&gt;style().appleColorFilter();</span>
<span class="line-added"> 540     for (const auto&amp; colorFilterOperation : colorFilter.operations()) {</span>
<span class="line-added"> 541         if (colorFilterOperation-&gt;type() != FilterOperation::APPLE_INVERT_LIGHTNESS)</span>
<span class="line-added"> 542             return false;</span>
<span class="line-added"> 543     }</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545     auto propertyLightness = [&amp;](const StyleProperties&amp; inlineStyle, CSSPropertyID propertyID) -&gt; Optional&lt;double&gt; {</span>
<span class="line-added"> 546         auto color = inlineStyle.propertyAsColor(propertyID);</span>
<span class="line-added"> 547         if (!color || !color.value().isVisible() || color.value().isSemantic())</span>
<span class="line-added"> 548             return { };</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550         double hue, saturation, lightness;</span>
<span class="line-added"> 551         color.value().getHSL(hue, saturation, lightness);</span>
<span class="line-added"> 552         return lightness;</span>
<span class="line-added"> 553     };</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555     const double lightnessDarkEnoughForText = 0.4;</span>
<span class="line-added"> 556     const double lightnessLightEnoughForBackground = 0.6;</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558     for (RefPtr&lt;Node&gt; node = fragment.firstChild(); node; node = NodeTraversal::next(*node)) {</span>
<span class="line-added"> 559         if (!is&lt;StyledElement&gt;(*node))</span>
<span class="line-added"> 560             continue;</span>
<span class="line-added"> 561 </span>
<span class="line-added"> 562         auto&amp; element = downcast&lt;StyledElement&gt;(*node);</span>
<span class="line-added"> 563         auto* inlineStyle = element.inlineStyle();</span>
<span class="line-added"> 564         if (!inlineStyle)</span>
<span class="line-added"> 565             continue;</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567         auto textLightness = propertyLightness(*inlineStyle, CSSPropertyColor);</span>
<span class="line-added"> 568         if (textLightness &amp;&amp; *textLightness &lt; lightnessDarkEnoughForText)</span>
<span class="line-added"> 569             return false;</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571         auto backgroundLightness = propertyLightness(*inlineStyle, CSSPropertyBackgroundColor);</span>
<span class="line-added"> 572         if (backgroundLightness &amp;&amp; *backgroundLightness &gt; lightnessLightEnoughForBackground)</span>
<span class="line-added"> 573             return false;</span>
<span class="line-added"> 574     }</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576     return true;</span>
<span class="line-added"> 577 }</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579 void ReplaceSelectionCommand::inverseTransformColor(InsertedNodes&amp; insertedNodes)</span>
<span class="line-added"> 580 {</span>
<span class="line-added"> 581     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();</span>
<span class="line-added"> 582     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = NodeTraversal::next(*node)) {</span>
<span class="line-added"> 583         if (!is&lt;StyledElement&gt;(*node))</span>
<span class="line-added"> 584             continue;</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586         auto&amp; element = downcast&lt;StyledElement&gt;(*node);</span>
<span class="line-added"> 587         auto* inlineStyle = element.inlineStyle();</span>
<span class="line-added"> 588         if (!inlineStyle)</span>
<span class="line-added"> 589             continue;</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591         auto editingStyle = EditingStyle::create(inlineStyle);</span>
<span class="line-added"> 592         auto transformedStyle = editingStyle-&gt;inverseTransformColorIfNeeded(element);</span>
<span class="line-added"> 593         if (editingStyle.ptr() == transformedStyle.ptr())</span>
<span class="line-added"> 594             continue;</span>
<span class="line-added"> 595 </span>
<span class="line-added"> 596         setNodeAttribute(element, styleAttr, transformedStyle-&gt;style()-&gt;asText());</span>
<span class="line-added"> 597     }</span>
<span class="line-added"> 598 }</span>
<span class="line-added"> 599 </span>
 600 // Style rules that match just inserted elements could change their appearance, like
 601 // a div inserted into a document with div { display:inline; }.
 602 void ReplaceSelectionCommand::removeRedundantStylesAndKeepStyleSpanInline(InsertedNodes&amp; insertedNodes)
 603 {
 604     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 605     RefPtr&lt;Node&gt; next;
 606     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 607         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 608 
 609         next = NodeTraversal::next(*node);
 610         if (!is&lt;StyledElement&gt;(*node))
 611             continue;
 612 
 613         StyledElement* element = downcast&lt;StyledElement&gt;(node.get());
 614 
 615         const StyleProperties* inlineStyle = element-&gt;inlineStyle();
 616         auto newInlineStyle = EditingStyle::create(inlineStyle);
 617         if (inlineStyle) {
 618             if (is&lt;HTMLElement&gt;(*element)) {
 619                 Vector&lt;QualifiedName&gt; attributes;
 620                 HTMLElement&amp; htmlElement = downcast&lt;HTMLElement&gt;(*element);
 621 
 622                 if (newInlineStyle-&gt;conflictsWithImplicitStyleOfElement(htmlElement)) {
 623                     // e.g. &lt;b style=&quot;font-weight: normal;&quot;&gt; is converted to &lt;span style=&quot;font-weight: normal;&quot;&gt;
 624                     node = replaceElementWithSpanPreservingChildrenAndAttributes(htmlElement);
 625                     element = downcast&lt;StyledElement&gt;(node.get());
 626                     insertedNodes.didReplaceNode(&amp;htmlElement, node.get());
 627                 } else if (newInlineStyle-&gt;extractConflictingImplicitStyleOfAttributes(htmlElement, EditingStyle::PreserveWritingDirection, nullptr, attributes, EditingStyle::DoNotExtractMatchingStyle)) {
 628                     // e.g. &lt;font size=&quot;3&quot; style=&quot;font-size: 20px;&quot;&gt; is converted to &lt;font style=&quot;font-size: 20px;&quot;&gt;
 629                     for (auto&amp; attribute : attributes)
 630                         removeNodeAttribute(*element, attribute);
 631                 }
 632             }
 633 
 634             ContainerNode* context = element-&gt;parentNode();
 635 
 636             // If Mail wraps the fragment with a Paste as Quotation blockquote, or if you&#39;re pasting into a quoted region,
 637             // styles from blockquoteNode are allowed to override those from the source document, see &lt;rdar://problem/4930986&gt; and &lt;rdar://problem/5089327&gt;.
 638             Node* blockquoteNode = isMailPasteAsQuotationNode(context) ? context : enclosingNodeOfType(firstPositionInNode(context), isMailBlockquote, CanCrossEditingBoundary);
 639             if (blockquoteNode)
 640                 newInlineStyle-&gt;removeStyleFromRulesAndContext(*element, document().documentElement());
 641 
 642             newInlineStyle-&gt;removeStyleFromRulesAndContext(*element, context);
 643         }
 644 
 645         if (!inlineStyle || newInlineStyle-&gt;isEmpty()) {
 646             if (isStyleSpanOrSpanWithOnlyStyleAttribute(*element) || isEmptyFontTag(element, AllowNonEmptyStyleAttribute)) {
 647                 insertedNodes.willRemoveNodePreservingChildren(element);
 648                 removeNodePreservingChildren(*element);
 649                 continue;
 650             }
 651             removeNodeAttribute(*element, styleAttr);
 652         } else if (newInlineStyle-&gt;style()-&gt;propertyCount() != inlineStyle-&gt;propertyCount())
 653             setNodeAttribute(*element, styleAttr, newInlineStyle-&gt;style()-&gt;asText());
 654 
 655         // FIXME: Tolerate differences in id, class, and style attributes.
 656         if (element-&gt;parentNode() &amp;&amp; isNonTableCellHTMLBlockElement(element) &amp;&amp; areIdenticalElements(*element, *element-&gt;parentNode())
 657             &amp;&amp; VisiblePosition(firstPositionInNode(element-&gt;parentNode())) == VisiblePosition(firstPositionInNode(element))
 658             &amp;&amp; VisiblePosition(lastPositionInNode(element-&gt;parentNode())) == VisiblePosition(lastPositionInNode(element))) {
 659             insertedNodes.willRemoveNodePreservingChildren(element);
 660             removeNodePreservingChildren(*element);
 661             continue;
 662         }
 663 
 664         if (element-&gt;parentNode() &amp;&amp; element-&gt;parentNode()-&gt;hasRichlyEditableStyle())
 665             removeNodeAttribute(*element, contenteditableAttr);
 666 
 667         // WebKit used to not add display: inline and float: none on copy.
 668         // Keep this code around for backward compatibility
 669         if (isLegacyAppleStyleSpan(element)) {
 670             if (!element-&gt;firstChild()) {
 671                 insertedNodes.willRemoveNodePreservingChildren(element);
 672                 removeNodePreservingChildren(*element);
 673                 continue;
 674             }
 675             // There are other styles that style rules can give to style spans,
 676             // but these are the two important ones because they&#39;ll prevent
 677             // inserted content from appearing in the right paragraph.
 678             // FIXME: Hyatt is concerned that selectively using display:inline will give inconsistent
 679             // results. We already know one issue because td elements ignore their display property
 680             // in quirks mode (which Mail.app is always in). We should look for an alternative.
 681 
 682             // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
 683             if (isBlock(element))
 684                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyDisplay, &quot;inline&quot;, false);
 685             if (element-&gt;renderer() &amp;&amp; element-&gt;renderer()-&gt;style().isFloating())
 686                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyFloat, &quot;none&quot;, false);
 687         }
 688     }
 689 }
 690 
 691 static bool isProhibitedParagraphChild(const AtomString&amp; name)
 692 {
 693     // https://dvcs.w3.org/hg/editing/raw-file/57abe6d3cb60/editing.html#prohibited-paragraph-child
 694     static const auto localNames = makeNeverDestroyed([] {
 695         static const HTMLQualifiedName* const tags[] = {
 696             &amp;addressTag.get(),
 697             &amp;articleTag.get(),
 698             &amp;asideTag.get(),
 699             &amp;blockquoteTag.get(),
 700             &amp;captionTag.get(),
 701             &amp;centerTag.get(),
 702             &amp;colTag.get(),
 703             &amp;colgroupTag.get(),
 704             &amp;ddTag.get(),
 705             &amp;detailsTag.get(),
 706             &amp;dirTag.get(),
 707             &amp;divTag.get(),
 708             &amp;dlTag.get(),
 709             &amp;dtTag.get(),
 710             &amp;fieldsetTag.get(),
 711             &amp;figcaptionTag.get(),
 712             &amp;figureTag.get(),
 713             &amp;footerTag.get(),
 714             &amp;formTag.get(),
 715             &amp;h1Tag.get(),
 716             &amp;h2Tag.get(),
 717             &amp;h3Tag.get(),
 718             &amp;h4Tag.get(),
 719             &amp;h5Tag.get(),
 720             &amp;h6Tag.get(),
 721             &amp;headerTag.get(),
 722             &amp;hgroupTag.get(),
 723             &amp;hrTag.get(),
 724             &amp;liTag.get(),
 725             &amp;listingTag.get(),
 726             &amp;mainTag.get(), // Missing in the specification.
 727             &amp;menuTag.get(),
 728             &amp;navTag.get(),
 729             &amp;olTag.get(),
 730             &amp;pTag.get(),
 731             &amp;plaintextTag.get(),
 732             &amp;preTag.get(),
 733             &amp;sectionTag.get(),
 734             &amp;summaryTag.get(),
 735             &amp;tableTag.get(),
 736             &amp;tbodyTag.get(),
 737             &amp;tdTag.get(),
 738             &amp;tfootTag.get(),
 739             &amp;thTag.get(),
 740             &amp;theadTag.get(),
 741             &amp;trTag.get(),
 742             &amp;ulTag.get(),
 743             &amp;xmpTag.get(),
 744         };
 745         HashSet&lt;AtomString&gt; set;
 746         for (auto&amp; tag : tags)
 747             set.add(tag-&gt;localName());
 748         return set;
 749     }());
 750     return localNames.get().contains(name);
 751 }
 752 
 753 void ReplaceSelectionCommand::makeInsertedContentRoundTrippableWithHTMLTreeBuilder(InsertedNodes&amp; insertedNodes)
 754 {
 755     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 756     RefPtr&lt;Node&gt; next;
 757     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 758         next = NodeTraversal::next(*node);
 759 
 760         if (!is&lt;HTMLElement&gt;(*node))
 761             continue;
 762 
 763         if (isProhibitedParagraphChild(downcast&lt;HTMLElement&gt;(*node).localName())) {
 764             if (auto* paragraphElement = enclosingElementWithTag(positionInParentBeforeNode(node.get()), pTag)) {
 765                 auto* parent = paragraphElement-&gt;parentNode();
 766                 if (parent &amp;&amp; parent-&gt;hasEditableStyle())
 767                     moveNodeOutOfAncestor(*node, *paragraphElement, insertedNodes);
 768             }
 769         }
 770 
 771         if (isHeaderElement(node.get())) {
 772             if (auto* headerElement = highestEnclosingNodeOfType(positionInParentBeforeNode(node.get()), isHeaderElement)) {
 773                 if (headerElement-&gt;parentNode() &amp;&amp; headerElement-&gt;parentNode()-&gt;isContentRichlyEditable())
 774                     moveNodeOutOfAncestor(*node, *headerElement, insertedNodes);
 775                 else {
 776                     HTMLElement* newSpanElement = replaceElementWithSpanPreservingChildrenAndAttributes(downcast&lt;HTMLElement&gt;(*node));
 777                     insertedNodes.didReplaceNode(node.get(), newSpanElement);
 778                 }
 779             }
 780         }
 781     }
 782 }
 783 
 784 static inline bool hasRenderedText(const Text&amp; text)
 785 {
 786     return text.renderer() &amp;&amp; text.renderer()-&gt;hasRenderedText();
 787 }
 788 
 789 void ReplaceSelectionCommand::moveNodeOutOfAncestor(Node&amp; node, Node&amp; ancestor, InsertedNodes&amp; insertedNodes)
 790 {
 791     Ref&lt;Node&gt; protectedNode = node;
 792     Ref&lt;Node&gt; protectedAncestor = ancestor;
 793 
 794     VisiblePosition positionAtEndOfNode = lastPositionInOrAfterNode(&amp;node);
 795     VisiblePosition lastPositionInParagraph = lastPositionInNode(&amp;ancestor);
 796     if (positionAtEndOfNode == lastPositionInParagraph) {
 797         removeNode(node);
 798         if (ancestor.nextSibling())
 799             insertNodeBefore(WTFMove(protectedNode), *ancestor.nextSibling());
 800         else
 801             appendNode(WTFMove(protectedNode), *ancestor.parentNode());
 802     } else {
 803         RefPtr&lt;Node&gt; nodeToSplitTo = splitTreeToNode(node, ancestor, true);
 804         removeNode(node);
 805         insertNodeBefore(WTFMove(protectedNode), *nodeToSplitTo);
 806     }
 807 
 808     document().updateLayoutIgnorePendingStylesheets();
 809 
 810     bool safeToRemoveAncestor = true;
 811     for (auto* child = ancestor.firstChild(); child; child = child-&gt;nextSibling()) {
 812         if (is&lt;Text&gt;(child) &amp;&amp; hasRenderedText(downcast&lt;Text&gt;(*child))) {
 813             safeToRemoveAncestor = false;
 814             break;
 815         }
 816 
 817         if (is&lt;Element&gt;(child)) {
 818             safeToRemoveAncestor = false;
 819             break;
 820         }
 821     }
 822 
 823     if (safeToRemoveAncestor) {
 824         insertedNodes.willRemoveNode(&amp;ancestor);
 825         removeNode(ancestor);
 826     }
 827 }
 828 
 829 void ReplaceSelectionCommand::removeUnrenderedTextNodesAtEnds(InsertedNodes&amp; insertedNodes)
 830 {
 831     document().updateLayoutIgnorePendingStylesheets();
 832 
 833     Node* lastLeafInserted = insertedNodes.lastLeafInserted();
 834     if (is&lt;Text&gt;(lastLeafInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*lastLeafInserted))
 835         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), selectTag)
 836         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), scriptTag)) {
 837         insertedNodes.willRemoveNode(lastLeafInserted);
 838         removeNode(*lastLeafInserted);
 839     }
 840 
 841     // We don&#39;t have to make sure that firstNodeInserted isn&#39;t inside a select or script element
 842     // because it is a top level node in the fragment and the user can&#39;t insert into those elements.
 843     Node* firstNodeInserted = insertedNodes.firstNodeInserted();
 844     if (is&lt;Text&gt;(firstNodeInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*firstNodeInserted))) {
 845         insertedNodes.willRemoveNode(firstNodeInserted);
 846         removeNode(*firstNodeInserted);
 847     }
 848 }
 849 
 850 VisiblePosition ReplaceSelectionCommand::positionAtEndOfInsertedContent() const
 851 {
 852     // FIXME: Why is this hack here?  What&#39;s special about &lt;select&gt; tags?
 853     auto* enclosingSelect = enclosingElementWithTag(m_endOfInsertedContent, selectTag);
 854     return enclosingSelect ? lastPositionInOrAfterNode(enclosingSelect) : m_endOfInsertedContent;
 855 }
 856 
 857 VisiblePosition ReplaceSelectionCommand::positionAtStartOfInsertedContent() const
 858 {
 859     return m_startOfInsertedContent;
 860 }
 861 
 862 // Remove style spans before insertion if they are unnecessary.  It&#39;s faster because we&#39;ll
 863 // avoid doing a layout.
 864 static bool handleStyleSpansBeforeInsertion(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)
 865 {
 866     Node* topNode = fragment.firstChild();
 867 
 868     // Handling the case where we are doing Paste as Quotation or pasting into quoted content is more complicated (see handleStyleSpans)
 869     // and doesn&#39;t receive the optimization.
 870     if (isMailPasteAsQuotationNode(topNode) || enclosingNodeOfType(firstPositionInOrBeforeNode(topNode), isMailBlockquote, CanCrossEditingBoundary))
 871         return false;
 872 
 873     // Either there are no style spans in the fragment or a WebKit client has added content to the fragment
 874     // before inserting it.  Look for and handle style spans after insertion.
 875     if (!isLegacyAppleStyleSpan(topNode))
 876         return false;
 877 
 878     Node* wrappingStyleSpan = topNode;
 879     auto styleAtInsertionPos = EditingStyle::create(insertionPos.parentAnchoredEquivalent());
 880     String styleText = styleAtInsertionPos-&gt;style()-&gt;asText();
 881 
 882     // FIXME: This string comparison is a naive way of comparing two styles.
 883     // We should be taking the diff and check that the diff is empty.
 884     if (styleText != downcast&lt;Element&gt;(*wrappingStyleSpan).getAttribute(styleAttr))
 885         return false;
 886 
 887     fragment.removeNodePreservingChildren(*wrappingStyleSpan);
 888     return true;
 889 }
 890 
 891 // At copy time, WebKit wraps copied content in a span that contains the source document&#39;s
 892 // default styles.  If the copied Range inherits any other styles from its ancestors, we put
 893 // those styles on a second span.
 894 // This function removes redundant styles from those spans, and removes the spans if all their
 895 // styles are redundant.
 896 // We should remove the Apple-style-span class when we&#39;re done, see &lt;rdar://problem/5685600&gt;.
 897 // We should remove styles from spans that are overridden by all of their children, either here
 898 // or at copy time.
 899 void ReplaceSelectionCommand::handleStyleSpans(InsertedNodes&amp; insertedNodes)
 900 {
 901     HTMLElement* wrappingStyleSpan = nullptr;
 902     // The style span that contains the source document&#39;s default style should be at
 903     // the top of the fragment, but Mail sometimes adds a wrapper (for Paste As Quotation),
 904     // so search for the top level style span instead of assuming it&#39;s at the top.
 905     for (Node* node = insertedNodes.firstNodeInserted(); node; node = NodeTraversal::next(*node)) {
 906         if (isLegacyAppleStyleSpan(node)) {
 907             wrappingStyleSpan = downcast&lt;HTMLElement&gt;(node);
 908             break;
 909         }
 910     }
 911 
 912     // There might not be any style spans if we&#39;re pasting from another application or if
 913     // we are here because of a document.execCommand(&quot;InsertHTML&quot;, ...) call.
 914     if (!wrappingStyleSpan)
 915         return;
 916 
 917     auto style = EditingStyle::create(wrappingStyleSpan-&gt;inlineStyle());
 918     ContainerNode* context = wrappingStyleSpan-&gt;parentNode();
 919 
 920     // If Mail wraps the fragment with a Paste as Quotation blockquote, or if you&#39;re pasting into a quoted region,
 921     // styles from blockquoteNode are allowed to override those from the source document, see &lt;rdar://problem/4930986&gt; and &lt;rdar://problem/5089327&gt;.
 922     Node* blockquoteNode = isMailPasteAsQuotationNode(context) ? context : enclosingNodeOfType(firstPositionInNode(context), isMailBlockquote, CanCrossEditingBoundary);
 923     if (blockquoteNode)
 924         context = document().documentElement();
 925 
 926     // This operation requires that only editing styles to be removed from sourceDocumentStyle.
 927     style-&gt;prepareToApplyAt(firstPositionInNode(context));
 928 
 929     // Remove block properties in the span&#39;s style. This prevents properties that probably have no effect
 930     // currently from affecting blocks later if the style is cloned for a new block element during a future
 931     // editing operation.
 932     // FIXME: They *can* have an effect currently if blocks beneath the style span aren&#39;t individually marked
 933     // with block styles by the editing engine used to style them.  WebKit doesn&#39;t do this, but others might.
 934     style-&gt;removeBlockProperties();
 935 
 936     if (style-&gt;isEmpty() || !wrappingStyleSpan-&gt;firstChild()) {
 937         insertedNodes.willRemoveNodePreservingChildren(wrappingStyleSpan);
 938         removeNodePreservingChildren(*wrappingStyleSpan);
 939     } else
 940         setNodeAttribute(*wrappingStyleSpan, styleAttr, style-&gt;style()-&gt;asText());
 941 }
 942 
 943 void ReplaceSelectionCommand::mergeEndIfNeeded()
 944 {
 945     if (!m_shouldMergeEnd)
 946         return;
 947 
 948     VisiblePosition startOfInsertedContent(positionAtStartOfInsertedContent());
 949     VisiblePosition endOfInsertedContent(positionAtEndOfInsertedContent());
 950 
 951     // Bail to avoid infinite recursion.
 952     if (m_movingParagraph) {
 953         ASSERT_NOT_REACHED();
 954         return;
 955     }
 956 
 957     // Merging two paragraphs will destroy the moved one&#39;s block styles.  Always move the end of inserted forward
 958     // to preserve the block style of the paragraph already in the document, unless the paragraph to move would
 959     // include the what was the start of the selection that was pasted into, so that we preserve that paragraph&#39;s
 960     // block styles.
 961     bool mergeForward = !(inSameParagraph(startOfInsertedContent, endOfInsertedContent) &amp;&amp; !isStartOfParagraph(startOfInsertedContent));
 962 
 963     VisiblePosition destination = mergeForward ? endOfInsertedContent.next() : endOfInsertedContent;
 964     VisiblePosition startOfParagraphToMove = mergeForward ? startOfParagraph(endOfInsertedContent) : endOfInsertedContent.next();
 965 
 966     // Merging forward could result in deleting the destination anchor node.
 967     // To avoid this, we add a placeholder node before the start of the paragraph.
 968     if (endOfParagraph(startOfParagraphToMove) == destination) {
 969         auto placeholder = HTMLBRElement::create(document());
 970         auto* placeholderPtr = placeholder.ptr();
 971         insertNodeBefore(WTFMove(placeholder), *startOfParagraphToMove.deepEquivalent().deprecatedNode());
 972         destination = VisiblePosition(positionBeforeNode(placeholderPtr));
 973     }
 974 
 975     moveParagraph(startOfParagraphToMove, endOfParagraph(startOfParagraphToMove), destination);
 976 
 977     // Merging forward will remove m_endOfInsertedContent from the document.
 978     if (mergeForward) {
 979         if (m_startOfInsertedContent.isOrphan())
 980             m_startOfInsertedContent = endingSelection().visibleStart().deepEquivalent();
 981          m_endOfInsertedContent = endingSelection().visibleEnd().deepEquivalent();
 982         // If we merged text nodes, m_endOfInsertedContent could be null. If this is the case, we use m_startOfInsertedContent.
 983         if (m_endOfInsertedContent.isNull())
 984             m_endOfInsertedContent = m_startOfInsertedContent;
 985     }
 986 }
 987 
 988 static Node* enclosingInline(Node* node)
 989 {
 990     while (ContainerNode* parent = node-&gt;parentNode()) {
 991         if (isBlockFlowElement(*parent) || parent-&gt;hasTagName(bodyTag))
 992             return node;
 993         // Stop if any previous sibling is a block.
 994         for (Node* sibling = node-&gt;previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 995             if (isBlockFlowElement(*sibling))
 996                 return node;
 997         }
 998         node = parent;
 999     }
1000     return node;
1001 }
1002 
1003 static bool isInlineNodeWithStyle(const Node* node)
1004 {
1005     // We don&#39;t want to skip over any block elements.
1006     if (isBlock(node))
1007         return false;
1008 
1009     if (!node-&gt;isHTMLElement())
1010         return false;
1011 
1012     // We can skip over elements whose class attribute is
1013     // one of our internal classes.
1014     const HTMLElement* element = static_cast&lt;const HTMLElement*&gt;(node);
1015     const AtomString&amp; classAttributeValue = element-&gt;attributeWithoutSynchronization(classAttr);
1016     if (classAttributeValue == AppleTabSpanClass
1017         || classAttributeValue == AppleConvertedSpace
1018         || classAttributeValue == ApplePasteAsQuotation)
1019         return true;
1020 
1021     return EditingStyle::elementIsStyledSpanOrHTMLEquivalent(*element);
1022 }
1023 
1024 inline Node* nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(const Position&amp; insertionPos)
1025 {
1026     Node* containgBlock = enclosingBlock(insertionPos.containerNode());
1027     return highestEnclosingNodeOfType(insertionPos, isInlineNodeWithStyle, CannotCrossEditingBoundary, containgBlock);
1028 }
1029 
1030 bool ReplaceSelectionCommand::willApplyCommand()
1031 {
1032     m_documentFragmentPlainText = m_documentFragment-&gt;textContent();
1033     m_documentFragmentHTMLMarkup = serializeFragment(*m_documentFragment, SerializedNodes::SubtreeIncludingNode);
1034     ensureReplacementFragment();
1035     return CompositeEditCommand::willApplyCommand();
1036 }
1037 
1038 static bool hasBlankLineBetweenParagraphs(Position&amp; position)
1039 {
1040     bool reachedBoundaryStart = false;
1041     bool reachedBoundaryEnd = false;
1042     VisiblePosition visiblePosition(position);
1043     VisiblePosition previousPosition = visiblePosition.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1044     VisiblePosition nextPosition = visiblePosition.next(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1045     bool hasLineBeforePosition = isEndOfLine(previousPosition);
1046 
1047     return !reachedBoundaryStart &amp;&amp; !reachedBoundaryEnd &amp;&amp; isBlankParagraph(visiblePosition) &amp;&amp; hasLineBeforePosition &amp;&amp; isStartOfLine(nextPosition);
1048 }
1049 
1050 void ReplaceSelectionCommand::doApply()
1051 {
1052     VisibleSelection selection = endingSelection();
1053     ASSERT(selection.isCaretOrRange());
1054     ASSERT(selection.start().deprecatedNode());
1055     if (selection.isNoneOrOrphaned() || !selection.start().deprecatedNode() || !selection.isContentEditable())
1056         return;
1057 
1058     // In plain text only regions, we create style-less fragments, so the inserted content will automatically
1059     // match the style of the surrounding area and so we can avoid unnecessary work below for m_matchStyle.
1060     if (!selection.isContentRichlyEditable())
1061         m_matchStyle = false;
1062 
1063     ReplacementFragment&amp; fragment = *ensureReplacementFragment();
1064     if (performTrivialReplace(fragment))
1065         return;
1066 
1067     // We can skip matching the style if the selection is plain text.
1068     if ((selection.start().deprecatedNode()-&gt;renderer() &amp;&amp; selection.start().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly)
1069         &amp;&amp; (selection.end().deprecatedNode()-&gt;renderer() &amp;&amp; selection.end().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly))
1070         m_matchStyle = false;
1071 
1072     if (m_matchStyle) {
1073         m_insertionStyle = EditingStyle::create(selection.start());
1074         m_insertionStyle-&gt;mergeTypingStyle(document());
1075     }
1076 
1077     VisiblePosition visibleStart = selection.visibleStart();
1078     VisiblePosition visibleEnd = selection.visibleEnd();
1079 
1080     bool selectionEndWasEndOfParagraph = isEndOfParagraph(visibleEnd);
1081     bool selectionStartWasStartOfParagraph = isStartOfParagraph(visibleStart);
1082 
1083     Node* startBlock = enclosingBlock(visibleStart.deepEquivalent().deprecatedNode());
1084 
1085     Position insertionPos = selection.start();
1086     bool shouldHandleMailBlockquote = enclosingNodeOfType(insertionPos, isMailBlockquote, CanCrossEditingBoundary) &amp;&amp; !m_ignoreMailBlockquote;
1087     bool selectionIsPlainText = !selection.isContentRichlyEditable();
1088     Element* currentRoot = selection.rootEditableElement();
1089 
1090     if ((selectionStartWasStartOfParagraph &amp;&amp; selectionEndWasEndOfParagraph &amp;&amp; !shouldHandleMailBlockquote)
1091         || startBlock == currentRoot || isListItem(startBlock) || selectionIsPlainText)
1092         m_preventNesting = false;
1093 
1094     if (selection.isRange()) {
1095         // When the end of the selection being pasted into is at the end of a paragraph, and that selection
1096         // spans multiple blocks, not merging may leave an empty line.
1097         // When the start of the selection being pasted into is at the start of a block, not merging
1098         // will leave hanging block(s).
1099         // Merge blocks if the start of the selection was in a Mail blockquote, since we handle
1100         // that case specially to prevent nesting.
1101         bool mergeBlocksAfterDelete = shouldHandleMailBlockquote || isEndOfParagraph(visibleEnd) || isStartOfBlock(visibleStart);
1102         // FIXME: We should only expand to include fully selected special elements if we are copying a
1103         // selection and pasting it on top of itself.
1104         // FIXME: capturing the content of this delete would allow a replace accessibility notification instead of a simple insert
1105         deleteSelection(false, mergeBlocksAfterDelete, true, false, true);
1106         visibleStart = endingSelection().visibleStart();
1107         if (fragment.hasInterchangeNewlineAtStart()) {
1108             if (isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart)) {
1109                 if (!isEndOfEditableOrNonEditableContent(visibleStart))
1110                     setEndingSelection(visibleStart.next());
1111             } else
1112                 insertParagraphSeparator();
1113         }
1114         insertionPos = endingSelection().start();
1115     } else {
1116         ASSERT(selection.isCaret());
1117         if (fragment.hasInterchangeNewlineAtStart()) {
1118             VisiblePosition next = visibleStart.next(CannotCrossEditingBoundary);
1119             if (isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart) &amp;&amp; next.isNotNull())
1120                 setEndingSelection(next);
1121             else  {
1122                 insertParagraphSeparator();
1123                 visibleStart = endingSelection().visibleStart();
1124             }
1125         }
1126         // We split the current paragraph in two to avoid nesting the blocks from the fragment inside the current block.
1127         // For example paste &lt;div&gt;foo&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;baz&lt;/div&gt; into &lt;div&gt;x^x&lt;/div&gt;, where ^ is the caret.
1128         // As long as the  div styles are the same, visually you&#39;d expect: &lt;div&gt;xbar&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;bazx&lt;/div&gt;,
1129         // not &lt;div&gt;xbar&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;bazx&lt;/div&gt;&lt;/div&gt;.
1130         // Don&#39;t do this if the selection started in a Mail blockquote.
1131         if (m_preventNesting &amp;&amp; !shouldHandleMailBlockquote &amp;&amp; !isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart)) {
1132             insertParagraphSeparator();
1133             setEndingSelection(endingSelection().visibleStart().previous());
1134         }
1135         insertionPos = endingSelection().start();
1136     }
1137 
1138     // We don&#39;t want any of the pasted content to end up nested in a Mail blockquote, so first break
1139     // out of any surrounding Mail blockquotes. Unless we&#39;re inserting in a table, in which case
1140     // breaking the blockquote will prevent the content from actually being inserted in the table.
1141     if (shouldHandleMailBlockquote &amp;&amp; m_preventNesting &amp;&amp; !(enclosingNodeOfType(insertionPos, &amp;isTableStructureNode))) {
1142         applyCommandToComposite(BreakBlockquoteCommand::create(document()));
1143         // This will leave a br between the split.
1144         Node* br = endingSelection().start().deprecatedNode();
1145         ASSERT(br-&gt;hasTagName(brTag));
1146         // Insert content between the two blockquotes, but remove the br (since it was just a placeholder).
1147         insertionPos = positionInParentBeforeNode(br);
1148         removeNode(*br);
1149     }
1150 
1151     // Inserting content could cause whitespace to collapse, e.g. inserting &lt;div&gt;foo&lt;/div&gt; into hello^ world.
1152     prepareWhitespaceAtPositionForSplit(insertionPos);
1153 
1154     // If the downstream node has been removed there&#39;s no point in continuing.
1155     if (!insertionPos.downstream().deprecatedNode())
1156       return;
1157 
1158     // NOTE: This would be an incorrect usage of downstream() if downstream() were changed to mean the last position after
1159     // p that maps to the same visible position as p (since in the case where a br is at the end of a block and collapsed
1160     // away, there are positions after the br which map to the same visible position as [br, 0]).
1161     RefPtr&lt;Node&gt; endBR = insertionPos.downstream().deprecatedNode()-&gt;hasTagName(brTag) ? insertionPos.downstream().deprecatedNode() : nullptr;
1162     VisiblePosition originalVisPosBeforeEndBR;
1163     if (endBR)
1164         originalVisPosBeforeEndBR = VisiblePosition(positionBeforeNode(endBR.get()), DOWNSTREAM).previous();
1165 
1166     RefPtr&lt;Node&gt; insertionBlock = enclosingBlock(insertionPos.deprecatedNode());
1167 
1168     // Adjust insertionPos to prevent nesting.
1169     // If the start was in a Mail blockquote, we will have already handled adjusting insertionPos above.
1170     if (m_preventNesting &amp;&amp; insertionBlock &amp;&amp; !isTableCell(insertionBlock.get()) &amp;&amp; !shouldHandleMailBlockquote) {
1171         ASSERT(insertionBlock != currentRoot);
1172         VisiblePosition visibleInsertionPos(insertionPos);
1173         if (isEndOfBlock(visibleInsertionPos) &amp;&amp; !(isStartOfBlock(visibleInsertionPos) &amp;&amp; fragment.hasInterchangeNewlineAtEnd()))
1174             insertionPos = positionInParentAfterNode(insertionBlock.get());
1175         else if (isStartOfBlock(visibleInsertionPos))
1176             insertionPos = positionInParentBeforeNode(insertionBlock.get());
1177     }
1178 
1179     // Paste at start or end of link goes outside of link.
1180     insertionPos = positionAvoidingSpecialElementBoundary(insertionPos);
1181 
1182     // FIXME: Can this wait until after the operation has been performed?  There doesn&#39;t seem to be
1183     // any work performed after this that queries or uses the typing style.
1184     frame().selection().clearTypingStyle();
1185 
1186     // We don&#39;t want the destination to end up inside nodes that weren&#39;t selected.  To avoid that, we move the
1187     // position forward without changing the visible position so we&#39;re still at the same visible location, but
1188     // outside of preceding tags.
1189     insertionPos = positionAvoidingPrecedingNodes(insertionPos);
1190 
1191     // Paste into run of tabs splits the tab span.
1192     insertionPos = positionOutsideTabSpan(insertionPos);
1193 
1194     bool hasBlankLinesBetweenParagraphs = hasBlankLineBetweenParagraphs(insertionPos);
<a name="4" id="anc4"></a>
1195     bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);
<a name="5" id="anc5"></a><span class="line-added">1196     bool needsColorTransformed = fragmentNeedsColorTransformed(fragment, insertionPos);</span>
1197 
1198     // We&#39;re finished if there is nothing to add.
1199     if (fragment.isEmpty() || !fragment.firstChild())
1200         return;
1201 
1202     // If we are not trying to match the destination style we prefer a position
1203     // that is outside inline elements that provide style.
1204     // This way we can produce a less verbose markup.
1205     // We can skip this optimization for fragments not wrapped in one of
1206     // our style spans and for positions inside list items
1207     // since insertAsListItems already does the right thing.
1208     if (!m_matchStyle &amp;&amp; !enclosingList(insertionPos.containerNode())) {
1209         if (insertionPos.containerNode()-&gt;isTextNode() &amp;&amp; insertionPos.offsetInContainerNode() &amp;&amp; !insertionPos.atLastEditingPositionForNode()) {
1210             splitTextNode(*insertionPos.containerText(), insertionPos.offsetInContainerNode());
1211             insertionPos = firstPositionInNode(insertionPos.containerNode());
1212         }
1213 
1214         if (RefPtr&lt;Node&gt; nodeToSplitTo = nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(insertionPos)) {
1215             if (insertionPos.containerNode() != nodeToSplitTo-&gt;parentNode()) {
1216                 Node* splitStart = insertionPos.computeNodeAfterPosition();
1217                 if (!splitStart)
1218                     splitStart = insertionPos.containerNode();
1219                 ASSERT(splitStart);
1220                 nodeToSplitTo = splitTreeToNode(*splitStart, *nodeToSplitTo-&gt;parentNode()).get();
1221                 insertionPos = positionInParentBeforeNode(nodeToSplitTo.get());
1222             }
1223         }
1224     }
1225 
1226     // FIXME: When pasting rich content we&#39;re often prevented from heading down the fast path by style spans.  Try
1227     // again here if they&#39;ve been removed.
1228 
1229     // 1) Insert the content.
1230     // 2) Remove redundant styles and style tags, this inner &lt;b&gt; for example: &lt;b&gt;foo &lt;b&gt;bar&lt;/b&gt; baz&lt;/b&gt;.
1231     // 3) Merge the start of the added content with the content before the position being pasted into.
1232     // 4) Do one of the following: a) expand the last br if the fragment ends with one and it collapsed,
1233     // b) merge the last paragraph of the incoming fragment with the paragraph that contained the
1234     // end of the selection that was pasted into, or c) handle an interchange newline at the end of the
1235     // incoming fragment.
1236     // 5) Add spaces for smart replace.
1237     // 6) Select the replacement if requested, and match style if requested.
1238 
1239     InsertedNodes insertedNodes;
1240     RefPtr&lt;Node&gt; refNode = fragment.firstChild();
1241     RefPtr&lt;Node&gt; node = refNode-&gt;nextSibling();
1242 
1243     if (refNode)
1244         fragment.removeNode(*refNode);
1245 
1246     Node* blockStart = enclosingBlock(insertionPos.deprecatedNode());
1247     bool isInsertingIntoList = (isListHTMLElement(refNode.get()) || (isLegacyAppleStyleSpan(refNode.get()) &amp;&amp; isListHTMLElement(refNode-&gt;firstChild())))
1248     &amp;&amp; blockStart &amp;&amp; blockStart-&gt;renderer()-&gt;isListItem();
1249     if (isInsertingIntoList)
1250         refNode = insertAsListItems(downcast&lt;HTMLElement&gt;(*refNode), blockStart, insertionPos, insertedNodes);
1251     else {
1252         insertNodeAt(*refNode, insertionPos);
1253         insertedNodes.respondToNodeInsertion(refNode.get());
1254     }
1255 
1256     // Mutation events (bug 22634) may have already removed the inserted content
1257     if (!refNode-&gt;isConnected())
1258         return;
1259 
1260     bool plainTextFragment = isPlainTextMarkup(refNode.get());
1261 
1262     while (node) {
1263         RefPtr&lt;Node&gt; next = node-&gt;nextSibling();
1264         fragment.removeNode(*node);
1265         insertNodeAfter(*node, *refNode);
1266         insertedNodes.respondToNodeInsertion(node.get());
1267 
1268         // Mutation events (bug 22634) may have already removed the inserted content
1269         if (!node-&gt;isConnected())
1270             return;
1271 
1272         refNode = node;
1273         if (node &amp;&amp; plainTextFragment)
1274             plainTextFragment = isPlainTextMarkup(node.get());
1275         node = next;
1276     }
1277 
1278     if (insertedNodes.isEmpty())
1279         return;
1280     removeUnrenderedTextNodesAtEnds(insertedNodes);
1281 
1282     if (!handledStyleSpans)
1283         handleStyleSpans(insertedNodes);
1284 
1285     // Mutation events (bug 20161) may have already removed the inserted content
1286     if (insertedNodes.isEmpty())
1287         return;
1288     if (!insertedNodes.firstNodeInserted()-&gt;isConnected())
1289         return;
1290 
1291     VisiblePosition startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1292 
1293     // We inserted before the insertionBlock to prevent nesting, and the content before the insertionBlock wasn&#39;t in its own block and
1294     // didn&#39;t have a br after it, so the inserted content ended up in the same paragraph.
1295     if (!startOfInsertedContent.isNull() &amp;&amp; insertionBlock &amp;&amp; insertionPos.deprecatedNode() == insertionBlock-&gt;parentNode() &amp;&amp; (unsigned)insertionPos.deprecatedEditingOffset() &lt; insertionBlock-&gt;computeNodeIndex() &amp;&amp; !isStartOfParagraph(startOfInsertedContent))
1296         insertNodeAt(HTMLBRElement::create(document()), startOfInsertedContent.deepEquivalent());
1297 
1298     if (endBR &amp;&amp; (plainTextFragment || shouldRemoveEndBR(endBR.get(), originalVisPosBeforeEndBR))) {
1299         RefPtr&lt;Node&gt; parent = endBR-&gt;parentNode();
1300         insertedNodes.willRemoveNode(endBR.get());
1301         removeNode(*endBR);
1302         if (Node* nodeToRemove = highestNodeToRemoveInPruning(parent.get())) {
1303             insertedNodes.willRemoveNode(nodeToRemove);
1304             removeNode(*nodeToRemove);
1305         }
1306     }
1307 
1308     makeInsertedContentRoundTrippableWithHTMLTreeBuilder(insertedNodes);
1309     if (insertedNodes.isEmpty())
1310         return;
1311 
<a name="6" id="anc6"></a><span class="line-added">1312     if (needsColorTransformed)</span>
<span class="line-added">1313         inverseTransformColor(insertedNodes);</span>
<span class="line-added">1314 </span>
1315     removeRedundantStylesAndKeepStyleSpanInline(insertedNodes);
1316     if (insertedNodes.isEmpty())
1317         return;
1318 
1319     if (m_sanitizeFragment)
1320         applyCommandToComposite(SimplifyMarkupCommand::create(document(), insertedNodes.firstNodeInserted(), insertedNodes.pastLastLeaf()));
1321 
1322     // Setup m_startOfInsertedContent and m_endOfInsertedContent. This should be the last two lines of code that access insertedNodes.
1323     m_startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1324     m_endOfInsertedContent = lastPositionInOrAfterNode(insertedNodes.lastLeafInserted());
1325 
1326     // Determine whether or not we should merge the end of inserted content with what&#39;s after it before we do
1327     // the start merge so that the start merge doesn&#39;t effect our decision.
1328     m_shouldMergeEnd = shouldMergeEnd(selectionEndWasEndOfParagraph);
1329 
1330     if (shouldMergeStart(selectionStartWasStartOfParagraph, fragment.hasInterchangeNewlineAtStart(), shouldHandleMailBlockquote)) {
1331         VisiblePosition startOfParagraphToMove = positionAtStartOfInsertedContent();
1332         VisiblePosition destination = startOfParagraphToMove.previous();
1333         // We need to handle the case where we need to merge the end
1334         // but our destination node is inside an inline that is the last in the block.
1335         // We insert a placeholder before the newly inserted content to avoid being merged into the inline.
1336         Node* destinationNode = destination.deepEquivalent().deprecatedNode();
1337         if (m_shouldMergeEnd &amp;&amp; destinationNode != enclosingInline(destinationNode) &amp;&amp; enclosingInline(destinationNode)-&gt;nextSibling())
1338             insertNodeBefore(HTMLBRElement::create(document()), *refNode);
1339 
1340         // Merging the first paragraph of inserted content with the content that came
1341         // before the selection that was pasted into would also move content after
1342         // the selection that was pasted into if: only one paragraph was being pasted,
1343         // and it was not wrapped in a block, the selection that was pasted into ended
1344         // at the end of a block and the next paragraph didn&#39;t start at the start of a block.
1345         // Insert a line break just after the inserted content to separate it from what
1346         // comes after and prevent that from happening.
1347         VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1348         if (startOfParagraph(endOfInsertedContent) == startOfParagraphToMove) {
1349             insertNodeAt(HTMLBRElement::create(document()), endOfInsertedContent.deepEquivalent());
1350             // Mutation events (bug 22634) triggered by inserting the &lt;br&gt; might have removed the content we&#39;re about to move
1351             if (!startOfParagraphToMove.deepEquivalent().anchorNode()-&gt;isConnected())
1352                 return;
1353         }
1354 
1355         // FIXME: Maintain positions for the start and end of inserted content instead of keeping nodes.  The nodes are
1356         // only ever used to create positions where inserted content starts/ends.
1357         moveParagraph(startOfParagraphToMove, endOfParagraph(startOfParagraphToMove), destination);
1358         m_startOfInsertedContent = endingSelection().visibleStart().deepEquivalent().downstream();
1359         if (m_endOfInsertedContent.isOrphan())
1360             m_endOfInsertedContent = endingSelection().visibleEnd().deepEquivalent().upstream();
1361     }
1362 
1363     Position lastPositionToSelect;
1364     if (fragment.hasInterchangeNewlineAtEnd()) {
1365         VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1366         VisiblePosition next = endOfInsertedContent.next(CannotCrossEditingBoundary);
1367 
1368         if (selectionEndWasEndOfParagraph || !isEndOfParagraph(endOfInsertedContent) || next.isNull()) {
1369             if (!isStartOfParagraph(endOfInsertedContent)) {
1370                 setEndingSelection(endOfInsertedContent);
1371                 Node* enclosingNode = enclosingBlock(endOfInsertedContent.deepEquivalent().deprecatedNode());
1372                 if (isListItem(enclosingNode)) {
1373                     auto newListItem = HTMLLIElement::create(document());
1374                     insertNodeAfter(newListItem.copyRef(), *enclosingNode);
1375                     setEndingSelection(VisiblePosition(firstPositionInNode(newListItem.ptr())));
1376                 } else {
1377                     // Use a default paragraph element (a plain div) for the empty paragraph, using the last paragraph
1378                     // block&#39;s style seems to annoy users.
1379                     insertParagraphSeparator(true, !shouldHandleMailBlockquote &amp;&amp; highestEnclosingNodeOfType(endOfInsertedContent.deepEquivalent(),
1380                         isMailBlockquote, CannotCrossEditingBoundary, insertedNodes.firstNodeInserted()-&gt;parentNode()));
1381                 }
1382 
1383                 // Select up to the paragraph separator that was added.
1384                 lastPositionToSelect = endingSelection().visibleStart().deepEquivalent();
1385                 updateNodesInserted(lastPositionToSelect.deprecatedNode());
1386             }
1387         } else {
1388             // Select up to the beginning of the next paragraph.
1389             lastPositionToSelect = next.deepEquivalent().downstream();
1390         }
1391 
1392     } else
1393         mergeEndIfNeeded();
1394 
1395     if (Node* mailBlockquote = enclosingNodeOfType(positionAtStartOfInsertedContent().deepEquivalent(), isMailPasteAsQuotationNode))
1396         removeNodeAttribute(downcast&lt;Element&gt;(*mailBlockquote), classAttr);
1397 
1398     if (shouldPerformSmartReplace())
1399         addSpacesForSmartReplace();
1400 
1401     if (!isInsertingIntoList &amp;&amp; hasBlankLinesBetweenParagraphs &amp;&amp; shouldPerformSmartParagraphReplace())
1402         addNewLinesForSmartReplace();
1403 
1404     // If we are dealing with a fragment created from plain text
1405     // no style matching is necessary.
1406     if (plainTextFragment)
1407         m_matchStyle = false;
1408 
1409     completeHTMLReplacement(lastPositionToSelect);
1410 }
1411 
1412 String ReplaceSelectionCommand::inputEventData() const
1413 {
1414     if (isEditingTextAreaOrTextInput())
1415         return m_documentFragment-&gt;textContent();
1416 
1417     return CompositeEditCommand::inputEventData();
1418 }
1419 
1420 RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
1421 {
1422     if (isEditingTextAreaOrTextInput())
1423         return CompositeEditCommand::inputEventDataTransfer();
1424 
<a name="7" id="anc7"></a><span class="line-modified">1425     return DataTransfer::createForInputEvent(m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
1426 }
1427 
1428 bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
1429 {
1430     if (!endBR || !endBR-&gt;isConnected())
1431         return false;
1432 
1433     VisiblePosition visiblePos(positionBeforeNode(endBR));
1434 
1435     // Don&#39;t remove the br if nothing was inserted.
1436     if (visiblePos.previous() == originalVisPosBeforeEndBR)
1437         return false;
1438 
1439     // Remove the br if it is collapsed away and so is unnecessary.
1440     if (!document().inNoQuirksMode() &amp;&amp; isEndOfBlock(visiblePos) &amp;&amp; !isStartOfParagraph(visiblePos))
1441         return true;
1442 
1443     // A br that was originally holding a line open should be displaced by inserted content or turned into a line break.
1444     // A br that was originally acting as a line break should still be acting as a line break, not as a placeholder.
1445     return isStartOfParagraph(visiblePos) &amp;&amp; isEndOfParagraph(visiblePos);
1446 }
1447 
1448 bool ReplaceSelectionCommand::shouldPerformSmartReplace() const
1449 {
1450     if (!m_smartReplace)
1451         return false;
1452 
1453     Element* textControl = enclosingTextFormControl(positionAtStartOfInsertedContent().deepEquivalent());
1454     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*textControl).isPasswordField())
1455         return false; // Disable smart replace for password fields.
1456 
1457     return true;
1458 }
1459 
1460 bool ReplaceSelectionCommand::shouldPerformSmartParagraphReplace() const
1461 {
1462     if (!m_smartReplace)
1463         return false;
1464 
1465     if (!document().editingBehavior().shouldSmartInsertDeleteParagraphs())
1466         return false;
1467 
1468     return true;
1469 }
1470 
1471 static bool isCharacterSmartReplaceExemptConsideringNonBreakingSpace(UChar32 character, bool previousCharacter)
1472 {
1473     return isCharacterSmartReplaceExempt(character == noBreakSpace ? &#39; &#39; : character, previousCharacter);
1474 }
1475 
1476 void ReplaceSelectionCommand::addNewLinesForSmartReplace()
1477 {
1478     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();
1479     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1480 
1481     bool isPastedContentEntireParagraphs = isStartOfParagraph(startOfInsertedContent) &amp;&amp; isEndOfParagraph(endOfInsertedContent);
1482 
1483     // If we aren&#39;t pasting a paragraph, no need to attempt to insert newlines.
1484     if (!isPastedContentEntireParagraphs)
1485         return;
1486 
1487     bool reachedBoundaryStart = false;
1488     bool reachedBoundaryEnd = false;
1489     VisiblePosition positionBeforeStart = startOfInsertedContent.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1490     VisiblePosition positionAfterEnd = endOfInsertedContent.next(CannotCrossEditingBoundary, &amp;reachedBoundaryEnd);
1491 
1492     if (!reachedBoundaryStart &amp;&amp; !reachedBoundaryEnd) {
1493         if (!isBlankParagraph(positionBeforeStart) &amp;&amp; !isBlankParagraph(startOfInsertedContent) &amp;&amp; isEndOfLine(positionBeforeStart) &amp;&amp; !isEndOfEditableOrNonEditableContent(positionAfterEnd) &amp;&amp; !isEndOfEditableOrNonEditableContent(endOfInsertedContent)) {
1494             setEndingSelection(startOfInsertedContent);
1495             insertParagraphSeparator();
1496             auto newStart = endingSelection().visibleStart().previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1497             if (!reachedBoundaryStart)
1498                 m_startOfInsertedContent = newStart.deepEquivalent();
1499         }
1500     }
1501 
1502     reachedBoundaryStart = false;
1503     reachedBoundaryEnd = false;
1504     positionAfterEnd = endOfInsertedContent.next(CannotCrossEditingBoundary, &amp;reachedBoundaryEnd);
1505     positionBeforeStart = startOfInsertedContent.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1506 
1507     if (!reachedBoundaryEnd &amp;&amp; !reachedBoundaryStart) {
1508         if (!isBlankParagraph(positionAfterEnd) &amp;&amp; !isBlankParagraph(endOfInsertedContent) &amp;&amp; isStartOfLine(positionAfterEnd) &amp;&amp; !isEndOfLine(positionAfterEnd) &amp;&amp; !isEndOfEditableOrNonEditableContent(positionAfterEnd)) {
1509             setEndingSelection(endOfInsertedContent);
1510             insertParagraphSeparator();
1511             m_endOfInsertedContent = endingSelection().start();
1512         }
1513     }
1514 }
1515 
1516 void ReplaceSelectionCommand::addSpacesForSmartReplace()
1517 {
1518     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();
1519     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1520 
1521     Position endUpstream = endOfInsertedContent.deepEquivalent().upstream();
1522     Node* endNode = endUpstream.computeNodeBeforePosition();
1523     int endOffset = is&lt;Text&gt;(endNode) ? downcast&lt;Text&gt;(*endNode).length() : 0;
1524     if (endUpstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1525         endNode = endUpstream.containerNode();
1526         endOffset = endUpstream.offsetInContainerNode();
1527     }
1528 
1529     bool needsTrailingSpace = !isEndOfParagraph(endOfInsertedContent) &amp;&amp; !isStartOfParagraph(endOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(endOfInsertedContent.characterAfter(), false);
1530     if (needsTrailingSpace &amp;&amp; endNode) {
1531         bool collapseWhiteSpace = !endNode-&gt;renderer() || endNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1532         if (is&lt;Text&gt;(*endNode)) {
1533             insertTextIntoNode(downcast&lt;Text&gt;(*endNode), endOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1534             if (m_endOfInsertedContent.containerNode() == endNode)
1535                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
1536         } else {
1537             auto node = document().createEditingTextNode(collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1538             insertNodeAfter(node.copyRef(), *endNode);
1539             updateNodesInserted(node.ptr());
1540         }
1541     }
1542 
1543     document().updateLayout();
1544 
1545     Position startDownstream = startOfInsertedContent.deepEquivalent().downstream();
1546     Node* startNode = startDownstream.computeNodeAfterPosition();
1547     unsigned startOffset = 0;
1548     if (startDownstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1549         startNode = startDownstream.containerNode();
1550         startOffset = startDownstream.offsetInContainerNode();
1551     }
1552 
1553     bool needsLeadingSpace = !isStartOfParagraph(startOfInsertedContent) &amp;&amp; !isEndOfParagraph(startOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(startOfInsertedContent.previous().characterAfter(), true);
1554     if (needsLeadingSpace &amp;&amp; startNode) {
1555         bool collapseWhiteSpace = !startNode-&gt;renderer() || startNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1556         if (is&lt;Text&gt;(*startNode)) {
1557             insertTextIntoNode(downcast&lt;Text&gt;(*startNode), startOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1558             if (m_endOfInsertedContent.containerNode() == startNode &amp;&amp; m_endOfInsertedContent.offsetInContainerNode())
1559                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
1560         } else {
1561             auto node = document().createEditingTextNode(collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1562             auto* nodePtr = node.ptr();
1563             // Don&#39;t updateNodesInserted. Doing so would set m_endOfInsertedContent to be the node containing the leading space,
1564             // but m_endOfInsertedContent is supposed to mark the end of pasted content.
1565             insertNodeBefore(WTFMove(node), *startNode);
1566             m_startOfInsertedContent = firstPositionInNode(nodePtr);
1567         }
1568     }
1569 }
1570 
1571 void ReplaceSelectionCommand::completeHTMLReplacement(const Position &amp;lastPositionToSelect)
1572 {
1573     Position start = positionAtStartOfInsertedContent().deepEquivalent();
1574     Position end = positionAtEndOfInsertedContent().deepEquivalent();
1575 
1576     // Mutation events may have deleted start or end
1577     if (start.isNotNull() &amp;&amp; !start.isOrphan() &amp;&amp; end.isNotNull() &amp;&amp; !end.isOrphan()) {
1578         // FIXME (11475): Remove this and require that the creator of the fragment to use nbsps.
1579         rebalanceWhitespaceAt(start);
1580         rebalanceWhitespaceAt(end);
1581 
1582         if (m_matchStyle) {
1583             ASSERT(m_insertionStyle);
1584             applyStyle(m_insertionStyle.get(), start, end);
1585         }
1586 
1587         if (lastPositionToSelect.isNotNull())
1588             end = lastPositionToSelect;
1589 
1590         mergeTextNodesAroundPosition(start, end);
1591         mergeTextNodesAroundPosition(end, start);
1592     } else if (lastPositionToSelect.isNotNull())
1593         start = end = lastPositionToSelect;
1594     else
1595         return;
1596 
1597     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1598         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1599 
1600     if (m_selectReplacement)
1601         setEndingSelection(VisibleSelection(start, end, SEL_DEFAULT_AFFINITY, endingSelection().isDirectional()));
1602     else
1603         setEndingSelection(VisibleSelection(end, SEL_DEFAULT_AFFINITY, endingSelection().isDirectional()));
1604 }
1605 
1606 void ReplaceSelectionCommand::mergeTextNodesAroundPosition(Position&amp; position, Position&amp; positionOnlyToBeUpdated)
1607 {
1608     bool positionIsOffsetInAnchor = position.anchorType() == Position::PositionIsOffsetInAnchor;
1609     bool positionOnlyToBeUpdatedIsOffsetInAnchor = positionOnlyToBeUpdated.anchorType() == Position::PositionIsOffsetInAnchor;
1610     RefPtr&lt;Text&gt; text;
1611     if (positionIsOffsetInAnchor &amp;&amp; is&lt;Text&gt;(position.containerNode()))
1612         text = downcast&lt;Text&gt;(position.containerNode());
1613     else {
1614         Node* before = position.computeNodeBeforePosition();
1615         if (is&lt;Text&gt;(before))
1616             text = downcast&lt;Text&gt;(before);
1617         else {
1618             Node* after = position.computeNodeAfterPosition();
1619             if (is&lt;Text&gt;(after))
1620                 text = downcast&lt;Text&gt;(after);
1621         }
1622     }
1623     if (!text)
1624         return;
1625 
1626     if (is&lt;Text&gt;(text-&gt;previousSibling())) {
1627         Ref&lt;Text&gt; previous(downcast&lt;Text&gt;(*text-&gt;previousSibling()));
1628         insertTextIntoNode(*text, 0, previous-&gt;data());
1629 
1630         if (positionIsOffsetInAnchor)
1631             position.moveToOffset(previous-&gt;length() + position.offsetInContainerNode());
1632         else
1633             updatePositionForNodeRemoval(position, previous.get());
1634 
1635         if (positionOnlyToBeUpdatedIsOffsetInAnchor) {
1636             if (positionOnlyToBeUpdated.containerNode() == text)
1637                 positionOnlyToBeUpdated.moveToOffset(previous-&gt;length() + positionOnlyToBeUpdated.offsetInContainerNode());
1638             else if (positionOnlyToBeUpdated.containerNode() == previous.ptr())
1639                 positionOnlyToBeUpdated.moveToPosition(text.get(), positionOnlyToBeUpdated.offsetInContainerNode());
1640         } else
1641             updatePositionForNodeRemoval(positionOnlyToBeUpdated, previous.get());
1642 
1643         removeNode(previous);
1644     }
1645     if (is&lt;Text&gt;(text-&gt;nextSibling())) {
1646         Ref&lt;Text&gt; next(downcast&lt;Text&gt;(*text-&gt;nextSibling()));
1647         unsigned originalLength = text-&gt;length();
1648         insertTextIntoNode(*text, originalLength, next-&gt;data());
1649 
1650         if (!positionIsOffsetInAnchor)
1651             updatePositionForNodeRemoval(position, next.get());
1652 
1653         if (positionOnlyToBeUpdatedIsOffsetInAnchor &amp;&amp; positionOnlyToBeUpdated.containerNode() == next.ptr())
1654             positionOnlyToBeUpdated.moveToPosition(text.get(), originalLength + positionOnlyToBeUpdated.offsetInContainerNode());
1655         else
1656             updatePositionForNodeRemoval(positionOnlyToBeUpdated, next.get());
1657 
1658         removeNode(next);
1659     }
1660 }
1661 
1662 static HTMLElement* singleChildList(HTMLElement&amp; element)
1663 {
1664     if (!element.hasOneChild())
1665         return nullptr;
1666 
1667     auto&amp; child = *element.firstChild();
1668     return isListHTMLElement(&amp;child) ? &amp;downcast&lt;HTMLElement&gt;(child) : nullptr;
1669 }
1670 
1671 static HTMLElement&amp; deepestSingleChildList(HTMLElement&amp; topLevelList)
1672 {
1673     auto* list = &amp;topLevelList;
1674     while (auto* childList = singleChildList(*list))
1675         list = childList;
1676     return *list;
1677 }
1678 
1679 // If the user is inserting a list into an existing list, instead of nesting the list,
1680 // we put the list items into the existing list.
1681 Node* ReplaceSelectionCommand::insertAsListItems(HTMLElement&amp; passedListElement, Node* insertionBlock, const Position&amp; insertPos, InsertedNodes&amp; insertedNodes)
1682 {
1683     Ref&lt;HTMLElement&gt; listElement = deepestSingleChildList(passedListElement);
1684 
1685     bool isStart = isStartOfParagraph(insertPos);
1686     bool isEnd = isEndOfParagraph(insertPos);
1687     bool isMiddle = !isStart &amp;&amp; !isEnd;
1688     Node* lastNode = insertionBlock;
1689 
1690     // If we&#39;re in the middle of a list item, we should split it into two separate
1691     // list items and insert these nodes between them.
1692     if (isMiddle) {
1693         int textNodeOffset = insertPos.offsetInContainerNode();
1694         if (is&lt;Text&gt;(*insertPos.deprecatedNode()) &amp;&amp; textNodeOffset &gt; 0)
1695             splitTextNode(downcast&lt;Text&gt;(*insertPos.deprecatedNode()), textNodeOffset);
1696         splitTreeToNode(*insertPos.deprecatedNode(), *lastNode, true);
1697     }
1698 
1699     while (RefPtr&lt;Node&gt; listItem = listElement-&gt;firstChild()) {
1700         listElement-&gt;removeChild(*listItem);
1701         if (isStart || isMiddle) {
1702             insertNodeBefore(*listItem, *lastNode);
1703             insertedNodes.respondToNodeInsertion(listItem.get());
1704         } else if (isEnd) {
1705             insertNodeAfter(*listItem, *lastNode);
1706             insertedNodes.respondToNodeInsertion(listItem.get());
1707             lastNode = listItem.get();
1708         } else
1709             ASSERT_NOT_REACHED();
1710     }
1711     if ((isStart || isMiddle) &amp;&amp; lastNode-&gt;previousSibling())
1712         lastNode = lastNode-&gt;previousSibling();
1713     return lastNode;
1714 }
1715 
1716 void ReplaceSelectionCommand::updateNodesInserted(Node *node)
1717 {
1718     if (!node)
1719         return;
1720 
1721     if (m_startOfInsertedContent.isNull())
1722         m_startOfInsertedContent = firstPositionInOrBeforeNode(node);
1723 
1724     m_endOfInsertedContent = lastPositionInOrAfterNode(node-&gt;lastDescendant());
1725 }
1726 
1727 ReplacementFragment* ReplaceSelectionCommand::ensureReplacementFragment()
1728 {
1729     if (!m_replacementFragment)
1730         m_replacementFragment = makeUnique&lt;ReplacementFragment&gt;(m_documentFragment.get(), endingSelection());
1731     return m_replacementFragment.get();
1732 }
1733 
1734 // During simple pastes, where we&#39;re just pasting a text node into a run of text, we insert the text node
1735 // directly into the text node that holds the selection.  This is much faster than the generalized code in
1736 // ReplaceSelectionCommand, and works around &lt;https://bugs.webkit.org/show_bug.cgi?id=6148&gt; since we don&#39;t
1737 // split text nodes.
1738 bool ReplaceSelectionCommand::performTrivialReplace(const ReplacementFragment&amp; fragment)
1739 {
1740     if (!is&lt;Text&gt;(fragment.firstChild()) || fragment.firstChild() != fragment.lastChild())
1741         return false;
1742 
1743     // FIXME: Would be nice to handle smart replace in the fast path.
1744     if (m_smartReplace || fragment.hasInterchangeNewlineAtStart() || fragment.hasInterchangeNewlineAtEnd())
1745         return false;
1746 
1747     // e.g. when &quot;bar&quot; is inserted after &quot;foo&quot; in &lt;div&gt;&lt;u&gt;foo&lt;/u&gt;&lt;/div&gt;, &quot;bar&quot; should not be underlined.
1748     if (nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(endingSelection().start()))
1749         return false;
1750 
1751     RefPtr&lt;Node&gt; nodeAfterInsertionPos = endingSelection().end().downstream().anchorNode();
1752     Text&amp; textNode = downcast&lt;Text&gt;(*fragment.firstChild());
1753     // Our fragment creation code handles tabs, spaces, and newlines, so we don&#39;t have to worry about those here.
1754 
1755     Position start = endingSelection().start();
1756     Position end = replaceSelectedTextInNode(textNode.data());
1757     if (end.isNull())
1758         return false;
1759 
1760     if (nodeAfterInsertionPos &amp;&amp; nodeAfterInsertionPos-&gt;parentNode() &amp;&amp; nodeAfterInsertionPos-&gt;hasTagName(brTag)
1761         &amp;&amp; shouldRemoveEndBR(nodeAfterInsertionPos.get(), positionBeforeNode(nodeAfterInsertionPos.get())))
1762         removeNodeAndPruneAncestors(*nodeAfterInsertionPos);
1763 
1764     VisibleSelection selectionAfterReplace(m_selectReplacement ? start : end, end);
1765 
1766     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1767         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1768 
1769     setEndingSelection(selectionAfterReplace);
1770 
1771     return true;
1772 }
1773 
<a name="8" id="anc8"></a><span class="line-added">1774 RefPtr&lt;Range&gt; ReplaceSelectionCommand::insertedContentRange() const</span>
<span class="line-added">1775 {</span>
<span class="line-added">1776     if (auto document = makeRefPtr(m_startOfInsertedContent.document()))</span>
<span class="line-added">1777         return Range::create(*document, m_startOfInsertedContent, m_endOfInsertedContent);</span>
<span class="line-added">1778 </span>
<span class="line-added">1779     return nullptr;</span>
<span class="line-added">1780 }</span>
<span class="line-added">1781 </span>
1782 } // namespace WebCore
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
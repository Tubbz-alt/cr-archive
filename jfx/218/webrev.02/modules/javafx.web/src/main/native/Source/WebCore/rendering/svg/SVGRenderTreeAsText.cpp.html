<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderTreeAsText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005, 2007, 2009 Apple Inc. All rights reserved.
  3  *           (C) 2005 Rob Buis &lt;buis@kde.org&gt;
  4  *           (C) 2006 Alexander Kellett &lt;lypanov@kde.org&gt;
  5  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  * 1. Redistributions of source code must retain the above copyright
 11  *    notice, this list of conditions and the following disclaimer.
 12  * 2. Redistributions in binary form must reproduce the above copyright
 13  *    notice, this list of conditions and the following disclaimer in the
 14  *    documentation and/or other materials provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SVGRenderTreeAsText.h&quot;
 31 
 32 #include &quot;GraphicsTypes.h&quot;
 33 #include &quot;NodeRenderStyle.h&quot;
 34 #include &quot;RenderImage.h&quot;
 35 #include &quot;RenderIterator.h&quot;
 36 #include &quot;RenderSVGGradientStop.h&quot;
 37 #include &quot;RenderSVGImage.h&quot;
 38 #include &quot;RenderSVGPath.h&quot;
 39 #include &quot;RenderSVGResourceClipper.h&quot;
 40 #include &quot;RenderSVGResourceFilter.h&quot;
 41 #include &quot;RenderSVGResourceLinearGradient.h&quot;
 42 #include &quot;RenderSVGResourceMarker.h&quot;
 43 #include &quot;RenderSVGResourceMasker.h&quot;
 44 #include &quot;RenderSVGResourcePattern.h&quot;
 45 #include &quot;RenderSVGResourceRadialGradient.h&quot;
 46 #include &quot;RenderSVGResourceSolidColor.h&quot;
 47 #include &quot;RenderSVGRoot.h&quot;
 48 #include &quot;RenderSVGText.h&quot;
 49 #include &quot;SVGCircleElement.h&quot;
 50 #include &quot;SVGEllipseElement.h&quot;
 51 #include &quot;SVGInlineTextBox.h&quot;
 52 #include &quot;SVGLineElement.h&quot;
 53 #include &quot;SVGPathElement.h&quot;
 54 #include &quot;SVGPathUtilities.h&quot;
 55 #include &quot;SVGPolyElement.h&quot;
 56 #include &quot;SVGRectElement.h&quot;
 57 #include &quot;SVGRootInlineBox.h&quot;
 58 #include &quot;SVGStopElement.h&quot;
 59 
 60 #include &lt;math.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 /** class + iomanip to help streaming list separators, i.e. &quot;, &quot; in string &quot;a, b, c, d&quot;
 65  * Can be used in cases where you don&#39;t know which item in the list is the first
 66  * one to be printed, but still want to avoid strings like &quot;, b, c&quot;.
 67  */
 68 class TextStreamSeparator {
 69 public:
 70     TextStreamSeparator(const String&amp; s)
 71         : m_separator(s)
 72         , m_needToSeparate(false)
 73     {
 74     }
 75 
 76 private:
 77     friend TextStream&amp; operator&lt;&lt;(TextStream&amp;, TextStreamSeparator&amp;);
 78 
 79     String m_separator;
 80     bool m_needToSeparate;
 81 };
 82 
 83 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, TextStreamSeparator&amp; sep)
 84 {
 85     if (sep.m_needToSeparate)
 86         ts &lt;&lt; sep.m_separator;
 87     else
 88         sep.m_needToSeparate = true;
 89     return ts;
 90 }
 91 
 92 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DashArray&amp; a)
 93 {
 94     ts &lt;&lt; &quot;{&quot;;
 95     DashArray::const_iterator end = a.end();
 96     for (DashArray::const_iterator it = a.begin(); it != end; ++it) {
 97         if (it != a.begin())
 98             ts &lt;&lt; &quot;, &quot;;
 99         ts &lt;&lt; *it;
100     }
101     ts &lt;&lt; &quot;}&quot;;
102     return ts;
103 }
104 
105 template&lt;typename ValueType&gt;
106 static void writeNameValuePair(TextStream&amp; ts, const char* name, ValueType value)
107 {
108     ts &lt;&lt; &quot; [&quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; value &lt;&lt; &quot;]&quot;;
109 }
110 
111 template&lt;typename ValueType&gt;
112 static void writeNameAndQuotedValue(TextStream&amp; ts, const char* name, ValueType value)
113 {
114     ts &lt;&lt; &quot; [&quot; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\&quot;]&quot;;
115 }
116 
117 static void writeIfNotEmpty(TextStream&amp; ts, const char* name, const String&amp; value)
118 {
119     if (!value.isEmpty())
120         writeNameValuePair(ts, name, value);
121 }
122 
123 template&lt;typename ValueType&gt;
124 static void writeIfNotDefault(TextStream&amp; ts, const char* name, ValueType value, ValueType defaultValue)
125 {
126     if (value != defaultValue)
127         writeNameValuePair(ts, name, value);
128 }
129 
130 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SVGUnitTypes::SVGUnitType&amp; unitType)
131 {
132     ts &lt;&lt; SVGPropertyTraits&lt;SVGUnitTypes::SVGUnitType&gt;::toString(unitType);
133     return ts;
134 }
135 
136 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SVGMarkerUnitsType&amp; markerUnit)
137 {
138     ts &lt;&lt; SVGPropertyTraits&lt;SVGMarkerUnitsType&gt;::toString(markerUnit);
139     return ts;
140 }
141 
142 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SVGSpreadMethodType&amp; type)
143 {
144     ts &lt;&lt; SVGPropertyTraits&lt;SVGSpreadMethodType&gt;::toString(type).convertToASCIIUppercase();
145     return ts;
146 }
147 
148 static void writeSVGPaintingResource(TextStream&amp; ts, RenderSVGResource* resource)
149 {
150     if (resource-&gt;resourceType() == SolidColorResourceType) {
151         ts &lt;&lt; &quot;[type=SOLID] [color=&quot; &lt;&lt; static_cast&lt;RenderSVGResourceSolidColor*&gt;(resource)-&gt;color() &lt;&lt; &quot;]&quot;;
152         return;
153     }
154 
155     // All other resources derive from RenderSVGResourceContainer
156     RenderSVGResourceContainer* container = static_cast&lt;RenderSVGResourceContainer*&gt;(resource);
157     SVGElement&amp; element = container-&gt;element();
158 
159     if (resource-&gt;resourceType() == PatternResourceType)
160         ts &lt;&lt; &quot;[type=PATTERN]&quot;;
161     else if (resource-&gt;resourceType() == LinearGradientResourceType)
162         ts &lt;&lt; &quot;[type=LINEAR-GRADIENT]&quot;;
163     else if (resource-&gt;resourceType() == RadialGradientResourceType)
164         ts &lt;&lt; &quot;[type=RADIAL-GRADIENT]&quot;;
165 
166     ts &lt;&lt; &quot; [id=\&quot;&quot; &lt;&lt; element.getIdAttribute() &lt;&lt; &quot;\&quot;]&quot;;
167 }
168 
169 static void writeStyle(TextStream&amp; ts, const RenderElement&amp; renderer)
170 {
171     const RenderStyle&amp; style = renderer.style();
172     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
173 
174     if (!renderer.localTransform().isIdentity())
175         writeNameValuePair(ts, &quot;transform&quot;, renderer.localTransform());
176     writeIfNotDefault(ts, &quot;image rendering&quot;, style.imageRendering(), RenderStyle::initialImageRendering());
177     writeIfNotDefault(ts, &quot;opacity&quot;, style.opacity(), RenderStyle::initialOpacity());
178     if (is&lt;RenderSVGShape&gt;(renderer)) {
179         const auto&amp; shape = downcast&lt;RenderSVGShape&gt;(renderer);
180 
181         Color fallbackColor;
182         if (RenderSVGResource* strokePaintingResource = RenderSVGResource::strokePaintingResource(const_cast&lt;RenderSVGShape&amp;&gt;(shape), shape.style(), fallbackColor)) {
183             TextStreamSeparator s(&quot; &quot;);
184             ts &lt;&lt; &quot; [stroke={&quot; &lt;&lt; s;
185             writeSVGPaintingResource(ts, strokePaintingResource);
186 
187             SVGLengthContext lengthContext(&amp;shape.graphicsElement());
188             double dashOffset = lengthContext.valueForLength(svgStyle.strokeDashOffset());
189             double strokeWidth = lengthContext.valueForLength(style.strokeWidth());
190             const auto&amp; dashes = svgStyle.strokeDashArray();
191 
192             DashArray dashArray;
193             for (auto&amp; length : dashes)
194                 dashArray.append(length.value(lengthContext));
195 
196             writeIfNotDefault(ts, &quot;opacity&quot;, svgStyle.strokeOpacity(), 1.0f);
197             writeIfNotDefault(ts, &quot;stroke width&quot;, strokeWidth, 1.0);
198             writeIfNotDefault(ts, &quot;miter limit&quot;, style.strokeMiterLimit(), 4.0f);
199             writeIfNotDefault(ts, &quot;line cap&quot;, style.capStyle(), ButtCap);
200             writeIfNotDefault(ts, &quot;line join&quot;, style.joinStyle(), MiterJoin);
201             writeIfNotDefault(ts, &quot;dash offset&quot;, dashOffset, 0.0);
202             if (!dashArray.isEmpty())
203                 writeNameValuePair(ts, &quot;dash array&quot;, dashArray);
204 
205             if (is&lt;SVGGeometryElement&gt;(shape.graphicsElement())) {
206                 double pathLength = downcast&lt;SVGGeometryElement&gt;(shape.graphicsElement()).pathLength();
207                 writeIfNotDefault(ts, &quot;path length&quot;, pathLength, 0.0);
208             }
209 
210             ts &lt;&lt; &quot;}]&quot;;
211         }
212 
213         if (RenderSVGResource* fillPaintingResource = RenderSVGResource::fillPaintingResource(const_cast&lt;RenderSVGShape&amp;&gt;(shape), shape.style(), fallbackColor)) {
214             TextStreamSeparator s(&quot; &quot;);
215             ts &lt;&lt; &quot; [fill={&quot; &lt;&lt; s;
216             writeSVGPaintingResource(ts, fillPaintingResource);
217 
218             writeIfNotDefault(ts, &quot;opacity&quot;, svgStyle.fillOpacity(), 1.0f);
219             writeIfNotDefault(ts, &quot;fill rule&quot;, svgStyle.fillRule(), WindRule::NonZero);
220             ts &lt;&lt; &quot;}]&quot;;
221         }
222         writeIfNotDefault(ts, &quot;clip rule&quot;, svgStyle.clipRule(), WindRule::NonZero);
223     }
224 
225     writeIfNotEmpty(ts, &quot;start marker&quot;, svgStyle.markerStartResource());
226     writeIfNotEmpty(ts, &quot;middle marker&quot;, svgStyle.markerMidResource());
227     writeIfNotEmpty(ts, &quot;end marker&quot;, svgStyle.markerEndResource());
228 }
229 
230 static TextStream&amp; writePositionAndStyle(TextStream&amp; ts, const RenderElement&amp; renderer, OptionSet&lt;RenderAsTextFlag&gt; behavior = { })
231 {
232     if (behavior.contains(RenderAsTextFlag::ShowSVGGeometry)) {
233         if (is&lt;RenderBox&gt;(renderer)) {
234             LayoutRect r = downcast&lt;RenderBox&gt;(renderer).frameRect();
235             ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(r);
236         }
237 
238         ts &lt;&lt; &quot; clipped&quot;;
239     }
240 
241     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(renderer.absoluteClippedOverflowRect());
242 
243     writeStyle(ts, renderer);
244     return ts;
245 }
246 
247 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderSVGShape&amp; shape)
248 {
249     writePositionAndStyle(ts, shape);
250 
251     SVGGraphicsElement&amp; svgElement = shape.graphicsElement();
252     SVGLengthContext lengthContext(&amp;svgElement);
253 
254     if (is&lt;SVGRectElement&gt;(svgElement)) {
255         const SVGRectElement&amp; element = downcast&lt;SVGRectElement&gt;(svgElement);
256         writeNameValuePair(ts, &quot;x&quot;, element.x().value(lengthContext));
257         writeNameValuePair(ts, &quot;y&quot;, element.y().value(lengthContext));
258         writeNameValuePair(ts, &quot;width&quot;, element.width().value(lengthContext));
259         writeNameValuePair(ts, &quot;height&quot;, element.height().value(lengthContext));
260     } else if (is&lt;SVGLineElement&gt;(svgElement)) {
261         const SVGLineElement&amp; element = downcast&lt;SVGLineElement&gt;(svgElement);
262         writeNameValuePair(ts, &quot;x1&quot;, element.x1().value(lengthContext));
263         writeNameValuePair(ts, &quot;y1&quot;, element.y1().value(lengthContext));
264         writeNameValuePair(ts, &quot;x2&quot;, element.x2().value(lengthContext));
265         writeNameValuePair(ts, &quot;y2&quot;, element.y2().value(lengthContext));
266     } else if (is&lt;SVGEllipseElement&gt;(svgElement)) {
267         const SVGEllipseElement&amp; element = downcast&lt;SVGEllipseElement&gt;(svgElement);
268         writeNameValuePair(ts, &quot;cx&quot;, element.cx().value(lengthContext));
269         writeNameValuePair(ts, &quot;cy&quot;, element.cy().value(lengthContext));
270         writeNameValuePair(ts, &quot;rx&quot;, element.rx().value(lengthContext));
271         writeNameValuePair(ts, &quot;ry&quot;, element.ry().value(lengthContext));
272     } else if (is&lt;SVGCircleElement&gt;(svgElement)) {
273         const SVGCircleElement&amp; element = downcast&lt;SVGCircleElement&gt;(svgElement);
274         writeNameValuePair(ts, &quot;cx&quot;, element.cx().value(lengthContext));
275         writeNameValuePair(ts, &quot;cy&quot;, element.cy().value(lengthContext));
276         writeNameValuePair(ts, &quot;r&quot;, element.r().value(lengthContext));
277     } else if (is&lt;SVGPolyElement&gt;(svgElement)) {
278         const SVGPolyElement&amp; element = downcast&lt;SVGPolyElement&gt;(svgElement);
279         writeNameAndQuotedValue(ts, &quot;points&quot;, element.points().valueAsString());
280     } else if (is&lt;SVGPathElement&gt;(svgElement)) {
281         const SVGPathElement&amp; element = downcast&lt;SVGPathElement&gt;(svgElement);
282         String pathString;
283         // FIXME: We should switch to UnalteredParsing here - this will affect the path dumping output of dozens of tests.
284         buildStringFromByteStream(element.pathByteStream(), pathString, NormalizedParsing);
285         writeNameAndQuotedValue(ts, &quot;data&quot;, pathString);
286     } else
287         ASSERT_NOT_REACHED();
288     return ts;
289 }
290 
291 static void writeRenderSVGTextBox(TextStream&amp; ts, const RenderSVGText&amp; text)
292 {
293     auto* box = downcast&lt;SVGRootInlineBox&gt;(text.firstRootBox());
294     if (!box)
295         return;
296 
297     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(FloatRect(text.location(), FloatSize(box-&gt;logicalWidth(), box-&gt;logicalHeight())));
298 
299     // FIXME: Remove this hack, once the new text layout engine is completly landed. We want to preserve the old layout test results for now.
300     ts &lt;&lt; &quot; contains 1 chunk(s)&quot;;
301 
302     if (text.parent() &amp;&amp; (text.parent()-&gt;style().visitedDependentColor(CSSPropertyColor) != text.style().visitedDependentColor(CSSPropertyColor)))
303         writeNameValuePair(ts, &quot;color&quot;, text.style().visitedDependentColor(CSSPropertyColor).nameForRenderTreeAsText());
304 }
305 
306 static inline void writeSVGInlineTextBox(TextStream&amp; ts, SVGInlineTextBox* textBox)
307 {
308     Vector&lt;SVGTextFragment&gt;&amp; fragments = textBox-&gt;textFragments();
309     if (fragments.isEmpty())
310         return;
311 
312     const SVGRenderStyle&amp; svgStyle = textBox-&gt;renderer().style().svgStyle();
313     String text = textBox-&gt;renderer().text();
314 
315     TextStream::IndentScope indentScope(ts);
316 
317     unsigned fragmentsSize = fragments.size();
318     for (unsigned i = 0; i &lt; fragmentsSize; ++i) {
319         SVGTextFragment&amp; fragment = fragments.at(i);
320         ts &lt;&lt; indent;
321 
322         unsigned startOffset = fragment.characterOffset;
323         unsigned endOffset = fragment.characterOffset + fragment.length;
324 
325         // FIXME: Remove this hack, once the new text layout engine is completly landed. We want to preserve the old layout test results for now.
326         ts &lt;&lt; &quot;chunk 1 &quot;;
327         TextAnchor anchor = svgStyle.textAnchor();
328         bool isVerticalText = textBox-&gt;renderer().style().isVerticalWritingMode();
329         if (anchor == TextAnchor::Middle) {
330             ts &lt;&lt; &quot;(middle anchor&quot;;
331             if (isVerticalText)
332                 ts &lt;&lt; &quot;, vertical&quot;;
333             ts &lt;&lt; &quot;) &quot;;
334         } else if (anchor == TextAnchor::End) {
335             ts &lt;&lt; &quot;(end anchor&quot;;
336             if (isVerticalText)
337                 ts &lt;&lt; &quot;, vertical&quot;;
338             ts &lt;&lt; &quot;) &quot;;
339         } else if (isVerticalText)
340             ts &lt;&lt; &quot;(vertical) &quot;;
341         startOffset -= textBox-&gt;start();
342         endOffset -= textBox-&gt;start();
343         // &lt;/hack&gt;
344 
345         ts &lt;&lt; &quot;text run &quot; &lt;&lt; i + 1 &lt;&lt; &quot; at (&quot; &lt;&lt; fragment.x &lt;&lt; &quot;,&quot; &lt;&lt; fragment.y &lt;&lt; &quot;)&quot;;
346         ts &lt;&lt; &quot; startOffset &quot; &lt;&lt; startOffset &lt;&lt; &quot; endOffset &quot; &lt;&lt; endOffset;
347         if (isVerticalText)
348             ts &lt;&lt; &quot; height &quot; &lt;&lt; fragment.height;
349         else
350             ts &lt;&lt; &quot; width &quot; &lt;&lt; fragment.width;
351 
352         if (!textBox-&gt;isLeftToRightDirection() || textBox-&gt;dirOverride()) {
353             ts &lt;&lt; (textBox-&gt;isLeftToRightDirection() ? &quot; LTR&quot; : &quot; RTL&quot;);
354             if (textBox-&gt;dirOverride())
355                 ts &lt;&lt; &quot; override&quot;;
356         }
357 
358         ts &lt;&lt; &quot;: &quot; &lt;&lt; quoteAndEscapeNonPrintables(text.substring(fragment.characterOffset, fragment.length)) &lt;&lt; &quot;\n&quot;;
359     }
360 }
361 
362 static inline void writeSVGInlineTextBoxes(TextStream&amp; ts, const RenderText&amp; text)
363 {
364     for (InlineTextBox* box = text.firstTextBox(); box; box = box-&gt;nextTextBox()) {
365         if (!is&lt;SVGInlineTextBox&gt;(*box))
366             continue;
367 
368         writeSVGInlineTextBox(ts, downcast&lt;SVGInlineTextBox&gt;(box));
369     }
370 }
371 
372 enum class WriteIndentOrNot {
373     No,
374     Yes
375 };
376 
377 static void writeStandardPrefix(TextStream&amp; ts, const RenderObject&amp; object, OptionSet&lt;RenderAsTextFlag&gt; behavior, WriteIndentOrNot writeIndent = WriteIndentOrNot::Yes)
378 {
379     if (writeIndent == WriteIndentOrNot::Yes)
380         ts &lt;&lt; indent;
381 
382     ts &lt;&lt; object.renderName();
383 
384     if (behavior.contains(RenderAsTextFlag::ShowAddresses))
385         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;object);
386 
387     if (object.node())
388         ts &lt;&lt; &quot; {&quot; &lt;&lt; object.node()-&gt;nodeName() &lt;&lt; &quot;}&quot;;
389 
390     writeDebugInfo(ts, object, behavior);
391 }
392 
393 static void writeChildren(TextStream&amp; ts, const RenderElement&amp; parent, OptionSet&lt;RenderAsTextFlag&gt; behavior)
394 {
395     TextStream::IndentScope indentScope(ts);
396 
397     for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(parent))
398         write(ts, child, behavior);
399 }
400 
401 static inline void writeCommonGradientProperties(TextStream&amp; ts, SVGSpreadMethodType spreadMethod, const AffineTransform&amp; gradientTransform, SVGUnitTypes::SVGUnitType gradientUnits)
402 {
403     writeNameValuePair(ts, &quot;gradientUnits&quot;, gradientUnits);
404 
405     if (spreadMethod != SVGSpreadMethodPad)
406         ts &lt;&lt; &quot; [spreadMethod=&quot; &lt;&lt; spreadMethod &lt;&lt; &quot;]&quot;;
407 
408     if (!gradientTransform.isIdentity())
409         ts &lt;&lt; &quot; [gradientTransform=&quot; &lt;&lt; gradientTransform &lt;&lt; &quot;]&quot;;
410 }
411 
412 void writeSVGResourceContainer(TextStream&amp; ts, const RenderSVGResourceContainer&amp; resource, OptionSet&lt;RenderAsTextFlag&gt; behavior)
413 {
414     writeStandardPrefix(ts, resource, behavior);
415 
416     const AtomString&amp; id = resource.element().getIdAttribute();
417     writeNameAndQuotedValue(ts, &quot;id&quot;, id);
418 
419     if (resource.resourceType() == MaskerResourceType) {
420         const auto&amp; masker = static_cast&lt;const RenderSVGResourceMasker&amp;&gt;(resource);
421         writeNameValuePair(ts, &quot;maskUnits&quot;, masker.maskUnits());
422         writeNameValuePair(ts, &quot;maskContentUnits&quot;, masker.maskContentUnits());
423         ts &lt;&lt; &quot;\n&quot;;
424     } else if (resource.resourceType() == FilterResourceType) {
425         const auto&amp; filter = static_cast&lt;const RenderSVGResourceFilter&amp;&gt;(resource);
426         writeNameValuePair(ts, &quot;filterUnits&quot;, filter.filterUnits());
427         writeNameValuePair(ts, &quot;primitiveUnits&quot;, filter.primitiveUnits());
428         ts &lt;&lt; &quot;\n&quot;;
429         // Creating a placeholder filter which is passed to the builder.
430         FloatRect dummyRect;
431         auto dummyFilter = SVGFilter::create(AffineTransform(), dummyRect, dummyRect, dummyRect, true);
432         if (auto builder = filter.buildPrimitives(dummyFilter.get())) {
433             TextStream::IndentScope indentScope(ts);
434 
435             if (FilterEffect* lastEffect = builder-&gt;lastEffect())
436                 lastEffect-&gt;externalRepresentation(ts);
437         }
438     } else if (resource.resourceType() == ClipperResourceType) {
439         const auto&amp; clipper = static_cast&lt;const RenderSVGResourceClipper&amp;&gt;(resource);
440         writeNameValuePair(ts, &quot;clipPathUnits&quot;, clipper.clipPathUnits());
441         ts &lt;&lt; &quot;\n&quot;;
442     } else if (resource.resourceType() == MarkerResourceType) {
443         const auto&amp; marker = static_cast&lt;const RenderSVGResourceMarker&amp;&gt;(resource);
444         writeNameValuePair(ts, &quot;markerUnits&quot;, marker.markerUnits());
445         ts &lt;&lt; &quot; [ref at &quot; &lt;&lt; marker.referencePoint() &lt;&lt; &quot;]&quot;;
446         ts &lt;&lt; &quot; [angle=&quot;;
447         if (marker.angle() == -1)
448             ts &lt;&lt; &quot;auto&quot; &lt;&lt; &quot;]\n&quot;;
449         else
450             ts &lt;&lt; marker.angle() &lt;&lt; &quot;]\n&quot;;
451     } else if (resource.resourceType() == PatternResourceType) {
452         const auto&amp; pattern = static_cast&lt;const RenderSVGResourcePattern&amp;&gt;(resource);
453 
454         // Dump final results that are used for rendering. No use in asking SVGPatternElement for its patternUnits(), as it may
455         // link to other patterns using xlink:href, we need to build the full inheritance chain, aka. collectPatternProperties()
456         PatternAttributes attributes;
457         pattern.collectPatternAttributes(attributes);
458 
459         writeNameValuePair(ts, &quot;patternUnits&quot;, attributes.patternUnits());
460         writeNameValuePair(ts, &quot;patternContentUnits&quot;, attributes.patternContentUnits());
461 
462         AffineTransform transform = attributes.patternTransform();
463         if (!transform.isIdentity())
464             ts &lt;&lt; &quot; [patternTransform=&quot; &lt;&lt; transform &lt;&lt; &quot;]&quot;;
465         ts &lt;&lt; &quot;\n&quot;;
466     } else if (resource.resourceType() == LinearGradientResourceType) {
467         const auto&amp; gradient = static_cast&lt;const RenderSVGResourceLinearGradient&amp;&gt;(resource);
468 
469         // Dump final results that are used for rendering. No use in asking SVGGradientElement for its gradientUnits(), as it may
470         // link to other gradients using xlink:href, we need to build the full inheritance chain, aka. collectGradientProperties()
471         LinearGradientAttributes attributes;
472         gradient.linearGradientElement().collectGradientAttributes(attributes);
473         writeCommonGradientProperties(ts, attributes.spreadMethod(), attributes.gradientTransform(), attributes.gradientUnits());
474 
475         ts &lt;&lt; &quot; [start=&quot; &lt;&lt; gradient.startPoint(attributes) &lt;&lt; &quot;] [end=&quot; &lt;&lt; gradient.endPoint(attributes) &lt;&lt; &quot;]\n&quot;;
476     }  else if (resource.resourceType() == RadialGradientResourceType) {
477         const auto&amp; gradient = static_cast&lt;const RenderSVGResourceRadialGradient&amp;&gt;(resource);
478 
479         // Dump final results that are used for rendering. No use in asking SVGGradientElement for its gradientUnits(), as it may
480         // link to other gradients using xlink:href, we need to build the full inheritance chain, aka. collectGradientProperties()
481         RadialGradientAttributes attributes;
482         gradient.radialGradientElement().collectGradientAttributes(attributes);
483         writeCommonGradientProperties(ts, attributes.spreadMethod(), attributes.gradientTransform(), attributes.gradientUnits());
484 
485         FloatPoint focalPoint = gradient.focalPoint(attributes);
486         FloatPoint centerPoint = gradient.centerPoint(attributes);
487         float radius = gradient.radius(attributes);
488         float focalRadius = gradient.focalRadius(attributes);
489 
490         ts &lt;&lt; &quot; [center=&quot; &lt;&lt; centerPoint &lt;&lt; &quot;] [focal=&quot; &lt;&lt; focalPoint &lt;&lt; &quot;] [radius=&quot; &lt;&lt; radius &lt;&lt; &quot;] [focalRadius=&quot; &lt;&lt; focalRadius &lt;&lt; &quot;]\n&quot;;
491     } else
492         ts &lt;&lt; &quot;\n&quot;;
493     writeChildren(ts, resource, behavior);
494 }
495 
496 void writeSVGContainer(TextStream&amp; ts, const RenderSVGContainer&amp; container, OptionSet&lt;RenderAsTextFlag&gt; behavior)
497 {
498     // Currently RenderSVGResourceFilterPrimitive has no meaningful output.
499     if (container.isSVGResourceFilterPrimitive())
500         return;
501     writeStandardPrefix(ts, container, behavior);
502     writePositionAndStyle(ts, container, behavior);
503     ts &lt;&lt; &quot;\n&quot;;
504     writeResources(ts, container, behavior);
505     writeChildren(ts, container, behavior);
506 }
507 
508 void write(TextStream&amp; ts, const RenderSVGRoot&amp; root, OptionSet&lt;RenderAsTextFlag&gt; behavior)
509 {
510     writeStandardPrefix(ts, root, behavior);
511     writePositionAndStyle(ts, root, behavior);
512     ts &lt;&lt; &quot;\n&quot;;
513     writeChildren(ts, root, behavior);
514 }
515 
516 void writeSVGText(TextStream&amp; ts, const RenderSVGText&amp; text, OptionSet&lt;RenderAsTextFlag&gt; behavior)
517 {
518     writeStandardPrefix(ts, text, behavior);
519     writeRenderSVGTextBox(ts, text);
520     ts &lt;&lt; &quot;\n&quot;;
521     writeResources(ts, text, behavior);
522     writeChildren(ts, text, behavior);
523 }
524 
525 void writeSVGInlineText(TextStream&amp; ts, const RenderSVGInlineText&amp; text, OptionSet&lt;RenderAsTextFlag&gt; behavior)
526 {
527     writeStandardPrefix(ts, text, behavior);
528     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(FloatRect(text.firstRunLocation(), text.floatLinesBoundingBox().size())) &lt;&lt; &quot;\n&quot;;
529     writeResources(ts, text, behavior);
530     writeSVGInlineTextBoxes(ts, text);
531 }
532 
533 void writeSVGImage(TextStream&amp; ts, const RenderSVGImage&amp; image, OptionSet&lt;RenderAsTextFlag&gt; behavior)
534 {
535     writeStandardPrefix(ts, image, behavior);
536     writePositionAndStyle(ts, image, behavior);
537     ts &lt;&lt; &quot;\n&quot;;
538     writeResources(ts, image, behavior);
539 }
540 
541 void write(TextStream&amp; ts, const RenderSVGShape&amp; shape, OptionSet&lt;RenderAsTextFlag&gt; behavior)
542 {
543     writeStandardPrefix(ts, shape, behavior);
544     ts &lt;&lt; shape &lt;&lt; &quot;\n&quot;;
545     writeResources(ts, shape, behavior);
546 }
547 
548 void writeSVGGradientStop(TextStream&amp; ts, const RenderSVGGradientStop&amp; stop, OptionSet&lt;RenderAsTextFlag&gt; behavior)
549 {
550     writeStandardPrefix(ts, stop, behavior);
551 
552     ts &lt;&lt; &quot; [offset=&quot; &lt;&lt; stop.element().offset() &lt;&lt; &quot;] [color=&quot; &lt;&lt; stop.element().stopColorIncludingOpacity() &lt;&lt; &quot;]\n&quot;;
553 }
554 
555 void writeResources(TextStream&amp; ts, const RenderObject&amp; renderer, OptionSet&lt;RenderAsTextFlag&gt; behavior)
556 {
557     const RenderStyle&amp; style = renderer.style();
558     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
559 
560     // FIXME: We want to use SVGResourcesCache to determine which resources are present, instead of quering the resource &lt;-&gt; id cache.
561     // For now leave the DRT output as is, but later on we should change this so cycles are properly ignored in the DRT output.
562     if (!svgStyle.maskerResource().isEmpty()) {
563         if (RenderSVGResourceMasker* masker = getRenderSVGResourceById&lt;RenderSVGResourceMasker&gt;(renderer.document(), svgStyle.maskerResource())) {
564             ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
565             writeNameAndQuotedValue(ts, &quot;masker&quot;, svgStyle.maskerResource());
566             ts &lt;&lt; &quot; &quot;;
567             writeStandardPrefix(ts, *masker, behavior, WriteIndentOrNot::No);
568             ts &lt;&lt; &quot; &quot; &lt;&lt; masker-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
569         }
570     }
571     if (style.clipPath() &amp;&amp; is&lt;ReferenceClipPathOperation&gt;(style.clipPath())) {
572         auto resourceClipPath = downcast&lt;ReferenceClipPathOperation&gt;(style.clipPath());
573         AtomString id = resourceClipPath-&gt;fragment();
574         if (RenderSVGResourceClipper* clipper = getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(renderer.document(), id)) {
575             ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
576             writeNameAndQuotedValue(ts, &quot;clipPath&quot;, resourceClipPath-&gt;fragment());
577             ts &lt;&lt; &quot; &quot;;
578             writeStandardPrefix(ts, *clipper, behavior, WriteIndentOrNot::No);
579             ts &lt;&lt; &quot; &quot; &lt;&lt; clipper-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
580         }
581     }
582     if (style.hasFilter()) {
583         const FilterOperations&amp; filterOperations = style.filter();
584         if (filterOperations.size() == 1) {
585             const FilterOperation&amp; filterOperation = *filterOperations.at(0);
586             if (filterOperation.type() == FilterOperation::REFERENCE) {
587                 const auto&amp; referenceFilterOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
588                 AtomString id = SVGURIReference::fragmentIdentifierFromIRIString(referenceFilterOperation.url(), renderer.document());
589                 if (RenderSVGResourceFilter* filter = getRenderSVGResourceById&lt;RenderSVGResourceFilter&gt;(renderer.document(), id)) {
590                     ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
591                     writeNameAndQuotedValue(ts, &quot;filter&quot;, id);
592                     ts &lt;&lt; &quot; &quot;;
593                     writeStandardPrefix(ts, *filter, behavior, WriteIndentOrNot::No);
594                     ts &lt;&lt; &quot; &quot; &lt;&lt; filter-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
595                 }
596             }
597         }
598     }
599 }
600 
601 } // namespace WebCore
    </pre>
  </body>
</html>
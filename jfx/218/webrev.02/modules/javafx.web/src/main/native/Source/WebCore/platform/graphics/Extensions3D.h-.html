<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Extensions3D.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef Extensions3D_h
 27 #define Extensions3D_h
 28 
 29 #include &quot;GraphicsTypes3D.h&quot;
 30 
 31 #include &lt;wtf/text/WTFString.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 // This is a base class containing only pure virtual functions.
 36 // Implementations must provide a subclass.
 37 //
 38 // The supported extensions are defined below and in subclasses,
 39 // possibly platform-specific ones.
 40 //
 41 // Calling any extension function not supported by the current context
 42 // must be a no-op; in particular, it may not have side effects. In
 43 // this situation, if the function has a return value, 0 is returned.
 44 class Extensions3D {
 45 public:
 46     virtual ~Extensions3D() = default;
 47 
 48     // Supported extensions:
 49     //   GL_EXT_texture_format_BGRA8888
 50     //   GL_EXT_read_format_bgra
 51     //   GL_ARB_robustness
 52     //   GL_ARB_texture_non_power_of_two / GL_OES_texture_npot
 53     //   GL_EXT_packed_depth_stencil / GL_OES_packed_depth_stencil
 54     //   GL_ANGLE_framebuffer_blit / GL_ANGLE_framebuffer_multisample
 55     //   GL_IMG_multisampled_render_to_texture
 56     //   GL_OES_texture_float
 57     //   GL_OES_texture_float_linear
 58     //   GL_OES_texture_half_float
 59     //   GL_OES_texture_half_float_linear
 60     //   GL_OES_standard_derivatives
 61     //   GL_OES_rgb8_rgba8
 62     //   GL_OES_vertex_array_object
 63     //   GL_OES_element_index_uint
 64     //   GL_ANGLE_translated_shader_source
 65     //   GL_ARB_texture_rectangle (only the subset required to
 66     //     implement IOSurface binding; it&#39;s recommended to support
 67     //     this only on Mac OS X to limit the amount of code dependent
 68     //     on this extension)
 69     //   GL_EXT_texture_compression_dxt1
 70     //   GL_EXT_texture_compression_s3tc
 71     //   GL_OES_compressed_ETC1_RGB8_texture
 72     //   GL_IMG_texture_compression_pvrtc
 73     //   GL_KHR_texture_compression_astc_hdr
 74     //   GL_KHR_texture_compression_astc_ldr
 75     //   EXT_texture_filter_anisotropic
 76     //   GL_EXT_debug_marker
 77     //   GL_ARB_draw_buffers / GL_EXT_draw_buffers
 78     //   GL_ANGLE_instanced_arrays
 79 
 80     // Takes full name of extension; for example,
 81     // &quot;GL_EXT_texture_format_BGRA8888&quot;.
 82     virtual bool supports(const String&amp;) = 0;
 83 
 84     // Certain OpenGL and WebGL implementations may support enabling
 85     // extensions lazily. This method may only be called with
 86     // extension names for which supports returns true.
 87     virtual void ensureEnabled(const String&amp;) = 0;
 88 
 89     // Takes full name of extension: for example, &quot;GL_EXT_texture_format_BGRA8888&quot;.
 90     // Checks to see whether the given extension is actually enabled (see ensureEnabled).
 91     // Has no other side-effects.
 92     virtual bool isEnabled(const String&amp;) = 0;
 93 
 94     enum ExtensionsEnumType {
 95         // EXT_sRGB formats
 96         SRGB_EXT = 0x8C40,
 97         SRGB_ALPHA_EXT = 0x8C42,
 98         SRGB8_ALPHA8_EXT = 0x8C43,
 99         FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x8210,
100 
101         // EXT_blend_minmax enums
102         MIN_EXT = 0x8007,
103         MAX_EXT = 0x8008,
104 
105         // GL_EXT_texture_format_BGRA8888 enums
106         BGRA_EXT = 0x80E1,
107 
108         // GL_ARB_robustness enums
109         GUILTY_CONTEXT_RESET_ARB = 0x8253,
110         INNOCENT_CONTEXT_RESET_ARB = 0x8254,
111         UNKNOWN_CONTEXT_RESET_ARB = 0x8255,
112         CONTEXT_ROBUST_ACCESS = 0x90F3,
113 
114         // GL_EXT/OES_packed_depth_stencil enums
115         DEPTH24_STENCIL8 = 0x88F0,
116 
117         // GL_ANGLE_framebuffer_blit names
118         READ_FRAMEBUFFER = 0x8CA8,
119         DRAW_FRAMEBUFFER = 0x8CA9,
120         DRAW_FRAMEBUFFER_BINDING = 0x8CA6,
121         READ_FRAMEBUFFER_BINDING = 0x8CAA,
122 
123         // GL_ANGLE_framebuffer_multisample names
124         RENDERBUFFER_SAMPLES = 0x8CAB,
125         FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56,
126         MAX_SAMPLES = 0x8D57,
127 
128         // GL_IMG_multisampled_render_to_texture
129         RENDERBUFFER_SAMPLES_IMG = 0x9133,
130         FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = 0x9134,
131         MAX_SAMPLES_IMG = 0x9135,
132         TEXTURE_SAMPLES_IMG = 0x9136,
133 
134         // GL_OES_standard_derivatives names
135         FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B,
136 
137         // GL_OES_rgb8_rgba8 names
138         RGB8_OES = 0x8051,
139         RGBA8_OES = 0x8058,
140 
141         // GL_OES_vertex_array_object names
142         VERTEX_ARRAY_BINDING_OES = 0x85B5,
143 
144         // GL_ANGLE_translated_shader_source
145         TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = 0x93A0,
146 
147         // GL_ARB_texture_rectangle
148         TEXTURE_RECTANGLE_ARB =  0x84F5,
149         TEXTURE_BINDING_RECTANGLE_ARB = 0x84F6,
150 
151         // GL_EXT_texture_compression_dxt1
152         // GL_EXT_texture_compression_s3tc
153         COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0,
154         COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1,
155         COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2,
156         COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3,
157 
158         // GL_OES_compressed_ETC1_RGB8_texture
159         ETC1_RGB8_OES = 0x8D64,
160 
161         // GL_IMG_texture_compression_pvrtc
162         COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00,
163         COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01,
164         COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02,
165         COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03,
166 
167         // GL_AMD_compressed_ATC_texture
168         COMPRESSED_ATC_RGB_AMD = 0x8C92,
169         COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD = 0x8C93,
170         COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD = 0x87EE,
171 
172         // GL_KHR_texture_compression_astc_hdr
173         COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0,
174         COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1,
175         COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2,
176         COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3,
177         COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4,
178         COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5,
179         COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6,
180         COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7,
181         COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8,
182         COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9,
183         COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA,
184         COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB,
185         COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC,
186         COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD,
187 
188         COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0,
189         COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1,
190         COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2,
191         COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3,
192         COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4,
193         COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5,
194         COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6,
195         COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7,
196         COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8,
197         COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9,
198         COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA,
199         COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB,
200         COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC,
201         COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD,
202 
203         // GL_EXT_texture_filter_anisotropic
204         TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE,
205         MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF,
206 
207         // GL_ARB_draw_buffers / GL_EXT_draw_buffers
208         MAX_DRAW_BUFFERS_EXT = 0x8824,
209         DRAW_BUFFER0_EXT = 0x8825,
210         DRAW_BUFFER1_EXT = 0x8826,
211         DRAW_BUFFER2_EXT = 0x8827,
212         DRAW_BUFFER3_EXT = 0x8828,
213         DRAW_BUFFER4_EXT = 0x8829,
214         DRAW_BUFFER5_EXT = 0x882A,
215         DRAW_BUFFER6_EXT = 0x882B,
216         DRAW_BUFFER7_EXT = 0x882C,
217         DRAW_BUFFER8_EXT = 0x882D,
218         DRAW_BUFFER9_EXT = 0x882E,
219         DRAW_BUFFER10_EXT = 0x882F,
220         DRAW_BUFFER11_EXT = 0x8830,
221         DRAW_BUFFER12_EXT = 0x8831,
222         DRAW_BUFFER13_EXT = 0x8832,
223         DRAW_BUFFER14_EXT = 0x8833,
224         DRAW_BUFFER15_EXT = 0x8834,
225         MAX_COLOR_ATTACHMENTS_EXT = 0x8CDF,
226         COLOR_ATTACHMENT0_EXT = 0x8CE0,
227         COLOR_ATTACHMENT1_EXT = 0x8CE1,
228         COLOR_ATTACHMENT2_EXT = 0x8CE2,
229         COLOR_ATTACHMENT3_EXT = 0x8CE3,
230         COLOR_ATTACHMENT4_EXT = 0x8CE4,
231         COLOR_ATTACHMENT5_EXT = 0x8CE5,
232         COLOR_ATTACHMENT6_EXT = 0x8CE6,
233         COLOR_ATTACHMENT7_EXT = 0x8CE7,
234         COLOR_ATTACHMENT8_EXT = 0x8CE8,
235         COLOR_ATTACHMENT9_EXT = 0x8CE9,
236         COLOR_ATTACHMENT10_EXT = 0x8CEA,
237         COLOR_ATTACHMENT11_EXT = 0x8CEB,
238         COLOR_ATTACHMENT12_EXT = 0x8CEC,
239         COLOR_ATTACHMENT13_EXT = 0x8CED,
240         COLOR_ATTACHMENT14_EXT = 0x8CEE,
241         COLOR_ATTACHMENT15_EXT = 0x8CEF
242     };
243 
244     // GL_ARB_robustness
245     // Note: This method&#39;s behavior differs from the GL_ARB_robustness
246     // specification in the following way:
247     // The implementation must not reset the error state during this call.
248     // If getGraphicsResetStatusARB returns an error, it should continue
249     // returning the same error. Restoring the GraphicsContext3D is handled
250     // externally.
251     virtual int getGraphicsResetStatusARB() = 0;
252 
253     // GL_ANGLE_framebuffer_blit
254     virtual void blitFramebuffer(long srcX0, long srcY0, long srcX1, long srcY1, long dstX0, long dstY0, long dstX1, long dstY1, unsigned long mask, unsigned long filter) = 0;
255 
256     // GL_ANGLE_framebuffer_multisample
257     virtual void renderbufferStorageMultisample(unsigned long target, unsigned long samples, unsigned long internalformat, unsigned long width, unsigned long height) = 0;
258 
259     // GL_OES_vertex_array_object
260     virtual Platform3DObject createVertexArrayOES() = 0;
261     virtual void deleteVertexArrayOES(Platform3DObject) = 0;
262     virtual GC3Dboolean isVertexArrayOES(Platform3DObject) = 0;
263     virtual void bindVertexArrayOES(Platform3DObject) = 0;
264 
265     // GL_ANGLE_translated_shader_source
266     virtual String getTranslatedShaderSourceANGLE(Platform3DObject) = 0;
267 
268     // EXT Robustness - uses getGraphicsResetStatusARB
269     virtual void readnPixelsEXT(int x, int y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, GC3Dsizei bufSize, void *data) = 0;
270     virtual void getnUniformfvEXT(GC3Duint program, int location, GC3Dsizei bufSize, float *params) = 0;
271     virtual void getnUniformivEXT(GC3Duint program, int location, GC3Dsizei bufSize, int *params) = 0;
272 
273     // GL_EXT_debug_marker
274     virtual void insertEventMarkerEXT(const String&amp;) = 0;
275     virtual void pushGroupMarkerEXT(const String&amp;) = 0;
276     virtual void popGroupMarkerEXT(void) = 0;
277 
278     // GL_ARB_draw_buffers / GL_EXT_draw_buffers
279     virtual void drawBuffersEXT(GC3Dsizei n, const GC3Denum* bufs) = 0;
280 
281     // GL_ANGLE_instanced_arrays
282     virtual void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount) = 0;
283     virtual void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount) = 0;
284     virtual void vertexAttribDivisor(GC3Duint index, GC3Duint divisor) = 0;
285 
286     virtual bool isNVIDIA() = 0;
287     virtual bool isAMD() = 0;
288     virtual bool isIntel() = 0;
289     virtual bool isImagination() = 0;
290     virtual String vendor() = 0;
291 
292     // Some configurations have bugs regarding built-in functions in their OpenGL drivers
293     // that must be avoided. Ports should implement these flags on such configurations.
294     virtual bool requiresBuiltInFunctionEmulation() = 0;
295     virtual bool requiresRestrictedMaximumTextureSize() = 0;
296 
297 };
298 
299 } // namespace WebCore
300 
301 #endif // Extensions3D_h
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTransformDistance.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGTransform.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGTransformList.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTransformDistance.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;SVGTransformDistance.h&quot;
 22 
 23 #include &quot;FloatConversion.h&quot;
 24 #include &quot;FloatPoint.h&quot;
 25 #include &quot;FloatSize.h&quot;
 26 #include &quot;SVGTransformValue.h&quot;
 27 
 28 #include &lt;math.h&gt;
 29 




 30 namespace WebCore {
 31 
 32 SVGTransformDistance::SVGTransformDistance()
 33     : m_type(SVGTransformValue::SVG_TRANSFORM_UNKNOWN)
 34     , m_angle(0)
 35     , m_cx(0)
 36     , m_cy(0)
 37 {
 38 }
 39 
 40 SVGTransformDistance::SVGTransformDistance(SVGTransformValue::SVGTransformType type, float angle, float cx, float cy, const AffineTransform&amp; transform)
 41     : m_type(type)
 42     , m_angle(angle)
 43     , m_cx(cx)
 44     , m_cy(cy)
 45     , m_transform(transform)
 46 {
 47 }
 48 
 49 SVGTransformDistance::SVGTransformDistance(const SVGTransformValue&amp; fromSVGTransform, const SVGTransformValue&amp; toSVGTransform)
 50     : m_type(fromSVGTransform.type())
 51     , m_angle(0)
 52     , m_cx(0)
 53     , m_cy(0)
 54 {
 55     ASSERT(m_type == toSVGTransform.type());
 56 
 57     switch (m_type) {
 58     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
 59         ASSERT_NOT_REACHED();
<span class="line-modified"> 60 #if ASSERT_DISABLED</span>
 61         FALLTHROUGH;
 62 #endif
 63     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
 64         break;
 65     case SVGTransformValue::SVG_TRANSFORM_ROTATE: {
 66         FloatSize centerDistance = toSVGTransform.rotationCenter() - fromSVGTransform.rotationCenter();
 67         m_angle = toSVGTransform.angle() - fromSVGTransform.angle();
 68         m_cx = centerDistance.width();
 69         m_cy = centerDistance.height();
 70         break;
 71     }
 72     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
 73         FloatSize translationDistance = toSVGTransform.translate() - fromSVGTransform.translate();
 74         m_transform.translate(translationDistance.width(), translationDistance.height());
 75         break;
 76     }
 77     case SVGTransformValue::SVG_TRANSFORM_SCALE: {
 78         float scaleX = toSVGTransform.scale().width() - fromSVGTransform.scale().width();
 79         float scaleY = toSVGTransform.scale().height() - fromSVGTransform.scale().height();
 80         m_transform.scaleNonUniform(scaleX, scaleY);
 81         break;
 82     }
 83     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
 84     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
 85         m_angle = toSVGTransform.angle() - fromSVGTransform.angle();
 86         break;
 87     }
 88 }
 89 
 90 SVGTransformDistance SVGTransformDistance::scaledDistance(float scaleFactor) const
 91 {
 92     switch (m_type) {
 93     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
 94         ASSERT_NOT_REACHED();
<span class="line-modified"> 95 #if ASSERT_DISABLED</span>
 96         FALLTHROUGH;
 97 #endif
 98     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
 99         return SVGTransformDistance();
100     case SVGTransformValue::SVG_TRANSFORM_ROTATE:
101         return SVGTransformDistance(m_type, m_angle * scaleFactor, m_cx * scaleFactor, m_cy * scaleFactor, AffineTransform());
102     case SVGTransformValue::SVG_TRANSFORM_SCALE:
103         return SVGTransformDistance(m_type, m_angle * scaleFactor, m_cx * scaleFactor, m_cy * scaleFactor, AffineTransform(m_transform).scale(scaleFactor));
104     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
105         AffineTransform newTransform(m_transform);
106         newTransform.setE(m_transform.e() * scaleFactor);
107         newTransform.setF(m_transform.f() * scaleFactor);
108         return SVGTransformDistance(m_type, 0, 0, 0, newTransform);
109     }
110     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
111     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
112         return SVGTransformDistance(m_type, m_angle * scaleFactor, m_cx * scaleFactor, m_cy * scaleFactor, AffineTransform());
113     }
114 
115     ASSERT_NOT_REACHED();
116     return SVGTransformDistance();
117 }
118 
119 SVGTransformValue SVGTransformDistance::addSVGTransforms(const SVGTransformValue&amp; first, const SVGTransformValue&amp; second, unsigned repeatCount)
120 {
121     ASSERT(first.type() == second.type());
122 
123     SVGTransformValue transform;
124 
125     switch (first.type()) {
126     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
127         ASSERT_NOT_REACHED();
<span class="line-modified">128 #if ASSERT_DISABLED</span>
129         FALLTHROUGH;
130 #endif
131     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
132         return { };
133     case SVGTransformValue::SVG_TRANSFORM_ROTATE: {
134         transform.setRotate(first.angle() + second.angle() * repeatCount, first.rotationCenter().x() + second.rotationCenter().x() * repeatCount, first.rotationCenter().y() + second.rotationCenter().y() * repeatCount);
135         return transform;
136     }
137     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
138         float dx = first.translate().x() + second.translate().x() * repeatCount;
139         float dy = first.translate().y() + second.translate().y() * repeatCount;
140         transform.setTranslate(dx, dy);
141         return transform;
142     }
143     case SVGTransformValue::SVG_TRANSFORM_SCALE: {
144         FloatSize scale = second.scale();
145         scale.scale(repeatCount);
146         scale += first.scale();
147         transform.setScale(scale.width(), scale.height());
148         return transform;
</pre>
<hr />
<pre>
150     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
151         transform.setSkewX(first.angle() + second.angle() * repeatCount);
152         return transform;
153     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
154         transform.setSkewY(first.angle() + second.angle() * repeatCount);
155         return transform;
156     }
157     ASSERT_NOT_REACHED();
158     return { };
159 }
160 
161 SVGTransformValue SVGTransformDistance::addToSVGTransform(const SVGTransformValue&amp; transform) const
162 {
163     ASSERT(m_type == transform.type() || !transform.isValid());
164 
165     SVGTransformValue newTransform(transform);
166 
167     switch (m_type) {
168     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
169         ASSERT_NOT_REACHED();
<span class="line-modified">170 #if ASSERT_DISABLED</span>
171         FALLTHROUGH;
172 #endif
173     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
174         return { };
175     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
176         FloatPoint translation = transform.translate();
177         translation += FloatSize::narrowPrecision(m_transform.e(), m_transform.f());
178         newTransform.setTranslate(translation.x(), translation.y());
179         return newTransform;
180     }
181     case SVGTransformValue::SVG_TRANSFORM_SCALE: {
182         FloatSize scale = transform.scale();
183         scale += FloatSize::narrowPrecision(m_transform.a(), m_transform.d());
184         newTransform.setScale(scale.width(), scale.height());
185         return newTransform;
186     }
187     case SVGTransformValue::SVG_TRANSFORM_ROTATE: {
188         FloatPoint center = transform.rotationCenter();
189         newTransform.setRotate(transform.angle() + m_angle, center.x() + m_cx, center.y() + m_cy);
190         return newTransform;
</pre>
<hr />
<pre>
194         return newTransform;
195     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
196         newTransform.setSkewY(transform.angle() + m_angle);
197         return newTransform;
198     }
199 
200     ASSERT_NOT_REACHED();
201     return { };
202 }
203 
204 bool SVGTransformDistance::isZero() const
205 {
206     return m_transform.isIdentity() &amp;&amp; !m_angle;
207 }
208 
209 float SVGTransformDistance::distance() const
210 {
211     switch (m_type) {
212     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
213         ASSERT_NOT_REACHED();
<span class="line-modified">214 #if ASSERT_DISABLED</span>
215         FALLTHROUGH;
216 #endif
217     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
218         return 0;
219     case SVGTransformValue::SVG_TRANSFORM_ROTATE:
<span class="line-modified">220         return sqrtf(m_angle * m_angle + m_cx * m_cx + m_cy * m_cy);</span>




221     case SVGTransformValue::SVG_TRANSFORM_SCALE:
<span class="line-modified">222         return static_cast&lt;float&gt;(sqrt(m_transform.a() * m_transform.a() + m_transform.d() * m_transform.d()));</span>
223     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE:
<span class="line-modified">224         return static_cast&lt;float&gt;(sqrt(m_transform.e() * m_transform.e() + m_transform.f() * m_transform.f()));</span>
225     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
226     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
227         return m_angle;
228     }
229     ASSERT_NOT_REACHED();
230     return 0;
231 }
232 
233 }
</pre>
</td>
<td>
<hr />
<pre>
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;SVGTransformDistance.h&quot;
 22 
 23 #include &quot;FloatConversion.h&quot;
 24 #include &quot;FloatPoint.h&quot;
 25 #include &quot;FloatSize.h&quot;
 26 #include &quot;SVGTransformValue.h&quot;
 27 
 28 #include &lt;math.h&gt;
 29 
<span class="line-added"> 30 #if PLATFORM(JAVA)</span>
<span class="line-added"> 31 #include &lt;wtf/java/JavaMath.h&gt;</span>
<span class="line-added"> 32 #endif</span>
<span class="line-added"> 33 </span>
 34 namespace WebCore {
 35 
 36 SVGTransformDistance::SVGTransformDistance()
 37     : m_type(SVGTransformValue::SVG_TRANSFORM_UNKNOWN)
 38     , m_angle(0)
 39     , m_cx(0)
 40     , m_cy(0)
 41 {
 42 }
 43 
 44 SVGTransformDistance::SVGTransformDistance(SVGTransformValue::SVGTransformType type, float angle, float cx, float cy, const AffineTransform&amp; transform)
 45     : m_type(type)
 46     , m_angle(angle)
 47     , m_cx(cx)
 48     , m_cy(cy)
 49     , m_transform(transform)
 50 {
 51 }
 52 
 53 SVGTransformDistance::SVGTransformDistance(const SVGTransformValue&amp; fromSVGTransform, const SVGTransformValue&amp; toSVGTransform)
 54     : m_type(fromSVGTransform.type())
 55     , m_angle(0)
 56     , m_cx(0)
 57     , m_cy(0)
 58 {
 59     ASSERT(m_type == toSVGTransform.type());
 60 
 61     switch (m_type) {
 62     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
 63         ASSERT_NOT_REACHED();
<span class="line-modified"> 64 #if !ASSERT_ENABLED</span>
 65         FALLTHROUGH;
 66 #endif
 67     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
 68         break;
 69     case SVGTransformValue::SVG_TRANSFORM_ROTATE: {
 70         FloatSize centerDistance = toSVGTransform.rotationCenter() - fromSVGTransform.rotationCenter();
 71         m_angle = toSVGTransform.angle() - fromSVGTransform.angle();
 72         m_cx = centerDistance.width();
 73         m_cy = centerDistance.height();
 74         break;
 75     }
 76     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
 77         FloatSize translationDistance = toSVGTransform.translate() - fromSVGTransform.translate();
 78         m_transform.translate(translationDistance.width(), translationDistance.height());
 79         break;
 80     }
 81     case SVGTransformValue::SVG_TRANSFORM_SCALE: {
 82         float scaleX = toSVGTransform.scale().width() - fromSVGTransform.scale().width();
 83         float scaleY = toSVGTransform.scale().height() - fromSVGTransform.scale().height();
 84         m_transform.scaleNonUniform(scaleX, scaleY);
 85         break;
 86     }
 87     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
 88     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
 89         m_angle = toSVGTransform.angle() - fromSVGTransform.angle();
 90         break;
 91     }
 92 }
 93 
 94 SVGTransformDistance SVGTransformDistance::scaledDistance(float scaleFactor) const
 95 {
 96     switch (m_type) {
 97     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
 98         ASSERT_NOT_REACHED();
<span class="line-modified"> 99 #if !ASSERT_ENABLED</span>
100         FALLTHROUGH;
101 #endif
102     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
103         return SVGTransformDistance();
104     case SVGTransformValue::SVG_TRANSFORM_ROTATE:
105         return SVGTransformDistance(m_type, m_angle * scaleFactor, m_cx * scaleFactor, m_cy * scaleFactor, AffineTransform());
106     case SVGTransformValue::SVG_TRANSFORM_SCALE:
107         return SVGTransformDistance(m_type, m_angle * scaleFactor, m_cx * scaleFactor, m_cy * scaleFactor, AffineTransform(m_transform).scale(scaleFactor));
108     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
109         AffineTransform newTransform(m_transform);
110         newTransform.setE(m_transform.e() * scaleFactor);
111         newTransform.setF(m_transform.f() * scaleFactor);
112         return SVGTransformDistance(m_type, 0, 0, 0, newTransform);
113     }
114     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
115     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
116         return SVGTransformDistance(m_type, m_angle * scaleFactor, m_cx * scaleFactor, m_cy * scaleFactor, AffineTransform());
117     }
118 
119     ASSERT_NOT_REACHED();
120     return SVGTransformDistance();
121 }
122 
123 SVGTransformValue SVGTransformDistance::addSVGTransforms(const SVGTransformValue&amp; first, const SVGTransformValue&amp; second, unsigned repeatCount)
124 {
125     ASSERT(first.type() == second.type());
126 
127     SVGTransformValue transform;
128 
129     switch (first.type()) {
130     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
131         ASSERT_NOT_REACHED();
<span class="line-modified">132 #if !ASSERT_ENABLED</span>
133         FALLTHROUGH;
134 #endif
135     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
136         return { };
137     case SVGTransformValue::SVG_TRANSFORM_ROTATE: {
138         transform.setRotate(first.angle() + second.angle() * repeatCount, first.rotationCenter().x() + second.rotationCenter().x() * repeatCount, first.rotationCenter().y() + second.rotationCenter().y() * repeatCount);
139         return transform;
140     }
141     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
142         float dx = first.translate().x() + second.translate().x() * repeatCount;
143         float dy = first.translate().y() + second.translate().y() * repeatCount;
144         transform.setTranslate(dx, dy);
145         return transform;
146     }
147     case SVGTransformValue::SVG_TRANSFORM_SCALE: {
148         FloatSize scale = second.scale();
149         scale.scale(repeatCount);
150         scale += first.scale();
151         transform.setScale(scale.width(), scale.height());
152         return transform;
</pre>
<hr />
<pre>
154     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
155         transform.setSkewX(first.angle() + second.angle() * repeatCount);
156         return transform;
157     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
158         transform.setSkewY(first.angle() + second.angle() * repeatCount);
159         return transform;
160     }
161     ASSERT_NOT_REACHED();
162     return { };
163 }
164 
165 SVGTransformValue SVGTransformDistance::addToSVGTransform(const SVGTransformValue&amp; transform) const
166 {
167     ASSERT(m_type == transform.type() || !transform.isValid());
168 
169     SVGTransformValue newTransform(transform);
170 
171     switch (m_type) {
172     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
173         ASSERT_NOT_REACHED();
<span class="line-modified">174 #if !ASSERT_ENABLED</span>
175         FALLTHROUGH;
176 #endif
177     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
178         return { };
179     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE: {
180         FloatPoint translation = transform.translate();
181         translation += FloatSize::narrowPrecision(m_transform.e(), m_transform.f());
182         newTransform.setTranslate(translation.x(), translation.y());
183         return newTransform;
184     }
185     case SVGTransformValue::SVG_TRANSFORM_SCALE: {
186         FloatSize scale = transform.scale();
187         scale += FloatSize::narrowPrecision(m_transform.a(), m_transform.d());
188         newTransform.setScale(scale.width(), scale.height());
189         return newTransform;
190     }
191     case SVGTransformValue::SVG_TRANSFORM_ROTATE: {
192         FloatPoint center = transform.rotationCenter();
193         newTransform.setRotate(transform.angle() + m_angle, center.x() + m_cx, center.y() + m_cy);
194         return newTransform;
</pre>
<hr />
<pre>
198         return newTransform;
199     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
200         newTransform.setSkewY(transform.angle() + m_angle);
201         return newTransform;
202     }
203 
204     ASSERT_NOT_REACHED();
205     return { };
206 }
207 
208 bool SVGTransformDistance::isZero() const
209 {
210     return m_transform.isIdentity() &amp;&amp; !m_angle;
211 }
212 
213 float SVGTransformDistance::distance() const
214 {
215     switch (m_type) {
216     case SVGTransformValue::SVG_TRANSFORM_MATRIX:
217         ASSERT_NOT_REACHED();
<span class="line-modified">218 #if !ASSERT_ENABLED</span>
219         FALLTHROUGH;
220 #endif
221     case SVGTransformValue::SVG_TRANSFORM_UNKNOWN:
222         return 0;
223     case SVGTransformValue::SVG_TRANSFORM_ROTATE:
<span class="line-modified">224 #if PLATFORM(JAVA)</span>
<span class="line-added">225         return javamath::hypot(m_angle, m_cx, m_cy);</span>
<span class="line-added">226 #else</span>
<span class="line-added">227         return std::hypot(m_angle, m_cx, m_cy);</span>
<span class="line-added">228 #endif</span>
229     case SVGTransformValue::SVG_TRANSFORM_SCALE:
<span class="line-modified">230         return static_cast&lt;float&gt;(std::hypot(m_transform.a(), m_transform.d()));</span>
231     case SVGTransformValue::SVG_TRANSFORM_TRANSLATE:
<span class="line-modified">232         return static_cast&lt;float&gt;(std::hypot(m_transform.e(), m_transform.f()));</span>
233     case SVGTransformValue::SVG_TRANSFORM_SKEWX:
234     case SVGTransformValue::SVG_TRANSFORM_SKEWY:
235         return m_angle;
236     }
237     ASSERT_NOT_REACHED();
238     return 0;
239 }
240 
241 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGTransform.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGTransformList.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/css/FontFaceSet.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/FontFaceSet.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/FontFaceSet.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/FontFaceSet.cpp
@@ -24,14 +24,17 @@
  */
 
 #include "config.h"
 #include "FontFaceSet.h"
 
+#include "DOMPromiseProxy.h"
 #include "Document.h"
+#include "EventLoop.h"
 #include "FontFace.h"
 #include "FrameLoader.h"
 #include "JSDOMBinding.h"
+#include "JSDOMPromiseDeferred.h"
 #include "JSFontFace.h"
 #include "JSFontFaceSet.h"
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
@@ -53,27 +56,27 @@
 }
 
 FontFaceSet::FontFaceSet(Document& document, const Vector<RefPtr<FontFace>>& initialFaces)
     : ActiveDOMObject(document)
     , m_backing(CSSFontFaceSet::create())
-    , m_readyPromise(*this, &FontFaceSet::readyPromiseResolve)
+    , m_readyPromise(makeUniqueRef<ReadyPromise>(*this, &FontFaceSet::readyPromiseResolve))
 {
     m_backing->addClient(*this);
     for (auto& face : initialFaces)
         add(*face);
 }
 
 FontFaceSet::FontFaceSet(Document& document, CSSFontFaceSet& backing)
     : ActiveDOMObject(document)
     , m_backing(backing)
-    , m_readyPromise(*this, &FontFaceSet::readyPromiseResolve)
+    , m_readyPromise(makeUniqueRef<ReadyPromise>(*this, &FontFaceSet::readyPromiseResolve))
 {
     if (document.frame())
-        m_isFirstLayoutDone = document.frame()->loader().stateMachine().firstLayoutDone();
+        m_isDocumentLoaded = document.loadEventFinished() && !document.processingLoadEvent();
 
-    if (m_isFirstLayoutDone && !backing.hasActiveFontFaces())
-        m_readyPromise.resolve(*this);
+    if (m_isDocumentLoaded && !backing.hasActiveFontFaces())
+        m_readyPromise->resolve(*this);
 
     m_backing->addClient(*this);
 }
 
 FontFaceSet::~FontFaceSet()
@@ -92,11 +95,11 @@
         return nullptr;
     return m_target->backing()[m_index++].wrapper();
 }
 
 FontFaceSet::PendingPromise::PendingPromise(LoadPromise&& promise)
-    : promise(WTFMove(promise))
+    : promise(makeUniqueRef<LoadPromise>(WTFMove(promise)))
 {
 }
 
 FontFaceSet::PendingPromise::~PendingPromise() = default;
 
@@ -166,11 +169,11 @@
         ASSERT(face.get().existingWrapper());
         m_pendingPromises.add(face.get().existingWrapper(), Vector<Ref<PendingPromise>>()).iterator->value.append(pendingPromise.copyRef());
     }
 
     if (!waiting)
-        pendingPromise->promise.resolve(pendingPromise->faces);
+        pendingPromise->promise->resolve(pendingPromise->faces);
 }
 
 ExceptionOr<bool> FontFaceSet::check(const String& family, const String& text)
 {
     return m_backing->check(family, text);
@@ -186,58 +189,51 @@
     }
     ASSERT_NOT_REACHED();
     return LoadStatus::Loaded;
 }
 
-bool FontFaceSet::canSuspendForDocumentSuspension() const
-{
-    return m_backing->status() == CSSFontFaceSet::Status::Loaded;
-}
-
 void FontFaceSet::startedLoading()
 {
     // FIXME: Fire a "loading" event asynchronously.
 }
 
-void FontFaceSet::didFirstLayout()
+void FontFaceSet::documentDidFinishLoading()
 {
-    m_isFirstLayoutDone = true;
-    if (!m_backing->hasActiveFontFaces() && !m_readyPromise.isFulfilled())
-        m_readyPromise.resolve(*this);
+    m_isDocumentLoaded = true;
+    if (!m_backing->hasActiveFontFaces() && !m_readyPromise->isFulfilled())
+        m_readyPromise->resolve(*this);
 }
 
 void FontFaceSet::completedLoading()
 {
-    if (m_isFirstLayoutDone && !m_readyPromise.isFulfilled())
-        m_readyPromise.resolve(*this);
+    if (m_isDocumentLoaded && !m_readyPromise->isFulfilled())
+        m_readyPromise->resolve(*this);
 }
 
 void FontFaceSet::faceFinished(CSSFontFace& face, CSSFontFace::Status newStatus)
 {
     if (!face.existingWrapper())
         return;
 
-    auto iterator = m_pendingPromises.find(face.existingWrapper());
-    if (iterator == m_pendingPromises.end())
+    auto pendingPromises = m_pendingPromises.take(face.existingWrapper());
+    if (pendingPromises.isEmpty())
         return;
 
-    for (auto& pendingPromise : iterator->value) {
+    for (auto& pendingPromise : pendingPromises) {
         if (pendingPromise->hasReachedTerminalState)
             continue;
         if (newStatus == CSSFontFace::Status::Success) {
             if (pendingPromise->hasOneRef()) {
-                pendingPromise->promise.resolve(pendingPromise->faces);
+                pendingPromise->promise->resolve(pendingPromise->faces);
                 pendingPromise->hasReachedTerminalState = true;
             }
         } else {
             ASSERT(newStatus == CSSFontFace::Status::Failure);
-            pendingPromise->promise.reject(NetworkError);
+            pendingPromise->promise->reject(NetworkError);
             pendingPromise->hasReachedTerminalState = true;
         }
     }
-
-    m_pendingPromises.remove(iterator);
 }
 
 FontFaceSet& FontFaceSet::readyPromiseResolve()
 {
     return *this;

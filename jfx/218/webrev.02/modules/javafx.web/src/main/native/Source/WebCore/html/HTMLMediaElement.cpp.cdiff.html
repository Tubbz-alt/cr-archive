<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMarqueeElement.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,12 ***</span>
<span class="line-new-header">--- 70,14 ---</span>
  #include &quot;MediaList.h&quot;
  #include &quot;MediaPlayer.h&quot;
  #include &quot;MediaQueryEvaluator.h&quot;
  #include &quot;MediaResourceLoader.h&quot;
  #include &quot;NetworkingContext.h&quot;
<span class="line-added">+ #include &quot;PODIntervalTree.h&quot;</span>
  #include &quot;Page.h&quot;
  #include &quot;PageGroup.h&quot;
<span class="line-added">+ #include &quot;PictureInPictureSupport.h&quot;</span>
  #include &quot;PlatformMediaSessionManager.h&quot;
  #include &quot;ProgressTracker.h&quot;
  #include &quot;Quirks.h&quot;
  #include &quot;RegistrableDomain.h&quot;
  #include &quot;RenderLayerCompositor.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,10 ***</span>
<span class="line-new-header">--- 129,11 ---</span>
  #include &quot;RuntimeApplicationChecks.h&quot;
  #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-added">+ #include &quot;RemotePlayback.h&quot;</span>
  #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
  #endif
  
  #if ENABLE(MEDIA_SESSION)
  #include &quot;MediaSession.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,34 ***</span>
      static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithoutUserGesture) == 3, &quot;AutoplayEventPlaybackState::StartedWithoutUserGesture is not 3 as expected&quot;);
      ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
      return values[static_cast&lt;size_t&gt;(enumerationValue)];
  }
  
<span class="line-removed">- typedef HashMap&lt;Document*, HashSet&lt;HTMLMediaElement*&gt;&gt; DocumentElementSetMap;</span>
<span class="line-removed">- static DocumentElementSetMap&amp; documentToElementSetMap()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static NeverDestroyed&lt;DocumentElementSetMap&gt; map;</span>
<span class="line-removed">-     return map;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void addElementToDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     DocumentElementSetMap&amp; map = documentToElementSetMap();</span>
<span class="line-removed">-     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);</span>
<span class="line-removed">-     set.add(&amp;element);</span>
<span class="line-removed">-     map.add(&amp;document, set);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void removeElementFromDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     DocumentElementSetMap&amp; map = documentToElementSetMap();</span>
<span class="line-removed">-     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);</span>
<span class="line-removed">-     set.remove(&amp;element);</span>
<span class="line-removed">-     if (!set.isEmpty())</span>
<span class="line-removed">-         map.add(&amp;document, set);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #if ENABLE(VIDEO_TRACK)
  
  class TrackDisplayUpdateScope {
  public:
      TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
<span class="line-new-header">--- 272,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,11 ***</span>
  
  private:
      HTMLMediaElement&amp; m_element;
  };
  
<span class="line-removed">- #endif</span>
  
  struct HTMLMediaElement::TrackGroup {
      enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
  
      TrackGroup(GroupKind kind)
<span class="line-new-header">--- 290,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,10 ***</span>
<span class="line-new-header">--- 305,11 ---</span>
      RefPtr&lt;TextTrack&gt; visibleTrack;
      RefPtr&lt;TextTrack&gt; defaultTrack;
      GroupKind kind;
      bool hasSrcLang { false };
  };
<span class="line-added">+ #endif</span>
  
  HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
  {
      static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
      return elements;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,11 ***</span>
      , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
      , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
      , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
      , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
      , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
<span class="line-modified">!     , m_asyncEventQueue(*this)</span>
      , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
      , m_firstTimePlaying(true)
      , m_playing(false)
      , m_isWaitingUntilMediaCanStart(false)
      , m_shouldDelayLoadEvent(false)
<span class="line-new-header">--- 403,12 ---</span>
      , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
      , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
      , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
      , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
      , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
<span class="line-modified">!     , m_updatePlayStateTask(*this)</span>
<span class="line-added">+     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))</span>
      , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
      , m_firstTimePlaying(true)
      , m_playing(false)
      , m_isWaitingUntilMediaCanStart(false)
      , m_shouldDelayLoadEvent(false)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,10 ***</span>
<span class="line-new-header">--- 443,13 ---</span>
  #if ENABLE(VIDEO_TRACK)
      , m_tracksAreReady(true)
      , m_haveVisibleTextTrack(false)
      , m_processingPreferenceChange(false)
  #endif
<span class="line-added">+ #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added">+     , m_remote(RemotePlayback::create(*this))</span>
<span class="line-added">+ #endif</span>
  #if !RELEASE_LOG_DISABLED
      , m_logger(&amp;document.logger())
      , m_logIdentifier(uniqueLogIdentifier())
  #endif
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 518,11 ***</span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
          if (shouldVideoPlaybackRequireUserGesture || shouldAudioPlaybackRequireUserGesture)
              m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker);
  #endif
  
<span class="line-modified">!         if (!document.settings().mediaDataLoadsAutomatically())</span>
              m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::AutoPreloadingNotPermitted);
  
          if (document.settings().mainContentUserGestureOverrideEnabled())
              m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::OverrideUserGestureRequirementForMainContent);
      }
<span class="line-new-header">--- 501,11 ---</span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
          if (shouldVideoPlaybackRequireUserGesture || shouldAudioPlaybackRequireUserGesture)
              m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker);
  #endif
  
<span class="line-modified">!         if (!document.mediaDataLoadsAutomatically() &amp;&amp; !document.quirks().needsPreloadAutoQuirk())</span>
              m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::AutoPreloadingNotPermitted);
  
          if (document.settings().mainContentUserGestureOverrideEnabled())
              m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::OverrideUserGestureRequirementForMainContent);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,33 ***</span>
  #endif
  
      mediaSession().clientWillBeginAutoplaying();
  }
  
<span class="line-removed">- // FIXME: Remove this code once https://webkit.org/b/185284 is fixed.</span>
<span class="line-removed">- static unsigned s_destructorCount = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool HTMLMediaElement::isRunningDestructor()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return !!s_destructorCount;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- class HTMLMediaElementDestructorScope {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     HTMLMediaElementDestructorScope() { ++s_destructorCount; }</span>
<span class="line-removed">-     ~HTMLMediaElementDestructorScope() { --s_destructorCount; }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  HTMLMediaElement::~HTMLMediaElement()
  {
<span class="line-removed">-     HTMLMediaElementDestructorScope destructorScope;</span>
      ALWAYS_LOG(LOGIDENTIFIER);
  
      beginIgnoringTrackDisplayUpdateRequests();
      allMediaElements().remove(this);
  
<span class="line-modified">!     m_asyncEventQueue.close();</span>
  
      setShouldDelayLoadEvent(false);
      unregisterWithDocument(document());
  
  #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
<span class="line-new-header">--- 531,18 ---</span>
  #endif
  
      mediaSession().clientWillBeginAutoplaying();
  }
  
  HTMLMediaElement::~HTMLMediaElement()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
  
      beginIgnoringTrackDisplayUpdateRequests();
      allMediaElements().remove(this);
  
<span class="line-modified">!     m_asyncEventQueue-&gt;close();</span>
  
      setShouldDelayLoadEvent(false);
      unregisterWithDocument(document());
  
  #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,11 ***</span>
      if (m_videoTracks)
          m_videoTracks-&gt;clearElement();
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {</span>
          m_hasPlaybackTargetAvailabilityListeners = false;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
          updateMediaState();
      }
  #endif
<span class="line-new-header">--- 557,11 ---</span>
      if (m_videoTracks)
          m_videoTracks-&gt;clearElement();
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
          m_hasPlaybackTargetAvailabilityListeners = false;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
          updateMediaState();
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 679,88 ***</span>
      return &amp;strongestSessionCandidate.session-&gt;element();
  }
  
  void HTMLMediaElement::registerWithDocument(Document&amp; document)
  {
      m_mediaSession-&gt;registerWithDocument(document);
  
      if (m_isWaitingUntilMediaCanStart)
          document.addMediaCanStartListener(*this);
  
<span class="line-removed">- #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     document.registerForMediaVolumeCallbacks(*this);</span>
<span class="line-removed">-     document.registerForPrivateBrowsingStateChangedCallbacks(*this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      document.registerForVisibilityStateChangedCallbacks(*this);
  
  #if ENABLE(VIDEO_TRACK)
      if (m_requireCaptionPreferencesChangedCallbacks)
          document.registerForCaptionPreferencesChangedCallbacks(*this);
  #endif
  
<span class="line-removed">- #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed">-     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-removed">-         document.registerForPageScaleFactorChangedCallbacks(*this);</span>
<span class="line-removed">-     document.registerForUserInterfaceLayoutDirectionChangedCallbacks(*this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      document.registerForDocumentSuspensionCallbacks(*this);
  #endif
  
<span class="line-removed">-     document.registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);</span>
<span class="line-removed">- </span>
      document.addAudioProducer(*this);
<span class="line-removed">-     addElementToDocumentMap(*this, document);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(MEDIA_STREAM)</span>
<span class="line-removed">-     document.registerForMediaStreamStateChangeCallbacks(*this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     document.addApplicationStateChangeListener(*this);</span>
  }
  
  void HTMLMediaElement::unregisterWithDocument(Document&amp; document)
  {
      m_mediaSession-&gt;unregisterWithDocument(document);
  
      if (m_isWaitingUntilMediaCanStart)
          document.removeMediaCanStartListener(*this);
  
<span class="line-removed">- #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     document.unregisterForMediaVolumeCallbacks(*this);</span>
<span class="line-removed">-     document.unregisterForPrivateBrowsingStateChangedCallbacks(*this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      document.unregisterForVisibilityStateChangedCallbacks(*this);
  
  #if ENABLE(VIDEO_TRACK)
      if (m_requireCaptionPreferencesChangedCallbacks)
          document.unregisterForCaptionPreferencesChangedCallbacks(*this);
  #endif
  
<span class="line-removed">- #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed">-     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-removed">-         document.unregisterForPageScaleFactorChangedCallbacks(*this);</span>
<span class="line-removed">-     document.unregisterForUserInterfaceLayoutDirectionChangedCallbacks(*this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      document.unregisterForDocumentSuspensionCallbacks(*this);
  #endif
  
<span class="line-removed">-     document.unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);</span>
<span class="line-removed">- </span>
      document.removeAudioProducer(*this);
<span class="line-removed">-     removeElementFromDocumentMap(*this, document);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(MEDIA_STREAM)</span>
<span class="line-removed">-     document.unregisterForMediaStreamStateChangeCallbacks(*this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     document.removeApplicationStateChangeListener(*this);</span>
  }
  
  void HTMLMediaElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
  {
      ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
<span class="line-new-header">--- 647,52 ---</span>
      return &amp;strongestSessionCandidate.session-&gt;element();
  }
  
  void HTMLMediaElement::registerWithDocument(Document&amp; document)
  {
<span class="line-added">+     document.registerMediaElement(*this);</span>
<span class="line-added">+ </span>
      m_mediaSession-&gt;registerWithDocument(document);
  
      if (m_isWaitingUntilMediaCanStart)
          document.addMediaCanStartListener(*this);
  
      document.registerForVisibilityStateChangedCallbacks(*this);
  
  #if ENABLE(VIDEO_TRACK)
      if (m_requireCaptionPreferencesChangedCallbacks)
          document.registerForCaptionPreferencesChangedCallbacks(*this);
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      document.registerForDocumentSuspensionCallbacks(*this);
  #endif
  
      document.addAudioProducer(*this);
  }
  
  void HTMLMediaElement::unregisterWithDocument(Document&amp; document)
  {
<span class="line-added">+     document.unregisterMediaElement(*this);</span>
<span class="line-added">+ </span>
      m_mediaSession-&gt;unregisterWithDocument(document);
  
      if (m_isWaitingUntilMediaCanStart)
          document.removeMediaCanStartListener(*this);
  
      document.unregisterForVisibilityStateChangedCallbacks(*this);
  
  #if ENABLE(VIDEO_TRACK)
      if (m_requireCaptionPreferencesChangedCallbacks)
          document.unregisterForCaptionPreferencesChangedCallbacks(*this);
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      document.unregisterForDocumentSuspensionCallbacks(*this);
  #endif
  
      document.removeAudioProducer(*this);
  }
  
  void HTMLMediaElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
  {
      ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 775,20 ***</span>
<span class="line-new-header">--- 707,22 ---</span>
      HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
      updateShouldAutoplay();
  }
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-added">+ </span>
  void HTMLMediaElement::prepareForDocumentSuspension()
  {
      m_mediaSession-&gt;unregisterWithDocument(document());
  }
  
  void HTMLMediaElement::resumeFromDocumentSuspension()
  {
      m_mediaSession-&gt;registerWithDocument(document());
      updateShouldAutoplay();
  }
<span class="line-added">+ </span>
  #endif
  
  bool HTMLMediaElement::supportsFocus() const
  {
      if (document().isMediaDocument())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 823,17 ***</span>
          configureMediaControls();
      else if (name == loopAttr)
          updateSleepDisabling();
      else if (name == preloadAttr) {
          if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
<span class="line-modified">!             m_preload = MediaPlayer::None;</span>
          else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
<span class="line-modified">!             m_preload = MediaPlayer::MetaData;</span>
          else {
              // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
              // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
<span class="line-modified">!             m_preload = MediaPlayer::Auto;</span>
          }
  
          // The attribute must be ignored if the autoplay attribute is present
          if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
              m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
<span class="line-new-header">--- 757,17 ---</span>
          configureMediaControls();
      else if (name == loopAttr)
          updateSleepDisabling();
      else if (name == preloadAttr) {
          if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
<span class="line-modified">!             m_preload = MediaPlayer::Preload::None;</span>
          else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
<span class="line-modified">!             m_preload = MediaPlayer::Preload::MetaData;</span>
          else {
              // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
              // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
<span class="line-modified">!             m_preload = MediaPlayer::Preload::Auto;</span>
          }
  
          // The attribute must be ignored if the autoplay attribute is present
          if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
              m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,10 ***</span>
<span class="line-new-header">--- 904,15 ---</span>
  
  inline void HTMLMediaElement::updateRenderer()
  {
      if (auto* renderer = this-&gt;renderer())
          renderer-&gt;updateFromElement();
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-added">+     if (m_mediaControlsHost)</span>
<span class="line-added">+         m_mediaControlsHost-&gt;updateCaptionDisplaySizes();</span>
<span class="line-added">+ #endif</span>
  }
  
  void HTMLMediaElement::didAttachRenderers()
  {
      if (auto* renderer = this-&gt;renderer()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,11 ***</span>
      m_resourceSelectionTaskQueue.enqueueTask([this] {
          loadNextSourceChild();
      });
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*)</span>
  {
      m_hasEverHadAudio |= hasAudio();
      m_hasEverHadVideo |= hasVideo();
  }
  
<span class="line-new-header">--- 945,11 ---</span>
      m_resourceSelectionTaskQueue.enqueueTask([this] {
          loadNextSourceChild();
      });
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged()</span>
  {
      m_hasEverHadAudio |= hasAudio();
      m_hasEverHadVideo |= hasVideo();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1019,12 ***</span>
      auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
  
      // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
      // will trigger an ASSERT if this element has been marked for deletion.
  
<span class="line-modified">!     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
  }
  
  void HTMLMediaElement::scheduleResolvePendingPlayPromises()
  {
      m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
          resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
<span class="line-new-header">--- 958,19 ---</span>
      auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
  
      // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
      // will trigger an ASSERT if this element has been marked for deletion.
  
<span class="line-modified">!     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+ void HTMLMediaElement::scheduleEvent(Ref&lt;Event&gt;&amp;&amp; event)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
  }
<span class="line-added">+ #endif</span>
  
  void HTMLMediaElement::scheduleResolvePendingPlayPromises()
  {
      m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
          resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1150,17 ***</span>
      String canPlay;
  
      // 4.8.10.3
      switch (support)
      {
<span class="line-modified">!         case MediaPlayer::IsNotSupported:</span>
              canPlay = emptyString();
              break;
<span class="line-modified">!         case MediaPlayer::MayBeSupported:</span>
              canPlay = &quot;maybe&quot;_s;
              break;
<span class="line-modified">!         case MediaPlayer::IsSupported:</span>
              canPlay = &quot;probably&quot;_s;
              break;
      }
  
      INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);
<span class="line-new-header">--- 1096,17 ---</span>
      String canPlay;
  
      // 4.8.10.3
      switch (support)
      {
<span class="line-modified">!         case MediaPlayer::SupportsType::IsNotSupported:</span>
              canPlay = emptyString();
              break;
<span class="line-modified">!         case MediaPlayer::SupportsType::MayBeSupported:</span>
              canPlay = &quot;maybe&quot;_s;
              break;
<span class="line-modified">!         case MediaPlayer::SupportsType::IsSupported:</span>
              canPlay = &quot;probably&quot;_s;
              break;
      }
  
      INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1244,12 ***</span>
<span class="line-new-header">--- 1190,14 ---</span>
          // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
  #if ENABLE(MEDIA_SOURCE)
          detachMediaSource();
  #endif
  
<span class="line-added">+ #if ENABLE(VIDEO_TRACK)</span>
          // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
          forgetResourceSpecificTracks();
<span class="line-added">+ #endif</span>
  
          // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
          m_readyState = HAVE_NOTHING;
          m_readyStateMaximum = HAVE_NOTHING;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1441,17 ***</span>
              // 2. Let absolute URL be the absolute URL that would have resulted from parsing the URL
              //    specified by the src attribute’s value relative to the media element when the src
              //    attribute was last changed.
              URL absoluteURL = getNonEmptyURLAttribute(srcAttr);
              if (absoluteURL.isEmpty()) {
<span class="line-modified">!                 mediaLoadingFailed(MediaPlayer::FormatError);</span>
                  ALWAYS_LOG(logSiteIdentifier, &quot;empty &#39;src&#39;&quot;);
                  return;
              }
  
              if (!isSafeToLoadURL(absoluteURL, Complain) || !dispatchBeforeLoadEvent(absoluteURL.string())) {
<span class="line-modified">!                 mediaLoadingFailed(MediaPlayer::FormatError);</span>
                  return;
              }
  
              // 3. If absolute URL was obtained successfully, set the currentSrc attribute to absolute URL.
              m_currentSrc = absoluteURL;
<span class="line-new-header">--- 1389,17 ---</span>
              // 2. Let absolute URL be the absolute URL that would have resulted from parsing the URL
              //    specified by the src attribute’s value relative to the media element when the src
              //    attribute was last changed.
              URL absoluteURL = getNonEmptyURLAttribute(srcAttr);
              if (absoluteURL.isEmpty()) {
<span class="line-modified">!                 mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
                  ALWAYS_LOG(logSiteIdentifier, &quot;empty &#39;src&#39;&quot;);
                  return;
              }
  
              if (!isSafeToLoadURL(absoluteURL, Complain) || !dispatchBeforeLoadEvent(absoluteURL.string())) {
<span class="line-modified">!                 mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
                  return;
              }
  
              // 3. If absolute URL was obtained successfully, set the currentSrc attribute to absolute URL.
              m_currentSrc = absoluteURL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1503,30 ***</span>
  
      INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);
  
      RefPtr&lt;Frame&gt; frame = document().frame();
      if (!frame) {
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::FormatError);</span>
          return;
      }
  
      Page* page = frame-&gt;page();
      if (!page) {
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::FormatError);</span>
          return;
      }
  
      URL url = initialURL;
      if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::FormatError);</span>
          return;
      }
  
  #if ENABLE(CONTENT_EXTENSIONS)
      if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
          if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::FormatError);</span>
              return;
          }
      }
  #endif
  
<span class="line-new-header">--- 1451,30 ---</span>
  
      INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);
  
      RefPtr&lt;Frame&gt; frame = document().frame();
      if (!frame) {
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
          return;
      }
  
      Page* page = frame-&gt;page();
      if (!page) {
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
          return;
      }
  
      URL url = initialURL;
      if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
          return;
      }
  
  #if ENABLE(CONTENT_EXTENSIONS)
      if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
          if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
              return;
          }
      }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1537,11 ***</span>
      ApplicationCacheResource* resource = nullptr;
      if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
          // Resources that are not present in the manifest will always fail to load (at least, after the
          // cache has been primed the first time), making the testing of offline applications simpler.
          if (!resource || resource-&gt;path().isEmpty()) {
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::NetworkError);</span>
              return;
          }
      }
  
      // Log that we started loading a media element.
<span class="line-new-header">--- 1485,11 ---</span>
      ApplicationCacheResource* resource = nullptr;
      if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
          // Resources that are not present in the manifest will always fail to load (at least, after the
          // cache has been primed the first time), making the testing of offline applications simpler.
          if (!resource || resource-&gt;path().isEmpty()) {
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::NetworkState::NetworkError);</span>
              return;
          }
      }
  
      // Log that we started loading a media element.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1587,46 ***</span>
  
      if (m_mediaSource) {
          loadAttempted = true;
  
          ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
<span class="line-modified">!         if (!m_mediaSource-&gt;attachToElement(*this) || !m_player-&gt;load(url, contentType, m_mediaSource.get())) {</span>
              // Forget our reference to the MediaSource, so we leave it alone
              // while processing remainder of load failure.
              m_mediaSource = nullptr;
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::FormatError);</span>
          }
      }
  #endif
  #if ENABLE(MEDIA_STREAM)
      if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {
          loadAttempted = true;
          ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);
          if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::FormatError);</span>
      }
  #endif
  
      if (!loadAttempted &amp;&amp; m_blob) {
          loadAttempted = true;
          ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
          if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::FormatError);</span>
      }
  
      if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::FormatError);</span>
  
      // If there is no poster to display, allow the media engine to render video frames as soon as
      // they are available.
      updateDisplayState();
  
      updateRenderer();
  }
  
  #if ENABLE(VIDEO_TRACK)
  
  static bool trackIndexCompare(TextTrack* a, TextTrack* b)
  {
      return a-&gt;trackIndex() - b-&gt;trackIndex() &lt; 0;
  }
  
<span class="line-new-header">--- 1535,57 ---</span>
  
      if (m_mediaSource) {
          loadAttempted = true;
  
          ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
<span class="line-modified">!         if (!m_mediaSource-&gt;attachToElement(*this)) {</span>
              // Forget our reference to the MediaSource, so we leave it alone
              // while processing remainder of load failure.
              m_mediaSource = nullptr;
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
<span class="line-added">+         } else if (!m_player-&gt;load(url, contentType, m_mediaSource.get())) {</span>
<span class="line-added">+             // We have to detach the MediaSource before we forget the reference to it.</span>
<span class="line-added">+             m_mediaSource-&gt;detachFromElement(*this);</span>
<span class="line-added">+             m_mediaSource = nullptr;</span>
<span class="line-added">+             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
          }
      }
  #endif
  #if ENABLE(MEDIA_STREAM)
      if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {
          loadAttempted = true;
          ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);
          if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
      }
  #endif
  
      if (!loadAttempted &amp;&amp; m_blob) {
          loadAttempted = true;
          ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
          if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
      }
  
      if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
<span class="line-modified">!         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
  
      // If there is no poster to display, allow the media engine to render video frames as soon as
      // they are available.
      updateDisplayState();
  
      updateRenderer();
  }
  
  #if ENABLE(VIDEO_TRACK)
  
<span class="line-added">+ struct HTMLMediaElement::CueData {</span>
<span class="line-added">+     WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
<span class="line-added">+     PODIntervalTree&lt;MediaTime, TextTrackCue*&gt; cueTree;</span>
<span class="line-added">+     CueList currentlyActiveCues;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  static bool trackIndexCompare(TextTrack* a, TextTrack* b)
  {
      return a-&gt;trackIndex() - b-&gt;trackIndex() &lt; 0;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1657,10 ***</span>
<span class="line-new-header">--- 1616,15 ---</span>
  static bool compareCueIntervalEndTime(const CueInterval&amp; one, const CueInterval&amp; two)
  {
      return one.data()-&gt;endMediaTime() &gt; two.data()-&gt;endMediaTime();
  }
  
<span class="line-added">+ bool HTMLMediaElement::ignoreTrackDisplayUpdateRequests() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueData || m_cueData-&gt;cueTree.isEmpty();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void HTMLMediaElement::updateActiveTextTrackCues(const MediaTime&amp; movieTime)
  {
      // 4.8.10.8 Playing the media resource
  
      //  If the current playback position changes while the steps are running,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1676,24 ***</span>
      // than the current playback position.
      CueList currentCues;
  
      // The user agent must synchronously unset [the text track cue active] flag
      // whenever ... the media element&#39;s readyState is changed back to HAVE_NOTHING.
<span class="line-removed">-     auto movieTimeInterval = m_cueTree.createInterval(movieTime, movieTime);</span>
      if (m_readyState != HAVE_NOTHING &amp;&amp; m_player) {
<span class="line-modified">!         currentCues = m_cueTree.allOverlaps(movieTimeInterval);</span>
          if (currentCues.size() &gt; 1)
              std::sort(currentCues.begin(), currentCues.end(), &amp;compareCueInterval);
      }
  
      CueList previousCues;
      CueList missedCues;
  
      // 2 - Let other cues be a list of cues, initialized to contain all the cues
      // of hidden, showing, and showing by default text tracks of the media
      // element that are not present in current cues.
<span class="line-modified">!     previousCues = m_currentlyActiveCues;</span>
  
      // 3 - Let last time be the current playback position at the time this
      // algorithm was last run for this media element, if this is not the first
      // time it has run.
      MediaTime lastTime = m_lastTextTrackUpdateTime;
<span class="line-new-header">--- 1640,23 ---</span>
      // than the current playback position.
      CueList currentCues;
  
      // The user agent must synchronously unset [the text track cue active] flag
      // whenever ... the media element&#39;s readyState is changed back to HAVE_NOTHING.
      if (m_readyState != HAVE_NOTHING &amp;&amp; m_player) {
<span class="line-modified">!         currentCues = m_cueData-&gt;cueTree.allOverlaps({ movieTime, movieTime });</span>
          if (currentCues.size() &gt; 1)
              std::sort(currentCues.begin(), currentCues.end(), &amp;compareCueInterval);
      }
  
      CueList previousCues;
      CueList missedCues;
  
      // 2 - Let other cues be a list of cues, initialized to contain all the cues
      // of hidden, showing, and showing by default text tracks of the media
      // element that are not present in current cues.
<span class="line-modified">!     previousCues = m_cueData-&gt;currentlyActiveCues;</span>
  
      // 3 - Let last time be the current playback position at the time this
      // algorithm was last run for this media element, if this is not the first
      // time it has run.
      MediaTime lastTime = m_lastTextTrackUpdateTime;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1703,11 ***</span>
      // during normal playback, then let missed cues be the list of cues in other
      // cues whose start times are greater than or equal to last time and whose
      // end times are less than or equal to the current playback position.
      // Otherwise, let missed cues be an empty list.
      if (lastTime &gt;= MediaTime::zeroTime() &amp;&amp; m_lastSeekTime &lt; movieTime) {
<span class="line-modified">!         for (auto&amp; cue : m_cueTree.allOverlaps(m_cueTree.createInterval(lastTime, movieTime))) {</span>
              // Consider cues that may have been missed since the last seek time.
              if (cue.low() &gt; std::max(m_lastSeekTime, lastTime) &amp;&amp; cue.high() &lt; movieTime)
                  missedCues.append(cue);
          }
      }
<span class="line-new-header">--- 1666,11 ---</span>
      // during normal playback, then let missed cues be the list of cues in other
      // cues whose start times are greater than or equal to last time and whose
      // end times are less than or equal to the current playback position.
      // Otherwise, let missed cues be an empty list.
      if (lastTime &gt;= MediaTime::zeroTime() &amp;&amp; m_lastSeekTime &lt; movieTime) {
<span class="line-modified">!         for (auto&amp; cue : m_cueData-&gt;cueTree.allOverlaps({ lastTime, movieTime })) {</span>
              // Consider cues that may have been missed since the last seek time.
              if (cue.low() &gt; std::max(m_lastSeekTime, lastTime) &amp;&amp; cue.high() &lt; movieTime)
                  missedCues.append(cue);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1739,23 ***</span>
          if (!currentCues.contains(previousCues[i]) &amp;&amp; previousCues[i].data()-&gt;isActive())
              activeSetChanged = true;
  
      for (size_t i = 0; i &lt; currentCuesSize; ++i) {
          RefPtr&lt;TextTrackCue&gt; cue = currentCues[i].data();
<span class="line-modified">! </span>
<span class="line-removed">-         if (cue-&gt;isRenderable())</span>
<span class="line-removed">-             toVTTCue(cue.get())-&gt;updateDisplayTree(movieTime);</span>
<span class="line-removed">- </span>
          if (!cue-&gt;isActive())
              activeSetChanged = true;
      }
  
      MediaTime nextInterestingTime = MediaTime::invalidTime();
      if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
          nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
  
<span class="line-modified">!     Optional&lt;CueInterval&gt; nextCue = m_cueTree.nextIntervalAfter(movieTimeInterval);</span>
      if (nextCue)
          nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
  
      INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
  
<span class="line-new-header">--- 1702,20 ---</span>
          if (!currentCues.contains(previousCues[i]) &amp;&amp; previousCues[i].data()-&gt;isActive())
              activeSetChanged = true;
  
      for (size_t i = 0; i &lt; currentCuesSize; ++i) {
          RefPtr&lt;TextTrackCue&gt; cue = currentCues[i].data();
<span class="line-modified">!         cue-&gt;updateDisplayTree(movieTime);</span>
          if (!cue-&gt;isActive())
              activeSetChanged = true;
      }
  
      MediaTime nextInterestingTime = MediaTime::invalidTime();
      if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
          nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
  
<span class="line-modified">!     Optional&lt;CueInterval&gt; nextCue = m_cueData-&gt;cueTree.nextIntervalAfter(movieTime);</span>
      if (nextCue)
          nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
  
      INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1847,23 ***</span>
          // correctly identifies the type of the event, if the startTime is
          // less than the endTime in the cue.
          if (eventTask.second-&gt;startTime() &gt;= eventTask.second-&gt;endTime()) {
              auto enterEvent = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
              enterEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">!             m_asyncEventQueue.enqueueEvent(WTFMove(enterEvent));</span>
  
              auto exitEvent = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
              exitEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">!             m_asyncEventQueue.enqueueEvent(WTFMove(exitEvent));</span>
          } else {
              RefPtr&lt;Event&gt; event;
              if (eventTask.first == eventTask.second-&gt;startMediaTime())
                  event = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
              else
                  event = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
              event-&gt;setTarget(eventTask.second);
<span class="line-modified">!             m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
          }
      }
  
      // 14 - Sort affected tracks in the same order as the text tracks appear in
      // the media element&#39;s list of text tracks, and remove duplicates.
<span class="line-new-header">--- 1807,23 ---</span>
          // correctly identifies the type of the event, if the startTime is
          // less than the endTime in the cue.
          if (eventTask.second-&gt;startTime() &gt;= eventTask.second-&gt;endTime()) {
              auto enterEvent = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
              enterEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">!             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(enterEvent));</span>
  
              auto exitEvent = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
              exitEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">!             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(exitEvent));</span>
          } else {
              RefPtr&lt;Event&gt; event;
              if (eventTask.first == eventTask.second-&gt;startMediaTime())
                  event = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
              else
                  event = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
              event-&gt;setTarget(eventTask.second);
<span class="line-modified">!             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
          }
      }
  
      // 14 - Sort affected tracks in the same order as the text tracks appear in
      // the media element&#39;s list of text tracks, and remove duplicates.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1872,20 ***</span>
      // 15 - For each text track in affected tracks, in the list order, queue a
      // task to fire a simple event named cuechange at the TextTrack object, and, ...
      for (auto&amp; affectedTrack : affectedTracks) {
          auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
          event-&gt;setTarget(affectedTrack);
<span class="line-modified">!         m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
  
          // ... if the text track has a corresponding track element, to then fire a
          // simple event named cuechange at the track element as well.
          if (is&lt;LoadableTextTrack&gt;(*affectedTrack)) {
              auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
              auto trackElement = makeRefPtr(downcast&lt;LoadableTextTrack&gt;(*affectedTrack).trackElement());
              ASSERT(trackElement);
              event-&gt;setTarget(trackElement);
<span class="line-modified">!             m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
          }
      }
  
      // 16 - Set the text track cue active flag of all the cues in the current
      // cues, and unset the text track cue active flag of all the cues in the
<span class="line-new-header">--- 1832,20 ---</span>
      // 15 - For each text track in affected tracks, in the list order, queue a
      // task to fire a simple event named cuechange at the TextTrack object, and, ...
      for (auto&amp; affectedTrack : affectedTracks) {
          auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
          event-&gt;setTarget(affectedTrack);
<span class="line-modified">!         m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
  
          // ... if the text track has a corresponding track element, to then fire a
          // simple event named cuechange at the track element as well.
          if (is&lt;LoadableTextTrack&gt;(*affectedTrack)) {
              auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
              auto trackElement = makeRefPtr(downcast&lt;LoadableTextTrack&gt;(*affectedTrack).trackElement());
              ASSERT(trackElement);
              event-&gt;setTarget(trackElement);
<span class="line-modified">!             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
          }
      }
  
      // 16 - Set the text track cue active flag of all the cues in the current
      // cues, and unset the text track cue active flag of all the cues in the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1896,11 ***</span>
      for (size_t i = 0; i &lt; previousCuesSize; ++i)
          if (!currentCues.contains(previousCues[i]))
              previousCues[i].data()-&gt;setIsActive(false);
  
      // Update the current active cues.
<span class="line-modified">!     m_currentlyActiveCues = currentCues;</span>
  
      if (activeSetChanged)
          updateTextTrackDisplay();
  }
  
<span class="line-new-header">--- 1856,11 ---</span>
      for (size_t i = 0; i &lt; previousCuesSize; ++i)
          if (!currentCues.contains(previousCues[i]))
              previousCues[i].data()-&gt;setIsActive(false);
  
      // Update the current active cues.
<span class="line-modified">!     m_cueData-&gt;currentlyActiveCues = currentCues;</span>
  
      if (activeSetChanged)
          updateTextTrackDisplay();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1965,11 ***</span>
          }
      }
  
      // If this is the first added track, create the list of text tracks.
      if (!m_textTracks)
<span class="line-modified">!         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
  
      // Mark this track as &quot;configured&quot; so configureTextTracks won&#39;t change the mode again.
      track.setHasBeenConfigured(true);
  
      if (track.mode() != TextTrack::Mode::Disabled &amp;&amp; trackIsLoaded)
<span class="line-new-header">--- 1925,11 ---</span>
          }
      }
  
      // If this is the first added track, create the list of text tracks.
      if (!m_textTracks)
<span class="line-modified">!         m_textTracks = TextTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
  
      // Mark this track as &quot;configured&quot; so configureTextTracks won&#39;t change the mode again.
      track.setHasBeenConfigured(true);
  
      if (track.mode() != TextTrack::Mode::Disabled &amp;&amp; trackIsLoaded)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2033,49 ***</span>
  void HTMLMediaElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
  {
      if (track.mode() == TextTrack::Mode::Disabled)
          return;
  
      // Negative duration cues need be treated in the interval tree as
      // zero-length cues.
      MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
  
<span class="line-modified">!     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">!     if (!m_cueTree.contains(interval))</span>
<span class="line-modified">!         m_cueTree.add(interval);</span>
      updateActiveTextTrackCues(currentMediaTime());
  }
  
  void HTMLMediaElement::textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp; cue)
  {
      // Negative duration cues need to be treated in the interval tree as
      // zero-length cues.
      MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
  
<span class="line-modified">!     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">!     m_cueTree.remove(interval);</span>
  
      // Since the cue will be removed from the media element and likely the
      // TextTrack might also be destructed, notifying the region of the cue
      // removal shouldn&#39;t be done.
<span class="line-modified">!     if (cue.isRenderable())</span>
          toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(false);
  
<span class="line-modified">!     size_t index = m_currentlyActiveCues.find(interval);</span>
      if (index != notFound) {
          cue.setIsActive(false);
<span class="line-modified">!         m_currentlyActiveCues.remove(index);</span>
      }
  
<span class="line-modified">!     if (cue.isRenderable())</span>
<span class="line-removed">-         toVTTCue(&amp;cue)-&gt;removeDisplayTree();</span>
      updateActiveTextTrackCues(currentMediaTime());
  
<span class="line-modified">!     if (cue.isRenderable())</span>
          toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(true);
  }
  
  #endif
  
  static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
  {
      // Elements in user agent show tree should load whatever the embedding document policy is.
<span class="line-new-header">--- 1993,62 ---</span>
  void HTMLMediaElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
  {
      if (track.mode() == TextTrack::Mode::Disabled)
          return;
  
<span class="line-added">+     if (!m_cueData)</span>
<span class="line-added">+         m_cueData = makeUnique&lt;CueData&gt;();</span>
<span class="line-added">+ </span>
      // Negative duration cues need be treated in the interval tree as
      // zero-length cues.
      MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
  
<span class="line-modified">!     CueInterval interval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">!     if (!m_cueData-&gt;cueTree.contains(interval))</span>
<span class="line-modified">!         m_cueData-&gt;cueTree.add(interval);</span>
      updateActiveTextTrackCues(currentMediaTime());
  }
  
  void HTMLMediaElement::textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp; cue)
  {
<span class="line-added">+     if (!m_cueData)</span>
<span class="line-added">+         m_cueData = makeUnique&lt;CueData&gt;();</span>
<span class="line-added">+ </span>
      // Negative duration cues need to be treated in the interval tree as
      // zero-length cues.
      MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
  
<span class="line-modified">!     CueInterval interval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">!     m_cueData-&gt;cueTree.remove(interval);</span>
  
      // Since the cue will be removed from the media element and likely the
      // TextTrack might also be destructed, notifying the region of the cue
      // removal shouldn&#39;t be done.
<span class="line-modified">!     auto isVTT = is&lt;VTTCue&gt;(cue);</span>
<span class="line-added">+     if (isVTT)</span>
          toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(false);
  
<span class="line-modified">!     size_t index = m_cueData-&gt;currentlyActiveCues.find(interval);</span>
      if (index != notFound) {
          cue.setIsActive(false);
<span class="line-modified">!         m_cueData-&gt;currentlyActiveCues.remove(index);</span>
      }
  
<span class="line-modified">!     cue.removeDisplayTree();</span>
      updateActiveTextTrackCues(currentMediaTime());
  
<span class="line-modified">!     if (isVTT)</span>
          toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(true);
  }
  
<span class="line-added">+ CueList HTMLMediaElement::currentlyActiveCues() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_cueData)</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     return m_cueData-&gt;currentlyActiveCues;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #endif
  
  static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
  {
      // Elements in user agent show tree should load whatever the embedding document policy is.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2154,12 ***</span>
<span class="line-new-header">--- 2127,14 ---</span>
  
      // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
      // MEDIA_ERR_SRC_NOT_SUPPORTED.
      m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
  
<span class="line-added">+ #if ENABLE(VIDEO_TRACK)</span>
      // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
      forgetResourceSpecificTracks();
<span class="line-added">+ #endif</span>
  
      // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
      m_networkState = NETWORK_NO_SOURCE;
  
      // 7 - Queue a task to fire a simple event named error at the media element.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2187,13 ***</span>
      stopPeriodicTimers();
      m_loadState = WaitingForSource;
  
      // 2 - Set the error attribute to a new MediaError object whose code attribute is
      // set to MEDIA_ERR_NETWORK/MEDIA_ERR_DECODE.
<span class="line-modified">!     if (error == MediaPlayer::NetworkError)</span>
          m_error = MediaError::create(MediaError::MEDIA_ERR_NETWORK);
<span class="line-modified">!     else if (error == MediaPlayer::DecodeError)</span>
          m_error = MediaError::create(MediaError::MEDIA_ERR_DECODE);
      else
          ASSERT_NOT_REACHED();
  
      // 3 - Queue a task to fire a simple event named error at the media element.
<span class="line-new-header">--- 2162,13 ---</span>
      stopPeriodicTimers();
      m_loadState = WaitingForSource;
  
      // 2 - Set the error attribute to a new MediaError object whose code attribute is
      // set to MEDIA_ERR_NETWORK/MEDIA_ERR_DECODE.
<span class="line-modified">!     if (error == MediaPlayer::NetworkState::NetworkError)</span>
          m_error = MediaError::create(MediaError::MEDIA_ERR_NETWORK);
<span class="line-modified">!     else if (error == MediaPlayer::NetworkState::DecodeError)</span>
          m_error = MediaError::create(MediaError::MEDIA_ERR_DECODE);
      else
          ASSERT_NOT_REACHED();
  
      // 3 - Queue a task to fire a simple event named error at the media element.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2211,29 ***</span>
      // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
      setShouldDelayLoadEvent(false);
  
      // 6 - Abort the overall resource selection algorithm.
      m_currentSourceNode = nullptr;
<span class="line-removed">- </span>
<span class="line-removed">- #if PLATFORM(COCOA)</span>
<span class="line-removed">-     if (is&lt;MediaDocument&gt;(document()))</span>
<span class="line-removed">-         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();</span>
<span class="line-removed">- #endif</span>
  }
  
  void HTMLMediaElement::cancelPendingEventsAndCallbacks()
  {
      INFO_LOG(LOGIDENTIFIER);
<span class="line-modified">!     m_asyncEventQueue.cancelAllEvents();</span>
  
      for (auto&amp; source : childrenOfType&lt;HTMLSourceElement&gt;(*this))
          source.cancelPendingErrorEvent();
  
      rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(AbortError));
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerNetworkStateChanged(MediaPlayer*)</span>
  {
      beginProcessingMediaPlayerCallback();
      setNetworkState(m_player-&gt;networkState());
      endProcessingMediaPlayerCallback();
  }
<span class="line-new-header">--- 2186,24 ---</span>
      // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
      setShouldDelayLoadEvent(false);
  
      // 6 - Abort the overall resource selection algorithm.
      m_currentSourceNode = nullptr;
  }
  
  void HTMLMediaElement::cancelPendingEventsAndCallbacks()
  {
      INFO_LOG(LOGIDENTIFIER);
<span class="line-modified">!     m_asyncEventQueue-&gt;cancelAllEvents();</span>
  
      for (auto&amp; source : childrenOfType&lt;HTMLSourceElement&gt;(*this))
          source.cancelPendingErrorEvent();
  
      rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(AbortError));
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerNetworkStateChanged()</span>
  {
      beginProcessingMediaPlayerCallback();
      setNetworkState(m_player-&gt;networkState());
      endProcessingMediaPlayerCallback();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2258,24 ***</span>
          diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsMediaEngineKey(), mediaEngine, ShouldSample::No);
  
      page-&gt;sawMediaEngine(mediaEngine);
  }
  
<span class="line-removed">- static String stringForNetworkState(MediaPlayer::NetworkState state)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     switch (state) {</span>
<span class="line-removed">-     case MediaPlayer::Empty: return &quot;Empty&quot;_s;</span>
<span class="line-removed">-     case MediaPlayer::Idle: return &quot;Idle&quot;_s;</span>
<span class="line-removed">-     case MediaPlayer::Loading: return &quot;Loading&quot;_s;</span>
<span class="line-removed">-     case MediaPlayer::Loaded: return &quot;Loaded&quot;_s;</span>
<span class="line-removed">-     case MediaPlayer::FormatError: return &quot;FormatError&quot;_s;</span>
<span class="line-removed">-     case MediaPlayer::NetworkError: return &quot;NetworkError&quot;_s;</span>
<span class="line-removed">-     case MediaPlayer::DecodeError: return &quot;DecodeError&quot;_s;</span>
<span class="line-removed">-     default: return emptyString();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
  {
      stopPeriodicTimers();
  
      // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
<span class="line-new-header">--- 2228,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2289,12 ***</span>
<span class="line-new-header">--- 2245,14 ---</span>
          else
              INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
  
          // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
  
<span class="line-added">+ #if ENABLE(VIDEO_TRACK)</span>
          // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
          forgetResourceSpecificTracks();
<span class="line-added">+ #endif</span>
  
          if (havePotentialSourceChild()) {
              INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
              scheduleNextSourceChild();
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2303,60 ***</span>
          }
  
          return;
      }
  
<span class="line-modified">!     if ((error == MediaPlayer::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::DecodeError)</span>
          mediaLoadingFailedFatally(error);
<span class="line-modified">!     else if ((error == MediaPlayer::FormatError || error == MediaPlayer::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)</span>
          noneSupported();
  
      updateDisplayState();
      if (hasMediaControls()) {
          mediaControls()-&gt;reset();
          mediaControls()-&gt;reportedError();
      }
  
      ERROR_LOG(LOGIDENTIFIER, &quot;error = &quot;, static_cast&lt;int&gt;(error));
  
<span class="line-modified">!     logMediaLoadRequest(document().page(), String(), stringForNetworkState(error), false);</span>
  
      m_mediaSession-&gt;clientCharacteristicsChanged();
  }
  
  void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
  {
      if (static_cast&lt;int&gt;(state) != static_cast&lt;int&gt;(m_networkState))
          ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_networkState);
  
<span class="line-modified">!     if (state == MediaPlayer::Empty) {</span>
          // Just update the cached state and leave, we can&#39;t do anything.
          m_networkState = NETWORK_EMPTY;
          return;
      }
  
<span class="line-modified">!     if (state == MediaPlayer::FormatError || state == MediaPlayer::NetworkError || state == MediaPlayer::DecodeError) {</span>
          mediaLoadingFailed(state);
          return;
      }
  
<span class="line-modified">!     if (state == MediaPlayer::Idle) {</span>
          if (m_networkState &gt; NETWORK_IDLE) {
              changeNetworkStateFromLoadingToIdle();
              setShouldDelayLoadEvent(false);
          } else {
              m_networkState = NETWORK_IDLE;
          }
      }
  
<span class="line-modified">!     if (state == MediaPlayer::Loading) {</span>
          if (m_networkState &lt; NETWORK_LOADING || m_networkState == NETWORK_NO_SOURCE)
              startProgressEventTimer();
          m_networkState = NETWORK_LOADING;
      }
  
<span class="line-modified">!     if (state == MediaPlayer::Loaded) {</span>
          if (m_networkState != NETWORK_IDLE)
              changeNetworkStateFromLoadingToIdle();
          m_completelyLoaded = true;
      }
  
<span class="line-new-header">--- 2261,60 ---</span>
          }
  
          return;
      }
  
<span class="line-modified">!     if ((error == MediaPlayer::NetworkState::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::NetworkState::DecodeError)</span>
          mediaLoadingFailedFatally(error);
<span class="line-modified">!     else if ((error == MediaPlayer::NetworkState::FormatError || error == MediaPlayer::NetworkState::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)</span>
          noneSupported();
  
      updateDisplayState();
      if (hasMediaControls()) {
          mediaControls()-&gt;reset();
          mediaControls()-&gt;reportedError();
      }
  
      ERROR_LOG(LOGIDENTIFIER, &quot;error = &quot;, static_cast&lt;int&gt;(error));
  
<span class="line-modified">!     logMediaLoadRequest(document().page(), String(), convertEnumerationToString(error), false);</span>
  
      m_mediaSession-&gt;clientCharacteristicsChanged();
  }
  
  void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
  {
      if (static_cast&lt;int&gt;(state) != static_cast&lt;int&gt;(m_networkState))
          ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_networkState);
  
<span class="line-modified">!     if (state == MediaPlayer::NetworkState::Empty) {</span>
          // Just update the cached state and leave, we can&#39;t do anything.
          m_networkState = NETWORK_EMPTY;
          return;
      }
  
<span class="line-modified">!     if (state == MediaPlayer::NetworkState::FormatError || state == MediaPlayer::NetworkState::NetworkError || state == MediaPlayer::NetworkState::DecodeError) {</span>
          mediaLoadingFailed(state);
          return;
      }
  
<span class="line-modified">!     if (state == MediaPlayer::NetworkState::Idle) {</span>
          if (m_networkState &gt; NETWORK_IDLE) {
              changeNetworkStateFromLoadingToIdle();
              setShouldDelayLoadEvent(false);
          } else {
              m_networkState = NETWORK_IDLE;
          }
      }
  
<span class="line-modified">!     if (state == MediaPlayer::NetworkState::Loading) {</span>
          if (m_networkState &lt; NETWORK_LOADING || m_networkState == NETWORK_NO_SOURCE)
              startProgressEventTimer();
          m_networkState = NETWORK_LOADING;
      }
  
<span class="line-modified">!     if (state == MediaPlayer::NetworkState::Loaded) {</span>
          if (m_networkState != NETWORK_IDLE)
              changeNetworkStateFromLoadingToIdle();
          m_completelyLoaded = true;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2375,12 ***</span>
      scheduleEvent(eventNames().progressEvent);
      scheduleEvent(eventNames().suspendEvent);
      m_networkState = NETWORK_IDLE;
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerReadyStateChanged(MediaPlayer*)</span>
  {
      beginProcessingMediaPlayerCallback();
  
      setReadyState(m_player-&gt;readyState());
  
      endProcessingMediaPlayerCallback();
<span class="line-new-header">--- 2333,19 ---</span>
      scheduleEvent(eventNames().progressEvent);
      scheduleEvent(eventNames().suspendEvent);
      m_networkState = NETWORK_IDLE;
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerReadyStateChanged()</span>
  {
<span class="line-added">+     if (isSuspended()) {</span>
<span class="line-added">+         queueTaskKeepingObjectAlive(*this, TaskSource::MediaElement, [this] {</span>
<span class="line-added">+             mediaPlayerReadyStateChanged();</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      beginProcessingMediaPlayerCallback();
  
      setReadyState(m_player-&gt;readyState());
  
      endProcessingMediaPlayerCallback();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2593,11 ***</span>
  RefPtr&lt;ArrayBuffer&gt; HTMLMediaElement::mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const
  {
      return m_webKitMediaKeys ? m_webKitMediaKeys-&gt;cachedKeyForKeyId(keyId) : nullptr;
  }
  
<span class="line-modified">! bool HTMLMediaElement::mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array* initData)</span>
  {
      if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
          return false;
  
      if (!hasEventListeners(&quot;webkitneedkey&quot;)
<span class="line-new-header">--- 2558,11 ---</span>
  RefPtr&lt;ArrayBuffer&gt; HTMLMediaElement::mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const
  {
      return m_webKitMediaKeys ? m_webKitMediaKeys-&gt;cachedKeyForKeyId(keyId) : nullptr;
  }
  
<span class="line-modified">! bool HTMLMediaElement::mediaPlayerKeyNeeded(Uint8Array* initData)</span>
  {
      if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
          return false;
  
      if (!hasEventListeners(&quot;webkitneedkey&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2612,11 ***</span>
          return false;
      }
  
      auto event = WebKitMediaKeyNeededEvent::create(eventNames().webkitneedkeyEvent, initData);
      event-&gt;setTarget(this);
<span class="line-modified">!     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
  
      return true;
  }
  
  String HTMLMediaElement::mediaPlayerMediaKeysStorageDirectory() const
<span class="line-new-header">--- 2577,11 ---</span>
          return false;
      }
  
      auto event = WebKitMediaKeyNeededEvent::create(eventNames().webkitneedkeyEvent, initData);
      event-&gt;setTarget(this);
<span class="line-modified">!     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
  
      return true;
  }
  
  String HTMLMediaElement::mediaPlayerMediaKeysStorageDirectory() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2759,11 ***</span>
      //    initialized to true, and dispatch it at the media element.
      //    The event interface MediaEncryptedEvent has:
      //      initDataType = initDataType
      //      initData = initData
      MediaEncryptedEventInit initializer { initDataType, WTFMove(initData) };
<span class="line-modified">!     m_asyncEventQueue.enqueueEvent(MediaEncryptedEvent::create(eventNames().encryptedEvent, initializer, Event::IsTrusted::Yes));</span>
  }
  
  void HTMLMediaElement::mediaPlayerWaitingForKeyChanged()
  {
      if (!m_player)
<span class="line-new-header">--- 2724,11 ---</span>
      //    initialized to true, and dispatch it at the media element.
      //    The event interface MediaEncryptedEvent has:
      //      initDataType = initDataType
      //      initData = initData
      MediaEncryptedEventInit initializer { initDataType, WTFMove(initData) };
<span class="line-modified">!     m_asyncEventQueue-&gt;enqueueEvent(MediaEncryptedEvent::create(eventNames().encryptedEvent, initializer, Event::IsTrusted::Yes));</span>
  }
  
  void HTMLMediaElement::mediaPlayerWaitingForKeyChanged()
  {
      if (!m_player)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2999,11 ***</span>
      // 2 - If the media element&#39;s readyState is HAVE_NOTHING, abort these steps.
      if (m_readyState == HAVE_NOTHING || !m_player)
          return;
  
      // If the media engine has been told to postpone loading data, let it go ahead now.
<span class="line-modified">!     if (m_preload &lt; MediaPlayer::Auto &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)</span>
          prepareToPlay();
  
      // Get the current time before setting m_seeking, m_lastSeekTime is returned once it is set.
      refreshCachedTime();
      MediaTime now = currentMediaTime();
<span class="line-new-header">--- 2964,11 ---</span>
      // 2 - If the media element&#39;s readyState is HAVE_NOTHING, abort these steps.
      if (m_readyState == HAVE_NOTHING || !m_player)
          return;
  
      // If the media engine has been told to postpone loading data, let it go ahead now.
<span class="line-modified">!     if (m_preload &lt; MediaPlayer::Preload::Auto &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)</span>
          prepareToPlay();
  
      // Get the current time before setting m_seeking, m_lastSeekTime is returned once it is set.
      refreshCachedTime();
      MediaTime now = currentMediaTime();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3171,11 ***</span>
      return m_readyState;
  }
  
  MediaPlayer::MovieLoadType HTMLMediaElement::movieLoadType() const
  {
<span class="line-modified">!     return m_player ? m_player-&gt;movieLoadType() : MediaPlayer::Unknown;</span>
  }
  
  bool HTMLMediaElement::hasAudio() const
  {
      return m_player ? m_player-&gt;hasAudio() : false;
<span class="line-new-header">--- 3136,11 ---</span>
      return m_readyState;
  }
  
  MediaPlayer::MovieLoadType HTMLMediaElement::movieLoadType() const
  {
<span class="line-modified">!     return m_player ? m_player-&gt;movieLoadType() : MediaPlayer::MovieLoadType::Unknown;</span>
  }
  
  bool HTMLMediaElement::hasAudio() const
  {
      return m_player ? m_player-&gt;hasAudio() : false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3467,15 ***</span>
      if (m_mediaStreamSrcObject)
          return &quot;none&quot;_s;
  #endif
  
      switch (m_preload) {
<span class="line-modified">!     case MediaPlayer::None:</span>
          return &quot;none&quot;_s;
<span class="line-modified">!     case MediaPlayer::MetaData:</span>
          return &quot;metadata&quot;_s;
<span class="line-modified">!     case MediaPlayer::Auto:</span>
          return &quot;auto&quot;_s;
      }
  
      ASSERT_NOT_REACHED();
      return String();
<span class="line-new-header">--- 3432,15 ---</span>
      if (m_mediaStreamSrcObject)
          return &quot;none&quot;_s;
  #endif
  
      switch (m_preload) {
<span class="line-modified">!     case MediaPlayer::Preload::None:</span>
          return &quot;none&quot;_s;
<span class="line-modified">!     case MediaPlayer::Preload::MetaData:</span>
          return &quot;metadata&quot;_s;
<span class="line-modified">!     case MediaPlayer::Preload::Auto:</span>
          return &quot;auto&quot;_s;
      }
  
      ASSERT_NOT_REACHED();
      return String();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3811,10 ***</span>
<span class="line-new-header">--- 3776,11 ---</span>
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
          scheduleUpdateMediaState();
  #endif
          m_mediaSession-&gt;canProduceAudioChanged();
<span class="line-added">+         updateSleepDisabling();</span>
      }
  
      schedulePlaybackControlsManagerUpdate();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4038,11 ***</span>
  void HTMLMediaElement::mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp; track)
  {
      // 4.8.10.12.2 Sourcing in-band text tracks
      // 1. Associate the relevant data with a new text track and its corresponding new TextTrack object.
      auto textTrack = InbandTextTrack::create(*ActiveDOMObject::scriptExecutionContext(), *this, track);
<span class="line-modified">!     textTrack-&gt;setMediaElement(this);</span>
  
      // 2. Set the new text track&#39;s kind, label, and language based on the semantics of the relevant data,
      // as defined by the relevant specification. If there is no label in that data, then the label must
      // be set to the empty string.
      // 3. Associate the text track list of cues with the rules for updating the text track rendering appropriate
<span class="line-new-header">--- 4004,11 ---</span>
  void HTMLMediaElement::mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp; track)
  {
      // 4.8.10.12.2 Sourcing in-band text tracks
      // 1. Associate the relevant data with a new text track and its corresponding new TextTrack object.
      auto textTrack = InbandTextTrack::create(*ActiveDOMObject::scriptExecutionContext(), *this, track);
<span class="line-modified">!     textTrack-&gt;setMediaElement(makeWeakPtr(this));</span>
  
      // 2. Set the new text track&#39;s kind, label, and language based on the semantics of the relevant data,
      // as defined by the relevant specification. If there is no label in that data, then the label must
      // be set to the empty string.
      // 3. Associate the text track list of cues with the rules for updating the text track rendering appropriate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4195,27 ***</span>
  }
  
  AudioTrackList&amp; HTMLMediaElement::ensureAudioTracks()
  {
      if (!m_audioTracks)
<span class="line-modified">!         m_audioTracks = AudioTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
  
      return *m_audioTracks;
  }
  
  TextTrackList&amp; HTMLMediaElement::ensureTextTracks()
  {
      if (!m_textTracks)
<span class="line-modified">!         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
  
      return *m_textTracks;
  }
  
  VideoTrackList&amp; HTMLMediaElement::ensureVideoTracks()
  {
      if (!m_videoTracks)
<span class="line-modified">!         m_videoTracks = VideoTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
  
      return *m_videoTracks;
  }
  
  void HTMLMediaElement::didAddTextTrack(HTMLTrackElement&amp; trackElement)
<span class="line-new-header">--- 4161,27 ---</span>
  }
  
  AudioTrackList&amp; HTMLMediaElement::ensureAudioTracks()
  {
      if (!m_audioTracks)
<span class="line-modified">!         m_audioTracks = AudioTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
  
      return *m_audioTracks;
  }
  
  TextTrackList&amp; HTMLMediaElement::ensureTextTracks()
  {
      if (!m_textTracks)
<span class="line-modified">!         m_textTracks = TextTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
  
      return *m_textTracks;
  }
  
  VideoTrackList&amp; HTMLMediaElement::ensureVideoTracks()
  {
      if (!m_videoTracks)
<span class="line-modified">!         m_videoTracks = VideoTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
  
      return *m_videoTracks;
  }
  
  void HTMLMediaElement::didAddTextTrack(HTMLTrackElement&amp; trackElement)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4368,31 ***</span>
      }
  
      m_processingPreferenceChange = false;
  }
  
<span class="line-modified">! static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)</span>
  {
      JSC::VM&amp; vm = globalObject.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);</span>
  
      // Retrieve the controller through the JS object graph
      JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
      if (!mediaJSWrapperObject)
          return JSC::jsNull();
  
      JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
<span class="line-modified">!     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);</span>
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
      if (!controlsHostJSWrapperObject)
          return JSC::jsNull();
  
      JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);
<span class="line-modified">!     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);</span>
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      return controllerJSWrapper;
  }
  
<span class="line-new-header">--- 4334,31 ---</span>
      }
  
      m_processingPreferenceChange = false;
  }
  
<span class="line-modified">! static JSC::JSValue controllerJSValue(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)</span>
  {
      JSC::VM&amp; vm = globalObject.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto mediaJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, media);</span>
  
      // Retrieve the controller through the JS object graph
      JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
      if (!mediaJSWrapperObject)
          return JSC::jsNull();
  
      JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
<span class="line-modified">!     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;lexicalGlobalObject, controlsHost);</span>
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
      if (!controlsHostJSWrapperObject)
          return JSC::jsNull();
  
      JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);
<span class="line-modified">!     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;lexicalGlobalObject, controllerID);</span>
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      return controllerJSWrapper;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4415,15 ***</span>
      auto&amp; scriptController = document().frame()-&gt;script();
      auto* globalObject = JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(world));
      auto&amp; vm = globalObject-&gt;vm();
      JSC::JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* exec = globalObject-&gt;globalExec();</span>
  
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     return task(*globalObject, *exec, scriptController, world);</span>
  }
  
  void HTMLMediaElement::updateCaptionContainer()
  {
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
<span class="line-new-header">--- 4381,15 ---</span>
      auto&amp; scriptController = document().frame()-&gt;script();
      auto* globalObject = JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(world));
      auto&amp; vm = globalObject-&gt;vm();
      JSC::JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* lexicalGlobalObject = globalObject;</span>
  
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     return task(*globalObject, *lexicalGlobalObject, scriptController, world);</span>
  }
  
  void HTMLMediaElement::updateCaptionContainer()
  {
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4436,25 ***</span>
      ensureMediaControlsShadowRoot();
  
      if (!m_mediaControlsHost)
          m_mediaControlsHost = MediaControlsHost::create(this);
  
<span class="line-modified">!     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
          auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
          if (!controllerObject)
              return false;
  
          // The media controls script must provide a method on the Controller object with the following details.
          // Name: updateCaptionContainer
          // Parameters:
          //     None
          // Return value:
          //     None
<span class="line-modified">!         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
          auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
          if (!methodObject)
              return false;
  
          JSC::CallData callData;
<span class="line-new-header">--- 4402,25 ---</span>
      ensureMediaControlsShadowRoot();
  
      if (!m_mediaControlsHost)
          m_mediaControlsHost = MediaControlsHost::create(this);
  
<span class="line-modified">!     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
          auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
          if (!controllerObject)
              return false;
  
          // The media controls script must provide a method on the Controller object with the following details.
          // Name: updateCaptionContainer
          // Parameters:
          //     None
          // Return value:
          //     None
<span class="line-modified">!         auto methodValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
          auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
          if (!methodObject)
              return false;
  
          JSC::CallData callData;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4462,11 ***</span>
          if (callType == JSC::CallType::None)
              return false;
  
          JSC::MarkedArgumentBuffer noArguments;
          ASSERT(!noArguments.hasOverflowed());
<span class="line-modified">!         JSC::call(&amp;exec, methodObject, callType, callData, controllerObject, noArguments);</span>
          scope.clearException();
  
          m_haveSetUpCaptionContainer = true;
  
          return true;
<span class="line-new-header">--- 4428,11 ---</span>
          if (callType == JSC::CallType::None)
              return false;
  
          JSC::MarkedArgumentBuffer noArguments;
          ASSERT(!noArguments.hasOverflowed());
<span class="line-modified">!         JSC::call(&amp;lexicalGlobalObject, methodObject, callType, callData, controllerObject, noArguments);</span>
          scope.clearException();
  
          m_haveSetUpCaptionContainer = true;
  
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4705,11 ***</span>
              parameters.isMediaStream = mediaURL.protocolIs(mediaStreamBlobProtocol);
  #endif
              if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback() || Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source))
                  parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
  
<span class="line-modified">!             if (!MediaPlayer::supportsType(parameters))</span>
                  goto CheckAgain;
          }
  
          // Is it safe to load this url?
          if (!isSafeToLoadURL(mediaURL, actionIfInvalid) || !dispatchBeforeLoadEvent(mediaURL.string()))
<span class="line-new-header">--- 4671,11 ---</span>
              parameters.isMediaStream = mediaURL.protocolIs(mediaStreamBlobProtocol);
  #endif
              if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback() || Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source))
                  parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
  
<span class="line-modified">!             if (MediaPlayer::supportsType(parameters) == MediaPlayer::SupportsType::IsNotSupported)</span>
                  goto CheckAgain;
          }
  
          // Is it safe to load this url?
          if (!isSafeToLoadURL(mediaURL, actionIfInvalid) || !dispatchBeforeLoadEvent(mediaURL.string()))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4819,11 ***</span>
          m_currentSourceNode = nullptr;
          INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);
      }
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
  #if ENABLE(VIDEO_TRACK)
      updateActiveTextTrackCues(currentMediaTime());
<span class="line-new-header">--- 4785,11 ---</span>
          m_currentSourceNode = nullptr;
          INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);
      }
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerTimeChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
  #if ENABLE(VIDEO_TRACK)
      updateActiveTextTrackCues(currentMediaTime());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4947,11 ***</span>
      m_isScrubbingRemotely = false;
      m_seekToPlaybackPositionEndedTimer.stop();
  #endif
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerVolumeChanged(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
      if (m_player) {
<span class="line-new-header">--- 4913,11 ---</span>
      m_isScrubbingRemotely = false;
      m_seekToPlaybackPositionEndedTimer.stop();
  #endif
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerVolumeChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
      if (m_player) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4963,38 ***</span>
          }
      }
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerMuteChanged(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
      if (m_player)
          setMuted(m_player-&gt;muted());
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerDurationChanged(MediaPlayer* player)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
  
      scheduleEvent(eventNames().durationchangeEvent);
<span class="line-modified">!     mediaPlayerCharacteristicChanged(player);</span>
  
      MediaTime now = currentMediaTime();
      MediaTime dur = durationMediaTime();
      if (now &gt; dur)
          seekInternal(dur);
  
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerRateChanged(MediaPlayer*)</span>
  {
      beginProcessingMediaPlayerCallback();
  
      // Stash the rate in case the one we tried to set isn&#39;t what the engine is
      // using (eg. it can&#39;t handle the rate we set)
<span class="line-new-header">--- 4929,38 ---</span>
          }
      }
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerMuteChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
      if (m_player)
          setMuted(m_player-&gt;muted());
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerDurationChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
  
      scheduleEvent(eventNames().durationchangeEvent);
<span class="line-modified">!     mediaPlayerCharacteristicChanged();</span>
  
      MediaTime now = currentMediaTime();
      MediaTime dur = durationMediaTime();
      if (now &gt; dur)
          seekInternal(dur);
  
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerRateChanged()</span>
  {
      beginProcessingMediaPlayerCallback();
  
      // Stash the rate in case the one we tried to set isn&#39;t what the engine is
      // using (eg. it can&#39;t handle the rate we set)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5008,11 ***</span>
      updateSleepDisabling();
  
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerPlaybackStateChanged(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      if (!m_player || m_pausedInternal)
          return;
<span class="line-new-header">--- 4974,11 ---</span>
      updateSleepDisabling();
  
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerPlaybackStateChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      if (!m_player || m_pausedInternal)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5026,40 ***</span>
      updateSleepDisabling();
  
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerSawUnsupportedTracks(MediaPlayer*)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     INFO_LOG(LOGIDENTIFIER);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The MediaPlayer came across content it cannot completely handle.</span>
<span class="line-removed">-     // This is normally acceptable except when we are in a standalone</span>
<span class="line-removed">-     // MediaDocument. If so, tell the document what has happened.</span>
<span class="line-removed">-     if (is&lt;MediaDocument&gt;(document()))</span>
<span class="line-removed">-         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void HTMLMediaElement::mediaPlayerResourceNotSupported(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      // The MediaPlayer came across content which no installed engine supports.
<span class="line-modified">!     mediaLoadingFailed(MediaPlayer::FormatError);</span>
  }
  
  // MediaPlayerPresentation methods
<span class="line-modified">! void HTMLMediaElement::mediaPlayerRepaint(MediaPlayer*)</span>
  {
      beginProcessingMediaPlayerCallback();
      updateDisplayState();
      if (auto* renderer = this-&gt;renderer())
          renderer-&gt;repaint();
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerSizeChanged(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      if (is&lt;MediaDocument&gt;(document()) &amp;&amp; m_player)
          downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
<span class="line-new-header">--- 4992,29 ---</span>
      updateSleepDisabling();
  
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerResourceNotSupported()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      // The MediaPlayer came across content which no installed engine supports.
<span class="line-modified">!     mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
  }
  
  // MediaPlayerPresentation methods
<span class="line-modified">! void HTMLMediaElement::mediaPlayerRepaint()</span>
  {
      beginProcessingMediaPlayerCallback();
      updateDisplayState();
      if (auto* renderer = this-&gt;renderer())
          renderer-&gt;repaint();
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerSizeChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      if (is&lt;MediaDocument&gt;(document()) &amp;&amp; m_player)
          downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5069,18 ***</span>
          scheduleResizeEventIfSizeChanged();
      updateRenderer();
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! bool HTMLMediaElement::mediaPlayerRenderingCanBeAccelerated(MediaPlayer*)</span>
  {
      auto* renderer = this-&gt;renderer();
      return is&lt;RenderVideo&gt;(renderer)
          &amp;&amp; downcast&lt;RenderVideo&gt;(*renderer).view().compositor().canAccelerateVideoRendering(downcast&lt;RenderVideo&gt;(*renderer));
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerRenderingModeChanged(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      // Kick off a fake recalcStyle that will update the compositing tree.
      invalidateStyleAndLayerComposition();
<span class="line-new-header">--- 5024,18 ---</span>
          scheduleResizeEventIfSizeChanged();
      updateRenderer();
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! bool HTMLMediaElement::mediaPlayerRenderingCanBeAccelerated()</span>
  {
      auto* renderer = this-&gt;renderer();
      return is&lt;RenderVideo&gt;(renderer)
          &amp;&amp; downcast&lt;RenderVideo&gt;(*renderer).view().compositor().canAccelerateVideoRendering(downcast&lt;RenderVideo&gt;(*renderer));
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerRenderingModeChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      // Kick off a fake recalcStyle that will update the compositing tree.
      invalidateStyleAndLayerComposition();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5091,11 ***</span>
      return document().settings().acceleratedCompositingEnabled();
  }
  
  #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
  
<span class="line-modified">! GraphicsDeviceAdapter* HTMLMediaElement::mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const</span>
  {
      auto* page = document().page();
      if (!page)
          return nullptr;
      return page-&gt;chrome().client().graphicsDeviceAdapter();
<span class="line-new-header">--- 5046,11 ---</span>
      return document().settings().acceleratedCompositingEnabled();
  }
  
  #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
  
<span class="line-modified">! GraphicsDeviceAdapter* HTMLMediaElement::mediaPlayerGraphicsDeviceAdapter() const</span>
  {
      auto* page = document().page();
      if (!page)
          return nullptr;
      return page-&gt;chrome().client().graphicsDeviceAdapter();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5151,11 ***</span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      scheduleUpdateMediaState();
  #endif
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerEngineUpdated(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
  #if ENABLE(MEDIA_SOURCE)
      m_droppedVideoFrames = 0;
<span class="line-new-header">--- 5106,11 ---</span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      scheduleUpdateMediaState();
  #endif
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerEngineUpdated()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
  #if ENABLE(MEDIA_SOURCE)
      m_droppedVideoFrames = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5164,23 ***</span>
      m_havePreparedToPlay = false;
  
      scheduleMediaEngineWasUpdated();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerFirstVideoFrameAvailable(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER, &quot;current display mode = &quot;, (int)displayMode());
  
      beginProcessingMediaPlayerCallback();
      if (displayMode() == PosterWaitingForVideo) {
          setDisplayMode(Video);
<span class="line-modified">!         mediaPlayerRenderingModeChanged(m_player.get());</span>
      }
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerCharacteristicChanged(MediaPlayer*)</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
  
<span class="line-new-header">--- 5119,23 ---</span>
      m_havePreparedToPlay = false;
  
      scheduleMediaEngineWasUpdated();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerFirstVideoFrameAvailable()</span>
  {
      INFO_LOG(LOGIDENTIFIER, &quot;current display mode = &quot;, (int)displayMode());
  
      beginProcessingMediaPlayerCallback();
      if (displayMode() == PosterWaitingForVideo) {
          setDisplayMode(Video);
<span class="line-modified">!         mediaPlayerRenderingModeChanged();</span>
      }
      endProcessingMediaPlayerCallback();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerCharacteristicChanged()</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      beginProcessingMediaPlayerCallback();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5189,11 ***</span>
          markCaptionAndSubtitleTracksAsUnconfigured(AfterDelay);
  #endif
  
      if (potentiallyPlaying() &amp;&amp; displayMode() == PosterWaitingForVideo) {
          setDisplayMode(Video);
<span class="line-modified">!         mediaPlayerRenderingModeChanged(m_player.get());</span>
      }
  
      if (hasMediaControls())
          mediaControls()-&gt;reset();
      updateRenderer();
<span class="line-new-header">--- 5144,11 ---</span>
          markCaptionAndSubtitleTracksAsUnconfigured(AfterDelay);
  #endif
  
      if (potentiallyPlaying() &amp;&amp; displayMode() == PosterWaitingForVideo) {
          setDisplayMode(Video);
<span class="line-modified">!         mediaPlayerRenderingModeChanged();</span>
      }
  
      if (hasMediaControls())
          mediaControls()-&gt;reset();
      updateRenderer();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5525,10 ***</span>
<span class="line-new-header">--- 5480,16 ---</span>
  {
      m_pausedInternal = b;
      scheduleUpdatePlayState();
  }
  
<span class="line-added">+ void HTMLMediaElement::pauseAndUpdatePlayStateImmediately()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_pausedInternal = true;</span>
<span class="line-added">+     updatePlayState();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void HTMLMediaElement::stopPeriodicTimers()
  {
      m_progressEventTimer.stop();
      m_playbackProgressTimer.stop();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5619,11 ***</span>
  #if ENABLE(VIDEO_TRACK)
      forgetResourceSpecificTracks();
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {</span>
          m_hasPlaybackTargetAvailabilityListeners = false;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
  
          // Send an availability event in case scripts want to hide the picker when the element
          // doesn&#39;t support playback to a target.
<span class="line-new-header">--- 5580,11 ---</span>
  #if ENABLE(VIDEO_TRACK)
      forgetResourceSpecificTracks();
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
          m_hasPlaybackTargetAvailabilityListeners = false;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
  
          // Send an availability event in case scripts want to hide the picker when the element
          // doesn&#39;t support playback to a target.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5661,15 ***</span>
      m_resourceSelectionTaskQueue.cancelAllTasks();
  
      updateSleepDisabling();
  }
  
<span class="line-removed">- bool HTMLMediaElement::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  const char* HTMLMediaElement::activeDOMObjectName() const
  {
      return &quot;HTMLMediaElement&quot;;
  }
  
<span class="line-new-header">--- 5622,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5685,12 ***</span>
      schedulePlaybackControlsManagerUpdate();
      setInActiveDocument(false);
  
      // Stop the playback without generating events
      setPlaying(false);
<span class="line-modified">!     setPausedInternal(true);</span>
<span class="line-modified">!     m_mediaSession-&gt;stopSession();</span>
  
      setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
  
      userCancelledLoad();
  
<span class="line-new-header">--- 5641,12 ---</span>
      schedulePlaybackControlsManagerUpdate();
      setInActiveDocument(false);
  
      // Stop the playback without generating events
      setPlaying(false);
<span class="line-modified">!     pauseAndUpdatePlayStateImmediately();</span>
<span class="line-modified">!     m_mediaSession-&gt;clientWillBeDOMSuspended();</span>
  
      setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
  
      userCancelledLoad();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5718,11 ***</span>
      m_resourceSelectionTaskQueue.close();
      m_visibilityChangeTaskQueue.close();
  #if ENABLE(ENCRYPTED_MEDIA)
      m_encryptedMediaQueue.close();
  #endif
<span class="line-modified">!     m_asyncEventQueue.close();</span>
  #if PLATFORM(IOS_FAMILY)
      m_volumeRevertTaskQueue.close();
  #endif
  }
  
<span class="line-new-header">--- 5674,11 ---</span>
      m_resourceSelectionTaskQueue.close();
      m_visibilityChangeTaskQueue.close();
  #if ENABLE(ENCRYPTED_MEDIA)
      m_encryptedMediaQueue.close();
  #endif
<span class="line-modified">!     m_asyncEventQueue-&gt;close();</span>
  #if PLATFORM(IOS_FAMILY)
      m_volumeRevertTaskQueue.close();
  #endif
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5757,13 ***</span>
      Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
  
      m_resumeTaskQueue.cancelTask();
  
      switch (reason) {
<span class="line-modified">!     case ReasonForSuspension::PageCache:</span>
          stopWithoutDestroyingMediaPlayer();
<span class="line-removed">-         m_asyncEventQueue.suspend();</span>
          setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);
          m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
          break;
      case ReasonForSuspension::PageWillBeSuspended:
      case ReasonForSuspension::JavaScriptDebuggerPaused:
<span class="line-new-header">--- 5713,12 ---</span>
      Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
  
      m_resumeTaskQueue.cancelTask();
  
      switch (reason) {
<span class="line-modified">!     case ReasonForSuspension::BackForwardCache:</span>
          stopWithoutDestroyingMediaPlayer();
          setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);
          m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
          break;
      case ReasonForSuspension::PageWillBeSuspended:
      case ReasonForSuspension::JavaScriptDebuggerPaused:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5777,22 ***</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      setInActiveDocument(true);
  
<span class="line-removed">-     m_asyncEventQueue.resume();</span>
<span class="line-removed">- </span>
      if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
          document().addMediaCanStartListener(*this);
      else
          setPausedInternal(false);
  
      m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
      m_mediaSession-&gt;updateBufferingPolicy();
  
      if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
<span class="line-modified">!         // Restart the load if it was aborted in the middle by moving the document to the page cache.</span>
          // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
          //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
          // This behavior is not specified but it seems like a sensible thing to do.
          // As it is not safe to immedately start loading now, let&#39;s schedule a load.
          m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
<span class="line-new-header">--- 5732,20 ---</span>
  {
      INFO_LOG(LOGIDENTIFIER);
  
      setInActiveDocument(true);
  
      if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
          document().addMediaCanStartListener(*this);
      else
          setPausedInternal(false);
  
      m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
      m_mediaSession-&gt;updateBufferingPolicy();
  
      if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
<span class="line-modified">!         // Restart the load if it was aborted in the middle by moving the document to the back/forward cache.</span>
          // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
          //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
          // This behavior is not specified but it seems like a sensible thing to do.
          // As it is not safe to immedately start loading now, let&#39;s schedule a load.
          m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5801,17 ***</span>
      updateRenderer();
  }
  
  bool HTMLMediaElement::hasPendingActivity() const
  {
<span class="line-modified">!     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue.hasPendingEvents() || m_creatingControls;</span>
  }
  
  void HTMLMediaElement::mediaVolumeDidChange()
  {
      INFO_LOG(LOGIDENTIFIER);
      updateVolume();
  }
  
  void HTMLMediaElement::visibilityStateChanged()
  {
      bool elementIsHidden = document().hidden() &amp;&amp; m_videoFullscreenMode != VideoFullscreenModePictureInPicture;
<span class="line-new-header">--- 5754,20 ---</span>
      updateRenderer();
  }
  
  bool HTMLMediaElement::hasPendingActivity() const
  {
<span class="line-modified">!     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue-&gt;hasPendingEvents() || m_creatingControls;</span>
  }
  
  void HTMLMediaElement::mediaVolumeDidChange()
  {
<span class="line-added">+     // FIXME: We should try to reconcile this so there&#39;s no difference for PLATFORM(IOS_FAMILY).</span>
<span class="line-added">+ #if !PLATFORM(IOS_FAMILY)</span>
      INFO_LOG(LOGIDENTIFIER);
      updateVolume();
<span class="line-added">+ #endif</span>
  }
  
  void HTMLMediaElement::visibilityStateChanged()
  {
      bool elementIsHidden = document().hidden() &amp;&amp; m_videoFullscreenMode != VideoFullscreenModePictureInPicture;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5866,25 ***</span>
      m_mediaSession-&gt;showPlaybackTargetPicker();
  }
  
  void HTMLMediaElement::wirelessRoutesAvailableDidChange()
  {
      enqueuePlaybackTargetAvailabilityChangedEvent();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*)</span>
  {
<span class="line-modified">!     setIsPlayingToWirelessTarget(m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless());</span>
  }
  
  void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
  {
      m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
          if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
              return;
          m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
<span class="line-modified">! </span>
          ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
          configureMediaControls();
          m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
          m_mediaSession-&gt;canProduceAudioChanged();
          scheduleUpdateMediaState();
<span class="line-new-header">--- 5822,28 ---</span>
      m_mediaSession-&gt;showPlaybackTargetPicker();
  }
  
  void HTMLMediaElement::wirelessRoutesAvailableDidChange()
  {
<span class="line-added">+     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();</span>
<span class="line-added">+     m_remote-&gt;availabilityChanged(hasTargets);</span>
<span class="line-added">+ </span>
      enqueuePlaybackTargetAvailabilityChangedEvent();
  }
  
<span class="line-modified">! void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool isCurrentPlayBackTargetWireless)</span>
  {
<span class="line-modified">!     setIsPlayingToWirelessTarget(m_player &amp;&amp; isCurrentPlayBackTargetWireless);</span>
  }
  
  void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
  {
      m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
          if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
              return;
          m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
<span class="line-modified">!         m_remote-&gt;isPlayingToRemoteTargetChanged(m_isPlayingToWirelessTarget);</span>
          ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
          configureMediaControls();
          m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
          m_mediaSession-&gt;canProduceAudioChanged();
          scheduleUpdateMediaState();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5910,11 ***</span>
  bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
  {
      if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
          return Node::addEventListener(eventType, WTFMove(listener), options);
  
<span class="line-modified">!     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);</span>
      if (!Node::addEventListener(eventType, WTFMove(listener), options))
          return false;
  
      if (isFirstAvailabilityChangedListener) {
          m_hasPlaybackTargetAvailabilityListeners = true;
<span class="line-new-header">--- 5869,12 ---</span>
  bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
  {
      if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
          return Node::addEventListener(eventType, WTFMove(listener), options);
  
<span class="line-modified">!     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) &amp;&amp; !m_remote-&gt;hasAvailabilityCallbacks();</span>
<span class="line-added">+ </span>
      if (!Node::addEventListener(eventType, WTFMove(listener), options))
          return false;
  
      if (isFirstAvailabilityChangedListener) {
          m_hasPlaybackTargetAvailabilityListeners = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5933,11 ***</span>
          return Node::removeEventListener(eventType, listener, options);
  
      if (!Node::removeEventListener(eventType, listener, options))
          return false;
  
<span class="line-modified">!     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);</span>
      INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
      if (didRemoveLastAvailabilityChangedListener) {
          m_hasPlaybackTargetAvailabilityListeners = false;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
          scheduleUpdateMediaState();
<span class="line-new-header">--- 5893,11 ---</span>
          return Node::removeEventListener(eventType, listener, options);
  
      if (!Node::removeEventListener(eventType, listener, options))
          return false;
  
<span class="line-modified">!     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) &amp;&amp; !m_remote-&gt;hasAvailabilityCallbacks();</span>
      INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
      if (didRemoveLastAvailabilityChangedListener) {
          m_hasPlaybackTargetAvailabilityListeners = false;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
          scheduleUpdateMediaState();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5950,29 ***</span>
  {
      bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();
      INFO_LOG(LOGIDENTIFIER, &quot;hasTargets = &quot;, hasTargets);
      auto event = WebKitPlaybackTargetAvailabilityEvent::create(eventNames().webkitplaybacktargetavailabilitychangedEvent, hasTargets);
      event-&gt;setTarget(this);
<span class="line-modified">!     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
      scheduleUpdateMediaState();
  }
  
  void HTMLMediaElement::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
  {
      ALWAYS_LOG(LOGIDENTIFIER);
      if (m_player)
          m_player-&gt;setWirelessPlaybackTarget(WTFMove(device));
  }
  
  void HTMLMediaElement::setShouldPlayToPlaybackTarget(bool shouldPlay)
  {
      ALWAYS_LOG(LOGIDENTIFIER, shouldPlay);
  
      if (m_player)
          m_player-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
  }
  
  #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
  
  bool HTMLMediaElement::webkitCurrentPlaybackTargetIsWireless() const
  {
      INFO_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
<span class="line-new-header">--- 5910,48 ---</span>
  {
      bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();
      INFO_LOG(LOGIDENTIFIER, &quot;hasTargets = &quot;, hasTargets);
      auto event = WebKitPlaybackTargetAvailabilityEvent::create(eventNames().webkitplaybacktargetavailabilitychangedEvent, hasTargets);
      event-&gt;setTarget(this);
<span class="line-modified">!     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
      scheduleUpdateMediaState();
  }
  
  void HTMLMediaElement::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
  {
      ALWAYS_LOG(LOGIDENTIFIER);
<span class="line-added">+     bool hasActiveRoute = device-&gt;hasActiveRoute();</span>
      if (m_player)
          m_player-&gt;setWirelessPlaybackTarget(WTFMove(device));
<span class="line-added">+ </span>
<span class="line-added">+     m_remote-&gt;shouldPlayToRemoteTargetChanged(hasActiveRoute);</span>
  }
  
  void HTMLMediaElement::setShouldPlayToPlaybackTarget(bool shouldPlay)
  {
      ALWAYS_LOG(LOGIDENTIFIER, shouldPlay);
  
      if (m_player)
          m_player-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
  }
  
<span class="line-added">+ void HTMLMediaElement::playbackTargetPickerWasDismissed()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_remote-&gt;playbackTargetPickerWasDismissed();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void HTMLMediaElement::remoteHasAvailabilityCallbacksChanged()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool hasListeners = hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks();</span>
<span class="line-added">+     if (m_hasPlaybackTargetAvailabilityListeners == hasListeners)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     INFO_LOG(LOGIDENTIFIER, &quot;hasListeners: &quot;, hasListeners);</span>
<span class="line-added">+     m_hasPlaybackTargetAvailabilityListeners = hasListeners;</span>
<span class="line-added">+     m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(hasListeners);</span>
<span class="line-added">+     scheduleUpdateMediaState();</span>
<span class="line-added">+ }</span>
  #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
  
  bool HTMLMediaElement::webkitCurrentPlaybackTargetIsWireless() const
  {
      INFO_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6032,11 ***</span>
          enterFullscreen();
  }
  
  void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER);</span>
      ASSERT(mode != VideoFullscreenModeNone);
  
      if (m_videoFullscreenMode == mode)
          return;
  
<span class="line-new-header">--- 6011,11 ---</span>
          enterFullscreen();
  }
  
  void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, &quot;, m_videoFullscreenMode = &quot;, m_videoFullscreenMode, &quot;, mode = &quot;, mode);</span>
      ASSERT(mode != VideoFullscreenModeNone);
  
      if (m_videoFullscreenMode == mode)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6061,10 ***</span>
<span class="line-new-header">--- 6040,11 ---</span>
          if (hasMediaControls())
              mediaControls()-&gt;enteredFullscreen();
          if (is&lt;HTMLVideoElement&gt;(*this)) {
              HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
              if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {
<span class="line-added">+                 INFO_LOG(LOGIDENTIFIER, &quot;Entering fullscreen mode &quot;, m_videoFullscreenMode, &quot;, m_videoFullscreenStandby = &quot;, m_videoFullscreenStandby);</span>
                  document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
                  scheduleEvent(eventNames().webkitbeginfullscreenEvent);
              }
          }
      });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6179,10 ***</span>
<span class="line-new-header">--- 6159,11 ---</span>
      Element::willBecomeFullscreenElement();
  }
  
  void HTMLMediaElement::didBecomeFullscreenElement()
  {
<span class="line-added">+     INFO_LOG(LOGIDENTIFIER, &quot;, fullscreen mode = &quot;, fullscreenMode());</span>
      m_waitingToEnterFullscreen = false;
      if (hasMediaControls())
          mediaControls()-&gt;enteredFullscreen();
      scheduleUpdatePlayState();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6210,10 ***</span>
<span class="line-new-header">--- 6191,11 ---</span>
      }
  }
  
  void HTMLMediaElement::waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
  {
<span class="line-added">+     INFO_LOG(LOGIDENTIFIER);</span>
      ASSERT(!m_preparedForInlineCompletionHandler);
      if (m_preparedForInline)  {
          completionHandler();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6234,10 ***</span>
<span class="line-new-header">--- 6216,11 ---</span>
      return !m_videoFullscreenLayer;
  };
  
  void HTMLMediaElement::setVideoFullscreenLayer(PlatformLayer* platformLayer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
  {
<span class="line-added">+     INFO_LOG(LOGIDENTIFIER);</span>
      m_videoFullscreenLayer = platformLayer;
      if (!m_player) {
          completionHandler();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6440,14 ***</span>
<span class="line-new-header">--- 6423,19 ---</span>
      MediaPlayer::resetMediaEngines();
  }
  
  void HTMLMediaElement::privateBrowsingStateDidChange(PAL::SessionID sessionID)
  {
<span class="line-added">+     // FIXME: We should try to reconcile this so there&#39;s no difference for PLATFORM(IOS_FAMILY).</span>
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     UNUSED_PARAM(sessionID);</span>
<span class="line-added">+ #else</span>
      if (!m_player)
          return;
  
      m_player-&gt;setPrivateBrowsingMode(sessionID.isEphemeral());
<span class="line-added">+ #endif</span>
  }
  
  MediaControls* HTMLMediaElement::mediaControls() const
  {
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6580,10 ***</span>
<span class="line-new-header">--- 6568,11 ---</span>
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      if (!m_haveVisibleTextTrack)
          return;
  
      ensureMediaControlsShadowRoot();
<span class="line-added">+     updateTextTrackDisplay();</span>
  #else
      if (!m_haveVisibleTextTrack &amp;&amp; !hasMediaControls())
          return;
      if (!hasMediaControls() &amp;&amp; !createMediaControls())
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6603,11 ***</span>
      if (hasMediaControls())
          mediaControls()-&gt;textTrackPreferencesChanged();
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      if (m_mediaControlsHost)
<span class="line-modified">!         m_mediaControlsHost-&gt;updateCaptionDisplaySizes();</span>
  #endif
  
      if (m_player)
          m_player-&gt;tracksChanged();
  
<span class="line-new-header">--- 6592,11 ---</span>
      if (hasMediaControls())
          mediaControls()-&gt;textTrackPreferencesChanged();
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      if (m_mediaControlsHost)
<span class="line-modified">!         m_mediaControlsHost-&gt;updateCaptionDisplaySizes(MediaControlsHost::ForceUpdate::Yes);</span>
  #endif
  
      if (m_player)
          m_player-&gt;tracksChanged();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6700,21 ***</span>
          m_audioSourceNode-&gt;unlock();
      }
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {</span>
          m_hasPlaybackTargetAvailabilityListeners = true;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
          enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
      }
  #endif
  
      updateSleepDisabling();
  }
  
  #if ENABLE(WEB_AUDIO)
  void HTMLMediaElement::setAudioSourceNode(MediaElementAudioSourceNode* sourceNode)
  {
      m_audioSourceNode = sourceNode;
  
      if (audioSourceProvider())
<span class="line-new-header">--- 6689,22 ---</span>
          m_audioSourceNode-&gt;unlock();
      }
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
          m_hasPlaybackTargetAvailabilityListeners = true;
          m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
          enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
      }
  #endif
  
      updateSleepDisabling();
  }
  
  #if ENABLE(WEB_AUDIO)
<span class="line-added">+ </span>
  void HTMLMediaElement::setAudioSourceNode(MediaElementAudioSourceNode* sourceNode)
  {
      m_audioSourceNode = sourceNode;
  
      if (audioSourceProvider())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6724,12 ***</span>
  AudioSourceProvider* HTMLMediaElement::audioSourceProvider()
  {
      if (m_player)
          return m_player-&gt;audioSourceProvider();
  
<span class="line-modified">!     return 0;</span>
  }
  #endif
  
  const String&amp; HTMLMediaElement::mediaGroup() const
  {
      return m_mediaGroup;
<span class="line-new-header">--- 6714,13 ---</span>
  AudioSourceProvider* HTMLMediaElement::audioSourceProvider()
  {
      if (m_player)
          return m_player-&gt;audioSourceProvider();
  
<span class="line-modified">!     return nullptr;</span>
  }
<span class="line-added">+ </span>
  #endif
  
  const String&amp; HTMLMediaElement::mediaGroup() const
  {
      return m_mediaGroup;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6751,26 ***</span>
      if (group.isEmpty())
          return;
  
      // 4. If there is another media element whose Document is the same as m&#39;s Document (even if one or both
      // of these elements are not actually in the Document),
<span class="line-modified">!     HashSet&lt;HTMLMediaElement*&gt; elements = documentToElementSetMap().get(&amp;document());</span>
<span class="line-modified">!     for (auto&amp; element : elements) {</span>
<span class="line-removed">-         if (element == this)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
          // and which also has a mediagroup attribute, and whose mediagroup attribute has the same value as
          // the new value of m&#39;s mediagroup attribute,
<span class="line-modified">!         if (element-&gt;mediaGroup() == group) {</span>
              //  then let controller be that media element&#39;s current media controller.
<span class="line-modified">!             setController(element-&gt;controller());</span>
<span class="line-removed">-             return;</span>
          }
<span class="line-modified">!     }</span>
  
      // Otherwise, let controller be a newly created MediaController.
<span class="line-modified">!     setController(MediaController::create(document()));</span>
  }
  
  MediaController* HTMLMediaElement::controller() const
  {
      return m_mediaController.get();
<span class="line-new-header">--- 6742,23 ---</span>
      if (group.isEmpty())
          return;
  
      // 4. If there is another media element whose Document is the same as m&#39;s Document (even if one or both
      // of these elements are not actually in the Document),
<span class="line-modified">!     // FIXME: It does not seem OK that this algorithm iterates the media elements in a random order.</span>
<span class="line-modified">!     document().forEachMediaElement([&amp;] (HTMLMediaElement&amp; element) {</span>
          // and which also has a mediagroup attribute, and whose mediagroup attribute has the same value as
          // the new value of m&#39;s mediagroup attribute,
<span class="line-modified">!         if (&amp;element != this &amp;&amp; !controller() &amp;&amp; element.mediaGroup() == group) {</span>
              //  then let controller be that media element&#39;s current media controller.
<span class="line-modified">!             setController(element.controller());</span>
          }
<span class="line-modified">!     });</span>
  
      // Otherwise, let controller be a newly created MediaController.
<span class="line-modified">!     if (!controller())</span>
<span class="line-added">+         setController(MediaController::create(document()));</span>
  }
  
  MediaController* HTMLMediaElement::controller() const
  {
      return m_mediaController.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7052,16 ***</span>
      if (auto page = document().page())
          return page-&gt;pageScaleFactor() * page-&gt;deviceScaleFactor();
      return 1;
  }
  
<span class="line-removed">- void HTMLMediaElement::mediaPlayerSetSize(const IntSize&amp; size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     setIntegralAttribute(widthAttr, size.width());</span>
<span class="line-removed">-     setIntegralAttribute(heightAttr, size.height());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void HTMLMediaElement::mediaPlayerPause()
  {
      pause();
  }
  
<span class="line-new-header">--- 7040,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7073,15 ***</span>
  bool HTMLMediaElement::mediaPlayerPlatformVolumeConfigurationRequired() const
  {
      return !m_volumeInitialized;
  }
  
<span class="line-removed">- bool HTMLMediaElement::mediaPlayerIsPaused() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return paused();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool HTMLMediaElement::mediaPlayerIsLooping() const
  {
      return loop();
  }
  
<span class="line-new-header">--- 7055,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7105,11 ***</span>
  }
  
  bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
  {
      if (Page* page = document().page())
<span class="line-modified">!         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabled();</span>
  
      return false;
  }
  
  const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
<span class="line-new-header">--- 7082,11 ---</span>
  }
  
  bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
  {
      if (Page* page = document().page())
<span class="line-modified">!         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabledByWebInspector();</span>
  
      return false;
  }
  
  const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7126,16 ***</span>
<span class="line-new-header">--- 7103,19 ---</span>
      return emptyString();
  }
  
  Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
  {
<span class="line-added">+ #if ENABLE(VIDEO_TRACK)</span>
      if (Page* page = document().page())
          return page-&gt;group().captionPreferences().preferredAudioCharacteristics();
<span class="line-added">+ #endif</span>
      return Vector&lt;String&gt;();
  }
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-added">+ </span>
  String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
  {
      return DeprecatedGlobalSettings::networkInterfaceName();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7143,16 ***</span>
  {
      if (auto* page = document().page())
          return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
      return false;
  }
<span class="line-removed">- #endif</span>
  
<span class="line-modified">! bool HTMLMediaElement::mediaPlayerIsInMediaDocument() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return document().isMediaDocument();</span>
<span class="line-removed">- }</span>
  
  void HTMLMediaElement::mediaPlayerEngineFailedToLoad() const
  {
      if (!m_player)
          return;
<span class="line-new-header">--- 7123,12 ---</span>
  {
      if (auto* page = document().page())
          return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
      return false;
  }
  
<span class="line-modified">! #endif</span>
  
  void HTMLMediaElement::mediaPlayerEngineFailedToLoad() const
  {
      if (!m_player)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7253,11 ***</span>
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
  DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
  {
      if (!m_isolatedWorld)
<span class="line-modified">!         m_isolatedWorld = DOMWrapperWorld::create(commonVM());</span>
      return *m_isolatedWorld;
  }
  
  bool HTMLMediaElement::ensureMediaControlsInjectedScript()
  {
<span class="line-new-header">--- 7229,11 ---</span>
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
  DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
  {
      if (!m_isolatedWorld)
<span class="line-modified">!         m_isolatedWorld = DOMWrapperWorld::create(commonVM(), DOMWrapperWorld::Type::Internal, makeString(&quot;Media Controls (&quot;, localName(), &#39;)&#39;));</span>
      return *m_isolatedWorld;
  }
  
  bool HTMLMediaElement::ensureMediaControlsInjectedScript()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7269,25 ***</span>
  
      String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
      if (!mediaControlsScript.length())
          return false;
  
<span class="line-modified">!     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
          if (functionValue.isFunction(vm))
              return true;
  
  #ifndef NDEBUG
          // Setting a scriptURL allows the source to be debuggable in the inspector.
          URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
  #else
          URL scriptURL;
  #endif
<span class="line-modified">!         scriptController.evaluateInWorld(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);</span>
          if (UNLIKELY(scope.exception())) {
              scope.clearException();
              return false;
          }
  
<span class="line-new-header">--- 7245,25 ---</span>
  
      String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
      if (!mediaControlsScript.length())
          return false;
  
<span class="line-modified">!     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
          if (functionValue.isFunction(vm))
              return true;
  
  #ifndef NDEBUG
          // Setting a scriptURL allows the source to be debuggable in the inspector.
          URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
  #else
          URL scriptURL;
  #endif
<span class="line-modified">!         scriptController.evaluateInWorldIgnoringException(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);</span>
          if (UNLIKELY(scope.exception())) {
              scope.clearException();
              return false;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7314,22 ***</span>
      setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
  }
  
  void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
  {
<span class="line-modified">!     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
<span class="line-modified">!         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
          if (controllerValue.isNull())
              return false;
  
          JSC::PutPropertySlot propertySlot(controllerValue);
<span class="line-modified">!         auto* controllerObject = controllerValue.toObject(&amp;exec);</span>
          if (!controllerObject)
              return false;
  
<span class="line-modified">!         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
  
          return true;
      });
  }
  
<span class="line-new-header">--- 7290,22 ---</span>
      setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
  }
  
  void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
  {
<span class="line-modified">!     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
<span class="line-modified">!         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
          if (controllerValue.isNull())
              return false;
  
          JSC::PutPropertySlot propertySlot(controllerValue);
<span class="line-modified">!         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
          if (!controllerObject)
              return false;
  
<span class="line-modified">!         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
  
          return true;
      });
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7338,11 ***</span>
      INFO_LOG(LOGIDENTIFIER);
  
      if (!ensureMediaControlsInjectedScript())
          return;
  
<span class="line-modified">!     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
          // The media controls script must provide a method with the following details.
          // Name: createControls
<span class="line-new-header">--- 7314,11 ---</span>
      INFO_LOG(LOGIDENTIFIER);
  
      if (!ensureMediaControlsInjectedScript())
          return;
  
<span class="line-modified">!     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
          // The media controls script must provide a method with the following details.
          // Name: createControls
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7351,55 ***</span>
          //     2. This object (and HTMLMediaElement).
          //     3. The MediaControlsHost object.
          // Return value:
          //     A reference to the created media controller instance.
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
          if (functionValue.isUndefinedOrNull())
              return false;
  
          if (!m_mediaControlsHost)
              m_mediaControlsHost = MediaControlsHost::create(this);
  
<span class="line-modified">!         auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, *this);</span>
<span class="line-modified">!         auto mediaControlsHostJSWrapper = toJS(&amp;exec, &amp;globalObject, *m_mediaControlsHost);</span>
  
          JSC::MarkedArgumentBuffer argList;
<span class="line-modified">!         argList.append(toJS(&amp;exec, &amp;globalObject, root));</span>
          argList.append(mediaJSWrapper);
          argList.append(mediaControlsHostJSWrapper);
          ASSERT(!argList.hasOverflowed());
  
<span class="line-modified">!         auto* function = functionValue.toObject(&amp;exec);</span>
          scope.assertNoException();
          JSC::CallData callData;
          auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
          if (callType == JSC::CallType::None)
              return false;
  
<span class="line-modified">!         auto controllerValue = JSC::call(&amp;exec, function, callType, callData, &amp;globalObject, argList);</span>
          scope.clearException();
          auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
          if (!controllerObject)
              return false;
  
          // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
<span class="line-modified">!         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);</span>
          scope.assertNoException();
          auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
  
<span class="line-modified">!         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));</span>
  
          mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
  
          auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
          if (!mediaControlsHostJSWrapperObject)
              return false;
  
          auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);
  
<span class="line-modified">!         ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));</span>
  
          mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
  
          updatePageScaleFactorJSProperty();
          updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
<span class="line-new-header">--- 7327,55 ---</span>
          //     2. This object (and HTMLMediaElement).
          //     3. The MediaControlsHost object.
          // Return value:
          //     A reference to the created media controller instance.
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
          if (functionValue.isUndefinedOrNull())
              return false;
  
          if (!m_mediaControlsHost)
              m_mediaControlsHost = MediaControlsHost::create(this);
  
<span class="line-modified">!         auto mediaJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, *this);</span>
<span class="line-modified">!         auto mediaControlsHostJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, *m_mediaControlsHost);</span>
  
          JSC::MarkedArgumentBuffer argList;
<span class="line-modified">!         argList.append(toJS(&amp;lexicalGlobalObject, &amp;globalObject, root));</span>
          argList.append(mediaJSWrapper);
          argList.append(mediaControlsHostJSWrapper);
          ASSERT(!argList.hasOverflowed());
  
<span class="line-modified">!         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
          scope.assertNoException();
          JSC::CallData callData;
          auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
          if (callType == JSC::CallType::None)
              return false;
  
<span class="line-modified">!         auto controllerValue = JSC::call(&amp;lexicalGlobalObject, function, callType, callData, &amp;globalObject, argList);</span>
          scope.clearException();
          auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
          if (!controllerObject)
              return false;
  
          // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
<span class="line-modified">!         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;lexicalGlobalObject);</span>
          scope.assertNoException();
          auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
  
<span class="line-modified">!         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;lexicalGlobalObject, controlsHost));</span>
  
          mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
  
          auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
          if (!mediaControlsHostJSWrapperObject)
              return false;
  
          auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);
  
<span class="line-modified">!         ASSERT(!controllerObject-&gt;hasProperty(&amp;lexicalGlobalObject, controller));</span>
  
          mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
  
          updatePageScaleFactorJSProperty();
          updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7419,19 ***</span>
          INFO_LOG(LOGIDENTIFIER, &quot;forced to false by Settings value&quot;);
          m_mediaControlsDependOnPageScaleFactor = false;
          return;
      }
  
<span class="line-removed">-     if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-removed">-         document().registerForPageScaleFactorChangedCallbacks(*this);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         document().unregisterForPageScaleFactorChangedCallbacks(*this);</span>
  }
  
  void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
  {
      // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
<span class="line-new-header">--- 7395,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7440,41 ***</span>
          return;
  
      if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
          return;
  
<span class="line-modified">!     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
<span class="line-modified">!         auto* controllerObject = controllerValue.toObject(&amp;exec);</span>
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
<span class="line-modified">!         auto* function = functionValue.toObject(&amp;exec);</span>
          scope.assertNoException();
          JSC::CallData callData;
          auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
          if (callType == JSC::CallType::None)
              return false;
  
          JSC::MarkedArgumentBuffer argList;
          ASSERT(!argList.hasOverflowed());
<span class="line-modified">!         JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);</span>
  
          return true;
      });
  }
  
  void HTMLMediaElement::pageScaleFactorChanged()
  {
<span class="line-modified">!     updatePageScaleFactorJSProperty();</span>
  }
  
  void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
  {
      updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
<span class="line-new-header">--- 7408,42 ---</span>
          return;
  
      if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
          return;
  
<span class="line-modified">!     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
<span class="line-modified">!         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
<span class="line-modified">!         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
          scope.assertNoException();
          JSC::CallData callData;
          auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
          if (callType == JSC::CallType::None)
              return false;
  
          JSC::MarkedArgumentBuffer argList;
          ASSERT(!argList.hasOverflowed());
<span class="line-modified">!         JSC::call(&amp;lexicalGlobalObject, function, callType, callData, controllerObject, argList);</span>
  
          return true;
      });
  }
  
  void HTMLMediaElement::pageScaleFactorChanged()
  {
<span class="line-modified">!     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-added">+         updatePageScaleFactorJSProperty();</span>
  }
  
  void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
  {
      updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7483,37 ***</span>
  String HTMLMediaElement::getCurrentMediaControlsStatus()
  {
      ensureMediaControlsShadowRoot();
  
      String status;
<span class="line-modified">!     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
<span class="line-modified">!         auto* controllerObject = controllerValue.toObject(&amp;exec);</span>
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
<span class="line-modified">!         auto* function = functionValue.toObject(&amp;exec);</span>
          scope.assertNoException();
          JSC::CallData callData;
          auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
          JSC::MarkedArgumentBuffer argList;
          ASSERT(!argList.hasOverflowed());
          if (callType == JSC::CallType::None)
              return false;
  
<span class="line-modified">!         auto outputValue = JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);</span>
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         status = outputValue.getString(&amp;exec);</span>
          return true;
      });
  
      return status;
  }
<span class="line-new-header">--- 7452,37 ---</span>
  String HTMLMediaElement::getCurrentMediaControlsStatus()
  {
      ensureMediaControlsShadowRoot();
  
      String status;
<span class="line-modified">!     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
<span class="line-modified">!         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
<span class="line-modified">!         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
          scope.assertNoException();
          JSC::CallData callData;
          auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
          JSC::MarkedArgumentBuffer argList;
          ASSERT(!argList.hasOverflowed());
          if (callType == JSC::CallType::None)
              return false;
  
<span class="line-modified">!         auto outputValue = JSC::call(&amp;lexicalGlobalObject, function, callType, callData, controllerObject, argList);</span>
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         status = outputValue.getString(&amp;lexicalGlobalObject);</span>
          return true;
      });
  
      return status;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7583,11 ***</span>
  #endif
  
      if (muted())
          return false;
  
<span class="line-modified">!     return m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA &amp;&amp; hasAudio();</span>
  }
  
  bool HTMLMediaElement::isSuspended() const
  {
      return document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped();
<span class="line-new-header">--- 7552,14 ---</span>
  #endif
  
      if (muted())
          return false;
  
<span class="line-modified">!     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA)</span>
<span class="line-added">+         return hasAudio();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return hasEverHadAudio();</span>
  }
  
  bool HTMLMediaElement::isSuspended() const
  {
      return document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7635,11 ***</span>
      title = document().title().stripWhiteSpace().simplifyWhiteSpace();
      if (!title.isEmpty())
          return title;
  
      title = m_currentSrc.host().toString();
<span class="line-modified">! #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
      if (!title.isEmpty())
          title = decodeHostName(title);
  #endif
      if (!title.isEmpty()) {
          auto domain = RegistrableDomain { m_currentSrc };
<span class="line-new-header">--- 7607,11 ---</span>
      title = document().title().stripWhiteSpace().simplifyWhiteSpace();
      if (!title.isEmpty())
          return title;
  
      title = m_currentSrc.host().toString();
<span class="line-modified">! #if PLATFORM(COCOA)</span>
      if (!title.isEmpty())
          title = decodeHostName(title);
  #endif
      if (!title.isEmpty()) {
          auto domain = RegistrableDomain { m_currentSrc };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7935,10 ***</span>
<span class="line-new-header">--- 7907,11 ---</span>
  
      return false;
  }
  
  #if ENABLE(MEDIA_SESSION)
<span class="line-added">+ </span>
  double HTMLMediaElement::playerVolume() const
  {
      return m_player ? m_player-&gt;volume() : 0;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8159,8 ***</span>
<span class="line-new-header">--- 8132,32 ---</span>
  #else
      return false;
  #endif
  }
  
<span class="line-added">+ #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">+ void HTMLMediaElement::mediaStreamCaptureStarted()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (canTransitionFromAutoplayToPlay())</span>
<span class="line-added">+         play();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void HTMLMediaElement::enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp; function)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!isMainThread()) {</span>
<span class="line-added">+         callOnMainThread([this, weakThis = makeWeakPtr(*this), function = WTFMove(function)]() mutable {</span>
<span class="line-added">+             if (!weakThis)</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             enqueueTaskForDispatcher(WTFMove(function));</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!scriptExecutionContext())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     scriptExecutionContext()-&gt;eventLoop().queueTask(TaskSource::MediaElement, WTFMove(function));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  }
  
  #endif
</pre>
<center><a href="HTMLMarqueeElement.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
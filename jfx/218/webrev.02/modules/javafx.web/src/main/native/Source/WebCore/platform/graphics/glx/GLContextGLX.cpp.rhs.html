<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/glx/GLContextGLX.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011, 2012 Igalia, S.L.
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Lesser General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Lesser General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Lesser General Public
 15  *  License along with this library; if not, write to the Free Software
 16  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 17  */
 18 
 19 #include &quot;config.h&quot;
 20 #include &quot;GLContextGLX.h&quot;
 21 
 22 #if USE(GLX)
<a name="1" id="anc1"></a>
 23 #include &quot;OpenGLShims.h&quot;
 24 #include &quot;PlatformDisplayX11.h&quot;
 25 #include &quot;XErrorTrapper.h&quot;
 26 #include &lt;GL/glx.h&gt;
 27 #include &lt;cairo.h&gt;
 28 
 29 #if ENABLE(ACCELERATED_2D_CANVAS)
 30 #include &lt;cairo-gl.h&gt;
 31 #endif
 32 
 33 namespace WebCore {
 34 
 35 #if !defined(PFNGLXSWAPINTERVALSGIPROC)
 36 typedef int (*PFNGLXSWAPINTERVALSGIPROC) (int);
 37 #endif
 38 #if !defined(PFNGLXCREATECONTEXTATTRIBSARBPROC)
 39 typedef GLXContext (*PFNGLXCREATECONTEXTATTRIBSARBPROC) (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
 40 #endif
 41 
 42 static PFNGLXSWAPINTERVALSGIPROC glXSwapIntervalSGI;
 43 static PFNGLXCREATECONTEXTATTRIBSARBPROC glXCreateContextAttribsARB;
 44 
 45 static bool hasSGISwapControlExtension(Display* display)
 46 {
 47     static bool initialized = false;
 48     if (initialized)
 49         return !!glXSwapIntervalSGI;
 50 
 51     initialized = true;
 52     if (!GLContext::isExtensionSupported(glXQueryExtensionsString(display, 0), &quot;GLX_SGI_swap_control&quot;))
 53         return false;
 54 
 55     glXSwapIntervalSGI = reinterpret_cast&lt;PFNGLXSWAPINTERVALSGIPROC&gt;(glXGetProcAddress(reinterpret_cast&lt;const unsigned char*&gt;(&quot;glXSwapIntervalSGI&quot;)));
 56     return !!glXSwapIntervalSGI;
 57 }
 58 
 59 static bool hasGLXARBCreateContextExtension(Display* display)
 60 {
 61     static bool initialized = false;
 62     if (initialized)
 63         return !!glXCreateContextAttribsARB;
 64 
 65     initialized = true;
 66     if (!GLContext::isExtensionSupported(glXQueryExtensionsString(display, 0), &quot;GLX_ARB_create_context&quot;))
 67         return false;
 68 
 69     glXCreateContextAttribsARB = reinterpret_cast&lt;PFNGLXCREATECONTEXTATTRIBSARBPROC&gt;(glXGetProcAddress(reinterpret_cast&lt;const unsigned char*&gt;(&quot;glXCreateContextAttribsARB&quot;)));
 70     return !!glXCreateContextAttribsARB;
 71 }
 72 
 73 static GLXContext createGLXARBContext(Display* display, GLXFBConfig config, GLXContext sharingContext)
 74 {
 75     // We want to create a context with version &gt;= 3.2 core profile, cause that ensures that the i965 driver won&#39;t
 76     // use the software renderer. If that doesn&#39;t work, we will use whatever version available. Unfortunately,
 77     // there&#39;s no way to know whether glXCreateContextAttribsARB can provide an OpenGL version &gt;= 3.2 until
 78     // we actually call it and check the return value. To make things more fun, if a version &gt;= 3.2 cannot be
 79     // provided, glXCreateContextAttribsARB will throw a GLXBadFBConfig X error, causing the app to crash.
 80     // So, the first time a context is requested, we set a X error trap to disable crashes with GLXBadFBConfig
 81     // and then check whether the return value is a context or not.
 82 
 83     static bool canCreate320Context = false;
 84     static bool canCreate320ContextInitialized = false;
 85 
 86     static const int contextAttributes[] = {
 87         GLX_CONTEXT_MAJOR_VERSION_ARB, 3,
 88         GLX_CONTEXT_MINOR_VERSION_ARB, 2,
 89         0
 90     };
 91 
 92     if (!canCreate320ContextInitialized) {
 93         canCreate320ContextInitialized = true;
 94 
 95         {
 96             // Set an X error trapper that ignores errors to avoid crashing on GLXBadFBConfig. Use a scope
 97             // here to limit the error trap to just this context creation call.
 98             XErrorTrapper trapper(display, XErrorTrapper::Policy::Ignore);
 99             GLXContext context = glXCreateContextAttribsARB(display, config, sharingContext, GL_TRUE, contextAttributes);
100             if (context) {
101                 canCreate320Context = true;
102                 return context;
103             }
104         }
105 
106         // Creating the 3.2 context failed, so use whatever is available.
107         return glXCreateContextAttribsARB(display, config, sharingContext, GL_TRUE, nullptr);
108     }
109 
110     if (canCreate320Context)
111         return glXCreateContextAttribsARB(display, config, sharingContext, GL_TRUE, contextAttributes);
112 
113     return glXCreateContextAttribsARB(display, config, sharingContext, GL_TRUE, nullptr);
114 }
115 
116 static bool compatibleVisuals(XVisualInfo* a, XVisualInfo* b)
117 {
118     return a-&gt;c_class == b-&gt;c_class
119         &amp;&amp; a-&gt;depth == b-&gt;depth
120         &amp;&amp; a-&gt;red_mask == b-&gt;red_mask
121         &amp;&amp; a-&gt;green_mask == b-&gt;green_mask
122         &amp;&amp; a-&gt;blue_mask == b-&gt;blue_mask
123         &amp;&amp; a-&gt;colormap_size == b-&gt;colormap_size
124         &amp;&amp; a-&gt;bits_per_rgb == b-&gt;bits_per_rgb;
125 }
126 
127 std::unique_ptr&lt;GLContextGLX&gt; GLContextGLX::createWindowContext(GLNativeWindowType window, PlatformDisplay&amp; platformDisplay, GLXContext sharingContext)
128 {
129     // In order to create the GLContext, we need to select a GLXFBConfig that has depth and stencil
130     // buffers that is compatible with the Visual used to create the window. To do this, we request
131     // all the GLXFBConfigs that have the features we need and compare their XVisualInfo to check whether
132     // they are compatible with the window one. Then we try to create the GLContext with each of those
133     // configs until we succeed, and finally fallback to the window config if nothing else works.
134     Display* display = downcast&lt;PlatformDisplayX11&gt;(platformDisplay).native();
135     XWindowAttributes attributes;
136     if (!XGetWindowAttributes(display, static_cast&lt;Window&gt;(window), &amp;attributes))
137         return nullptr;
138 
139     XVisualInfo visualInfo;
140     visualInfo.visualid = XVisualIDFromVisual(attributes.visual);
141 
142     int numConfigs = 0;
143     GLXFBConfig windowConfig = nullptr;
144     XUniquePtr&lt;GLXFBConfig&gt; configs(glXGetFBConfigs(display, DefaultScreen(display), &amp;numConfigs));
145     for (int i = 0; i &lt; numConfigs; i++) {
146         XUniquePtr&lt;XVisualInfo&gt; glxVisualInfo(glXGetVisualFromFBConfig(display, configs.get()[i]));
147         if (!glxVisualInfo)
148             continue;
149         if (glxVisualInfo.get()-&gt;visualid == visualInfo.visualid) {
150             windowConfig = configs.get()[i];
151             break;
152         }
153     }
154     ASSERT(windowConfig);
155     XUniquePtr&lt;XVisualInfo&gt; windowVisualInfo(glXGetVisualFromFBConfig(display, windowConfig));
156 
157     static const int fbConfigAttributes[] = {
158         GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
159         GLX_RENDER_TYPE, GLX_RGBA_BIT,
160         GLX_X_RENDERABLE, GL_TRUE,
161         GLX_RED_SIZE, 1,
162         GLX_GREEN_SIZE, 1,
163         GLX_BLUE_SIZE, 1,
164         GLX_ALPHA_SIZE, 1,
165         GLX_DEPTH_SIZE, 1,
166         GLX_STENCIL_SIZE, 1,
167         GLX_DOUBLEBUFFER, GL_TRUE,
168         GLX_CONFIG_CAVEAT, GLX_NONE,
169 #ifdef GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT
170         // Discard sRGB configs if any sRGB extension is installed.
171         GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, GL_FALSE,
172 #endif
173         0
174     };
175     configs.reset(glXChooseFBConfig(display, DefaultScreen(display), fbConfigAttributes, &amp;numConfigs));
176     XUniqueGLXContext context;
177     for (int i = 0; i &lt; numConfigs; i++) {
178         XUniquePtr&lt;XVisualInfo&gt; configVisualInfo(glXGetVisualFromFBConfig(display, configs.get()[i]));
179         if (!configVisualInfo)
180             continue;
181         if (compatibleVisuals(windowVisualInfo.get(), configVisualInfo.get())) {
182             // Try to create a context with this config. Use the trapper in case we get an XError.
183             XErrorTrapper trapper(display, XErrorTrapper::Policy::Ignore);
184             if (hasGLXARBCreateContextExtension(display))
185                 context.reset(createGLXARBContext(display, configs.get()[i], sharingContext));
186             else {
187                 // Legacy OpenGL version.
188                 context.reset(glXCreateContext(display, configVisualInfo.get(), sharingContext, True));
189             }
190 
191             if (context)
192                 return std::unique_ptr&lt;GLContextGLX&gt;(new GLContextGLX(platformDisplay, WTFMove(context), window));
193         }
194     }
195 
196     // Fallback to the config used by the window. We don&#39;t probably have the buffers we need in
197     // this config and that will cause artifacts, but it&#39;s better than not rendering anything.
198     if (hasGLXARBCreateContextExtension(display))
199         context.reset(createGLXARBContext(display, windowConfig, sharingContext));
200     else {
201         // Legacy OpenGL version.
202         context.reset(glXCreateContext(display, windowVisualInfo.get(), sharingContext, True));
203     }
204 
205     if (!context)
206         return nullptr;
207 
208     return std::unique_ptr&lt;GLContextGLX&gt;(new GLContextGLX(platformDisplay, WTFMove(context), window));
209 }
210 
211 std::unique_ptr&lt;GLContextGLX&gt; GLContextGLX::createPbufferContext(PlatformDisplay&amp; platformDisplay, GLXContext sharingContext)
212 {
213     static const int fbConfigAttributes[] = {
214         GLX_DRAWABLE_TYPE, GLX_PBUFFER_BIT,
215         GLX_RENDER_TYPE, GLX_RGBA_BIT,
216         GLX_RED_SIZE, 1,
217         GLX_GREEN_SIZE, 1,
218         GLX_BLUE_SIZE, 1,
219         GLX_ALPHA_SIZE, 1,
220         GLX_DOUBLEBUFFER, GL_FALSE,
221         0
222     };
223 
224     int returnedElements;
225     Display* display = downcast&lt;PlatformDisplayX11&gt;(platformDisplay).native();
226     XUniquePtr&lt;GLXFBConfig&gt; configs(glXChooseFBConfig(display, 0, fbConfigAttributes, &amp;returnedElements));
227     if (!returnedElements)
228         return nullptr;
229 
230     // We will be rendering to a texture, so our pbuffer does not need to be large.
231     static const int pbufferAttributes[] = { GLX_PBUFFER_WIDTH, 1, GLX_PBUFFER_HEIGHT, 1, 0 };
232     XUniqueGLXPbuffer pbuffer(glXCreatePbuffer(display, configs.get()[0], pbufferAttributes));
233     if (!pbuffer)
234         return nullptr;
235 
236     XUniqueGLXContext context;
237     if (hasGLXARBCreateContextExtension(display))
238         context.reset(createGLXARBContext(display, configs.get()[0], sharingContext));
239     else {
240         // Legacy OpenGL version.
241         context.reset(glXCreateNewContext(display, configs.get()[0], GLX_RGBA_TYPE, sharingContext, GL_TRUE));
242     }
243 
244     if (!context)
245         return nullptr;
246 
247     return std::unique_ptr&lt;GLContextGLX&gt;(new GLContextGLX(platformDisplay, WTFMove(context), WTFMove(pbuffer)));
248 }
249 
250 std::unique_ptr&lt;GLContextGLX&gt; GLContextGLX::createPixmapContext(PlatformDisplay&amp; platformDisplay, GLXContext sharingContext)
251 {
252     static int visualAttributes[] = {
253         GLX_RGBA,
254         GLX_RED_SIZE, 1,
255         GLX_GREEN_SIZE, 1,
256         GLX_BLUE_SIZE, 1,
257         GLX_ALPHA_SIZE, 1,
258         0
259     };
260 
261     Display* display = downcast&lt;PlatformDisplayX11&gt;(platformDisplay).native();
262     XUniquePtr&lt;XVisualInfo&gt; visualInfo(glXChooseVisual(display, DefaultScreen(display), visualAttributes));
263     if (!visualInfo)
264         return nullptr;
265 
266     XUniqueGLXContext context(glXCreateContext(display, visualInfo.get(), sharingContext, GL_TRUE));
267     if (!context)
268         return nullptr;
269 
270     XUniquePixmap pixmap(XCreatePixmap(display, DefaultRootWindow(display), 1, 1, visualInfo-&gt;depth));
271     if (!pixmap)
272         return nullptr;
273 
274     XUniqueGLXPixmap glxPixmap(glXCreateGLXPixmap(display, visualInfo.get(), pixmap.get()));
275     if (!glxPixmap)
276         return nullptr;
277 
278     return std::unique_ptr&lt;GLContextGLX&gt;(new GLContextGLX(platformDisplay, WTFMove(context), WTFMove(pixmap), WTFMove(glxPixmap)));
279 }
280 
281 std::unique_ptr&lt;GLContextGLX&gt; GLContextGLX::createContext(GLNativeWindowType window, PlatformDisplay&amp; platformDisplay)
282 {
283     GLXContext glxSharingContext = platformDisplay.sharingGLContext() ? static_cast&lt;GLContextGLX*&gt;(platformDisplay.sharingGLContext())-&gt;m_context.get() : nullptr;
284     auto context = window ? createWindowContext(window, platformDisplay, glxSharingContext) : nullptr;
285     if (!context)
286         context = createPbufferContext(platformDisplay, glxSharingContext);
287     if (!context)
288         context = createPixmapContext(platformDisplay, glxSharingContext);
289 
290     return context;
291 }
292 
293 std::unique_ptr&lt;GLContextGLX&gt; GLContextGLX::createSharingContext(PlatformDisplay&amp; platformDisplay)
294 {
295     auto context = createPbufferContext(platformDisplay);
296     if (!context)
297         context = createPixmapContext(platformDisplay);
298     return context;
299 }
300 
301 GLContextGLX::GLContextGLX(PlatformDisplay&amp; display, XUniqueGLXContext&amp;&amp; context, GLNativeWindowType window)
302     : GLContext(display)
303     , m_x11Display(downcast&lt;PlatformDisplayX11&gt;(m_display).native())
304     , m_context(WTFMove(context))
305     , m_window(static_cast&lt;Window&gt;(window))
306 {
307 }
308 
309 GLContextGLX::GLContextGLX(PlatformDisplay&amp; display, XUniqueGLXContext&amp;&amp; context, XUniqueGLXPbuffer&amp;&amp; pbuffer)
310     : GLContext(display)
311     , m_x11Display(downcast&lt;PlatformDisplayX11&gt;(m_display).native())
312     , m_context(WTFMove(context))
313     , m_pbuffer(WTFMove(pbuffer))
314 {
315 }
316 
317 GLContextGLX::GLContextGLX(PlatformDisplay&amp; display, XUniqueGLXContext&amp;&amp; context, XUniquePixmap&amp;&amp; pixmap, XUniqueGLXPixmap&amp;&amp; glxPixmap)
318     : GLContext(display)
319     , m_x11Display(downcast&lt;PlatformDisplayX11&gt;(m_display).native())
320     , m_context(WTFMove(context))
321     , m_pixmap(WTFMove(pixmap))
322     , m_glxPixmap(WTFMove(glxPixmap))
323 {
324 }
325 
326 GLContextGLX::~GLContextGLX()
327 {
328     if (m_cairoDevice)
329         cairo_device_destroy(m_cairoDevice);
330 
331     if (m_context) {
332         // Due to a bug in some nvidia drivers, we need bind the default framebuffer in a context before
333         // destroying it to avoid a crash. In order to do that, we need to make the context current and,
334         // after the bind change, we need to set the previous context again.
335         GLContext* previousActiveContext = GLContext::current();
336         makeContextCurrent();
337         glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
338         if (previousActiveContext &amp;&amp; previousActiveContext != this) {
339             // If there was a previous context different from this one, just make it current again.
340             previousActiveContext-&gt;makeContextCurrent();
341         } else {
342             // If there was no previous context or this was the previous, set a void context as current.
343             // We use the GLX function here, and the destructor of GLContext will clean the pointer
344             // returned by GLContext::current().
345             glXMakeCurrent(m_x11Display, None, None);
346         }
347     }
348 }
349 
350 bool GLContextGLX::canRenderToDefaultFramebuffer()
351 {
352     return m_window;
353 }
354 
355 IntSize GLContextGLX::defaultFrameBufferSize()
356 {
357     if (!canRenderToDefaultFramebuffer() || !m_window)
358         return IntSize();
359 
360     int x, y;
361     Window rootWindow;
362     unsigned int width, height, borderWidth, depth;
363     if (!XGetGeometry(m_x11Display, m_window, &amp;rootWindow, &amp;x, &amp;y, &amp;width, &amp;height, &amp;borderWidth, &amp;depth))
364         return IntSize();
365 
366     return IntSize(width, height);
367 }
368 
369 bool GLContextGLX::makeContextCurrent()
370 {
371     ASSERT(m_context &amp;&amp; (m_window || m_pbuffer || m_glxPixmap));
372 
373     GLContext::makeContextCurrent();
374     if (glXGetCurrentContext() == m_context.get())
375         return true;
376 
377     if (m_window)
378         return glXMakeCurrent(m_x11Display, m_window, m_context.get());
379 
380     if (m_pbuffer)
381         return glXMakeCurrent(m_x11Display, m_pbuffer.get(), m_context.get());
382 
383     return ::glXMakeCurrent(m_x11Display, m_glxPixmap.get(), m_context.get());
384 }
385 
386 void GLContextGLX::swapBuffers()
387 {
388     if (m_window)
389         glXSwapBuffers(m_x11Display, m_window);
390 }
391 
392 void GLContextGLX::waitNative()
393 {
394     glXWaitX();
395 }
396 
397 void GLContextGLX::swapInterval(int interval)
398 {
399     if (!hasSGISwapControlExtension(m_x11Display))
400         return;
401     glXSwapIntervalSGI(interval);
402 }
403 
404 cairo_device_t* GLContextGLX::cairoDevice()
405 {
406     if (m_cairoDevice)
407         return m_cairoDevice;
408 
409 #if ENABLE(ACCELERATED_2D_CANVAS) &amp;&amp; CAIRO_HAS_GLX_FUNCTIONS
410     m_cairoDevice = cairo_glx_device_create(m_x11Display, m_context.get());
411 #endif
412 
413     return m_cairoDevice;
414 }
415 
<a name="2" id="anc2"></a><span class="line-modified">416 #if ENABLE(GRAPHICS_CONTEXT_GL)</span>
<span class="line-modified">417 PlatformGraphicsContextGL GLContextGLX::platformContext()</span>
418 {
419     return m_context.get();
420 }
421 #endif
422 
423 } // namespace WebCore
424 
425 #endif // USE(GLX)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;ActivityStateChangeObserver.h&quot;
 31 #include &quot;ExceptionOr.h&quot;
 32 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
 33 #include &quot;GraphicsContextGLOpenGL.h&quot;
 34 #include &quot;ImageBuffer.h&quot;
 35 #include &quot;SuspendableTimer.h&quot;
 36 #include &quot;Timer.h&quot;
 37 #include &quot;WebGLAny.h&quot;
 38 #include &quot;WebGLBuffer.h&quot;
 39 #include &quot;WebGLContextAttributes.h&quot;
 40 #include &quot;WebGLFramebuffer.h&quot;
 41 #include &quot;WebGLProgram.h&quot;
 42 #include &quot;WebGLRenderbuffer.h&quot;
 43 #include &quot;WebGLStateTracker.h&quot;
 44 #include &quot;WebGLTexture.h&quot;
 45 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 46 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 47 #include &lt;limits&gt;
 48 #include &lt;memory&gt;
 49 
 50 #if ENABLE(WEBGL2)
 51 #include &quot;WebGLVertexArrayObject.h&quot;
 52 #endif
 53 
 54 namespace WebCore {
 55 
 56 class ANGLEInstancedArrays;
 57 class EXTBlendMinMax;
 58 class EXTTextureFilterAnisotropic;
 59 class EXTShaderTextureLOD;
 60 class EXTsRGB;
 61 class EXTFragDepth;
 62 class HTMLImageElement;
 63 class ImageData;
 64 class IntSize;
 65 class OESStandardDerivatives;
 66 class OESTextureFloat;
 67 class OESTextureFloatLinear;
 68 class OESTextureHalfFloat;
 69 class OESTextureHalfFloatLinear;
 70 class OESVertexArrayObject;
 71 class OESElementIndexUint;
 72 #if ENABLE(OFFSCREEN_CANVAS)
 73 class OffscreenCanvas;
 74 #endif
 75 class WebGLActiveInfo;
 76 class WebGLContextGroup;
 77 class WebGLContextObject;
 78 class WebGLCompressedTextureASTC;
 79 class WebGLCompressedTextureATC;
 80 class WebGLCompressedTextureETC;
 81 class WebGLCompressedTextureETC1;
 82 class WebGLCompressedTexturePVRTC;
 83 class WebGLCompressedTextureS3TC;
 84 class WebGLDebugRendererInfo;
 85 class WebGLDebugShaders;
 86 class WebGLDepthTexture;
 87 class WebGLDrawBuffers;
 88 class WebGLExtension;
 89 class WebGLLoseContext;
 90 class WebGLObject;
 91 class WebGLShader;
 92 class WebGLSharedObject;
 93 class WebGLShaderPrecisionFormat;
 94 class WebGLUniformLocation;
 95 
 96 #if ENABLE(VIDEO)
 97 class HTMLVideoElement;
 98 #endif
 99 
100 #if ENABLE(OFFSCREEN_CANVAS)
101 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;OffscreenCanvas&gt;&gt;;
102 #else
103 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;&gt;;
104 #endif
105 
106 class WebGLRenderingContextBase : public GraphicsContextGLOpenGL::Client, public GPUBasedCanvasRenderingContext, private ActivityStateChangeObserver {
107     WTF_MAKE_ISO_ALLOCATED(WebGLRenderingContextBase);
108 public:
109     static std::unique_ptr&lt;WebGLRenderingContextBase&gt; create(CanvasBase&amp;, WebGLContextAttributes&amp;, const String&amp;);
110     virtual ~WebGLRenderingContextBase();
111 
112     WebGLCanvas canvas();
113 
114     int drawingBufferWidth() const;
115     int drawingBufferHeight() const;
116 
117     void activeTexture(GCGLenum texture);
118     void attachShader(WebGLProgram*, WebGLShader*);
119     void bindAttribLocation(WebGLProgram*, GCGLuint index, const String&amp; name);
120     void bindBuffer(GCGLenum target, WebGLBuffer*);
121     void bindFramebuffer(GCGLenum target, WebGLFramebuffer*);
122     void bindRenderbuffer(GCGLenum target, WebGLRenderbuffer*);
123     void bindTexture(GCGLenum target, WebGLTexture*);
124     void blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);
125     void blendEquation(GCGLenum mode);
126     void blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha);
127     void blendFunc(GCGLenum sfactor, GCGLenum dfactor);
128     void blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha);
129 
130     using BufferDataSource = WTF::Variant&lt;RefPtr&lt;ArrayBuffer&gt;, RefPtr&lt;ArrayBufferView&gt;&gt;;
131     void bufferData(GCGLenum target, long long size, GCGLenum usage);
132     void bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp;, GCGLenum usage);
133     void bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp;);
134 
135     GCGLenum checkFramebufferStatus(GCGLenum target);
136     virtual void clear(GCGLbitfield mask) = 0;
137     void clearColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);
138     void clearDepth(GCGLfloat);
139     void clearStencil(GCGLint);
140     void colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha);
141     void compileShader(WebGLShader*);
142 
143     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data);
144     void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data);
145 
146     void copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border);
147     void copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);
148 
149     RefPtr&lt;WebGLBuffer&gt; createBuffer();
150     RefPtr&lt;WebGLFramebuffer&gt; createFramebuffer();
151     RefPtr&lt;WebGLProgram&gt; createProgram();
152     RefPtr&lt;WebGLRenderbuffer&gt; createRenderbuffer();
153     RefPtr&lt;WebGLShader&gt; createShader(GCGLenum type);
154     RefPtr&lt;WebGLTexture&gt; createTexture();
155 
156     void cullFace(GCGLenum mode);
157 
158     void deleteBuffer(WebGLBuffer*);
159     void deleteFramebuffer(WebGLFramebuffer*);
160     void deleteProgram(WebGLProgram*);
161     void deleteRenderbuffer(WebGLRenderbuffer*);
162     void deleteShader(WebGLShader*);
163     void deleteTexture(WebGLTexture*);
164 
165     void depthFunc(GCGLenum);
166     void depthMask(GCGLboolean);
167     void depthRange(GCGLfloat zNear, GCGLfloat zFar);
168     void detachShader(WebGLProgram*, WebGLShader*);
169     void disable(GCGLenum cap);
170     void disableVertexAttribArray(GCGLuint index);
171     void drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count);
172     void drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset);
173 
174     void enable(GCGLenum cap);
175     void enableVertexAttribArray(GCGLuint index);
176     void finish();
177     void flush();
178     void framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer*);
179     void framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture*, GCGLint level);
180     void frontFace(GCGLenum mode);
181     void generateMipmap(GCGLenum target);
182 
183     RefPtr&lt;WebGLActiveInfo&gt; getActiveAttrib(WebGLProgram*, GCGLuint index);
184     RefPtr&lt;WebGLActiveInfo&gt; getActiveUniform(WebGLProgram*, GCGLuint index);
185     Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; getAttachedShaders(WebGLProgram*);
186     GCGLint getAttribLocation(WebGLProgram*, const String&amp; name);
187     WebGLAny getBufferParameter(GCGLenum target, GCGLenum pname);
188     Optional&lt;WebGLContextAttributes&gt; getContextAttributes();
189     GCGLenum getError();
190     virtual WebGLExtension* getExtension(const String&amp; name) = 0;
191     virtual WebGLAny getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname) = 0;
192     virtual WebGLAny getParameter(GCGLenum pname) = 0;
193     WebGLAny getProgramParameter(WebGLProgram*, GCGLenum pname);
194     String getProgramInfoLog(WebGLProgram*);
195     WebGLAny getRenderbufferParameter(GCGLenum target, GCGLenum pname);
196     WebGLAny getShaderParameter(WebGLShader*, GCGLenum pname);
197     String getShaderInfoLog(WebGLShader*);
198     RefPtr&lt;WebGLShaderPrecisionFormat&gt; getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType);
199     String getShaderSource(WebGLShader*);
200     virtual Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() = 0;
201     WebGLAny getTexParameter(GCGLenum target, GCGLenum pname);
202     WebGLAny getUniform(WebGLProgram*, const WebGLUniformLocation*);
203     RefPtr&lt;WebGLUniformLocation&gt; getUniformLocation(WebGLProgram*, const String&amp;);
204     WebGLAny getVertexAttrib(GCGLuint index, GCGLenum pname);
205     long long getVertexAttribOffset(GCGLuint index, GCGLenum pname);
206 
207     bool extensionIsEnabled(const String&amp;);
208 
209     bool isPreservingDrawingBuffer() const { return m_attributes.preserveDrawingBuffer; }
210     void setPreserveDrawingBuffer(bool value) { m_attributes.preserveDrawingBuffer = value; }
211 
212     bool preventBufferClearForInspector() const { return m_preventBufferClearForInspector; }
213     void setPreventBufferClearForInspector(bool value) { m_preventBufferClearForInspector = value; }
214 
215     virtual void hint(GCGLenum target, GCGLenum mode) = 0;
216     GCGLboolean isBuffer(WebGLBuffer*);
217     bool isContextLost() const;
218     GCGLboolean isEnabled(GCGLenum cap);
219     GCGLboolean isFramebuffer(WebGLFramebuffer*);
220     GCGLboolean isProgram(WebGLProgram*);
221     GCGLboolean isRenderbuffer(WebGLRenderbuffer*);
222     GCGLboolean isShader(WebGLShader*);
223     GCGLboolean isTexture(WebGLTexture*);
224 
225     void lineWidth(GCGLfloat);
226     void linkProgram(WebGLProgram*);
227     bool linkProgramWithoutInvalidatingAttribLocations(WebGLProgram*);
228     void pixelStorei(GCGLenum pname, GCGLint param);
229     void polygonOffset(GCGLfloat factor, GCGLfloat units);
230     void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels);
231     void releaseShaderCompiler();
232     virtual void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) = 0;
233     void sampleCoverage(GCGLfloat value, GCGLboolean invert);
234     void scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);
235     void shaderSource(WebGLShader*, const String&amp;);
236     void stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask);
237     void stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask);
238     void stencilMask(GCGLuint);
239     void stencilMaskSeparate(GCGLenum face, GCGLuint mask);
240     void stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass);
241     void stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass);
242 
243     void texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);
244 
245 #if ENABLE(VIDEO)
246     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
247 #else
248     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
249 #endif
250 
251     ExceptionOr&lt;void&gt; texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;);
252 
253     void texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param);
254     void texParameteri(GCGLenum target, GCGLenum pname, GCGLint param);
255 
256     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);
257     ExceptionOr&lt;void&gt; texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp;);
258 
259     template &lt;class TypedArray, class DataType&gt;
260     class TypedList {
261     public:
262         using VariantType = Variant&lt;RefPtr&lt;TypedArray&gt;, Vector&lt;DataType&gt;&gt;;
263 
264         TypedList(VariantType&amp;&amp; variant)
265             : m_variant(WTFMove(variant))
266         {
267         }
268 
269         const DataType* data() const
270         {
271             return WTF::switchOn(m_variant,
272                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; const DataType* { return typedArray-&gt;data(); },
273                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; const DataType* { return vector.data(); }
274             );
275         }
276 
277         GCGLsizei length() const
278         {
279             return WTF::switchOn(m_variant,
280                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; GCGLsizei { return typedArray-&gt;length(); },
281                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; GCGLsizei { return vector.size(); }
282             );
283         }
284 
285     private:
286         VariantType m_variant;
287     };
288 
289     using Float32List = TypedList&lt;Float32Array, float&gt;;
290     using Int32List = TypedList&lt;Int32Array, int&gt;;
291 
292     void uniform1f(const WebGLUniformLocation*, GCGLfloat x);
293     void uniform2f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y);
294     void uniform3f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z);
295     void uniform4f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);
296 
297     void uniform1i(const WebGLUniformLocation*, GCGLint x);
298     void uniform2i(const WebGLUniformLocation*, GCGLint x, GCGLint y);
299     void uniform3i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z);
300     void uniform4i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z, GCGLint w);
301 
302     void uniform1fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
303     void uniform2fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
304     void uniform3fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
305     void uniform4fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
306 
307     void uniform1iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
308     void uniform2iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
309     void uniform3iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
310     void uniform4iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
311 
312     void uniformMatrix2fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);
313     void uniformMatrix3fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);
314     void uniformMatrix4fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);
315 
316     void useProgram(WebGLProgram*);
317     void validateProgram(WebGLProgram*);
318 
319     void vertexAttrib1f(GCGLuint index, GCGLfloat x);
320     void vertexAttrib2f(GCGLuint index, GCGLfloat x, GCGLfloat y);
321     void vertexAttrib3f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z);
322     void vertexAttrib4f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);
323 
324     void vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp;);
325     void vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp;);
326     void vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp;);
327     void vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp;);
328 
329     void vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized,
330         GCGLsizei stride, long long offset);
331 
332     void viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);
333 
334     // WEBKIT_lose_context support
335     enum LostContextMode {
336         // Lost context occurred at the graphics system level.
337         RealLostContext,
338 
339         // Lost context provoked by WEBKIT_lose_context.
340         SyntheticLostContext
341     };
342     void forceLostContext(LostContextMode);
343     void forceRestoreContext();
344     void loseContextImpl(LostContextMode);
345     WEBCORE_EXPORT void simulateContextChanged();
346 
347     GraphicsContextGLOpenGL* graphicsContextGL() const { return m_context.get(); }
348     WebGLContextGroup* contextGroup() const { return m_contextGroup.get(); }
349     PlatformLayer* platformLayer() const override;
350 
351     void reshape(int width, int height) override;
352 
353     void markLayerComposited() final;
354     void paintRenderingResultsToCanvas() override;
355     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
356 
357     void removeSharedObject(WebGLSharedObject&amp;);
358     void removeContextObject(WebGLContextObject&amp;);
359 
360     unsigned getMaxVertexAttribs() const { return m_maxVertexAttribs; }
361 
362     // Instanced Array helper functions.
363     void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);
364     void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount);
365     void vertexAttribDivisor(GCGLuint index, GCGLuint divisor);
366 
367     // Used for testing only, from Internals.
368     WEBCORE_EXPORT void setFailNextGPUStatusCheck();
369 
370     // GraphicsContextGL::Client
371     void didComposite() override;
372     void forceContextLost() override;
373     void recycleContext() override;
374     void dispatchContextChangedNotification() override;
375 
376     // ActiveDOMObject
377     bool hasPendingActivity() const final;
378 
379 protected:
380     WebGLRenderingContextBase(CanvasBase&amp;, WebGLContextAttributes);
381     WebGLRenderingContextBase(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, WebGLContextAttributes);
382 
383     friend class WebGLDrawBuffers;
384     friend class WebGLFramebuffer;
385     friend class WebGLObject;
386     friend class OESVertexArrayObject;
387     friend class WebGLDebugShaders;
388     friend class WebGLCompressedTextureASTC;
389     friend class WebGLCompressedTextureATC;
390     friend class WebGLCompressedTextureETC;
391     friend class WebGLCompressedTextureETC1;
392     friend class WebGLCompressedTexturePVRTC;
393     friend class WebGLCompressedTextureS3TC;
394     friend class WebGLRenderingContextErrorMessageCallback;
395     friend class WebGLVertexArrayObjectOES;
396     friend class WebGLVertexArrayObject;
397     friend class WebGLVertexArrayObjectBase;
398 
399     virtual void initializeNewContext();
400     virtual void initializeVertexArrayObjects() = 0;
401     void setupFlags();
402 
403     // ActiveDOMObject
404     void stop() override;
405     const char* activeDOMObjectName() const override;
406     void suspend(ReasonForSuspension) override;
407     void resume() override;
408 
409     void addSharedObject(WebGLSharedObject&amp;);
410     void addContextObject(WebGLContextObject&amp;);
411     void detachAndRemoveAllObjects();
412 
413     void destroyGraphicsContextGL();
414     void markContextChanged();
415     void markContextChangedAndNotifyCanvasObserver();
416 
417     void addActivityStateChangeObserverIfNecessary();
418     void removeActivityStateChangeObserver();
419 
420     // Query whether it is built on top of compliant GLES2 implementation.
421     bool isGLES2Compliant() { return m_isGLES2Compliant; }
422     // Query if the GL implementation is NPOT strict.
423     bool isGLES2NPOTStrict() { return m_isGLES2NPOTStrict; }
424     // Query if depth_stencil buffer is supported.
425     bool isDepthStencilSupported() { return m_isDepthStencilSupported; }
426 
427     // Helper to return the size in bytes of OpenGL data types
428     // like GL_FLOAT, GL_INT, etc.
429     unsigned sizeInBytes(GCGLenum type);
430 
431     // Basic validation of count and offset against number of elements in element array buffer
432     bool validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset);
433 
434     // Conservative but quick index validation
435     virtual bool validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired) = 0;
436 
437     // Precise but slow index validation -- only done if conservative checks fail
438     bool validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired);
439     bool validateVertexAttributes(unsigned elementCount, unsigned primitiveCount = 0);
440 
441     bool validateWebGLObject(const char*, WebGLObject*);
442 
443     bool validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);
444     bool validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primcount);
445     bool validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName);
446 
447     // Adds a compressed texture format.
448     void addCompressedTextureFormat(GCGLenum);
449 
450     RefPtr&lt;Image&gt; drawImageIntoBuffer(Image&amp;, int width, int height, int deviceScaleFactor);
451 
452 #if ENABLE(VIDEO)
453     RefPtr&lt;Image&gt; videoFrameToImage(HTMLVideoElement*, BackingStoreCopy);
454 #endif
455 
456     WebGLTexture::TextureExtensionFlag textureExtensionFlags() const;
457 
458     bool enableSupportedExtension(ASCIILiteral extensionNameLiteral);
459 
460     virtual void uncacheDeletedBuffer(WebGLBuffer*);
461 
462     RefPtr&lt;GraphicsContextGLOpenGL&gt; m_context;
463     RefPtr&lt;WebGLContextGroup&gt; m_contextGroup;
464 
465     // Dispatches a context lost event once it is determined that one is needed.
466     // This is used both for synthetic and real context losses. For real ones, it&#39;s
467     // likely that there&#39;s no JavaScript on the stack, but that might be dependent
468     // on how exactly the platform discovers that the context was lost. For better
469     // portability we always defer the dispatch of the event.
470     SuspendableTimer m_dispatchContextLostEventTimer;
471     SuspendableTimer m_dispatchContextChangedEventTimer;
472     bool m_restoreAllowed { false };
473     SuspendableTimer m_restoreTimer;
474 
475     bool m_needsUpdate;
476     bool m_markedCanvasDirty;
477     HashSet&lt;WebGLContextObject*&gt; m_contextObjects;
478 
479     // List of bound VBO&#39;s. Used to maintain info about sizes for ARRAY_BUFFER and stored values for ELEMENT_ARRAY_BUFFER
480     RefPtr&lt;WebGLBuffer&gt; m_boundArrayBuffer;
481     RefPtr&lt;WebGLBuffer&gt; m_boundCopyReadBuffer;
482     RefPtr&lt;WebGLBuffer&gt; m_boundCopyWriteBuffer;
483     RefPtr&lt;WebGLBuffer&gt; m_boundPixelPackBuffer;
484     RefPtr&lt;WebGLBuffer&gt; m_boundPixelUnpackBuffer;
485     RefPtr&lt;WebGLBuffer&gt; m_boundTransformFeedbackBuffer;
486     RefPtr&lt;WebGLBuffer&gt; m_boundUniformBuffer;
487 
488     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_defaultVertexArrayObject;
489     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_boundVertexArrayObject;
490 
491     void setBoundVertexArrayObject(WebGLVertexArrayObjectBase* arrayObject)
492     {
493         m_boundVertexArrayObject = arrayObject ? arrayObject : m_defaultVertexArrayObject;
494     }
495 
496     class VertexAttribValue {
497     public:
498         VertexAttribValue()
499         {
500             initValue();
501         }
502 
503         void initValue()
504         {
505             value[0] = 0.0f;
506             value[1] = 0.0f;
507             value[2] = 0.0f;
508             value[3] = 1.0f;
509         }
510 
511         GCGLfloat value[4];
512     };
513     Vector&lt;VertexAttribValue&gt; m_vertexAttribValue;
514     unsigned m_maxVertexAttribs;
515     RefPtr&lt;WebGLBuffer&gt; m_vertexAttrib0Buffer;
516     long m_vertexAttrib0BufferSize { 0 };
517     GCGLfloat m_vertexAttrib0BufferValue[4];
518     bool m_forceAttrib0BufferRefill { true };
519     bool m_vertexAttrib0UsedBefore { false };
520 
521     RefPtr&lt;WebGLProgram&gt; m_currentProgram;
522     RefPtr&lt;WebGLFramebuffer&gt; m_framebufferBinding;
523     RefPtr&lt;WebGLFramebuffer&gt; m_readFramebufferBinding;
524     RefPtr&lt;WebGLRenderbuffer&gt; m_renderbufferBinding;
525     struct TextureUnitState {
526         RefPtr&lt;WebGLTexture&gt; texture2DBinding;
527         RefPtr&lt;WebGLTexture&gt; textureCubeMapBinding;
528     };
529     Vector&lt;TextureUnitState&gt; m_textureUnits;
530     HashSet&lt;unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; m_unrenderableTextureUnits;
531 
532     unsigned long m_activeTextureUnit;
533 
534     RefPtr&lt;WebGLTexture&gt; m_blackTexture2D;
535     RefPtr&lt;WebGLTexture&gt; m_blackTextureCubeMap;
536 
537     Vector&lt;GCGLenum&gt; m_compressedTextureFormats;
538 
539     // Fixed-size cache of reusable image buffers for video texImage2D calls.
540     class LRUImageBufferCache {
541     public:
542         LRUImageBufferCache(int capacity);
543         // The pointer returned is owned by the image buffer map.
544         ImageBuffer* imageBuffer(const IntSize&amp; size);
545     private:
546         void bubbleToFront(size_t idx);
547         Vector&lt;std::unique_ptr&lt;ImageBuffer&gt;&gt; m_buffers;
548     };
549     LRUImageBufferCache m_generatedImageCache { 0 };
550 
551     GCGLint m_maxTextureSize;
552     GCGLint m_maxCubeMapTextureSize;
553     GCGLint m_maxRenderbufferSize;
554     GCGLint m_maxViewportDims[2] { 0, 0 };
555     GCGLint m_maxTextureLevel;
556     GCGLint m_maxCubeMapTextureLevel;
557 
558     GCGLint m_maxDrawBuffers;
559     GCGLint m_maxColorAttachments;
560     GCGLenum m_backDrawBuffer;
561     bool m_drawBuffersWebGLRequirementsChecked;
562     bool m_drawBuffersSupported;
563 
564     GCGLint m_packAlignment;
565     GCGLint m_unpackAlignment;
566     bool m_unpackFlipY;
567     bool m_unpackPremultiplyAlpha;
568     GCGLenum m_unpackColorspaceConversion;
569     bool m_contextLost { false };
570     LostContextMode m_contextLostMode { SyntheticLostContext };
571     WebGLContextAttributes m_attributes;
572 
573     bool m_layerCleared;
574     GCGLfloat m_clearColor[4];
575     bool m_scissorEnabled;
576     GCGLfloat m_clearDepth;
577     GCGLint m_clearStencil;
578     GCGLboolean m_colorMask[4];
579     GCGLboolean m_depthMask;
580 
581     bool m_stencilEnabled;
582     GCGLuint m_stencilMask, m_stencilMaskBack;
583     GCGLint m_stencilFuncRef, m_stencilFuncRefBack; // Note that these are the user specified values, not the internal clamped value.
584     GCGLuint m_stencilFuncMask, m_stencilFuncMaskBack;
585 
586     bool m_isGLES2Compliant;
587     bool m_isGLES2NPOTStrict;
588     bool m_isDepthStencilSupported;
589     bool m_isRobustnessEXTSupported;
590 
591     bool m_synthesizedErrorsToConsole { true };
592     int m_numGLErrorsToConsoleAllowed;
593 
594     bool m_preventBufferClearForInspector { false };
595 
596     // A WebGLRenderingContext can be created in a state where it appears as
597     // a valid and active context, but will not execute any important operations
598     // until its load policy is completely resolved.
599     bool m_isPendingPolicyResolution { false };
600     bool m_hasRequestedPolicyResolution { false };
601     bool isContextLostOrPending();
602 
603     // Enabled extension objects.
604     // FIXME: Move some of these to WebGLRenderingContext, the ones not needed for WebGL2
605     std::unique_ptr&lt;EXTFragDepth&gt; m_extFragDepth;
606     std::unique_ptr&lt;EXTBlendMinMax&gt; m_extBlendMinMax;
607     std::unique_ptr&lt;EXTsRGB&gt; m_extsRGB;
608     std::unique_ptr&lt;EXTTextureFilterAnisotropic&gt; m_extTextureFilterAnisotropic;
609     std::unique_ptr&lt;EXTShaderTextureLOD&gt; m_extShaderTextureLOD;
610     std::unique_ptr&lt;OESTextureFloat&gt; m_oesTextureFloat;
611     std::unique_ptr&lt;OESTextureFloatLinear&gt; m_oesTextureFloatLinear;
612     std::unique_ptr&lt;OESTextureHalfFloat&gt; m_oesTextureHalfFloat;
613     std::unique_ptr&lt;OESTextureHalfFloatLinear&gt; m_oesTextureHalfFloatLinear;
614     std::unique_ptr&lt;OESStandardDerivatives&gt; m_oesStandardDerivatives;
615     std::unique_ptr&lt;OESVertexArrayObject&gt; m_oesVertexArrayObject;
616     std::unique_ptr&lt;OESElementIndexUint&gt; m_oesElementIndexUint;
617     std::unique_ptr&lt;WebGLLoseContext&gt; m_webglLoseContext;
618     std::unique_ptr&lt;WebGLDebugRendererInfo&gt; m_webglDebugRendererInfo;
619     std::unique_ptr&lt;WebGLDebugShaders&gt; m_webglDebugShaders;
620     std::unique_ptr&lt;WebGLCompressedTextureASTC&gt; m_webglCompressedTextureASTC;
621     std::unique_ptr&lt;WebGLCompressedTextureATC&gt; m_webglCompressedTextureATC;
622     std::unique_ptr&lt;WebGLCompressedTextureETC&gt; m_webglCompressedTextureETC;
623     std::unique_ptr&lt;WebGLCompressedTextureETC1&gt; m_webglCompressedTextureETC1;
624     std::unique_ptr&lt;WebGLCompressedTexturePVRTC&gt; m_webglCompressedTexturePVRTC;
625     std::unique_ptr&lt;WebGLCompressedTextureS3TC&gt; m_webglCompressedTextureS3TC;
626     std::unique_ptr&lt;WebGLDepthTexture&gt; m_webglDepthTexture;
627     std::unique_ptr&lt;WebGLDrawBuffers&gt; m_webglDrawBuffers;
628     std::unique_ptr&lt;ANGLEInstancedArrays&gt; m_angleInstancedArrays;
629 
630     // Helpers for getParameter and other similar functions.
631     bool getBooleanParameter(GCGLenum);
632     Vector&lt;bool&gt; getBooleanArrayParameter(GCGLenum);
633     float getFloatParameter(GCGLenum);
634     int getIntParameter(GCGLenum);
635     unsigned getUnsignedIntParameter(GCGLenum);
636     long long getInt64Parameter(GCGLenum);
637     RefPtr&lt;Float32Array&gt; getWebGLFloatArrayParameter(GCGLenum);
638     RefPtr&lt;Int32Array&gt; getWebGLIntArrayParameter(GCGLenum);
639 
640     // Clear the backbuffer if it was composited since the last operation.
641     // clearMask is set to the bitfield of any clear that would happen anyway at this time
642     // and the function returns true if that clear is now unnecessary.
643     bool clearIfComposited(GCGLbitfield clearMask = 0);
644 
645     // Helper to restore state that clearing the framebuffer may destroy.
646     void restoreStateAfterClear();
647 
648     void texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels);
649     void texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);
650     void texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalformat, GCGLenum format, GCGLenum type, const void* pixels);
651     void texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);
652 
653     bool checkTextureCompleteness(const char*, bool);
654 
655     void createFallbackBlackTextures1x1();
656 
657     // Helper function for copyTex{Sub}Image, check whether the internalformat
658     // and the color buffer format of the current bound framebuffer combination
659     // is valid.
660     bool isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat);
661 
662     // Helper function to get the bound framebuffer&#39;s color buffer format.
663     GCGLenum getBoundFramebufferColorFormat();
664 
665     // Helper function to get the bound framebuffer&#39;s width.
666     int getBoundFramebufferWidth();
667 
668     // Helper function to get the bound framebuffer&#39;s height.
669     int getBoundFramebufferHeight();
670 
671     // Helper function to verify limits on the length of uniform and attribute locations.
672     bool validateLocationLength(const char* functionName, const String&amp;);
673 
674     // Helper function to check if size is non-negative.
675     // Generate GL error and return false for negative inputs; otherwise, return true.
676     bool validateSize(const char* functionName, GCGLint x, GCGLint y);
677 
678     // Helper function to check if all characters in the string belong to the
679     // ASCII subset as defined in GLSL ES 1.0 spec section 3.1.
680     bool validateString(const char* functionName, const String&amp;);
681 
682     // Helper function to check target and texture bound to the target.
683     // Generate GL errors and return 0 if target is invalid or texture bound is
684     // null.  Otherwise, return the texture bound to the target.
685     RefPtr&lt;WebGLTexture&gt; validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap);
686 
687     // Helper function to check input format/type for functions {copy}Tex{Sub}Image.
688     // Generates GL error and returns false if parameters are invalid.
689     bool validateTexFuncFormatAndType(const char* functionName, GCGLenum internalformat, GCGLenum format, GCGLenum type, GCGLint level);
690 
691     // Helper function to check input level for functions {copy}Tex{Sub}Image.
692     // Generates GL error and returns false if level is invalid.
693     bool validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level);
694 
695     enum TexFuncValidationFunctionType {
696         TexImage,
697         TexSubImage,
698         CopyTexImage
699     };
700 
701     enum TexFuncValidationSourceType {
702         SourceArrayBufferView,
703         SourceImageBitmap,
704         SourceImageData,
705         SourceHTMLImageElement,
706         SourceHTMLCanvasElement,
707 #if ENABLE(VIDEO)
708         SourceHTMLVideoElement,
709 #endif
710     };
711 
712     // Helper function for tex{Sub}Image2D to check if the input format/type/level/target/width/height/border/xoffset/yoffset are valid.
713     // Otherwise, it would return quickly without doing other work.
714     bool validateTexFunc(const char* functionName, TexFuncValidationFunctionType, TexFuncValidationSourceType, GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width,
715         GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset);
716 
717     // Helper function to check input parameters for functions {copy}Tex{Sub}Image.
718     // Generates GL error and returns false if parameters are invalid.
719     bool validateTexFuncParameters(const char* functionName,
720         TexFuncValidationFunctionType,
721         GCGLenum target, GCGLint level,
722         GCGLenum internalformat,
723         GCGLsizei width, GCGLsizei height, GCGLint border,
724         GCGLenum format, GCGLenum type);
725 
726     enum NullDisposition {
727         NullAllowed,
728         NullNotAllowed
729     };
730 
731     // Helper function to validate that the given ArrayBufferView
732     // is of the correct type and contains enough data for the texImage call.
733     // Generates GL error and returns false if parameters are invalid.
734     bool validateTexFuncData(const char* functionName, GCGLint level,
735         GCGLsizei width, GCGLsizei height,
736         GCGLenum internalformat, GCGLenum format, GCGLenum type,
737         ArrayBufferView* pixels,
738         NullDisposition);
739 
740     // Helper function to validate a given texture format is settable as in
741     // you can supply data to texImage2D, or call texImage2D, copyTexImage2D and
742     // copyTexSubImage2D.
743     // Generates GL error and returns false if the format is not settable.
744     bool validateSettableTexInternalFormat(const char* functionName, GCGLenum format);
745 
746     // Helper function to validate compressed texture data is correct size
747     // for the given format and dimensions.
748     bool validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels);
749 
750     // Helper function for validating compressed texture formats.
751     bool validateCompressedTexFormat(GCGLenum format);
752 
753     // Helper function to validate compressed texture dimensions are valid for
754     // the given format.
755     bool validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format);
756 
757     // Helper function to validate compressed texture dimensions are valid for
758     // the given format.
759     bool validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset,
760         GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture*);
761 
762     // Helper function to validate mode for draw{Arrays/Elements}.
763     bool validateDrawMode(const char* functionName, GCGLenum);
764 
765     // Helper function to validate if front/back stencilMask and stencilFunc settings are the same.
766     bool validateStencilSettings(const char* functionName);
767 
768     // Helper function to validate stencil func.
769     bool validateStencilFunc(const char* functionName, GCGLenum);
770 
771     // Helper function for texParameterf and texParameteri.
772     void texParameter(GCGLenum target, GCGLenum pname, GCGLfloat parami, GCGLint paramf, bool isFloat);
773 
774     // Helper function to print errors and warnings to console.
775     void printToConsole(MessageLevel, const String&amp;);
776 
777     // Helper function to validate input parameters for framebuffer functions.
778     // Generate GL error if parameters are illegal.
779     virtual bool validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment) = 0;
780 
781     // Helper function to validate blend equation mode.
782     virtual bool validateBlendEquation(const char* functionName, GCGLenum) = 0;
783 
784     // Helper function to validate blend func factors.
785     bool validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst);
786 
787     // Helper function to validate a GL capability.
788     virtual bool validateCapability(const char* functionName, GCGLenum) = 0;
789 
790     // Helper function to validate input parameters for uniform functions.
791     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Float32List&amp;, GCGLsizei mod);
792     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Int32List&amp;, GCGLsizei mod);
793     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, void*, GCGLsizei, GCGLsizei mod);
794     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const Float32List&amp;, GCGLsizei mod);
795     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const void*, GCGLsizei, GCGLsizei mod);
796 
797     // Helper function to validate parameters for bufferData.
798     // Return the current bound buffer to target, or 0 if parameters are invalid.
799     WebGLBuffer* validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage);
800 
801     // Helper function for tex{Sub}Image2D to make sure image is ready.
802     ExceptionOr&lt;bool&gt; validateHTMLImageElement(const char* functionName, HTMLImageElement*);
803     ExceptionOr&lt;bool&gt; validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement*);
804 #if ENABLE(VIDEO)
805     ExceptionOr&lt;bool&gt; validateHTMLVideoElement(const char* functionName, HTMLVideoElement*);
806 #endif
807 
808     // Helper functions for vertexAttribNf{v}.
809     void vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat, GCGLfloat, GCGLfloat, GCGLfloat);
810     void vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp;, GCGLsizei expectedSize);
811 
812     // Helper function for delete* (deleteBuffer, deleteProgram, etc) functions.
813     // Return false if caller should return without further processing.
814     bool deleteObject(WebGLObject*);
815 
816     // Helper function for bind* (bindBuffer, bindTexture, etc) and useProgram.
817     // If the object has already been deleted, set deleted to true upon return.
818     // Return false if caller should return without further processing.
819     bool checkObjectToBeBound(const char* functionName, WebGLObject*, bool&amp; deleted);
820 
821     bool validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer*);
822 
823     // Helpers for simulating vertexAttrib0.
824     void initVertexAttrib0();
825     Optional&lt;bool&gt; simulateVertexAttrib0(GCGLuint numVertex);
826     bool validateSimulatedVertexAttrib0(GCGLuint numVertex);
827     void restoreStatesAfterVertexAttrib0Simulation();
828 
829     // Wrapper for GraphicsContextGLOpenGL::synthesizeGLError that sends a message to the JavaScript console.
830     enum ConsoleDisplayPreference { DisplayInConsole, DontDisplayInConsole };
831     void synthesizeGLError(GCGLenum, const char* functionName, const char* description, ConsoleDisplayPreference = DisplayInConsole);
832 
833     String ensureNotNull(const String&amp;) const;
834 
835     // Enable or disable stencil test based on user setting and whether the current FBO has a stencil buffer.
836     void applyStencilTest();
837 
838     // Helper for enabling or disabling a capability.
839     void enableOrDisable(GCGLenum capability, bool enable);
840 
841     // Clamp the width and height to GL_MAX_VIEWPORT_DIMS.
842     IntSize clampedCanvasSize();
843 
844     virtual GCGLint getMaxDrawBuffers() = 0;
845     virtual GCGLint getMaxColorAttachments() = 0;
846 
847     void setBackDrawBuffer(GCGLenum);
848 
849     void restoreCurrentFramebuffer();
850     void restoreCurrentTexture2D();
851 
852     // Check if EXT_draw_buffers extension is supported and if it satisfies the WebGL requirements.
853     bool supportsDrawBuffers();
854 
855 #if ENABLE(OFFSCREEN_CANVAS)
856     OffscreenCanvas* offscreenCanvas();
857 #endif
858 
859     template &lt;typename T&gt; inline Optional&lt;T&gt; checkedAddAndMultiply(T value, T add, T multiply);
860     template &lt;typename T&gt; unsigned getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n);
861 
862 private:
863     void dispatchContextLostEvent();
864     void dispatchContextChangedEvent();
865     // Helper for restoration after context lost.
866     void maybeRestoreContext();
867 
868     bool validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt;);
869     void registerWithWebGLStateTracker();
870     void checkForContextLossHandling();
871 
872     void activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState) override;
873 
874     WebGLStateTracker::Token m_trackerToken;
875     Timer m_checkForContextLossHandlingTimer;
876     bool m_isSuspended { false };
877 };
878 
879 template &lt;typename T&gt;
880 inline Optional&lt;T&gt; WebGLRenderingContextBase::checkedAddAndMultiply(T value, T add, T multiply)
881 {
882     Checked&lt;T, RecordOverflow&gt; checkedResult = Checked&lt;T&gt;(value);
883     checkedResult += Checked&lt;T&gt;(add);
884     checkedResult *= Checked&lt;T&gt;(multiply);
885     if (checkedResult.hasOverflowed())
886         return WTF::nullopt;
887 
888     return checkedResult.unsafeGet();
889 }
890 
891 template&lt;typename T&gt;
892 inline unsigned WebGLRenderingContextBase::getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n)
893 {
894     unsigned maxIndex = 0;
895     T restartIndex = 0;
896 
897 #if ENABLE(WEBGL2)
898     // WebGL 2 spec enforces that GL_PRIMITIVE_RESTART_FIXED_INDEX is always enabled, so ignore the restart index.
899     if (isWebGL2())
900         restartIndex = std::numeric_limits&lt;T&gt;::max();
901 #endif
902 
903     // Make uoffset an element offset.
904     uoffset /= sizeof(T);
905     const T* p = static_cast&lt;const T*&gt;(elementArrayBuffer-&gt;data()) + uoffset;
906     while (n-- &gt; 0) {
907         if (*p != restartIndex &amp;&amp; *p &gt; maxIndex)
908             maxIndex = *p;
909         ++p;
910     }
911 
912     return maxIndex;
913 }
914 
915 } // namespace WebCore
916 
917 SPECIALIZE_TYPE_TRAITS_CANVASRENDERINGCONTEXT(WebCore::WebGLRenderingContextBase, isWebGL())
918 
919 #endif
    </pre>
  </body>
</html>
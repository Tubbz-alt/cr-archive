<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2014-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;AccessCase.h&quot;
 31 #include &quot;JITStubRoutine.h&quot;
 32 #include &quot;JSFunctionInlines.h&quot;
 33 #include &quot;MacroAssembler.h&quot;
 34 #include &quot;ScratchRegisterAllocator.h&quot;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 namespace JSC {
 38 namespace DOMJIT {
 39 class GetterSetter;
 40 }
 41 
 42 class CodeBlock;
 43 class PolymorphicAccess;
 44 class StructureStubInfo;
 45 class WatchpointsOnStructureStubInfo;
 46 class ScratchRegisterAllocator;
 47 
<a name="2" id="anc2"></a><span class="line-added"> 48 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
<span class="line-added"> 49 </span>
 50 class AccessGenerationResult {
 51 public:
 52     enum Kind {
 53         MadeNoChanges,
 54         GaveUp,
 55         Buffered,
 56         GeneratedNewCode,
 57         GeneratedFinalCode, // Generated so much code that we never want to generate code again.
 58         ResetStubAndFireWatchpoints // We found out some data that makes us want to start over fresh with this stub. Currently, this happens when we detect poly proto.
 59     };
 60 
 61 
 62     AccessGenerationResult() = default;
 63     AccessGenerationResult(AccessGenerationResult&amp;&amp;) = default;
 64     AccessGenerationResult&amp; operator=(AccessGenerationResult&amp;&amp;) = default;
 65 
 66     AccessGenerationResult(Kind kind)
 67         : m_kind(kind)
 68     {
 69         RELEASE_ASSERT(kind != GeneratedNewCode);
 70         RELEASE_ASSERT(kind != GeneratedFinalCode);
 71     }
 72 
 73     AccessGenerationResult(Kind kind, MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt; code)
 74         : m_kind(kind)
 75         , m_code(code)
 76     {
 77         RELEASE_ASSERT(kind == GeneratedNewCode || kind == GeneratedFinalCode);
 78         RELEASE_ASSERT(code);
 79     }
 80 
 81     bool operator==(const AccessGenerationResult&amp; other) const
 82     {
 83         return m_kind == other.m_kind &amp;&amp; m_code == other.m_code;
 84     }
 85 
 86     bool operator!=(const AccessGenerationResult&amp; other) const
 87     {
 88         return !(*this == other);
 89     }
 90 
 91     explicit operator bool() const
 92     {
 93         return *this != AccessGenerationResult();
 94     }
 95 
 96     Kind kind() const { return m_kind; }
 97 
 98     const MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt;&amp; code() const { return m_code; }
 99 
100     bool madeNoChanges() const { return m_kind == MadeNoChanges; }
101     bool gaveUp() const { return m_kind == GaveUp; }
102     bool buffered() const { return m_kind == Buffered; }
103     bool generatedNewCode() const { return m_kind == GeneratedNewCode; }
104     bool generatedFinalCode() const { return m_kind == GeneratedFinalCode; }
105     bool shouldResetStubAndFireWatchpoints() const { return m_kind == ResetStubAndFireWatchpoints; }
106 
107     // If we gave up on this attempt to generate code, or if we generated the &quot;final&quot; code, then we
108     // should give up after this.
109     bool shouldGiveUpNow() const { return gaveUp() || generatedFinalCode(); }
110 
111     bool generatedSomeCode() const { return generatedNewCode() || generatedFinalCode(); }
112 
113     void dump(PrintStream&amp;) const;
114 
115     void addWatchpointToFire(InlineWatchpointSet&amp; set, StringFireDetail detail)
116     {
117         m_watchpointsToFire.append(std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;(set, detail));
118     }
119     void fireWatchpoints(VM&amp; vm)
120     {
121         ASSERT(m_kind == ResetStubAndFireWatchpoints);
122         for (auto&amp; pair : m_watchpointsToFire)
123             pair.first.invalidate(vm, pair.second);
124     }
125 
126 private:
127     Kind m_kind;
128     MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt; m_code;
129     Vector&lt;std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;&gt; m_watchpointsToFire;
130 };
131 
132 class PolymorphicAccess {
133     WTF_MAKE_NONCOPYABLE(PolymorphicAccess);
<a name="3" id="anc3"></a><span class="line-modified">134     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
135 public:
136     PolymorphicAccess();
137     ~PolymorphicAccess();
138 
139     // When this fails (returns GaveUp), this will leave the old stub intact but you should not try
140     // to call this method again for that PolymorphicAccess instance.
141     AccessGenerationResult addCases(
<a name="4" id="anc4"></a><span class="line-modified">142         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt;);</span>
143 
144     AccessGenerationResult addCase(
<a name="5" id="anc5"></a><span class="line-modified">145         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
146 
<a name="6" id="anc6"></a><span class="line-modified">147     AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;);</span>
148 
149     bool isEmpty() const { return m_list.isEmpty(); }
150     unsigned size() const { return m_list.size(); }
151     const AccessCase&amp; at(unsigned i) const { return *m_list[i]; }
152     const AccessCase&amp; operator[](unsigned i) const { return *m_list[i]; }
153 
<a name="7" id="anc7"></a><span class="line-added">154     void visitAggregate(SlotVisitor&amp;);</span>
<span class="line-added">155 </span>
156     // If this returns false then we are requesting a reset of the owning StructureStubInfo.
157     bool visitWeak(VM&amp;) const;
158 
159     // This returns true if it has marked everything it will ever marked. This can be used as an
160     // optimization to then avoid calling this method again during the fixpoint.
161     bool propagateTransitions(SlotVisitor&amp;) const;
162 
163     void aboutToDie();
164 
165     void dump(PrintStream&amp; out) const;
166     bool containsPC(void* pc) const
167     {
168         if (!m_stubRoutine)
169             return false;
170 
171         uintptr_t pcAsInt = bitwise_cast&lt;uintptr_t&gt;(pc);
172         return m_stubRoutine-&gt;startAddress() &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= m_stubRoutine-&gt;endAddress();
173     }
174 
175 private:
176     friend class AccessCase;
177     friend class CodeBlock;
178     friend struct AccessGenerationState;
179 
180     typedef Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; ListType;
181 
182     void commit(
183         const GCSafeConcurrentJSLocker&amp;, VM&amp;, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp;, CodeBlock*, StructureStubInfo&amp;,
<a name="8" id="anc8"></a><span class="line-modified">184         AccessCase&amp;);</span>
185 
186     ListType m_list;
187     RefPtr&lt;JITStubRoutine&gt; m_stubRoutine;
188     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; m_watchpoints;
189     std::unique_ptr&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt; m_weakReferences;
190 };
191 
192 struct AccessGenerationState {
193     AccessGenerationState(VM&amp; vm, JSGlobalObject* globalObject)
194         : m_vm(vm)
195         , m_globalObject(globalObject)
196         , m_calculatedRegistersForCallAndExceptionHandling(false)
197         , m_needsToRestoreRegistersIfException(false)
198         , m_calculatedCallSiteIndex(false)
199     {
<a name="9" id="anc9"></a><span class="line-added">200         u.thisGPR = InvalidGPRReg;</span>
201     }
202     VM&amp; m_vm;
203     JSGlobalObject* m_globalObject;
204     CCallHelpers* jit { nullptr };
205     ScratchRegisterAllocator* allocator;
206     ScratchRegisterAllocator::PreservedState preservedReusedRegisterState;
207     PolymorphicAccess* access { nullptr };
208     StructureStubInfo* stubInfo { nullptr };
209     MacroAssembler::JumpList success;
210     MacroAssembler::JumpList failAndRepatch;
211     MacroAssembler::JumpList failAndIgnore;
212     GPRReg baseGPR { InvalidGPRReg };
<a name="10" id="anc10"></a><span class="line-modified">213     union {</span>
<span class="line-added">214         GPRReg thisGPR;</span>
<span class="line-added">215         GPRReg prototypeGPR;</span>
<span class="line-added">216         GPRReg propertyGPR;</span>
<span class="line-added">217     } u;</span>
218     JSValueRegs valueRegs;
219     GPRReg scratchGPR { InvalidGPRReg };
<a name="11" id="anc11"></a><span class="line-modified">220     FPRReg scratchFPR { InvalidFPRReg };</span>
221     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; watchpoints;
222     Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;
<a name="12" id="anc12"></a><span class="line-added">223     Bag&lt;CallLinkInfo&gt; m_callLinkInfos;</span>
224 
<a name="13" id="anc13"></a><span class="line-modified">225     void installWatchpoint(const ObjectPropertyCondition&amp;);</span>
226 
227     void restoreScratch();
228     void succeed();
229 
230     struct SpillState {
231         SpillState() = default;
232         SpillState(RegisterSet&amp;&amp; regs, unsigned usedStackBytes)
233             : spilledRegisters(WTFMove(regs))
234             , numberOfStackBytesUsedForRegisterPreservation(usedStackBytes)
235         {
236         }
237 
238         RegisterSet spilledRegisters { };
239         unsigned numberOfStackBytesUsedForRegisterPreservation { std::numeric_limits&lt;unsigned&gt;::max() };
240 
241         bool isEmpty() const { return numberOfStackBytesUsedForRegisterPreservation == std::numeric_limits&lt;unsigned&gt;::max(); }
242     };
243 
244     const RegisterSet&amp; calculateLiveRegistersForCallAndExceptionHandling();
245 
246     SpillState preserveLiveRegistersToStackForCall(const RegisterSet&amp; extra = { });
247 
248     void restoreLiveRegistersFromStackForCallWithThrownException(const SpillState&amp;);
249     void restoreLiveRegistersFromStackForCall(const SpillState&amp;, const RegisterSet&amp; dontRestore = { });
250 
251     const RegisterSet&amp; liveRegistersForCall();
252 
253     CallSiteIndex callSiteIndexForExceptionHandlingOrOriginal();
254     DisposableCallSiteIndex callSiteIndexForExceptionHandling();
255 
256     const HandlerInfo&amp; originalExceptionHandler();
257 
258     bool needsToRestoreRegistersIfException() const { return m_needsToRestoreRegistersIfException; }
259     CallSiteIndex originalCallSiteIndex() const;
260 
261     void emitExplicitExceptionHandler();
262 
263     void setSpillStateForJSGetterSetter(SpillState&amp; spillState)
264     {
265         if (!m_spillStateForJSGetterSetter.isEmpty()) {
266             ASSERT(m_spillStateForJSGetterSetter.numberOfStackBytesUsedForRegisterPreservation == spillState.numberOfStackBytesUsedForRegisterPreservation);
267             ASSERT(m_spillStateForJSGetterSetter.spilledRegisters == spillState.spilledRegisters);
268         }
269         m_spillStateForJSGetterSetter = spillState;
270     }
271     SpillState spillStateForJSGetterSetter() const { return m_spillStateForJSGetterSetter; }
272 
273 private:
274     const RegisterSet&amp; liveRegistersToPreserveAtExceptionHandlingCallSite();
275 
276     RegisterSet m_liveRegistersToPreserveAtExceptionHandlingCallSite;
277     RegisterSet m_liveRegistersForCall;
278     CallSiteIndex m_callSiteIndex;
279     SpillState m_spillStateForJSGetterSetter;
280     bool m_calculatedRegistersForCallAndExceptionHandling : 1;
281     bool m_needsToRestoreRegistersIfException : 1;
282     bool m_calculatedCallSiteIndex : 1;
283 };
284 
285 } // namespace JSC
286 
287 namespace WTF {
288 
289 void printInternal(PrintStream&amp;, JSC::AccessGenerationResult::Kind);
290 void printInternal(PrintStream&amp;, JSC::AccessCase::AccessType);
291 void printInternal(PrintStream&amp;, JSC::AccessCase::State);
292 
293 } // namespace WTF
294 
295 #endif // ENABLE(JIT)
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
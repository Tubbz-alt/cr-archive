<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringToIntegerConversion.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
<span class="line-modified">   3  * Copyright (C) 2005-2018 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2009 Google Inc. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &lt;limits.h&gt;
  26 #include &lt;unicode/ustring.h&gt;
  27 #include &lt;wtf/ASCIICType.h&gt;
  28 #include &lt;wtf/CheckedArithmetic.h&gt;

  29 #include &lt;wtf/Expected.h&gt;
  30 #include &lt;wtf/MathExtras.h&gt;

  31 #include &lt;wtf/StdLibExtras.h&gt;
  32 #include &lt;wtf/Vector.h&gt;
  33 #include &lt;wtf/text/ASCIIFastPath.h&gt;
  34 #include &lt;wtf/text/ConversionMode.h&gt;
  35 #include &lt;wtf/text/StringCommon.h&gt;
  36 #include &lt;wtf/text/StringHasher.h&gt;
  37 #include &lt;wtf/text/UTF8ConversionError.h&gt;
  38 
  39 #if USE(CF)
  40 typedef const struct __CFString * CFStringRef;
  41 #endif
  42 
  43 #ifdef __OBJC__
  44 @class NSString;
  45 #endif
  46 
  47 namespace JSC {
  48 namespace LLInt { class Data; }
  49 class LLIntOffsetsExtractor;
  50 }
</pre>
<hr />
<pre>
  77     WTF_MAKE_STRUCT_FAST_ALLOCATED;
  78     void add8BitString(unsigned length, bool isSubString = false)
  79     {
  80         ++m_totalNumberStrings;
  81         ++m_number8BitStrings;
  82         if (!isSubString)
  83             m_total8BitData += length;
  84     }
  85 
  86     void add16BitString(unsigned length, bool isSubString = false)
  87     {
  88         ++m_totalNumberStrings;
  89         ++m_number16BitStrings;
  90         if (!isSubString)
  91             m_total16BitData += length;
  92     }
  93 
  94     void removeString(StringImpl&amp;);
  95     void printStats();
  96 
<span class="line-modified">  97     static const unsigned s_printStringStatsFrequency = 5000;</span>
  98     static std::atomic&lt;unsigned&gt; s_stringRemovesTillPrintStats;
  99 
 100     std::atomic&lt;unsigned&gt; m_refCalls;
 101     std::atomic&lt;unsigned&gt; m_derefCalls;
 102 
 103     std::atomic&lt;unsigned&gt; m_totalNumberStrings;
 104     std::atomic&lt;unsigned&gt; m_number8BitStrings;
 105     std::atomic&lt;unsigned&gt; m_number16BitStrings;
 106     std::atomic&lt;unsigned long long&gt; m_total8BitData;
 107     std::atomic&lt;unsigned long long&gt; m_total16BitData;
 108 };
 109 
 110 #define STRING_STATS_ADD_8BIT_STRING(length) StringImpl::stringStats().add8BitString(length)
 111 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) StringImpl::stringStats().add8BitString(length, isSubString)
 112 #define STRING_STATS_ADD_16BIT_STRING(length) StringImpl::stringStats().add16BitString(length)
 113 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) StringImpl::stringStats().add16BitString(length, isSubString)
 114 #define STRING_STATS_REMOVE_STRING(string) StringImpl::stringStats().removeString(string)
 115 #define STRING_STATS_REF_STRING(string) ++StringImpl::stringStats().m_refCalls;
 116 #define STRING_STATS_DEREF_STRING(string) ++StringImpl::stringStats().m_derefCalls;
 117 
</pre>
<hr />
<pre>
 143 
 144     unsigned m_refCount;
 145     unsigned m_length;
 146     union {
 147         const LChar* m_data8;
 148         const UChar* m_data16;
 149         // It seems that reinterpret_cast prevents constexpr&#39;s compile time initialization in VC++.
 150         // These are needed to avoid reinterpret_cast.
 151         const char* m_data8Char;
 152         const char16_t* m_data16Char;
 153     };
 154     mutable unsigned m_hashAndFlags;
 155 };
 156 
 157 // FIXME: Use of StringImpl and const is rather confused.
 158 // The actual string inside a StringImpl is immutable, so you can&#39;t modify a string using a StringImpl&amp;.
 159 // We could mark every member function const and always use &quot;const StringImpl&amp;&quot; and &quot;const StringImpl*&quot;.
 160 // Or we could say that &quot;const&quot; doesn&#39;t make sense at all and use &quot;StringImpl&amp;&quot; and &quot;StringImpl*&quot; everywhere.
 161 // Right now we use a mix of both, which makes code more confusing and has no benefit.
 162 

 163 class StringImpl : private StringImplShape {
<span class="line-modified"> 164     WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;</span>

 165 
 166     friend class AtomStringImpl;
 167     friend class JSC::LLInt::Data;
 168     friend class JSC::LLIntOffsetsExtractor;
 169     friend class PrivateSymbolImpl;
 170     friend class RegisteredSymbolImpl;
 171     friend class SymbolImpl;
 172     friend class ExternalStringImpl;
 173 
 174     friend struct WTF::CStringTranslator;
 175     friend struct WTF::HashAndUTF8CharactersTranslator;
 176     friend struct WTF::LCharBufferTranslator;
 177     friend struct WTF::SubstringTranslator;
 178     friend struct WTF::UCharBufferTranslator;
 179 
 180     template&lt;typename&gt; friend struct WTF::BufferFromStaticDataTranslator;
 181     template&lt;typename&gt; friend struct WTF::HashAndCharactersTranslator;
 182 
 183 public:
 184     enum BufferOwnership { BufferInternal, BufferOwned, BufferSubstring, BufferExternal };
 185 
 186     static constexpr unsigned MaxLength = StringImplShape::MaxLength;
 187 
 188     // The bottom 6 bits in the hash are flags.
 189     static constexpr const unsigned s_flagCount = 6;

 190 private:
 191     static constexpr const unsigned s_flagMask = (1u &lt;&lt; s_flagCount) - 1;
 192     static_assert(s_flagCount &lt;= StringHasher::flagCount, &quot;StringHasher reserves enough bits for StringImpl flags&quot;);
 193     static constexpr const unsigned s_flagStringKindCount = 4;
 194 
 195     static constexpr const unsigned s_hashFlagStringKindIsAtom = 1u &lt;&lt; (s_flagStringKindCount);
 196     static constexpr const unsigned s_hashFlagStringKindIsSymbol = 1u &lt;&lt; (s_flagStringKindCount + 1);
 197     static constexpr const unsigned s_hashMaskStringKind = s_hashFlagStringKindIsAtom | s_hashFlagStringKindIsSymbol;
 198     static constexpr const unsigned s_hashFlagDidReportCost = 1u &lt;&lt; 3;
 199     static constexpr const unsigned s_hashFlag8BitBuffer = 1u &lt;&lt; 2;
 200     static constexpr const unsigned s_hashMaskBufferOwnership = (1u &lt;&lt; 0) | (1u &lt;&lt; 1);
 201 
 202     enum StringKind {
 203         StringNormal = 0u, // non-symbol, non-atomic
 204         StringAtom = s_hashFlagStringKindIsAtom, // non-symbol, atomic
 205         StringSymbol = s_hashFlagStringKindIsSymbol, // symbol, non-atomic
 206     };
 207 
 208     // Create a normal 8-bit string with internal storage (BufferInternal).
 209     enum Force8Bit { Force8BitConstructor };
 210     StringImpl(unsigned length, Force8Bit);
 211 
 212     // Create a normal 16-bit string with internal storage (BufferInternal).
 213     explicit StringImpl(unsigned length);
 214 
 215     // Create a StringImpl adopting ownership of the provided buffer (BufferOwned).
<span class="line-modified"> 216     StringImpl(MallocPtr&lt;LChar&gt;, unsigned length);</span>
<span class="line-modified"> 217     StringImpl(MallocPtr&lt;UChar&gt;, unsigned length);</span>
 218     enum ConstructWithoutCopyingTag { ConstructWithoutCopying };
 219     StringImpl(const UChar*, unsigned length, ConstructWithoutCopyingTag);
 220     StringImpl(const LChar*, unsigned length, ConstructWithoutCopyingTag);
 221 
 222     // Used to create new strings that are a substring of an existing StringImpl (BufferSubstring).
 223     StringImpl(const LChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 224     StringImpl(const UChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 225 
 226 public:
 227     WTF_EXPORT_PRIVATE static void destroy(StringImpl*);
 228 
 229     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const UChar*, unsigned length);
 230     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const LChar*, unsigned length);
 231     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create8BitIfPossible(const UChar*, unsigned length);
 232     template&lt;size_t inlineCapacity&gt; static Ref&lt;StringImpl&gt; create8BitIfPossible(const Vector&lt;UChar, inlineCapacity&gt;&amp;);
 233     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create8BitIfPossible(const UChar*);
 234 
 235     ALWAYS_INLINE static Ref&lt;StringImpl&gt; create(const char* characters, unsigned length) { return create(reinterpret_cast&lt;const LChar*&gt;(characters), length); }
 236     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const LChar*);
 237     ALWAYS_INLINE static Ref&lt;StringImpl&gt; create(const char* string) { return create(reinterpret_cast&lt;const LChar*&gt;(string)); }
 238 
 239     static Ref&lt;StringImpl&gt; createSubstringSharingImpl(StringImpl&amp;, unsigned offset, unsigned length);
 240 
 241     template&lt;unsigned characterCount&gt; static Ref&lt;StringImpl&gt; createFromLiteral(const char (&amp;)[characterCount]);
 242 
 243     // FIXME: Replace calls to these overloads of createFromLiteral to createWithoutCopying instead.
 244     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*, unsigned length);
 245     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*);
 246 
 247     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const UChar*, unsigned length);
 248     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const LChar*, unsigned length);
 249     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, LChar*&amp;);
 250     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, UChar*&amp;);
 251     template&lt;typename CharacterType&gt; static RefPtr&lt;StringImpl&gt; tryCreateUninitialized(unsigned length, CharacterType*&amp;);
 252 


 253     // Reallocate the StringImpl. The originalString must be only owned by the Ref,
 254     // and the buffer ownership must be BufferInternal. Just like the input pointer of realloc(),
 255     // the originalString can&#39;t be used after this function.
 256     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 257     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 258     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 259     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 260 
 261     static unsigned flagsOffset() { return OBJECT_OFFSETOF(StringImpl, m_hashAndFlags); }
 262     static constexpr unsigned flagIs8Bit() { return s_hashFlag8BitBuffer; }
 263     static constexpr unsigned flagIsAtom() { return s_hashFlagStringKindIsAtom; }
 264     static constexpr unsigned flagIsSymbol() { return s_hashFlagStringKindIsSymbol; }
 265     static constexpr unsigned maskStringKind() { return s_hashMaskStringKind; }
 266     static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }
 267 
<span class="line-modified"> 268     template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 269     static Ref&lt;StringImpl&gt; adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp;);</span>
 270 
 271     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;UChar&gt;&amp;&amp;);
 272     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;LChar&gt;&amp;&amp;);
 273 
 274     unsigned length() const { return m_length; }
 275     static ptrdiff_t lengthMemoryOffset() { return OBJECT_OFFSETOF(StringImpl, m_length); }
 276     bool isEmpty() const { return !m_length; }
 277 
 278     bool is8Bit() const { return m_hashAndFlags &amp; s_hashFlag8BitBuffer; }
 279     ALWAYS_INLINE const LChar* characters8() const { ASSERT(is8Bit()); return m_data8; }
 280     ALWAYS_INLINE const UChar* characters16() const { ASSERT(!is8Bit()); return m_data16; }
 281 
 282     template&lt;typename CharacterType&gt; const CharacterType* characters() const;
 283 
 284     size_t cost() const;
 285     size_t costDuringGC();
 286 
 287     WTF_EXPORT_PRIVATE size_t sizeInBytes() const;
 288 
 289     bool isSymbol() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsSymbol; }
</pre>
<hr />
<pre>
 353         //       that StringImpl::cost() returns early.
 354         //       This means StaticStringImpl costs are not counted. But since there should only
 355         //       be a finite set of StaticStringImpls, their cost can be aggregated into a single
 356         //       system cost if needed.
 357         //    b. setIsAtom() is never called on a StaticStringImpl.
 358         //       setIsAtom() asserts !isStatic().
 359         //    c. setHash() is never called on a StaticStringImpl.
 360         //       StaticStringImpl&#39;s constructor sets the hash on construction.
 361         //       StringImpl::hash() only sets a new hash iff !hasHash().
 362         //       Additionally, StringImpl::setHash() asserts hasHash() and !isStatic().
 363 
 364         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char (&amp;characters)[characterCount], StringKind = StringNormal);
 365         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char16_t (&amp;characters)[characterCount], StringKind = StringNormal);
 366         operator StringImpl&amp;();
 367     };
 368 
 369     WTF_EXPORT_PRIVATE static StaticStringImpl s_emptyAtomString;
 370     ALWAYS_INLINE static StringImpl* empty() { return reinterpret_cast&lt;StringImpl*&gt;(&amp;s_emptyAtomString); }
 371 
 372     // FIXME: Does this really belong in StringImpl?
<span class="line-modified"> 373     template&lt;typename CharacterType&gt; static void copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters);</span>
<span class="line-removed"> 374     static void copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters);</span>
 375 
 376     // Some string features, like reference counting and the atomicity flag, are not
 377     // thread-safe. We achieve thread safety by isolation, giving each thread
 378     // its own copy of the string.
 379     Ref&lt;StringImpl&gt; isolatedCopy() const;
 380 
 381     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; substring(unsigned position, unsigned length = MaxLength);
 382 
 383     UChar at(unsigned) const;
 384     UChar operator[](unsigned i) const { return at(i); }
 385     WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned);
 386 
 387     int toIntStrict(bool* ok = 0, int base = 10);
 388     unsigned toUIntStrict(bool* ok = 0, int base = 10);
 389     int64_t toInt64Strict(bool* ok = 0, int base = 10);
 390     uint64_t toUInt64Strict(bool* ok = 0, int base = 10);
 391     intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);
 392 
 393     WTF_EXPORT_PRIVATE int toInt(bool* ok = 0); // ignores trailing garbage
 394     unsigned toUInt(bool* ok = 0); // ignores trailing garbage
</pre>
<hr />
<pre>
 502     bool requiresCopy() const;
 503     template&lt;typename T&gt; const T* tailPointer() const;
 504     template&lt;typename T&gt; T* tailPointer();
 505     StringImpl* const&amp; substringBuffer() const;
 506     StringImpl*&amp; substringBuffer();
 507 
 508     enum class CaseConvertType { Upper, Lower };
 509     template&lt;CaseConvertType, typename CharacterType&gt; static Ref&lt;StringImpl&gt; convertASCIICase(StringImpl&amp;, const CharacterType*, unsigned);
 510 
 511     template&lt;class CodeUnitPredicate&gt; Ref&lt;StringImpl&gt; stripMatchedCharacters(CodeUnitPredicate);
 512     template&lt;typename CharacterType&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; removeCharacters(const CharacterType* characters, CodeUnitMatchFunction);
 513     template&lt;typename CharacterType, class CodeUnitPredicate&gt; Ref&lt;StringImpl&gt; simplifyMatchedCharactersToSpace(CodeUnitPredicate);
 514     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; constructInternal(StringImpl&amp;, unsigned);
 515     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createUninitializedInternal(unsigned, CharacterType*&amp;);
 516     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createUninitializedInternalNonEmpty(unsigned, CharacterType*&amp;);
 517     template&lt;typename CharacterType&gt; static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; reallocateInternal(Ref&lt;StringImpl&gt;&amp;&amp;, unsigned, CharacterType*&amp;);
 518     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createInternal(const CharacterType*, unsigned);
 519     WTF_EXPORT_PRIVATE NEVER_INLINE unsigned hashSlowCase() const;
 520 
 521     // The bottom bit in the ref count indicates a static (immortal) string.
<span class="line-modified"> 522     static const unsigned s_refCountFlagIsStaticString = 0x1;</span>
<span class="line-modified"> 523     static const unsigned s_refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static string flag.</span>
 524 
 525 #if STRING_STATS
 526     WTF_EXPORT_PRIVATE static StringStats m_stringStats;
 527 #endif
 528 
 529 public:
 530     void assertHashIsCorrect() const;
 531 };
 532 
 533 using StaticStringImpl = StringImpl::StaticStringImpl;
 534 
 535 static_assert(sizeof(StringImpl) == sizeof(StaticStringImpl), &quot;&quot;);
 536 
<span class="line-modified"> 537 #if !ASSERT_DISABLED</span>
 538 
 539 // StringImpls created from StaticStringImpl will ASSERT in the generic ValueCheck&lt;T&gt;::checkConsistency
 540 // as they are not allocated by fastMalloc. We don&#39;t currently have any way to detect that case
 541 // so we ignore the consistency check for all StringImpl*.
 542 template&lt;&gt; struct ValueCheck&lt;StringImpl*&gt; {
 543     static void checkConsistency(const StringImpl*) { }
 544 };
 545 
<span class="line-modified"> 546 #endif</span>
 547 
 548 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const StringImpl*);
 549 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*);
 550 inline bool equal(const StringImpl* a, const char* b) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b)); }
 551 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*, unsigned);
 552 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const UChar*, unsigned);
 553 inline bool equal(const StringImpl* a, const char* b, unsigned length) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b), length); }
 554 inline bool equal(const LChar* a, StringImpl* b) { return equal(b, a); }
 555 inline bool equal(const char* a, StringImpl* b) { return equal(b, reinterpret_cast&lt;const LChar*&gt;(a)); }
 556 WTF_EXPORT_PRIVATE bool equal(const StringImpl&amp; a, const StringImpl&amp; b);
 557 
 558 WTF_EXPORT_PRIVATE bool equalIgnoringNullity(StringImpl*, StringImpl*);
 559 WTF_EXPORT_PRIVATE bool equalIgnoringNullity(const UChar*, size_t length, StringImpl*);
 560 
 561 bool equalIgnoringASCIICase(const StringImpl&amp;, const StringImpl&amp;);
 562 WTF_EXPORT_PRIVATE bool equalIgnoringASCIICase(const StringImpl*, const StringImpl*);
 563 bool equalIgnoringASCIICase(const StringImpl&amp;, const char*);
 564 bool equalIgnoringASCIICase(const StringImpl*, const char*);
 565 
 566 WTF_EXPORT_PRIVATE bool equalIgnoringASCIICaseNonNull(const StringImpl*, const StringImpl*);
</pre>
<hr />
<pre>
 578 
 579 template&lt;size_t inlineCapacity&gt; bool equalIgnoringNullity(const Vector&lt;UChar, inlineCapacity&gt;&amp;, StringImpl*);
 580 
 581 template&lt;typename CharacterType1, typename CharacterType2&gt; int codePointCompare(const CharacterType1*, unsigned length1, const CharacterType2*, unsigned length2);
 582 int codePointCompare(const StringImpl*, const StringImpl*);
 583 
 584 // FIXME: Should rename this to make clear it uses the Unicode definition of whitespace.
 585 // Most WebKit callers don&#39;t want that would use isASCIISpace or isHTMLSpace instead.
 586 bool isSpaceOrNewline(UChar32);
 587 
 588 template&lt;typename CharacterType&gt; unsigned lengthOfNullTerminatedString(const CharacterType*);
 589 
 590 // StringHash is the default hash for StringImpl* and RefPtr&lt;StringImpl&gt;
 591 template&lt;typename T&gt; struct DefaultHash;
 592 template&lt;&gt; struct DefaultHash&lt;StringImpl*&gt; {
 593     typedef StringHash Hash;
 594 };
 595 template&lt;&gt; struct DefaultHash&lt;RefPtr&lt;StringImpl&gt;&gt; {
 596     typedef StringHash Hash;
 597 };



 598 
 599 #define MAKE_STATIC_STRING_IMPL(characters) ([] { \
 600         static StaticStringImpl impl(characters); \
 601         return &amp;impl; \
 602     }())
 603 
 604 template&lt;&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::constructInternal&lt;LChar&gt;(StringImpl&amp; string, unsigned length)
 605 {
 606     return adoptRef(*new (NotNull, &amp;string) StringImpl { length, Force8BitConstructor });
 607 }
 608 
 609 template&lt;&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::constructInternal&lt;UChar&gt;(StringImpl&amp; string, unsigned length)
 610 {
 611     return adoptRef(*new (NotNull, &amp;string) StringImpl { length });
 612 }
 613 
 614 template&lt;&gt; ALWAYS_INLINE const LChar* StringImpl::characters&lt;LChar&gt;() const
 615 {
 616     return characters8();
 617 }
</pre>
<hr />
<pre>
 841 }
 842 
 843 inline StringImpl::StringImpl(unsigned length, Force8Bit)
 844     : StringImplShape(s_refCountIncrement, length, tailPointer&lt;LChar&gt;(), s_hashFlag8BitBuffer | StringNormal | BufferInternal)
 845 {
 846     ASSERT(m_data8);
 847     ASSERT(m_length);
 848 
 849     STRING_STATS_ADD_8BIT_STRING(m_length);
 850 }
 851 
 852 inline StringImpl::StringImpl(unsigned length)
 853     : StringImplShape(s_refCountIncrement, length, tailPointer&lt;UChar&gt;(), StringNormal | BufferInternal)
 854 {
 855     ASSERT(m_data16);
 856     ASSERT(m_length);
 857 
 858     STRING_STATS_ADD_16BIT_STRING(m_length);
 859 }
 860 
<span class="line-modified"> 861 inline StringImpl::StringImpl(MallocPtr&lt;LChar&gt; characters, unsigned length)</span>
<span class="line-modified"> 862     : StringImplShape(s_refCountIncrement, length, characters.leakPtr(), s_hashFlag8BitBuffer | StringNormal | BufferOwned)</span>

 863 {







 864     ASSERT(m_data8);
 865     ASSERT(m_length);
 866 
 867     STRING_STATS_ADD_8BIT_STRING(m_length);
 868 }
 869 
 870 inline StringImpl::StringImpl(const UChar* characters, unsigned length, ConstructWithoutCopyingTag)
 871     : StringImplShape(s_refCountIncrement, length, characters, StringNormal | BufferInternal)
 872 {
 873     ASSERT(m_data16);
 874     ASSERT(m_length);
 875 
 876     STRING_STATS_ADD_16BIT_STRING(m_length);
 877 }
 878 
 879 inline StringImpl::StringImpl(const LChar* characters, unsigned length, ConstructWithoutCopyingTag)
 880     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringNormal | BufferInternal)
 881 {
 882     ASSERT(m_data8);
 883     ASSERT(m_length);
 884 
 885     STRING_STATS_ADD_8BIT_STRING(m_length);
 886 }
 887 
<span class="line-modified"> 888 inline StringImpl::StringImpl(MallocPtr&lt;UChar&gt; characters, unsigned length)</span>
<span class="line-modified"> 889     : StringImplShape(s_refCountIncrement, length, characters.leakPtr(), StringNormal | BufferOwned)</span>

 890 {







 891     ASSERT(m_data16);
 892     ASSERT(m_length);
 893 
 894     STRING_STATS_ADD_16BIT_STRING(m_length);
 895 }
 896 
 897 inline StringImpl::StringImpl(const LChar* characters, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp; base)
 898     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringNormal | BufferSubstring)
 899 {
 900     ASSERT(is8Bit());
 901     ASSERT(m_data8);
 902     ASSERT(m_length);
 903     ASSERT(base-&gt;bufferOwnership() != BufferSubstring);
 904 
 905     substringBuffer() = &amp;base.leakRef();
 906 
 907     STRING_STATS_ADD_8BIT_STRING2(m_length, true);
 908 }
 909 
 910 inline StringImpl::StringImpl(const UChar* characters, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp; base)
</pre>
<hr />
<pre>
 928 ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::createSubstringSharingImpl(StringImpl&amp; rep, unsigned offset, unsigned length)
 929 {
 930     ASSERT(length &lt;= rep.length());
 931 
 932     if (!length)
 933         return *empty();
 934 
 935     // Coyping the thing would save more memory sometimes, largely due to the size of pointer.
 936     size_t substringSize = allocationSize&lt;StringImpl*&gt;(1);
 937     if (rep.is8Bit()) {
 938         if (substringSize &gt;= allocationSize&lt;LChar&gt;(length))
 939             return create(rep.m_data8 + offset, length);
 940     } else {
 941         if (substringSize &gt;= allocationSize&lt;UChar&gt;(length))
 942             return create(rep.m_data16 + offset, length);
 943     }
 944 
 945     auto* ownerRep = ((rep.bufferOwnership() == BufferSubstring) ? rep.substringBuffer() : &amp;rep);
 946 
 947     // We allocate a buffer that contains both the StringImpl struct as well as the pointer to the owner string.
<span class="line-modified"> 948     auto* stringImpl = static_cast&lt;StringImpl*&gt;(fastMalloc(substringSize));</span>
 949     if (rep.is8Bit())
 950         return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data8 + offset, length, *ownerRep));
 951     return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data16 + offset, length, *ownerRep));
 952 }
 953 
 954 template&lt;unsigned characterCount&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char (&amp;characters)[characterCount])
 955 {
 956     COMPILE_ASSERT(characterCount &gt; 1, StringImplFromLiteralNotEmpty);
 957     COMPILE_ASSERT((characterCount - 1 &lt;= ((unsigned(~0) - sizeof(StringImpl)) / sizeof(LChar))), StringImplFromLiteralCannotOverflow);
 958 
 959     return createWithoutCopying(reinterpret_cast&lt;const LChar*&gt;(characters), characterCount - 1);
 960 }
 961 
 962 template&lt;typename CharacterType&gt; ALWAYS_INLINE RefPtr&lt;StringImpl&gt; StringImpl::tryCreateUninitialized(unsigned length, CharacterType*&amp; output)
 963 {
 964     if (!length) {
 965         output = nullptr;
 966         return empty();
 967     }
 968 
 969     if (length &gt; maxInternalLength&lt;CharacterType&gt;()) {
 970         output = nullptr;
 971         return nullptr;
 972     }
 973     StringImpl* result;
<span class="line-modified"> 974     if (!tryFastMalloc(allocationSize&lt;CharacterType&gt;(length)).getValue(result)) {</span>


 975         output = nullptr;
 976         return nullptr;
 977     }
 978     output = result-&gt;tailPointer&lt;CharacterType&gt;();
 979 
 980     return constructInternal&lt;CharacterType&gt;(*result, length);
 981 }
 982 
<span class="line-modified"> 983 template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 984 inline Ref&lt;StringImpl&gt; StringImpl::adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; vector)</span>
 985 {
 986     if (size_t size = vector.size()) {
 987         ASSERT(vector.data());
 988         if (size &gt; MaxLength)
 989             CRASH();
<span class="line-modified"> 990         return adoptRef(*new StringImpl(vector.releaseBuffer(), size));</span>









 991     }
 992     return *empty();
 993 }
 994 
 995 inline size_t StringImpl::cost() const
 996 {
 997     // For substrings, return the cost of the base string.
 998     if (bufferOwnership() == BufferSubstring)
 999         return substringBuffer()-&gt;cost();
1000 
1001     // Note: we must not alter the m_hashAndFlags field in instances of StaticStringImpl.
1002     // We ensure this by pre-setting the s_hashFlagDidReportCost bit in all instances of
1003     // StaticStringImpl. As a result, StaticStringImpl instances will always return a cost of
1004     // 0 here and avoid modifying m_hashAndFlags.
1005     if (m_hashAndFlags &amp; s_hashFlagDidReportCost)
1006         return 0;
1007 
1008     m_hashAndFlags |= s_hashFlagDidReportCost;
1009     size_t result = m_length;
1010     if (!is8Bit())
</pre>
<hr />
<pre>
1057 
1058 inline void StringImpl::ref()
1059 {
1060     STRING_STATS_REF_STRING(*this);
1061 
1062     m_refCount += s_refCountIncrement;
1063 }
1064 
1065 inline void StringImpl::deref()
1066 {
1067     STRING_STATS_DEREF_STRING(*this);
1068 
1069     unsigned tempRefCount = m_refCount - s_refCountIncrement;
1070     if (!tempRefCount) {
1071         StringImpl::destroy(this);
1072         return;
1073     }
1074     m_refCount = tempRefCount;
1075 }
1076 
<span class="line-modified">1077 template&lt;typename CharacterType&gt; inline void StringImpl::copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters)</span>

1078 {
<span class="line-modified">1079     if (numCharacters == 1) {</span>
<span class="line-modified">1080         *destination = *source;</span>
<span class="line-modified">1081         return;</span>










1082     }
<span class="line-removed">1083     memcpy(destination, source, numCharacters * sizeof(CharacterType));</span>
<span class="line-removed">1084 }</span>
<span class="line-removed">1085 </span>
<span class="line-removed">1086 ALWAYS_INLINE void StringImpl::copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters)</span>
<span class="line-removed">1087 {</span>
<span class="line-removed">1088     for (unsigned i = 0; i &lt; numCharacters; ++i)</span>
<span class="line-removed">1089         destination[i] = source[i];</span>
1090 }
1091 
1092 inline UChar StringImpl::at(unsigned i) const
1093 {
1094     ASSERT_WITH_SECURITY_IMPLICATION(i &lt; m_length);
1095     return is8Bit() ? m_data8[i] : m_data16[i];
1096 }
1097 
1098 inline StringImpl::StringImpl(CreateSymbolTag, const LChar* characters, unsigned length)
1099     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringSymbol | BufferSubstring)
1100 {
1101     ASSERT(is8Bit());
1102     ASSERT(m_data8);
1103     STRING_STATS_ADD_8BIT_STRING2(m_length, true);
1104 }
1105 
1106 inline StringImpl::StringImpl(CreateSymbolTag, const UChar* characters, unsigned length)
1107     : StringImplShape(s_refCountIncrement, length, characters, StringSymbol | BufferSubstring)
1108 {
1109     ASSERT(!is8Bit());
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
<span class="line-modified">   3  * Copyright (C) 2005-2020 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2009 Google Inc. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &lt;limits.h&gt;
  26 #include &lt;unicode/ustring.h&gt;
  27 #include &lt;wtf/ASCIICType.h&gt;
  28 #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-added">  29 #include &lt;wtf/DebugHeap.h&gt;</span>
  30 #include &lt;wtf/Expected.h&gt;
  31 #include &lt;wtf/MathExtras.h&gt;
<span class="line-added">  32 #include &lt;wtf/Packed.h&gt;</span>
  33 #include &lt;wtf/StdLibExtras.h&gt;
  34 #include &lt;wtf/Vector.h&gt;
  35 #include &lt;wtf/text/ASCIIFastPath.h&gt;
  36 #include &lt;wtf/text/ConversionMode.h&gt;
  37 #include &lt;wtf/text/StringCommon.h&gt;
  38 #include &lt;wtf/text/StringHasher.h&gt;
  39 #include &lt;wtf/text/UTF8ConversionError.h&gt;
  40 
  41 #if USE(CF)
  42 typedef const struct __CFString * CFStringRef;
  43 #endif
  44 
  45 #ifdef __OBJC__
  46 @class NSString;
  47 #endif
  48 
  49 namespace JSC {
  50 namespace LLInt { class Data; }
  51 class LLIntOffsetsExtractor;
  52 }
</pre>
<hr />
<pre>
  79     WTF_MAKE_STRUCT_FAST_ALLOCATED;
  80     void add8BitString(unsigned length, bool isSubString = false)
  81     {
  82         ++m_totalNumberStrings;
  83         ++m_number8BitStrings;
  84         if (!isSubString)
  85             m_total8BitData += length;
  86     }
  87 
  88     void add16BitString(unsigned length, bool isSubString = false)
  89     {
  90         ++m_totalNumberStrings;
  91         ++m_number16BitStrings;
  92         if (!isSubString)
  93             m_total16BitData += length;
  94     }
  95 
  96     void removeString(StringImpl&amp;);
  97     void printStats();
  98 
<span class="line-modified">  99     static constexpr unsigned s_printStringStatsFrequency = 5000;</span>
 100     static std::atomic&lt;unsigned&gt; s_stringRemovesTillPrintStats;
 101 
 102     std::atomic&lt;unsigned&gt; m_refCalls;
 103     std::atomic&lt;unsigned&gt; m_derefCalls;
 104 
 105     std::atomic&lt;unsigned&gt; m_totalNumberStrings;
 106     std::atomic&lt;unsigned&gt; m_number8BitStrings;
 107     std::atomic&lt;unsigned&gt; m_number16BitStrings;
 108     std::atomic&lt;unsigned long long&gt; m_total8BitData;
 109     std::atomic&lt;unsigned long long&gt; m_total16BitData;
 110 };
 111 
 112 #define STRING_STATS_ADD_8BIT_STRING(length) StringImpl::stringStats().add8BitString(length)
 113 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) StringImpl::stringStats().add8BitString(length, isSubString)
 114 #define STRING_STATS_ADD_16BIT_STRING(length) StringImpl::stringStats().add16BitString(length)
 115 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) StringImpl::stringStats().add16BitString(length, isSubString)
 116 #define STRING_STATS_REMOVE_STRING(string) StringImpl::stringStats().removeString(string)
 117 #define STRING_STATS_REF_STRING(string) ++StringImpl::stringStats().m_refCalls;
 118 #define STRING_STATS_DEREF_STRING(string) ++StringImpl::stringStats().m_derefCalls;
 119 
</pre>
<hr />
<pre>
 145 
 146     unsigned m_refCount;
 147     unsigned m_length;
 148     union {
 149         const LChar* m_data8;
 150         const UChar* m_data16;
 151         // It seems that reinterpret_cast prevents constexpr&#39;s compile time initialization in VC++.
 152         // These are needed to avoid reinterpret_cast.
 153         const char* m_data8Char;
 154         const char16_t* m_data16Char;
 155     };
 156     mutable unsigned m_hashAndFlags;
 157 };
 158 
 159 // FIXME: Use of StringImpl and const is rather confused.
 160 // The actual string inside a StringImpl is immutable, so you can&#39;t modify a string using a StringImpl&amp;.
 161 // We could mark every member function const and always use &quot;const StringImpl&amp;&quot; and &quot;const StringImpl*&quot;.
 162 // Or we could say that &quot;const&quot; doesn&#39;t make sense at all and use &quot;StringImpl&amp;&quot; and &quot;StringImpl*&quot; everywhere.
 163 // Right now we use a mix of both, which makes code more confusing and has no benefit.
 164 
<span class="line-added"> 165 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringImpl);</span>
 166 class StringImpl : private StringImplShape {
<span class="line-modified"> 167     WTF_MAKE_NONCOPYABLE(StringImpl);</span>
<span class="line-added"> 168     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StringImpl);</span>
 169 
 170     friend class AtomStringImpl;
 171     friend class JSC::LLInt::Data;
 172     friend class JSC::LLIntOffsetsExtractor;
 173     friend class PrivateSymbolImpl;
 174     friend class RegisteredSymbolImpl;
 175     friend class SymbolImpl;
 176     friend class ExternalStringImpl;
 177 
 178     friend struct WTF::CStringTranslator;
 179     friend struct WTF::HashAndUTF8CharactersTranslator;
 180     friend struct WTF::LCharBufferTranslator;
 181     friend struct WTF::SubstringTranslator;
 182     friend struct WTF::UCharBufferTranslator;
 183 
 184     template&lt;typename&gt; friend struct WTF::BufferFromStaticDataTranslator;
 185     template&lt;typename&gt; friend struct WTF::HashAndCharactersTranslator;
 186 
 187 public:
 188     enum BufferOwnership { BufferInternal, BufferOwned, BufferSubstring, BufferExternal };
 189 
 190     static constexpr unsigned MaxLength = StringImplShape::MaxLength;
 191 
 192     // The bottom 6 bits in the hash are flags.
 193     static constexpr const unsigned s_flagCount = 6;
<span class="line-added"> 194 </span>
 195 private:
 196     static constexpr const unsigned s_flagMask = (1u &lt;&lt; s_flagCount) - 1;
 197     static_assert(s_flagCount &lt;= StringHasher::flagCount, &quot;StringHasher reserves enough bits for StringImpl flags&quot;);
 198     static constexpr const unsigned s_flagStringKindCount = 4;
 199 
 200     static constexpr const unsigned s_hashFlagStringKindIsAtom = 1u &lt;&lt; (s_flagStringKindCount);
 201     static constexpr const unsigned s_hashFlagStringKindIsSymbol = 1u &lt;&lt; (s_flagStringKindCount + 1);
 202     static constexpr const unsigned s_hashMaskStringKind = s_hashFlagStringKindIsAtom | s_hashFlagStringKindIsSymbol;
 203     static constexpr const unsigned s_hashFlagDidReportCost = 1u &lt;&lt; 3;
 204     static constexpr const unsigned s_hashFlag8BitBuffer = 1u &lt;&lt; 2;
 205     static constexpr const unsigned s_hashMaskBufferOwnership = (1u &lt;&lt; 0) | (1u &lt;&lt; 1);
 206 
 207     enum StringKind {
 208         StringNormal = 0u, // non-symbol, non-atomic
 209         StringAtom = s_hashFlagStringKindIsAtom, // non-symbol, atomic
 210         StringSymbol = s_hashFlagStringKindIsSymbol, // symbol, non-atomic
 211     };
 212 
 213     // Create a normal 8-bit string with internal storage (BufferInternal).
 214     enum Force8Bit { Force8BitConstructor };
 215     StringImpl(unsigned length, Force8Bit);
 216 
 217     // Create a normal 16-bit string with internal storage (BufferInternal).
 218     explicit StringImpl(unsigned length);
 219 
 220     // Create a StringImpl adopting ownership of the provided buffer (BufferOwned).
<span class="line-modified"> 221     template&lt;typename Malloc&gt; StringImpl(MallocPtr&lt;LChar, Malloc&gt;, unsigned length);</span>
<span class="line-modified"> 222     template&lt;typename Malloc&gt; StringImpl(MallocPtr&lt;UChar, Malloc&gt;, unsigned length);</span>
 223     enum ConstructWithoutCopyingTag { ConstructWithoutCopying };
 224     StringImpl(const UChar*, unsigned length, ConstructWithoutCopyingTag);
 225     StringImpl(const LChar*, unsigned length, ConstructWithoutCopyingTag);
 226 
 227     // Used to create new strings that are a substring of an existing StringImpl (BufferSubstring).
 228     StringImpl(const LChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 229     StringImpl(const UChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 230 
 231 public:
 232     WTF_EXPORT_PRIVATE static void destroy(StringImpl*);
 233 
 234     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const UChar*, unsigned length);
 235     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const LChar*, unsigned length);
 236     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create8BitIfPossible(const UChar*, unsigned length);
 237     template&lt;size_t inlineCapacity&gt; static Ref&lt;StringImpl&gt; create8BitIfPossible(const Vector&lt;UChar, inlineCapacity&gt;&amp;);
 238     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create8BitIfPossible(const UChar*);
 239 
 240     ALWAYS_INLINE static Ref&lt;StringImpl&gt; create(const char* characters, unsigned length) { return create(reinterpret_cast&lt;const LChar*&gt;(characters), length); }
 241     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const LChar*);
 242     ALWAYS_INLINE static Ref&lt;StringImpl&gt; create(const char* string) { return create(reinterpret_cast&lt;const LChar*&gt;(string)); }
 243 
 244     static Ref&lt;StringImpl&gt; createSubstringSharingImpl(StringImpl&amp;, unsigned offset, unsigned length);
 245 
 246     template&lt;unsigned characterCount&gt; static Ref&lt;StringImpl&gt; createFromLiteral(const char (&amp;)[characterCount]);
 247 
 248     // FIXME: Replace calls to these overloads of createFromLiteral to createWithoutCopying instead.
 249     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*, unsigned length);
 250     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*);
 251 
 252     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const UChar*, unsigned length);
 253     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const LChar*, unsigned length);
 254     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, LChar*&amp;);
 255     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, UChar*&amp;);
 256     template&lt;typename CharacterType&gt; static RefPtr&lt;StringImpl&gt; tryCreateUninitialized(unsigned length, CharacterType*&amp;);
 257 
<span class="line-added"> 258     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createStaticStringImpl(const char*, unsigned length);</span>
<span class="line-added"> 259 </span>
 260     // Reallocate the StringImpl. The originalString must be only owned by the Ref,
 261     // and the buffer ownership must be BufferInternal. Just like the input pointer of realloc(),
 262     // the originalString can&#39;t be used after this function.
 263     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 264     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 265     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 266     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 267 
 268     static unsigned flagsOffset() { return OBJECT_OFFSETOF(StringImpl, m_hashAndFlags); }
 269     static constexpr unsigned flagIs8Bit() { return s_hashFlag8BitBuffer; }
 270     static constexpr unsigned flagIsAtom() { return s_hashFlagStringKindIsAtom; }
 271     static constexpr unsigned flagIsSymbol() { return s_hashFlagStringKindIsSymbol; }
 272     static constexpr unsigned maskStringKind() { return s_hashMaskStringKind; }
 273     static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }
 274 
<span class="line-modified"> 275     template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 276     static Ref&lt;StringImpl&gt; adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp;);</span>
 277 
 278     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;UChar&gt;&amp;&amp;);
 279     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;LChar&gt;&amp;&amp;);
 280 
 281     unsigned length() const { return m_length; }
 282     static ptrdiff_t lengthMemoryOffset() { return OBJECT_OFFSETOF(StringImpl, m_length); }
 283     bool isEmpty() const { return !m_length; }
 284 
 285     bool is8Bit() const { return m_hashAndFlags &amp; s_hashFlag8BitBuffer; }
 286     ALWAYS_INLINE const LChar* characters8() const { ASSERT(is8Bit()); return m_data8; }
 287     ALWAYS_INLINE const UChar* characters16() const { ASSERT(!is8Bit()); return m_data16; }
 288 
 289     template&lt;typename CharacterType&gt; const CharacterType* characters() const;
 290 
 291     size_t cost() const;
 292     size_t costDuringGC();
 293 
 294     WTF_EXPORT_PRIVATE size_t sizeInBytes() const;
 295 
 296     bool isSymbol() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsSymbol; }
</pre>
<hr />
<pre>
 360         //       that StringImpl::cost() returns early.
 361         //       This means StaticStringImpl costs are not counted. But since there should only
 362         //       be a finite set of StaticStringImpls, their cost can be aggregated into a single
 363         //       system cost if needed.
 364         //    b. setIsAtom() is never called on a StaticStringImpl.
 365         //       setIsAtom() asserts !isStatic().
 366         //    c. setHash() is never called on a StaticStringImpl.
 367         //       StaticStringImpl&#39;s constructor sets the hash on construction.
 368         //       StringImpl::hash() only sets a new hash iff !hasHash().
 369         //       Additionally, StringImpl::setHash() asserts hasHash() and !isStatic().
 370 
 371         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char (&amp;characters)[characterCount], StringKind = StringNormal);
 372         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char16_t (&amp;characters)[characterCount], StringKind = StringNormal);
 373         operator StringImpl&amp;();
 374     };
 375 
 376     WTF_EXPORT_PRIVATE static StaticStringImpl s_emptyAtomString;
 377     ALWAYS_INLINE static StringImpl* empty() { return reinterpret_cast&lt;StringImpl*&gt;(&amp;s_emptyAtomString); }
 378 
 379     // FIXME: Does this really belong in StringImpl?
<span class="line-modified"> 380     template&lt;typename SourceCharacterType, typename DestinationCharacterType&gt; static void copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters);</span>

 381 
 382     // Some string features, like reference counting and the atomicity flag, are not
 383     // thread-safe. We achieve thread safety by isolation, giving each thread
 384     // its own copy of the string.
 385     Ref&lt;StringImpl&gt; isolatedCopy() const;
 386 
 387     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; substring(unsigned position, unsigned length = MaxLength);
 388 
 389     UChar at(unsigned) const;
 390     UChar operator[](unsigned i) const { return at(i); }
 391     WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned);
 392 
 393     int toIntStrict(bool* ok = 0, int base = 10);
 394     unsigned toUIntStrict(bool* ok = 0, int base = 10);
 395     int64_t toInt64Strict(bool* ok = 0, int base = 10);
 396     uint64_t toUInt64Strict(bool* ok = 0, int base = 10);
 397     intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);
 398 
 399     WTF_EXPORT_PRIVATE int toInt(bool* ok = 0); // ignores trailing garbage
 400     unsigned toUInt(bool* ok = 0); // ignores trailing garbage
</pre>
<hr />
<pre>
 508     bool requiresCopy() const;
 509     template&lt;typename T&gt; const T* tailPointer() const;
 510     template&lt;typename T&gt; T* tailPointer();
 511     StringImpl* const&amp; substringBuffer() const;
 512     StringImpl*&amp; substringBuffer();
 513 
 514     enum class CaseConvertType { Upper, Lower };
 515     template&lt;CaseConvertType, typename CharacterType&gt; static Ref&lt;StringImpl&gt; convertASCIICase(StringImpl&amp;, const CharacterType*, unsigned);
 516 
 517     template&lt;class CodeUnitPredicate&gt; Ref&lt;StringImpl&gt; stripMatchedCharacters(CodeUnitPredicate);
 518     template&lt;typename CharacterType&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; removeCharacters(const CharacterType* characters, CodeUnitMatchFunction);
 519     template&lt;typename CharacterType, class CodeUnitPredicate&gt; Ref&lt;StringImpl&gt; simplifyMatchedCharactersToSpace(CodeUnitPredicate);
 520     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; constructInternal(StringImpl&amp;, unsigned);
 521     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createUninitializedInternal(unsigned, CharacterType*&amp;);
 522     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createUninitializedInternalNonEmpty(unsigned, CharacterType*&amp;);
 523     template&lt;typename CharacterType&gt; static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; reallocateInternal(Ref&lt;StringImpl&gt;&amp;&amp;, unsigned, CharacterType*&amp;);
 524     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createInternal(const CharacterType*, unsigned);
 525     WTF_EXPORT_PRIVATE NEVER_INLINE unsigned hashSlowCase() const;
 526 
 527     // The bottom bit in the ref count indicates a static (immortal) string.
<span class="line-modified"> 528     static constexpr unsigned s_refCountFlagIsStaticString = 0x1;</span>
<span class="line-modified"> 529     static constexpr unsigned s_refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static string flag.</span>
 530 
 531 #if STRING_STATS
 532     WTF_EXPORT_PRIVATE static StringStats m_stringStats;
 533 #endif
 534 
 535 public:
 536     void assertHashIsCorrect() const;
 537 };
 538 
 539 using StaticStringImpl = StringImpl::StaticStringImpl;
 540 
 541 static_assert(sizeof(StringImpl) == sizeof(StaticStringImpl), &quot;&quot;);
 542 
<span class="line-modified"> 543 #if ASSERT_ENABLED</span>
 544 
 545 // StringImpls created from StaticStringImpl will ASSERT in the generic ValueCheck&lt;T&gt;::checkConsistency
 546 // as they are not allocated by fastMalloc. We don&#39;t currently have any way to detect that case
 547 // so we ignore the consistency check for all StringImpl*.
 548 template&lt;&gt; struct ValueCheck&lt;StringImpl*&gt; {
 549     static void checkConsistency(const StringImpl*) { }
 550 };
 551 
<span class="line-modified"> 552 #endif // ASSERT_ENABLED</span>
 553 
 554 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const StringImpl*);
 555 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*);
 556 inline bool equal(const StringImpl* a, const char* b) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b)); }
 557 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*, unsigned);
 558 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const UChar*, unsigned);
 559 inline bool equal(const StringImpl* a, const char* b, unsigned length) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b), length); }
 560 inline bool equal(const LChar* a, StringImpl* b) { return equal(b, a); }
 561 inline bool equal(const char* a, StringImpl* b) { return equal(b, reinterpret_cast&lt;const LChar*&gt;(a)); }
 562 WTF_EXPORT_PRIVATE bool equal(const StringImpl&amp; a, const StringImpl&amp; b);
 563 
 564 WTF_EXPORT_PRIVATE bool equalIgnoringNullity(StringImpl*, StringImpl*);
 565 WTF_EXPORT_PRIVATE bool equalIgnoringNullity(const UChar*, size_t length, StringImpl*);
 566 
 567 bool equalIgnoringASCIICase(const StringImpl&amp;, const StringImpl&amp;);
 568 WTF_EXPORT_PRIVATE bool equalIgnoringASCIICase(const StringImpl*, const StringImpl*);
 569 bool equalIgnoringASCIICase(const StringImpl&amp;, const char*);
 570 bool equalIgnoringASCIICase(const StringImpl*, const char*);
 571 
 572 WTF_EXPORT_PRIVATE bool equalIgnoringASCIICaseNonNull(const StringImpl*, const StringImpl*);
</pre>
<hr />
<pre>
 584 
 585 template&lt;size_t inlineCapacity&gt; bool equalIgnoringNullity(const Vector&lt;UChar, inlineCapacity&gt;&amp;, StringImpl*);
 586 
 587 template&lt;typename CharacterType1, typename CharacterType2&gt; int codePointCompare(const CharacterType1*, unsigned length1, const CharacterType2*, unsigned length2);
 588 int codePointCompare(const StringImpl*, const StringImpl*);
 589 
 590 // FIXME: Should rename this to make clear it uses the Unicode definition of whitespace.
 591 // Most WebKit callers don&#39;t want that would use isASCIISpace or isHTMLSpace instead.
 592 bool isSpaceOrNewline(UChar32);
 593 
 594 template&lt;typename CharacterType&gt; unsigned lengthOfNullTerminatedString(const CharacterType*);
 595 
 596 // StringHash is the default hash for StringImpl* and RefPtr&lt;StringImpl&gt;
 597 template&lt;typename T&gt; struct DefaultHash;
 598 template&lt;&gt; struct DefaultHash&lt;StringImpl*&gt; {
 599     typedef StringHash Hash;
 600 };
 601 template&lt;&gt; struct DefaultHash&lt;RefPtr&lt;StringImpl&gt;&gt; {
 602     typedef StringHash Hash;
 603 };
<span class="line-added"> 604 template&lt;&gt; struct DefaultHash&lt;PackedPtr&lt;StringImpl&gt;&gt; {</span>
<span class="line-added"> 605     using Hash = StringHash;</span>
<span class="line-added"> 606 };</span>
 607 
 608 #define MAKE_STATIC_STRING_IMPL(characters) ([] { \
 609         static StaticStringImpl impl(characters); \
 610         return &amp;impl; \
 611     }())
 612 
 613 template&lt;&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::constructInternal&lt;LChar&gt;(StringImpl&amp; string, unsigned length)
 614 {
 615     return adoptRef(*new (NotNull, &amp;string) StringImpl { length, Force8BitConstructor });
 616 }
 617 
 618 template&lt;&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::constructInternal&lt;UChar&gt;(StringImpl&amp; string, unsigned length)
 619 {
 620     return adoptRef(*new (NotNull, &amp;string) StringImpl { length });
 621 }
 622 
 623 template&lt;&gt; ALWAYS_INLINE const LChar* StringImpl::characters&lt;LChar&gt;() const
 624 {
 625     return characters8();
 626 }
</pre>
<hr />
<pre>
 850 }
 851 
 852 inline StringImpl::StringImpl(unsigned length, Force8Bit)
 853     : StringImplShape(s_refCountIncrement, length, tailPointer&lt;LChar&gt;(), s_hashFlag8BitBuffer | StringNormal | BufferInternal)
 854 {
 855     ASSERT(m_data8);
 856     ASSERT(m_length);
 857 
 858     STRING_STATS_ADD_8BIT_STRING(m_length);
 859 }
 860 
 861 inline StringImpl::StringImpl(unsigned length)
 862     : StringImplShape(s_refCountIncrement, length, tailPointer&lt;UChar&gt;(), StringNormal | BufferInternal)
 863 {
 864     ASSERT(m_data16);
 865     ASSERT(m_length);
 866 
 867     STRING_STATS_ADD_16BIT_STRING(m_length);
 868 }
 869 
<span class="line-modified"> 870 template&lt;typename Malloc&gt;</span>
<span class="line-modified"> 871 inline StringImpl::StringImpl(MallocPtr&lt;LChar, Malloc&gt; characters, unsigned length)</span>
<span class="line-added"> 872     : StringImplShape(s_refCountIncrement, length, static_cast&lt;const LChar*&gt;(nullptr), s_hashFlag8BitBuffer | StringNormal | BufferOwned)</span>
 873 {
<span class="line-added"> 874     if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="line-added"> 875         m_data8 = characters.leakPtr();</span>
<span class="line-added"> 876     else {</span>
<span class="line-added"> 877         m_data8 = static_cast&lt;const LChar*&gt;(StringImplMalloc::malloc(length));</span>
<span class="line-added"> 878         memcpy((void*)m_data8, characters.get(), length);</span>
<span class="line-added"> 879     }</span>
<span class="line-added"> 880 </span>
 881     ASSERT(m_data8);
 882     ASSERT(m_length);
 883 
 884     STRING_STATS_ADD_8BIT_STRING(m_length);
 885 }
 886 
 887 inline StringImpl::StringImpl(const UChar* characters, unsigned length, ConstructWithoutCopyingTag)
 888     : StringImplShape(s_refCountIncrement, length, characters, StringNormal | BufferInternal)
 889 {
 890     ASSERT(m_data16);
 891     ASSERT(m_length);
 892 
 893     STRING_STATS_ADD_16BIT_STRING(m_length);
 894 }
 895 
 896 inline StringImpl::StringImpl(const LChar* characters, unsigned length, ConstructWithoutCopyingTag)
 897     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringNormal | BufferInternal)
 898 {
 899     ASSERT(m_data8);
 900     ASSERT(m_length);
 901 
 902     STRING_STATS_ADD_8BIT_STRING(m_length);
 903 }
 904 
<span class="line-modified"> 905 template&lt;typename Malloc&gt;</span>
<span class="line-modified"> 906 inline StringImpl::StringImpl(MallocPtr&lt;UChar, Malloc&gt; characters, unsigned length)</span>
<span class="line-added"> 907     : StringImplShape(s_refCountIncrement, length, static_cast&lt;const UChar*&gt;(nullptr), StringNormal | BufferOwned)</span>
 908 {
<span class="line-added"> 909     if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="line-added"> 910         m_data16 = characters.leakPtr();</span>
<span class="line-added"> 911     else {</span>
<span class="line-added"> 912         m_data16 = static_cast&lt;const UChar*&gt;(StringImplMalloc::malloc(length * sizeof(UChar)));</span>
<span class="line-added"> 913         memcpy((void*)m_data16, characters.get(), length * sizeof(UChar));</span>
<span class="line-added"> 914     }</span>
<span class="line-added"> 915 </span>
 916     ASSERT(m_data16);
 917     ASSERT(m_length);
 918 
 919     STRING_STATS_ADD_16BIT_STRING(m_length);
 920 }
 921 
 922 inline StringImpl::StringImpl(const LChar* characters, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp; base)
 923     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringNormal | BufferSubstring)
 924 {
 925     ASSERT(is8Bit());
 926     ASSERT(m_data8);
 927     ASSERT(m_length);
 928     ASSERT(base-&gt;bufferOwnership() != BufferSubstring);
 929 
 930     substringBuffer() = &amp;base.leakRef();
 931 
 932     STRING_STATS_ADD_8BIT_STRING2(m_length, true);
 933 }
 934 
 935 inline StringImpl::StringImpl(const UChar* characters, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp; base)
</pre>
<hr />
<pre>
 953 ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::createSubstringSharingImpl(StringImpl&amp; rep, unsigned offset, unsigned length)
 954 {
 955     ASSERT(length &lt;= rep.length());
 956 
 957     if (!length)
 958         return *empty();
 959 
 960     // Coyping the thing would save more memory sometimes, largely due to the size of pointer.
 961     size_t substringSize = allocationSize&lt;StringImpl*&gt;(1);
 962     if (rep.is8Bit()) {
 963         if (substringSize &gt;= allocationSize&lt;LChar&gt;(length))
 964             return create(rep.m_data8 + offset, length);
 965     } else {
 966         if (substringSize &gt;= allocationSize&lt;UChar&gt;(length))
 967             return create(rep.m_data16 + offset, length);
 968     }
 969 
 970     auto* ownerRep = ((rep.bufferOwnership() == BufferSubstring) ? rep.substringBuffer() : &amp;rep);
 971 
 972     // We allocate a buffer that contains both the StringImpl struct as well as the pointer to the owner string.
<span class="line-modified"> 973     auto* stringImpl = static_cast&lt;StringImpl*&gt;(StringImplMalloc::malloc(substringSize));</span>
 974     if (rep.is8Bit())
 975         return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data8 + offset, length, *ownerRep));
 976     return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data16 + offset, length, *ownerRep));
 977 }
 978 
 979 template&lt;unsigned characterCount&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char (&amp;characters)[characterCount])
 980 {
 981     COMPILE_ASSERT(characterCount &gt; 1, StringImplFromLiteralNotEmpty);
 982     COMPILE_ASSERT((characterCount - 1 &lt;= ((unsigned(~0) - sizeof(StringImpl)) / sizeof(LChar))), StringImplFromLiteralCannotOverflow);
 983 
 984     return createWithoutCopying(reinterpret_cast&lt;const LChar*&gt;(characters), characterCount - 1);
 985 }
 986 
 987 template&lt;typename CharacterType&gt; ALWAYS_INLINE RefPtr&lt;StringImpl&gt; StringImpl::tryCreateUninitialized(unsigned length, CharacterType*&amp; output)
 988 {
 989     if (!length) {
 990         output = nullptr;
 991         return empty();
 992     }
 993 
 994     if (length &gt; maxInternalLength&lt;CharacterType&gt;()) {
 995         output = nullptr;
 996         return nullptr;
 997     }
 998     StringImpl* result;
<span class="line-modified"> 999 </span>
<span class="line-added">1000     result = (StringImpl*)StringImplMalloc::tryMalloc(allocationSize&lt;CharacterType&gt;(length));</span>
<span class="line-added">1001     if (!result) {</span>
1002         output = nullptr;
1003         return nullptr;
1004     }
1005     output = result-&gt;tailPointer&lt;CharacterType&gt;();
1006 
1007     return constructInternal&lt;CharacterType&gt;(*result, length);
1008 }
1009 
<span class="line-modified">1010 template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1011 inline Ref&lt;StringImpl&gt; StringImpl::adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; vector)</span>
1012 {
1013     if (size_t size = vector.size()) {
1014         ASSERT(vector.data());
1015         if (size &gt; MaxLength)
1016             CRASH();
<span class="line-modified">1017 </span>
<span class="line-added">1018         if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="line-added">1019             return adoptRef(*new StringImpl(vector.releaseBuffer(), size));</span>
<span class="line-added">1020         else {</span>
<span class="line-added">1021             // We have to copy between malloc zones.</span>
<span class="line-added">1022             auto vectorBuffer = vector.releaseBuffer();</span>
<span class="line-added">1023             auto stringImplBuffer = MallocPtr&lt;CharacterType, StringImplMalloc&gt;::malloc(size);</span>
<span class="line-added">1024             memcpy(stringImplBuffer.get(), vectorBuffer.get(), size);</span>
<span class="line-added">1025             return adoptRef(*new StringImpl(WTFMove(stringImplBuffer), size));</span>
<span class="line-added">1026         }</span>
1027     }
1028     return *empty();
1029 }
1030 
1031 inline size_t StringImpl::cost() const
1032 {
1033     // For substrings, return the cost of the base string.
1034     if (bufferOwnership() == BufferSubstring)
1035         return substringBuffer()-&gt;cost();
1036 
1037     // Note: we must not alter the m_hashAndFlags field in instances of StaticStringImpl.
1038     // We ensure this by pre-setting the s_hashFlagDidReportCost bit in all instances of
1039     // StaticStringImpl. As a result, StaticStringImpl instances will always return a cost of
1040     // 0 here and avoid modifying m_hashAndFlags.
1041     if (m_hashAndFlags &amp; s_hashFlagDidReportCost)
1042         return 0;
1043 
1044     m_hashAndFlags |= s_hashFlagDidReportCost;
1045     size_t result = m_length;
1046     if (!is8Bit())
</pre>
<hr />
<pre>
1093 
1094 inline void StringImpl::ref()
1095 {
1096     STRING_STATS_REF_STRING(*this);
1097 
1098     m_refCount += s_refCountIncrement;
1099 }
1100 
1101 inline void StringImpl::deref()
1102 {
1103     STRING_STATS_DEREF_STRING(*this);
1104 
1105     unsigned tempRefCount = m_refCount - s_refCountIncrement;
1106     if (!tempRefCount) {
1107         StringImpl::destroy(this);
1108         return;
1109     }
1110     m_refCount = tempRefCount;
1111 }
1112 
<span class="line-modified">1113 template&lt;typename SourceCharacterType, typename DestinationCharacterType&gt;</span>
<span class="line-added">1114 inline void StringImpl::copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters)</span>
1115 {
<span class="line-modified">1116     static_assert(std::is_same&lt;SourceCharacterType, LChar&gt;::value || std::is_same&lt;SourceCharacterType, UChar&gt;::value);</span>
<span class="line-modified">1117     static_assert(std::is_same&lt;DestinationCharacterType, LChar&gt;::value || std::is_same&lt;DestinationCharacterType, UChar&gt;::value);</span>
<span class="line-modified">1118     if constexpr (std::is_same&lt;SourceCharacterType, DestinationCharacterType&gt;::value) {</span>
<span class="line-added">1119         if (numCharacters == 1) {</span>
<span class="line-added">1120             *destination = *source;</span>
<span class="line-added">1121             return;</span>
<span class="line-added">1122         }</span>
<span class="line-added">1123         memcpy(destination, source, numCharacters * sizeof(DestinationCharacterType));</span>
<span class="line-added">1124     } else {</span>
<span class="line-added">1125         // FIXME: We should ensure that UChar -&gt; LChar copying happens when UChar only contains Latin-1.</span>
<span class="line-added">1126         // https://bugs.webkit.org/show_bug.cgi?id=205355</span>
<span class="line-added">1127         for (unsigned i = 0; i &lt; numCharacters; ++i)</span>
<span class="line-added">1128             destination[i] = source[i];</span>
1129     }







1130 }
1131 
1132 inline UChar StringImpl::at(unsigned i) const
1133 {
1134     ASSERT_WITH_SECURITY_IMPLICATION(i &lt; m_length);
1135     return is8Bit() ? m_data8[i] : m_data16[i];
1136 }
1137 
1138 inline StringImpl::StringImpl(CreateSymbolTag, const LChar* characters, unsigned length)
1139     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringSymbol | BufferSubstring)
1140 {
1141     ASSERT(is8Bit());
1142     ASSERT(m_data8);
1143     STRING_STATS_ADD_8BIT_STRING2(m_length, true);
1144 }
1145 
1146 inline StringImpl::StringImpl(CreateSymbolTag, const UChar* characters, unsigned length)
1147     : StringImplShape(s_refCountIncrement, length, characters, StringSymbol | BufferSubstring)
1148 {
1149     ASSERT(!is8Bit());
</pre>
</td>
</tr>
</table>
<center><a href="StringImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringToIntegerConversion.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
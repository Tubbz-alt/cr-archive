<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008, 2009, 2010, 2011 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2009 Torch Mobile, Inc.
  4  * Copyright 2010, The Android Open Source Project
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;Geolocation.h&quot;
 30 
 31 #if ENABLE(GEOLOCATION)
 32 
 33 #include &quot;Document.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;GeoNotifier.h&quot;
 36 #include &quot;GeolocationController.h&quot;
 37 #include &quot;GeolocationCoordinates.h&quot;
 38 #include &quot;GeolocationError.h&quot;
 39 #include &quot;GeolocationPosition.h&quot;
 40 #include &quot;GeolocationPositionData.h&quot;
 41 #include &quot;Navigator.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RuntimeApplicationChecks.h&quot;
 44 #include &quot;SecurityOrigin.h&quot;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/Ref.h&gt;
 47 #include &lt;wtf/text/StringBuilder.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 static const ASCIILiteral permissionDeniedErrorMessage { &quot;User denied Geolocation&quot;_s };
 52 static const ASCIILiteral failedToStartServiceErrorMessage { &quot;Failed to start Geolocation service&quot;_s };
 53 static const ASCIILiteral framelessDocumentErrorMessage { &quot;Geolocation cannot be used in frameless documents&quot;_s };
 54 static const ASCIILiteral originCannotRequestGeolocationErrorMessage { &quot;Origin does not have permission to use Geolocation service&quot;_s };
 55 
 56 WTF_MAKE_ISO_ALLOCATED_IMPL(Geolocation);
 57 
 58 static RefPtr&lt;GeolocationPosition&gt; createGeolocationPosition(Optional&lt;GeolocationPositionData&gt;&amp;&amp; position)
 59 {
 60     if (!position)
 61         return nullptr;
 62 
 63     DOMTimeStamp timestamp = convertSecondsToDOMTimeStamp(position-&gt;timestamp);
 64     return GeolocationPosition::create(GeolocationCoordinates::create(WTFMove(position.value())), timestamp);
 65 }
 66 
 67 static Ref&lt;GeolocationPositionError&gt; createGeolocationPositionError(GeolocationError&amp; error)
 68 {
 69     auto code = GeolocationPositionError::POSITION_UNAVAILABLE;
 70     switch (error.code()) {
 71     case GeolocationError::PermissionDenied:
 72         code = GeolocationPositionError::PERMISSION_DENIED;
 73         break;
 74     case GeolocationError::PositionUnavailable:
 75         code = GeolocationPositionError::POSITION_UNAVAILABLE;
 76         break;
 77     }
 78 
 79     return GeolocationPositionError::create(code, error.message());
 80 }
 81 
 82 bool Geolocation::Watchers::add(int id, RefPtr&lt;GeoNotifier&gt;&amp;&amp; notifier)
 83 {
 84     ASSERT(id &gt; 0);
 85 
 86     if (!m_idToNotifierMap.add(id, notifier.get()).isNewEntry)
 87         return false;
 88     m_notifierToIdMap.set(WTFMove(notifier), id);
 89     return true;
 90 }
 91 
 92 GeoNotifier* Geolocation::Watchers::find(int id)
 93 {
 94     ASSERT(id &gt; 0);
 95     return m_idToNotifierMap.get(id);
 96 }
 97 
 98 void Geolocation::Watchers::remove(int id)
 99 {
100     ASSERT(id &gt; 0);
101     if (auto notifier = m_idToNotifierMap.take(id))
102         m_notifierToIdMap.remove(notifier);
103 }
104 
105 void Geolocation::Watchers::remove(GeoNotifier* notifier)
106 {
107     if (auto identifier = m_notifierToIdMap.take(notifier))
108         m_idToNotifierMap.remove(identifier);
109 }
110 
111 bool Geolocation::Watchers::contains(GeoNotifier* notifier) const
112 {
113     return m_notifierToIdMap.contains(notifier);
114 }
115 
116 void Geolocation::Watchers::clear()
117 {
118     m_idToNotifierMap.clear();
119     m_notifierToIdMap.clear();
120 }
121 
122 bool Geolocation::Watchers::isEmpty() const
123 {
124     return m_idToNotifierMap.isEmpty();
125 }
126 
127 void Geolocation::Watchers::getNotifiersVector(GeoNotifierVector&amp; copy) const
128 {
129     copy = copyToVector(m_idToNotifierMap.values());
130 }
131 
132 Ref&lt;Geolocation&gt; Geolocation::create(Navigator&amp; navigator)
133 {
134     auto geolocation = adoptRef(*new Geolocation(navigator));
135     geolocation.get().suspendIfNeeded();
136     return geolocation;
137 }
138 
139 Geolocation::Geolocation(Navigator&amp; navigator)
140     : ActiveDOMObject(navigator.scriptExecutionContext())
141     , m_navigator(makeWeakPtr(navigator))
142     , m_resumeTimer(*this, &amp;Geolocation::resumeTimerFired)
143 {
144 }
145 
146 Geolocation::~Geolocation()
147 {
148     ASSERT(m_allowGeolocation != InProgress);
149     revokeAuthorizationTokenIfNecessary();
150 }
151 
152 SecurityOrigin* Geolocation::securityOrigin() const
153 {
154     return scriptExecutionContext()-&gt;securityOrigin();
155 }
156 
157 Page* Geolocation::page() const
158 {
159     return document() ? document()-&gt;page() : nullptr;
160 }
161 
162 void Geolocation::suspend(ReasonForSuspension reason)
163 {
164     if (reason == ReasonForSuspension::BackForwardCache) {
165         stop();
166         m_resetOnResume = true;
167     }
168 
169     // Suspend GeoNotifier timeout timers.
170     if (hasListeners())
171         stopTimers();
172 
173     m_isSuspended = true;
174     m_resumeTimer.stop();
175     ActiveDOMObject::suspend(reason);
176 }
177 
178 void Geolocation::resume()
179 {
180 #if USE(WEB_THREAD)
181     ASSERT(WebThreadIsLockedOrDisabled());
182 #endif
183     ActiveDOMObject::resume();
184 
185     if (!m_resumeTimer.isActive())
186         m_resumeTimer.startOneShot(0_s);
187 }
188 
189 void Geolocation::resumeTimerFired()
190 {
191     m_isSuspended = false;
192 
193     if (m_resetOnResume) {
194         resetAllGeolocationPermission();
195         m_resetOnResume = false;
196     }
197 
198     // Resume GeoNotifier timeout timers.
199     if (hasListeners()) {
200         for (auto&amp; notifier : m_oneShots)
201             notifier-&gt;startTimerIfNeeded();
202         GeoNotifierVector watcherCopy;
203         m_watchers.getNotifiersVector(watcherCopy);
204         for (auto&amp; watcher : watcherCopy)
205             watcher-&gt;startTimerIfNeeded();
206     }
207 
208     if ((isAllowed() || isDenied()) &amp;&amp; !m_pendingForPermissionNotifiers.isEmpty()) {
209         // The pending permission was granted while the object was suspended.
210         setIsAllowed(isAllowed(), authorizationToken());
211         ASSERT(!m_hasChangedPosition);
212         ASSERT(!m_errorWaitingForResume);
213         return;
214     }
215 
216     if (isDenied() &amp;&amp; hasListeners()) {
217         // The permission was revoked while the object was suspended.
218         setIsAllowed(false, { });
219         return;
220     }
221 
222     if (m_hasChangedPosition) {
223         positionChanged();
224         m_hasChangedPosition = false;
225     }
226 
227     if (m_errorWaitingForResume) {
228         handleError(*m_errorWaitingForResume);
229         m_errorWaitingForResume = nullptr;
230     }
231 }
232 
233 void Geolocation::resetAllGeolocationPermission()
234 {
235     if (m_isSuspended) {
236         m_resetOnResume = true;
237         return;
238     }
239 
240     if (m_allowGeolocation == InProgress) {
241         Page* page = this-&gt;page();
242         if (page)
243             GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
244 
245         // This return is not technically correct as GeolocationController::cancelPermissionRequest() should have cleared the active request.
246         // Neither iOS nor OS X supports cancelPermissionRequest() (https://bugs.webkit.org/show_bug.cgi?id=89524), so we workaround that and let ongoing requests complete. :(
247         return;
248     }
249 
250     // 1) Reset our own state.
251     stopUpdating();
252     resetIsAllowed();
253     m_hasChangedPosition = false;
254     m_errorWaitingForResume = nullptr;
255 
256     // 2) Request new permission for the active notifiers.
257     stopTimers();
258 
259     // Go over the one shot and re-request permission.
260     for (auto&amp; notifier : m_oneShots)
261         startRequest(notifier.get());
262     // Go over the watchers and re-request permission.
263     GeoNotifierVector watcherCopy;
264     m_watchers.getNotifiersVector(watcherCopy);
265     for (auto&amp; watcher : watcherCopy)
266         startRequest(watcher.get());
267 }
268 
269 void Geolocation::stop()
270 {
271     Page* page = this-&gt;page();
272     if (page &amp;&amp; m_allowGeolocation == InProgress)
273         GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
274     // The frame may be moving to a new page and we want to get the permissions from the new page&#39;s client.
275     resetIsAllowed();
276     cancelAllRequests();
277     stopUpdating();
278     m_hasChangedPosition = false;
279     m_errorWaitingForResume = nullptr;
280     m_pendingForPermissionNotifiers.clear();
281 }
282 
283 const char* Geolocation::activeDOMObjectName() const
284 {
285     return &quot;Geolocation&quot;;
286 }
287 
288 GeolocationPosition* Geolocation::lastPosition()
289 {
290     Page* page = this-&gt;page();
291     if (!page)
292         return nullptr;
293 
294     m_lastPosition = createGeolocationPosition(GeolocationController::from(page)-&gt;lastPosition());
295 
296     return m_lastPosition.get();
297 }
298 
299 void Geolocation::getCurrentPosition(Ref&lt;PositionCallback&gt;&amp;&amp; successCallback, RefPtr&lt;PositionErrorCallback&gt;&amp;&amp; errorCallback, PositionOptions&amp;&amp; options)
300 {
301     if (!frame())
302         return;
303 
304     auto notifier = GeoNotifier::create(*this, WTFMove(successCallback), WTFMove(errorCallback), WTFMove(options));
305     startRequest(notifier.ptr());
306 
307     m_oneShots.add(WTFMove(notifier));
308 }
309 
310 int Geolocation::watchPosition(Ref&lt;PositionCallback&gt;&amp;&amp; successCallback, RefPtr&lt;PositionErrorCallback&gt;&amp;&amp; errorCallback, PositionOptions&amp;&amp; options)
311 {
312     if (!frame())
313         return 0;
314 
315     auto notifier = GeoNotifier::create(*this, WTFMove(successCallback), WTFMove(errorCallback), WTFMove(options));
316     startRequest(notifier.ptr());
317 
318     int watchID;
319     // Keep asking for the next id until we&#39;re given one that we don&#39;t already have.
320     do {
321         watchID = m_scriptExecutionContext-&gt;circularSequentialID();
322     } while (!m_watchers.add(watchID, notifier.copyRef()));
323     return watchID;
324 }
325 
326 static void logError(const String&amp; target, const bool isSecure, const bool isMixedContent, Document* document)
327 {
328     StringBuilder message;
329     message.append(&quot;[blocked] Access to geolocation was blocked over&quot;);
330 
331     if (!isSecure)
332         message.append(&quot; insecure connection to &quot;);
333     else if (isMixedContent)
334         message.append(&quot; secure connection with mixed content to &quot;);
335     else
336         return;
337 
338     message.append(target);
339     message.append(&quot;.\n&quot;);
340     document-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message.toString());
341 }
342 
343 // FIXME: remove this function when rdar://problem/32137821 is fixed.
344 static bool isRequestFromIBooks()
345 {
346 #if PLATFORM(MAC)
347     return MacApplication::isIBooks();
348 #elif PLATFORM(IOS_FAMILY)
349     return IOSApplication::isIBooks();
350 #endif
351     return false;
352 }
353 
354 bool Geolocation::shouldBlockGeolocationRequests()
355 {
356     bool isSecure = SecurityOrigin::isSecure(document()-&gt;url());
357     bool hasMixedContent = !document()-&gt;foundMixedContent().isEmpty();
358     bool isLocalOrigin = securityOrigin()-&gt;isLocal();
359     if (securityOrigin()-&gt;canRequestGeolocation()) {
360         if (isLocalOrigin || (isSecure &amp;&amp; !hasMixedContent) || isRequestFromIBooks())
361             return false;
362     }
363 
364     logError(securityOrigin()-&gt;toString(), isSecure, hasMixedContent, document());
365     return true;
366 }
367 
368 void Geolocation::startRequest(GeoNotifier* notifier)
369 {
370     if (shouldBlockGeolocationRequests()) {
371         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, originCannotRequestGeolocationErrorMessage));
372         return;
373     }
374     document()-&gt;setGeolocationAccessed();
375 
376     // Check whether permissions have already been denied. Note that if this is the case,
377     // the permission state can not change again in the lifetime of this page.
378     if (isDenied())
379         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));
380     else if (haveSuitableCachedPosition(notifier-&gt;options()))
381         notifier-&gt;setUseCachedPosition();
382     else if (notifier-&gt;hasZeroTimeout())
383         notifier-&gt;startTimerIfNeeded();
384     else if (!isAllowed()) {
385         // if we don&#39;t yet have permission, request for permission before calling startUpdating()
386         m_pendingForPermissionNotifiers.add(notifier);
387         requestPermission();
388     } else if (startUpdating(notifier))
389         notifier-&gt;startTimerIfNeeded();
390     else
391         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));
392 }
393 
394 void Geolocation::fatalErrorOccurred(GeoNotifier* notifier)
395 {
396     // This request has failed fatally. Remove it from our lists.
397     m_oneShots.remove(notifier);
398     m_watchers.remove(notifier);
399 
400     if (!hasListeners())
401         stopUpdating();
402 }
403 
404 void Geolocation::requestUsesCachedPosition(GeoNotifier* notifier)
405 {
406     // This is called asynchronously, so the permissions could have been denied
407     // since we last checked in startRequest.
408     if (isDenied()) {
409         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));
410         return;
411     }
412 
413     m_requestsAwaitingCachedPosition.add(notifier);
414 
415     // If permissions are allowed, make the callback
416     if (isAllowed()) {
417         makeCachedPositionCallbacks();
418         return;
419     }
420 
421     // Request permissions, which may be synchronous or asynchronous.
422     requestPermission();
423 }
424 
425 void Geolocation::makeCachedPositionCallbacks()
426 {
427     // All modifications to m_requestsAwaitingCachedPosition are done
428     // asynchronously, so we don&#39;t need to worry about it being modified from
429     // the callbacks.
430     for (auto&amp; notifier : m_requestsAwaitingCachedPosition) {
431         // FIXME: This seems wrong, since makeCachedPositionCallbacks() is called in a branch where
432         // lastPosition() is known to be null in Geolocation::setIsAllowed().
433         notifier-&gt;runSuccessCallback(lastPosition());
434 
435         // If this is a one-shot request, stop it. Otherwise, if the watch still
436         // exists, start the service to get updates.
437         if (!m_oneShots.remove(notifier.get()) &amp;&amp; m_watchers.contains(notifier.get())) {
438             if (notifier-&gt;hasZeroTimeout() || startUpdating(notifier.get()))
439                 notifier-&gt;startTimerIfNeeded();
440             else
441                 notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));
442         }
443     }
444 
445     m_requestsAwaitingCachedPosition.clear();
446 
447     if (!hasListeners())
448         stopUpdating();
449 }
450 
451 void Geolocation::requestTimedOut(GeoNotifier* notifier)
452 {
453     // If this is a one-shot request, stop it.
454     m_oneShots.remove(notifier);
455 
456     if (!hasListeners())
457         stopUpdating();
458 }
459 
460 bool Geolocation::haveSuitableCachedPosition(const PositionOptions&amp; options)
461 {
462     auto* cachedPosition = lastPosition();
463     if (!cachedPosition)
464         return false;
465     if (!options.maximumAge)
466         return false;
467     DOMTimeStamp currentTimeMillis = convertSecondsToDOMTimeStamp(WallTime::now().secondsSinceEpoch());
468     return cachedPosition-&gt;timestamp() &gt; currentTimeMillis - options.maximumAge;
469 }
470 
471 void Geolocation::clearWatch(int watchID)
472 {
473     if (watchID &lt;= 0)
474         return;
475 
476     if (GeoNotifier* notifier = m_watchers.find(watchID))
477         m_pendingForPermissionNotifiers.remove(notifier);
478     m_watchers.remove(watchID);
479 
480     if (!hasListeners())
481         stopUpdating();
482 }
483 
484 void Geolocation::setIsAllowed(bool allowed, const String&amp; authorizationToken)
485 {
486     // Protect the Geolocation object from garbage collection during a callback.
487     Ref&lt;Geolocation&gt; protectedThis(*this);
488 
489     // This may be due to either a new position from the service, or a cached
490     // position.
491     m_allowGeolocation = allowed ? Yes : No;
492     m_authorizationToken = authorizationToken;
493 
494     if (m_isSuspended)
495         return;
496 
497     // Permission request was made during the startRequest process
498     if (!m_pendingForPermissionNotifiers.isEmpty()) {
499         handlePendingPermissionNotifiers();
500         m_pendingForPermissionNotifiers.clear();
501         return;
502     }
503 
504     if (!isAllowed()) {
505         auto error = GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage);
506         error-&gt;setIsFatal(true);
507         handleError(error);
508         m_requestsAwaitingCachedPosition.clear();
509         m_hasChangedPosition = false;
510         m_errorWaitingForResume = nullptr;
511         return;
512     }
513 
514     // If the service has a last position, use it to call back for all requests.
515     // If any of the requests are waiting for permission for a cached position,
516     // the position from the service will be at least as fresh.
517     if (RefPtr&lt;GeolocationPosition&gt; position = lastPosition())
518         makeSuccessCallbacks(*position);
519     else
520         makeCachedPositionCallbacks();
521 }
522 
523 void Geolocation::sendError(GeoNotifierVector&amp; notifiers, GeolocationPositionError&amp; error)
524 {
525     for (auto&amp; notifier : notifiers)
526         notifier-&gt;runErrorCallback(error);
527 }
528 
529 void Geolocation::sendPosition(GeoNotifierVector&amp; notifiers, GeolocationPosition&amp; position)
530 {
531     for (auto&amp; notifier : notifiers)
532         notifier-&gt;runSuccessCallback(&amp;position);
533 }
534 
535 void Geolocation::stopTimer(GeoNotifierVector&amp; notifiers)
536 {
537     for (auto&amp; notifier : notifiers)
538         notifier-&gt;stopTimer();
539 }
540 
541 void Geolocation::stopTimersForOneShots()
542 {
543     auto copy = copyToVector(m_oneShots);
544     stopTimer(copy);
545 }
546 
547 void Geolocation::stopTimersForWatchers()
548 {
549     GeoNotifierVector copy;
550     m_watchers.getNotifiersVector(copy);
551 
552     stopTimer(copy);
553 }
554 
555 void Geolocation::stopTimers()
556 {
557     stopTimersForOneShots();
558     stopTimersForWatchers();
559 }
560 
561 void Geolocation::cancelRequests(GeoNotifierVector&amp; notifiers)
562 {
563     for (auto&amp; notifier : notifiers)
564         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, framelessDocumentErrorMessage));
565 }
566 
567 void Geolocation::cancelAllRequests()
568 {
569     auto copy = copyToVector(m_oneShots);
570     cancelRequests(copy);
571     m_watchers.getNotifiersVector(copy);
572     cancelRequests(copy);
573 }
574 
575 void Geolocation::extractNotifiersWithCachedPosition(GeoNotifierVector&amp; notifiers, GeoNotifierVector* cached)
576 {
577     GeoNotifierVector nonCached;
578     for (auto&amp; notifier : notifiers) {
579         if (notifier-&gt;useCachedPosition()) {
580             if (cached)
581                 cached-&gt;append(notifier.get());
582         } else
583             nonCached.append(notifier.get());
584     }
585     notifiers.swap(nonCached);
586 }
587 
588 void Geolocation::copyToSet(const GeoNotifierVector&amp; src, GeoNotifierSet&amp; dest)
589 {
590     for (auto&amp; notifier : src)
591         dest.add(notifier.get());
592 }
593 
594 void Geolocation::handleError(GeolocationPositionError&amp; error)
595 {
596     auto oneShotsCopy = copyToVector(m_oneShots);
597 
598     GeoNotifierVector watchersCopy;
599     m_watchers.getNotifiersVector(watchersCopy);
600 
601     // Clear the lists before we make the callbacks, to avoid clearing notifiers
602     // added by calls to Geolocation methods from the callbacks, and to prevent
603     // further callbacks to these notifiers.
604     GeoNotifierVector oneShotsWithCachedPosition;
605     m_oneShots.clear();
606     if (error.isFatal())
607         m_watchers.clear();
608     else {
609         // Don&#39;t send non-fatal errors to notifiers due to receive a cached position.
610         extractNotifiersWithCachedPosition(oneShotsCopy, &amp;oneShotsWithCachedPosition);
611         extractNotifiersWithCachedPosition(watchersCopy, 0);
612     }
613 
614     sendError(oneShotsCopy, error);
615     sendError(watchersCopy, error);
616 
617     // hasListeners() doesn&#39;t distinguish between notifiers due to receive a
618     // cached position and those requiring a fresh position. Perform the check
619     // before restoring the notifiers below.
620     if (!hasListeners())
621         stopUpdating();
622 
623     // Maintain a reference to the cached notifiers until their timer fires.
624     copyToSet(oneShotsWithCachedPosition, m_oneShots);
625 }
626 
627 void Geolocation::requestPermission()
628 {
629     if (m_allowGeolocation &gt; Unknown)
630         return;
631 
632     Page* page = this-&gt;page();
633     if (!page)
634         return;
635 
636     m_allowGeolocation = InProgress;
637 
638     // Ask the embedder: it maintains the geolocation challenge policy itself.
639     GeolocationController::from(page)-&gt;requestPermission(*this);
640 }
641 
642 void Geolocation::revokeAuthorizationTokenIfNecessary()
643 {
644     if (m_authorizationToken.isNull())
645         return;
646 
647     Page* page = this-&gt;page();
648     if (!page)
649         return;
650 
651     GeolocationController::from(page)-&gt;revokeAuthorizationToken(std::exchange(m_authorizationToken, String()));
652 }
653 
654 void Geolocation::resetIsAllowed()
655 {
656     m_allowGeolocation = Unknown;
657     revokeAuthorizationTokenIfNecessary();
658 }
659 
660 void Geolocation::makeSuccessCallbacks(GeolocationPosition&amp; position)
661 {
662     ASSERT(lastPosition());
663     ASSERT(isAllowed());
664 
665     auto oneShotsCopy = copyToVector(m_oneShots);
666 
667     GeoNotifierVector watchersCopy;
668     m_watchers.getNotifiersVector(watchersCopy);
669 
670     // Clear the lists before we make the callbacks, to avoid clearing notifiers
671     // added by calls to Geolocation methods from the callbacks, and to prevent
672     // further callbacks to these notifiers.
673     m_oneShots.clear();
674 
675     sendPosition(oneShotsCopy, position);
676     sendPosition(watchersCopy, position);
677 
678     if (!hasListeners())
679         stopUpdating();
680 }
681 
682 void Geolocation::positionChanged()
683 {
684     ASSERT(isAllowed());
685 
686     // Stop all currently running timers.
687     stopTimers();
688 
689     if (m_isSuspended) {
690         m_hasChangedPosition = true;
691         return;
692     }
693 
694     RefPtr&lt;GeolocationPosition&gt; position = lastPosition();
695     ASSERT(position);
696 
697     makeSuccessCallbacks(*position);
698 }
699 
700 void Geolocation::setError(GeolocationError&amp; error)
701 {
702     if (m_isSuspended) {
703         m_errorWaitingForResume = createGeolocationPositionError(error);
704         return;
705     }
706 
707     auto positionError = createGeolocationPositionError(error);
708     handleError(positionError);
709 }
710 
711 bool Geolocation::startUpdating(GeoNotifier* notifier)
712 {
713     Page* page = this-&gt;page();
714     if (!page)
715         return false;
716 
717     GeolocationController::from(page)-&gt;addObserver(*this, notifier-&gt;options().enableHighAccuracy);
718     return true;
719 }
720 
721 void Geolocation::stopUpdating()
722 {
723     Page* page = this-&gt;page();
724     if (!page)
725         return;
726 
727     GeolocationController::from(page)-&gt;removeObserver(*this);
728 }
729 
730 void Geolocation::handlePendingPermissionNotifiers()
731 {
732     // While we iterate through the list, we need not worry about list being modified as the permission
733     // is already set to Yes/No and no new listeners will be added to the pending list
734     for (auto&amp; notifier : m_pendingForPermissionNotifiers) {
735         if (isAllowed()) {
736             // start all pending notification requests as permission granted.
737             // The notifier is always ref&#39;ed by m_oneShots or m_watchers.
738             if (startUpdating(notifier.get()))
739                 notifier-&gt;startTimerIfNeeded();
740             else
741                 notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));
742         } else
743             notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));
744     }
745 }
746 
747 Navigator* Geolocation::navigator()
748 {
749     return m_navigator.get();
750 }
751 
752 Frame* Geolocation::frame() const
753 {
754     return m_navigator ? m_navigator-&gt;frame() : nullptr;
755 }
756 
757 } // namespace WebCore
758 
759 #endif // ENABLE(GEOLOCATION)
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp
@@ -33,18 +33,22 @@
 
 #include "AXObjectCache.h"
 #include "AccessibilityNodeObject.h"
 #include "Attr.h"
 #include "CSSComputedStyleDeclaration.h"
+#include "CSSParser.h"
 #include "CSSPropertyNames.h"
 #include "CSSPropertySourceData.h"
 #include "CSSRule.h"
 #include "CSSRuleList.h"
+#include "CSSSelector.h"
+#include "CSSSelectorList.h"
 #include "CSSStyleRule.h"
 #include "CSSStyleSheet.h"
 #include "CharacterData.h"
 #include "CommandLineAPIHost.h"
+#include "ComposedTreeIterator.h"
 #include "ContainerNode.h"
 #include "Cookie.h"
 #include "CookieJar.h"
 #include "DOMEditor.h"
 #include "DOMException.h"
@@ -90,10 +94,11 @@
 #include "Pasteboard.h"
 #include "PseudoElement.h"
 #include "RenderStyle.h"
 #include "RenderStyleConstants.h"
 #include "ScriptState.h"
+#include "SelectorChecker.h"
 #include "ShadowRoot.h"
 #include "StaticNodeList.h"
 #include "StyleProperties.h"
 #include "StyleResolver.h"
 #include "StyleSheetList.h"
@@ -107,10 +112,11 @@
 #include <JavaScriptCore/IdentifiersFactory.h>
 #include <JavaScriptCore/InjectedScript.h>
 #include <JavaScriptCore/InjectedScriptManager.h>
 #include <JavaScriptCore/JSCInlines.h>
 #include <pal/crypto/CryptoDigest.h>
+#include <wtf/Function.h>
 #include <wtf/text/Base64.h>
 #include <wtf/text/CString.h>
 #include <wtf/text/WTFString.h>
 
 namespace WebCore {
@@ -215,11 +221,11 @@
     explicit InspectableNode(Node* node)
         : m_node(node)
     {
     }
 
-    JSC::JSValue get(JSC::ExecState& state) final
+    JSC::JSValue get(JSC::JSGlobalObject& state) final
     {
         return InspectorDOMAgent::nodeAsScriptValue(state, m_node.get());
     }
 private:
     RefPtr<Node> m_node;
@@ -459,11 +465,11 @@
 Node* InspectorDOMAgent::assertEditableNode(ErrorString& errorString, int nodeId)
 {
     Node* node = assertNode(errorString, nodeId);
     if (!node)
         return nullptr;
-    if (node->isInUserAgentShadowTree()) {
+    if (node->isInUserAgentShadowTree() && !m_allowEditingUserAgentShadowTrees) {
         errorString = "Node for given nodeId is in a shadow tree"_s;
         return nullptr;
     }
     if (node->isPseudoElement()) {
         errorString = "Node for given nodeId is a pseudo-element"_s;
@@ -539,21 +545,30 @@
     m_eventListenerEntries.clear();
     releaseDanglingNodes();
     m_childrenRequested.clear();
 }
 
+int InspectorDOMAgent::pushNodeToFrontend(Node* nodeToPush)
+{
+    if (!nodeToPush)
+        return 0;
+
+    ErrorString ignored;
+    return pushNodeToFrontend(ignored, boundNodeId(&nodeToPush->document()), nodeToPush);
+}
+
 int InspectorDOMAgent::pushNodeToFrontend(ErrorString& errorString, int documentNodeId, Node* nodeToPush)
 {
     Document* document = assertDocument(errorString, documentNodeId);
     if (!document)
         return 0;
     if (&nodeToPush->document() != document) {
         errorString = "nodeToPush is not part of the document with given documentNodeId"_s;
         return 0;
     }
 
-    return pushNodePathToFrontend(nodeToPush);
+    return pushNodePathToFrontend(errorString, nodeToPush);
 }
 
 Node* InspectorDOMAgent::nodeForId(int id)
 {
     if (!m_idToNode.isValidKey(id))
@@ -596,11 +611,11 @@
         errorString = "DOM Error while querying with given selectors"_s;
         return;
     }
 
     if (auto* element = queryResult.releaseReturnValue())
-        *elementId = pushNodePathToFrontend(element);
+        *elementId = pushNodePathToFrontend(errorString, element);
 }
 
 void InspectorDOMAgent::querySelectorAll(ErrorString& errorString, int nodeId, const String& selectors, RefPtr<JSON::ArrayOf<int>>& result)
 {
     Node* node = assertNode(errorString, nodeId);
@@ -622,17 +637,28 @@
     for (unsigned i = 0; i < nodes->length(); ++i)
         result->addItem(pushNodePathToFrontend(nodes->item(i)));
 }
 
 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)
+{
+    ErrorString ignored;
+    return pushNodePathToFrontend(ignored, nodeToPush);
+}
+
+int InspectorDOMAgent::pushNodePathToFrontend(ErrorString errorString, Node* nodeToPush)
 {
     ASSERT(nodeToPush);  // Invalid input
 
-    if (!m_document)
+    if (!m_document) {
+        errorString = "Missing document"_s;
         return 0;
-    if (!m_documentNodeToIdMap.contains(m_document))
+    }
+
+    if (!m_documentNodeToIdMap.contains(m_document)) {
+        errorString = "Document must have been requested"_s;
         return 0;
+    }
 
     // Return id in case the node is known.
     int result = m_documentNodeToIdMap.get(nodeToPush);
     if (result)
         return result;
@@ -773,11 +799,11 @@
     if (!m_domEditor->insertBefore(*parent, newElement.copyRef(), oldNode->nextSibling(), errorString))
         return;
     if (!m_domEditor->removeChild(*parent, *oldNode, errorString))
         return;
 
-    *newId = pushNodePathToFrontend(newElement.ptr());
+    *newId = pushNodePathToFrontend(errorString, newElement.ptr());
     if (m_childrenRequested.contains(nodeId))
         pushChildNodesToFrontend(*newId);
 }
 
 void InspectorDOMAgent::getOuterHTML(ErrorString& errorString, int nodeId, WTF::String* outerHTML)
@@ -813,11 +839,11 @@
     if (!newNode) {
         // The only child node has been deleted.
         return;
     }
 
-    int newId = pushNodePathToFrontend(newNode);
+    int newId = pushNodePathToFrontend(errorString, newNode);
 
     bool childrenRequested = m_childrenRequested.contains(nodeId);
     if (childrenRequested)
         pushChildNodesToFrontend(newId);
 }
@@ -1110,11 +1136,11 @@
 
     Frame* frame = node->document().frame();
     if (!frame)
         return;
 
-    JSC::ExecState* scriptState = mainWorldExecState(frame);
+    JSC::JSGlobalObject* scriptState = mainWorldExecState(frame);
     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
     if (injectedScript.hasNoValue())
         return;
 
     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
@@ -1211,10 +1237,14 @@
     m_overlay->highlightQuad(WTFMove(quad), *highlightConfig);
 }
 
 void InspectorDOMAgent::highlightSelector(ErrorString& errorString, const JSON::Object& highlightInspectorObject, const String& selectorString, const String* frameId)
 {
+    auto highlightConfig = highlightConfigFromInspectorObject(errorString, &highlightInspectorObject);
+    if (!highlightConfig)
+        return;
+
     RefPtr<Document> document;
 
     if (frameId) {
         auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
         if (!pageAgent) {
@@ -1233,22 +1263,70 @@
     if (!document) {
         errorString = "Missing document of frame for given frameId"_s;
         return;
     }
 
-    auto queryResult = document->querySelectorAll(selectorString);
-    // FIXME: <https://webkit.org/b/146161> Web Inspector: DOM.highlightSelector should work for "a:visited"
-    if (queryResult.hasException()) {
-        errorString = "DOM Error while querying with given selectorString"_s;
-        return;
-    }
+    CSSParser parser(*document);
+    CSSSelectorList selectorList;
+    parser.parseSelector(selectorString, selectorList);
 
-    auto highlightConfig = highlightConfigFromInspectorObject(errorString, &highlightInspectorObject);
-    if (!highlightConfig)
-        return;
+    SelectorChecker selectorChecker(*document);
 
-    m_overlay->highlightNodeList(queryResult.releaseReturnValue(), *highlightConfig);
+    Vector<Ref<Node>> nodeList;
+    HashSet<Node*> seenNodes;
+
+    for (auto& descendant : composedTreeDescendants(*document)) {
+        if (!is<Element>(descendant))
+            continue;
+
+        auto& descendantElement = downcast<Element>(descendant);
+
+        auto isInUserAgentShadowTree = descendantElement.isInUserAgentShadowTree();
+        auto pseudoId = descendantElement.pseudoId();
+        auto& pseudo = descendantElement.pseudo();
+
+        for (const auto* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector)) {
+            if (isInUserAgentShadowTree && (selector->match() != CSSSelector::PseudoElement || selector->value() != pseudo))
+                continue;
+
+            SelectorChecker::CheckingContext context(SelectorChecker::Mode::ResolvingStyle);
+            context.pseudoId = pseudoId;
+
+            unsigned ignoredSpecificity;
+            if (selectorChecker.match(*selector, descendantElement, context, ignoredSpecificity)) {
+                if (seenNodes.add(&descendantElement))
+                    nodeList.append(descendantElement);
+            }
+
+            if (context.pseudoIDSet) {
+                auto pseudoIDs = PseudoIdSet::fromMask(context.pseudoIDSet.data());
+
+                if (pseudoIDs.has(PseudoId::Before)) {
+                    pseudoIDs.remove(PseudoId::Before);
+                    if (auto* beforePseudoElement = descendantElement.beforePseudoElement()) {
+                        if (seenNodes.add(beforePseudoElement))
+                            nodeList.append(*beforePseudoElement);
+                    }
+                }
+
+                if (pseudoIDs.has(PseudoId::After)) {
+                    pseudoIDs.remove(PseudoId::After);
+                    if (auto* afterPseudoElement = descendantElement.afterPseudoElement()) {
+                        if (seenNodes.add(afterPseudoElement))
+                            nodeList.append(*afterPseudoElement);
+                    }
+                }
+
+                if (pseudoIDs) {
+                    if (seenNodes.add(&descendantElement))
+                        nodeList.append(descendantElement);
+                }
+            }
+        }
+    }
+
+    m_overlay->highlightNodeList(StaticNodeList::create(WTFMove(nodeList)), *highlightConfig);
 }
 
 void InspectorDOMAgent::highlightNode(ErrorString& errorString, const JSON::Object& highlightInspectorObject, const int* nodeId, const String* objectId)
 {
     Node* node = nullptr;
@@ -1353,11 +1431,11 @@
     }
 
     if (!m_domEditor->insertBefore(*targetElement, *node, anchorNode, errorString))
         return;
 
-    *newNodeId = pushNodePathToFrontend(node);
+    *newNodeId = pushNodePathToFrontend(errorString, node);
 }
 
 void InspectorDOMAgent::undo(ErrorString& errorString)
 {
     auto result = m_history->undo();
@@ -1393,11 +1471,11 @@
 {
     Node* node = assertNode(errorString, nodeId);
     if (!node)
         return;
 
-    if (node->isInUserAgentShadowTree()) {
+    if (node->isInUserAgentShadowTree() && !m_allowEditingUserAgentShadowTrees) {
         errorString = "Node for given nodeId is in a shadow tree"_s;
         return;
     }
 
     m_inspectedNode = node;
@@ -1429,15 +1507,15 @@
         return;
 
     result = buildArrayForElementAttributes(element);
 }
 
-void InspectorDOMAgent::requestNode(ErrorString&, const String& objectId, int* nodeId)
+void InspectorDOMAgent::requestNode(ErrorString& errorString, const String& objectId, int* nodeId)
 {
     Node* node = nodeForObjectId(objectId);
     if (node)
-        *nodeId = pushNodePathToFrontend(node);
+        *nodeId = pushNodePathToFrontend(errorString, node);
     else
         *nodeId = 0;
 }
 
 String InspectorDOMAgent::documentURLString(Document* document)
@@ -1685,11 +1763,11 @@
                 document = downcast<Document>(scriptExecutionContext);
         } else if (is<Node>(eventTarget))
             document = &downcast<Node>(eventTarget).document();
 
         JSC::JSObject* handlerObject = nullptr;
-        JSC::ExecState* exec = nullptr;
+        JSC::JSGlobalObject* exec = nullptr;
 
         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
 
         if (document) {
             handlerObject = scriptListener.jsFunction(*document);
@@ -1759,11 +1837,11 @@
     if (hasBreakpoint)
         value->setHasBreakpoint(hasBreakpoint);
     return value;
 }
 
-void InspectorDOMAgent::processAccessibilityChildren(AccessibilityObject& axObject, JSON::ArrayOf<int>& childNodeIds)
+void InspectorDOMAgent::processAccessibilityChildren(AXCoreObject& axObject, JSON::ArrayOf<int>& childNodeIds)
 {
     const auto& children = axObject.children();
     if (!children.size())
         return;
 
@@ -1822,17 +1900,17 @@
     int headingLevel = 0;
     unsigned hierarchicalLevel = 0;
     unsigned level = 0;
 
     if (AXObjectCache* axObjectCache = node->document().axObjectCache()) {
-        if (AccessibilityObject* axObject = axObjectCache->getOrCreate(node)) {
+        if (AXCoreObject* axObject = axObjectCache->getOrCreate(node)) {
 
-            if (AccessibilityObject* activeDescendant = axObject->activeDescendant())
+            if (AXCoreObject* activeDescendant = axObject->activeDescendant())
                 activeDescendantNode = activeDescendant->node();
 
             // An AX object is "busy" if it or any ancestor has aria-busy="true" set.
-            AccessibilityObject* current = axObject;
+            AXCoreObject* current = axObject;
             while (!busy && current) {
                 busy = current->isBusy();
                 current = current->parentObject();
             }
 
@@ -1969,11 +2047,11 @@
                     for (Element* ownedElement : ownedElements)
                         ownedNodeIds->addItem(pushNodePathToFrontend(ownedElement));
                 }
             }
 
-            if (AccessibilityObject* parentObject = axObject->parentObjectUnignored())
+            if (AXCoreObject* parentObject = axObject->parentObjectUnignored())
                 parentNode = parentObject->node();
 
             supportsPressed = axObject->pressedIsPresent();
             if (supportsPressed)
                 pressed = axObject->isPressed();
@@ -1986,11 +2064,11 @@
                 required = axObject->isRequired();
 
             role = axObject->computedRoleString();
             selected = axObject->isSelected();
 
-            AccessibilityObject::AccessibilityChildrenVector selectedChildren;
+            AXCoreObject::AccessibilityChildrenVector selectedChildren;
             axObject->selectedChildren(selectedChildren);
             if (selectedChildren.size()) {
                 selectedChildNodeIds = JSON::ArrayOf<int>::create();
                 for (auto& selectedChildObject : selectedChildren) {
                     if (Node* selectedChildNode = selectedChildObject->node())
@@ -2577,11 +2655,11 @@
 }
 
 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString& errorString, const String& path, int* nodeId)
 {
     if (Node* node = nodeForPath(path))
-        *nodeId = pushNodePathToFrontend(node);
+        *nodeId = pushNodePathToFrontend(errorString, node);
     else
         errorString = "Missing node for given path"_s;
 }
 
 RefPtr<Inspector::Protocol::Runtime::RemoteObject> InspectorDOMAgent::resolveNode(Node* node, const String& objectGroup)
@@ -2606,12 +2684,17 @@
     if (!value || !value.isObject())
         return nullptr;
     return JSNode::toWrapped(value.getObject()->vm(), value.getObject());
 }
 
-JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState& state, Node* node)
+JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::JSGlobalObject& state, Node* node)
 {
     JSC::JSLockHolder lock(&state);
     return toJS(&state, deprecatedGlobalObjectForPrototype(&state), BindingSecurity::checkSecurityForNode(state, node));
 }
 
+void InspectorDOMAgent::setAllowEditingUserAgentShadowTrees(ErrorString&, bool allow)
+{
+    m_allowEditingUserAgentShadowTrees = allow;
+}
+
 } // namespace WebCore

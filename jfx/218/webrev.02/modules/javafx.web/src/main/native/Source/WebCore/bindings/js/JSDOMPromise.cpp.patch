diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromise.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromise.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromise.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromise.cpp
@@ -36,57 +36,55 @@
 
 using namespace JSC;
 
 namespace WebCore {
 
-static inline JSC::JSValue callFunction(JSC::ExecState& state, JSC::JSValue jsFunction, JSC::JSValue thisValue, const JSC::ArgList& arguments)
-{
-    VM& vm = state.vm();
-    auto scope = DECLARE_THROW_SCOPE(vm);
-    JSC::CallData callData;
-    auto callType = JSC::getCallData(vm, jsFunction, callData);
-    ASSERT(callType != JSC::CallType::None);
-    auto result = call(&state, jsFunction, callType, callData, thisValue, arguments);
-
-    EXCEPTION_ASSERT_UNUSED(scope, !scope.exception() || isTerminatedExecutionException(state.vm(), scope.exception()));
-
-    return result;
-}
-
 void DOMPromise::whenSettled(std::function<void()>&& callback)
 {
     whenPromiseIsSettled(globalObject(), promise(), WTFMove(callback));
 }
 
-void DOMPromise::whenPromiseIsSettled(JSDOMGlobalObject* globalObject, JSC::JSObject* promise, std::function<void()>&& callback)
+void DOMPromise::whenPromiseIsSettled(JSDOMGlobalObject* globalObject, JSC::JSObject* promise, Function<void()>&& callback)
 {
-    auto& state = *globalObject->globalExec();
-    auto& vm = state.vm();
+    auto& lexicalGlobalObject = *globalObject;
+    auto& vm = lexicalGlobalObject.vm();
     JSLockHolder lock(vm);
-    auto* handler = JSC::JSNativeStdFunction::create(vm, globalObject, 1, String { }, [callback = WTFMove(callback)] (ExecState*) mutable {
+    auto* handler = JSC::JSNativeStdFunction::create(vm, globalObject, 1, String { }, [callback = WTFMove(callback)] (JSGlobalObject*, CallFrame*) mutable {
         callback();
         return JSC::JSValue::encode(JSC::jsUndefined());
     });
 
+    auto scope = DECLARE_THROW_SCOPE(vm);
     const JSC::Identifier& privateName = vm.propertyNames->builtinNames().thenPrivateName();
-    auto thenFunction = promise->get(&state, privateName);
+    auto thenFunction = promise->get(&lexicalGlobalObject, privateName);
+
+    EXCEPTION_ASSERT(!scope.exception() || isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));
+    if (scope.exception())
+        return;
+
     ASSERT(thenFunction.isFunction(vm));
 
     JSC::MarkedArgumentBuffer arguments;
     arguments.append(handler);
     arguments.append(handler);
-    callFunction(state, thenFunction, promise, arguments);
+
+    JSC::CallData callData;
+    auto callType = JSC::getCallData(vm, thenFunction, callData);
+    ASSERT(callType != JSC::CallType::None);
+    call(&lexicalGlobalObject, thenFunction, callType, callData, promise, arguments);
+
+    EXCEPTION_ASSERT(!scope.exception() || isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));
 }
 
 JSC::JSValue DOMPromise::result() const
 {
-    return promise()->result(m_globalObject->globalExec()->vm());
+    return promise()->result(m_globalObject->vm());
 }
 
 DOMPromise::Status DOMPromise::status() const
 {
-    switch (promise()->status(m_globalObject->globalExec()->vm())) {
+    switch (promise()->status(m_globalObject->vm())) {
     case JSC::JSPromise::Status::Pending:
         return Status::Pending;
     case JSC::JSPromise::Status::Fulfilled:
         return Status::Fulfilled;
     case JSC::JSPromise::Status::Rejected:

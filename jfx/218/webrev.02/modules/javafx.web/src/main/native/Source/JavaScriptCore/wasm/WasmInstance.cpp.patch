diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmInstance.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmInstance.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmInstance.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmInstance.cpp
@@ -45,23 +45,30 @@
 }
 
 Instance::Instance(Context* context, Ref<Module>&& module, EntryFrame** pointerToTopEntryFrame, void** pointerToActualStackLimit, StoreTopCallFrameCallback&& storeTopCallFrame)
     : m_context(context)
     , m_module(WTFMove(module))
-    , m_globals(MallocPtr<GlobalValue>::malloc(globalMemoryByteSize(m_module.get())))
+    , m_globals(MallocPtr<Global::Value, VMMalloc>::malloc(globalMemoryByteSize(m_module.get())))
     , m_globalsToMark(m_module.get().moduleInformation().globals.size())
+    , m_globalsToBinding(m_module.get().moduleInformation().globals.size())
     , m_pointerToTopEntryFrame(pointerToTopEntryFrame)
     , m_pointerToActualStackLimit(pointerToActualStackLimit)
     , m_storeTopCallFrame(WTFMove(storeTopCallFrame))
     , m_numImportFunctions(m_module->moduleInformation().importFunctionCount())
 {
     for (unsigned i = 0; i < m_numImportFunctions; ++i)
         new (importFunctionInfo(i)) ImportFunctionInfo();
     memset(static_cast<void*>(m_globals.get()), 0, globalMemoryByteSize(m_module.get()));
     for (unsigned i = 0; i < m_module->moduleInformation().globals.size(); ++i) {
-        if (isSubtype(m_module.get().moduleInformation().globals[i].type, Anyref))
+        const Wasm::GlobalInformation& global = m_module.get().moduleInformation().globals[i];
+        if (global.bindingMode == Wasm::GlobalInformation::BindingMode::Portable) {
+            // This is kept alive by JSWebAssemblyInstance -> JSWebAssemblyGlobal -> binding.
+            m_globalsToBinding.set(i);
+        } else if (isSubtype(global.type, Anyref)) {
+            // This is kept alive by JSWebAssemblyInstance -> binding.
             m_globalsToMark.set(i);
+        }
     }
     memset(bitwise_cast<char*>(this) + offsetOfTablePtr(m_numImportFunctions, 0), 0, m_module->moduleInformation().tableCount() * sizeof(Table*));
 }
 
 Ref<Instance> Instance::create(Context* context, Ref<Module>&& module, EntryFrame** pointerToTopEntryFrame, void** pointerToActualStackLimit, StoreTopCallFrameCallback&& storeTopCallFrame)
@@ -76,12 +83,20 @@
     return globalMemoryByteSize(m_module.get()) + allocationSize(m_numImportFunctions, m_module->moduleInformation().tableCount());
 }
 
 void Instance::setGlobal(unsigned i, JSValue value)
 {
+    Global::Value* slot = m_globals.get() + i;
+    if (m_globalsToBinding.get(i)) {
+        Wasm::Global* global = getGlobalBinding(i);
+        if (!global)
+            return;
+        global->valuePointer()->m_anyref.set(owner<JSWebAssemblyInstance>()->vm(), global->owner<JSWebAssemblyGlobal>(), value);
+        return;
+    }
     ASSERT(m_owner);
-    m_globals.get()[i].anyref.set(owner<JSWebAssemblyInstance>()->vm(), owner<JSWebAssemblyInstance>(), value);
+    slot->m_anyref.set(owner<JSWebAssemblyInstance>()->vm(), owner<JSWebAssemblyInstance>(), value);
 }
 
 JSValue Instance::getFunctionWrapper(unsigned i) const
 {
     JSValue value = m_functionWrappers.get(i).get();
@@ -111,95 +126,14 @@
     RELEASE_ASSERT(i < m_module->moduleInformation().tableCount());
     ASSERT(!this->table(i));
     *bitwise_cast<Table**>(bitwise_cast<char*>(this) + offsetOfTablePtr(m_numImportFunctions, i)) = &table.leakRef();
 }
 
-EncodedJSValue getWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex)
-{
-    ASSERT(tableIndex < instance->module().moduleInformation().tableCount());
-    if (signedIndex < 0)
-        return 0;
-
-    uint32_t index = signedIndex;
-    if (index >= instance->table(tableIndex)->length())
-        return 0;
-
-    return JSValue::encode(instance->table(tableIndex)->get(index));
-}
-
-bool setWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex, EncodedJSValue encValue)
-{
-    ASSERT(tableIndex < instance->module().moduleInformation().tableCount());
-    if (signedIndex < 0)
-        return false;
-
-    uint32_t index = signedIndex;
-    if (index >= instance->table(tableIndex)->length())
-        return false;
-
-    JSValue value = JSValue::decode(encValue);
-    if (instance->table(tableIndex)->type() == Wasm::TableElementType::Anyref)
-        instance->table(tableIndex)->set(index, value);
-    else if (instance->table(tableIndex)->type() == Wasm::TableElementType::Funcref) {
-        WebAssemblyFunction* wasmFunction;
-        WebAssemblyWrapperFunction* wasmWrapperFunction;
-
-        if (isWebAssemblyHostFunction(instance->owner<JSObject>()->vm(), value, wasmFunction, wasmWrapperFunction)) {
-            ASSERT(!!wasmFunction || !!wasmWrapperFunction);
-            if (wasmFunction)
-                instance->table(tableIndex)->asFuncrefTable()->setFunction(index, jsCast<JSObject*>(value), wasmFunction->importableFunction(), &wasmFunction->instance()->instance());
-            else
-                instance->table(tableIndex)->asFuncrefTable()->setFunction(index, jsCast<JSObject*>(value), wasmWrapperFunction->importableFunction(), &wasmWrapperFunction->instance()->instance());
-        } else if (value.isNull())
-            instance->table(tableIndex)->clear(index);
-        else
-            ASSERT_NOT_REACHED();
-    } else
-        ASSERT_NOT_REACHED();
-
-    return true;
-}
-
-int32_t doWasmTableGrow(Instance* instance, unsigned tableIndex, EncodedJSValue fill, int32_t delta)
-{
-    ASSERT(tableIndex < instance->module().moduleInformation().tableCount());
-    auto oldSize = instance->table(tableIndex)->length();
-    if (delta < 0)
-        return oldSize;
-    auto newSize = instance->table(tableIndex)->grow(delta);
-    if (!newSize || *newSize == oldSize)
-        return -1;
-
-    for (unsigned i = oldSize; i < instance->table(tableIndex)->length(); ++i)
-        setWasmTableElement(instance, tableIndex, i, fill);
-
-    return oldSize;
-}
-
-bool doWasmTableFill(Instance* instance, unsigned tableIndex, int32_t unsafeOffset, EncodedJSValue fill, int32_t unsafeCount)
-{
-    ASSERT(tableIndex < instance->module().moduleInformation().tableCount());
-    if (unsafeOffset < 0 || unsafeCount < 0)
-        return false;
-
-    unsigned offset = unsafeOffset;
-    unsigned count = unsafeCount;
-
-    if (offset >= instance->table(tableIndex)->length() || offset + count > instance->table(tableIndex)->length())
-        return false;
-
-    for (unsigned j = 0; j < count; ++j)
-        setWasmTableElement(instance, tableIndex, offset + j, fill);
-
-    return true;
-}
-
-EncodedJSValue doWasmRefFunc(Instance* instance, uint32_t index)
+void Instance::linkGlobal(unsigned i, Ref<Global>&& global)
 {
-    JSValue value = instance->getFunctionWrapper(index);
-    ASSERT(value.isFunction(instance->owner<JSObject>()->vm()));
-    return JSValue::encode(value);
+    m_globals.get()[i].m_pointer = global->valuePointer();
+    m_linkedGlobals.set(i, WTFMove(global));
 }
 
 } } // namespace JSC::Wasm
 
 #endif // ENABLE(WEBASSEMBLY)

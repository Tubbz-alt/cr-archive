<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBRequestCompletionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBTransaction.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  61 using namespace JSC;
  62 
  63 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBTransaction);
  64 
  65 std::atomic&lt;unsigned&gt; IDBTransaction::numberOfIDBTransactions { 0 };
  66 
  67 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info)
  68 {
  69     return adoptRef(*new IDBTransaction(database, info, nullptr));
  70 }
  71 
  72 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
  73 {
  74     return adoptRef(*new IDBTransaction(database, info, &amp;request));
  75 }
  76 
  77 IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
  78     : IDBActiveDOMObject(database.scriptExecutionContext())
  79     , m_database(database)
  80     , m_info(info)
<span class="line-removed">  81     , m_pendingOperationTimer(*this, &amp;IDBTransaction::pendingOperationTimerFired)</span>
<span class="line-removed">  82     , m_completedOperationTimer(*this, &amp;IDBTransaction::completedOperationTimerFired)</span>
  83     , m_openDBRequest(request)
  84     , m_currentlyCompletingRequest(request)
  85 
  86 {
  87     LOG(IndexedDB, &quot;IDBTransaction::IDBTransaction - %s&quot;, m_info.loggingString().utf8().data());
<span class="line-modified">  88     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
  89 
  90     ++numberOfIDBTransactions;
  91 
  92     if (m_info.mode() == IDBTransactionMode::Versionchange) {
  93         ASSERT(m_openDBRequest);
  94         m_openDBRequest-&gt;setVersionChangeTransaction(*this);
  95         m_startedOnServer = true;
  96     } else {
  97         activate();
  98 
  99         auto* context = scriptExecutionContext();
 100         ASSERT(context);
 101 
 102         JSC::VM&amp; vm = context-&gt;vm();
 103         vm.whenIdle([protectedThis = makeRef(*this)]() {
 104             protectedThis-&gt;deactivate();
 105         });
 106 
 107         establishOnServer();
 108     }
 109 
 110     suspendIfNeeded();
 111 }
 112 
 113 IDBTransaction::~IDBTransaction()
 114 {
 115     --numberOfIDBTransactions;
<span class="line-modified"> 116     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 117 }
 118 
 119 IDBClient::IDBConnectionProxy&amp; IDBTransaction::connectionProxy()
 120 {
 121     return m_database-&gt;connectionProxy();
 122 }
 123 
 124 Ref&lt;DOMStringList&gt; IDBTransaction::objectStoreNames() const
 125 {
<span class="line-modified"> 126     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 127 
 128     const Vector&lt;String&gt; names = isVersionChange() ? m_database-&gt;info().objectStoreNames() : m_info.objectStores();
 129 
 130     Ref&lt;DOMStringList&gt; objectStoreNames = DOMStringList::create();
 131     for (auto&amp; name : names)
 132         objectStoreNames-&gt;append(name);
 133 
 134     objectStoreNames-&gt;sort();
 135     return objectStoreNames;
 136 }
 137 
 138 IDBDatabase* IDBTransaction::db()
 139 {
<span class="line-modified"> 140     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 141     return m_database.ptr();
 142 }
 143 
 144 DOMException* IDBTransaction::error() const
 145 {
<span class="line-modified"> 146     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 147     return m_domError.get();
 148 }
 149 
 150 ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBTransaction::objectStore(const String&amp; objectStoreName)
 151 {
 152     LOG(IndexedDB, &quot;IDBTransaction::objectStore&quot;);
<span class="line-modified"> 153     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 154 
 155     if (!scriptExecutionContext())
 156         return Exception { InvalidStateError };
 157 
 158     if (isFinishedOrFinishing())
 159         return Exception { InvalidStateError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The transaction finished.&quot;_s };
 160 
 161     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 162 
 163     if (auto* store = m_referencedObjectStores.get(objectStoreName))
 164         return makeRef(*store);
 165 
 166     bool found = false;
 167     for (auto&amp; objectStore : m_info.objectStores()) {
 168         if (objectStore == objectStoreName) {
 169             found = true;
 170             break;
 171         }
 172     }
 173 
 174     auto* info = m_database-&gt;info().infoForExistingObjectStore(objectStoreName);
 175     if (!info)
 176         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 177 
 178     // Version change transactions are scoped to every object store in the database.
 179     if (!info || (!found &amp;&amp; !isVersionChange()))
 180         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 181 
 182     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), *info, *this);
 183     auto* rawObjectStore = objectStore.get();
 184     m_referencedObjectStores.set(objectStoreName, WTFMove(objectStore));
 185 
 186     return Ref&lt;IDBObjectStore&gt;(*rawObjectStore);
 187 }
 188 
 189 
 190 void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
 191 {
 192     LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
<span class="line-modified"> 193     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 194 
 195     if (isFinishedOrFinishing())
 196         return;
 197 
 198     m_domError = &amp;error;
 199     internalAbort();
 200 }
 201 
 202 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
 203 {
<span class="line-modified"> 204     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 205 
 206     ASSERT(!isFinishedOrFinishing());
 207     m_state = state;
 208     ASSERT(isFinishedOrFinishing());
 209 }
 210 
 211 ExceptionOr&lt;void&gt; IDBTransaction::abort()
 212 {
 213     LOG(IndexedDB, &quot;IDBTransaction::abort&quot;);
<span class="line-modified"> 214     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 215 
 216     if (isFinishedOrFinishing())
 217         return Exception { InvalidStateError, &quot;Failed to execute &#39;abort&#39; on &#39;IDBTransaction&#39;: The transaction is inactive or finished.&quot;_s };
 218 
 219     internalAbort();
 220 
 221     return { };
 222 }
 223 
 224 void IDBTransaction::internalAbort()
 225 {
 226     LOG(IndexedDB, &quot;IDBTransaction::internalAbort&quot;);
<span class="line-modified"> 227     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 228     ASSERT(!isFinishedOrFinishing());
 229 
 230     m_database-&gt;willAbortTransaction(*this);
 231 
 232     if (isVersionChange()) {
 233         Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 234 
 235         auto&amp; info = m_database-&gt;info();
 236         Vector&lt;uint64_t&gt; identifiersToRemove;
 237         for (auto&amp; iterator : m_deletedObjectStores) {
 238             if (info.infoForExistingObjectStore(iterator.key)) {
 239                 auto name = iterator.value-&gt;info().name();
 240                 m_referencedObjectStores.set(name, WTFMove(iterator.value));
 241                 identifiersToRemove.append(iterator.key);
 242             }
 243         }
 244 
 245         for (auto identifier : identifiersToRemove)
 246             m_deletedObjectStores.remove(identifier);
 247 
</pre>
<hr />
<pre>
 257     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 258         protectedThis-&gt;abortOnServerAndCancelRequests(operation);
 259     }));
 260 }
 261 
 262 void IDBTransaction::abortInProgressOperations(const IDBError&amp; error)
 263 {
 264     LOG(IndexedDB, &quot;IDBTransaction::abortInProgressOperations&quot;);
 265 
 266     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; inProgressAbortVector;
 267     inProgressAbortVector.reserveInitialCapacity(m_transactionOperationsInProgressQueue.size());
 268     while (!m_transactionOperationsInProgressQueue.isEmpty())
 269         inProgressAbortVector.uncheckedAppend(m_transactionOperationsInProgressQueue.takeFirst());
 270 
 271     for (auto&amp; operation : inProgressAbortVector) {
 272         m_transactionOperationsInProgressQueue.append(operation.get());
 273         m_currentlyCompletingRequest = nullptr;
 274         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 275     }
 276 
<span class="line-modified"> 277     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; completedOnServerAbortVector;</span>
<span class="line-removed"> 278     completedOnServerAbortVector.reserveInitialCapacity(m_completedOnServerQueue.size());</span>
<span class="line-removed"> 279     while (!m_completedOnServerQueue.isEmpty())</span>
<span class="line-removed"> 280         completedOnServerAbortVector.uncheckedAppend(m_completedOnServerQueue.takeFirst().first);</span>
<span class="line-removed"> 281 </span>
<span class="line-removed"> 282     for (auto&amp; operation : completedOnServerAbortVector) {</span>
<span class="line-removed"> 283         m_currentlyCompletingRequest = nullptr;</span>
<span class="line-removed"> 284         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));</span>
<span class="line-removed"> 285     }</span>
 286 

 287     connectionProxy().forgetActiveOperations(inProgressAbortVector);
 288 }
 289 
 290 void IDBTransaction::abortOnServerAndCancelRequests(IDBClient::TransactionOperation&amp; operation)
 291 {
 292     LOG(IndexedDB, &quot;IDBTransaction::abortOnServerAndCancelRequests&quot;);
<span class="line-modified"> 293     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 294     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 295 
 296     m_database-&gt;connectionProxy().abortTransaction(*this);
 297 
 298     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 299     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 300     m_transactionOperationMap.remove(operation.identifier());
 301     m_transactionOperationsInProgressQueue.removeLast();
 302 
 303     m_currentlyCompletingRequest = nullptr;
 304 
 305     IDBError error(AbortError);
 306 
 307     abortInProgressOperations(error);
 308 
 309     for (auto&amp; operation : m_abortQueue) {
 310         m_transactionOperationsInProgressQueue.append(operation.get());
 311         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 312         m_currentlyCompletingRequest = nullptr;
 313     }
 314 
 315     m_abortQueue.clear();

 316     // Since we&#39;re aborting, it should be impossible to have queued any further operations.
 317     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 318 }
 319 
 320 const char* IDBTransaction::activeDOMObjectName() const
 321 {
<span class="line-modified"> 322     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 323     return &quot;IDBTransaction&quot;;
 324 }
 325 
<span class="line-removed"> 326 bool IDBTransaction::canSuspendForDocumentSuspension() const</span>
<span class="line-removed"> 327 {</span>
<span class="line-removed"> 328     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="line-removed"> 329     return false;</span>
<span class="line-removed"> 330 }</span>
<span class="line-removed"> 331 </span>
 332 bool IDBTransaction::hasPendingActivity() const
 333 {
<span class="line-modified"> 334     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current() || Thread::mayBeGCThread());</span>
 335     return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
 336 }
 337 
 338 void IDBTransaction::stop()
 339 {
 340     LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
<span class="line-modified"> 341     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 342 
 343     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
 344     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
 345     if (m_contextStopped)
 346         return;
 347 
 348     removeAllEventListeners();
 349 
 350     m_contextStopped = true;
 351 
 352     if (isVersionChange())
 353         m_openDBRequest = nullptr;
 354 
 355     if (isFinishedOrFinishing())
 356         return;
 357 
 358     internalAbort();
 359 }
 360 
 361 bool IDBTransaction::isActive() const
 362 {
<span class="line-modified"> 363     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 364     return m_state == IndexedDB::TransactionState::Active;
 365 }
 366 
 367 bool IDBTransaction::isFinishedOrFinishing() const
 368 {
<span class="line-modified"> 369     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 370 
 371     return m_state == IndexedDB::TransactionState::Committing
 372         || m_state == IndexedDB::TransactionState::Aborting
 373         || m_state == IndexedDB::TransactionState::Finished;
 374 }
 375 
 376 void IDBTransaction::addRequest(IDBRequest&amp; request)
 377 {
<span class="line-modified"> 378     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 379     m_openRequests.add(&amp;request);
 380 }
 381 
 382 void IDBTransaction::removeRequest(IDBRequest&amp; request)
 383 {
<span class="line-modified"> 384     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>



 385     m_openRequests.remove(&amp;request);


 386 }
 387 
<span class="line-modified"> 388 void IDBTransaction::scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp; operation)</span>
 389 {
 390     ASSERT(!m_transactionOperationMap.contains(operation-&gt;identifier()));
<span class="line-modified"> 391     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>



 392 
 393     auto identifier = operation-&gt;identifier();
 394     m_pendingTransactionOperationQueue.append(operation.copyRef());
 395     m_transactionOperationMap.set(identifier, WTFMove(operation));
 396 
<span class="line-modified"> 397     schedulePendingOperationTimer();</span>
 398 }
 399 
<span class="line-modified"> 400 void IDBTransaction::schedulePendingOperationTimer()</span>
<span class="line-removed"> 401 {</span>
<span class="line-removed"> 402     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404     if (!m_pendingOperationTimer.isActive())</span>
<span class="line-removed"> 405         m_pendingOperationTimer.startOneShot(0_s);</span>
<span class="line-removed"> 406 }</span>
<span class="line-removed"> 407 </span>
<span class="line-removed"> 408 void IDBTransaction::pendingOperationTimerFired()</span>
 409 {
<span class="line-modified"> 410     LOG(IndexedDB, &quot;IDBTransaction::pendingOperationTimerFired (%p)&quot;, this);</span>
<span class="line-modified"> 411     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="line-removed"> 412 </span>
<span class="line-removed"> 413     if (!m_startedOnServer)</span>
<span class="line-removed"> 414         return;</span>
 415 
<span class="line-modified"> 416     // If the last in-progress operation we&#39;ve sent to the server is not an IDBRequest operation,</span>
<span class="line-removed"> 417     // then we have to wait until it completes before sending any more.</span>
<span class="line-removed"> 418     if (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_transactionOperationsInProgressQueue.last()-&gt;nextRequestCanGoToServer())</span>
 419         return;
 420 
<span class="line-modified"> 421     // We want to batch operations together without spinning the runloop for performance,</span>
<span class="line-removed"> 422     // but don&#39;t want to affect responsiveness of the main thread.</span>
<span class="line-removed"> 423     // This number is a good compromise in ad-hoc testing.</span>
<span class="line-removed"> 424     static const size_t operationBatchLimit = 128;</span>
<span class="line-removed"> 425 </span>
<span class="line-removed"> 426     for (size_t iterations = 0; !m_pendingTransactionOperationQueue.isEmpty() &amp;&amp; iterations &lt; operationBatchLimit; ++iterations) {</span>
<span class="line-removed"> 427         auto operation = m_pendingTransactionOperationQueue.takeFirst();</span>
<span class="line-removed"> 428         m_transactionOperationsInProgressQueue.append(operation.get());</span>
<span class="line-removed"> 429         operation-&gt;perform();</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431         if (!operation-&gt;nextRequestCanGoToServer())</span>
<span class="line-removed"> 432             break;</span>
<span class="line-removed"> 433 </span>
<span class="line-removed"> 434     }</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436     if (!m_transactionOperationMap.isEmpty() || !m_openRequests.isEmpty())</span>
<span class="line-removed"> 437         return;</span>
<span class="line-removed"> 438 </span>
<span class="line-removed"> 439     if (!isFinishedOrFinishing())</span>
<span class="line-removed"> 440         commit();</span>
<span class="line-removed"> 441 }</span>
<span class="line-removed"> 442 </span>
<span class="line-removed"> 443 void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)</span>
<span class="line-removed"> 444 {</span>
<span class="line-removed"> 445     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="line-removed"> 446     ASSERT(&amp;operation.originThread() == &amp;Thread::current());</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448     m_completedOnServerQueue.append({ &amp;operation, data });</span>
 449 
 450     if (!m_currentlyCompletingRequest)
<span class="line-modified"> 451         scheduleCompletedOperationTimer();</span>
<span class="line-removed"> 452 }</span>
<span class="line-removed"> 453 </span>
<span class="line-removed"> 454 void IDBTransaction::scheduleCompletedOperationTimer()</span>
<span class="line-removed"> 455 {</span>
<span class="line-removed"> 456     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="line-removed"> 457 </span>
<span class="line-removed"> 458     if (!m_completedOperationTimer.isActive())</span>
<span class="line-removed"> 459         m_completedOperationTimer.startOneShot(0_s);</span>
 460 }
 461 
<span class="line-modified"> 462 void IDBTransaction::completedOperationTimerFired()</span>
 463 {
<span class="line-modified"> 464     LOG(IndexedDB, &quot;IDBTransaction::completedOperationTimerFired (%p)&quot;, this);</span>
<span class="line-modified"> 465     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="line-removed"> 466 </span>
<span class="line-removed"> 467     if (m_completedOnServerQueue.isEmpty() || m_currentlyCompletingRequest)</span>
<span class="line-removed"> 468         return;</span>
 469 
<span class="line-modified"> 470     auto iterator = m_completedOnServerQueue.takeFirst();</span>
<span class="line-modified"> 471     iterator.first-&gt;doComplete(iterator.second);</span>


 472 
<span class="line-modified"> 473     if (!m_completedOnServerQueue.isEmpty() &amp;&amp; !m_currentlyCompletingRequest)</span>
<span class="line-modified"> 474         scheduleCompletedOperationTimer();</span>
 475 }
 476 
 477 void IDBTransaction::completeNoncursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 478 {
 479     ASSERT(!m_currentlyCompletingRequest);
 480 
 481     request.completeRequestAndDispatchEvent(result);
 482 
 483     m_currentlyCompletingRequest = &amp;request;
 484 }
 485 
 486 void IDBTransaction::completeCursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 487 {
 488     ASSERT(!m_currentlyCompletingRequest);
 489 
 490     request.didOpenOrIterateCursor(result);
 491 
 492     m_currentlyCompletingRequest = &amp;request;
 493 }
 494 
 495 void IDBTransaction::finishedDispatchEventForRequest(IDBRequest&amp; request)
 496 {
<span class="line-modified"> 497     if (isFinishedOrFinishing())</span>
 498         return;
 499 
 500     ASSERT_UNUSED(request, !m_currentlyCompletingRequest || m_currentlyCompletingRequest == &amp;request);
 501 
 502     m_currentlyCompletingRequest = nullptr;
<span class="line-modified"> 503     scheduleCompletedOperationTimer();</span>
 504 }
 505 
 506 void IDBTransaction::commit()
 507 {
 508     LOG(IndexedDB, &quot;IDBTransaction::commit&quot;);
<span class="line-modified"> 509     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 510     ASSERT(!isFinishedOrFinishing());
 511 
 512     transitionedToFinishing(IndexedDB::TransactionState::Committing);
 513     m_database-&gt;willCommitTransaction(*this);
 514 
 515     LOG(IndexedDBOperations, &quot;IDB commit operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 516     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 517         protectedThis-&gt;commitOnServer(operation);
 518     }));
 519 }
 520 
 521 void IDBTransaction::commitOnServer(IDBClient::TransactionOperation&amp; operation)
 522 {
 523     LOG(IndexedDB, &quot;IDBTransaction::commitOnServer&quot;);
<span class="line-modified"> 524     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 525 
 526     m_database-&gt;connectionProxy().commitTransaction(*this);
 527 
 528     ASSERT(!m_transactionOperationsInProgressQueue.isEmpty());
 529     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 530     m_transactionOperationsInProgressQueue.removeLast();
 531 
 532     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 533     m_transactionOperationMap.remove(operation.identifier());
 534 }
 535 
 536 void IDBTransaction::finishAbortOrCommit()
 537 {
 538     ASSERT(m_state != IndexedDB::TransactionState::Finished);
<span class="line-modified"> 539     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 540 
 541     m_state = IndexedDB::TransactionState::Finished;
 542 }
 543 
 544 void IDBTransaction::didStart(const IDBError&amp; error)
 545 {
 546     LOG(IndexedDB, &quot;IDBTransaction::didStart&quot;);
<span class="line-modified"> 547     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 548 
 549     m_database-&gt;didStartTransaction(*this);
 550 
 551     m_startedOnServer = true;
 552 
 553     // It&#39;s possible the transaction failed to start on the server.
 554     // That equates to an abort.
 555     if (!error.isNull()) {
 556         didAbort(error);
 557         return;
 558     }
 559 
<span class="line-modified"> 560     schedulePendingOperationTimer();</span>





 561 }
 562 
 563 void IDBTransaction::notifyDidAbort(const IDBError&amp; error)
 564 {
<span class="line-modified"> 565     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 566 
 567     m_database-&gt;didAbortTransaction(*this);
 568     m_idbError = error;
 569     fireOnAbort();
 570 
 571     if (isVersionChange() &amp;&amp; !m_contextStopped) {
 572         ASSERT(m_openDBRequest);
 573         m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 574     }
 575 }
 576 
 577 void IDBTransaction::didAbort(const IDBError&amp; error)
 578 {
 579     LOG(IndexedDB, &quot;IDBTransaction::didAbort&quot;);
<span class="line-modified"> 580     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 581 
 582     if (m_state == IndexedDB::TransactionState::Finished)
 583         return;
 584 
 585     notifyDidAbort(error);
 586 
 587     finishAbortOrCommit();
 588 }
 589 
 590 void IDBTransaction::didCommit(const IDBError&amp; error)
 591 {
 592     LOG(IndexedDB, &quot;IDBTransaction::didCommit&quot;);
<span class="line-modified"> 593     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 594     ASSERT(m_state == IndexedDB::TransactionState::Committing);
 595 
 596     if (error.isNull()) {
 597         m_database-&gt;didCommitTransaction(*this);
 598         fireOnComplete();
 599     } else {
 600         m_database-&gt;willAbortTransaction(*this);
 601         notifyDidAbort(error);
 602     }
 603 
 604     finishAbortOrCommit();
 605 }
 606 
 607 void IDBTransaction::fireOnComplete()
 608 {
 609     LOG(IndexedDB, &quot;IDBTransaction::fireOnComplete&quot;);
<span class="line-modified"> 610     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 611     enqueueEvent(Event::create(eventNames().completeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 612 }
 613 
 614 void IDBTransaction::fireOnAbort()
 615 {
 616     LOG(IndexedDB, &quot;IDBTransaction::fireOnAbort&quot;);
<span class="line-modified"> 617     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 618     enqueueEvent(Event::create(eventNames().abortEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
 619 }
 620 
 621 void IDBTransaction::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
 622 {
 623     ASSERT(m_state != IndexedDB::TransactionState::Finished);
<span class="line-modified"> 624     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 625 
 626     if (!scriptExecutionContext() || m_contextStopped)
 627         return;
 628 
<span class="line-modified"> 629     event-&gt;setTarget(this);</span>
<span class="line-removed"> 630     scriptExecutionContext()-&gt;eventQueue().enqueueEvent(WTFMove(event));</span>
 631 }
 632 
 633 void IDBTransaction::dispatchEvent(Event&amp; event)
 634 {
 635     LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
 636 
<span class="line-modified"> 637     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 638     ASSERT(scriptExecutionContext());
 639     ASSERT(!m_contextStopped);
<span class="line-removed"> 640     ASSERT(event.target() == this);</span>
 641     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 642 
 643     auto protectedThis = makeRef(*this);
 644 
 645     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
 646     m_didDispatchAbortOrCommit = true;
 647 
 648     if (isVersionChange()) {
 649         ASSERT(m_openDBRequest);
 650         m_openDBRequest-&gt;versionChangeTransactionDidFinish();
 651 
 652         if (event.type() == eventNames().completeEvent) {
 653             if (m_database-&gt;isClosingOrClosed())
 654                 m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 655             else
 656                 m_openDBRequest-&gt;fireSuccessAfterVersionChangeCommit();
 657         }
 658 
 659         m_openDBRequest = nullptr;
 660     }
 661 }
 662 
 663 Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
 664 {
 665     LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
 666     ASSERT(isVersionChange());
 667     ASSERT(scriptExecutionContext());
<span class="line-modified"> 668     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 669 
 670     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 671 
 672     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);
 673     auto* rawObjectStore = objectStore.get();
 674     m_referencedObjectStores.set(info.name(), WTFMove(objectStore));
 675 
 676     LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
 677     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 678         protectedThis-&gt;didCreateObjectStoreOnServer(result);
 679     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 680         protectedThis-&gt;createObjectStoreOnServer(operation, info);
<span class="line-modified"> 681     }));</span>
 682 
 683     return *rawObjectStore;
 684 }
 685 
 686 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
 687 {
 688     LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
<span class="line-modified"> 689     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 690     ASSERT(isVersionChange());
 691 
 692     m_database-&gt;connectionProxy().createObjectStore(operation, info);
 693 }
 694 
 695 void IDBTransaction::didCreateObjectStoreOnServer(const IDBResultData&amp; resultData)
 696 {
 697     LOG(IndexedDB, &quot;IDBTransaction::didCreateObjectStoreOnServer&quot;);
<span class="line-modified"> 698     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 699     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::CreateObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 700 }
 701 
 702 void IDBTransaction::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
 703 {
 704     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStore&quot;);
 705 
 706     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 707 
 708     ASSERT(isVersionChange());
 709     ASSERT(scriptExecutionContext());
<span class="line-modified"> 710     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 711 
 712     ASSERT(m_referencedObjectStores.contains(objectStore.info().name()));
 713     ASSERT(!m_referencedObjectStores.contains(newName));
 714     ASSERT(m_referencedObjectStores.get(objectStore.info().name()) == &amp;objectStore);
 715 
 716     uint64_t objectStoreIdentifier = objectStore.info().identifier();
 717 
 718     LOG(IndexedDBOperations, &quot;IDB rename object store operation: %s to %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), newName.utf8().data());
 719     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 720         protectedThis-&gt;didRenameObjectStoreOnServer(result);
 721     }, [protectedThis = makeRef(*this), objectStoreIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 722         protectedThis-&gt;renameObjectStoreOnServer(operation, objectStoreIdentifier, newName);
<span class="line-modified"> 723     }));</span>
 724 
 725     m_referencedObjectStores.set(newName, m_referencedObjectStores.take(objectStore.info().name()));
 726 }
 727 
 728 void IDBTransaction::renameObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; newName)
 729 {
 730     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStoreOnServer&quot;);
<span class="line-modified"> 731     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 732     ASSERT(isVersionChange());
 733 
 734     m_database-&gt;connectionProxy().renameObjectStore(operation, objectStoreIdentifier, newName);
 735 }
 736 
 737 void IDBTransaction::didRenameObjectStoreOnServer(const IDBResultData&amp; resultData)
 738 {
 739     LOG(IndexedDB, &quot;IDBTransaction::didRenameObjectStoreOnServer&quot;);
<span class="line-modified"> 740     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 741     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 742 }
 743 
 744 std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
 745 {
 746     LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
 747     ASSERT(isVersionChange());
<span class="line-modified"> 748     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 749 
 750     if (!scriptExecutionContext())
 751         return nullptr;
 752 
 753     LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
 754     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 755         protectedThis-&gt;didCreateIndexOnServer(result);
 756     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 757         protectedThis-&gt;createIndexOnServer(operation, info);
<span class="line-modified"> 758     }));</span>
 759 
 760     return makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);
 761 }
 762 
 763 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
 764 {
 765     LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
<span class="line-modified"> 766     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 767     ASSERT(isVersionChange());
 768 
 769     m_database-&gt;connectionProxy().createIndex(operation, info);
 770 }
 771 
 772 void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
 773 {
 774     LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
<span class="line-modified"> 775     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 776 
 777     if (resultData.type() == IDBResultType::CreateIndexSuccess)
 778         return;
 779 
 780     ASSERT(resultData.type() == IDBResultType::Error);
 781 
 782     // This operation might have failed because the transaction is already aborting.
 783     if (m_state == IndexedDB::TransactionState::Aborting)
 784         return;
 785 
 786     // Otherwise, failure to create an index forced abortion of the transaction.
 787     abortDueToFailedRequest(DOMException::create(resultData.error().message(), resultData.error().name()));
 788 }
 789 
 790 void IDBTransaction::renameIndex(IDBIndex&amp; index, const String&amp; newName)
 791 {
 792     LOG(IndexedDB, &quot;IDBTransaction::renameIndex&quot;);
 793     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 794 
 795     ASSERT(isVersionChange());
 796     ASSERT(scriptExecutionContext());
<span class="line-modified"> 797     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 798 
 799     ASSERT(m_referencedObjectStores.contains(index.objectStore().info().name()));
 800     ASSERT(m_referencedObjectStores.get(index.objectStore().info().name()) == &amp;index.objectStore());
 801 
 802     index.objectStore().renameReferencedIndex(index, newName);
 803 
 804     uint64_t objectStoreIdentifier = index.objectStore().info().identifier();
 805     uint64_t indexIdentifier = index.info().identifier();
 806 
 807     LOG(IndexedDBOperations, &quot;IDB rename index operation: %s to %s under object store %&quot; PRIu64, index.info().condensedLoggingString().utf8().data(), newName.utf8().data(), index.info().objectStoreIdentifier());
 808     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 809         protectedThis-&gt;didRenameIndexOnServer(result);
 810     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 811         protectedThis-&gt;renameIndexOnServer(operation, objectStoreIdentifier, indexIdentifier, newName);
<span class="line-modified"> 812     }));</span>
 813 }
 814 
 815 void IDBTransaction::renameIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const uint64_t&amp; indexIdentifier, const String&amp; newName)
 816 {
 817     LOG(IndexedDB, &quot;IDBTransaction::renameIndexOnServer&quot;);
<span class="line-modified"> 818     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 819     ASSERT(isVersionChange());
 820 
 821     m_database-&gt;connectionProxy().renameIndex(operation, objectStoreIdentifier, indexIdentifier, newName);
 822 }
 823 
 824 void IDBTransaction::didRenameIndexOnServer(const IDBResultData&amp; resultData)
 825 {
 826     LOG(IndexedDB, &quot;IDBTransaction::didRenameIndexOnServer&quot;);
<span class="line-modified"> 827     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 828     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameIndexSuccess || resultData.type() == IDBResultType::Error);
 829 }
 830 
<span class="line-modified"> 831 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBCursorInfo&amp; info)</span>
 832 {
 833     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<span class="line-modified"> 834     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 835 
 836     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 837         return doRequestOpenCursor(state, IDBCursor::create(objectStore, info));
 838 
 839     return doRequestOpenCursor(state, IDBCursorWithValue::create(objectStore, info));
 840 }
 841 
<span class="line-modified"> 842 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(ExecState&amp; state, IDBIndex&amp; index, const IDBCursorInfo&amp; info)</span>
 843 {
 844     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<span class="line-modified"> 845     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 846 
 847     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 848         return doRequestOpenCursor(state, IDBCursor::create(index, info));
 849 
 850     return doRequestOpenCursor(state, IDBCursorWithValue::create(index, info));
 851 }
 852 
<span class="line-modified"> 853 Ref&lt;IDBRequest&gt; IDBTransaction::doRequestOpenCursor(ExecState&amp; state, Ref&lt;IDBCursor&gt;&amp;&amp; cursor)</span>
 854 {
 855     ASSERT(isActive());
<span class="line-modified"> 856     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 857 
 858     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 859 
 860     auto request = IDBRequest::create(*scriptExecutionContext(), cursor.get(), *this);
 861     addRequest(request.get());
 862 
 863     LOG(IndexedDBOperations, &quot;IDB open cursor operation: %s&quot;, cursor-&gt;info().loggingString().utf8().data());
 864     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 865         protectedThis-&gt;didOpenCursorOnServer(request.get(), result);
 866     }, [protectedThis = makeRef(*this), info = cursor-&gt;info().isolatedCopy()] (auto&amp; operation) {
 867         protectedThis-&gt;openCursorOnServer(operation, info);
 868     }));
 869 
 870     return request;
 871 }
 872 
 873 void IDBTransaction::openCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
 874 {
 875     LOG(IndexedDB, &quot;IDBTransaction::openCursorOnServer&quot;);
<span class="line-modified"> 876     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 877 
 878     m_database-&gt;connectionProxy().openCursor(operation, info);
 879 }
 880 
 881 void IDBTransaction::didOpenCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 882 {
 883     LOG(IndexedDB, &quot;IDBTransaction::didOpenCursorOnServer&quot;);
<span class="line-modified"> 884     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 885 
 886     completeCursorRequest(request, resultData);
 887 }
 888 
 889 void IDBTransaction::iterateCursor(IDBCursor&amp; cursor, const IDBIterateCursorData&amp; data)
 890 {
 891     LOG(IndexedDB, &quot;IDBTransaction::iterateCursor&quot;);
 892     ASSERT(isActive());
 893     ASSERT(cursor.request());
<span class="line-modified"> 894     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 895 
 896     addRequest(*cursor.request());
 897 
 898     LOG(IndexedDBOperations, &quot;IDB iterate cursor operation: %s %s&quot;, cursor.info().loggingString().utf8().data(), data.loggingString().utf8().data());
 899     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, *cursor.request(), [protectedThis = makeRef(*this), request = makeRef(*cursor.request())] (const auto&amp; result) {
 900         protectedThis-&gt;didIterateCursorOnServer(request.get(), result);
 901     }, [protectedThis = makeRef(*this), data = data.isolatedCopy()] (auto&amp; operation) {
 902         protectedThis-&gt;iterateCursorOnServer(operation, data);
 903     }));
 904 }
 905 
 906 // FIXME: changes here
 907 void IDBTransaction::iterateCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
 908 {
 909     LOG(IndexedDB, &quot;IDBTransaction::iterateCursorOnServer&quot;);
<span class="line-modified"> 910     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>




 911 












 912     m_database-&gt;connectionProxy().iterateCursor(operation, data);
 913 }
 914 
 915 void IDBTransaction::didIterateCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 916 {
 917     LOG(IndexedDB, &quot;IDBTransaction::didIterateCursorOnServer&quot;);
<span class="line-modified"> 918     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 919 
 920     completeCursorRequest(request, resultData);
 921 }
 922 
<span class="line-modified"> 923 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllObjectStoreRecords(JSC::ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
 924 {
 925     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllObjectStoreRecords&quot;);
 926     ASSERT(isActive());
<span class="line-modified"> 927     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 928 
 929     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 930 
 931     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
 932     addRequest(request.get());
 933 
 934     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, objectStore.info().identifier(), 0 };
 935 
 936     LOG(IndexedDBOperations, &quot;IDB get all object store records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 937     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 938         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 939     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 940         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 941     }));
 942 
 943     return request;
 944 }
 945 
<span class="line-modified"> 946 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllIndexRecords(JSC::ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
 947 {
 948     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllIndexRecords&quot;);
 949     ASSERT(isActive());
<span class="line-modified"> 950     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 951 
 952     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 953 
 954     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
 955     addRequest(request.get());
 956 
 957     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, index.objectStore().info().identifier(), index.info().identifier() };
 958 
 959     LOG(IndexedDBOperations, &quot;IDB get all index records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 960     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 961         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 962     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 963         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 964     }));
 965 
 966     return request;
 967 }
 968 
 969 void IDBTransaction::getAllRecordsOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetAllRecordsData&amp; getAllRecordsData)
 970 {
 971     LOG(IndexedDB, &quot;IDBTransaction::getAllRecordsOnServer&quot;);
<span class="line-modified"> 972     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 973 
 974     m_database-&gt;connectionProxy().getAllRecords(operation, getAllRecordsData);
 975 }
 976 
 977 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 978 {
 979     LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
<span class="line-modified"> 980     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
 981 
 982     if (resultData.type() == IDBResultType::Error) {
 983         completeNoncursorRequest(request, resultData);
 984         return;
 985     }
 986 
 987     ASSERT(resultData.type() == IDBResultType::GetAllRecordsSuccess);
 988 
 989     auto&amp; getAllResult = resultData.getAllResult();
 990     switch (getAllResult.type()) {
 991     case IndexedDB::GetAllType::Keys:
 992         request.setResult(getAllResult.keys());
 993         break;
 994     case IndexedDB::GetAllType::Values:
 995         request.setResult(getAllResult);
 996         break;
 997     }
 998 
 999     completeNoncursorRequest(request, resultData);
1000 }
1001 
<span class="line-modified">1002 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)</span>
1003 {
1004     LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
1005     ASSERT(isActive());
1006     ASSERT(!getRecordData.keyRangeData.isNull);
<span class="line-modified">1007     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1008 
1009     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1010 
1011     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
1012 
1013     auto request = IDBRequest::createObjectStoreGet(*scriptExecutionContext(), objectStore, type, *this);
1014     addRequest(request.get());
1015 
1016     LOG(IndexedDBOperations, &quot;IDB get record operation: %s %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
1017     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1018         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
1019     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
1020         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
1021     }));
1022 
1023     return request;
1024 }
1025 
<span class="line-modified">1026 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetValue(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
1027 {
1028     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<span class="line-modified">1029     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1030 
1031     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Value, range);
1032 }
1033 
<span class="line-modified">1034 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetKey(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
1035 {
1036     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<span class="line-modified">1037     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1038 
1039     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Key, range);
1040 }
1041 
<span class="line-modified">1042 Ref&lt;IDBRequest&gt; IDBTransaction::requestIndexRecord(ExecState&amp; state, IDBIndex&amp; index, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range)</span>
1043 {
1044     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1045     ASSERT(isActive());
1046     ASSERT(!range.isNull);
<span class="line-modified">1047     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1048 
1049     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1050 
1051     auto request = IDBRequest::createIndexGet(*scriptExecutionContext(), index, type, *this);
1052     addRequest(request.get());
1053 
1054     IDBGetRecordData getRecordData = { range, IDBGetRecordDataType::KeyAndValue };
1055 
1056     LOG(IndexedDBOperations, &quot;IDB get index record operation: %s %s&quot;, index.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
1057     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1058         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
1059     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
1060         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
1061     }));
1062 
1063     return request;
1064 }
1065 
1066 void IDBTransaction::getRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetRecordData&amp; getRecordData)
1067 {
1068     LOG(IndexedDB, &quot;IDBTransaction::getRecordOnServer&quot;);
<span class="line-modified">1069     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1070 
1071     m_database-&gt;connectionProxy().getRecord(operation, getRecordData);
1072 }
1073 
1074 void IDBTransaction::didGetRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1075 {
1076     LOG(IndexedDB, &quot;IDBTransaction::didGetRecordOnServer&quot;);
<span class="line-modified">1077     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1078 
1079     if (resultData.type() == IDBResultType::Error) {
1080         completeNoncursorRequest(request, resultData);
1081         return;
1082     }
1083 
1084     ASSERT(resultData.type() == IDBResultType::GetRecordSuccess);
1085 
1086     bool useResultKey = request.sourceIndexIdentifier() &amp;&amp; request.requestedIndexRecordType() == IndexedDB::IndexRecordType::Key;
1087     if (!useResultKey)
1088         useResultKey = request.requestedObjectStoreRecordType() == IndexedDB::ObjectStoreRecordType::KeyOnly;
1089 
1090     const IDBGetResult&amp; result = resultData.getResult();
1091 
1092     if (useResultKey) {
1093         if (!result.keyData().isNull())
1094             request.setResult(result.keyData());
1095         else
1096             request.setResultToUndefined();
1097     } else {
1098         if (resultData.getResult().value().data().data())
1099             request.setResultToStructuredClone(resultData.getResult());
1100         else
1101             request.setResultToUndefined();
1102     }
1103 
1104     completeNoncursorRequest(request, resultData);
1105 }
1106 
<span class="line-modified">1107 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
1108 {
1109     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
1110     ASSERT(isActive());
1111     ASSERT(!range.isNull);
<span class="line-modified">1112     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1113 
1114     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1115 
1116     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1117     addRequest(request.get());
1118 
1119     LOG(IndexedDBOperations, &quot;IDB object store count operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1120     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1121         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1122     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1123         protectedThis-&gt;getCountOnServer(operation, range);
1124     }));
1125 
1126     return request;
1127 }
1128 
<span class="line-modified">1129 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
1130 {
1131     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBIndex)&quot;);
1132     ASSERT(isActive());
1133     ASSERT(!range.isNull);
<span class="line-modified">1134     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1135 
1136     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1137 
1138     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
1139     addRequest(request.get());
1140 
1141     LOG(IndexedDBOperations, &quot;IDB index count operation: %s, range %s&quot;, index.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1142     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1143         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1144     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1145         protectedThis-&gt;getCountOnServer(operation, range);
1146     }));
1147 
1148     return request;
1149 }
1150 
1151 void IDBTransaction::getCountOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1152 {
1153     LOG(IndexedDB, &quot;IDBTransaction::getCountOnServer&quot;);
<span class="line-modified">1154     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1155 
1156     m_database-&gt;connectionProxy().getCount(operation, keyRange);
1157 }
1158 
1159 void IDBTransaction::didGetCountOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1160 {
1161     LOG(IndexedDB, &quot;IDBTransaction::didGetCountOnServer&quot;);
<span class="line-modified">1162     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1163 
1164     request.setResult(resultData.resultInteger());
1165     completeNoncursorRequest(request, resultData);
1166 }
1167 
<span class="line-modified">1168 Ref&lt;IDBRequest&gt; IDBTransaction::requestDeleteRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
1169 {
1170     LOG(IndexedDB, &quot;IDBTransaction::requestDeleteRecord&quot;);
1171     ASSERT(isActive());
1172     ASSERT(!range.isNull);
<span class="line-modified">1173     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1174 
1175     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1176 
1177     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1178     addRequest(request.get());
1179 
1180     LOG(IndexedDBOperations, &quot;IDB delete record operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1181     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1182         protectedThis-&gt;didDeleteRecordOnServer(request.get(), result);
1183     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1184         protectedThis-&gt;deleteRecordOnServer(operation, range);
<span class="line-modified">1185     }));</span>
1186     return request;
1187 }
1188 
1189 void IDBTransaction::deleteRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1190 {
1191     LOG(IndexedDB, &quot;IDBTransaction::deleteRecordOnServer&quot;);
<span class="line-modified">1192     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1193 
1194     m_database-&gt;connectionProxy().deleteRecord(operation, keyRange);
1195 }
1196 
1197 void IDBTransaction::didDeleteRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1198 {
1199     LOG(IndexedDB, &quot;IDBTransaction::didDeleteRecordOnServer&quot;);
<span class="line-modified">1200     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1201 
1202     request.setResultToUndefined();
1203     completeNoncursorRequest(request, resultData);
1204 }
1205 
<span class="line-modified">1206 Ref&lt;IDBRequest&gt; IDBTransaction::requestClearObjectStore(ExecState&amp; state, IDBObjectStore&amp; objectStore)</span>
1207 {
1208     LOG(IndexedDB, &quot;IDBTransaction::requestClearObjectStore&quot;);
1209     ASSERT(isActive());
<span class="line-modified">1210     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1211 
1212     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1213 
1214     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1215     addRequest(request.get());
1216 
1217     uint64_t objectStoreIdentifier = objectStore.info().identifier();
1218 
1219     LOG(IndexedDBOperations, &quot;IDB clear object store operation: %s&quot;, objectStore.info().condensedLoggingString().utf8().data());
1220     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1221         protectedThis-&gt;didClearObjectStoreOnServer(request.get(), result);
1222     }, [protectedThis = makeRef(*this), objectStoreIdentifier] (auto&amp; operation) {
1223         protectedThis-&gt;clearObjectStoreOnServer(operation, objectStoreIdentifier);
<span class="line-modified">1224     }));</span>
1225 
1226     return request;
1227 }
1228 
1229 void IDBTransaction::clearObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier)
1230 {
1231     LOG(IndexedDB, &quot;IDBTransaction::clearObjectStoreOnServer&quot;);
<span class="line-modified">1232     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1233 
1234     m_database-&gt;connectionProxy().clearObjectStore(operation, objectStoreIdentifier);
1235 }
1236 
1237 void IDBTransaction::didClearObjectStoreOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1238 {
1239     LOG(IndexedDB, &quot;IDBTransaction::didClearObjectStoreOnServer&quot;);
<span class="line-modified">1240     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1241 
1242     request.setResultToUndefined();
1243     completeNoncursorRequest(request, resultData);
1244 }
1245 
<span class="line-modified">1246 Ref&lt;IDBRequest&gt; IDBTransaction::requestPutOrAdd(ExecState&amp; state, IDBObjectStore&amp; objectStore, RefPtr&lt;IDBKey&gt;&amp;&amp; key, SerializedScriptValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)</span>
1247 {
1248     LOG(IndexedDB, &quot;IDBTransaction::requestPutOrAdd&quot;);
1249     ASSERT(isActive());
1250     ASSERT(!isReadOnly());
1251     ASSERT(objectStore.info().autoIncrement() || key);
<span class="line-modified">1252     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1253 
1254     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1255 
1256     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1257     addRequest(request.get());
1258 
1259     LOG(IndexedDBOperations, &quot;IDB putOrAdd operation: %s key: %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), key ? key-&gt;loggingString().utf8().data() : &quot;&lt;null key&gt;&quot;);
1260     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1261         protectedThis-&gt;didPutOrAddOnServer(request.get(), result);
1262     }, [protectedThis = makeRef(*this), key, value = makeRef(value), overwriteMode] (auto&amp; operation) {
1263         protectedThis-&gt;putOrAddOnServer(operation, key.get(), value.ptr(), overwriteMode);
<span class="line-modified">1264     }));</span>
1265 
1266     return request;
1267 }
1268 
1269 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
1270 {
1271     LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
<span class="line-modified">1272     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
1273     ASSERT(!isReadOnly());
1274     ASSERT(value);
1275 
1276     if (!value-&gt;hasBlobURLs()) {
1277         m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
1278         return;
1279     }
1280 
1281     // Due to current limitations on our ability to post tasks back to a worker thread,
1282     // workers currently write blobs to disk synchronously.
1283     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
1284     if (!isMainThread()) {
<span class="line-modified">1285         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously(scriptExecutionContext()-&gt;sessionID());</span>
1286         if (idbValue.data().data())
1287             m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
1288         else {
1289             // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1290             // In that case, we cannot successfully store this record, so we callback with an error.
1291             RefPtr&lt;IDBClient::TransactionOperation&gt; protectedOperation(&amp;operation);
1292             auto result = IDBResultData::error(operation.identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1293             scriptExecutionContext()-&gt;postTask([protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)](ScriptExecutionContext&amp;) {
1294                 protectedOperation-&gt;doComplete(result);
1295             });
1296         }
1297         return;
1298     }
1299 
1300     // Since this request won&#39;t actually go to the server until the blob writes are complete,
1301     // stop future requests from going to the server ahead of it.
1302     operation.setNextRequestCanGoToServer(false);
1303 
<span class="line-modified">1304     value-&gt;writeBlobsToDiskForIndexedDB(scriptExecutionContext()-&gt;sessionID(), [protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {</span>
<span class="line-modified">1305         ASSERT(&amp;originThread() == &amp;Thread::current());</span>
1306         ASSERT(isMainThread());
1307         if (idbValue.data().data()) {
1308             m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
1309             return;
1310         }
1311 
1312         // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1313         // In that case, we cannot successfully store this record, so we callback with an error.
1314         auto result = IDBResultData::error(protectedOperation-&gt;identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1315         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)]() mutable {
1316             protectedOperation-&gt;doComplete(result);
1317         });
1318     });
1319 }
1320 
1321 void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1322 {
1323     LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
<span class="line-modified">1324     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1325 
1326     if (auto* result = resultData.resultKey())
1327         request.setResult(*result);
1328     else
1329         request.setResultToUndefined();
1330     completeNoncursorRequest(request, resultData);
1331 }
1332 
1333 void IDBTransaction::deleteObjectStore(const String&amp; objectStoreName)
1334 {
1335     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStore&quot;);
<span class="line-modified">1336     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1337     ASSERT(isVersionChange());
1338 
1339     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1340 
1341     if (auto objectStore = m_referencedObjectStores.take(objectStoreName)) {
1342         objectStore-&gt;markAsDeleted();
1343         auto identifier = objectStore-&gt;info().identifier();
1344         m_deletedObjectStores.set(identifier, WTFMove(objectStore));
1345     }
1346 
1347     LOG(IndexedDBOperations, &quot;IDB delete object store operation: %s&quot;, objectStoreName.utf8().data());
1348     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1349         protectedThis-&gt;didDeleteObjectStoreOnServer(result);
1350     }, [protectedThis = makeRef(*this), objectStoreName = objectStoreName.isolatedCopy()] (auto&amp; operation) {
1351         protectedThis-&gt;deleteObjectStoreOnServer(operation, objectStoreName);
<span class="line-modified">1352     }));</span>
1353 }
1354 
1355 void IDBTransaction::deleteObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const String&amp; objectStoreName)
1356 {
1357     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStoreOnServer&quot;);
1358     ASSERT(isVersionChange());
<span class="line-modified">1359     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1360 
1361     m_database-&gt;connectionProxy().deleteObjectStore(operation, objectStoreName);
1362 }
1363 
1364 void IDBTransaction::didDeleteObjectStoreOnServer(const IDBResultData&amp; resultData)
1365 {
1366     LOG(IndexedDB, &quot;IDBTransaction::didDeleteObjectStoreOnServer&quot;);
<span class="line-modified">1367     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1368     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteObjectStoreSuccess || resultData.type() == IDBResultType::Error);
1369 }
1370 
1371 void IDBTransaction::deleteIndex(uint64_t objectStoreIdentifier, const String&amp; indexName)
1372 {
1373     LOG(IndexedDB, &quot;IDBTransaction::deleteIndex&quot;);
<span class="line-modified">1374     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1375     ASSERT(isVersionChange());
1376 
1377     LOG(IndexedDBOperations, &quot;IDB delete index operation: %s (%&quot; PRIu64 &quot;)&quot;, indexName.utf8().data(), objectStoreIdentifier);
1378     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1379         protectedThis-&gt;didDeleteIndexOnServer(result);
1380     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexName = indexName.isolatedCopy()] (auto&amp; operation) {
1381         protectedThis-&gt;deleteIndexOnServer(operation, objectStoreIdentifier, indexName);
<span class="line-modified">1382     }));</span>
1383 }
1384 
1385 void IDBTransaction::deleteIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; indexName)
1386 {
1387     LOG(IndexedDB, &quot;IDBTransaction::deleteIndexOnServer&quot;);
1388     ASSERT(isVersionChange());
<span class="line-modified">1389     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1390 
1391     m_database-&gt;connectionProxy().deleteIndex(operation, objectStoreIdentifier, indexName);
1392 }
1393 
1394 void IDBTransaction::didDeleteIndexOnServer(const IDBResultData&amp; resultData)
1395 {
1396     LOG(IndexedDB, &quot;IDBTransaction::didDeleteIndexOnServer&quot;);
<span class="line-modified">1397     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1398     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteIndexSuccess || resultData.type() == IDBResultType::Error);
1399 }
1400 
1401 void IDBTransaction::operationCompletedOnClient(IDBClient::TransactionOperation&amp; operation)
1402 {
1403     LOG(IndexedDB, &quot;IDBTransaction::operationCompletedOnClient&quot;);
1404 
<span class="line-modified">1405     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="line-modified">1406     ASSERT(&amp;operation.originThread() == &amp;Thread::current());</span>
1407     ASSERT(m_transactionOperationMap.get(operation.identifier()) == &amp;operation);
1408     ASSERT(m_transactionOperationsInProgressQueue.first() == &amp;operation);
1409 
1410     m_transactionOperationMap.remove(operation.identifier());
1411     m_transactionOperationsInProgressQueue.removeFirst();
1412 
<span class="line-modified">1413     schedulePendingOperationTimer();</span>



1414 }
1415 
1416 void IDBTransaction::establishOnServer()
1417 {
1418     LOG(IndexedDB, &quot;IDBTransaction::establishOnServer&quot;);
<span class="line-modified">1419     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1420 
1421     m_database-&gt;connectionProxy().establishTransaction(*this);
1422 }
1423 
1424 void IDBTransaction::activate()
1425 {
<span class="line-modified">1426     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1427 
1428     if (isFinishedOrFinishing())
1429         return;
1430 
1431     m_state = IndexedDB::TransactionState::Active;
1432 }
1433 
1434 void IDBTransaction::deactivate()
1435 {
<span class="line-modified">1436     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
1437 
1438     if (m_state == IndexedDB::TransactionState::Active)
1439         m_state = IndexedDB::TransactionState::Inactive;
1440 
<span class="line-modified">1441     schedulePendingOperationTimer();</span>
1442 }
1443 
1444 void IDBTransaction::connectionClosedFromServer(const IDBError&amp; error)
1445 {
1446     LOG(IndexedDB, &quot;IDBTransaction::connectionClosedFromServer - %s&quot;, error.message().utf8().data());
1447 
1448     m_database-&gt;willAbortTransaction(*this);
1449     m_state = IndexedDB::TransactionState::Aborting;
1450 





1451     abortInProgressOperations(error);
1452 
1453     auto operations = copyToVector(m_transactionOperationMap.values());
1454     for (auto&amp; operation : operations) {
1455         m_currentlyCompletingRequest = nullptr;
1456         m_transactionOperationsInProgressQueue.append(operation.get());
1457         ASSERT(m_transactionOperationsInProgressQueue.first() == operation.get());
1458         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
1459     }
1460     m_currentlyCompletingRequest = nullptr;


1461 
1462     connectionProxy().forgetActiveOperations(operations);
1463     connectionProxy().forgetTransaction(*this);
1464 
<span class="line-removed">1465     m_pendingTransactionOperationQueue.clear();</span>
1466     m_abortQueue.clear();
1467     m_transactionOperationMap.clear();
1468 
1469     m_idbError = error;
1470     m_domError = error.toDOMException();
1471     m_database-&gt;didAbortTransaction(*this);
1472     fireOnAbort();
1473 }
1474 
1475 void IDBTransaction::visitReferencedObjectStores(JSC::SlotVisitor&amp; visitor) const
1476 {
1477     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1478     for (auto&amp; objectStore : m_referencedObjectStores.values())
1479         visitor.addOpaqueRoot(objectStore.get());
1480     for (auto&amp; objectStore : m_deletedObjectStores.values())
1481         visitor.addOpaqueRoot(objectStore.get());
1482 }
1483 














































1484 } // namespace WebCore
1485 
1486 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
  61 using namespace JSC;
  62 
  63 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBTransaction);
  64 
  65 std::atomic&lt;unsigned&gt; IDBTransaction::numberOfIDBTransactions { 0 };
  66 
  67 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info)
  68 {
  69     return adoptRef(*new IDBTransaction(database, info, nullptr));
  70 }
  71 
  72 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
  73 {
  74     return adoptRef(*new IDBTransaction(database, info, &amp;request));
  75 }
  76 
  77 IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
  78     : IDBActiveDOMObject(database.scriptExecutionContext())
  79     , m_database(database)
  80     , m_info(info)


  81     , m_openDBRequest(request)
  82     , m_currentlyCompletingRequest(request)
  83 
  84 {
  85     LOG(IndexedDB, &quot;IDBTransaction::IDBTransaction - %s&quot;, m_info.loggingString().utf8().data());
<span class="line-modified">  86     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  87 
  88     ++numberOfIDBTransactions;
  89 
  90     if (m_info.mode() == IDBTransactionMode::Versionchange) {
  91         ASSERT(m_openDBRequest);
  92         m_openDBRequest-&gt;setVersionChangeTransaction(*this);
  93         m_startedOnServer = true;
  94     } else {
  95         activate();
  96 
  97         auto* context = scriptExecutionContext();
  98         ASSERT(context);
  99 
 100         JSC::VM&amp; vm = context-&gt;vm();
 101         vm.whenIdle([protectedThis = makeRef(*this)]() {
 102             protectedThis-&gt;deactivate();
 103         });
 104 
 105         establishOnServer();
 106     }
 107 
 108     suspendIfNeeded();
 109 }
 110 
 111 IDBTransaction::~IDBTransaction()
 112 {
 113     --numberOfIDBTransactions;
<span class="line-modified"> 114     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 115 }
 116 
 117 IDBClient::IDBConnectionProxy&amp; IDBTransaction::connectionProxy()
 118 {
 119     return m_database-&gt;connectionProxy();
 120 }
 121 
 122 Ref&lt;DOMStringList&gt; IDBTransaction::objectStoreNames() const
 123 {
<span class="line-modified"> 124     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 125 
 126     const Vector&lt;String&gt; names = isVersionChange() ? m_database-&gt;info().objectStoreNames() : m_info.objectStores();
 127 
 128     Ref&lt;DOMStringList&gt; objectStoreNames = DOMStringList::create();
 129     for (auto&amp; name : names)
 130         objectStoreNames-&gt;append(name);
 131 
 132     objectStoreNames-&gt;sort();
 133     return objectStoreNames;
 134 }
 135 
 136 IDBDatabase* IDBTransaction::db()
 137 {
<span class="line-modified"> 138     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 139     return m_database.ptr();
 140 }
 141 
 142 DOMException* IDBTransaction::error() const
 143 {
<span class="line-modified"> 144     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 145     return m_domError.get();
 146 }
 147 
 148 ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBTransaction::objectStore(const String&amp; objectStoreName)
 149 {
 150     LOG(IndexedDB, &quot;IDBTransaction::objectStore&quot;);
<span class="line-modified"> 151     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 152 
 153     if (!scriptExecutionContext())
 154         return Exception { InvalidStateError };
 155 
 156     if (isFinishedOrFinishing())
 157         return Exception { InvalidStateError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The transaction finished.&quot;_s };
 158 
 159     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 160 
 161     if (auto* store = m_referencedObjectStores.get(objectStoreName))
 162         return makeRef(*store);
 163 
 164     bool found = false;
 165     for (auto&amp; objectStore : m_info.objectStores()) {
 166         if (objectStore == objectStoreName) {
 167             found = true;
 168             break;
 169         }
 170     }
 171 
 172     auto* info = m_database-&gt;info().infoForExistingObjectStore(objectStoreName);
 173     if (!info)
 174         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 175 
 176     // Version change transactions are scoped to every object store in the database.
 177     if (!info || (!found &amp;&amp; !isVersionChange()))
 178         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 179 
 180     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), *info, *this);
 181     auto* rawObjectStore = objectStore.get();
 182     m_referencedObjectStores.set(objectStoreName, WTFMove(objectStore));
 183 
 184     return Ref&lt;IDBObjectStore&gt;(*rawObjectStore);
 185 }
 186 
 187 
 188 void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
 189 {
 190     LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
<span class="line-modified"> 191     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 192 
 193     if (isFinishedOrFinishing())
 194         return;
 195 
 196     m_domError = &amp;error;
 197     internalAbort();
 198 }
 199 
 200 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
 201 {
<span class="line-modified"> 202     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 203 
 204     ASSERT(!isFinishedOrFinishing());
 205     m_state = state;
 206     ASSERT(isFinishedOrFinishing());
 207 }
 208 
 209 ExceptionOr&lt;void&gt; IDBTransaction::abort()
 210 {
 211     LOG(IndexedDB, &quot;IDBTransaction::abort&quot;);
<span class="line-modified"> 212     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 213 
 214     if (isFinishedOrFinishing())
 215         return Exception { InvalidStateError, &quot;Failed to execute &#39;abort&#39; on &#39;IDBTransaction&#39;: The transaction is inactive or finished.&quot;_s };
 216 
 217     internalAbort();
 218 
 219     return { };
 220 }
 221 
 222 void IDBTransaction::internalAbort()
 223 {
 224     LOG(IndexedDB, &quot;IDBTransaction::internalAbort&quot;);
<span class="line-modified"> 225     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 226     ASSERT(!isFinishedOrFinishing());
 227 
 228     m_database-&gt;willAbortTransaction(*this);
 229 
 230     if (isVersionChange()) {
 231         Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 232 
 233         auto&amp; info = m_database-&gt;info();
 234         Vector&lt;uint64_t&gt; identifiersToRemove;
 235         for (auto&amp; iterator : m_deletedObjectStores) {
 236             if (info.infoForExistingObjectStore(iterator.key)) {
 237                 auto name = iterator.value-&gt;info().name();
 238                 m_referencedObjectStores.set(name, WTFMove(iterator.value));
 239                 identifiersToRemove.append(iterator.key);
 240             }
 241         }
 242 
 243         for (auto identifier : identifiersToRemove)
 244             m_deletedObjectStores.remove(identifier);
 245 
</pre>
<hr />
<pre>
 255     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 256         protectedThis-&gt;abortOnServerAndCancelRequests(operation);
 257     }));
 258 }
 259 
 260 void IDBTransaction::abortInProgressOperations(const IDBError&amp; error)
 261 {
 262     LOG(IndexedDB, &quot;IDBTransaction::abortInProgressOperations&quot;);
 263 
 264     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; inProgressAbortVector;
 265     inProgressAbortVector.reserveInitialCapacity(m_transactionOperationsInProgressQueue.size());
 266     while (!m_transactionOperationsInProgressQueue.isEmpty())
 267         inProgressAbortVector.uncheckedAppend(m_transactionOperationsInProgressQueue.takeFirst());
 268 
 269     for (auto&amp; operation : inProgressAbortVector) {
 270         m_transactionOperationsInProgressQueue.append(operation.get());
 271         m_currentlyCompletingRequest = nullptr;
 272         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 273     }
 274 
<span class="line-modified"> 275     m_transactionOperationResultMap.clear();</span>








 276 
<span class="line-added"> 277     m_currentlyCompletingRequest = nullptr;</span>
 278     connectionProxy().forgetActiveOperations(inProgressAbortVector);
 279 }
 280 
 281 void IDBTransaction::abortOnServerAndCancelRequests(IDBClient::TransactionOperation&amp; operation)
 282 {
 283     LOG(IndexedDB, &quot;IDBTransaction::abortOnServerAndCancelRequests&quot;);
<span class="line-modified"> 284     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 285     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 286 
 287     m_database-&gt;connectionProxy().abortTransaction(*this);
 288 
 289     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 290     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 291     m_transactionOperationMap.remove(operation.identifier());
 292     m_transactionOperationsInProgressQueue.removeLast();
 293 
 294     m_currentlyCompletingRequest = nullptr;
 295 
 296     IDBError error(AbortError);
 297 
 298     abortInProgressOperations(error);
 299 
 300     for (auto&amp; operation : m_abortQueue) {
 301         m_transactionOperationsInProgressQueue.append(operation.get());
 302         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 303         m_currentlyCompletingRequest = nullptr;
 304     }
 305 
 306     m_abortQueue.clear();
<span class="line-added"> 307     m_openRequests.clear();</span>
 308     // Since we&#39;re aborting, it should be impossible to have queued any further operations.
 309     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 310 }
 311 
 312 const char* IDBTransaction::activeDOMObjectName() const
 313 {
<span class="line-modified"> 314     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 315     return &quot;IDBTransaction&quot;;
 316 }
 317 






 318 bool IDBTransaction::hasPendingActivity() const
 319 {
<span class="line-modified"> 320     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()) || Thread::mayBeGCThread());</span>
 321     return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
 322 }
 323 
 324 void IDBTransaction::stop()
 325 {
 326     LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
<span class="line-modified"> 327     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 328 
 329     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
 330     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
 331     if (m_contextStopped)
 332         return;
 333 
 334     removeAllEventListeners();
 335 
 336     m_contextStopped = true;
 337 
 338     if (isVersionChange())
 339         m_openDBRequest = nullptr;
 340 
 341     if (isFinishedOrFinishing())
 342         return;
 343 
 344     internalAbort();
 345 }
 346 
 347 bool IDBTransaction::isActive() const
 348 {
<span class="line-modified"> 349     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 350     return m_state == IndexedDB::TransactionState::Active;
 351 }
 352 
 353 bool IDBTransaction::isFinishedOrFinishing() const
 354 {
<span class="line-modified"> 355     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 356 
 357     return m_state == IndexedDB::TransactionState::Committing
 358         || m_state == IndexedDB::TransactionState::Aborting
 359         || m_state == IndexedDB::TransactionState::Finished;
 360 }
 361 
 362 void IDBTransaction::addRequest(IDBRequest&amp; request)
 363 {
<span class="line-modified"> 364     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 365     m_openRequests.add(&amp;request);
 366 }
 367 
 368 void IDBTransaction::removeRequest(IDBRequest&amp; request)
 369 {
<span class="line-modified"> 370     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added"> 371     if (m_currentlyCompletingRequest == &amp;request)</span>
<span class="line-added"> 372         return;</span>
<span class="line-added"> 373 </span>
 374     m_openRequests.remove(&amp;request);
<span class="line-added"> 375 </span>
<span class="line-added"> 376     autoCommit();</span>
 377 }
 378 
<span class="line-modified"> 379 void IDBTransaction::scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp; operation, IsWriteOperation isWriteOperation)</span>
 380 {
 381     ASSERT(!m_transactionOperationMap.contains(operation-&gt;identifier()));
<span class="line-modified"> 382     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384     if (isWriteOperation == IsWriteOperation::Yes)</span>
<span class="line-added"> 385         m_lastWriteOperationID = operation-&gt;operationID();</span>
 386 
 387     auto identifier = operation-&gt;identifier();
 388     m_pendingTransactionOperationQueue.append(operation.copyRef());
 389     m_transactionOperationMap.set(identifier, WTFMove(operation));
 390 
<span class="line-modified"> 391     handlePendingOperations();</span>
 392 }
 393 
<span class="line-modified"> 394 void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)</span>








 395 {
<span class="line-modified"> 396     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-modified"> 397     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));</span>



 398 
<span class="line-modified"> 399     if (!m_transactionOperationMap.contains(operation.identifier()))</span>


 400         return;
 401 
<span class="line-modified"> 402     m_transactionOperationResultMap.set(&amp;operation, IDBResultData(data));</span>



























 403 
 404     if (!m_currentlyCompletingRequest)
<span class="line-modified"> 405         handleOperationsCompletedOnServer();</span>








 406 }
 407 
<span class="line-modified"> 408 void IDBTransaction::handleOperationsCompletedOnServer()</span>
 409 {
<span class="line-modified"> 410     LOG(IndexedDB, &quot;IDBTransaction::handleOperationsCompletedOnServer&quot;);</span>
<span class="line-modified"> 411     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>



 412 
<span class="line-modified"> 413     while (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_currentlyCompletingRequest) {</span>
<span class="line-modified"> 414         RefPtr&lt;IDBClient::TransactionOperation&gt; currentOperation = m_transactionOperationsInProgressQueue.first();</span>
<span class="line-added"> 415         if (!m_transactionOperationResultMap.contains(currentOperation))</span>
<span class="line-added"> 416             return;</span>
 417 
<span class="line-modified"> 418         currentOperation-&gt;doComplete(m_transactionOperationResultMap.take(currentOperation));</span>
<span class="line-modified"> 419     }</span>
 420 }
 421 
 422 void IDBTransaction::completeNoncursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 423 {
 424     ASSERT(!m_currentlyCompletingRequest);
 425 
 426     request.completeRequestAndDispatchEvent(result);
 427 
 428     m_currentlyCompletingRequest = &amp;request;
 429 }
 430 
 431 void IDBTransaction::completeCursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 432 {
 433     ASSERT(!m_currentlyCompletingRequest);
 434 
 435     request.didOpenOrIterateCursor(result);
 436 
 437     m_currentlyCompletingRequest = &amp;request;
 438 }
 439 
 440 void IDBTransaction::finishedDispatchEventForRequest(IDBRequest&amp; request)
 441 {
<span class="line-modified"> 442     if (isFinished())</span>
 443         return;
 444 
 445     ASSERT_UNUSED(request, !m_currentlyCompletingRequest || m_currentlyCompletingRequest == &amp;request);
 446 
 447     m_currentlyCompletingRequest = nullptr;
<span class="line-modified"> 448     handleOperationsCompletedOnServer();</span>
 449 }
 450 
 451 void IDBTransaction::commit()
 452 {
 453     LOG(IndexedDB, &quot;IDBTransaction::commit&quot;);
<span class="line-modified"> 454     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 455     ASSERT(!isFinishedOrFinishing());
 456 
 457     transitionedToFinishing(IndexedDB::TransactionState::Committing);
 458     m_database-&gt;willCommitTransaction(*this);
 459 
 460     LOG(IndexedDBOperations, &quot;IDB commit operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 461     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 462         protectedThis-&gt;commitOnServer(operation);
 463     }));
 464 }
 465 
 466 void IDBTransaction::commitOnServer(IDBClient::TransactionOperation&amp; operation)
 467 {
 468     LOG(IndexedDB, &quot;IDBTransaction::commitOnServer&quot;);
<span class="line-modified"> 469     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 470 
 471     m_database-&gt;connectionProxy().commitTransaction(*this);
 472 
 473     ASSERT(!m_transactionOperationsInProgressQueue.isEmpty());
 474     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 475     m_transactionOperationsInProgressQueue.removeLast();
 476 
 477     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 478     m_transactionOperationMap.remove(operation.identifier());
 479 }
 480 
 481 void IDBTransaction::finishAbortOrCommit()
 482 {
 483     ASSERT(m_state != IndexedDB::TransactionState::Finished);
<span class="line-modified"> 484     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 485 
 486     m_state = IndexedDB::TransactionState::Finished;
 487 }
 488 
 489 void IDBTransaction::didStart(const IDBError&amp; error)
 490 {
 491     LOG(IndexedDB, &quot;IDBTransaction::didStart&quot;);
<span class="line-modified"> 492     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 493 
 494     m_database-&gt;didStartTransaction(*this);
 495 
 496     m_startedOnServer = true;
 497 
 498     // It&#39;s possible the transaction failed to start on the server.
 499     // That equates to an abort.
 500     if (!error.isNull()) {
 501         didAbort(error);
 502         return;
 503     }
 504 
<span class="line-modified"> 505     handlePendingOperations();</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507     // It&#39;s possible transaction does not create requests (or creates but finishes them early</span>
<span class="line-added"> 508     // because of error) during intialization. In this case, since the transaction will</span>
<span class="line-added"> 509     // not be active any more, we can end it.</span>
<span class="line-added"> 510     autoCommit();</span>
 511 }
 512 
 513 void IDBTransaction::notifyDidAbort(const IDBError&amp; error)
 514 {
<span class="line-modified"> 515     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 516 
 517     m_database-&gt;didAbortTransaction(*this);
 518     m_idbError = error;
 519     fireOnAbort();
 520 
 521     if (isVersionChange() &amp;&amp; !m_contextStopped) {
 522         ASSERT(m_openDBRequest);
 523         m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 524     }
 525 }
 526 
 527 void IDBTransaction::didAbort(const IDBError&amp; error)
 528 {
 529     LOG(IndexedDB, &quot;IDBTransaction::didAbort&quot;);
<span class="line-modified"> 530     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 531 
 532     if (m_state == IndexedDB::TransactionState::Finished)
 533         return;
 534 
 535     notifyDidAbort(error);
 536 
 537     finishAbortOrCommit();
 538 }
 539 
 540 void IDBTransaction::didCommit(const IDBError&amp; error)
 541 {
 542     LOG(IndexedDB, &quot;IDBTransaction::didCommit&quot;);
<span class="line-modified"> 543     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 544     ASSERT(m_state == IndexedDB::TransactionState::Committing);
 545 
 546     if (error.isNull()) {
 547         m_database-&gt;didCommitTransaction(*this);
 548         fireOnComplete();
 549     } else {
 550         m_database-&gt;willAbortTransaction(*this);
 551         notifyDidAbort(error);
 552     }
 553 
 554     finishAbortOrCommit();
 555 }
 556 
 557 void IDBTransaction::fireOnComplete()
 558 {
 559     LOG(IndexedDB, &quot;IDBTransaction::fireOnComplete&quot;);
<span class="line-modified"> 560     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 561     enqueueEvent(Event::create(eventNames().completeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 562 }
 563 
 564 void IDBTransaction::fireOnAbort()
 565 {
 566     LOG(IndexedDB, &quot;IDBTransaction::fireOnAbort&quot;);
<span class="line-modified"> 567     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 568     enqueueEvent(Event::create(eventNames().abortEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
 569 }
 570 
 571 void IDBTransaction::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
 572 {
 573     ASSERT(m_state != IndexedDB::TransactionState::Finished);
<span class="line-modified"> 574     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 575 
 576     if (!scriptExecutionContext() || m_contextStopped)
 577         return;
 578 
<span class="line-modified"> 579     queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));</span>

 580 }
 581 
 582 void IDBTransaction::dispatchEvent(Event&amp; event)
 583 {
 584     LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
 585 
<span class="line-modified"> 586     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 587     ASSERT(scriptExecutionContext());
 588     ASSERT(!m_contextStopped);

 589     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 590 
 591     auto protectedThis = makeRef(*this);
 592 
 593     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
 594     m_didDispatchAbortOrCommit = true;
 595 
 596     if (isVersionChange()) {
 597         ASSERT(m_openDBRequest);
 598         m_openDBRequest-&gt;versionChangeTransactionDidFinish();
 599 
 600         if (event.type() == eventNames().completeEvent) {
 601             if (m_database-&gt;isClosingOrClosed())
 602                 m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 603             else
 604                 m_openDBRequest-&gt;fireSuccessAfterVersionChangeCommit();
 605         }
 606 
 607         m_openDBRequest = nullptr;
 608     }
 609 }
 610 
 611 Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
 612 {
 613     LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
 614     ASSERT(isVersionChange());
 615     ASSERT(scriptExecutionContext());
<span class="line-modified"> 616     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 617 
 618     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 619 
 620     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);
 621     auto* rawObjectStore = objectStore.get();
 622     m_referencedObjectStores.set(info.name(), WTFMove(objectStore));
 623 
 624     LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
 625     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 626         protectedThis-&gt;didCreateObjectStoreOnServer(result);
 627     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 628         protectedThis-&gt;createObjectStoreOnServer(operation, info);
<span class="line-modified"> 629     }), IsWriteOperation::Yes);</span>
 630 
 631     return *rawObjectStore;
 632 }
 633 
 634 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
 635 {
 636     LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
<span class="line-modified"> 637     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 638     ASSERT(isVersionChange());
 639 
 640     m_database-&gt;connectionProxy().createObjectStore(operation, info);
 641 }
 642 
 643 void IDBTransaction::didCreateObjectStoreOnServer(const IDBResultData&amp; resultData)
 644 {
 645     LOG(IndexedDB, &quot;IDBTransaction::didCreateObjectStoreOnServer&quot;);
<span class="line-modified"> 646     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 647     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::CreateObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 648 }
 649 
 650 void IDBTransaction::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
 651 {
 652     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStore&quot;);
 653 
 654     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 655 
 656     ASSERT(isVersionChange());
 657     ASSERT(scriptExecutionContext());
<span class="line-modified"> 658     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 659 
 660     ASSERT(m_referencedObjectStores.contains(objectStore.info().name()));
 661     ASSERT(!m_referencedObjectStores.contains(newName));
 662     ASSERT(m_referencedObjectStores.get(objectStore.info().name()) == &amp;objectStore);
 663 
 664     uint64_t objectStoreIdentifier = objectStore.info().identifier();
 665 
 666     LOG(IndexedDBOperations, &quot;IDB rename object store operation: %s to %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), newName.utf8().data());
 667     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 668         protectedThis-&gt;didRenameObjectStoreOnServer(result);
 669     }, [protectedThis = makeRef(*this), objectStoreIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 670         protectedThis-&gt;renameObjectStoreOnServer(operation, objectStoreIdentifier, newName);
<span class="line-modified"> 671     }), IsWriteOperation::Yes);</span>
 672 
 673     m_referencedObjectStores.set(newName, m_referencedObjectStores.take(objectStore.info().name()));
 674 }
 675 
 676 void IDBTransaction::renameObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; newName)
 677 {
 678     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStoreOnServer&quot;);
<span class="line-modified"> 679     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 680     ASSERT(isVersionChange());
 681 
 682     m_database-&gt;connectionProxy().renameObjectStore(operation, objectStoreIdentifier, newName);
 683 }
 684 
 685 void IDBTransaction::didRenameObjectStoreOnServer(const IDBResultData&amp; resultData)
 686 {
 687     LOG(IndexedDB, &quot;IDBTransaction::didRenameObjectStoreOnServer&quot;);
<span class="line-modified"> 688     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 689     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 690 }
 691 
 692 std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
 693 {
 694     LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
 695     ASSERT(isVersionChange());
<span class="line-modified"> 696     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 697 
 698     if (!scriptExecutionContext())
 699         return nullptr;
 700 
 701     LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
 702     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 703         protectedThis-&gt;didCreateIndexOnServer(result);
 704     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 705         protectedThis-&gt;createIndexOnServer(operation, info);
<span class="line-modified"> 706     }), IsWriteOperation::Yes);</span>
 707 
 708     return makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);
 709 }
 710 
 711 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
 712 {
 713     LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
<span class="line-modified"> 714     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 715     ASSERT(isVersionChange());
 716 
 717     m_database-&gt;connectionProxy().createIndex(operation, info);
 718 }
 719 
 720 void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
 721 {
 722     LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
<span class="line-modified"> 723     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 724 
 725     if (resultData.type() == IDBResultType::CreateIndexSuccess)
 726         return;
 727 
 728     ASSERT(resultData.type() == IDBResultType::Error);
 729 
 730     // This operation might have failed because the transaction is already aborting.
 731     if (m_state == IndexedDB::TransactionState::Aborting)
 732         return;
 733 
 734     // Otherwise, failure to create an index forced abortion of the transaction.
 735     abortDueToFailedRequest(DOMException::create(resultData.error().message(), resultData.error().name()));
 736 }
 737 
 738 void IDBTransaction::renameIndex(IDBIndex&amp; index, const String&amp; newName)
 739 {
 740     LOG(IndexedDB, &quot;IDBTransaction::renameIndex&quot;);
 741     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 742 
 743     ASSERT(isVersionChange());
 744     ASSERT(scriptExecutionContext());
<span class="line-modified"> 745     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 746 
 747     ASSERT(m_referencedObjectStores.contains(index.objectStore().info().name()));
 748     ASSERT(m_referencedObjectStores.get(index.objectStore().info().name()) == &amp;index.objectStore());
 749 
 750     index.objectStore().renameReferencedIndex(index, newName);
 751 
 752     uint64_t objectStoreIdentifier = index.objectStore().info().identifier();
 753     uint64_t indexIdentifier = index.info().identifier();
 754 
 755     LOG(IndexedDBOperations, &quot;IDB rename index operation: %s to %s under object store %&quot; PRIu64, index.info().condensedLoggingString().utf8().data(), newName.utf8().data(), index.info().objectStoreIdentifier());
 756     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 757         protectedThis-&gt;didRenameIndexOnServer(result);
 758     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 759         protectedThis-&gt;renameIndexOnServer(operation, objectStoreIdentifier, indexIdentifier, newName);
<span class="line-modified"> 760     }), IsWriteOperation::Yes);</span>
 761 }
 762 
 763 void IDBTransaction::renameIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const uint64_t&amp; indexIdentifier, const String&amp; newName)
 764 {
 765     LOG(IndexedDB, &quot;IDBTransaction::renameIndexOnServer&quot;);
<span class="line-modified"> 766     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 767     ASSERT(isVersionChange());
 768 
 769     m_database-&gt;connectionProxy().renameIndex(operation, objectStoreIdentifier, indexIdentifier, newName);
 770 }
 771 
 772 void IDBTransaction::didRenameIndexOnServer(const IDBResultData&amp; resultData)
 773 {
 774     LOG(IndexedDB, &quot;IDBTransaction::didRenameIndexOnServer&quot;);
<span class="line-modified"> 775     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 776     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameIndexSuccess || resultData.type() == IDBResultType::Error);
 777 }
 778 
<span class="line-modified"> 779 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBCursorInfo&amp; info)</span>
 780 {
 781     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<span class="line-modified"> 782     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 783 
 784     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 785         return doRequestOpenCursor(state, IDBCursor::create(objectStore, info));
 786 
 787     return doRequestOpenCursor(state, IDBCursorWithValue::create(objectStore, info));
 788 }
 789 
<span class="line-modified"> 790 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBCursorInfo&amp; info)</span>
 791 {
 792     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<span class="line-modified"> 793     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 794 
 795     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 796         return doRequestOpenCursor(state, IDBCursor::create(index, info));
 797 
 798     return doRequestOpenCursor(state, IDBCursorWithValue::create(index, info));
 799 }
 800 
<span class="line-modified"> 801 Ref&lt;IDBRequest&gt; IDBTransaction::doRequestOpenCursor(JSGlobalObject&amp; state, Ref&lt;IDBCursor&gt;&amp;&amp; cursor)</span>
 802 {
 803     ASSERT(isActive());
<span class="line-modified"> 804     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 805 
 806     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 807 
 808     auto request = IDBRequest::create(*scriptExecutionContext(), cursor.get(), *this);
 809     addRequest(request.get());
 810 
 811     LOG(IndexedDBOperations, &quot;IDB open cursor operation: %s&quot;, cursor-&gt;info().loggingString().utf8().data());
 812     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 813         protectedThis-&gt;didOpenCursorOnServer(request.get(), result);
 814     }, [protectedThis = makeRef(*this), info = cursor-&gt;info().isolatedCopy()] (auto&amp; operation) {
 815         protectedThis-&gt;openCursorOnServer(operation, info);
 816     }));
 817 
 818     return request;
 819 }
 820 
 821 void IDBTransaction::openCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
 822 {
 823     LOG(IndexedDB, &quot;IDBTransaction::openCursorOnServer&quot;);
<span class="line-modified"> 824     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 825 
 826     m_database-&gt;connectionProxy().openCursor(operation, info);
 827 }
 828 
 829 void IDBTransaction::didOpenCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 830 {
 831     LOG(IndexedDB, &quot;IDBTransaction::didOpenCursorOnServer&quot;);
<span class="line-modified"> 832     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 833 
 834     completeCursorRequest(request, resultData);
 835 }
 836 
 837 void IDBTransaction::iterateCursor(IDBCursor&amp; cursor, const IDBIterateCursorData&amp; data)
 838 {
 839     LOG(IndexedDB, &quot;IDBTransaction::iterateCursor&quot;);
 840     ASSERT(isActive());
 841     ASSERT(cursor.request());
<span class="line-modified"> 842     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 843 
 844     addRequest(*cursor.request());
 845 
 846     LOG(IndexedDBOperations, &quot;IDB iterate cursor operation: %s %s&quot;, cursor.info().loggingString().utf8().data(), data.loggingString().utf8().data());
 847     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, *cursor.request(), [protectedThis = makeRef(*this), request = makeRef(*cursor.request())] (const auto&amp; result) {
 848         protectedThis-&gt;didIterateCursorOnServer(request.get(), result);
 849     }, [protectedThis = makeRef(*this), data = data.isolatedCopy()] (auto&amp; operation) {
 850         protectedThis-&gt;iterateCursorOnServer(operation, data);
 851     }));
 852 }
 853 
 854 // FIXME: changes here
 855 void IDBTransaction::iterateCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
 856 {
 857     LOG(IndexedDB, &quot;IDBTransaction::iterateCursorOnServer&quot;);
<span class="line-modified"> 858     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added"> 859     ASSERT(operation.idbRequest());</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861     auto* cursor = operation.idbRequest()-&gt;pendingCursor();</span>
<span class="line-added"> 862     ASSERT(cursor);</span>
 863 
<span class="line-added"> 864     if (data.keyData.isNull() &amp;&amp; data.primaryKeyData.isNull()) {</span>
<span class="line-added"> 865         if (auto getResult = cursor-&gt;iterateWithPrefetchedRecords(data.count, m_lastWriteOperationID)) {</span>
<span class="line-added"> 866             auto result = IDBResultData::iterateCursorSuccess(operation.identifier(), getResult.value());</span>
<span class="line-added"> 867             m_database-&gt;connectionProxy().iterateCursor(operation, { data.keyData, data.primaryKeyData, data.count, IndexedDB::CursorIterateOption::DoNotReply });</span>
<span class="line-added"> 868             operationCompletedOnServer(result, operation);</span>
<span class="line-added"> 869             return;</span>
<span class="line-added"> 870         }</span>
<span class="line-added"> 871     }</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873     cursor-&gt;clearPrefetchedRecords();</span>
<span class="line-added"> 874 </span>
<span class="line-added"> 875     ASSERT(data.option == IndexedDB::CursorIterateOption::Reply);</span>
 876     m_database-&gt;connectionProxy().iterateCursor(operation, data);
 877 }
 878 
 879 void IDBTransaction::didIterateCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 880 {
 881     LOG(IndexedDB, &quot;IDBTransaction::didIterateCursorOnServer&quot;);
<span class="line-modified"> 882     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 883 
 884     completeCursorRequest(request, resultData);
 885 }
 886 
<span class="line-modified"> 887 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllObjectStoreRecords(JSC::JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
 888 {
 889     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllObjectStoreRecords&quot;);
 890     ASSERT(isActive());
<span class="line-modified"> 891     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 892 
 893     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 894 
 895     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
 896     addRequest(request.get());
 897 
 898     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, objectStore.info().identifier(), 0 };
 899 
 900     LOG(IndexedDBOperations, &quot;IDB get all object store records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 901     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 902         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 903     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 904         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 905     }));
 906 
 907     return request;
 908 }
 909 
<span class="line-modified"> 910 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllIndexRecords(JSC::JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
 911 {
 912     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllIndexRecords&quot;);
 913     ASSERT(isActive());
<span class="line-modified"> 914     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 915 
 916     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 917 
 918     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
 919     addRequest(request.get());
 920 
 921     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, index.objectStore().info().identifier(), index.info().identifier() };
 922 
 923     LOG(IndexedDBOperations, &quot;IDB get all index records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 924     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 925         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 926     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 927         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 928     }));
 929 
 930     return request;
 931 }
 932 
 933 void IDBTransaction::getAllRecordsOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetAllRecordsData&amp; getAllRecordsData)
 934 {
 935     LOG(IndexedDB, &quot;IDBTransaction::getAllRecordsOnServer&quot;);
<span class="line-modified"> 936     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 937 
 938     m_database-&gt;connectionProxy().getAllRecords(operation, getAllRecordsData);
 939 }
 940 
 941 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 942 {
 943     LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
<span class="line-modified"> 944     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 945 
 946     if (resultData.type() == IDBResultType::Error) {
 947         completeNoncursorRequest(request, resultData);
 948         return;
 949     }
 950 
 951     ASSERT(resultData.type() == IDBResultType::GetAllRecordsSuccess);
 952 
 953     auto&amp; getAllResult = resultData.getAllResult();
 954     switch (getAllResult.type()) {
 955     case IndexedDB::GetAllType::Keys:
 956         request.setResult(getAllResult.keys());
 957         break;
 958     case IndexedDB::GetAllType::Values:
 959         request.setResult(getAllResult);
 960         break;
 961     }
 962 
 963     completeNoncursorRequest(request, resultData);
 964 }
 965 
<span class="line-modified"> 966 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)</span>
 967 {
 968     LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
 969     ASSERT(isActive());
 970     ASSERT(!getRecordData.keyRangeData.isNull);
<span class="line-modified"> 971     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 972 
 973     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 974 
 975     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
 976 
 977     auto request = IDBRequest::createObjectStoreGet(*scriptExecutionContext(), objectStore, type, *this);
 978     addRequest(request.get());
 979 
 980     LOG(IndexedDBOperations, &quot;IDB get record operation: %s %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
 981     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 982         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
 983     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
 984         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
 985     }));
 986 
 987     return request;
 988 }
 989 
<span class="line-modified"> 990 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetValue(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
 991 {
 992     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<span class="line-modified"> 993     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 994 
 995     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Value, range);
 996 }
 997 
<span class="line-modified"> 998 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetKey(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
 999 {
1000     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<span class="line-modified">1001     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1002 
1003     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Key, range);
1004 }
1005 
<span class="line-modified">1006 Ref&lt;IDBRequest&gt; IDBTransaction::requestIndexRecord(JSGlobalObject&amp; state, IDBIndex&amp; index, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range)</span>
1007 {
1008     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1009     ASSERT(isActive());
1010     ASSERT(!range.isNull);
<span class="line-modified">1011     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1012 
1013     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1014 
1015     auto request = IDBRequest::createIndexGet(*scriptExecutionContext(), index, type, *this);
1016     addRequest(request.get());
1017 
1018     IDBGetRecordData getRecordData = { range, IDBGetRecordDataType::KeyAndValue };
1019 
1020     LOG(IndexedDBOperations, &quot;IDB get index record operation: %s %s&quot;, index.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
1021     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1022         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
1023     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
1024         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
1025     }));
1026 
1027     return request;
1028 }
1029 
1030 void IDBTransaction::getRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetRecordData&amp; getRecordData)
1031 {
1032     LOG(IndexedDB, &quot;IDBTransaction::getRecordOnServer&quot;);
<span class="line-modified">1033     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1034 
1035     m_database-&gt;connectionProxy().getRecord(operation, getRecordData);
1036 }
1037 
1038 void IDBTransaction::didGetRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1039 {
1040     LOG(IndexedDB, &quot;IDBTransaction::didGetRecordOnServer&quot;);
<span class="line-modified">1041     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1042 
1043     if (resultData.type() == IDBResultType::Error) {
1044         completeNoncursorRequest(request, resultData);
1045         return;
1046     }
1047 
1048     ASSERT(resultData.type() == IDBResultType::GetRecordSuccess);
1049 
1050     bool useResultKey = request.sourceIndexIdentifier() &amp;&amp; request.requestedIndexRecordType() == IndexedDB::IndexRecordType::Key;
1051     if (!useResultKey)
1052         useResultKey = request.requestedObjectStoreRecordType() == IndexedDB::ObjectStoreRecordType::KeyOnly;
1053 
1054     const IDBGetResult&amp; result = resultData.getResult();
1055 
1056     if (useResultKey) {
1057         if (!result.keyData().isNull())
1058             request.setResult(result.keyData());
1059         else
1060             request.setResultToUndefined();
1061     } else {
1062         if (resultData.getResult().value().data().data())
1063             request.setResultToStructuredClone(resultData.getResult());
1064         else
1065             request.setResultToUndefined();
1066     }
1067 
1068     completeNoncursorRequest(request, resultData);
1069 }
1070 
<span class="line-modified">1071 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
1072 {
1073     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
1074     ASSERT(isActive());
1075     ASSERT(!range.isNull);
<span class="line-modified">1076     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1077 
1078     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1079 
1080     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1081     addRequest(request.get());
1082 
1083     LOG(IndexedDBOperations, &quot;IDB object store count operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1084     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1085         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1086     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1087         protectedThis-&gt;getCountOnServer(operation, range);
1088     }));
1089 
1090     return request;
1091 }
1092 
<span class="line-modified">1093 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
1094 {
1095     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBIndex)&quot;);
1096     ASSERT(isActive());
1097     ASSERT(!range.isNull);
<span class="line-modified">1098     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1099 
1100     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1101 
1102     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
1103     addRequest(request.get());
1104 
1105     LOG(IndexedDBOperations, &quot;IDB index count operation: %s, range %s&quot;, index.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1106     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1107         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1108     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1109         protectedThis-&gt;getCountOnServer(operation, range);
1110     }));
1111 
1112     return request;
1113 }
1114 
1115 void IDBTransaction::getCountOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1116 {
1117     LOG(IndexedDB, &quot;IDBTransaction::getCountOnServer&quot;);
<span class="line-modified">1118     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1119 
1120     m_database-&gt;connectionProxy().getCount(operation, keyRange);
1121 }
1122 
1123 void IDBTransaction::didGetCountOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1124 {
1125     LOG(IndexedDB, &quot;IDBTransaction::didGetCountOnServer&quot;);
<span class="line-modified">1126     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1127 
1128     request.setResult(resultData.resultInteger());
1129     completeNoncursorRequest(request, resultData);
1130 }
1131 
<span class="line-modified">1132 Ref&lt;IDBRequest&gt; IDBTransaction::requestDeleteRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
1133 {
1134     LOG(IndexedDB, &quot;IDBTransaction::requestDeleteRecord&quot;);
1135     ASSERT(isActive());
1136     ASSERT(!range.isNull);
<span class="line-modified">1137     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1138 
1139     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1140 
1141     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1142     addRequest(request.get());
1143 
1144     LOG(IndexedDBOperations, &quot;IDB delete record operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1145     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1146         protectedThis-&gt;didDeleteRecordOnServer(request.get(), result);
1147     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1148         protectedThis-&gt;deleteRecordOnServer(operation, range);
<span class="line-modified">1149     }), IsWriteOperation::Yes);</span>
1150     return request;
1151 }
1152 
1153 void IDBTransaction::deleteRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1154 {
1155     LOG(IndexedDB, &quot;IDBTransaction::deleteRecordOnServer&quot;);
<span class="line-modified">1156     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1157 
1158     m_database-&gt;connectionProxy().deleteRecord(operation, keyRange);
1159 }
1160 
1161 void IDBTransaction::didDeleteRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1162 {
1163     LOG(IndexedDB, &quot;IDBTransaction::didDeleteRecordOnServer&quot;);
<span class="line-modified">1164     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1165 
1166     request.setResultToUndefined();
1167     completeNoncursorRequest(request, resultData);
1168 }
1169 
<span class="line-modified">1170 Ref&lt;IDBRequest&gt; IDBTransaction::requestClearObjectStore(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore)</span>
1171 {
1172     LOG(IndexedDB, &quot;IDBTransaction::requestClearObjectStore&quot;);
1173     ASSERT(isActive());
<span class="line-modified">1174     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1175 
1176     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1177 
1178     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1179     addRequest(request.get());
1180 
1181     uint64_t objectStoreIdentifier = objectStore.info().identifier();
1182 
1183     LOG(IndexedDBOperations, &quot;IDB clear object store operation: %s&quot;, objectStore.info().condensedLoggingString().utf8().data());
1184     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1185         protectedThis-&gt;didClearObjectStoreOnServer(request.get(), result);
1186     }, [protectedThis = makeRef(*this), objectStoreIdentifier] (auto&amp; operation) {
1187         protectedThis-&gt;clearObjectStoreOnServer(operation, objectStoreIdentifier);
<span class="line-modified">1188     }), IsWriteOperation::Yes);</span>
1189 
1190     return request;
1191 }
1192 
1193 void IDBTransaction::clearObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier)
1194 {
1195     LOG(IndexedDB, &quot;IDBTransaction::clearObjectStoreOnServer&quot;);
<span class="line-modified">1196     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1197 
1198     m_database-&gt;connectionProxy().clearObjectStore(operation, objectStoreIdentifier);
1199 }
1200 
1201 void IDBTransaction::didClearObjectStoreOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1202 {
1203     LOG(IndexedDB, &quot;IDBTransaction::didClearObjectStoreOnServer&quot;);
<span class="line-modified">1204     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1205 
1206     request.setResultToUndefined();
1207     completeNoncursorRequest(request, resultData);
1208 }
1209 
<span class="line-modified">1210 Ref&lt;IDBRequest&gt; IDBTransaction::requestPutOrAdd(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, RefPtr&lt;IDBKey&gt;&amp;&amp; key, SerializedScriptValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)</span>
1211 {
1212     LOG(IndexedDB, &quot;IDBTransaction::requestPutOrAdd&quot;);
1213     ASSERT(isActive());
1214     ASSERT(!isReadOnly());
1215     ASSERT(objectStore.info().autoIncrement() || key);
<span class="line-modified">1216     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1217 
1218     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1219 
1220     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1221     addRequest(request.get());
1222 
1223     LOG(IndexedDBOperations, &quot;IDB putOrAdd operation: %s key: %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), key ? key-&gt;loggingString().utf8().data() : &quot;&lt;null key&gt;&quot;);
1224     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1225         protectedThis-&gt;didPutOrAddOnServer(request.get(), result);
1226     }, [protectedThis = makeRef(*this), key, value = makeRef(value), overwriteMode] (auto&amp; operation) {
1227         protectedThis-&gt;putOrAddOnServer(operation, key.get(), value.ptr(), overwriteMode);
<span class="line-modified">1228     }), IsWriteOperation::Yes);</span>
1229 
1230     return request;
1231 }
1232 
1233 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
1234 {
1235     LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
<span class="line-modified">1236     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
1237     ASSERT(!isReadOnly());
1238     ASSERT(value);
1239 
1240     if (!value-&gt;hasBlobURLs()) {
1241         m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
1242         return;
1243     }
1244 
1245     // Due to current limitations on our ability to post tasks back to a worker thread,
1246     // workers currently write blobs to disk synchronously.
1247     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
1248     if (!isMainThread()) {
<span class="line-modified">1249         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously();</span>
1250         if (idbValue.data().data())
1251             m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
1252         else {
1253             // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1254             // In that case, we cannot successfully store this record, so we callback with an error.
1255             RefPtr&lt;IDBClient::TransactionOperation&gt; protectedOperation(&amp;operation);
1256             auto result = IDBResultData::error(operation.identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1257             scriptExecutionContext()-&gt;postTask([protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)](ScriptExecutionContext&amp;) {
1258                 protectedOperation-&gt;doComplete(result);
1259             });
1260         }
1261         return;
1262     }
1263 
1264     // Since this request won&#39;t actually go to the server until the blob writes are complete,
1265     // stop future requests from going to the server ahead of it.
1266     operation.setNextRequestCanGoToServer(false);
1267 
<span class="line-modified">1268     value-&gt;writeBlobsToDiskForIndexedDB([protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {</span>
<span class="line-modified">1269         ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
1270         ASSERT(isMainThread());
1271         if (idbValue.data().data()) {
1272             m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
1273             return;
1274         }
1275 
1276         // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1277         // In that case, we cannot successfully store this record, so we callback with an error.
1278         auto result = IDBResultData::error(protectedOperation-&gt;identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1279         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)]() mutable {
1280             protectedOperation-&gt;doComplete(result);
1281         });
1282     });
1283 }
1284 
1285 void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1286 {
1287     LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
<span class="line-modified">1288     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1289 
1290     if (auto* result = resultData.resultKey())
1291         request.setResult(*result);
1292     else
1293         request.setResultToUndefined();
1294     completeNoncursorRequest(request, resultData);
1295 }
1296 
1297 void IDBTransaction::deleteObjectStore(const String&amp; objectStoreName)
1298 {
1299     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStore&quot;);
<span class="line-modified">1300     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1301     ASSERT(isVersionChange());
1302 
1303     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1304 
1305     if (auto objectStore = m_referencedObjectStores.take(objectStoreName)) {
1306         objectStore-&gt;markAsDeleted();
1307         auto identifier = objectStore-&gt;info().identifier();
1308         m_deletedObjectStores.set(identifier, WTFMove(objectStore));
1309     }
1310 
1311     LOG(IndexedDBOperations, &quot;IDB delete object store operation: %s&quot;, objectStoreName.utf8().data());
1312     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1313         protectedThis-&gt;didDeleteObjectStoreOnServer(result);
1314     }, [protectedThis = makeRef(*this), objectStoreName = objectStoreName.isolatedCopy()] (auto&amp; operation) {
1315         protectedThis-&gt;deleteObjectStoreOnServer(operation, objectStoreName);
<span class="line-modified">1316     }), IsWriteOperation::Yes);</span>
1317 }
1318 
1319 void IDBTransaction::deleteObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const String&amp; objectStoreName)
1320 {
1321     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStoreOnServer&quot;);
1322     ASSERT(isVersionChange());
<span class="line-modified">1323     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1324 
1325     m_database-&gt;connectionProxy().deleteObjectStore(operation, objectStoreName);
1326 }
1327 
1328 void IDBTransaction::didDeleteObjectStoreOnServer(const IDBResultData&amp; resultData)
1329 {
1330     LOG(IndexedDB, &quot;IDBTransaction::didDeleteObjectStoreOnServer&quot;);
<span class="line-modified">1331     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1332     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteObjectStoreSuccess || resultData.type() == IDBResultType::Error);
1333 }
1334 
1335 void IDBTransaction::deleteIndex(uint64_t objectStoreIdentifier, const String&amp; indexName)
1336 {
1337     LOG(IndexedDB, &quot;IDBTransaction::deleteIndex&quot;);
<span class="line-modified">1338     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1339     ASSERT(isVersionChange());
1340 
1341     LOG(IndexedDBOperations, &quot;IDB delete index operation: %s (%&quot; PRIu64 &quot;)&quot;, indexName.utf8().data(), objectStoreIdentifier);
1342     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1343         protectedThis-&gt;didDeleteIndexOnServer(result);
1344     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexName = indexName.isolatedCopy()] (auto&amp; operation) {
1345         protectedThis-&gt;deleteIndexOnServer(operation, objectStoreIdentifier, indexName);
<span class="line-modified">1346     }), IsWriteOperation::Yes);</span>
1347 }
1348 
1349 void IDBTransaction::deleteIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; indexName)
1350 {
1351     LOG(IndexedDB, &quot;IDBTransaction::deleteIndexOnServer&quot;);
1352     ASSERT(isVersionChange());
<span class="line-modified">1353     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1354 
1355     m_database-&gt;connectionProxy().deleteIndex(operation, objectStoreIdentifier, indexName);
1356 }
1357 
1358 void IDBTransaction::didDeleteIndexOnServer(const IDBResultData&amp; resultData)
1359 {
1360     LOG(IndexedDB, &quot;IDBTransaction::didDeleteIndexOnServer&quot;);
<span class="line-modified">1361     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1362     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteIndexSuccess || resultData.type() == IDBResultType::Error);
1363 }
1364 
1365 void IDBTransaction::operationCompletedOnClient(IDBClient::TransactionOperation&amp; operation)
1366 {
1367     LOG(IndexedDB, &quot;IDBTransaction::operationCompletedOnClient&quot;);
1368 
<span class="line-modified">1369     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-modified">1370     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));</span>
1371     ASSERT(m_transactionOperationMap.get(operation.identifier()) == &amp;operation);
1372     ASSERT(m_transactionOperationsInProgressQueue.first() == &amp;operation);
1373 
1374     m_transactionOperationMap.remove(operation.identifier());
1375     m_transactionOperationsInProgressQueue.removeFirst();
1376 
<span class="line-modified">1377     if (m_transactionOperationsInProgressQueue.isEmpty())</span>
<span class="line-added">1378         handlePendingOperations();</span>
<span class="line-added">1379 </span>
<span class="line-added">1380     autoCommit();</span>
1381 }
1382 
1383 void IDBTransaction::establishOnServer()
1384 {
1385     LOG(IndexedDB, &quot;IDBTransaction::establishOnServer&quot;);
<span class="line-modified">1386     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1387 
1388     m_database-&gt;connectionProxy().establishTransaction(*this);
1389 }
1390 
1391 void IDBTransaction::activate()
1392 {
<span class="line-modified">1393     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1394 
1395     if (isFinishedOrFinishing())
1396         return;
1397 
1398     m_state = IndexedDB::TransactionState::Active;
1399 }
1400 
1401 void IDBTransaction::deactivate()
1402 {
<span class="line-modified">1403     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1404 
1405     if (m_state == IndexedDB::TransactionState::Active)
1406         m_state = IndexedDB::TransactionState::Inactive;
1407 
<span class="line-modified">1408     autoCommit();</span>
1409 }
1410 
1411 void IDBTransaction::connectionClosedFromServer(const IDBError&amp; error)
1412 {
1413     LOG(IndexedDB, &quot;IDBTransaction::connectionClosedFromServer - %s&quot;, error.message().utf8().data());
1414 
1415     m_database-&gt;willAbortTransaction(*this);
1416     m_state = IndexedDB::TransactionState::Aborting;
1417 
<span class="line-added">1418     // Move operations out of m_pendingTransactionOperationQueue, otherwise we may start handling</span>
<span class="line-added">1419     // them after we forcibly complete in-progress transactions.</span>
<span class="line-added">1420     Deque&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; pendingTransactionOperationQueue;</span>
<span class="line-added">1421     pendingTransactionOperationQueue.swap(m_pendingTransactionOperationQueue);</span>
<span class="line-added">1422 </span>
1423     abortInProgressOperations(error);
1424 
1425     auto operations = copyToVector(m_transactionOperationMap.values());
1426     for (auto&amp; operation : operations) {
1427         m_currentlyCompletingRequest = nullptr;
1428         m_transactionOperationsInProgressQueue.append(operation.get());
1429         ASSERT(m_transactionOperationsInProgressQueue.first() == operation.get());
1430         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
1431     }
1432     m_currentlyCompletingRequest = nullptr;
<span class="line-added">1433     m_openRequests.clear();</span>
<span class="line-added">1434     pendingTransactionOperationQueue.clear();</span>
1435 
1436     connectionProxy().forgetActiveOperations(operations);
1437     connectionProxy().forgetTransaction(*this);
1438 

1439     m_abortQueue.clear();
1440     m_transactionOperationMap.clear();
1441 
1442     m_idbError = error;
1443     m_domError = error.toDOMException();
1444     m_database-&gt;didAbortTransaction(*this);
1445     fireOnAbort();
1446 }
1447 
1448 void IDBTransaction::visitReferencedObjectStores(JSC::SlotVisitor&amp; visitor) const
1449 {
1450     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1451     for (auto&amp; objectStore : m_referencedObjectStores.values())
1452         visitor.addOpaqueRoot(objectStore.get());
1453     for (auto&amp; objectStore : m_deletedObjectStores.values())
1454         visitor.addOpaqueRoot(objectStore.get());
1455 }
1456 
<span class="line-added">1457 void IDBTransaction::handlePendingOperations()</span>
<span class="line-added">1458 {</span>
<span class="line-added">1459     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added">1460 </span>
<span class="line-added">1461     if (!m_startedOnServer)</span>
<span class="line-added">1462         return;</span>
<span class="line-added">1463 </span>
<span class="line-added">1464     if (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_transactionOperationsInProgressQueue.last()-&gt;nextRequestCanGoToServer())</span>
<span class="line-added">1465         return;</span>
<span class="line-added">1466 </span>
<span class="line-added">1467     while (!m_pendingTransactionOperationQueue.isEmpty()) {</span>
<span class="line-added">1468         auto operation = m_pendingTransactionOperationQueue.takeFirst();</span>
<span class="line-added">1469         m_transactionOperationsInProgressQueue.append(operation.get());</span>
<span class="line-added">1470         operation-&gt;perform();</span>
<span class="line-added">1471 </span>
<span class="line-added">1472         if (!operation-&gt;nextRequestCanGoToServer())</span>
<span class="line-added">1473             break;</span>
<span class="line-added">1474     }</span>
<span class="line-added">1475 }</span>
<span class="line-added">1476 </span>
<span class="line-added">1477 void IDBTransaction::autoCommit()</span>
<span class="line-added">1478 {</span>
<span class="line-added">1479     // If transaction is not inactive, it&#39;s active, finished or finishing.</span>
<span class="line-added">1480     // If it&#39;s active, it may create new requests, so we cannot commit it.</span>
<span class="line-added">1481     if (m_state != IndexedDB::TransactionState::Inactive)</span>
<span class="line-added">1482         return;</span>
<span class="line-added">1483 </span>
<span class="line-added">1484     if (!m_startedOnServer)</span>
<span class="line-added">1485         return;</span>
<span class="line-added">1486 </span>
<span class="line-added">1487     if (!m_transactionOperationMap.isEmpty())</span>
<span class="line-added">1488         return;</span>
<span class="line-added">1489 </span>
<span class="line-added">1490     if (!m_openRequests.isEmpty())</span>
<span class="line-added">1491         return;</span>
<span class="line-added">1492     ASSERT(!m_currentlyCompletingRequest);</span>
<span class="line-added">1493 </span>
<span class="line-added">1494     commit();</span>
<span class="line-added">1495 }</span>
<span class="line-added">1496 </span>
<span class="line-added">1497 uint64_t IDBTransaction::generateOperationID()</span>
<span class="line-added">1498 {</span>
<span class="line-added">1499     static std::atomic&lt;uint64_t&gt; currentOperationID(1);</span>
<span class="line-added">1500     return currentOperationID += 1;</span>
<span class="line-added">1501 }</span>
<span class="line-added">1502 </span>
1503 } // namespace WebCore
1504 
1505 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="IDBRequestCompletionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBTransaction.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScriptExecutable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;BatchedTransitionOptimizer.h&quot;
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;Debugger.h&quot;
 31 #include &quot;EvalCodeBlock.h&quot;
 32 #include &quot;FunctionCodeBlock.h&quot;
 33 #include &quot;GlobalExecutable.h&quot;
 34 #include &quot;IsoCellSetInlines.h&quot;
 35 #include &quot;JIT.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;JSTemplateObjectDescriptor.h&quot;
 38 #include &quot;LLIntEntrypoint.h&quot;
 39 #include &quot;ModuleProgramCodeBlock.h&quot;
 40 #include &quot;Parser.h&quot;
 41 #include &quot;ProgramCodeBlock.h&quot;
 42 #include &quot;TypeProfiler.h&quot;
 43 #include &quot;VMInlines.h&quot;
 44 #include &lt;wtf/CommaPrinter.h&gt;
 45 
 46 namespace JSC {
 47 
 48 const ClassInfo ScriptExecutable::s_info = { &quot;ScriptExecutable&quot;, &amp;ExecutableBase::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ScriptExecutable) };
 49 
 50 ScriptExecutable::ScriptExecutable(Structure* structure, VM&amp; vm, const SourceCode&amp; source, bool isInStrictContext, DerivedContextType derivedContextType, bool isInArrowFunctionContext, EvalContextType evalContextType, Intrinsic intrinsic)
 51     : ExecutableBase(vm, structure)
 52     , m_source(source)
 53     , m_intrinsic(intrinsic)
 54     , m_features(isInStrictContext ? StrictModeFeature : 0)
 55     , m_hasCapturedVariables(false)
 56     , m_neverInline(false)
 57     , m_neverOptimize(false)
 58     , m_neverFTLOptimize(false)
 59     , m_isArrowFunctionContext(isInArrowFunctionContext)
 60     , m_canUseOSRExitFuzzing(true)
 61     , m_codeForGeneratorBodyWasGenerated(false)
 62     , m_derivedContextType(static_cast&lt;unsigned&gt;(derivedContextType))
 63     , m_evalContextType(static_cast&lt;unsigned&gt;(evalContextType))
 64 {
 65 }
 66 
 67 void ScriptExecutable::destroy(JSCell* cell)
 68 {
 69     static_cast&lt;ScriptExecutable*&gt;(cell)-&gt;ScriptExecutable::~ScriptExecutable();
 70 }
 71 
 72 void ScriptExecutable::clearCode(IsoCellSet&amp; clearableCodeSet)
 73 {
 74     m_jitCodeForCall = nullptr;
 75     m_jitCodeForConstruct = nullptr;
 76     m_jitCodeForCallWithArityCheck = MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt;();
 77     m_jitCodeForConstructWithArityCheck = MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt;();
 78 
 79     switch (type()) {
 80     case FunctionExecutableType: {
 81         FunctionExecutable* executable = static_cast&lt;FunctionExecutable*&gt;(this);
 82         executable-&gt;m_codeBlockForCall.clear();
 83         executable-&gt;m_codeBlockForConstruct.clear();
 84         break;
 85     }
 86     case EvalExecutableType: {
 87         EvalExecutable* executable = static_cast&lt;EvalExecutable*&gt;(this);
 88         executable-&gt;m_evalCodeBlock.clear();
 89         executable-&gt;m_unlinkedEvalCodeBlock.clear();
 90         break;
 91     }
 92     case ProgramExecutableType: {
 93         ProgramExecutable* executable = static_cast&lt;ProgramExecutable*&gt;(this);
 94         executable-&gt;m_programCodeBlock.clear();
 95         executable-&gt;m_unlinkedProgramCodeBlock.clear();
 96         break;
 97     }
 98     case ModuleProgramExecutableType: {
 99         ModuleProgramExecutable* executable = static_cast&lt;ModuleProgramExecutable*&gt;(this);
100         executable-&gt;m_moduleProgramCodeBlock.clear();
101         executable-&gt;m_unlinkedModuleProgramCodeBlock.clear();
102         executable-&gt;m_moduleEnvironmentSymbolTable.clear();
103         break;
104     }
105     default:
106         RELEASE_ASSERT_NOT_REACHED();
107         break;
108     }
109 
110     ASSERT(&amp;VM::SpaceAndSet::setFor(*subspace()) == &amp;clearableCodeSet);
111     clearableCodeSet.remove(this);
112 }
113 
114 void ScriptExecutable::installCode(CodeBlock* codeBlock)
115 {
116     installCode(codeBlock-&gt;vm(), codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());
117 }
118 
119 void ScriptExecutable::installCode(VM&amp; vm, CodeBlock* genericCodeBlock, CodeType codeType, CodeSpecializationKind kind)
120 {
121     if (genericCodeBlock)
122         CODEBLOCK_LOG_EVENT(genericCodeBlock, &quot;installCode&quot;, ());
123 
124     CodeBlock* oldCodeBlock = nullptr;
125 
126     switch (codeType) {
127     case GlobalCode: {
128         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
129         ProgramCodeBlock* codeBlock = static_cast&lt;ProgramCodeBlock*&gt;(genericCodeBlock);
130 
131         ASSERT(kind == CodeForCall);
132 
133         oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_programCodeBlock.get());
134         executable-&gt;m_programCodeBlock.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
135         break;
136     }
137 
138     case ModuleCode: {
139         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
140         ModuleProgramCodeBlock* codeBlock = static_cast&lt;ModuleProgramCodeBlock*&gt;(genericCodeBlock);
141 
142         ASSERT(kind == CodeForCall);
143 
144         oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_moduleProgramCodeBlock.get());
145         executable-&gt;m_moduleProgramCodeBlock.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
146         break;
147     }
148 
149     case EvalCode: {
150         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
151         EvalCodeBlock* codeBlock = static_cast&lt;EvalCodeBlock*&gt;(genericCodeBlock);
152 
153         ASSERT(kind == CodeForCall);
154 
155         oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_evalCodeBlock.get());
156         executable-&gt;m_evalCodeBlock.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
157         break;
158     }
159 
160     case FunctionCode: {
161         FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
162         FunctionCodeBlock* codeBlock = static_cast&lt;FunctionCodeBlock*&gt;(genericCodeBlock);
163 
164         switch (kind) {
165         case CodeForCall:
166             oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_codeBlockForCall.get());
167             executable-&gt;m_codeBlockForCall.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
168             break;
169         case CodeForConstruct:
170             oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_codeBlockForConstruct.get());
171             executable-&gt;m_codeBlockForConstruct.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
172             break;
173         }
174         break;
175     }
176     }
177 
178     switch (kind) {
179     case CodeForCall:
180         m_jitCodeForCall = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
181         m_jitCodeForCallWithArityCheck = nullptr;
182         break;
183     case CodeForConstruct:
184         m_jitCodeForConstruct = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
185         m_jitCodeForConstructWithArityCheck = nullptr;
186         break;
187     }
188 
189     auto&amp; clearableCodeSet = VM::SpaceAndSet::setFor(*subspace());
190     if (hasClearableCode(vm))
191         clearableCodeSet.add(this);
192     else
193         clearableCodeSet.remove(this);
194 
195     if (genericCodeBlock) {
196         RELEASE_ASSERT(genericCodeBlock-&gt;ownerExecutable() == this);
197         RELEASE_ASSERT(JITCode::isExecutableScript(genericCodeBlock-&gt;jitType()));
198 
<a name="1" id="anc1"></a><span class="line-modified">199         dataLogLnIf(Options::verboseOSR(), &quot;Installing &quot;, *genericCodeBlock);</span>

200 
201         if (UNLIKELY(vm.m_perBytecodeProfiler))
202             vm.m_perBytecodeProfiler-&gt;ensureBytecodesFor(genericCodeBlock);
203 
204         Debugger* debugger = genericCodeBlock-&gt;globalObject()-&gt;debugger();
205         if (UNLIKELY(debugger))
206             debugger-&gt;registerCodeBlock(genericCodeBlock);
207     }
208 
209     if (oldCodeBlock)
210         oldCodeBlock-&gt;unlinkIncomingCalls();
211 
212     vm.heap.writeBarrier(this);
213 }
214 
215 bool ScriptExecutable::hasClearableCode(VM&amp; vm) const
216 {
217     if (m_jitCodeForCall
218         || m_jitCodeForConstruct
219         || m_jitCodeForCallWithArityCheck
220         || m_jitCodeForConstructWithArityCheck)
221         return true;
222 
223     if (structure(vm)-&gt;classInfo() == FunctionExecutable::info()) {
224         auto* executable = static_cast&lt;const FunctionExecutable*&gt;(this);
225         if (executable-&gt;m_codeBlockForCall || executable-&gt;m_codeBlockForConstruct)
226             return true;
227 
228     } else if (structure(vm)-&gt;classInfo() == EvalExecutable::info()) {
229         auto* executable = static_cast&lt;const EvalExecutable*&gt;(this);
230         if (executable-&gt;m_evalCodeBlock || executable-&gt;m_unlinkedEvalCodeBlock)
231             return true;
232 
233     } else if (structure(vm)-&gt;classInfo() == ProgramExecutable::info()) {
234         auto* executable = static_cast&lt;const ProgramExecutable*&gt;(this);
235         if (executable-&gt;m_programCodeBlock || executable-&gt;m_unlinkedProgramCodeBlock)
236             return true;
237 
238     } else if (structure(vm)-&gt;classInfo() == ModuleProgramExecutable::info()) {
239         auto* executable = static_cast&lt;const ModuleProgramExecutable*&gt;(this);
240         if (executable-&gt;m_moduleProgramCodeBlock
241             || executable-&gt;m_unlinkedModuleProgramCodeBlock
242             || executable-&gt;m_moduleEnvironmentSymbolTable)
243             return true;
244     }
245     return false;
246 }
247 
248 CodeBlock* ScriptExecutable::newCodeBlockFor(
249     CodeSpecializationKind kind, JSFunction* function, JSScope* scope, Exception*&amp; exception)
250 {
251     VM&amp; vm = scope-&gt;vm();
252     auto throwScope = DECLARE_THROW_SCOPE(vm);
253 
254     ASSERT(vm.heap.isDeferred());
255     ASSERT(endColumn() != UINT_MAX);
256 
257     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);
<a name="2" id="anc2"></a>
258 
259     if (classInfo(vm) == EvalExecutable::info()) {
260         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
261         RELEASE_ASSERT(kind == CodeForCall);
262         RELEASE_ASSERT(!executable-&gt;m_evalCodeBlock);
263         RELEASE_ASSERT(!function);
264         auto codeBlock = EvalCodeBlock::create(vm,
265             executable, executable-&gt;m_unlinkedEvalCodeBlock.get(), scope);
266         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
267         if (!codeBlock) {
268             exception = throwException(
<a name="3" id="anc3"></a><span class="line-modified">269                 globalObject, throwScope,</span>
<span class="line-modified">270                 createOutOfMemoryError(globalObject));</span>
271             return nullptr;
272         }
273         return codeBlock;
274     }
275 
276     if (classInfo(vm) == ProgramExecutable::info()) {
277         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
278         RELEASE_ASSERT(kind == CodeForCall);
279         RELEASE_ASSERT(!executable-&gt;m_programCodeBlock);
280         RELEASE_ASSERT(!function);
281         auto codeBlock = ProgramCodeBlock::create(vm,
282             executable, executable-&gt;m_unlinkedProgramCodeBlock.get(), scope);
283         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
284         if (!codeBlock) {
285             exception = throwException(
<a name="4" id="anc4"></a><span class="line-modified">286                 globalObject, throwScope,</span>
<span class="line-modified">287                 createOutOfMemoryError(globalObject));</span>
288             return nullptr;
289         }
290         return codeBlock;
291     }
292 
293     if (classInfo(vm) == ModuleProgramExecutable::info()) {
294         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
295         RELEASE_ASSERT(kind == CodeForCall);
296         RELEASE_ASSERT(!executable-&gt;m_moduleProgramCodeBlock);
297         RELEASE_ASSERT(!function);
298         auto codeBlock = ModuleProgramCodeBlock::create(vm,
299             executable, executable-&gt;m_unlinkedModuleProgramCodeBlock.get(), scope);
300         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
301         if (!codeBlock) {
302             exception = throwException(
<a name="5" id="anc5"></a><span class="line-modified">303                 globalObject, throwScope,</span>
<span class="line-modified">304                 createOutOfMemoryError(globalObject));</span>
305             return nullptr;
306         }
307         return codeBlock;
308     }
309 
310     RELEASE_ASSERT(classInfo(vm) == FunctionExecutable::info());
311     RELEASE_ASSERT(function);
312     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
313     RELEASE_ASSERT(!executable-&gt;codeBlockFor(kind));
314     ParserError error;
315     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;defaultCodeGenerationMode();
316     // We continue using the same CodeGenerationMode for Generators because live generator objects can
317     // keep the state which is only valid with the CodeBlock compiled with the same CodeGenerationMode.
318     if (isGeneratorOrAsyncFunctionBodyParseMode(executable-&gt;parseMode())) {
319         if (!m_codeForGeneratorBodyWasGenerated) {
320             m_codeGenerationModeForGeneratorBody = codeGenerationMode;
321             m_codeForGeneratorBodyWasGenerated = true;
322         } else
323             codeGenerationMode = m_codeGenerationModeForGeneratorBody;
324     }
325     UnlinkedFunctionCodeBlock* unlinkedCodeBlock =
326         executable-&gt;m_unlinkedExecutable-&gt;unlinkedCodeBlockFor(
327             vm, executable-&gt;source(), kind, codeGenerationMode, error,
328             executable-&gt;parseMode());
329     recordParse(
330         executable-&gt;m_unlinkedExecutable-&gt;features(),
331         executable-&gt;m_unlinkedExecutable-&gt;hasCapturedVariables(),
332         lastLine(), endColumn());
333     if (!unlinkedCodeBlock) {
334         exception = throwException(
<a name="6" id="anc6"></a><span class="line-modified">335             globalObject, throwScope,</span>
336             error.toErrorObject(globalObject, executable-&gt;source()));
337         return nullptr;
338     }
339 
340     RELEASE_AND_RETURN(throwScope, FunctionCodeBlock::create(vm, executable, unlinkedCodeBlock, scope));
341 }
342 
343 CodeBlock* ScriptExecutable::newReplacementCodeBlockFor(
344     CodeSpecializationKind kind)
345 {
346     VM&amp; vm = this-&gt;vm();
347     if (classInfo(vm) == EvalExecutable::info()) {
348         RELEASE_ASSERT(kind == CodeForCall);
349         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
350         EvalCodeBlock* baseline = static_cast&lt;EvalCodeBlock*&gt;(
351             executable-&gt;codeBlock()-&gt;baselineVersion());
352         EvalCodeBlock* result = EvalCodeBlock::create(vm,
353             CodeBlock::CopyParsedBlock, *baseline);
354         result-&gt;setAlternative(vm, baseline);
355         return result;
356     }
357 
358     if (classInfo(vm) == ProgramExecutable::info()) {
359         RELEASE_ASSERT(kind == CodeForCall);
360         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
361         ProgramCodeBlock* baseline = static_cast&lt;ProgramCodeBlock*&gt;(
362             executable-&gt;codeBlock()-&gt;baselineVersion());
363         ProgramCodeBlock* result = ProgramCodeBlock::create(vm,
364             CodeBlock::CopyParsedBlock, *baseline);
365         result-&gt;setAlternative(vm, baseline);
366         return result;
367     }
368 
369     if (classInfo(vm) == ModuleProgramExecutable::info()) {
370         RELEASE_ASSERT(kind == CodeForCall);
371         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
372         ModuleProgramCodeBlock* baseline = static_cast&lt;ModuleProgramCodeBlock*&gt;(
373             executable-&gt;codeBlock()-&gt;baselineVersion());
374         ModuleProgramCodeBlock* result = ModuleProgramCodeBlock::create(vm,
375             CodeBlock::CopyParsedBlock, *baseline);
376         result-&gt;setAlternative(vm, baseline);
377         return result;
378     }
379 
380     RELEASE_ASSERT(classInfo(vm) == FunctionExecutable::info());
381     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
382     FunctionCodeBlock* baseline = static_cast&lt;FunctionCodeBlock*&gt;(
383         executable-&gt;codeBlockFor(kind)-&gt;baselineVersion());
384     FunctionCodeBlock* result = FunctionCodeBlock::create(vm,
385         CodeBlock::CopyParsedBlock, *baseline);
386     result-&gt;setAlternative(vm, baseline);
387     return result;
388 }
389 
390 static void setupLLInt(CodeBlock* codeBlock)
391 {
392     LLInt::setEntrypoint(codeBlock);
393 }
394 
395 static void setupJIT(VM&amp; vm, CodeBlock* codeBlock)
396 {
397 #if ENABLE(JIT)
398     CompilationResult result = JIT::compile(vm, codeBlock, JITCompilationMustSucceed);
399     RELEASE_ASSERT(result == CompilationSuccessful);
400 #else
401     UNUSED_PARAM(vm);
402     UNUSED_PARAM(codeBlock);
403     UNREACHABLE_FOR_PLATFORM();
404 #endif
405 }
406 
407 Exception* ScriptExecutable::prepareForExecutionImpl(
408     VM&amp; vm, JSFunction* function, JSScope* scope, CodeSpecializationKind kind, CodeBlock*&amp; resultCodeBlock)
409 {
410     auto throwScope = DECLARE_THROW_SCOPE(vm);
411     DeferGCForAWhile deferGC(vm.heap);
412 
413     if (UNLIKELY(vm.getAndClearFailNextNewCodeBlock())) {
<a name="7" id="anc7"></a><span class="line-modified">414         JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-modified">415         return throwException(globalObject, throwScope, createError(globalObject, &quot;Forced Failure&quot;_s));</span>
416     }
417 
418     Exception* exception = nullptr;
419     CodeBlock* codeBlock = newCodeBlockFor(kind, function, scope, exception);
420     resultCodeBlock = codeBlock;
421     EXCEPTION_ASSERT(!!throwScope.exception() == !codeBlock);
422     if (UNLIKELY(!codeBlock))
423         return exception;
424 
425     if (Options::validateBytecode())
426         codeBlock-&gt;validate();
427 
428     if (Options::useLLInt())
429         setupLLInt(codeBlock);
430     else
431         setupJIT(vm, codeBlock);
432 
433     installCode(vm, codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());
434     return nullptr;
435 }
436 
437 ScriptExecutable* ScriptExecutable::topLevelExecutable()
438 {
439     switch (type()) {
440     case FunctionExecutableType:
441         return jsCast&lt;FunctionExecutable*&gt;(this)-&gt;topLevelExecutable();
442     default:
443         return this;
444     }
445 }
446 
<a name="8" id="anc8"></a><span class="line-modified">447 JSArray* ScriptExecutable::createTemplateObject(JSGlobalObject* globalObject, JSTemplateObjectDescriptor* descriptor)</span>
448 {
<a name="9" id="anc9"></a><span class="line-modified">449     VM&amp; vm = globalObject-&gt;vm();</span>
450     auto scope = DECLARE_THROW_SCOPE(vm);
451 
452     TemplateObjectMap&amp; templateObjectMap = ensureTemplateObjectMap(vm);
453     TemplateObjectMap::AddResult result;
454     {
455         auto locker = holdLock(cellLock());
456         result = templateObjectMap.add(descriptor-&gt;endOffset(), WriteBarrier&lt;JSArray&gt;());
457     }
458     if (JSArray* array = result.iterator-&gt;value.get())
459         return array;
<a name="10" id="anc10"></a><span class="line-modified">460     JSArray* templateObject = descriptor-&gt;createTemplateObject(globalObject);</span>
461     RETURN_IF_EXCEPTION(scope, nullptr);
462     result.iterator-&gt;value.set(vm, this, templateObject);
463     return templateObject;
464 }
465 
466 auto ScriptExecutable::ensureTemplateObjectMapImpl(std::unique_ptr&lt;TemplateObjectMap&gt;&amp; dest) -&gt; TemplateObjectMap&amp;
467 {
468     if (dest)
469         return *dest;
470     auto result = makeUnique&lt;TemplateObjectMap&gt;();
471     WTF::storeStoreFence();
472     dest = WTFMove(result);
473     return *dest;
474 }
475 
476 auto ScriptExecutable::ensureTemplateObjectMap(VM&amp; vm) -&gt; TemplateObjectMap&amp;
477 {
478     switch (type()) {
479     case FunctionExecutableType:
480         return static_cast&lt;FunctionExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);
481     case EvalExecutableType:
482         return static_cast&lt;EvalExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);
483     case ProgramExecutableType:
484         return static_cast&lt;ProgramExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);
485     case ModuleProgramExecutableType:
486     default:
487         ASSERT(type() == ModuleProgramExecutableType);
488         return static_cast&lt;ModuleProgramExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);
489     }
490 }
491 
492 CodeBlockHash ScriptExecutable::hashFor(CodeSpecializationKind kind) const
493 {
494     return CodeBlockHash(source(), kind);
495 }
496 
497 Optional&lt;int&gt; ScriptExecutable::overrideLineNumber(VM&amp; vm) const
498 {
499     if (inherits&lt;FunctionExecutable&gt;(vm))
500         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;overrideLineNumber();
501     return WTF::nullopt;
502 }
503 
504 unsigned ScriptExecutable::typeProfilingStartOffset(VM&amp; vm) const
505 {
506     if (inherits&lt;FunctionExecutable&gt;(vm))
507         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;typeProfilingStartOffset(vm);
508     if (inherits&lt;EvalExecutable&gt;(vm))
509         return UINT_MAX;
510     return 0;
511 }
512 
513 unsigned ScriptExecutable::typeProfilingEndOffset(VM&amp; vm) const
514 {
515     if (inherits&lt;FunctionExecutable&gt;(vm))
516         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;typeProfilingEndOffset(vm);
517     if (inherits&lt;EvalExecutable&gt;(vm))
518         return UINT_MAX;
519     return source().length() - 1;
520 }
521 
522 void ScriptExecutable::recordParse(CodeFeatures features, bool hasCapturedVariables, int lastLine, unsigned endColumn)
523 {
524     switch (type()) {
525     case FunctionExecutableType:
526         // Since UnlinkedFunctionExecutable holds the information to calculate lastLine and endColumn, we do not need to remember them in ScriptExecutable&#39;s fields.
527         jsCast&lt;FunctionExecutable*&gt;(this)-&gt;recordParse(features, hasCapturedVariables);
528         return;
529     default:
530         jsCast&lt;GlobalExecutable*&gt;(this)-&gt;recordParse(features, hasCapturedVariables, lastLine, endColumn);
531         return;
532     }
533 }
534 
535 int ScriptExecutable::lastLine() const
536 {
537     switch (type()) {
538     case FunctionExecutableType:
539         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;lastLine();
540     default:
541         return jsCast&lt;const GlobalExecutable*&gt;(this)-&gt;lastLine();
542     }
543     return 0;
544 }
545 
546 unsigned ScriptExecutable::endColumn() const
547 {
548     switch (type()) {
549     case FunctionExecutableType:
550         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;endColumn();
551     default:
552         return jsCast&lt;const GlobalExecutable*&gt;(this)-&gt;endColumn();
553     }
554     return 0;
555 }
556 
557 } // namespace JSC
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
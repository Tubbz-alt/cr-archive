<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 117,10 ***</span>
<span class="line-new-header">--- 117,11 ---</span>
      Undetermined
  };
  
  enum class IndirectCompositingReason {
      None,
<span class="line-added">+     Clipping,</span>
      Stacking,
      OverflowScrollPositioning,
      Overlap,
      BackgroundLayer,
      GraphicalEffect, // opacity, mask, filter, transform etc.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,12 ***</span>
      const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
      const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
      ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
  };
  
  class RenderLayer final : public ScrollableArea {
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
      friend class RenderReplica;
      friend class RenderLayerFilters;
      friend class RenderLayerBacking;
      friend class RenderLayerCompositor;
<span class="line-new-header">--- 134,13 ---</span>
      const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
      const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
      ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
  };
  
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
  class RenderLayer final : public ScrollableArea {
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
  public:
      friend class RenderReplica;
      friend class RenderLayerFilters;
      friend class RenderLayerBacking;
      friend class RenderLayerCompositor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,10 ***</span>
<span class="line-new-header">--- 162,11 ---</span>
      RenderLayer* previousSibling() const { return m_previous; }
      RenderLayer* nextSibling() const { return m_next; }
      RenderLayer* firstChild() const { return m_first; }
      RenderLayer* lastChild() const { return m_last; }
      bool isDescendantOf(const RenderLayer&amp;) const;
<span class="line-added">+     RenderLayer* commonAncestorWithLayer(const RenderLayer&amp;) const;</span>
  
      // This does an ancestor tree walk. Avoid it!
      const RenderLayer* root() const
      {
          const RenderLayer* curr = this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,12 ***</span>
      }
  
      void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
      void removeChild(RenderLayer&amp;);
  
<span class="line-modified">!     void insertOnlyThisLayer();</span>
<span class="line-modified">!     void removeOnlyThisLayer();</span>
  
      bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
  
      // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.
      // Not all stacking contexts are CSS stacking contexts.
<span class="line-new-header">--- 176,16 ---</span>
      }
  
      void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
      void removeChild(RenderLayer&amp;);
  
<span class="line-modified">!     enum class LayerChangeTiming {</span>
<span class="line-modified">!         StyleChange,</span>
<span class="line-added">+         RenderTreeConstruction,</span>
<span class="line-added">+     };</span>
<span class="line-added">+     void insertOnlyThisLayer(LayerChangeTiming);</span>
<span class="line-added">+     void removeOnlyThisLayer(LayerChangeTiming);</span>
  
      bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
  
      // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.
      // Not all stacking contexts are CSS stacking contexts.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,11 ***</span>
      void dirtyStackingContextZOrderLists();
  
      bool normalFlowListDirty() const { return m_normalFlowListDirty; }
      bool zOrderListsDirty() const { return m_zOrderListsDirty; }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
      void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
  #endif
  
  private:
<span class="line-new-header">--- 210,11 ---</span>
      void dirtyStackingContextZOrderLists();
  
      bool normalFlowListDirty() const { return m_normalFlowListDirty; }
      bool zOrderListsDirty() const { return m_zOrderListsDirty; }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
      void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
  #endif
  
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,10 ***</span>
<span class="line-new-header">--- 437,12 ---</span>
      void panScrollFromPoint(const IntPoint&amp;);
  
      // Scrolling methods for layers that can scroll their overflow.
      void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
  
<span class="line-added">+     bool requestScrollPositionUpdate(const ScrollPosition&amp;, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) override;</span>
<span class="line-added">+ </span>
      WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);
  
      void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);
      void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 645,11 ***</span>
      enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
      void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
      LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
      LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
  
<span class="line-modified">!     int zIndex() const { return renderer().style().zIndex(); }</span>
  
      enum PaintLayerFlag {
          PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
          PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
          PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
<span class="line-new-header">--- 654,11 ---</span>
      enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
      void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
      LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
      LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
  
<span class="line-modified">!     int zIndex() const { return renderer().style().usedZIndex(); }</span>
  
      enum PaintLayerFlag {
          PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
          PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
          PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 787,10 ***</span>
<span class="line-new-header">--- 796,12 ---</span>
      bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
      bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
  
      void filterNeedsRepaint();
      bool hasFilter() const { return renderer().hasFilter(); }
<span class="line-added">+     bool hasFilterOutsets() const { return !filterOutsets().isZero(); }</span>
<span class="line-added">+     IntOutsets filterOutsets() const;</span>
      bool hasBackdropFilter() const
      {
  #if ENABLE(FILTERS_LEVEL_2)
          return renderer().hasBackdropFilter();
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 895,11 ***</span>
      bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
  
      void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
      bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
  
<span class="line-modified">!     WEBCORE_EXPORT bool isTransparentOrFullyClippedRespectingParentFrames() const;</span>
  
      void invalidateEventRegion();
  
  private:
  
<span class="line-new-header">--- 906,11 ---</span>
      bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
  
      void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
      bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
  
<span class="line-modified">!     WEBCORE_EXPORT bool isTransparentRespectingParentFrames() const;</span>
  
      void invalidateEventRegion();
  
  private:
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,12 ***</span>
  
      bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
  
      void updateZOrderLists();
      void rebuildZOrderLists();
<span class="line-modified">!     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);</span>
<span class="line-modified">!     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);</span>
      void clearZOrderLists();
  
      void updateNormalFlowList();
  
      struct LayerPaintingInfo {
<span class="line-new-header">--- 935,12 ---</span>
  
      bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
  
      void updateZOrderLists();
      void rebuildZOrderLists();
<span class="line-modified">!     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);</span>
<span class="line-modified">!     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);</span>
      void clearZOrderLists();
  
      void updateNormalFlowList();
  
      struct LayerPaintingInfo {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1236,12 ***</span>
      bool m_hasCompositedScrollableOverflow : 1;
  
      bool m_hasTransformedAncestor : 1;
      bool m_has3DTransformedAncestor : 1;
  
<span class="line-modified">!     unsigned m_indirectCompositingReason : 3;</span>
<span class="line-modified">!     unsigned m_viewportConstrainedNotCompositedReason : 2;</span>
  
  #if PLATFORM(IOS_FAMILY)
  #if ENABLE(IOS_TOUCH_EVENTS)
      bool m_registeredAsTouchEventListenerForScrolling : 1;
  #endif
<span class="line-new-header">--- 1247,12 ---</span>
      bool m_hasCompositedScrollableOverflow : 1;
  
      bool m_hasTransformedAncestor : 1;
      bool m_has3DTransformedAncestor : 1;
  
<span class="line-modified">!     unsigned m_indirectCompositingReason : 4; // IndirectCompositingReason</span>
<span class="line-modified">!     unsigned m_viewportConstrainedNotCompositedReason : 2; // ViewportConstrainedNotCompositedReason</span>
  
  #if PLATFORM(IOS_FAMILY)
  #if ENABLE(IOS_TOUCH_EVENTS)
      bool m_registeredAsTouchEventListenerForScrolling : 1;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1250,16 ***</span>
  
      bool m_requiresScrollPositionReconciliation : 1;
      bool m_containsDirtyOverlayScrollbars : 1;
      bool m_updatingMarqueePosition : 1;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      bool m_layerListMutationAllowed : 1;
  #endif
  
  #if ENABLE(CSS_COMPOSITING)
<span class="line-modified">!     unsigned m_blendMode : 5;</span>
      bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
      bool m_hasNotIsolatedBlendingDescendants : 1;
      bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
  #endif
  
<span class="line-new-header">--- 1261,16 ---</span>
  
      bool m_requiresScrollPositionReconciliation : 1;
      bool m_containsDirtyOverlayScrollbars : 1;
      bool m_updatingMarqueePosition : 1;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      bool m_layerListMutationAllowed : 1;
  #endif
  
  #if ENABLE(CSS_COMPOSITING)
<span class="line-modified">!     unsigned m_blendMode : 5; // BlendMode</span>
      bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
      bool m_hasNotIsolatedBlendingDescendants : 1;
      bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1358,11 ***</span>
  inline RenderLayer* RenderLayer::paintOrderParent() const
  {
      return m_isNormalFlowOnly ? m_parent : stackingContext();
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  class LayerListMutationDetector {
  public:
      LayerListMutationDetector(RenderLayer&amp; layer)
          : m_layer(layer)
          , m_previousMutationAllowedState(layer.layerListMutationAllowed())
<span class="line-new-header">--- 1369,11 ---</span>
  inline RenderLayer* RenderLayer::paintOrderParent() const
  {
      return m_isNormalFlowOnly ? m_parent : stackingContext();
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  class LayerListMutationDetector {
  public:
      LayerListMutationDetector(RenderLayer&amp; layer)
          : m_layer(layer)
          , m_previousMutationAllowedState(layer.layerListMutationAllowed())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1377,11 ***</span>
  
  private:
      RenderLayer&amp; m_layer;
      bool m_previousMutationAllowedState;
  };
<span class="line-modified">! #endif</span>
  
  void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
  
  bool compositedWithOwnBackingStore(const RenderLayer&amp;);
  
<span class="line-new-header">--- 1388,11 ---</span>
  
  private:
      RenderLayer&amp; m_layer;
      bool m_previousMutationAllowedState;
  };
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
  
  bool compositedWithOwnBackingStore(const RenderLayer&amp;);
  
</pre>
<center><a href="RenderLayer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
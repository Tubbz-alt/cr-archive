diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp
@@ -37,20 +37,20 @@
 ErrorInstance::ErrorInstance(VM& vm, Structure* structure)
     : Base(vm, structure)
 {
 }
 
-ErrorInstance* ErrorInstance::create(ExecState* state, Structure* structure, JSValue message, SourceAppender appender, RuntimeType type, bool useCurrentFrame)
+ErrorInstance* ErrorInstance::create(JSGlobalObject* globalObject, Structure* structure, JSValue message, SourceAppender appender, RuntimeType type, bool useCurrentFrame)
 {
-    VM& vm = state->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    String messageString = message.isUndefined() ? String() : message.toWTFString(state);
+    String messageString = message.isUndefined() ? String() : message.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, nullptr);
-    return create(state, vm, structure, messageString, appender, type, useCurrentFrame);
+    return create(globalObject, vm, structure, messageString, appender, type, useCurrentFrame);
 }
 
-static void appendSourceToError(CallFrame* callFrame, ErrorInstance* exception, unsigned bytecodeOffset)
+static void appendSourceToError(JSGlobalObject* globalObject, CallFrame* callFrame, ErrorInstance* exception, BytecodeIndex bytecodeIndex)
 {
     ErrorInstance::SourceAppender appender = exception->sourceAppender();
     exception->clearSourceAppender();
     RuntimeType type = exception->runtimeTypeForCause();
     exception->clearRuntimeTypeForCause();
@@ -69,25 +69,25 @@
     if (codeOrigin && codeOrigin.inlineCallFrame())
         codeBlock = baselineCodeBlockForInlineCallFrame(codeOrigin.inlineCallFrame());
     else
         codeBlock = callFrame->codeBlock();
 
-    codeBlock->expressionRangeForBytecodeOffset(bytecodeOffset, divotPoint, startOffset, endOffset, line, column);
+    codeBlock->expressionRangeForBytecodeIndex(bytecodeIndex, divotPoint, startOffset, endOffset, line, column);
 
     int expressionStart = divotPoint - startOffset;
     int expressionStop = divotPoint + endOffset;
 
     StringView sourceString = codeBlock->source().provider()->source();
     if (!expressionStop || expressionStart > static_cast<int>(sourceString.length()))
         return;
 
-    VM& vm = callFrame->vm();
+    VM& vm = globalObject->vm();
     JSValue jsMessage = exception->getDirect(vm, vm.propertyNames->message);
     if (!jsMessage || !jsMessage.isString())
         return;
 
-    String message = asString(jsMessage)->value(callFrame);
+    String message = asString(jsMessage)->value(globalObject);
     if (expressionStart < expressionStop)
         message = appender(message, codeBlock->source().provider()->getRange(expressionStart, expressionStop).toString(), type, ErrorInstance::FoundExactSource);
     else {
         // No range information, so give a few characters of context.
         int dataLength = sourceString.length();
@@ -107,46 +107,39 @@
     }
     exception->putDirect(vm, vm.propertyNames->message, jsString(vm, message));
 
 }
 
-void ErrorInstance::finishCreation(ExecState* exec, VM& vm, const String& message, bool useCurrentFrame)
+void ErrorInstance::finishCreation(JSGlobalObject* globalObject, VM& vm, const String& message, bool useCurrentFrame)
 {
     Base::finishCreation(vm);
     ASSERT(inherits(vm, info()));
     if (!message.isNull())
         putDirect(vm, vm.propertyNames->message, jsString(vm, message), static_cast<unsigned>(PropertyAttribute::DontEnum));
 
-    std::unique_ptr<Vector<StackFrame>> stackTrace = getStackTrace(exec, vm, this, useCurrentFrame);
+    std::unique_ptr<Vector<StackFrame>> stackTrace = getStackTrace(globalObject, vm, this, useCurrentFrame);
     {
         auto locker = holdLock(cellLock());
         m_stackTrace = WTFMove(stackTrace);
     }
     vm.heap.writeBarrier(this);
 
     if (m_stackTrace && !m_stackTrace->isEmpty() && hasSourceAppender()) {
-        unsigned bytecodeOffset;
+        BytecodeIndex bytecodeIndex;
         CallFrame* callFrame;
-        getBytecodeOffset(exec, vm, m_stackTrace.get(), callFrame, bytecodeOffset);
-        if (callFrame && callFrame->codeBlock()) {
-            ASSERT(!callFrame->callee().isWasm());
-            appendSourceToError(callFrame, this, bytecodeOffset);
-        }
+        getBytecodeIndex(vm, vm.topCallFrame, m_stackTrace.get(), callFrame, bytecodeIndex);
+        if (callFrame && callFrame->codeBlock() && !callFrame->callee().isWasm())
+            appendSourceToError(globalObject, callFrame, this, bytecodeIndex);
     }
 }
 
-void ErrorInstance::destroy(JSCell* cell)
-{
-    static_cast<ErrorInstance*>(cell)->ErrorInstance::~ErrorInstance();
-}
-
 // Based on ErrorPrototype's errorProtoFuncToString(), but is modified to
 // have no observable side effects to the user (i.e. does not call proxies,
 // and getters).
-String ErrorInstance::sanitizedToString(ExecState* exec)
+String ErrorInstance::sanitizedToString(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     JSValue nameValue;
     auto namePropertName = vm.propertyNames->name;
     PropertySlot nameSlot(this, PropertySlot::InternalMethodType::VMInquiry);
@@ -157,38 +150,38 @@
     // We only check the current object and its prototype (2 levels) because normal
     // Error objects may have a name property, and if not, its prototype should have
     // a name property for the type of error e.g. "SyntaxError".
     while (currentObj.isCell() && prototypeDepth++ < 2) {
         JSObject* obj = jsCast<JSObject*>(currentObj);
-        if (JSObject::getOwnPropertySlot(obj, exec, namePropertName, nameSlot) && nameSlot.isValue()) {
-            nameValue = nameSlot.getValue(exec, namePropertName);
+        if (JSObject::getOwnPropertySlot(obj, globalObject, namePropertName, nameSlot) && nameSlot.isValue()) {
+            nameValue = nameSlot.getValue(globalObject, namePropertName);
             break;
         }
         currentObj = obj->getPrototypeDirect(vm);
     }
     scope.assertNoException();
 
     String nameString;
     if (!nameValue)
         nameString = "Error"_s;
     else {
-        nameString = nameValue.toWTFString(exec);
+        nameString = nameValue.toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, String());
     }
 
     JSValue messageValue;
     auto messagePropertName = vm.propertyNames->message;
     PropertySlot messageSlot(this, PropertySlot::InternalMethodType::VMInquiry);
-    if (JSObject::getOwnPropertySlot(this, exec, messagePropertName, messageSlot) && messageSlot.isValue())
-        messageValue = messageSlot.getValue(exec, messagePropertName);
+    if (JSObject::getOwnPropertySlot(this, globalObject, messagePropertName, messageSlot) && messageSlot.isValue())
+        messageValue = messageSlot.getValue(globalObject, messagePropertName);
     scope.assertNoException();
 
     String messageString;
     if (!messageValue)
         messageString = String();
     else {
-        messageString = messageValue.toWTFString(exec);
+        messageString = messageValue.toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, String());
     }
 
     if (!nameString.length())
         return messageString;
@@ -236,16 +229,18 @@
         return false;
 
     computeErrorInfo(vm);
 
     if (!m_stackString.isNull()) {
-        putDirect(vm, vm.propertyNames->line, jsNumber(m_line));
-        putDirect(vm, vm.propertyNames->column, jsNumber(m_column));
+        auto attributes = static_cast<unsigned>(PropertyAttribute::DontEnum);
+
+        putDirect(vm, vm.propertyNames->line, jsNumber(m_line), attributes);
+        putDirect(vm, vm.propertyNames->column, jsNumber(m_column), attributes);
         if (!m_sourceURL.isEmpty())
-            putDirect(vm, vm.propertyNames->sourceURL, jsString(vm, WTFMove(m_sourceURL)));
+            putDirect(vm, vm.propertyNames->sourceURL, jsString(vm, WTFMove(m_sourceURL)), attributes);
 
-        putDirect(vm, vm.propertyNames->stack, jsString(vm, WTFMove(m_stackString)), static_cast<unsigned>(PropertyAttribute::DontEnum));
+        putDirect(vm, vm.propertyNames->stack, jsString(vm, WTFMove(m_stackString)), attributes);
     }
 
     m_errorInfoMaterialized = true;
     return true;
 }
@@ -258,56 +253,56 @@
         || propertyName == vm.propertyNames->stack)
         return materializeErrorInfoIfNeeded(vm);
     return false;
 }
 
-bool ErrorInstance::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
+bool ErrorInstance::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ErrorInstance* thisObject = jsCast<ErrorInstance*>(object);
     thisObject->materializeErrorInfoIfNeeded(vm, propertyName);
-    return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);
+    return Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 }
 
-void ErrorInstance::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray& propertyNameArray, EnumerationMode enumerationMode)
+void ErrorInstance::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& propertyNameArray, EnumerationMode enumerationMode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ErrorInstance* thisObject = jsCast<ErrorInstance*>(object);
     thisObject->materializeErrorInfoIfNeeded(vm);
-    Base::getOwnNonIndexPropertyNames(thisObject, exec, propertyNameArray, enumerationMode);
+    Base::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNameArray, enumerationMode);
 }
 
-void ErrorInstance::getStructurePropertyNames(JSObject* object, ExecState* exec, PropertyNameArray& propertyNameArray, EnumerationMode enumerationMode)
+void ErrorInstance::getStructurePropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& propertyNameArray, EnumerationMode enumerationMode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ErrorInstance* thisObject = jsCast<ErrorInstance*>(object);
     thisObject->materializeErrorInfoIfNeeded(vm);
-    Base::getStructurePropertyNames(thisObject, exec, propertyNameArray, enumerationMode);
+    Base::getStructurePropertyNames(thisObject, globalObject, propertyNameArray, enumerationMode);
 }
 
-bool ErrorInstance::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor& descriptor, bool shouldThrow)
+bool ErrorInstance::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor& descriptor, bool shouldThrow)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ErrorInstance* thisObject = jsCast<ErrorInstance*>(object);
     thisObject->materializeErrorInfoIfNeeded(vm, propertyName);
-    return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);
+    return Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);
 }
 
-bool ErrorInstance::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+bool ErrorInstance::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ErrorInstance* thisObject = jsCast<ErrorInstance*>(cell);
     bool materializedProperties = thisObject->materializeErrorInfoIfNeeded(vm, propertyName);
     if (materializedProperties)
         slot.disableCaching();
-    return Base::put(thisObject, exec, propertyName, value, slot);
+    return Base::put(thisObject, globalObject, propertyName, value, slot);
 }
 
-bool ErrorInstance::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
+bool ErrorInstance::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ErrorInstance* thisObject = jsCast<ErrorInstance*>(cell);
     thisObject->materializeErrorInfoIfNeeded(vm, propertyName);
-    return Base::deleteProperty(thisObject, exec, propertyName);
+    return Base::deleteProperty(thisObject, globalObject, propertyName);
 }
 
 } // namespace JSC

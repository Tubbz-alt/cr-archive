<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  3  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  4  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ImageBuffer.h&quot;
 30 
 31 #include &quot;ColorUtilities.h&quot;
 32 #include &quot;GraphicsContext.h&quot;
 33 #include &quot;IntRect.h&quot;
 34 #include &lt;wtf/IsoMallocInlines.h&gt;
 35 #include &lt;wtf/MathExtras.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 static const float MaxClampedLength = 4096;
 40 static const float MaxClampedArea = MaxClampedLength * MaxClampedLength;
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(ImageBuffer);
 43 
 44 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::create(const FloatSize&amp; size, RenderingMode renderingMode, float resolutionScale, ColorSpace colorSpace, const HostWindow* hostWindow)
 45 {
 46     bool success = false;
 47     std::unique_ptr&lt;ImageBuffer&gt; buffer(new ImageBuffer(size, resolutionScale, colorSpace, renderingMode, hostWindow, success));
 48     if (!success)
 49         return nullptr;
 50     return buffer;
 51 }
 52 
 53 #if USE(DIRECT2D)
 54 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::create(const FloatSize&amp; size, RenderingMode renderingMode, const GraphicsContext* targetContext, float resolutionScale, ColorSpace colorSpace, const HostWindow* hostWindow)
 55 {
 56     bool success = false;
 57     std::unique_ptr&lt;ImageBuffer&gt; buffer(new ImageBuffer(size, resolutionScale, colorSpace, renderingMode, hostWindow, targetContext, success));
 58     if (!success)
 59         return nullptr;
 60     return buffer;
 61 }
 62 #endif
 63 
 64 bool ImageBuffer::sizeNeedsClamping(const FloatSize&amp; size)
 65 {
 66     if (size.isEmpty())
 67         return false;
 68 
 69     return floorf(size.height()) * floorf(size.width()) &gt; MaxClampedArea;
 70 }
 71 
 72 bool ImageBuffer::sizeNeedsClamping(const FloatSize&amp; size, FloatSize&amp; scale)
 73 {
 74     FloatSize scaledSize(size);
 75     scaledSize.scale(scale.width(), scale.height());
 76 
 77     if (!sizeNeedsClamping(scaledSize))
 78         return false;
 79 
 80     // The area of scaled size is bigger than the upper limit, adjust the scale to fit.
 81     scale.scale(sqrtf(MaxClampedArea / (scaledSize.width() * scaledSize.height())));
 82     ASSERT(!sizeNeedsClamping(size, scale));
 83     return true;
 84 }
 85 
 86 FloatSize ImageBuffer::clampedSize(const FloatSize&amp; size)
 87 {
 88     return size.shrunkTo(FloatSize(MaxClampedLength, MaxClampedLength));
 89 }
 90 
 91 FloatSize ImageBuffer::clampedSize(const FloatSize&amp; size, FloatSize&amp; scale)
 92 {
 93     if (size.isEmpty())
 94         return size;
 95 
 96     FloatSize clampedSize = ImageBuffer::clampedSize(size);
 97     scale = clampedSize / size;
 98     ASSERT(!sizeNeedsClamping(clampedSize));
 99     ASSERT(!sizeNeedsClamping(size, scale));
100     return clampedSize;
101 }
102 
103 FloatRect ImageBuffer::clampedRect(const FloatRect&amp; rect)
104 {
105     return FloatRect(rect.location(), clampedSize(rect.size()));
106 }
107 
108 #if !USE(CG) &amp;&amp; !USE(CAIRO)
109 Vector&lt;uint8_t&gt; ImageBuffer::toBGRAData() const
110 {
111     // FIXME: Implement this for other backends.
112     return { };
113 }
114 #endif
115 
116 #if !(USE(CG) || USE(DIRECT2D))
<a name="1" id="anc1"></a>





117 void ImageBuffer::transformColorSpace(ColorSpace srcColorSpace, ColorSpace dstColorSpace)
118 {
119     if (srcColorSpace == dstColorSpace)
120         return;
121 
122     // only sRGB &lt;-&gt; linearRGB are supported at the moment
<a name="2" id="anc2"></a><span class="line-modified">123     if ((srcColorSpace != ColorSpace::LinearRGB &amp;&amp; srcColorSpace != ColorSpace::SRGB)</span>
<span class="line-modified">124         || (dstColorSpace != ColorSpace::LinearRGB &amp;&amp; dstColorSpace != ColorSpace::SRGB))</span>
125         return;
126 
<a name="3" id="anc3"></a><span class="line-modified">127     if (dstColorSpace == ColorSpace::LinearRGB) {</span>
128         static const std::array&lt;uint8_t, 256&gt; linearRgbLUT = [] {
129             std::array&lt;uint8_t, 256&gt; array;
130             for (unsigned i = 0; i &lt; 256; i++) {
131                 float color = i / 255.0f;
132                 color = sRGBToLinearColorComponent(color);
133                 array[i] = static_cast&lt;uint8_t&gt;(round(color * 255));
134             }
135             return array;
136         }();
137         platformTransformColorSpace(linearRgbLUT);
<a name="4" id="anc4"></a><span class="line-modified">138     } else if (dstColorSpace == ColorSpace::SRGB) {</span>
139         static const std::array&lt;uint8_t, 256&gt; deviceRgbLUT= [] {
140             std::array&lt;uint8_t, 256&gt; array;
141             for (unsigned i = 0; i &lt; 256; i++) {
142                 float color = i / 255.0f;
143                 color = linearToSRGBColorComponent(color);
144                 array[i] = static_cast&lt;uint8_t&gt;(round(color * 255));
145             }
146             return array;
147         }();
148         platformTransformColorSpace(deviceRgbLUT);
149     }
150 }
151 
152 #endif // USE(CG)
153 
154 inline void ImageBuffer::genericConvertToLuminanceMask()
155 {
156     IntRect luminanceRect(IntPoint(), internalSize());
157     auto srcPixelArray = getUnmultipliedImageData(luminanceRect);
158     if (!srcPixelArray)
159         return;
160 
161     unsigned pixelArrayLength = srcPixelArray-&gt;length();
162     for (unsigned pixelOffset = 0; pixelOffset &lt; pixelArrayLength; pixelOffset += 4) {
163         uint8_t a = srcPixelArray-&gt;item(pixelOffset + 3);
164         if (!a)
165             continue;
166         uint8_t r = srcPixelArray-&gt;item(pixelOffset);
167         uint8_t g = srcPixelArray-&gt;item(pixelOffset + 1);
168         uint8_t b = srcPixelArray-&gt;item(pixelOffset + 2);
169 
170         double luma = (r * 0.2125 + g * 0.7154 + b * 0.0721) * ((double)a / 255.0);
171         srcPixelArray-&gt;set(pixelOffset + 3, luma);
172     }
173     putByteArray(*srcPixelArray, AlphaPremultiplication::Unpremultiplied, luminanceRect.size(), luminanceRect, IntPoint());
174 }
175 
176 void ImageBuffer::convertToLuminanceMask()
177 {
178     // Add platform specific functions with platformConvertToLuminanceMask here later.
179     genericConvertToLuminanceMask();
180 }
181 
182 #if !USE(CAIRO)
183 PlatformLayer* ImageBuffer::platformLayer() const
184 {
185     return 0;
186 }
187 
<a name="5" id="anc5"></a><span class="line-modified">188 bool ImageBuffer::copyToPlatformTexture(GraphicsContextGLOpenGL&amp;, GCGLenum, PlatformGLObject, GCGLenum, bool, bool)</span>
189 {
190     return false;
191 }
192 #endif
193 
194 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::copyRectToBuffer(const FloatRect&amp; rect, ColorSpace colorSpace, const GraphicsContext&amp; context)
195 {
196     if (rect.isEmpty())
197         return nullptr;
198 
199     IntSize scaledSize = ImageBuffer::compatibleBufferSize(rect.size(), context);
200 
201     auto buffer = ImageBuffer::createCompatibleBuffer(scaledSize, 1, colorSpace, context);
202     if (!buffer)
203         return nullptr;
204 
205     buffer-&gt;context().drawImageBuffer(*this, -rect.location());
206     return buffer;
207 }
208 
209 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::createCompatibleBuffer(const FloatSize&amp; size, ColorSpace colorSpace, const GraphicsContext&amp; context)
210 {
211     if (size.isEmpty())
212         return nullptr;
213 
214     IntSize scaledSize = ImageBuffer::compatibleBufferSize(size, context);
215 
216     auto buffer = ImageBuffer::createCompatibleBuffer(scaledSize, 1, colorSpace, context);
217     if (!buffer)
218         return nullptr;
219 
220     // Set up a corresponding scale factor on the graphics context.
221     buffer-&gt;context().scale(scaledSize / size);
222     return buffer;
223 }
224 
225 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::createCompatibleBuffer(const FloatSize&amp; size, float resolutionScale, ColorSpace colorSpace, const GraphicsContext&amp; context)
226 {
227 #if USE(DIRECT2D)
228     return create(size, context.renderingMode(), &amp;context, resolutionScale, colorSpace);
229 #else
230     return create(size, context.renderingMode(), resolutionScale, colorSpace);
231 #endif
232 }
233 
234 IntSize ImageBuffer::compatibleBufferSize(const FloatSize&amp; size, const GraphicsContext&amp; context)
235 {
236     // Enlarge the buffer size if the context&#39;s transform is scaling it so we need a higher
237     // resolution than one pixel per unit.
238     return expandedIntSize(size * context.scaleFactor());
239 }
240 
<a name="6" id="anc6"></a>




241 #if !USE(IOSURFACE_CANVAS_BACKING_STORE)
242 size_t ImageBuffer::memoryCost() const
243 {
244     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful about what data we access here and how.
245     // It&#39;s safe to access internalSize() because it doesn&#39;t do any pointer chasing.
246     return 4 * internalSize().width() * internalSize().height();
247 }
248 
249 size_t ImageBuffer::externalMemoryCost() const
250 {
251     return 0;
252 }
253 #endif
254 
255 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
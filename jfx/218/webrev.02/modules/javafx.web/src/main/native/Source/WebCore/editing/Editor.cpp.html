<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Editor.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;AlternativeTextController.h&quot;
  32 #include &quot;ApplyStyleCommand.h&quot;
  33 #include &quot;CSSComputedStyleDeclaration.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValueList.h&quot;
  36 #include &quot;CSSValuePool.h&quot;
  37 #include &quot;CachedResourceLoader.h&quot;
  38 #include &quot;ChangeListTypeCommand.h&quot;
  39 #include &quot;ClipboardEvent.h&quot;
  40 #include &quot;CompositionEvent.h&quot;
  41 #include &quot;CompositionHighlight.h&quot;
  42 #include &quot;CreateLinkCommand.h&quot;
  43 #include &quot;CustomUndoStep.h&quot;
  44 #include &quot;DataTransfer.h&quot;
  45 #include &quot;DeleteSelectionCommand.h&quot;
  46 #include &quot;DictationAlternative.h&quot;
  47 #include &quot;DictationCommand.h&quot;
  48 #include &quot;DocumentFragment.h&quot;
  49 #include &quot;DocumentMarkerController.h&quot;
  50 #include &quot;Editing.h&quot;
  51 #include &quot;EditorClient.h&quot;
  52 #include &quot;EventHandler.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;File.h&quot;
  55 #include &quot;FocusController.h&quot;
  56 #include &quot;FontAttributes.h&quot;
  57 #include &quot;Frame.h&quot;
  58 #include &quot;FrameLoader.h&quot;
  59 #include &quot;FrameTree.h&quot;
  60 #include &quot;FrameView.h&quot;
  61 #include &quot;GraphicsContext.h&quot;
  62 #include &quot;HTMLAttachmentElement.h&quot;
  63 #include &quot;HTMLBRElement.h&quot;
  64 #include &quot;HTMLCollection.h&quot;
  65 #include &quot;HTMLFormControlElement.h&quot;
  66 #include &quot;HTMLFrameOwnerElement.h&quot;
  67 #include &quot;HTMLImageElement.h&quot;
  68 #include &quot;HTMLInputElement.h&quot;
  69 #include &quot;HTMLNames.h&quot;
  70 #include &quot;HTMLOListElement.h&quot;
  71 #include &quot;HTMLQuoteElement.h&quot;
  72 #include &quot;HTMLSpanElement.h&quot;
  73 #include &quot;HTMLUListElement.h&quot;
  74 #include &quot;HitTestResult.h&quot;
  75 #include &quot;IndentOutdentCommand.h&quot;
  76 #include &quot;InputEvent.h&quot;
  77 #include &quot;InsertEditableImageCommand.h&quot;
  78 #include &quot;InsertListCommand.h&quot;
  79 #include &quot;InsertTextCommand.h&quot;
  80 #include &quot;KeyboardEvent.h&quot;
  81 #include &quot;Logging.h&quot;
  82 #include &quot;ModifySelectionListLevel.h&quot;
  83 #include &quot;NodeList.h&quot;
  84 #include &quot;NodeTraversal.h&quot;
  85 #include &quot;Page.h&quot;
  86 #include &quot;Pasteboard.h&quot;
  87 #include &quot;Range.h&quot;
  88 #include &quot;RemoveFormatCommand.h&quot;
  89 #include &quot;RenderBlock.h&quot;
  90 #include &quot;RenderLayer.h&quot;
  91 #include &quot;RenderTextControl.h&quot;
  92 #include &quot;RenderedDocumentMarker.h&quot;
  93 #include &quot;RenderedPosition.h&quot;
  94 #include &quot;ReplaceRangeWithTextCommand.h&quot;
  95 #include &quot;ReplaceSelectionCommand.h&quot;
  96 #include &quot;RuntimeEnabledFeatures.h&quot;
  97 #include &quot;SerializedAttachmentData.h&quot;
  98 #include &quot;Settings.h&quot;
  99 #include &quot;ShadowRoot.h&quot;
 100 #include &quot;SharedBuffer.h&quot;
 101 #include &quot;SimplifyMarkupCommand.h&quot;
 102 #include &quot;SpellChecker.h&quot;
 103 #include &quot;SpellingCorrectionCommand.h&quot;
 104 #include &quot;StaticPasteboard.h&quot;
 105 #include &quot;StyleProperties.h&quot;
 106 #include &quot;TelephoneNumberDetector.h&quot;
 107 #include &quot;Text.h&quot;
 108 #include &quot;TextCheckerClient.h&quot;
 109 #include &quot;TextCheckingHelper.h&quot;
 110 #include &quot;TextEvent.h&quot;
 111 #include &quot;TextIterator.h&quot;
 112 #include &quot;TypingCommand.h&quot;
 113 #include &quot;UserTypingGestureIndicator.h&quot;
 114 #include &quot;VisibleUnits.h&quot;
 115 #include &quot;markup.h&quot;
 116 #include &lt;pal/FileSizeFormatter.h&gt;
 117 #include &lt;pal/system/Sound.h&gt;
 118 #include &lt;pal/text/KillRing.h&gt;
 119 #include &lt;wtf/unicode/CharacterNames.h&gt;
 120 
 121 #if PLATFORM(MAC)
 122 #include &quot;ServicesOverlayController.h&quot;
 123 #endif
 124 
 125 namespace WebCore {
 126 
 127 static bool dispatchBeforeInputEvent(Element&amp; element, const AtomString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)
 128 {
 129     if (!element.document().settings().inputEventsEnabled())
 130         return true;
 131 
 132     auto event = InputEvent::create(eventNames().beforeinputEvent, inputType, cancelable, element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0);
 133     element.dispatchEvent(event);
 134     return !event-&gt;defaultPrevented();
 135 }
 136 
 137 static void dispatchInputEvent(Element&amp; element, const AtomString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })
 138 {
 139     if (element.document().settings().inputEventsEnabled()) {
 140         // FIXME: We should not be dispatching to the scoped queue here. Normally, input events are dispatched in CompositeEditCommand::apply after the end of the scope,
 141         // but TypingCommands are special in that existing TypingCommands that are applied again fire input events *from within* the scope by calling typingAddedToOpenCommand.
 142         // Instead, TypingCommands should always dispatch events synchronously after the end of the scoped queue in CompositeEditCommand::apply. To work around this for the
 143         // time being, just revert back to calling dispatchScopedEvent.
 144         element.dispatchScopedEvent(InputEvent::create(eventNames().inputEvent, inputType, Event::IsCancelable::No,
 145             element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0));
 146     } else
 147         element.dispatchInputEvent();
 148 }
 149 
 150 static String inputEventDataForEditingStyleAndAction(const StyleProperties* style, EditAction action)
 151 {
 152     if (!style)
 153         return { };
 154 
 155     switch (action) {
 156     case EditAction::SetColor:
 157         return style-&gt;getPropertyValue(CSSPropertyColor);
 158     case EditAction::SetInlineWritingDirection:
 159     case EditAction::SetBlockWritingDirection:
 160         return style-&gt;getPropertyValue(CSSPropertyDirection);
 161     default:
 162         return { };
 163     }
 164 }
 165 
 166 static String inputEventDataForEditingStyleAndAction(EditingStyle&amp; style, EditAction action)
 167 {
 168     return inputEventDataForEditingStyleAndAction(style.style(), action);
 169 }
 170 
 171 class ClearTextCommand : public DeleteSelectionCommand {
 172 public:
 173     ClearTextCommand(Document&amp; document);
 174     static void CreateAndApply(const RefPtr&lt;Frame&gt; frame);
 175 
 176 private:
 177     EditAction editingAction() const override;
 178 };
 179 
 180 ClearTextCommand::ClearTextCommand(Document&amp; document)
 181     : DeleteSelectionCommand(document, false, true, false, false, true)
 182 {
 183 }
 184 
 185 EditAction ClearTextCommand::editingAction() const
 186 {
 187     return EditAction::Delete;
 188 }
 189 
 190 void ClearTextCommand::CreateAndApply(const RefPtr&lt;Frame&gt; frame)
 191 {
 192     if (frame-&gt;selection().isNone())
 193         return;
 194 
 195     // Don&#39;t leave around stale composition state.
 196     frame-&gt;editor().clear();
 197 
 198     const VisibleSelection oldSelection = frame-&gt;selection().selection();
 199     frame-&gt;selection().selectAll();
 200     auto clearCommand = adoptRef(*new ClearTextCommand(*frame-&gt;document()));
 201     clearCommand-&gt;setStartingSelection(oldSelection);
 202     clearCommand-&gt;apply();
 203 }
 204 
 205 using namespace HTMLNames;
 206 using namespace WTF::Unicode;
 207 
 208 TemporarySelectionChange::TemporarySelectionChange(Frame&amp; frame, Optional&lt;VisibleSelection&gt; temporarySelection, OptionSet&lt;TemporarySelectionOption&gt; options)
 209     : m_frame(frame)
 210     , m_options(options)
 211     , m_wasIgnoringSelectionChanges(frame.editor().ignoreSelectionChanges())
 212 #if PLATFORM(IOS_FAMILY)
 213     , m_appearanceUpdatesWereEnabled(frame.selection().isUpdateAppearanceEnabled())
 214 #endif
 215 {
 216 #if PLATFORM(IOS_FAMILY)
 217     if (options &amp; TemporarySelectionOption::EnableAppearanceUpdates)
 218         frame.selection().setUpdateAppearanceEnabled(true);
 219 #endif
 220 
 221     if (options &amp; TemporarySelectionOption::IgnoreSelectionChanges)
 222         frame.editor().setIgnoreSelectionChanges(true);
 223 
 224     if (temporarySelection) {
 225         m_selectionToRestore = frame.selection().selection();
 226         setSelection(temporarySelection.value());
 227     }
 228 }
 229 
 230 TemporarySelectionChange::~TemporarySelectionChange()
 231 {
 232     if (m_selectionToRestore)
 233         setSelection(m_selectionToRestore.value());
 234 
 235     if (m_options &amp; TemporarySelectionOption::IgnoreSelectionChanges) {
 236         auto revealSelection = m_options &amp; TemporarySelectionOption::RevealSelection ? Editor::RevealSelection::Yes : Editor::RevealSelection::No;
 237         m_frame-&gt;editor().setIgnoreSelectionChanges(m_wasIgnoringSelectionChanges, revealSelection);
 238     }
 239 
 240 #if PLATFORM(IOS_FAMILY)
 241     if (m_options &amp; TemporarySelectionOption::EnableAppearanceUpdates)
 242         m_frame-&gt;selection().setUpdateAppearanceEnabled(m_appearanceUpdatesWereEnabled);
 243 #endif
 244 }
 245 
 246 void TemporarySelectionChange::setSelection(const VisibleSelection&amp; selection)
 247 {
 248     auto options = FrameSelection::defaultSetSelectionOptions();
 249     if (m_options &amp; TemporarySelectionOption::DoNotSetFocus)
 250         options.add(FrameSelection::DoNotSetFocus);
 251     m_frame-&gt;selection().setSelection(selection, options);
 252 }
 253 
 254 // When an event handler has moved the selection outside of a text control
 255 // we should use the target control&#39;s selection for this editing operation.
 256 VisibleSelection Editor::selectionForCommand(Event* event)
 257 {
 258     auto selection = m_frame.selection().selection();
 259     if (!event)
 260         return selection;
 261     // If the target is a text control, and the current selection is outside of its shadow tree,
 262     // then use the saved selection for that text control.
 263     if (is&lt;Element&gt;(event-&gt;target()) &amp;&amp; downcast&lt;Element&gt;(*event-&gt;target()).isTextField()) {
 264         auto&amp; target = downcast&lt;HTMLTextFormControlElement&gt;(*event-&gt;target());
 265         auto start = selection.start();
 266         if (start.isNull() || &amp;target != enclosingTextFormControl(start)) {
 267             if (auto range = target.selection())
 268                 return { *range, DOWNSTREAM, selection.isDirectional() };
 269         }
 270     }
 271     return selection;
 272 }
 273 
 274 // Function considers Mac editing behavior a fallback when Page or Settings is not available.
 275 EditingBehavior Editor::behavior() const
 276 {
 277     return EditingBehavior(m_frame.settings().editingBehaviorType());
 278 }
 279 
 280 EditorClient* Editor::client() const
 281 {
 282     if (Page* page = m_frame.page())
 283         return &amp;page-&gt;editorClient();
 284     return nullptr;
 285 }
 286 
 287 TextCheckerClient* Editor::textChecker() const
 288 {
 289     if (EditorClient* owner = client())
 290         return owner-&gt;textChecker();
 291     return 0;
 292 }
 293 
 294 void Editor::handleKeyboardEvent(KeyboardEvent&amp; event)
 295 {
 296     if (auto* client = this-&gt;client())
 297         client-&gt;handleKeyboardEvent(event);
 298 }
 299 
 300 void Editor::handleInputMethodKeydown(KeyboardEvent&amp; event)
 301 {
 302     if (auto* client = this-&gt;client())
 303         client-&gt;handleInputMethodKeydown(event);
 304 }
 305 
 306 void Editor::didDispatchInputMethodKeydown(KeyboardEvent&amp; event)
 307 {
 308     if (auto* client = this-&gt;client())
 309         client-&gt;didDispatchInputMethodKeydown(event);
 310 }
 311 
 312 bool Editor::handleTextEvent(TextEvent&amp; event)
 313 {
 314     LOG(Editing, &quot;Editor %p handleTextEvent (data %s)&quot;, this, event.data().utf8().data());
 315 
 316     // Default event handling for Drag and Drop will be handled by DragController
 317     // so we leave the event for it.
 318     if (event.isDrop())
 319         return false;
 320 
 321     if (event.isPaste()) {
 322         if (event.pastingFragment()) {
 323 #if PLATFORM(IOS_FAMILY)
 324             if (client()-&gt;performsTwoStepPaste(event.pastingFragment()))
 325                 return true;
 326 #endif
 327             replaceSelectionWithFragment(*event.pastingFragment(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, event.shouldMatchStyle() ? MatchStyle::Yes : MatchStyle::No, EditAction::Paste, event.mailBlockquoteHandling());
 328         } else
 329             replaceSelectionWithText(event.data(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, EditAction::Paste);
 330         return true;
 331     }
 332 
 333     String data = event.data();
 334     if (data == &quot;\n&quot;) {
 335         if (event.isLineBreak())
 336             return insertLineBreak();
 337         return insertParagraphSeparator();
 338     }
 339 
 340     return insertTextWithoutSendingTextEvent(data, false, &amp;event);
 341 }
 342 
 343 bool Editor::canEdit() const
 344 {
 345     return m_frame.selection().selection().rootEditableElement();
 346 }
 347 
 348 bool Editor::canEditRichly() const
 349 {
 350     return m_frame.selection().selection().isContentRichlyEditable();
 351 }
 352 
 353 enum class ClipboardEventKind {
 354     Copy,
 355     Cut,
 356     Paste,
 357     PasteAsPlainText,
 358     PasteAsQuotation,
 359     BeforeCopy,
 360     BeforeCut,
 361     BeforePaste,
 362 };
 363 
 364 static AtomString eventNameForClipboardEvent(ClipboardEventKind kind)
 365 {
 366     switch (kind) {
 367     case ClipboardEventKind::Copy:
 368         return eventNames().copyEvent;
 369     case ClipboardEventKind::Cut:
 370         return eventNames().cutEvent;
 371     case ClipboardEventKind::Paste:
 372     case ClipboardEventKind::PasteAsPlainText:
 373     case ClipboardEventKind::PasteAsQuotation:
 374         return eventNames().pasteEvent;
 375     case ClipboardEventKind::BeforeCopy:
 376         return eventNames().beforecopyEvent;
 377     case ClipboardEventKind::BeforeCut:
 378         return eventNames().beforecutEvent;
 379     case ClipboardEventKind::BeforePaste:
 380         return eventNames().beforepasteEvent;
 381     }
 382     ASSERT_NOT_REACHED();
 383     return { };
 384 }
 385 
 386 static Ref&lt;DataTransfer&gt; createDataTransferForClipboardEvent(Document&amp; document, ClipboardEventKind kind)
 387 {
 388     switch (kind) {
 389     case ClipboardEventKind::Copy:
 390     case ClipboardEventKind::Cut:
 391         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::ReadWrite, makeUnique&lt;StaticPasteboard&gt;());
 392     case ClipboardEventKind::PasteAsPlainText:
 393         if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
 394             auto plainTextType = &quot;text/plain&quot;_s;
 395             auto plainText = Pasteboard::createForCopyAndPaste()-&gt;readString(plainTextType);
 396             auto pasteboard = makeUnique&lt;StaticPasteboard&gt;();
 397             pasteboard-&gt;writeString(plainTextType, plainText);
 398             return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, WTFMove(pasteboard));
 399         }
 400         FALLTHROUGH;
 401     case ClipboardEventKind::Paste:
 402     case ClipboardEventKind::PasteAsQuotation:
 403         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, Pasteboard::createForCopyAndPaste());
 404     case ClipboardEventKind::BeforeCopy:
 405     case ClipboardEventKind::BeforeCut:
 406     case ClipboardEventKind::BeforePaste:
 407         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, makeUnique&lt;StaticPasteboard&gt;());
 408     }
 409     ASSERT_NOT_REACHED();
 410     return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, makeUnique&lt;StaticPasteboard&gt;());
 411 }
 412 
 413 // Returns whether caller should continue with &quot;the default processing&quot;, which is the same as
 414 // the event handler NOT setting the return value to false
 415 // https://w3c.github.io/clipboard-apis/#fire-a-clipboard-event
 416 static bool dispatchClipboardEvent(RefPtr&lt;Element&gt;&amp;&amp; target, ClipboardEventKind kind)
 417 {
 418     // FIXME: Move the target selection code here.
 419     if (!target)
 420         return true;
 421 
 422     auto dataTransfer = createDataTransferForClipboardEvent(target-&gt;document(), kind);
 423 
 424     auto event = ClipboardEvent::create(eventNameForClipboardEvent(kind), dataTransfer.copyRef());
 425 
 426     target-&gt;dispatchEvent(event);
 427     bool noDefaultProcessing = event-&gt;defaultPrevented();
 428     if (noDefaultProcessing &amp;&amp; (kind == ClipboardEventKind::Copy || kind == ClipboardEventKind::Cut)) {
 429         auto pasteboard = Pasteboard::createForCopyAndPaste();
 430         pasteboard-&gt;clear();
 431         dataTransfer-&gt;commitToPasteboard(*pasteboard);
 432     }
 433 
 434     dataTransfer-&gt;makeInvalidForSecurity();
 435 
 436     return !noDefaultProcessing;
 437 }
 438 
 439 // WinIE uses onbeforecut and onbeforepaste to enables the cut and paste menu items.  They
 440 // also send onbeforecopy, apparently for symmetry, but it doesn&#39;t affect the menu items.
 441 // We need to use onbeforecopy as a real menu enabler because we allow elements that are not
 442 // normally selectable to implement copy/paste (like divs, or a document body).
 443 
 444 bool Editor::canDHTMLCut()
 445 {
 446     if (m_frame.selection().selection().isInPasswordField())
 447         return false;
 448 
 449     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforeCut);
 450 }
 451 
 452 bool Editor::canDHTMLCopy()
 453 {
 454     if (m_frame.selection().selection().isInPasswordField())
 455         return false;
 456     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforeCopy);
 457 }
 458 
 459 bool Editor::canDHTMLPaste()
 460 {
 461     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforePaste);
 462 }
 463 
 464 bool Editor::canCut() const
 465 {
 466     return canCopy() &amp;&amp; canDelete();
 467 }
 468 
 469 static HTMLImageElement* imageElementFromImageDocument(Document&amp; document)
 470 {
 471     if (!document.isImageDocument())
 472         return nullptr;
 473 
 474     HTMLElement* body = document.bodyOrFrameset();
 475     if (!body)
 476         return nullptr;
 477 
 478     Node* node = body-&gt;firstChild();
 479     if (!is&lt;HTMLImageElement&gt;(node))
 480         return nullptr;
 481     return downcast&lt;HTMLImageElement&gt;(node);
 482 }
 483 
 484 bool Editor::canCopy() const
 485 {
 486     if (imageElementFromImageDocument(document()))
 487         return true;
 488     const VisibleSelection&amp; selection = m_frame.selection().selection();
 489     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
 490 }
 491 
 492 bool Editor::canPaste() const
 493 {
 494     if (m_frame.mainFrame().loader().shouldSuppressTextInputFromEditing())
 495         return false;
 496 
 497     return canEdit();
 498 }
 499 
 500 bool Editor::canDelete() const
 501 {
 502     const VisibleSelection&amp; selection = m_frame.selection().selection();
 503     return selection.isRange() &amp;&amp; selection.rootEditableElement();
 504 }
 505 
 506 bool Editor::canDeleteRange(Range* range) const
 507 {
 508     Node&amp; startContainer = range-&gt;startContainer();
 509     Node&amp; endContainer = range-&gt;endContainer();
 510 
 511     if (!startContainer.hasEditableStyle() || !endContainer.hasEditableStyle())
 512         return false;
 513 
 514     if (range-&gt;collapsed()) {
 515         VisiblePosition start(range-&gt;startPosition(), DOWNSTREAM);
 516         VisiblePosition previous = start.previous();
 517         // FIXME: We sometimes allow deletions at the start of editable roots, like when the caret is in an empty list item.
 518         if (previous.isNull() || previous.deepEquivalent().deprecatedNode()-&gt;rootEditableElement() != startContainer.rootEditableElement())
 519             return false;
 520     }
 521     return true;
 522 }
 523 
 524 bool Editor::shouldSmartDelete()
 525 {
 526     if (behavior().shouldAlwaysSmartDelete())
 527         return true;
 528     return m_frame.selection().granularity() == WordGranularity;
 529 }
 530 
 531 bool Editor::smartInsertDeleteEnabled()
 532 {
 533     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled();
 534 }
 535 
 536 bool Editor::canSmartCopyOrDelete()
 537 {
 538     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; shouldSmartDelete();
 539 }
 540 
 541 bool Editor::isSelectTrailingWhitespaceEnabled() const
 542 {
 543     return client() &amp;&amp; client()-&gt;isSelectTrailingWhitespaceEnabled();
 544 }
 545 
 546 bool Editor::deleteWithDirection(SelectionDirection direction, TextGranularity granularity, bool shouldAddToKillRing, bool isTypingAction)
 547 {
 548     if (!canEdit())
 549         return false;
 550 
 551     if (m_frame.selection().isRange()) {
 552         if (isTypingAction) {
 553             TypingCommand::deleteKeyPressed(document(), canSmartCopyOrDelete() ? TypingCommand::SmartDelete : 0, granularity);
 554             revealSelectionAfterEditingOperation();
 555         } else {
 556             if (shouldAddToKillRing)
 557                 addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
 558             deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
 559             // Implicitly calls revealSelectionAfterEditingOperation().
 560         }
 561     } else {
 562         TypingCommand::Options options = 0;
 563         if (canSmartCopyOrDelete())
 564             options |= TypingCommand::SmartDelete;
 565         if (shouldAddToKillRing)
 566             options |= TypingCommand::AddsToKillRing;
 567         switch (direction) {
 568         case DirectionForward:
 569         case DirectionRight:
 570             TypingCommand::forwardDeleteKeyPressed(document(), options, granularity);
 571             break;
 572         case DirectionBackward:
 573         case DirectionLeft:
 574             TypingCommand::deleteKeyPressed(document(), options, granularity);
 575             break;
 576         }
 577         revealSelectionAfterEditingOperation();
 578     }
 579 
 580     // FIXME: We should to move this down into deleteKeyPressed.
 581     // clear the &quot;start new kill ring sequence&quot; setting, because it was set to true
 582     // when the selection was updated by deleting the range
 583     if (shouldAddToKillRing)
 584         setStartNewKillRingSequence(false);
 585 
 586     return true;
 587 }
 588 
 589 void Editor::deleteSelectionWithSmartDelete(bool smartDelete, EditAction editingAction)
 590 {
 591     if (m_frame.selection().isNone())
 592         return;
 593 
 594     DeleteSelectionCommand::create(document(), smartDelete, true, false, false, true, editingAction)-&gt;apply();
 595 }
 596 
 597 void Editor::clearText()
 598 {
 599     ClearTextCommand::CreateAndApply(&amp;m_frame);
 600 }
 601 
 602 void Editor::pasteAsPlainText(const String&amp; pastingText, bool smartReplace)
 603 {
 604     Element* target = findEventTargetFromSelection();
 605     if (!target)
 606         return;
 607     target-&gt;dispatchEvent(TextEvent::createForPlainTextPaste(document().windowProxy(), pastingText, smartReplace));
 608 }
 609 
 610 void Editor::pasteAsFragment(Ref&lt;DocumentFragment&gt;&amp;&amp; pastingFragment, bool smartReplace, bool matchStyle, MailBlockquoteHandling respectsMailBlockquote)
 611 {
 612     Element* target = findEventTargetFromSelection();
 613     if (!target)
 614         return;
 615     target-&gt;dispatchEvent(TextEvent::createForFragmentPaste(document().windowProxy(), WTFMove(pastingFragment), smartReplace, matchStyle, respectsMailBlockquote));
 616 }
 617 
 618 void Editor::pasteAsPlainTextBypassingDHTML()
 619 {
 620     pasteAsPlainTextWithPasteboard(*Pasteboard::createForCopyAndPaste());
 621 }
 622 
 623 void Editor::pasteAsPlainTextWithPasteboard(Pasteboard&amp; pasteboard)
 624 {
 625     String text = readPlainTextFromPasteboard(pasteboard);
 626     if (client() &amp;&amp; client()-&gt;shouldInsertText(text, selectedRange().get(), EditorInsertAction::Pasted))
 627         pasteAsPlainText(text, canSmartReplaceWithPasteboard(pasteboard));
 628 }
 629 
 630 String Editor::readPlainTextFromPasteboard(Pasteboard&amp; pasteboard)
 631 {
 632     PasteboardPlainText text;
 633     pasteboard.read(text);
 634     return plainTextFromPasteboard(text);
 635 }
 636 
 637 #if !PLATFORM(MAC)
 638 
 639 String Editor::plainTextFromPasteboard(const PasteboardPlainText&amp; text)
 640 {
 641     return text.text;
 642 }
 643 
 644 #endif
 645 
 646 bool Editor::canSmartReplaceWithPasteboard(Pasteboard&amp; pasteboard)
 647 {
 648     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; pasteboard.canSmartReplace();
 649 }
 650 
 651 bool Editor::shouldInsertFragment(DocumentFragment&amp; fragment, Range* replacingDOMRange, EditorInsertAction givenAction)
 652 {
 653     if (!client())
 654         return false;
 655 
 656     auto* child = fragment.firstChild();
 657     if (is&lt;CharacterData&gt;(child) &amp;&amp; fragment.lastChild() == child)
 658         return client()-&gt;shouldInsertText(downcast&lt;CharacterData&gt;(*child).data(), replacingDOMRange, givenAction);
 659 
 660     return client()-&gt;shouldInsertNode(&amp;fragment, replacingDOMRange, givenAction);
 661 }
 662 
 663 void Editor::replaceSelectionWithFragment(DocumentFragment&amp; fragment, SelectReplacement selectReplacement, SmartReplace smartReplace, MatchStyle matchStyle, EditAction editingAction, MailBlockquoteHandling mailBlockquoteHandling)
 664 {
 665     VisibleSelection selection = m_frame.selection().selection();
 666     if (selection.isNone() || !selection.isContentEditable())
 667         return;
 668 
 669     AccessibilityReplacedText replacedText;
 670     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste)
 671         replacedText = AccessibilityReplacedText(selection);
 672 
 673     OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SanitizeFragment };
 674     if (selectReplacement == SelectReplacement::Yes)
 675         options.add(ReplaceSelectionCommand::SelectReplacement);
 676     if (smartReplace == SmartReplace::Yes)
 677         options.add(ReplaceSelectionCommand::SmartReplace);
 678     if (matchStyle == MatchStyle::Yes)
 679         options.add(ReplaceSelectionCommand::MatchStyle);
 680     if (mailBlockquoteHandling == MailBlockquoteHandling::IgnoreBlockquote)
 681         options.add(ReplaceSelectionCommand::IgnoreMailBlockquote);
 682 
 683     auto command = ReplaceSelectionCommand::create(document(), &amp;fragment, options, editingAction);
 684     command-&gt;apply();
 685 
 686     m_imageElementsToLoadBeforeRevealingSelection.clear();
 687     if (auto insertionRange = command-&gt;insertedContentRange())
 688         m_imageElementsToLoadBeforeRevealingSelection = visibleImageElementsInRangeWithNonLoadedImages(*insertionRange);
 689 
 690     if (m_imageElementsToLoadBeforeRevealingSelection.isEmpty())
 691         revealSelectionAfterEditingOperation();
 692 
 693     selection = m_frame.selection().selection();
 694     if (selection.isInPasswordField())
 695         return;
 696 
 697     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste) {
 698         String text = AccessibilityObject::stringForVisiblePositionRange(command-&gt;visibleSelectionForInsertedText());
 699         replacedText.postTextStateChangeNotification(document().existingAXObjectCache(), AXTextEditTypePaste, text, m_frame.selection().selection());
 700         command-&gt;composition()-&gt;setRangeDeletedByUnapply(replacedText.replacedRange());
 701     }
 702 
 703     if (!isContinuousSpellCheckingEnabled())
 704         return;
 705 
 706     Node* nodeToCheck = selection.rootEditableElement();
 707     if (!nodeToCheck)
 708         return;
 709 
 710     auto rangeToCheck = Range::create(document(), firstPositionInNode(nodeToCheck), lastPositionInNode(nodeToCheck));
 711     if (auto request = SpellCheckRequest::create(resolveTextCheckingTypeMask(*nodeToCheck, { TextCheckingType::Spelling, TextCheckingType::Grammar }), TextCheckingProcessBatch, rangeToCheck.copyRef(), rangeToCheck.copyRef(), rangeToCheck.copyRef()))
 712         m_spellChecker-&gt;requestCheckingFor(request.releaseNonNull());
 713 }
 714 
 715 void Editor::replaceSelectionWithText(const String&amp; text, SelectReplacement selectReplacement, SmartReplace smartReplace, EditAction editingAction)
 716 {
 717     RefPtr&lt;Range&gt; range = selectedRange();
 718     if (!range)
 719         return;
 720 
 721     replaceSelectionWithFragment(createFragmentFromText(*range, text), selectReplacement, smartReplace, MatchStyle::Yes, editingAction);
 722 }
 723 
 724 RefPtr&lt;Range&gt; Editor::selectedRange()
 725 {
 726     return m_frame.selection().toNormalizedRange();
 727 }
 728 
 729 bool Editor::shouldDeleteRange(Range* range) const
 730 {
 731     if (!range || range-&gt;collapsed())
 732         return false;
 733 
 734     if (!canDeleteRange(range))
 735         return false;
 736 
 737     return client() &amp;&amp; client()-&gt;shouldDeleteRange(range);
 738 }
 739 
 740 bool Editor::tryDHTMLCopy()
 741 {
 742     if (m_frame.selection().selection().isInPasswordField())
 743         return false;
 744 
 745     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Copy);
 746 }
 747 
 748 bool Editor::tryDHTMLCut()
 749 {
 750     if (m_frame.selection().selection().isInPasswordField())
 751         return false;
 752 
 753     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Cut);
 754 }
 755 
 756 bool Editor::shouldInsertText(const String&amp; text, Range* range, EditorInsertAction action) const
 757 {
 758     if (m_frame.mainFrame().loader().shouldSuppressTextInputFromEditing() &amp;&amp; action == EditorInsertAction::Typed)
 759         return false;
 760 
 761     return client() &amp;&amp; client()-&gt;shouldInsertText(text, range, action);
 762 }
 763 
 764 void Editor::respondToChangedContents(const VisibleSelection&amp; endingSelection)
 765 {
 766     if (AXObjectCache::accessibilityEnabled()) {
 767         Node* node = endingSelection.start().deprecatedNode();
 768         if (AXObjectCache* cache = document().existingAXObjectCache())
 769             cache-&gt;postNotification(node, AXObjectCache::AXValueChanged, TargetObservableParent);
 770     }
 771 
 772     updateMarkersForWordsAffectedByEditing(true);
 773 
 774     if (client())
 775         client()-&gt;respondToChangedContents();
 776 }
 777 
 778 bool Editor::hasBidiSelection() const
 779 {
 780     if (m_frame.selection().isNone())
 781         return false;
 782 
 783     Node* startNode;
 784     if (m_frame.selection().isRange()) {
 785         startNode = m_frame.selection().selection().start().downstream().deprecatedNode();
 786         Node* endNode = m_frame.selection().selection().end().upstream().deprecatedNode();
 787         if (enclosingBlock(startNode) != enclosingBlock(endNode))
 788             return false;
 789     } else
 790         startNode = m_frame.selection().selection().visibleStart().deepEquivalent().deprecatedNode();
 791 
 792     if (!startNode)
 793         return false;
 794 
 795     auto renderer = startNode-&gt;renderer();
 796     while (renderer &amp;&amp; !is&lt;RenderBlockFlow&gt;(*renderer))
 797         renderer = renderer-&gt;parent();
 798 
 799     if (!renderer)
 800         return false;
 801 
 802     if (!renderer-&gt;style().isLeftToRightDirection())
 803         return true;
 804 
 805     return downcast&lt;RenderBlockFlow&gt;(*renderer).containsNonZeroBidiLevel();
 806 }
 807 
 808 TriState Editor::selectionUnorderedListState() const
 809 {
 810     if (m_frame.selection().isCaret()) {
 811         if (enclosingElementWithTag(m_frame.selection().selection().start(), ulTag))
 812             return TrueTriState;
 813     } else if (m_frame.selection().isRange()) {
 814         auto* startNode = enclosingElementWithTag(m_frame.selection().selection().start(), ulTag);
 815         auto* endNode = enclosingElementWithTag(m_frame.selection().selection().end(), ulTag);
 816         if (startNode &amp;&amp; endNode &amp;&amp; startNode == endNode)
 817             return TrueTriState;
 818     }
 819 
 820     return FalseTriState;
 821 }
 822 
 823 TriState Editor::selectionOrderedListState() const
 824 {
 825     if (m_frame.selection().isCaret()) {
 826         if (enclosingElementWithTag(m_frame.selection().selection().start(), olTag))
 827             return TrueTriState;
 828     } else if (m_frame.selection().isRange()) {
 829         auto* startNode = enclosingElementWithTag(m_frame.selection().selection().start(), olTag);
 830         auto* endNode = enclosingElementWithTag(m_frame.selection().selection().end(), olTag);
 831         if (startNode &amp;&amp; endNode &amp;&amp; startNode == endNode)
 832             return TrueTriState;
 833     }
 834 
 835     return FalseTriState;
 836 }
 837 
 838 RefPtr&lt;Node&gt; Editor::insertOrderedList()
 839 {
 840     if (!canEditRichly())
 841         return nullptr;
 842 
 843     auto newList = InsertListCommand::insertList(document(), InsertListCommand::Type::OrderedList);
 844     revealSelectionAfterEditingOperation();
 845     return newList;
 846 }
 847 
 848 RefPtr&lt;Node&gt; Editor::insertUnorderedList()
 849 {
 850     if (!canEditRichly())
 851         return nullptr;
 852 
 853     auto newList = InsertListCommand::insertList(document(), InsertListCommand::Type::UnorderedList);
 854     revealSelectionAfterEditingOperation();
 855     return newList;
 856 }
 857 
 858 bool Editor::canIncreaseSelectionListLevel()
 859 {
 860     return canEditRichly() &amp;&amp; IncreaseSelectionListLevelCommand::canIncreaseSelectionListLevel(&amp;document());
 861 }
 862 
 863 bool Editor::canDecreaseSelectionListLevel()
 864 {
 865     return canEditRichly() &amp;&amp; DecreaseSelectionListLevelCommand::canDecreaseSelectionListLevel(&amp;document());
 866 }
 867 
 868 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevel()
 869 {
 870     if (!canEditRichly() || m_frame.selection().isNone())
 871         return nullptr;
 872 
 873     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevel(&amp;document());
 874     revealSelectionAfterEditingOperation();
 875     return newList;
 876 }
 877 
 878 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevelOrdered()
 879 {
 880     if (!canEditRichly() || m_frame.selection().isNone())
 881         return nullptr;
 882 
 883     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevelOrdered(&amp;document());
 884     revealSelectionAfterEditingOperation();
 885     return newList;
 886 }
 887 
 888 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevelUnordered()
 889 {
 890     if (!canEditRichly() || m_frame.selection().isNone())
 891         return nullptr;
 892 
 893     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevelUnordered(&amp;document());
 894     revealSelectionAfterEditingOperation();
 895     return newList;
 896 }
 897 
 898 void Editor::decreaseSelectionListLevel()
 899 {
 900     if (!canEditRichly() || m_frame.selection().isNone())
 901         return;
 902 
 903     DecreaseSelectionListLevelCommand::decreaseSelectionListLevel(&amp;document());
 904     revealSelectionAfterEditingOperation();
 905 }
 906 
 907 void Editor::removeFormattingAndStyle()
 908 {
 909     RemoveFormatCommand::create(document())-&gt;apply();
 910 }
 911 
 912 void Editor::clearLastEditCommand()
 913 {
 914     m_lastEditCommand = nullptr;
 915 }
 916 
 917 Element* Editor::findEventTargetFrom(const VisibleSelection&amp; selection) const
 918 {
 919     Element* target = selection.start().element();
 920     if (!target)
 921         target = document().bodyOrFrameset();
 922     if (!target)
 923         return nullptr;
 924 
 925     return target;
 926 }
 927 
 928 Element* Editor::findEventTargetFromSelection() const
 929 {
 930     return findEventTargetFrom(m_frame.selection().selection());
 931 }
 932 
 933 void Editor::applyStyle(StyleProperties* style, EditAction editingAction)
 934 {
 935     if (style)
 936         applyStyle(EditingStyle::create(style), editingAction, ColorFilterMode::UseOriginalColor);
 937 }
 938 
 939 void Editor::applyStyle(RefPtr&lt;EditingStyle&gt;&amp;&amp; style, EditAction editingAction, ColorFilterMode colorFilterMode)
 940 {
 941     if (!style)
 942         return;
 943 
 944     auto selectionType = m_frame.selection().selection().selectionType();
 945     if (selectionType == VisibleSelection::NoSelection)
 946         return;
 947 
 948     String inputTypeName = inputTypeNameForEditingAction(editingAction);
 949     String inputEventData = inputEventDataForEditingStyleAndAction(*style, editingAction);
 950     RefPtr&lt;Element&gt; element = m_frame.selection().selection().rootEditableElement();
 951     if (element &amp;&amp; !dispatchBeforeInputEvent(*element, inputTypeName, inputEventData))
 952         return;
 953 
 954     Ref&lt;EditingStyle&gt; styleToApply = colorFilterMode == ColorFilterMode::InvertColor ? style-&gt;inverseTransformColorIfNeeded(*element) : style.releaseNonNull();
 955 
 956     switch (selectionType) {
 957     case VisibleSelection::CaretSelection:
 958         computeAndSetTypingStyle(styleToApply.get(), editingAction);
 959         break;
 960     case VisibleSelection::RangeSelection:
 961         ApplyStyleCommand::create(document(), styleToApply.ptr(), editingAction)-&gt;apply();
 962         break;
 963     default:
 964         break;
 965     }
 966 
 967     client()-&gt;didApplyStyle();
 968     if (element)
 969         dispatchInputEvent(*element, inputTypeName, inputEventData);
 970 }
 971 
 972 bool Editor::shouldApplyStyle(StyleProperties* style, Range* range)
 973 {
 974     return client()-&gt;shouldApplyStyle(style, range);
 975 }
 976 
 977 void Editor::applyParagraphStyle(StyleProperties* style, EditAction editingAction)
 978 {
 979     if (!style)
 980         return;
 981 
 982     auto selectionType = m_frame.selection().selection().selectionType();
 983     if (selectionType == VisibleSelection::NoSelection)
 984         return;
 985 
 986     String inputTypeName = inputTypeNameForEditingAction(editingAction);
 987     String inputEventData = inputEventDataForEditingStyleAndAction(style, editingAction);
 988     RefPtr&lt;Element&gt; element = m_frame.selection().selection().rootEditableElement();
 989     if (element &amp;&amp; !dispatchBeforeInputEvent(*element, inputTypeName, inputEventData))
 990         return;
 991 
 992     ApplyStyleCommand::create(document(), EditingStyle::create(style).ptr(), editingAction, ApplyStyleCommand::ForceBlockProperties)-&gt;apply();
 993     client()-&gt;didApplyStyle();
 994     if (element)
 995         dispatchInputEvent(*element, inputTypeName, inputEventData);
 996 }
 997 
 998 void Editor::applyStyleToSelection(StyleProperties* style, EditAction editingAction)
 999 {
1000     if (!style || style-&gt;isEmpty() || !canEditRichly())
1001         return;
1002 
1003     if (!client() || !client()-&gt;shouldApplyStyle(style, m_frame.selection().toNormalizedRange().get()))
1004         return;
1005     applyStyle(style, editingAction);
1006 }
1007 
1008 void Editor::applyStyleToSelection(Ref&lt;EditingStyle&gt;&amp;&amp; style, EditAction editingAction, ColorFilterMode colorFilterMode)
1009 {
1010     if (style-&gt;isEmpty() || !canEditRichly())
1011         return;
1012 
1013     // FIXME: This is wrong for text decorations since m_mutableStyle is empty.
1014     if (!client() || !client()-&gt;shouldApplyStyle(style-&gt;styleWithResolvedTextDecorations().ptr(), m_frame.selection().toNormalizedRange().get()))
1015         return;
1016 
1017     applyStyle(WTFMove(style), editingAction, colorFilterMode);
1018 }
1019 
1020 void Editor::applyParagraphStyleToSelection(StyleProperties* style, EditAction editingAction)
1021 {
1022     if (!style || style-&gt;isEmpty() || !canEditRichly())
1023         return;
1024 
1025     if (client() &amp;&amp; client()-&gt;shouldApplyStyle(style, m_frame.selection().toNormalizedRange().get()))
1026         applyParagraphStyle(style, editingAction);
1027 }
1028 
1029 bool Editor::selectionStartHasStyle(CSSPropertyID propertyID, const String&amp; value) const
1030 {
1031     if (auto editingStyle = EditingStyle::styleAtSelectionStart(m_frame.selection().selection(), propertyID == CSSPropertyBackgroundColor))
1032         return editingStyle-&gt;hasStyle(propertyID, value);
1033     return false;
1034 }
1035 
1036 TriState Editor::selectionHasStyle(CSSPropertyID propertyID, const String&amp; value) const
1037 {
1038     return EditingStyle::create(propertyID, value)-&gt;triStateOfStyle(m_frame.selection().selection());
1039 }
1040 
1041 String Editor::selectionStartCSSPropertyValue(CSSPropertyID propertyID)
1042 {
1043     RefPtr&lt;EditingStyle&gt; selectionStyle = EditingStyle::styleAtSelectionStart(m_frame.selection().selection(),
1044         propertyID == CSSPropertyBackgroundColor);
1045     if (!selectionStyle || !selectionStyle-&gt;style())
1046         return String();
1047 
1048     if (propertyID == CSSPropertyFontSize)
1049         return String::number(selectionStyle-&gt;legacyFontSize(document()));
1050     return selectionStyle-&gt;style()-&gt;getPropertyValue(propertyID);
1051 }
1052 
1053 void Editor::indent()
1054 {
1055     IndentOutdentCommand::create(document(), IndentOutdentCommand::Indent)-&gt;apply();
1056 }
1057 
1058 void Editor::outdent()
1059 {
1060     IndentOutdentCommand::create(document(), IndentOutdentCommand::Outdent)-&gt;apply();
1061 }
1062 
1063 static void notifyTextFromControls(Element* startRoot, Element* endRoot)
1064 {
1065     HTMLTextFormControlElement* startingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(startRoot));
1066     HTMLTextFormControlElement* endingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(endRoot));
1067     if (startingTextControl)
1068         startingTextControl-&gt;didEditInnerTextValue();
1069     if (endingTextControl &amp;&amp; startingTextControl != endingTextControl)
1070         endingTextControl-&gt;didEditInnerTextValue();
1071 }
1072 
1073 static bool dispatchBeforeInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)
1074 {
1075     bool continueWithDefaultBehavior = true;
1076     if (startRoot)
1077         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1078     if (endRoot &amp;&amp; endRoot != startRoot)
1079         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1080     return continueWithDefaultBehavior;
1081 }
1082 
1083 static void dispatchInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })
1084 {
1085     if (startRoot)
1086         dispatchInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1087     if (endRoot &amp;&amp; endRoot != startRoot)
1088         dispatchInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1089 }
1090 
1091 bool Editor::willApplyEditing(CompositeEditCommand&amp; command, Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp;&amp; targetRanges) const
1092 {
1093     if (!command.shouldDispatchInputEvents())
1094         return true;
1095 
1096     auto* composition = command.composition();
1097     if (!composition)
1098         return true;
1099 
1100     return dispatchBeforeInputEvents(composition-&gt;startingRootEditableElement(), composition-&gt;endingRootEditableElement(), command.inputEventTypeName(),
1101         command.inputEventData(), command.inputEventDataTransfer(), targetRanges, command.isBeforeInputEventCancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No);
1102 }
1103 
1104 void Editor::appliedEditing(CompositeEditCommand&amp; command)
1105 {
1106     LOG(Editing, &quot;Editor %p appliedEditing&quot;, this);
1107 
1108     document().updateLayout();
1109 
1110     ASSERT(command.composition());
1111     auto&amp; composition = *command.composition();
1112     VisibleSelection newSelection(command.endingSelection());
1113 
1114     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1115 
1116     if (command.isTopLevelCommand()) {
1117         // Don&#39;t clear the typing style with this selection change. We do those things elsewhere if necessary.
1118         OptionSet&lt;FrameSelection::SetSelectionOption&gt; options;
1119         if (command.isDictationCommand())
1120             options.add(FrameSelection::DictationTriggered);
1121 
1122         changeSelectionAfterCommand(newSelection, options);
1123     }
1124 
1125     if (command.shouldDispatchInputEvents())
1126         dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), command.inputEventTypeName(), command.inputEventData(), command.inputEventDataTransfer());
1127 
1128     if (command.isTopLevelCommand()) {
1129         updateEditorUINowIfScheduled();
1130 
1131         m_alternativeTextController-&gt;respondToAppliedEditing(&amp;command);
1132 
1133         if (!command.preservesTypingStyle())
1134             m_frame.selection().clearTypingStyle();
1135 
1136         // Command will be equal to last edit command only in the case of typing
1137         if (m_lastEditCommand.get() == &amp;command)
1138             ASSERT(command.isTypingCommand());
1139         else {
1140             // Only register a new undo command if the command passed in is
1141             // different from the last command
1142             m_lastEditCommand = &amp;command;
1143             if (client())
1144                 client()-&gt;registerUndoStep(m_lastEditCommand-&gt;ensureComposition());
1145         }
1146         respondToChangedContents(newSelection);
1147     }
1148 }
1149 
1150 bool Editor::willUnapplyEditing(const EditCommandComposition&amp; composition) const
1151 {
1152     return dispatchBeforeInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyUndo&quot;);
1153 }
1154 
1155 void Editor::unappliedEditing(EditCommandComposition&amp; composition)
1156 {
1157     document().updateLayout();
1158 
1159     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1160 
1161     VisibleSelection newSelection(composition.startingSelection());
1162     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1163     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyUndo&quot;);
1164 
1165     updateEditorUINowIfScheduled();
1166 
1167     m_alternativeTextController-&gt;respondToUnappliedEditing(&amp;composition);
1168 
1169     m_lastEditCommand = nullptr;
1170     if (auto* client = this-&gt;client())
1171         client-&gt;registerRedoStep(composition);
1172     respondToChangedContents(newSelection);
1173 }
1174 
1175 bool Editor::willReapplyEditing(const EditCommandComposition&amp; composition) const
1176 {
1177     return dispatchBeforeInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1178 }
1179 
1180 void Editor::reappliedEditing(EditCommandComposition&amp; composition)
1181 {
1182     document().updateLayout();
1183 
1184     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1185 
1186     VisibleSelection newSelection(composition.endingSelection());
1187     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1188     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1189 
1190     updateEditorUINowIfScheduled();
1191 
1192     m_lastEditCommand = nullptr;
1193     if (auto* client = this-&gt;client())
1194         client-&gt;registerUndoStep(composition);
1195     respondToChangedContents(newSelection);
1196 }
1197 
1198 Editor::Editor(Frame&amp; frame)
1199     : m_frame(frame)
1200     , m_killRing(makeUnique&lt;PAL::KillRing&gt;())
1201     , m_spellChecker(makeUnique&lt;SpellChecker&gt;(frame))
1202     , m_alternativeTextController(makeUnique&lt;AlternativeTextController&gt;(frame))
1203     , m_editorUIUpdateTimer(*this, &amp;Editor::editorUIUpdateTimerFired)
1204 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1205     , m_telephoneNumberDetectionUpdateTimer(*this, &amp;Editor::scanSelectionForTelephoneNumbers)
1206 #endif
1207 {
1208 }
1209 
1210 Editor::~Editor() = default;
1211 
1212 void Editor::clear()
1213 {
1214     m_lastEditCommand = nullptr;
1215     if (m_compositionNode) {
1216         m_compositionNode = nullptr;
1217         if (EditorClient* client = this-&gt;client())
1218             client-&gt;discardedComposition(&amp;m_frame);
1219     }
1220     m_customCompositionUnderlines.clear();
1221     m_customCompositionHighlights.clear();
1222     m_shouldStyleWithCSS = false;
1223     m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
1224     m_mark = { };
1225     m_oldSelectionForEditorUIUpdate = { };
1226     m_editorUIUpdateTimer.stop();
1227 
1228 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1229     m_telephoneNumberDetectionUpdateTimer.stop();
1230     m_detectedTelephoneNumberRanges.clear();
1231 #endif
1232 }
1233 
1234 bool Editor::insertText(const String&amp; text, Event* triggeringEvent, TextEventInputType inputType)
1235 {
1236     return m_frame.eventHandler().handleTextInputEvent(text, triggeringEvent, inputType);
1237 }
1238 
1239 bool Editor::insertTextForConfirmedComposition(const String&amp; text)
1240 {
1241     return m_frame.eventHandler().handleTextInputEvent(text, 0, TextEventInputComposition);
1242 }
1243 
1244 bool Editor::insertDictatedText(const String&amp; text, const Vector&lt;DictationAlternative&gt;&amp; dictationAlternatives, Event* triggeringEvent)
1245 {
1246     return m_alternativeTextController-&gt;insertDictatedText(text, dictationAlternatives, triggeringEvent);
1247 }
1248 
1249 bool Editor::insertTextWithoutSendingTextEvent(const String&amp; text, bool selectInsertedText, TextEvent* triggeringEvent)
1250 {
1251     if (text.isEmpty())
1252         return false;
1253 
1254     VisibleSelection selection = selectionForCommand(triggeringEvent);
1255     if (!selection.isContentEditable())
1256         return false;
1257     RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
1258 
1259     if (!shouldInsertText(text, range.get(), EditorInsertAction::Typed))
1260         return true;
1261 
1262     updateMarkersForWordsAffectedByEditing(isSpaceOrNewline(text[0]));
1263 
1264     bool shouldConsiderApplyingAutocorrection = false;
1265     if (text == &quot; &quot; || text == &quot;\t&quot;)
1266         shouldConsiderApplyingAutocorrection = true;
1267 
1268     if (text.length() == 1 &amp;&amp; u_ispunct(text[0]) &amp;&amp; !isAmbiguousBoundaryCharacter(text[0]))
1269         shouldConsiderApplyingAutocorrection = true;
1270 
1271     bool autocorrectionWasApplied = shouldConsiderApplyingAutocorrection &amp;&amp; m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1272 
1273     // Get the selection to use for the event that triggered this insertText.
1274     // If the event handler changed the selection, we may want to use a different selection
1275     // that is contained in the event target.
1276     selection = selectionForCommand(triggeringEvent);
1277     if (selection.isContentEditable()) {
1278         if (Node* selectionStart = selection.start().deprecatedNode()) {
1279             Ref&lt;Document&gt; document(selectionStart-&gt;document());
1280 
1281             // Insert the text
1282             if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isDictation())
1283                 DictationCommand::insertText(document, text, triggeringEvent-&gt;dictationAlternatives(), selection);
1284             else {
1285                 TypingCommand::Options options = 0;
1286                 if (selectInsertedText)
1287                     options |= TypingCommand::SelectInsertedText;
1288                 if (autocorrectionWasApplied)
1289                     options |= TypingCommand::RetainAutocorrectionIndicator;
1290                 if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isAutocompletion())
1291                     options |= TypingCommand::IsAutocompletion;
1292                 TypingCommand::insertText(document, text, selection, options, triggeringEvent &amp;&amp; triggeringEvent-&gt;isComposition() ? TypingCommand::TextCompositionFinal : TypingCommand::TextCompositionNone);
1293             }
1294 
1295             // Reveal the current selection
1296             if (Frame* editedFrame = document-&gt;frame())
1297                 if (Page* page = editedFrame-&gt;page()) {
1298                     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
1299                     page-&gt;focusController().focusedOrMainFrame().selection().revealSelection(revealMode, ScrollAlignment::alignCenterIfNeeded);
1300                 }
1301         }
1302     }
1303 
1304     return true;
1305 }
1306 
1307 bool Editor::insertLineBreak()
1308 {
1309     if (!canEdit())
1310         return false;
1311 
1312     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1313         return true;
1314 
1315     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1316     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1317     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1318     TypingCommand::insertLineBreak(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
1319     revealSelectionAfterEditingOperation(alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded : ScrollAlignment::alignCenterIfNeeded);
1320 
1321     return true;
1322 }
1323 
1324 bool Editor::insertParagraphSeparator()
1325 {
1326     if (!canEdit())
1327         return false;
1328 
1329     if (!canEditRichly())
1330         return insertLineBreak();
1331 
1332     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1333         return true;
1334 
1335     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1336     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1337     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1338     TypingCommand::insertParagraphSeparator(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
1339     revealSelectionAfterEditingOperation(alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded : ScrollAlignment::alignCenterIfNeeded);
1340 
1341     return true;
1342 }
1343 
1344 bool Editor::insertParagraphSeparatorInQuotedContent()
1345 {
1346     // FIXME: Why is this missing calls to canEdit, canEditRichly, etc.?
1347     TypingCommand::insertParagraphSeparatorInQuotedContent(document());
1348     revealSelectionAfterEditingOperation();
1349     return true;
1350 }
1351 
1352 void Editor::cut()
1353 {
1354     if (tryDHTMLCut())
1355         return; // DHTML did the whole operation
1356     if (!canCut()) {
1357         PAL::systemBeep();
1358         return;
1359     }
1360 
1361     performCutOrCopy(CutAction);
1362 }
1363 
1364 void Editor::copy()
1365 {
1366     if (tryDHTMLCopy())
1367         return; // DHTML did the whole operation
1368     if (!canCopy()) {
1369         PAL::systemBeep();
1370         return;
1371     }
1372 
1373     performCutOrCopy(CopyAction);
1374 }
1375 
1376 void Editor::postTextStateChangeNotificationForCut(const String&amp; text, const VisibleSelection&amp; selection)
1377 {
1378     if (!AXObjectCache::accessibilityEnabled())
1379         return;
1380     if (!text.length())
1381         return;
1382     AXObjectCache* cache = document().existingAXObjectCache();
1383     if (!cache)
1384         return;
1385     cache-&gt;postTextStateChangeNotification(selection.start().anchorNode(), AXTextEditTypeCut, text, selection.start());
1386 }
1387 
1388 void Editor::performCutOrCopy(EditorActionSpecifier action)
1389 {
1390     RefPtr&lt;Range&gt; selection = selectedRange();
1391     willWriteSelectionToPasteboard(selection.get());
1392     if (action == CutAction) {
1393         if (!shouldDeleteRange(selection.get()))
1394             return;
1395 
1396         updateMarkersForWordsAffectedByEditing(true);
1397     }
1398 
1399     if (enclosingTextFormControl(m_frame.selection().selection().start()))
1400         Pasteboard::createForCopyAndPaste()-&gt;writePlainText(selectedTextForDataTransfer(), canSmartCopyOrDelete() ? Pasteboard::CanSmartReplace : Pasteboard::CannotSmartReplace);
1401     else {
1402         HTMLImageElement* imageElement = nullptr;
1403         if (action == CopyAction)
1404             imageElement = imageElementFromImageDocument(document());
1405 
1406         if (imageElement) {
1407 #if !PLATFORM(WIN)
1408             writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *imageElement, document().url(), document().title());
1409 #else
1410             // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1411             Pasteboard::createForCopyAndPaste()-&gt;writeImage(*imageElement, document().url(), document().title());
1412 #endif
1413         } else {
1414 #if !PLATFORM(WIN)
1415             writeSelectionToPasteboard(*Pasteboard::createForCopyAndPaste());
1416 #else
1417             // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1418             Pasteboard::createForCopyAndPaste()-&gt;writeSelection(*selection, canSmartCopyOrDelete(), m_frame, IncludeImageAltTextForDataTransfer);
1419 #endif
1420         }
1421     }
1422 
1423     didWriteSelectionToPasteboard();
1424     if (action == CutAction) {
1425         String text;
1426         if (AXObjectCache::accessibilityEnabled())
1427             text = AccessibilityObject::stringForVisiblePositionRange(m_frame.selection().selection());
1428         deleteSelectionWithSmartDelete(canSmartCopyOrDelete(), EditAction::Cut);
1429         if (AXObjectCache::accessibilityEnabled())
1430             postTextStateChangeNotificationForCut(text, m_frame.selection().selection());
1431     }
1432 }
1433 
1434 void Editor::paste()
1435 {
1436     paste(*Pasteboard::createForCopyAndPaste());
1437 }
1438 
1439 void Editor::paste(Pasteboard&amp; pasteboard)
1440 {
1441     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Paste))
1442         return; // DHTML did the whole operation
1443     if (!canPaste())
1444         return;
1445     updateMarkersForWordsAffectedByEditing(false);
1446     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1447     if (m_frame.selection().selection().isContentRichlyEditable())
1448         pasteWithPasteboard(&amp;pasteboard, { PasteOption::AllowPlainText });
1449     else
1450         pasteAsPlainTextWithPasteboard(pasteboard);
1451 }
1452 
1453 void Editor::pasteAsPlainText()
1454 {
1455     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsPlainText))
1456         return;
1457     if (!canPaste())
1458         return;
1459     updateMarkersForWordsAffectedByEditing(false);
1460     pasteAsPlainTextWithPasteboard(*Pasteboard::createForCopyAndPaste());
1461 }
1462 
1463 void Editor::pasteAsQuotation()
1464 {
1465     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsQuotation))
1466         return;
1467     if (!canPaste())
1468         return;
1469     updateMarkersForWordsAffectedByEditing(false);
1470     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1471     auto pasteboard = Pasteboard::createForCopyAndPaste();
1472     if (m_frame.selection().selection().isContentRichlyEditable())
1473         pasteWithPasteboard(pasteboard.get(), { PasteOption::AllowPlainText, PasteOption::AsQuotation });
1474     else
1475         pasteAsPlainTextWithPasteboard(*pasteboard);
1476 }
1477 
1478 void Editor::quoteFragmentForPasting(DocumentFragment&amp; fragment)
1479 {
1480     auto blockQuote = HTMLQuoteElement::create(blockquoteTag, document());
1481     blockQuote-&gt;setAttributeWithoutSynchronization(typeAttr, AtomString(&quot;cite&quot;));
1482     blockQuote-&gt;setAttributeWithoutSynchronization(classAttr, AtomString(ApplePasteAsQuotation));
1483 
1484     auto childNode = fragment.firstChild();
1485 
1486     if (childNode) {
1487         while (childNode) {
1488             blockQuote-&gt;appendChild(*childNode);
1489             childNode = fragment.firstChild();
1490         }
1491     } else
1492         blockQuote-&gt;appendChild(HTMLBRElement::create(document()));
1493 
1494     fragment.appendChild(blockQuote);
1495 }
1496 
1497 void Editor::performDelete()
1498 {
1499     if (!canDelete()) {
1500         PAL::systemBeep();
1501         return;
1502     }
1503 
1504     addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
1505     deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
1506 
1507     // clear the &quot;start new kill ring sequence&quot; setting, because it was set to true
1508     // when the selection was updated by deleting the range
1509     setStartNewKillRingSequence(false);
1510 }
1511 
1512 void Editor::changeSelectionListType()
1513 {
1514     if (auto type = ChangeListTypeCommand::listConversionType(document()))
1515         ChangeListTypeCommand::create(document(), *type)-&gt;apply();
1516 }
1517 
1518 void Editor::simplifyMarkup(Node* startNode, Node* endNode)
1519 {
1520     if (!startNode)
1521         return;
1522     if (endNode) {
1523         if (&amp;startNode-&gt;document() != &amp;endNode-&gt;document())
1524             return;
1525         // check if start node is before endNode
1526         Node* node = startNode;
1527         while (node &amp;&amp; node != endNode)
1528             node = NodeTraversal::next(*node);
1529         if (!node)
1530             return;
1531     }
1532 
1533     SimplifyMarkupCommand::create(document(), startNode, endNode ? NodeTraversal::next(*endNode) : nullptr)-&gt;apply();
1534 }
1535 
1536 void Editor::copyURL(const URL&amp; url, const String&amp; title)
1537 {
1538     copyURL(url, title, *Pasteboard::createForCopyAndPaste());
1539 }
1540 
1541 void Editor::copyURL(const URL&amp; url, const String&amp; title, Pasteboard&amp; pasteboard)
1542 {
1543     PasteboardURL pasteboardURL;
1544     pasteboardURL.url = url;
1545     pasteboardURL.title = title;
1546 
1547 #if PLATFORM(MAC)
1548     pasteboardURL.userVisibleForm = userVisibleString(url);
1549 #endif
1550 
1551     pasteboard.write(pasteboardURL);
1552 }
1553 
1554 PasteboardWriterData::URLData Editor::pasteboardWriterURL(const URL&amp; url, const String&amp; title)
1555 {
1556     PasteboardWriterData::URLData result;
1557 
1558     result.url = url;
1559     result.title = title;
1560 #if PLATFORM(MAC)
1561     result.userVisibleForm = userVisibleString(url);
1562 #endif
1563 
1564     return result;
1565 }
1566 
1567 #if !PLATFORM(IOS_FAMILY)
1568 
1569 void Editor::copyImage(const HitTestResult&amp; result)
1570 {
1571     Element* element = result.innerNonSharedElement();
1572     if (!element)
1573         return;
1574 
1575     URL url = result.absoluteLinkURL();
1576     if (url.isEmpty())
1577         url = result.absoluteImageURL();
1578 
1579 #if !PLATFORM(WIN)
1580     writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *element, url, result.altDisplayString());
1581 #else
1582     // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1583     Pasteboard::createForCopyAndPaste()-&gt;writeImage(*element, url, result.altDisplayString());
1584 #endif
1585 }
1586 
1587 #endif
1588 
1589 void Editor::revealSelectionIfNeededAfterLoadingImageForElement(HTMLImageElement&amp; element)
1590 {
1591     if (m_imageElementsToLoadBeforeRevealingSelection.isEmpty())
1592         return;
1593 
1594     if (!m_imageElementsToLoadBeforeRevealingSelection.remove(&amp;element))
1595         return;
1596 
1597     if (!m_imageElementsToLoadBeforeRevealingSelection.isEmpty())
1598         return;
1599 
1600     // FIXME: This should be queued as a task for the next rendering update.
1601     document().updateLayout();
1602     revealSelectionAfterEditingOperation();
1603 }
1604 
1605 void Editor::renderLayerDidScroll(const RenderLayer&amp; layer)
1606 {
1607     if (m_imageElementsToLoadBeforeRevealingSelection.isEmpty())
1608         return;
1609 
1610     auto startContainer = makeRefPtr(m_frame.selection().selection().start().containerNode());
1611     if (!startContainer)
1612         return;
1613 
1614     auto* startContainerRenderer = startContainer-&gt;renderer();
1615     if (!startContainerRenderer)
1616         return;
1617 
1618     // FIXME: Ideally, this would also cancel deferred selection revealing if the selection is inside a subframe and a parent frame is scrolled.
1619     for (auto* enclosingLayer = startContainerRenderer-&gt;enclosingLayer(); enclosingLayer; enclosingLayer = enclosingLayer-&gt;parent()) {
1620         if (enclosingLayer == &amp;layer) {
1621             m_imageElementsToLoadBeforeRevealingSelection.clear();
1622             break;
1623         }
1624     }
1625 }
1626 
1627 bool Editor::isContinuousSpellCheckingEnabled() const
1628 {
1629     return client() &amp;&amp; client()-&gt;isContinuousSpellCheckingEnabled();
1630 }
1631 
1632 void Editor::toggleContinuousSpellChecking()
1633 {
1634     if (client())
1635         client()-&gt;toggleContinuousSpellChecking();
1636 }
1637 
1638 bool Editor::isGrammarCheckingEnabled()
1639 {
1640     return client() &amp;&amp; client()-&gt;isGrammarCheckingEnabled();
1641 }
1642 
1643 void Editor::toggleGrammarChecking()
1644 {
1645     if (client())
1646         client()-&gt;toggleGrammarChecking();
1647 }
1648 
1649 int Editor::spellCheckerDocumentTag()
1650 {
1651     return client() ? client()-&gt;spellCheckerDocumentTag() : 0;
1652 }
1653 
1654 #if USE(APPKIT)
1655 
1656 void Editor::uppercaseWord()
1657 {
1658     if (client())
1659         client()-&gt;uppercaseWord();
1660 }
1661 
1662 void Editor::lowercaseWord()
1663 {
1664     if (client())
1665         client()-&gt;lowercaseWord();
1666 }
1667 
1668 void Editor::capitalizeWord()
1669 {
1670     if (client())
1671         client()-&gt;capitalizeWord();
1672 }
1673 
1674 #endif
1675 
1676 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
1677 
1678 void Editor::showSubstitutionsPanel()
1679 {
1680     if (!client()) {
1681         LOG_ERROR(&quot;No NSSpellChecker&quot;);
1682         return;
1683     }
1684 
1685     if (client()-&gt;substitutionsPanelIsShowing()) {
1686         client()-&gt;showSubstitutionsPanel(false);
1687         return;
1688     }
1689     client()-&gt;showSubstitutionsPanel(true);
1690 }
1691 
1692 bool Editor::substitutionsPanelIsShowing()
1693 {
1694     if (!client())
1695         return false;
1696     return client()-&gt;substitutionsPanelIsShowing();
1697 }
1698 
1699 void Editor::toggleSmartInsertDelete()
1700 {
1701     if (client())
1702         client()-&gt;toggleSmartInsertDelete();
1703 }
1704 
1705 bool Editor::isAutomaticQuoteSubstitutionEnabled()
1706 {
1707     return client() &amp;&amp; client()-&gt;isAutomaticQuoteSubstitutionEnabled();
1708 }
1709 
1710 void Editor::toggleAutomaticQuoteSubstitution()
1711 {
1712     if (client())
1713         client()-&gt;toggleAutomaticQuoteSubstitution();
1714 }
1715 
1716 bool Editor::isAutomaticLinkDetectionEnabled()
1717 {
1718     return client() &amp;&amp; client()-&gt;isAutomaticLinkDetectionEnabled();
1719 }
1720 
1721 void Editor::toggleAutomaticLinkDetection()
1722 {
1723     if (client())
1724         client()-&gt;toggleAutomaticLinkDetection();
1725 }
1726 
1727 bool Editor::isAutomaticDashSubstitutionEnabled()
1728 {
1729     return client() &amp;&amp; client()-&gt;isAutomaticDashSubstitutionEnabled();
1730 }
1731 
1732 void Editor::toggleAutomaticDashSubstitution()
1733 {
1734     if (client())
1735         client()-&gt;toggleAutomaticDashSubstitution();
1736 }
1737 
1738 bool Editor::isAutomaticTextReplacementEnabled()
1739 {
1740     return client() &amp;&amp; client()-&gt;isAutomaticTextReplacementEnabled();
1741 }
1742 
1743 void Editor::toggleAutomaticTextReplacement()
1744 {
1745     if (client())
1746         client()-&gt;toggleAutomaticTextReplacement();
1747 }
1748 
1749 bool Editor::isAutomaticSpellingCorrectionEnabled()
1750 {
1751     return m_alternativeTextController-&gt;isAutomaticSpellingCorrectionEnabled();
1752 }
1753 
1754 void Editor::toggleAutomaticSpellingCorrection()
1755 {
1756     if (client())
1757         client()-&gt;toggleAutomaticSpellingCorrection();
1758 }
1759 
1760 #endif
1761 
1762 bool Editor::shouldEndEditing(Range* range)
1763 {
1764     return client() &amp;&amp; client()-&gt;shouldEndEditing(range);
1765 }
1766 
1767 bool Editor::shouldBeginEditing(Range* range)
1768 {
1769     return client() &amp;&amp; client()-&gt;shouldBeginEditing(range);
1770 }
1771 
1772 void Editor::clearUndoRedoOperations()
1773 {
1774     if (client())
1775         client()-&gt;clearUndoRedoOperations();
1776 }
1777 
1778 bool Editor::canUndo() const
1779 {
1780     return client() &amp;&amp; client()-&gt;canUndo();
1781 }
1782 
1783 void Editor::undo()
1784 {
1785     if (client())
1786         client()-&gt;undo();
1787 }
1788 
1789 bool Editor::canRedo() const
1790 {
1791     return client() &amp;&amp; client()-&gt;canRedo();
1792 }
1793 
1794 void Editor::redo()
1795 {
1796     if (client())
1797         client()-&gt;redo();
1798 }
1799 
1800 void Editor::registerCustomUndoStep(Ref&lt;CustomUndoStep&gt;&amp;&amp; undoStep)
1801 {
1802     ASSERT(RuntimeEnabledFeatures::sharedFeatures().undoManagerAPIEnabled());
1803     if (auto* client = this-&gt;client())
1804         client-&gt;registerUndoStep(WTFMove(undoStep));
1805 }
1806 
1807 void Editor::didBeginEditing()
1808 {
1809     if (client())
1810         client()-&gt;didBeginEditing();
1811 }
1812 
1813 void Editor::didEndEditing()
1814 {
1815     if (client())
1816         client()-&gt;didEndEditing();
1817 }
1818 
1819 void Editor::willWriteSelectionToPasteboard(Range* range)
1820 {
1821     if (client())
1822         client()-&gt;willWriteSelectionToPasteboard(range);
1823 }
1824 
1825 void Editor::didWriteSelectionToPasteboard()
1826 {
1827     if (client())
1828         client()-&gt;didWriteSelectionToPasteboard();
1829 }
1830 
1831 void Editor::toggleBold()
1832 {
1833     command(&quot;ToggleBold&quot;).execute();
1834 }
1835 
1836 void Editor::toggleUnderline()
1837 {
1838     command(&quot;ToggleUnderline&quot;).execute();
1839 }
1840 
1841 void Editor::setBaseWritingDirection(WritingDirection direction)
1842 {
1843 #if PLATFORM(IOS_FAMILY)
1844     if (inSameParagraph(m_frame.selection().selection().visibleStart(), m_frame.selection().selection().visibleEnd()) &amp;&amp;
1845         baseWritingDirectionForSelectionStart() == direction)
1846         return;
1847 #endif
1848 
1849     Element* focusedElement = document().focusedElement();
1850     if (focusedElement &amp;&amp; focusedElement-&gt;isTextField()) {
1851         if (direction == WritingDirection::Natural)
1852             return;
1853 
1854         auto&amp; focusedFormElement = downcast&lt;HTMLTextFormControlElement&gt;(*focusedElement);
1855         auto directionValue = direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : &quot;rtl&quot;;
1856         auto writingDirectionInputTypeName = inputTypeNameForEditingAction(EditAction::SetBlockWritingDirection);
1857         if (!dispatchBeforeInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue))
1858             return;
1859 
1860         focusedFormElement.setAttributeWithoutSynchronization(dirAttr, directionValue);
1861         dispatchInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue);
1862         document().updateStyleIfNeeded();
1863         return;
1864     }
1865 
1866     auto style = MutableStyleProperties::create();
1867     style-&gt;setProperty(CSSPropertyDirection, direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : direction == WritingDirection::RightToLeft ? &quot;rtl&quot; : &quot;inherit&quot;, false);
1868     applyParagraphStyleToSelection(style.ptr(), EditAction::SetBlockWritingDirection);
1869 }
1870 
1871 WritingDirection Editor::baseWritingDirectionForSelectionStart() const
1872 {
1873     auto result = WritingDirection::LeftToRight;
1874 
1875     Position pos = m_frame.selection().selection().visibleStart().deepEquivalent();
1876     Node* node = pos.deprecatedNode();
1877     if (!node)
1878         return result;
1879 
1880     auto renderer = node-&gt;renderer();
1881     if (!renderer)
1882         return result;
1883 
1884     if (!renderer-&gt;isRenderBlockFlow()) {
1885         renderer = renderer-&gt;containingBlock();
1886         if (!renderer)
1887             return result;
1888     }
1889 
1890     switch (renderer-&gt;style().direction()) {
1891     case TextDirection::LTR:
1892         return WritingDirection::LeftToRight;
1893     case TextDirection::RTL:
1894         return WritingDirection::RightToLeft;
1895     }
1896 
1897     return result;
1898 }
1899 
1900 void Editor::selectComposition()
1901 {
1902     RefPtr&lt;Range&gt; range = compositionRange();
1903     if (!range)
1904         return;
1905 
1906     // The composition can start inside a composed character sequence, so we have to override checks.
1907     // See &lt;http://bugs.webkit.org/show_bug.cgi?id=15781&gt;
1908     VisibleSelection selection;
1909     selection.setWithoutValidation(range-&gt;startPosition(), range-&gt;endPosition());
1910     m_frame.selection().setSelection(selection, { });
1911 }
1912 
1913 void Editor::confirmComposition()
1914 {
1915     if (!m_compositionNode)
1916         return;
1917     setComposition(m_compositionNode-&gt;data().substring(m_compositionStart, m_compositionEnd - m_compositionStart), ConfirmComposition);
1918 }
1919 
1920 void Editor::cancelComposition()
1921 {
1922     if (!m_compositionNode)
1923         return;
1924     setComposition(emptyString(), CancelComposition);
1925 }
1926 
1927 bool Editor::cancelCompositionIfSelectionIsInvalid()
1928 {
1929     unsigned start;
1930     unsigned end;
1931     if (!hasComposition() || ignoreSelectionChanges() || getCompositionSelection(start, end))
1932         return false;
1933 
1934     cancelComposition();
1935     return true;
1936 }
1937 
1938 void Editor::confirmComposition(const String&amp; text)
1939 {
1940     setComposition(text, ConfirmComposition);
1941 }
1942 
1943 class SetCompositionScope {
1944 public:
1945     SetCompositionScope(Frame&amp; frame)
1946         : m_frame(frame)
1947         , m_typingGestureIndicator(frame)
1948     {
1949         m_frame-&gt;editor().setIgnoreSelectionChanges(true);
1950     }
1951 
1952     ~SetCompositionScope()
1953     {
1954         m_frame-&gt;editor().setIgnoreSelectionChanges(false);
1955         if (auto* editorClient = m_frame-&gt;editor().client())
1956             editorClient-&gt;didUpdateComposition();
1957     }
1958 
1959     Ref&lt;Frame&gt; m_frame;
1960     UserTypingGestureIndicator m_typingGestureIndicator;
1961 };
1962 
1963 void Editor::setComposition(const String&amp; text, SetCompositionMode mode)
1964 {
1965     ASSERT(mode == ConfirmComposition || mode == CancelComposition);
1966     SetCompositionScope setCompositionScope(m_frame);
1967 
1968     if (mode == CancelComposition)
1969         ASSERT(text == emptyString());
1970     else
1971         selectComposition();
1972 
1973     m_compositionNode = nullptr;
1974     m_customCompositionUnderlines.clear();
1975     m_customCompositionHighlights.clear();
1976 
1977     if (m_frame.selection().isNone())
1978         return;
1979 
1980     // Always delete the current composition before inserting the finalized composition text if we&#39;re confirming our composition.
1981     // Our default behavior (if the beforeinput event is not prevented) is to insert the finalized composition text back in.
1982     // We pass TypingCommand::TextCompositionPending here to indicate that we are deleting the pending composition.
1983     if (mode != CancelComposition)
1984         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionPending);
1985 
1986     insertTextForConfirmedComposition(text);
1987 
1988     if (auto* target = document().focusedElement())
1989         target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
1990 
1991     if (mode == CancelComposition) {
1992         // An open typing command that disagrees about current selection would cause issues with typing later on.
1993         TypingCommand::closeTyping(&amp;m_frame);
1994     }
1995 }
1996 
1997 void Editor::setComposition(const String&amp; text, const Vector&lt;CompositionUnderline&gt;&amp; underlines, const Vector&lt;CompositionHighlight&gt;&amp; highlights, unsigned selectionStart, unsigned selectionEnd)
1998 {
1999     SetCompositionScope setCompositionScope(m_frame);
2000 
2001     // Updates styles before setting selection for composition to prevent
2002     // inserting the previous composition text into text nodes oddly.
2003     // See https://bugs.webkit.org/show_bug.cgi?id=46868
2004     document().updateStyleIfNeeded();
2005 
2006     selectComposition();
2007 
2008     if (m_frame.selection().isNone())
2009         return;
2010 
2011     String originalText = selectedText();
2012     bool isStartingToRecomposeExistingRange = !text.isEmpty() &amp;&amp; selectionStart &lt; selectionEnd &amp;&amp; !hasComposition();
2013     if (isStartingToRecomposeExistingRange) {
2014         // We pass TypingCommand::TextCompositionFinal here to indicate that we are removing composition text that has been finalized.
2015         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionFinal);
2016         const VisibleSelection&amp; currentSelection = m_frame.selection().selection();
2017         if (currentSelection.isRange()) {
2018             // If deletion was prevented, then we need to collapse the selection to the end so that the original text will not be recomposed.
2019             m_frame.selection().setSelection({ currentSelection.end(), currentSelection.end() });
2020         }
2021     }
2022 
2023 #if PLATFORM(IOS_FAMILY)
2024     client()-&gt;startDelayingAndCoalescingContentChangeNotifications();
2025 #endif
2026 
2027     Element* target = document().focusedElement();
2028     if (target) {
2029         // Dispatch an appropriate composition event to the focused node.
2030         // We check the composition status and choose an appropriate composition event since this
2031         // function is used for three purposes:
2032         // 1. Starting a new composition.
2033         //    Send a compositionstart and a compositionupdate event when this function creates
2034         //    a new composition node, i.e.
2035         //    m_compositionNode == 0 &amp;&amp; !text.isEmpty().
2036         //    Sending a compositionupdate event at this time ensures that at least one
2037         //    compositionupdate event is dispatched.
2038         // 2. Updating the existing composition node.
2039         //    Send a compositionupdate event when this function updates the existing composition
2040         //    node, i.e. m_compositionNode != 0 &amp;&amp; !text.isEmpty().
2041         // 3. Canceling the ongoing composition.
2042         //    Send a compositionend event when function deletes the existing composition node, i.e.
2043         //    m_compositionNode != 0 &amp;&amp; test.isEmpty().
2044         RefPtr&lt;CompositionEvent&gt; event;
2045         if (!m_compositionNode) {
2046             // We should send a compositionstart event only when the given text is not empty because this
2047             // function doesn&#39;t create a composition node when the text is empty.
2048             if (!text.isEmpty()) {
2049                 target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionstartEvent, document().windowProxy(), originalText));
2050                 event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
2051             }
2052         } else if (!text.isEmpty())
2053             event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
2054 
2055         if (event)
2056             target-&gt;dispatchEvent(*event);
2057     }
2058 
2059     // If text is empty, then delete the old composition here.  If text is non-empty, InsertTextCommand::input
2060     // will delete the old composition with an optimized replace operation.
2061     if (text.isEmpty()) {
2062         TypingCommand::deleteSelection(document(), TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2063         if (target)
2064             target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
2065     }
2066 
2067     m_compositionNode = nullptr;
2068     m_customCompositionUnderlines.clear();
2069     m_customCompositionHighlights.clear();
2070 
2071     if (!text.isEmpty()) {
2072         TypingCommand::insertText(document(), text, TypingCommand::SelectInsertedText | TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2073 
2074         // Find out what node has the composition now.
2075         Position base = m_frame.selection().selection().base().downstream();
2076         Position extent = m_frame.selection().selection().extent();
2077         Node* baseNode = base.deprecatedNode();
2078         unsigned baseOffset = base.deprecatedEditingOffset();
2079         Node* extentNode = extent.deprecatedNode();
2080         unsigned extentOffset = extent.deprecatedEditingOffset();
2081 
2082         if (is&lt;Text&gt;(baseNode) &amp;&amp; baseNode == extentNode &amp;&amp; baseOffset + text.length() == extentOffset) {
2083             m_compositionNode = downcast&lt;Text&gt;(baseNode);
2084             m_compositionStart = baseOffset;
2085             m_compositionEnd = extentOffset;
2086             m_customCompositionUnderlines = underlines;
2087             for (auto&amp; underline : m_customCompositionUnderlines) {
2088                 underline.startOffset += baseOffset;
2089                 underline.endOffset += baseOffset;
2090             }
2091             m_customCompositionHighlights = highlights;
2092             for (auto&amp; highlight : m_customCompositionHighlights) {
2093                 highlight.startOffset += baseOffset;
2094                 highlight.endOffset += baseOffset;
2095             }
2096             if (baseNode-&gt;renderer())
2097                 baseNode-&gt;renderer()-&gt;repaint();
2098 
2099             unsigned start = std::min(baseOffset + selectionStart, extentOffset);
2100             unsigned end = std::min(std::max(start, baseOffset + selectionEnd), extentOffset);
2101             auto selectedRange = Range::create(baseNode-&gt;document(), baseNode, start, baseNode, end);
2102             m_frame.selection().setSelectedRange(selectedRange.ptr(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::No);
2103         }
2104     }
2105 
2106 #if PLATFORM(IOS_FAMILY)
2107     client()-&gt;stopDelayingAndCoalescingContentChangeNotifications();
2108 #endif
2109 }
2110 
2111 void Editor::ignoreSpelling()
2112 {
2113     if (!client())
2114         return;
2115 
2116     RefPtr&lt;Range&gt; selectedRange = m_frame.selection().toNormalizedRange();
2117     if (selectedRange)
2118         document().markers().removeMarkers(*selectedRange, DocumentMarker::Spelling);
2119 
2120     String text = selectedText();
2121     ASSERT(text.length());
2122     textChecker()-&gt;ignoreWordInSpellDocument(text);
2123 }
2124 
2125 void Editor::learnSpelling()
2126 {
2127     if (!client())
2128         return;
2129 
2130     // FIXME: On Mac OS X, when use &quot;learn&quot; button on &quot;Spelling and Grammar&quot; panel, we don&#39;t call this function. It should remove misspelling markers around the learned word, see &lt;rdar://problem/5396072&gt;.
2131 
2132     RefPtr&lt;Range&gt; selectedRange = m_frame.selection().toNormalizedRange();
2133     if (selectedRange)
2134         document().markers().removeMarkers(*selectedRange, DocumentMarker::Spelling);
2135 
2136     String text = selectedText();
2137     ASSERT(text.length());
2138     textChecker()-&gt;learnWord(text);
2139 }
2140 
2141 #if !PLATFORM(IOS_FAMILY)
2142 
2143 void Editor::advanceToNextMisspelling(bool startBeforeSelection)
2144 {
2145     Ref&lt;Frame&gt; protection(m_frame);
2146 
2147     // The basic approach is to search in two phases - from the selection end to the end of the doc, and
2148     // then we wrap and search from the doc start to (approximately) where we started.
2149 
2150     // Start at the end of the selection, search to edge of document.  Starting at the selection end makes
2151     // repeated &quot;check spelling&quot; commands work.
2152     VisibleSelection selection(m_frame.selection().selection());
2153     Ref&lt;Range&gt; spellingSearchRange = rangeOfContents(document());
2154 
2155     bool startedWithSelection = false;
2156     if (selection.start().deprecatedNode()) {
2157         startedWithSelection = true;
2158         if (startBeforeSelection) {
2159             VisiblePosition start(selection.visibleStart());
2160             // We match AppKit&#39;s rule: Start 1 character before the selection.
2161             VisiblePosition oneBeforeStart = start.previous();
2162             setStart(spellingSearchRange.ptr(), oneBeforeStart.isNotNull() ? oneBeforeStart : start);
2163         } else
2164             setStart(spellingSearchRange.ptr(), selection.visibleEnd());
2165     }
2166 
2167     Position position = spellingSearchRange-&gt;startPosition();
2168     if (!isEditablePosition(position)) {
2169         // This shouldn&#39;t happen in very often because the Spelling menu items aren&#39;t enabled unless the
2170         // selection is editable.
2171         // This can happen in Mail for a mix of non-editable and editable content (like Stationary),
2172         // when spell checking the whole document before sending the message.
2173         // In that case the document might not be editable, but there are editable pockets that need to be spell checked.
2174 
2175         position = VisiblePosition(firstEditablePositionAfterPositionInRoot(position, document().documentElement())).deepEquivalent();
2176         if (position.isNull())
2177             return;
2178 
2179         Position rangeCompliantPosition = position.parentAnchoredEquivalent();
2180         if (rangeCompliantPosition.deprecatedNode())
2181             spellingSearchRange-&gt;setStart(*rangeCompliantPosition.deprecatedNode(), rangeCompliantPosition.deprecatedEditingOffset());
2182         startedWithSelection = false; // won&#39;t need to wrap
2183     }
2184 
2185     // topNode defines the whole range we want to operate on
2186     auto* topNode = highestEditableRoot(position);
2187     // FIXME: lastOffsetForEditing() is wrong here if editingIgnoresContent(highestEditableRoot()) returns true (e.g. a &lt;table&gt;)
2188     if (topNode)
2189         spellingSearchRange-&gt;setEnd(*topNode, lastOffsetForEditing(*topNode));
2190 
2191     // If spellingSearchRange starts in the middle of a word, advance to the next word so we start checking
2192     // at a word boundary. Going back by one char and then forward by a word does the trick.
2193     if (startedWithSelection) {
2194         VisiblePosition oneBeforeStart = startVisiblePosition(spellingSearchRange.ptr(), DOWNSTREAM).previous();
2195         if (oneBeforeStart.isNotNull())
2196             setStart(spellingSearchRange.ptr(), endOfWord(oneBeforeStart));
2197         // else we were already at the start of the editable node
2198     }
2199 
2200     if (spellingSearchRange-&gt;collapsed())
2201         return; // nothing to search in
2202 
2203     // Get the spell checker if it is available
2204     if (!client())
2205         return;
2206 
2207     // We go to the end of our first range instead of the start of it, just to be sure
2208     // we don&#39;t get foiled by any word boundary problems at the start.  It means we might
2209     // do a tiny bit more searching.
2210     Node&amp; searchEndNodeAfterWrap = spellingSearchRange-&gt;endContainer();
2211     int searchEndOffsetAfterWrap = spellingSearchRange-&gt;endOffset();
2212 
2213     int misspellingOffset = 0;
2214     GrammarDetail grammarDetail;
2215     int grammarPhraseOffset = 0;
2216     RefPtr&lt;Range&gt; grammarSearchRange;
2217     String badGrammarPhrase;
2218     String misspelledWord;
2219 
2220     bool isSpelling = true;
2221     int foundOffset = 0;
2222     String foundItem;
2223     RefPtr&lt;Range&gt; firstMisspellingRange;
2224     if (unifiedTextCheckerEnabled()) {
2225         grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2226         foundItem = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspellingOrBadGrammar(isGrammarCheckingEnabled(), isSpelling, foundOffset, grammarDetail);
2227         if (isSpelling) {
2228             misspelledWord = foundItem;
2229             misspellingOffset = foundOffset;
2230         } else {
2231             badGrammarPhrase = foundItem;
2232             grammarPhraseOffset = foundOffset;
2233         }
2234     } else {
2235         misspelledWord = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspelling(misspellingOffset, false, firstMisspellingRange);
2236 
2237 #if USE(GRAMMAR_CHECKING)
2238         grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2239         if (!misspelledWord.isEmpty()) {
2240             // Stop looking at start of next misspelled word
2241             CharacterIterator chars(*grammarSearchRange);
2242             chars.advance(misspellingOffset);
2243             grammarSearchRange-&gt;setEnd(chars.range()-&gt;startContainer(), chars.range()-&gt;startOffset());
2244         }
2245 
2246         if (isGrammarCheckingEnabled())
2247             badGrammarPhrase = TextCheckingHelper(*client(), *grammarSearchRange).findFirstBadGrammar(grammarDetail, grammarPhraseOffset, false);
2248 #endif
2249     }
2250 
2251     // If we found neither bad grammar nor a misspelled word, wrap and try again (but don&#39;t bother if we started at the beginning of the
2252     // block rather than at a selection).
2253     if (startedWithSelection &amp;&amp; !misspelledWord &amp;&amp; !badGrammarPhrase) {
2254         if (topNode)
2255             spellingSearchRange-&gt;setStart(*topNode, 0);
2256         // going until the end of the very first chunk we tested is far enough
2257         spellingSearchRange-&gt;setEnd(searchEndNodeAfterWrap, searchEndOffsetAfterWrap);
2258 
2259         if (unifiedTextCheckerEnabled()) {
2260             grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2261             foundItem = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspellingOrBadGrammar(isGrammarCheckingEnabled(), isSpelling, foundOffset, grammarDetail);
2262             if (isSpelling) {
2263                 misspelledWord = foundItem;
2264                 misspellingOffset = foundOffset;
2265             } else {
2266                 badGrammarPhrase = foundItem;
2267                 grammarPhraseOffset = foundOffset;
2268             }
2269         } else {
2270             misspelledWord = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspelling(misspellingOffset, false, firstMisspellingRange);
2271 
2272 #if USE(GRAMMAR_CHECKING)
2273             grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2274             if (!misspelledWord.isEmpty()) {
2275                 // Stop looking at start of next misspelled word
2276                 CharacterIterator chars(*grammarSearchRange);
2277                 chars.advance(misspellingOffset);
2278                 grammarSearchRange-&gt;setEnd(chars.range()-&gt;startContainer(), chars.range()-&gt;startOffset());
2279             }
2280 
2281             if (isGrammarCheckingEnabled())
2282                 badGrammarPhrase = TextCheckingHelper(*client(), *grammarSearchRange).findFirstBadGrammar(grammarDetail, grammarPhraseOffset, false);
2283 #endif
2284         }
2285     }
2286 
2287 #if !USE(GRAMMAR_CHECKING)
2288     ASSERT(badGrammarPhrase.isEmpty());
2289     UNUSED_PARAM(grammarPhraseOffset);
2290 #else
2291     if (!badGrammarPhrase.isEmpty()) {
2292         // We found bad grammar. Since we only searched for bad grammar up to the first misspelled word, the bad grammar
2293         // takes precedence and we ignore any potential misspelled word. Select the grammar detail, update the spelling
2294         // panel, and store a marker so we draw the green squiggle later.
2295 
2296         ASSERT(badGrammarPhrase.length() &gt; 0);
2297         ASSERT(grammarDetail.location != -1 &amp;&amp; grammarDetail.length &gt; 0);
2298 
2299         // FIXME 4859190: This gets confused with doubled punctuation at the end of a paragraph
2300         auto badGrammarRange = TextIterator::subrange(*grammarSearchRange, grammarPhraseOffset + grammarDetail.location, grammarDetail.length);
2301         m_frame.selection().setSelection(VisibleSelection(badGrammarRange, SEL_DEFAULT_AFFINITY));
2302         m_frame.selection().revealSelection();
2303 
2304         client()-&gt;updateSpellingUIWithGrammarString(badGrammarPhrase, grammarDetail);
2305         document().markers().addMarker(badGrammarRange, DocumentMarker::Grammar, grammarDetail.userDescription);
2306     } else
2307 #endif
2308     if (!misspelledWord.isEmpty()) {
2309         // We found a misspelling, but not any earlier bad grammar. Select the misspelling, update the spelling panel, and store
2310         // a marker so we draw the red squiggle later.
2311 
2312         auto misspellingRange = TextIterator::subrange(spellingSearchRange, misspellingOffset, misspelledWord.length());
2313         m_frame.selection().setSelection(VisibleSelection(misspellingRange, DOWNSTREAM));
2314         m_frame.selection().revealSelection();
2315 
2316         client()-&gt;updateSpellingUIWithMisspelledWord(misspelledWord);
2317         document().markers().addMarker(misspellingRange, DocumentMarker::Spelling);
2318     }
2319 }
2320 
2321 #endif // !PLATFORM(IOS_FAMILY)
2322 
2323 String Editor::misspelledWordAtCaretOrRange(Node* clickedNode) const
2324 {
2325     if (!isContinuousSpellCheckingEnabled() || !clickedNode || !isSpellCheckingEnabledFor(clickedNode))
2326         return String();
2327 
2328     VisibleSelection selection = m_frame.selection().selection();
2329     if (!selection.isContentEditable() || selection.isNone())
2330         return String();
2331 
2332     VisibleSelection wordSelection(selection.base());
2333     wordSelection.expandUsingGranularity(WordGranularity);
2334     RefPtr&lt;Range&gt; wordRange = wordSelection.toNormalizedRange();
2335     if (!wordRange)
2336         return String();
2337 
2338     // In compliance with GTK+ applications, additionally allow to provide suggestions when the current
2339     // selection exactly match the word selection.
2340     if (selection.isRange() &amp;&amp; !areRangesEqual(wordRange.get(), selection.toNormalizedRange().get()))
2341         return String();
2342 
2343     String word = wordRange-&gt;text();
2344     if (word.isEmpty() || !client())
2345         return String();
2346 
2347     int wordLength = word.length();
2348     int misspellingLocation = -1;
2349     int misspellingLength = 0;
2350     textChecker()-&gt;checkSpellingOfString(word, &amp;misspellingLocation, &amp;misspellingLength);
2351 
2352     return misspellingLength == wordLength ? word : String();
2353 }
2354 
2355 String Editor::misspelledSelectionString() const
2356 {
2357     String selectedString = selectedText();
2358     int length = selectedString.length();
2359     if (!length || !client())
2360         return String();
2361 
2362     int misspellingLocation = -1;
2363     int misspellingLength = 0;
2364     textChecker()-&gt;checkSpellingOfString(selectedString, &amp;misspellingLocation, &amp;misspellingLength);
2365 
2366     // The selection only counts as misspelled if the selected text is exactly one misspelled word
2367     if (misspellingLength != length)
2368         return String();
2369 
2370     // Update the spelling panel to be displaying this error (whether or not the spelling panel is on screen).
2371     // This is necessary to make a subsequent call to [NSSpellChecker ignoreWord:inSpellDocumentWithTag:] work
2372     // correctly; that call behaves differently based on whether the spelling panel is displaying a misspelling
2373     // or a grammar error.
2374     client()-&gt;updateSpellingUIWithMisspelledWord(selectedString);
2375 
2376     return selectedString;
2377 }
2378 
2379 bool Editor::isSelectionUngrammatical()
2380 {
2381 #if USE(GRAMMAR_CHECKING)
2382     RefPtr&lt;Range&gt; range = m_frame.selection().toNormalizedRange();
2383     if (!range || !client())
2384         return false;
2385     return TextCheckingHelper(*client(), *range).isUngrammatical();
2386 #else
2387     return false;
2388 #endif
2389 }
2390 
2391 Vector&lt;String&gt; Editor::guessesForMisspelledWord(const String&amp; word) const
2392 {
2393     ASSERT(word.length());
2394 
2395     Vector&lt;String&gt; guesses;
2396     if (client())
2397         textChecker()-&gt;getGuessesForWord(word, String(), m_frame.selection().selection(), guesses);
2398     return guesses;
2399 }
2400 
2401 Vector&lt;String&gt; Editor::guessesForMisspelledOrUngrammatical(bool&amp; misspelled, bool&amp; ungrammatical)
2402 {
2403     if (unifiedTextCheckerEnabled()) {
2404         RefPtr&lt;Range&gt; range;
2405         VisibleSelection selection = m_frame.selection().selection();
2406         if (selection.isCaret() &amp;&amp; behavior().shouldAllowSpellingSuggestionsWithoutSelection()) {
2407             VisibleSelection wordSelection = VisibleSelection(selection.base());
2408             wordSelection.expandUsingGranularity(WordGranularity);
2409             range = wordSelection.toNormalizedRange();
2410         } else
2411             range = selection.toNormalizedRange();
2412         if (!range || !client())
2413             return Vector&lt;String&gt;();
2414         return TextCheckingHelper(*client(), *range).guessesForMisspelledOrUngrammaticalRange(isGrammarCheckingEnabled(), misspelled, ungrammatical);
2415     }
2416 
2417     String misspelledWord = behavior().shouldAllowSpellingSuggestionsWithoutSelection() ? misspelledWordAtCaretOrRange(document().focusedElement()) : misspelledSelectionString();
2418     misspelled = !misspelledWord.isEmpty();
2419     // Only unified text checker supports guesses for ungrammatical phrases.
2420     ungrammatical = false;
2421 
2422     if (misspelled)
2423         return guessesForMisspelledWord(misspelledWord);
2424     return Vector&lt;String&gt;();
2425 }
2426 
2427 void Editor::showSpellingGuessPanel()
2428 {
2429     if (!client()) {
2430         LOG_ERROR(&quot;No NSSpellChecker&quot;);
2431         return;
2432     }
2433 
2434     if (client()-&gt;spellingUIIsShowing()) {
2435         client()-&gt;showSpellingUI(false);
2436         return;
2437     }
2438 
2439 #if !PLATFORM(IOS_FAMILY)
2440     advanceToNextMisspelling(true);
2441 #endif
2442     client()-&gt;showSpellingUI(true);
2443 }
2444 
2445 bool Editor::spellingPanelIsShowing()
2446 {
2447     if (!client())
2448         return false;
2449     return client()-&gt;spellingUIIsShowing();
2450 }
2451 
2452 void Editor::clearMisspellingsAndBadGrammar(const VisibleSelection&amp; movingSelection)
2453 {
2454     if (auto selectedRange = movingSelection.toNormalizedRange())
2455         document().markers().removeMarkers(*selectedRange, { DocumentMarker::Spelling, DocumentMarker::Grammar });
2456 }
2457 
2458 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection &amp;movingSelection)
2459 {
2460     markMisspellingsAndBadGrammar(movingSelection, isContinuousSpellCheckingEnabled() &amp;&amp; isGrammarCheckingEnabled(), movingSelection);
2461 }
2462 
2463 void Editor::markMisspellingsAfterTypingToWord(const VisiblePosition &amp;wordStart, const VisibleSelection&amp; selectionAfterTyping, bool doReplacement)
2464 {
2465     Ref&lt;Frame&gt; protection(m_frame);
2466 
2467     if (platformDrivenTextCheckerEnabled())
2468         return;
2469 
2470 #if PLATFORM(IOS_FAMILY)
2471     UNUSED_PARAM(selectionAfterTyping);
2472     UNUSED_PARAM(doReplacement);
2473     OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2474     if (isContinuousSpellCheckingEnabled())
2475         textCheckingOptions.add(TextCheckingType::Spelling);
2476     if (!textCheckingOptions.contains(TextCheckingType::Spelling))
2477         return;
2478 
2479     VisibleSelection adjacentWords = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary));
2480     auto adjacentWordRange = adjacentWords.toNormalizedRange();
2481     markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, adjacentWordRange.copyRef(), adjacentWordRange.copyRef(), adjacentWordRange.copyRef());
2482 #else
2483 #if !USE(AUTOMATIC_TEXT_REPLACEMENT)
2484     UNUSED_PARAM(doReplacement);
2485 #endif
2486 
2487     if (unifiedTextCheckerEnabled()) {
2488         m_alternativeTextController-&gt;applyPendingCorrection(selectionAfterTyping);
2489 
2490         OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2491 
2492         if (isContinuousSpellCheckingEnabled())
2493             textCheckingOptions.add(TextCheckingType::Spelling);
2494 
2495 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2496         if (doReplacement
2497             &amp;&amp; (isAutomaticQuoteSubstitutionEnabled()
2498                 || isAutomaticLinkDetectionEnabled()
2499                 || isAutomaticDashSubstitutionEnabled()
2500                 || isAutomaticTextReplacementEnabled()
2501                 || (textCheckingOptions.contains(TextCheckingType::Spelling) &amp;&amp; isAutomaticSpellingCorrectionEnabled())))
2502             textCheckingOptions.add(TextCheckingType::Replacement);
2503 #endif
2504         if (!textCheckingOptions.contains(TextCheckingType::Spelling) &amp;&amp; !textCheckingOptions.contains(TextCheckingType::Replacement))
2505             return;
2506 
2507         if (isGrammarCheckingEnabled())
2508             textCheckingOptions.add(TextCheckingType::Grammar);
2509 
2510         auto sentenceStart = startOfSentence(wordStart);
2511         auto sentenceEnd = endOfSentence(wordStart);
2512         VisibleSelection fullSentence(sentenceStart, sentenceEnd);
2513         auto fullSentenceRange = fullSentence.toNormalizedRange();
2514         if (!fullSentenceRange)
2515             return;
2516 
2517         auto spellCheckingStart = wordStart;
2518         auto spellCheckingEnd = wordStart;
2519 
2520         // FIXME: The following logic doesn&#39;t handle adding spelling markers due to retro sentence corrections when an
2521         // incorrectly spelled range is separated from the start of the current word by a text node inside an element
2522         // with spellcheck disabled. To fix this, we need to refactor markAllMisspellingsAndBadGrammarInRanges so that
2523         // it can handle a list of spelling ranges, alongside the grammar range.
2524         while (sentenceStart &lt; spellCheckingStart) {
2525             auto previousPosition = spellCheckingStart.previous(CannotCrossEditingBoundary);
2526             if (previousPosition.isNull() || previousPosition == spellCheckingStart)
2527                 break;
2528 
2529             auto* container = previousPosition.deepEquivalent().downstream().containerNode();
2530             if (auto* containerElement = is&lt;Element&gt;(container) ? downcast&lt;Element&gt;(container) : container-&gt;parentElement()) {
2531                 if (!containerElement-&gt;isSpellCheckingEnabled())
2532                     break;
2533             }
2534 
2535             spellCheckingStart = previousPosition;
2536         }
2537 
2538         while (spellCheckingEnd &lt; sentenceEnd) {
2539             auto nextPosition = spellCheckingEnd.next(CannotCrossEditingBoundary);
2540             if (nextPosition.isNull() || nextPosition == spellCheckingEnd)
2541                 break;
2542 
2543             auto* container = nextPosition.deepEquivalent().upstream().containerNode();
2544             if (auto* containerElement = is&lt;Element&gt;(container) ? downcast&lt;Element&gt;(container) : container-&gt;parentElement()) {
2545                 if (!containerElement-&gt;isSpellCheckingEnabled())
2546                     break;
2547             }
2548 
2549             spellCheckingEnd = nextPosition;
2550         }
2551 
2552         auto spellCheckingRange = VisibleSelection(spellCheckingStart, spellCheckingEnd).toNormalizedRange();
2553         if (!spellCheckingRange)
2554             return;
2555 
2556         auto adjacentWordRange = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary)).toNormalizedRange();
2557         if (!adjacentWordRange)
2558             return;
2559 
2560         // The spelling and grammar markers in these ranges are recomputed. This is because typing a word may
2561         // cause any other part of the current sentence to lose or gain spelling correction markers, due to
2562         // sentence retro correction. As such, we expand the spell checking range to encompass as much of the
2563         // full sentence as we can, respecting boundaries where spellchecking is disabled.
2564         fullSentenceRange-&gt;ownerDocument().markers().removeMarkers(*fullSentenceRange, DocumentMarker::Grammar);
2565         spellCheckingRange-&gt;ownerDocument().markers().removeMarkers(*spellCheckingRange, DocumentMarker::Spelling);
2566         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, WTFMove(spellCheckingRange), WTFMove(adjacentWordRange), WTFMove(fullSentenceRange));
2567         return;
2568     }
2569 
2570     if (!isContinuousSpellCheckingEnabled())
2571         return;
2572 
2573     // Check spelling of one word
2574     RefPtr&lt;Range&gt; misspellingRange;
2575     markMisspellings(VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary)), misspellingRange);
2576 
2577     // Autocorrect the misspelled word.
2578     if (!misspellingRange)
2579         return;
2580 
2581     // Get the misspelled word.
2582     const String misspelledWord = plainText(misspellingRange.get());
2583     String autocorrectedString = textChecker()-&gt;getAutoCorrectSuggestionForMisspelledWord(misspelledWord);
2584 
2585     // If autocorrected word is non empty, replace the misspelled word by this word.
2586     if (!autocorrectedString.isEmpty()) {
2587         VisibleSelection newSelection(*misspellingRange, DOWNSTREAM);
2588         if (newSelection != m_frame.selection().selection()) {
2589             if (!m_frame.selection().shouldChangeSelection(newSelection))
2590                 return;
2591             m_frame.selection().setSelection(newSelection);
2592         }
2593 
2594         if (!m_frame.editor().shouldInsertText(autocorrectedString, misspellingRange.get(), EditorInsertAction::Typed))
2595             return;
2596         m_frame.editor().replaceSelectionWithText(autocorrectedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2597 
2598         // Reset the charet one character further.
2599         m_frame.selection().moveTo(m_frame.selection().selection().end());
2600         m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2601     }
2602 
2603     if (!isGrammarCheckingEnabled())
2604         return;
2605 
2606     // Check grammar of entire sentence
2607     markBadGrammar(VisibleSelection(startOfSentence(wordStart), endOfSentence(wordStart)));
2608 #endif
2609 }
2610 
2611 void Editor::markMisspellingsOrBadGrammar(const VisibleSelection&amp; selection, bool checkSpelling, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2612 {
2613 #if !PLATFORM(IOS_FAMILY)
2614     // This function is called with a selection already expanded to word boundaries.
2615     // Might be nice to assert that here.
2616 
2617     // This function is used only for as-you-type checking, so if that&#39;s off we do nothing. Note that
2618     // grammar checking can only be on if spell checking is also on.
2619     if (!isContinuousSpellCheckingEnabled())
2620         return;
2621 
2622     RefPtr&lt;Range&gt; searchRange(selection.toNormalizedRange());
2623     if (!searchRange)
2624         return;
2625 
2626     // If we&#39;re not in an editable node, bail.
2627     Node&amp; editableNode = searchRange-&gt;startContainer();
2628     if (!editableNode.hasEditableStyle())
2629         return;
2630 
2631     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2632         return;
2633 
2634     // Get the spell checker if it is available
2635     if (!client())
2636         return;
2637 
2638     TextCheckingHelper checker(*client(), *searchRange);
2639     if (checkSpelling)
2640         checker.markAllMisspellings(firstMisspellingRange);
2641     else {
2642 #if USE(GRAMMAR_CHECKING)
2643         if (isGrammarCheckingEnabled())
2644             checker.markAllBadGrammar();
2645 #else
2646         ASSERT_NOT_REACHED();
2647 #endif
2648     }
2649 #else
2650         UNUSED_PARAM(selection);
2651         UNUSED_PARAM(checkSpelling);
2652         UNUSED_PARAM(firstMisspellingRange);
2653 #endif // !PLATFORM(IOS_FAMILY)
2654 }
2655 
2656 bool Editor::isSpellCheckingEnabledFor(Node* node) const
2657 {
2658     if (!node)
2659         return false;
2660     Element* element = is&lt;Element&gt;(*node) ? downcast&lt;Element&gt;(node) : node-&gt;parentElement();
2661     if (!element)
2662         return false;
2663     if (element-&gt;isInUserAgentShadowTree()) {
2664         if (HTMLTextFormControlElement* textControl = enclosingTextFormControl(firstPositionInOrBeforeNode(element)))
2665             return textControl-&gt;isSpellCheckingEnabled();
2666     }
2667     return element-&gt;isSpellCheckingEnabled();
2668 }
2669 
2670 bool Editor::isSpellCheckingEnabledInFocusedNode() const
2671 {
2672     return isSpellCheckingEnabledFor(m_frame.selection().selection().start().deprecatedNode());
2673 }
2674 
2675 void Editor::markMisspellings(const VisibleSelection&amp; selection, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2676 {
2677     markMisspellingsOrBadGrammar(selection, true, firstMisspellingRange);
2678 }
2679 
2680 void Editor::markBadGrammar(const VisibleSelection&amp; selection)
2681 {
2682 #if USE(GRAMMAR_CHECKING)
2683     RefPtr&lt;Range&gt; firstMisspellingRange;
2684     markMisspellingsOrBadGrammar(selection, false, firstMisspellingRange);
2685 #else
2686     ASSERT_NOT_REACHED();
2687 #endif
2688 }
2689 
2690 void Editor::markAllMisspellingsAndBadGrammarInRanges(OptionSet&lt;TextCheckingType&gt; textCheckingOptions, RefPtr&lt;Range&gt;&amp;&amp; spellingRange, RefPtr&lt;Range&gt;&amp;&amp; automaticReplacementRange, RefPtr&lt;Range&gt;&amp;&amp; grammarRange)
2691 {
2692     if (platformDrivenTextCheckerEnabled())
2693         return;
2694 
2695     ASSERT(unifiedTextCheckerEnabled());
2696 
2697     // There shouldn&#39;t be pending autocorrection at this moment.
2698     ASSERT(!m_alternativeTextController-&gt;hasPendingCorrection());
2699 
2700     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2701     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2702 
2703     // This function is called with selections already expanded to word boundaries.
2704     if (!client() || !spellingRange || (shouldMarkGrammar &amp;&amp; !grammarRange))
2705         return;
2706 
2707     // If we&#39;re not in an editable node, bail.
2708     Node&amp; editableNode = spellingRange-&gt;startContainer();
2709     if (!editableNode.hasEditableStyle())
2710         return;
2711 
2712     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2713         return;
2714 
2715     auto rangeToCheck = shouldMarkGrammar ? grammarRange.releaseNonNull() : spellingRange.releaseNonNull();
2716     TextCheckingParagraph paragraphToCheck(rangeToCheck.get());
2717     if (paragraphToCheck.isEmpty())
2718         return;
2719 
2720     bool asynchronous = m_frame.settings().asynchronousSpellCheckingEnabled() &amp;&amp; !shouldShowCorrectionPanel;
2721 
2722     // In asynchronous mode, we intentionally check paragraph-wide sentence.
2723     const auto resolvedOptions = resolveTextCheckingTypeMask(editableNode, textCheckingOptions);
2724     auto textReplacementRange = automaticReplacementRange ? makeRef(*automaticReplacementRange) : rangeToCheck.copyRef();
2725     auto request = SpellCheckRequest::create(resolvedOptions, TextCheckingProcessIncremental, asynchronous ? makeRef(paragraphToCheck.paragraphRange()) : WTFMove(rangeToCheck), WTFMove(textReplacementRange), paragraphToCheck.paragraphRange());
2726     if (!request)
2727         return;
2728 
2729     if (asynchronous) {
2730         m_spellChecker-&gt;requestCheckingFor(request.releaseNonNull());
2731         return;
2732     }
2733 
2734     Vector&lt;TextCheckingResult&gt; results;
2735     checkTextOfParagraph(*textChecker(), paragraphToCheck.text(), resolvedOptions, results, m_frame.selection().selection());
2736     markAndReplaceFor(request.releaseNonNull(), results);
2737 }
2738 
2739 static bool isAutomaticTextReplacementType(TextCheckingType type)
2740 {
2741     switch (type) {
2742     case TextCheckingType::None:
2743     case TextCheckingType::Spelling:
2744     case TextCheckingType::Grammar:
2745         return false;
2746     case TextCheckingType::Link:
2747     case TextCheckingType::Quote:
2748     case TextCheckingType::Dash:
2749     case TextCheckingType::Replacement:
2750     case TextCheckingType::Correction:
2751     case TextCheckingType::ShowCorrectionPanel:
2752         return true;
2753     }
2754     ASSERT_NOT_REACHED();
2755     return false;
2756 }
2757 
2758 void Editor::replaceRangeForSpellChecking(Range&amp; rangeToReplace, const String&amp; replacement)
2759 {
2760     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();
2761 }
2762 
2763 static void correctSpellcheckingPreservingTextCheckingParagraph(TextCheckingParagraph&amp; paragraph, Range&amp; rangeToReplace, const String&amp; replacement, int resultLocation, int resultLength)
2764 {
2765     auto&amp; scope = downcast&lt;ContainerNode&gt;(paragraph.paragraphRange().startContainer().rootNode());
2766 
2767     size_t paragraphLocation;
2768     size_t paragraphLength;
2769     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;paragraph.paragraphRange(), paragraphLocation, paragraphLength);
2770 
2771     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();
2772 
2773     // TextCheckingParagraph may be orphaned after SpellingCorrectionCommand mutated DOM.
2774     // See &lt;rdar://10305315&gt;, http://webkit.org/b/89526.
2775 
2776     RefPtr&lt;Range&gt; newParagraphRange = TextIterator::rangeFromLocationAndLength(&amp;scope, paragraphLocation, paragraphLength + replacement.length() - resultLength);
2777 
2778     auto spellCheckingRange = TextIterator::subrange(*newParagraphRange, resultLocation, replacement.length());
2779     paragraph = TextCheckingParagraph(spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), newParagraphRange.get());
2780 }
2781 
2782 void Editor::markAndReplaceFor(const SpellCheckRequest&amp; request, const Vector&lt;TextCheckingResult&gt;&amp; results)
2783 {
2784     Ref&lt;Frame&gt; protection(m_frame);
2785 
2786     auto textCheckingOptions = request.data().checkingTypes();
2787     TextCheckingParagraph paragraph(request.checkingRange(), request.automaticReplacementRange(), &amp;request.paragraphRange());
2788 
2789     // FIXME: Mark this const once MSVC bug is fixed: &lt;https://developercommunity.visualstudio.com/content/problem/316713/msvc-cant-compile-webkits-optionsetcontainsany.html&gt;.
2790     bool shouldPerformReplacement = textCheckingOptions.containsAny({ TextCheckingType::Quote, TextCheckingType::Dash, TextCheckingType::Replacement });
2791     const bool shouldMarkSpelling = textCheckingOptions.contains(TextCheckingType::Spelling);
2792     const bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2793     const bool shouldMarkLink = textCheckingOptions.contains(TextCheckingType::Link);
2794     const bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2795     const bool shouldCheckForCorrection = shouldShowCorrectionPanel || textCheckingOptions.contains(TextCheckingType::Correction);
2796 #if !USE(AUTOCORRECTION_PANEL)
2797     ASSERT(!shouldShowCorrectionPanel);
2798 #endif
2799 
2800     // Expand the range to encompass entire paragraphs, since text checking needs that much context.
2801     int selectionOffset = 0;
2802     bool useAmbiguousBoundaryOffset = false;
2803     bool selectionChanged = false;
2804     bool restoreSelectionAfterChange = false;
2805     bool adjustSelectionForParagraphBoundaries = false;
2806 
2807     if (shouldPerformReplacement || shouldMarkSpelling || shouldCheckForCorrection) {
2808         if (m_frame.selection().selection().selectionType() == VisibleSelection::CaretSelection) {
2809             // Attempt to save the caret position so we can restore it later if needed
2810             Position caretPosition = m_frame.selection().selection().end();
2811             selectionOffset = paragraph.offsetTo(caretPosition).releaseReturnValue();
2812             restoreSelectionAfterChange = true;
2813             if (selectionOffset &gt; 0 &amp;&amp; (selectionOffset &gt; paragraph.textLength() || paragraph.textCharAt(selectionOffset - 1) == newlineCharacter))
2814                 adjustSelectionForParagraphBoundaries = true;
2815             if (selectionOffset &gt; 0 &amp;&amp; selectionOffset &lt;= paragraph.textLength() &amp;&amp; isAmbiguousBoundaryCharacter(paragraph.textCharAt(selectionOffset - 1)))
2816                 useAmbiguousBoundaryOffset = true;
2817         }
2818     }
2819 
2820     int offsetDueToReplacement = 0;
2821 
2822     for (unsigned i = 0; i &lt; results.size(); i++) {
2823         const int spellingRangeEndOffset = paragraph.checkingEnd() + offsetDueToReplacement;
2824         const TextCheckingType resultType = results[i].type;
2825         const int resultLocation = results[i].location + offsetDueToReplacement;
2826         const int resultLength = results[i].length;
2827         const int resultEndLocation = resultLocation + resultLength;
2828         const int automaticReplacementEndLocation = paragraph.automaticReplacementStart() + paragraph.automaticReplacementLength() + offsetDueToReplacement;
2829         const String&amp; replacement = results[i].replacement;
2830         const bool resultEndsAtAmbiguousBoundary = useAmbiguousBoundaryOffset &amp;&amp; selectionOffset - 1 &lt;= resultEndLocation;
2831 
2832         // Only mark misspelling if:
2833         // 1. Current text checking isn&#39;t done for autocorrection, in which case shouldMarkSpelling is false.
2834         // 2. Result falls within spellingRange.
2835         // 3. The word in question doesn&#39;t end at an ambiguous boundary. For instance, we would not mark
2836         //    &quot;wouldn&#39;&quot; as misspelled right after apostrophe is typed.
2837         if (shouldMarkSpelling &amp;&amp; !shouldShowCorrectionPanel &amp;&amp; resultType == TextCheckingType::Spelling
2838             &amp;&amp; resultLocation &gt;= paragraph.checkingStart() &amp;&amp; resultEndLocation &lt;= spellingRangeEndOffset &amp;&amp; !resultEndsAtAmbiguousBoundary) {
2839             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2840             auto misspellingRange = paragraph.subrange(resultLocation, resultLength);
2841             if (!m_alternativeTextController-&gt;isSpellingMarkerAllowed(misspellingRange))
2842                 continue;
2843             misspellingRange-&gt;startContainer().document().markers().addMarker(misspellingRange, DocumentMarker::Spelling, replacement);
2844         } else if (shouldMarkGrammar &amp;&amp; resultType == TextCheckingType::Grammar &amp;&amp; paragraph.checkingRangeCovers(resultLocation, resultLength)) {
2845             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2846             for (auto&amp; detail : results[i].details) {
2847                 ASSERT(detail.length &gt; 0 &amp;&amp; detail.location &gt;= 0);
2848                 if (paragraph.checkingRangeCovers(resultLocation + detail.location, detail.length)) {
2849                     auto badGrammarRange = paragraph.subrange(resultLocation + detail.location, detail.length);
2850                     badGrammarRange-&gt;startContainer().document().markers().addMarker(badGrammarRange, DocumentMarker::Grammar, detail.userDescription);
2851                 }
2852             }
2853         } else if (resultEndLocation &lt;= automaticReplacementEndLocation &amp;&amp; resultEndLocation &gt;= paragraph.automaticReplacementStart()
2854             &amp;&amp; isAutomaticTextReplacementType(resultType)) {
2855             // In this case the result range just has to touch the automatic replacement range, so we can handle replacing non-word text such as punctuation.
2856             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2857 
2858             if (shouldShowCorrectionPanel &amp;&amp; (resultEndLocation &lt; automaticReplacementEndLocation
2859                 || (resultType != TextCheckingType::Replacement &amp;&amp; resultType != TextCheckingType::Correction)))
2860                 continue;
2861 
2862             // Apply replacement if:
2863             // 1. The replacement length is non-zero.
2864             // 2. The result doesn&#39;t end at an ambiguous boundary.
2865             //    (FIXME: this is required until 6853027 is fixed and text checking can do this for us
2866             bool doReplacement = replacement.length() &gt; 0 &amp;&amp; !resultEndsAtAmbiguousBoundary;
2867             auto rangeToReplace = paragraph.subrange(resultLocation, resultLength);
2868 
2869             // Adding links should be done only immediately after they are typed.
2870             if (resultType == TextCheckingType::Link &amp;&amp; selectionOffset != resultEndLocation + 1)
2871                 continue;
2872 
2873             if (!(shouldPerformReplacement || shouldCheckForCorrection || shouldMarkLink) || !doReplacement)
2874                 continue;
2875 
2876             String replacedString = plainText(rangeToReplace.ptr());
2877             const bool existingMarkersPermitReplacement = m_alternativeTextController-&gt;processMarkersOnTextToBeReplacedByResult(results[i], rangeToReplace, replacedString);
2878             if (!existingMarkersPermitReplacement)
2879                 continue;
2880 
2881             if (shouldShowCorrectionPanel) {
2882                 if (resultEndLocation == automaticReplacementEndLocation) {
2883                     // We only show the correction panel on the last word.
2884                     m_alternativeTextController-&gt;show(rangeToReplace, replacement);
2885                     break;
2886                 }
2887                 // If this function is called for showing correction panel, we ignore other correction or replacement.
2888                 continue;
2889             }
2890 
2891             VisibleSelection selectionToReplace(rangeToReplace, DOWNSTREAM);
2892             if (selectionToReplace != m_frame.selection().selection()) {
2893                 if (!m_frame.selection().shouldChangeSelection(selectionToReplace))
2894                     continue;
2895             }
2896 
2897             if (resultType == TextCheckingType::Link) {
2898                 m_frame.selection().setSelection(selectionToReplace);
2899                 selectionChanged = true;
2900                 restoreSelectionAfterChange = false;
2901                 if (canEditRichly())
2902                     CreateLinkCommand::create(document(), replacement)-&gt;apply();
2903             } else if (canEdit() &amp;&amp; shouldInsertText(replacement, rangeToReplace.ptr(), EditorInsertAction::Typed)) {
2904                 correctSpellcheckingPreservingTextCheckingParagraph(paragraph, rangeToReplace, replacement, resultLocation, resultLength);
2905 
2906                 if (AXObjectCache* cache = document().existingAXObjectCache()) {
2907                     if (Element* root = m_frame.selection().selection().rootEditableElement())
2908                         cache-&gt;postNotification(root, AXObjectCache::AXAutocorrectionOccured);
2909                 }
2910 
2911                 // Skip all other results for the replaced text.
2912                 while (i + 1 &lt; results.size() &amp;&amp; results[i + 1].location + offsetDueToReplacement &lt;= resultLocation)
2913                     i++;
2914 
2915                 selectionChanged = true;
2916                 offsetDueToReplacement += replacement.length() - resultLength;
2917                 if (resultLocation &lt; selectionOffset)
2918                     selectionOffset += replacement.length() - resultLength;
2919 
2920                 if (resultType == TextCheckingType::Correction) {
2921                     auto replacementRange = paragraph.subrange(resultLocation, replacement.length());
2922                     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Accepted, replacedString, replacementRange.ptr());
2923 
2924                     // Add a marker so that corrections can easily be undone and won&#39;t be re-corrected.
2925                     m_alternativeTextController-&gt;markCorrection(replacementRange, replacedString);
2926                 }
2927             }
2928         }
2929     }
2930 
2931     if (selectionChanged) {
2932         TextCheckingParagraph extendedParagraph(WTFMove(paragraph));
2933         // Restore the caret position if we have made any replacements
2934         extendedParagraph.expandRangeToNextEnd();
2935         if (restoreSelectionAfterChange &amp;&amp; selectionOffset &gt;= 0 &amp;&amp; selectionOffset &lt;= extendedParagraph.rangeLength()) {
2936             auto selectionRange = extendedParagraph.subrange(0, selectionOffset);
2937             m_frame.selection().moveTo(selectionRange-&gt;endPosition(), DOWNSTREAM);
2938             if (adjustSelectionForParagraphBoundaries)
2939                 m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2940         } else {
2941             // If this fails for any reason, the fallback is to go one position beyond the last replacement
2942             m_frame.selection().moveTo(m_frame.selection().selection().end());
2943             m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2944         }
2945     }
2946 }
2947 
2948 void Editor::changeBackToReplacedString(const String&amp; replacedString)
2949 {
2950 #if !PLATFORM(IOS_FAMILY)
2951     ASSERT(unifiedTextCheckerEnabled());
2952 
2953     if (replacedString.isEmpty())
2954         return;
2955 
2956     RefPtr&lt;Range&gt; selection = selectedRange();
2957     if (!shouldInsertText(replacedString, selection.get(), EditorInsertAction::Pasted))
2958         return;
2959 
2960     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Reverted, replacedString, selection.get());
2961     TextCheckingParagraph paragraph(*selection);
2962     replaceSelectionWithText(replacedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2963     auto changedRange = paragraph.subrange(paragraph.checkingStart(), replacedString.length());
2964     changedRange-&gt;startContainer().document().markers().addMarker(changedRange, DocumentMarker::Replacement, String());
2965     m_alternativeTextController-&gt;markReversed(changedRange);
2966 #else
2967     ASSERT_NOT_REACHED();
2968     UNUSED_PARAM(replacedString);
2969 #endif // !PLATFORM(IOS_FAMILY)
2970 }
2971 
2972 
2973 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection&amp; spellingSelection, bool markGrammar, const VisibleSelection&amp; grammarSelection)
2974 {
2975     if (platformDrivenTextCheckerEnabled())
2976         return;
2977 
2978     if (unifiedTextCheckerEnabled()) {
2979         if (!isContinuousSpellCheckingEnabled())
2980             return;
2981 
2982         // markMisspellingsAndBadGrammar() is triggered by selection change, in which case we check spelling and grammar, but don&#39;t autocorrect misspellings.
2983         OptionSet&lt;TextCheckingType&gt; textCheckingOptions { TextCheckingType::Spelling };
2984         if (markGrammar &amp;&amp; isGrammarCheckingEnabled())
2985             textCheckingOptions.add(TextCheckingType::Grammar);
2986         auto spellCheckingRange = spellingSelection.toNormalizedRange();
2987         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), grammarSelection.toNormalizedRange());
2988         return;
2989     }
2990 
2991     RefPtr&lt;Range&gt; firstMisspellingRange;
2992     markMisspellings(spellingSelection, firstMisspellingRange);
2993     if (markGrammar)
2994         markBadGrammar(grammarSelection);
2995 }
2996 
2997 void Editor::unappliedSpellCorrection(const VisibleSelection&amp; selectionOfCorrected, const String&amp; corrected, const String&amp; correction)
2998 {
2999     m_alternativeTextController-&gt;respondToUnappliedSpellCorrection(selectionOfCorrected, corrected, correction);
3000 }
3001 
3002 void Editor::updateMarkersForWordsAffectedByEditing(bool doNotRemoveIfSelectionAtWordBoundary)
3003 {
3004     if (!document().markers().hasMarkers())
3005         return;
3006 
3007     if (!m_alternativeTextController-&gt;shouldRemoveMarkersUponEditing() &amp;&amp; (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Spelling)))
3008         return;
3009 
3010     // We want to remove the markers from a word if an editing command will change the word. This can happen in one of
3011     // several scenarios:
3012     // 1. Insert in the middle of a word.
3013     // 2. Appending non whitespace at the beginning of word.
3014     // 3. Appending non whitespace at the end of word.
3015     // Note that, appending only whitespaces at the beginning or end of word won&#39;t change the word, so we don&#39;t need to
3016     // remove the markers on that word.
3017     // Of course, if current selection is a range, we potentially will edit two words that fall on the boundaries of
3018     // selection, and remove words between the selection boundaries.
3019     //
3020     VisiblePosition startOfSelection = m_frame.selection().selection().start();
3021     VisiblePosition endOfSelection = m_frame.selection().selection().end();
3022     if (startOfSelection.isNull())
3023         return;
3024     // First word is the word that ends after or on the start of selection.
3025     VisiblePosition startOfFirstWord = startOfWord(startOfSelection, LeftWordIfOnBoundary);
3026     VisiblePosition endOfFirstWord = endOfWord(startOfSelection, LeftWordIfOnBoundary);
3027     // Last word is the word that begins before or on the end of selection
3028     VisiblePosition startOfLastWord = startOfWord(endOfSelection, RightWordIfOnBoundary);
3029     VisiblePosition endOfLastWord = endOfWord(endOfSelection, RightWordIfOnBoundary);
3030 
3031     if (startOfFirstWord.isNull()) {
3032         startOfFirstWord = startOfWord(startOfSelection, RightWordIfOnBoundary);
3033         endOfFirstWord = endOfWord(startOfSelection, RightWordIfOnBoundary);
3034     }
3035 
3036     if (endOfLastWord.isNull()) {
3037         startOfLastWord = startOfWord(endOfSelection, LeftWordIfOnBoundary);
3038         endOfLastWord = endOfWord(endOfSelection, LeftWordIfOnBoundary);
3039     }
3040 
3041     // If doNotRemoveIfSelectionAtWordBoundary is true, and first word ends at the start of selection,
3042     // we choose next word as the first word.
3043     if (doNotRemoveIfSelectionAtWordBoundary &amp;&amp; endOfFirstWord == startOfSelection) {
3044         startOfFirstWord = nextWordPosition(startOfFirstWord);
3045         endOfFirstWord = endOfWord(startOfFirstWord, RightWordIfOnBoundary);
3046         if (startOfFirstWord == endOfSelection)
3047             return;
3048     }
3049 
3050     // If doNotRemoveIfSelectionAtWordBoundary is true, and last word begins at the end of selection,
3051     // we choose previous word as the last word.
3052     if (doNotRemoveIfSelectionAtWordBoundary &amp;&amp; startOfLastWord == endOfSelection) {
3053         startOfLastWord = previousWordPosition(startOfLastWord);
3054         endOfLastWord = endOfWord(startOfLastWord, RightWordIfOnBoundary);
3055         if (endOfLastWord == startOfSelection)
3056             return;
3057     }
3058 
3059     if (startOfFirstWord.isNull() || endOfFirstWord.isNull() || startOfLastWord.isNull() || endOfLastWord.isNull())
3060         return;
3061 
3062     // Now we remove markers on everything between startOfFirstWord and endOfLastWord.
3063     // However, if an autocorrection change a single word to multiple words, we want to remove correction mark from all the
3064     // resulted words even we only edit one of them. For example, assuming autocorrection changes &quot;avantgarde&quot; to &quot;avant
3065     // garde&quot;, we will have CorrectionIndicator marker on both words and on the whitespace between them. If we then edit garde,
3066     // we would like to remove the marker from word &quot;avant&quot; and whitespace as well. So we need to get the continous range of
3067     // of marker that contains the word in question, and remove marker on that whole range.
3068     auto wordRange = Range::create(document(), startOfFirstWord.deepEquivalent(), endOfLastWord.deepEquivalent());
3069 
3070     Vector&lt;RenderedDocumentMarker*&gt; markers = document().markers().markersInRange(wordRange, DocumentMarker::DictationAlternatives);
3071     for (auto* marker : markers)
3072         m_alternativeTextController-&gt;removeDictationAlternativesForMarker(*marker);
3073 
3074     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypesToRemove {
3075         DocumentMarker::CorrectionIndicator,
3076         DocumentMarker::DictationAlternatives,
3077         DocumentMarker::SpellCheckingExemption,
3078         DocumentMarker::Spelling,
3079 #if !PLATFORM(IOS_FAMILY)
3080         DocumentMarker::Grammar,
3081 #endif
3082     };
3083     document().markers().removeMarkers(wordRange, markerTypesToRemove, DocumentMarkerController::RemovePartiallyOverlappingMarker);
3084     document().markers().clearDescriptionOnMarkersIntersectingRange(wordRange, DocumentMarker::Replacement);
3085 }
3086 
3087 void Editor::deletedAutocorrectionAtPosition(const Position&amp; position, const String&amp; originalString)
3088 {
3089     m_alternativeTextController-&gt;deletedAutocorrectionAtPosition(position, originalString);
3090 }
3091 
3092 RefPtr&lt;Range&gt; Editor::rangeForPoint(const IntPoint&amp; windowPoint)
3093 {
3094     Document* document = m_frame.documentAtPoint(windowPoint);
3095     if (!document)
3096         return nullptr;
3097 
3098     Frame* frame = document-&gt;frame();
3099     ASSERT(frame);
3100     FrameView* frameView = frame-&gt;view();
3101     if (!frameView)
3102         return nullptr;
3103     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
3104     VisibleSelection selection(frame-&gt;visiblePositionForPoint(framePoint));
3105 
3106     return selection.toNormalizedRange();
3107 }
3108 
3109 void Editor::revealSelectionAfterEditingOperation(const ScrollAlignment&amp; alignment, RevealExtentOption revealExtentOption)
3110 {
3111     if (m_ignoreSelectionChanges)
3112         return;
3113 
3114     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
3115     m_frame.selection().revealSelection(revealMode, alignment, revealExtentOption);
3116 }
3117 
3118 void Editor::setIgnoreSelectionChanges(bool ignore, RevealSelection shouldRevealExistingSelection)
3119 {
3120     if (m_ignoreSelectionChanges == ignore)
3121         return;
3122 
3123     m_ignoreSelectionChanges = ignore;
3124 #if PLATFORM(IOS_FAMILY)
3125     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3126     if (!ignore)
3127         respondToChangedSelection(m_frame.selection().selection(), { });
3128 #endif
3129     if (!ignore &amp;&amp; shouldRevealExistingSelection == RevealSelection::Yes)
3130         revealSelectionAfterEditingOperation(ScrollAlignment::alignToEdgeIfNeeded, RevealExtent);
3131 }
3132 
3133 RefPtr&lt;Range&gt; Editor::compositionRange() const
3134 {
3135     if (!m_compositionNode)
3136         return nullptr;
3137     unsigned length = m_compositionNode-&gt;length();
3138     unsigned start = std::min(m_compositionStart, length);
3139     unsigned end = std::min(std::max(start, m_compositionEnd), length);
3140     // FIXME: Why is this early return neeed?
3141     if (start &gt;= end)
3142         return nullptr;
3143     return Range::create(m_compositionNode-&gt;document(), m_compositionNode.get(), start, m_compositionNode.get(), end);
3144 }
3145 
3146 bool Editor::getCompositionSelection(unsigned&amp; selectionStart, unsigned&amp; selectionEnd) const
3147 {
3148     if (!m_compositionNode)
3149         return false;
3150     const VisibleSelection&amp; selection = m_frame.selection().selection();
3151     Position start = selection.start();
3152     if (start.deprecatedNode() != m_compositionNode)
3153         return false;
3154     Position end = selection.end();
3155     if (end.deprecatedNode() != m_compositionNode)
3156         return false;
3157 
3158     if (static_cast&lt;unsigned&gt;(start.deprecatedEditingOffset()) &lt; m_compositionStart)
3159         return false;
3160     if (static_cast&lt;unsigned&gt;(end.deprecatedEditingOffset()) &gt; m_compositionEnd)
3161         return false;
3162 
3163     selectionStart = start.deprecatedEditingOffset() - m_compositionStart;
3164     selectionEnd = start.deprecatedEditingOffset() - m_compositionEnd;
3165     return true;
3166 }
3167 
3168 void Editor::transpose()
3169 {
3170     if (!canEdit())
3171         return;
3172 
3173     VisibleSelection selection = m_frame.selection().selection();
3174     if (!selection.isCaret())
3175         return;
3176 
3177     // Make a selection that goes back one character and forward two characters.
3178     VisiblePosition caret = selection.visibleStart();
3179     VisiblePosition next = isEndOfParagraph(caret) ? caret : caret.next();
3180     VisiblePosition previous = next.previous();
3181     if (next == previous)
3182         return;
3183     previous = previous.previous();
3184     if (!inSameParagraph(next, previous))
3185         return;
3186     RefPtr&lt;Range&gt; range = makeRange(previous, next);
3187     if (!range)
3188         return;
3189     VisibleSelection newSelection(*range, DOWNSTREAM);
3190 
3191     // Transpose the two characters.
3192     String text = plainText(range.get());
3193     if (text.length() != 2)
3194         return;
3195     String transposed = text.right(1) + text.left(1);
3196 
3197     // Select the two characters.
3198     if (newSelection != m_frame.selection().selection()) {
3199         if (!m_frame.selection().shouldChangeSelection(newSelection))
3200             return;
3201         m_frame.selection().setSelection(newSelection);
3202     }
3203 
3204     // Insert the transposed characters.
3205     if (!shouldInsertText(transposed, range.get(), EditorInsertAction::Typed))
3206         return;
3207     replaceSelectionWithText(transposed, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
3208 }
3209 
3210 void Editor::addRangeToKillRing(const Range&amp; range, KillRingInsertionMode mode)
3211 {
3212     addTextToKillRing(plainText(&amp;range), mode);
3213 }
3214 
3215 void Editor::addTextToKillRing(const String&amp; text, KillRingInsertionMode mode)
3216 {
3217     if (m_shouldStartNewKillRingSequence)
3218         killRing().startNewSequence();
3219 
3220     m_shouldStartNewKillRingSequence = false;
3221 
3222     // If the kill was from a backwards motion, prepend to the kill ring.
3223     // This will ensure that alternating forward and backward kills will
3224     // build up the original string in the kill ring without permuting it.
3225     switch (mode) {
3226     case KillRingInsertionMode::PrependText:
3227         killRing().prepend(text);
3228         break;
3229     case KillRingInsertionMode::AppendText:
3230         killRing().append(text);
3231         break;
3232     }
3233 }
3234 
3235 void Editor::startAlternativeTextUITimer()
3236 {
3237     m_alternativeTextController-&gt;startAlternativeTextUITimer(AlternativeTextTypeCorrection);
3238 }
3239 
3240 void Editor::handleAlternativeTextUIResult(const String&amp; correction)
3241 {
3242     m_alternativeTextController-&gt;handleAlternativeTextUIResult(correction);
3243 }
3244 
3245 
3246 void Editor::dismissCorrectionPanelAsIgnored()
3247 {
3248     m_alternativeTextController-&gt;dismiss(ReasonForDismissingAlternativeTextIgnored);
3249 }
3250 
3251 void Editor::changeSelectionAfterCommand(const VisibleSelection&amp; newSelection, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3252 {
3253     Ref&lt;Frame&gt; protection(m_frame);
3254 
3255     // If the new selection is orphaned, then don&#39;t update the selection.
3256     if (newSelection.start().isOrphan() || newSelection.end().isOrphan())
3257         return;
3258 
3259     // If there is no selection change, don&#39;t bother sending shouldChangeSelection, but still call setSelection,
3260     // because there is work that it must do in this situation.
3261     // The old selection can be invalid here and calling shouldChangeSelection can produce some strange calls.
3262     // See &lt;rdar://problem/5729315&gt; Some shouldChangeSelectedDOMRange contain Ranges for selections that are no longer valid
3263     bool selectionDidNotChangeDOMPosition = newSelection == m_frame.selection().selection();
3264     if (selectionDidNotChangeDOMPosition || m_frame.selection().shouldChangeSelection(newSelection))
3265         m_frame.selection().setSelection(newSelection, options);
3266 
3267     // Some editing operations change the selection visually without affecting its position within the DOM.
3268     // For example when you press return in the following (the caret is marked by ^):
3269     // &lt;div contentEditable=&quot;true&quot;&gt;&lt;div&gt;^Hello&lt;/div&gt;&lt;/div&gt;
3270     // WebCore inserts &lt;div&gt;&lt;br&gt;&lt;/div&gt; *before* the current block, which correctly moves the paragraph down but which doesn&#39;t
3271     // change the caret&#39;s DOM position ([&quot;hello&quot;, 0]). In these situations the above FrameSelection::setSelection call
3272     // does not call EditorClient::respondToChangedSelection(), which, on the Mac, sends selection change notifications and
3273     // starts a new kill ring sequence, but we want to do these things (matches AppKit).
3274 #if PLATFORM(IOS_FAMILY)
3275     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3276     if (m_ignoreSelectionChanges)
3277         return;
3278 #endif
3279     if (selectionDidNotChangeDOMPosition &amp;&amp; client())
3280         client()-&gt;respondToChangedSelection(&amp;m_frame);
3281 }
3282 
3283 String Editor::selectedText() const
3284 {
3285     TextIteratorBehavior behavior = TextIteratorDefaultBehavior;
3286     if (m_frame.settings().selectionAcrossShadowBoundariesEnabled())
3287         behavior |= TextIteratorTraversesFlatTree;
3288     return selectedText(behavior);
3289 }
3290 
3291 String Editor::selectedTextForDataTransfer() const
3292 {
3293     TextIteratorBehavior behavior = TextIteratorEmitsImageAltText;
3294     if (m_frame.settings().selectionAcrossShadowBoundariesEnabled())
3295         behavior |= TextIteratorTraversesFlatTree;
3296     return selectedText(behavior);
3297 }
3298 
3299 String Editor::selectedText(TextIteratorBehavior behavior) const
3300 {
3301     // We remove &#39;\0&#39; characters because they are not visibly rendered to the user.
3302     auto&amp; selection = m_frame.selection().selection();
3303     return plainText(selection.start(), selection.end(), behavior).replaceWithLiteral(&#39;\0&#39;, &quot;&quot;);
3304 }
3305 
3306 static inline void collapseCaretWidth(IntRect&amp; rect)
3307 {
3308     // FIXME: Width adjustment doesn&#39;t work for rotated text.
3309     if (rect.width() == caretWidth)
3310         rect.setWidth(0);
3311     else if (rect.height() == caretWidth)
3312         rect.setHeight(0);
3313 }
3314 
3315 IntRect Editor::firstRectForRange(Range* range) const
3316 {
3317     VisiblePosition startVisiblePosition(range-&gt;startPosition(), DOWNSTREAM);
3318 
3319     if (range-&gt;collapsed()) {
3320         // FIXME: Getting caret rect and removing caret width is a very roundabout way to get collapsed range location.
3321         // In particular, width adjustment doesn&#39;t work for rotated text.
3322         IntRect startCaretRect = RenderedPosition(startVisiblePosition).absoluteRect();
3323         collapseCaretWidth(startCaretRect);
3324         return startCaretRect;
3325     }
3326 
3327     VisiblePosition endVisiblePosition(range-&gt;endPosition(), UPSTREAM);
3328 
3329     if (inSameLine(startVisiblePosition, endVisiblePosition))
3330         return enclosingIntRect(RenderObject::absoluteBoundingBoxRectForRange(range));
3331 
3332     LayoutUnit extraWidthToEndOfLine;
3333     IntRect startCaretRect = RenderedPosition(startVisiblePosition).absoluteRect(&amp;extraWidthToEndOfLine);
3334     if (startCaretRect == IntRect())
3335         return IntRect();
3336 
3337     // When start and end aren&#39;t on the same line, we want to go from start to the end of its line.
3338     bool textIsHorizontal = startCaretRect.width() == caretWidth;
3339     return textIsHorizontal ?
3340         IntRect(startCaretRect.x(),
3341             startCaretRect.y(),
3342             startCaretRect.width() + extraWidthToEndOfLine,
3343             startCaretRect.height()) :
3344         IntRect(startCaretRect.x(),
3345             startCaretRect.y(),
3346             startCaretRect.width(),
3347             startCaretRect.height() + extraWidthToEndOfLine);
3348 }
3349 
3350 bool Editor::shouldChangeSelection(const VisibleSelection&amp; oldSelection, const VisibleSelection&amp; newSelection, EAffinity affinity, bool stillSelecting) const
3351 {
3352 #if PLATFORM(IOS_FAMILY)
3353     if (m_frame.selectionChangeCallbacksDisabled())
3354         return true;
3355 #endif
3356     return client() &amp;&amp; client()-&gt;shouldChangeSelectedRange(oldSelection.toNormalizedRange().get(), newSelection.toNormalizedRange().get(), affinity, stillSelecting);
3357 }
3358 
3359 void Editor::computeAndSetTypingStyle(EditingStyle&amp; style, EditAction editingAction)
3360 {
3361     if (style.isEmpty()) {
3362         m_frame.selection().clearTypingStyle();
3363         return;
3364     }
3365 
3366     // Calculate the current typing style.
3367     RefPtr&lt;EditingStyle&gt; typingStyle;
3368     if (auto existingTypingStyle = m_frame.selection().typingStyle())
3369         typingStyle = existingTypingStyle-&gt;copy();
3370     else
3371         typingStyle = EditingStyle::create();
3372     typingStyle-&gt;overrideTypingStyleAt(style, m_frame.selection().selection().visibleStart().deepEquivalent());
3373 
3374     // Handle block styles, substracting these from the typing style.
3375     RefPtr&lt;EditingStyle&gt; blockStyle = typingStyle-&gt;extractAndRemoveBlockProperties();
3376     if (!blockStyle-&gt;isEmpty())
3377         ApplyStyleCommand::create(document(), blockStyle.get(), editingAction)-&gt;apply();
3378 
3379     // Set the remaining style as the typing style.
3380     m_frame.selection().setTypingStyle(WTFMove(typingStyle));
3381 }
3382 
3383 void Editor::computeAndSetTypingStyle(StyleProperties&amp; properties, EditAction editingAction)
3384 {
3385     return computeAndSetTypingStyle(EditingStyle::create(&amp;properties), editingAction);
3386 }
3387 
3388 void Editor::textFieldDidBeginEditing(Element* e)
3389 {
3390     if (client())
3391         client()-&gt;textFieldDidBeginEditing(e);
3392 }
3393 
3394 void Editor::textFieldDidEndEditing(Element* e)
3395 {
3396     dismissCorrectionPanelAsIgnored();
3397     if (client())
3398         client()-&gt;textFieldDidEndEditing(e);
3399 }
3400 
3401 void Editor::textDidChangeInTextField(Element* e)
3402 {
3403     if (client())
3404         client()-&gt;textDidChangeInTextField(e);
3405 }
3406 
3407 bool Editor::doTextFieldCommandFromEvent(Element* e, KeyboardEvent* ke)
3408 {
3409     if (client())
3410         return client()-&gt;doTextFieldCommandFromEvent(e, ke);
3411 
3412     return false;
3413 }
3414 
3415 void Editor::textWillBeDeletedInTextField(Element* input)
3416 {
3417     if (client())
3418         client()-&gt;textWillBeDeletedInTextField(input);
3419 }
3420 
3421 void Editor::textDidChangeInTextArea(Element* e)
3422 {
3423     if (client())
3424         client()-&gt;textDidChangeInTextArea(e);
3425 }
3426 
3427 void Editor::applyEditingStyleToBodyElement() const
3428 {
3429     auto collection = document().getElementsByTagName(HTMLNames::bodyTag-&gt;localName());
3430     unsigned length = collection-&gt;length();
3431     for (unsigned i = 0; i &lt; length; ++i)
3432         applyEditingStyleToElement(collection-&gt;item(i));
3433 }
3434 
3435 void Editor::applyEditingStyleToElement(Element* element) const
3436 {
3437     ASSERT(!element || is&lt;StyledElement&gt;(*element));
3438     if (!is&lt;StyledElement&gt;(element))
3439         return;
3440 
3441     // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
3442     auto&amp; style = downcast&lt;StyledElement&gt;(*element).cssomStyle();
3443     style.setPropertyInternal(CSSPropertyWordWrap, &quot;break-word&quot;, false);
3444     style.setPropertyInternal(CSSPropertyWebkitNbspMode, &quot;space&quot;, false);
3445     style.setPropertyInternal(CSSPropertyLineBreak, &quot;after-white-space&quot;, false);
3446 }
3447 
3448 bool Editor::findString(const String&amp; target, FindOptions options)
3449 {
3450     Ref&lt;Frame&gt; protection(m_frame);
3451 
3452     VisibleSelection selection = m_frame.selection().selection();
3453 
3454     RefPtr&lt;Range&gt; resultRange = rangeOfString(target, selection.firstRange().get(), options);
3455 
3456     if (!resultRange)
3457         return false;
3458 
3459     m_frame.selection().setSelection(VisibleSelection(*resultRange, DOWNSTREAM));
3460 
3461     if (!(options.contains(DoNotRevealSelection)))
3462         m_frame.selection().revealSelection();
3463 
3464     return true;
3465 }
3466 
3467 RefPtr&lt;Range&gt; Editor::rangeOfString(const String&amp; target, Range* referenceRange, FindOptions options)
3468 {
3469     if (target.isEmpty())
3470         return nullptr;
3471 
3472     // Start from an edge of the reference range, if there&#39;s a reference range that&#39;s not in shadow content. Which edge
3473     // is used depends on whether we&#39;re searching forward or backward, and whether startInSelection is set.
3474     RefPtr&lt;Range&gt; searchRange(rangeOfContents(document()));
3475 
3476     bool forward = !options.contains(Backwards);
3477     bool startInReferenceRange = referenceRange &amp;&amp; options.contains(StartInSelection);
3478     if (referenceRange) {
3479         if (forward)
3480             searchRange-&gt;setStart(startInReferenceRange ? referenceRange-&gt;startPosition() : referenceRange-&gt;endPosition());
3481         else
3482             searchRange-&gt;setEnd(startInReferenceRange ? referenceRange-&gt;endPosition() : referenceRange-&gt;startPosition());
3483     }
3484 
3485     RefPtr&lt;ShadowRoot&gt; shadowTreeRoot = referenceRange ? referenceRange-&gt;startContainer().containingShadowRoot() : nullptr;
3486     if (shadowTreeRoot) {
3487         if (forward)
3488             searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3489         else
3490             searchRange-&gt;setStart(*shadowTreeRoot, 0);
3491     }
3492 
3493     RefPtr&lt;Range&gt; resultRange = findPlainText(*searchRange, target, options);
3494     // If we started in the reference range and the found range exactly matches the reference range, find again.
3495     // Build a selection with the found range to remove collapsed whitespace.
3496     // Compare ranges instead of selection objects to ignore the way that the current selection was made.
3497     if (startInReferenceRange &amp;&amp; areRangesEqual(VisibleSelection(*resultRange).toNormalizedRange().get(), referenceRange)) {
3498         searchRange = rangeOfContents(document());
3499         if (forward)
3500             searchRange-&gt;setStart(referenceRange-&gt;endPosition());
3501         else
3502             searchRange-&gt;setEnd(referenceRange-&gt;startPosition());
3503 
3504         if (shadowTreeRoot) {
3505             if (forward)
3506                 searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3507             else
3508                 searchRange-&gt;setStart(*shadowTreeRoot, 0);
3509         }
3510 
3511         resultRange = findPlainText(*searchRange, target, options);
3512     }
3513 
3514     // If nothing was found in the shadow tree, search in main content following the shadow tree.
3515     if (resultRange-&gt;collapsed() &amp;&amp; shadowTreeRoot) {
3516         searchRange = rangeOfContents(document());
3517         if (shadowTreeRoot-&gt;shadowHost()) {
3518             if (forward)
3519                 searchRange-&gt;setStartAfter(*shadowTreeRoot-&gt;shadowHost());
3520             else
3521                 searchRange-&gt;setEndBefore(*shadowTreeRoot-&gt;shadowHost());
3522         }
3523 
3524         resultRange = findPlainText(*searchRange, target, options);
3525     }
3526 
3527     // If we didn&#39;t find anything and we&#39;re wrapping, search again in the entire document (this will
3528     // redundantly re-search the area already searched in some cases).
3529     if (resultRange-&gt;collapsed() &amp;&amp; options.contains(WrapAround)) {
3530         searchRange = rangeOfContents(document());
3531         resultRange = findPlainText(*searchRange, target, options);
3532         // We used to return false here if we ended up with the same range that we started with
3533         // (e.g., the reference range was already the only instance of this text). But we decided that
3534         // this should be a success case instead, so we&#39;ll just fall through in that case.
3535     }
3536 
3537     return resultRange-&gt;collapsed() ? nullptr : resultRange;
3538 }
3539 
3540 static bool isFrameInRange(Frame&amp; frame, Range&amp; range)
3541 {
3542     for (auto* ownerElement = frame.ownerElement(); ownerElement; ownerElement = ownerElement-&gt;document().ownerElement()) {
3543         if (&amp;ownerElement-&gt;document() == &amp;range.ownerDocument()) {
3544             auto result = range.intersectsNode(*ownerElement);
3545             return !result.hasException() &amp;&amp; result.releaseReturnValue();
3546         }
3547     }
3548     return false;
3549 }
3550 
3551 unsigned Editor::countMatchesForText(const String&amp; target, Range* range, FindOptions options, unsigned limit, bool markMatches, Vector&lt;RefPtr&lt;Range&gt;&gt;* matches)
3552 {
3553     if (target.isEmpty())
3554         return 0;
3555 
3556     RefPtr&lt;Range&gt; searchRange;
3557     if (range) {
3558         if (&amp;range-&gt;ownerDocument() == &amp;document())
3559             searchRange = range;
3560         else if (!isFrameInRange(m_frame, *range))
3561             return 0;
3562     }
3563     if (!searchRange)
3564         searchRange = rangeOfContents(document());
3565 
3566     Node&amp; originalEndContainer = searchRange-&gt;endContainer();
3567     int originalEndOffset = searchRange-&gt;endOffset();
3568 
3569     unsigned matchCount = 0;
3570     do {
3571         auto resultRange = findPlainText(*searchRange, target, options - Backwards);
3572         if (resultRange-&gt;collapsed()) {
3573             if (!resultRange-&gt;startContainer().isInShadowTree())
3574                 break;
3575 
3576             searchRange-&gt;setStartAfter(*resultRange-&gt;startContainer().shadowHost());
3577             searchRange-&gt;setEnd(originalEndContainer, originalEndOffset);
3578             continue;
3579         }
3580 
3581         ++matchCount;
3582         if (matches)
3583             matches-&gt;append(resultRange.ptr());
3584 
3585         if (markMatches)
3586             document().markers().addMarker(resultRange, DocumentMarker::TextMatch);
3587 
3588         // Stop looking if we hit the specified limit. A limit of 0 means no limit.
3589         if (limit &gt; 0 &amp;&amp; matchCount &gt;= limit)
3590             break;
3591 
3592         // Set the new start for the search range to be the end of the previous
3593         // result range. There is no need to use a VisiblePosition here,
3594         // since findPlainText will use a TextIterator to go over the visible
3595         // text nodes.
3596         searchRange-&gt;setStart(resultRange-&gt;endContainer(), resultRange-&gt;endOffset());
3597 
3598         Node* shadowTreeRoot = searchRange-&gt;shadowRoot();
3599         if (searchRange-&gt;collapsed() &amp;&amp; shadowTreeRoot)
3600             searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3601     } while (true);
3602 
3603     return matchCount;
3604 }
3605 
3606 void Editor::setMarkedTextMatchesAreHighlighted(bool flag)
3607 {
3608     if (flag == m_areMarkedTextMatchesHighlighted)
3609         return;
3610 
3611     m_areMarkedTextMatchesHighlighted = flag;
3612     document().markers().repaintMarkers(DocumentMarker::TextMatch);
3613 }
3614 
3615 #if !PLATFORM(MAC)
3616 void Editor::selectionWillChange()
3617 {
3618 }
3619 #endif
3620 
3621 void Editor::respondToChangedSelection(const VisibleSelection&amp;, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3622 {
3623 #if PLATFORM(IOS_FAMILY)
3624     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3625     if (m_ignoreSelectionChanges)
3626         return;
3627 #endif
3628 
3629     if (client())
3630         client()-&gt;respondToChangedSelection(&amp;m_frame);
3631 
3632 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3633     if (shouldDetectTelephoneNumbers())
3634         m_telephoneNumberDetectionUpdateTimer.startOneShot(0_s);
3635 #endif
3636 
3637     setStartNewKillRingSequence(true);
3638     m_imageElementsToLoadBeforeRevealingSelection.clear();
3639 
3640     if (m_editorUIUpdateTimer.isActive())
3641         return;
3642 
3643     // Don&#39;t check spelling and grammar if the change of selection is triggered by spelling correction itself.
3644     m_editorUIUpdateTimerShouldCheckSpellingAndGrammar = options.contains(FrameSelection::CloseTyping) &amp;&amp; !options.contains(FrameSelection::SpellCorrectionTriggered);
3645     m_editorUIUpdateTimerWasTriggeredByDictation = options.contains(FrameSelection::DictationTriggered);
3646     scheduleEditorUIUpdate();
3647 }
3648 
3649 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3650 
3651 bool Editor::shouldDetectTelephoneNumbers()
3652 {
3653     if (!m_frame.document())
3654         return false;
3655     return document().isTelephoneNumberParsingEnabled() &amp;&amp; TelephoneNumberDetector::isSupported();
3656 }
3657 
3658 void Editor::scanSelectionForTelephoneNumbers()
3659 {
3660     if (!shouldDetectTelephoneNumbers() || !client())
3661         return;
3662 
3663     m_detectedTelephoneNumberRanges.clear();
3664 
3665     Vector&lt;RefPtr&lt;Range&gt;&gt; markedRanges;
3666 
3667     FrameSelection&amp; frameSelection = m_frame.selection();
3668     if (!frameSelection.isRange()) {
3669         if (auto* page = m_frame.page())
3670             page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3671         return;
3672     }
3673     RefPtr&lt;Range&gt; selectedRange = frameSelection.toNormalizedRange();
3674 
3675     // Extend the range a few characters in each direction to detect incompletely selected phone numbers.
3676     static const int charactersToExtend = 15;
3677     const VisibleSelection&amp; visibleSelection = frameSelection.selection();
3678     Position start = visibleSelection.start();
3679     Position end = visibleSelection.end();
3680     for (int i = 0; i &lt; charactersToExtend; ++i) {
3681         start = start.previous(Character);
3682         end = end.next(Character);
3683     }
3684 
3685     FrameSelection extendedSelection;
3686     extendedSelection.setStart(start);
3687     extendedSelection.setEnd(end);
3688     RefPtr&lt;Range&gt; extendedRange = extendedSelection.toNormalizedRange();
3689 
3690     if (!extendedRange) {
3691         if (auto* page = m_frame.page())
3692             page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3693         return;
3694     }
3695 
3696     scanRangeForTelephoneNumbers(*extendedRange, extendedRange-&gt;text(), markedRanges);
3697 
3698     // Only consider ranges with a detected telephone number if they overlap with the actual selection range.
3699     for (auto&amp; range : markedRanges) {
3700         if (rangesOverlap(range.get(), selectedRange.get()))
3701             m_detectedTelephoneNumberRanges.append(range);
3702     }
3703 
3704     if (auto* page = m_frame.page())
3705         page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3706 }
3707 
3708 void Editor::scanRangeForTelephoneNumbers(Range&amp; range, const StringView&amp; stringView, Vector&lt;RefPtr&lt;Range&gt;&gt;&amp; markedRanges)
3709 {
3710     // Don&#39;t scan for phone numbers inside editable regions.
3711     Node&amp; startNode = range.startContainer();
3712     if (startNode.hasEditableStyle())
3713         return;
3714 
3715     // relativeStartPosition and relativeEndPosition are the endpoints of the phone number range,
3716     // relative to the scannerPosition
3717     unsigned length = stringView.length();
3718     unsigned scannerPosition = 0;
3719     int relativeStartPosition = 0;
3720     int relativeEndPosition = 0;
3721 
3722     auto characters = stringView.upconvertedCharacters();
3723 
3724     while (scannerPosition &lt; length &amp;&amp; TelephoneNumberDetector::find(&amp;characters[scannerPosition], length - scannerPosition, &amp;relativeStartPosition, &amp;relativeEndPosition)) {
3725         // The convention in the Data Detectors framework is that the end position is the first character NOT in the phone number
3726         // (that is, the length of the range is relativeEndPosition - relativeStartPosition). So subtract 1 to get the same
3727         // convention as the old WebCore phone number parser (so that the rest of the code is still valid if we want to go back
3728         // to the old parser).
3729         --relativeEndPosition;
3730 
3731         ASSERT(scannerPosition + relativeEndPosition &lt; length);
3732 
3733         unsigned subrangeOffset = scannerPosition + relativeStartPosition;
3734         unsigned subrangeLength = relativeEndPosition - relativeStartPosition + 1;
3735 
3736         auto subrange = TextIterator::subrange(range, subrangeOffset, subrangeLength);
3737 
3738         markedRanges.append(subrange.ptr());
3739         range.ownerDocument().markers().addMarker(subrange, DocumentMarker::TelephoneNumber);
3740 
3741         scannerPosition += relativeEndPosition + 1;
3742     }
3743 }
3744 
3745 #endif // ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3746 
3747 void Editor::updateEditorUINowIfScheduled()
3748 {
3749     if (!m_editorUIUpdateTimer.isActive())
3750         return;
3751     m_editorUIUpdateTimer.stop();
3752     editorUIUpdateTimerFired();
3753 }
3754 
3755 void Editor::editorUIUpdateTimerFired()
3756 {
3757     VisibleSelection oldSelection = m_oldSelectionForEditorUIUpdate;
3758 
3759     m_alternativeTextController-&gt;stopPendingCorrection(oldSelection);
3760 
3761     bool isContinuousSpellCheckingEnabled = this-&gt;isContinuousSpellCheckingEnabled();
3762     bool isContinuousGrammarCheckingEnabled = isContinuousSpellCheckingEnabled &amp;&amp; isGrammarCheckingEnabled();
3763     if (isContinuousSpellCheckingEnabled) {
3764         VisibleSelection newAdjacentWords;
3765         VisibleSelection newSelectedSentence;
3766         bool caretBrowsing = m_frame.settings().caretBrowsingEnabled();
3767         if (m_frame.selection().selection().isContentEditable() || caretBrowsing) {
3768             VisiblePosition newStart(m_frame.selection().selection().visibleStart());
3769 #if !PLATFORM(IOS_FAMILY)
3770             newAdjacentWords = VisibleSelection(startOfWord(newStart, LeftWordIfOnBoundary), endOfWord(newStart, RightWordIfOnBoundary));
3771 #else
3772             // If this bug gets fixed, this PLATFORM(IOS_FAMILY) code could be removed:
3773             // &lt;rdar://problem/7259611&gt; Word boundary code on iPhone gives different results than desktop
3774             EWordSide startWordSide = LeftWordIfOnBoundary;
3775             UChar32 c = newStart.characterBefore();
3776             // FIXME: VisiblePosition::characterAfter() and characterBefore() do not emit newlines the same
3777             // way as TextIterator, so we do an isStartOfParagraph check here.
3778             if (isSpaceOrNewline(c) || c == noBreakSpace || isStartOfParagraph(newStart)) {
3779                 startWordSide = RightWordIfOnBoundary;
3780             }
3781             newAdjacentWords = VisibleSelection(startOfWord(newStart, startWordSide), endOfWord(newStart, RightWordIfOnBoundary));
3782 #endif // !PLATFORM(IOS_FAMILY)
3783             if (isContinuousGrammarCheckingEnabled)
3784                 newSelectedSentence = VisibleSelection(startOfSentence(newStart), endOfSentence(newStart));
3785         }
3786 
3787         // When typing we check spelling elsewhere, so don&#39;t redo it here.
3788         // If this is a change in selection resulting from a delete operation,
3789         // oldSelection may no longer be in the document.
3790         if (m_editorUIUpdateTimerShouldCheckSpellingAndGrammar &amp;&amp; oldSelection.isContentEditable() &amp;&amp; oldSelection.start().deprecatedNode() &amp;&amp; oldSelection.start().anchorNode()-&gt;isConnected()) {
3791             VisiblePosition oldStart(oldSelection.visibleStart());
3792             VisibleSelection oldAdjacentWords = VisibleSelection(startOfWord(oldStart, LeftWordIfOnBoundary), endOfWord(oldStart, RightWordIfOnBoundary));
3793             if (oldAdjacentWords != newAdjacentWords) {
3794                 if (isContinuousGrammarCheckingEnabled) {
3795                     VisibleSelection oldSelectedSentence = VisibleSelection(startOfSentence(oldStart), endOfSentence(oldStart));
3796                     markMisspellingsAndBadGrammar(oldAdjacentWords, oldSelectedSentence != newSelectedSentence, oldSelectedSentence);
3797                 } else
3798                     markMisspellingsAndBadGrammar(oldAdjacentWords, false, oldAdjacentWords);
3799             }
3800         }
3801 
3802         if (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Spelling)) {
3803             if (RefPtr&lt;Range&gt; wordRange = newAdjacentWords.toNormalizedRange())
3804                 document().markers().removeMarkers(*wordRange, DocumentMarker::Spelling);
3805         }
3806         if (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Grammar)) {
3807             if (RefPtr&lt;Range&gt; sentenceRange = newSelectedSentence.toNormalizedRange())
3808                 document().markers().removeMarkers(*sentenceRange, DocumentMarker::Grammar);
3809         }
3810     }
3811 
3812     // When continuous spell checking is off, existing markers disappear after the selection changes.
3813     if (!isContinuousSpellCheckingEnabled)
3814         document().markers().removeMarkers(DocumentMarker::Spelling);
3815     if (!isContinuousGrammarCheckingEnabled)
3816         document().markers().removeMarkers(DocumentMarker::Grammar);
3817 
3818     if (!m_editorUIUpdateTimerWasTriggeredByDictation)
3819         m_alternativeTextController-&gt;respondToChangedSelection(oldSelection);
3820 
3821     m_oldSelectionForEditorUIUpdate = m_frame.selection().selection();
3822 
3823 #if ENABLE(ATTACHMENT_ELEMENT)
3824     notifyClientOfAttachmentUpdates();
3825 #endif
3826 }
3827 
3828 static Node* findFirstMarkable(Node* node)
3829 {
3830     while (node) {
3831         if (!node-&gt;renderer())
3832             return nullptr;
3833         if (node-&gt;renderer()-&gt;isTextOrLineBreak())
3834             return node;
3835         if (is&lt;Element&gt;(*node) &amp;&amp; downcast&lt;Element&gt;(*node).isTextField())
3836             node = downcast&lt;HTMLTextFormControlElement&gt;(*node).visiblePositionForIndex(1).deepEquivalent().deprecatedNode();
3837         else if (node-&gt;firstChild())
3838             node = node-&gt;firstChild();
3839         else
3840             node = node-&gt;nextSibling();
3841     }
3842 
3843     return nullptr;
3844 }
3845 
3846 bool Editor::selectionStartHasMarkerFor(DocumentMarker::MarkerType markerType, int from, int length) const
3847 {
3848     Node* node = findFirstMarkable(m_frame.selection().selection().start().deprecatedNode());
3849     if (!node)
3850         return false;
3851 
3852     unsigned int startOffset = static_cast&lt;unsigned int&gt;(from);
3853     unsigned int endOffset = static_cast&lt;unsigned int&gt;(from + length);
3854     Vector&lt;RenderedDocumentMarker*&gt; markers = document().markers().markersFor(*node);
3855     for (auto* marker : markers) {
3856         if (marker-&gt;startOffset() &lt;= startOffset &amp;&amp; endOffset &lt;= marker-&gt;endOffset() &amp;&amp; marker-&gt;type() == markerType)
3857             return true;
3858     }
3859 
3860     return false;
3861 }
3862 
3863 OptionSet&lt;TextCheckingType&gt; Editor::resolveTextCheckingTypeMask(const Node&amp; rootEditableElement, OptionSet&lt;TextCheckingType&gt; textCheckingOptions)
3864 {
3865 #if USE(AUTOMATIC_TEXT_REPLACEMENT) &amp;&amp; !PLATFORM(IOS_FAMILY)
3866     bool onlyAllowsTextReplacement = false;
3867     if (auto* host = rootEditableElement.shadowHost())
3868         onlyAllowsTextReplacement = is&lt;HTMLInputElement&gt;(host) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*host).isSpellcheckDisabledExceptTextReplacement();
3869     if (onlyAllowsTextReplacement)
3870         textCheckingOptions = textCheckingOptions &amp; TextCheckingType::Replacement;
3871 #else
3872     UNUSED_PARAM(rootEditableElement);
3873 #endif
3874 
3875     bool shouldMarkSpelling = textCheckingOptions.contains(TextCheckingType::Spelling);
3876     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
3877 #if !PLATFORM(IOS_FAMILY)
3878     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
3879     bool shouldCheckForCorrection = shouldShowCorrectionPanel || textCheckingOptions.contains(TextCheckingType::Correction);
3880 #endif
3881 
3882     OptionSet&lt;TextCheckingType&gt; checkingTypes;
3883     if (shouldMarkSpelling)
3884         checkingTypes.add(TextCheckingType::Spelling);
3885     if (shouldMarkGrammar)
3886         checkingTypes.add(TextCheckingType::Grammar);
3887 #if !PLATFORM(IOS_FAMILY)
3888     if (shouldCheckForCorrection)
3889         checkingTypes.add(TextCheckingType::Correction);
3890     if (shouldShowCorrectionPanel)
3891         checkingTypes.add(TextCheckingType::ShowCorrectionPanel);
3892 
3893 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
3894     bool shouldPerformReplacement = textCheckingOptions.contains(TextCheckingType::Replacement);
3895     if (shouldPerformReplacement) {
3896         if (!onlyAllowsTextReplacement) {
3897             if (isAutomaticLinkDetectionEnabled())
3898                 checkingTypes.add(TextCheckingType::Link);
3899             if (isAutomaticQuoteSubstitutionEnabled())
3900                 checkingTypes.add(TextCheckingType::Quote);
3901             if (isAutomaticDashSubstitutionEnabled())
3902                 checkingTypes.add(TextCheckingType::Dash);
3903             if (shouldMarkSpelling &amp;&amp; isAutomaticSpellingCorrectionEnabled())
3904                 checkingTypes.add(TextCheckingType::Correction);
3905         }
3906         if (isAutomaticTextReplacementEnabled())
3907             checkingTypes.add(TextCheckingType::Replacement);
3908     }
3909 #endif
3910 #endif // !PLATFORM(IOS_FAMILY)
3911 
3912     return checkingTypes;
3913 }
3914 
3915 static RefPtr&lt;Range&gt; candidateRangeForSelection(Frame&amp; frame)
3916 {
3917     const VisibleSelection&amp; selection = frame.selection().selection();
3918     return selection.isCaret() ? wordRangeFromPosition(selection.start()) : frame.selection().toNormalizedRange();
3919 }
3920 
3921 static bool candidateWouldReplaceText(const VisibleSelection&amp; selection)
3922 {
3923     // If the character behind the caret in the current selection is anything but a space or a newline then we should
3924     // replace the whole current word with the candidate.
3925     UChar32 characterAfterSelection, characterBeforeSelection, twoCharacterBeforeSelection = 0;
3926     charactersAroundPosition(selection.visibleStart(), characterAfterSelection, characterBeforeSelection, twoCharacterBeforeSelection);
3927     return !(characterBeforeSelection == &#39;\0&#39; || characterBeforeSelection == &#39;\n&#39; || characterBeforeSelection == &#39; &#39;);
3928 }
3929 
3930 String Editor::stringForCandidateRequest() const
3931 {
3932     const VisibleSelection&amp; selection = m_frame.selection().selection();
3933     RefPtr&lt;Range&gt; rangeForCurrentlyTypedString = candidateRangeForSelection(m_frame);
3934     if (rangeForCurrentlyTypedString &amp;&amp; candidateWouldReplaceText(selection))
3935         return plainText(rangeForCurrentlyTypedString.get());
3936 
3937     return String();
3938 }
3939 
3940 RefPtr&lt;Range&gt; Editor::contextRangeForCandidateRequest() const
3941 {
3942     const VisibleSelection&amp; selection = m_frame.selection().selection();
3943     return makeRange(startOfParagraph(selection.visibleStart()), endOfParagraph(selection.visibleEnd()));
3944 }
3945 
3946 RefPtr&lt;Range&gt; Editor::rangeForTextCheckingResult(const TextCheckingResult&amp; result) const
3947 {
3948     if (!result.length)
3949         return nullptr;
3950 
3951     RefPtr&lt;Range&gt; contextRange = contextRangeForCandidateRequest();
3952     if (!contextRange)
3953         return nullptr;
3954 
3955     return TextIterator::subrange(*contextRange, result.location, result.length);
3956 }
3957 
3958 void Editor::scheduleEditorUIUpdate()
3959 {
3960     m_editorUIUpdateTimer.startOneShot(0_s);
3961 }
3962 
3963 #if !PLATFORM(COCOA)
3964 
3965 void Editor::platformFontAttributesAtSelectionStart(FontAttributes&amp;, const RenderStyle&amp;) const
3966 {
3967 }
3968 
3969 #endif
3970 
3971 static Vector&lt;TextList&gt; editableTextListsAtPositionInDescendingOrder(const Position&amp; position)
3972 {
3973     auto startContainer = makeRefPtr(position.containerNode());
3974     if (!startContainer)
3975         return { };
3976 
3977     auto* editableRoot = highestEditableRoot(firstPositionInOrBeforeNode(startContainer.get()));
3978     if (!editableRoot)
3979         return { };
3980 
3981     Vector&lt;Ref&lt;HTMLElement&gt;&gt; enclosingLists;
3982     for (auto&amp; ancestor : ancestorsOfType&lt;HTMLElement&gt;(*startContainer)) {
3983         if (&amp;ancestor == editableRoot)
3984             break;
3985 
3986         auto* renderer = ancestor.renderer();
3987         if (!renderer)
3988             continue;
3989 
3990         if (is&lt;HTMLUListElement&gt;(ancestor) || is&lt;HTMLOListElement&gt;(ancestor))
3991             enclosingLists.append(ancestor);
3992     }
3993 
3994     Vector&lt;TextList&gt; textLists;
3995     textLists.reserveCapacity(enclosingLists.size());
3996     for (auto iterator = enclosingLists.rbegin(); iterator != enclosingLists.rend(); ++iterator) {
3997         auto&amp; list = iterator-&gt;get();
3998         bool ordered = is&lt;HTMLOListElement&gt;(list);
3999         textLists.uncheckedAppend({ list.renderer()-&gt;style().listStyleType(), ordered ? downcast&lt;HTMLOListElement&gt;(list).start() : 1, ordered });
4000     }
4001 
4002     return textLists;
4003 }
4004 
4005 FontAttributes Editor::fontAttributesAtSelectionStart() const
4006 {
4007     FontAttributes attributes;
4008     Node* nodeToRemove = nullptr;
4009     auto* style = styleForSelectionStart(&amp;m_frame, nodeToRemove);
4010     if (!style) {
4011         if (nodeToRemove)
4012             nodeToRemove-&gt;remove();
4013         return attributes;
4014     }
4015 
4016     platformFontAttributesAtSelectionStart(attributes, *style);
4017 
4018     // FIXME: for now, always report the colors after applying -apple-color-filter. In future not all clients
4019     // may want this, so we may have to add a setting to control it. See also editingAttributedStringFromRange().
4020     auto backgroundColor = style-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
4021     if (backgroundColor.isVisible())
4022         attributes.backgroundColor = backgroundColor;
4023 
4024     auto foregroundColor = style-&gt;visitedDependentColorWithColorFilter(CSSPropertyColor);
4025     // FIXME: isBlackColor not suitable for dark mode.
4026     if (foregroundColor.isValid() &amp;&amp; !Color::isBlackColor(foregroundColor))
4027         attributes.foregroundColor = foregroundColor;
4028 
4029     if (auto* shadowData = style-&gt;textShadow())
4030         attributes.fontShadow = { shadowData-&gt;color(), { static_cast&lt;float&gt;(shadowData-&gt;x()), static_cast&lt;float&gt;(shadowData-&gt;y()) }, static_cast&lt;double&gt;(shadowData-&gt;radius()) };
4031 
4032     switch (style-&gt;verticalAlign()) {
4033     case VerticalAlign::Baseline:
4034     case VerticalAlign::Bottom:
4035     case VerticalAlign::BaselineMiddle:
4036     case VerticalAlign::Length:
4037     case VerticalAlign::Middle:
4038     case VerticalAlign::TextBottom:
4039     case VerticalAlign::TextTop:
4040     case VerticalAlign::Top:
4041         break;
4042     case VerticalAlign::Sub:
4043         attributes.subscriptOrSuperscript = FontAttributes::SubscriptOrSuperscript::Subscript;
4044         break;
4045     case VerticalAlign::Super:
4046         attributes.subscriptOrSuperscript = FontAttributes::SubscriptOrSuperscript::Superscript;
4047         break;
4048     }
4049 
4050     attributes.textLists = editableTextListsAtPositionInDescendingOrder(m_frame.selection().selection().start());
4051 
4052     switch (style-&gt;textAlign()) {
4053     case TextAlignMode::Right:
4054     case TextAlignMode::WebKitRight:
4055         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Right;
4056         break;
4057     case TextAlignMode::Left:
4058     case TextAlignMode::WebKitLeft:
4059         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Left;
4060         break;
4061     case TextAlignMode::Center:
4062     case TextAlignMode::WebKitCenter:
4063         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Center;
4064         break;
4065     case TextAlignMode::Justify:
4066         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Justify;
4067         break;
4068     case TextAlignMode::Start:
4069         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Natural;
4070         break;
4071     case TextAlignMode::End:
4072         attributes.horizontalAlignment = style-&gt;isLeftToRightDirection() ? FontAttributes::HorizontalAlignment::Right : FontAttributes::HorizontalAlignment::Left;
4073         break;
4074     }
4075 
4076     auto typingStyle = makeRefPtr(m_frame.selection().typingStyle());
4077     if (typingStyle &amp;&amp; typingStyle-&gt;style()) {
4078         auto value = typingStyle-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
4079         if (value &amp;&amp; value-&gt;isValueList()) {
4080             CSSValueList&amp; valueList = downcast&lt;CSSValueList&gt;(*value);
4081             if (valueList.hasValue(CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough).ptr()))
4082                 attributes.hasStrikeThrough = true;
4083             if (valueList.hasValue(CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline).ptr()))
4084                 attributes.hasUnderline = true;
4085         }
4086     } else {
4087         auto decoration = style-&gt;textDecorationsInEffect();
4088         if (decoration &amp; TextDecoration::LineThrough)
4089             attributes.hasStrikeThrough = true;
4090         if (decoration &amp; TextDecoration::Underline)
4091             attributes.hasUnderline = true;
4092     }
4093 
4094     if (nodeToRemove)
4095         nodeToRemove-&gt;remove();
4096 
4097     return attributes;
4098 }
4099 
4100 #if ENABLE(ATTACHMENT_ELEMENT)
4101 
4102 void Editor::registerAttachmentIdentifier(const String&amp; identifier, const String&amp; contentType, const String&amp; preferredFileName, Ref&lt;SharedBuffer&gt;&amp;&amp; data)
4103 {
4104     if (auto* client = this-&gt;client())
4105         client-&gt;registerAttachmentIdentifier(identifier, contentType, preferredFileName, WTFMove(data));
4106 }
4107 
4108 void Editor::registerAttachmentIdentifier(const String&amp; identifier, const String&amp; contentType, const String&amp; filePath)
4109 {
4110     if (auto* client = this-&gt;client())
4111         client-&gt;registerAttachmentIdentifier(identifier, contentType, filePath);
4112 }
4113 
4114 void Editor::registerAttachments(Vector&lt;SerializedAttachmentData&gt;&amp;&amp; data)
4115 {
4116     if (auto* client = this-&gt;client())
4117         client-&gt;registerAttachments(WTFMove(data));
4118 }
4119 
4120 void Editor::registerAttachmentIdentifier(const String&amp; identifier)
4121 {
4122     if (auto* client = this-&gt;client())
4123         client-&gt;registerAttachmentIdentifier(identifier);
4124 }
4125 
4126 void Editor::cloneAttachmentData(const String&amp; fromIdentifier, const String&amp; toIdentifier)
4127 {
4128     if (auto* client = this-&gt;client())
4129         client-&gt;cloneAttachmentData(fromIdentifier, toIdentifier);
4130 }
4131 
4132 void Editor::didInsertAttachmentElement(HTMLAttachmentElement&amp; attachment)
4133 {
4134     auto identifier = attachment.uniqueIdentifier();
4135     if (identifier.isEmpty())
4136         return;
4137 
4138     if (!m_removedAttachmentIdentifiers.take(identifier))
4139         m_insertedAttachmentIdentifiers.add(identifier);
4140     scheduleEditorUIUpdate();
4141 }
4142 
4143 void Editor::didRemoveAttachmentElement(HTMLAttachmentElement&amp; attachment)
4144 {
4145     auto identifier = attachment.uniqueIdentifier();
4146     if (identifier.isEmpty())
4147         return;
4148 
4149     if (!m_insertedAttachmentIdentifiers.take(identifier))
4150         m_removedAttachmentIdentifiers.add(identifier);
4151     scheduleEditorUIUpdate();
4152 }
4153 
4154 void Editor::notifyClientOfAttachmentUpdates()
4155 {
4156     auto removedAttachmentIdentifiers = WTFMove(m_removedAttachmentIdentifiers);
4157     auto insertedAttachmentIdentifiers = WTFMove(m_insertedAttachmentIdentifiers);
4158     if (!client())
4159         return;
4160 
4161     for (auto&amp; identifier : removedAttachmentIdentifiers)
4162         client()-&gt;didRemoveAttachmentWithIdentifier(identifier);
4163 
4164     auto* document = m_frame.document();
4165     if (!document)
4166         return;
4167 
4168     for (auto&amp; identifier : insertedAttachmentIdentifiers) {
4169         if (auto attachment = document-&gt;attachmentForIdentifier(identifier))
4170             client()-&gt;didInsertAttachmentWithIdentifier(identifier, attachment-&gt;attributeWithoutSynchronization(HTMLNames::srcAttr), attachment-&gt;hasEnclosingImage());
4171         else
4172             ASSERT_NOT_REACHED();
4173     }
4174 }
4175 
4176 void Editor::insertAttachment(const String&amp; identifier, Optional&lt;uint64_t&gt;&amp;&amp; fileSize, const String&amp; fileName, const String&amp; contentType)
4177 {
4178     auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, document());
4179     attachment-&gt;setUniqueIdentifier(identifier);
4180     attachment-&gt;updateAttributes(WTFMove(fileSize), contentType, fileName);
4181 
4182     auto fragmentToInsert = document().createDocumentFragment();
4183     fragmentToInsert-&gt;appendChild(attachment.get());
4184 
4185     replaceSelectionWithFragment(fragmentToInsert.get(), SelectReplacement::No, SmartReplace::No, MatchStyle::Yes);
4186 }
4187 
4188 #endif // ENABLE(ATTACHMENT_ELEMENT)
4189 
4190 void Editor::handleAcceptedCandidate(TextCheckingResult acceptedCandidate)
4191 {
4192     const VisibleSelection&amp; selection = m_frame.selection().selection();
4193 
4194     m_isHandlingAcceptedCandidate = true;
4195 
4196     if (auto range = rangeForTextCheckingResult(acceptedCandidate)) {
4197         if (shouldInsertText(acceptedCandidate.replacement, range.get(), EditorInsertAction::Typed))
4198             ReplaceRangeWithTextCommand::create(range.get(), acceptedCandidate.replacement)-&gt;apply();
4199     } else
4200         insertText(acceptedCandidate.replacement, nullptr);
4201 
4202     RefPtr&lt;Range&gt; insertedCandidateRange = rangeExpandedByCharactersInDirectionAtWordBoundary(selection.visibleStart(), acceptedCandidate.replacement.length(), DirectionBackward);
4203     if (insertedCandidateRange)
4204         insertedCandidateRange-&gt;startContainer().document().markers().addMarker(*insertedCandidateRange, DocumentMarker::AcceptedCandidate, acceptedCandidate.replacement);
4205 
4206     m_isHandlingAcceptedCandidate = false;
4207 }
4208 
4209 bool Editor::unifiedTextCheckerEnabled() const
4210 {
4211     return WebCore::unifiedTextCheckerEnabled(&amp;m_frame);
4212 }
4213 
4214 Vector&lt;String&gt; Editor::dictationAlternativesForMarker(const DocumentMarker&amp; marker)
4215 {
4216     return m_alternativeTextController-&gt;dictationAlternativesForMarker(marker);
4217 }
4218 
4219 void Editor::applyDictationAlternativelternative(const String&amp; alternativeString)
4220 {
4221     m_alternativeTextController-&gt;applyDictationAlternative(alternativeString);
4222 }
4223 
4224 void Editor::toggleOverwriteModeEnabled()
4225 {
4226     m_overwriteModeEnabled = !m_overwriteModeEnabled;
4227     m_frame.selection().setShouldShowBlockCursor(m_overwriteModeEnabled);
4228 }
4229 
4230 Document&amp; Editor::document() const
4231 {
4232     ASSERT(m_frame.document());
4233     return *m_frame.document();
4234 }
4235 
4236 RefPtr&lt;Range&gt; Editor::adjustedSelectionRange()
4237 {
4238     // FIXME: Why do we need to adjust the selection to include the anchor tag it&#39;s in?
4239     // Whoever wrote this code originally forgot to leave us a comment explaining the rationale.
4240     RefPtr&lt;Range&gt; range = selectedRange();
4241     Node* commonAncestor = range-&gt;commonAncestorContainer();
4242     ASSERT(commonAncestor);
4243     auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(commonAncestor), HTMLNames::aTag);
4244     if (enclosingAnchor &amp;&amp; comparePositions(firstPositionInOrBeforeNode(range-&gt;startPosition().anchorNode()), range-&gt;startPosition()) &gt;= 0)
4245         range-&gt;setStart(*enclosingAnchor, 0);
4246     return range;
4247 }
4248 
4249 // FIXME: This figures out the current style by inserting a &lt;span&gt;!
4250 const RenderStyle* Editor::styleForSelectionStart(Frame* frame, Node*&amp; nodeToRemove)
4251 {
4252     nodeToRemove = nullptr;
4253 
4254     if (frame-&gt;selection().isNone())
4255         return nullptr;
4256 
4257     Position position = adjustedSelectionStartForStyleComputation(frame-&gt;selection().selection());
4258     if (!position.isCandidate() || position.isNull())
4259         return nullptr;
4260 
4261     RefPtr&lt;EditingStyle&gt; typingStyle = frame-&gt;selection().typingStyle();
4262     if (!typingStyle || !typingStyle-&gt;style())
4263         return &amp;position.deprecatedNode()-&gt;renderer()-&gt;style();
4264 
4265     auto styleElement = HTMLSpanElement::create(*frame-&gt;document());
4266 
4267     String styleText = typingStyle-&gt;style()-&gt;asText() + &quot; display: inline&quot;;
4268     styleElement-&gt;setAttribute(HTMLNames::styleAttr, styleText);
4269 
4270     styleElement-&gt;appendChild(frame-&gt;document()-&gt;createEditingTextNode(emptyString()));
4271 
4272     auto positionNode = position.deprecatedNode();
4273     if (!positionNode || !positionNode-&gt;parentNode() || positionNode-&gt;parentNode()-&gt;appendChild(styleElement).hasException())
4274         return nullptr;
4275 
4276     nodeToRemove = styleElement.ptr();
4277 
4278     frame-&gt;document()-&gt;updateStyleIfNeeded();
4279     return styleElement-&gt;renderer() ? &amp;styleElement-&gt;renderer()-&gt;style() : nullptr;
4280 }
4281 
4282 const Font* Editor::fontForSelection(bool&amp; hasMultipleFonts) const
4283 {
4284     hasMultipleFonts = false;
4285 
4286     if (!m_frame.selection().isRange()) {
4287         Node* nodeToRemove;
4288         auto* style = styleForSelectionStart(&amp;m_frame, nodeToRemove); // sets nodeToRemove
4289 
4290         const Font* font = nullptr;
4291         if (style) {
4292             font = &amp;style-&gt;fontCascade().primaryFont();
4293             if (nodeToRemove)
4294                 nodeToRemove-&gt;remove();
4295         }
4296 
4297         return font;
4298     }
4299 
4300     RefPtr&lt;Range&gt; range = m_frame.selection().toNormalizedRange();
4301     if (!range)
4302         return nullptr;
4303 
4304     Node* startNode = adjustedSelectionStartForStyleComputation(m_frame.selection().selection()).deprecatedNode();
4305     if (!startNode)
4306         return nullptr;
4307 
4308     const Font* font = nullptr;
4309     Node* pastEnd = range-&gt;pastLastNode();
4310     // In the loop below, node should eventually match pastEnd and not become null, but we&#39;ve seen at least one
4311     // unreproducible case where this didn&#39;t happen, so check for null also.
4312     for (Node* node = startNode; node &amp;&amp; node != pastEnd; node = NodeTraversal::next(*node)) {
4313         auto renderer = node-&gt;renderer();
4314         if (!renderer)
4315             continue;
4316         // FIXME: Are there any node types that have renderers, but that we should be skipping?
4317         const Font&amp; primaryFont = renderer-&gt;style().fontCascade().primaryFont();
4318         if (!font)
4319             font = &amp;primaryFont;
4320         else if (font != &amp;primaryFont) {
4321             hasMultipleFonts = true;
4322             break;
4323         }
4324     }
4325 
4326     return font;
4327 }
4328 
4329 RefPtr&lt;HTMLImageElement&gt; Editor::insertEditableImage()
4330 {
4331     return InsertEditableImageCommand::insertEditableImage(document());
4332 }
4333 
4334 bool Editor::canCopyExcludingStandaloneImages() const
4335 {
4336     auto&amp; selection = m_frame.selection().selection();
4337     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
4338 }
4339 
4340 } // namespace WebCore
    </pre>
  </body>
</html>
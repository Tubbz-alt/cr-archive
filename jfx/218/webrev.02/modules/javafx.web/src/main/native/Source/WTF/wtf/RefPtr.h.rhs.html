<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 // RefPtr is documented at http://webkit.org/coding/RefPtr.html
 22 
 23 #pragma once
 24 
 25 #include &lt;algorithm&gt;
 26 #include &lt;utility&gt;
 27 #include &lt;wtf/FastMalloc.h&gt;
 28 #include &lt;wtf/Ref.h&gt;
 29 
 30 namespace WTF {
 31 
 32 template&lt;typename T, typename PtrTraits&gt; class RefPtr;
 33 template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt; RefPtr&lt;T, PtrTraits&gt; adoptRef(T*);
 34 
 35 template&lt;typename T&gt; ALWAYS_INLINE void refIfNotNull(T* ptr)
 36 {
 37     if (LIKELY(ptr != nullptr))
 38         ptr-&gt;ref();
 39 }
 40 
 41 template&lt;typename T&gt; ALWAYS_INLINE void derefIfNotNull(T* ptr)
 42 {
 43     if (LIKELY(ptr != nullptr))
 44         ptr-&gt;deref();
 45 }
 46 
<a name="1" id="anc1"></a><span class="line-modified"> 47 template&lt;typename T, typename Traits&gt;</span>
 48 class RefPtr {
 49     WTF_MAKE_FAST_ALLOCATED;
 50 public:
<a name="2" id="anc2"></a><span class="line-added"> 51     using PtrTraits = Traits;</span>
 52     typedef T ValueType;
 53     typedef ValueType* PtrType;
 54 
 55     static constexpr bool isRefPtr = true;
 56 
 57     ALWAYS_INLINE constexpr RefPtr() : m_ptr(nullptr) { }
 58     ALWAYS_INLINE RefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }
 59     ALWAYS_INLINE RefPtr(const RefPtr&amp; o) : m_ptr(o.m_ptr) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 60     template&lt;typename X, typename Y&gt; RefPtr(const RefPtr&lt;X, Y&gt;&amp; o) : m_ptr(o.get()) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 61 
 62     ALWAYS_INLINE RefPtr(RefPtr&amp;&amp; o) : m_ptr(o.leakRef()) { }
 63     template&lt;typename X, typename Y&gt; RefPtr(RefPtr&lt;X, Y&gt;&amp;&amp; o) : m_ptr(o.leakRef()) { }
 64     template&lt;typename X, typename Y&gt; RefPtr(Ref&lt;X, Y&gt;&amp;&amp;);
 65 
 66     // Hash table deleted values, which are only constructed and never copied or destroyed.
<a name="3" id="anc3"></a><span class="line-modified"> 67     RefPtr(HashTableDeletedValueType) : m_ptr(PtrTraits::hashTableDeletedValue()) { }</span>
<span class="line-modified"> 68     bool isHashTableDeletedValue() const { return PtrTraits::isHashTableDeletedValue(m_ptr); }</span>
 69 
 70     ALWAYS_INLINE ~RefPtr() { derefIfNotNull(PtrTraits::exchange(m_ptr, nullptr)); }
 71 
 72     T* get() const { return PtrTraits::unwrap(m_ptr); }
 73 
 74     Ref&lt;T&gt; releaseNonNull() { ASSERT(m_ptr); Ref&lt;T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 75     Ref&lt;const T&gt; releaseConstNonNull() { ASSERT(m_ptr); Ref&lt;const T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 76 
 77     T* leakRef() WARN_UNUSED_RETURN;
 78 
 79     T&amp; operator*() const { ASSERT(m_ptr); return *PtrTraits::unwrap(m_ptr); }
 80     ALWAYS_INLINE T* operator-&gt;() const { return PtrTraits::unwrap(m_ptr); }
 81 
 82     bool operator!() const { return !m_ptr; }
 83 
 84     // This conversion operator allows implicit conversion to bool but not to other integer types.
<a name="4" id="anc4"></a><span class="line-modified"> 85     using UnspecifiedBoolType = void (RefPtr::*)() const;</span>
<span class="line-modified"> 86     operator UnspecifiedBoolType() const { return m_ptr ? &amp;RefPtr::unspecifiedBoolTypeInstance : nullptr; }</span>
 87 
 88     explicit operator bool() const { return !!m_ptr; }
 89 
 90     RefPtr&amp; operator=(const RefPtr&amp;);
 91     RefPtr&amp; operator=(T*);
 92     RefPtr&amp; operator=(std::nullptr_t);
 93     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(const RefPtr&lt;X, Y&gt;&amp;);
 94     RefPtr&amp; operator=(RefPtr&amp;&amp;);
 95     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(RefPtr&lt;X, Y&gt;&amp;&amp;);
 96     template&lt;typename X&gt; RefPtr&amp; operator=(Ref&lt;X&gt;&amp;&amp;);
 97 
 98     template&lt;typename X, typename Y&gt; void swap(RefPtr&lt;X, Y&gt;&amp;);
 99 
<a name="5" id="anc5"></a>

100     RefPtr copyRef() &amp;&amp; = delete;
101     RefPtr copyRef() const &amp; WARN_UNUSED_RETURN { return RefPtr(m_ptr); }
102 
103 private:
<a name="6" id="anc6"></a><span class="line-added">104     void unspecifiedBoolTypeInstance() const { }</span>
<span class="line-added">105 </span>
106     friend RefPtr adoptRef&lt;T, PtrTraits&gt;(T*);
107     template&lt;typename X, typename Y&gt; friend class RefPtr;
108 
109     enum AdoptTag { Adopt };
110     RefPtr(T* ptr, AdoptTag) : m_ptr(ptr) { }
111 
112     typename PtrTraits::StorageType m_ptr;
113 };
114 
115 template&lt;typename T, typename U&gt;
116 template&lt;typename X, typename Y&gt;
117 inline RefPtr&lt;T, U&gt;::RefPtr(Ref&lt;X, Y&gt;&amp;&amp; reference)
118     : m_ptr(&amp;reference.leakRef())
119 {
120 }
121 
122 template&lt;typename T, typename U&gt;
123 inline T* RefPtr&lt;T, U&gt;::leakRef()
124 {
125     return U::exchange(m_ptr, nullptr);
126 }
127 
128 template&lt;typename T, typename U&gt;
129 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(const RefPtr&amp; o)
130 {
131     RefPtr ptr = o;
132     swap(ptr);
133     return *this;
134 }
135 
136 template&lt;typename T, typename U&gt;
137 template&lt;typename X, typename Y&gt;
138 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(const RefPtr&lt;X, Y&gt;&amp; o)
139 {
140     RefPtr ptr = o;
141     swap(ptr);
142     return *this;
143 }
144 
145 template&lt;typename T, typename U&gt;
146 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(T* optr)
147 {
148     RefPtr ptr = optr;
149     swap(ptr);
150     return *this;
151 }
152 
153 template&lt;typename T, typename U&gt;
154 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(std::nullptr_t)
155 {
156     derefIfNotNull(U::exchange(m_ptr, nullptr));
157     return *this;
158 }
159 
160 template&lt;typename T, typename U&gt;
161 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(RefPtr&amp;&amp; o)
162 {
163     RefPtr ptr = WTFMove(o);
164     swap(ptr);
165     return *this;
166 }
167 
168 template&lt;typename T, typename U&gt;
169 template&lt;typename X, typename Y&gt;
170 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(RefPtr&lt;X, Y&gt;&amp;&amp; o)
171 {
172     RefPtr ptr = WTFMove(o);
173     swap(ptr);
174     return *this;
175 }
176 
177 template&lt;typename T, typename V&gt;
178 template&lt;typename U&gt;
179 inline RefPtr&lt;T, V&gt;&amp; RefPtr&lt;T, V&gt;::operator=(Ref&lt;U&gt;&amp;&amp; reference)
180 {
181     RefPtr ptr = WTFMove(reference);
182     swap(ptr);
183     return *this;
184 }
185 
186 template&lt;class T, typename U&gt;
187 template&lt;typename X, typename Y&gt;
188 inline void RefPtr&lt;T, U&gt;::swap(RefPtr&lt;X, Y&gt;&amp; o)
189 {
190     U::swap(m_ptr, o.m_ptr);
191 }
192 
193 template&lt;typename T, typename U, typename X, typename Y, typename = std::enable_if_t&lt;!std::is_same&lt;U, DumbPtrTraits&lt;T&gt;&gt;::value || !std::is_same&lt;Y, DumbPtrTraits&lt;X&gt;&gt;::value&gt;&gt;
194 inline void swap(RefPtr&lt;T, U&gt;&amp; a, RefPtr&lt;X, Y&gt;&amp; b)
195 {
196     a.swap(b);
197 }
198 
199 template&lt;typename T, typename U, typename X, typename Y&gt;
200 inline bool operator==(const RefPtr&lt;T, U&gt;&amp; a, const RefPtr&lt;X, Y&gt;&amp; b)
201 {
202     return a.get() == b.get();
203 }
204 
205 template&lt;typename T, typename U, typename X&gt;
206 inline bool operator==(const RefPtr&lt;T, U&gt;&amp; a, X* b)
207 {
208     return a.get() == b;
209 }
210 
211 template&lt;typename T, typename X, typename Y&gt;
212 inline bool operator==(T* a, const RefPtr&lt;X, Y&gt;&amp; b)
213 {
214     return a == b.get();
215 }
216 
217 template&lt;typename T, typename U, typename X, typename Y&gt;
218 inline bool operator!=(const RefPtr&lt;T, U&gt;&amp; a, const RefPtr&lt;X, Y&gt;&amp; b)
219 {
220     return a.get() != b.get();
221 }
222 
223 template&lt;typename T, typename U, typename X&gt;
224 inline bool operator!=(const RefPtr&lt;T, U&gt;&amp; a, X* b)
225 {
226     return a.get() != b;
227 }
228 
229 template&lt;typename T, typename X, typename Y&gt;
230 inline bool operator!=(T* a, const RefPtr&lt;X, Y&gt;&amp; b)
231 {
232     return a != b.get();
233 }
234 
235 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
236 inline RefPtr&lt;T, U&gt; static_pointer_cast(const RefPtr&lt;X, Y&gt;&amp; p)
237 {
238     return RefPtr&lt;T, U&gt;(static_cast&lt;T*&gt;(p.get()));
239 }
240 
241 template &lt;typename T, typename U&gt;
242 struct IsSmartPtr&lt;RefPtr&lt;T, U&gt;&gt; {
<a name="7" id="anc7"></a><span class="line-modified">243     static constexpr bool value = true;</span>
244 };
245 
246 template&lt;typename T, typename U&gt;
247 inline RefPtr&lt;T, U&gt; adoptRef(T* p)
248 {
249     adopted(p);
250     return RefPtr&lt;T, U&gt;(p, RefPtr&lt;T, U&gt;::Adopt);
251 }
252 
253 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T* pointer)
254 {
255     return pointer;
256 }
257 
258 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T&amp; reference)
259 {
260     return &amp;reference;
261 }
262 
263 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
264 inline bool is(RefPtr&lt;ArgType, PtrTraits&gt;&amp; source)
265 {
266     return is&lt;ExpectedType&gt;(source.get());
267 }
268 
269 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
270 inline bool is(const RefPtr&lt;ArgType, PtrTraits&gt;&amp; source)
271 {
272     return is&lt;ExpectedType&gt;(source.get());
273 }
274 
275 } // namespace WTF
276 
277 using WTF::RefPtr;
278 using WTF::adoptRef;
279 using WTF::makeRefPtr;
280 using WTF::static_pointer_cast;
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
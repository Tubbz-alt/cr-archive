<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012, 2013 Google Inc. All rights reserved.
 12  * Copyright (C) 2014 Igalia S.L.
 13  *
 14  * This library is free software; you can redistribute it and/or
 15  * modify it under the terms of the GNU Library General Public
 16  * License as published by the Free Software Foundation; either
 17  * version 2 of the License, or (at your option) any later version.
 18  *
 19  * This library is distributed in the hope that it will be useful,
 20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 22  * Library General Public License for more details.
 23  *
 24  * You should have received a copy of the GNU Library General Public License
 25  * along with this library; see the file COPYING.LIB.  If not, write to
 26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 27  * Boston, MA 02110-1301, USA.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;StyleBuilder.h&quot;
 32 
 33 #include &quot;CSSFontSelector.h&quot;
 34 #include &quot;CSSPaintImageValue.h&quot;
 35 #include &quot;CSSValuePool.h&quot;
 36 #include &quot;HTMLElement.h&quot;
 37 #include &quot;PaintWorkletGlobalScope.h&quot;
 38 #include &quot;Settings.h&quot;
 39 #include &quot;StyleBuilderGenerated.h&quot;
 40 #include &quot;StyleFontSizeFunctions.h&quot;
 41 #include &quot;StylePropertyShorthand.h&quot;
 42 
 43 namespace WebCore {
 44 namespace Style {
 45 
 46 static const CSSPropertyID firstLowPriorityProperty = static_cast&lt;CSSPropertyID&gt;(lastHighPriorityProperty + 1);
 47 
 48 inline PropertyCascade::Direction directionFromStyle(const RenderStyle&amp; style)
 49 {
 50     return { style.direction(), style.writingMode() };
 51 }
 52 
 53 inline bool isValidVisitedLinkProperty(CSSPropertyID id)
 54 {
 55     switch (id) {
 56     case CSSPropertyBackgroundColor:
 57     case CSSPropertyBorderLeftColor:
 58     case CSSPropertyBorderRightColor:
 59     case CSSPropertyBorderTopColor:
 60     case CSSPropertyBorderBottomColor:
 61     case CSSPropertyCaretColor:
 62     case CSSPropertyColor:
 63     case CSSPropertyOutlineColor:
 64     case CSSPropertyColumnRuleColor:
 65     case CSSPropertyTextDecorationColor:
 66     case CSSPropertyWebkitTextEmphasisColor:
 67     case CSSPropertyWebkitTextFillColor:
 68     case CSSPropertyWebkitTextStrokeColor:
 69     case CSSPropertyFill:
 70     case CSSPropertyStroke:
 71     case CSSPropertyStrokeColor:
 72         return true;
 73     default:
 74         break;
 75     }
 76 
 77     return false;
 78 }
 79 
 80 Builder::Builder(RenderStyle&amp; style, BuilderContext&amp;&amp; context, const MatchResult&amp; matchResult, OptionSet&lt;CascadeLevel&gt; cascadeLevels, PropertyCascade::IncludedProperties includedProperties)
 81     : m_cascade(matchResult, cascadeLevels, includedProperties, directionFromStyle(style))
 82     , m_state(*this, style, WTFMove(context))
 83 {
 84 }
 85 
 86 Builder::~Builder() = default;
 87 
 88 void Builder::applyAllProperties()
 89 {
 90     applyHighPriorityProperties();
 91     applyLowPriorityProperties();
 92 }
 93 
 94 // High priority properties may affect resolution of other properties (they are mostly font related).
 95 void Builder::applyHighPriorityProperties()
 96 {
 97     applyProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition);
 98     m_state.adjustStyleForInterCharacterRuby();
 99 
100 #if ENABLE(DARK_MODE_CSS)
101     // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
102     applyProperties(CSSPropertyColorScheme, CSSPropertyColorScheme);
103 #endif
104 
105     applyProperties(firstCSSProperty, lastHighPriorityProperty);
106 
107     m_state.updateFont();
108 }
109 
110 void Builder::applyLowPriorityProperties()
111 {
112     ASSERT(!m_state.fontDirty());
113 
114     applyCustomProperties();
115     applyProperties(firstLowPriorityProperty, lastCSSProperty);
116     applyDeferredProperties();
117 
118     ASSERT(!m_state.fontDirty());
119 }
120 
121 void Builder::applyPropertyValue(CSSPropertyID propertyID, CSSValue* value)
122 {
123     if (!value)
124         return;
125 
126     applyProperty(propertyID, *value, SelectorChecker::MatchDefault);
127 
128     m_state.updateFont();
129 }
130 
131 void Builder::applyDeferredProperties()
132 {
133     for (auto&amp; property : m_cascade.deferredProperties())
134         applyCascadeProperty(property);
135 }
136 
137 void Builder::applyProperties(int firstProperty, int lastProperty)
138 {
139     if (LIKELY(m_cascade.customProperties().isEmpty()))
140         return applyPropertiesImpl&lt;CustomPropertyCycleTracking::Disabled&gt;(firstProperty, lastProperty);
141 
142     return applyPropertiesImpl&lt;CustomPropertyCycleTracking::Enabled&gt;(firstProperty, lastProperty);
143 }
144 
145 template&lt;Builder::CustomPropertyCycleTracking trackCycles&gt;
146 inline void Builder::applyPropertiesImpl(int firstProperty, int lastProperty)
147 {
148     for (int id = firstProperty; id &lt;= lastProperty; ++id) {
149         CSSPropertyID propertyID = static_cast&lt;CSSPropertyID&gt;(id);
150         if (!m_cascade.hasProperty(propertyID))
151             continue;
152         ASSERT(propertyID != CSSPropertyCustom);
153         auto&amp; property = m_cascade.property(propertyID);
154 
155         if (trackCycles == CustomPropertyCycleTracking::Enabled) {
156             if (UNLIKELY(m_state.m_inProgressProperties.get(propertyID))) {
157                 // We are in a cycle (eg. setting font size using registered custom property value containing em).
158                 // So this value should be unset.
159                 m_state.m_appliedProperties.set(propertyID);
160                 // This property is in a cycle, and only the root of the call stack will have firstProperty != lastProperty.
161                 ASSERT(firstProperty == lastProperty);
162                 continue;
163             }
164             m_state.m_inProgressProperties.set(propertyID);
165             applyCascadeProperty(property);
166             m_state.m_appliedProperties.set(propertyID);
167             m_state.m_inProgressProperties.set(propertyID, false);
168             continue;
169         }
170 
171         // If we don&#39;t have any custom properties, then there can&#39;t be any cycles.
172         applyCascadeProperty(property);
173     }
174 }
175 
176 void Builder::applyCustomProperties()
177 {
178     for (auto&amp; name : m_cascade.customProperties().keys())
179         applyCustomProperty(name);
180 }
181 
182 void Builder::applyCustomProperty(const String&amp; name)
183 {
184     if (m_state.m_appliedCustomProperties.contains(name) || !m_cascade.customProperties().contains(name))
185         return;
186 
187     auto property = m_cascade.customProperty(name);
188     bool inCycle = m_state.m_inProgressPropertiesCustom.contains(name);
189 
190     for (auto index : { SelectorChecker::MatchDefault, SelectorChecker::MatchLink, SelectorChecker::MatchVisited }) {
191         if (!property.cssValue[index])
192             continue;
193         if (index != SelectorChecker::MatchDefault &amp;&amp; m_state.style().insideLink() == InsideLink::NotInside)
194             continue;
195 
196         Ref&lt;CSSCustomPropertyValue&gt; valueToApply = CSSCustomPropertyValue::create(downcast&lt;CSSCustomPropertyValue&gt;(*property.cssValue[index]));
197 
198         if (inCycle) {
199             m_state.m_appliedCustomProperties.add(name); // Make sure we do not try to apply this property again while resolving it.
200             valueToApply = CSSCustomPropertyValue::createWithID(name, CSSValueInvalid);
201         }
202 
203         m_state.m_inProgressPropertiesCustom.add(name);
204 
205         if (WTF::holds_alternative&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(valueToApply-&gt;value())) {
206             RefPtr&lt;CSSValue&gt; parsedValue = resolvedVariableValue(CSSPropertyCustom, valueToApply.get());
207 
208             if (m_state.m_appliedCustomProperties.contains(name))
209                 return; // There was a cycle and the value was reset, so bail.
210 
211             if (!parsedValue)
212                 parsedValue = CSSCustomPropertyValue::createWithID(name, CSSValueUnset);
213 
214             valueToApply = downcast&lt;CSSCustomPropertyValue&gt;(*parsedValue);
215         }
216 
217         if (m_state.m_inProgressPropertiesCustom.contains(name)) {
218             m_state.m_linkMatch = index;
219             applyProperty(CSSPropertyCustom, valueToApply.get(), index);
220         }
221     }
222 
223     m_state.m_linkMatch = SelectorChecker::MatchDefault;
224     m_state.m_inProgressPropertiesCustom.remove(name);
225     m_state.m_appliedCustomProperties.add(name);
226 
227     for (auto index : { SelectorChecker::MatchDefault, SelectorChecker::MatchLink, SelectorChecker::MatchVisited }) {
228         if (!property.cssValue[index])
229             continue;
230         if (index != SelectorChecker::MatchDefault &amp;&amp; m_state.style().insideLink() == InsideLink::NotInside)
231             continue;
232 
233         Ref&lt;CSSCustomPropertyValue&gt; valueToApply = CSSCustomPropertyValue::create(downcast&lt;CSSCustomPropertyValue&gt;(*property.cssValue[index]));
234 
235         if (inCycle &amp;&amp; WTF::holds_alternative&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(valueToApply-&gt;value())) {
236             // Resolve this value so that we reset its dependencies.
237             resolvedVariableValue(CSSPropertyCustom, valueToApply.get());
238         }
239     }
240 }
241 
242 inline void Builder::applyCascadeProperty(const PropertyCascade::Property&amp; property)
243 {
244     m_state.m_cascadeLevel = property.level;
245     m_state.m_styleScopeOrdinal = property.styleScopeOrdinal;
246 
247     auto applyWithLinkMatch = [&amp;](SelectorChecker::LinkMatchMask linkMatch) {
248         if (property.cssValue[linkMatch]) {
249             m_state.m_linkMatch = linkMatch;
250             applyProperty(property.id, *property.cssValue[linkMatch], linkMatch);
251         }
252     };
253 
254     applyWithLinkMatch(SelectorChecker::MatchDefault);
255 
256     if (m_state.style().insideLink() == InsideLink::NotInside)
257         return;
258 
259     applyWithLinkMatch(SelectorChecker::MatchLink);
260     applyWithLinkMatch(SelectorChecker::MatchVisited);
261 
262     m_state.m_linkMatch = SelectorChecker::MatchDefault;
263 }
264 
265 void Builder::applyProperty(CSSPropertyID id, CSSValue&amp; value, SelectorChecker::LinkMatchMask linkMatchMask)
266 {
267     ASSERT_WITH_MESSAGE(!isShorthandCSSProperty(id), &quot;Shorthand property id = %d wasn&#39;t expanded at parsing time&quot;, id);
268 
269     auto valueToApply = resolveValue(id, value);
270 
271     if (CSSProperty::isDirectionAwareProperty(id)) {
272         auto direction = m_cascade.direction();
273         CSSPropertyID newId = CSSProperty::resolveDirectionAwareProperty(id, direction.textDirection, direction.writingMode);
274         ASSERT(newId != id);
275         return applyProperty(newId, valueToApply.get(), linkMatchMask);
276     }
277 
278     CSSCustomPropertyValue* customPropertyValue = nullptr;
279     CSSValueID customPropertyValueID = CSSValueInvalid;
280     CSSRegisteredCustomProperty* customPropertyRegistered = nullptr;
281 
282     if (id == CSSPropertyCustom) {
283         customPropertyValue = downcast&lt;CSSCustomPropertyValue&gt;(valueToApply.ptr());
284         ASSERT(customPropertyValue-&gt;isResolved());
285         if (WTF::holds_alternative&lt;CSSValueID&gt;(customPropertyValue-&gt;value()))
286             customPropertyValueID = WTF::get&lt;CSSValueID&gt;(customPropertyValue-&gt;value());
287         auto&amp; name = customPropertyValue-&gt;name();
288         customPropertyRegistered = m_state.document().getCSSRegisteredCustomPropertySet().get(name);
289     }
290 
291     bool isInherit = valueToApply-&gt;isInheritedValue() || customPropertyValueID == CSSValueInherit;
292     bool isInitial = valueToApply-&gt;isInitialValue() || customPropertyValueID == CSSValueInitial;
293 
294     bool isUnset = valueToApply-&gt;isUnsetValue() || customPropertyValueID == CSSValueUnset;
295     bool isRevert = valueToApply-&gt;isRevertValue() || customPropertyValueID == CSSValueRevert;
296 
297     if (isRevert) {
298         if (auto* rollback = m_cascade.propertyCascadeForRollback(m_state.m_cascadeLevel)) {
299             // With the rollback cascade built, we need to obtain the property and apply it. If the property is
300             // not present, then we behave like &quot;unset.&quot; Otherwise we apply the property instead of
301             // our own.
302             if (customPropertyValue) {
303                 if (customPropertyRegistered &amp;&amp; customPropertyRegistered-&gt;inherits &amp;&amp; rollback-&gt;hasCustomProperty(customPropertyValue-&gt;name())) {
304                     auto property = rollback-&gt;customProperty(customPropertyValue-&gt;name());
305                     if (property.cssValue[linkMatchMask])
306                         applyProperty(property.id, *property.cssValue[linkMatchMask], linkMatchMask);
307                     return;
308                 }
309             } else if (rollback-&gt;hasProperty(id)) {
310                 auto&amp; property = rollback-&gt;property(id);
311                 if (property.cssValue[linkMatchMask])
312                     applyProperty(property.id, *property.cssValue[linkMatchMask], linkMatchMask);
313                 return;
314             }
315         }
316 
317         isUnset = true;
318     }
319 
320     if (isUnset) {
321         if (CSSProperty::isInheritedProperty(id))
322             isInherit = true;
323         else
324             isInitial = true;
325     }
326 
327     ASSERT(!isInherit || !isInitial); // isInherit -&gt; !isInitial &amp;&amp; isInitial -&gt; !isInherit
328 
329     if (m_state.applyPropertyToVisitedLinkStyle() &amp;&amp; !isValidVisitedLinkProperty(id)) {
330         // Limit the properties that can be applied to only the ones honored by :visited.
331         return;
332     }
333 
334     if (isInherit &amp;&amp; !CSSProperty::isInheritedProperty(id))
335         m_state.style().setHasExplicitlyInheritedProperties();
336 
337 #if ENABLE(CSS_PAINTING_API)
338     if (is&lt;CSSPaintImageValue&gt;(valueToApply)) {
339         auto&amp; name = downcast&lt;CSSPaintImageValue&gt;(valueToApply.get()).name();
340         if (auto* paintWorklet = const_cast&lt;Document&amp;&gt;(m_state.document()).paintWorkletGlobalScopeForName(name)) {
341             auto locker = holdLock(paintWorklet-&gt;paintDefinitionLock());
342             if (auto* registration = paintWorklet-&gt;paintDefinitionMap().get(name)) {
343                 for (auto&amp; property : registration-&gt;inputProperties)
344                     m_state.style().addCustomPaintWatchProperty(property);
345             }
346         }
347     }
348 #endif
349 
350     BuilderGenerated::applyProperty(id, m_state, valueToApply.get(), isInitial, isInherit, customPropertyRegistered);
351 }
352 
353 Ref&lt;CSSValue&gt; Builder::resolveValue(CSSPropertyID propertyID, CSSValue&amp; value)
354 {
355     if (!value.hasVariableReferences())
356         return value;
357 
358     auto variableValue = resolvedVariableValue(propertyID, value);
359     // If the cascade has already applied this id, then we detected a cycle, and this value should be unset.
360     if (!variableValue || m_state.m_appliedProperties.get(propertyID)) {
361         if (CSSProperty::isInheritedProperty(propertyID))
362             return CSSValuePool::singleton().createInheritedValue();
363         return CSSValuePool::singleton().createExplicitInitialValue();
364     }
365 
366     return *variableValue;
367 }
368 
369 RefPtr&lt;CSSValue&gt; Builder::resolvedVariableValue(CSSPropertyID propID, const CSSValue&amp; value)
370 {
371     CSSParser parser(m_state.document());
372     return parser.parseValueWithVariableReferences(propID, value, m_state);
373 }
374 
375 }
376 }
    </pre>
  </body>
</html>
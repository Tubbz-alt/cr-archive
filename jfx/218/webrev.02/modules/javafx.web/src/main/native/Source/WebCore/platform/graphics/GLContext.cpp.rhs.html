<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GLContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011, 2012 Igalia, S.L.
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Lesser General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Lesser General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Lesser General Public
 15  *  License along with this library; if not, write to the Free Software
 16  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 17  */
 18 
 19 #include &quot;config.h&quot;
 20 
<a name="1" id="anc1"></a><span class="line-modified"> 21 #if ENABLE(GRAPHICS_CONTEXT_GL)</span>
 22 #include &quot;GLContext.h&quot;
 23 #include &lt;wtf/ThreadSpecific.h&gt;
 24 
 25 #if USE(EGL)
 26 #include &quot;GLContextEGL.h&quot;
 27 #endif
 28 
<a name="2" id="anc2"></a>





 29 #if USE(GLX)
 30 #include &quot;GLContextGLX.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 31 #include &quot;OpenGLShims.h&quot;</span>
 32 #endif
 33 
 34 using WTF::ThreadSpecific;
 35 
 36 namespace WebCore {
 37 
 38 class ThreadGlobalGLContext {
 39 public:
 40     static ThreadSpecific&lt;ThreadGlobalGLContext&gt;* staticGLContext;
 41 
 42     void setContext(GLContext* context) { m_context = context; }
 43     GLContext* context() { return m_context; }
 44 
 45 private:
 46     GLContext* m_context { nullptr };
 47 };
 48 
 49 ThreadSpecific&lt;ThreadGlobalGLContext&gt;* ThreadGlobalGLContext::staticGLContext;
 50 
 51 inline ThreadGlobalGLContext* currentContext()
 52 {
 53     if (!ThreadGlobalGLContext::staticGLContext)
 54         ThreadGlobalGLContext::staticGLContext = new ThreadSpecific&lt;ThreadGlobalGLContext&gt;;
 55     return *ThreadGlobalGLContext::staticGLContext;
 56 }
 57 
 58 static bool initializeOpenGLShimsIfNeeded()
 59 {
 60 #if USE(OPENGL_ES) || USE(LIBEPOXY)
 61     return true;
 62 #else
 63     static bool initialized = false;
 64     static bool success = true;
 65     if (!initialized) {
 66         success = initializeOpenGLShims();
 67         initialized = true;
 68     }
 69     return success;
 70 #endif
 71 }
 72 
 73 std::unique_ptr&lt;GLContext&gt; GLContext::createContextForWindow(GLNativeWindowType windowHandle, PlatformDisplay* platformDisplay)
 74 {
 75     if (!initializeOpenGLShimsIfNeeded())
 76         return nullptr;
 77 
 78     PlatformDisplay&amp; display = platformDisplay ? *platformDisplay : PlatformDisplay::sharedDisplay();
 79 #if PLATFORM(WAYLAND)
 80     if (display.type() == PlatformDisplay::Type::Wayland) {
 81         if (auto eglContext = GLContextEGL::createContext(windowHandle, display))
 82             return eglContext;
 83         return nullptr;
 84     }
 85 #endif
 86 
 87 #if USE(GLX)
 88     if (display.type() == PlatformDisplay::Type::X11) {
 89         if (auto glxContext = GLContextGLX::createContext(windowHandle, display))
 90             return glxContext;
 91     }
 92 #endif
 93 #if USE(EGL)
 94     if (auto eglContext = GLContextEGL::createContext(windowHandle, display))
 95         return eglContext;
 96 #endif
 97     return nullptr;
 98 }
 99 
100 std::unique_ptr&lt;GLContext&gt; GLContext::createOffscreenContext(PlatformDisplay* platformDisplay)
101 {
102     if (!initializeOpenGLShimsIfNeeded())
103         return nullptr;
104 
105     return createContextForWindow(0, platformDisplay ? platformDisplay : &amp;PlatformDisplay::sharedDisplay());
106 }
107 
108 std::unique_ptr&lt;GLContext&gt; GLContext::createSharingContext(PlatformDisplay&amp; display)
109 {
110     if (!initializeOpenGLShimsIfNeeded())
111         return nullptr;
112 
113 #if USE(GLX)
114     if (display.type() == PlatformDisplay::Type::X11) {
115         if (auto glxContext = GLContextGLX::createSharingContext(display))
116             return glxContext;
117     }
118 #endif
119 
120 #if USE(EGL) || PLATFORM(WAYLAND) || PLATFORM(WPE)
121     if (auto eglContext = GLContextEGL::createSharingContext(display))
122         return eglContext;
123 #endif
124 
125     return nullptr;
126 }
127 
128 GLContext::GLContext(PlatformDisplay&amp; display)
129     : m_display(display)
130 {
131 }
132 
133 GLContext::~GLContext()
134 {
135     if (this == currentContext()-&gt;context())
136         currentContext()-&gt;setContext(nullptr);
137 }
138 
139 bool GLContext::makeContextCurrent()
140 {
141     currentContext()-&gt;setContext(this);
142     return true;
143 }
144 
145 GLContext* GLContext::current()
146 {
147     return currentContext()-&gt;context();
148 }
149 
150 bool GLContext::isExtensionSupported(const char* extensionList, const char* extension)
151 {
152     if (!extensionList)
153         return false;
154 
155     ASSERT(extension);
156     int extensionLen = strlen(extension);
157     const char* extensionListPtr = extensionList;
158     while ((extensionListPtr = strstr(extensionListPtr, extension))) {
159         if (extensionListPtr[extensionLen] == &#39; &#39; || extensionListPtr[extensionLen] == &#39;\0&#39;)
160             return true;
161         extensionListPtr += extensionLen;
162     }
163     return false;
164 }
165 
166 unsigned GLContext::version()
167 {
168     if (!m_version) {
169         // Version string can start with the version number (all versions except GLES 1 and 2) or with
170         // &quot;OpenGL&quot;. Different fields inside the version string are separated by spaces.
171         String versionString = String(reinterpret_cast&lt;const char*&gt;(::glGetString(GL_VERSION)));
172         Vector&lt;String&gt; versionStringComponents = versionString.split(&#39; &#39;);
173 
174         Vector&lt;String&gt; versionDigits;
175         if (versionStringComponents[0] == &quot;OpenGL&quot;) {
176             // If the version string starts with &quot;OpenGL&quot; it can be GLES 1 or 2. In GLES1 version string starts
177             // with &quot;OpenGL ES-&lt;profile&gt; major.minor&quot; and in GLES2 with &quot;OpenGL ES major.minor&quot;. Version is the
178             // third component in both cases.
179             versionDigits = versionStringComponents[2].split(&#39;.&#39;);
180         } else {
181             // Version is the first component. The version number is always &quot;major.minor&quot; or
182             // &quot;major.minor.release&quot;. Ignore the release number.
183             versionDigits = versionStringComponents[0].split(&#39;.&#39;);
184         }
185 
186         m_version = versionDigits[0].toUInt() * 100 + versionDigits[1].toUInt() * 10;
187     }
188     return m_version;
189 }
190 
191 } // namespace WebCore
192 
193 #endif
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
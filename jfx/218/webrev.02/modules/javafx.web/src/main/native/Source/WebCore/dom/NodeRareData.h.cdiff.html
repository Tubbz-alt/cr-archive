<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/NodeRareData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NodeRareData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OverflowEvent.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/NodeRareData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008, 2010 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008 David Smith &lt;catfish.man@gmail.com&gt;
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
   * License as published by the Free Software Foundation; either
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008 David Smith &lt;catfish.man@gmail.com&gt;
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
   * License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,39 ***</span>
  
  #pragma once
  
  #include &quot;ChildNodeList.h&quot;
  #include &quot;HTMLCollection.h&quot;
<span class="line-removed">- #include &quot;HTMLNames.h&quot;</span>
<span class="line-removed">- #include &quot;LiveNodeList.h&quot;</span>
  #include &quot;MutationObserverRegistration.h&quot;
  #include &quot;QualifiedName.h&quot;
  #include &quot;TagCollection.h&quot;
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
<span class="line-removed">- #include &lt;wtf/text/AtomString.h&gt;</span>
  
  namespace WebCore {
  
  class LabelsNodeList;
  class NameNodeList;
  class RadioNodeList;
<span class="line-removed">- class TreeScope;</span>
  
<span class="line-modified">! template &lt;class ListType&gt; struct NodeListTypeIdentifier;</span>
<span class="line-removed">- template &lt;&gt; struct NodeListTypeIdentifier&lt;NameNodeList&gt; { static int value() { return 0; } };</span>
<span class="line-removed">- template &lt;&gt; struct NodeListTypeIdentifier&lt;RadioNodeList&gt; { static int value() { return 1; } };</span>
<span class="line-removed">- template &lt;&gt; struct NodeListTypeIdentifier&lt;LabelsNodeList&gt; { static int value() { return 2; } };</span>
  
  class NodeListsNodeData {
<span class="line-modified">!     WTF_MAKE_NONCOPYABLE(NodeListsNodeData); WTF_MAKE_FAST_ALLOCATED;</span>
  public:
<span class="line-modified">!     NodeListsNodeData()</span>
<span class="line-removed">-         : m_childNodeList(nullptr)</span>
<span class="line-removed">-         , m_emptyChildNodeList(nullptr)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void clearChildNodeListCache()
      {
          if (m_childNodeList)
              m_childNodeList-&gt;invalidateCache();
<span class="line-new-header">--- 21,31 ---</span>
  
  #pragma once
  
  #include &quot;ChildNodeList.h&quot;
  #include &quot;HTMLCollection.h&quot;
  #include &quot;MutationObserverRegistration.h&quot;
  #include &quot;QualifiedName.h&quot;
  #include &quot;TagCollection.h&quot;
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  
  namespace WebCore {
  
  class LabelsNodeList;
<span class="line-added">+ class LiveNodeList;</span>
  class NameNodeList;
  class RadioNodeList;
  
<span class="line-modified">! template&lt;typename ListType&gt; struct NodeListTypeIdentifier;</span>
  
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(NodeListsNodeData);</span>
  class NodeListsNodeData {
<span class="line-modified">!     WTF_MAKE_NONCOPYABLE(NodeListsNodeData);</span>
<span class="line-added">+     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(NodeListsNodeData);</span>
  public:
<span class="line-modified">!     NodeListsNodeData() = default;</span>
  
      void clearChildNodeListCache()
      {
          if (m_childNodeList)
              m_childNodeList-&gt;invalidateCache();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,30 ***</span>
          }
          static bool equal(const std::pair&lt;unsigned char, AtomString&gt;&amp; a, const std::pair&lt;unsigned char, AtomString&gt;&amp; b) { return a.first == b.first &amp;&amp; DefaultHash&lt;AtomString&gt;::Hash::equal(a.second, b.second); }
          static const bool safeToCompareToEmptyOrDeleted = DefaultHash&lt;AtomString&gt;::Hash::safeToCompareToEmptyOrDeleted;
      };
  
<span class="line-modified">!     typedef HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, LiveNodeList*, NodeListCacheMapEntryHash&gt; NodeListAtomicNameCacheMap;</span>
<span class="line-modified">!     typedef HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, HTMLCollection*, NodeListCacheMapEntryHash&gt; CollectionCacheMap;</span>
<span class="line-modified">!     typedef HashMap&lt;QualifiedName, TagCollectionNS*&gt; TagCollectionNSCache;</span>
  
      template&lt;typename T, typename ContainerType&gt;
<span class="line-modified">!     ALWAYS_INLINE Ref&lt;T&gt; addCacheWithAtomicName(ContainerType&amp; container, const AtomString&amp; name)</span>
      {
<span class="line-modified">!         NodeListAtomicNameCacheMap::AddResult result = m_atomicNameCaches.fastAdd(namedNodeListKey&lt;T&gt;(name), nullptr);</span>
          if (!result.isNewEntry)
              return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
  
          auto list = T::create(container, name);
          result.iterator-&gt;value = &amp;list.get();
          return list;
      }
  
      ALWAYS_INLINE Ref&lt;TagCollectionNS&gt; addCachedTagCollectionNS(ContainerNode&amp; node, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
      {
<span class="line-modified">!         QualifiedName name(nullAtom(), localName, namespaceURI);</span>
<span class="line-removed">-         TagCollectionNSCache::AddResult result = m_tagCollectionNSCache.fastAdd(name, nullptr);</span>
          if (!result.isNewEntry)
              return *result.iterator-&gt;value;
  
          auto list = TagCollectionNS::create(node, namespaceURI, localName);
          result.iterator-&gt;value = list.ptr();
<span class="line-new-header">--- 94,29 ---</span>
          }
          static bool equal(const std::pair&lt;unsigned char, AtomString&gt;&amp; a, const std::pair&lt;unsigned char, AtomString&gt;&amp; b) { return a.first == b.first &amp;&amp; DefaultHash&lt;AtomString&gt;::Hash::equal(a.second, b.second); }
          static const bool safeToCompareToEmptyOrDeleted = DefaultHash&lt;AtomString&gt;::Hash::safeToCompareToEmptyOrDeleted;
      };
  
<span class="line-modified">!     using NodeListCacheMap = HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, LiveNodeList*, NodeListCacheMapEntryHash&gt;;</span>
<span class="line-modified">!     using CollectionCacheMap = HashMap&lt;std::pair&lt;unsigned char, AtomString&gt;, HTMLCollection*, NodeListCacheMapEntryHash&gt;;</span>
<span class="line-modified">!     using TagCollectionNSCache = HashMap&lt;QualifiedName, TagCollectionNS*&gt;;</span>
  
      template&lt;typename T, typename ContainerType&gt;
<span class="line-modified">!     ALWAYS_INLINE Ref&lt;T&gt; addCacheWithAtomName(ContainerType&amp; container, const AtomString&amp; name)</span>
      {
<span class="line-modified">!         auto result = m_atomNameCaches.fastAdd(namedNodeListKey&lt;T&gt;(name), nullptr);</span>
          if (!result.isNewEntry)
              return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
  
          auto list = T::create(container, name);
          result.iterator-&gt;value = &amp;list.get();
          return list;
      }
  
      ALWAYS_INLINE Ref&lt;TagCollectionNS&gt; addCachedTagCollectionNS(ContainerNode&amp; node, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
      {
<span class="line-modified">!         auto result = m_tagCollectionNSCache.fastAdd(QualifiedName { nullAtom(), localName, namespaceURI }, nullptr);</span>
          if (!result.isNewEntry)
              return *result.iterator-&gt;value;
  
          auto list = TagCollectionNS::create(node, namespaceURI, localName);
          result.iterator-&gt;value = list.ptr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
      }
  
      template&lt;typename T, typename ContainerType&gt;
      ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType, const AtomString&amp; name)
      {
<span class="line-modified">!         CollectionCacheMap::AddResult result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, name), nullptr);</span>
          if (!result.isNewEntry)
              return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
  
          auto list = T::create(container, collectionType, name);
          result.iterator-&gt;value = &amp;list.get();
<span class="line-new-header">--- 124,11 ---</span>
      }
  
      template&lt;typename T, typename ContainerType&gt;
      ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType, const AtomString&amp; name)
      {
<span class="line-modified">!         auto result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, name), nullptr);</span>
          if (!result.isNewEntry)
              return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
  
          auto list = T::create(container, collectionType, name);
          result.iterator-&gt;value = &amp;list.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,11 ***</span>
      }
  
      template&lt;typename T, typename ContainerType&gt;
      ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType)
      {
<span class="line-modified">!         CollectionCacheMap::AddResult result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, starAtom()), nullptr);</span>
          if (!result.isNewEntry)
              return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
  
          auto list = T::create(container, collectionType);
          result.iterator-&gt;value = &amp;list.get();
<span class="line-new-header">--- 136,11 ---</span>
      }
  
      template&lt;typename T, typename ContainerType&gt;
      ALWAYS_INLINE Ref&lt;T&gt; addCachedCollection(ContainerType&amp; container, CollectionType collectionType)
      {
<span class="line-modified">!         auto result = m_cachedCollections.fastAdd(namedCollectionKey(collectionType, starAtom()), nullptr);</span>
          if (!result.isNewEntry)
              return static_cast&lt;T&amp;&gt;(*result.iterator-&gt;value);
  
          auto list = T::create(container, collectionType);
          result.iterator-&gt;value = &amp;list.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,17 ***</span>
      T* cachedCollection(CollectionType collectionType)
      {
          return static_cast&lt;T*&gt;(m_cachedCollections.get(namedCollectionKey(collectionType, starAtom())));
      }
  
<span class="line-modified">!     template &lt;class NodeListType&gt;</span>
<span class="line-modified">!     void removeCacheWithAtomicName(NodeListType* list, const AtomString&amp; name = starAtom())</span>
      {
<span class="line-modified">!         ASSERT(list == m_atomicNameCaches.get(namedNodeListKey&lt;NodeListType&gt;(name)));</span>
<span class="line-modified">!         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(list-&gt;ownerNode()))</span>
              return;
<span class="line-modified">!         m_atomicNameCaches.remove(namedNodeListKey&lt;NodeListType&gt;(name));</span>
      }
  
      void removeCachedTagCollectionNS(HTMLCollection&amp; collection, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
      {
          QualifiedName name(nullAtom(), localName, namespaceURI);
<span class="line-new-header">--- 151,17 ---</span>
      T* cachedCollection(CollectionType collectionType)
      {
          return static_cast&lt;T*&gt;(m_cachedCollections.get(namedCollectionKey(collectionType, starAtom())));
      }
  
<span class="line-modified">!     template&lt;typename NodeListType&gt;</span>
<span class="line-modified">!     void removeCacheWithAtomName(NodeListType&amp; list, const AtomString&amp; name)</span>
      {
<span class="line-modified">!         ASSERT(&amp;list == m_atomNameCaches.get(namedNodeListKey&lt;NodeListType&gt;(name)));</span>
<span class="line-modified">!         if (deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(list.ownerNode()))</span>
              return;
<span class="line-modified">!         m_atomNameCaches.remove(namedNodeListKey&lt;NodeListType&gt;(name));</span>
      }
  
      void removeCachedTagCollectionNS(HTMLCollection&amp; collection, const AtomString&amp; namespaceURI, const AtomString&amp; localName)
      {
          QualifiedName name(nullAtom(), localName, namespaceURI);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,11 ***</span>
          if (&amp;oldDocument == &amp;newDocument) {
              invalidateCaches();
              return;
          }
  
<span class="line-modified">!         for (auto&amp; cache : m_atomicNameCaches.values())</span>
              cache-&gt;invalidateCacheForDocument(oldDocument);
  
          for (auto&amp; list : m_tagCollectionNSCache.values()) {
              ASSERT(!list-&gt;isRootedAtDocument());
              list-&gt;invalidateCacheForDocument(oldDocument);
<span class="line-new-header">--- 192,11 ---</span>
          if (&amp;oldDocument == &amp;newDocument) {
              invalidateCaches();
              return;
          }
  
<span class="line-modified">!         for (auto&amp; cache : m_atomNameCaches.values())</span>
              cache-&gt;invalidateCacheForDocument(oldDocument);
  
          for (auto&amp; list : m_tagCollectionNSCache.values()) {
              ASSERT(!list-&gt;isRootedAtDocument());
              list-&gt;invalidateCacheForDocument(oldDocument);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,23 ***</span>
      std::pair&lt;unsigned char, AtomString&gt; namedCollectionKey(CollectionType type, const AtomString&amp; name)
      {
          return std::pair&lt;unsigned char, AtomString&gt;(type, name);
      }
  
<span class="line-modified">!     template &lt;class NodeListType&gt;</span>
      std::pair&lt;unsigned char, AtomString&gt; namedNodeListKey(const AtomString&amp; name)
      {
          return std::pair&lt;unsigned char, AtomString&gt;(NodeListTypeIdentifier&lt;NodeListType&gt;::value(), name);
      }
  
      bool deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp;);
  
      // These two are currently mutually exclusive and could be unioned. Not very important as this class is large anyway.
<span class="line-modified">!     ChildNodeList* m_childNodeList;</span>
<span class="line-modified">!     EmptyNodeList* m_emptyChildNodeList;</span>
  
<span class="line-modified">!     NodeListAtomicNameCacheMap m_atomicNameCaches;</span>
      TagCollectionNSCache m_tagCollectionNSCache;
      CollectionCacheMap m_cachedCollections;
  };
  
  class NodeMutationObserverData {
<span class="line-new-header">--- 210,23 ---</span>
      std::pair&lt;unsigned char, AtomString&gt; namedCollectionKey(CollectionType type, const AtomString&amp; name)
      {
          return std::pair&lt;unsigned char, AtomString&gt;(type, name);
      }
  
<span class="line-modified">!     template&lt;typename NodeListType&gt;</span>
      std::pair&lt;unsigned char, AtomString&gt; namedNodeListKey(const AtomString&amp; name)
      {
          return std::pair&lt;unsigned char, AtomString&gt;(NodeListTypeIdentifier&lt;NodeListType&gt;::value(), name);
      }
  
      bool deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp;);
  
      // These two are currently mutually exclusive and could be unioned. Not very important as this class is large anyway.
<span class="line-modified">!     ChildNodeList* m_childNodeList { nullptr };</span>
<span class="line-modified">!     EmptyNodeList* m_emptyChildNodeList { nullptr };</span>
  
<span class="line-modified">!     NodeListCacheMap m_atomNameCaches;</span>
      TagCollectionNSCache m_tagCollectionNSCache;
      CollectionCacheMap m_cachedCollections;
  };
  
  class NodeMutationObserverData {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,12 ***</span>
      HashSet&lt;MutationObserverRegistration*&gt; transientRegistry;
  
      NodeMutationObserverData() { }
  };
  
  class NodeRareData {
<span class="line-modified">!     WTF_MAKE_NONCOPYABLE(NodeRareData); WTF_MAKE_FAST_ALLOCATED;</span>
  public:
  #if defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS
      enum class UseType : uint16_t {
          ConnectedFrameCount = 1 &lt;&lt; 0,
          NodeList = 1 &lt;&lt; 1,
<span class="line-new-header">--- 236,14 ---</span>
      HashSet&lt;MutationObserverRegistration*&gt; transientRegistry;
  
      NodeMutationObserverData() { }
  };
  
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(NodeRareData);</span>
  class NodeRareData {
<span class="line-modified">!     WTF_MAKE_NONCOPYABLE(NodeRareData);</span>
<span class="line-added">+     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(NodeRareData);</span>
  public:
  #if defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS
      enum class UseType : uint16_t {
          ConnectedFrameCount = 1 &lt;&lt; 0,
          NodeList = 1 &lt;&lt; 1,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,15 ***</span>
  
      std::unique_ptr&lt;NodeListsNodeData&gt; m_nodeLists;
      std::unique_ptr&lt;NodeMutationObserverData&gt; m_mutationObserverData;
  };
  
  inline bool NodeListsNodeData::deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp; ownerNode)
  {
      ASSERT(ownerNode.nodeLists() == this);
<span class="line-modified">!     if ((m_childNodeList ? 1 : 0) + (m_emptyChildNodeList ? 1 : 0) + m_atomicNameCaches.size()</span>
<span class="line-modified">!         + m_tagCollectionNSCache.size() + m_cachedCollections.size() != 1)</span>
          return false;
      ownerNode.clearNodeLists();
      return true;
  }
  
<span class="line-new-header">--- 322,31 ---</span>
  
      std::unique_ptr&lt;NodeListsNodeData&gt; m_nodeLists;
      std::unique_ptr&lt;NodeMutationObserverData&gt; m_mutationObserverData;
  };
  
<span class="line-added">+ template&lt;&gt; struct NodeListTypeIdentifier&lt;NameNodeList&gt; {</span>
<span class="line-added">+     static constexpr unsigned char value() { return 0; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;&gt; struct NodeListTypeIdentifier&lt;RadioNodeList&gt; {</span>
<span class="line-added">+     static constexpr unsigned char value() { return 1; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;&gt; struct NodeListTypeIdentifier&lt;LabelsNodeList&gt; {</span>
<span class="line-added">+     static constexpr unsigned char value() { return 2; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  inline bool NodeListsNodeData::deleteThisAndUpdateNodeRareDataIfAboutToRemoveLastList(Node&amp; ownerNode)
  {
      ASSERT(ownerNode.nodeLists() == this);
<span class="line-modified">!     size_t listsCount = (m_childNodeList ? 1 : 0)</span>
<span class="line-modified">!         + (m_emptyChildNodeList ? 1 : 0)</span>
<span class="line-added">+         + m_atomNameCaches.size()</span>
<span class="line-added">+         + m_tagCollectionNSCache.size()</span>
<span class="line-added">+         + m_cachedCollections.size();</span>
<span class="line-added">+     if (listsCount != 1)</span>
          return false;
      ownerNode.clearNodeLists();
      return true;
  }
  
</pre>
<center><a href="NodeRareData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OverflowEvent.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
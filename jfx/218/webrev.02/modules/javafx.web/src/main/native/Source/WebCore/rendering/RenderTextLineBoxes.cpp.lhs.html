<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTextLineBoxes.h&quot;
 28 
 29 #include &quot;EllipsisBox.h&quot;
 30 #include &quot;InlineTextBox.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 #include &quot;RenderStyle.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &quot;RootInlineBox.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 RenderTextLineBoxes::RenderTextLineBoxes()
 39     : m_first(nullptr)
 40     , m_last(nullptr)
 41 {
 42 }
 43 
 44 InlineTextBox* RenderTextLineBoxes::createAndAppendLineBox(RenderText&amp; renderText)
 45 {
 46     auto textBox = renderText.createTextBox();
 47     if (!m_first) {
 48         m_first = textBox.get();
 49         m_last = textBox.get();
 50     } else {
 51         m_last-&gt;setNextTextBox(textBox.get());
 52         textBox-&gt;setPreviousTextBox(m_last);
 53         m_last = textBox.get();
 54     }
 55     return textBox.release();
 56 }
 57 
 58 void RenderTextLineBoxes::extract(InlineTextBox&amp; box)
 59 {
 60     checkConsistency();
 61 
 62     m_last = box.prevTextBox();
 63     if (&amp;box == m_first)
 64         m_first = nullptr;
 65     if (box.prevTextBox())
 66         box.prevTextBox()-&gt;setNextTextBox(nullptr);
 67     box.setPreviousTextBox(nullptr);
 68     for (auto* current = &amp;box; current; current = current-&gt;nextTextBox())
 69         current-&gt;setExtracted();
 70 
 71     checkConsistency();
 72 }
 73 
 74 void RenderTextLineBoxes::attach(InlineTextBox&amp; box)
 75 {
 76     checkConsistency();
 77 
 78     if (m_last) {
 79         m_last-&gt;setNextTextBox(&amp;box);
 80         box.setPreviousTextBox(m_last);
 81     } else
 82         m_first = &amp;box;
 83     InlineTextBox* last = nullptr;
 84     for (auto* current = &amp;box; current; current = current-&gt;nextTextBox()) {
 85         current-&gt;setExtracted(false);
 86         last = current;
 87     }
 88     m_last = last;
 89 
 90     checkConsistency();
 91 }
 92 
 93 void RenderTextLineBoxes::remove(InlineTextBox&amp; box)
 94 {
 95     checkConsistency();
 96 
 97     if (&amp;box == m_first)
 98         m_first = box.nextTextBox();
 99     if (&amp;box == m_last)
100         m_last = box.prevTextBox();
101     if (box.nextTextBox())
102         box.nextTextBox()-&gt;setPreviousTextBox(box.prevTextBox());
103     if (box.prevTextBox())
104         box.prevTextBox()-&gt;setNextTextBox(box.nextTextBox());
105 
106     checkConsistency();
107 }
108 
109 void RenderTextLineBoxes::removeAllFromParent(RenderText&amp; renderer)
110 {
111     if (!m_first) {
112         if (renderer.parent())
113             renderer.parent()-&gt;dirtyLinesFromChangedChild(renderer);
114         return;
115     }
116     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
117         box-&gt;removeFromParent();
118 }
119 
120 void RenderTextLineBoxes::deleteAll()
121 {
122     if (!m_first)
123         return;
124     InlineTextBox* next;
125     for (auto* current = m_first; current; current = next) {
126         next = current-&gt;nextTextBox();
127         delete current;
128     }
129     m_first = nullptr;
130     m_last = nullptr;
131 }
132 
133 InlineTextBox* RenderTextLineBoxes::findNext(int offset, int&amp; position) const
134 {
135     if (!m_first)
136         return nullptr;
137     // FIXME: This looks buggy. The function is only used for debugging purposes.
138     auto current = m_first;
139     int currentOffset = current-&gt;len();
140     while (offset &gt; currentOffset &amp;&amp; current-&gt;nextTextBox()) {
141         current = current-&gt;nextTextBox();
142         currentOffset = current-&gt;start() + current-&gt;len();
143     }
144     // we are now in the correct text run
145     position = (offset &gt; currentOffset ? current-&gt;len() : current-&gt;len() - (currentOffset - offset));
146     return current;
147 }
148 
<a name="1" id="anc1"></a><span class="line-removed">149 IntRect RenderTextLineBoxes::boundingBox(const RenderText&amp; renderer) const</span>
<span class="line-removed">150 {</span>
<span class="line-removed">151     if (!m_first)</span>
<span class="line-removed">152         return IntRect();</span>
<span class="line-removed">153 </span>
<span class="line-removed">154     // Return the width of the minimal left side and the maximal right side.</span>
<span class="line-removed">155     float logicalLeftSide = 0;</span>
<span class="line-removed">156     float logicalRightSide = 0;</span>
<span class="line-removed">157     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {</span>
<span class="line-removed">158         if (current == m_first || current-&gt;logicalLeft() &lt; logicalLeftSide)</span>
<span class="line-removed">159             logicalLeftSide = current-&gt;logicalLeft();</span>
<span class="line-removed">160         if (current == m_first || current-&gt;logicalRight() &gt; logicalRightSide)</span>
<span class="line-removed">161             logicalRightSide = current-&gt;logicalRight();</span>
<span class="line-removed">162     }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164     bool isHorizontal = renderer.style().isHorizontalWritingMode();</span>
<span class="line-removed">165 </span>
<span class="line-removed">166     float x = isHorizontal ? logicalLeftSide : m_first-&gt;x();</span>
<span class="line-removed">167     float y = isHorizontal ? m_first-&gt;y() : logicalLeftSide;</span>
<span class="line-removed">168     float width = isHorizontal ? logicalRightSide - logicalLeftSide : m_last-&gt;logicalBottom() - x;</span>
<span class="line-removed">169     float height = isHorizontal ? m_last-&gt;logicalBottom() - y : logicalRightSide - logicalLeftSide;</span>
<span class="line-removed">170     return enclosingIntRect(FloatRect(x, y, width, height));</span>
<span class="line-removed">171 }</span>
<span class="line-removed">172 </span>
<span class="line-removed">173 IntPoint RenderTextLineBoxes::firstRunLocation() const</span>
<span class="line-removed">174 {</span>
<span class="line-removed">175     if (!m_first)</span>
<span class="line-removed">176         return IntPoint();</span>
<span class="line-removed">177     return IntPoint(m_first-&gt;topLeft());</span>
<span class="line-removed">178 }</span>
<span class="line-removed">179 </span>
180 LayoutRect RenderTextLineBoxes::visualOverflowBoundingBox(const RenderText&amp; renderer) const
181 {
182     if (!m_first)
183         return LayoutRect();
184 
185     // Return the width of the minimal left side and the maximal right side.
186     auto logicalLeftSide = LayoutUnit::max();
187     auto logicalRightSide = LayoutUnit::min();
188     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
189         logicalLeftSide = std::min(logicalLeftSide, current-&gt;logicalLeftVisualOverflow());
190         logicalRightSide = std::max(logicalRightSide, current-&gt;logicalRightVisualOverflow());
191     }
192 
193     auto logicalTop = m_first-&gt;logicalTopVisualOverflow();
194     auto logicalWidth = logicalRightSide - logicalLeftSide;
195     auto logicalHeight = m_last-&gt;logicalBottomVisualOverflow() - logicalTop;
196 
197     LayoutRect rect(logicalLeftSide, logicalTop, logicalWidth, logicalHeight);
198     if (!renderer.style().isHorizontalWritingMode())
199         rect = rect.transposedRect();
200     return rect;
201 }
202 
<a name="2" id="anc2"></a><span class="line-removed">203 bool RenderTextLineBoxes::hasRenderedText() const</span>
<span class="line-removed">204 {</span>
<span class="line-removed">205     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">206         if (box-&gt;len())</span>
<span class="line-removed">207             return true;</span>
<span class="line-removed">208     }</span>
<span class="line-removed">209     return false;</span>
<span class="line-removed">210 }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212 int RenderTextLineBoxes::caretMinOffset() const</span>
<span class="line-removed">213 {</span>
<span class="line-removed">214     auto box = m_first;</span>
<span class="line-removed">215     if (!box)</span>
<span class="line-removed">216         return 0;</span>
<span class="line-removed">217     int minOffset = box-&gt;start();</span>
<span class="line-removed">218     for (box = box-&gt;nextTextBox(); box; box = box-&gt;nextTextBox())</span>
<span class="line-removed">219         minOffset = std::min&lt;int&gt;(minOffset, box-&gt;start());</span>
<span class="line-removed">220     return minOffset;</span>
<span class="line-removed">221 }</span>
<span class="line-removed">222 </span>
<span class="line-removed">223 int RenderTextLineBoxes::caretMaxOffset(const RenderText&amp; renderer) const</span>
<span class="line-removed">224 {</span>
<span class="line-removed">225     auto box = m_last;</span>
<span class="line-removed">226     if (!box)</span>
<span class="line-removed">227         return renderer.text().length();</span>
<span class="line-removed">228 </span>
<span class="line-removed">229     int maxOffset = box-&gt;start() + box-&gt;len();</span>
<span class="line-removed">230     for (box = box-&gt;prevTextBox(); box; box = box-&gt;prevTextBox())</span>
<span class="line-removed">231         maxOffset = std::max&lt;int&gt;(maxOffset, box-&gt;start() + box-&gt;len());</span>
<span class="line-removed">232     return maxOffset;</span>
<span class="line-removed">233 }</span>
<span class="line-removed">234 </span>
<span class="line-removed">235 bool RenderTextLineBoxes::containsOffset(const RenderText&amp; renderer, unsigned offset, OffsetType type) const</span>
<span class="line-removed">236 {</span>
<span class="line-removed">237     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">238         if (offset &lt; box-&gt;start() &amp;&amp; !renderer.containsReversedText())</span>
<span class="line-removed">239             return false;</span>
<span class="line-removed">240         unsigned boxEnd = box-&gt;start() + box-&gt;len();</span>
<span class="line-removed">241         if (offset &gt;= box-&gt;start() &amp;&amp; offset &lt;= boxEnd) {</span>
<span class="line-removed">242             if (offset == boxEnd &amp;&amp; (type == CharacterOffset || box-&gt;isLineBreak()))</span>
<span class="line-removed">243                 continue;</span>
<span class="line-removed">244             if (type == CharacterOffset)</span>
<span class="line-removed">245                 return true;</span>
<span class="line-removed">246             // Return false for offsets inside composed characters.</span>
<span class="line-removed">247             return !offset || offset == static_cast&lt;unsigned&gt;(renderer.nextOffset(renderer.previousOffset(offset)));</span>
<span class="line-removed">248         }</span>
<span class="line-removed">249     }</span>
<span class="line-removed">250     return false;</span>
<span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253 unsigned RenderTextLineBoxes::countCharacterOffsetsUntil(unsigned offset) const</span>
<span class="line-removed">254 {</span>
<span class="line-removed">255     unsigned result = 0;</span>
<span class="line-removed">256     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">257         if (offset &lt; box-&gt;start())</span>
<span class="line-removed">258             return result;</span>
<span class="line-removed">259         if (offset &lt;= box-&gt;start() + box-&gt;len()) {</span>
<span class="line-removed">260             result += offset - box-&gt;start();</span>
<span class="line-removed">261             return result;</span>
<span class="line-removed">262         }</span>
<span class="line-removed">263         result += box-&gt;len();</span>
<span class="line-removed">264     }</span>
<span class="line-removed">265     return result;</span>
<span class="line-removed">266 }</span>
<span class="line-removed">267 </span>
268 enum ShouldAffinityBeDownstream { AlwaysDownstream, AlwaysUpstream, UpstreamIfPositionIsNotAtStart };
269 
270 static bool lineDirectionPointFitsInBox(int pointLineDirection, const InlineTextBox&amp; box, ShouldAffinityBeDownstream&amp; shouldAffinityBeDownstream)
271 {
272     shouldAffinityBeDownstream = AlwaysDownstream;
273 
274     // the x coordinate is equal to the left edge of this box
275     // the affinity must be downstream so the position doesn&#39;t jump back to the previous line
276     // except when box is the first box in the line
277     if (pointLineDirection &lt;= box.logicalLeft()) {
<a name="3" id="anc3"></a><span class="line-modified">278         shouldAffinityBeDownstream = !box.prevLeafChild() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;</span>
279         return true;
280     }
281 
282 #if !PLATFORM(IOS_FAMILY)
283     // and the x coordinate is to the left of the right edge of this box
284     // check to see if position goes in this box
285     if (pointLineDirection &lt; box.logicalRight()) {
286         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
287         return true;
288     }
289 #endif
290 
291     // box is first on line
292     // and the x coordinate is to the left of the first text box left edge
<a name="4" id="anc4"></a><span class="line-modified">293     if (!box.prevLeafChildIgnoringLineBreak() &amp;&amp; pointLineDirection &lt; box.logicalLeft())</span>
294         return true;
295 
<a name="5" id="anc5"></a><span class="line-modified">296     if (!box.nextLeafChildIgnoringLineBreak()) {</span>
297         // box is last on line
298         // and the x coordinate is to the right of the last text box right edge
299         // generate VisiblePosition, use UPSTREAM affinity if possible
300         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
301         return true;
302     }
303 
304     return false;
305 }
306 
307 static VisiblePosition createVisiblePositionForBox(const InlineBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
308 {
309     EAffinity affinity = VP_DEFAULT_AFFINITY;
310     switch (shouldAffinityBeDownstream) {
311     case AlwaysDownstream:
312         affinity = DOWNSTREAM;
313         break;
314     case AlwaysUpstream:
315         affinity = VP_UPSTREAM_IF_POSSIBLE;
316         break;
317     case UpstreamIfPositionIsNotAtStart:
318         affinity = offset &gt; box.caretMinOffset() ? VP_UPSTREAM_IF_POSSIBLE : DOWNSTREAM;
319         break;
320     }
321     return box.renderer().createVisiblePosition(offset, affinity);
322 }
323 
324 static VisiblePosition createVisiblePositionAfterAdjustingOffsetForBiDi(const InlineTextBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
325 {
326     ASSERT(offset &gt;= 0);
327 
328     if (offset &amp;&amp; static_cast&lt;unsigned&gt;(offset) &lt; box.len())
329         return createVisiblePositionForBox(box, box.start() + offset, shouldAffinityBeDownstream);
330 
331     bool positionIsAtStartOfBox = !offset;
332     if (positionIsAtStartOfBox == box.isLeftToRightDirection()) {
333         // offset is on the left edge
334 
<a name="6" id="anc6"></a><span class="line-modified">335         const InlineBox* prevBox = box.prevLeafChildIgnoringLineBreak();</span>
336         if ((prevBox &amp;&amp; prevBox-&gt;bidiLevel() == box.bidiLevel())
337             || box.renderer().containingBlock()-&gt;style().direction() == box.direction()) // FIXME: left on 12CBA
338             return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
339 
340         if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
341             // e.g. left of B in aDC12BAb
342             const InlineBox* leftmostBox;
343             do {
344                 leftmostBox = prevBox;
<a name="7" id="anc7"></a><span class="line-modified">345                 prevBox = leftmostBox-&gt;prevLeafChildIgnoringLineBreak();</span>
346             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel());
347             return createVisiblePositionForBox(*leftmostBox, leftmostBox-&gt;caretRightmostOffset(), shouldAffinityBeDownstream);
348         }
349 
350         if (!prevBox || prevBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
351             // e.g. left of D in aDC12BAb
352             const InlineBox* rightmostBox;
353             const InlineBox* nextBox = &amp;box;
354             do {
355                 rightmostBox = nextBox;
<a name="8" id="anc8"></a><span class="line-modified">356                 nextBox = rightmostBox-&gt;nextLeafChildIgnoringLineBreak();</span>
357             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt;= box.bidiLevel());
358             return createVisiblePositionForBox(*rightmostBox,
359                 box.isLeftToRightDirection() ? rightmostBox-&gt;caretMaxOffset() : rightmostBox-&gt;caretMinOffset(), shouldAffinityBeDownstream);
360         }
361 
362         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
363     }
364 
<a name="9" id="anc9"></a><span class="line-modified">365     const InlineBox* nextBox = box.nextLeafChildIgnoringLineBreak();</span>
366     if ((nextBox &amp;&amp; nextBox-&gt;bidiLevel() == box.bidiLevel())
367         || box.renderer().containingBlock()-&gt;style().direction() == box.direction())
368         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
369 
370     // offset is on the right edge
371     if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
372         // e.g. right of C in aDC12BAb
373         const InlineBox* rightmostBox;
374         do {
375             rightmostBox = nextBox;
<a name="10" id="anc10"></a><span class="line-modified">376             nextBox = rightmostBox-&gt;nextLeafChildIgnoringLineBreak();</span>
377         } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel());
378         return createVisiblePositionForBox(*rightmostBox, rightmostBox-&gt;caretLeftmostOffset(), shouldAffinityBeDownstream);
379     }
380 
381     if (!nextBox || nextBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
382         // e.g. right of A in aDC12BAb
383         const InlineBox* leftmostBox;
384         const InlineBox* prevBox = &amp;box;
385         do {
386             leftmostBox = prevBox;
<a name="11" id="anc11"></a><span class="line-modified">387             prevBox = leftmostBox-&gt;prevLeafChildIgnoringLineBreak();</span>
388         } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt;= box.bidiLevel());
389         return createVisiblePositionForBox(*leftmostBox,
390             box.isLeftToRightDirection() ? leftmostBox-&gt;caretMinOffset() : leftmostBox-&gt;caretMaxOffset(), shouldAffinityBeDownstream);
391     }
392 
393     return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
394 }
395 
396 VisiblePosition RenderTextLineBoxes::positionForPoint(const RenderText&amp; renderer, const LayoutPoint&amp; point) const
397 {
398     if (!m_first || !renderer.text().length())
399         return renderer.createVisiblePosition(0, DOWNSTREAM);
400 
401     LayoutUnit pointLineDirection = m_first-&gt;isHorizontal() ? point.x() : point.y();
402     LayoutUnit pointBlockDirection = m_first-&gt;isHorizontal() ? point.y() : point.x();
403     bool blocksAreFlipped = renderer.style().isFlippedBlocksWritingMode();
404 
405     InlineTextBox* lastBox = nullptr;
406     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<a name="12" id="anc12"></a><span class="line-modified">407         if (box-&gt;isLineBreak() &amp;&amp; !box-&gt;prevLeafChild() &amp;&amp; box-&gt;nextLeafChild() &amp;&amp; !box-&gt;nextLeafChild()-&gt;isLineBreak())</span>
408             box = box-&gt;nextTextBox();
409 
410         auto&amp; rootBox = box-&gt;root();
411         LayoutUnit top = std::min(rootBox.selectionTop(), rootBox.lineTop());
412         if (pointBlockDirection &gt; top || (!blocksAreFlipped &amp;&amp; pointBlockDirection == top)) {
413             LayoutUnit bottom = rootBox.selectionBottom();
414             if (rootBox.nextRootBox())
415                 bottom = std::min(bottom, rootBox.nextRootBox()-&gt;lineTop());
416 
417             if (pointBlockDirection &lt; bottom || (blocksAreFlipped &amp;&amp; pointBlockDirection == bottom)) {
418                 ShouldAffinityBeDownstream shouldAffinityBeDownstream;
419 #if PLATFORM(IOS_FAMILY)
420                 if (pointLineDirection != box-&gt;logicalLeft() &amp;&amp; point.x() &lt; box-&gt;x() + box-&gt;logicalWidth()) {
421                     int half = box-&gt;x() + box-&gt;logicalWidth() / 2;
422                     EAffinity affinity = point.x() &lt; half ? DOWNSTREAM : VP_UPSTREAM_IF_POSSIBLE;
423                     return renderer.createVisiblePosition(box-&gt;offsetForPosition(pointLineDirection) + box-&gt;start(), affinity);
424                 }
425 #endif
426                 if (lineDirectionPointFitsInBox(pointLineDirection, *box, shouldAffinityBeDownstream))
427                     return createVisiblePositionAfterAdjustingOffsetForBiDi(*box, box-&gt;offsetForPosition(pointLineDirection), shouldAffinityBeDownstream);
428             }
429         }
430         lastBox = box;
431     }
432 
433     if (lastBox) {
434         ShouldAffinityBeDownstream shouldAffinityBeDownstream;
435         lineDirectionPointFitsInBox(pointLineDirection, *lastBox, shouldAffinityBeDownstream);
436         return createVisiblePositionAfterAdjustingOffsetForBiDi(*lastBox, lastBox-&gt;offsetForPosition(pointLineDirection) + lastBox-&gt;start(), shouldAffinityBeDownstream);
437     }
438     return renderer.createVisiblePosition(0, DOWNSTREAM);
439 }
440 
441 void RenderTextLineBoxes::setSelectionState(RenderText&amp; renderer, RenderObject::SelectionState state)
442 {
443     if (state == RenderObject::SelectionInside || state == RenderObject::SelectionNone) {
444         for (auto* box = m_first; box; box = box-&gt;nextTextBox())
445             box-&gt;root().setHasSelectedChildren(state == RenderObject::SelectionInside);
446         return;
447     }
448 
<a name="13" id="anc13"></a><span class="line-modified">449     auto start = renderer.view().selection().startPosition();</span>
<span class="line-modified">450     auto end = renderer.view().selection().endPosition();</span>
451     if (state == RenderObject::SelectionStart) {
452         end = renderer.text().length();
453         // to handle selection from end of text to end of line
454         if (start &amp;&amp; start == end)
455             start = end - 1;
456     } else if (state == RenderObject::SelectionEnd)
457         start = 0;
458 
459     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
460         if (box-&gt;isSelected(start, end))
461             box-&gt;root().setHasSelectedChildren(true);
462     }
463 }
464 
465 static IntRect ellipsisRectForBox(const InlineTextBox&amp; box, unsigned start, unsigned end)
466 {
467     unsigned short truncation = box.truncation();
468     if (truncation == cNoTruncation)
469         return IntRect();
470 
471     auto ellipsis = box.root().ellipsisBox();
472     if (!ellipsis)
473         return IntRect();
474 
475     IntRect rect;
476     int ellipsisStartPosition = std::max&lt;int&gt;(start - box.start(), 0);
477     int ellipsisEndPosition = std::min&lt;int&gt;(end - box.start(), box.len());
478 
479     // The ellipsis should be considered to be selected if the end of
480     // the selection is past the beginning of the truncation and the
481     // beginning of the selection is before or at the beginning of the truncation.
482     if (ellipsisEndPosition &lt; truncation &amp;&amp; ellipsisStartPosition &gt; truncation)
483         return IntRect();
484     return ellipsis-&gt;selectionRect();
485 }
486 
487 LayoutRect RenderTextLineBoxes::selectionRectForRange(unsigned start, unsigned end)
488 {
489     LayoutRect rect;
490     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
491         rect.unite(box-&gt;localSelectionRect(start, end));
492         rect.unite(ellipsisRectForBox(*box, start, end));
493     }
494     return rect;
495 }
496 
497 void RenderTextLineBoxes::collectSelectionRectsForRange(unsigned start, unsigned end, Vector&lt;LayoutRect&gt;&amp; rects)
498 {
499     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
500         LayoutRect rect;
501         rect.unite(box-&gt;localSelectionRect(start, end));
502         rect.unite(ellipsisRectForBox(*box, start, end));
503         if (!rect.size().isEmpty())
504             rects.append(rect);
505     }
506 }
507 
<a name="14" id="anc14"></a><span class="line-removed">508 Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRects(const LayoutPoint&amp; accumulatedOffset) const</span>
<span class="line-removed">509 {</span>
<span class="line-removed">510     Vector&lt;IntRect&gt; rects;</span>
<span class="line-removed">511     for (auto* box = m_first; box; box = box-&gt;nextTextBox())</span>
<span class="line-removed">512         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + box-&gt;topLeft(), box-&gt;size())));</span>
<span class="line-removed">513     return rects;</span>
<span class="line-removed">514 }</span>
<span class="line-removed">515 </span>
516 static FloatRect localQuadForTextBox(const InlineTextBox&amp; box, unsigned start, unsigned end, bool useSelectionHeight)
517 {
<a name="15" id="anc15"></a><span class="line-modified">518     unsigned realEnd = std::min(box.end() + 1, end);</span>
519     LayoutRect boxSelectionRect = box.localSelectionRect(start, realEnd);
520     if (!boxSelectionRect.height())
521         return FloatRect();
522     if (useSelectionHeight)
523         return boxSelectionRect;
524     // Change the height and y position (or width and x for vertical text)
525     // because selectionRect uses selection-specific values.
526     if (box.isHorizontal()) {
527         boxSelectionRect.setHeight(box.height());
528         boxSelectionRect.setY(box.y());
529     } else {
530         boxSelectionRect.setWidth(box.width());
531         boxSelectionRect.setX(box.x());
532     }
533     return boxSelectionRect;
534 }
535 
<a name="16" id="anc16"></a><span class="line-modified">536 Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRectsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
537 {
<a name="17" id="anc17"></a><span class="line-modified">538     Vector&lt;IntRect&gt; rects;</span>
539     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<a name="18" id="anc18"></a><span class="line-modified">540         // Note: box-&gt;end() returns the index of the last character, not the index past it</span>
<span class="line-modified">541         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end) {</span>

542             FloatRect boundaries = box-&gt;calculateBoundaries();
543             if (useSelectionHeight) {
544                 LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);
545                 if (box-&gt;isHorizontal()) {
546                     boundaries.setHeight(selectionRect.height());
547                     boundaries.setY(selectionRect.y());
548                 } else {
549                     boundaries.setWidth(selectionRect.width());
550                     boundaries.setX(selectionRect.x());
551                 }
552             }
<a name="19" id="anc19"></a><span class="line-modified">553             rects.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed).enclosingBoundingBox());</span>
554             continue;
555         }
556         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
557         if (!rect.isZero())
<a name="20" id="anc20"></a><span class="line-modified">558             rects.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed).enclosingBoundingBox());</span>
559     }
<a name="21" id="anc21"></a><span class="line-modified">560     return rects;</span>





561 }
562 
563 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuads(const RenderText&amp; renderer, bool* wasFixed, ClippingOption option) const
564 {
565     Vector&lt;FloatQuad&gt; quads;
566     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
567         FloatRect boundaries = box-&gt;calculateBoundaries();
568 
569         // Shorten the width of this text box if it ends in an ellipsis.
570         // FIXME: ellipsisRectForBox should switch to return FloatRect soon with the subpixellayout branch.
571         IntRect ellipsisRect = (option == ClipToEllipsis) ? ellipsisRectForBox(*box, 0, renderer.text().length()) : IntRect();
572         if (!ellipsisRect.isEmpty()) {
573             if (renderer.style().isHorizontalWritingMode())
574                 boundaries.setWidth(ellipsisRect.maxX() - boundaries.x());
575             else
576                 boundaries.setHeight(ellipsisRect.maxY() - boundaries.y());
577         }
578         quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
579     }
580     return quads;
581 }
582 
<a name="22" id="anc22"></a><span class="line-removed">583 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuadsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
<span class="line-removed">584 {</span>
<span class="line-removed">585     Vector&lt;FloatQuad&gt; quads;</span>
<span class="line-removed">586     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">587         // Note: box-&gt;end() returns the index of the last character, not the index past it</span>
<span class="line-removed">588         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end) {</span>
<span class="line-removed">589             FloatRect boundaries = box-&gt;calculateBoundaries();</span>
<span class="line-removed">590             if (useSelectionHeight) {</span>
<span class="line-removed">591                 LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);</span>
<span class="line-removed">592                 if (box-&gt;isHorizontal()) {</span>
<span class="line-removed">593                     boundaries.setHeight(selectionRect.height());</span>
<span class="line-removed">594                     boundaries.setY(selectionRect.y());</span>
<span class="line-removed">595                 } else {</span>
<span class="line-removed">596                     boundaries.setWidth(selectionRect.width());</span>
<span class="line-removed">597                     boundaries.setX(selectionRect.x());</span>
<span class="line-removed">598                 }</span>
<span class="line-removed">599             }</span>
<span class="line-removed">600             quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));</span>
<span class="line-removed">601             continue;</span>
<span class="line-removed">602         }</span>
<span class="line-removed">603         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);</span>
<span class="line-removed">604         if (!rect.isZero())</span>
<span class="line-removed">605             quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));</span>
<span class="line-removed">606     }</span>
<span class="line-removed">607     return quads;</span>
<span class="line-removed">608 }</span>
<span class="line-removed">609 </span>
610 void RenderTextLineBoxes::dirtyAll()
611 {
612     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
613         box-&gt;dirtyLineBoxes();
614 }
615 
616 bool RenderTextLineBoxes::dirtyRange(RenderText&amp; renderer, unsigned start, unsigned end, int lengthDelta)
617 {
618     RootInlineBox* firstRootBox = nullptr;
619     RootInlineBox* lastRootBox = nullptr;
620 
621     // Dirty all text boxes that include characters in between offset and offset+len.
622     bool dirtiedLines = false;
623     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
624         // FIXME: This shouldn&#39;t rely on the end of a dirty line box. See https://bugs.webkit.org/show_bug.cgi?id=97264
625         // Text run is entirely before the affected range.
<a name="23" id="anc23"></a><span class="line-modified">626         if (current-&gt;end() &lt; start)</span>
627             continue;
628         // Text run is entirely after the affected range.
<a name="24" id="anc24"></a><span class="line-modified">629         if (current-&gt;start() &gt; end) {</span>
630             current-&gt;offsetRun(lengthDelta);
631             auto&amp; rootBox = current-&gt;root();
632             if (!firstRootBox) {
633                 firstRootBox = &amp;rootBox;
634                 if (!dirtiedLines) {
635                     // The affected area was in between two runs. Mark the root box of the run after the affected area as dirty.
636                     firstRootBox-&gt;markDirty();
637                     dirtiedLines = true;
638                 }
639             }
640             lastRootBox = &amp;rootBox;
641             continue;
642         }
<a name="25" id="anc25"></a><span class="line-modified">643         if (current-&gt;end() &gt;= start &amp;&amp; current-&gt;end() &lt;= end) {</span>
644             // Text run overlaps with the left end of the affected range.
645             current-&gt;dirtyLineBoxes();
646             dirtiedLines = true;
647             continue;
648         }
649         if (current-&gt;start() &lt;= start &amp;&amp; current-&gt;end() &gt;= end) {
650             // Text run subsumes the affected range.
651             current-&gt;dirtyLineBoxes();
652             dirtiedLines = true;
653             continue;
654         }
<a name="26" id="anc26"></a><span class="line-modified">655         if (current-&gt;start() &lt;= end &amp;&amp; current-&gt;end() &gt;= end) {</span>
656             // Text run overlaps with right end of the affected range.
657             current-&gt;dirtyLineBoxes();
658             dirtiedLines = true;
659             continue;
660         }
661     }
662 
663     // Now we have to walk all of the clean lines and adjust their cached line break information
664     // to reflect our updated offsets.
665     if (lastRootBox)
666         lastRootBox = lastRootBox-&gt;nextRootBox();
667     if (firstRootBox) {
668         auto previousRootBox = firstRootBox-&gt;prevRootBox();
669         if (previousRootBox)
670             firstRootBox = previousRootBox;
671     } else if (m_last) {
672         ASSERT(!lastRootBox);
673         firstRootBox = &amp;m_last-&gt;root();
674         firstRootBox-&gt;markDirty();
675         dirtiedLines = true;
676     }
677     for (auto* current = firstRootBox; current &amp;&amp; current != lastRootBox; current = current-&gt;nextRootBox()) {
678         if (current-&gt;lineBreakObj() == &amp;renderer &amp;&amp; current-&gt;lineBreakPos() &gt; end)
679             current-&gt;setLineBreakPos(current-&gt;lineBreakPos() + lengthDelta);
680     }
681 
682     // If the text node is empty, dirty the line where new text will be inserted.
683     if (!m_first &amp;&amp; renderer.parent()) {
684         renderer.parent()-&gt;dirtyLinesFromChangedChild(renderer);
685         dirtiedLines = true;
686     }
687     return dirtiedLines;
688 }
689 
690 inline void RenderTextLineBoxes::checkConsistency() const
691 {
<a name="27" id="anc27"></a><span class="line-modified">692 #if !ASSERT_DISABLED</span>
693 #ifdef CHECK_CONSISTENCY
694     const InlineTextBox* prev = nullptr;
695     for (auto* child = m_first; child; child = child-&gt;nextTextBox()) {
696         ASSERT(child-&gt;renderer() == this);
697         ASSERT(child-&gt;prevTextBox() == prev);
698         prev = child;
699     }
700     ASSERT(prev == m_last);
701 #endif
<a name="28" id="anc28"></a><span class="line-modified">702 #endif</span>
703 }
704 
<a name="29" id="anc29"></a><span class="line-modified">705 #if !ASSERT_DISABLED</span>
706 RenderTextLineBoxes::~RenderTextLineBoxes()
707 {
708     ASSERT(!m_first);
709     ASSERT(!m_last);
710 }
711 #endif
712 
713 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
714 void RenderTextLineBoxes::invalidateParentChildLists()
715 {
716     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
717         box-&gt;invalidateParentChildList();
718 }
719 #endif
720 
721 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JIT.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JIT.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITAddGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JIT.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 66,22 ***</span>
      struct Instruction;
      struct OperandTypes;
      struct SimpleJumpTable;
      struct StringJumpTable;
  
      struct CallRecord {
          MacroAssembler::Call from;
<span class="line-modified">!         unsigned bytecodeOffset;</span>
          FunctionPtr&lt;OperationPtrTag&gt; callee;
  
          CallRecord()
          {
          }
  
<span class="line-modified">!         CallRecord(MacroAssembler::Call from, unsigned bytecodeOffset, FunctionPtr&lt;OperationPtrTag&gt; callee)</span>
              : from(from)
<span class="line-modified">!             , bytecodeOffset(bytecodeOffset)</span>
              , callee(callee)
          {
          }
      };
  
<span class="line-new-header">--- 66,26 ---</span>
      struct Instruction;
      struct OperandTypes;
      struct SimpleJumpTable;
      struct StringJumpTable;
  
<span class="line-added">+     struct OpPutByVal;</span>
<span class="line-added">+     struct OpPutByValDirect;</span>
<span class="line-added">+     struct OpPutToScope;</span>
<span class="line-added">+ </span>
      struct CallRecord {
          MacroAssembler::Call from;
<span class="line-modified">!         BytecodeIndex bytecodeIndex;</span>
          FunctionPtr&lt;OperationPtrTag&gt; callee;
  
          CallRecord()
          {
          }
  
<span class="line-modified">!         CallRecord(MacroAssembler::Call from, BytecodeIndex bytecodeIndex, FunctionPtr&lt;OperationPtrTag&gt; callee)</span>
              : from(from)
<span class="line-modified">!             , bytecodeIndex(bytecodeIndex)</span>
              , callee(callee)
          {
          }
      };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,13 ***</span>
          }
      };
  
      struct SlowCaseEntry {
          MacroAssembler::Jump from;
<span class="line-modified">!         unsigned to;</span>
  
<span class="line-modified">!         SlowCaseEntry(MacroAssembler::Jump f, unsigned t)</span>
              : from(f)
              , to(t)
          {
          }
      };
<span class="line-new-header">--- 100,13 ---</span>
          }
      };
  
      struct SlowCaseEntry {
          MacroAssembler::Jump from;
<span class="line-modified">!         BytecodeIndex to;</span>
  
<span class="line-modified">!         SlowCaseEntry(MacroAssembler::Jump f, BytecodeIndex t)</span>
              : from(f)
              , to(t)
          {
          }
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,34 ***</span>
          union {
              SimpleJumpTable* simpleJumpTable;
              StringJumpTable* stringJumpTable;
          } jumpTable;
  
<span class="line-modified">!         unsigned bytecodeOffset;</span>
          unsigned defaultOffset;
  
<span class="line-modified">!         SwitchRecord(SimpleJumpTable* jumpTable, unsigned bytecodeOffset, unsigned defaultOffset, Type type)</span>
              : type(type)
<span class="line-modified">!             , bytecodeOffset(bytecodeOffset)</span>
              , defaultOffset(defaultOffset)
          {
              this-&gt;jumpTable.simpleJumpTable = jumpTable;
          }
  
<span class="line-modified">!         SwitchRecord(StringJumpTable* jumpTable, unsigned bytecodeOffset, unsigned defaultOffset)</span>
              : type(String)
<span class="line-modified">!             , bytecodeOffset(bytecodeOffset)</span>
              , defaultOffset(defaultOffset)
          {
              this-&gt;jumpTable.stringJumpTable = jumpTable;
          }
      };
  
      struct ByValCompilationInfo {
          ByValCompilationInfo() { }
  
<span class="line-modified">!         ByValCompilationInfo(ByValInfo* byValInfo, unsigned bytecodeIndex, MacroAssembler::PatchableJump notIndexJump, MacroAssembler::PatchableJump badTypeJump, JITArrayMode arrayMode, ArrayProfile* arrayProfile, MacroAssembler::Label doneTarget, MacroAssembler::Label nextHotPathTarget)</span>
              : byValInfo(byValInfo)
              , bytecodeIndex(bytecodeIndex)
              , notIndexJump(notIndexJump)
              , badTypeJump(badTypeJump)
              , arrayMode(arrayMode)
<span class="line-new-header">--- 123,34 ---</span>
          union {
              SimpleJumpTable* simpleJumpTable;
              StringJumpTable* stringJumpTable;
          } jumpTable;
  
<span class="line-modified">!         BytecodeIndex bytecodeIndex;</span>
          unsigned defaultOffset;
  
<span class="line-modified">!         SwitchRecord(SimpleJumpTable* jumpTable, BytecodeIndex bytecodeIndex, unsigned defaultOffset, Type type)</span>
              : type(type)
<span class="line-modified">!             , bytecodeIndex(bytecodeIndex)</span>
              , defaultOffset(defaultOffset)
          {
              this-&gt;jumpTable.simpleJumpTable = jumpTable;
          }
  
<span class="line-modified">!         SwitchRecord(StringJumpTable* jumpTable, BytecodeIndex bytecodeIndex, unsigned defaultOffset)</span>
              : type(String)
<span class="line-modified">!             , bytecodeIndex(bytecodeIndex)</span>
              , defaultOffset(defaultOffset)
          {
              this-&gt;jumpTable.stringJumpTable = jumpTable;
          }
      };
  
      struct ByValCompilationInfo {
          ByValCompilationInfo() { }
  
<span class="line-modified">!         ByValCompilationInfo(ByValInfo* byValInfo, BytecodeIndex bytecodeIndex, MacroAssembler::PatchableJump notIndexJump, MacroAssembler::PatchableJump badTypeJump, JITArrayMode arrayMode, ArrayProfile* arrayProfile, MacroAssembler::Label doneTarget, MacroAssembler::Label nextHotPathTarget)</span>
              : byValInfo(byValInfo)
              , bytecodeIndex(bytecodeIndex)
              , notIndexJump(notIndexJump)
              , badTypeJump(badTypeJump)
              , arrayMode(arrayMode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,11 ***</span>
              , nextHotPathTarget(nextHotPathTarget)
          {
          }
  
          ByValInfo* byValInfo;
<span class="line-modified">!         unsigned bytecodeIndex;</span>
          MacroAssembler::PatchableJump notIndexJump;
          MacroAssembler::PatchableJump badTypeJump;
          JITArrayMode arrayMode;
          ArrayProfile* arrayProfile;
          MacroAssembler::Label doneTarget;
<span class="line-new-header">--- 159,11 ---</span>
              , nextHotPathTarget(nextHotPathTarget)
          {
          }
  
          ByValInfo* byValInfo;
<span class="line-modified">!         BytecodeIndex bytecodeIndex;</span>
          MacroAssembler::PatchableJump notIndexJump;
          MacroAssembler::PatchableJump badTypeJump;
          JITArrayMode arrayMode;
          ArrayProfile* arrayProfile;
          MacroAssembler::Label doneTarget;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,72 ***</span>
  
          using MacroAssembler::Jump;
          using MacroAssembler::JumpList;
          using MacroAssembler::Label;
  
<span class="line-modified">!         static const uintptr_t patchGetByIdDefaultStructure = unusedPointer;</span>
<span class="line-modified">!         static const int patchGetByIdDefaultOffset = 0;</span>
          // Magic number - initial offset cannot be representable as a signed 8bit value, or the X86Assembler
          // will compress the displacement, and we may not be able to fit a patched offset.
<span class="line-modified">!         static const int patchPutByIdDefaultOffset = 256;</span>
  
      public:
<span class="line-modified">!         JIT(VM&amp;, CodeBlock* = 0, unsigned loopOSREntryBytecodeOffset = 0);</span>
          ~JIT();
  
          VM&amp; vm() { return *JSInterfaceJIT::vm(); }
  
          void compileWithoutLinking(JITCompilationEffort);
          CompilationResult link();
  
          void doMainThreadPreparationBeforeCompile();
  
<span class="line-modified">!         static CompilationResult compile(VM&amp; vm, CodeBlock* codeBlock, JITCompilationEffort effort, unsigned bytecodeOffset = 0)</span>
          {
              return JIT(vm, codeBlock, bytecodeOffset).privateCompile(effort);
          }
  
<span class="line-removed">-         static void compileGetByVal(const ConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             JIT jit(vm, codeBlock);</span>
<span class="line-removed">-             jit.m_bytecodeOffset = byValInfo-&gt;bytecodeIndex;</span>
<span class="line-removed">-             jit.privateCompileGetByVal(locker, byValInfo, returnAddress, arrayMode);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static void compileGetByValWithCachedId(VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, const Identifier&amp; propertyName)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             JIT jit(vm, codeBlock);</span>
<span class="line-removed">-             jit.m_bytecodeOffset = byValInfo-&gt;bytecodeIndex;</span>
<span class="line-removed">-             jit.privateCompileGetByValWithCachedId(byValInfo, returnAddress, propertyName);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          static void compilePutByVal(const ConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeOffset = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompilePutByVal&lt;OpPutByVal&gt;(locker, byValInfo, returnAddress, arrayMode);
          }
  
          static void compileDirectPutByVal(const ConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeOffset = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompilePutByVal&lt;OpPutByValDirect&gt;(locker, byValInfo, returnAddress, arrayMode);
          }
  
          template&lt;typename Op&gt;
          static void compilePutByValWithCachedId(VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, PutKind putKind, const Identifier&amp; propertyName)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeOffset = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompilePutByValWithCachedId&lt;Op&gt;(byValInfo, returnAddress, putKind, propertyName);
          }
  
          static void compileHasIndexedProperty(VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeOffset = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompileHasIndexedProperty(byValInfo, returnAddress, arrayMode);
          }
  
          static unsigned frameRegisterCountFor(CodeBlock*);
          static int stackPointerOffsetFor(CodeBlock*);
<span class="line-new-header">--- 187,58 ---</span>
  
          using MacroAssembler::Jump;
          using MacroAssembler::JumpList;
          using MacroAssembler::Label;
  
<span class="line-modified">!         static constexpr uintptr_t patchGetByIdDefaultStructure = unusedPointer;</span>
<span class="line-modified">!         static constexpr int patchGetByIdDefaultOffset = 0;</span>
          // Magic number - initial offset cannot be representable as a signed 8bit value, or the X86Assembler
          // will compress the displacement, and we may not be able to fit a patched offset.
<span class="line-modified">!         static constexpr int patchPutByIdDefaultOffset = 256;</span>
  
      public:
<span class="line-modified">!         JIT(VM&amp;, CodeBlock* = nullptr, BytecodeIndex loopOSREntryBytecodeOffset = BytecodeIndex(0));</span>
          ~JIT();
  
          VM&amp; vm() { return *JSInterfaceJIT::vm(); }
  
          void compileWithoutLinking(JITCompilationEffort);
          CompilationResult link();
  
          void doMainThreadPreparationBeforeCompile();
  
<span class="line-modified">!         static CompilationResult compile(VM&amp; vm, CodeBlock* codeBlock, JITCompilationEffort effort, BytecodeIndex bytecodeOffset = BytecodeIndex(0))</span>
          {
              return JIT(vm, codeBlock, bytecodeOffset).privateCompile(effort);
          }
  
          static void compilePutByVal(const ConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeIndex = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompilePutByVal&lt;OpPutByVal&gt;(locker, byValInfo, returnAddress, arrayMode);
          }
  
          static void compileDirectPutByVal(const ConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeIndex = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompilePutByVal&lt;OpPutByValDirect&gt;(locker, byValInfo, returnAddress, arrayMode);
          }
  
          template&lt;typename Op&gt;
          static void compilePutByValWithCachedId(VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, PutKind putKind, const Identifier&amp; propertyName)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeIndex = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompilePutByValWithCachedId&lt;Op&gt;(byValInfo, returnAddress, putKind, propertyName);
          }
  
          static void compileHasIndexedProperty(VM&amp; vm, CodeBlock* codeBlock, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)
          {
              JIT jit(vm, codeBlock);
<span class="line-modified">!             jit.m_bytecodeIndex = byValInfo-&gt;bytecodeIndex;</span>
              jit.privateCompileHasIndexedProperty(byValInfo, returnAddress, arrayMode);
          }
  
          static unsigned frameRegisterCountFor(CodeBlock*);
          static int stackPointerOffsetFor(CodeBlock*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,19 ***</span>
  
          // Add a call out from JIT code, without an exception check.
          Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
          {
              Call functionCall = call(OperationPtrTag);
<span class="line-modified">!             m_calls.append(CallRecord(functionCall, m_bytecodeOffset, function.retagged&lt;OperationPtrTag&gt;()));</span>
              return functionCall;
          }
  
  #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
          Call appendCallWithSlowPathReturnType(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
          {
              Call functionCall = callWithSlowPathReturnType(OperationPtrTag);
<span class="line-modified">!             m_calls.append(CallRecord(functionCall, m_bytecodeOffset, function.retagged&lt;OperationPtrTag&gt;()));</span>
              return functionCall;
          }
  #endif
  
          void exceptionCheck(Jump jumpToHandler)
<span class="line-new-header">--- 265,19 ---</span>
  
          // Add a call out from JIT code, without an exception check.
          Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
          {
              Call functionCall = call(OperationPtrTag);
<span class="line-modified">!             m_calls.append(CallRecord(functionCall, m_bytecodeIndex, function.retagged&lt;OperationPtrTag&gt;()));</span>
              return functionCall;
          }
  
  #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
          Call appendCallWithSlowPathReturnType(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
          {
              Call functionCall = callWithSlowPathReturnType(OperationPtrTag);
<span class="line-modified">!             m_calls.append(CallRecord(functionCall, m_bytecodeIndex, function.retagged&lt;OperationPtrTag&gt;()));</span>
              return functionCall;
          }
  #endif
  
          void exceptionCheck(Jump jumpToHandler)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,20 ***</span>
          void compileOpStrictEq(const Instruction*, CompileOpStrictEqType);
          template&lt;typename Op&gt;
          void compileOpStrictEqJump(const Instruction*, CompileOpStrictEqType);
          enum class CompileOpEqType { Eq, NEq };
          void compileOpEqJumpSlow(Vector&lt;SlowCaseEntry&gt;::iterator&amp;, CompileOpEqType, int jumpTarget);
<span class="line-modified">!         bool isOperandConstantDouble(int src);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         void emitLoadDouble(int index, FPRegisterID value);</span>
<span class="line-removed">-         void emitLoadInt32ToDouble(int index, FPRegisterID value);</span>
  
          enum WriteBarrierMode { UnconditionalWriteBarrier, ShouldFilterBase, ShouldFilterValue, ShouldFilterBaseAndValue };
          // value register in write barrier is used before any scratch registers
          // so may safely be the same as either of the scratch registers.
<span class="line-modified">!         void emitWriteBarrier(unsigned owner, unsigned value, WriteBarrierMode);</span>
<span class="line-modified">!         void emitWriteBarrier(JSCell* owner, unsigned value, WriteBarrierMode);</span>
          void emitWriteBarrier(JSCell* owner);
  
          // This assumes that the value to profile is in regT0 and that regT3 is available for
          // scratch.
          void emitValueProfilingSite(ValueProfile&amp;);
<span class="line-new-header">--- 333,17 ---</span>
          void compileOpStrictEq(const Instruction*, CompileOpStrictEqType);
          template&lt;typename Op&gt;
          void compileOpStrictEqJump(const Instruction*, CompileOpStrictEqType);
          enum class CompileOpEqType { Eq, NEq };
          void compileOpEqJumpSlow(Vector&lt;SlowCaseEntry&gt;::iterator&amp;, CompileOpEqType, int jumpTarget);
<span class="line-modified">!         bool isOperandConstantDouble(VirtualRegister);</span>
  
          enum WriteBarrierMode { UnconditionalWriteBarrier, ShouldFilterBase, ShouldFilterValue, ShouldFilterBaseAndValue };
          // value register in write barrier is used before any scratch registers
          // so may safely be the same as either of the scratch registers.
<span class="line-modified">!         void emitWriteBarrier(VirtualRegister owner, VirtualRegister value, WriteBarrierMode);</span>
<span class="line-modified">!         void emitWriteBarrier(JSCell* owner, VirtualRegister value, WriteBarrierMode);</span>
          void emitWriteBarrier(JSCell* owner);
  
          // This assumes that the value to profile is in regT0 and that regT3 is available for
          // scratch.
          void emitValueProfilingSite(ValueProfile&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,19 ***</span>
          JumpList emitDoubleLoad(const Instruction*, PatchableJump&amp; badType);
          JumpList emitContiguousLoad(const Instruction*, PatchableJump&amp; badType, IndexingType expectedShape = ContiguousShape);
          JumpList emitArrayStorageLoad(const Instruction*, PatchableJump&amp; badType);
          JumpList emitLoadForArrayMode(const Instruction*, JITArrayMode, PatchableJump&amp; badType);
  
<span class="line-removed">-         JumpList emitInt32GetByVal(const Instruction* instruction, PatchableJump&amp; badType) { return emitContiguousGetByVal(instruction, badType, Int32Shape); }</span>
<span class="line-removed">-         JumpList emitDoubleGetByVal(const Instruction*, PatchableJump&amp; badType);</span>
<span class="line-removed">-         JumpList emitContiguousGetByVal(const Instruction*, PatchableJump&amp; badType, IndexingType expectedShape = ContiguousShape);</span>
<span class="line-removed">-         JumpList emitArrayStorageGetByVal(const Instruction*, PatchableJump&amp; badType);</span>
<span class="line-removed">-         JumpList emitDirectArgumentsGetByVal(const Instruction*, PatchableJump&amp; badType);</span>
<span class="line-removed">-         JumpList emitScopedArgumentsGetByVal(const Instruction*, PatchableJump&amp; badType);</span>
<span class="line-removed">-         JumpList emitIntTypedArrayGetByVal(const Instruction*, PatchableJump&amp; badType, TypedArrayType);</span>
<span class="line-removed">-         JumpList emitFloatTypedArrayGetByVal(const Instruction*, PatchableJump&amp; badType, TypedArrayType);</span>
<span class="line-removed">- </span>
          // Property is in regT1, base is in regT0. regT2 contains indecing type.
          // The value to store is not yet loaded. Property is int-checked and
          // zero-extended. Base is cell checked. Structure is already profiled.
          // returns the slow cases.
          template&lt;typename Op&gt;
<span class="line-new-header">--- 367,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,87 ***</span>
          JumpList emitFloatTypedArrayPutByVal(Op, PatchableJump&amp; badType, TypedArrayType);
  
          // Identifier check helper for GetByVal and PutByVal.
          void emitByValIdentifierCheck(ByValInfo*, RegisterID cell, RegisterID scratch, const Identifier&amp;, JumpList&amp; slowCases);
  
<span class="line-removed">-         JITGetByIdGenerator emitGetByValWithCachedId(ByValInfo*, OpGetByVal, const Identifier&amp;, Jump&amp; fastDoneCase, Jump&amp; slowDoneCase, JumpList&amp; slowCases);</span>
          template&lt;typename Op&gt;
          JITPutByIdGenerator emitPutByValWithCachedId(ByValInfo*, Op, PutKind, const Identifier&amp;, JumpList&amp; doneCases, JumpList&amp; slowCases);
  
          enum FinalObjectMode { MayBeFinal, KnownNotFinal };
  
<span class="line-modified">!         void emitGetVirtualRegister(int src, JSValueRegs dst);</span>
<span class="line-modified">!         void emitPutVirtualRegister(int dst, JSValueRegs src);</span>
  
<span class="line-modified">!         int32_t getOperandConstantInt(int src);</span>
<span class="line-modified">!         double getOperandConstantDouble(int src);</span>
  
  #if USE(JSVALUE32_64)
<span class="line-modified">!         bool getOperandConstantInt(int op1, int op2, int&amp; op, int32_t&amp; constant);</span>
  
<span class="line-modified">!         void emitLoadTag(int index, RegisterID tag);</span>
<span class="line-modified">!         void emitLoadPayload(int index, RegisterID payload);</span>
  
          void emitLoad(const JSValue&amp; v, RegisterID tag, RegisterID payload);
<span class="line-modified">!         void emitLoad(int index, RegisterID tag, RegisterID payload, RegisterID base = callFrameRegister);</span>
<span class="line-modified">!         void emitLoad2(int index1, RegisterID tag1, RegisterID payload1, int index2, RegisterID tag2, RegisterID payload2);</span>
  
<span class="line-modified">!         void emitStore(int index, RegisterID tag, RegisterID payload, RegisterID base = callFrameRegister);</span>
<span class="line-modified">!         void emitStore(int index, const JSValue constant, RegisterID base = callFrameRegister);</span>
<span class="line-modified">!         void emitStoreInt32(int index, RegisterID payload, bool indexIsInt32 = false);</span>
<span class="line-modified">!         void emitStoreInt32(int index, TrustedImm32 payload, bool indexIsInt32 = false);</span>
<span class="line-modified">!         void emitStoreCell(int index, RegisterID payload, bool indexIsCell = false);</span>
<span class="line-modified">!         void emitStoreBool(int index, RegisterID payload, bool indexIsBool = false);</span>
<span class="line-modified">!         void emitStoreDouble(int index, FPRegisterID value);</span>
  
<span class="line-modified">!         void emitJumpSlowCaseIfNotJSCell(int virtualRegisterIndex);</span>
<span class="line-modified">!         void emitJumpSlowCaseIfNotJSCell(int virtualRegisterIndex, RegisterID tag);</span>
  
          void compileGetByIdHotPath(const Identifier*);
  
          // Arithmetic opcode helpers
          template &lt;typename Op&gt;
          void emitBinaryDoubleOp(const Instruction *, OperandTypes, JumpList&amp; notInt32Op1, JumpList&amp; notInt32Op2, bool op1IsInRegisters = true, bool op2IsInRegisters = true);
  
  #else // USE(JSVALUE32_64)
<span class="line-removed">-         void emitGetVirtualRegister(int src, RegisterID dst);</span>
          void emitGetVirtualRegister(VirtualRegister src, RegisterID dst);
<span class="line-removed">-         void emitGetVirtualRegisters(int src1, RegisterID dst1, int src2, RegisterID dst2);</span>
          void emitGetVirtualRegisters(VirtualRegister src1, RegisterID dst1, VirtualRegister src2, RegisterID dst2);
<span class="line-removed">-         void emitPutVirtualRegister(int dst, RegisterID from = regT0);</span>
          void emitPutVirtualRegister(VirtualRegister dst, RegisterID from = regT0);
<span class="line-modified">!         void emitStoreCell(int dst, RegisterID payload, bool /* only used in JSValue32_64 */ = false)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             emitPutVirtualRegister(dst, payload);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         void emitStoreCell(VirtualRegister dst, RegisterID payload)</span>
          {
              emitPutVirtualRegister(dst, payload);
          }
  
          Jump emitJumpIfBothJSCells(RegisterID, RegisterID, RegisterID);
          void emitJumpSlowCaseIfJSCell(RegisterID);
          void emitJumpSlowCaseIfNotJSCell(RegisterID);
<span class="line-modified">!         void emitJumpSlowCaseIfNotJSCell(RegisterID, int VReg);</span>
          Jump emitJumpIfNotInt(RegisterID, RegisterID, RegisterID scratch);
          PatchableJump emitPatchableJumpIfNotInt(RegisterID);
          void emitJumpSlowCaseIfNotInt(RegisterID);
          void emitJumpSlowCaseIfNotNumber(RegisterID);
          void emitJumpSlowCaseIfNotInt(RegisterID, RegisterID, RegisterID scratch);
  
<span class="line-modified">!         void compileGetByIdHotPath(int baseVReg, const Identifier*);</span>
  
  #endif // USE(JSVALUE32_64)
  
          template&lt;typename Op&gt;
          void emit_compareAndJump(const Instruction*, RelationalCondition);
          template&lt;typename Op&gt;
          void emit_compareUnsigned(const Instruction*, RelationalCondition);
          template&lt;typename Op&gt;
          void emit_compareUnsignedAndJump(const Instruction*, RelationalCondition);
          template&lt;typename Op&gt;
<span class="line-modified">!         void emit_compareAndJumpSlow(const Instruction*, DoubleCondition, size_t (JIT_OPERATION *operation)(ExecState*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);</span>
  
          void assertStackPointerOffset();
  
          void emit_op_add(const Instruction*);
          void emit_op_bitand(const Instruction*);
<span class="line-new-header">--- 398,84 ---</span>
          JumpList emitFloatTypedArrayPutByVal(Op, PatchableJump&amp; badType, TypedArrayType);
  
          // Identifier check helper for GetByVal and PutByVal.
          void emitByValIdentifierCheck(ByValInfo*, RegisterID cell, RegisterID scratch, const Identifier&amp;, JumpList&amp; slowCases);
  
          template&lt;typename Op&gt;
          JITPutByIdGenerator emitPutByValWithCachedId(ByValInfo*, Op, PutKind, const Identifier&amp;, JumpList&amp; doneCases, JumpList&amp; slowCases);
  
          enum FinalObjectMode { MayBeFinal, KnownNotFinal };
  
<span class="line-modified">!         void emitGetVirtualRegister(VirtualRegister src, JSValueRegs dst);</span>
<span class="line-modified">!         void emitPutVirtualRegister(VirtualRegister dst, JSValueRegs src);</span>
  
<span class="line-modified">!         int32_t getOperandConstantInt(VirtualRegister src);</span>
<span class="line-modified">!         double getOperandConstantDouble(VirtualRegister src);</span>
  
  #if USE(JSVALUE32_64)
<span class="line-modified">!         bool getOperandConstantInt(VirtualRegister op1, VirtualRegister op2, VirtualRegister&amp; op, int32_t&amp; constant);</span>
  
<span class="line-modified">!         void emitLoadDouble(VirtualRegister, FPRegisterID value);</span>
<span class="line-modified">!         void emitLoadTag(VirtualRegister, RegisterID tag);</span>
<span class="line-added">+         void emitLoadPayload(VirtualRegister, RegisterID payload);</span>
  
          void emitLoad(const JSValue&amp; v, RegisterID tag, RegisterID payload);
<span class="line-modified">!         void emitLoad(VirtualRegister, RegisterID tag, RegisterID payload, RegisterID base = callFrameRegister);</span>
<span class="line-modified">!         void emitLoad2(VirtualRegister, RegisterID tag1, RegisterID payload1, VirtualRegister, RegisterID tag2, RegisterID payload2);</span>
  
<span class="line-modified">!         void emitStore(VirtualRegister, RegisterID tag, RegisterID payload, RegisterID base = callFrameRegister);</span>
<span class="line-modified">!         void emitStore(VirtualRegister, const JSValue constant, RegisterID base = callFrameRegister);</span>
<span class="line-modified">!         void emitStoreInt32(VirtualRegister, RegisterID payload, bool indexIsInt32 = false);</span>
<span class="line-modified">!         void emitStoreInt32(VirtualRegister, TrustedImm32 payload, bool indexIsInt32 = false);</span>
<span class="line-modified">!         void emitStoreCell(VirtualRegister, RegisterID payload, bool indexIsCell = false);</span>
<span class="line-modified">!         void emitStoreBool(VirtualRegister, RegisterID payload, bool indexIsBool = false);</span>
<span class="line-modified">!         void emitStoreDouble(VirtualRegister, FPRegisterID value);</span>
  
<span class="line-modified">!         void emitJumpSlowCaseIfNotJSCell(VirtualRegister);</span>
<span class="line-modified">!         void emitJumpSlowCaseIfNotJSCell(VirtualRegister, RegisterID tag);</span>
  
          void compileGetByIdHotPath(const Identifier*);
  
          // Arithmetic opcode helpers
          template &lt;typename Op&gt;
          void emitBinaryDoubleOp(const Instruction *, OperandTypes, JumpList&amp; notInt32Op1, JumpList&amp; notInt32Op2, bool op1IsInRegisters = true, bool op2IsInRegisters = true);
  
  #else // USE(JSVALUE32_64)
          void emitGetVirtualRegister(VirtualRegister src, RegisterID dst);
          void emitGetVirtualRegisters(VirtualRegister src1, RegisterID dst1, VirtualRegister src2, RegisterID dst2);
          void emitPutVirtualRegister(VirtualRegister dst, RegisterID from = regT0);
<span class="line-modified">!         void emitStoreCell(VirtualRegister dst, RegisterID payload, bool /* only used in JSValue32_64 */ = false)</span>
          {
              emitPutVirtualRegister(dst, payload);
          }
  
          Jump emitJumpIfBothJSCells(RegisterID, RegisterID, RegisterID);
          void emitJumpSlowCaseIfJSCell(RegisterID);
          void emitJumpSlowCaseIfNotJSCell(RegisterID);
<span class="line-modified">!         void emitJumpSlowCaseIfNotJSCell(RegisterID, VirtualRegister);</span>
          Jump emitJumpIfNotInt(RegisterID, RegisterID, RegisterID scratch);
          PatchableJump emitPatchableJumpIfNotInt(RegisterID);
          void emitJumpSlowCaseIfNotInt(RegisterID);
          void emitJumpSlowCaseIfNotNumber(RegisterID);
          void emitJumpSlowCaseIfNotInt(RegisterID, RegisterID, RegisterID scratch);
  
<span class="line-modified">!         void compileGetByIdHotPath(VirtualRegister baseReg, const Identifier*);</span>
  
  #endif // USE(JSVALUE32_64)
  
          template&lt;typename Op&gt;
          void emit_compareAndJump(const Instruction*, RelationalCondition);
<span class="line-added">+         void emit_compareAndJumpImpl(VirtualRegister op1, VirtualRegister op2, unsigned target, RelationalCondition);</span>
          template&lt;typename Op&gt;
          void emit_compareUnsigned(const Instruction*, RelationalCondition);
<span class="line-added">+         void emit_compareUnsignedImpl(VirtualRegister dst, VirtualRegister op1, VirtualRegister op2, RelationalCondition);</span>
          template&lt;typename Op&gt;
          void emit_compareUnsignedAndJump(const Instruction*, RelationalCondition);
<span class="line-added">+         void emit_compareUnsignedAndJumpImpl(VirtualRegister op1, VirtualRegister op2, unsigned target, RelationalCondition);</span>
          template&lt;typename Op&gt;
<span class="line-modified">!         void emit_compareAndJumpSlow(const Instruction*, DoubleCondition, size_t (JIT_OPERATION *operation)(JSGlobalObject*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);</span>
<span class="line-added">+         void emit_compareAndJumpSlowImpl(VirtualRegister op1, VirtualRegister op2, unsigned target, size_t instructionSize, DoubleCondition, size_t (JIT_OPERATION *operation)(JSGlobalObject*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);</span>
  
          void assertStackPointerOffset();
  
          void emit_op_add(const Instruction*);
          void emit_op_bitand(const Instruction*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 573,10 ***</span>
<span class="line-new-header">--- 548,11 ---</span>
          void emit_op_jnstricteq(const Instruction*);
          void emit_op_jbelow(const Instruction*);
          void emit_op_jbeloweq(const Instruction*);
          void emit_op_jtrue(const Instruction*);
          void emit_op_loop_hint(const Instruction*);
<span class="line-added">+         void emit_op_check_traps(const Instruction*);</span>
          void emit_op_nop(const Instruction*);
          void emit_op_super_sampler_begin(const Instruction*);
          void emit_op_super_sampler_end(const Instruction*);
          void emit_op_lshift(const Instruction*);
          void emit_op_mod(const Instruction*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,10 ***</span>
<span class="line-new-header">--- 598,11 ---</span>
          void emit_op_switch_imm(const Instruction*);
          void emit_op_switch_string(const Instruction*);
          void emit_op_tear_off_arguments(const Instruction*);
          void emit_op_throw(const Instruction*);
          void emit_op_to_number(const Instruction*);
<span class="line-added">+         void emit_op_to_numeric(const Instruction*);</span>
          void emit_op_to_string(const Instruction*);
          void emit_op_to_object(const Instruction*);
          void emit_op_to_primitive(const Instruction*);
          void emit_op_unexpected_load(const Instruction*);
          void emit_op_unsigned(const Instruction*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 633,12 ***</span>
<span class="line-new-header">--- 610,15 ---</span>
          void emit_op_has_structure_property(const Instruction*);
          void emit_op_has_indexed_property(const Instruction*);
          void emit_op_get_direct_pname(const Instruction*);
          void emit_op_enumerator_structure_pname(const Instruction*);
          void emit_op_enumerator_generic_pname(const Instruction*);
<span class="line-added">+         void emit_op_get_internal_field(const Instruction*);</span>
<span class="line-added">+         void emit_op_put_internal_field(const Instruction*);</span>
          void emit_op_log_shadow_chicken_prologue(const Instruction*);
          void emit_op_log_shadow_chicken_tail(const Instruction*);
<span class="line-added">+         void emit_op_to_property_key(const Instruction*);</span>
  
          void emitSlow_op_add(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_call(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_tail_call(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_call_eval(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 670,11 ***</span>
          void emitSlow_op_jneq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_jstricteq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_jnstricteq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_jtrue(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_loop_hint(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
<span class="line-modified">!         void emitSlow_op_enter(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);</span>
          void emitSlow_op_mod(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_mul(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_negate(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_neq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_new_object(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
<span class="line-new-header">--- 650,11 ---</span>
          void emitSlow_op_jneq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_jstricteq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_jnstricteq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_jtrue(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_loop_hint(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
<span class="line-modified">!         void emitSlow_op_check_traps(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);</span>
          void emitSlow_op_mod(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_mul(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_negate(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_neq(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
          void emitSlow_op_new_object(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 699,33 ***</span>
          template&lt;typename Op&gt;
          void emitNewFuncCommon(const Instruction*);
          template&lt;typename Op&gt;
          void emitNewFuncExprCommon(const Instruction*);
          void emitVarInjectionCheck(bool needsVarInjectionChecks);
<span class="line-modified">!         void emitResolveClosure(int dst, int scope, bool needsVarInjectionChecks, unsigned depth);</span>
<span class="line-modified">!         void emitLoadWithStructureCheck(int scope, Structure** structureSlot);</span>
  #if USE(JSVALUE64)
          void emitGetVarFromPointer(JSValue* operand, GPRReg);
          void emitGetVarFromIndirectPointer(JSValue** operand, GPRReg);
  #else
          void emitGetVarFromIndirectPointer(JSValue** operand, GPRReg tag, GPRReg payload);
          void emitGetVarFromPointer(JSValue* operand, GPRReg tag, GPRReg payload);
  #endif
<span class="line-modified">!         void emitGetClosureVar(int scope, uintptr_t operand);</span>
          void emitNotifyWrite(WatchpointSet*);
          void emitNotifyWrite(GPRReg pointerToSet);
<span class="line-modified">!         void emitPutGlobalVariable(JSValue* operand, int value, WatchpointSet*);</span>
<span class="line-modified">!         void emitPutGlobalVariableIndirect(JSValue** addressOfOperand, int value, WatchpointSet**);</span>
<span class="line-modified">!         void emitPutClosureVar(int scope, uintptr_t operand, int value, WatchpointSet*);</span>
  
<span class="line-modified">!         void emitInitRegister(int dst);</span>
  
<span class="line-modified">!         void emitPutIntToCallFrameHeader(RegisterID from, int entry);</span>
  
<span class="line-modified">!         JSValue getConstantOperand(int src);</span>
<span class="line-modified">!         bool isOperandConstantInt(int src);</span>
<span class="line-modified">!         bool isOperandConstantChar(int src);</span>
  
          template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
          void emitMathICFast(JITUnaryMathIC&lt;Generator&gt;*, const Instruction*, ProfiledFunction, NonProfiledFunction);
          template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
          void emitMathICFast(JITBinaryMathIC&lt;Generator&gt;*, const Instruction*, ProfiledFunction, NonProfiledFunction);
<span class="line-new-header">--- 679,33 ---</span>
          template&lt;typename Op&gt;
          void emitNewFuncCommon(const Instruction*);
          template&lt;typename Op&gt;
          void emitNewFuncExprCommon(const Instruction*);
          void emitVarInjectionCheck(bool needsVarInjectionChecks);
<span class="line-modified">!         void emitResolveClosure(VirtualRegister dst, VirtualRegister scope, bool needsVarInjectionChecks, unsigned depth);</span>
<span class="line-modified">!         void emitLoadWithStructureCheck(VirtualRegister scope, Structure** structureSlot);</span>
  #if USE(JSVALUE64)
          void emitGetVarFromPointer(JSValue* operand, GPRReg);
          void emitGetVarFromIndirectPointer(JSValue** operand, GPRReg);
  #else
          void emitGetVarFromIndirectPointer(JSValue** operand, GPRReg tag, GPRReg payload);
          void emitGetVarFromPointer(JSValue* operand, GPRReg tag, GPRReg payload);
  #endif
<span class="line-modified">!         void emitGetClosureVar(VirtualRegister scope, uintptr_t operand);</span>
          void emitNotifyWrite(WatchpointSet*);
          void emitNotifyWrite(GPRReg pointerToSet);
<span class="line-modified">!         void emitPutGlobalVariable(JSValue* operand, VirtualRegister value, WatchpointSet*);</span>
<span class="line-modified">!         void emitPutGlobalVariableIndirect(JSValue** addressOfOperand, VirtualRegister value, WatchpointSet**);</span>
<span class="line-modified">!         void emitPutClosureVar(VirtualRegister scope, uintptr_t operand, VirtualRegister value, WatchpointSet*);</span>
  
<span class="line-modified">!         void emitInitRegister(VirtualRegister);</span>
  
<span class="line-modified">!         void emitPutIntToCallFrameHeader(RegisterID from, VirtualRegister);</span>
  
<span class="line-modified">!         JSValue getConstantOperand(VirtualRegister);</span>
<span class="line-modified">!         bool isOperandConstantInt(VirtualRegister);</span>
<span class="line-modified">!         bool isOperandConstantChar(VirtualRegister);</span>
  
          template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
          void emitMathICFast(JITUnaryMathIC&lt;Generator&gt;*, const Instruction*, ProfiledFunction, NonProfiledFunction);
          template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
          void emitMathICFast(JITBinaryMathIC&lt;Generator&gt;*, const Instruction*, ProfiledFunction, NonProfiledFunction);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,31 ***</span>
          void linkDummySlowCase(Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
          {
              ASSERT(!iter-&gt;from.isSet());
              ++iter;
          }
<span class="line-modified">!         void linkSlowCaseIfNotJSCell(Vector&lt;SlowCaseEntry&gt;::iterator&amp;, int virtualRegisterIndex);</span>
<span class="line-modified">!         void linkAllSlowCasesForBytecodeOffset(Vector&lt;SlowCaseEntry&gt;&amp; slowCases,</span>
<span class="line-modified">!             Vector&lt;SlowCaseEntry&gt;::iterator&amp;, unsigned bytecodeOffset);</span>
  
          void linkAllSlowCases(Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
          {
<span class="line-modified">!             linkAllSlowCasesForBytecodeOffset(m_slowCases, iter, m_bytecodeOffset);</span>
          }
  
          MacroAssembler::Call appendCallWithExceptionCheck(const FunctionPtr&lt;CFunctionPtrTag&gt;);
  #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
          MacroAssembler::Call appendCallWithExceptionCheckAndSlowPathReturnType(const FunctionPtr&lt;CFunctionPtrTag&gt;);
  #endif
          MacroAssembler::Call appendCallWithCallFrameRollbackOnException(const FunctionPtr&lt;CFunctionPtrTag&gt;);
<span class="line-modified">!         MacroAssembler::Call appendCallWithExceptionCheckSetJSValueResult(const FunctionPtr&lt;CFunctionPtrTag&gt;, int);</span>
          template&lt;typename Metadata&gt;
<span class="line-modified">!         MacroAssembler::Call appendCallWithExceptionCheckSetJSValueResultWithProfile(Metadata&amp;, const FunctionPtr&lt;CFunctionPtrTag&gt;, int);</span>
  
          template&lt;typename OperationType, typename... Args&gt;
          std::enable_if_t&lt;FunctionTraits&lt;OperationType&gt;::hasResult, MacroAssembler::Call&gt;
<span class="line-modified">!         callOperation(OperationType operation, int result, Args... args)</span>
          {
              setupArguments&lt;OperationType&gt;(args...);
              return appendCallWithExceptionCheckSetJSValueResult(operation, result);
          }
  
<span class="line-new-header">--- 728,37 ---</span>
          void linkDummySlowCase(Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
          {
              ASSERT(!iter-&gt;from.isSet());
              ++iter;
          }
<span class="line-modified">!         void linkSlowCaseIfNotJSCell(Vector&lt;SlowCaseEntry&gt;::iterator&amp;, VirtualRegister);</span>
<span class="line-modified">!         void linkAllSlowCasesForBytecodeIndex(Vector&lt;SlowCaseEntry&gt;&amp; slowCases,</span>
<span class="line-modified">!             Vector&lt;SlowCaseEntry&gt;::iterator&amp;, BytecodeIndex bytecodeOffset);</span>
  
          void linkAllSlowCases(Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
          {
<span class="line-modified">!             linkAllSlowCasesForBytecodeIndex(m_slowCases, iter, m_bytecodeIndex);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         bool hasAnySlowCases(Vector&lt;SlowCaseEntry&gt;&amp; slowCases, Vector&lt;SlowCaseEntry&gt;::iterator&amp;, BytecodeIndex bytecodeOffset);</span>
<span class="line-added">+         bool hasAnySlowCases(Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             return hasAnySlowCases(m_slowCases, iter, m_bytecodeIndex);</span>
          }
  
          MacroAssembler::Call appendCallWithExceptionCheck(const FunctionPtr&lt;CFunctionPtrTag&gt;);
  #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
          MacroAssembler::Call appendCallWithExceptionCheckAndSlowPathReturnType(const FunctionPtr&lt;CFunctionPtrTag&gt;);
  #endif
          MacroAssembler::Call appendCallWithCallFrameRollbackOnException(const FunctionPtr&lt;CFunctionPtrTag&gt;);
<span class="line-modified">!         MacroAssembler::Call appendCallWithExceptionCheckSetJSValueResult(const FunctionPtr&lt;CFunctionPtrTag&gt;, VirtualRegister result);</span>
          template&lt;typename Metadata&gt;
<span class="line-modified">!         MacroAssembler::Call appendCallWithExceptionCheckSetJSValueResultWithProfile(Metadata&amp;, const FunctionPtr&lt;CFunctionPtrTag&gt;, VirtualRegister result);</span>
  
          template&lt;typename OperationType, typename... Args&gt;
          std::enable_if_t&lt;FunctionTraits&lt;OperationType&gt;::hasResult, MacroAssembler::Call&gt;
<span class="line-modified">!         callOperation(OperationType operation, VirtualRegister result, Args... args)</span>
          {
              setupArguments&lt;OperationType&gt;(args...);
              return appendCallWithExceptionCheckSetJSValueResult(operation, result);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 812,11 ***</span>
          }
  #endif // OS(WINDOWS) &amp;&amp; CPU(X86_64)
  
          template&lt;typename Metadata, typename OperationType, typename... Args&gt;
          std::enable_if_t&lt;FunctionTraits&lt;OperationType&gt;::hasResult, MacroAssembler::Call&gt;
<span class="line-modified">!         callOperationWithProfile(Metadata&amp; metadata, OperationType operation, int result, Args... args)</span>
          {
              setupArguments&lt;OperationType&gt;(args...);
              return appendCallWithExceptionCheckSetJSValueResultWithProfile(metadata, operation, result);
          }
  
<span class="line-new-header">--- 798,11 ---</span>
          }
  #endif // OS(WINDOWS) &amp;&amp; CPU(X86_64)
  
          template&lt;typename Metadata, typename OperationType, typename... Args&gt;
          std::enable_if_t&lt;FunctionTraits&lt;OperationType&gt;::hasResult, MacroAssembler::Call&gt;
<span class="line-modified">!         callOperationWithProfile(Metadata&amp; metadata, OperationType operation, VirtualRegister result, Args... args)</span>
          {
              setupArguments&lt;OperationType&gt;(args...);
              return appendCallWithExceptionCheckSetJSValueResultWithProfile(metadata, operation, result);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 865,12 ***</span>
          // Loads the character value of a single character string into dst.
          void emitLoadCharacterString(RegisterID src, RegisterID dst, JumpList&amp; failures);
  
          int jumpTarget(const Instruction*, int target);
  
  #ifndef NDEBUG
<span class="line-modified">!         void printBytecodeOperandTypes(int src1, int src2);</span>
  #endif
  
  #if ENABLE(SAMPLING_FLAGS)
          void setSamplingFlag(int32_t);
          void clearSamplingFlag(int32_t);
<span class="line-new-header">--- 851,18 ---</span>
          // Loads the character value of a single character string into dst.
          void emitLoadCharacterString(RegisterID src, RegisterID dst, JumpList&amp; failures);
  
          int jumpTarget(const Instruction*, int target);
  
<span class="line-added">+ #if ENABLE(DFG_JIT)</span>
<span class="line-added">+         void emitEnterOptimizationCheck();</span>
<span class="line-added">+ #else</span>
<span class="line-added">+         void emitEnterOptimizationCheck() { }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #ifndef NDEBUG
<span class="line-modified">!         void printBytecodeOperandTypes(VirtualRegister src1, VirtualRegister src2);</span>
  #endif
  
  #if ENABLE(SAMPLING_FLAGS)
          void setSamplingFlag(int32_t);
          void clearSamplingFlag(int32_t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 908,43 ***</span>
          // If you need to check a value from the metadata table and you need it to
          // be consistent across the fast and slow path, then you want to use this.
          // It will give the slow path the same value read by the fast path.
          GetPutInfo copiedGetPutInfo(OpPutToScope);
          template&lt;typename BinaryOp&gt;
<span class="line-modified">!         ArithProfile copiedArithProfile(BinaryOp);</span>
  
          Interpreter* m_interpreter;
  
          Vector&lt;CallRecord&gt; m_calls;
          Vector&lt;Label&gt; m_labels;
          Vector&lt;JITGetByIdGenerator&gt; m_getByIds;
          Vector&lt;JITGetByIdWithThisGenerator&gt; m_getByIdsWithThis;
          Vector&lt;JITPutByIdGenerator&gt; m_putByIds;
          Vector&lt;JITInByIdGenerator&gt; m_inByIds;
          Vector&lt;JITInstanceOfGenerator&gt; m_instanceOfs;
          Vector&lt;ByValCompilationInfo&gt; m_byValCompilationInfo;
          Vector&lt;CallCompilationInfo&gt; m_callCompilationInfo;
          Vector&lt;JumpTable&gt; m_jmpTable;
  
<span class="line-modified">!         unsigned m_bytecodeOffset;</span>
          Vector&lt;SlowCaseEntry&gt; m_slowCases;
          Vector&lt;SwitchRecord&gt; m_switches;
  
          HashMap&lt;unsigned, unsigned&gt; m_copiedGetPutInfos;
<span class="line-modified">!         HashMap&lt;uint64_t, ArithProfile&gt; m_copiedArithProfiles;</span>
  
          JumpList m_exceptionChecks;
          JumpList m_exceptionChecksWithCallFrameRollback;
          Label m_exceptionHandler;
  
          unsigned m_getByIdIndex { UINT_MAX };
          unsigned m_getByIdWithThisIndex { UINT_MAX };
          unsigned m_putByIdIndex { UINT_MAX };
          unsigned m_inByIdIndex { UINT_MAX };
          unsigned m_instanceOfIndex { UINT_MAX };
          unsigned m_byValInstructionIndex { UINT_MAX };
          unsigned m_callLinkInfoIndex { UINT_MAX };
  
          Label m_arityCheck;
          std::unique_ptr&lt;LinkBuffer&gt; m_linkBuffer;
  
          std::unique_ptr&lt;JITDisassembler&gt; m_disassembler;
<span class="line-new-header">--- 900,46 ---</span>
          // If you need to check a value from the metadata table and you need it to
          // be consistent across the fast and slow path, then you want to use this.
          // It will give the slow path the same value read by the fast path.
          GetPutInfo copiedGetPutInfo(OpPutToScope);
          template&lt;typename BinaryOp&gt;
<span class="line-modified">!         BinaryArithProfile copiedArithProfile(BinaryOp);</span>
  
          Interpreter* m_interpreter;
  
          Vector&lt;CallRecord&gt; m_calls;
          Vector&lt;Label&gt; m_labels;
          Vector&lt;JITGetByIdGenerator&gt; m_getByIds;
<span class="line-added">+         Vector&lt;JITGetByValGenerator&gt; m_getByVals;</span>
          Vector&lt;JITGetByIdWithThisGenerator&gt; m_getByIdsWithThis;
          Vector&lt;JITPutByIdGenerator&gt; m_putByIds;
          Vector&lt;JITInByIdGenerator&gt; m_inByIds;
          Vector&lt;JITInstanceOfGenerator&gt; m_instanceOfs;
          Vector&lt;ByValCompilationInfo&gt; m_byValCompilationInfo;
          Vector&lt;CallCompilationInfo&gt; m_callCompilationInfo;
          Vector&lt;JumpTable&gt; m_jmpTable;
  
<span class="line-modified">!         BytecodeIndex m_bytecodeIndex;</span>
          Vector&lt;SlowCaseEntry&gt; m_slowCases;
          Vector&lt;SwitchRecord&gt; m_switches;
  
          HashMap&lt;unsigned, unsigned&gt; m_copiedGetPutInfos;
<span class="line-modified">!         HashMap&lt;uint64_t, BinaryArithProfile&gt; m_copiedArithProfiles;</span>
  
          JumpList m_exceptionChecks;
          JumpList m_exceptionChecksWithCallFrameRollback;
          Label m_exceptionHandler;
  
          unsigned m_getByIdIndex { UINT_MAX };
<span class="line-added">+         unsigned m_getByValIndex { UINT_MAX };</span>
          unsigned m_getByIdWithThisIndex { UINT_MAX };
          unsigned m_putByIdIndex { UINT_MAX };
          unsigned m_inByIdIndex { UINT_MAX };
          unsigned m_instanceOfIndex { UINT_MAX };
          unsigned m_byValInstructionIndex { UINT_MAX };
          unsigned m_callLinkInfoIndex { UINT_MAX };
<span class="line-added">+         unsigned m_bytecodeCountHavingSlowCase { 0 };</span>
  
          Label m_arityCheck;
          std::unique_ptr&lt;LinkBuffer&gt; m_linkBuffer;
  
          std::unique_ptr&lt;JITDisassembler&gt; m_disassembler;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 956,12 ***</span>
          HashMap&lt;const Instruction*, MathICGenerationState&gt; m_instructionToMathICGenerationState;
  
          bool m_canBeOptimized;
          bool m_canBeOptimizedOrInlined;
          bool m_shouldEmitProfiling;
<span class="line-modified">!         bool m_shouldUseIndexMasking;</span>
<span class="line-removed">-         unsigned m_loopOSREntryBytecodeOffset { 0 };</span>
      };
  
  } // namespace JSC
  
  
<span class="line-new-header">--- 951,11 ---</span>
          HashMap&lt;const Instruction*, MathICGenerationState&gt; m_instructionToMathICGenerationState;
  
          bool m_canBeOptimized;
          bool m_canBeOptimizedOrInlined;
          bool m_shouldEmitProfiling;
<span class="line-modified">!         BytecodeIndex m_loopOSREntryBytecodeIndex;</span>
      };
  
  } // namespace JSC
  
  
</pre>
<center><a href="JIT.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITAddGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityMathMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityListBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityMathMLElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityMathMLElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
185     return node() &amp;&amp; node()-&gt;hasTagName(MathMLNames::mmultiscriptsTag);
186 }
187 
188 bool AccessibilityMathMLElement::isMathTable() const
189 {
190     return node() &amp;&amp; node()-&gt;hasTagName(MathMLNames::mtableTag);
191 }
192 
193 bool AccessibilityMathMLElement::isMathTableRow() const
194 {
195     return node() &amp;&amp; (node()-&gt;hasTagName(MathMLNames::mtrTag) || hasTagName(MathMLNames::mlabeledtrTag));
196 }
197 
198 bool AccessibilityMathMLElement::isMathTableCell() const
199 {
200     return node() &amp;&amp; node()-&gt;hasTagName(MathMLNames::mtdTag);
201 }
202 
203 bool AccessibilityMathMLElement::isMathScriptObject(AccessibilityMathScriptObjectType type) const
204 {
<span class="line-modified">205     AccessibilityObject* parent = parentObjectUnignored();</span>
206     if (!parent)
207         return false;
208 
209     return type == AccessibilityMathScriptObjectType::Subscript ? this == parent-&gt;mathSubscriptObject() : this == parent-&gt;mathSuperscriptObject();
210 }
211 
212 bool AccessibilityMathMLElement::isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType type) const
213 {
<span class="line-modified">214     AccessibilityObject* parent = parentObjectUnignored();</span>
215     if (!parent || !parent-&gt;isMathMultiscript())
216         return false;
217 
218     // The scripts in a MathML &lt;mmultiscripts&gt; element consist of one or more
219     // subscript, superscript pairs. In order to determine if this object is
220     // a scripted token, we need to examine each set of pairs to see if the
221     // this token is present and in the position corresponding with the type.
222 
223     AccessibilityMathMultiscriptPairs pairs;
224     if (type == AccessibilityMathMultiscriptObjectType::PreSubscript || type == AccessibilityMathMultiscriptObjectType::PreSuperscript)
225         parent-&gt;mathPrescripts(pairs);
226     else
227         parent-&gt;mathPostscripts(pairs);
228 
229     for (const auto&amp; pair : pairs) {
230         if (this == pair.first)
231             return (type == AccessibilityMathMultiscriptObjectType::PreSubscript || type == AccessibilityMathMultiscriptObjectType::PostSubscript);
232         if (this == pair.second)
233             return (type == AccessibilityMathMultiscriptObjectType::PreSuperscript || type == AccessibilityMathMultiscriptObjectType::PostSuperscript);
234     }
235 
236     return false;
237 }
238 
<span class="line-modified">239 AccessibilityObject* AccessibilityMathMLElement::mathRadicandObject()</span>
240 {
241     if (!isMathRoot())
242         return nullptr;
243 
244     // For MathSquareRoot, we actually return the first child of the base.
245     // See also https://webkit.org/b/146452
246     const auto&amp; children = this-&gt;children();
247     if (children.size() &lt; 1)
248         return nullptr;
249 
250     return children[0].get();
251 }
252 
<span class="line-modified">253 AccessibilityObject* AccessibilityMathMLElement::mathRootIndexObject()</span>
254 {
255     if (!isMathRoot() || isMathSquareRoot())
256         return nullptr;
257 
258     const auto&amp; children = this-&gt;children();
259     if (children.size() &lt; 2)
260         return nullptr;
261 
262     return children[1].get();
263 }
264 
<span class="line-modified">265 AccessibilityObject* AccessibilityMathMLElement::mathNumeratorObject()</span>
266 {
267     if (!isMathFraction())
268         return nullptr;
269 
270     const auto&amp; children = this-&gt;children();
271     if (children.size() != 2)
272         return nullptr;
273 
274     return children[0].get();
275 }
276 
<span class="line-modified">277 AccessibilityObject* AccessibilityMathMLElement::mathDenominatorObject()</span>
278 {
279     if (!isMathFraction())
280         return nullptr;
281 
282     const auto&amp; children = this-&gt;children();
283     if (children.size() != 2)
284         return nullptr;
285 
286     return children[1].get();
287 }
288 
<span class="line-modified">289 AccessibilityObject* AccessibilityMathMLElement::mathUnderObject()</span>
290 {
291     if (!isMathUnderOver() || !node())
292         return nullptr;
293 
294     const auto&amp; children = this-&gt;children();
295     if (children.size() &lt; 2)
296         return nullptr;
297 
298     if (node()-&gt;hasTagName(MathMLNames::munderTag) || node()-&gt;hasTagName(MathMLNames::munderoverTag))
299         return children[1].get();
300 
301     return nullptr;
302 }
303 
<span class="line-modified">304 AccessibilityObject* AccessibilityMathMLElement::mathOverObject()</span>
305 {
306     if (!isMathUnderOver() || !node())
307         return nullptr;
308 
309     const auto&amp; children = this-&gt;children();
310     if (children.size() &lt; 2)
311         return nullptr;
312 
313     if (node()-&gt;hasTagName(MathMLNames::moverTag))
314         return children[1].get();
315     if (node()-&gt;hasTagName(MathMLNames::munderoverTag))
316         return children[2].get();
317 
318     return nullptr;
319 }
320 
<span class="line-modified">321 AccessibilityObject* AccessibilityMathMLElement::mathBaseObject()</span>
322 {
323     if (!isMathSubscriptSuperscript() &amp;&amp; !isMathUnderOver() &amp;&amp; !isMathMultiscript())
324         return nullptr;
325 
326     const auto&amp; children = this-&gt;children();
327     // The base object in question is always the first child.
328     if (children.size() &gt; 0)
329         return children[0].get();
330 
331     return nullptr;
332 }
333 
<span class="line-modified">334 AccessibilityObject* AccessibilityMathMLElement::mathSubscriptObject()</span>
335 {
336     if (!isMathSubscriptSuperscript() || !node())
337         return nullptr;
338 
339     const auto&amp; children = this-&gt;children();
340     if (children.size() &lt; 2)
341         return nullptr;
342 
343     if (node()-&gt;hasTagName(MathMLNames::msubTag) || node()-&gt;hasTagName(MathMLNames::msubsupTag))
344         return children[1].get();
345 
346     return nullptr;
347 }
348 
<span class="line-modified">349 AccessibilityObject* AccessibilityMathMLElement::mathSuperscriptObject()</span>
350 {
351     if (!isMathSubscriptSuperscript() || !node())
352         return nullptr;
353 
354     const auto&amp; children = this-&gt;children();
355     unsigned count = children.size();
356 
357     if (count &gt;= 2 &amp;&amp; node()-&gt;hasTagName(MathMLNames::msupTag))
358         return children[1].get();
359 
360     if (count &gt;= 3 &amp;&amp; node()-&gt;hasTagName(MathMLNames::msubsupTag))
361         return children[2].get();
362 
363     return nullptr;
364 }
365 
366 String AccessibilityMathMLElement::mathFencedOpenString() const
367 {
368     if (!isMathFenced())
369         return String();
</pre>
</td>
<td>
<hr />
<pre>
185     return node() &amp;&amp; node()-&gt;hasTagName(MathMLNames::mmultiscriptsTag);
186 }
187 
188 bool AccessibilityMathMLElement::isMathTable() const
189 {
190     return node() &amp;&amp; node()-&gt;hasTagName(MathMLNames::mtableTag);
191 }
192 
193 bool AccessibilityMathMLElement::isMathTableRow() const
194 {
195     return node() &amp;&amp; (node()-&gt;hasTagName(MathMLNames::mtrTag) || hasTagName(MathMLNames::mlabeledtrTag));
196 }
197 
198 bool AccessibilityMathMLElement::isMathTableCell() const
199 {
200     return node() &amp;&amp; node()-&gt;hasTagName(MathMLNames::mtdTag);
201 }
202 
203 bool AccessibilityMathMLElement::isMathScriptObject(AccessibilityMathScriptObjectType type) const
204 {
<span class="line-modified">205     AXCoreObject* parent = parentObjectUnignored();</span>
206     if (!parent)
207         return false;
208 
209     return type == AccessibilityMathScriptObjectType::Subscript ? this == parent-&gt;mathSubscriptObject() : this == parent-&gt;mathSuperscriptObject();
210 }
211 
212 bool AccessibilityMathMLElement::isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType type) const
213 {
<span class="line-modified">214     AXCoreObject* parent = parentObjectUnignored();</span>
215     if (!parent || !parent-&gt;isMathMultiscript())
216         return false;
217 
218     // The scripts in a MathML &lt;mmultiscripts&gt; element consist of one or more
219     // subscript, superscript pairs. In order to determine if this object is
220     // a scripted token, we need to examine each set of pairs to see if the
221     // this token is present and in the position corresponding with the type.
222 
223     AccessibilityMathMultiscriptPairs pairs;
224     if (type == AccessibilityMathMultiscriptObjectType::PreSubscript || type == AccessibilityMathMultiscriptObjectType::PreSuperscript)
225         parent-&gt;mathPrescripts(pairs);
226     else
227         parent-&gt;mathPostscripts(pairs);
228 
229     for (const auto&amp; pair : pairs) {
230         if (this == pair.first)
231             return (type == AccessibilityMathMultiscriptObjectType::PreSubscript || type == AccessibilityMathMultiscriptObjectType::PostSubscript);
232         if (this == pair.second)
233             return (type == AccessibilityMathMultiscriptObjectType::PreSuperscript || type == AccessibilityMathMultiscriptObjectType::PostSuperscript);
234     }
235 
236     return false;
237 }
238 
<span class="line-modified">239 AXCoreObject* AccessibilityMathMLElement::mathRadicandObject()</span>
240 {
241     if (!isMathRoot())
242         return nullptr;
243 
244     // For MathSquareRoot, we actually return the first child of the base.
245     // See also https://webkit.org/b/146452
246     const auto&amp; children = this-&gt;children();
247     if (children.size() &lt; 1)
248         return nullptr;
249 
250     return children[0].get();
251 }
252 
<span class="line-modified">253 AXCoreObject* AccessibilityMathMLElement::mathRootIndexObject()</span>
254 {
255     if (!isMathRoot() || isMathSquareRoot())
256         return nullptr;
257 
258     const auto&amp; children = this-&gt;children();
259     if (children.size() &lt; 2)
260         return nullptr;
261 
262     return children[1].get();
263 }
264 
<span class="line-modified">265 AXCoreObject* AccessibilityMathMLElement::mathNumeratorObject()</span>
266 {
267     if (!isMathFraction())
268         return nullptr;
269 
270     const auto&amp; children = this-&gt;children();
271     if (children.size() != 2)
272         return nullptr;
273 
274     return children[0].get();
275 }
276 
<span class="line-modified">277 AXCoreObject* AccessibilityMathMLElement::mathDenominatorObject()</span>
278 {
279     if (!isMathFraction())
280         return nullptr;
281 
282     const auto&amp; children = this-&gt;children();
283     if (children.size() != 2)
284         return nullptr;
285 
286     return children[1].get();
287 }
288 
<span class="line-modified">289 AXCoreObject* AccessibilityMathMLElement::mathUnderObject()</span>
290 {
291     if (!isMathUnderOver() || !node())
292         return nullptr;
293 
294     const auto&amp; children = this-&gt;children();
295     if (children.size() &lt; 2)
296         return nullptr;
297 
298     if (node()-&gt;hasTagName(MathMLNames::munderTag) || node()-&gt;hasTagName(MathMLNames::munderoverTag))
299         return children[1].get();
300 
301     return nullptr;
302 }
303 
<span class="line-modified">304 AXCoreObject* AccessibilityMathMLElement::mathOverObject()</span>
305 {
306     if (!isMathUnderOver() || !node())
307         return nullptr;
308 
309     const auto&amp; children = this-&gt;children();
310     if (children.size() &lt; 2)
311         return nullptr;
312 
313     if (node()-&gt;hasTagName(MathMLNames::moverTag))
314         return children[1].get();
315     if (node()-&gt;hasTagName(MathMLNames::munderoverTag))
316         return children[2].get();
317 
318     return nullptr;
319 }
320 
<span class="line-modified">321 AXCoreObject* AccessibilityMathMLElement::mathBaseObject()</span>
322 {
323     if (!isMathSubscriptSuperscript() &amp;&amp; !isMathUnderOver() &amp;&amp; !isMathMultiscript())
324         return nullptr;
325 
326     const auto&amp; children = this-&gt;children();
327     // The base object in question is always the first child.
328     if (children.size() &gt; 0)
329         return children[0].get();
330 
331     return nullptr;
332 }
333 
<span class="line-modified">334 AXCoreObject* AccessibilityMathMLElement::mathSubscriptObject()</span>
335 {
336     if (!isMathSubscriptSuperscript() || !node())
337         return nullptr;
338 
339     const auto&amp; children = this-&gt;children();
340     if (children.size() &lt; 2)
341         return nullptr;
342 
343     if (node()-&gt;hasTagName(MathMLNames::msubTag) || node()-&gt;hasTagName(MathMLNames::msubsupTag))
344         return children[1].get();
345 
346     return nullptr;
347 }
348 
<span class="line-modified">349 AXCoreObject* AccessibilityMathMLElement::mathSuperscriptObject()</span>
350 {
351     if (!isMathSubscriptSuperscript() || !node())
352         return nullptr;
353 
354     const auto&amp; children = this-&gt;children();
355     unsigned count = children.size();
356 
357     if (count &gt;= 2 &amp;&amp; node()-&gt;hasTagName(MathMLNames::msupTag))
358         return children[1].get();
359 
360     if (count &gt;= 3 &amp;&amp; node()-&gt;hasTagName(MathMLNames::msubsupTag))
361         return children[2].get();
362 
363     return nullptr;
364 }
365 
366 String AccessibilityMathMLElement::mathFencedOpenString() const
367 {
368     if (!isMathFenced())
369         return String();
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityListBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityMathMLElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineLineBuilder.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;InlineFormattingContext.h&quot;
 32 #include &quot;InlineSoftLineBreakItem.h&quot;
 33 #include &quot;RuntimeEnabledFeatures.h&quot;
 34 #include &quot;TextUtil.h&quot;
 35 #include &lt;wtf/IsoMallocInlines.h&gt;
 36 
 37 namespace WebCore {
 38 namespace Layout {
 39 
 40 static inline bool isWhitespacePreserved(const RenderStyle&amp; style)
 41 {
 42     auto whitespace = style.whiteSpace();
 43     return whitespace == WhiteSpace::Pre || whitespace == WhiteSpace::PreWrap || whitespace == WhiteSpace::BreakSpaces;
 44 }
 45 
 46 struct HangingContent {
 47 public:
 48     void reset();
 49 
 50     InlineLayoutUnit width() const { return m_width; }
 51     bool isConditional() const { return m_isConditional; }
 52 
 53     void setIsConditional() { m_isConditional = true; }
 54     void expand(InlineLayoutUnit width) { m_width += width; }
 55 
 56 private:
 57     bool m_isConditional { false };
 58     InlineLayoutUnit m_width { 0 };
 59 };
 60 
 61 void HangingContent::reset()
 62 {
 63     m_isConditional = false;
 64     m_width =  0;
 65 }
 66 
 67 LineBuilder::LineBuilder(const InlineFormattingContext&amp; inlineFormattingContext, Optional&lt;TextAlignMode&gt; horizontalAlignment, IntrinsicSizing intrinsicSizing)
 68     : m_inlineFormattingContext(inlineFormattingContext)
 69     , m_trimmableTrailingContent(m_runs)
 70     , m_horizontalAlignment(horizontalAlignment)
 71     , m_isIntrinsicSizing(intrinsicSizing == IntrinsicSizing::Yes)
 72     , m_shouldIgnoreTrailingLetterSpacing(RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled())
 73 {
 74 }
 75 
 76 LineBuilder::~LineBuilder()
 77 {
 78 }
 79 
 80 void LineBuilder::initialize(const Constraints&amp; constraints)
 81 {
 82     ASSERT(m_isIntrinsicSizing || constraints.heightAndBaseline);
 83 
 84     InlineLayoutUnit initialLineHeight = 0;
 85     InlineLayoutUnit initialBaselineOffset = 0;
 86     if (constraints.heightAndBaseline) {
 87         m_initialStrut = constraints.heightAndBaseline-&gt;strut;
 88         initialLineHeight = constraints.heightAndBaseline-&gt;height;
 89         initialBaselineOffset = constraints.heightAndBaseline-&gt;baselineOffset;
 90     } else
 91         m_initialStrut = { };
 92 
 93     auto lineRect = Display::InlineRect { constraints.logicalTopLeft, 0_lu, initialLineHeight };
 94     auto baseline = LineBoxBuilder::Baseline { initialBaselineOffset, initialLineHeight - initialBaselineOffset };
 95     m_lineBox = LineBoxBuilder { lineRect, baseline, initialBaselineOffset };
 96     m_lineLogicalWidth = constraints.availableLogicalWidth;
 97     m_hasIntrusiveFloat = constraints.lineIsConstrainedByFloat;
 98 
 99     resetContent();
100 }
101 
102 void LineBuilder::resetContent()
103 {
104     m_lineBox.setLogicalWidth({ });
105     m_lineBox.setIsConsideredEmpty();
106     m_runs.clear();
107     m_trimmableTrailingContent.reset();
108     m_lineIsVisuallyEmptyBeforeTrimmableTrailingContent = { };
109 }
110 
111 LineBuilder::RunList LineBuilder::close(IsLastLineWithInlineContent isLastLineWithInlineContent)
112 {
113     // 1. Remove trimmable trailing content.
114     // 2. Join text runs together when possible [foo][ ][bar] -&gt; [foo bar].
115     // 3. Align merged runs both vertically and horizontally.
116     removeTrailingTrimmableContent();
117     visuallyCollapsePreWrapOverflowContent();
118     auto hangingContent = collectHangingContent(isLastLineWithInlineContent);
119 
120     if (!m_isIntrinsicSizing) {
121         for (auto&amp; run : m_runs) {
122             adjustBaselineAndLineHeight(run);
123             run.setLogicalHeight(runContentHeight(run));
124         }
125         if (isVisuallyEmpty()) {
126             m_lineBox.resetBaseline();
127             m_lineBox.setLogicalHeight({ });
128         }
129         // Remove descent when all content is baseline aligned but none of them have descent.
130         if (formattingContext().quirks().lineDescentNeedsCollapsing(m_runs)) {
131             m_lineBox.shrinkVertically(m_lineBox.baseline().descent());
132             m_lineBox.resetDescent();
133         }
134         alignContentVertically();
135         alignHorizontally(hangingContent, isLastLineWithInlineContent);
136     }
137     return WTFMove(m_runs);
138 }
139 
140 void LineBuilder::alignContentVertically()
141 {
142     ASSERT(!m_isIntrinsicSizing);
143     auto scrollableOverflowRect = m_lineBox.logicalRect();
144     for (auto&amp; run : m_runs) {
145         InlineLayoutUnit logicalTop = 0;
146         auto&amp; layoutBox = run.layoutBox();
147         auto verticalAlign = layoutBox.style().verticalAlign();
148         auto ascent = layoutBox.style().fontMetrics().ascent();
149 
150         switch (verticalAlign) {
151         case VerticalAlign::Baseline:
152             if (run.isLineBreak() || run.isText())
153                 logicalTop = baselineOffset() - ascent;
154             else if (run.isContainerStart()) {
155                 auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);
156                 logicalTop = baselineOffset() - ascent - boxGeometry.borderTop() - boxGeometry.paddingTop().valueOr(0);
157             } else if (layoutBox.isInlineBlockBox() &amp;&amp; layoutBox.establishesInlineFormattingContext()) {
158                 auto&amp; formattingState = layoutState().establishedInlineFormattingState(downcast&lt;Container&gt;(layoutBox));
159                 // Spec makes us generate at least one line -even if it is empty.
160                 auto inlineBlockBaselineOffset = formattingState.displayInlineContent()-&gt;lineBoxes.last().baselineOffset();
161                 // The inline-block&#39;s baseline offset is relative to its content box. Let&#39;s convert it relative to the margin box.
162                 //           _______________ &lt;- margin box
163                 //          |
164                 //          |  ____________  &lt;- border box
165                 //          | |
166                 //          | |  _________  &lt;- content box
167                 //          | | |   ^
168                 //          | | |   |  &lt;- baseline offset
169                 //          | | |   |
170                 //     text | | |   v text
171                 //     -----|-|-|---------- &lt;- baseline
172                 //
173                 auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);
174                 auto baselineOffsetFromMarginBox = boxGeometry.marginBefore() + boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0) + inlineBlockBaselineOffset;
175                 logicalTop = baselineOffset() - baselineOffsetFromMarginBox;
176             } else
177                 logicalTop = baselineOffset() - run.logicalRect().height();
178             break;
179         case VerticalAlign::Top:
180             logicalTop = 0_lu;
181             break;
182         case VerticalAlign::Bottom:
183             logicalTop = logicalBottom() - run.logicalRect().height();
184             break;
185         default:
186             ASSERT_NOT_IMPLEMENTED_YET();
187             break;
188         }
189         run.adjustLogicalTop(logicalTop);
190         // Adjust scrollable overflow if the run overflows the line.
191         scrollableOverflowRect.expandVerticallyToContain(run.logicalRect());
192         // Convert runs from relative to the line top/left to the formatting root&#39;s border box top/left.
193         run.moveVertically(this-&gt;logicalTop());
194         run.moveHorizontally(this-&gt;logicalLeft());
195     }
196     m_lineBox.setScrollableOverflow(scrollableOverflowRect);
197 }
198 
199 void LineBuilder::justifyRuns(InlineLayoutUnit availableWidth)
200 {
201     ASSERT(availableWidth &gt; 0);
202     // Collect the expansion opportunity numbers and find the last run with content.
203     auto expansionOpportunityCount = 0;
204     Run* lastRunWithContent = nullptr;
205     for (auto&amp; run : m_runs) {
206         expansionOpportunityCount += run.expansionOpportunityCount();
207         if (run.isText() || run.isBox())
208             lastRunWithContent = &amp;run;
209     }
210     // Need to fix up the last run&#39;s trailing expansion.
211     if (lastRunWithContent &amp;&amp; lastRunWithContent-&gt;hasExpansionOpportunity()) {
212         // Turn off the trailing bits first and add the forbid trailing expansion.
213         auto leadingExpansion = *lastRunWithContent-&gt;expansionBehavior() &amp; LeadingExpansionMask;
214         lastRunWithContent-&gt;adjustExpansionBehavior(leadingExpansion | ForbidTrailingExpansion);
215     }
216     // Nothing to distribute?
217     if (!expansionOpportunityCount)
218         return;
219     // Distribute the extra space.
220     auto expansionToDistribute = availableWidth / expansionOpportunityCount;
221     InlineLayoutUnit accumulatedExpansion = 0;
222     for (auto&amp; run : m_runs) {
223         // Expand and moves runs by the accumulated expansion.
224         if (!run.hasExpansionOpportunity()) {
225             run.moveHorizontally(accumulatedExpansion);
226             continue;
227         }
228         ASSERT(run.expansionOpportunityCount());
229         auto computedExpansion = expansionToDistribute * run.expansionOpportunityCount();
230         run.setComputedHorizontalExpansion(computedExpansion);
231         run.moveHorizontally(accumulatedExpansion);
232         accumulatedExpansion += computedExpansion;
233     }
234 }
235 
236 void LineBuilder::alignHorizontally(const HangingContent&amp; hangingContent, IsLastLineWithInlineContent lastLine)
237 {
238     ASSERT(!m_isIntrinsicSizing);
239     auto availableWidth = this-&gt;availableWidth() + hangingContent.width();
240     if (m_runs.isEmpty() || availableWidth &lt;= 0)
241         return;
242 
243     if (isTextAlignJustify()) {
244         // Do not justify align the last line.
245         if (lastLine == IsLastLineWithInlineContent::No)
246             justifyRuns(availableWidth);
247         return;
248     }
249 
250     auto adjustmentForAlignment = [&amp;]() -&gt; Optional&lt;InlineLayoutUnit&gt; {
251         switch (*m_horizontalAlignment) {
252         case TextAlignMode::Left:
253         case TextAlignMode::WebKitLeft:
254         case TextAlignMode::Start:
255             return { };
256         case TextAlignMode::Right:
257         case TextAlignMode::WebKitRight:
258         case TextAlignMode::End:
259             return std::max&lt;InlineLayoutUnit&gt;(availableWidth, 0);
260         case TextAlignMode::Center:
261         case TextAlignMode::WebKitCenter:
262             return std::max&lt;InlineLayoutUnit&gt;(availableWidth / 2, 0);
263         case TextAlignMode::Justify:
264             ASSERT_NOT_REACHED();
265             break;
266         }
267         ASSERT_NOT_REACHED();
268         return { };
269     };
270 
271     auto adjustment = adjustmentForAlignment();
272     if (!adjustment)
273         return;
274     // Horizontal alignment means that we not only adjust the runs but also make sure
275     // that the line box is aligned as well
276     // e.g. &lt;div style=&quot;text-align: center; width: 100px;&quot;&gt;centered text&lt;/div&gt; : the line box will also be centered
277     // as opposed to start at 0px all the way to [centered text] run&#39;s right edge.
278     m_lineBox.moveHorizontally(*adjustment);
279     for (auto&amp; run : m_runs)
280         run.moveHorizontally(*adjustment);
281 }
282 
283 void LineBuilder::removeTrailingTrimmableContent()
284 {
285     if (m_trimmableTrailingContent.isEmpty() || m_runs.isEmpty())
286         return;
287 
288     // Complex line layout quirk: keep the trailing whitespace around when it is followed by a line break, unless the content overflows the line.
289     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
290         if (m_runs.last().isLineBreak() &amp;&amp; availableWidth() &gt;= 0 &amp;&amp; !isTextAlignRight()) {
291             m_trimmableTrailingContent.reset();
292             return;
293         }
294     }
295 
296     m_lineBox.shrinkHorizontally(m_trimmableTrailingContent.remove());
297     // If we removed the first visible run on the line, we need to re-check the visibility status.
298     if (m_lineIsVisuallyEmptyBeforeTrimmableTrailingContent) {
299         // Just because the line was visually empty before the removed content, it does not necessarily mean it is still visually empty.
300         // &lt;span&gt;  &lt;/span&gt;&lt;span style=&quot;padding-left: 10px&quot;&gt;&lt;/span&gt;  &lt;- non-empty
301         auto lineIsVisuallyEmpty = [&amp;] {
302             for (auto&amp; run : m_runs) {
303                 if (isVisuallyNonEmpty(run))
304                     return false;
305             }
306             return true;
307         };
308         // We could only go from visually non empty -&gt; to visually empty. Trimmed runs should never make the line visible.
309         if (lineIsVisuallyEmpty())
310             m_lineBox.setIsConsideredEmpty();
311         m_lineIsVisuallyEmptyBeforeTrimmableTrailingContent = { };
312     }
313 }
314 
315 void LineBuilder::visuallyCollapsePreWrapOverflowContent()
316 {
317     ASSERT(m_trimmableTrailingContent.isEmpty());
318     // If white-space is set to pre-wrap, the UA must
319     // ...
320     // It may also visually collapse the character advance widths of any that would otherwise overflow.
321     auto overflowWidth = -availableWidth();
322     if (overflowWidth &lt;= 0)
323         return;
324     // Let&#39;s just find the trailing pre-wrap whitespace content for now (e.g check if there are multiple trailing runs with
325     // different set of white-space values and decide if the in-between pre-wrap content should be collapsed as well.)
326     InlineLayoutUnit trimmedContentWidth = 0;
327     for (auto&amp; run : WTF::makeReversedRange(m_runs)) {
328         if (run.style().whiteSpace() != WhiteSpace::PreWrap) {
329             // We are only interested in pre-wrap trailing content.
330             break;
331         }
332         auto preWrapVisuallyCollapsibleInlineItem = run.isContainerStart() || run.isContainerEnd() || run.hasTrailingWhitespace();
333         if (!preWrapVisuallyCollapsibleInlineItem)
334             break;
335         ASSERT(!run.hasCollapsibleTrailingWhitespace());
336         InlineLayoutUnit trimmableWidth = { };
337         if (run.isText()) {
338             // FIXME: We should always collapse the run at a glyph boundary as the spec indicates: &quot;collapse the character advance widths of any that would otherwise overflow&quot;
339             // and the trimmed width should be capped at std::min(run.trailingWhitespaceWidth(), overflowWidth) for texgt runs. Both FF and Chrome agree.
340             trimmableWidth = run.trailingWhitespaceWidth();
341             run.visuallyCollapseTrailingWhitespace();
342         } else {
343             trimmableWidth = run.logicalWidth();
344             run.shrinkHorizontally(trimmableWidth);
345         }
346         trimmedContentWidth += trimmableWidth;
347         overflowWidth -= trimmableWidth;
348         if (overflowWidth &lt;= 0)
349             break;
350     }
351     m_lineBox.shrinkHorizontally(trimmedContentWidth);
352 }
353 
354 HangingContent LineBuilder::collectHangingContent(IsLastLineWithInlineContent isLastLineWithInlineContent)
355 {
356     auto hangingContent = HangingContent { };
357     // Can&#39;t setup hanging content with removable trailing whitespace.
358     ASSERT(m_trimmableTrailingContent.isEmpty());
359     if (isLastLineWithInlineContent == IsLastLineWithInlineContent::Yes)
360         hangingContent.setIsConditional();
361     for (auto&amp; run : WTF::makeReversedRange(m_runs)) {
362         if (run.isContainerStart() || run.isContainerEnd())
363             continue;
364         if (run.isLineBreak()) {
365             hangingContent.setIsConditional();
366             continue;
367         }
368         if (!run.hasTrailingWhitespace())
369             break;
370         // Check if we have a preserved or hung whitespace.
371         if (run.style().whiteSpace() != WhiteSpace::PreWrap)
372             break;
373         // This is either a normal or conditionally hanging trailing whitespace.
374         hangingContent.expand(run.trailingWhitespaceWidth());
375     }
376     return hangingContent;
377 }
378 
379 void LineBuilder::moveLogicalLeft(InlineLayoutUnit delta)
380 {
381     if (!delta)
382         return;
383     ASSERT(delta &gt; 0);
384     m_lineBox.moveHorizontally(delta);
385     m_lineLogicalWidth -= delta;
386 }
387 
388 void LineBuilder::moveLogicalRight(InlineLayoutUnit delta)
389 {
390     ASSERT(delta &gt; 0);
391     m_lineLogicalWidth -= delta;
392 }
393 
394 void LineBuilder::append(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)
395 {
396     if (inlineItem.isText())
397         appendTextContent(downcast&lt;InlineTextItem&gt;(inlineItem), logicalWidth);
398     else if (inlineItem.isLineBreak())
399         appendLineBreak(inlineItem);
400     else if (inlineItem.isContainerStart())
401         appendInlineContainerStart(inlineItem, logicalWidth);
402     else if (inlineItem.isContainerEnd())
403         appendInlineContainerEnd(inlineItem, logicalWidth);
404     else if (inlineItem.layoutBox().replaced())
405         appendReplacedInlineBox(inlineItem, logicalWidth);
406     else if (inlineItem.isBox())
407         appendNonReplacedInlineBox(inlineItem, logicalWidth);
408     else
409         ASSERT_NOT_REACHED();
410 
411     // Check if this freshly appended content makes the line visually non-empty.
412     if (m_lineBox.isConsideredEmpty() &amp;&amp; !m_runs.isEmpty() &amp;&amp; isVisuallyNonEmpty(m_runs.last()))
413         m_lineBox.setIsConsideredNonEmpty();
414 }
415 
416 void LineBuilder::appendNonBreakableSpace(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalLeft, InlineLayoutUnit logicalWidth)
417 {
418     m_runs.append({ inlineItem, logicalLeft, logicalWidth });
419     m_lineBox.expandHorizontally(logicalWidth);
420 }
421 
422 void LineBuilder::appendInlineContainerStart(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)
423 {
424     // This is really just a placeholder to mark the start of the inline level container &lt;span&gt;.
425     appendNonBreakableSpace(inlineItem, contentLogicalWidth(), logicalWidth);
426 }
427 
428 void LineBuilder::appendInlineContainerEnd(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)
429 {
430     // This is really just a placeholder to mark the end of the inline level container &lt;/span&gt;.
431     auto removeTrailingLetterSpacing = [&amp;] {
432         if (!m_trimmableTrailingContent.isTrailingRunPartiallyTrimmable())
433             return;
434         m_lineBox.shrinkHorizontally(m_trimmableTrailingContent.removePartiallyTrimmableContent());
435     };
436     // Prevent trailing letter-spacing from spilling out of the inline container.
437     // https://drafts.csswg.org/css-text-3/#letter-spacing-property See example 21.
438     removeTrailingLetterSpacing();
439     appendNonBreakableSpace(inlineItem, contentLogicalRight(), logicalWidth);
440 }
441 
442 void LineBuilder::appendTextContent(const InlineTextItem&amp; inlineTextItem, InlineLayoutUnit logicalWidth)
443 {
444     auto willCollapseCompletely = [&amp;] {
445         if (!inlineTextItem.isCollapsible())
446             return false;
447         if (inlineTextItem.isEmptyContent())
448             return true;
449         // Check if the last item is collapsed as well.
450         for (auto&amp; run : WTF::makeReversedRange(m_runs)) {
451             if (run.isBox())
452                 return false;
453             // https://drafts.csswg.org/css-text-3/#white-space-phase-1
454             // Any collapsible space immediately following another collapsible space—even one outside the boundary of the inline containing that space,
455             // provided both spaces are within the same inline formatting context—is collapsed to have zero advance width.
456             // : &quot;&lt;span&gt;  &lt;/span&gt; &quot; &lt;- the trailing whitespace collapses completely.
457             // Not that when the inline container has preserve whitespace style, &quot;&lt;span style=&quot;white-space: pre&quot;&gt;  &lt;/span&gt; &quot; &lt;- this whitespace stays around.
458             if (run.isText())
459                 return run.hasCollapsibleTrailingWhitespace();
460             ASSERT(run.isContainerStart() || run.isContainerEnd());
461         }
462         // Leading whitespace.
463         return !isWhitespacePreserved(inlineTextItem.style());
464     };
465 
466     if (willCollapseCompletely())
467         return;
468 
469     auto inlineTextItemNeedsNewRun = true;
470     if (!m_runs.isEmpty()) {
471         auto&amp; lastRun = m_runs.last();
472         inlineTextItemNeedsNewRun = lastRun.hasCollapsedTrailingWhitespace() || !lastRun.isText() || &amp;lastRun.layoutBox() != &amp;inlineTextItem.layoutBox();
473         if (!inlineTextItemNeedsNewRun)
474             lastRun.expand(inlineTextItem, logicalWidth);
475     }
476     if (inlineTextItemNeedsNewRun)
477         m_runs.append({ inlineTextItem, contentLogicalWidth(), logicalWidth });
478 
479     m_lineBox.expandHorizontally(logicalWidth);
480 
481     // Set the trailing trimmable content.
482     if (inlineTextItem.isWhitespace() &amp;&amp; !TextUtil::shouldPreserveTrailingWhitespace(inlineTextItem.style())) {
483         m_trimmableTrailingContent.addFullyTrimmableContent(m_runs.size() - 1, logicalWidth);
484         // If we ever trim this content, we need to know if the line visibility state needs to be recomputed.
485         if (m_trimmableTrailingContent.isEmpty())
486             m_lineIsVisuallyEmptyBeforeTrimmableTrailingContent = isVisuallyEmpty();
487         return;
488     }
489     // Any non-whitespace, no-trimmable content resets the existing trimmable.
490     m_trimmableTrailingContent.reset();
491     if (!m_shouldIgnoreTrailingLetterSpacing &amp;&amp; !inlineTextItem.isWhitespace() &amp;&amp; inlineTextItem.style().letterSpacing() &gt; 0)
492         m_trimmableTrailingContent.addPartiallyTrimmableContent(m_runs.size() - 1, logicalWidth);
493 }
494 
495 void LineBuilder::appendNonReplacedInlineBox(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)
496 {
497     auto&amp; layoutBox = inlineItem.layoutBox();
498     auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);
499     auto horizontalMargin = boxGeometry.horizontalMargin();
500     m_runs.append({ inlineItem, contentLogicalWidth() + horizontalMargin.start, logicalWidth });
501     m_lineBox.expandHorizontally(logicalWidth + horizontalMargin.start + horizontalMargin.end);
502     m_trimmableTrailingContent.reset();
503 }
504 
505 void LineBuilder::appendReplacedInlineBox(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)
506 {
507     ASSERT(inlineItem.layoutBox().isReplaced());
508     // FIXME: Surely replaced boxes behave differently.
509     appendNonReplacedInlineBox(inlineItem, logicalWidth);
510 }
511 
512 void LineBuilder::appendLineBreak(const InlineItem&amp; inlineItem)
513 {
514     if (inlineItem.isHardLineBreak())
515         return m_runs.append({ inlineItem, contentLogicalWidth(), 0_lu });
516     // Soft line breaks (preserved new line characters) require inline text boxes for compatibility reasons.
517     ASSERT(inlineItem.isSoftLineBreak());
518     m_runs.append({ downcast&lt;InlineSoftLineBreakItem&gt;(inlineItem), contentLogicalWidth() });
519 }
520 
521 void LineBuilder::adjustBaselineAndLineHeight(const Run&amp; run)
522 {
523     auto&amp; baseline = m_lineBox.baseline();
524     if (run.isText() || run.isLineBreak()) {
525         // For text content we set the baseline either through the initial strut (set by the formatting context root) or
526         // through the inline container (start) -see above. Normally the text content itself does not stretch the line.
527         if (!m_initialStrut)
528             return;
529         m_lineBox.setAscentIfGreater(m_initialStrut-&gt;ascent());
530         m_lineBox.setDescentIfGreater(m_initialStrut-&gt;descent());
531         m_lineBox.setLogicalHeightIfGreater(baseline.height());
532         m_initialStrut = { };
533         return;
534     }
535 
536     auto&amp; layoutBox = run.layoutBox();
537     auto&amp; style = layoutBox.style();
538     if (run.isContainerStart()) {
539         // Inline containers stretch the line by their font size.
540         // Vertical margins, paddings and borders don&#39;t contribute to the line height.
541         auto&amp; fontMetrics = style.fontMetrics();
542         if (style.verticalAlign() == VerticalAlign::Baseline) {
543             auto halfLeading = halfLeadingMetrics(fontMetrics, style.computedLineHeight());
544             // Both halfleading ascent and descent could be negative (tall font vs. small line-height value)
545             if (halfLeading.descent() &gt; 0)
546                 m_lineBox.setDescentIfGreater(halfLeading.descent());
547             if (halfLeading.ascent() &gt; 0)
548                 m_lineBox.setAscentIfGreater(halfLeading.ascent());
549             m_lineBox.setLogicalHeightIfGreater(baseline.height());
550         } else
551             m_lineBox.setLogicalHeightIfGreater(fontMetrics.height());
552         return;
553     }
554 
555     if (run.isContainerEnd()) {
556         // The line&#39;s baseline and height have already been adjusted at ContainerStart.
557         return;
558     }
559 
560     if (run.isBox()) {
561         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);
562         auto marginBoxHeight = boxGeometry.marginBoxHeight();
563 
564         switch (style.verticalAlign()) {
565         case VerticalAlign::Baseline: {
566             if (layoutBox.isInlineBlockBox() &amp;&amp; layoutBox.establishesInlineFormattingContext()) {
567                 // Inline-blocks with inline content always have baselines.
568                 auto&amp; formattingState = layoutState().establishedInlineFormattingState(downcast&lt;Container&gt;(layoutBox));
569                 // Spec makes us generate at least one line -even if it is empty.
570                 auto&amp; lastLineBox = formattingState.displayInlineContent()-&gt;lineBoxes.last();
571                 auto inlineBlockBaseline = lastLineBox.baseline();
572                 auto beforeHeight = boxGeometry.marginBefore() + boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0);
573 
574                 m_lineBox.setAscentIfGreater(inlineBlockBaseline.ascent());
575                 m_lineBox.setDescentIfGreater(inlineBlockBaseline.descent());
576                 m_lineBox.setBaselineOffsetIfGreater(beforeHeight + lastLineBox.baselineOffset());
577                 m_lineBox.setLogicalHeightIfGreater(marginBoxHeight);
578             } else {
579                 // Non inline-block boxes sit on the baseline (including their bottom margin).
580                 m_lineBox.setAscentIfGreater(marginBoxHeight);
581                 // Ignore negative descent (yes, negative descent is a thing).
582                 m_lineBox.setLogicalHeightIfGreater(marginBoxHeight + std::max&lt;InlineLayoutUnit&gt;(0, baseline.descent()));
583             }
584             break;
585         }
586         case VerticalAlign::Top:
587             // Top align content never changes the baseline, it only pushes the bottom of the line further down.
588             m_lineBox.setLogicalHeightIfGreater(marginBoxHeight);
589             break;
590         case VerticalAlign::Bottom: {
591             // Bottom aligned, tall content pushes the baseline further down from the line top.
592             auto lineLogicalHeight = m_lineBox.logicalHeight();
593             if (marginBoxHeight &gt; lineLogicalHeight) {
594                 m_lineBox.setLogicalHeightIfGreater(marginBoxHeight);
595                 m_lineBox.setBaselineOffsetIfGreater(m_lineBox.baselineOffset() + (marginBoxHeight - lineLogicalHeight));
596             }
597             break;
598         }
599         default:
600             ASSERT_NOT_IMPLEMENTED_YET();
601             break;
602         }
603         return;
604     }
605     ASSERT_NOT_REACHED();
606 }
607 
608 InlineLayoutUnit LineBuilder::runContentHeight(const Run&amp; run) const
609 {
610     ASSERT(!m_isIntrinsicSizing);
611     auto&amp; fontMetrics = run.style().fontMetrics();
612     if (run.isText() || run.isLineBreak())
613         return fontMetrics.height();
614 
615     if (run.isContainerStart() || run.isContainerEnd())
616         return fontMetrics.height();
617 
618     auto&amp; layoutBox = run.layoutBox();
619     auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);
620     if (layoutBox.replaced() || layoutBox.isFloatingPositioned())
621         return boxGeometry.contentBoxHeight();
622 
623     // Non-replaced inline box (e.g. inline-block). It looks a bit misleading but their margin box is considered the content height here.
624     return boxGeometry.marginBoxHeight();
625 }
626 
627 bool LineBuilder::isVisuallyNonEmpty(const Run&amp; run) const
628 {
629     if (run.isText())
630         return true;
631 
632     if (run.isLineBreak())
633         return true;
634 
635     // Note that this does not check whether the inline container has content. It simply checks if the container itself is considered non-empty.
636     if (run.isContainerStart() || run.isContainerEnd()) {
637         if (!run.logicalWidth())
638             return false;
639         // Margin does not make the container visually non-empty. Check if it has border or padding.
640         auto&amp; boxGeometry = formattingContext().geometryForBox(run.layoutBox());
641         if (run.isContainerStart())
642             return boxGeometry.borderLeft() || (boxGeometry.paddingLeft() &amp;&amp; boxGeometry.paddingLeft().value());
643         return boxGeometry.borderRight() || (boxGeometry.paddingRight() &amp;&amp; boxGeometry.paddingRight().value());
644     }
645 
646     if (run.isBox()) {
647         if (run.layoutBox().isReplaced())
648             return true;
649         ASSERT(run.layoutBox().isInlineBlockBox() || run.layoutBox().isInlineTableBox());
650         if (!run.logicalWidth())
651             return false;
652         if (m_isIntrinsicSizing || formattingContext().geometryForBox(run.layoutBox()).height())
653             return true;
654         return false;
655     }
656 
657     ASSERT_NOT_REACHED();
658     return false;
659 }
660 
661 LineBoxBuilder::Baseline LineBuilder::halfLeadingMetrics(const FontMetrics&amp; fontMetrics, InlineLayoutUnit lineLogicalHeight)
662 {
663     auto ascent = fontMetrics.ascent();
664     auto descent = fontMetrics.descent();
665     // 10.8.1 Leading and half-leading
666     auto halfLeading = (lineLogicalHeight - (ascent + descent)) / 2;
667     // Inline tree height is all integer based.
668     auto adjustedAscent = std::max&lt;InlineLayoutUnit&gt;(floorf(ascent + halfLeading), 0);
669     auto adjustedDescent = std::max&lt;InlineLayoutUnit&gt;(ceilf(descent + halfLeading), 0);
670     return { adjustedAscent, adjustedDescent };
671 }
672 
673 LayoutState&amp; LineBuilder::layoutState() const
674 {
675     return formattingContext().layoutState();
676 }
677 
678 const InlineFormattingContext&amp; LineBuilder::formattingContext() const
679 {
680     return m_inlineFormattingContext;
681 }
682 
683 LineBuilder::TrimmableTrailingContent::TrimmableTrailingContent(RunList&amp; runs)
684     : m_runs(runs)
685 {
686 }
687 
688 void LineBuilder::TrimmableTrailingContent::addFullyTrimmableContent(size_t runIndex, InlineLayoutUnit trimmableWidth)
689 {
690     // Any subsequent trimmable whitespace should collapse to zero advanced width and ignored at ::appendTextContent().
691     ASSERT(!m_hasFullyTrimmableContent);
692     m_fullyTrimmableWidth = trimmableWidth;
693     // Note that just becasue the trimmable width is 0 (font-size: 0px), it does not mean we don&#39;t have a trimmable trailing content.
694     m_hasFullyTrimmableContent = true;
695     m_firstRunIndex = m_firstRunIndex.valueOr(runIndex);
696 }
697 
698 void LineBuilder::TrimmableTrailingContent::addPartiallyTrimmableContent(size_t runIndex, InlineLayoutUnit trimmableWidth)
699 {
700     // Do not add trimmable letter spacing after a fully trimmable whitesapce.
701     ASSERT(!m_firstRunIndex);
702     ASSERT(!m_hasFullyTrimmableContent);
703     ASSERT(!m_partiallyTrimmableWidth);
704     ASSERT(trimmableWidth);
705     m_partiallyTrimmableWidth = trimmableWidth;
706     m_firstRunIndex = runIndex;
707 }
708 
709 InlineLayoutUnit LineBuilder::TrimmableTrailingContent::remove()
710 {
711     // Remove trimmable trailing content and move all the subsequent trailing runs.
712     // &lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;/span&gt;
713     // [trailing whitespace][container end][container start][container end]
714     // Trim the whitespace run and move the trailing inline container runs to the logical left.
715     ASSERT(!isEmpty());
716     auto&amp; trimmableRun = m_runs[*m_firstRunIndex];
717     ASSERT(trimmableRun.isText());
718 
719     if (m_hasFullyTrimmableContent)
720         trimmableRun.removeTrailingWhitespace();
721     if (m_partiallyTrimmableWidth)
722         trimmableRun.removeTrailingLetterSpacing();
723 
724     auto trimmableWidth = width();
725     for (auto index = *m_firstRunIndex + 1; index &lt; m_runs.size(); ++index) {
726         auto&amp; run = m_runs[index];
727         ASSERT(run.isContainerStart() || run.isContainerEnd() || run.isLineBreak());
728         run.moveHorizontally(-trimmableWidth);
729     }
730     reset();
731     return trimmableWidth;
732 }
733 
734 InlineLayoutUnit LineBuilder::TrimmableTrailingContent::removePartiallyTrimmableContent()
735 {
736     // Partially trimmable content is always gated by a fully trimmable content.
737     // We can&#39;t just trim spacing in the middle.
738     ASSERT(!m_fullyTrimmableWidth);
739     return remove();
740 }
741 
742 LineBuilder::Run::Run(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalLeft, InlineLayoutUnit logicalWidth)
743     : m_type(inlineItem.type())
744     , m_layoutBox(&amp;inlineItem.layoutBox())
745     , m_logicalRect({ 0, logicalLeft, logicalWidth, 0 })
746 {
747 }
748 
749 LineBuilder::Run::Run(const InlineSoftLineBreakItem&amp; softLineBreakItem, InlineLayoutUnit logicalLeft)
750     : m_type(softLineBreakItem.type())
751     , m_layoutBox(&amp;softLineBreakItem.layoutBox())
752     , m_logicalRect({ 0, logicalLeft, 0, 0 })
753     , m_textContext({ softLineBreakItem.position(), 1, softLineBreakItem.layoutBox().textContext()-&gt;content })
754 {
755 }
756 
757 LineBuilder::Run::Run(const InlineTextItem&amp; inlineTextItem, InlineLayoutUnit logicalLeft, InlineLayoutUnit logicalWidth)
758     : m_type(InlineItem::Type::Text)
759     , m_layoutBox(&amp;inlineTextItem.layoutBox())
760     , m_logicalRect({ 0, logicalLeft, logicalWidth, 0 })
761     , m_trailingWhitespaceType(trailingWhitespaceType(inlineTextItem))
762     , m_textContext({ inlineTextItem.start(), m_trailingWhitespaceType == TrailingWhitespace::Collapsed ? 1 : inlineTextItem.length(), inlineTextItem.layoutBox().textContext()-&gt;content })
763 {
764     if (m_trailingWhitespaceType != TrailingWhitespace::None) {
765         m_trailingWhitespaceWidth = logicalWidth;
766         m_textContext-&gt;setExpansion({ ExpansionBehavior(DefaultExpansion), { } });
767         if (!isWhitespacePreserved(inlineTextItem.style()))
768             m_expansionOpportunityCount = 1;
769     }
770 }
771 
772 void LineBuilder::Run::expand(const InlineTextItem&amp; inlineTextItem, InlineLayoutUnit logicalWidth)
773 {
774     // FIXME: This is a very simple expansion merge. We should eventually switch over to FontCascade::expansionOpportunityCount.
775     ASSERT(!hasCollapsedTrailingWhitespace());
776     ASSERT(isText() &amp;&amp; inlineTextItem.isText());
777     ASSERT(m_layoutBox == &amp;inlineTextItem.layoutBox());
778 
779     m_logicalRect.expandHorizontally(logicalWidth);
780     m_trailingWhitespaceType = trailingWhitespaceType(inlineTextItem);
781 
782     if (m_trailingWhitespaceType == TrailingWhitespace::None) {
783         m_trailingWhitespaceWidth = { };
784         m_textContext-&gt;setExpansion({ ExpansionBehavior(AllowLeadingExpansion | AllowTrailingExpansion), { } });
785         m_textContext-&gt;expand(inlineTextItem.length());
786         return;
787     }
788     m_trailingWhitespaceWidth += logicalWidth;
789     if (!isWhitespacePreserved(inlineTextItem.style()))
790         ++m_expansionOpportunityCount;
791     m_textContext-&gt;setExpansion({ ExpansionBehavior(DefaultExpansion), { } });
792     m_textContext-&gt;expand(m_trailingWhitespaceType == TrailingWhitespace::Collapsed ? 1 : inlineTextItem.length());
793 }
794 
795 bool LineBuilder::Run::hasTrailingLetterSpacing() const
796 {
797     // Complex line layout does not keep track of trailing letter spacing.
798     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled())
799         return false;
800     return !hasTrailingWhitespace() &amp;&amp; style().letterSpacing() &gt; 0;
801 }
802 
803 InlineLayoutUnit LineBuilder::Run::trailingLetterSpacing() const
804 {
805     if (!hasTrailingLetterSpacing())
806         return 0_lu;
807     return InlineLayoutUnit { style().letterSpacing() };
808 }
809 
810 void LineBuilder::Run::removeTrailingLetterSpacing()
811 {
812     ASSERT(hasTrailingLetterSpacing());
813     shrinkHorizontally(trailingLetterSpacing());
814     ASSERT(logicalWidth() &gt; 0 || (!logicalWidth() &amp;&amp; style().letterSpacing() &gt;= intMaxForLayoutUnit));
815 }
816 
817 void LineBuilder::Run::removeTrailingWhitespace()
818 {
819     // According to https://www.w3.org/TR/css-text-3/#white-space-property matrix
820     // Trimmable whitespace is always collapsable so the length of the trailing trimmable whitespace is always 1 (or non-existent).
821     ASSERT(m_textContext-&gt;length());
822     m_textContext-&gt;expand(-1);
823     visuallyCollapseTrailingWhitespace();
824 }
825 
826 void LineBuilder::Run::visuallyCollapseTrailingWhitespace()
827 {
828     // This is just a visual adjustment, the text length should remain the same.
829     shrinkHorizontally(m_trailingWhitespaceWidth);
830     m_trailingWhitespaceWidth = { };
831     m_trailingWhitespaceType = TrailingWhitespace::None;
832 
833     if (!isWhitespacePreserved(style())) {
834         ASSERT(m_expansionOpportunityCount);
835         m_expansionOpportunityCount--;
836     }
837     m_textContext-&gt;setExpansion({ ExpansionBehavior(AllowLeadingExpansion | AllowTrailingExpansion), { } });
838 }
839 
840 void LineBuilder::Run::adjustExpansionBehavior(ExpansionBehavior expansionBehavior)
841 {
842     ASSERT(isText());
843     ASSERT(hasExpansionOpportunity());
844     m_textContext-&gt;setExpansion({ expansionBehavior, m_textContext-&gt;expansion()-&gt;horizontalExpansion });
845 }
846 
847 inline Optional&lt;ExpansionBehavior&gt; LineBuilder::Run::expansionBehavior() const
848 {
849     ASSERT(isText());
850     if (auto expansionContext = m_textContext-&gt;expansion())
851         return expansionContext-&gt;behavior;
852     return { };
853 }
854 
855 void LineBuilder::Run::setComputedHorizontalExpansion(InlineLayoutUnit logicalExpansion)
856 {
857     ASSERT(isText());
858     ASSERT(hasExpansionOpportunity());
859     m_logicalRect.expandHorizontally(logicalExpansion);
860     m_textContext-&gt;setExpansion({ m_textContext-&gt;expansion()-&gt;behavior, logicalExpansion });
861 }
862 
863 }
864 }
865 
866 #endif
    </pre>
  </body>
</html>
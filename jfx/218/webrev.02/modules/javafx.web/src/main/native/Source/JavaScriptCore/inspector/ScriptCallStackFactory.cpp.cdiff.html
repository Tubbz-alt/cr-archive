<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptCallStackFactory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptCallStack.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptCallStackFactory.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptCallStackFactory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 43,14 ***</span>
  #include &quot;ScriptCallFrame.h&quot;
  #include &quot;StackVisitor.h&quot;
  #include &quot;StrongInlines.h&quot;
  #include &lt;wtf/text/WTFString.h&gt;
  
<span class="line-removed">- using namespace JSC;</span>
<span class="line-removed">- </span>
  namespace Inspector {
  
  class CreateScriptCallStackFunctor {
  public:
      CreateScriptCallStackFunctor(bool needToSkipAFrame, Vector&lt;ScriptCallFrame&gt;&amp; frames, size_t remainingCapacity)
          : m_needToSkipAFrame(needToSkipAFrame)
          , m_frames(frames)
<span class="line-new-header">--- 43,14 ---</span>
  #include &quot;ScriptCallFrame.h&quot;
  #include &quot;StackVisitor.h&quot;
  #include &quot;StrongInlines.h&quot;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace Inspector {
  
<span class="line-added">+ using namespace JSC;</span>
<span class="line-added">+ </span>
  class CreateScriptCallStackFunctor {
  public:
      CreateScriptCallStackFunctor(bool needToSkipAFrame, Vector&lt;ScriptCallFrame&gt;&amp; frames, size_t remainingCapacity)
          : m_needToSkipAFrame(needToSkipAFrame)
          , m_frames(frames)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,65 ***</span>
      mutable bool m_needToSkipAFrame;
      Vector&lt;ScriptCallFrame&gt;&amp; m_frames;
      mutable size_t m_remainingCapacityForFrameCapture;
  };
  
<span class="line-modified">! Ref&lt;ScriptCallStack&gt; createScriptCallStack(JSC::ExecState* exec, size_t maxStackSize)</span>
  {
<span class="line-modified">!     if (!exec)</span>
          return ScriptCallStack::create();
  
<span class="line-modified">!     JSLockHolder locker(exec);</span>
      Vector&lt;ScriptCallFrame&gt; frames;
  
<span class="line-modified">!     CallFrame* frame = exec-&gt;vm().topCallFrame;</span>
      if (!frame)
          return ScriptCallStack::create();
      CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified">!     frame-&gt;iterate(functor);</span>
  
      return ScriptCallStack::create(frames);
  }
  
<span class="line-modified">! Ref&lt;ScriptCallStack&gt; createScriptCallStackForConsole(JSC::ExecState* exec, size_t maxStackSize)</span>
  {
<span class="line-modified">!     if (!exec)</span>
          return ScriptCallStack::create();
  
<span class="line-modified">!     JSLockHolder locker(exec);</span>
      Vector&lt;ScriptCallFrame&gt; frames;
  
<span class="line-modified">!     CallFrame* frame = exec-&gt;vm().topCallFrame;</span>
      if (!frame)
          return ScriptCallStack::create();
      CreateScriptCallStackFunctor functor(true, frames, maxStackSize);
<span class="line-modified">!     frame-&gt;iterate(functor);</span>
  
      if (frames.isEmpty()) {
          CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified">!         frame-&gt;iterate(functor);</span>
      }
  
      return ScriptCallStack::create(frames);
  }
  
<span class="line-modified">! static bool extractSourceInformationFromException(JSC::ExecState* exec, JSObject* exceptionObject, int* lineNumber, int* columnNumber, String* sourceURL)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      // FIXME: &lt;http://webkit.org/b/115087&gt; Web Inspector: Should not need to evaluate JavaScript handling exceptions
      JSValue lineValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;line&quot;));
      JSValue columnValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;column&quot;));
      JSValue sourceURLValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;sourceURL&quot;));
  
      bool result = false;
      if (lineValue &amp;&amp; lineValue.isNumber()
          &amp;&amp; sourceURLValue &amp;&amp; sourceURLValue.isString()) {
<span class="line-modified">!         *lineNumber = int(lineValue.toNumber(exec));</span>
<span class="line-modified">!         *columnNumber = columnValue &amp;&amp; columnValue.isNumber() ? int(columnValue.toNumber(exec)) : 0;</span>
<span class="line-modified">!         *sourceURL = sourceURLValue.toWTFString(exec);</span>
          result = true;
      } else if (ErrorInstance* error = jsDynamicCast&lt;ErrorInstance*&gt;(vm, exceptionObject)) {
          unsigned unsignedLine;
          unsigned unsignedColumn;
          result = getLineColumnAndSource(error-&gt;stackTrace(), unsignedLine, unsignedColumn, *sourceURL);
<span class="line-new-header">--- 82,67 ---</span>
      mutable bool m_needToSkipAFrame;
      Vector&lt;ScriptCallFrame&gt;&amp; m_frames;
      mutable size_t m_remainingCapacityForFrameCapture;
  };
  
<span class="line-modified">! Ref&lt;ScriptCallStack&gt; createScriptCallStack(JSC::JSGlobalObject* globalObject, size_t maxStackSize)</span>
  {
<span class="line-modified">!     if (!globalObject)</span>
          return ScriptCallStack::create();
  
<span class="line-modified">!     JSLockHolder locker(globalObject);</span>
      Vector&lt;ScriptCallFrame&gt; frames;
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* frame = vm.topCallFrame;</span>
      if (!frame)
          return ScriptCallStack::create();
      CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified">!     frame-&gt;iterate(vm, functor);</span>
  
      return ScriptCallStack::create(frames);
  }
  
<span class="line-modified">! Ref&lt;ScriptCallStack&gt; createScriptCallStackForConsole(JSC::JSGlobalObject* globalObject, size_t maxStackSize)</span>
  {
<span class="line-modified">!     if (!globalObject)</span>
          return ScriptCallStack::create();
  
<span class="line-modified">!     JSLockHolder locker(globalObject);</span>
      Vector&lt;ScriptCallFrame&gt; frames;
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* frame = vm.topCallFrame;</span>
      if (!frame)
          return ScriptCallStack::create();
      CreateScriptCallStackFunctor functor(true, frames, maxStackSize);
<span class="line-modified">!     frame-&gt;iterate(vm, functor);</span>
  
      if (frames.isEmpty()) {
          CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified">!         frame-&gt;iterate(vm, functor);</span>
      }
  
      return ScriptCallStack::create(frames);
  }
  
<span class="line-modified">! static bool extractSourceInformationFromException(JSC::JSGlobalObject* globalObject, JSObject* exceptionObject, int* lineNumber, int* columnNumber, String* sourceURL)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      // FIXME: &lt;http://webkit.org/b/115087&gt; Web Inspector: Should not need to evaluate JavaScript handling exceptions
      JSValue lineValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;line&quot;));
      JSValue columnValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;column&quot;));
      JSValue sourceURLValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;sourceURL&quot;));
  
      bool result = false;
      if (lineValue &amp;&amp; lineValue.isNumber()
          &amp;&amp; sourceURLValue &amp;&amp; sourceURLValue.isString()) {
<span class="line-modified">!         *lineNumber = int(lineValue.toNumber(globalObject));</span>
<span class="line-modified">!         *columnNumber = columnValue &amp;&amp; columnValue.isNumber() ? int(columnValue.toNumber(globalObject)) : 0;</span>
<span class="line-modified">!         *sourceURL = sourceURLValue.toWTFString(globalObject);</span>
          result = true;
      } else if (ErrorInstance* error = jsDynamicCast&lt;ErrorInstance*&gt;(vm, exceptionObject)) {
          unsigned unsignedLine;
          unsigned unsignedColumn;
          result = getLineColumnAndSource(error-&gt;stackTrace(), unsignedLine, unsignedColumn, *sourceURL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,56 ***</span>
  
      scope.clearException();
      return result;
  }
  
<span class="line-modified">! Ref&lt;ScriptCallStack&gt; createScriptCallStackFromException(JSC::ExecState* exec, JSC::Exception* exception, size_t maxStackSize)</span>
  {
      Vector&lt;ScriptCallFrame&gt; frames;
      auto&amp; stackTrace = exception-&gt;stack();
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      for (size_t i = 0; i &lt; stackTrace.size() &amp;&amp; i &lt; maxStackSize; i++) {
          unsigned line;
          unsigned column;
          stackTrace[i].computeLineAndColumn(line, column);
          String functionName = stackTrace[i].functionName(vm);
          frames.append(ScriptCallFrame(functionName, stackTrace[i].sourceURL(), static_cast&lt;SourceID&gt;(stackTrace[i].sourceID()), line, column));
      }
  
      // Fallback to getting at least the line and sourceURL from the exception object if it has values and the exceptionStack doesn&#39;t.
      if (exception-&gt;value().isObject()) {
<span class="line-modified">!         JSObject* exceptionObject = exception-&gt;value().toObject(exec);</span>
          ASSERT(exceptionObject);
          int lineNumber;
          int columnNumber;
          String exceptionSourceURL;
          if (!frames.size()) {
<span class="line-modified">!             if (extractSourceInformationFromException(exec, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
                  frames.append(ScriptCallFrame(String(), exceptionSourceURL, noSourceID, lineNumber, columnNumber));
          } else {
              // FIXME: The typical stack trace will have a native frame at the top, and consumers of
              // this code already know this (see JSDOMExceptionHandling.cpp&#39;s reportException, for
              // example - it uses firstNonNativeCallFrame). This looks like it splats something else
              // over it. That something else is probably already at stackTrace[1].
              // https://bugs.webkit.org/show_bug.cgi?id=176663
              if (!stackTrace[0].hasLineAndColumnInfo() || stackTrace[0].sourceURL().isEmpty()) {
                  const ScriptCallFrame&amp; firstCallFrame = frames.first();
<span class="line-modified">!                 if (extractSourceInformationFromException(exec, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
                      frames[0] = ScriptCallFrame(firstCallFrame.functionName(), exceptionSourceURL, stackTrace[0].sourceID(), lineNumber, columnNumber);
              }
          }
      }
  
      return ScriptCallStack::create(frames);
  }
  
<span class="line-modified">! Ref&lt;ScriptArguments&gt; createScriptArguments(JSC::ExecState* state, unsigned skipArgumentCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt; arguments;
<span class="line-modified">!     size_t argumentCount = state-&gt;argumentCount();</span>
      for (size_t i = skipArgumentCount; i &lt; argumentCount; ++i)
<span class="line-modified">!         arguments.append({ vm, state-&gt;uncheckedArgument(i) });</span>
<span class="line-modified">!     return ScriptArguments::create(*state, WTFMove(arguments));</span>
  }
  
  } // namespace Inspector
<span class="line-new-header">--- 155,56 ---</span>
  
      scope.clearException();
      return result;
  }
  
<span class="line-modified">! Ref&lt;ScriptCallStack&gt; createScriptCallStackFromException(JSC::JSGlobalObject* globalObject, JSC::Exception* exception, size_t maxStackSize)</span>
  {
      Vector&lt;ScriptCallFrame&gt; frames;
      auto&amp; stackTrace = exception-&gt;stack();
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      for (size_t i = 0; i &lt; stackTrace.size() &amp;&amp; i &lt; maxStackSize; i++) {
          unsigned line;
          unsigned column;
          stackTrace[i].computeLineAndColumn(line, column);
          String functionName = stackTrace[i].functionName(vm);
          frames.append(ScriptCallFrame(functionName, stackTrace[i].sourceURL(), static_cast&lt;SourceID&gt;(stackTrace[i].sourceID()), line, column));
      }
  
      // Fallback to getting at least the line and sourceURL from the exception object if it has values and the exceptionStack doesn&#39;t.
      if (exception-&gt;value().isObject()) {
<span class="line-modified">!         JSObject* exceptionObject = exception-&gt;value().toObject(globalObject);</span>
          ASSERT(exceptionObject);
          int lineNumber;
          int columnNumber;
          String exceptionSourceURL;
          if (!frames.size()) {
<span class="line-modified">!             if (extractSourceInformationFromException(globalObject, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
                  frames.append(ScriptCallFrame(String(), exceptionSourceURL, noSourceID, lineNumber, columnNumber));
          } else {
              // FIXME: The typical stack trace will have a native frame at the top, and consumers of
              // this code already know this (see JSDOMExceptionHandling.cpp&#39;s reportException, for
              // example - it uses firstNonNativeCallFrame). This looks like it splats something else
              // over it. That something else is probably already at stackTrace[1].
              // https://bugs.webkit.org/show_bug.cgi?id=176663
              if (!stackTrace[0].hasLineAndColumnInfo() || stackTrace[0].sourceURL().isEmpty()) {
                  const ScriptCallFrame&amp; firstCallFrame = frames.first();
<span class="line-modified">!                 if (extractSourceInformationFromException(globalObject, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
                      frames[0] = ScriptCallFrame(firstCallFrame.functionName(), exceptionSourceURL, stackTrace[0].sourceID(), lineNumber, columnNumber);
              }
          }
      }
  
      return ScriptCallStack::create(frames);
  }
  
<span class="line-modified">! Ref&lt;ScriptArguments&gt; createScriptArguments(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame, unsigned skipArgumentCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt; arguments;
<span class="line-modified">!     size_t argumentCount = callFrame-&gt;argumentCount();</span>
      for (size_t i = skipArgumentCount; i &lt; argumentCount; ++i)
<span class="line-modified">!         arguments.append({ vm, callFrame-&gt;uncheckedArgument(i) });</span>
<span class="line-modified">!     return ScriptArguments::create(globalObject, WTFMove(arguments));</span>
  }
  
  } // namespace Inspector
</pre>
<center><a href="ScriptCallStack.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptCallStackFactory.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
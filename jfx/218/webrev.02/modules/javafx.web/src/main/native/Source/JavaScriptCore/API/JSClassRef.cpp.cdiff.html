<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSClassRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCallbackObjectFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSClassRef.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 145,35 ***</span>
              staticFunctions-&gt;add(it-&gt;key-&gt;isolatedCopy(), makeUnique&lt;StaticFunctionEntry&gt;(it-&gt;value-&gt;callAsFunction, it-&gt;value-&gt;attributes));
          }
      }
  }
  
<span class="line-modified">! OpaqueJSClassContextData&amp; OpaqueJSClass::contextData(ExecState* exec)</span>
  {
<span class="line-modified">!     std::unique_ptr&lt;OpaqueJSClassContextData&gt;&amp; contextData = exec-&gt;lexicalGlobalObject()-&gt;opaqueJSClassData().add(this, nullptr).iterator-&gt;value;</span>
      if (!contextData)
<span class="line-modified">!         contextData = makeUnique&lt;OpaqueJSClassContextData&gt;(exec-&gt;vm(), this);</span>
      return *contextData;
  }
  
  String OpaqueJSClass::className()
  {
      // Make a deep copy, so that the caller has no chance to put the original into AtomStringTable.
      return m_className.isolatedCopy();
  }
  
<span class="line-modified">! OpaqueJSClassStaticValuesTable* OpaqueJSClass::staticValues(JSC::ExecState* exec)</span>
  {
<span class="line-modified">!     return contextData(exec).staticValues.get();</span>
  }
  
<span class="line-modified">! OpaqueJSClassStaticFunctionsTable* OpaqueJSClass::staticFunctions(JSC::ExecState* exec)</span>
  {
<span class="line-modified">!     return contextData(exec).staticFunctions.get();</span>
  }
  
<span class="line-modified">! JSObject* OpaqueJSClass::prototype(ExecState* exec)</span>
  {
      /* Class (C++) and prototype (JS) inheritance are parallel, so:
       *     (C++)      |        (JS)
       *   ParentClass  |   ParentClassPrototype
       *       ^        |          ^
<span class="line-new-header">--- 145,35 ---</span>
              staticFunctions-&gt;add(it-&gt;key-&gt;isolatedCopy(), makeUnique&lt;StaticFunctionEntry&gt;(it-&gt;value-&gt;callAsFunction, it-&gt;value-&gt;attributes));
          }
      }
  }
  
<span class="line-modified">! OpaqueJSClassContextData&amp; OpaqueJSClass::contextData(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     std::unique_ptr&lt;OpaqueJSClassContextData&gt;&amp; contextData = globalObject-&gt;opaqueJSClassData().add(this, nullptr).iterator-&gt;value;</span>
      if (!contextData)
<span class="line-modified">!         contextData = makeUnique&lt;OpaqueJSClassContextData&gt;(globalObject-&gt;vm(), this);</span>
      return *contextData;
  }
  
  String OpaqueJSClass::className()
  {
      // Make a deep copy, so that the caller has no chance to put the original into AtomStringTable.
      return m_className.isolatedCopy();
  }
  
<span class="line-modified">! OpaqueJSClassStaticValuesTable* OpaqueJSClass::staticValues(JSC::JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     return contextData(globalObject).staticValues.get();</span>
  }
  
<span class="line-modified">! OpaqueJSClassStaticFunctionsTable* OpaqueJSClass::staticFunctions(JSC::JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     return contextData(globalObject).staticFunctions.get();</span>
  }
  
<span class="line-modified">! JSObject* OpaqueJSClass::prototype(JSGlobalObject* globalObject)</span>
  {
      /* Class (C++) and prototype (JS) inheritance are parallel, so:
       *     (C++)      |        (JS)
       *   ParentClass  |   ParentClassPrototype
       *       ^        |          ^
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,20 ***</span>
       */
  
      if (!prototypeClass)
          return 0;
  
<span class="line-modified">!     OpaqueJSClassContextData&amp; jsClassData = contextData(exec);</span>
  
      if (JSObject* prototype = jsClassData.cachedPrototype.get())
          return prototype;
  
      // Recursive, but should be good enough for our purposes
<span class="line-modified">!     JSObject* prototype = JSCallbackObject&lt;JSDestructibleObject&gt;::create(exec, exec-&gt;lexicalGlobalObject(), exec-&gt;lexicalGlobalObject()-&gt;callbackObjectStructure(), prototypeClass, &amp;jsClassData); // set jsClassData as the object&#39;s private data, so it can clear our reference on destruction</span>
      if (parentClass) {
<span class="line-modified">!         if (JSObject* parentPrototype = parentClass-&gt;prototype(exec))</span>
<span class="line-modified">!             prototype-&gt;setPrototypeDirect(exec-&gt;vm(), parentPrototype);</span>
      }
  
      jsClassData.cachedPrototype = Weak&lt;JSObject&gt;(prototype);
      return prototype;
  }
<span class="line-new-header">--- 182,20 ---</span>
       */
  
      if (!prototypeClass)
          return 0;
  
<span class="line-modified">!     OpaqueJSClassContextData&amp; jsClassData = contextData(globalObject);</span>
  
      if (JSObject* prototype = jsClassData.cachedPrototype.get())
          return prototype;
  
      // Recursive, but should be good enough for our purposes
<span class="line-modified">!     JSObject* prototype = JSCallbackObject&lt;JSNonFinalObject&gt;::create(globalObject, globalObject-&gt;callbackObjectStructure(), prototypeClass, &amp;jsClassData); // set jsClassData as the object&#39;s private data, so it can clear our reference on destruction</span>
      if (parentClass) {
<span class="line-modified">!         if (JSObject* parentPrototype = parentClass-&gt;prototype(globalObject))</span>
<span class="line-modified">!             prototype-&gt;setPrototypeDirect(globalObject-&gt;vm(), parentPrototype);</span>
      }
  
      jsClassData.cachedPrototype = Weak&lt;JSObject&gt;(prototype);
      return prototype;
  }
</pre>
<center><a href="JSCallbackObjectFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
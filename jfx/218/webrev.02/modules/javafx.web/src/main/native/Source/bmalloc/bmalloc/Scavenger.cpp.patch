diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp
@@ -28,10 +28,11 @@
 #include "AllIsoHeapsInlines.h"
 #include "AvailableMemory.h"
 #include "BulkDecommit.h"
 #include "Environment.h"
 #include "Heap.h"
+#include "IsoHeapImplInlines.h"
 #if BOS(DARWIN)
 #import <dispatch/dispatch.h>
 #import <mach/host_info.h>
 #import <mach/mach.h>
 #import <mach/mach_error.h>
@@ -65,11 +66,11 @@
     bool printed { false };
 };
 
 DEFINE_STATIC_PER_PROCESS_STORAGE(Scavenger);
 
-Scavenger::Scavenger(std::lock_guard<Mutex>&)
+Scavenger::Scavenger(const LockHolder&)
 {
     BASSERT(!Environment::get()->isDebugHeapEnabled());
 
 #if BOS(DARWIN)
     auto queue = dispatch_queue_create("WebKit Malloc Memory Pressure Handler", DISPATCH_QUEUE_SERIAL);
@@ -78,34 +79,38 @@
         scavenge();
     });
     dispatch_resume(m_pressureHandlerDispatchSource);
     dispatch_release(queue);
 #endif
+#if BUSE(PARTIAL_SCAVENGE)
+    m_waitTime = std::chrono::milliseconds(m_isInMiniMode ? 200 : 2000);
+#else
     m_waitTime = std::chrono::milliseconds(10);
+#endif
 
     m_thread = std::thread(&threadEntryPoint, this);
 }
 
 void Scavenger::run()
 {
-    std::lock_guard<Mutex> lock(mutex());
-    runHoldingLock();
+    LockHolder lock(mutex());
+    run(lock);
 }
 
-void Scavenger::runHoldingLock()
+void Scavenger::run(const LockHolder&)
 {
     m_state = State::Run;
     m_condition.notify_all();
 }
 
 void Scavenger::runSoon()
 {
-    std::lock_guard<Mutex> lock(mutex());
-    runSoonHoldingLock();
+    LockHolder lock(mutex());
+    runSoon(lock);
 }
 
-void Scavenger::runSoonHoldingLock()
+void Scavenger::runSoon(const LockHolder&)
 {
     if (willRunSoon())
         return;
     m_state = State::RunSoon;
     m_condition.notify_all();
@@ -117,15 +122,15 @@
     m_isProbablyGrowing = true;
 }
 
 void Scavenger::scheduleIfUnderMemoryPressure(size_t bytes)
 {
-    std::lock_guard<Mutex> lock(mutex());
-    scheduleIfUnderMemoryPressureHoldingLock(bytes);
+    LockHolder lock(mutex());
+    scheduleIfUnderMemoryPressure(lock, bytes);
 }
 
-void Scavenger::scheduleIfUnderMemoryPressureHoldingLock(size_t bytes)
+void Scavenger::scheduleIfUnderMemoryPressure(const LockHolder& lock, size_t bytes)
 {
     m_scavengerBytes += bytes;
     if (m_scavengerBytes < scavengerBytesPerMemoryPressureCheck)
         return;
 
@@ -136,23 +141,23 @@
 
     if (!isUnderMemoryPressure())
         return;
 
     m_isProbablyGrowing = false;
-    runHoldingLock();
+    run(lock);
 }
 
 void Scavenger::schedule(size_t bytes)
 {
-    std::lock_guard<Mutex> lock(mutex());
-    scheduleIfUnderMemoryPressureHoldingLock(bytes);
+    LockHolder lock(mutex());
+    scheduleIfUnderMemoryPressure(lock, bytes);
 
     if (willRunSoon())
         return;
 
     m_isProbablyGrowing = false;
-    runSoonHoldingLock();
+    runSoon(lock);
 }
 
 inline void dumpStats()
 {
     auto dump = [] (auto* string, auto size) {
@@ -172,24 +177,32 @@
     dump("bmalloc-footprint", Scavenger::get()->footprint());
 }
 
 std::chrono::milliseconds Scavenger::timeSinceLastFullScavenge()
 {
-    std::unique_lock<Mutex> lock(mutex());
+    UniqueLockHolder lock(mutex());
     return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - m_lastFullScavengeTime);
 }
 
+#if BUSE(PARTIAL_SCAVENGE)
+std::chrono::milliseconds Scavenger::timeSinceLastPartialScavenge()
+{
+    UniqueLockHolder lock(mutex());
+    return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - m_lastPartialScavengeTime);
+}
+#endif
+
 void Scavenger::enableMiniMode()
 {
     m_isInMiniMode = true; // We just store to this racily. The scavenger thread will eventually pick up the right value.
     if (m_state == State::RunSoon)
         run();
 }
 
 void Scavenger::scavenge()
 {
-    std::unique_lock<Mutex> lock(m_scavengingMutex);
+    UniqueLockHolder lock(m_scavengingMutex);
 
     if (verbose) {
         fprintf(stderr, "--------------------------------\n");
         fprintf(stderr, "--before scavenging--\n");
         dumpStats();
@@ -198,31 +211,39 @@
     {
         BulkDecommit decommitter;
 
         {
             PrintTime printTime("\nfull scavenge under lock time");
+#if !BUSE(PARTIAL_SCAVENGE)
             size_t deferredDecommits = 0;
-            std::lock_guard<Mutex> lock(Heap::mutex());
+#endif
+            LockHolder lock(Heap::mutex());
             for (unsigned i = numHeaps; i--;) {
                 if (!isActiveHeapKind(static_cast<HeapKind>(i)))
                     continue;
+#if BUSE(PARTIAL_SCAVENGE)
+                PerProcess<PerHeapKind<Heap>>::get()->at(i).scavenge(lock, decommitter);
+#else
                 PerProcess<PerHeapKind<Heap>>::get()->at(i).scavenge(lock, decommitter, deferredDecommits);
+#endif
             }
             decommitter.processEager();
 
+#if !BUSE(PARTIAL_SCAVENGE)
             if (deferredDecommits)
                 m_state = State::RunSoon;
+#endif
         }
 
         {
             PrintTime printTime("full scavenge lazy decommit time");
             decommitter.processLazy();
         }
 
         {
             PrintTime printTime("full scavenge mark all as eligible time");
-            std::lock_guard<Mutex> lock(Heap::mutex());
+            LockHolder lock(Heap::mutex());
             for (unsigned i = numHeaps; i--;) {
                 if (!isActiveHeapKind(static_cast<HeapKind>(i)))
                     continue;
                 PerProcess<PerHeapKind<Heap>>::get()->at(i).markAllLargeAsEligibile(lock);
             }
@@ -244,20 +265,89 @@
         dumpStats();
         fprintf(stderr, "--------------------------------\n");
     }
 
     {
-        std::unique_lock<Mutex> lock(mutex());
+        UniqueLockHolder lock(mutex());
         m_lastFullScavengeTime = std::chrono::steady_clock::now();
     }
 }
 
+#if BUSE(PARTIAL_SCAVENGE)
+void Scavenger::partialScavenge()
+{
+    UniqueLockHolder lock(m_scavengingMutex);
+
+    if (verbose) {
+        fprintf(stderr, "--------------------------------\n");
+        fprintf(stderr, "--before partial scavenging--\n");
+        dumpStats();
+    }
+
+    {
+        BulkDecommit decommitter;
+        {
+            PrintTime printTime("\npartialScavenge under lock time");
+            LockHolder lock(Heap::mutex());
+            for (unsigned i = numHeaps; i--;) {
+                if (!isActiveHeapKind(static_cast<HeapKind>(i)))
+                    continue;
+                Heap& heap = PerProcess<PerHeapKind<Heap>>::get()->at(i);
+                size_t freeableMemory = heap.freeableMemory(lock);
+                if (freeableMemory < 4 * MB)
+                    continue;
+                heap.scavengeToHighWatermark(lock, decommitter);
+            }
+
+            decommitter.processEager();
+        }
+
+        {
+            PrintTime printTime("partialScavenge lazy decommit time");
+            decommitter.processLazy();
+        }
+
+        {
+            PrintTime printTime("partialScavenge mark all as eligible time");
+            LockHolder lock(Heap::mutex());
+            for (unsigned i = numHeaps; i--;) {
+                if (!isActiveHeapKind(static_cast<HeapKind>(i)))
+                    continue;
+                Heap& heap = PerProcess<PerHeapKind<Heap>>::get()->at(i);
+                heap.markAllLargeAsEligibile(lock);
+            }
+        }
+    }
+
+    {
+        RELEASE_BASSERT(!m_deferredDecommits.size());
+        AllIsoHeaps::get()->forEach(
+            [&] (IsoHeapImplBase& heap) {
+                heap.scavengeToHighWatermark(m_deferredDecommits);
+            });
+        IsoHeapImplBase::finishScavenging(m_deferredDecommits);
+        m_deferredDecommits.shrink(0);
+    }
+
+    if (verbose) {
+        fprintf(stderr, "--after partial scavenging--\n");
+        dumpStats();
+        fprintf(stderr, "--------------------------------\n");
+    }
+
+    {
+        UniqueLockHolder lock(mutex());
+        m_lastPartialScavengeTime = std::chrono::steady_clock::now();
+    }
+}
+#endif
+
 size_t Scavenger::freeableMemory()
 {
     size_t result = 0;
     {
-        std::lock_guard<Mutex> lock(Heap::mutex());
+        LockHolder lock(Heap::mutex());
         for (unsigned i = numHeaps; i--;) {
             if (!isActiveHeapKind(static_cast<HeapKind>(i)))
                 continue;
             result += PerProcess<PerHeapKind<Heap>>::get()->at(i).freeableMemory(lock);
         }
@@ -310,16 +400,16 @@
     // We require any state change while we are sleeping to signal to our
     // condition variable and wake us up.
 
     while (true) {
         if (m_state == State::Sleep) {
-            std::unique_lock<Mutex> lock(mutex());
+            UniqueLockHolder lock(mutex());
             m_condition.wait(lock, [&]() { return m_state != State::Sleep; });
         }
 
         if (m_state == State::RunSoon) {
-            std::unique_lock<Mutex> lock(mutex());
+            UniqueLockHolder lock(mutex());
             m_condition.wait_for(lock, m_waitTime, [&]() { return m_state != State::RunSoon; });
         }
 
         m_state = State::Sleep;
 
@@ -330,10 +420,73 @@
             fprintf(stderr, "considering running scavenger\n");
             dumpStats();
             fprintf(stderr, "--------------------------------\n");
         }
 
+#if BUSE(PARTIAL_SCAVENGE)
+        enum class ScavengeMode {
+            None,
+            Partial,
+            Full
+        };
+
+        size_t freeableMemory = this->freeableMemory();
+
+        ScavengeMode scavengeMode = [&] {
+            auto timeSinceLastFullScavenge = this->timeSinceLastFullScavenge();
+            auto timeSinceLastPartialScavenge = this->timeSinceLastPartialScavenge();
+            auto timeSinceLastScavenge = std::min(timeSinceLastPartialScavenge, timeSinceLastFullScavenge);
+
+            if (isUnderMemoryPressure() && freeableMemory > 1 * MB && timeSinceLastScavenge > std::chrono::milliseconds(5))
+                return ScavengeMode::Full;
+
+            if (!m_isProbablyGrowing) {
+                if (timeSinceLastFullScavenge < std::chrono::milliseconds(1000) && !m_isInMiniMode)
+                    return ScavengeMode::Partial;
+                return ScavengeMode::Full;
+            }
+
+            if (m_isInMiniMode) {
+                if (timeSinceLastFullScavenge < std::chrono::milliseconds(200))
+                    return ScavengeMode::Partial;
+                return ScavengeMode::Full;
+            }
+
+#if BCPU(X86_64)
+            auto partialScavengeInterval = std::chrono::milliseconds(12000);
+#else
+            auto partialScavengeInterval = std::chrono::milliseconds(8000);
+#endif
+            if (timeSinceLastScavenge < partialScavengeInterval) {
+                // Rate limit partial scavenges.
+                return ScavengeMode::None;
+            }
+            if (freeableMemory < 25 * MB)
+                return ScavengeMode::None;
+            if (5 * freeableMemory < footprint())
+                return ScavengeMode::None;
+            return ScavengeMode::Partial;
+        }();
+
+        m_isProbablyGrowing = false;
+
+        switch (scavengeMode) {
+        case ScavengeMode::None: {
+            runSoon();
+            break;
+        }
+        case ScavengeMode::Partial: {
+            partialScavenge();
+            runSoon();
+            break;
+        }
+        case ScavengeMode::Full: {
+            scavenge();
+            break;
+        }
+        }
+#else
         std::chrono::steady_clock::time_point start { std::chrono::steady_clock::now() };
 
         scavenge();
 
         auto timeSpentScavenging = std::chrono::steady_clock::now() - start;
@@ -341,24 +494,21 @@
         if (verbose) {
             fprintf(stderr, "time spent scavenging %lfms\n",
                 static_cast<double>(std::chrono::duration_cast<std::chrono::microseconds>(timeSpentScavenging).count()) / 1000);
         }
 
-        std::chrono::milliseconds newWaitTime;
-
-        if (m_isInMiniMode) {
-            timeSpentScavenging *= 50;
-            newWaitTime = std::chrono::duration_cast<std::chrono::milliseconds>(timeSpentScavenging);
-            newWaitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(25)), std::chrono::milliseconds(500));
-        } else {
+        // FIXME: We need to investigate mini-mode's adjustment.
+        // https://bugs.webkit.org/show_bug.cgi?id=203987
+        if (!m_isInMiniMode) {
             timeSpentScavenging *= 150;
-            newWaitTime = std::chrono::duration_cast<std::chrono::milliseconds>(timeSpentScavenging);
+            std::chrono::milliseconds newWaitTime = std::chrono::duration_cast<std::chrono::milliseconds>(timeSpentScavenging);
             m_waitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(100)), std::chrono::milliseconds(10000));
         }
 
         if (verbose)
             fprintf(stderr, "new wait time %lldms\n", static_cast<long long int>(m_waitTime.count()));
+#endif
     }
 }
 
 void Scavenger::setThreadName(const char* name)
 {

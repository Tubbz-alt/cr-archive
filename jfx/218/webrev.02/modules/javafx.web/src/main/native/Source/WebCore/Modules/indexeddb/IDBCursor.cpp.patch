diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBCursor.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBCursor.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBCursor.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBCursor.cpp
@@ -60,28 +60,28 @@
 
 IDBCursor::IDBCursor(IDBObjectStore& objectStore, const IDBCursorInfo& info)
     : m_info(info)
     , m_source(&objectStore)
 {
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 }
 
 IDBCursor::IDBCursor(IDBIndex& index, const IDBCursorInfo& info)
     : m_info(info)
     , m_source(&index)
 {
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 }
 
 IDBCursor::~IDBCursor()
 {
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 }
 
 bool IDBCursor::sourcesDeleted() const
 {
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     return WTF::switchOn(m_source,
         [] (const RefPtr<IDBObjectStore>& objectStore) { return objectStore->isDeleted(); },
         [] (const RefPtr<IDBIndex>& index) { return index->isDeleted() || index->objectStore().isDeleted(); }
     );
@@ -95,18 +95,18 @@
     );
 }
 
 IDBTransaction& IDBCursor::transaction() const
 {
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
     return effectiveObjectStore().transaction();
 }
 
-ExceptionOr<Ref<IDBRequest>> IDBCursor::update(ExecState& state, JSValue value)
+ExceptionOr<Ref<IDBRequest>> IDBCursor::update(JSGlobalObject& state, JSValue value)
 {
     LOG(IndexedDB, "IDBCursor::update");
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     if (sourcesDeleted())
         return Exception { InvalidStateError, "Failed to execute 'update' on 'IDBCursor': The cursor's source or effective object store has been deleted."_s };
 
     if (!transaction().isActive())
@@ -142,11 +142,11 @@
 }
 
 ExceptionOr<void> IDBCursor::advance(unsigned count)
 {
     LOG(IndexedDB, "IDBCursor::advance");
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     if (!m_request)
         return Exception { InvalidStateError };
 
     if (!count)
@@ -166,11 +166,11 @@
     uncheckedIterateCursor(IDBKeyData(), count);
 
     return { };
 }
 
-ExceptionOr<void> IDBCursor::continuePrimaryKey(ExecState& state, JSValue keyValue, JSValue primaryKeyValue)
+ExceptionOr<void> IDBCursor::continuePrimaryKey(JSGlobalObject& state, JSValue keyValue, JSValue primaryKeyValue)
 {
     if (!m_request)
         return Exception { InvalidStateError };
 
     if (!transaction().isActive())
@@ -218,11 +218,11 @@
     uncheckedIterateCursor(keyData, primaryKeyData);
 
     return { };
 }
 
-ExceptionOr<void> IDBCursor::continueFunction(ExecState& execState, JSValue keyValue)
+ExceptionOr<void> IDBCursor::continueFunction(JSGlobalObject& execState, JSValue keyValue)
 {
     RefPtr<IDBKey> key;
     if (!keyValue.isUndefined())
         key = scriptValueToIDBKey(execState, keyValue);
 
@@ -230,11 +230,11 @@
 }
 
 ExceptionOr<void> IDBCursor::continueFunction(const IDBKeyData& key)
 {
     LOG(IndexedDB, "IDBCursor::continueFunction (to key %s)", key.loggingString().utf8().data());
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     if (!m_request)
         return Exception { InvalidStateError };
 
     if (!transaction().isActive())
@@ -265,29 +265,29 @@
 }
 
 void IDBCursor::uncheckedIterateCursor(const IDBKeyData& key, unsigned count)
 {
     ASSERT(m_request);
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     m_request->willIterateCursor(*this);
     transaction().iterateCursor(*this, { key, { }, count });
 }
 
 void IDBCursor::uncheckedIterateCursor(const IDBKeyData& key, const IDBKeyData& primaryKey)
 {
     ASSERT(m_request);
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     m_request->willIterateCursor(*this);
     transaction().iterateCursor(*this, { key, primaryKey, 0 });
 }
 
-ExceptionOr<Ref<WebCore::IDBRequest>> IDBCursor::deleteFunction(ExecState& state)
+ExceptionOr<Ref<WebCore::IDBRequest>> IDBCursor::deleteFunction(JSGlobalObject& state)
 {
     LOG(IndexedDB, "IDBCursor::deleteFunction");
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     if (sourcesDeleted())
         return Exception { InvalidStateError, "Failed to execute 'delete' on 'IDBCursor': The cursor's source or effective object store has been deleted."_s };
 
     if (!transaction().isActive())
@@ -310,14 +310,14 @@
     request->setSource(*this);
 
     return request;
 }
 
-bool IDBCursor::setGetResult(IDBRequest& request, const IDBGetResult& getResult)
+bool IDBCursor::setGetResult(IDBRequest& request, const IDBGetResult& getResult, uint64_t operationID)
 {
     LOG(IndexedDB, "IDBCursor::setGetResult - current key %s", getResult.keyData().loggingString().substring(0, 100).utf8().data());
-    ASSERT(&effectiveObjectStore().transaction().database().originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(effectiveObjectStore().transaction().database().originThread()));
 
     auto* context = request.scriptExecutionContext();
     if (!context)
         return false;
 
@@ -347,10 +347,17 @@
     if (isKeyCursorWithValue()) {
         m_value = getResult.value();
         m_keyPath = getResult.keyPath();
     }
 
+    auto prefetchedRecords = getResult.prefetchedRecords();
+    if (!prefetchedRecords.isEmpty()) {
+        for (auto& record : prefetchedRecords)
+            m_prefetchedRecords.append(record);
+        m_prefetchOperationID = operationID;
+    }
+
     m_gotValue = true;
     return true;
 }
 
 void IDBCursor::clearWrappers()
@@ -358,8 +365,28 @@
     m_keyWrapper.clear();
     m_primaryKeyWrapper.clear();
     m_valueWrapper.clear();
 }
 
+Optional<IDBGetResult> IDBCursor::iterateWithPrefetchedRecords(unsigned count, uint64_t lastWriteOperationID)
+{
+    unsigned step = count > 0 ? count : 1;
+    if (step > m_prefetchedRecords.size() || m_prefetchOperationID <= lastWriteOperationID)
+        return WTF::nullopt;
+
+    while (--step)
+        m_prefetchedRecords.removeFirst();
+
+    auto record = m_prefetchedRecords.takeFirst();
+
+    LOG(IndexedDB, "IDBTransaction::iterateWithPrefetchedRecords consumes %u records", count > 0 ? count : 1);
+    return IDBGetResult(record.key, record.primaryKey, IDBValue(record.value), effectiveObjectStore().keyPath());
+}
+
+void IDBCursor::clearPrefetchedRecords()
+{
+    m_prefetchedRecords.clear();
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(INDEXED_DATABASE)

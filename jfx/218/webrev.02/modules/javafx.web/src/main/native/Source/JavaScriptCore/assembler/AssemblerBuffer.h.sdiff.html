<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractMacroAssembler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblerBufferWithConstantPool.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBuffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008, 2012, 2014 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 26 #pragma once
 27 
 28 #if ENABLE(ASSEMBLER)
 29 
 30 #include &quot;ExecutableAllocator.h&quot;
 31 #include &quot;JITCompilationEffort.h&quot;
 32 #include &quot;stdint.h&quot;
 33 #include &lt;string.h&gt;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/FastMalloc.h&gt;
 36 #if CPU(ARM64E)
 37 #include &lt;wtf/PtrTag.h&gt;
 38 #endif
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 #include &lt;wtf/UnalignedAccess.h&gt;
 41 
 42 namespace JSC {
 43 
 44     class LinkBuffer;
 45 


 46     struct AssemblerLabel {
 47         AssemblerLabel()
 48             : m_offset(std::numeric_limits&lt;uint32_t&gt;::max())
 49         {
 50         }
 51 
 52         explicit AssemblerLabel(uint32_t offset)
 53             : m_offset(offset)
 54         {
 55         }
 56 
 57         bool isSet() const { return (m_offset != std::numeric_limits&lt;uint32_t&gt;::max()); }
 58 
 59         AssemblerLabel labelAtOffset(int offset) const
 60         {
 61             return AssemblerLabel(m_offset + offset);
 62         }
 63 
 64         bool operator==(const AssemblerLabel&amp; other) const { return m_offset == other.m_offset; }
 65 
 66         uint32_t m_offset;
 67     };
 68 
 69     class AssemblerData {
 70         WTF_MAKE_NONCOPYABLE(AssemblerData);
<span class="line-modified"> 71         static const size_t InlineCapacity = 128;</span>
 72     public:
 73         AssemblerData()
 74             : m_buffer(m_inlineBuffer)
 75             , m_capacity(InlineCapacity)
 76         {
 77         }
 78 
 79         AssemblerData(size_t initialCapacity)
 80         {
 81             if (initialCapacity &lt;= InlineCapacity) {
 82                 m_capacity = InlineCapacity;
 83                 m_buffer = m_inlineBuffer;
 84             } else {
 85                 m_capacity = initialCapacity;
<span class="line-modified"> 86                 m_buffer = static_cast&lt;char*&gt;(fastMalloc(m_capacity));</span>
 87             }
 88         }
 89 
 90         AssemblerData(AssemblerData&amp;&amp; other)
 91         {
 92             if (other.isInlineBuffer()) {
 93                 ASSERT(other.m_capacity == InlineCapacity);
 94                 memcpy(m_inlineBuffer, other.m_inlineBuffer, InlineCapacity);
 95                 m_buffer = m_inlineBuffer;
 96             } else
 97                 m_buffer = other.m_buffer;
 98             m_capacity = other.m_capacity;
 99 
100             other.m_buffer = nullptr;
101             other.m_capacity = 0;
102         }
103 
104         AssemblerData&amp; operator=(AssemblerData&amp;&amp; other)
105         {
106             if (m_buffer &amp;&amp; !isInlineBuffer())
<span class="line-modified">107                 fastFree(m_buffer);</span>
108 
109             if (other.isInlineBuffer()) {
110                 ASSERT(other.m_capacity == InlineCapacity);
111                 memcpy(m_inlineBuffer, other.m_inlineBuffer, InlineCapacity);
112                 m_buffer = m_inlineBuffer;
113             } else
114                 m_buffer = other.m_buffer;
115             m_capacity = other.m_capacity;
116 
117             other.m_buffer = nullptr;
118             other.m_capacity = 0;
119             return *this;
120         }
121 
122         ~AssemblerData()
123         {
124             if (m_buffer &amp;&amp; !isInlineBuffer())
<span class="line-modified">125                 fastFree(m_buffer);</span>
126         }
127 
128         char* buffer() const { return m_buffer; }
129 
130         unsigned capacity() const { return m_capacity; }
131 
132         void grow(unsigned extraCapacity = 0)
133         {
134             m_capacity = m_capacity + m_capacity / 2 + extraCapacity;
135             if (isInlineBuffer()) {
<span class="line-modified">136                 m_buffer = static_cast&lt;char*&gt;(fastMalloc(m_capacity));</span>
137                 memcpy(m_buffer, m_inlineBuffer, InlineCapacity);
138             } else
<span class="line-modified">139                 m_buffer = static_cast&lt;char*&gt;(fastRealloc(m_buffer, m_capacity));</span>
140         }
141 
142     private:
143         bool isInlineBuffer() const { return m_buffer == m_inlineBuffer; }
144         char* m_buffer;
145         char m_inlineBuffer[InlineCapacity];
146         unsigned m_capacity;
147     };
148 
149 #if CPU(ARM64E)
150     class ARM64EHash {
151     public:
152         ARM64EHash() = default;
153         ALWAYS_INLINE void update(uint32_t value)
154         {
155             uint64_t input = value ^ m_hash;
156             uint64_t a = static_cast&lt;uint32_t&gt;(tagInt(input, static_cast&lt;PtrTag&gt;(0)) &gt;&gt; 39);
157             uint64_t b = tagInt(input, static_cast&lt;PtrTag&gt;(0xb7e151628aed2a6a)) &gt;&gt; 23;
158             m_hash = a ^ b;
159         }
</pre>
<hr />
<pre>
228         unsigned debugOffset() { return m_index; }
229 
230         AssemblerData&amp;&amp; releaseAssemblerData() { return WTFMove(m_storage); }
231 
232         // LocalWriter is a trick to keep the storage buffer and the index
233         // in memory while issuing multiple Stores.
234         // It is created in a block scope and its attribute can stay live
235         // between writes.
236         //
237         // LocalWriter *CANNOT* be mixed with other types of access to AssemblerBuffer.
238         // AssemblerBuffer cannot be used until its LocalWriter goes out of scope.
239 #if !CPU(ARM64) // If we ever need to use this on arm64e, we would need to make the checksum aware of this.
240         class LocalWriter {
241         public:
242             LocalWriter(AssemblerBuffer&amp; buffer, unsigned requiredSpace)
243                 : m_buffer(buffer)
244             {
245                 buffer.ensureSpace(requiredSpace);
246                 m_storageBuffer = buffer.m_storage.buffer();
247                 m_index = buffer.m_index;
<span class="line-modified">248 #if !defined(NDEBUG)</span>
249                 m_initialIndex = m_index;
250                 m_requiredSpace = requiredSpace;
251 #endif
252             }
253 
254             ~LocalWriter()
255             {
256                 ASSERT(m_index - m_initialIndex &lt;= m_requiredSpace);
257                 ASSERT(m_buffer.m_index == m_initialIndex);
258                 ASSERT(m_storageBuffer == m_buffer.m_storage.buffer());
259                 m_buffer.m_index = m_index;
260             }
261 
262             void putByteUnchecked(int8_t value) { putIntegralUnchecked(value); }
263             void putShortUnchecked(int16_t value) { putIntegralUnchecked(value); }
264             void putIntUnchecked(int32_t value) { putIntegralUnchecked(value); }
265             void putInt64Unchecked(int64_t value) { putIntegralUnchecked(value); }
266         private:
267             template&lt;typename IntegralType&gt;
268             void putIntegralUnchecked(IntegralType value)
269             {
270                 ASSERT(m_index + sizeof(IntegralType) &lt;= m_buffer.m_storage.capacity());
271                 WTF::unalignedStore&lt;IntegralType&gt;(m_storageBuffer + m_index, value);
272                 m_index += sizeof(IntegralType);
273             }
274             AssemblerBuffer&amp; m_buffer;
275             char* m_storageBuffer;
276             unsigned m_index;
<span class="line-modified">277 #if !defined(NDEBUG)</span>
278             unsigned m_initialIndex;
279             unsigned m_requiredSpace;
280 #endif
281         };
282 #endif // !CPU(ARM64)
283 
284 #if CPU(ARM64E)
285         ARM64EHash hash() const { return m_hash; }
286 #endif
287 
288 #if !CPU(ARM64) // If we were to define this on arm64e, we&#39;d need a way to update the hash as we write directly into the buffer.
289         void* data() const { return m_storage.buffer(); }
290 #endif
291 
292 
293     protected:
294         template&lt;typename IntegralType&gt;
295         void putIntegral(IntegralType value)
296         {
297             unsigned nextIndex = m_index + sizeof(IntegralType);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 26 #pragma once
 27 
 28 #if ENABLE(ASSEMBLER)
 29 
 30 #include &quot;ExecutableAllocator.h&quot;
 31 #include &quot;JITCompilationEffort.h&quot;
 32 #include &quot;stdint.h&quot;
 33 #include &lt;string.h&gt;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/FastMalloc.h&gt;
 36 #if CPU(ARM64E)
 37 #include &lt;wtf/PtrTag.h&gt;
 38 #endif
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 #include &lt;wtf/UnalignedAccess.h&gt;
 41 
 42 namespace JSC {
 43 
 44     class LinkBuffer;
 45 
<span class="line-added"> 46     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AssemblerData);</span>
<span class="line-added"> 47 </span>
 48     struct AssemblerLabel {
 49         AssemblerLabel()
 50             : m_offset(std::numeric_limits&lt;uint32_t&gt;::max())
 51         {
 52         }
 53 
 54         explicit AssemblerLabel(uint32_t offset)
 55             : m_offset(offset)
 56         {
 57         }
 58 
 59         bool isSet() const { return (m_offset != std::numeric_limits&lt;uint32_t&gt;::max()); }
 60 
 61         AssemblerLabel labelAtOffset(int offset) const
 62         {
 63             return AssemblerLabel(m_offset + offset);
 64         }
 65 
 66         bool operator==(const AssemblerLabel&amp; other) const { return m_offset == other.m_offset; }
 67 
 68         uint32_t m_offset;
 69     };
 70 
 71     class AssemblerData {
 72         WTF_MAKE_NONCOPYABLE(AssemblerData);
<span class="line-modified"> 73         static constexpr size_t InlineCapacity = 128;</span>
 74     public:
 75         AssemblerData()
 76             : m_buffer(m_inlineBuffer)
 77             , m_capacity(InlineCapacity)
 78         {
 79         }
 80 
 81         AssemblerData(size_t initialCapacity)
 82         {
 83             if (initialCapacity &lt;= InlineCapacity) {
 84                 m_capacity = InlineCapacity;
 85                 m_buffer = m_inlineBuffer;
 86             } else {
 87                 m_capacity = initialCapacity;
<span class="line-modified"> 88                 m_buffer = static_cast&lt;char*&gt;(AssemblerDataMalloc::malloc(m_capacity));</span>
 89             }
 90         }
 91 
 92         AssemblerData(AssemblerData&amp;&amp; other)
 93         {
 94             if (other.isInlineBuffer()) {
 95                 ASSERT(other.m_capacity == InlineCapacity);
 96                 memcpy(m_inlineBuffer, other.m_inlineBuffer, InlineCapacity);
 97                 m_buffer = m_inlineBuffer;
 98             } else
 99                 m_buffer = other.m_buffer;
100             m_capacity = other.m_capacity;
101 
102             other.m_buffer = nullptr;
103             other.m_capacity = 0;
104         }
105 
106         AssemblerData&amp; operator=(AssemblerData&amp;&amp; other)
107         {
108             if (m_buffer &amp;&amp; !isInlineBuffer())
<span class="line-modified">109                 AssemblerDataMalloc::free(m_buffer);</span>
110 
111             if (other.isInlineBuffer()) {
112                 ASSERT(other.m_capacity == InlineCapacity);
113                 memcpy(m_inlineBuffer, other.m_inlineBuffer, InlineCapacity);
114                 m_buffer = m_inlineBuffer;
115             } else
116                 m_buffer = other.m_buffer;
117             m_capacity = other.m_capacity;
118 
119             other.m_buffer = nullptr;
120             other.m_capacity = 0;
121             return *this;
122         }
123 
124         ~AssemblerData()
125         {
126             if (m_buffer &amp;&amp; !isInlineBuffer())
<span class="line-modified">127                 AssemblerDataMalloc::free(m_buffer);</span>
128         }
129 
130         char* buffer() const { return m_buffer; }
131 
132         unsigned capacity() const { return m_capacity; }
133 
134         void grow(unsigned extraCapacity = 0)
135         {
136             m_capacity = m_capacity + m_capacity / 2 + extraCapacity;
137             if (isInlineBuffer()) {
<span class="line-modified">138                 m_buffer = static_cast&lt;char*&gt;(AssemblerDataMalloc::malloc(m_capacity));</span>
139                 memcpy(m_buffer, m_inlineBuffer, InlineCapacity);
140             } else
<span class="line-modified">141                 m_buffer = static_cast&lt;char*&gt;(AssemblerDataMalloc::realloc(m_buffer, m_capacity));</span>
142         }
143 
144     private:
145         bool isInlineBuffer() const { return m_buffer == m_inlineBuffer; }
146         char* m_buffer;
147         char m_inlineBuffer[InlineCapacity];
148         unsigned m_capacity;
149     };
150 
151 #if CPU(ARM64E)
152     class ARM64EHash {
153     public:
154         ARM64EHash() = default;
155         ALWAYS_INLINE void update(uint32_t value)
156         {
157             uint64_t input = value ^ m_hash;
158             uint64_t a = static_cast&lt;uint32_t&gt;(tagInt(input, static_cast&lt;PtrTag&gt;(0)) &gt;&gt; 39);
159             uint64_t b = tagInt(input, static_cast&lt;PtrTag&gt;(0xb7e151628aed2a6a)) &gt;&gt; 23;
160             m_hash = a ^ b;
161         }
</pre>
<hr />
<pre>
230         unsigned debugOffset() { return m_index; }
231 
232         AssemblerData&amp;&amp; releaseAssemblerData() { return WTFMove(m_storage); }
233 
234         // LocalWriter is a trick to keep the storage buffer and the index
235         // in memory while issuing multiple Stores.
236         // It is created in a block scope and its attribute can stay live
237         // between writes.
238         //
239         // LocalWriter *CANNOT* be mixed with other types of access to AssemblerBuffer.
240         // AssemblerBuffer cannot be used until its LocalWriter goes out of scope.
241 #if !CPU(ARM64) // If we ever need to use this on arm64e, we would need to make the checksum aware of this.
242         class LocalWriter {
243         public:
244             LocalWriter(AssemblerBuffer&amp; buffer, unsigned requiredSpace)
245                 : m_buffer(buffer)
246             {
247                 buffer.ensureSpace(requiredSpace);
248                 m_storageBuffer = buffer.m_storage.buffer();
249                 m_index = buffer.m_index;
<span class="line-modified">250 #if ASSERT_ENABLED</span>
251                 m_initialIndex = m_index;
252                 m_requiredSpace = requiredSpace;
253 #endif
254             }
255 
256             ~LocalWriter()
257             {
258                 ASSERT(m_index - m_initialIndex &lt;= m_requiredSpace);
259                 ASSERT(m_buffer.m_index == m_initialIndex);
260                 ASSERT(m_storageBuffer == m_buffer.m_storage.buffer());
261                 m_buffer.m_index = m_index;
262             }
263 
264             void putByteUnchecked(int8_t value) { putIntegralUnchecked(value); }
265             void putShortUnchecked(int16_t value) { putIntegralUnchecked(value); }
266             void putIntUnchecked(int32_t value) { putIntegralUnchecked(value); }
267             void putInt64Unchecked(int64_t value) { putIntegralUnchecked(value); }
268         private:
269             template&lt;typename IntegralType&gt;
270             void putIntegralUnchecked(IntegralType value)
271             {
272                 ASSERT(m_index + sizeof(IntegralType) &lt;= m_buffer.m_storage.capacity());
273                 WTF::unalignedStore&lt;IntegralType&gt;(m_storageBuffer + m_index, value);
274                 m_index += sizeof(IntegralType);
275             }
276             AssemblerBuffer&amp; m_buffer;
277             char* m_storageBuffer;
278             unsigned m_index;
<span class="line-modified">279 #if ASSERT_ENABLED</span>
280             unsigned m_initialIndex;
281             unsigned m_requiredSpace;
282 #endif
283         };
284 #endif // !CPU(ARM64)
285 
286 #if CPU(ARM64E)
287         ARM64EHash hash() const { return m_hash; }
288 #endif
289 
290 #if !CPU(ARM64) // If we were to define this on arm64e, we&#39;d need a way to update the hash as we write directly into the buffer.
291         void* data() const { return m_storage.buffer(); }
292 #endif
293 
294 
295     protected:
296         template&lt;typename IntegralType&gt;
297         void putIntegral(IntegralType value)
298         {
299             unsigned nextIndex = m_index + sizeof(IntegralType);
</pre>
</td>
</tr>
</table>
<center><a href="AbstractMacroAssembler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblerBufferWithConstantPool.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
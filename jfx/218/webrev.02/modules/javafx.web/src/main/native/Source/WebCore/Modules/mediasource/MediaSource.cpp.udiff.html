<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/MediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../mediasession/WebMediaSessionManagerClient.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaSource.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/MediaSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -99,11 +99,11 @@</span>
  
  MediaSource::MediaSource(ScriptExecutionContext&amp; context)
      : ActiveDOMObject(&amp;context)
      , m_duration(MediaTime::invalidTime())
      , m_pendingSeekTime(MediaTime::invalidTime())
<span class="udiff-line-modified-removed">-     , m_asyncEventQueue(*this)</span>
<span class="udiff-line-modified-added">+     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))</span>
  #if !RELEASE_LOG_DISABLED
      , m_logger(downcast&lt;Document&gt;(context).logger())
  #endif
  {
      m_sourceBuffers = SourceBufferList::create(scriptExecutionContext());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -128,11 +128,11 @@</span>
  
      // ↳ If readyState is NOT set to &quot;closed&quot;
      //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing the user agent to give up trying
      //    to fetch the resource&quot; steps of the resource fetch algorithm&#39;s media data processing steps list.
      if (!isClosed()) {
<span class="udiff-line-modified-removed">-         m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkError);</span>
<span class="udiff-line-modified-added">+         m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkState::NetworkError);</span>
          return;
      }
  
      // ↳ Otherwise
      // 1. Set the media element&#39;s delaying-the-load-event-flag to false.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -241,11 +241,11 @@</span>
      // to play back that position&quot; step of the seek algorithm:
      // ↳ If new playback position is not in any TimeRange of HTMLMediaElement.buffered
      if (!hasBufferedTime(time)) {
          // 1. If the HTMLMediaElement.readyState attribute is greater than HAVE_METADATA,
          // then set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
<span class="udiff-line-modified-removed">-         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);</span>
<span class="udiff-line-modified-added">+         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
  
          // 2. The media element waits until an appendBuffer() or an appendStream() call causes the coded
          // frame processing algorithm to set the HTMLMediaElement.readyState attribute to a value greater
          // than HAVE_METADATA.
          m_private-&gt;waitForSeekCompleted();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -424,11 +424,11 @@</span>
      // 2.4.4 SourceBuffer Monitoring
      // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#buffer-monitoring
  
      // Note, the behavior if activeSourceBuffers is empty is undefined.
      if (!m_activeSourceBuffers) {
<span class="udiff-line-modified-removed">-         m_private-&gt;setReadyState(MediaPlayer::HaveNothing);</span>
<span class="udiff-line-modified-added">+         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveNothing);</span>
          return;
      }
  
      // ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING:
      if (mediaElement()-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -439,11 +439,11 @@</span>
      // ↳ If HTMLMediaElement.buffered does not contain a TimeRange for the current playback position:
      if (!hasCurrentTime()) {
          // 1. Set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
          // 2. If this is the first transition to HAVE_METADATA, then queue a task to fire a simple event
          // named loadedmetadata at the media element.
<span class="udiff-line-modified-removed">-         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);</span>
<span class="udiff-line-modified-added">+         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
  
          // 3. Abort these steps.
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -454,11 +454,11 @@</span>
          return sourceBuffer-&gt;canPlayThroughRange(*ranges);
      })) {
          // 1. Set the HTMLMediaElement.readyState attribute to HAVE_ENOUGH_DATA.
          // 2. Queue a task to fire a simple event named canplaythrough at the media element.
          // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
<span class="udiff-line-modified-removed">-         m_private-&gt;setReadyState(MediaPlayer::HaveEnoughData);</span>
<span class="udiff-line-modified-added">+         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveEnoughData);</span>
  
          if (m_pendingSeekTime.isValid())
              completeSeek();
  
          // 4. Abort these steps.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -469,11 +469,11 @@</span>
      //  position and some time beyond the current playback position, then run the following steps:
      if (hasFutureTime()) {
          // 1. Set the HTMLMediaElement.readyState attribute to HAVE_FUTURE_DATA.
          // 2. If the previous value of HTMLMediaElement.readyState was less than HAVE_FUTURE_DATA, then queue a task to fire a simple event named canplay at the media element.
          // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
<span class="udiff-line-modified-removed">-         m_private-&gt;setReadyState(MediaPlayer::HaveFutureData);</span>
<span class="udiff-line-modified-added">+         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveFutureData);</span>
  
          if (m_pendingSeekTime.isValid())
              completeSeek();
  
          // 4. Abort these steps.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -486,11 +486,11 @@</span>
      // 1. Set the HTMLMediaElement.readyState attribute to HAVE_CURRENT_DATA.
      // 2. If this is the first transition to HAVE_CURRENT_DATA, then queue a task to fire a simple
      // event named loadeddata at the media element.
      // 3. Playback is suspended at this point since the media element doesn&#39;t have enough data to
      // advance the media timeline.
<span class="udiff-line-modified-removed">-     m_private-&gt;setReadyState(MediaPlayer::HaveCurrentData);</span>
<span class="udiff-line-modified-added">+     m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveCurrentData);</span>
  
      if (m_pendingSeekTime.isValid())
          completeSeek();
  
      // 4. Abort these steps.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -635,33 +635,33 @@</span>
          if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
              //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
              //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing
              //    the user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
              //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
<span class="udiff-line-modified-removed">-             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::NetworkError);</span>
<span class="udiff-line-modified-added">+             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::NetworkState::NetworkError);</span>
          } else {
              //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
              //    Run the &quot;If the connection is interrupted after some media data has been received, causing the
              //    user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
              //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
<span class="udiff-line-modified-removed">-             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkError);</span>
<span class="udiff-line-modified-added">+             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkState::NetworkError);</span>
          }
      } else {
          // ↳ If error is set to &quot;decode&quot;
          ASSERT(error == EndOfStreamError::Decode);
          ASSERT(m_mediaElement);
          if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
              //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
              //    Run the &quot;If the media data can be fetched but is found by inspection to be in an unsupported
              //    format, or can otherwise not be rendered at all&quot; steps of the resource fetch algorithm.
              //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
<span class="udiff-line-modified-removed">-             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::FormatError);</span>
<span class="udiff-line-modified-added">+             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
          } else {
              //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
              //    Run the media data is corrupted steps of the resource fetch algorithm.
              //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
<span class="udiff-line-modified-removed">-             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::DecodeError);</span>
<span class="udiff-line-modified-added">+             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkState::DecodeError);</span>
          }
      }
  }
  
  ExceptionOr&lt;Ref&lt;SourceBuffer&gt;&gt; MediaSource::addSourceBuffer(const String&amp; type)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -734,22 +734,22 @@</span>
      buffer.abortIfUpdating();
  
      ASSERT(scriptExecutionContext());
      if (!scriptExecutionContext()-&gt;activeDOMObjectsAreStopped()) {
          // 4. Let SourceBuffer audioTracks list equal the AudioTrackList object returned by sourceBuffer.audioTracks.
<span class="udiff-line-modified-removed">-         auto&amp; audioTracks = buffer.audioTracks();</span>
<span class="udiff-line-modified-added">+         auto* audioTracks = buffer.audioTracksIfExists();</span>
  
          // 5. If the SourceBuffer audioTracks list is not empty, then run the following steps:
<span class="udiff-line-modified-removed">-         if (audioTracks.length()) {</span>
<span class="udiff-line-modified-added">+         if (audioTracks &amp;&amp; audioTracks-&gt;length()) {</span>
              // 5.1 Let HTMLMediaElement audioTracks list equal the AudioTrackList object returned by the audioTracks
              // attribute on the HTMLMediaElement.
              // 5.2 Let the removed enabled audio track flag equal false.
              bool removedEnabledAudioTrack = false;
  
              // 5.3 For each AudioTrack object in the SourceBuffer audioTracks list, run the following steps:
<span class="udiff-line-modified-removed">-             while (audioTracks.length()) {</span>
<span class="udiff-line-modified-removed">-                 auto&amp; track = *audioTracks.lastItem();</span>
<span class="udiff-line-modified-added">+             while (audioTracks-&gt;length()) {</span>
<span class="udiff-line-modified-added">+                 auto&amp; track = *audioTracks-&gt;lastItem();</span>
  
                  // 5.3.1 Set the sourceBuffer attribute on the AudioTrack object to null.
                  track.setSourceBuffer(nullptr);
  
                  // 5.3.2 If the enabled attribute on the AudioTrack object is true, then set the removed enabled
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -764,32 +764,32 @@</span>
                      mediaElement()-&gt;removeAudioTrack(track);
  
                  // 5.3.5 Remove the AudioTrack object from the SourceBuffer audioTracks list.
                  // 5.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
                  // cancelable, and that uses the TrackEvent interface, at the SourceBuffer audioTracks list.
<span class="udiff-line-modified-removed">-                 audioTracks.remove(track);</span>
<span class="udiff-line-modified-added">+                 audioTracks-&gt;remove(track);</span>
              }
  
              // 5.4 If the removed enabled audio track flag equals true, then queue a task to fire a simple event
              // named change at the HTMLMediaElement audioTracks list.
              if (removedEnabledAudioTrack)
                  mediaElement()-&gt;ensureAudioTracks().scheduleChangeEvent();
          }
  
          // 6. Let SourceBuffer videoTracks list equal the VideoTrackList object returned by sourceBuffer.videoTracks.
<span class="udiff-line-modified-removed">-         auto&amp; videoTracks = buffer.videoTracks();</span>
<span class="udiff-line-modified-added">+         auto* videoTracks = buffer.videoTracksIfExists();</span>
  
          // 7. If the SourceBuffer videoTracks list is not empty, then run the following steps:
<span class="udiff-line-modified-removed">-         if (videoTracks.length()) {</span>
<span class="udiff-line-modified-added">+         if (videoTracks &amp;&amp; videoTracks-&gt;length()) {</span>
              // 7.1 Let HTMLMediaElement videoTracks list equal the VideoTrackList object returned by the videoTracks
              // attribute on the HTMLMediaElement.
              // 7.2 Let the removed selected video track flag equal false.
              bool removedSelectedVideoTrack = false;
  
              // 7.3 For each VideoTrack object in the SourceBuffer videoTracks list, run the following steps:
<span class="udiff-line-modified-removed">-             while (videoTracks.length()) {</span>
<span class="udiff-line-modified-removed">-                 auto&amp; track = *videoTracks.lastItem();</span>
<span class="udiff-line-modified-added">+             while (videoTracks-&gt;length()) {</span>
<span class="udiff-line-modified-added">+                 auto&amp; track = *videoTracks-&gt;lastItem();</span>
  
                  // 7.3.1 Set the sourceBuffer attribute on the VideoTrack object to null.
                  track.setSourceBuffer(nullptr);
  
                  // 7.3.2 If the selected attribute on the VideoTrack object is true, then set the removed selected
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -804,32 +804,32 @@</span>
                      mediaElement()-&gt;removeVideoTrack(track);
  
                  // 7.3.5 Remove the VideoTrack object from the SourceBuffer videoTracks list.
                  // 7.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
                  // cancelable, and that uses the TrackEvent interface, at the SourceBuffer videoTracks list.
<span class="udiff-line-modified-removed">-                 videoTracks.remove(track);</span>
<span class="udiff-line-modified-added">+                 videoTracks-&gt;remove(track);</span>
              }
  
              // 7.4 If the removed selected video track flag equals true, then queue a task to fire a simple event
              // named change at the HTMLMediaElement videoTracks list.
              if (removedSelectedVideoTrack)
                  mediaElement()-&gt;ensureVideoTracks().scheduleChangeEvent();
          }
  
          // 8. Let SourceBuffer textTracks list equal the TextTrackList object returned by sourceBuffer.textTracks.
<span class="udiff-line-modified-removed">-         auto&amp; textTracks = buffer.textTracks();</span>
<span class="udiff-line-modified-added">+         auto* textTracks = buffer.textTracksIfExists();</span>
  
          // 9. If the SourceBuffer textTracks list is not empty, then run the following steps:
<span class="udiff-line-modified-removed">-         if (textTracks.length()) {</span>
<span class="udiff-line-modified-added">+         if (textTracks &amp;&amp; textTracks-&gt;length()) {</span>
              // 9.1 Let HTMLMediaElement textTracks list equal the TextTrackList object returned by the textTracks
              // attribute on the HTMLMediaElement.
              // 9.2 Let the removed enabled text track flag equal false.
              bool removedEnabledTextTrack = false;
  
              // 9.3 For each TextTrack object in the SourceBuffer textTracks list, run the following steps:
<span class="udiff-line-modified-removed">-             while (textTracks.length()) {</span>
<span class="udiff-line-modified-removed">-                 auto&amp; track = *textTracks.lastItem();</span>
<span class="udiff-line-modified-added">+             while (textTracks-&gt;length()) {</span>
<span class="udiff-line-modified-added">+                 auto&amp; track = *textTracks-&gt;lastItem();</span>
  
                  // 9.3.1 Set the sourceBuffer attribute on the TextTrack object to null.
                  track.setSourceBuffer(nullptr);
  
                  // 9.3.2 If the mode attribute on the TextTrack object is set to &quot;showing&quot; or &quot;hidden&quot;, then
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -844,11 +844,11 @@</span>
                      mediaElement()-&gt;removeTextTrack(track);
  
                  // 9.3.5 Remove the TextTrack object from the SourceBuffer textTracks list.
                  // 9.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
                  // cancelable, and that uses the TrackEvent interface, at the SourceBuffer textTracks list.
<span class="udiff-line-modified-removed">-                 textTracks.remove(track);</span>
<span class="udiff-line-modified-added">+                 textTracks-&gt;remove(track);</span>
              }
  
              // 9.4 If the removed enabled text track flag equals true, then queue a task to fire a simple event
              // named change at the HTMLMediaElement textTracks list.
              if (removedEnabledTextTrack)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -892,13 +892,13 @@</span>
      parameters.type = contentType;
      parameters.isMediaSource = true;
      MediaPlayer::SupportsType supported = MediaPlayer::supportsType(parameters);
  
      if (codecs.isEmpty())
<span class="udiff-line-modified-removed">-         return supported != MediaPlayer::IsNotSupported;</span>
<span class="udiff-line-modified-added">+         return supported != MediaPlayer::SupportsType::IsNotSupported;</span>
  
<span class="udiff-line-modified-removed">-     return supported == MediaPlayer::IsSupported;</span>
<span class="udiff-line-modified-added">+     return supported == MediaPlayer::SupportsType::IsSupported;</span>
  }
  
  bool MediaSource::isOpen() const
  {
      return readyState() == ReadyState::Open;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -954,11 +954,11 @@</span>
      if (m_mediaElement)
          return false;
  
      ASSERT(isClosed());
  
<span class="udiff-line-modified-removed">-     m_mediaElement = &amp;element;</span>
<span class="udiff-line-modified-added">+     m_mediaElement = makeWeakPtr(&amp;element);</span>
      return true;
  }
  
  void MediaSource::openIfInEndedState()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -971,53 +971,24 @@</span>
      m_private-&gt;unmarkEndOfStream();
  }
  
  bool MediaSource::hasPendingActivity() const
  {
<span class="udiff-line-modified-removed">-     return m_private || m_asyncEventQueue.hasPendingEvents()</span>
<span class="udiff-line-modified-added">+     return m_private || m_asyncEventQueue-&gt;hasPendingEvents()</span>
          || ActiveDOMObject::hasPendingActivity();
  }
  
<span class="udiff-line-removed">- void MediaSource::suspend(ReasonForSuspension reason)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ALWAYS_LOG(LOGIDENTIFIER, static_cast&lt;int&gt;(reason));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     switch (reason) {</span>
<span class="udiff-line-removed">-     case ReasonForSuspension::PageCache:</span>
<span class="udiff-line-removed">-     case ReasonForSuspension::PageWillBeSuspended:</span>
<span class="udiff-line-removed">-         m_asyncEventQueue.suspend();</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     case ReasonForSuspension::JavaScriptDebuggerPaused:</span>
<span class="udiff-line-removed">-     case ReasonForSuspension::WillDeferLoading:</span>
<span class="udiff-line-removed">-         // Do nothing, we don&#39;t pause media playback in these cases.</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MediaSource::resume()</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_asyncEventQueue.resume();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void MediaSource::stop()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
  
<span class="udiff-line-removed">-     m_asyncEventQueue.close();</span>
      if (m_mediaElement)
          m_mediaElement-&gt;detachMediaSource();
      m_readyState = ReadyState::Closed;
      m_private = nullptr;
  }
  
<span class="udiff-line-removed">- bool MediaSource::canSuspendForDocumentSuspension() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     return isClosed() &amp;&amp; !m_asyncEventQueue.hasPendingEvents();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  const char* MediaSource::activeDOMObjectName() const
  {
      return &quot;MediaSource&quot;;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1078,11 +1049,11 @@</span>
      DEBUG_LOG(LOGIDENTIFIER, &quot;scheduling &#39;&quot;, eventName, &quot;&#39;&quot;);
  
      auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No);
      event-&gt;setTarget(this);
  
<span class="udiff-line-modified-removed">-     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
<span class="udiff-line-modified-added">+     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
  }
  
  ScriptExecutionContext* MediaSource::scriptExecutionContext() const
  {
      return ActiveDOMObject::scriptExecutionContext();
</pre>
<center><a href="../mediasession/WebMediaSessionManagerClient.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaSource.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
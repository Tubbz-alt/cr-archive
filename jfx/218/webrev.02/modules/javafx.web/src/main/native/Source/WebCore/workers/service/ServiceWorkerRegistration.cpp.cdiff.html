<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerProvider.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerRegistration.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  #if ENABLE(SERVICE_WORKER)
  #include &quot;DOMWindow.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Event.h&quot;
  #include &quot;EventNames.h&quot;
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;Logging.h&quot;
  #include &quot;ServiceWorker.h&quot;
  #include &quot;ServiceWorkerContainer.h&quot;
  #include &quot;ServiceWorkerTypes.h&quot;
  #include &quot;WorkerGlobalScope.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,12 ***</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerRegistration);
  
<span class="line-removed">- const Seconds softUpdateDelay { 1_s };</span>
<span class="line-removed">- </span>
  Ref&lt;ServiceWorkerRegistration&gt; ServiceWorkerRegistration::getOrCreate(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; data)
  {
      if (auto* registration = container-&gt;registration(data.identifier)) {
          ASSERT(!registration-&gt;m_isStopped);
          return *registration;
<span class="line-new-header">--- 44,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,11 ***</span>
  
  ServiceWorkerRegistration::ServiceWorkerRegistration(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; registrationData)
      : ActiveDOMObject(&amp;context)
      , m_registrationData(WTFMove(registrationData))
      , m_container(WTFMove(container))
<span class="line-removed">-     , m_softUpdateTimer([this] { softUpdate(); })</span>
  {
      LOG(ServiceWorker, &quot;Creating registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
      suspendIfNeeded();
  
      if (m_registrationData.installingWorker)
<span class="line-new-header">--- 58,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,11 ***</span>
      REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;ServiceWorkerRegistration: ID %llu, installing: %llu, waiting: %llu, active: %llu&quot;, identifier().toUInt64(), m_installingWorker ? m_installingWorker-&gt;identifier().toUInt64() : 0, m_waitingWorker ? m_waitingWorker-&gt;identifier().toUInt64() : 0, m_activeWorker ? m_activeWorker-&gt;identifier().toUInt64() : 0);
  
      m_container-&gt;addRegistration(*this);
  
      relaxAdoptionRequirement();
<span class="line-removed">-     updatePendingActivityForEventDispatch();</span>
  }
  
  ServiceWorkerRegistration::~ServiceWorkerRegistration()
  {
      LOG(ServiceWorker, &quot;Deleting registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
<span class="line-new-header">--- 74,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,11 ***</span>
  ServiceWorker* ServiceWorkerRegistration::active()
  {
      return m_activeWorker.get();
  }
  
<span class="line-modified">! ServiceWorker* ServiceWorkerRegistration::getNewestWorker()</span>
  {
      if (m_installingWorker)
          return m_installingWorker.get();
      if (m_waitingWorker)
          return m_waitingWorker.get();
<span class="line-new-header">--- 98,11 ---</span>
  ServiceWorker* ServiceWorkerRegistration::active()
  {
      return m_activeWorker.get();
  }
  
<span class="line-modified">! ServiceWorker* ServiceWorkerRegistration::getNewestWorker() const</span>
  {
      if (m_installingWorker)
          return m_installingWorker.get();
      if (m_waitingWorker)
          return m_waitingWorker.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,32 ***</span>
  
      // FIXME: Support worker types.
      m_container-&gt;updateRegistration(m_registrationData.scopeURL, newestWorker-&gt;scriptURL(), WorkerType::Classic, WTFMove(promise));
  }
  
<span class="line-removed">- // To avoid scheduling many updates during a single page load, we do soft updates on a 1 second delay and keep delaying</span>
<span class="line-removed">- // as long as soft update requests keep coming. This seems to match Chrome&#39;s behavior.</span>
<span class="line-removed">- void ServiceWorkerRegistration::scheduleSoftUpdate()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_softUpdateTimer.isActive())</span>
<span class="line-removed">-         m_softUpdateTimer.stop();</span>
<span class="line-removed">-     m_softUpdateTimer.startOneShot(softUpdateDelay);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ServiceWorkerRegistration::softUpdate()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_isStopped)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* newestWorker = getNewestWorker();</span>
<span class="line-removed">-     if (!newestWorker)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // FIXME: Support worker types.</span>
<span class="line-removed">-     m_container-&gt;updateRegistration(m_registrationData.scopeURL, newestWorker-&gt;scriptURL(), WorkerType::Classic, nullptr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ServiceWorkerRegistration::unregister(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
      if (m_isStopped) {
          promise-&gt;reject(Exception(InvalidStateError));
          return;
<span class="line-new-header">--- 150,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,22 ***</span>
      case ServiceWorkerRegistrationState::Active:
          REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu active worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
          m_activeWorker = WTFMove(serviceWorker);
          break;
      }
<span class="line-removed">-     updatePendingActivityForEventDispatch();</span>
  }
  
<span class="line-modified">! void ServiceWorkerRegistration::fireUpdateFoundEvent()</span>
  {
      if (m_isStopped)
          return;
  
      REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;fireUpdateFoundEvent: Firing updatefound event for registration %llu&quot;, identifier().toUInt64());
  
<span class="line-modified">!     ASSERT(m_pendingActivityForEventDispatch);</span>
<span class="line-removed">-     dispatchEvent(Event::create(eventNames().updatefoundEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  }
  
  EventTargetInterface ServiceWorkerRegistration::eventTargetInterface() const
  {
      return ServiceWorkerRegistrationEventTargetInterfaceType;
<span class="line-new-header">--- 176,20 ---</span>
      case ServiceWorkerRegistrationState::Active:
          REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu active worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
          m_activeWorker = WTFMove(serviceWorker);
          break;
      }
  }
  
<span class="line-modified">! void ServiceWorkerRegistration::queueTaskToFireUpdateFoundEvent()</span>
  {
      if (m_isStopped)
          return;
  
      REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;fireUpdateFoundEvent: Firing updatefound event for registration %llu&quot;, identifier().toUInt64());
  
<span class="line-modified">!     queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().updatefoundEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  }
  
  EventTargetInterface ServiceWorkerRegistration::eventTargetInterface() const
  {
      return ServiceWorkerRegistrationEventTargetInterfaceType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,33 ***</span>
  const char* ServiceWorkerRegistration::activeDOMObjectName() const
  {
      return &quot;ServiceWorkerRegistration&quot;;
  }
  
<span class="line-removed">- bool ServiceWorkerRegistration::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // FIXME: We should do better as this prevents a page from entering PageCache when there is a service worker registration.</span>
<span class="line-removed">-     return !hasPendingActivity();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ServiceWorkerRegistration::stop()
  {
      m_isStopped = true;
      removeAllEventListeners();
<span class="line-removed">-     updatePendingActivityForEventDispatch();</span>
  }
  
<span class="line-modified">! void ServiceWorkerRegistration::updatePendingActivityForEventDispatch()</span>
  {
<span class="line-modified">!     // If a registration has no ServiceWorker, then it has been cleared on server-side.</span>
<span class="line-modified">!     if (m_isStopped || !getNewestWorker()) {</span>
<span class="line-modified">!         m_pendingActivityForEventDispatch = nullptr;</span>
<span class="line-modified">!         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (m_pendingActivityForEventDispatch)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     m_pendingActivityForEventDispatch = makePendingActivity(*this);</span>
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
<span class="line-new-header">--- 203,22 ---</span>
  const char* ServiceWorkerRegistration::activeDOMObjectName() const
  {
      return &quot;ServiceWorkerRegistration&quot;;
  }
  
  void ServiceWorkerRegistration::stop()
  {
      m_isStopped = true;
      removeAllEventListeners();
  }
  
<span class="line-modified">! bool ServiceWorkerRegistration::hasPendingActivity() const</span>
  {
<span class="line-modified">!     if (!m_isStopped &amp;&amp; getNewestWorker() &amp;&amp; hasEventListeners())</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return ActiveDOMObject::hasPendingActivity();</span>
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
</pre>
<center><a href="ServiceWorkerProvider.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerRegistration.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp
@@ -38,10 +38,11 @@
 
 #include "Document.h"
 #include "Event.h"
 #include "EventNames.h"
 #include "Frame.h"
+#include "JSDOMPromiseDeferred.h"
 #include "JSRTCPeerConnection.h"
 #include "Logging.h"
 #include "MediaEndpointConfiguration.h"
 #include "MediaStream.h"
 #include "MediaStreamTrack.h"
@@ -65,36 +66,34 @@
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(RTCPeerConnection);
 
 Ref<RTCPeerConnection> RTCPeerConnection::create(ScriptExecutionContext& context)
 {
-    auto peerConnection = adoptRef(*new RTCPeerConnection(context));
+    auto& document = downcast<Document>(context);
+    auto peerConnection = adoptRef(*new RTCPeerConnection(document));
     peerConnection->suspendIfNeeded();
-    // RTCPeerConnection may send events at about any time during its lifetime.
-    // Let's make it uncollectable until the pc is closed by JS or the page stops it.
     if (!peerConnection->isClosed()) {
-        peerConnection->m_pendingActivity = peerConnection->makePendingActivity(peerConnection.get());
-        if (auto* page = downcast<Document>(context).page()) {
+        if (auto* page = document.page()) {
             peerConnection->registerToController(page->rtcController());
-            page->libWebRTCProvider().setEnableLogging(!context.sessionID().isEphemeral());
+            page->libWebRTCProvider().setEnableLogging(!page->sessionID().isEphemeral());
         }
     }
     return peerConnection;
 }
 
-RTCPeerConnection::RTCPeerConnection(ScriptExecutionContext& context)
-    : ActiveDOMObject(&context)
+RTCPeerConnection::RTCPeerConnection(Document& document)
+    : ActiveDOMObject(document)
 #if !RELEASE_LOG_DISABLED
-    , m_logger(downcast<Document>(context).logger())
+    , m_logger(document.logger())
     , m_logIdentifier(reinterpret_cast<const void*>(cryptographicallyRandomNumber()))
 #endif
     , m_backend(PeerConnectionBackend::create(*this))
 {
     ALWAYS_LOG(LOGIDENTIFIER);
 
 #if !RELEASE_LOG_DISABLED
-    auto* page = downcast<Document>(context).page();
+    auto* page = document.page();
     if (page && !page->settings().webRTCEncryptionEnabled())
         ALWAYS_LOG(LOGIDENTIFIER, "encryption is disabled");
 #endif
 
     if (!m_backend)
@@ -194,10 +193,11 @@
     if (isClosed()) {
         promise.reject(InvalidStateError);
         return;
     }
 
+    addPendingPromise(promise);
     m_backend->createOffer(WTFMove(options), WTFMove(promise));
 }
 
 void RTCPeerConnection::queuedCreateAnswer(RTCAnswerOptions&& options, SessionDescriptionPromise&& promise)
 {
@@ -205,10 +205,11 @@
     if (isClosed()) {
         promise.reject(InvalidStateError);
         return;
     }
 
+    addPendingPromise(promise);
     m_backend->createAnswer(WTFMove(options), WTFMove(promise));
 }
 
 void RTCPeerConnection::queuedSetLocalDescription(RTCSessionDescription& description, DOMPromiseDeferred<void>&& promise)
 {
@@ -216,10 +217,11 @@
     if (isClosed()) {
         promise.reject(InvalidStateError);
         return;
     }
 
+    addPendingPromise(promise);
     m_backend->setLocalDescription(description, WTFMove(promise));
 }
 
 RefPtr<RTCSessionDescription> RTCPeerConnection::localDescription() const
 {
@@ -242,10 +244,11 @@
 
     if (isClosed()) {
         promise.reject(InvalidStateError);
         return;
     }
+    addPendingPromise(promise);
     m_backend->setRemoteDescription(description, WTFMove(promise));
 }
 
 RefPtr<RTCSessionDescription> RTCPeerConnection::remoteDescription() const
 {
@@ -269,10 +272,11 @@
     if (isClosed()) {
         promise.reject(InvalidStateError);
         return;
     }
 
+    addPendingPromise(promise);
     m_backend->addIceCandidate(rtcCandidate, WTFMove(promise));
 }
 
 // Implementation of https://w3c.github.io/webrtc-pc/#set-pc-configuration
 static inline ExceptionOr<Vector<MediaEndpointConfiguration::IceServerInfo>> iceServersFromConfiguration(RTCConfiguration& newConfiguration, const RTCConfiguration* existingConfiguration, bool isLocalDescriptionSet)
@@ -316,11 +320,11 @@
 }
 
 ExceptionOr<Vector<MediaEndpointConfiguration::CertificatePEM>> RTCPeerConnection::certificatesFromConfiguration(const RTCConfiguration& configuration)
 {
     auto currentMilliSeconds = WallTime::now().secondsSinceEpoch().milliseconds();
-    auto& origin = downcast<Document>(*scriptExecutionContext()).securityOrigin();
+    auto& origin = document()->securityOrigin();
 
     Vector<MediaEndpointConfiguration::CertificatePEM> certificates;
     certificates.reserveInitialCapacity(configuration.certificates.size());
     for (auto& certificate : configuration.certificates) {
         if (!origin.isSameOriginAs(certificate->origin()))
@@ -396,14 +400,15 @@
                 m_backend->getStats(transceiver->receiver(), WTFMove(promise));
                 return;
             }
         }
     }
+    addPendingPromise(promise.get());
     m_backend->getStats(WTFMove(promise));
 }
 
-ExceptionOr<Ref<RTCDataChannel>> RTCPeerConnection::createDataChannel(ScriptExecutionContext& context, String&& label, RTCDataChannelInit&& options)
+ExceptionOr<Ref<RTCDataChannel>> RTCPeerConnection::createDataChannel(String&& label, RTCDataChannelInit&& options)
 {
     ALWAYS_LOG(LOGIDENTIFIER);
 
     if (isClosed())
         return Exception { InvalidStateError };
@@ -419,18 +424,19 @@
 
     auto channelHandler = m_backend->createDataChannelHandler(label, options);
     if (!channelHandler)
         return Exception { NotSupportedError };
 
-    return RTCDataChannel::create(context, WTFMove(channelHandler), WTFMove(label), WTFMove(options));
+    return RTCDataChannel::create(*document(), WTFMove(channelHandler), WTFMove(label), WTFMove(options));
 }
 
 bool RTCPeerConnection::doClose()
 {
     if (isClosed())
         return false;
 
+    m_shouldDelayTasks = false;
     m_connectionState = RTCPeerConnectionState::Closed;
     m_iceConnectionState = RTCIceConnectionState::Closed;
     m_signalingState = RTCSignalingState::Closed;
 
     for (auto& transceiver : m_transceiverSet->list()) {
@@ -447,35 +453,32 @@
     if (!doClose())
         return;
 
     updateConnectionState();
     ASSERT(isClosed());
-    doStop();
+    m_backend->close();
 }
 
 void RTCPeerConnection::emulatePlatformEvent(const String& action)
 {
     m_backend->emulatePlatformEvent(action);
 }
 
 void RTCPeerConnection::stop()
 {
-    if (!doClose())
-        return;
-
+    doClose();
     doStop();
 }
 
 void RTCPeerConnection::doStop()
 {
     if (m_isStopped)
         return;
 
     m_isStopped = true;
-
-    m_backend->stop();
-    m_pendingActivity = nullptr;
+    if (m_backend)
+        m_backend->stop();
 }
 
 void RTCPeerConnection::registerToController(RTCController& controller)
 {
     m_controller = &controller;
@@ -491,18 +494,48 @@
 const char* RTCPeerConnection::activeDOMObjectName() const
 {
     return "RTCPeerConnection";
 }
 
-bool RTCPeerConnection::canSuspendForDocumentSuspension() const
+void RTCPeerConnection::suspend(ReasonForSuspension reason)
 {
-    return !hasPendingActivity();
+    if (reason != ReasonForSuspension::BackForwardCache)
+        return;
+
+    m_shouldDelayTasks = true;
+    m_backend->suspend();
+}
+
+void RTCPeerConnection::resume()
+{
+    if (!m_shouldDelayTasks)
+        return;
+
+    m_shouldDelayTasks = false;
+    m_backend->resume();
+
+    scriptExecutionContext()->postTask([this, protectedThis = makeRef(*this)](auto&) {
+        if (m_isStopped || m_shouldDelayTasks)
+            return;
+
+        auto tasks = WTFMove(m_pendingTasks);
+        for (auto& task : tasks)
+            task();
+    });
 }
 
 bool RTCPeerConnection::hasPendingActivity() const
 {
-    return !m_isStopped;
+    if (m_isStopped)
+        return false;
+
+    // This returns true if we have pending promises to be resolved.
+    if (ActiveDOMObject::hasPendingActivity())
+        return true;
+
+    // As long as the connection is not stopped and it has event listeners, it may dispatch events.
+    return hasEventListeners();
 }
 
 void RTCPeerConnection::addTransceiver(Ref<RTCRtpTransceiver>&& transceiver)
 {
     INFO_LOG(LOGIDENTIFIER);
@@ -522,11 +555,11 @@
     scriptExecutionContext()->postTask([protectedThis = makeRef(*this), newState](ScriptExecutionContext&) {
         if (protectedThis->isClosed() || protectedThis->m_iceGatheringState == newState)
             return;
 
         protectedThis->m_iceGatheringState = newState;
-        protectedThis->dispatchEvent(Event::create(eventNames().icegatheringstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+        protectedThis->dispatchEventWhenFeasible(Event::create(eventNames().icegatheringstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
         protectedThis->updateConnectionState();
     });
 }
 
 void RTCPeerConnection::updateIceConnectionState(RTCIceConnectionState newState)
@@ -536,11 +569,11 @@
     scriptExecutionContext()->postTask([protectedThis = makeRef(*this), newState](ScriptExecutionContext&) {
         if (protectedThis->isClosed() || protectedThis->m_iceConnectionState == newState)
             return;
 
         protectedThis->m_iceConnectionState = newState;
-        protectedThis->dispatchEvent(Event::create(eventNames().iceconnectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+        protectedThis->dispatchEventWhenFeasible(Event::create(eventNames().iceconnectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
         protectedThis->updateConnectionState();
     });
 }
 
 void RTCPeerConnection::updateConnectionState()
@@ -566,47 +599,58 @@
         return;
 
     INFO_LOG(LOGIDENTIFIER, "state changed from: " , m_connectionState, " to ", state);
 
     m_connectionState = state;
-    dispatchEvent(Event::create(eventNames().connectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    dispatchEventWhenFeasible(Event::create(eventNames().connectionstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 }
 
 void RTCPeerConnection::scheduleNegotiationNeededEvent()
 {
     scriptExecutionContext()->postTask([protectedThis = makeRef(*this)](ScriptExecutionContext&) {
         if (protectedThis->isClosed())
             return;
         if (!protectedThis->m_backend->isNegotiationNeeded())
             return;
         protectedThis->m_backend->clearNegotiationNeededState();
-        protectedThis->dispatchEvent(Event::create(eventNames().negotiationneededEvent, Event::CanBubble::No, Event::IsCancelable::No));
+        protectedThis->dispatchEventWhenFeasible(Event::create(eventNames().negotiationneededEvent, Event::CanBubble::No, Event::IsCancelable::No));
     });
 }
 
-void RTCPeerConnection::fireEvent(Event& event)
+void RTCPeerConnection::doTask(Function<void()>&& task)
+{
+    if (m_shouldDelayTasks || !m_pendingTasks.isEmpty()) {
+        m_pendingTasks.append(WTFMove(task));
+        return;
+    }
+    task();
+}
+
+void RTCPeerConnection::dispatchEventWhenFeasible(Ref<Event>&& event)
 {
-    dispatchEvent(event);
+    doTask([this, event = WTFMove(event)] {
+        dispatchEvent(event);
+    });
 }
 
 void RTCPeerConnection::dispatchEvent(Event& event)
 {
     INFO_LOG(LOGIDENTIFIER, "dispatching '", event.type(), "'");
     EventTarget::dispatchEvent(event);
 }
 
-static inline ExceptionOr<PeerConnectionBackend::CertificateInformation> certificateTypeFromAlgorithmIdentifier(JSC::ExecState& state, RTCPeerConnection::AlgorithmIdentifier&& algorithmIdentifier)
+static inline ExceptionOr<PeerConnectionBackend::CertificateInformation> certificateTypeFromAlgorithmIdentifier(JSC::JSGlobalObject& lexicalGlobalObject, RTCPeerConnection::AlgorithmIdentifier&& algorithmIdentifier)
 {
     if (WTF::holds_alternative<String>(algorithmIdentifier))
         return Exception { NotSupportedError, "Algorithm is not supported"_s };
 
     auto& value = WTF::get<JSC::Strong<JSC::JSObject>>(algorithmIdentifier);
 
-    JSC::VM& vm = state.vm();
+    JSC::VM& vm = lexicalGlobalObject.vm();
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
-    auto parameters = convertDictionary<RTCPeerConnection::CertificateParameters>(state, value.get());
+    auto parameters = convertDictionary<RTCPeerConnection::CertificateParameters>(lexicalGlobalObject, value.get());
     if (UNLIKELY(scope.exception())) {
         scope.clearException();
         return Exception { TypeError, "Unable to read certificate parameters"_s };
     }
 
@@ -638,18 +682,18 @@
     }
 
     return Exception { NotSupportedError, "Algorithm is not supported"_s };
 }
 
-void RTCPeerConnection::generateCertificate(JSC::ExecState& state, AlgorithmIdentifier&& algorithmIdentifier, DOMPromiseDeferred<IDLInterface<RTCCertificate>>&& promise)
+void RTCPeerConnection::generateCertificate(JSC::JSGlobalObject& lexicalGlobalObject, AlgorithmIdentifier&& algorithmIdentifier, DOMPromiseDeferred<IDLInterface<RTCCertificate>>&& promise)
 {
-    auto parameters = certificateTypeFromAlgorithmIdentifier(state, WTFMove(algorithmIdentifier));
+    auto parameters = certificateTypeFromAlgorithmIdentifier(lexicalGlobalObject, WTFMove(algorithmIdentifier));
     if (parameters.hasException()) {
         promise.reject(parameters.releaseException());
         return;
     }
-    auto& document = downcast<Document>(*JSC::jsCast<JSDOMGlobalObject*>(state.lexicalGlobalObject())->scriptExecutionContext());
+    auto& document = downcast<Document>(*JSC::jsCast<JSDOMGlobalObject*>(&lexicalGlobalObject)->scriptExecutionContext());
     PeerConnectionBackend::generateCertificate(document, parameters.returnValue(), WTFMove(promise));
 }
 
 Vector<std::reference_wrapper<RTCRtpSender>> RTCPeerConnection::getSenders() const
 {
@@ -667,10 +711,15 @@
 {
     m_backend->collectTransceivers();
     return m_transceiverSet->list();
 }
 
+Document* RTCPeerConnection::document()
+{
+    return downcast<Document>(scriptExecutionContext());
+}
+
 #if !RELEASE_LOG_DISABLED
 WTFLogChannel& RTCPeerConnection::logChannel() const
 {
     return LogWebRTC;
 }

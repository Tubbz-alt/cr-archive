<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CrossOriginPreflightChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
</pre>
<hr />
<pre>
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;DocumentParser.h&quot;
  45 #include &quot;DocumentWriter.h&quot;
  46 #include &quot;ElementChildIterator.h&quot;
  47 #include &quot;Event.h&quot;
  48 #include &quot;EventNames.h&quot;
  49 #include &quot;ExtensionStyleSheets.h&quot;
  50 #include &quot;FormState.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameTree.h&quot;
  55 #include &quot;HTMLFormElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;
  57 #include &quot;HTTPHeaderNames.h&quot;
  58 #include &quot;HistoryItem.h&quot;
  59 #include &quot;HistoryController.h&quot;
  60 #include &quot;IconLoader.h&quot;
  61 #include &quot;InspectorInstrumentation.h&quot;

  62 #include &quot;LinkIconCollector.h&quot;
  63 #include &quot;LinkIconType.h&quot;
  64 #include &quot;LoaderStrategy.h&quot;
  65 #include &quot;Logging.h&quot;
  66 #include &quot;MemoryCache.h&quot;
  67 #include &quot;NetworkLoadMetrics.h&quot;
  68 #include &quot;Page.h&quot;
  69 #include &quot;PingLoader.h&quot;
  70 #include &quot;PlatformStrategies.h&quot;
  71 #include &quot;PolicyChecker.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;ResourceHandle.h&quot;
  74 #include &quot;ResourceLoadObserver.h&quot;
  75 #include &quot;RuntimeEnabledFeatures.h&quot;
  76 #include &quot;SWClientConnection.h&quot;
<span class="line-removed">  77 #include &quot;SchemeRegistry.h&quot;</span>
  78 #include &quot;ScriptableDocumentParser.h&quot;
  79 #include &quot;SecurityPolicy.h&quot;
  80 #include &quot;ServiceWorker.h&quot;
  81 #include &quot;ServiceWorkerClientData.h&quot;
  82 #include &quot;ServiceWorkerProvider.h&quot;
  83 #include &quot;Settings.h&quot;
  84 #include &quot;SubresourceLoader.h&quot;
  85 #include &quot;TextResourceDecoder.h&quot;
  86 #include &lt;wtf/Assertions.h&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/NeverDestroyed.h&gt;
  89 #include &lt;wtf/Ref.h&gt;
  90 #include &lt;wtf/text/CString.h&gt;
  91 #include &lt;wtf/text/WTFString.h&gt;
  92 
  93 #if ENABLE(APPLICATION_MANIFEST)
  94 #include &quot;ApplicationManifestLoader.h&quot;
  95 #include &quot;HTMLHeadElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #endif
  98 
  99 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 100 #include &quot;ArchiveFactory.h&quot;
 101 #endif
 102 
 103 #if ENABLE(CONTENT_FILTERING)
 104 #include &quot;ContentFilter.h&quot;


 105 #endif
 106 
 107 #if USE(QUICK_LOOK)
 108 #include &quot;PreviewConverter.h&quot;
 109 #include &quot;QuickLook.h&quot;
 110 #endif
 111 
 112 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - DocumentLoader::&quot; fmt, this, ##__VA_ARGS__)
 113 
 114 namespace WebCore {
 115 
 116 static void cancelAll(const ResourceLoaderMap&amp; loaders)
 117 {
 118     for (auto&amp; loader : copyToVector(loaders.values()))
 119         loader-&gt;cancel();
 120 }
 121 
 122 static void setAllDefersLoading(const ResourceLoaderMap&amp; loaders, bool defers)
 123 {
 124     for (auto&amp; loader : copyToVector(loaders.values()))
 125         loader-&gt;setDefersLoading(defers);
 126 }
 127 
<span class="line-modified"> 128 static bool shouldPendingCachedResourceLoadPreventPageCache(CachedResource&amp; cachedResource)</span>
 129 {
<span class="line-modified"> 130     if (!cachedResource.isLoading())</span>
<span class="line-modified"> 131         return false;</span>
<span class="line-removed"> 132 </span>
<span class="line-removed"> 133     switch (cachedResource.type()) {</span>
<span class="line-removed"> 134     case CachedResource::Type::ImageResource:</span>
<span class="line-removed"> 135     case CachedResource::Type::Icon:</span>
<span class="line-removed"> 136     case CachedResource::Type::Beacon:</span>
<span class="line-removed"> 137     case CachedResource::Type::Ping:</span>
<span class="line-removed"> 138     case CachedResource::Type::LinkPrefetch:</span>
<span class="line-removed"> 139         return false;</span>
<span class="line-removed"> 140     case CachedResource::Type::MainResource:</span>
<span class="line-removed"> 141     case CachedResource::Type::CSSStyleSheet:</span>
<span class="line-removed"> 142     case CachedResource::Type::Script:</span>
<span class="line-removed"> 143     case CachedResource::Type::FontResource:</span>
<span class="line-removed"> 144 #if ENABLE(SVG_FONTS)</span>
<span class="line-removed"> 145     case CachedResource::Type::SVGFontResource:</span>
<span class="line-removed"> 146 #endif</span>
<span class="line-removed"> 147     case CachedResource::Type::MediaResource:</span>
<span class="line-removed"> 148     case CachedResource::Type::RawResource:</span>
<span class="line-removed"> 149     case CachedResource::Type::SVGDocumentResource:</span>
<span class="line-removed"> 150 #if ENABLE(XSLT)</span>
<span class="line-removed"> 151     case CachedResource::Type::XSLStyleSheet:</span>
<span class="line-removed"> 152 #endif</span>
<span class="line-removed"> 153 #if ENABLE(VIDEO_TRACK)</span>
<span class="line-removed"> 154     case CachedResource::Type::TextTrackResource:</span>
<span class="line-removed"> 155 #endif</span>
<span class="line-removed"> 156 #if ENABLE(APPLICATION_MANIFEST)</span>
<span class="line-removed"> 157     case CachedResource::Type::ApplicationManifest:</span>
<span class="line-removed"> 158 #endif</span>
<span class="line-removed"> 159         break;</span>
<span class="line-removed"> 160     };</span>
<span class="line-removed"> 161     return !cachedResource.areAllClientsXMLHttpRequests();</span>
 162 }
 163 
<span class="line-modified"> 164 static bool areAllLoadersPageCacheAcceptable(const ResourceLoaderMap&amp; loaders)</span>
 165 {
<span class="line-modified"> 166     for (auto&amp; loader : copyToVector(loaders.values())) {</span>
<span class="line-removed"> 167         if (!loader-&gt;frameLoader() || !loader-&gt;frameLoader()-&gt;frame().page())</span>
<span class="line-removed"> 168             return false;</span>
<span class="line-removed"> 169 </span>
<span class="line-removed"> 170         CachedResource* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());</span>
<span class="line-removed"> 171         if (!cachedResource)</span>
<span class="line-removed"> 172             return false;</span>
<span class="line-removed"> 173 </span>
<span class="line-removed"> 174         // Only image and XHR loads do not prevent the page from entering the PageCache.</span>
<span class="line-removed"> 175         // All non-image loads will prevent the page from entering the PageCache.</span>
<span class="line-removed"> 176         if (shouldPendingCachedResourceLoadPreventPageCache(*cachedResource))</span>
<span class="line-removed"> 177             return false;</span>
<span class="line-removed"> 178     }</span>
<span class="line-removed"> 179     return true;</span>
 180 }
 181 


 182 DocumentLoader::DocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 183     : FrameDestructionObserver(nullptr)
 184     , m_cachedResourceLoader(CachedResourceLoader::create(this))
 185     , m_originalRequest(request)
 186     , m_substituteData(substituteData)
 187     , m_originalRequestCopy(request)
 188     , m_request(request)
 189     , m_originalSubstituteDataWasValid(substituteData.isValid())
 190     , m_substituteResourceDeliveryTimer(*this, &amp;DocumentLoader::substituteResourceDeliveryTimerFired)
 191     , m_dataLoadTimer(*this, &amp;DocumentLoader::handleSubstituteDataLoadNow)
 192     , m_applicationCacheHost(makeUnique&lt;ApplicationCacheHost&gt;(*this))
 193 {
 194 }
 195 
 196 FrameLoader* DocumentLoader::frameLoader() const
 197 {
 198     if (!m_frame)
 199         return nullptr;
 200     return &amp;m_frame-&gt;loader();
 201 }
 202 
 203 SubresourceLoader* DocumentLoader::mainResourceLoader() const
 204 {
 205     if (!m_mainResource)
 206         return nullptr;
 207     return m_mainResource-&gt;loader();
 208 }
 209 
 210 DocumentLoader::~DocumentLoader()
 211 {
 212     ASSERT(!m_frame || !isLoading() || frameLoader()-&gt;activeDocumentLoader() != this);
 213     ASSERT_WITH_MESSAGE(!m_waitingForContentPolicy, &quot;The content policy callback should never outlive its DocumentLoader.&quot;);
 214     ASSERT_WITH_MESSAGE(!m_waitingForNavigationPolicy, &quot;The navigation policy callback should never outlive its DocumentLoader.&quot;);
 215 
 216     m_cachedResourceLoader-&gt;clearDocumentLoader();
 217     clearMainResource();







 218 }
 219 
 220 RefPtr&lt;SharedBuffer&gt; DocumentLoader::mainResourceData() const
 221 {
 222     if (m_substituteData.isValid())
 223         return m_substituteData.content()-&gt;copy();
 224     if (m_mainResource)
 225         return m_mainResource-&gt;resourceBuffer();
 226     return nullptr;
 227 }
 228 
 229 Document* DocumentLoader::document() const
 230 {
 231     if (m_frame &amp;&amp; m_frame-&gt;loader().documentLoader() == this)
 232         return m_frame-&gt;document();
 233     return nullptr;
 234 }
 235 
 236 void DocumentLoader::replaceRequestURLForSameDocumentNavigation(const URL&amp; url)
 237 {
</pre>
<hr />
<pre>
 242 void DocumentLoader::setRequest(const ResourceRequest&amp; req)
 243 {
 244     // Replacing an unreachable URL with alternate content looks like a server-side
 245     // redirect at this point, but we can replace a committed dataSource.
 246     bool handlingUnreachableURL = false;
 247 
 248     handlingUnreachableURL = m_substituteData.isValid() &amp;&amp; !m_substituteData.failingURL().isEmpty();
 249 
 250     bool shouldNotifyAboutProvisionalURLChange = false;
 251     if (handlingUnreachableURL)
 252         m_committed = false;
 253     else if (isLoadingMainResource() &amp;&amp; req.url() != m_request.url())
 254         shouldNotifyAboutProvisionalURLChange = true;
 255 
 256     // We should never be getting a redirect callback after the data
 257     // source is committed, except in the unreachable URL case. It
 258     // would be a WebFoundation bug if it sent a redirect callback after commit.
 259     ASSERT(!m_committed);
 260 
 261     m_request = req;
<span class="line-modified"> 262     if (shouldNotifyAboutProvisionalURLChange)</span>



 263         frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();

 264 }
 265 
 266 void DocumentLoader::setMainDocumentError(const ResourceError&amp; error)
 267 {
 268     if (!error.isNull())
 269         RELEASE_LOG_IF_ALLOWED(&quot;setMainDocumentError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 270 
 271     m_mainDocumentError = error;
 272     frameLoader()-&gt;client().setMainDocumentError(this, error);
 273 }
 274 
 275 void DocumentLoader::mainReceivedError(const ResourceError&amp; error)
 276 {
 277     ASSERT(!error.isNull());
 278 
 279     if (!frameLoader())
 280         return;
 281 
 282     if (!error.isNull())
 283         RELEASE_LOG_IF_ALLOWED(&quot;mainReceivedError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
</pre>
<hr />
<pre>
 297 
 298     setMainDocumentError(error);
 299     clearMainResourceLoader();
 300     frameLoader()-&gt;receivedMainResourceError(error);
 301 }
 302 
 303 // Cancels the data source&#39;s pending loads.  Conceptually, a data source only loads
 304 // one document at a time, but one document may have many related resources.
 305 // stopLoading will stop all loads initiated by the data source,
 306 // but not loads initiated by child frames&#39; data sources -- that&#39;s the WebFrame&#39;s job.
 307 void DocumentLoader::stopLoading()
 308 {
 309     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 310     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 311 
 312     // In some rare cases, calling FrameLoader::stopLoading could cause isLoading() to return false.
 313     // (This can happen when there&#39;s a single XMLHttpRequest currently loading and stopLoading causes it
 314     // to stop loading. Because of this, we need to save it so we don&#39;t return early.
 315     bool loading = isLoading();
 316 
<span class="line-removed"> 317     // We may want to audit the existing subresource loaders when we are on a page which has completed</span>
<span class="line-removed"> 318     // loading but there are subresource loads during cancellation. This must be done before the</span>
<span class="line-removed"> 319     // frame-&gt;stopLoading() call, which may evict the CachedResources, which we rely on to check</span>
<span class="line-removed"> 320     // the type of the resource loads.</span>
<span class="line-removed"> 321     if (loading &amp;&amp; m_committed &amp;&amp; !mainResourceLoader() &amp;&amp; !m_subresourceLoaders.isEmpty())</span>
<span class="line-removed"> 322         m_subresourceLoadersArePageCacheAcceptable = areAllLoadersPageCacheAcceptable(m_subresourceLoaders);</span>
<span class="line-removed"> 323 </span>
 324     if (m_committed) {
 325         // Attempt to stop the frame if the document loader is loading, or if it is done loading but
 326         // still  parsing. Failure to do so can cause a world leak.
 327         Document* doc = m_frame-&gt;document();
 328 
 329         if (loading || doc-&gt;parsing())
 330             m_frame-&gt;loader().stopLoading(UnloadEventPolicyNone);
 331     }
 332 
 333     for (auto callbackIdentifier : m_iconLoaders.values())
 334         notifyFinishedLoadingIcon(callbackIdentifier, nullptr);
 335     m_iconLoaders.clear();
 336     m_iconsPendingLoadDecision.clear();
 337 
 338 #if ENABLE(APPLICATION_MANIFEST)
 339     for (auto callbackIdentifier : m_applicationManifestLoaders.values())
 340         notifyFinishedLoadingApplicationManifest(callbackIdentifier, WTF::nullopt);
 341     m_applicationManifestLoaders.clear();
 342 #endif
 343 
</pre>
<hr />
<pre>
 512 void DocumentLoader::handleSubstituteDataLoadNow()
 513 {
 514     ResourceResponse response = m_substituteData.response();
 515     if (response.url().isEmpty())
 516         response = ResourceResponse(m_request.url(), m_substituteData.mimeType(), m_substituteData.content()-&gt;size(), m_substituteData.textEncoding());
 517 
 518     responseReceived(response, nullptr);
 519 }
 520 
 521 void DocumentLoader::startDataLoadTimer()
 522 {
 523     m_dataLoadTimer.startOneShot(0_s);
 524 
 525 #if HAVE(RUNLOOP_TIMER)
 526     if (SchedulePairHashSet* scheduledPairs = m_frame-&gt;page()-&gt;scheduledRunLoopPairs())
 527         m_dataLoadTimer.schedule(*scheduledPairs);
 528 #endif
 529 }
 530 
 531 #if ENABLE(SERVICE_WORKER)










 532 void DocumentLoader::matchRegistration(const URL&amp; url, SWClientConnection::RegistrationCallback&amp;&amp; callback)
 533 {
<span class="line-modified"> 534     auto shouldTryLoadingThroughServiceWorker = !frameLoader()-&gt;isReloadingFromOrigin() &amp;&amp; m_frame-&gt;page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; SchemeRegistry::canServiceWorkersHandleURLScheme(url.protocol().toStringWithoutCopying());</span>
 535     if (!shouldTryLoadingThroughServiceWorker) {
 536         callback(WTF::nullopt);
 537         return;
 538     }
 539 
 540     auto origin = (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) ? m_frame-&gt;document()-&gt;topOrigin().data() : SecurityOriginData::fromURL(url);
<span class="line-modified"> 541     auto sessionID = m_frame-&gt;page()-&gt;sessionID();</span>
<span class="line-removed"> 542     auto&amp; provider = ServiceWorkerProvider::singleton();</span>
<span class="line-removed"> 543     if (!provider.mayHaveServiceWorkerRegisteredForOrigin(sessionID, origin)) {</span>
 544         callback(WTF::nullopt);
 545         return;
 546     }
 547 
<span class="line-modified"> 548     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);</span>
 549     connection.matchRegistration(WTFMove(origin), url, WTFMove(callback));
 550 }
 551 
 552 static inline bool areRegistrationsEqual(const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; a, const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; b)
 553 {
 554     if (!a)
 555         return !b;
 556     if (!b)
 557         return false;
 558     return a-&gt;identifier == b-&gt;identifier;
 559 }
 560 #endif
 561 
 562 void DocumentLoader::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 563 {
 564     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
 565 #if ENABLE(SERVICE_WORKER)
<span class="line-modified"> 566     bool isRedirectionFromServiceWorker = redirectResponse.source() == ResourceResponse::Source::ServiceWorker;</span>
<span class="line-modified"> 567     willSendRequest(WTFMove(request), redirectResponse, [isRedirectionFromServiceWorker, completionHandler = WTFMove(completionHandler), protectedThis = makeRef(*this), this] (auto&amp;&amp; request) mutable {</span>



 568         ASSERT(!m_substituteData.isValid());
 569         if (request.isNull() || !m_mainDocumentError.isNull() || !m_frame) {
 570             completionHandler({ });
 571             return;
 572         }
 573 
<span class="line-modified"> 574         auto url = request.url();</span>
<span class="line-modified"> 575         this-&gt;matchRegistration(url, [request = WTFMove(request), isRedirectionFromServiceWorker, completionHandler = WTFMove(completionHandler), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified"> 576             if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-modified"> 577                 completionHandler({ });</span>
<span class="line-modified"> 578                 return;</span>
<span class="line-modified"> 579             }</span>
<span class="line-modified"> 580 </span>
<span class="line-modified"> 581             if (!registrationData &amp;&amp; this-&gt;tryLoadingRedirectRequestFromApplicationCache(request)) {</span>
<span class="line-modified"> 582                 completionHandler({ });</span>
<span class="line-modified"> 583                 return;</span>
<span class="line-modified"> 584             }</span>
<span class="line-modified"> 585 </span>
<span class="line-removed"> 586             bool shouldContinueLoad = areRegistrationsEqual(m_serviceWorkerRegistrationData, registrationData)</span>
<span class="line-removed"> 587                 &amp;&amp; isRedirectionFromServiceWorker == !!registrationData;</span>
<span class="line-removed"> 588 </span>
<span class="line-removed"> 589             if (shouldContinueLoad) {</span>
 590                 completionHandler(WTFMove(request));
<span class="line-modified"> 591                 return;</span>
<span class="line-removed"> 592             }</span>
<span class="line-removed"> 593 </span>
<span class="line-removed"> 594             this-&gt;restartLoadingDueToServiceWorkerRegistrationChange(WTFMove(request), WTFMove(registrationData));</span>
<span class="line-removed"> 595             completionHandler({ });</span>
 596             return;
<span class="line-modified"> 597         });</span>

 598     });
 599 #else
 600     willSendRequest(WTFMove(request), redirectResponse, WTFMove(completionHandler));
 601 #endif
 602 }
 603 
 604 void DocumentLoader::willSendRequest(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 605 {
 606     // Note that there are no asserts here as there are for the other callbacks. This is due to the
 607     // fact that this &quot;callback&quot; is sent when starting every load, and the state of callback
 608     // deferrals plays less of a part in this function in preventing the bad behavior deferring
 609     // callbacks is meant to prevent.
 610     ASSERT(!newRequest.isNull());
 611 




 612     bool didReceiveRedirectResponse = !redirectResponse.isNull();
 613     if (!frameLoader()-&gt;checkIfFormActionAllowedByCSP(newRequest.url(), didReceiveRedirectResponse)) {
 614         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - form action not allowed by CSP (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 615         cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 616         return completionHandler(WTFMove(newRequest));
 617     }
 618 
 619     ASSERT(timing().fetchStart());
 620     if (didReceiveRedirectResponse) {
 621         // If the redirecting url is not allowed to display content from the target origin,
 622         // then block the redirect.
 623         Ref&lt;SecurityOrigin&gt; redirectingOrigin(SecurityOrigin::create(redirectResponse.url()));
 624         if (!redirectingOrigin.get().canDisplay(newRequest.url())) {
 625             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - redirecting URL not allowed to display content from target(frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 626             FrameLoader::reportLocalLoadFailed(m_frame, newRequest.url().string());
 627             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 628             return completionHandler(WTFMove(newRequest));
 629         }
 630         if (!portAllowed(newRequest.url())) {
 631             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - port not allowed (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
</pre>
<hr />
<pre>
 740 
 741     // We need to remove our reference to the CachedResource in favor of a SubstituteData load, which can triger the cancellation of the underyling ResourceLoader.
 742     // If the ResourceLoader is indeed cancelled, it would normally send resource load callbacks.
 743     // Therefore, sever our relationship with the network load but prevent the ResourceLoader from sending ResourceLoadNotifier callbacks.
 744 
 745     auto resourceLoader = makeRefPtr(mainResourceLoader());
 746     if (resourceLoader) {
 747         ASSERT(resourceLoader-&gt;shouldSendResourceLoadCallbacks());
 748         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::DoNotSendCallbacks);
 749     }
 750 
 751     clearMainResource();
 752 
 753     if (resourceLoader)
 754         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::SendCallbacks);
 755 
 756     handleSubstituteDataLoadNow();
 757     return true;
 758 }
 759 
<span class="line-removed"> 760 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-removed"> 761 void DocumentLoader::restartLoadingDueToServiceWorkerRegistrationChange(ResourceRequest&amp;&amp; request, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; registrationData)</span>
<span class="line-removed"> 762 {</span>
<span class="line-removed"> 763     clearMainResource();</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765     ASSERT(!isCommitted());</span>
<span class="line-removed"> 766     m_serviceWorkerRegistrationData = WTFMove(registrationData);</span>
<span class="line-removed"> 767     loadMainResource(WTFMove(request));</span>
<span class="line-removed"> 768 </span>
<span class="line-removed"> 769     if (m_mainResource)</span>
<span class="line-removed"> 770         frameLoader()-&gt;client().dispatchDidReceiveServerRedirectForProvisionalLoad();</span>
<span class="line-removed"> 771 }</span>
<span class="line-removed"> 772 #endif</span>
<span class="line-removed"> 773 </span>
 774 void DocumentLoader::stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp; response)
 775 {
 776     Ref&lt;DocumentLoader&gt; protectedThis { *this };
 777     InspectorInstrumentation::continueAfterXFrameOptionsDenied(*m_frame, identifier, *this, response);
 778     m_frame-&gt;document()-&gt;enforceSandboxFlags(SandboxOrigin);
 779     if (HTMLFrameOwnerElement* ownerElement = m_frame-&gt;ownerElement())
 780         ownerElement-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 781 
 782     // The load event might have detached this frame. In that case, the load will already have been cancelled during detach.
 783     if (FrameLoader* frameLoader = this-&gt;frameLoader())
 784         cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 785 }
 786 
 787 void DocumentLoader::responseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 788 {
 789     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);













 790     responseReceived(response, WTFMove(completionHandler));
 791 }
 792 
 793 void DocumentLoader::responseReceived(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 794 {

 795     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
 796 
 797 #if ENABLE(CONTENT_FILTERING)
 798     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterResponseReceived(response))
 799         return;
 800 #endif
 801 
 802     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 803     bool willLoadFallback = m_applicationCacheHost-&gt;maybeLoadFallbackForMainResponse(request(), response);
 804 
 805     // The memory cache doesn&#39;t understand the application cache or its caching rules. So if a main resource is served
 806     // from the application cache, ensure we don&#39;t save the result for future use.
 807     if (willLoadFallback)
 808         MemoryCache::singleton().remove(*m_mainResource);
 809 
 810     if (willLoadFallback)
 811         return;
 812 
 813     ASSERT(m_identifierForLoadWithoutResourceLoader || m_mainResource);
 814     unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();
</pre>
<hr />
<pre>
 865 
 866     // Always show content with valid substitute data.
 867     if (m_substituteData.isValid()) {
 868         continueAfterContentPolicy(PolicyAction::Use);
 869         return;
 870     }
 871 
 872 #if ENABLE(FTPDIR)
 873     // Respect the hidden FTP Directory Listing pref so it can be tested even if the policy delegate might otherwise disallow it
 874     if (m_frame-&gt;settings().forceFTPDirectoryListings() &amp;&amp; m_response.mimeType() == &quot;application/x-ftp-directory&quot;) {
 875         continueAfterContentPolicy(PolicyAction::Use);
 876         return;
 877     }
 878 #endif
 879 
 880     RefPtr&lt;SubresourceLoader&gt; mainResourceLoader = this-&gt;mainResourceLoader();
 881     if (mainResourceLoader)
 882         mainResourceLoader-&gt;markInAsyncResponsePolicyCheck();
 883     auto requestIdentifier = PolicyCheckIdentifier::create();
 884     frameLoader()-&gt;checkContentPolicy(m_response, requestIdentifier, [this, protectedThis = makeRef(*this), mainResourceLoader = WTFMove(mainResourceLoader),
<span class="line-modified"> 885         completionHandler = completionHandlerCaller.release(), requestIdentifier] (PolicyAction policy, PolicyCheckIdentifier responseIdentifeir) mutable {</span>
<span class="line-modified"> 886         RELEASE_ASSERT(responseIdentifeir.isValidFor(requestIdentifier));</span>
 887         continueAfterContentPolicy(policy);
 888         if (mainResourceLoader)
 889             mainResourceLoader-&gt;didReceiveResponsePolicy();
 890         if (completionHandler)
 891             completionHandler();
 892     });
 893 }
 894 
 895 // Prevent web archives from loading if
 896 // 1) it is remote;
 897 // 2) it is not the main frame;
 898 // 3) it is not any of { loaded by clients; loaded by drag; reloaded from any of the previous two };
 899 // because they can claim to be from any domain and thus avoid cross-domain security checks (4120255, 45524528, 47610130).
 900 bool DocumentLoader::disallowWebArchive() const
 901 {
 902     using MIMETypeHashSet = HashSet&lt;String, ASCIICaseInsensitiveHash&gt;;
 903     static NeverDestroyed&lt;MIMETypeHashSet&gt; webArchiveMIMETypes {
 904         MIMETypeHashSet {
 905             &quot;application/x-webarchive&quot;_s,
 906             &quot;application/x-mimearchive&quot;_s,
 907             &quot;multipart/related&quot;_s,
 908 #if PLATFORM(GTK)
 909             &quot;message/rfc822&quot;_s,
 910 #endif
 911         }
 912     };
 913 
 914     String mimeType = m_response.mimeType();
 915     if (mimeType.isNull() || !webArchiveMIMETypes.get().contains(mimeType))
 916         return false;
 917 
 918 #if USE(QUICK_LOOK)
 919     if (isQuickLookPreviewURL(m_response.url()))
 920         return false;
 921 #endif
 922 
 923     if (m_substituteData.isValid())
 924         return false;
 925 
<span class="line-modified"> 926     if (!SchemeRegistry::shouldTreatURLSchemeAsLocal(m_request.url().protocol().toStringWithoutCopying()))</span>
 927         return true;
 928 
 929     if (!frame() || (frame()-&gt;isMainFrame() &amp;&amp; m_allowsWebArchiveForMainFrame))
 930         return false;
 931 
 932     // On purpose of maintaining existing tests.
 933     if (frame()-&gt;mainFrame().loader().alwaysAllowLocalWebarchive())
 934         return false;
 935     return true;
 936 }
 937 




















 938 void DocumentLoader::continueAfterContentPolicy(PolicyAction policy)
 939 {
 940     ASSERT(m_waitingForContentPolicy);
 941     m_waitingForContentPolicy = false;
 942     if (isStopping())
 943         return;
 944 





 945     switch (policy) {
 946     case PolicyAction::Use: {
<span class="line-modified"> 947         if (!frameLoader()-&gt;client().canShowMIMEType(m_response.mimeType()) || disallowWebArchive()) {</span>
 948             frameLoader()-&gt;policyChecker().cannotShowMIMEType(m_response);
 949             // Check reachedTerminalState since the load may have already been canceled inside of _handleUnimplementablePolicyWithErrorCode::.
 950             stopLoadingForPolicyChange();
 951             return;
 952         }
 953         break;
 954     }
 955 
 956     case PolicyAction::Download: {
 957         // m_mainResource can be null, e.g. when loading a substitute resource from application cache.
 958         if (!m_mainResource) {
 959             RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: cannot show URL (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 960             mainReceivedError(frameLoader()-&gt;client().cannotShowURLError(m_request));
 961             return;
 962         }
 963 
 964         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 965             InspectorInstrumentation::continueWithPolicyDownload(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 966 
 967         // When starting the request, we didn&#39;t know that it would result in download and not navigation. Now we know that main document URL didn&#39;t change.
 968         // Download may use this knowledge for purposes unrelated to cookies, notably for setting file quarantine data.
 969         frameLoader()-&gt;setOriginalURLForDownloadRequest(m_request);
 970 
<span class="line-removed"> 971         PAL::SessionID sessionID = PAL::SessionID::defaultSessionID();</span>
<span class="line-removed"> 972         if (frame() &amp;&amp; frame()-&gt;page())</span>
<span class="line-removed"> 973             sessionID = frame()-&gt;page()-&gt;sessionID();</span>
<span class="line-removed"> 974 </span>
 975         if (m_request.url().protocolIsData()) {
 976             // We decode data URL internally, there is no resource load to convert.
 977             frameLoader()-&gt;client().startDownload(m_request);
 978         } else
<span class="line-modified"> 979             frameLoader()-&gt;client().convertMainResourceLoadToDownload(this, sessionID, m_request, m_response);</span>
 980 
 981         // The main resource might be loading from the memory cache, or its loader might have gone missing.
 982         if (mainResourceLoader()) {
 983             static_cast&lt;ResourceLoader*&gt;(mainResourceLoader())-&gt;didFail(interruptedForPolicyChangeError());
 984             return;
 985         }
 986 
 987         // We must stop loading even if there is no main resource loader. Otherwise, we might remain
 988         // the client of a CachedRawResource that will continue to send us data.
 989         stopLoadingForPolicyChange();
 990         return;
 991     }
 992     case PolicyAction::StopAllLoads:
 993         ASSERT_NOT_REACHED();
<span class="line-modified"> 994 #if ASSERT_DISABLED</span>
 995         FALLTHROUGH;
 996 #endif
 997     case PolicyAction::Ignore:
 998         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 999             InspectorInstrumentation::continueWithPolicyIgnore(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
1000         stopLoadingForPolicyChange();
1001         return;
1002     }
1003 
1004     if (m_response.isHTTP()) {
1005         int status = m_response.httpStatusCode(); // Status may be zero when loading substitute data, in particular from a WebArchive.
1006         if (status &amp;&amp; (status &lt; 200 || status &gt;= 300)) {
1007             bool hostedByObject = frameLoader()-&gt;isHostedByObjectElement();
1008 
1009             frameLoader()-&gt;handleFallbackContent();
1010             // object elements are no longer rendered after we fallback, so don&#39;t
1011             // keep trying to process data from their load
1012 
1013             if (hostedByObject)
1014                 cancelMainResourceLoad(frameLoader()-&gt;cancelledError(m_request));
</pre>
<hr />
<pre>
1046 #endif
1047     frameLoader-&gt;client().committedLoad(this, data, length);
1048 
1049     if (isMultipartReplacingLoad())
1050         frameLoader-&gt;client().didReplaceMultipartContent();
1051 }
1052 
1053 ResourceError DocumentLoader::interruptedForPolicyChangeError() const
1054 {
1055     return frameLoader()-&gt;client().interruptedForPolicyChangeError(request());
1056 }
1057 
1058 void DocumentLoader::stopLoadingForPolicyChange()
1059 {
1060     ResourceError error = interruptedForPolicyChangeError();
1061     error.setType(ResourceError::Type::Cancellation);
1062     cancelMainResourceLoad(error);
1063 }
1064 
1065 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">1066 static inline bool isLocalURL(const URL&amp; url)</span>

1067 {
<span class="line-modified">1068     // https://fetch.spec.whatwg.org/#is-local</span>
<span class="line-removed">1069     auto protocol = url.protocol().toStringWithoutCopying();</span>
<span class="line-removed">1070     return equalLettersIgnoringASCIICase(protocol, &quot;data&quot;) || equalLettersIgnoringASCIICase(protocol, &quot;blob&quot;) || equalLettersIgnoringASCIICase(protocol, &quot;about&quot;);</span>
1071 }
1072 #endif
1073 
1074 void DocumentLoader::commitData(const char* bytes, size_t length)
1075 {
1076     if (!m_gotFirstByte) {
1077         m_gotFirstByte = true;
1078         bool hasBegun = m_writer.begin(documentURL(), false);
1079         m_writer.setDocumentWasLoadedAsPartOfNavigation();
1080 
1081         if (SecurityPolicy::allowSubstituteDataAccessToLocal() &amp;&amp; m_originalSubstituteDataWasValid) {
1082             // If this document was loaded with substituteData, then the document can
1083             // load local resources. See https://bugs.webkit.org/show_bug.cgi?id=16756
1084             // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
1085             // discussion.
1086             m_frame-&gt;document()-&gt;securityOrigin().grantLoadLocalResources();
1087         }
1088 
1089         if (frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
1090             return;
1091 
1092 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1093         if (m_archive &amp;&amp; m_archive-&gt;shouldOverrideBaseURL())
1094             m_frame-&gt;document()-&gt;setBaseURLOverride(m_archive-&gt;mainResource()-&gt;url());
1095 #endif
1096 #if ENABLE(SERVICE_WORKER)
1097         if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {
1098             if (m_serviceWorkerRegistrationData &amp;&amp; m_serviceWorkerRegistrationData-&gt;activeWorker) {
1099                 m_frame-&gt;document()-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*m_frame-&gt;document(), WTFMove(m_serviceWorkerRegistrationData-&gt;activeWorker.value())));
1100                 m_serviceWorkerRegistrationData = { };
<span class="line-modified">1101             } else if (isLocalURL(m_frame-&gt;document()-&gt;url())) {</span>
<span class="line-modified">1102                 if (auto* parent = m_frame-&gt;document()-&gt;parentDocument())</span>
1103                     m_frame-&gt;document()-&gt;setActiveServiceWorker(parent-&gt;activeServiceWorker());
1104             }
1105 
<span class="line-modified">1106             if (m_frame-&gt;document()-&gt;activeServiceWorker() || SchemeRegistry::canServiceWorkersHandleURLScheme(m_frame-&gt;document()-&gt;url().protocol().toStringWithoutCopying()))</span>
<span class="line-modified">1107                 m_frame-&gt;document()-&gt;setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(m_frame-&gt;page()-&gt;sessionID()));</span>
1108 
1109             // We currently unregister the temporary service worker client since we now registered the real document.
1110             // FIXME: We should make the real document use the temporary client identifier.
1111             unregisterTemporaryServiceWorkerClient();
1112         }
1113 #endif
1114         // Call receivedFirstData() exactly once per load. We should only reach this point multiple times
1115         // for multipart loads, and FrameLoader::isReplacing() will be true after the first time.
1116         if (!isMultipartReplacingLoad())
1117             frameLoader()-&gt;receivedFirstData();
1118 
1119         // The load could be canceled under receivedFirstData(), which makes delegate calls and even sometimes dispatches DOM events.
1120         if (!isLoading())
1121             return;
1122 
1123         if (auto* window = m_frame-&gt;document()-&gt;domWindow())
1124             window-&gt;prewarmLocalStorageIfNecessary();
1125 
1126         bool userChosen;
1127         String encoding;
</pre>
<hr />
<pre>
1201     frameLoader()-&gt;client().willReplaceMultipartContent();
1202 
1203     maybeFinishLoadingMultipartContent();
1204     maybeCreateArchive();
1205     m_writer.end();
1206     frameLoader()-&gt;setReplacing();
1207     m_gotFirstByte = false;
1208 
1209     stopLoadingSubresources();
1210     stopLoadingPlugIns();
1211 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1212     clearArchiveResources();
1213 #endif
1214 }
1215 
1216 void DocumentLoader::checkLoadComplete()
1217 {
1218     if (!m_frame || isLoading())
1219         return;
1220 
<span class="line-modified">1221     ASSERT(this == frameLoader()-&gt;activeDocumentLoader());</span>
1222     m_frame-&gt;document()-&gt;domWindow()-&gt;finishedLoading();
1223 }
1224 
1225 void DocumentLoader::applyPoliciesToSettings()
1226 {
1227     if (!m_frame) {
1228         ASSERT_NOT_REACHED();
1229         return;
1230     }
1231 
1232     if (!m_frame-&gt;isMainFrame())
1233         return;
1234 
1235 #if ENABLE(MEDIA_SOURCE)
1236     m_frame-&gt;settings().setMediaSourceEnabled(m_mediaSourcePolicy == MediaSourcePolicy::Default ? Settings::platformDefaultMediaSourceEnabled() : m_mediaSourcePolicy == MediaSourcePolicy::Enable);
1237 #endif
1238 }
1239 
1240 void DocumentLoader::attachToFrame(Frame&amp; frame)
1241 {
1242     if (m_frame == &amp;frame)
1243         return;
1244 
1245     ASSERT(!m_frame);
1246     observeFrame(&amp;frame);
1247     m_writer.setFrame(frame);
1248     attachToFrame();
1249 
<span class="line-modified">1250 #ifndef NDEBUG</span>
1251     m_hasEverBeenAttached = true;
1252 #endif
1253 
1254     applyPoliciesToSettings();
1255 }
1256 
1257 void DocumentLoader::attachToFrame()
1258 {
1259     ASSERT(m_frame);
1260 }
1261 
1262 void DocumentLoader::detachFromFrame()
1263 {
<span class="line-modified">1264 #ifndef NDEBUG</span>
1265     if (m_hasEverBeenAttached)
1266         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader twice without an attachToFrame() inbetween&quot;);
1267     else
1268         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader that has never attached to any Frame&quot;);
1269 #endif
1270     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1271     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1272 
1273     // It never makes sense to have a document loader that is detached from its
1274     // frame have any loads active, so kill all the loads.
1275     stopLoading();
1276     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
1277         m_mainResource-&gt;removeClient(*this);
1278 #if ENABLE(CONTENT_FILTERING)
1279     if (m_contentFilter)
1280         m_contentFilter-&gt;stopFilteringMainResource();
1281 #endif
1282 
1283     m_applicationCacheHost-&gt;setDOMApplicationCache(nullptr);
1284 
1285     cancelPolicyCheckIfNeeded();
1286 
1287     // cancelPolicyCheckIfNeeded can clear m_frame if the policy check
1288     // is stopped, resulting in a recursive call into this detachFromFrame.
1289     // If m_frame is nullptr after cancelPolicyCheckIfNeeded, our work is
1290     // already done so just return.
1291     if (!m_frame)
1292         return;
1293 
1294     InspectorInstrumentation::loaderDetachedFromFrame(*m_frame, *this);
1295 
1296     observeFrame(nullptr);
1297 }
1298 
1299 void DocumentLoader::clearMainResourceLoader()
1300 {
1301     m_loadingMainResource = false;
1302 
<span class="line-modified">1303     if (this == frameLoader()-&gt;activeDocumentLoader())</span>





1304         checkLoadComplete();
1305 }
1306 
1307 #if ENABLE(APPLICATION_MANIFEST)
1308 uint64_t DocumentLoader::loadApplicationManifest()
1309 {
1310     static uint64_t nextCallbackID = 1;
1311 
1312     auto* document = this-&gt;document();
1313     if (!document)
1314         return 0;
1315 
1316     if (!m_frame-&gt;isMainFrame())
1317         return 0;
1318 
1319     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
1320         return 0;
1321 
1322     auto head = document-&gt;head();
1323     if (!head)
</pre>
<hr />
<pre>
1527     if (m_pendingSubstituteResources.isEmpty())
1528         return;
1529     ASSERT(m_frame);
1530     ASSERT(m_frame-&gt;page());
1531     if (m_frame-&gt;page()-&gt;defersLoading())
1532         return;
1533 
1534     auto pendingSubstituteResources = WTFMove(m_pendingSubstituteResources);
1535     for (auto&amp; pendingSubstituteResource : pendingSubstituteResources) {
1536         auto&amp; loader = pendingSubstituteResource.key;
1537         if (auto&amp; resource = pendingSubstituteResource.value)
1538             resource-&gt;deliver(*loader);
1539         else {
1540             // A null resource means that we should fail the load.
1541             // FIXME: Maybe we should use another error here - something like &quot;not in cache&quot;.
1542             loader-&gt;didFail(loader-&gt;cannotShowURLError());
1543         }
1544     }
1545 }
1546 
<span class="line-modified">1547 #ifndef NDEBUG</span>
1548 
1549 bool DocumentLoader::isSubstituteLoadPending(ResourceLoader* loader) const
1550 {
1551     return m_pendingSubstituteResources.contains(loader);
1552 }
1553 
<span class="line-modified">1554 #endif</span>
1555 
1556 void DocumentLoader::cancelPendingSubstituteLoad(ResourceLoader* loader)
1557 {
1558     if (m_pendingSubstituteResources.isEmpty())
1559         return;
1560     m_pendingSubstituteResources.remove(loader);
1561     if (m_pendingSubstituteResources.isEmpty())
1562         m_substituteResourceDeliveryTimer.stop();
1563 }
1564 
1565 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1566 
1567 bool DocumentLoader::scheduleArchiveLoad(ResourceLoader&amp; loader, const ResourceRequest&amp; request)
1568 {
1569     if (auto* resource = archiveResourceForURL(request.url())) {
1570         scheduleSubstituteResourceLoad(loader, *resource);
1571         return true;
1572     }
1573 
1574     if (!m_archive)
</pre>
<hr />
<pre>
1701     ASSERT(m_subresourceLoaders.isEmpty());
1702 }
1703 
1704 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
1705 {
1706     // The main resource&#39;s underlying ResourceLoader will ask to be added here.
1707     // It is much simpler to handle special casing of main resource loads if we don&#39;t
1708     // let it be added. In the main resource load case, mainResourceLoader()
1709     // will still be null at this point, but m_gotFirstByte should be false here if and only
1710     // if we are just starting the main resource load.
1711     if (!m_gotFirstByte)
1712         return;
1713     ASSERT(loader-&gt;identifier());
1714     ASSERT(!m_subresourceLoaders.contains(loader-&gt;identifier()));
1715     ASSERT(!mainResourceLoader() || mainResourceLoader() != loader);
1716 
1717     // Application Cache loaders are handled by their ApplicationCacheGroup directly.
1718     if (loader-&gt;options().applicationCacheMode == ApplicationCacheMode::Bypass)
1719         return;
1720 
<span class="line-modified">1721 #if !ASSERT_DISABLED</span>
1722     if (document()) {
<span class="line-modified">1723         switch (document()-&gt;pageCacheState()) {</span>
<span class="line-modified">1724         case Document::NotInPageCache:</span>
1725             break;
<span class="line-modified">1726         case Document::AboutToEnterPageCache: {</span>
<span class="line-modified">1727             // A page about to enter PageCache should only be able to start ping loads.</span>
1728             auto* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
1729             ASSERT(cachedResource &amp;&amp; CachedResource::shouldUsePingLoad(cachedResource-&gt;type()));
1730             break;
1731         }
<span class="line-modified">1732         case Document::InPageCache:</span>
<span class="line-modified">1733             // A page in the PageCache should not be able to start loads.</span>
1734             ASSERT_NOT_REACHED();
1735             break;
1736         }
1737     }
1738 #endif
1739 
1740     m_subresourceLoaders.add(loader-&gt;identifier(), loader);
1741 }
1742 
1743 void DocumentLoader::removeSubresourceLoader(LoadCompletionType type, ResourceLoader* loader)
1744 {
1745     ASSERT(loader-&gt;identifier());
1746 
1747     if (!m_subresourceLoaders.remove(loader-&gt;identifier()))
1748         return;
1749     checkLoadComplete();
1750     if (Frame* frame = m_frame)
1751         frame-&gt;loader().subresourceLoadDone(type);
1752 }
1753 
</pre>
<hr />
<pre>
1758 
1759     m_plugInStreamLoaders.add(loader.identifier(), &amp;loader);
1760 }
1761 
1762 void DocumentLoader::removePlugInStreamLoader(ResourceLoader&amp; loader)
1763 {
1764     ASSERT(loader.identifier());
1765     ASSERT(&amp;loader == m_plugInStreamLoaders.get(loader.identifier()));
1766 
1767     m_plugInStreamLoaders.remove(loader.identifier());
1768     checkLoadComplete();
1769 }
1770 
1771 bool DocumentLoader::isMultipartReplacingLoad() const
1772 {
1773     return isLoadingMultipartContent() &amp;&amp; frameLoader()-&gt;isReplacing();
1774 }
1775 
1776 bool DocumentLoader::maybeLoadEmpty()
1777 {
<span class="line-modified">1778     bool shouldLoadEmpty = !m_substituteData.isValid() &amp;&amp; (m_request.url().isEmpty() || SchemeRegistry::shouldLoadURLSchemeAsEmptyDocument(m_request.url().protocol().toStringWithoutCopying()));</span>
1779     if (!shouldLoadEmpty &amp;&amp; !frameLoader()-&gt;client().representationExistsForURLScheme(m_request.url().protocol().toStringWithoutCopying()))
1780         return false;
1781 
1782     if (m_request.url().isEmpty() &amp;&amp; !frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument()) {
1783         m_request.setURL(WTF::blankURL());
1784         if (isLoadingMainResource())
1785             frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
1786     }
1787 
1788     String mimeType = shouldLoadEmpty ? &quot;text/html&quot; : frameLoader()-&gt;client().generatedMIMETypeForURLScheme(m_request.url().protocol().toStringWithoutCopying());
1789     m_response = ResourceResponse(m_request.url(), mimeType, 0, String());
1790     finishedLoading();
1791     return true;
1792 }
1793 
1794 void DocumentLoader::startLoadingMainResource()
1795 {
1796     m_mainDocumentError = ResourceError();
1797     timing().markStartTimeAndFetchStart();
1798     ASSERT(!m_mainResource);
</pre>
<hr />
<pre>
1803 
1804     if (maybeLoadEmpty()) {
1805         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1806         return;
1807     }
1808 
1809 #if ENABLE(CONTENT_FILTERING)
1810     m_contentFilter = !m_substituteData.isValid() ? ContentFilter::create(*this) : nullptr;
1811 #endif
1812 
1813     // Make sure we re-apply the user agent to the Document&#39;s ResourceRequest upon reload in case the embedding
1814     // application has changed it.
1815     m_request.clearHTTPUserAgent();
1816     frameLoader()-&gt;addExtraFieldsToMainResourceRequest(m_request);
1817 
1818     ASSERT(timing().startTime());
1819     ASSERT(timing().fetchStart());
1820 
1821     willSendRequest(ResourceRequest(m_request), ResourceResponse(), [this, protectedThis = WTFMove(protectedThis)] (ResourceRequest&amp;&amp; request) mutable {
1822         m_request = request;

1823 
1824         // willSendRequest() may lead to our Frame being detached or cancelling the load via nulling the ResourceRequest.
1825         if (!m_frame || m_request.isNull()) {
1826             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Load canceled after willSendRequest (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1827             return;
1828         }
1829 
1830         request.setRequester(ResourceRequest::Requester::Main);
1831         // If this is a reload the cache layer might have made the previous request conditional. DocumentLoader can&#39;t handle 304 responses itself.
1832         request.makeUnconditional();
1833 
1834         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Starting load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1835 
1836 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">1837         // FIXME: Implement local URL interception by getting the service worker of the parent.</span>
<span class="line-modified">1838         auto url = request.url();</span>
<span class="line-modified">1839         matchRegistration(url, [request = WTFMove(request), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified">1840             if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-modified">1841                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of main document error (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-modified">1842                 return;</span>
<span class="line-modified">1843             }</span>
1844 
<span class="line-modified">1845             m_serviceWorkerRegistrationData = WTFMove(registrationData);</span>





1846 
<span class="line-modified">1847             // Prefer existing substitute data (from WKWebView.loadData etc) over service worker fetch.</span>
<span class="line-modified">1848             if (this-&gt;tryLoadingSubstituteData()) {</span>
<span class="line-modified">1849                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-modified">1850                 return;</span>
<span class="line-modified">1851             }</span>
<span class="line-modified">1852             // Try app cache only if there is no service worker.</span>
<span class="line-modified">1853             if (!m_serviceWorkerRegistrationData &amp;&amp; this-&gt;tryLoadingRequestFromApplicationCache()) {</span>
<span class="line-modified">1854                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());</span>
<span class="line-removed">1855                 return;</span>
<span class="line-removed">1856             }</span>
<span class="line-removed">1857             this-&gt;loadMainResource(WTFMove(request));</span>
<span class="line-removed">1858         });</span>
1859 #else
1860         if (tryLoadingRequestFromApplicationCache()) {
1861             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1862             return;
1863         }
<span class="line-removed">1864         loadMainResource(WTFMove(request));</span>
1865 #endif

1866     });
1867 }
1868 
<span class="line-removed">1869 void DocumentLoader::registerTemporaryServiceWorkerClient(const URL&amp; url)</span>
<span class="line-removed">1870 {</span>
<span class="line-removed">1871 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-removed">1872     ASSERT(!m_temporaryServiceWorkerClient);</span>
<span class="line-removed">1873 </span>
<span class="line-removed">1874     if (!m_serviceWorkerRegistrationData)</span>
<span class="line-removed">1875         return;</span>
<span class="line-removed">1876 </span>
<span class="line-removed">1877     m_temporaryServiceWorkerClient = TemporaryServiceWorkerClient {</span>
<span class="line-removed">1878         DocumentIdentifier::generate(),</span>
<span class="line-removed">1879         m_frame-&gt;page()-&gt;sessionID()</span>
<span class="line-removed">1880     };</span>
<span class="line-removed">1881 </span>
<span class="line-removed">1882     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(m_temporaryServiceWorkerClient-&gt;sessionID);</span>
<span class="line-removed">1883 </span>
<span class="line-removed">1884     // FIXME: Compute ServiceWorkerClientFrameType appropriately.</span>
<span class="line-removed">1885     ServiceWorkerClientData data { { serviceWorkerConnection.serverConnectionIdentifier(), m_temporaryServiceWorkerClient-&gt;documentIdentifier }, ServiceWorkerClientType::Window, ServiceWorkerClientFrameType::None, url };</span>
<span class="line-removed">1886 </span>
<span class="line-removed">1887     RefPtr&lt;SecurityOrigin&gt; topOrigin;</span>
<span class="line-removed">1888     if (m_frame-&gt;isMainFrame())</span>
<span class="line-removed">1889         topOrigin = SecurityOrigin::create(url);</span>
<span class="line-removed">1890     else</span>
<span class="line-removed">1891         topOrigin = &amp;m_frame-&gt;mainFrame().document()-&gt;topOrigin();</span>
<span class="line-removed">1892     serviceWorkerConnection.registerServiceWorkerClient(*topOrigin, WTFMove(data), m_serviceWorkerRegistrationData-&gt;identifier, m_frame-&gt;loader().userAgent(url));</span>
<span class="line-removed">1893 #else</span>
<span class="line-removed">1894     UNUSED_PARAM(url);</span>
<span class="line-removed">1895 #endif</span>
<span class="line-removed">1896 }</span>
<span class="line-removed">1897 </span>
1898 void DocumentLoader::unregisterTemporaryServiceWorkerClient()
1899 {
1900 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">1901     if (!m_temporaryServiceWorkerClient)</span>
1902         return;
1903 
<span class="line-modified">1904     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(m_temporaryServiceWorkerClient-&gt;sessionID);</span>
<span class="line-modified">1905     serviceWorkerConnection.unregisterServiceWorkerClient(m_temporaryServiceWorkerClient-&gt;documentIdentifier);</span>
<span class="line-removed">1906     m_temporaryServiceWorkerClient = WTF::nullopt;</span>
1907 #endif
1908 }
1909 
1910 void DocumentLoader::loadMainResource(ResourceRequest&amp;&amp; request)
1911 {
<span class="line-modified">1912     static NeverDestroyed&lt;ResourceLoaderOptions&gt; mainResourceLoadOptions(</span>
1913         SendCallbackPolicy::SendCallbacks,
1914         ContentSniffingPolicy::SniffContent,
1915         DataBufferingPolicy::BufferData,
1916         StoredCredentialsPolicy::Use,
1917         ClientCredentialPolicy::MayAskClientForCredentials,
1918         FetchOptions::Credentials::Include,
1919         SecurityCheckPolicy::SkipSecurityCheck,
1920         FetchOptions::Mode::Navigate,
1921         CertificateInfoPolicy::IncludeCertificateInfo,
1922         ContentSecurityPolicyImposition::SkipPolicyCheck,
1923         DefersLoadingPolicy::AllowDefersLoading,
1924         CachingPolicy::AllowCaching);









1925     CachedResourceRequest mainResourceRequest(WTFMove(request), mainResourceLoadOptions);
1926     if (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) {
1927         // If we are loading the main resource of a subframe, use the cache partition of the main document.
1928         mainResourceRequest.setDomainForCachePartition(*m_frame-&gt;document());
1929     } else {
1930         auto origin = SecurityOrigin::create(mainResourceRequest.resourceRequest().url());
1931         origin-&gt;setStorageBlockingPolicy(frameLoader()-&gt;frame().settings().storageBlockingPolicy());
1932         mainResourceRequest.setDomainForCachePartition(origin-&gt;domainForCachePartition());
1933     }
1934 
<span class="line-removed">1935 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-removed">1936     mainResourceRequest.setNavigationServiceWorkerRegistrationData(m_serviceWorkerRegistrationData);</span>
<span class="line-removed">1937     if (mainResourceRequest.options().serviceWorkersMode != ServiceWorkersMode::None) {</span>
<span class="line-removed">1938         // As per step 12 of https://w3c.github.io/ServiceWorker/#on-fetch-request-algorithm, the active service worker should be controlling the document.</span>
<span class="line-removed">1939         // Since we did not yet create the document, we register a temporary service worker client instead.</span>
<span class="line-removed">1940         registerTemporaryServiceWorkerClient(mainResourceRequest.resourceRequest().url());</span>
<span class="line-removed">1941     }</span>
<span class="line-removed">1942 #endif</span>
<span class="line-removed">1943 </span>
1944     m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(WTFMove(mainResourceRequest)).value_or(nullptr);
1945 
1946     if (!m_mainResource) {
1947         // The frame may have gone away if this load was cancelled synchronously and this was the last pending load.
1948         // This is because we may have fired the load event in a parent frame.
1949         if (!m_frame) {
1950             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, frame has gone away (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1951             return;
1952         }
1953 
1954         if (!m_request.url().isValid()) {
1955             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, URL is invalid (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1956             cancelMainResourceLoad(frameLoader()-&gt;client().cannotShowURLError(m_request));
1957             return;
1958         }
1959 
1960         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1961 
1962         setRequest(ResourceRequest());
1963         // If the load was aborted by clearing m_request, it&#39;s possible the ApplicationCacheHost
</pre>
<hr />
<pre>
2187 {
2188     ASSERT(!m_gotFirstByte);
2189     m_pendingNamedContentExtensionStyleSheets.set(identifier, &amp;sheet);
2190 }
2191 
2192 void DocumentLoader::addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID)
2193 {
2194     ASSERT(!m_gotFirstByte);
2195     auto addResult = m_pendingContentExtensionDisplayNoneSelectors.add(identifier, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;());
2196     addResult.iterator-&gt;value.append(std::make_pair(selector, selectorID));
2197 }
2198 #endif
2199 
2200 bool DocumentLoader::isAlwaysOnLoggingAllowed() const
2201 {
2202     return !m_frame || m_frame-&gt;isAlwaysOnLoggingAllowed();
2203 }
2204 
2205 #if USE(QUICK_LOOK)
2206 
<span class="line-modified">2207 void DocumentLoader::setPreviewConverter(std::unique_ptr&lt;PreviewConverter&gt;&amp;&amp; previewConverter)</span>






2208 {
2209     m_previewConverter = WTFMove(previewConverter);
2210 }
2211 
2212 PreviewConverter* DocumentLoader::previewConverter() const
2213 {
2214     return m_previewConverter.get();
2215 }
2216 
2217 #endif
2218 
2219 void DocumentLoader::addConsoleMessage(MessageSource messageSource, MessageLevel messageLevel, const String&amp; message, unsigned long requestIdentifier)
2220 {
2221     static_cast&lt;ScriptExecutionContext*&gt;(m_frame-&gt;document())-&gt;addConsoleMessage(messageSource, messageLevel, message, requestIdentifier);
2222 }
2223 
2224 void DocumentLoader::sendCSPViolationReport(URL&amp;&amp; reportURL, Ref&lt;FormData&gt;&amp;&amp; report)
2225 {
2226     PingLoader::sendViolationReport(*m_frame, WTFMove(reportURL), WTFMove(report), ViolationReportType::ContentSecurityPolicy);
2227 }
2228 
2229 void DocumentLoader::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
2230 {
2231     m_frame-&gt;document()-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(eventInit));
2232 }
2233 






























2234 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
</pre>
<hr />
<pre>
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;DocumentParser.h&quot;
  45 #include &quot;DocumentWriter.h&quot;
  46 #include &quot;ElementChildIterator.h&quot;
  47 #include &quot;Event.h&quot;
  48 #include &quot;EventNames.h&quot;
  49 #include &quot;ExtensionStyleSheets.h&quot;
  50 #include &quot;FormState.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameTree.h&quot;
  55 #include &quot;HTMLFormElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;
  57 #include &quot;HTTPHeaderNames.h&quot;
  58 #include &quot;HistoryItem.h&quot;
  59 #include &quot;HistoryController.h&quot;
  60 #include &quot;IconLoader.h&quot;
  61 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">  62 #include &quot;LegacySchemeRegistry.h&quot;</span>
  63 #include &quot;LinkIconCollector.h&quot;
  64 #include &quot;LinkIconType.h&quot;
  65 #include &quot;LoaderStrategy.h&quot;
  66 #include &quot;Logging.h&quot;
  67 #include &quot;MemoryCache.h&quot;
  68 #include &quot;NetworkLoadMetrics.h&quot;
  69 #include &quot;Page.h&quot;
  70 #include &quot;PingLoader.h&quot;
  71 #include &quot;PlatformStrategies.h&quot;
  72 #include &quot;PolicyChecker.h&quot;
  73 #include &quot;ProgressTracker.h&quot;
  74 #include &quot;ResourceHandle.h&quot;
  75 #include &quot;ResourceLoadObserver.h&quot;
  76 #include &quot;RuntimeEnabledFeatures.h&quot;
  77 #include &quot;SWClientConnection.h&quot;

  78 #include &quot;ScriptableDocumentParser.h&quot;
  79 #include &quot;SecurityPolicy.h&quot;
  80 #include &quot;ServiceWorker.h&quot;
  81 #include &quot;ServiceWorkerClientData.h&quot;
  82 #include &quot;ServiceWorkerProvider.h&quot;
  83 #include &quot;Settings.h&quot;
  84 #include &quot;SubresourceLoader.h&quot;
  85 #include &quot;TextResourceDecoder.h&quot;
  86 #include &lt;wtf/Assertions.h&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/NeverDestroyed.h&gt;
  89 #include &lt;wtf/Ref.h&gt;
  90 #include &lt;wtf/text/CString.h&gt;
  91 #include &lt;wtf/text/WTFString.h&gt;
  92 
  93 #if ENABLE(APPLICATION_MANIFEST)
  94 #include &quot;ApplicationManifestLoader.h&quot;
  95 #include &quot;HTMLHeadElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #endif
  98 
  99 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 100 #include &quot;ArchiveFactory.h&quot;
 101 #endif
 102 
 103 #if ENABLE(CONTENT_FILTERING)
 104 #include &quot;ContentFilter.h&quot;
<span class="line-added"> 105 #include &quot;FrameLoadRequest.h&quot;</span>
<span class="line-added"> 106 #include &quot;ScriptController.h&quot;</span>
 107 #endif
 108 
 109 #if USE(QUICK_LOOK)
 110 #include &quot;PreviewConverter.h&quot;
 111 #include &quot;QuickLook.h&quot;
 112 #endif
 113 
 114 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - DocumentLoader::&quot; fmt, this, ##__VA_ARGS__)
 115 
 116 namespace WebCore {
 117 
 118 static void cancelAll(const ResourceLoaderMap&amp; loaders)
 119 {
 120     for (auto&amp; loader : copyToVector(loaders.values()))
 121         loader-&gt;cancel();
 122 }
 123 
 124 static void setAllDefersLoading(const ResourceLoaderMap&amp; loaders, bool defers)
 125 {
 126     for (auto&amp; loader : copyToVector(loaders.values()))
 127         loader-&gt;setDefersLoading(defers);
 128 }
 129 
<span class="line-modified"> 130 static HashMap&lt;DocumentIdentifier, DocumentLoader*&gt;&amp; temporaryIdentifierToLoaderMap()</span>
 131 {
<span class="line-modified"> 132     static NeverDestroyed&lt;HashMap&lt;DocumentIdentifier, DocumentLoader*&gt;&gt; map;</span>
<span class="line-modified"> 133     return map.get();</span>






























 134 }
 135 
<span class="line-modified"> 136 DocumentLoader* DocumentLoader::fromTemporaryDocumentIdentifier(DocumentIdentifier identifier)</span>
 137 {
<span class="line-modified"> 138     return temporaryIdentifierToLoaderMap().get(identifier);</span>













 139 }
 140 
<span class="line-added"> 141 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DocumentLoader);</span>
<span class="line-added"> 142 </span>
 143 DocumentLoader::DocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 144     : FrameDestructionObserver(nullptr)
 145     , m_cachedResourceLoader(CachedResourceLoader::create(this))
 146     , m_originalRequest(request)
 147     , m_substituteData(substituteData)
 148     , m_originalRequestCopy(request)
 149     , m_request(request)
 150     , m_originalSubstituteDataWasValid(substituteData.isValid())
 151     , m_substituteResourceDeliveryTimer(*this, &amp;DocumentLoader::substituteResourceDeliveryTimerFired)
 152     , m_dataLoadTimer(*this, &amp;DocumentLoader::handleSubstituteDataLoadNow)
 153     , m_applicationCacheHost(makeUnique&lt;ApplicationCacheHost&gt;(*this))
 154 {
 155 }
 156 
 157 FrameLoader* DocumentLoader::frameLoader() const
 158 {
 159     if (!m_frame)
 160         return nullptr;
 161     return &amp;m_frame-&gt;loader();
 162 }
 163 
 164 SubresourceLoader* DocumentLoader::mainResourceLoader() const
 165 {
 166     if (!m_mainResource)
 167         return nullptr;
 168     return m_mainResource-&gt;loader();
 169 }
 170 
 171 DocumentLoader::~DocumentLoader()
 172 {
 173     ASSERT(!m_frame || !isLoading() || frameLoader()-&gt;activeDocumentLoader() != this);
 174     ASSERT_WITH_MESSAGE(!m_waitingForContentPolicy, &quot;The content policy callback should never outlive its DocumentLoader.&quot;);
 175     ASSERT_WITH_MESSAGE(!m_waitingForNavigationPolicy, &quot;The navigation policy callback should never outlive its DocumentLoader.&quot;);
 176 
 177     m_cachedResourceLoader-&gt;clearDocumentLoader();
 178     clearMainResource();
<span class="line-added"> 179 </span>
<span class="line-added"> 180 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added"> 181     if (m_temporaryServiceWorkerClient) {</span>
<span class="line-added"> 182         ASSERT(temporaryIdentifierToLoaderMap().contains(*m_temporaryServiceWorkerClient));</span>
<span class="line-added"> 183         temporaryIdentifierToLoaderMap().remove(*m_temporaryServiceWorkerClient);</span>
<span class="line-added"> 184     }</span>
<span class="line-added"> 185 #endif</span>
 186 }
 187 
 188 RefPtr&lt;SharedBuffer&gt; DocumentLoader::mainResourceData() const
 189 {
 190     if (m_substituteData.isValid())
 191         return m_substituteData.content()-&gt;copy();
 192     if (m_mainResource)
 193         return m_mainResource-&gt;resourceBuffer();
 194     return nullptr;
 195 }
 196 
 197 Document* DocumentLoader::document() const
 198 {
 199     if (m_frame &amp;&amp; m_frame-&gt;loader().documentLoader() == this)
 200         return m_frame-&gt;document();
 201     return nullptr;
 202 }
 203 
 204 void DocumentLoader::replaceRequestURLForSameDocumentNavigation(const URL&amp; url)
 205 {
</pre>
<hr />
<pre>
 210 void DocumentLoader::setRequest(const ResourceRequest&amp; req)
 211 {
 212     // Replacing an unreachable URL with alternate content looks like a server-side
 213     // redirect at this point, but we can replace a committed dataSource.
 214     bool handlingUnreachableURL = false;
 215 
 216     handlingUnreachableURL = m_substituteData.isValid() &amp;&amp; !m_substituteData.failingURL().isEmpty();
 217 
 218     bool shouldNotifyAboutProvisionalURLChange = false;
 219     if (handlingUnreachableURL)
 220         m_committed = false;
 221     else if (isLoadingMainResource() &amp;&amp; req.url() != m_request.url())
 222         shouldNotifyAboutProvisionalURLChange = true;
 223 
 224     // We should never be getting a redirect callback after the data
 225     // source is committed, except in the unreachable URL case. It
 226     // would be a WebFoundation bug if it sent a redirect callback after commit.
 227     ASSERT(!m_committed);
 228 
 229     m_request = req;
<span class="line-modified"> 230     if (shouldNotifyAboutProvisionalURLChange) {</span>
<span class="line-added"> 231         // Logging for &lt;rdar://problem/54830233&gt;.</span>
<span class="line-added"> 232         if (!frameLoader()-&gt;provisionalDocumentLoader())</span>
<span class="line-added"> 233             RELEASE_LOG_IF_ALLOWED(&quot;DocumentLoader::setRequest: With no provisional document loader (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
 234         frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
<span class="line-added"> 235     }</span>
 236 }
 237 
 238 void DocumentLoader::setMainDocumentError(const ResourceError&amp; error)
 239 {
 240     if (!error.isNull())
 241         RELEASE_LOG_IF_ALLOWED(&quot;setMainDocumentError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 242 
 243     m_mainDocumentError = error;
 244     frameLoader()-&gt;client().setMainDocumentError(this, error);
 245 }
 246 
 247 void DocumentLoader::mainReceivedError(const ResourceError&amp; error)
 248 {
 249     ASSERT(!error.isNull());
 250 
 251     if (!frameLoader())
 252         return;
 253 
 254     if (!error.isNull())
 255         RELEASE_LOG_IF_ALLOWED(&quot;mainReceivedError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
</pre>
<hr />
<pre>
 269 
 270     setMainDocumentError(error);
 271     clearMainResourceLoader();
 272     frameLoader()-&gt;receivedMainResourceError(error);
 273 }
 274 
 275 // Cancels the data source&#39;s pending loads.  Conceptually, a data source only loads
 276 // one document at a time, but one document may have many related resources.
 277 // stopLoading will stop all loads initiated by the data source,
 278 // but not loads initiated by child frames&#39; data sources -- that&#39;s the WebFrame&#39;s job.
 279 void DocumentLoader::stopLoading()
 280 {
 281     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 282     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 283 
 284     // In some rare cases, calling FrameLoader::stopLoading could cause isLoading() to return false.
 285     // (This can happen when there&#39;s a single XMLHttpRequest currently loading and stopLoading causes it
 286     // to stop loading. Because of this, we need to save it so we don&#39;t return early.
 287     bool loading = isLoading();
 288 







 289     if (m_committed) {
 290         // Attempt to stop the frame if the document loader is loading, or if it is done loading but
 291         // still  parsing. Failure to do so can cause a world leak.
 292         Document* doc = m_frame-&gt;document();
 293 
 294         if (loading || doc-&gt;parsing())
 295             m_frame-&gt;loader().stopLoading(UnloadEventPolicyNone);
 296     }
 297 
 298     for (auto callbackIdentifier : m_iconLoaders.values())
 299         notifyFinishedLoadingIcon(callbackIdentifier, nullptr);
 300     m_iconLoaders.clear();
 301     m_iconsPendingLoadDecision.clear();
 302 
 303 #if ENABLE(APPLICATION_MANIFEST)
 304     for (auto callbackIdentifier : m_applicationManifestLoaders.values())
 305         notifyFinishedLoadingApplicationManifest(callbackIdentifier, WTF::nullopt);
 306     m_applicationManifestLoaders.clear();
 307 #endif
 308 
</pre>
<hr />
<pre>
 477 void DocumentLoader::handleSubstituteDataLoadNow()
 478 {
 479     ResourceResponse response = m_substituteData.response();
 480     if (response.url().isEmpty())
 481         response = ResourceResponse(m_request.url(), m_substituteData.mimeType(), m_substituteData.content()-&gt;size(), m_substituteData.textEncoding());
 482 
 483     responseReceived(response, nullptr);
 484 }
 485 
 486 void DocumentLoader::startDataLoadTimer()
 487 {
 488     m_dataLoadTimer.startOneShot(0_s);
 489 
 490 #if HAVE(RUNLOOP_TIMER)
 491     if (SchedulePairHashSet* scheduledPairs = m_frame-&gt;page()-&gt;scheduledRunLoopPairs())
 492         m_dataLoadTimer.schedule(*scheduledPairs);
 493 #endif
 494 }
 495 
 496 #if ENABLE(SERVICE_WORKER)
<span class="line-added"> 497 bool DocumentLoader::setControllingServiceWorkerRegistration(ServiceWorkerRegistrationData&amp;&amp; data)</span>
<span class="line-added"> 498 {</span>
<span class="line-added"> 499     if (!m_loadingMainResource)</span>
<span class="line-added"> 500         return false;</span>
<span class="line-added"> 501 </span>
<span class="line-added"> 502     ASSERT(!m_gotFirstByte);</span>
<span class="line-added"> 503     m_serviceWorkerRegistrationData = WTFMove(data);</span>
<span class="line-added"> 504     return true;</span>
<span class="line-added"> 505 }</span>
<span class="line-added"> 506 </span>
 507 void DocumentLoader::matchRegistration(const URL&amp; url, SWClientConnection::RegistrationCallback&amp;&amp; callback)
 508 {
<span class="line-modified"> 509     auto shouldTryLoadingThroughServiceWorker = !frameLoader()-&gt;isReloadingFromOrigin() &amp;&amp; m_frame-&gt;page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; LegacySchemeRegistry::canServiceWorkersHandleURLScheme(url.protocol().toStringWithoutCopying());</span>
 510     if (!shouldTryLoadingThroughServiceWorker) {
 511         callback(WTF::nullopt);
 512         return;
 513     }
 514 
 515     auto origin = (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) ? m_frame-&gt;document()-&gt;topOrigin().data() : SecurityOriginData::fromURL(url);
<span class="line-modified"> 516     if (!ServiceWorkerProvider::singleton().serviceWorkerConnection().mayHaveServiceWorkerRegisteredForOrigin(origin)) {</span>


 517         callback(WTF::nullopt);
 518         return;
 519     }
 520 
<span class="line-modified"> 521     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();</span>
 522     connection.matchRegistration(WTFMove(origin), url, WTFMove(callback));
 523 }
 524 
 525 static inline bool areRegistrationsEqual(const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; a, const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; b)
 526 {
 527     if (!a)
 528         return !b;
 529     if (!b)
 530         return false;
 531     return a-&gt;identifier == b-&gt;identifier;
 532 }
 533 #endif
 534 
 535 void DocumentLoader::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 536 {
 537     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
 538 #if ENABLE(SERVICE_WORKER)
<span class="line-modified"> 539     if (m_serviceWorkerRegistrationData) {</span>
<span class="line-modified"> 540         m_serviceWorkerRegistrationData = { };</span>
<span class="line-added"> 541         unregisterTemporaryServiceWorkerClient();</span>
<span class="line-added"> 542     }</span>
<span class="line-added"> 543     willSendRequest(WTFMove(request), redirectResponse, [completionHandler = WTFMove(completionHandler), protectedThis = makeRef(*this), this] (auto&amp;&amp; request) mutable {</span>
 544         ASSERT(!m_substituteData.isValid());
 545         if (request.isNull() || !m_mainDocumentError.isNull() || !m_frame) {
 546             completionHandler({ });
 547             return;
 548         }
 549 
<span class="line-modified"> 550         if (m_applicationCacheHost-&gt;canLoadMainResource(request)) {</span>
<span class="line-modified"> 551             auto url = request.url();</span>
<span class="line-modified"> 552             // Let&#39;s check service worker registration to see whether loading from network or not.</span>
<span class="line-modified"> 553             this-&gt;matchRegistration(url, [request = WTFMove(request), completionHandler = WTFMove(completionHandler), protectedThis = WTFMove(protectedThis), this](auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified"> 554                 if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-modified"> 555                     completionHandler({ });</span>
<span class="line-modified"> 556                     return;</span>
<span class="line-modified"> 557                 }</span>
<span class="line-modified"> 558                 if (!registrationData &amp;&amp; this-&gt;tryLoadingRedirectRequestFromApplicationCache(request)) {</span>
<span class="line-modified"> 559                     completionHandler({ });</span>
<span class="line-modified"> 560                     return;</span>
<span class="line-modified"> 561                 }</span>




 562                 completionHandler(WTFMove(request));
<span class="line-modified"> 563             });</span>




 564             return;
<span class="line-modified"> 565         }</span>
<span class="line-added"> 566         completionHandler(WTFMove(request));</span>
 567     });
 568 #else
 569     willSendRequest(WTFMove(request), redirectResponse, WTFMove(completionHandler));
 570 #endif
 571 }
 572 
 573 void DocumentLoader::willSendRequest(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 574 {
 575     // Note that there are no asserts here as there are for the other callbacks. This is due to the
 576     // fact that this &quot;callback&quot; is sent when starting every load, and the state of callback
 577     // deferrals plays less of a part in this function in preventing the bad behavior deferring
 578     // callbacks is meant to prevent.
 579     ASSERT(!newRequest.isNull());
 580 
<span class="line-added"> 581     // Logging for &lt;rdar://problem/54830233&gt;.</span>
<span class="line-added"> 582     if (!frameLoader() || !frameLoader()-&gt;provisionalDocumentLoader())</span>
<span class="line-added"> 583         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: With no provisional document loader (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-added"> 584 </span>
 585     bool didReceiveRedirectResponse = !redirectResponse.isNull();
 586     if (!frameLoader()-&gt;checkIfFormActionAllowedByCSP(newRequest.url(), didReceiveRedirectResponse)) {
 587         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - form action not allowed by CSP (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 588         cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 589         return completionHandler(WTFMove(newRequest));
 590     }
 591 
 592     ASSERT(timing().fetchStart());
 593     if (didReceiveRedirectResponse) {
 594         // If the redirecting url is not allowed to display content from the target origin,
 595         // then block the redirect.
 596         Ref&lt;SecurityOrigin&gt; redirectingOrigin(SecurityOrigin::create(redirectResponse.url()));
 597         if (!redirectingOrigin.get().canDisplay(newRequest.url())) {
 598             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - redirecting URL not allowed to display content from target(frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 599             FrameLoader::reportLocalLoadFailed(m_frame, newRequest.url().string());
 600             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 601             return completionHandler(WTFMove(newRequest));
 602         }
 603         if (!portAllowed(newRequest.url())) {
 604             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - port not allowed (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
</pre>
<hr />
<pre>
 713 
 714     // We need to remove our reference to the CachedResource in favor of a SubstituteData load, which can triger the cancellation of the underyling ResourceLoader.
 715     // If the ResourceLoader is indeed cancelled, it would normally send resource load callbacks.
 716     // Therefore, sever our relationship with the network load but prevent the ResourceLoader from sending ResourceLoadNotifier callbacks.
 717 
 718     auto resourceLoader = makeRefPtr(mainResourceLoader());
 719     if (resourceLoader) {
 720         ASSERT(resourceLoader-&gt;shouldSendResourceLoadCallbacks());
 721         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::DoNotSendCallbacks);
 722     }
 723 
 724     clearMainResource();
 725 
 726     if (resourceLoader)
 727         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::SendCallbacks);
 728 
 729     handleSubstituteDataLoadNow();
 730     return true;
 731 }
 732 














 733 void DocumentLoader::stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp; response)
 734 {
 735     Ref&lt;DocumentLoader&gt; protectedThis { *this };
 736     InspectorInstrumentation::continueAfterXFrameOptionsDenied(*m_frame, identifier, *this, response);
 737     m_frame-&gt;document()-&gt;enforceSandboxFlags(SandboxOrigin);
 738     if (HTMLFrameOwnerElement* ownerElement = m_frame-&gt;ownerElement())
 739         ownerElement-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 740 
 741     // The load event might have detached this frame. In that case, the load will already have been cancelled during detach.
 742     if (FrameLoader* frameLoader = this-&gt;frameLoader())
 743         cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 744 }
 745 
 746 void DocumentLoader::responseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 747 {
 748     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);
<span class="line-added"> 749 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added"> 750     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; response.source() == ResourceResponse::Source::MemoryCache) {</span>
<span class="line-added"> 751         matchRegistration(response.url(), [this, protectedThis = makeRef(*this), response, completionHandler = WTFMove(completionHandler)](auto&amp;&amp; registrationData) mutable {</span>
<span class="line-added"> 752             if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-added"> 753                 completionHandler();</span>
<span class="line-added"> 754                 return;</span>
<span class="line-added"> 755             }</span>
<span class="line-added"> 756             m_serviceWorkerRegistrationData = WTFMove(registrationData);</span>
<span class="line-added"> 757             responseReceived(response, WTFMove(completionHandler));</span>
<span class="line-added"> 758         });</span>
<span class="line-added"> 759         return;</span>
<span class="line-added"> 760     }</span>
<span class="line-added"> 761 #endif</span>
 762     responseReceived(response, WTFMove(completionHandler));
 763 }
 764 
 765 void DocumentLoader::responseReceived(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 766 {
<span class="line-added"> 767     ASSERT(response.certificateInfo());</span>
 768     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
 769 
 770 #if ENABLE(CONTENT_FILTERING)
 771     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterResponseReceived(response))
 772         return;
 773 #endif
 774 
 775     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 776     bool willLoadFallback = m_applicationCacheHost-&gt;maybeLoadFallbackForMainResponse(request(), response);
 777 
 778     // The memory cache doesn&#39;t understand the application cache or its caching rules. So if a main resource is served
 779     // from the application cache, ensure we don&#39;t save the result for future use.
 780     if (willLoadFallback)
 781         MemoryCache::singleton().remove(*m_mainResource);
 782 
 783     if (willLoadFallback)
 784         return;
 785 
 786     ASSERT(m_identifierForLoadWithoutResourceLoader || m_mainResource);
 787     unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();
</pre>
<hr />
<pre>
 838 
 839     // Always show content with valid substitute data.
 840     if (m_substituteData.isValid()) {
 841         continueAfterContentPolicy(PolicyAction::Use);
 842         return;
 843     }
 844 
 845 #if ENABLE(FTPDIR)
 846     // Respect the hidden FTP Directory Listing pref so it can be tested even if the policy delegate might otherwise disallow it
 847     if (m_frame-&gt;settings().forceFTPDirectoryListings() &amp;&amp; m_response.mimeType() == &quot;application/x-ftp-directory&quot;) {
 848         continueAfterContentPolicy(PolicyAction::Use);
 849         return;
 850     }
 851 #endif
 852 
 853     RefPtr&lt;SubresourceLoader&gt; mainResourceLoader = this-&gt;mainResourceLoader();
 854     if (mainResourceLoader)
 855         mainResourceLoader-&gt;markInAsyncResponsePolicyCheck();
 856     auto requestIdentifier = PolicyCheckIdentifier::create();
 857     frameLoader()-&gt;checkContentPolicy(m_response, requestIdentifier, [this, protectedThis = makeRef(*this), mainResourceLoader = WTFMove(mainResourceLoader),
<span class="line-modified"> 858         completionHandler = completionHandlerCaller.release(), requestIdentifier] (PolicyAction policy, PolicyCheckIdentifier responseIdentifier) mutable {</span>
<span class="line-modified"> 859         RELEASE_ASSERT(responseIdentifier.isValidFor(requestIdentifier));</span>
 860         continueAfterContentPolicy(policy);
 861         if (mainResourceLoader)
 862             mainResourceLoader-&gt;didReceiveResponsePolicy();
 863         if (completionHandler)
 864             completionHandler();
 865     });
 866 }
 867 
 868 // Prevent web archives from loading if
 869 // 1) it is remote;
 870 // 2) it is not the main frame;
 871 // 3) it is not any of { loaded by clients; loaded by drag; reloaded from any of the previous two };
 872 // because they can claim to be from any domain and thus avoid cross-domain security checks (4120255, 45524528, 47610130).
 873 bool DocumentLoader::disallowWebArchive() const
 874 {
 875     using MIMETypeHashSet = HashSet&lt;String, ASCIICaseInsensitiveHash&gt;;
 876     static NeverDestroyed&lt;MIMETypeHashSet&gt; webArchiveMIMETypes {
 877         MIMETypeHashSet {
 878             &quot;application/x-webarchive&quot;_s,
 879             &quot;application/x-mimearchive&quot;_s,
 880             &quot;multipart/related&quot;_s,
 881 #if PLATFORM(GTK)
 882             &quot;message/rfc822&quot;_s,
 883 #endif
 884         }
 885     };
 886 
 887     String mimeType = m_response.mimeType();
 888     if (mimeType.isNull() || !webArchiveMIMETypes.get().contains(mimeType))
 889         return false;
 890 
 891 #if USE(QUICK_LOOK)
 892     if (isQuickLookPreviewURL(m_response.url()))
 893         return false;
 894 #endif
 895 
 896     if (m_substituteData.isValid())
 897         return false;
 898 
<span class="line-modified"> 899     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_request.url().protocol().toStringWithoutCopying()))</span>
 900         return true;
 901 
 902     if (!frame() || (frame()-&gt;isMainFrame() &amp;&amp; m_allowsWebArchiveForMainFrame))
 903         return false;
 904 
 905     // On purpose of maintaining existing tests.
 906     if (frame()-&gt;mainFrame().loader().alwaysAllowLocalWebarchive())
 907         return false;
 908     return true;
 909 }
 910 
<span class="line-added"> 911 // Prevent data URIs from loading as the main frame unless the result of user action.</span>
<span class="line-added"> 912 bool DocumentLoader::disallowDataRequest() const</span>
<span class="line-added"> 913 {</span>
<span class="line-added"> 914     if (!m_response.url().protocolIsData())</span>
<span class="line-added"> 915         return false;</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917     if (!frame() || !frame()-&gt;isMainFrame() || m_allowsDataURLsForMainFrame || frame()-&gt;settings().allowTopNavigationToDataURLs())</span>
<span class="line-added"> 918         return false;</span>
<span class="line-added"> 919 </span>
<span class="line-added"> 920     if (auto* currentDocument = frame()-&gt;document()) {</span>
<span class="line-added"> 921         unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();</span>
<span class="line-added"> 922         ASSERT(identifier);</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924         currentDocument-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Not allowed to navigate top frame to data URL &#39;&quot;, m_response.url().stringCenterEllipsizedToLength(), &quot;&#39;.&quot;), identifier);</span>
<span class="line-added"> 925     }</span>
<span class="line-added"> 926     RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: cannot show URL (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928     return true;</span>
<span class="line-added"> 929 }</span>
<span class="line-added"> 930 </span>
 931 void DocumentLoader::continueAfterContentPolicy(PolicyAction policy)
 932 {
 933     ASSERT(m_waitingForContentPolicy);
 934     m_waitingForContentPolicy = false;
 935     if (isStopping())
 936         return;
 937 
<span class="line-added"> 938     if (!m_frame) {</span>
<span class="line-added"> 939         RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: Policy action %i received by DocumentLoader with null frame&quot;, (int)policy);</span>
<span class="line-added"> 940         return;</span>
<span class="line-added"> 941     }</span>
<span class="line-added"> 942 </span>
 943     switch (policy) {
 944     case PolicyAction::Use: {
<span class="line-modified"> 945         if (!frameLoader()-&gt;client().canShowMIMEType(m_response.mimeType()) || disallowWebArchive() || disallowDataRequest()) {</span>
 946             frameLoader()-&gt;policyChecker().cannotShowMIMEType(m_response);
 947             // Check reachedTerminalState since the load may have already been canceled inside of _handleUnimplementablePolicyWithErrorCode::.
 948             stopLoadingForPolicyChange();
 949             return;
 950         }
 951         break;
 952     }
 953 
 954     case PolicyAction::Download: {
 955         // m_mainResource can be null, e.g. when loading a substitute resource from application cache.
 956         if (!m_mainResource) {
 957             RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: cannot show URL (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 958             mainReceivedError(frameLoader()-&gt;client().cannotShowURLError(m_request));
 959             return;
 960         }
 961 
 962         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 963             InspectorInstrumentation::continueWithPolicyDownload(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 964 
 965         // When starting the request, we didn&#39;t know that it would result in download and not navigation. Now we know that main document URL didn&#39;t change.
 966         // Download may use this knowledge for purposes unrelated to cookies, notably for setting file quarantine data.
 967         frameLoader()-&gt;setOriginalURLForDownloadRequest(m_request);
 968 




 969         if (m_request.url().protocolIsData()) {
 970             // We decode data URL internally, there is no resource load to convert.
 971             frameLoader()-&gt;client().startDownload(m_request);
 972         } else
<span class="line-modified"> 973             frameLoader()-&gt;client().convertMainResourceLoadToDownload(this, m_request, m_response);</span>
 974 
 975         // The main resource might be loading from the memory cache, or its loader might have gone missing.
 976         if (mainResourceLoader()) {
 977             static_cast&lt;ResourceLoader*&gt;(mainResourceLoader())-&gt;didFail(interruptedForPolicyChangeError());
 978             return;
 979         }
 980 
 981         // We must stop loading even if there is no main resource loader. Otherwise, we might remain
 982         // the client of a CachedRawResource that will continue to send us data.
 983         stopLoadingForPolicyChange();
 984         return;
 985     }
 986     case PolicyAction::StopAllLoads:
 987         ASSERT_NOT_REACHED();
<span class="line-modified"> 988 #if !ASSERT_ENABLED</span>
 989         FALLTHROUGH;
 990 #endif
 991     case PolicyAction::Ignore:
 992         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 993             InspectorInstrumentation::continueWithPolicyIgnore(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 994         stopLoadingForPolicyChange();
 995         return;
 996     }
 997 
 998     if (m_response.isHTTP()) {
 999         int status = m_response.httpStatusCode(); // Status may be zero when loading substitute data, in particular from a WebArchive.
1000         if (status &amp;&amp; (status &lt; 200 || status &gt;= 300)) {
1001             bool hostedByObject = frameLoader()-&gt;isHostedByObjectElement();
1002 
1003             frameLoader()-&gt;handleFallbackContent();
1004             // object elements are no longer rendered after we fallback, so don&#39;t
1005             // keep trying to process data from their load
1006 
1007             if (hostedByObject)
1008                 cancelMainResourceLoad(frameLoader()-&gt;cancelledError(m_request));
</pre>
<hr />
<pre>
1040 #endif
1041     frameLoader-&gt;client().committedLoad(this, data, length);
1042 
1043     if (isMultipartReplacingLoad())
1044         frameLoader-&gt;client().didReplaceMultipartContent();
1045 }
1046 
1047 ResourceError DocumentLoader::interruptedForPolicyChangeError() const
1048 {
1049     return frameLoader()-&gt;client().interruptedForPolicyChangeError(request());
1050 }
1051 
1052 void DocumentLoader::stopLoadingForPolicyChange()
1053 {
1054     ResourceError error = interruptedForPolicyChangeError();
1055     error.setType(ResourceError::Type::Cancellation);
1056     cancelMainResourceLoad(error);
1057 }
1058 
1059 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">1060 // https://w3c.github.io/ServiceWorker/#control-and-use-window-client</span>
<span class="line-added">1061 static inline bool shouldUseActiveServiceWorkerFromParent(const Document&amp; document, const Document&amp; parent)</span>
1062 {
<span class="line-modified">1063     return !document.url().protocolIsInHTTPFamily() &amp;&amp; !document.securityOrigin().isUnique() &amp;&amp; parent.securityOrigin().canAccess(document.securityOrigin());</span>


1064 }
1065 #endif
1066 
1067 void DocumentLoader::commitData(const char* bytes, size_t length)
1068 {
1069     if (!m_gotFirstByte) {
1070         m_gotFirstByte = true;
1071         bool hasBegun = m_writer.begin(documentURL(), false);
1072         m_writer.setDocumentWasLoadedAsPartOfNavigation();
1073 
1074         if (SecurityPolicy::allowSubstituteDataAccessToLocal() &amp;&amp; m_originalSubstituteDataWasValid) {
1075             // If this document was loaded with substituteData, then the document can
1076             // load local resources. See https://bugs.webkit.org/show_bug.cgi?id=16756
1077             // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
1078             // discussion.
1079             m_frame-&gt;document()-&gt;securityOrigin().grantLoadLocalResources();
1080         }
1081 
1082         if (frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
1083             return;
1084 
1085 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1086         if (m_archive &amp;&amp; m_archive-&gt;shouldOverrideBaseURL())
1087             m_frame-&gt;document()-&gt;setBaseURLOverride(m_archive-&gt;mainResource()-&gt;url());
1088 #endif
1089 #if ENABLE(SERVICE_WORKER)
1090         if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {
1091             if (m_serviceWorkerRegistrationData &amp;&amp; m_serviceWorkerRegistrationData-&gt;activeWorker) {
1092                 m_frame-&gt;document()-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*m_frame-&gt;document(), WTFMove(m_serviceWorkerRegistrationData-&gt;activeWorker.value())));
1093                 m_serviceWorkerRegistrationData = { };
<span class="line-modified">1094             } else if (auto* parent = m_frame-&gt;document()-&gt;parentDocument()) {</span>
<span class="line-modified">1095                 if (shouldUseActiveServiceWorkerFromParent(*m_frame-&gt;document(), *parent))</span>
1096                     m_frame-&gt;document()-&gt;setActiveServiceWorker(parent-&gt;activeServiceWorker());
1097             }
1098 
<span class="line-modified">1099             if (m_frame-&gt;document()-&gt;activeServiceWorker() || LegacySchemeRegistry::canServiceWorkersHandleURLScheme(m_frame-&gt;document()-&gt;url().protocol().toStringWithoutCopying()))</span>
<span class="line-modified">1100                 m_frame-&gt;document()-&gt;setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnection());</span>
1101 
1102             // We currently unregister the temporary service worker client since we now registered the real document.
1103             // FIXME: We should make the real document use the temporary client identifier.
1104             unregisterTemporaryServiceWorkerClient();
1105         }
1106 #endif
1107         // Call receivedFirstData() exactly once per load. We should only reach this point multiple times
1108         // for multipart loads, and FrameLoader::isReplacing() will be true after the first time.
1109         if (!isMultipartReplacingLoad())
1110             frameLoader()-&gt;receivedFirstData();
1111 
1112         // The load could be canceled under receivedFirstData(), which makes delegate calls and even sometimes dispatches DOM events.
1113         if (!isLoading())
1114             return;
1115 
1116         if (auto* window = m_frame-&gt;document()-&gt;domWindow())
1117             window-&gt;prewarmLocalStorageIfNecessary();
1118 
1119         bool userChosen;
1120         String encoding;
</pre>
<hr />
<pre>
1194     frameLoader()-&gt;client().willReplaceMultipartContent();
1195 
1196     maybeFinishLoadingMultipartContent();
1197     maybeCreateArchive();
1198     m_writer.end();
1199     frameLoader()-&gt;setReplacing();
1200     m_gotFirstByte = false;
1201 
1202     stopLoadingSubresources();
1203     stopLoadingPlugIns();
1204 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1205     clearArchiveResources();
1206 #endif
1207 }
1208 
1209 void DocumentLoader::checkLoadComplete()
1210 {
1211     if (!m_frame || isLoading())
1212         return;
1213 
<span class="line-modified">1214     // ASSERT(this == frameLoader()-&gt;activeDocumentLoader());</span>
1215     m_frame-&gt;document()-&gt;domWindow()-&gt;finishedLoading();
1216 }
1217 
1218 void DocumentLoader::applyPoliciesToSettings()
1219 {
1220     if (!m_frame) {
1221         ASSERT_NOT_REACHED();
1222         return;
1223     }
1224 
1225     if (!m_frame-&gt;isMainFrame())
1226         return;
1227 
1228 #if ENABLE(MEDIA_SOURCE)
1229     m_frame-&gt;settings().setMediaSourceEnabled(m_mediaSourcePolicy == MediaSourcePolicy::Default ? Settings::platformDefaultMediaSourceEnabled() : m_mediaSourcePolicy == MediaSourcePolicy::Enable);
1230 #endif
1231 }
1232 
1233 void DocumentLoader::attachToFrame(Frame&amp; frame)
1234 {
1235     if (m_frame == &amp;frame)
1236         return;
1237 
1238     ASSERT(!m_frame);
1239     observeFrame(&amp;frame);
1240     m_writer.setFrame(frame);
1241     attachToFrame();
1242 
<span class="line-modified">1243 #if ASSERT_ENABLED</span>
1244     m_hasEverBeenAttached = true;
1245 #endif
1246 
1247     applyPoliciesToSettings();
1248 }
1249 
1250 void DocumentLoader::attachToFrame()
1251 {
1252     ASSERT(m_frame);
1253 }
1254 
1255 void DocumentLoader::detachFromFrame()
1256 {
<span class="line-modified">1257 #if ASSERT_ENABLED</span>
1258     if (m_hasEverBeenAttached)
1259         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader twice without an attachToFrame() inbetween&quot;);
1260     else
1261         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader that has never attached to any Frame&quot;);
1262 #endif
1263     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1264     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1265 
1266     // It never makes sense to have a document loader that is detached from its
1267     // frame have any loads active, so kill all the loads.
1268     stopLoading();
1269     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
1270         m_mainResource-&gt;removeClient(*this);
1271 #if ENABLE(CONTENT_FILTERING)
1272     if (m_contentFilter)
1273         m_contentFilter-&gt;stopFilteringMainResource();
1274 #endif
1275 
1276     m_applicationCacheHost-&gt;setDOMApplicationCache(nullptr);
1277 
1278     cancelPolicyCheckIfNeeded();
1279 
1280     // cancelPolicyCheckIfNeeded can clear m_frame if the policy check
1281     // is stopped, resulting in a recursive call into this detachFromFrame.
1282     // If m_frame is nullptr after cancelPolicyCheckIfNeeded, our work is
1283     // already done so just return.
1284     if (!m_frame)
1285         return;
1286 
1287     InspectorInstrumentation::loaderDetachedFromFrame(*m_frame, *this);
1288 
1289     observeFrame(nullptr);
1290 }
1291 
1292 void DocumentLoader::clearMainResourceLoader()
1293 {
1294     m_loadingMainResource = false;
1295 
<span class="line-modified">1296     auto* frameLoader = this-&gt;frameLoader();</span>
<span class="line-added">1297 </span>
<span class="line-added">1298     if (!frameLoader)</span>
<span class="line-added">1299         return;</span>
<span class="line-added">1300 </span>
<span class="line-added">1301     if (this == frameLoader-&gt;activeDocumentLoader())</span>
1302         checkLoadComplete();
1303 }
1304 
1305 #if ENABLE(APPLICATION_MANIFEST)
1306 uint64_t DocumentLoader::loadApplicationManifest()
1307 {
1308     static uint64_t nextCallbackID = 1;
1309 
1310     auto* document = this-&gt;document();
1311     if (!document)
1312         return 0;
1313 
1314     if (!m_frame-&gt;isMainFrame())
1315         return 0;
1316 
1317     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
1318         return 0;
1319 
1320     auto head = document-&gt;head();
1321     if (!head)
</pre>
<hr />
<pre>
1525     if (m_pendingSubstituteResources.isEmpty())
1526         return;
1527     ASSERT(m_frame);
1528     ASSERT(m_frame-&gt;page());
1529     if (m_frame-&gt;page()-&gt;defersLoading())
1530         return;
1531 
1532     auto pendingSubstituteResources = WTFMove(m_pendingSubstituteResources);
1533     for (auto&amp; pendingSubstituteResource : pendingSubstituteResources) {
1534         auto&amp; loader = pendingSubstituteResource.key;
1535         if (auto&amp; resource = pendingSubstituteResource.value)
1536             resource-&gt;deliver(*loader);
1537         else {
1538             // A null resource means that we should fail the load.
1539             // FIXME: Maybe we should use another error here - something like &quot;not in cache&quot;.
1540             loader-&gt;didFail(loader-&gt;cannotShowURLError());
1541         }
1542     }
1543 }
1544 
<span class="line-modified">1545 #if ASSERT_ENABLED</span>
1546 
1547 bool DocumentLoader::isSubstituteLoadPending(ResourceLoader* loader) const
1548 {
1549     return m_pendingSubstituteResources.contains(loader);
1550 }
1551 
<span class="line-modified">1552 #endif // ASSERT_ENABLED</span>
1553 
1554 void DocumentLoader::cancelPendingSubstituteLoad(ResourceLoader* loader)
1555 {
1556     if (m_pendingSubstituteResources.isEmpty())
1557         return;
1558     m_pendingSubstituteResources.remove(loader);
1559     if (m_pendingSubstituteResources.isEmpty())
1560         m_substituteResourceDeliveryTimer.stop();
1561 }
1562 
1563 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1564 
1565 bool DocumentLoader::scheduleArchiveLoad(ResourceLoader&amp; loader, const ResourceRequest&amp; request)
1566 {
1567     if (auto* resource = archiveResourceForURL(request.url())) {
1568         scheduleSubstituteResourceLoad(loader, *resource);
1569         return true;
1570     }
1571 
1572     if (!m_archive)
</pre>
<hr />
<pre>
1699     ASSERT(m_subresourceLoaders.isEmpty());
1700 }
1701 
1702 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
1703 {
1704     // The main resource&#39;s underlying ResourceLoader will ask to be added here.
1705     // It is much simpler to handle special casing of main resource loads if we don&#39;t
1706     // let it be added. In the main resource load case, mainResourceLoader()
1707     // will still be null at this point, but m_gotFirstByte should be false here if and only
1708     // if we are just starting the main resource load.
1709     if (!m_gotFirstByte)
1710         return;
1711     ASSERT(loader-&gt;identifier());
1712     ASSERT(!m_subresourceLoaders.contains(loader-&gt;identifier()));
1713     ASSERT(!mainResourceLoader() || mainResourceLoader() != loader);
1714 
1715     // Application Cache loaders are handled by their ApplicationCacheGroup directly.
1716     if (loader-&gt;options().applicationCacheMode == ApplicationCacheMode::Bypass)
1717         return;
1718 
<span class="line-modified">1719 #if ASSERT_ENABLED</span>
1720     if (document()) {
<span class="line-modified">1721         switch (document()-&gt;backForwardCacheState()) {</span>
<span class="line-modified">1722         case Document::NotInBackForwardCache:</span>
1723             break;
<span class="line-modified">1724         case Document::AboutToEnterBackForwardCache: {</span>
<span class="line-modified">1725             // A page about to enter the BackForwardCache should only be able to start ping loads.</span>
1726             auto* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
1727             ASSERT(cachedResource &amp;&amp; CachedResource::shouldUsePingLoad(cachedResource-&gt;type()));
1728             break;
1729         }
<span class="line-modified">1730         case Document::InBackForwardCache:</span>
<span class="line-modified">1731             // A page in the BackForwardCache should not be able to start loads.</span>
1732             ASSERT_NOT_REACHED();
1733             break;
1734         }
1735     }
1736 #endif
1737 
1738     m_subresourceLoaders.add(loader-&gt;identifier(), loader);
1739 }
1740 
1741 void DocumentLoader::removeSubresourceLoader(LoadCompletionType type, ResourceLoader* loader)
1742 {
1743     ASSERT(loader-&gt;identifier());
1744 
1745     if (!m_subresourceLoaders.remove(loader-&gt;identifier()))
1746         return;
1747     checkLoadComplete();
1748     if (Frame* frame = m_frame)
1749         frame-&gt;loader().subresourceLoadDone(type);
1750 }
1751 
</pre>
<hr />
<pre>
1756 
1757     m_plugInStreamLoaders.add(loader.identifier(), &amp;loader);
1758 }
1759 
1760 void DocumentLoader::removePlugInStreamLoader(ResourceLoader&amp; loader)
1761 {
1762     ASSERT(loader.identifier());
1763     ASSERT(&amp;loader == m_plugInStreamLoaders.get(loader.identifier()));
1764 
1765     m_plugInStreamLoaders.remove(loader.identifier());
1766     checkLoadComplete();
1767 }
1768 
1769 bool DocumentLoader::isMultipartReplacingLoad() const
1770 {
1771     return isLoadingMultipartContent() &amp;&amp; frameLoader()-&gt;isReplacing();
1772 }
1773 
1774 bool DocumentLoader::maybeLoadEmpty()
1775 {
<span class="line-modified">1776     bool shouldLoadEmpty = !m_substituteData.isValid() &amp;&amp; (m_request.url().isEmpty() || LegacySchemeRegistry::shouldLoadURLSchemeAsEmptyDocument(m_request.url().protocol().toStringWithoutCopying()));</span>
1777     if (!shouldLoadEmpty &amp;&amp; !frameLoader()-&gt;client().representationExistsForURLScheme(m_request.url().protocol().toStringWithoutCopying()))
1778         return false;
1779 
1780     if (m_request.url().isEmpty() &amp;&amp; !frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument()) {
1781         m_request.setURL(WTF::blankURL());
1782         if (isLoadingMainResource())
1783             frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
1784     }
1785 
1786     String mimeType = shouldLoadEmpty ? &quot;text/html&quot; : frameLoader()-&gt;client().generatedMIMETypeForURLScheme(m_request.url().protocol().toStringWithoutCopying());
1787     m_response = ResourceResponse(m_request.url(), mimeType, 0, String());
1788     finishedLoading();
1789     return true;
1790 }
1791 
1792 void DocumentLoader::startLoadingMainResource()
1793 {
1794     m_mainDocumentError = ResourceError();
1795     timing().markStartTimeAndFetchStart();
1796     ASSERT(!m_mainResource);
</pre>
<hr />
<pre>
1801 
1802     if (maybeLoadEmpty()) {
1803         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1804         return;
1805     }
1806 
1807 #if ENABLE(CONTENT_FILTERING)
1808     m_contentFilter = !m_substituteData.isValid() ? ContentFilter::create(*this) : nullptr;
1809 #endif
1810 
1811     // Make sure we re-apply the user agent to the Document&#39;s ResourceRequest upon reload in case the embedding
1812     // application has changed it.
1813     m_request.clearHTTPUserAgent();
1814     frameLoader()-&gt;addExtraFieldsToMainResourceRequest(m_request);
1815 
1816     ASSERT(timing().startTime());
1817     ASSERT(timing().fetchStart());
1818 
1819     willSendRequest(ResourceRequest(m_request), ResourceResponse(), [this, protectedThis = WTFMove(protectedThis)] (ResourceRequest&amp;&amp; request) mutable {
1820         m_request = request;
<span class="line-added">1821         // FIXME: Implement local URL interception by getting the service worker of the parent.</span>
1822 
1823         // willSendRequest() may lead to our Frame being detached or cancelling the load via nulling the ResourceRequest.
1824         if (!m_frame || m_request.isNull()) {
1825             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Load canceled after willSendRequest (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1826             return;
1827         }
1828 
1829         request.setRequester(ResourceRequest::Requester::Main);
1830         // If this is a reload the cache layer might have made the previous request conditional. DocumentLoader can&#39;t handle 304 responses itself.
1831         request.makeUnconditional();
1832 
1833         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Starting load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1834 
1835 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">1836         if (m_applicationCacheHost-&gt;canLoadMainResource(request) || m_substituteData.isValid()) {</span>
<span class="line-modified">1837             auto url = request.url();</span>
<span class="line-modified">1838             matchRegistration(url, [request = WTFMove(request), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified">1839                 if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-modified">1840                     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of main document error (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-modified">1841                     return;</span>
<span class="line-modified">1842                 }</span>
1843 
<span class="line-modified">1844                 m_serviceWorkerRegistrationData = WTFMove(registrationData);</span>
<span class="line-added">1845                 // Prefer existing substitute data (from WKWebView.loadData etc) over service worker fetch.</span>
<span class="line-added">1846                 if (this-&gt;tryLoadingSubstituteData()) {</span>
<span class="line-added">1847                     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-added">1848                     return;</span>
<span class="line-added">1849                 }</span>
1850 
<span class="line-modified">1851                 if (!m_serviceWorkerRegistrationData &amp;&amp; this-&gt;tryLoadingRequestFromApplicationCache()) {</span>
<span class="line-modified">1852                     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());</span>
<span class="line-modified">1853                     return;</span>
<span class="line-modified">1854                 }</span>
<span class="line-modified">1855                 this-&gt;loadMainResource(WTFMove(request));</span>
<span class="line-modified">1856             });</span>
<span class="line-modified">1857             return;</span>
<span class="line-modified">1858         }</span>




1859 #else
1860         if (tryLoadingRequestFromApplicationCache()) {
1861             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1862             return;
1863         }

1864 #endif
<span class="line-added">1865         loadMainResource(WTFMove(request));</span>
1866     });
1867 }
1868 





























1869 void DocumentLoader::unregisterTemporaryServiceWorkerClient()
1870 {
1871 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">1872     if (!m_temporaryServiceWorkerClient || !RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled())</span>
1873         return;
1874 
<span class="line-modified">1875     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnection();</span>
<span class="line-modified">1876     serviceWorkerConnection.unregisterServiceWorkerClient(*m_temporaryServiceWorkerClient);</span>

1877 #endif
1878 }
1879 
1880 void DocumentLoader::loadMainResource(ResourceRequest&amp;&amp; request)
1881 {
<span class="line-modified">1882     ResourceLoaderOptions mainResourceLoadOptions(</span>
1883         SendCallbackPolicy::SendCallbacks,
1884         ContentSniffingPolicy::SniffContent,
1885         DataBufferingPolicy::BufferData,
1886         StoredCredentialsPolicy::Use,
1887         ClientCredentialPolicy::MayAskClientForCredentials,
1888         FetchOptions::Credentials::Include,
1889         SecurityCheckPolicy::SkipSecurityCheck,
1890         FetchOptions::Mode::Navigate,
1891         CertificateInfoPolicy::IncludeCertificateInfo,
1892         ContentSecurityPolicyImposition::SkipPolicyCheck,
1893         DefersLoadingPolicy::AllowDefersLoading,
1894         CachingPolicy::AllowCaching);
<span class="line-added">1895 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">1896     if (!m_temporaryServiceWorkerClient) {</span>
<span class="line-added">1897         // The main navigation load will trigger the registration of the temp client.</span>
<span class="line-added">1898         m_temporaryServiceWorkerClient = DocumentIdentifier::generate();</span>
<span class="line-added">1899         ASSERT(!temporaryIdentifierToLoaderMap().contains(*m_temporaryServiceWorkerClient));</span>
<span class="line-added">1900         temporaryIdentifierToLoaderMap().add(*m_temporaryServiceWorkerClient, this);</span>
<span class="line-added">1901     }</span>
<span class="line-added">1902     mainResourceLoadOptions.clientIdentifier = m_temporaryServiceWorkerClient;</span>
<span class="line-added">1903 #endif</span>
1904     CachedResourceRequest mainResourceRequest(WTFMove(request), mainResourceLoadOptions);
1905     if (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) {
1906         // If we are loading the main resource of a subframe, use the cache partition of the main document.
1907         mainResourceRequest.setDomainForCachePartition(*m_frame-&gt;document());
1908     } else {
1909         auto origin = SecurityOrigin::create(mainResourceRequest.resourceRequest().url());
1910         origin-&gt;setStorageBlockingPolicy(frameLoader()-&gt;frame().settings().storageBlockingPolicy());
1911         mainResourceRequest.setDomainForCachePartition(origin-&gt;domainForCachePartition());
1912     }
1913 









1914     m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(WTFMove(mainResourceRequest)).value_or(nullptr);
1915 
1916     if (!m_mainResource) {
1917         // The frame may have gone away if this load was cancelled synchronously and this was the last pending load.
1918         // This is because we may have fired the load event in a parent frame.
1919         if (!m_frame) {
1920             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, frame has gone away (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1921             return;
1922         }
1923 
1924         if (!m_request.url().isValid()) {
1925             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, URL is invalid (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1926             cancelMainResourceLoad(frameLoader()-&gt;client().cannotShowURLError(m_request));
1927             return;
1928         }
1929 
1930         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1931 
1932         setRequest(ResourceRequest());
1933         // If the load was aborted by clearing m_request, it&#39;s possible the ApplicationCacheHost
</pre>
<hr />
<pre>
2157 {
2158     ASSERT(!m_gotFirstByte);
2159     m_pendingNamedContentExtensionStyleSheets.set(identifier, &amp;sheet);
2160 }
2161 
2162 void DocumentLoader::addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID)
2163 {
2164     ASSERT(!m_gotFirstByte);
2165     auto addResult = m_pendingContentExtensionDisplayNoneSelectors.add(identifier, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;());
2166     addResult.iterator-&gt;value.append(std::make_pair(selector, selectorID));
2167 }
2168 #endif
2169 
2170 bool DocumentLoader::isAlwaysOnLoggingAllowed() const
2171 {
2172     return !m_frame || m_frame-&gt;isAlwaysOnLoggingAllowed();
2173 }
2174 
2175 #if USE(QUICK_LOOK)
2176 
<span class="line-modified">2177 void DocumentLoader::previewResponseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response)</span>
<span class="line-added">2178 {</span>
<span class="line-added">2179     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);</span>
<span class="line-added">2180     m_response = response;</span>
<span class="line-added">2181 }</span>
<span class="line-added">2182 </span>
<span class="line-added">2183 void DocumentLoader::setPreviewConverter(RefPtr&lt;PreviewConverter&gt;&amp;&amp; previewConverter)</span>
2184 {
2185     m_previewConverter = WTFMove(previewConverter);
2186 }
2187 
2188 PreviewConverter* DocumentLoader::previewConverter() const
2189 {
2190     return m_previewConverter.get();
2191 }
2192 
2193 #endif
2194 
2195 void DocumentLoader::addConsoleMessage(MessageSource messageSource, MessageLevel messageLevel, const String&amp; message, unsigned long requestIdentifier)
2196 {
2197     static_cast&lt;ScriptExecutionContext*&gt;(m_frame-&gt;document())-&gt;addConsoleMessage(messageSource, messageLevel, message, requestIdentifier);
2198 }
2199 
2200 void DocumentLoader::sendCSPViolationReport(URL&amp;&amp; reportURL, Ref&lt;FormData&gt;&amp;&amp; report)
2201 {
2202     PingLoader::sendViolationReport(*m_frame, WTFMove(reportURL), WTFMove(report), ViolationReportType::ContentSecurityPolicy);
2203 }
2204 
2205 void DocumentLoader::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
2206 {
2207     m_frame-&gt;document()-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(eventInit));
2208 }
2209 
<span class="line-added">2210 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2211 void DocumentLoader::dataReceivedThroughContentFilter(const char* data, int size)</span>
<span class="line-added">2212 {</span>
<span class="line-added">2213     dataReceived(data, size);</span>
<span class="line-added">2214 }</span>
<span class="line-added">2215 </span>
<span class="line-added">2216 void DocumentLoader::cancelMainResourceLoadForContentFilter(const ResourceError&amp; error)</span>
<span class="line-added">2217 {</span>
<span class="line-added">2218     cancelMainResourceLoad(error);</span>
<span class="line-added">2219 }</span>
<span class="line-added">2220 </span>
<span class="line-added">2221 void DocumentLoader::handleProvisionalLoadFailureFromContentFilter(const URL&amp; blockedPageURL, SubstituteData&amp; substituteData)</span>
<span class="line-added">2222 {</span>
<span class="line-added">2223     frameLoader()-&gt;load(FrameLoadRequest(*frame(), blockedPageURL, ShouldOpenExternalURLsPolicy::ShouldNotAllow, substituteData));</span>
<span class="line-added">2224 }</span>
<span class="line-added">2225 </span>
<span class="line-added">2226 ResourceError DocumentLoader::contentFilterDidBlock(ContentFilterUnblockHandler unblockHandler, WTF::String&amp;&amp; unblockRequestDeniedScript)</span>
<span class="line-added">2227 {</span>
<span class="line-added">2228     unblockHandler.setUnreachableURL(documentURL());</span>
<span class="line-added">2229     if (!unblockRequestDeniedScript.isEmpty() &amp;&amp; frame()) {</span>
<span class="line-added">2230         unblockHandler.wrapWithDecisionHandler([scriptController = makeWeakPtr(frame()-&gt;script()), script = unblockRequestDeniedScript.isolatedCopy()](bool unblocked) {</span>
<span class="line-added">2231             if (!unblocked &amp;&amp; scriptController)</span>
<span class="line-added">2232                 scriptController-&gt;executeScriptIgnoringException(script);</span>
<span class="line-added">2233         });</span>
<span class="line-added">2234     }</span>
<span class="line-added">2235     frameLoader()-&gt;client().contentFilterDidBlockLoad(WTFMove(unblockHandler));</span>
<span class="line-added">2236     return frameLoader()-&gt;blockedByContentFilterError(request());</span>
<span class="line-added">2237 }</span>
<span class="line-added">2238 #endif // ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2239 </span>
2240 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CrossOriginPreflightChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperShaderProgram.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperPlatformLayerProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperShaderProgram.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperShaderProgram.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
143         GLSL_DIRECTIVE(define SamplerFunction texture2DRect) \
144     GLSL_DIRECTIVE(else) \
145         GLSL_DIRECTIVE(define SamplerType sampler2D) \
146         GLSL_DIRECTIVE(define SamplerFunction texture2D) \
147     GLSL_DIRECTIVE(endif)
148 
149 #define ANTIALIASING_TEX_COORD_DIRECTIVE \
150     GLSL_DIRECTIVE(if defined(ENABLE_Antialiasing) &amp;&amp; defined(ENABLE_Texture)) \
151         GLSL_DIRECTIVE(define transformTexCoord fragmentTransformTexCoord) \
152     GLSL_DIRECTIVE(else) \
153         GLSL_DIRECTIVE(define transformTexCoord vertexTransformTexCoord) \
154     GLSL_DIRECTIVE(endif)
155 
156 #define ENABLE_APPLIER(Name) &quot;#define ENABLE_&quot;#Name&quot;\n#define apply&quot;#Name&quot;IfNeeded apply&quot;#Name&quot;\n&quot;
157 #define DISABLE_APPLIER(Name) &quot;#define apply&quot;#Name&quot;IfNeeded noop\n&quot;
158 #define BLUR_CONSTANTS \
159     GLSL_DIRECTIVE(define GAUSSIAN_KERNEL_HALF_WIDTH 11) \
160     GLSL_DIRECTIVE(define GAUSSIAN_KERNEL_STEP 0.2)
161 
162 








163 // Common header for all versions. We define the matrices variables here to keep the precision
164 // directives scope: the first one applies to the matrices variables and the next one to the
165 // rest of them. The precision is only used in GLES.
166 static const char* fragmentTemplateHeaderCommon =
167     RECT_TEXTURE_DIRECTIVE
168     ANTIALIASING_TEX_COORD_DIRECTIVE
169     BLUR_CONSTANTS

170 #if USE(OPENGL_ES)
171     TEXTURE_SPACE_MATRIX_PRECISION_DIRECTIVE
<span class="line-removed">172 #endif</span>
<span class="line-removed">173 #if USE(OPENGL_ES)</span>
174     STRINGIFY(
175         precision TextureSpaceMatrixPrecision float;
176     )
177 #endif
178     STRINGIFY(
179         uniform mat4 u_textureSpaceMatrix;
180         uniform mat4 u_textureColorSpaceMatrix;
181     )
182 #if USE(OPENGL_ES)
183     STRINGIFY(
184         precision mediump float;
185     )
186 #endif
187     ;
188 
189 // Input/output variables definition for both GLES and OpenGL &lt; 3.2.
190 static const char* fragmentTemplateLT320Vars =
191     STRINGIFY(
192         varying float v_antialias;
193         varying vec2 v_texCoord;
194         varying vec2 v_transformedTexCoord;
195     );
196 
197 #if !USE(OPENGL_ES)
198 // Input/output variables definition for OpenGL &gt;= 3.2.
199 static const char* fragmentTemplateGE320Vars =
200     STRINGIFY(
201         in float v_antialias;
202         in vec2 v_texCoord;
203         in vec2 v_transformedTexCoord;
204     );
205 #endif
206 
207 static const char* fragmentTemplateCommon =
208     STRINGIFY(
209         uniform SamplerType s_sampler;



210         uniform sampler2D s_contentTexture;

211         uniform float u_opacity;
212         uniform float u_filterAmount;

213         uniform vec2 u_blurRadius;
214         uniform vec2 u_shadowOffset;
215         uniform vec4 u_color;
216         uniform float u_gaussianKernel[GAUSSIAN_KERNEL_HALF_WIDTH];
217 
218         void noop(inout vec4 dummyParameter) { }
219         void noop(inout vec4 dummyParameter, vec2 texCoord) { }
220         void noop(inout vec2 dummyParameter) { }
221 
222         float antialias() { return smoothstep(0., 1., v_antialias); }
223 
224         vec2 fragmentTransformTexCoord()
225         {
226             vec4 clampedPosition = clamp(vec4(v_texCoord, 0., 1.), 0., 1.);
227             return (u_textureSpaceMatrix * clampedPosition).xy;
228         }
229 
230         vec2 vertexTransformTexCoord() { return v_transformedTexCoord; }
231 
232         void applyManualRepeat(inout vec2 pos) { pos = fract(pos); }
233 
<span class="line-modified">234         void applyTexture(inout vec4 color, vec2 texCoord) { color = u_textureColorSpaceMatrix * SamplerFunction(s_sampler, texCoord); }</span>


































235         void applyOpacity(inout vec4 color) { color *= u_opacity; }
236         void applyAntialiasing(inout vec4 color) { color *= antialias(); }
237 
238         void applyGrayscaleFilter(inout vec4 color)
239         {
240             float amount = 1.0 - u_filterAmount;
241             color = vec4((0.2126 + 0.7874 * amount) * color.r + (0.7152 - 0.7152 * amount) * color.g + (0.0722 - 0.0722 * amount) * color.b,
242                 (0.2126 - 0.2126 * amount) * color.r + (0.7152 + 0.2848 * amount) * color.g + (0.0722 - 0.0722 * amount) * color.b,
243                 (0.2126 - 0.2126 * amount) * color.r + (0.7152 - 0.7152 * amount) * color.g + (0.0722 + 0.9278 * amount) * color.b,
244                 color.a);
245         }
246 
247         void applySepiaFilter(inout vec4 color)
248         {
249             float amount = 1.0 - u_filterAmount;
250             color = vec4((0.393 + 0.607 * amount) * color.r + (0.769 - 0.769 * amount) * color.g + (0.189 - 0.189 * amount) * color.b,
251                 (0.349 - 0.349 * amount) * color.r + (0.686 + 0.314 * amount) * color.g + (0.168 - 0.168 * amount) * color.b,
252                 (0.272 - 0.272 * amount) * color.r + (0.534 - 0.534 * amount) * color.g + (0.131 + 0.869 * amount) * color.b,
253                 color.a);
254         }
</pre>
<hr />
<pre>
319 
320         void applyAlphaBlur(inout vec4 color, vec2 texCoord)
321         {
322             float total = sampleAlphaAtRadius(0., texCoord) * u_gaussianKernel[0];
323             for (int i = 1; i &lt; GAUSSIAN_KERNEL_HALF_WIDTH; i++) {
324                 total += sampleAlphaAtRadius(float(i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
325                 total += sampleAlphaAtRadius(float(-1 * i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
326             }
327 
328             color *= total;
329         }
330 
331         vec4 sourceOver(vec4 src, vec4 dst) { return src + dst * (1. - dst.a); }
332 
333         void applyContentTexture(inout vec4 color, vec2 texCoord)
334         {
335             vec4 contentColor = texture2D(s_contentTexture, texCoord);
336             color = sourceOver(contentColor, color);
337         }
338 






339         void applySolidColor(inout vec4 color) { color *= u_color; }
340 
341         void main(void)
342         {
343             vec4 color = vec4(1., 1., 1., 1.);
344             vec2 texCoord = transformTexCoord();
345             applyManualRepeatIfNeeded(texCoord);
<span class="line-modified">346             applyTextureIfNeeded(color, texCoord);</span>




347             applySolidColorIfNeeded(color);
348             applyAntialiasingIfNeeded(color);
349             applyOpacityIfNeeded(color);
350             applyGrayscaleFilterIfNeeded(color);
351             applySepiaFilterIfNeeded(color);
352             applySaturateFilterIfNeeded(color);
353             applyHueRotateFilterIfNeeded(color);
354             applyInvertFilterIfNeeded(color);
355             applyBrightnessFilterIfNeeded(color);
356             applyContrastFilterIfNeeded(color);
357             applyOpacityFilterIfNeeded(color);
358             applyBlurFilterIfNeeded(color, texCoord);
359             applyAlphaBlurIfNeeded(color, texCoord);
360             applyContentTextureIfNeeded(color, texCoord);

361             gl_FragColor = color;
362         }
363     );
364 
365 Ref&lt;TextureMapperShaderProgram&gt; TextureMapperShaderProgram::create(TextureMapperShaderProgram::Options options)
366 {
367 #define SET_APPLIER_FROM_OPTIONS(Applier) \
368     optionsApplierBuilder.append(\
369         (options &amp; TextureMapperShaderProgram::Applier) ? ENABLE_APPLIER(Applier) : DISABLE_APPLIER(Applier))
370 
371     StringBuilder optionsApplierBuilder;
<span class="line-modified">372     SET_APPLIER_FROM_OPTIONS(Texture);</span>




373     SET_APPLIER_FROM_OPTIONS(Rect);
374     SET_APPLIER_FROM_OPTIONS(SolidColor);
375     SET_APPLIER_FROM_OPTIONS(Opacity);
376     SET_APPLIER_FROM_OPTIONS(Antialiasing);
377     SET_APPLIER_FROM_OPTIONS(GrayscaleFilter);
378     SET_APPLIER_FROM_OPTIONS(SepiaFilter);
379     SET_APPLIER_FROM_OPTIONS(SaturateFilter);
380     SET_APPLIER_FROM_OPTIONS(HueRotateFilter);
381     SET_APPLIER_FROM_OPTIONS(BrightnessFilter);
382     SET_APPLIER_FROM_OPTIONS(ContrastFilter);
383     SET_APPLIER_FROM_OPTIONS(InvertFilter);
384     SET_APPLIER_FROM_OPTIONS(OpacityFilter);
385     SET_APPLIER_FROM_OPTIONS(BlurFilter);
386     SET_APPLIER_FROM_OPTIONS(AlphaBlur);
387     SET_APPLIER_FROM_OPTIONS(ContentTexture);
388     SET_APPLIER_FROM_OPTIONS(ManualRepeat);

389 
390     StringBuilder vertexShaderBuilder;
391 
392     // OpenGL &gt;= 3.2 requires a #version directive at the beginning of the code.
393 #if !USE(OPENGL_ES)
394     unsigned glVersion = GLContext::current()-&gt;version();
395     if (glVersion &gt;= 320)
396         vertexShaderBuilder.append(GLSL_DIRECTIVE(version 150));
397 #endif
398 
399     // Append the options.
400     vertexShaderBuilder.append(optionsApplierBuilder.toString());
401 
402     // Append the appropriate input/output variable definitions.
403 #if USE(OPENGL_ES)
404     vertexShaderBuilder.append(vertexTemplateLT320Vars);
405 #else
406     if (glVersion &gt;= 320)
407         vertexShaderBuilder.append(vertexTemplateGE320Vars);
408     else
</pre>
</td>
<td>
<hr />
<pre>
143         GLSL_DIRECTIVE(define SamplerFunction texture2DRect) \
144     GLSL_DIRECTIVE(else) \
145         GLSL_DIRECTIVE(define SamplerType sampler2D) \
146         GLSL_DIRECTIVE(define SamplerFunction texture2D) \
147     GLSL_DIRECTIVE(endif)
148 
149 #define ANTIALIASING_TEX_COORD_DIRECTIVE \
150     GLSL_DIRECTIVE(if defined(ENABLE_Antialiasing) &amp;&amp; defined(ENABLE_Texture)) \
151         GLSL_DIRECTIVE(define transformTexCoord fragmentTransformTexCoord) \
152     GLSL_DIRECTIVE(else) \
153         GLSL_DIRECTIVE(define transformTexCoord vertexTransformTexCoord) \
154     GLSL_DIRECTIVE(endif)
155 
156 #define ENABLE_APPLIER(Name) &quot;#define ENABLE_&quot;#Name&quot;\n#define apply&quot;#Name&quot;IfNeeded apply&quot;#Name&quot;\n&quot;
157 #define DISABLE_APPLIER(Name) &quot;#define apply&quot;#Name&quot;IfNeeded noop\n&quot;
158 #define BLUR_CONSTANTS \
159     GLSL_DIRECTIVE(define GAUSSIAN_KERNEL_HALF_WIDTH 11) \
160     GLSL_DIRECTIVE(define GAUSSIAN_KERNEL_STEP 0.2)
161 
162 
<span class="line-added">163 #define OES_EGL_IMAGE_EXTERNAL_DIRECTIVE \</span>
<span class="line-added">164     GLSL_DIRECTIVE(ifdef ENABLE_TextureExternalOES) \</span>
<span class="line-added">165         GLSL_DIRECTIVE(extension GL_OES_EGL_image_external : require) \</span>
<span class="line-added">166         GLSL_DIRECTIVE(define SamplerExternalOESType samplerExternalOES) \</span>
<span class="line-added">167     GLSL_DIRECTIVE(else) \</span>
<span class="line-added">168         GLSL_DIRECTIVE(define SamplerExternalOESType sampler2D) \</span>
<span class="line-added">169     GLSL_DIRECTIVE(endif)</span>
<span class="line-added">170 </span>
171 // Common header for all versions. We define the matrices variables here to keep the precision
172 // directives scope: the first one applies to the matrices variables and the next one to the
173 // rest of them. The precision is only used in GLES.
174 static const char* fragmentTemplateHeaderCommon =
175     RECT_TEXTURE_DIRECTIVE
176     ANTIALIASING_TEX_COORD_DIRECTIVE
177     BLUR_CONSTANTS
<span class="line-added">178     OES_EGL_IMAGE_EXTERNAL_DIRECTIVE</span>
179 #if USE(OPENGL_ES)
180     TEXTURE_SPACE_MATRIX_PRECISION_DIRECTIVE


181     STRINGIFY(
182         precision TextureSpaceMatrixPrecision float;
183     )
184 #endif
185     STRINGIFY(
186         uniform mat4 u_textureSpaceMatrix;
187         uniform mat4 u_textureColorSpaceMatrix;
188     )
189 #if USE(OPENGL_ES)
190     STRINGIFY(
191         precision mediump float;
192     )
193 #endif
194     ;
195 
196 // Input/output variables definition for both GLES and OpenGL &lt; 3.2.
197 static const char* fragmentTemplateLT320Vars =
198     STRINGIFY(
199         varying float v_antialias;
200         varying vec2 v_texCoord;
201         varying vec2 v_transformedTexCoord;
202     );
203 
204 #if !USE(OPENGL_ES)
205 // Input/output variables definition for OpenGL &gt;= 3.2.
206 static const char* fragmentTemplateGE320Vars =
207     STRINGIFY(
208         in float v_antialias;
209         in vec2 v_texCoord;
210         in vec2 v_transformedTexCoord;
211     );
212 #endif
213 
214 static const char* fragmentTemplateCommon =
215     STRINGIFY(
216         uniform SamplerType s_sampler;
<span class="line-added">217         uniform SamplerType s_samplerY;</span>
<span class="line-added">218         uniform SamplerType s_samplerU;</span>
<span class="line-added">219         uniform SamplerType s_samplerV;</span>
220         uniform sampler2D s_contentTexture;
<span class="line-added">221         uniform SamplerExternalOESType s_externalOESTexture;</span>
222         uniform float u_opacity;
223         uniform float u_filterAmount;
<span class="line-added">224         uniform mat3 u_yuvToRgb;</span>
225         uniform vec2 u_blurRadius;
226         uniform vec2 u_shadowOffset;
227         uniform vec4 u_color;
228         uniform float u_gaussianKernel[GAUSSIAN_KERNEL_HALF_WIDTH];
229 
230         void noop(inout vec4 dummyParameter) { }
231         void noop(inout vec4 dummyParameter, vec2 texCoord) { }
232         void noop(inout vec2 dummyParameter) { }
233 
234         float antialias() { return smoothstep(0., 1., v_antialias); }
235 
236         vec2 fragmentTransformTexCoord()
237         {
238             vec4 clampedPosition = clamp(vec4(v_texCoord, 0., 1.), 0., 1.);
239             return (u_textureSpaceMatrix * clampedPosition).xy;
240         }
241 
242         vec2 vertexTransformTexCoord() { return v_transformedTexCoord; }
243 
244         void applyManualRepeat(inout vec2 pos) { pos = fract(pos); }
245 
<span class="line-modified">246         void applyTextureRGB(inout vec4 color, vec2 texCoord) { color = u_textureColorSpaceMatrix * SamplerFunction(s_sampler, texCoord); }</span>
<span class="line-added">247 </span>
<span class="line-added">248         vec3 yuvToRgb(float y, float u, float v)</span>
<span class="line-added">249         {</span>
<span class="line-added">250             // yuv is either bt601 or bt709 so the offset is the same</span>
<span class="line-added">251             vec3 yuv = vec3(y - 0.0625, u - 0.5, v - 0.5);</span>
<span class="line-added">252             return yuv * u_yuvToRgb;</span>
<span class="line-added">253         }</span>
<span class="line-added">254         void applyTextureYUV(inout vec4 color, vec2 texCoord)</span>
<span class="line-added">255         {</span>
<span class="line-added">256             float y = SamplerFunction(s_samplerY, texCoord).r;</span>
<span class="line-added">257             float u = SamplerFunction(s_samplerU, texCoord).r;</span>
<span class="line-added">258             float v = SamplerFunction(s_samplerV, texCoord).r;</span>
<span class="line-added">259             vec4 data = vec4(yuvToRgb(y, u, v), 1.0);</span>
<span class="line-added">260             color = u_textureColorSpaceMatrix * data;</span>
<span class="line-added">261         }</span>
<span class="line-added">262         void applyTextureNV12(inout vec4 color, vec2 texCoord)</span>
<span class="line-added">263         {</span>
<span class="line-added">264             float y = SamplerFunction(s_samplerY, texCoord).r;</span>
<span class="line-added">265             vec2 uv = SamplerFunction(s_samplerU, texCoord).rg;</span>
<span class="line-added">266             vec4 data = vec4(yuvToRgb(y, uv.x, uv.y), 1.0);</span>
<span class="line-added">267             color = u_textureColorSpaceMatrix * data;</span>
<span class="line-added">268         }</span>
<span class="line-added">269         void applyTextureNV21(inout vec4 color, vec2 texCoord)</span>
<span class="line-added">270         {</span>
<span class="line-added">271             float y = SamplerFunction(s_samplerY, texCoord).r;</span>
<span class="line-added">272             vec2 uv = SamplerFunction(s_samplerU, texCoord).gr;</span>
<span class="line-added">273             vec4 data = vec4(yuvToRgb(y, uv.x, uv.y), 1.0);</span>
<span class="line-added">274             color = u_textureColorSpaceMatrix * data;</span>
<span class="line-added">275         }</span>
<span class="line-added">276         void applyTexturePackedYUV(inout vec4 color, vec2 texCoord)</span>
<span class="line-added">277         {</span>
<span class="line-added">278             vec4 data = SamplerFunction(s_sampler, texCoord);</span>
<span class="line-added">279             color = u_textureColorSpaceMatrix * vec4(yuvToRgb(data.b, data.g, data.r), data.a);</span>
<span class="line-added">280         }</span>
281         void applyOpacity(inout vec4 color) { color *= u_opacity; }
282         void applyAntialiasing(inout vec4 color) { color *= antialias(); }
283 
284         void applyGrayscaleFilter(inout vec4 color)
285         {
286             float amount = 1.0 - u_filterAmount;
287             color = vec4((0.2126 + 0.7874 * amount) * color.r + (0.7152 - 0.7152 * amount) * color.g + (0.0722 - 0.0722 * amount) * color.b,
288                 (0.2126 - 0.2126 * amount) * color.r + (0.7152 + 0.2848 * amount) * color.g + (0.0722 - 0.0722 * amount) * color.b,
289                 (0.2126 - 0.2126 * amount) * color.r + (0.7152 - 0.7152 * amount) * color.g + (0.0722 + 0.9278 * amount) * color.b,
290                 color.a);
291         }
292 
293         void applySepiaFilter(inout vec4 color)
294         {
295             float amount = 1.0 - u_filterAmount;
296             color = vec4((0.393 + 0.607 * amount) * color.r + (0.769 - 0.769 * amount) * color.g + (0.189 - 0.189 * amount) * color.b,
297                 (0.349 - 0.349 * amount) * color.r + (0.686 + 0.314 * amount) * color.g + (0.168 - 0.168 * amount) * color.b,
298                 (0.272 - 0.272 * amount) * color.r + (0.534 - 0.534 * amount) * color.g + (0.131 + 0.869 * amount) * color.b,
299                 color.a);
300         }
</pre>
<hr />
<pre>
365 
366         void applyAlphaBlur(inout vec4 color, vec2 texCoord)
367         {
368             float total = sampleAlphaAtRadius(0., texCoord) * u_gaussianKernel[0];
369             for (int i = 1; i &lt; GAUSSIAN_KERNEL_HALF_WIDTH; i++) {
370                 total += sampleAlphaAtRadius(float(i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
371                 total += sampleAlphaAtRadius(float(-1 * i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
372             }
373 
374             color *= total;
375         }
376 
377         vec4 sourceOver(vec4 src, vec4 dst) { return src + dst * (1. - dst.a); }
378 
379         void applyContentTexture(inout vec4 color, vec2 texCoord)
380         {
381             vec4 contentColor = texture2D(s_contentTexture, texCoord);
382             color = sourceOver(contentColor, color);
383         }
384 
<span class="line-added">385         void applyTextureExternalOES(inout vec4 color, vec2 texCoord)</span>
<span class="line-added">386         {</span>
<span class="line-added">387             vec4 contentColor = texture2D(s_externalOESTexture, texCoord);</span>
<span class="line-added">388             color = sourceOver(contentColor, color);</span>
<span class="line-added">389         }</span>
<span class="line-added">390 </span>
391         void applySolidColor(inout vec4 color) { color *= u_color; }
392 
393         void main(void)
394         {
395             vec4 color = vec4(1., 1., 1., 1.);
396             vec2 texCoord = transformTexCoord();
397             applyManualRepeatIfNeeded(texCoord);
<span class="line-modified">398             applyTextureRGBIfNeeded(color, texCoord);</span>
<span class="line-added">399             applyTextureYUVIfNeeded(color, texCoord);</span>
<span class="line-added">400             applyTextureNV12IfNeeded(color, texCoord);</span>
<span class="line-added">401             applyTextureNV21IfNeeded(color, texCoord);</span>
<span class="line-added">402             applyTexturePackedYUVIfNeeded(color, texCoord);</span>
403             applySolidColorIfNeeded(color);
404             applyAntialiasingIfNeeded(color);
405             applyOpacityIfNeeded(color);
406             applyGrayscaleFilterIfNeeded(color);
407             applySepiaFilterIfNeeded(color);
408             applySaturateFilterIfNeeded(color);
409             applyHueRotateFilterIfNeeded(color);
410             applyInvertFilterIfNeeded(color);
411             applyBrightnessFilterIfNeeded(color);
412             applyContrastFilterIfNeeded(color);
413             applyOpacityFilterIfNeeded(color);
414             applyBlurFilterIfNeeded(color, texCoord);
415             applyAlphaBlurIfNeeded(color, texCoord);
416             applyContentTextureIfNeeded(color, texCoord);
<span class="line-added">417             applyTextureExternalOESIfNeeded(color, texCoord);</span>
418             gl_FragColor = color;
419         }
420     );
421 
422 Ref&lt;TextureMapperShaderProgram&gt; TextureMapperShaderProgram::create(TextureMapperShaderProgram::Options options)
423 {
424 #define SET_APPLIER_FROM_OPTIONS(Applier) \
425     optionsApplierBuilder.append(\
426         (options &amp; TextureMapperShaderProgram::Applier) ? ENABLE_APPLIER(Applier) : DISABLE_APPLIER(Applier))
427 
428     StringBuilder optionsApplierBuilder;
<span class="line-modified">429     SET_APPLIER_FROM_OPTIONS(TextureRGB);</span>
<span class="line-added">430     SET_APPLIER_FROM_OPTIONS(TextureYUV);</span>
<span class="line-added">431     SET_APPLIER_FROM_OPTIONS(TextureNV12);</span>
<span class="line-added">432     SET_APPLIER_FROM_OPTIONS(TextureNV21);</span>
<span class="line-added">433     SET_APPLIER_FROM_OPTIONS(TexturePackedYUV);</span>
434     SET_APPLIER_FROM_OPTIONS(Rect);
435     SET_APPLIER_FROM_OPTIONS(SolidColor);
436     SET_APPLIER_FROM_OPTIONS(Opacity);
437     SET_APPLIER_FROM_OPTIONS(Antialiasing);
438     SET_APPLIER_FROM_OPTIONS(GrayscaleFilter);
439     SET_APPLIER_FROM_OPTIONS(SepiaFilter);
440     SET_APPLIER_FROM_OPTIONS(SaturateFilter);
441     SET_APPLIER_FROM_OPTIONS(HueRotateFilter);
442     SET_APPLIER_FROM_OPTIONS(BrightnessFilter);
443     SET_APPLIER_FROM_OPTIONS(ContrastFilter);
444     SET_APPLIER_FROM_OPTIONS(InvertFilter);
445     SET_APPLIER_FROM_OPTIONS(OpacityFilter);
446     SET_APPLIER_FROM_OPTIONS(BlurFilter);
447     SET_APPLIER_FROM_OPTIONS(AlphaBlur);
448     SET_APPLIER_FROM_OPTIONS(ContentTexture);
449     SET_APPLIER_FROM_OPTIONS(ManualRepeat);
<span class="line-added">450     SET_APPLIER_FROM_OPTIONS(TextureExternalOES);</span>
451 
452     StringBuilder vertexShaderBuilder;
453 
454     // OpenGL &gt;= 3.2 requires a #version directive at the beginning of the code.
455 #if !USE(OPENGL_ES)
456     unsigned glVersion = GLContext::current()-&gt;version();
457     if (glVersion &gt;= 320)
458         vertexShaderBuilder.append(GLSL_DIRECTIVE(version 150));
459 #endif
460 
461     // Append the options.
462     vertexShaderBuilder.append(optionsApplierBuilder.toString());
463 
464     // Append the appropriate input/output variable definitions.
465 #if USE(OPENGL_ES)
466     vertexShaderBuilder.append(vertexTemplateLT320Vars);
467 #else
468     if (glVersion &gt;= 320)
469         vertexShaderBuilder.append(vertexTemplateGE320Vars);
470     else
</pre>
</td>
</tr>
</table>
<center><a href="TextureMapperPlatformLayerProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperShaderProgram.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
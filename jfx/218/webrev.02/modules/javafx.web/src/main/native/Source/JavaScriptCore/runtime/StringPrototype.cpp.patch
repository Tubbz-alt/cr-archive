diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp
@@ -37,10 +37,11 @@
 #include "JSCInlines.h"
 #include "JSFunction.h"
 #include "JSGlobalObjectFunctions.h"
 #include "JSStringIterator.h"
 #include "Lookup.h"
+#include "ObjectConstructor.h"
 #include "ObjectPrototype.h"
 #include "ParseInt.h"
 #include "PropertyNameArray.h"
 #include "RegExpCache.h"
 #include "RegExpConstructor.h"
@@ -59,34 +60,35 @@
 
 namespace JSC {
 
 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState*);
-EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject*, CallFrame*);
 
 }
 
 #include "StringPrototype.lut.h"
 
@@ -94,32 +96,33 @@
 
 const ClassInfo StringPrototype::s_info = { "String", &StringObject::s_info, &stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
 
 /* Source for StringConstructor.lut.h
 @begin stringPrototypeTable
-    concat    JSBuiltin    DontEnum|Function 1
-    match     JSBuiltin    DontEnum|Function 1
-    matchAll  JSBuiltin    DontEnum|Function 1
-    padStart  JSBuiltin    DontEnum|Function 1
-    padEnd    JSBuiltin    DontEnum|Function 1
-    repeat    JSBuiltin    DontEnum|Function 1
-    replace   JSBuiltin    DontEnum|Function 2
-    search    JSBuiltin    DontEnum|Function 1
-    split     JSBuiltin    DontEnum|Function 1
-    anchor    JSBuiltin    DontEnum|Function 1
-    big       JSBuiltin    DontEnum|Function 0
-    bold      JSBuiltin    DontEnum|Function 0
-    blink     JSBuiltin    DontEnum|Function 0
-    fixed     JSBuiltin    DontEnum|Function 0
-    fontcolor JSBuiltin    DontEnum|Function 1
-    fontsize  JSBuiltin    DontEnum|Function 1
-    italics   JSBuiltin    DontEnum|Function 0
-    link      JSBuiltin    DontEnum|Function 1
-    small     JSBuiltin    DontEnum|Function 0
-    strike    JSBuiltin    DontEnum|Function 0
-    sub       JSBuiltin    DontEnum|Function 0
-    sup       JSBuiltin    DontEnum|Function 0
+    concat        JSBuiltin    DontEnum|Function 1
+    match         JSBuiltin    DontEnum|Function 1
+    matchAll      JSBuiltin    DontEnum|Function 1
+    padStart      JSBuiltin    DontEnum|Function 1
+    padEnd        JSBuiltin    DontEnum|Function 1
+    repeat        JSBuiltin    DontEnum|Function 1
+    replace       JSBuiltin    DontEnum|Function 2
+    replaceAll    JSBuiltin    DontEnum|Function 2
+    search        JSBuiltin    DontEnum|Function 1
+    split         JSBuiltin    DontEnum|Function 1
+    anchor        JSBuiltin    DontEnum|Function 1
+    big           JSBuiltin    DontEnum|Function 0
+    bold          JSBuiltin    DontEnum|Function 0
+    blink         JSBuiltin    DontEnum|Function 0
+    fixed         JSBuiltin    DontEnum|Function 0
+    fontcolor     JSBuiltin    DontEnum|Function 1
+    fontsize      JSBuiltin    DontEnum|Function 1
+    italics       JSBuiltin    DontEnum|Function 0
+    link          JSBuiltin    DontEnum|Function 1
+    small         JSBuiltin    DontEnum|Function 0
+    strike        JSBuiltin    DontEnum|Function 0
+    sub           JSBuiltin    DontEnum|Function 0
+    sup           JSBuiltin    DontEnum|Function 0
 @end
 */
 
 // ECMA 15.5.4
 StringPrototype::StringPrototype(VM& vm, Structure* structure)
@@ -134,15 +137,16 @@
 
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->toString, stringProtoFuncToString, static_cast<unsigned>(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->valueOf, stringProtoFuncToString, static_cast<unsigned>(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION("charAt", stringProtoFuncCharAt, static_cast<unsigned>(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION("charCodeAt", stringProtoFuncCharCodeAt, static_cast<unsigned>(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
-    JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("codePointAt", stringProtoFuncCodePointAt, static_cast<unsigned>(PropertyAttribute::DontEnum), 1);
+    JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION("codePointAt", stringProtoFuncCodePointAt, static_cast<unsigned>(PropertyAttribute::DontEnum), 1, StringPrototypeCodePointAtIntrinsic);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("indexOf", stringProtoFuncIndexOf, static_cast<unsigned>(PropertyAttribute::DontEnum), 1);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("lastIndexOf", stringProtoFuncLastIndexOf, static_cast<unsigned>(PropertyAttribute::DontEnum), 1);
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast<unsigned>(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast<unsigned>(PropertyAttribute::DontEnum), 2);
+    JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->builtinNames().replaceAllUsingStringSearchPrivateName(), stringProtoFuncReplaceAllUsingStringSearch, static_cast<unsigned>(PropertyAttribute::DontEnum), 2);
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION("slice", stringProtoFuncSlice, static_cast<unsigned>(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("substr", stringProtoFuncSubstr, static_cast<unsigned>(PropertyAttribute::DontEnum), 2);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("substring", stringProtoFuncSubstring, static_cast<unsigned>(PropertyAttribute::DontEnum), 2);
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION("toLowerCase", stringProtoFuncToLowerCase, static_cast<unsigned>(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("toUpperCase", stringProtoFuncToUpperCase, static_cast<unsigned>(PropertyAttribute::DontEnum), 0);
@@ -214,35 +218,21 @@
         } else if (ref == '\'') {
             backrefStart = ovector[1];
             backrefLength = source.length() - backrefStart;
         } else if (reg && ref == '<') {
             // Named back reference
-            if (!hasNamedCaptures) {
-                result.append(replacement.substring(i, 2));
-                offset = i + 2;
-                advance = 1;
+            if (!hasNamedCaptures)
                 continue;
-            }
 
             size_t closingBracket = replacement.find('>', i + 2);
-            if (closingBracket == WTF::notFound) {
-                // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434
-                // Current proposed spec change throws a syntax error in this case.
-                // We have made the case that it makes more sense to treat this a literal
-                // If throwSyntaxError(exec, scope, "Missing closing '>' in replacement text");
+            if (closingBracket == WTF::notFound)
                 continue;
-            }
 
             unsigned nameLength = closingBracket - i - 2;
             unsigned backrefIndex = reg->subpatternForName(replacement.substring(i + 2, nameLength).toString());
 
             if (!backrefIndex || backrefIndex > reg->numSubpatterns()) {
-                // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434
-                // Proposed spec change throws a throw syntax error in this case.
-                // We have made the case that a non-existent back reference should be replaced with
-                // and empty string.
-                // throwSyntaxError(exec, scope, makeString("Replacement text references non-existent backreference \"" + replacement.substring(i + 2, nameLength).toString()));
                 backrefStart = 0;
                 backrefLength = 0;
             } else {
                 backrefStart = ovector[2 * backrefIndex];
                 backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
@@ -309,13 +299,13 @@
 
     int position;
     int length;
 };
 
-static ALWAYS_INLINE JSString* jsSpliceSubstrings(ExecState* exec, JSString* sourceVal, const String& source, const StringRange* substringRanges, int rangeCount)
+static ALWAYS_INLINE JSString* jsSpliceSubstrings(JSGlobalObject* globalObject, JSString* sourceVal, const String& source, const StringRange* substringRanges, int rangeCount)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (rangeCount == 1) {
         int sourceSize = source.length();
         int position = substringRanges[0].position;
@@ -341,11 +331,11 @@
     if (source.is8Bit()) {
         LChar* buffer;
         const LChar* sourceData = source.characters8();
         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
         if (!impl) {
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
             return nullptr;
         }
 
         Checked<int, AssertNoOverflow> bufferPos = 0;
         for (int i = 0; i < rangeCount; i++) {
@@ -361,11 +351,11 @@
     UChar* buffer;
     const UChar* sourceData = source.characters16();
 
     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
     if (!impl) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return nullptr;
     }
 
     Checked<int, AssertNoOverflow> bufferPos = 0;
     for (int i = 0; i < rangeCount; i++) {
@@ -376,13 +366,13 @@
     }
 
     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 }
 
-static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(ExecState* exec, JSString* sourceVal, const String& source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)
+static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(JSGlobalObject* globalObject, JSString* sourceVal, const String& source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (rangeCount == 1 && separatorCount == 0) {
         int sourceSize = source.length();
         int position = substringRanges[0].position;
@@ -391,21 +381,27 @@
             return sourceVal;
         // We could call String::substringSharingImpl(), but this would result in redundant checks.
         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
     }
 
+    if (rangeCount == 2 && separatorCount == 1) {
+        String leftPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[0].position, substringRanges[0].length));
+        String rightPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[1].position, substringRanges[1].length));
+        RELEASE_AND_RETURN(scope, jsString(globalObject, leftPart, separators[0], rightPart));
+    }
+
     Checked<int, RecordOverflow> totalLength = 0;
     bool allSeparators8Bit = true;
     for (int i = 0; i < rangeCount; i++)
         totalLength += substringRanges[i].length;
     for (int i = 0; i < separatorCount; i++) {
         totalLength += separators[i].length();
         if (separators[i].length() && !separators[i].is8Bit())
             allSeparators8Bit = false;
     }
     if (totalLength.hasOverflowed()) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return nullptr;
     }
 
     if (!totalLength)
         return jsEmptyString(vm);
@@ -414,11 +410,11 @@
         LChar* buffer;
         const LChar* sourceData = source.characters8();
 
         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
         if (!impl) {
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
             return nullptr;
         }
 
         int maxCount = std::max(rangeCount, separatorCount);
         Checked<int, AssertNoOverflow> bufferPos = 0;
@@ -441,11 +437,11 @@
     }
 
     UChar* buffer;
     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
     if (!impl) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return nullptr;
     }
 
     int maxCount = std::max(rangeCount, separatorCount);
     Checked<int, AssertNoOverflow> bufferPos = 0;
@@ -477,31 +473,30 @@
     do { \
         throwOutOfMemoryError(exec__, scope__); \
         return nullptr; \
     } while (false)
 
-static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM& vm, ExecState* exec, JSString* string, const String& source, RegExp* regExp)
+static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM& vm, JSGlobalObject* globalObject, JSString* string, const String& source, RegExp* regExp)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
     SuperSamplerScope superSamplerScope(false);
 
     size_t lastIndex = 0;
     unsigned startPosition = 0;
 
     Vector<StringRange, 16> sourceRanges;
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
     unsigned sourceLen = source.length();
 
     while (true) {
         MatchResult result = globalObject->regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
         RETURN_IF_EXCEPTION(scope, nullptr);
         if (!result)
             break;
 
         if (lastIndex < result.start) {
             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
-                OUT_OF_MEMORY(exec, scope);
+                OUT_OF_MEMORY(globalObject, scope);
         }
         lastIndex = result.end;
         startPosition = lastIndex;
 
         // special case of empty match
@@ -515,43 +510,39 @@
     if (!lastIndex)
         return string;
 
     if (static_cast<unsigned>(lastIndex) < sourceLen) {
         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
-            OUT_OF_MEMORY(exec, scope);
+            OUT_OF_MEMORY(globalObject, scope);
     }
-    RELEASE_AND_RETURN(scope, jsSpliceSubstrings(exec, string, source, sourceRanges.data(), sourceRanges.size()));
+    RELEASE_AND_RETURN(scope, jsSpliceSubstrings(globalObject, string, source, sourceRanges.data(), sourceRanges.size()));
 }
 
 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
-    VM& vm, ExecState* exec, JSString* string, JSValue searchValue, CallData& callData,
+    VM& vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, CallData& callData,
     CallType callType, String& replacementString, JSValue replaceValue)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String source = string->value(exec);
+    String source = string->value(globalObject);
     RETURN_IF_EXCEPTION(scope, nullptr);
     unsigned sourceLen = source.length();
     RETURN_IF_EXCEPTION(scope, nullptr);
     RegExpObject* regExpObject = jsCast<RegExpObject*>(searchValue);
     RegExp* regExp = regExpObject->regExp();
     bool global = regExp->global();
     bool hasNamedCaptures = regExp->hasNamedCaptures();
 
     if (global) {
         // ES5.1 15.5.4.10 step 8.a.
-        regExpObject->setLastIndex(exec, 0);
+        regExpObject->setLastIndex(globalObject, 0);
         RETURN_IF_EXCEPTION(scope, nullptr);
 
         if (callType == CallType::None && !replacementString.length())
-            RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, string, source, regExp));
+            RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, string, source, regExp));
     }
 
-    // FIXME: This is wrong because we may be called directly from the FTL.
-    // https://bugs.webkit.org/show_bug.cgi?id=154874
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
-
     size_t lastIndex = 0;
     unsigned startPosition = 0;
 
     Vector<StringRange, 16> sourceRanges;
     Vector<String, 16> replacements;
@@ -561,30 +552,24 @@
         // regExp->numSubpatterns() + 1 for pattern args, + 2 for match start and string
         int argCount = regExp->numSubpatterns() + 1 + 2;
         if (hasNamedCaptures)
             ++argCount;
         JSFunction* func = jsCast<JSFunction*>(replaceValue);
-        CachedCall cachedCall(exec, func, argCount);
+        CachedCall cachedCall(globalObject, callFrame, func, argCount);
         RETURN_IF_EXCEPTION(scope, nullptr);
         while (true) {
             int* ovector;
             MatchResult result = globalObject->regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &ovector);
             RETURN_IF_EXCEPTION(scope, nullptr);
             if (!result)
                 break;
 
             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
-                OUT_OF_MEMORY(exec, scope);
+                OUT_OF_MEMORY(globalObject, scope);
 
             cachedCall.clearArguments();
-
-            JSObject* groups = nullptr;
-
-            if (hasNamedCaptures) {
-                JSGlobalObject* globalObject = exec->lexicalGlobalObject();
-                groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject->objectPrototype(), 0));
-            }
+            JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject->nullPrototypeObjectStructure()) : nullptr;
 
             for (unsigned i = 0; i < regExp->numSubpatterns() + 1; ++i) {
                 int matchStart = ovector[i * 2];
                 int matchLen = ovector[i * 2 + 1] - matchStart;
 
@@ -609,17 +594,17 @@
             if (hasNamedCaptures)
                 cachedCall.appendArgument(groups);
 
             cachedCall.setThis(jsUndefined());
             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
-                throwOutOfMemoryError(exec, scope);
+                throwOutOfMemoryError(globalObject, scope);
                 return nullptr;
             }
 
             JSValue jsResult = cachedCall.call();
             RETURN_IF_EXCEPTION(scope, nullptr);
-            replacements.append(jsResult.toWTFString(exec));
+            replacements.append(jsResult.toWTFString(globalObject));
             RETURN_IF_EXCEPTION(scope, nullptr);
 
             lastIndex = result.end;
             startPosition = lastIndex;
 
@@ -638,19 +623,14 @@
             if (!result)
                 break;
 
             if (callType != CallType::None) {
                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
-                    OUT_OF_MEMORY(exec, scope);
+                    OUT_OF_MEMORY(globalObject, scope);
 
                 MarkedArgumentBuffer args;
-                JSObject* groups = nullptr;
-
-                if (hasNamedCaptures) {
-                    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
-                    groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject->objectPrototype(), 0));
-                }
+                JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject->nullPrototypeObjectStructure()) : nullptr;
 
                 for (unsigned i = 0; i < regExp->numSubpatterns() + 1; ++i) {
                     int matchStart = ovector[i * 2];
                     int matchLen = ovector[i * 2 + 1] - matchStart;
 
@@ -668,39 +648,38 @@
                     if (i && hasNamedCaptures) {
                         String groupName = regExp->getCaptureGroupName(i);
                         if (!groupName.isEmpty())
                             groups->putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
                     }
-
                 }
 
                 args.append(jsNumber(result.start));
                 args.append(string);
                 if (hasNamedCaptures)
                     args.append(groups);
                 if (UNLIKELY(args.hasOverflowed())) {
-                    throwOutOfMemoryError(exec, scope);
+                    throwOutOfMemoryError(globalObject, scope);
                     return nullptr;
                 }
 
-                JSValue replacement = call(exec, replaceValue, callType, callData, jsUndefined(), args);
+                JSValue replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);
                 RETURN_IF_EXCEPTION(scope, nullptr);
-                String replacementString = replacement.toWTFString(exec);
+                String replacementString = replacement.toWTFString(globalObject);
                 RETURN_IF_EXCEPTION(scope, nullptr);
                 replacements.append(replacementString);
                 RETURN_IF_EXCEPTION(scope, nullptr);
             } else {
                 int replLen = replacementString.length();
                 if (lastIndex < result.start || replLen) {
                     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
-                        OUT_OF_MEMORY(exec, scope);
+                        OUT_OF_MEMORY(globalObject, scope);
 
                     if (replLen) {
                         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
                         substituteBackreferences(replacement, replacementString, source, ovector, regExp);
                         if (UNLIKELY(replacement.hasOverflowed()))
-                            OUT_OF_MEMORY(exec, scope);
+                            OUT_OF_MEMORY(globalObject, scope);
                         replacements.append(replacement.toString());
                     } else
                         replacements.append(String());
                 }
             }
@@ -720,118 +699,153 @@
     if (!lastIndex && replacements.isEmpty())
         return string;
 
     if (static_cast<unsigned>(lastIndex) < sourceLen) {
         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
-            OUT_OF_MEMORY(exec, scope);
+            OUT_OF_MEMORY(globalObject, scope);
     }
-    RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(exec, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
+    RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 }
 
-JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(
-    ExecState* exec, JSString* thisValue, RegExpObject* searchValue)
+IGNORE_WARNINGS_BEGIN("frame-address")
+
+JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue)
 {
-    VM& vm = exec->vm();
-    NativeCallFrameTracer tracer(vm, exec);
+    VM& vm = globalObject->vm();
+    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
+    JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     RegExp* regExp = searchValue->regExp();
     if (regExp->global()) {
         // ES5.1 15.5.4.10 step 8.a.
-        searchValue->setLastIndex(exec, 0);
+        searchValue->setLastIndex(globalObject, 0);
         RETURN_IF_EXCEPTION(scope, nullptr);
-        String source = thisValue->value(exec);
+        String source = thisValue->value(globalObject);
         RETURN_IF_EXCEPTION(scope, nullptr);
-        RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, thisValue, source, regExp));
+        RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, thisValue, source, regExp));
     }
 
     CallData callData;
     String replacementString = emptyString();
     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
-        vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));
+        vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));
 }
 
-JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(
-    ExecState* exec, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)
+JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)
 {
-    VM& vm = exec->vm();
-    NativeCallFrameTracer tracer(vm, exec);
+    VM& vm = globalObject->vm();
+    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
+    JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     CallData callData;
-    String replacementString = replaceString->value(exec);
+    String replacementString = replaceString->value(globalObject);
     RETURN_IF_EXCEPTION(scope, nullptr);
     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
-        vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));
+        vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));
 }
 
-static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM& vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
+static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM& vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     String replacementString;
     CallData callData;
     CallType callType = getCallData(vm, replaceValue, callData);
     if (callType == CallType::None) {
-        replacementString = replaceValue.toWTFString(exec);
+        replacementString = replaceValue.toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, nullptr);
     }
 
     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
-        vm, exec, string, searchValue, callData, callType, replacementString, replaceValue));
+        vm, globalObject, callFrame, string, searchValue, callData, callType, replacementString, replaceValue));
 }
 
-static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM& vm, ExecState* exec, JSString* jsString, JSValue searchValue, JSValue replaceValue)
+enum class ReplaceMode : bool { Single, Global };
+
+static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM& vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* jsString, JSValue searchValue, JSValue replaceValue, ReplaceMode mode)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String string = jsString->value(exec);
+    String string = jsString->value(globalObject);
     RETURN_IF_EXCEPTION(scope, nullptr);
-    String searchString = searchValue.toWTFString(exec);
+    String searchString = searchValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, nullptr);
 
-    size_t matchStart = string.find(searchString);
-
-    if (matchStart == notFound)
-        return jsString;
-
     CallData callData;
     CallType callType = getCallData(vm, replaceValue, callData);
-    if (callType != CallType::None) {
-        MarkedArgumentBuffer args;
-        auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()->length());
+    Optional<CachedCall> cachedCall;
+    String replaceString;
+    if (callType == CallType::None) {
+        replaceString = replaceValue.toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, nullptr);
-        args.append(substring);
-        args.append(jsNumber(matchStart));
-        args.append(jsString);
-        ASSERT(!args.hasOverflowed());
-        replaceValue = call(exec, replaceValue, callType, callData, jsUndefined(), args);
+    } else if (callType == CallType::JS) {
+        cachedCall.emplace(globalObject, callFrame, jsCast<JSFunction*>(replaceValue), 3);
         RETURN_IF_EXCEPTION(scope, nullptr);
+        cachedCall->setThis(jsUndefined());
     }
 
-    String replaceString = replaceValue.toWTFString(exec);
-    RETURN_IF_EXCEPTION(scope, nullptr);
+    size_t matchStart = string.find(searchString);
+    if (matchStart == notFound)
+        return jsString;
 
-    StringImpl* stringImpl = string.impl();
-    String leftPart(StringImpl::createSubstringSharingImpl(*stringImpl, 0, matchStart));
+    size_t endOfLastMatch = 0;
+    size_t searchStringLength = searchString.length();
+    Vector<StringRange, 16> sourceRanges;
+    Vector<String, 16> replacements;
+    do {
+        if (callType != CallType::None) {
+            JSValue replacement;
+            if (cachedCall) {
+                auto* substring = jsSubstring(vm, string, matchStart, searchStringLength);
+                RETURN_IF_EXCEPTION(scope, nullptr);
+                cachedCall->clearArguments();
+                cachedCall->appendArgument(substring);
+                cachedCall->appendArgument(jsNumber(matchStart));
+                cachedCall->appendArgument(jsString);
+                ASSERT(!cachedCall->hasOverflowedArguments());
+                replacement = cachedCall->call();
+            } else {
+                MarkedArgumentBuffer args;
+                auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()->length());
+                RETURN_IF_EXCEPTION(scope, nullptr);
+                args.append(substring);
+                args.append(jsNumber(matchStart));
+                args.append(jsString);
+                ASSERT(!args.hasOverflowed());
+                replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);
+            }
+            RETURN_IF_EXCEPTION(scope, nullptr);
+            replaceString = replacement.toWTFString(globalObject);
+            RETURN_IF_EXCEPTION(scope, nullptr);
+        }
 
-    size_t matchEnd = matchStart + searchString.impl()->length();
-    int ovector[2] = { static_cast<int>(matchStart),  static_cast<int>(matchEnd)};
-    String middlePart;
-    if (callType != CallType::None)
-        middlePart = replaceString;
-    else {
-        StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
-        substituteBackreferences(replacement, replaceString, string, ovector, 0);
-        if (UNLIKELY(replacement.hasOverflowed()))
-            OUT_OF_MEMORY(exec, scope);
-        middlePart = replacement.toString();
-    }
+        if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, matchStart - endOfLastMatch)))
+            OUT_OF_MEMORY(globalObject, scope);
 
-    size_t leftLength = stringImpl->length() - matchEnd;
-    String rightPart(StringImpl::createSubstringSharingImpl(*stringImpl, matchEnd, leftLength));
-    RELEASE_AND_RETURN(scope, JSC::jsString(exec, leftPart, middlePart, rightPart));
+        size_t matchEnd = matchStart + searchStringLength;
+        if (callType != CallType::None)
+            replacements.append(replaceString);
+        else {
+            StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
+            int ovector[2] = { static_cast<int>(matchStart),  static_cast<int>(matchEnd) };
+            substituteBackreferences(replacement, replaceString, string, ovector, nullptr);
+            if (UNLIKELY(replacement.hasOverflowed()))
+                OUT_OF_MEMORY(globalObject, scope);
+            replacements.append(replacement.toString());
+        }
+
+        endOfLastMatch = matchEnd;
+        if (mode == ReplaceMode::Single)
+            break;
+        matchStart = string.find(searchString, !searchStringLength ? endOfLastMatch + 1 : endOfLastMatch);
+    } while (matchStart != notFound);
+
+    if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, string.length() - endOfLastMatch)))
+        OUT_OF_MEMORY(globalObject, scope);
+    RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, jsString, string, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 }
 
 static inline bool checkObjectCoercible(JSValue thisValue)
 {
     if (thisValue.isString())
@@ -844,167 +858,179 @@
         return false;
 
     return true;
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // For a string which length is single, instead of creating ropes,
     // allocating a sequential buffer and fill with the repeated string for efficiency.
-    ASSERT(exec->argumentCount() == 2);
+    ASSERT(callFrame->argumentCount() == 2);
 
-    ASSERT(exec->uncheckedArgument(0).isString());
-    JSString* string = asString(exec->uncheckedArgument(0));
+    ASSERT(callFrame->uncheckedArgument(0).isString());
+    JSString* string = asString(callFrame->uncheckedArgument(0));
     ASSERT(string->length() == 1);
 
-    JSValue repeatCountValue = exec->uncheckedArgument(1);
+    JSValue repeatCountValue = callFrame->uncheckedArgument(1);
     RELEASE_ASSERT(repeatCountValue.isNumber());
     int32_t repeatCount;
     double value = repeatCountValue.asNumber();
     if (value > JSString::MaxLength)
-        return JSValue::encode(throwOutOfMemoryError(exec, scope));
+        return JSValue::encode(throwOutOfMemoryError(globalObject, scope));
     repeatCount = static_cast<int32_t>(value);
     ASSERT(repeatCount >= 0);
     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 
-    auto viewWithString = string->viewWithUnderlyingString(exec);
+    auto viewWithString = string->viewWithUnderlyingString(globalObject);
     StringView view = viewWithString.view;
     ASSERT(view.length() == 1);
     scope.assertNoException();
     UChar character = view[0];
     scope.release();
     if (isLatin1(character))
-        return JSValue::encode(repeatCharacter(*exec, static_cast<LChar>(character), repeatCount));
-    return JSValue::encode(repeatCharacter(*exec, character, repeatCount));
+        return JSValue::encode(repeatCharacter(globalObject, static_cast<LChar>(character), repeatCount));
+    return JSValue::encode(repeatCharacter(globalObject, character, repeatCount));
 }
 
 ALWAYS_INLINE JSString* replace(
-    VM& vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
+    VM& vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)
 {
     if (searchValue.inherits<RegExpObject>(vm))
-        return replaceUsingRegExpSearch(vm, exec, string, searchValue, replaceValue);
-    return replaceUsingStringSearch(vm, exec, string, searchValue, replaceValue);
+        return replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, replaceValue);
+    return replaceUsingStringSearch(vm, globalObject, callFrame, string, searchValue, replaceValue, ReplaceMode::Single);
 }
 
 ALWAYS_INLINE JSString* replace(
-    VM& vm, ExecState* exec, JSValue thisValue, JSValue searchValue, JSValue replaceValue)
+    VM& vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSValue thisValue, JSValue searchValue, JSValue replaceValue)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!checkObjectCoercible(thisValue)) {
-        throwVMTypeError(exec, scope);
+        throwVMTypeError(globalObject, scope);
         return nullptr;
     }
-    JSString* string = thisValue.toString(exec);
+    JSString* string = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, nullptr);
-    RELEASE_AND_RETURN(scope, replace(vm, exec, string, searchValue, replaceValue));
+    RELEASE_AND_RETURN(scope, replace(vm, globalObject, callFrame, string, searchValue, replaceValue));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSString* string = exec->thisValue().toString(exec);
+    JSString* string = callFrame->thisValue().toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue searchValue = exec->argument(0);
+    JSValue searchValue = callFrame->argument(0);
     if (!searchValue.inherits<RegExpObject>(vm))
         return JSValue::encode(jsUndefined());
 
-    RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, exec, string, searchValue, exec->argument(1))));
+    RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, callFrame->argument(1))));
+}
+
+EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)
+{
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
+    JSString* string = callFrame->thisValue().toString(globalObject);
+    RETURN_IF_EXCEPTION(scope, encodedJSValue());
+
+    RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame->argument(0), callFrame->argument(1), ReplaceMode::Single)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSString* string = exec->thisValue().toString(exec);
+    JSString* string = callFrame->thisValue().toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, exec, string, exec->argument(0), exec->argument(1))));
+    RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame->argument(0), callFrame->argument(1), ReplaceMode::Global)));
 }
 
-JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(
-    ExecState* exec, EncodedJSValue thisValue, EncodedJSValue searchValue,
-    EncodedJSValue replaceValue)
+JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue searchValue, EncodedJSValue replaceValue)
 {
-    VM& vm = exec->vm();
-    NativeCallFrameTracer tracer(vm, exec);
+    VM& vm = globalObject->vm();
+    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
+    JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 
     return replace(
-        vm, exec, JSValue::decode(thisValue), JSValue::decode(searchValue),
+        vm, globalObject, callFrame, JSValue::decode(thisValue), JSValue::decode(searchValue),
         JSValue::decode(replaceValue));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState* exec)
+IGNORE_WARNINGS_END
+
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     // Also used for valueOf.
 
     if (thisValue.isString())
         return JSValue::encode(thisValue);
 
     auto* stringObject = jsDynamicCast<StringObject*>(vm, thisValue);
     if (stringObject)
         return JSValue::encode(stringObject->internalValue());
 
-    return throwVMTypeError(exec, scope);
+    return throwVMTypeError(globalObject, scope);
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
-    auto viewWithString = thisValue.toString(exec)->viewWithUnderlyingString(exec);
+        return throwVMTypeError(globalObject, scope);
+    auto viewWithString = thisValue.toString(globalObject)->viewWithUnderlyingString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     StringView view = viewWithString.view;
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    JSValue a0 = exec->argument(0);
+    JSValue a0 = callFrame->argument(0);
     if (a0.isUInt32()) {
         uint32_t i = a0.asUInt32();
         if (i < view.length())
             return JSValue::encode(jsSingleCharacterString(vm, view[i]));
         return JSValue::encode(jsEmptyString(vm));
     }
-    double dpos = a0.toInteger(exec);
+    double dpos = a0.toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     if (dpos >= 0 && dpos < view.length())
         return JSValue::encode(jsSingleCharacterString(vm, view[static_cast<unsigned>(dpos)]));
     return JSValue::encode(jsEmptyString(vm));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
-    auto viewWithString = thisValue.toString(exec)->viewWithUnderlyingString(exec);
+        return throwVMTypeError(globalObject, scope);
+    auto viewWithString = thisValue.toString(globalObject)->viewWithUnderlyingString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     StringView view = viewWithString.view;
-    JSValue a0 = exec->argument(0);
+    JSValue a0 = callFrame->argument(0);
     if (a0.isUInt32()) {
         uint32_t i = a0.asUInt32();
         if (i < view.length())
             return JSValue::encode(jsNumber(view[i]));
         return JSValue::encode(jsNaN());
     }
-    double dpos = a0.toInteger(exec);
+    double dpos = a0.toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     if (dpos >= 0 && dpos < view.length())
         return JSValue::encode(jsNumber(view[static_cast<int>(dpos)]));
     return JSValue::encode(jsNaN());
 }
@@ -1017,65 +1043,65 @@
     UChar32 character;
     U16_NEXT(string.characters16(), position, length, character);
     return character;
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    String string = thisValue.toWTFString(exec);
+    String string = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     unsigned length = string.length();
 
-    JSValue argument0 = exec->argument(0);
+    JSValue argument0 = callFrame->argument(0);
     if (argument0.isUInt32()) {
         unsigned position = argument0.asUInt32();
         if (position < length)
             return JSValue::encode(jsNumber(codePointAt(string, position, length)));
         return JSValue::encode(jsUndefined());
     }
 
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    double doublePosition = argument0.toInteger(exec);
+    double doublePosition = argument0.toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     if (doublePosition >= 0 && doublePosition < length)
         return JSValue::encode(jsNumber(codePointAt(string, static_cast<unsigned>(doublePosition), length)));
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    JSValue a0 = exec->argument(0);
-    JSValue a1 = exec->argument(1);
+    JSValue a0 = callFrame->argument(0);
+    JSValue a1 = callFrame->argument(1);
 
-    JSString* thisJSString = thisValue.toString(exec);
+    JSString* thisJSString = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    JSString* otherJSString = a0.toString(exec);
+    JSString* otherJSString = a0.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     unsigned pos = 0;
     if (!a1.isUndefined()) {
         int len = thisJSString->length();
         RELEASE_ASSERT(len >= 0);
         if (a1.isUInt32())
             pos = std::min<uint32_t>(a1.asUInt32(), len);
         else {
-            double dpos = a1.toInteger(exec);
+            double dpos = a1.toInteger(globalObject);
             RETURN_IF_EXCEPTION(scope, encodedJSValue());
             if (dpos < 0)
                 dpos = 0;
             else if (dpos > len)
                 dpos = len;
@@ -1084,39 +1110,39 @@
     }
 
     if (thisJSString->length() < otherJSString->length() + pos)
         return JSValue::encode(jsNumber(-1));
 
-    auto thisViewWithString = thisJSString->viewWithUnderlyingString(exec);
+    auto thisViewWithString = thisJSString->viewWithUnderlyingString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    auto otherViewWithString = otherJSString->viewWithUnderlyingString(exec);
+    auto otherViewWithString = otherJSString->viewWithUnderlyingString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
     if (result == notFound)
         return JSValue::encode(jsNumber(-1));
     return JSValue::encode(jsNumber(result));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    JSValue a0 = exec->argument(0);
-    JSValue a1 = exec->argument(1);
+    JSValue a0 = callFrame->argument(0);
+    JSValue a1 = callFrame->argument(1);
 
-    JSString* thisJSString = thisValue.toString(exec);
+    JSString* thisJSString = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     unsigned len = thisJSString->length();
-    JSString* otherJSString = a0.toString(exec);
+    JSString* otherJSString = a0.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    double dpos = a1.toIntegerPreserveNaN(exec);
+    double dpos = a1.toIntegerPreserveNaN(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     unsigned startPosition;
     if (dpos < 0)
         startPosition = 0;
     else if (!(dpos <= len)) // true for NaN
@@ -1125,13 +1151,13 @@
         startPosition = static_cast<unsigned>(dpos);
 
     if (len < otherJSString->length())
         return JSValue::encode(jsNumber(-1));
 
-    String thisString = thisJSString->value(exec);
+    String thisString = thisJSString->value(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    String otherString = otherJSString->value(exec);
+    String otherString = otherJSString->value(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     size_t result;
     if (!startPosition)
         result = thisString.startsWith(otherString) ? 0 : notFound;
     else
@@ -1139,40 +1165,40 @@
     if (result == notFound)
         return JSValue::encode(jsNumber(-1));
     return JSValue::encode(jsNumber(result));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
-    JSString* string = thisValue.toString(exec);
+        return throwVMTypeError(globalObject, scope);
+    JSString* string = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue a0 = exec->argument(0);
-    JSValue a1 = exec->argument(1);
+    JSValue a0 = callFrame->argument(0);
+    JSValue a1 = callFrame->argument(1);
 
     int length = string->length();
     RELEASE_ASSERT(length >= 0);
 
     // The arg processing is very much like ArrayProtoFunc::Slice
-    double start = a0.toInteger(exec);
+    double start = a0.toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    double end = a1.isUndefined() ? length : a1.toInteger(exec);
+    double end = a1.isUndefined() ? length : a1.toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(exec, vm, string, length, start, end)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(globalObject, vm, string, length, start, end)));
 }
 
 // Return true in case of early return (resultLength got to limitLength).
 template<typename CharacterType>
-static ALWAYS_INLINE bool splitStringByOneCharacterImpl(ExecState* exec, JSArray* result, JSValue originalValue, const String& input, StringImpl* string, UChar separatorCharacter, size_t& position, unsigned& resultLength, unsigned limitLength)
+static ALWAYS_INLINE bool splitStringByOneCharacterImpl(JSGlobalObject* globalObject, JSArray* result, JSValue originalValue, const String& input, StringImpl* string, UChar separatorCharacter, size_t& position, unsigned& resultLength, unsigned limitLength)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 12. Let q = p.
     size_t matchPosition;
     const CharacterType* characters = string->characters<CharacterType>();
@@ -1183,13 +1209,13 @@
     while ((matchPosition = WTF::find(characters, string->length(), separatorCharacter, position)) != notFound) {
         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
         //    through q (exclusive).
         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
-        auto* substring = jsSubstring(exec, originalValue, input, position, matchPosition - position);
+        auto* substring = jsSubstring(globalObject, originalValue, input, position, matchPosition - position);
         RETURN_IF_EXCEPTION(scope, false);
-        result->putDirectIndex(exec, resultLength, substring);
+        result->putDirectIndex(globalObject, resultLength, substring);
         RETURN_IF_EXCEPTION(scope, false);
         // 3. Increment lengthA by 1.
         // 4. If lengthA == lim, return A.
         if (++resultLength == limitLength)
             return true;
@@ -1200,54 +1226,54 @@
     }
     return false;
 }
 
 // ES 21.1.3.17 String.prototype.split(separator, limit)
-EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     ASSERT(checkObjectCoercible(thisValue));
 
     // 3. Let S be the result of calling ToString, giving it the this value as its argument.
     // 7. Let s be the number of characters in S.
-    String input = thisValue.toWTFString(exec);
+    String input = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     ASSERT(!input.isNull());
 
     // 4. Let A be a new array created as if by the expression new Array()
     //    where Array is the standard built-in constructor with that name.
-    JSArray* result = constructEmptyArray(exec, 0);
+    JSArray* result = constructEmptyArray(globalObject, 0);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     // 5. Let lengthA be 0.
     unsigned resultLength = 0;
 
     // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
-    JSValue limitValue = exec->uncheckedArgument(1);
-    unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(exec);
+    JSValue limitValue = callFrame->uncheckedArgument(1);
+    unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     // 8. Let p = 0.
     size_t position = 0;
 
     // 9. If separator is a RegExp object (its [[Class]] is "RegExp"), let R = separator;
     //    otherwise let R = ToString(separator).
-    JSValue separatorValue = exec->uncheckedArgument(0);
-    String separator = separatorValue.toWTFString(exec);
+    JSValue separatorValue = callFrame->uncheckedArgument(0);
+    String separator = separatorValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     // 10. If lim == 0, return A.
     if (!limit)
         return JSValue::encode(result);
 
     // 11. If separator is undefined, then
     if (separatorValue.isUndefined()) {
         // a. Call the [[DefineOwnProperty]] internal method of A with arguments "0",
         scope.release();
-        result->putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
+        result->putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));
         // b. Return A.
         return JSValue::encode(result);
     }
 
     // 12. If s == 0, then
@@ -1256,11 +1282,11 @@
         // b. If z is not false, return A.
         // c. Call CreateDataProperty(A, "0", S).
         // d. Return A.
         if (!separator.isEmpty()) {
             scope.release();
-            result->putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
+            result->putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));
         }
         return JSValue::encode(result);
     }
 
     // Optimized case for splitting on the empty string.
@@ -1268,11 +1294,11 @@
         limit = std::min(limit, input.length());
         // Zero limt/input length handled in steps 9/11 respectively, above.
         ASSERT(limit);
 
         do {
-            result->putDirectIndex(exec, position, jsSingleCharacterString(vm, input[position]));
+            result->putDirectIndex(globalObject, position, jsSingleCharacterString(vm, input[position]));
             RETURN_IF_EXCEPTION(scope, encodedJSValue());
         } while (++position < limit);
 
         return JSValue::encode(result);
     }
@@ -1291,14 +1317,14 @@
             separatorCharacter = separatorImpl->characters8()[0];
         else
             separatorCharacter = separatorImpl->characters16()[0];
 
         if (stringImpl->is8Bit()) {
-            if (splitStringByOneCharacterImpl<LChar>(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
+            if (splitStringByOneCharacterImpl<LChar>(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
         } else {
-            if (splitStringByOneCharacterImpl<UChar>(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
+            if (splitStringByOneCharacterImpl<UChar>(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
         }
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     } else {
         // 13. Let q = p.
@@ -1309,13 +1335,13 @@
         //   c. Else, e is an integer index <= s.
         while ((matchPosition = stringImpl->find(separatorImpl, position)) != notFound) {
             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
             //    through q (exclusive).
             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
-            auto* substring = jsSubstring(exec, thisValue, input, position, matchPosition - position);
+            auto* substring = jsSubstring(globalObject, thisValue, input, position, matchPosition - position);
             RETURN_IF_EXCEPTION(scope, { });
-            result->putDirectIndex(exec, resultLength, substring);
+            result->putDirectIndex(globalObject, resultLength, substring);
             RETURN_IF_EXCEPTION(scope, { });
             // 3. Increment lengthA by 1.
             // 4. If lengthA == lim, return A.
             if (++resultLength == limit)
                 return JSValue::encode(result);
@@ -1327,45 +1353,45 @@
     }
 
     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
     //     through s (exclusive).
     // 16. Call CreateDataProperty(A, ToString(lengthA), T).
-    auto* substring = jsSubstring(exec, thisValue, input, position, input.length() - position);
+    auto* substring = jsSubstring(globalObject, thisValue, input, position, input.length() - position);
     RETURN_IF_EXCEPTION(scope, { });
     scope.release();
-    result->putDirectIndex(exec, resultLength++, substring);
+    result->putDirectIndex(globalObject, resultLength++, substring);
 
     // 17. Return A.
     return JSValue::encode(result);
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState* exec)
+static EncodedJSValue stringProtoFuncSubstrImpl(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
     unsigned len;
     JSString* jsString = 0;
     String uString;
     if (thisValue.isString()) {
         jsString = asString(thisValue);
         len = jsString->length();
     } else {
-        uString = thisValue.toWTFString(exec);
+        uString = thisValue.toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
         len = uString.length();
     }
 
-    JSValue a0 = exec->argument(0);
-    JSValue a1 = exec->argument(1);
+    JSValue a0 = callFrame->argument(0);
+    JSValue a1 = callFrame->argument(1);
 
-    double start = a0.toInteger(exec);
+    double start = a0.toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    double length = a1.isUndefined() ? len : a1.toInteger(exec);
+    double length = a1.isUndefined() ? len : a1.toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     if (start >= len || length <= 0)
         return JSValue::encode(jsEmptyString(vm));
     if (start < 0) {
         start += len;
@@ -1376,56 +1402,61 @@
         length = len - start;
     unsigned substringStart = static_cast<unsigned>(start);
     unsigned substringLength = static_cast<unsigned>(length);
     scope.release();
     if (jsString)
-        return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
+        return JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength));
     return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));
 }
 
-EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject* globalObject, CallFrame* callFrame)
+{
+    return stringProtoFuncSubstrImpl(globalObject, callFrame);
+}
+
+EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
     // @substrInternal should not have any observable side effects (e.g. it should not call
     // GetMethod(..., @@toPrimitive) on the thisValue).
 
     // It is ok to use the default stringProtoFuncSubstr as the implementation of
     // @substrInternal because @substrInternal will only be called by builtins, which will
     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
     // will not need to call toString() on the thisValue, and there will be no observable
     // side-effects.
-    ASSERT(exec->thisValue().isString());
-    return stringProtoFuncSubstr(exec);
+    ASSERT(callFrame->thisValue().isString());
+    return stringProtoFuncSubstrImpl(globalObject, callFrame);
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    JSString* jsString = thisValue.toString(exec);
+    JSString* jsString = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue a0 = exec->argument(0);
-    JSValue a1 = exec->argument(1);
+    JSValue a0 = callFrame->argument(0);
+    JSValue a1 = callFrame->argument(1);
     int len = jsString->length();
     RELEASE_ASSERT(len >= 0);
 
-    double start = a0.toNumber(exec);
+    double start = a0.toNumber(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     double end;
     if (!(start >= 0)) // check for negative values or NaN
         start = 0;
     else if (start > len)
         start = len;
     if (a1.isUndefined())
         end = len;
     else {
-        end = a1.toNumber(exec);
+        end = a1.toNumber(globalObject);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
         if (!(end >= 0)) // check for negative values or NaN
             end = 0;
         else if (end > len)
             end = len;
@@ -1435,117 +1466,126 @@
         end = start;
         start = temp;
     }
     unsigned substringStart = static_cast<unsigned>(start);
     unsigned substringLength = static_cast<unsigned>(end) - substringStart;
-    RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
-    JSString* sVal = thisValue.toString(exec);
+        return throwVMTypeError(globalObject, scope);
+    JSString* sVal = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    String s = sVal->value(exec);
+    String s = sVal->value(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     String lowercasedString = s.convertToLowercaseWithoutLocale();
     if (lowercasedString.impl() == s.impl())
         return JSValue::encode(sVal);
     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
-    JSString* sVal = thisValue.toString(exec);
+        return throwVMTypeError(globalObject, scope);
+    JSString* sVal = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    String s = sVal->value(exec);
+    String s = sVal->value(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     String uppercasedString = s.convertToUppercaseWithoutLocale();
     if (uppercasedString.impl() == s.impl())
         return JSValue::encode(sVal);
     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
     // http://ecma-international.org/publications/standards/Ecma-402.htm
 
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 1. Let O be RequireObjectCoercible(this value).
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope, "String.prototype.localeCompare requires that |this| not be null or undefined"_s);
+        return throwVMTypeError(globalObject, scope, "String.prototype.localeCompare requires that |this| not be null or undefined"_s);
 
     // 2. Let S be ToString(O).
     // 3. ReturnIfAbrupt(S).
-    String string = thisValue.toWTFString(exec);
+    String string = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     // 4. Let That be ToString(that).
     // 5. ReturnIfAbrupt(That).
-    JSValue thatValue = exec->argument(0);
-    String that = thatValue.toWTFString(exec);
+    JSValue thatValue = callFrame->argument(0);
+    String that = thatValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
 #if ENABLE(INTL)
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
-    JSValue locales = exec->argument(1);
-    JSValue options = exec->argument(2);
+    JSValue locales = callFrame->argument(1);
+    JSValue options = callFrame->argument(2);
     IntlCollator* collator = nullptr;
-    if (locales.isUndefined() && options.isUndefined()) {
-        collator = globalObject->defaultCollator(exec);
-        RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    } else {
+    if (locales.isUndefined() && options.isUndefined())
+        collator = globalObject->defaultCollator();
+    else {
         collator = IntlCollator::create(vm, globalObject->collatorStructure());
-        collator->initializeCollator(*exec, locales, options);
+        collator->initializeCollator(globalObject, locales, options);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     }
-    RELEASE_AND_RETURN(scope, JSValue::encode(collator->compareStrings(*exec, string, that)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(collator->compareStrings(globalObject, string, that)));
 #else
     return JSValue::encode(jsNumber(Collator().collate(string, that)));
 #endif
 }
 
 #if ENABLE(INTL)
-static EncodedJSValue toLocaleCase(ExecState* state, int32_t (*convertCase)(UChar*, int32_t, const UChar*, int32_t, const char*, UErrorCode*))
+enum class CaseConversionMode {
+    Upper,
+    Lower,
+};
+template<CaseConversionMode mode>
+static EncodedJSValue toLocaleCase(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = state->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
+    auto convertCase = [&] (auto&&... args) {
+        if (mode == CaseConversionMode::Lower)
+            return u_strToLower(std::forward<decltype(args)>(args)...);
+        return u_strToUpper(std::forward<decltype(args)>(args)...);
+    };
+
     // 1. Let O be RequireObjectCoercible(this value).
-    JSValue thisValue = state->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(state, scope);
+        return throwVMTypeError(globalObject, scope);
 
     // 2. Let S be ToString(O).
-    JSString* sVal = thisValue.toString(state);
+    JSString* sVal = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    const String& s = sVal->value(state);
+    String s = sVal->value(globalObject);
 
     // 3. ReturnIfAbrupt(S).
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     // Optimization for empty strings.
     if (s.isEmpty())
         return JSValue::encode(sVal);
 
     // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
-    Vector<String> requestedLocales = canonicalizeLocaleList(*state, state->argument(0));
+    Vector<String> requestedLocales = canonicalizeLocaleList(globalObject, callFrame->argument(0));
 
     // 5. ReturnIfAbrupt(requestedLocales).
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     // 6. Let len be the number of elements in requestedLocales.
@@ -1553,11 +1593,11 @@
 
     // 7. If len > 0, then
     // a. Let requestedLocale be the first element of requestedLocales.
     // 8. Else
     // a. Let requestedLocale be DefaultLocale().
-    String requestedLocale = len > 0 ? requestedLocales.first() : defaultLocale(*state);
+    String requestedLocale = len > 0 ? requestedLocales.first() : defaultLocale(globalObject);
 
     // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
     String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
 
     // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
@@ -1593,48 +1633,48 @@
         // Converted case needs more space than original. Try again.
         UErrorCode error(U_ZERO_ERROR);
         Vector<UChar> buffer(resultLength);
         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &error);
         if (U_FAILURE(error))
-            return throwVMTypeError(state, scope, u_errorName(error));
+            return throwVMTypeError(globalObject, scope, u_errorName(error));
         lower = String(buffer.data(), resultLength);
     } else
-        return throwVMTypeError(state, scope, u_errorName(error));
+        return throwVMTypeError(globalObject, scope, u_errorName(error));
 
     // 18. Return L.
     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState* state)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
     // http://ecma-international.org/publications/standards/Ecma-402.htm
-    return toLocaleCase(state, u_strToLower);
+    return toLocaleCase<CaseConversionMode::Lower>(globalObject, callFrame);
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState* state)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
     // http://ecma-international.org/publications/standards/Ecma-402.htm
     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
-    return toLocaleCase(state, u_strToUpper);
+    return toLocaleCase<CaseConversionMode::Upper>(globalObject,callFrame);
 }
 #endif // ENABLE(INTL)
 
 enum {
     TrimStart = 1,
     TrimEnd = 2
 };
 
-static inline JSValue trimString(ExecState* exec, JSValue thisValue, int trimKind)
+static inline JSValue trimString(JSGlobalObject* globalObject, JSValue thisValue, int trimKind)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!checkObjectCoercible(thisValue))
-        return throwTypeError(exec, scope);
-    String str = thisValue.toWTFString(exec);
+        return throwTypeError(globalObject, scope);
+    String str = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     unsigned left = 0;
     if (trimKind & TrimStart) {
         while (left < str.length() && isStrWhiteSpace(str[left]))
@@ -1651,26 +1691,26 @@
         return thisValue;
 
     RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    JSValue thisValue = exec->thisValue();
-    return JSValue::encode(trimString(exec, thisValue, TrimStart | TrimEnd));
+    JSValue thisValue = callFrame->thisValue();
+    return JSValue::encode(trimString(globalObject, thisValue, TrimStart | TrimEnd));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    JSValue thisValue = exec->thisValue();
-    return JSValue::encode(trimString(exec, thisValue, TrimStart));
+    JSValue thisValue = callFrame->thisValue();
+    return JSValue::encode(trimString(globalObject, thisValue, TrimStart));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    JSValue thisValue = exec->thisValue();
-    return JSValue::encode(trimString(exec, thisValue, TrimEnd));
+    JSValue thisValue = callFrame->thisValue();
+    return JSValue::encode(trimString(globalObject, thisValue, TrimEnd));
 }
 
 static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
 {
     if (value < min)
@@ -1678,151 +1718,151 @@
     if (value > max)
         return max;
     return static_cast<unsigned>(value);
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    String stringToSearchIn = thisValue.toWTFString(exec);
+    String stringToSearchIn = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue a0 = exec->argument(0);
-    bool isRegularExpression = isRegExp(vm, exec, a0);
+    JSValue a0 = callFrame->argument(0);
+    bool isRegularExpression = isRegExp(vm, globalObject, a0);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     if (isRegularExpression)
-        return throwVMTypeError(exec, scope, "Argument to String.prototype.startsWith cannot be a RegExp");
+        return throwVMTypeError(globalObject, scope, "Argument to String.prototype.startsWith cannot be a RegExp");
 
-    String searchString = a0.toWTFString(exec);
+    String searchString = a0.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue positionArg = exec->argument(1);
+    JSValue positionArg = callFrame->argument(1);
     unsigned start = 0;
     if (positionArg.isInt32())
         start = std::max(0, positionArg.asInt32());
     else {
         unsigned length = stringToSearchIn.length();
-        start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);
+        start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     }
 
     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    String stringToSearchIn = thisValue.toWTFString(exec);
+    String stringToSearchIn = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue a0 = exec->argument(0);
-    bool isRegularExpression = isRegExp(vm, exec, a0);
+    JSValue a0 = callFrame->argument(0);
+    bool isRegularExpression = isRegExp(vm, globalObject, a0);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     if (isRegularExpression)
-        return throwVMTypeError(exec, scope, "Argument to String.prototype.endsWith cannot be a RegExp");
+        return throwVMTypeError(globalObject, scope, "Argument to String.prototype.endsWith cannot be a RegExp");
 
-    String searchString = a0.toWTFString(exec);
+    String searchString = a0.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     unsigned length = stringToSearchIn.length();
 
-    JSValue endPositionArg = exec->argument(1);
+    JSValue endPositionArg = callFrame->argument(1);
     unsigned end = length;
     if (endPositionArg.isInt32())
         end = std::max(0, endPositionArg.asInt32());
     else if (!endPositionArg.isUndefined()) {
-        end = clampAndTruncateToUnsigned(endPositionArg.toInteger(exec), 0, length);
+        end = clampAndTruncateToUnsigned(endPositionArg.toInteger(globalObject), 0, length);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     }
 
     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
 }
 
-static EncodedJSValue JSC_HOST_CALL stringIncludesImpl(VM& vm, ExecState* exec, String stringToSearchIn, String searchString, JSValue positionArg)
+static EncodedJSValue stringIncludesImpl(JSGlobalObject* globalObject, VM& vm, String stringToSearchIn, String searchString, JSValue positionArg)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
     unsigned start = 0;
     if (positionArg.isInt32())
         start = std::max(0, positionArg.asInt32());
     else {
         unsigned length = stringToSearchIn.length();
-        start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);
+        start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     }
 
     return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    String stringToSearchIn = thisValue.toWTFString(exec);
+    String stringToSearchIn = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue a0 = exec->argument(0);
-    bool isRegularExpression = isRegExp(vm, exec, a0);
+    JSValue a0 = callFrame->argument(0);
+    bool isRegularExpression = isRegExp(vm, globalObject, a0);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     if (isRegularExpression)
-        return throwVMTypeError(exec, scope, "Argument to String.prototype.includes cannot be a RegExp");
+        return throwVMTypeError(globalObject, scope, "Argument to String.prototype.includes cannot be a RegExp");
 
-    String searchString = a0.toWTFString(exec);
+    String searchString = a0.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue positionArg = exec->argument(1);
+    JSValue positionArg = callFrame->argument(1);
 
-    RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));
+    RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));
 }
 
-EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     ASSERT(checkObjectCoercible(thisValue));
 
-    String stringToSearchIn = thisValue.toWTFString(exec);
+    String stringToSearchIn = thisValue.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue a0 = exec->uncheckedArgument(0);
-    String searchString = a0.toWTFString(exec);
+    JSValue a0 = callFrame->uncheckedArgument(0);
+    String searchString = a0.toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    JSValue positionArg = exec->argument(1);
+    JSValue positionArg = callFrame->argument(1);
 
-    RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));
+    RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
-    JSString* string = thisValue.toString(exec);
+        return throwVMTypeError(globalObject, scope);
+    JSString* string = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    return JSValue::encode(JSStringIterator::create(exec, exec->jsCallee()->globalObject(vm)->stringIteratorStructure(), string));
+    return JSValue::encode(JSStringIterator::create(vm, globalObject->stringIteratorStructure(), string));
 }
 
 enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
 
 static constexpr bool normalizationAffects8Bit(NormalizationForm form)
@@ -1863,16 +1903,16 @@
     ASSERT(normalizer);
     ASSERT(U_SUCCESS(status));
     return normalizer;
 }
 
-static JSValue normalize(ExecState* exec, JSString* string, NormalizationForm form)
+static JSValue normalize(JSGlobalObject* globalObject, JSString* string, NormalizationForm form)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    auto viewWithString = string->viewWithUnderlyingString(exec);
+    auto viewWithString = string->viewWithUnderlyingString(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     StringView view = viewWithString.view;
     if (view.is8Bit() && (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
         RELEASE_AND_RETURN(scope, string);
@@ -1893,34 +1933,34 @@
     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
 
     UChar* buffer;
     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
     if (!result)
-        return throwOutOfMemoryError(exec, scope);
+        return throwOutOfMemoryError(globalObject, scope);
 
     status = U_ZERO_ERROR;
     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &status);
     ASSERT(U_SUCCESS(status));
 
     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));
 }
 
-EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!checkObjectCoercible(thisValue))
-        return throwVMTypeError(exec, scope);
-    JSString* string = thisValue.toString(exec);
+        return throwVMTypeError(globalObject, scope);
+    JSString* string = thisValue.toString(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     auto form = NormalizationForm::NFC;
-    JSValue formValue = exec->argument(0);
+    JSValue formValue = callFrame->argument(0);
     if (!formValue.isUndefined()) {
-        String formString = formValue.toWTFString(exec);
+        String formString = formValue.toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, { });
 
         if (formString == "NFC")
             form = NormalizationForm::NFC;
         else if (formString == "NFD")
@@ -1928,12 +1968,12 @@
         else if (formString == "NFKC")
             form = NormalizationForm::NFKC;
         else if (formString == "NFKD")
             form = NormalizationForm::NFKD;
         else
-            return throwVMRangeError(exec, scope, "argument does not match any normalization form"_s);
+            return throwVMRangeError(globalObject, scope, "argument does not match any normalization form"_s);
     }
 
-    RELEASE_AND_RETURN(scope, JSValue::encode(normalize(exec, string, form)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(normalize(globalObject, string, form)));
 }
 
 } // namespace JSC

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSWeakObjectMapRefPrivate.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSWeakObjectMapRefPrivate.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSWeakObjectMapRefPrivate.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSWeakObjectMapRefPrivate.cpp
@@ -40,55 +40,55 @@
 extern "C" {
 #endif
 
 JSWeakObjectMapRef JSWeakObjectMapCreate(JSContextRef context, void* privateData, JSWeakMapDestroyedCallback callback)
 {
-    ExecState* exec = toJS(context);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(context);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
     auto map = OpaqueJSWeakObjectMap::create(vm, privateData, callback);
-    exec->lexicalGlobalObject()->registerWeakMap(map.ptr());
+    globalObject->registerWeakMap(map.ptr());
     return map.ptr();
 }
 
 void JSWeakObjectMapSet(JSContextRef ctx, JSWeakObjectMapRef map, void* key, JSObjectRef object)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
     JSObject* obj = toJS(object);
     if (!obj)
         return;
     ASSERT(obj->inherits<JSProxy>(vm)
         || obj->inherits<JSCallbackObject<JSGlobalObject>>(vm)
-        || obj->inherits<JSCallbackObject<JSDestructibleObject>>(vm));
+        || obj->inherits<JSCallbackObject<JSNonFinalObject>>(vm));
     map->map().set(key, obj);
 }
 
 JSObjectRef JSWeakObjectMapGet(JSContextRef ctx, JSWeakObjectMapRef map, void* key)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return 0;
     }
-    ExecState* exec = toJS(ctx);
-    JSLockHolder locker(exec);
+    JSGlobalObject* globalObject = toJS(ctx);
+    JSLockHolder locker(globalObject);
     return toRef(jsCast<JSObject*>(map->map().get(key)));
 }
 
 void JSWeakObjectMapRemove(JSContextRef ctx, JSWeakObjectMapRef map, void* key)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
-    ExecState* exec = toJS(ctx);
-    JSLockHolder locker(exec);
+    JSGlobalObject* globalObject = toJS(ctx);
+    JSLockHolder locker(globalObject);
     map->map().remove(key);
 }
 
 // We need to keep this function in the build to keep the nightlies running.
 JS_EXPORT bool JSWeakObjectMapClear(JSContextRef, JSWeakObjectMapRef, void*, JSObjectRef);

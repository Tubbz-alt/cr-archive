<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VisibleSelection.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebContentReader.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -822,20 +822,20 @@</span>
          if (!startNode)
              return VisiblePosition();
      } else {
          // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
          // and so cannot be represented by a VisiblePosition. Use whatever follows instead.
<span class="udiff-line-modified-removed">-         startBox = rootBox-&gt;firstLeafChild();</span>
<span class="udiff-line-modified-added">+         startBox = rootBox-&gt;firstLeafDescendant();</span>
          while (true) {
              if (!startBox)
                  return VisiblePosition();
  
              startNode = startBox-&gt;renderer().nonPseudoNode();
              if (startNode)
                  break;
  
<span class="udiff-line-modified-removed">-             startBox = startBox-&gt;nextLeafChild();</span>
<span class="udiff-line-modified-added">+             startBox = startBox-&gt;nextLeafOnLine();</span>
          }
      }
  
      return is&lt;Text&gt;(*startNode) ? Position(downcast&lt;Text&gt;(startNode), downcast&lt;InlineTextBox&gt;(*startBox).start())
          : positionBeforeNode(startNode);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -896,20 +896,20 @@</span>
          if (!endNode)
              return VisiblePosition();
      } else {
          // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
          // and so cannot be represented by a VisiblePosition. Use whatever precedes instead.
<span class="udiff-line-modified-removed">-         endBox = rootBox-&gt;lastLeafChild();</span>
<span class="udiff-line-modified-added">+         endBox = rootBox-&gt;lastLeafDescendant();</span>
          while (true) {
              if (!endBox)
                  return VisiblePosition();
  
              endNode = endBox-&gt;renderer().nonPseudoNode();
              if (endNode)
                  break;
  
<span class="udiff-line-modified-removed">-             endBox = endBox-&gt;prevLeafChild();</span>
<span class="udiff-line-modified-added">+             endBox = endBox-&gt;previousLeafOnLine();</span>
          }
      }
  
      Position pos;
      if (is&lt;HTMLBRElement&gt;(*endNode))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1044,11 +1044,11 @@</span>
      visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
      if (box) {
          root = box-&gt;root().prevRootBox();
          // We want to skip zero height boxes.
          // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="udiff-line-modified-removed">-         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafChild())</span>
<span class="udiff-line-modified-added">+         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafDescendant())</span>
              root = nullptr;
      }
  
      if (!root) {
          Position position = previousRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1099,11 +1099,11 @@</span>
      visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
      if (box) {
          root = box-&gt;root().nextRootBox();
          // We want to skip zero height boxes.
          // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="udiff-line-modified-removed">-         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafChild())</span>
<span class="udiff-line-modified-added">+         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafDescendant())</span>
              root = nullptr;
      }
  
      if (!root) {
          // FIXME: We need do the same in previousLinePosition.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1589,11 +1589,11 @@</span>
          // Note that &quot;Left&quot; and &quot;Right&quot; in this context apparently mean &quot;upstream/previous&quot; and &quot;downstream/next&quot;.
          boundary = useDownstream ? endOfWord(vp, LeftWordIfOnBoundary) : startOfWord(vp, RightWordIfOnBoundary);
          break;
  
      case SentenceGranularity:
<span class="udiff-line-modified-removed">-         boundary = useDownstream ? endOfSentence(vp) : startOfSentence(vp);</span>
<span class="udiff-line-modified-added">+         boundary = useDownstream ? endOfSentence(previousSentencePosition(vp)) : startOfSentence(nextSentencePosition(vp));</span>
          break;
  
      case LineGranularity:
          // Affinity has to be set to get right boundary of the line.
          boundary = vp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1774,11 +1774,12 @@</span>
      }
  
      if (result == vp)
          return VisiblePosition();
  
<span class="udiff-line-modified-removed">-     ASSERT(useDownstream ? (result &gt; vp) : (result &lt; vp));</span>
<span class="udiff-line-modified-added">+     // Positions can only be compared if they are in the same tree scope.</span>
<span class="udiff-line-added">+     ASSERT_IMPLIES(areVisiblePositionsInSameTreeScope(result, vp), useDownstream ? (result &gt; vp) : (result &lt; vp));</span>
  
      return result;
  }
  
  static VisiblePosition nextLineBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1795,22 +1796,18 @@</span>
      }
  
      return result;
  }
  
<span class="udiff-line-modified-removed">- static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)</span>
<span class="udiff-line-modified-added">+ static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition&amp; position, SelectionDirection direction)</span>
  {
<span class="udiff-line-modified-removed">-     bool useDownstream = directionIsDownstream(direction);</span>
<span class="udiff-line-modified-removed">-     bool withinUnitOfGranularity = withinTextUnitOfGranularity(vp, ParagraphGranularity, direction);</span>
<span class="udiff-line-modified-removed">-     VisiblePosition result;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (!withinUnitOfGranularity)</span>
<span class="udiff-line-modified-removed">-         result =  useDownstream ? startOfParagraph(nextParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation())) : endOfParagraph(previousParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation()));</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-         result = useDownstream ? endOfParagraph(vp) : startOfParagraph(vp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return result;</span>
<span class="udiff-line-modified-added">+     auto useDownstream = directionIsDownstream(direction);</span>
<span class="udiff-line-modified-added">+     auto lineDirection = position.lineDirectionPointForBlockDirectionNavigation();</span>
<span class="udiff-line-modified-added">+     if (atBoundaryOfGranularity(position, ParagraphGranularity, direction))</span>
<span class="udiff-line-modified-added">+         return useDownstream ? startOfParagraph(nextParagraphPosition(position, lineDirection)) : endOfParagraph(previousParagraphPosition(position, lineDirection));</span>
<span class="udiff-line-modified-added">+     ASSERT(withinTextUnitOfGranularity(position, ParagraphGranularity, direction));</span>
<span class="udiff-line-modified-added">+     return useDownstream ? endOfParagraph(position) : startOfParagraph(position);</span>
  }
  
  static VisiblePosition nextDocumentBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
  {
      return directionIsDownstream(direction) ? endOfDocument(vp) : startOfDocument(vp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1967,37 +1964,27 @@</span>
  
      if (!range) {
          // We could be at the start of a word, try forward.
          range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
      }
<span class="udiff-line-added">+ </span>
      if (range)
          return range;
  
      VisiblePosition currentPosition = position;
      do {
          currentPosition = positionOfNextBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward);
      } while (currentPosition.isNotNull() &amp;&amp; !atBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward));
  
<span class="udiff-line-removed">-     // If the position is an empty paragraph and at the end of the document</span>
<span class="udiff-line-removed">-     // the word iterator could not pass the paragraph boundary, therefore iterating to</span>
<span class="udiff-line-removed">-     // the previous line is required.</span>
<span class="udiff-line-removed">-     if (currentPosition.isNull() &amp;&amp; isEndOfDocument(position)) {</span>
<span class="udiff-line-removed">-         VisiblePosition previousLinePosition = positionOfNextBoundaryOfGranularity(position, LineGranularity, DirectionBackward);</span>
<span class="udiff-line-removed">-         if (previousLinePosition.isNotNull()) {</span>
<span class="udiff-line-removed">-             currentPosition = positionOfNextBoundaryOfGranularity(previousLinePosition, WordGranularity, DirectionBackward);</span>
<span class="udiff-line-removed">-             if (currentPosition.isNull())</span>
<span class="udiff-line-removed">-                 currentPosition = previousLinePosition;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      if (currentPosition.isNull())
          currentPosition = positionOfNextBoundaryOfGranularity(position, WordGranularity, DirectionForward);
  
      if (currentPosition.isNotNull()) {
          range = Range::create(position.deepEquivalent().deprecatedNode()-&gt;document(), currentPosition, position);
          ASSERT(range);
      }
<span class="udiff-line-added">+ </span>
      return range;
  }
  
  VisiblePosition closestWordBoundaryForPosition(const VisiblePosition&amp; position)
  {
</pre>
<center><a href="VisibleSelection.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebContentReader.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
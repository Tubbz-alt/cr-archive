<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSImageSetValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSImageGeneratorValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSImageSetValue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSImageSetValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,55 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;CSSImageSetValue.h&quot;
  
  #include &quot;CSSImageValue.h&quot;
  #include &quot;CSSPrimitiveValue.h&quot;
<span class="line-removed">- #include &quot;CachedImage.h&quot;</span>
<span class="line-removed">- #include &quot;CachedResourceLoader.h&quot;</span>
<span class="line-removed">- #include &quot;CachedResourceRequest.h&quot;</span>
<span class="line-removed">- #include &quot;CachedResourceRequestInitiators.h&quot;</span>
  #include &quot;Document.h&quot;
  #include &quot;Page.h&quot;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! CSSImageSetValue::CSSImageSetValue(LoadedFromOpaqueSource loadedFromOpaqueSource)</span>
      : CSSValueList(ImageSetClass, CommaSeparator)
<span class="line-removed">-     , m_loadedFromOpaqueSource(loadedFromOpaqueSource)</span>
  {
  }
  
  CSSImageSetValue::~CSSImageSetValue() = default;
  
  void CSSImageSetValue::fillImageSet()
  {
      size_t length = this-&gt;length();
<span class="line-modified">!     size_t i = 0;</span>
<span class="line-removed">-     while (i &lt; length) {</span>
          CSSValue* imageValue = item(i);
<span class="line-modified">!         URL imageURL = downcast&lt;CSSImageValue&gt;(*imageValue).url();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         ++i;</span>
<span class="line-modified">!         ASSERT_WITH_SECURITY_IMPLICATION(i &lt; length);</span>
<span class="line-modified">!         CSSValue* scaleFactorValue = item(i);</span>
<span class="line-modified">!         float scaleFactor = downcast&lt;CSSPrimitiveValue&gt;(*scaleFactorValue).floatValue();</span>
<span class="line-modified">! </span>
<span class="line-removed">-         ImageWithScale image;</span>
<span class="line-removed">-         image.imageURL = imageURL;</span>
<span class="line-removed">-         image.scaleFactor = scaleFactor;</span>
<span class="line-removed">-         m_imagesInSet.append(image);</span>
<span class="line-removed">-         ++i;</span>
      }
  
      // Sort the images so that they are stored in order from lowest resolution to highest.
      std::sort(m_imagesInSet.begin(), m_imagesInSet.end(), CSSImageSetValue::compareByScaleFactor);
  }
  
<span class="line-modified">! CSSImageSetValue::ImageWithScale CSSImageSetValue::bestImageForScaleFactor()</span>
  {
      if (!m_imagesInSet.size())
          fillImageSet();
  
      ImageWithScale image;
<span class="line-new-header">--- 24,51 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;CSSImageSetValue.h&quot;
  
<span class="line-added">+ #include &quot;CSSImageGeneratorValue.h&quot;</span>
  #include &quot;CSSImageValue.h&quot;
  #include &quot;CSSPrimitiveValue.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Page.h&quot;
<span class="line-added">+ #include &quot;StyleBuilderState.h&quot;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! Ref&lt;CSSImageSetValue&gt; CSSImageSetValue::create()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return adoptRef(*new CSSImageSetValue);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CSSImageSetValue::CSSImageSetValue()</span>
      : CSSValueList(ImageSetClass, CommaSeparator)
  {
  }
  
  CSSImageSetValue::~CSSImageSetValue() = default;
  
  void CSSImageSetValue::fillImageSet()
  {
      size_t length = this-&gt;length();
<span class="line-modified">!     for (size_t i = 0; i + 1 &lt; length; i += 2) {</span>
          CSSValue* imageValue = item(i);
<span class="line-modified">!         CSSValue* scaleFactorValue = item(i + 1);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         ASSERT(is&lt;CSSImageValue&gt;(imageValue) || is&lt;CSSImageGeneratorValue&gt;(imageValue));</span>
<span class="line-modified">!         ASSERT(is&lt;CSSPrimitiveValue&gt;(scaleFactorValue));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         float scaleFactor = downcast&lt;CSSPrimitiveValue&gt;(scaleFactorValue)-&gt;floatValue(CSSUnitType::CSS_DPPX);</span>
<span class="line-modified">!         m_imagesInSet.append({ imageValue, scaleFactor });</span>
      }
  
      // Sort the images so that they are stored in order from lowest resolution to highest.
      std::sort(m_imagesInSet.begin(), m_imagesInSet.end(), CSSImageSetValue::compareByScaleFactor);
  }
  
<span class="line-modified">! ImageWithScale CSSImageSetValue::bestImageForScaleFactor()</span>
  {
      if (!m_imagesInSet.size())
          fillImageSet();
  
      ImageWithScale image;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,81 ***</span>
              return image;
      }
      return image;
  }
  
<span class="line-modified">! std::pair&lt;CachedImage*, float&gt; CSSImageSetValue::loadBestFitImage(CachedResourceLoader&amp; loader, const ResourceLoaderOptions&amp; options)</span>
  {
<span class="line-modified">!     Document* document = loader.document();</span>
<span class="line-modified">!     ASSERT(document);</span>
  
<span class="line-modified">!     updateDeviceScaleFactor(*document);</span>
  
      if (!m_accessedBestFitImage) {
          m_accessedBestFitImage = true;
<span class="line-modified">! </span>
<span class="line-removed">-         // FIXME: In the future, we want to take much more than deviceScaleFactor into acount here.</span>
<span class="line-removed">-         // All forms of scale should be included: Page::pageScaleFactor(), Frame::pageZoomFactor(),</span>
<span class="line-removed">-         // and any CSS transforms. https://bugs.webkit.org/show_bug.cgi?id=81698</span>
<span class="line-removed">-         ImageWithScale image = bestImageForScaleFactor();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ResourceLoaderOptions loadOptions = options;</span>
<span class="line-removed">-         loadOptions.loadedFromOpaqueSource = m_loadedFromOpaqueSource;</span>
<span class="line-removed">-         CachedResourceRequest request(ResourceRequest(document-&gt;completeURL(image.imageURL)), loadOptions);</span>
<span class="line-removed">-         request.setInitiator(cachedResourceRequestInitiators().css);</span>
<span class="line-removed">-         if (options.mode == FetchOptions::Mode::Cors)</span>
<span class="line-removed">-             request.updateForAccessControl(*document);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         m_cachedImage = loader.requestImage(WTFMove(request)).value_or(nullptr);</span>
<span class="line-removed">-         m_bestFitImageScaleFactor = image.scaleFactor;</span>
      }
<span class="line-modified">!     return { m_cachedImage.get(), m_bestFitImageScaleFactor };</span>
  }
  
  void CSSImageSetValue::updateDeviceScaleFactor(const Document&amp; document)
  {
      float deviceScaleFactor = document.page() ? document.page()-&gt;deviceScaleFactor() : 1;
      if (deviceScaleFactor == m_deviceScaleFactor)
          return;
      m_deviceScaleFactor = deviceScaleFactor;
      m_accessedBestFitImage = false;
<span class="line-modified">!     m_cachedImage = nullptr;</span>
  }
  
  String CSSImageSetValue::customCSSText() const
  {
      StringBuilder result;
      result.appendLiteral(&quot;image-set(&quot;);
  
      size_t length = this-&gt;length();
<span class="line-modified">!     size_t i = 0;</span>
<span class="line-removed">-     while (i &lt; length) {</span>
          if (i &gt; 0)
              result.appendLiteral(&quot;, &quot;);
  
<span class="line-modified">!         const CSSValue* imageValue = item(i);</span>
<span class="line-removed">-         result.append(imageValue-&gt;cssText());</span>
<span class="line-removed">-         result.append(&#39; &#39;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ++i;</span>
<span class="line-removed">-         ASSERT_WITH_SECURITY_IMPLICATION(i &lt; length);</span>
<span class="line-removed">-         const CSSValue* scaleFactorValue = item(i);</span>
<span class="line-removed">-         result.append(scaleFactorValue-&gt;cssText());</span>
<span class="line-removed">-         // FIXME: Eventually the scale factor should contain it&#39;s own unit http://wkb.ug/100120.</span>
<span class="line-removed">-         // For now &#39;x&#39; is hard-coded in the parser, so we hard-code it here too.</span>
<span class="line-removed">-         result.append(&#39;x&#39;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ++i;</span>
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
  }
  
  bool CSSImageSetValue::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
  {
<span class="line-modified">!     if (!m_cachedImage)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     return handler(*m_cachedImage);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 79,72 ---</span>
              return image;
      }
      return image;
  }
  
<span class="line-modified">! CachedImage* CSSImageSetValue::cachedImage() const</span>
  {
<span class="line-modified">!     if (is&lt;CSSImageValue&gt;(m_selectedImageValue))</span>
<span class="line-modified">!         return downcast&lt;CSSImageValue&gt;(*m_selectedImageValue).cachedImage();</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! ImageWithScale CSSImageSetValue::selectBestFitImage(const Document&amp; document)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     updateDeviceScaleFactor(document);</span>
  
      if (!m_accessedBestFitImage) {
          m_accessedBestFitImage = true;
<span class="line-modified">!         m_bestFitImage = bestImageForScaleFactor();</span>
      }
<span class="line-modified">! </span>
<span class="line-added">+     return m_bestFitImage;</span>
  }
  
  void CSSImageSetValue::updateDeviceScaleFactor(const Document&amp; document)
  {
<span class="line-added">+     // FIXME: In the future, we want to take much more than deviceScaleFactor into acount here.</span>
<span class="line-added">+     // All forms of scale should be included: Page::pageScaleFactor(), Frame::pageZoomFactor(),</span>
<span class="line-added">+     // and any CSS transforms. https://bugs.webkit.org/show_bug.cgi?id=81698</span>
      float deviceScaleFactor = document.page() ? document.page()-&gt;deviceScaleFactor() : 1;
      if (deviceScaleFactor == m_deviceScaleFactor)
          return;
      m_deviceScaleFactor = deviceScaleFactor;
      m_accessedBestFitImage = false;
<span class="line-modified">!     m_selectedImageValue = nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Ref&lt;CSSImageSetValue&gt; CSSImageSetValue::imageSetWithStylesResolved(Style::BuilderState&amp; builderState)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Ref&lt;CSSImageSetValue&gt; result = CSSImageSetValue::create();</span>
<span class="line-added">+     size_t length = this-&gt;length();</span>
<span class="line-added">+     for (size_t i = 0; i + 1 &lt; length; i += 2) {</span>
<span class="line-added">+         result-&gt;append(builderState.resolveImageStyles(*itemWithoutBoundsCheck(i)));</span>
<span class="line-added">+         result-&gt;append(*itemWithoutBoundsCheck(i + 1));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return result;</span>
  }
  
  String CSSImageSetValue::customCSSText() const
  {
      StringBuilder result;
      result.appendLiteral(&quot;image-set(&quot;);
  
      size_t length = this-&gt;length();
<span class="line-modified">!     for (size_t i = 0; i + 1 &lt; length; i += 2) {</span>
          if (i &gt; 0)
              result.appendLiteral(&quot;, &quot;);
  
<span class="line-modified">!         result.append(item(i)-&gt;cssText(), &#39; &#39;, item(i + 1)-&gt;cssText());</span>
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
  }
  
  bool CSSImageSetValue::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
  {
<span class="line-modified">!     return m_selectedImageValue &amp;&amp; m_selectedImageValue-&gt;traverseSubresources(handler);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="CSSImageGeneratorValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSImageSetValue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
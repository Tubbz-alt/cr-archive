diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedStringHash.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedStringHash.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedStringHash.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedStringHash.h
@@ -24,34 +24,27 @@
  */
 
 #pragma once
 
 #include <wtf/Forward.h>
+#include <wtf/Markable.h>
 #include <wtf/text/StringHash.h>
 
 namespace WebCore {
 
-typedef uint64_t SharedStringHash;
+using SharedStringHash = uint32_t;
 
-// Use the low 32-bits of the 64-bit SharedStringHash as the key for HashSets.
+// This is a hash value, but it can be used as a key in HashMap. So, we need to avoid producing deleted-value in HashMap, which is -1.
 struct SharedStringHashHash {
     static unsigned hash(SharedStringHash key) { return static_cast<unsigned>(key); }
     static bool equal(SharedStringHash a, SharedStringHash b) { return a == b; }
     static const bool safeToCompareToEmptyOrDeleted = true;
-
-    // See AlreadyHashed::avoidDeletedValue.
-    static unsigned avoidDeletedValue(SharedStringHash hash64)
-    {
-        ASSERT(hash64);
-        unsigned hash = static_cast<unsigned>(hash64);
-        unsigned newHash = hash | (!(hash + 1) << 31);
-        ASSERT(newHash);
-        ASSERT(newHash != 0xFFFFFFFF);
-        return newHash;
-    }
+    static constexpr SharedStringHash deletedValue = std::numeric_limits<SharedStringHash>::max();
 };
 
+using SharedStringHashMarkableTraits = IntegralMarkableTraits<SharedStringHash, SharedStringHashHash::deletedValue>;
+
 // Returns the hash of the string that will be used for visited link coloring.
 WEBCORE_EXPORT SharedStringHash computeSharedStringHash(const String& url);
 WEBCORE_EXPORT SharedStringHash computeSharedStringHash(const UChar* url, unsigned length);
 
 // Resolves the potentially relative URL "attributeURL" relative to the given

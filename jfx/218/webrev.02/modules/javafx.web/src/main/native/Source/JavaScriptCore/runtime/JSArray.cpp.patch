diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp
@@ -1,8 +1,8 @@
 /*
  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
- *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.
+ *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
  *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
@@ -79,11 +79,11 @@
         }
     } else {
         ASSERT(
             indexingType == ArrayWithSlowPutArrayStorage
             || indexingType == ArrayWithArrayStorage);
-        static const unsigned indexBias = 0;
+        static constexpr unsigned indexBias = 0;
         unsigned vectorLength = ArrayStorage::optimalVectorLength(indexBias, structure, initialLength);
         void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
             vm,
             Butterfly::totalSize(indexBias, outOfLineStorage, true, ArrayStorage::sizeFor(vectorLength)),
             deferralContext, AllocationFailureMode::ReturnNull);
@@ -132,81 +132,81 @@
             storage->m_vector[i].clear();
     }
     scope.notifyInitialized(array);
 }
 
-void JSArray::setLengthWritable(ExecState* exec, bool writable)
+void JSArray::setLengthWritable(JSGlobalObject* globalObject, bool writable)
 {
     ASSERT(isLengthWritable() || !writable);
     if (!isLengthWritable() || writable)
         return;
 
-    enterDictionaryIndexingMode(exec->vm());
+    enterDictionaryIndexingMode(globalObject->vm());
 
     SparseArrayValueMap* map = arrayStorage()->m_sparseMap.get();
     ASSERT(map);
     map->setLengthIsReadOnly();
 }
 
 // Defined in ES5.1 15.4.5.1
-bool JSArray::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor& descriptor, bool throwException)
+bool JSArray::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor& descriptor, bool throwException)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     JSArray* array = jsCast<JSArray*>(object);
 
     // 3. If P is "length", then
     if (propertyName == vm.propertyNames->length) {
         // All paths through length definition call the default [[DefineOwnProperty]], hence:
         // from ES5.1 8.12.9 7.a.
         if (descriptor.configurablePresent() && descriptor.configurable())
-            return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);
+            return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);
         // from ES5.1 8.12.9 7.b.
         if (descriptor.enumerablePresent() && descriptor.enumerable())
-            return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);
+            return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);
 
         // a. If the [[Value]] field of Desc is absent, then
         // a.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing "length", Desc, and Throw as arguments.
         if (descriptor.isAccessorDescriptor())
-            return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
+            return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
         // from ES5.1 8.12.9 10.a.
         if (!array->isLengthWritable() && descriptor.writablePresent() && descriptor.writable())
-            return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);
+            return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);
         // This descriptor is either just making length read-only, or changing nothing!
         if (!descriptor.value()) {
             if (descriptor.writablePresent())
-                array->setLengthWritable(exec, descriptor.writable());
+                array->setLengthWritable(globalObject, descriptor.writable());
             return true;
         }
 
         // b. Let newLenDesc be a copy of Desc.
         // c. Let newLen be ToUint32(Desc.[[Value]]).
-        unsigned newLen = descriptor.value().toUInt32(exec);
+        unsigned newLen = descriptor.value().toUInt32(globalObject);
         RETURN_IF_EXCEPTION(scope, false);
         // d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception.
-        double valueAsNumber = descriptor.value().toNumber(exec);
+        double valueAsNumber = descriptor.value().toNumber(globalObject);
         RETURN_IF_EXCEPTION(scope, false);
         if (newLen != valueAsNumber) {
-            JSC::throwException(exec, scope, createRangeError(exec, "Invalid array length"_s));
+            JSC::throwException(globalObject, scope, createRangeError(globalObject, "Invalid array length"_s));
             return false;
         }
 
         // Based on SameValue check in 8.12.9, this is always okay.
         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
         if (newLen == array->length()) {
             if (descriptor.writablePresent())
-                array->setLengthWritable(exec, descriptor.writable());
+                array->setLengthWritable(globalObject, descriptor.writable());
             return true;
         }
 
         // e. Set newLenDesc.[[Value] to newLen.
         // f. If newLen >= oldLen, then
         // f.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing "length", newLenDesc, and Throw as arguments.
         // g. Reject if oldLenDesc.[[Writable]] is false.
         if (!array->isLengthWritable())
-            return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);
+            return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);
 
         // h. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
         // i. Else,
         // i.i. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
         // i.ii. Let newWritable be false.
@@ -215,28 +215,28 @@
         // k. If succeeded is false, return false.
         // l. While newLen < oldLen repeat,
         // l.i. Set oldLen to oldLen â€“ 1.
         // l.ii. Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing ToString(oldLen) and false as arguments.
         // l.iii. If deleteSucceeded is false, then
-        bool success = array->setLength(exec, newLen, throwException);
+        bool success = array->setLength(globalObject, newLen, throwException);
         EXCEPTION_ASSERT(!scope.exception() || !success);
         if (!success) {
             // 1. Set newLenDesc.[[Value] to oldLen+1.
             // 2. If newWritable is false, set newLenDesc.[[Writable] to false.
             // 3. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing "length", newLenDesc, and false as arguments.
             // 4. Reject.
             if (descriptor.writablePresent())
-                array->setLengthWritable(exec, descriptor.writable());
+                array->setLengthWritable(globalObject, descriptor.writable());
             return false;
         }
 
         // m. If newWritable is false, then
         // i. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing "length",
         //    Property Descriptor{[[Writable]]: false}, and false as arguments. This call will always
         //    return true.
         if (descriptor.writablePresent())
-            array->setLengthWritable(exec, descriptor.writable());
+            array->setLengthWritable(globalObject, descriptor.writable());
         // n. Return true.
         return true;
     }
 
     // 4. Else if P is an array index (15.4), then
@@ -244,97 +244,97 @@
     if (Optional<uint32_t> optionalIndex = parseIndex(propertyName)) {
         // b. Reject if index >= oldLen and oldLenDesc.[[Writable]] is false.
         uint32_t index = optionalIndex.value();
         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
         if (index >= array->length() && !array->isLengthWritable())
-            return typeError(exec, scope, throwException, "Attempting to define numeric property on array with non-writable length property."_s);
+            return typeError(globalObject, scope, throwException, "Attempting to define numeric property on array with non-writable length property."_s);
         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
         // d. Reject if succeeded is false.
         // e. If index >= oldLen
         // e.i. Set oldLenDesc.[[Value]] to index + 1.
         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing "length", oldLenDesc, and false as arguments. This call will always return true.
         // f. Return true.
-        RELEASE_AND_RETURN(scope, array->defineOwnIndexedProperty(exec, index, descriptor, throwException));
+        RELEASE_AND_RETURN(scope, array->defineOwnIndexedProperty(globalObject, index, descriptor, throwException));
     }
 
-    RELEASE_AND_RETURN(scope, array->JSObject::defineOwnNonIndexProperty(exec, propertyName, descriptor, throwException));
+    RELEASE_AND_RETURN(scope, array->JSObject::defineOwnNonIndexProperty(globalObject, propertyName, descriptor, throwException));
 }
 
-bool JSArray::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
+bool JSArray::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSArray* thisObject = jsCast<JSArray*>(object);
     if (propertyName == vm.propertyNames->length) {
         unsigned attributes = thisObject->isLengthWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
         slot.setValue(thisObject, attributes, jsNumber(thisObject->length()));
         return true;
     }
 
-    return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
+    return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 }
 
 // ECMA 15.4.5.1
-bool JSArray::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+bool JSArray::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     JSArray* thisObject = jsCast<JSArray*>(cell);
 
     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
-        RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));
+        RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));
 
     thisObject->ensureWritable(vm);
 
     if (propertyName == vm.propertyNames->length) {
         if (!thisObject->isLengthWritable()) {
             if (slot.isStrictMode())
-                throwTypeError(exec, scope, "Array length is not writable"_s);
+                throwTypeError(globalObject, scope, "Array length is not writable"_s);
             return false;
         }
 
-        unsigned newLength = value.toUInt32(exec);
+        unsigned newLength = value.toUInt32(globalObject);
         RETURN_IF_EXCEPTION(scope, false);
-        double valueAsNumber = value.toNumber(exec);
+        double valueAsNumber = value.toNumber(globalObject);
         RETURN_IF_EXCEPTION(scope, false);
         if (valueAsNumber != static_cast<double>(newLength)) {
-            throwException(exec, scope, createRangeError(exec, "Invalid array length"_s));
+            throwException(globalObject, scope, createRangeError(globalObject, "Invalid array length"_s));
             return false;
         }
-        RELEASE_AND_RETURN(scope, thisObject->setLength(exec, newLength, slot.isStrictMode()));
+        RELEASE_AND_RETURN(scope, thisObject->setLength(globalObject, newLength, slot.isStrictMode()));
     }
 
-    RELEASE_AND_RETURN(scope, JSObject::put(thisObject, exec, propertyName, value, slot));
+    RELEASE_AND_RETURN(scope, JSObject::put(thisObject, globalObject, propertyName, value, slot));
 }
 
-bool JSArray::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
+bool JSArray::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSArray* thisObject = jsCast<JSArray*>(cell);
 
     if (propertyName == vm.propertyNames->length)
         return false;
 
-    return JSObject::deleteProperty(thisObject, exec, propertyName);
+    return JSObject::deleteProperty(thisObject, globalObject, propertyName);
 }
 
 static int compareKeysForQSort(const void* a, const void* b)
 {
     unsigned da = *static_cast<const unsigned*>(a);
     unsigned db = *static_cast<const unsigned*>(b);
     return (da > db) - (da < db);
 }
 
-void JSArray::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray& propertyNames, EnumerationMode mode)
+void JSArray::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& propertyNames, EnumerationMode mode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSArray* thisObject = jsCast<JSArray*>(object);
 
     if (mode.includeDontEnumProperties())
         propertyNames.add(vm.propertyNames->length);
 
-    JSObject::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);
+    JSObject::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode);
 }
 
 // This method makes room in the vector, but leaves the new space for count slots uncleared.
 bool JSArray::unshiftCountSlowCase(const AbstractLocker&, VM& vm, DeferGC&, bool addToFront, unsigned count)
 {
@@ -419,25 +419,25 @@
 
     Butterfly* newButterfly = Butterfly::fromBase(newAllocBase, preCapacity, propertyCapacity);
 
     if (addToFront) {
         ASSERT(count + usedVectorLength <= newVectorLength);
-        memmove(newButterfly->arrayStorage()->m_vector + count, storage->m_vector, sizeof(JSValue) * usedVectorLength);
-        memmove(newButterfly->propertyStorage() - propertySize, butterfly->propertyStorage() - propertySize, sizeof(JSValue) * propertySize + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
+        gcSafeMemmove(newButterfly->arrayStorage()->m_vector + count, storage->m_vector, sizeof(JSValue) * usedVectorLength);
+        gcSafeMemmove(newButterfly->propertyStorage() - propertySize, butterfly->propertyStorage() - propertySize, sizeof(JSValue) * propertySize + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
 
         // We don't need to zero the pre-capacity for the concurrent GC because it is not available to use as property storage.
-        memset(newButterfly->base(0, propertyCapacity), 0, (propertyCapacity - propertySize) * sizeof(JSValue));
+        gcSafeZeroMemory(static_cast<JSValue*>(newButterfly->base(0, propertyCapacity)), (propertyCapacity - propertySize) * sizeof(JSValue));
 
         if (allocatedNewStorage) {
             // We will set the vectorLength to newVectorLength. We populated requiredVectorLength
             // (usedVectorLength + count), which is less. Clear the difference.
             for (unsigned i = requiredVectorLength; i < newVectorLength; ++i)
                 newButterfly->arrayStorage()->m_vector[i].clear();
         }
     } else if ((newAllocBase != butterfly->base(structure)) || (preCapacity != storage->m_indexBias)) {
-        memmove(newButterfly->propertyStorage() - propertyCapacity, butterfly->propertyStorage() - propertyCapacity, sizeof(JSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
-        memmove(newButterfly->arrayStorage()->m_vector, storage->m_vector, sizeof(JSValue) * usedVectorLength);
+        gcSafeMemmove(newButterfly->propertyStorage() - propertyCapacity, butterfly->propertyStorage() - propertyCapacity, sizeof(JSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
+        gcSafeMemmove(newButterfly->arrayStorage()->m_vector, storage->m_vector, sizeof(JSValue) * usedVectorLength);
 
         for (unsigned i = requiredVectorLength; i < newVectorLength; i++)
             newButterfly->arrayStorage()->m_vector[i].clear();
     }
 
@@ -447,24 +447,24 @@
     setButterfly(vm, newButterfly);
 
     return true;
 }
 
-bool JSArray::setLengthWithArrayStorage(ExecState* exec, unsigned newLength, bool throwException, ArrayStorage* storage)
+bool JSArray::setLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned newLength, bool throwException, ArrayStorage* storage)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     unsigned length = storage->length();
 
     // If the length is read only then we enter sparse mode, so should enter the following 'if'.
     ASSERT(isLengthWritable() || storage->m_sparseMap);
 
     if (SparseArrayValueMap* map = storage->m_sparseMap.get()) {
         // Fail if the length is not writable.
         if (map->lengthIsReadOnly())
-            return typeError(exec, scope, throwException, ReadonlyPropertyWriteError);
+            return typeError(globalObject, scope, throwException, ReadonlyPropertyWriteError);
 
         if (newLength < length) {
             // Copy any keys we might be interested in into a vector.
             Vector<unsigned, 0, UnsafeVectorOverflow> keys;
             keys.reserveInitialCapacity(std::min(map->size(), static_cast<size_t>(length - newLength)));
@@ -485,11 +485,11 @@
                     unsigned index = keys[--i];
                     SparseArrayValueMap::iterator it = map->find(index);
                     ASSERT(it != map->notFound());
                     if (it->value.attributes() & PropertyAttribute::DontDelete) {
                         storage->setLength(index + 1);
-                        return typeError(exec, scope, throwException, UnableToDeletePropertyError);
+                        return typeError(globalObject, scope, throwException, UnableToDeletePropertyError);
                     }
                     map->remove(it);
                 }
             } else {
                 for (unsigned i = 0; i < keys.size(); ++i)
@@ -514,11 +514,11 @@
     storage->setLength(newLength);
 
     return true;
 }
 
-bool JSArray::appendMemcpy(ExecState* exec, VM& vm, unsigned startIndex, JSC::JSArray* otherArray)
+bool JSArray::appendMemcpy(JSGlobalObject* globalObject, VM& vm, unsigned startIndex, JSC::JSArray* otherArray)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!canFastCopy(vm, otherArray))
         return false;
@@ -544,19 +544,19 @@
     Checked<unsigned, RecordOverflow> checkedNewLength = startIndex;
     checkedNewLength += otherLength;
 
     unsigned newLength;
     if (checkedNewLength.safeGet(newLength) == CheckedState::DidOverflow) {
-        throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));
+        throwException(globalObject, scope, createRangeError(globalObject, LengthExceededTheMaximumArrayLengthError));
         return false;
     }
 
     if (newLength >= MIN_SPARSE_ARRAY_INDEX)
         return false;
 
     if (!ensureLength(vm, newLength)) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return false;
     }
     ASSERT(copyType == indexingType());
 
     if (UNLIKELY(otherType == ArrayWithUndecided)) {
@@ -567,32 +567,32 @@
         } else {
             for (unsigned i = startIndex; i < newLength; ++i)
                 butterfly->contiguousInt32().at(this, i).setWithoutWriteBarrier(JSValue());
         }
     } else if (type == ArrayWithDouble)
-        memcpy(butterfly()->contiguousDouble().data() + startIndex, otherArray->butterfly()->contiguousDouble().data(), sizeof(JSValue) * otherLength);
+        gcSafeMemcpy(butterfly()->contiguousDouble().data() + startIndex, otherArray->butterfly()->contiguousDouble().data(), sizeof(JSValue) * otherLength);
     else {
-        memcpy(butterfly()->contiguous().data() + startIndex, otherArray->butterfly()->contiguous().data(), sizeof(JSValue) * otherLength);
+        gcSafeMemcpy(butterfly()->contiguous().data() + startIndex, otherArray->butterfly()->contiguous().data(), sizeof(JSValue) * otherLength);
         vm.heap.writeBarrier(this);
     }
 
     return true;
 }
 
-bool JSArray::setLength(ExecState* exec, unsigned newLength, bool throwException)
+bool JSArray::setLength(JSGlobalObject* globalObject, unsigned newLength, bool throwException)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     Butterfly* butterfly = this->butterfly();
     switch (indexingMode()) {
     case ArrayClass:
         if (!newLength)
             return true;
         if (newLength >= MIN_SPARSE_ARRAY_INDEX) {
             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
-                exec, newLength, throwException,
+                globalObject, newLength, throwException,
                 ensureArrayStorage(vm)));
         }
         createInitialUndecided(vm, newLength);
         return true;
 
@@ -613,16 +613,16 @@
             return true;
         if (newLength > MAX_STORAGE_VECTOR_LENGTH // This check ensures that we can do fast push.
             || (newLength >= MIN_SPARSE_ARRAY_INDEX
                 && !isDenseEnoughForVector(newLength, countElements()))) {
             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
-                exec, newLength, throwException,
+                globalObject, newLength, throwException,
                 ensureArrayStorage(vm)));
         }
         if (newLength > butterfly->publicLength()) {
             if (!ensureLength(vm, newLength)) {
-                throwOutOfMemoryError(exec, scope);
+                throwOutOfMemoryError(globalObject, scope);
                 return false;
             }
             return true;
         }
 
@@ -644,21 +644,21 @@
         return true;
     }
 
     case ArrayWithArrayStorage:
     case ArrayWithSlowPutArrayStorage:
-        RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(exec, newLength, throwException, arrayStorage()));
+        RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(globalObject, newLength, throwException, arrayStorage()));
 
     default:
         CRASH();
         return false;
     }
 }
 
-JSValue JSArray::pop(ExecState* exec)
+JSValue JSArray::pop(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     ensureWritable(vm);
 
     Butterfly* butterfly = this->butterfly();
@@ -710,11 +710,11 @@
         ArrayStorage* storage = butterfly->arrayStorage();
 
         unsigned length = storage->length();
         if (!length) {
             if (!isLengthWritable())
-                throwTypeError(exec, scope, ReadonlyPropertyWriteError);
+                throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);
             return jsUndefined();
         }
 
         unsigned index = length - 1;
         if (index < storage->vectorLength()) {
@@ -737,37 +737,37 @@
         return JSValue();
     }
 
     unsigned index = getArrayLength() - 1;
     // Let element be the result of calling the [[Get]] internal method of O with argument indx.
-    JSValue element = get(exec, index);
+    JSValue element = get(globalObject, index);
     RETURN_IF_EXCEPTION(scope, JSValue());
     // Call the [[Delete]] internal method of O with arguments indx and true.
-    bool success = deletePropertyByIndex(this, exec, index);
+    bool success = deletePropertyByIndex(this, globalObject, index);
     RETURN_IF_EXCEPTION(scope, JSValue());
     if (!success) {
-        throwTypeError(exec, scope, UnableToDeletePropertyError);
+        throwTypeError(globalObject, scope, UnableToDeletePropertyError);
         return jsUndefined();
     }
     // Call the [[Put]] internal method of O with arguments "length", indx, and true.
     scope.release();
-    setLength(exec, index, true);
+    setLength(globalObject, index, true);
     // Return element.
     return element;
 }
 
 // Push & putIndex are almost identical, with two small differences.
 //  - we always are writing beyond the current array bounds, so it is always necessary to update m_length & m_numValuesInVector.
 //  - pushing to an array of length 2^32-1 stores the property, but throws a range error.
-NEVER_INLINE void JSArray::push(ExecState* exec, JSValue value)
+NEVER_INLINE void JSArray::push(JSGlobalObject* globalObject, JSValue value)
 {
-    pushInline(exec, value);
+    pushInline(globalObject, value);
 }
 
-JSArray* JSArray::fastSlice(ExecState& exec, unsigned startIndex, unsigned count)
+JSArray* JSArray::fastSlice(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)
 {
-    VM& vm = exec.vm();
+    VM& vm = globalObject->vm();
 
     ensureWritable(vm);
 
     auto arrayType = indexingMode();
     switch (arrayType) {
@@ -775,28 +775,27 @@
     case ArrayWithInt32:
     case ArrayWithContiguous: {
         if (count >= MIN_SPARSE_ARRAY_INDEX || structure(vm)->holesMustForwardToPrototype(vm, this))
             return nullptr;
 
-        JSGlobalObject* lexicalGlobalObject = exec.lexicalGlobalObject();
-        Structure* resultStructure = lexicalGlobalObject->arrayStructureForIndexingTypeDuringAllocation(arrayType);
+        Structure* resultStructure = globalObject->arrayStructureForIndexingTypeDuringAllocation(arrayType);
         if (UNLIKELY(hasAnyArrayStorage(resultStructure->indexingType())))
             return nullptr;
 
-        ASSERT(!lexicalGlobalObject->isHavingABadTime());
+        ASSERT(!globalObject->isHavingABadTime());
         ObjectInitializationScope scope(vm);
         JSArray* resultArray = JSArray::tryCreateUninitializedRestricted(scope, resultStructure, count);
         if (UNLIKELY(!resultArray))
             return nullptr;
 
         auto& resultButterfly = *resultArray->butterfly();
         if (arrayType == ArrayWithDouble)
-            memcpy(resultButterfly.contiguousDouble().data(), butterfly()->contiguousDouble().data() + startIndex, sizeof(JSValue) * count);
+            gcSafeMemcpy(resultButterfly.contiguousDouble().data(), butterfly()->contiguousDouble().data() + startIndex, sizeof(JSValue) * count);
         else
-            memcpy(resultButterfly.contiguous().data(), butterfly()->contiguous().data() + startIndex, sizeof(JSValue) * count);
-        resultButterfly.setPublicLength(count);
+            gcSafeMemcpy(resultButterfly.contiguous().data(), butterfly()->contiguous().data() + startIndex, sizeof(JSValue) * count);
 
+        ASSERT(resultButterfly.publicLength() == count);
         return resultArray;
     }
     default:
         return nullptr;
     }
@@ -848,11 +847,11 @@
     if (numElementsBeforeShiftRegion < numElementsAfterShiftRegion) {
         // The number of elements before the shift region is less than the number of elements
         // after the shift region, so we move the elements before to the right.
         if (numElementsBeforeShiftRegion) {
             RELEASE_ASSERT(count + startIndex <= vectorLength);
-            memmove(storage->m_vector + count,
+            gcSafeMemmove(storage->m_vector + count,
                 storage->m_vector,
                 sizeof(JSValue) * startIndex);
         }
         // Adjust the Butterfly and the index bias. We only need to do this here because we're changing
         // the start of the Butterfly, which needs to point at the first indexed property in the used
@@ -866,11 +865,11 @@
         storage->setVectorLength(vectorLength - count);
         setButterfly(vm, butterfly);
     } else {
         // The number of elements before the shift region is greater than or equal to the number
         // of elements after the shift region, so we move the elements after the shift region to the left.
-        memmove(storage->m_vector + startIndex,
+        gcSafeMemmove(storage->m_vector + startIndex,
             storage->m_vector + firstIndexAfterShiftRegion,
             sizeof(JSValue) * numElementsAfterShiftRegion);
 
         // Clear the slots of the elements we just moved.
         unsigned startOfEmptyVectorTail = usedVectorLength - count;
@@ -883,20 +882,21 @@
     }
 
     return true;
 }
 
-bool JSArray::shiftCountWithAnyIndexingType(ExecState* exec, unsigned& startIndex, unsigned count)
+bool JSArray::shiftCountWithAnyIndexingType(JSGlobalObject* globalObject, unsigned& startIndex, unsigned count)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     RELEASE_ASSERT(count > 0);
 
     ensureWritable(vm);
 
     Butterfly* butterfly = this->butterfly();
 
-    switch (indexingType()) {
+    auto indexingType = this->indexingType();
+    switch (indexingType) {
     case ArrayClass:
         return true;
 
     case ArrayWithUndecided:
         // Don't handle this because it's confusing and it shouldn't come up.
@@ -925,11 +925,11 @@
                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
                 }
                 butterfly->contiguous().at(this, i).setWithoutWriteBarrier(v);
             }
         } else {
-            memmove(butterfly->contiguous().data() + startIndex,
+            gcSafeMemmove(butterfly->contiguous().data() + startIndex,
                 butterfly->contiguous().data() + startIndex + count,
                 sizeof(JSValue) * (end - startIndex));
         }
 
         for (unsigned i = end; i < oldLength; ++i)
@@ -937,11 +937,12 @@
 
         butterfly->setPublicLength(oldLength - count);
 
         // Our memmoving of values around in the array could have concealed some of them from
         // the collector. Let's make sure that the collector scans this object again.
-        vm.heap.writeBarrier(this);
+        if (indexingType == ArrayWithContiguous)
+            vm.heap.writeBarrier(this);
 
         return true;
     }
 
     case ArrayWithDouble: {
@@ -966,11 +967,11 @@
                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
                 }
                 butterfly->contiguousDouble().at(this, i) = v;
             }
         } else {
-            memmove(butterfly->contiguousDouble().data() + startIndex,
+            gcSafeMemmove(butterfly->contiguousDouble().data() + startIndex,
                 butterfly->contiguousDouble().data() + startIndex + count,
                 sizeof(JSValue) * (end - startIndex));
         }
         for (unsigned i = end; i < oldLength; ++i)
             butterfly->contiguousDouble().at(this, i) = PNaN;
@@ -988,13 +989,13 @@
         return false;
     }
 }
 
 // Returns true if the unshift can be handled, false to fallback.
-bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage)
+bool JSArray::unshiftCountWithArrayStorage(JSGlobalObject* globalObject, unsigned startIndex, unsigned count, ArrayStorage* storage)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     unsigned length = storage->length();
 
     RELEASE_ASSERT(startIndex <= length);
@@ -1022,32 +1023,32 @@
     } else if (!moveFront && vectorLength - length >= count)
         storage = storage->butterfly()->arrayStorage();
     else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
         storage = arrayStorage();
     else {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return true;
     }
 
     WriteBarrier<Unknown>* vector = storage->m_vector;
 
     if (startIndex) {
         if (moveFront)
-            memmove(vector, vector + count, startIndex * sizeof(JSValue));
+            gcSafeMemmove(vector, vector + count, startIndex * sizeof(JSValue));
         else if (length - startIndex)
-            memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));
+            gcSafeMemmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));
     }
 
     for (unsigned i = 0; i < count; i++)
         vector[i + startIndex].clear();
 
     return true;
 }
 
-bool JSArray::unshiftCountWithAnyIndexingType(ExecState* exec, unsigned startIndex, unsigned count)
+bool JSArray::unshiftCountWithAnyIndexingType(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     ensureWritable(vm);
 
     Butterfly* butterfly = this->butterfly();
@@ -1063,33 +1064,33 @@
         unsigned oldLength = butterfly->publicLength();
 
         // We may have to walk the entire array to do the unshift. We're willing to do so
         // only if it's not horribly slow.
         if (oldLength - startIndex >= MIN_SPARSE_ARRAY_INDEX)
-            RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
+            RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));
 
         Checked<unsigned, RecordOverflow> checkedLength(oldLength);
         checkedLength += count;
         unsigned newLength;
         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
             return true;
         }
         if (newLength > MAX_STORAGE_VECTOR_LENGTH)
             return false;
         if (!ensureLength(vm, newLength)) {
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
             return true;
         }
         butterfly = this->butterfly();
 
         // We have to check for holes before we start moving things around so that we don't get halfway
         // through shifting and then realize we should have been in ArrayStorage mode.
         for (unsigned i = oldLength; i-- > startIndex;) {
             JSValue v = butterfly->contiguous().at(this, i).get();
             if (UNLIKELY(!v))
-                RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
+                RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));
         }
 
         for (unsigned i = oldLength; i-- > startIndex;) {
             JSValue v = butterfly->contiguous().at(this, i).get();
             ASSERT(v);
@@ -1112,33 +1113,33 @@
         unsigned oldLength = butterfly->publicLength();
 
         // We may have to walk the entire array to do the unshift. We're willing to do so
         // only if it's not horribly slow.
         if (oldLength - startIndex >= MIN_SPARSE_ARRAY_INDEX)
-            RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
+            RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));
 
         Checked<unsigned, RecordOverflow> checkedLength(oldLength);
         checkedLength += count;
         unsigned newLength;
         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
             return true;
         }
         if (newLength > MAX_STORAGE_VECTOR_LENGTH)
             return false;
         if (!ensureLength(vm, newLength)) {
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
             return true;
         }
         butterfly = this->butterfly();
 
         // We have to check for holes before we start moving things around so that we don't get halfway
         // through shifting and then realize we should have been in ArrayStorage mode.
         for (unsigned i = oldLength; i-- > startIndex;) {
             double v = butterfly->contiguousDouble().at(this, i);
             if (UNLIKELY(v != v))
-                RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
+                RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));
         }
 
         for (unsigned i = oldLength; i-- > startIndex;) {
             double v = butterfly->contiguousDouble().at(this, i);
             ASSERT(v == v);
@@ -1153,19 +1154,19 @@
         return true;
     }
 
     case ArrayWithArrayStorage:
     case ArrayWithSlowPutArrayStorage:
-        RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, arrayStorage()));
+        RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, arrayStorage()));
 
     default:
         CRASH();
         return false;
     }
 }
 
-void JSArray::fillArgList(ExecState* exec, MarkedArgumentBuffer& args)
+void JSArray::fillArgList(JSGlobalObject* globalObject, MarkedArgumentBuffer& args)
 {
     unsigned i = 0;
     unsigned vectorEnd;
     WriteBarrier<Unknown>* vector;
 
@@ -1224,16 +1225,16 @@
         args.append(v.get());
     }
 
     // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
     for (; i < length(); ++i)
-        args.append(get(exec, i));
+        args.append(get(globalObject, i));
 }
 
-void JSArray::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)
+void JSArray::copyToArguments(JSGlobalObject* globalObject, JSValue* firstElementDest, unsigned offset, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     unsigned i = offset;
     WriteBarrier<Unknown>* vector;
     unsigned vectorEnd;
@@ -1266,11 +1267,11 @@
         for (; i < butterfly->publicLength(); ++i) {
             ASSERT(i < butterfly->vectorLength());
             double v = butterfly->contiguousDouble().at(this, i);
             if (v != v)
                 break;
-            exec->r(firstElementDest + i - offset) = JSValue(JSValue::EncodeAsDouble, v);
+            firstElementDest[i - offset] = JSValue(JSValue::EncodeAsDouble, v);
         }
         break;
     }
 
     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
@@ -1291,15 +1292,15 @@
 
     for (; i < vectorEnd; ++i) {
         WriteBarrier<Unknown>& v = vector[i];
         if (!v)
             break;
-        exec->r(firstElementDest + i - offset) = v.get();
+        firstElementDest[i - offset] = v.get();
     }
 
     for (; i < length; ++i) {
-        exec->r(firstElementDest + i - offset) = get(exec, i);
+        firstElementDest[i - offset] = get(globalObject, i);
         RETURN_IF_EXCEPTION(scope, void());
     }
 }
 
 bool JSArray::isIteratorProtocolFastAndNonObservable()
@@ -1343,36 +1344,36 @@
         JSArray::eagerlyInitializeButterfly(scope, array, length);
 
     return array;
 }
 
-JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const ArgList& values)
+JSArray* constructArray(JSGlobalObject* globalObject, Structure* arrayStructure, const ArgList& values)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     unsigned length = values.size();
     ObjectInitializationScope scope(vm);
 
     JSArray* array = constructArray(scope, arrayStructure, length);
     for (unsigned i = 0; i < length; ++i)
         array->initializeIndex(scope, i, values.at(i));
     return array;
 }
 
-JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)
+JSArray* constructArray(JSGlobalObject* globalObject, Structure* arrayStructure, const JSValue* values, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ObjectInitializationScope scope(vm);
 
     JSArray* array = constructArray(scope, arrayStructure, length);
     for (unsigned i = 0; i < length; ++i)
         array->initializeIndex(scope, i, values[i]);
     return array;
 }
 
-JSArray* constructArrayNegativeIndexed(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)
+JSArray* constructArrayNegativeIndexed(JSGlobalObject* globalObject, Structure* arrayStructure, const JSValue* values, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ObjectInitializationScope scope(vm);
 
     JSArray* array = constructArray(scope, arrayStructure, length);
     for (int i = 0; i < static_cast<int>(length); ++i)
         array->initializeIndex(scope, i, values[-i]);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
<a name="2" id="anc2"></a><span class="line-added"> 30 #include &quot;CacheableIdentifier.h&quot;</span>
 31 #include &quot;JSFunctionInlines.h&quot;
 32 #include &quot;ObjectPropertyConditionSet.h&quot;
 33 #include &quot;PolyProtoAccessChain.h&quot;
 34 #include &lt;wtf/CommaPrinter.h&gt;
 35 
 36 namespace JSC {
 37 
 38 struct AccessGenerationState;
 39 
<a name="3" id="anc3"></a><span class="line-added"> 40 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AccessCase);</span>
<span class="line-added"> 41 </span>
 42 // An AccessCase describes one of the cases of a PolymorphicAccess. A PolymorphicAccess represents a
 43 // planned (to generate in future) or generated stub for some inline cache. That stub contains fast
 44 // path code for some finite number of fast cases, each described by an AccessCase object.
 45 //
 46 // An AccessCase object has a lifecycle that proceeds through several states. Note that the states
 47 // of AccessCase have a lot to do with the global effect epoch (we&#39;ll say epoch for short). This is
 48 // a simple way of reasoning about the state of the system outside this AccessCase. Any observable
 49 // effect - like storing to a property, changing an object&#39;s structure, etc. - increments the epoch.
 50 // The states are:
 51 //
 52 // Primordial:   This is an AccessCase that was just allocated. It does not correspond to any actual
 53 //               code and it is not owned by any PolymorphicAccess. In this state, the AccessCase
 54 //               assumes that it is in the same epoch as when it was created. This is important
 55 //               because it may make claims about itself (&quot;I represent a valid case so long as you
 56 //               register a watchpoint on this set&quot;) that could be contradicted by some outside
 57 //               effects (like firing and deleting the watchpoint set in question). This is also the
 58 //               state that an AccessCase is in when it is cloned (AccessCase::clone()).
 59 //
 60 // Committed:    This happens as soon as some PolymorphicAccess takes ownership of this AccessCase.
 61 //               In this state, the AccessCase no longer assumes anything about the epoch. To
 62 //               accomplish this, PolymorphicAccess calls AccessCase::commit(). This must be done
 63 //               during the same epoch when the AccessCase was created, either by the client or by
 64 //               clone(). When created by the client, committing during the same epoch works because
 65 //               we can be sure that whatever watchpoint sets they spoke of are still valid. When
 66 //               created by clone(), we can be sure that the set is still valid because the original
 67 //               of the clone still has watchpoints on it.
 68 //
 69 // Generated:    This is the state when the PolymorphicAccess generates code for this case by
 70 //               calling AccessCase::generate() or AccessCase::generateWithGuard(). At this point
 71 //               the case object will have some extra stuff in it, like possibly the CallLinkInfo
 72 //               object associated with the inline cache.
 73 //               FIXME: Moving into the Generated state should not mutate the AccessCase object or
 74 //               put more stuff into it. If we fix this, then we can get rid of AccessCase::clone().
 75 //               https://bugs.webkit.org/show_bug.cgi?id=156456
 76 //
 77 // An AccessCase may be destroyed while in any of these states.
 78 //
 79 // We will sometimes buffer committed AccessCases in the PolymorphicAccess object before generating
 80 // code. This allows us to only regenerate once we&#39;ve accumulated (hopefully) more than one new
 81 // AccessCase.
 82 class AccessCase {
<a name="4" id="anc4"></a><span class="line-modified"> 83     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(AccessCase);</span>
 84 public:
 85     enum AccessType : uint8_t {
 86         Load,
 87         Transition,
 88         Replace,
 89         Miss,
 90         GetGetter,
 91         Getter,
 92         Setter,
 93         CustomValueGetter,
 94         CustomAccessorGetter,
 95         CustomValueSetter,
 96         CustomAccessorSetter,
 97         IntrinsicGetter,
 98         InHit,
 99         InMiss,
100         ArrayLength,
101         StringLength,
102         DirectArgumentsLength,
103         ScopedArgumentsLength,
104         ModuleNamespaceLoad,
105         InstanceOfHit,
106         InstanceOfMiss,
<a name="5" id="anc5"></a><span class="line-modified">107         InstanceOfGeneric,</span>
<span class="line-added">108         IndexedInt32Load,</span>
<span class="line-added">109         IndexedDoubleLoad,</span>
<span class="line-added">110         IndexedContiguousLoad,</span>
<span class="line-added">111         IndexedArrayStorageLoad,</span>
<span class="line-added">112         IndexedScopedArgumentsLoad,</span>
<span class="line-added">113         IndexedDirectArgumentsLoad,</span>
<span class="line-added">114         IndexedTypedArrayInt8Load,</span>
<span class="line-added">115         IndexedTypedArrayUint8Load,</span>
<span class="line-added">116         IndexedTypedArrayUint8ClampedLoad,</span>
<span class="line-added">117         IndexedTypedArrayInt16Load,</span>
<span class="line-added">118         IndexedTypedArrayUint16Load,</span>
<span class="line-added">119         IndexedTypedArrayInt32Load,</span>
<span class="line-added">120         IndexedTypedArrayUint32Load,</span>
<span class="line-added">121         IndexedTypedArrayFloat32Load,</span>
<span class="line-added">122         IndexedTypedArrayFloat64Load,</span>
<span class="line-added">123         IndexedStringLoad</span>
124     };
125 
126     enum State : uint8_t {
127         Primordial,
128         Committed,
129         Generated
130     };
131 
132     template&lt;typename T&gt;
133     T&amp; as() { return *static_cast&lt;T*&gt;(this); }
134 
135     template&lt;typename T&gt;
136     const T&amp; as() const { return *static_cast&lt;const T*&gt;(this); }
137 
138 
139     template&lt;typename AccessCaseType, typename... Arguments&gt;
140     static std::unique_ptr&lt;AccessCaseType&gt; create(Arguments... arguments)
141     {
142         return std::unique_ptr&lt;AccessCaseType&gt;(new AccessCaseType(arguments...));
143     }
144 
<a name="6" id="anc6"></a><span class="line-modified">145     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset = invalidOffset,</span>
146         Structure* = nullptr, const ObjectPropertyConditionSet&amp; = ObjectPropertyConditionSet(), std::unique_ptr&lt;PolyProtoAccessChain&gt; = nullptr);
147 
148     // This create method should be used for transitions.
<a name="7" id="anc7"></a><span class="line-modified">149     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, CacheableIdentifier, PropertyOffset, Structure* oldStructure,</span>
150         Structure* newStructure, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);
151 
<a name="8" id="anc8"></a><span class="line-modified">152     static std::unique_ptr&lt;AccessCase&gt; fromStructureStubInfo(VM&amp;, JSCell* owner, CacheableIdentifier, StructureStubInfo&amp;);</span>
153 
154     AccessType type() const { return m_type; }
155     State state() const { return m_state; }
156     PropertyOffset offset() const { return m_offset; }
157 
158     Structure* structure() const
159     {
160         if (m_type == Transition)
161             return m_structure-&gt;previousID();
162         return m_structure.get();
163     }
<a name="9" id="anc9"></a><span class="line-modified">164     bool guardedByStructureCheck(const StructureStubInfo&amp;) const;</span>
165 
166     Structure* newStructure() const
167     {
168         ASSERT(m_type == Transition);
169         return m_structure.get();
170     }
171 
172     ObjectPropertyConditionSet conditionSet() const { return m_conditionSet; }
173 
174     virtual bool hasAlternateBase() const;
175     virtual JSObject* alternateBase() const;
176 
177     virtual WatchpointSet* additionalSet() const { return nullptr; }
178     bool viaProxy() const { return m_viaProxy; }
179 
180     // If you supply the optional vector, this will append the set of cells that this will need to keep alive
181     // past the call.
<a name="10" id="anc10"></a><span class="line-modified">182     bool doesCalls(VM&amp;, Vector&lt;JSCell*&gt;* cellsToMark = nullptr) const;</span>
<span class="line-added">183 </span>
<span class="line-added">184     bool isCustom() const</span>
<span class="line-added">185     {</span>
<span class="line-added">186         switch (type()) {</span>
<span class="line-added">187         case CustomValueGetter:</span>
<span class="line-added">188         case CustomAccessorGetter:</span>
<span class="line-added">189         case CustomValueSetter:</span>
<span class="line-added">190         case CustomAccessorSetter:</span>
<span class="line-added">191             return true;</span>
<span class="line-added">192         default:</span>
<span class="line-added">193             return false;</span>
<span class="line-added">194         }</span>
<span class="line-added">195     }</span>
196 
197     bool isGetter() const
198     {
199         switch (type()) {
200         case Getter:
201         case CustomValueGetter:
202         case CustomAccessorGetter:
203             return true;
204         default:
205             return false;
206         }
207     }
208 
209     bool isAccessor() const { return isGetter() || type() == Setter; }
210 
211     // Is it still possible for this case to ever be taken? Must call this as a prerequisite for
212     // calling generate() and friends. If this returns true, then you can call generate(). If
213     // this returns false, then generate() will crash. You must call generate() in the same epoch
214     // as when you called couldStillSucceed().
215     bool couldStillSucceed() const;
216 
217     // If this method returns true, then it&#39;s a good idea to remove &#39;other&#39; from the access once &#39;this&#39;
218     // is added. This method assumes that in case of contradictions, &#39;this&#39; represents a newer, and so
219     // more useful, truth. This method can be conservative; it will return false when it doubt.
220     bool canReplace(const AccessCase&amp; other) const;
221 
222     void dump(PrintStream&amp; out) const;
223     virtual void dumpImpl(PrintStream&amp;, CommaPrinter&amp;) const { }
224 
225     virtual ~AccessCase();
226 
227     bool usesPolyProto() const
228     {
229         return !!m_polyProtoAccessChain;
230     }
231 
<a name="11" id="anc11"></a><span class="line-added">232     bool requiresIdentifierNameMatch() const;</span>
<span class="line-added">233     bool requiresInt32PropertyCheck() const;</span>
<span class="line-added">234     bool needsScratchFPR() const;</span>
<span class="line-added">235 </span>
<span class="line-added">236     static TypedArrayType toTypedArrayType(AccessType);</span>
<span class="line-added">237 </span>
<span class="line-added">238     UniquedStringImpl* uid() const { return m_identifier.uid(); }</span>
<span class="line-added">239     CacheableIdentifier identifier() const { return m_identifier; }</span>
<span class="line-added">240 </span>
<span class="line-added">241 #if ASSERT_ENABLED</span>
<span class="line-added">242     void checkConsistency(StructureStubInfo&amp;);</span>
<span class="line-added">243 #else</span>
<span class="line-added">244     ALWAYS_INLINE void checkConsistency(StructureStubInfo&amp;) { }</span>
<span class="line-added">245 #endif</span>
<span class="line-added">246 </span>
247 protected:
<a name="12" id="anc12"></a><span class="line-modified">248     AccessCase(VM&amp;, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset, Structure*, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);</span>
249     AccessCase(AccessCase&amp;&amp;) = default;
250     AccessCase(const AccessCase&amp; other)
251         : m_type(other.m_type)
252         , m_state(other.m_state)
253         , m_viaProxy(other.m_viaProxy)
254         , m_offset(other.m_offset)
255         , m_structure(other.m_structure)
256         , m_conditionSet(other.m_conditionSet)
<a name="13" id="anc13"></a><span class="line-added">257         , m_identifier(other.m_identifier)</span>
258     {
259         if (other.m_polyProtoAccessChain)
260             m_polyProtoAccessChain = other.m_polyProtoAccessChain-&gt;clone();
261     }
262 
263     AccessCase&amp; operator=(const AccessCase&amp;) = delete;
264     void resetState() { m_state = Primordial; }
265 
266 private:
267     friend class CodeBlock;
268     friend class PolymorphicAccess;
269 
<a name="14" id="anc14"></a><span class="line-added">270     template&lt;typename Functor&gt;</span>
<span class="line-added">271     void forEachDependentCell(VM&amp;, const Functor&amp;) const;</span>
<span class="line-added">272 </span>
<span class="line-added">273     void visitAggregate(SlotVisitor&amp;) const;</span>
274     bool visitWeak(VM&amp;) const;
275     bool propagateTransitions(SlotVisitor&amp;) const;
276 
277     // FIXME: This only exists because of how AccessCase puts post-generation things into itself.
278     // https://bugs.webkit.org/show_bug.cgi?id=156456
279     virtual std::unique_ptr&lt;AccessCase&gt; clone() const;
280 
281     // Perform any action that must be performed before the end of the epoch in which the case
282     // was created. Returns a set of watchpoint sets that will need to be watched.
<a name="15" id="anc15"></a><span class="line-modified">283     Vector&lt;WatchpointSet*, 2&gt; commit(VM&amp;);</span>
284 
285     // Fall through on success. Two kinds of failures are supported: fall-through, which means that we
286     // should try a different case; and failure, which means that this was the right case but it needs
287     // help from the slow path.
288     void generateWithGuard(AccessGenerationState&amp;, MacroAssembler::JumpList&amp; fallThrough);
289 
290     // Fall through on success, add a jump to the failure list on failure.
291     void generate(AccessGenerationState&amp;);
292 
293     void generateImpl(AccessGenerationState&amp;);
294 
<a name="16" id="anc16"></a><span class="line-added">295     bool guardedByStructureCheckSkippingConstantIdentifierCheck() const;</span>
<span class="line-added">296 </span>
297     AccessType m_type;
298     State m_state { Primordial };
299 protected:
300     // m_viaProxy is true only if the instance inherits (or it is) ProxyableAccessCase.
301     // We put this value here instead of ProxyableAccessCase to reduce the size of ProxyableAccessCase and its
302     // derived classes, which are super frequently allocated.
303     bool m_viaProxy { false };
304 private:
305     PropertyOffset m_offset;
306 
307     // Usually this is the structure that we expect the base object to have. But, this is the *new*
308     // structure for a transition and we rely on the fact that it has a strong reference to the old
309     // structure. For proxies, this is the structure of the object behind the proxy.
310     WriteBarrier&lt;Structure&gt; m_structure;
311 
312     ObjectPropertyConditionSet m_conditionSet;
313 
314     std::unique_ptr&lt;PolyProtoAccessChain&gt; m_polyProtoAccessChain;
<a name="17" id="anc17"></a><span class="line-added">315 </span>
<span class="line-added">316     CacheableIdentifier m_identifier;</span>
317 };
318 
319 } // namespace JSC
320 
321 #endif
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
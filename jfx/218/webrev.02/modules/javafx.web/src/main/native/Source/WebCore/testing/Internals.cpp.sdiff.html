<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/testing/Internals.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InternalSettings.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Internals.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/testing/Internals.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Internals.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
<span class="line-removed">  31 #include &quot;ActiveDOMCallbackMicrotask.h&quot;</span>
  32 #include &quot;ActivityState.h&quot;
  33 #include &quot;AnimationTimeline.h&quot;
  34 #include &quot;ApplicationCacheStorage.h&quot;
  35 #include &quot;AudioSession.h&quot;
  36 #include &quot;Autofill.h&quot;

  37 #include &quot;BackForwardController.h&quot;
  38 #include &quot;BitmapImage.h&quot;
  39 #include &quot;CSSAnimationController.h&quot;
  40 #include &quot;CSSKeyframesRule.h&quot;
  41 #include &quot;CSSMediaRule.h&quot;

  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSSupportsRule.h&quot;
  44 #include &quot;CacheStorageConnection.h&quot;
  45 #include &quot;CacheStorageProvider.h&quot;
  46 #include &quot;CachedImage.h&quot;
  47 #include &quot;CachedResourceLoader.h&quot;
  48 #include &quot;CertificateInfo.h&quot;
  49 #include &quot;Chrome.h&quot;
  50 #include &quot;ChromeClient.h&quot;
  51 #include &quot;ClientOrigin.h&quot;
  52 #include &quot;ComposedTreeIterator.h&quot;
  53 #include &quot;CookieJar.h&quot;
  54 #include &quot;Cursor.h&quot;
  55 #include &quot;CustomHeaderFields.h&quot;
  56 #include &quot;DOMRect.h&quot;
  57 #include &quot;DOMRectList.h&quot;
  58 #include &quot;DOMStringList.h&quot;
  59 #include &quot;DOMWindow.h&quot;
  60 #include &quot;DeprecatedGlobalSettings.h&quot;
  61 #include &quot;DiagnosticLoggingClient.h&quot;
  62 #include &quot;DisabledAdaptations.h&quot;
  63 #include &quot;DisplayList.h&quot;
  64 #include &quot;Document.h&quot;
  65 #include &quot;DocumentLoader.h&quot;
  66 #include &quot;DocumentMarkerController.h&quot;
  67 #include &quot;DocumentTimeline.h&quot;
  68 #include &quot;Editor.h&quot;
  69 #include &quot;Element.h&quot;
  70 #include &quot;EventHandler.h&quot;
  71 #include &quot;EventListener.h&quot;

  72 #include &quot;EventNames.h&quot;
  73 #include &quot;ExtendableEvent.h&quot;
  74 #include &quot;ExtensionStyleSheets.h&quot;
  75 #include &quot;FetchResponse.h&quot;
  76 #include &quot;File.h&quot;
  77 #include &quot;FontCache.h&quot;
  78 #include &quot;FormController.h&quot;
  79 #include &quot;Frame.h&quot;
  80 #include &quot;FrameLoader.h&quot;

  81 #include &quot;FrameView.h&quot;
  82 #include &quot;FullscreenManager.h&quot;
  83 #include &quot;GCObservation.h&quot;
  84 #include &quot;GridPosition.h&quot;
  85 #include &quot;HEVCUtilities.h&quot;
  86 #include &quot;HTMLAnchorElement.h&quot;
  87 #include &quot;HTMLCanvasElement.h&quot;
  88 #include &quot;HTMLIFrameElement.h&quot;
  89 #include &quot;HTMLImageElement.h&quot;
  90 #include &quot;HTMLInputElement.h&quot;
  91 #include &quot;HTMLLinkElement.h&quot;
  92 #include &quot;HTMLNames.h&quot;
  93 #include &quot;HTMLPictureElement.h&quot;
  94 #include &quot;HTMLPlugInElement.h&quot;
  95 #include &quot;HTMLPreloadScanner.h&quot;
  96 #include &quot;HTMLSelectElement.h&quot;
  97 #include &quot;HTMLTextAreaElement.h&quot;
  98 #include &quot;HTMLVideoElement.h&quot;
  99 #include &quot;HistoryController.h&quot;
 100 #include &quot;HistoryItem.h&quot;
 101 #include &quot;HitTestResult.h&quot;
 102 #include &quot;InspectorClient.h&quot;
 103 #include &quot;InspectorController.h&quot;

 104 #include &quot;InspectorFrontendClientLocal.h&quot;
 105 #include &quot;InspectorOverlay.h&quot;
 106 #include &quot;InstrumentingAgents.h&quot;
 107 #include &quot;IntRect.h&quot;
 108 #include &quot;InternalSettings.h&quot;



 109 #include &quot;JSImageData.h&quot;

 110 #include &quot;LibWebRTCProvider.h&quot;
 111 #include &quot;LoaderStrategy.h&quot;


 112 #include &quot;MallocStatistics.h&quot;
 113 #include &quot;MediaDevices.h&quot;
 114 #include &quot;MediaEngineConfigurationFactory.h&quot;
 115 #include &quot;MediaPlayer.h&quot;
 116 #include &quot;MediaProducer.h&quot;

 117 #include &quot;MediaResourceLoader.h&quot;
 118 #include &quot;MediaStreamTrack.h&quot;
 119 #include &quot;MemoryCache.h&quot;
 120 #include &quot;MemoryInfo.h&quot;

 121 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 122 #include &quot;MockPageOverlay.h&quot;
 123 #include &quot;MockPageOverlayClient.h&quot;
 124 #include &quot;NavigatorMediaDevices.h&quot;
 125 #include &quot;NetworkLoadInformation.h&quot;
 126 #include &quot;Page.h&quot;
<span class="line-removed"> 127 #include &quot;PageCache.h&quot;</span>
 128 #include &quot;PageOverlay.h&quot;
 129 #include &quot;PathUtilities.h&quot;
 130 #include &quot;PlatformKeyboardEvent.h&quot;
 131 #include &quot;PlatformMediaSessionManager.h&quot;
 132 #include &quot;PlatformScreen.h&quot;
 133 #include &quot;PlatformStrategies.h&quot;
 134 #include &quot;PluginData.h&quot;
 135 #include &quot;PrintContext.h&quot;
 136 #include &quot;PseudoElement.h&quot;
 137 #include &quot;Range.h&quot;
 138 #include &quot;ReadableStream.h&quot;
 139 #include &quot;RenderEmbeddedObject.h&quot;
 140 #include &quot;RenderLayerBacking.h&quot;
 141 #include &quot;RenderLayerCompositor.h&quot;
 142 #include &quot;RenderMenuList.h&quot;

 143 #include &quot;RenderTreeAsText.h&quot;
 144 #include &quot;RenderView.h&quot;
 145 #include &quot;RenderedDocumentMarker.h&quot;
 146 #include &quot;ResourceLoadObserver.h&quot;
 147 #include &quot;RuntimeEnabledFeatures.h&quot;
 148 #include &quot;SMILTimeContainer.h&quot;
 149 #include &quot;SVGDocumentExtensions.h&quot;
 150 #include &quot;SVGPathStringBuilder.h&quot;
 151 #include &quot;SVGSVGElement.h&quot;
 152 #include &quot;SWClientConnection.h&quot;
<span class="line-modified"> 153 #include &quot;SchemeRegistry.h&quot;</span>
 154 #include &quot;ScriptedAnimationController.h&quot;
 155 #include &quot;ScrollingCoordinator.h&quot;
 156 #include &quot;ScrollingMomentumCalculator.h&quot;
 157 #include &quot;SecurityOrigin.h&quot;
 158 #include &quot;SerializedScriptValue.h&quot;
 159 #include &quot;ServiceWorker.h&quot;
 160 #include &quot;ServiceWorkerProvider.h&quot;
 161 #include &quot;ServiceWorkerRegistrationData.h&quot;
 162 #include &quot;Settings.h&quot;
 163 #include &quot;ShadowRoot.h&quot;
 164 #include &quot;SourceBuffer.h&quot;
 165 #include &quot;SpellChecker.h&quot;
 166 #include &quot;StaticNodeList.h&quot;


 167 #include &quot;StringCallback.h&quot;

 168 #include &quot;StyleRule.h&quot;
 169 #include &quot;StyleScope.h&quot;
 170 #include &quot;StyleSheetContents.h&quot;
 171 #include &quot;TextIterator.h&quot;
 172 #include &quot;TreeScope.h&quot;
 173 #include &quot;TypeConversions.h&quot;
 174 #include &quot;UserGestureIndicator.h&quot;
 175 #include &quot;UserMediaController.h&quot;
 176 #include &quot;ViewportArguments.h&quot;
 177 #include &quot;VoidCallback.h&quot;
 178 #include &quot;WebCoreJSClientData.h&quot;
 179 #include &quot;WindowProxy.h&quot;
 180 #include &quot;WorkerThread.h&quot;
 181 #include &quot;WorkletGlobalScope.h&quot;
 182 #include &quot;WritingDirection.h&quot;
 183 #include &quot;XMLHttpRequest.h&quot;
 184 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 185 #include &lt;JavaScriptCore/InspectorAgentBase.h&gt;
 186 #include &lt;JavaScriptCore/InspectorFrontendChannel.h&gt;
 187 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 188 #include &lt;JavaScriptCore/JSCJSValue.h&gt;
 189 #include &lt;wtf/HexNumber.h&gt;
 190 #include &lt;wtf/JSONValues.h&gt;
 191 #include &lt;wtf/Language.h&gt;
 192 #include &lt;wtf/MemoryPressureHandler.h&gt;
 193 #include &lt;wtf/MonotonicTime.h&gt;

 194 #include &lt;wtf/URLHelpers.h&gt;
 195 #include &lt;wtf/text/StringBuilder.h&gt;
 196 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 197 
 198 #if USE(CG)
 199 #include &quot;PDFDocumentImage.h&quot;
 200 #endif
 201 
 202 #if ENABLE(INPUT_TYPE_COLOR)
 203 #include &quot;ColorChooser.h&quot;
 204 #endif
 205 
 206 #if ENABLE(MOUSE_CURSOR_SCALE)
 207 #include &lt;wtf/dtoa.h&gt;
 208 #endif
 209 
 210 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 211 #include &quot;LegacyCDM.h&quot;
 212 #include &quot;LegacyMockCDM.h&quot;
 213 #endif
</pre>
<hr />
<pre>
 262 
 263 #if ENABLE(MEDIA_SESSION)
 264 #include &quot;MediaSession.h&quot;
 265 #include &quot;MediaSessionManager.h&quot;
 266 #endif
 267 
 268 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 269 #include &quot;MediaPlaybackTargetContext.h&quot;
 270 #endif
 271 
 272 #if ENABLE(POINTER_LOCK)
 273 #include &quot;PointerLockController.h&quot;
 274 #endif
 275 
 276 #if ENABLE(INDEXED_DATABASE)
 277 #include &quot;IDBRequest.h&quot;
 278 #include &quot;IDBTransaction.h&quot;
 279 #endif
 280 
 281 #if USE(QUICK_LOOK)

 282 #include &quot;MockPreviewLoaderClient.h&quot;
<span class="line-removed"> 283 #include &quot;PreviewLoader.h&quot;</span>
 284 #endif
 285 
 286 #if ENABLE(APPLE_PAY)
 287 #include &quot;MockPaymentCoordinator.h&quot;
 288 #include &quot;PaymentCoordinator.h&quot;
 289 #endif
 290 
 291 #if PLATFORM(MAC) &amp;&amp; USE(LIBWEBRTC)
 292 #include &lt;webrtc/sdk/WebKit/VideoProcessingSoftLink.h&gt;
 293 #endif
 294 
 295 #if PLATFORM(MAC)
<span class="line-modified"> 296 #include &quot;GraphicsContext3DManager.h&quot;</span>





 297 #endif
 298 
 299 using JSC::CallData;
 300 using JSC::CallType;
 301 using JSC::CodeBlock;
 302 using JSC::FunctionExecutable;
 303 using JSC::Identifier;
 304 using JSC::JSFunction;
 305 using JSC::JSGlobalObject;
 306 using JSC::JSObject;
 307 using JSC::JSValue;
 308 using JSC::MarkedArgumentBuffer;
 309 using JSC::PropertySlot;
 310 using JSC::ScriptExecutable;
 311 using JSC::StackVisitor;
 312 
 313 
 314 namespace WebCore {
 315 using namespace Inspector;
 316 
 317 using namespace HTMLNames;
 318 
 319 class InspectorStubFrontend final : public InspectorFrontendClientLocal, public FrontendChannel {
 320 public:
 321     InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow);
 322     virtual ~InspectorStubFrontend();
 323 
 324 private:
 325     void attachWindow(DockSide) final { }
 326     void detachWindow() final { }
 327     void closeWindow() final;
 328     void reopen() final { }
 329     void bringToFront() final { }
<span class="line-modified"> 330     String localizedStringsURL() final { return String(); }</span>





 331     void inspectedURLChanged(const String&amp;) final { }
 332     void showCertificate(const CertificateInfo&amp;) final { }
 333     void setAttachedWindowHeight(unsigned) final { }
 334     void setAttachedWindowWidth(unsigned) final { }
 335     void setSheetRect(const FloatRect&amp;) final { }
 336 
 337     void sendMessageToFrontend(const String&amp; message) final;
 338     ConnectionType connectionType() const final { return ConnectionType::Local; }
 339 
 340     RefPtr&lt;DOMWindow&gt; m_frontendWindow;
 341 };
 342 
 343 InspectorStubFrontend::InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow)
 344     : InspectorFrontendClientLocal(&amp;inspectedPage.inspectorController(), frontendWindow-&gt;document()-&gt;page(), makeUnique&lt;InspectorFrontendClientLocal::Settings&gt;())
 345     , m_frontendWindow(frontendWindow.copyRef())
 346 {
 347     ASSERT_ARG(frontendWindow, frontendWindow);
 348 
 349     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(this);
 350     inspectedPage.inspectorController().connectFrontend(*this);
</pre>
<hr />
<pre>
 468 
 469     WTF::clearDefaultPortForProtocolMapForTesting();
 470     overrideUserPreferredLanguages(Vector&lt;String&gt;());
 471     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(false);
 472     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(false);
 473 #if ENABLE(VIDEO_TRACK)
 474     page.group().captionPreferences().setTestingMode(true);
 475     page.group().captionPreferences().setCaptionsStyleSheetOverride(emptyString());
 476     page.group().captionPreferences().setTestingMode(false);
 477 #endif
 478     if (!page.mainFrame().editor().isContinuousSpellCheckingEnabled())
 479         page.mainFrame().editor().toggleContinuousSpellChecking();
 480     if (page.mainFrame().editor().isOverwriteModeEnabled())
 481         page.mainFrame().editor().toggleOverwriteModeEnabled();
 482     page.mainFrame().loader().clearTestingOverrides();
 483     page.applicationCacheStorage().setDefaultOriginQuota(ApplicationCacheStorage::noQuota());
 484 #if ENABLE(VIDEO)
 485     PlatformMediaSessionManager::sharedManager().resetRestrictions();
 486     PlatformMediaSessionManager::sharedManager().setWillIgnoreSystemInterruptions(true);
 487 #endif

 488     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(false);

 489 #if ENABLE(ACCESSIBILITY)
 490     AXObjectCache::setEnhancedUserInterfaceAccessibility(false);
 491     AXObjectCache::disableAccessibility();
 492 #endif
 493 
 494     MockPageOverlayClient::singleton().uninstallAllOverlays();
 495 
 496 #if ENABLE(CONTENT_FILTERING)
 497     MockContentFilterSettings::reset();
 498 #endif
 499 
 500 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 501     page.setMockMediaPlaybackTargetPickerEnabled(true);
 502     page.setMockMediaPlaybackTargetPickerState(emptyString(), MediaPlaybackTargetContext::Unknown);
 503 #endif
 504 
 505     page.setShowAllPlugins(false);
 506     page.setLowPowerModeEnabledOverrideForTesting(WTF::nullopt);
 507 
 508 #if USE(QUICK_LOOK)
 509     MockPreviewLoaderClient::singleton().setPassword(&quot;&quot;);
<span class="line-modified"> 510     PreviewLoader::setClientForTesting(nullptr);</span>
 511 #endif
 512 
 513     printContextForTesting() = nullptr;
 514 
 515 #if USE(LIBWEBRTC)
 516     auto&amp; rtcProvider = page.libWebRTCProvider();
 517     WebCore::useRealRTCPeerConnectionFactory(rtcProvider);
 518     rtcProvider.disableNonLocalhostConnections();
 519     RuntimeEnabledFeatures::sharedFeatures().setWebRTCVP8CodecEnabled(true);
 520     page.settings().setWebRTCEncryptionEnabled(true);

 521 #endif
 522 
 523     page.settings().setStorageAccessAPIEnabled(false);
 524     page.setFullscreenAutoHideDuration(0_s);
 525     page.setFullscreenInsets({ });
 526     page.setFullscreenControlsHidden(false);
 527 
 528     MediaEngineConfigurationFactory::disableMock();
 529 
 530 #if ENABLE(MEDIA_STREAM)
 531     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(false);


 532 #endif



 533 }
 534 
 535 Internals::Internals(Document&amp; document)
 536     : ContextDestructionObserver(&amp;document)
 537 #if ENABLE(MEDIA_STREAM)
 538     , m_orientationNotifier(0)
 539 #endif
 540 {
 541 #if ENABLE(VIDEO_TRACK)
 542     if (document.page())
 543         document.page()-&gt;group().captionPreferences().setTestingMode(true);
 544 #endif
 545 
 546 #if ENABLE(MEDIA_STREAM)
<span class="line-removed"> 547     setMockMediaCaptureDevicesEnabled(true);</span>
 548     setMediaCaptureRequiresSecureConnection(false);
 549 #endif
 550 
 551 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 552     if (document.page())
 553         document.page()-&gt;setMockMediaPlaybackTargetPickerEnabled(true);
 554 #endif
 555 
 556     if (contextDocument() &amp;&amp; contextDocument()-&gt;frame()) {
 557         setAutomaticSpellingCorrectionEnabled(true);
 558         setAutomaticQuoteSubstitutionEnabled(false);
 559         setAutomaticDashSubstitutionEnabled(false);
 560         setAutomaticLinkDetectionEnabled(false);
 561         setAutomaticTextReplacementEnabled(true);
 562     }
 563 
 564     setConsoleMessageListener(nullptr);
 565 
 566 #if ENABLE(APPLE_PAY)
 567     auto* frame = document.frame();
 568     if (frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;isMainFrame()) {
 569         auto mockPaymentCoordinator = new MockPaymentCoordinator(*frame-&gt;page());
 570         frame-&gt;page()-&gt;setPaymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*mockPaymentCoordinator));
 571     }
 572 #endif




 573 }
 574 
 575 Document* Internals::contextDocument() const
 576 {
 577     return downcast&lt;Document&gt;(scriptExecutionContext());
 578 }
 579 
 580 Frame* Internals::frame() const
 581 {
 582     if (!contextDocument())
 583         return nullptr;
 584     return contextDocument()-&gt;frame();
 585 }
 586 
 587 InternalSettings* Internals::settings() const
 588 {
 589     Document* document = contextDocument();
 590     if (!document)
 591         return nullptr;
 592     Page* page = document-&gt;page();
</pre>
<hr />
<pre>
 687 {
 688     if (response.isNull())
 689         return &quot;Null response&quot;;
 690     switch (response.source()) {
 691     case ResourceResponse::Source::Unknown:
 692         return &quot;Unknown&quot;;
 693     case ResourceResponse::Source::Network:
 694         return &quot;Network&quot;;
 695     case ResourceResponse::Source::ServiceWorker:
 696         return &quot;Service worker&quot;;
 697     case ResourceResponse::Source::DiskCache:
 698         return &quot;Disk cache&quot;;
 699     case ResourceResponse::Source::DiskCacheAfterValidation:
 700         return &quot;Disk cache after validation&quot;;
 701     case ResourceResponse::Source::MemoryCache:
 702         return &quot;Memory cache&quot;;
 703     case ResourceResponse::Source::MemoryCacheAfterValidation:
 704         return &quot;Memory cache after validation&quot;;
 705     case ResourceResponse::Source::ApplicationCache:
 706         return &quot;Application cache&quot;;




 707     }
 708     ASSERT_NOT_REACHED();
 709     return &quot;Error&quot;;
 710 }
 711 
 712 String Internals::xhrResponseSource(XMLHttpRequest&amp; request)
 713 {
 714     return responseSourceToString(request.resourceResponse());
 715 }
 716 
 717 String Internals::fetchResponseSource(FetchResponse&amp; response)
 718 {
 719     return responseSourceToString(response.resourceResponse());
 720 }
 721 
 722 bool Internals::isSharingStyleSheetContents(HTMLLinkElement&amp; a, HTMLLinkElement&amp; b)
 723 {
 724     if (!a.sheet() || !b.sheet())
 725         return false;
 726     return &amp;a.sheet()-&gt;contents() == &amp;b.sheet()-&gt;contents();
</pre>
<hr />
<pre>
 894 #endif
 895 }
 896 
 897 void Internals::setLargeImageAsyncDecodingEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 898 {
 899     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 900         bitmapImage-&gt;setLargeImageAsyncDecodingEnabledForTesting(enabled);
 901 }
 902 
 903 void Internals::setForceUpdateImageDataEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 904 {
 905     if (auto* cachedImage = element.cachedImage())
 906         cachedImage-&gt;setForceUpdateImageDataEnabledForTesting(enabled);
 907 }
 908 
 909 void Internals::setGridMaxTracksLimit(unsigned maxTrackLimit)
 910 {
 911     GridPosition::setMaxPositionForTesting(maxTrackLimit);
 912 }
 913 
<span class="line-modified"> 914 void Internals::clearPageCache()</span>
 915 {
<span class="line-modified"> 916     PageCache::singleton().pruneToSizeNow(0, PruningReason::None);</span>
 917 }
 918 
<span class="line-modified"> 919 unsigned Internals::pageCacheSize() const</span>
 920 {
<span class="line-modified"> 921     return PageCache::singleton().pageCount();</span>






 922 }
 923 
 924 void Internals::disableTileSizeUpdateDelay()
 925 {
 926     Document* document = contextDocument();
 927     if (!document || !document-&gt;frame())
 928         return;
 929 
 930     auto* view = document-&gt;frame()-&gt;view();
 931     if (!view)
 932         return;
 933 
 934     if (auto* backing = view-&gt;tiledBacking())
 935         backing-&gt;setTileSizeUpdateDelayDisabledForTesting(true);
 936 }
 937 
 938 void Internals::setSpeculativeTilingDelayDisabledForTesting(bool disabled)
 939 {
 940     Document* document = contextDocument();
 941     if (!document || !document-&gt;frame())
</pre>
<hr />
<pre>
1363     case WebCore::EventThrottlingBehavior::Unresponsive:
1364         return Internals::EventThrottlingBehavior::Unresponsive;
1365     }
1366 
1367     return WTF::nullopt;
1368 }
1369 
1370 String Internals::visiblePlaceholder(Element&amp; element)
1371 {
1372     if (is&lt;HTMLTextFormControlElement&gt;(element)) {
1373         const HTMLTextFormControlElement&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(element);
1374         if (!textFormControlElement.isPlaceholderVisible())
1375             return String();
1376         if (HTMLElement* placeholderElement = textFormControlElement.placeholderElement())
1377             return placeholderElement-&gt;textContent();
1378     }
1379 
1380     return String();
1381 }
1382 






1383 void Internals::selectColorInColorChooser(HTMLInputElement&amp; element, const String&amp; colorValue)
1384 {
1385     element.selectColor(colorValue);
1386 }
1387 
1388 ExceptionOr&lt;Vector&lt;String&gt;&gt; Internals::formControlStateOfPreviousHistoryItem()
1389 {
1390     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1391     if (!mainItem)
1392         return Exception { InvalidAccessError };
1393     String uniqueName = frame()-&gt;tree().uniqueName();
1394     if (mainItem-&gt;target() != uniqueName &amp;&amp; !mainItem-&gt;childItemWithTarget(uniqueName))
1395         return Exception { InvalidAccessError };
1396     return Vector&lt;String&gt; { mainItem-&gt;target() == uniqueName ? mainItem-&gt;documentState() : mainItem-&gt;childItemWithTarget(uniqueName)-&gt;documentState() };
1397 }
1398 
1399 ExceptionOr&lt;void&gt; Internals::setFormControlStateOfPreviousHistoryItem(const Vector&lt;String&gt;&amp; state)
1400 {
1401     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1402     if (!mainItem)
</pre>
<hr />
<pre>
1422     if (!synthesis)
1423         return;
1424 
1425     synthesis-&gt;setPlatformSynthesizer(makeUnique&lt;PlatformSpeechSynthesizerMock&gt;(synthesis));
1426 }
1427 
1428 #endif
1429 
1430 #if ENABLE(WEB_RTC)
1431 
1432 void Internals::emulateRTCPeerConnectionPlatformEvent(RTCPeerConnection&amp; connection, const String&amp; action)
1433 {
1434     if (!LibWebRTCProvider::webRTCAvailable())
1435         return;
1436 
1437     connection.emulatePlatformEvent(action);
1438 }
1439 
1440 void Internals::useMockRTCPeerConnectionFactory(const String&amp; testCase)
1441 {
<span class="line-removed">1442     ASSERT(RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled());</span>
1443     if (!LibWebRTCProvider::webRTCAvailable())
1444         return;
1445 
1446 #if USE(LIBWEBRTC)
1447     Document* document = contextDocument();
1448     LibWebRTCProvider* provider = (document &amp;&amp; document-&gt;page()) ? &amp;document-&gt;page()-&gt;libWebRTCProvider() : nullptr;
1449     WebCore::useMockRTCPeerConnectionFactory(provider, testCase);
1450 #else
1451     UNUSED_PARAM(testCase);
1452 #endif
1453 }
1454 
1455 void Internals::setICECandidateFiltering(bool enabled)
1456 {
1457     auto* page = contextDocument()-&gt;page();
1458     if (!page)
1459         return;
1460 
1461     auto&amp; rtcController = page-&gt;rtcController();
1462     if (enabled)
</pre>
<hr />
<pre>
1491 void Internals::clearPeerConnectionFactory()
1492 {
1493 #if USE(LIBWEBRTC)
1494     if (auto* page = contextDocument()-&gt;page())
1495         page-&gt;libWebRTCProvider().clearFactory();
1496 #endif
1497 }
1498 
1499 void Internals::applyRotationForOutgoingVideoSources(RTCPeerConnection&amp; connection)
1500 {
1501     connection.applyRotationForOutgoingVideoSources();
1502 }
1503 
1504 void Internals::setEnableWebRTCEncryption(bool value)
1505 {
1506 #if USE(LIBWEBRTC)
1507     if (auto* page = contextDocument()-&gt;page())
1508         page-&gt;settings().setWebRTCEncryptionEnabled(value);
1509 #endif
1510 }








1511 #endif

1512 
<span class="line-modified">1513 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-removed">1514 void Internals::setShouldInterruptAudioOnPageVisibilityChange(bool shouldInterrupt)</span>
1515 {
<span class="line-modified">1516     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(shouldInterrupt);</span>







1517 }

1518 
<span class="line-modified">1519 void Internals::setMockMediaCaptureDevicesEnabled(bool enabled)</span>

1520 {
<span class="line-modified">1521     Document* document = contextDocument();</span>
<span class="line-removed">1522     if (auto* page = document-&gt;page())</span>
<span class="line-removed">1523         page-&gt;settings().setMockCaptureDevicesEnabled(enabled);</span>
1524 }
1525 
1526 void Internals::setMediaCaptureRequiresSecureConnection(bool enabled)
1527 {
1528     Document* document = contextDocument();
1529     if (auto* page = document-&gt;page())
1530         page-&gt;settings().setMediaCaptureRequiresSecureConnection(enabled);
1531 }
1532 
1533 static std::unique_ptr&lt;MediaRecorderPrivate&gt; createRecorderMockSource()
1534 {
1535     return std::unique_ptr&lt;MediaRecorderPrivateMock&gt;(new MediaRecorderPrivateMock);
1536 }
1537 
1538 void Internals::setCustomPrivateRecorderCreator()
1539 {
1540     WebCore::MediaRecorder::setCustomPrivateRecorderCreator(createRecorderMockSource);
1541 }
1542 
1543 #endif
</pre>
<hr />
<pre>
1620 ExceptionOr&lt;String&gt; Internals::markerDescriptionForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1621 {
1622     auto result = markerAt(node, markerType, index);
1623     if (result.hasException())
1624         return result.releaseException();
1625     auto marker = result.releaseReturnValue();
1626     if (!marker)
1627         return String();
1628     return String { marker-&gt;description() };
1629 }
1630 
1631 ExceptionOr&lt;String&gt; Internals::dumpMarkerRects(const String&amp; markerTypeString)
1632 {
1633     DocumentMarker::MarkerType markerType;
1634     if (!markerTypeFrom(markerTypeString, markerType))
1635         return Exception { SyntaxError };
1636 
1637     contextDocument()-&gt;markers().updateRectsForInvalidatedMarkersOfType(markerType);
1638     auto rects = contextDocument()-&gt;markers().renderedRectsForMarkers(markerType);
1639 

1640     StringBuilder rectString;
1641     rectString.appendLiteral(&quot;marker rects: &quot;);
<span class="line-modified">1642     for (const auto&amp; rect : rects) {</span>
<span class="line-modified">1643         rectString.append(&#39;(&#39;);</span>
<span class="line-removed">1644         rectString.appendFixedPrecisionNumber(rect.x());</span>
<span class="line-removed">1645         rectString.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed">1646         rectString.appendFixedPrecisionNumber(rect.y());</span>
<span class="line-removed">1647         rectString.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed">1648         rectString.appendFixedPrecisionNumber(rect.width());</span>
<span class="line-removed">1649         rectString.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed">1650         rectString.appendFixedPrecisionNumber(rect.height());</span>
<span class="line-removed">1651         rectString.appendLiteral(&quot;) &quot;);</span>
<span class="line-removed">1652     }</span>
1653     return rectString.toString();
1654 }
1655 
1656 void Internals::addTextMatchMarker(const Range&amp; range, bool isActive)
1657 {
1658     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1659     range.ownerDocument().markers().addTextMatchMarker(range, isActive);
1660 }
1661 
1662 ExceptionOr&lt;void&gt; Internals::setMarkedTextMatchesAreHighlighted(bool flag)
1663 {
1664     Document* document = contextDocument();
1665     if (!document || !document-&gt;frame())
1666         return Exception { InvalidAccessError };
1667     document-&gt;frame()-&gt;editor().setMarkedTextMatchesAreHighlighted(flag);
1668     return { };
1669 }
1670 
1671 void Internals::invalidateFontCache()
1672 {
</pre>
<hr />
<pre>
1700     auto&amp; frameView = *document-&gt;view();
1701     bool constrainsScrollingToContentEdgeOldValue = frameView.constrainsScrollingToContentEdge();
1702     bool scrollbarsSuppressedOldValue = frameView.scrollbarsSuppressed();
1703 
1704     frameView.setConstrainsScrollingToContentEdge(false);
1705     frameView.setScrollbarsSuppressed(false);
1706     frameView.setScrollOffsetFromInternals({ x, y });
1707     frameView.setScrollbarsSuppressed(scrollbarsSuppressedOldValue);
1708     frameView.setConstrainsScrollingToContentEdge(constrainsScrollingToContentEdgeOldValue);
1709 
1710     return { };
1711 }
1712 
1713 ExceptionOr&lt;void&gt; Internals::unconstrainedScrollTo(Element&amp; element, double x, double y)
1714 {
1715     Document* document = contextDocument();
1716     if (!document || !document-&gt;view())
1717         return Exception { InvalidAccessError };
1718 
1719     element.scrollTo({ x, y }, ScrollClamping::Unclamped);




1720     return { };
1721 }
1722 
1723 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::layoutViewportRect()
1724 {
1725     Document* document = contextDocument();
1726     if (!document || !document-&gt;frame())
1727         return Exception { InvalidAccessError };
1728 
1729     document-&gt;updateLayoutIgnorePendingStylesheets();
1730 
1731     auto&amp; frameView = *document-&gt;view();
1732     return DOMRect::create(frameView.layoutViewportRect());
1733 }
1734 
1735 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::visualViewportRect()
1736 {
1737     Document* document = contextDocument();
1738     if (!document || !document-&gt;frame())
1739         return Exception { InvalidAccessError };
</pre>
<hr />
<pre>
1813     Document* document = contextDocument();
1814     if (!document || !document-&gt;page())
1815         return Exception { InvalidAccessError };
1816     document-&gt;page()-&gt;setPaginationLineGridEnabled(enabled);
1817     return { };
1818 }
1819 
1820 ExceptionOr&lt;String&gt; Internals::configurationForViewport(float devicePixelRatio, int deviceWidth, int deviceHeight, int availableWidth, int availableHeight)
1821 {
1822     Document* document = contextDocument();
1823     if (!document || !document-&gt;page())
1824         return Exception { InvalidAccessError };
1825 
1826     const int defaultLayoutWidthForNonMobilePages = 980;
1827 
1828     ViewportArguments arguments = document-&gt;page()-&gt;viewportArguments();
1829     ViewportAttributes attributes = computeViewportAttributes(arguments, defaultLayoutWidthForNonMobilePages, deviceWidth, deviceHeight, devicePixelRatio, IntSize(availableWidth, availableHeight));
1830     restrictMinimumScaleFactorToViewportSize(attributes, IntSize(availableWidth, availableHeight), devicePixelRatio);
1831     restrictScaleFactorToInitialScaleIfNotUserScalable(attributes);
1832 

1833     return makeString(&quot;viewport size &quot;, FormattedNumber::fixedPrecision(attributes.layoutSize.width()), &#39;x&#39;, FormattedNumber::fixedPrecision(attributes.layoutSize.height()), &quot; scale &quot;, FormattedNumber::fixedPrecision(attributes.initialScale), &quot; with limits [&quot;, FormattedNumber::fixedPrecision(attributes.minimumScale), &quot;, &quot;, FormattedNumber::fixedPrecision(attributes.maximumScale), &quot;] and userScalable &quot;, (attributes.userScalable ? &quot;true&quot; : &quot;false&quot;));
1834 }
1835 
1836 ExceptionOr&lt;bool&gt; Internals::wasLastChangeUserEdit(Element&amp; textField)
1837 {
1838     if (is&lt;HTMLInputElement&gt;(textField))
1839         return downcast&lt;HTMLInputElement&gt;(textField).lastChangeWasUserEdit();
1840 
1841     if (is&lt;HTMLTextAreaElement&gt;(textField))
1842         return downcast&lt;HTMLTextAreaElement&gt;(textField).lastChangeWasUserEdit();
1843 
1844     return Exception { InvalidNodeTypeError };
1845 }
1846 
1847 bool Internals::elementShouldAutoComplete(HTMLInputElement&amp; element)
1848 {
1849     return element.shouldAutocomplete();
1850 }
1851 
1852 void Internals::setAutofilled(HTMLInputElement&amp; element, bool enabled)
</pre>
<hr />
<pre>
2140     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
2141     {
2142         ++m_iterations;
2143         if (m_iterations &lt; 2)
2144             return StackVisitor::Continue;
2145 
2146         m_codeBlock = visitor-&gt;codeBlock();
2147         return StackVisitor::Done;
2148     }
2149 
2150     CodeBlock* codeBlock() const { return m_codeBlock; }
2151 
2152 private:
2153     mutable int m_iterations;
2154     mutable CodeBlock* m_codeBlock;
2155 };
2156 
2157 String Internals::parserMetaData(JSC::JSValue code)
2158 {
2159     JSC::VM&amp; vm = contextDocument()-&gt;vm();
<span class="line-modified">2160     JSC::ExecState* exec = vm.topCallFrame;</span>

2161     ScriptExecutable* executable;
2162 
2163     if (!code || code.isNull() || code.isUndefined()) {
2164         GetCallerCodeBlockFunctor iter;
<span class="line-modified">2165         exec-&gt;iterate(iter);</span>
2166         CodeBlock* codeBlock = iter.codeBlock();
2167         executable = codeBlock-&gt;ownerExecutable();
2168     } else if (code.isFunction(vm)) {
<span class="line-modified">2169         JSFunction* funcObj = JSC::jsCast&lt;JSFunction*&gt;(code.toObject(exec));</span>
2170         executable = funcObj-&gt;jsExecutable();
2171     } else
2172         return String();
2173 
2174     unsigned startLine = executable-&gt;firstLine();
2175     unsigned startColumn = executable-&gt;startColumn();
2176     unsigned endLine = executable-&gt;lastLine();
2177     unsigned endColumn = executable-&gt;endColumn();
2178 
2179     StringBuilder result;
2180 
2181     if (executable-&gt;isFunctionExecutable()) {
2182         FunctionExecutable* funcExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
2183         String inferredName = funcExecutable-&gt;ecmaName().string();
2184         result.appendLiteral(&quot;function \&quot;&quot;);
2185         result.append(inferredName);
2186         result.append(&#39;&quot;&#39;);
2187     } else if (executable-&gt;isEvalExecutable())
2188         result.appendLiteral(&quot;eval&quot;);
2189     else if (executable-&gt;isModuleProgramExecutable())
</pre>
<hr />
<pre>
2412     bool mark = markMatches == &quot;mark&quot;;
2413     return document-&gt;frame()-&gt;editor().countMatchesForText(text, nullptr, parsedOptions.releaseReturnValue(), 1000, mark, nullptr);
2414 }
2415 
2416 ExceptionOr&lt;unsigned&gt; Internals::countFindMatches(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions)
2417 {
2418     Document* document = contextDocument();
2419     if (!document || !document-&gt;page())
2420         return Exception { InvalidAccessError };
2421 
2422     auto parsedOptions = parseFindOptions(findOptions);
2423     if (parsedOptions.hasException())
2424         return parsedOptions.releaseException();
2425 
2426     return document-&gt;page()-&gt;countFindMatches(text, parsedOptions.releaseReturnValue(), 1000);
2427 }
2428 
2429 #if ENABLE(INDEXED_DATABASE)
2430 unsigned Internals::numberOfIDBTransactions() const
2431 {

2432     return IDBTransaction::numberOfIDBTransactions;



2433 }
2434 #endif
2435 
2436 unsigned Internals::numberOfLiveNodes() const
2437 {
2438     unsigned nodeCount = 0;
2439     for (auto* document : Document::allDocuments())
2440         nodeCount += document-&gt;referencingNodeCount();
2441     return nodeCount;
2442 }
2443 
2444 unsigned Internals::numberOfLiveDocuments() const
2445 {
2446     return Document::allDocuments().size();
2447 }
2448 
2449 unsigned Internals::referencingNodeCount(const Document&amp; document) const
2450 {
2451     return document.referencingNodeCount();
2452 }
2453 
2454 #if ENABLE(INTERSECTION_OBSERVER)
2455 unsigned Internals::numberOfIntersectionObservers(const Document&amp; document) const
2456 {
2457     return document.numberOfIntersectionObservers();
2458 }
2459 #endif
2460 
2461 uint64_t Internals::documentIdentifier(const Document&amp; document) const
2462 {
2463     return document.identifier().toUInt64();
2464 }
2465 
2466 bool Internals::isDocumentAlive(uint64_t documentIdentifier) const
2467 {
2468     return Document::allDocumentsMap().contains(makeObjectIdentifier&lt;DocumentIdentifierType&gt;(documentIdentifier));
2469 }
2470 


























2471 bool Internals::isAnyWorkletGlobalScopeAlive() const
2472 {
2473 #if ENABLE(CSS_PAINTING_API)
2474     return !WorkletGlobalScope::allWorkletGlobalScopesSet().isEmpty();
2475 #else
2476     return false;
2477 #endif
2478 }
2479 
2480 String Internals::serviceWorkerClientIdentifier(const Document&amp; document) const
2481 {
2482 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">2483     return ServiceWorkerClientIdentifier { ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(document.sessionID()).serverConnectionIdentifier(), document.identifier() }.toString();</span>
2484 #else
2485     UNUSED_PARAM(document);
2486     return String();
2487 #endif
2488 }
2489 
2490 RefPtr&lt;WindowProxy&gt; Internals::openDummyInspectorFrontend(const String&amp; url)
2491 {
2492     auto* inspectedPage = contextDocument()-&gt;frame()-&gt;page();
2493     auto* window = inspectedPage-&gt;mainFrame().document()-&gt;domWindow();
2494     auto frontendWindowProxy = window-&gt;open(*window, *window, url, &quot;&quot;, &quot;&quot;).releaseReturnValue();
2495     m_inspectorFrontend = makeUnique&lt;InspectorStubFrontend&gt;(*inspectedPage, downcast&lt;DOMWindow&gt;(frontendWindowProxy-&gt;window()));
2496     return frontendWindowProxy;
2497 }
2498 
2499 void Internals::closeDummyInspectorFrontend()
2500 {
2501     m_inspectorFrontend = nullptr;
2502 }
2503 
</pre>
<hr />
<pre>
2554     if (flags &amp; Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS)
2555         layerTreeFlags |= LayerTreeFlagsIncludeVisibleRects;
2556     if (flags &amp; Internals::LAYER_TREE_INCLUDES_TILE_CACHES)
2557         layerTreeFlags |= LayerTreeFlagsIncludeTileCaches;
2558     if (flags &amp; Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS)
2559         layerTreeFlags |= LayerTreeFlagsIncludeRepaintRects;
2560     if (flags &amp; Internals::LAYER_TREE_INCLUDES_PAINTING_PHASES)
2561         layerTreeFlags |= LayerTreeFlagsIncludePaintingPhases;
2562     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CONTENT_LAYERS)
2563         layerTreeFlags |= LayerTreeFlagsIncludeContentLayers;
2564     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ACCELERATES_DRAWING)
2565         layerTreeFlags |= LayerTreeFlagsIncludeAcceleratesDrawing;
2566     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CLIPPING)
2567         layerTreeFlags |= LayerTreeFlagsIncludeClipping;
2568     if (flags &amp; Internals::LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED)
2569         layerTreeFlags |= LayerTreeFlagsIncludeBackingStoreAttached;
2570     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES)
2571         layerTreeFlags |= LayerTreeFlagsIncludeRootLayerProperties;
2572     if (flags &amp; Internals::LAYER_TREE_INCLUDES_EVENT_REGION)
2573         layerTreeFlags |= LayerTreeFlagsIncludeEventRegion;


2574 
2575     return layerTreeFlags;
2576 }
2577 
2578 // FIXME: Remove the document argument. It is almost always the same as
2579 // contextDocument(), with the exception of a few tests that pass a
2580 // different document, and could just make the call through another Internals
2581 // instance instead.
2582 ExceptionOr&lt;String&gt; Internals::layerTreeAsText(Document&amp; document, unsigned short flags) const
2583 {
2584     if (!document.frame())
2585         return Exception { InvalidAccessError };
2586 
2587     document.updateLayoutIgnorePendingStylesheets();
2588     return document.frame()-&gt;layerTreeAsText(toLayerTreeFlags(flags));
2589 }
2590 
2591 ExceptionOr&lt;uint64_t&gt; Internals::layerIDForElement(Element&amp; element)
2592 {
2593     Document* document = contextDocument();
</pre>
<hr />
<pre>
3104 }
3105 
3106 void Internals::setFullscreenControlsHidden(bool hidden)
3107 {
3108     Page* page = contextDocument()-&gt;frame()-&gt;page();
3109     ASSERT(page);
3110 
3111     page-&gt;setFullscreenControlsHidden(hidden);
3112 }
3113 
3114 void Internals::setApplicationCacheOriginQuota(unsigned long long quota)
3115 {
3116     Document* document = contextDocument();
3117     if (!document || !document-&gt;page())
3118         return;
3119     document-&gt;page()-&gt;applicationCacheStorage().storeUpdatedQuotaForOrigin(&amp;document-&gt;securityOrigin(), quota);
3120 }
3121 
3122 void Internals::registerURLSchemeAsBypassingContentSecurityPolicy(const String&amp; scheme)
3123 {
<span class="line-modified">3124     SchemeRegistry::registerURLSchemeAsBypassingContentSecurityPolicy(scheme);</span>
3125 }
3126 
3127 void Internals::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(const String&amp; scheme)
3128 {
<span class="line-modified">3129     SchemeRegistry::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);</span>
3130 }
3131 
3132 void Internals::registerDefaultPortForProtocol(unsigned short port, const String&amp; protocol)
3133 {
3134     registerDefaultPortForProtocolForTesting(port, protocol);
3135 }
3136 
3137 Ref&lt;MallocStatistics&gt; Internals::mallocStatistics() const
3138 {
3139     return MallocStatistics::create();
3140 }
3141 
3142 Ref&lt;TypeConversions&gt; Internals::typeConversions() const
3143 {
3144     return TypeConversions::create();
3145 }
3146 
3147 Ref&lt;MemoryInfo&gt; Internals::memoryInfo() const
3148 {
3149     return MemoryInfo::create();
</pre>
<hr />
<pre>
3355     case Cursor::Grab: return &quot;Grab&quot;;
3356     case Cursor::Grabbing: return &quot;Grabbing&quot;;
3357     case Cursor::Custom: return &quot;Custom&quot;;
3358     }
3359 
3360     ASSERT_NOT_REACHED();
3361     return &quot;UNKNOWN&quot;;
3362 }
3363 #endif
3364 
3365 ExceptionOr&lt;String&gt; Internals::getCurrentCursorInfo()
3366 {
3367     Document* document = contextDocument();
3368     if (!document || !document-&gt;frame())
3369         return Exception { InvalidAccessError };
3370 
3371 #if !PLATFORM(IOS_FAMILY)
3372     Cursor cursor = document-&gt;frame()-&gt;eventHandler().currentMouseCursor();
3373 
3374     StringBuilder result;
<span class="line-modified">3375     result.appendLiteral(&quot;type=&quot;);</span>
<span class="line-removed">3376     result.append(cursorTypeToString(cursor.type()));</span>
<span class="line-removed">3377     result.appendLiteral(&quot; hotSpot=&quot;);</span>
<span class="line-removed">3378     result.appendNumber(cursor.hotSpot().x());</span>
<span class="line-removed">3379     result.append(&#39;,&#39;);</span>
<span class="line-removed">3380     result.appendNumber(cursor.hotSpot().y());</span>
3381     if (cursor.image()) {
3382         FloatSize size = cursor.image()-&gt;size();
<span class="line-modified">3383         result.appendLiteral(&quot; image=&quot;);</span>
<span class="line-removed">3384         result.appendFixedPrecisionNumber(size.width());</span>
<span class="line-removed">3385         result.append(&#39;x&#39;);</span>
<span class="line-removed">3386         result.appendFixedPrecisionNumber(size.height());</span>
3387     }
3388 #if ENABLE(MOUSE_CURSOR_SCALE)
<span class="line-modified">3389     if (cursor.imageScaleFactor() != 1) {</span>
<span class="line-modified">3390         result.appendLiteral(&quot; scale=&quot;);</span>
<span class="line-removed">3391         result.appendFixedPrecisionNumber(cursor.imageScaleFactor(), 8);</span>
<span class="line-removed">3392     }</span>
3393 #endif
3394     return result.toString();
3395 #else
3396     return &quot;FAIL: Cursor details not available on this platform.&quot;_str;
3397 #endif
3398 }
3399 
3400 Ref&lt;ArrayBuffer&gt; Internals::serializeObject(const RefPtr&lt;SerializedScriptValue&gt;&amp; value) const
3401 {
3402     auto&amp; bytes = value-&gt;data();
3403     return ArrayBuffer::create(bytes.data(), bytes.size());
3404 }
3405 
3406 Ref&lt;SerializedScriptValue&gt; Internals::deserializeBuffer(ArrayBuffer&amp; buffer) const
3407 {
3408     Vector&lt;uint8_t&gt; bytes;
3409     bytes.append(static_cast&lt;const uint8_t*&gt;(buffer.data()), buffer.byteLength());
3410     return SerializedScriptValue::adopt(WTFMove(bytes));
3411 }
3412 
3413 bool Internals::isFromCurrentWorld(JSC::JSValue value) const
3414 {
<span class="line-modified">3415     return isWorldCompatible(*contextDocument()-&gt;vm().topCallFrame, value);</span>









3416 }
3417 
3418 void Internals::setUsesOverlayScrollbars(bool enabled)
3419 {
3420     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(enabled);
3421 }
3422 
3423 void Internals::setUsesMockScrollAnimator(bool enabled)
3424 {
3425     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(enabled);
3426 }
3427 
3428 void Internals::forceReload(bool endToEnd)
3429 {
3430     OptionSet&lt;ReloadOption&gt; reloadOptions;
3431     if (endToEnd)
3432         reloadOptions.add(ReloadOption::FromOrigin);
3433 
3434     frame()-&gt;loader().reload(reloadOptions);
3435 }
</pre>
<hr />
<pre>
4002 
4003 void Internals::sendMediaControlEvent(MediaControlEvent event)
4004 {
4005     // FIXME: No good reason to use a single function with an argument instead of three functions.
4006     switch (event) {
4007     case MediControlEvent::PlayPause:
4008         MediaSessionManager::singleton().togglePlayback();
4009         break;
4010     case MediControlEvent::NextTrack:
4011         MediaSessionManager::singleton().skipToNextTrack();
4012         break;
4013     case MediControlEvent::PreviousTrack:
4014         MediaSessionManager::singleton().skipToPreviousTrack();
4015         break;
4016     }
4017 }
4018 
4019 #endif // ENABLE(MEDIA_SESSION)
4020 
4021 #if ENABLE(WEB_AUDIO)
<span class="line-removed">4022 </span>
4023 void Internals::setAudioContextRestrictions(AudioContext&amp; context, StringView restrictionsString)
4024 {
4025     AudioContext::BehaviorRestrictions restrictions = context.behaviorRestrictions();
4026     context.removeBehaviorRestriction(restrictions);
4027 
4028     restrictions = AudioContext::NoRestrictions;
4029 
4030     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
4031         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
4032             restrictions |= AudioContext::NoRestrictions;
4033         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudiostart&quot;))
4034             restrictions |= AudioContext::RequireUserGestureForAudioStartRestriction;
4035         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsentforaudiostart&quot;))
4036             restrictions |= AudioContext::RequirePageConsentForAudioStartRestriction;
4037     }
4038     context.addBehaviorRestriction(restrictions);
4039 }
4040 






4041 #endif
4042 
4043 void Internals::simulateSystemSleep() const
4044 {
4045 #if ENABLE(VIDEO)
4046     PlatformMediaSessionManager::sharedManager().systemWillSleep();
4047 #endif
4048 }
4049 
4050 void Internals::simulateSystemWake() const
4051 {
4052 #if ENABLE(VIDEO)
4053     PlatformMediaSessionManager::sharedManager().systemDidWake();
4054 #endif
4055 }
4056 
4057 ExceptionOr&lt;Internals::NowPlayingState&gt; Internals::nowPlayingState() const
4058 {
4059 #if ENABLE(VIDEO)
4060     return { { PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingTitle(),
</pre>
<hr />
<pre>
4094 ExceptionOr&lt;void&gt; Internals::setMockMediaPlaybackTargetPickerState(const String&amp; deviceName, const String&amp; deviceState)
4095 {
4096     Page* page = contextDocument()-&gt;frame()-&gt;page();
4097     ASSERT(page);
4098 
4099     MediaPlaybackTargetContext::State state = MediaPlaybackTargetContext::Unknown;
4100 
4101     if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceavailable&quot;))
4102         state = MediaPlaybackTargetContext::OutputDeviceAvailable;
4103     else if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceunavailable&quot;))
4104         state = MediaPlaybackTargetContext::OutputDeviceUnavailable;
4105     else if (equalLettersIgnoringASCIICase(deviceState, &quot;unknown&quot;))
4106         state = MediaPlaybackTargetContext::Unknown;
4107     else
4108         return Exception { InvalidAccessError };
4109 
4110     page-&gt;setMockMediaPlaybackTargetPickerState(deviceName, state);
4111     return { };
4112 }
4113 








4114 #endif
4115 
4116 ExceptionOr&lt;Ref&lt;MockPageOverlay&gt;&gt; Internals::installMockPageOverlay(PageOverlayType type)
4117 {
4118     Document* document = contextDocument();
4119     if (!document || !document-&gt;page())
4120         return Exception { InvalidAccessError };
4121 
4122     return MockPageOverlayClient::singleton().installOverlay(*document-&gt;page(), type == PageOverlayType::View ? PageOverlay::OverlayType::View : PageOverlay::OverlayType::Document);
4123 }
4124 
4125 ExceptionOr&lt;String&gt; Internals::pageOverlayLayerTreeAsText(unsigned short flags) const
4126 {
4127     Document* document = contextDocument();
4128     if (!document || !document-&gt;page())
4129         return Exception { InvalidAccessError };
4130 
4131     document-&gt;updateLayoutIgnorePendingStylesheets();
4132 
4133     return MockPageOverlayClient::singleton().layerTreeAsText(*document-&gt;page(), toLayerTreeFlags(flags));
</pre>
<hr />
<pre>
4218 }
4219 
4220 ExceptionOr&lt;bool&gt; Internals::pageDefersLoading()
4221 {
4222     Document* document = contextDocument();
4223     if (!document || !document-&gt;page())
4224         return Exception { InvalidAccessError };
4225     return document-&gt;page()-&gt;defersLoading();
4226 }
4227 
4228 RefPtr&lt;File&gt; Internals::createFile(const String&amp; path)
4229 {
4230     Document* document = contextDocument();
4231     if (!document)
4232         return nullptr;
4233 
4234     URL url = document-&gt;completeURL(path);
4235     if (!url.isLocalFile())
4236         return nullptr;
4237 
<span class="line-modified">4238     return File::create(document-&gt;sessionID(), url.fileSystemPath());</span>
4239 }
4240 
4241 void Internals::queueMicroTask(int testNumber)
4242 {
4243     Document* document = contextDocument();
4244     if (!document)
4245         return;
4246 
<span class="line-modified">4247     auto microtask = makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(MicrotaskQueue::mainThreadQueue(), *document, [document, testNumber]() {</span>


4248         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Debug, makeString(&quot;MicroTask #&quot;, testNumber, &quot; has run.&quot;));
4249     });
<span class="line-removed">4250 </span>
<span class="line-removed">4251     MicrotaskQueue::mainThreadQueue().append(WTFMove(microtask));</span>
4252 }
4253 
4254 #if ENABLE(CONTENT_FILTERING)
4255 
4256 MockContentFilterSettings&amp; Internals::mockContentFilterSettings()
4257 {
4258     return MockContentFilterSettings::singleton();
4259 }
4260 
4261 #endif
4262 
4263 #if ENABLE(CSS_SCROLL_SNAP)
4264 
4265 static void appendOffsets(StringBuilder&amp; builder, const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
4266 {
4267     bool justStarting = true;
4268 
4269     builder.appendLiteral(&quot;{ &quot;);
4270     for (auto&amp; coordinate : snapOffsets) {
4271         if (!justStarting)
</pre>
<hr />
<pre>
4332 
4333 #endif
4334 
4335 bool Internals::testPreloaderSettingViewport()
4336 {
4337     return testPreloadScannerViewportSupport(contextDocument());
4338 }
4339 
4340 ExceptionOr&lt;String&gt; Internals::pathStringWithShrinkWrappedRects(const Vector&lt;double&gt;&amp; rectComponents, double radius)
4341 {
4342     if (rectComponents.size() % 4)
4343         return Exception { InvalidAccessError };
4344 
4345     Vector&lt;FloatRect&gt; rects;
4346     for (unsigned i = 0; i &lt; rectComponents.size(); i += 4)
4347         rects.append(FloatRect(rectComponents[i], rectComponents[i + 1], rectComponents[i + 2], rectComponents[i + 3]));
4348 
4349     SVGPathStringBuilder builder;
4350     PathUtilities::pathWithShrinkWrappedRects(rects, radius).apply([&amp;builder](const PathElement&amp; element) {
4351         switch (element.type) {
<span class="line-modified">4352         case PathElementMoveToPoint:</span>
4353             builder.moveTo(element.points[0], false, AbsoluteCoordinates);
4354             return;
<span class="line-modified">4355         case PathElementAddLineToPoint:</span>
4356             builder.lineTo(element.points[0], AbsoluteCoordinates);
4357             return;
<span class="line-modified">4358         case PathElementAddQuadCurveToPoint:</span>
4359             builder.curveToQuadratic(element.points[0], element.points[1], AbsoluteCoordinates);
4360             return;
<span class="line-modified">4361         case PathElementAddCurveToPoint:</span>
4362             builder.curveToCubic(element.points[0], element.points[1], element.points[2], AbsoluteCoordinates);
4363             return;
<span class="line-modified">4364         case PathElementCloseSubpath:</span>
4365             builder.closePath();
4366             return;
4367         }
4368         ASSERT_NOT_REACHED();
4369     });
4370     return builder.result();
4371 }
4372 
4373 
4374 String Internals::getCurrentMediaControlsStatusForElement(HTMLMediaElement&amp; mediaElement)
4375 {
4376 #if !ENABLE(MEDIA_CONTROLS_SCRIPT)
4377     UNUSED_PARAM(mediaElement);
4378     return String();
4379 #else
4380     return mediaElement.getCurrentMediaControlsStatus();
4381 #endif
4382 }
4383 
4384 #if !PLATFORM(COCOA)
</pre>
<hr />
<pre>
4388     return WTF::URLHelpers::userVisibleURL(url.href().string().utf8());
4389 }
4390 
4391 #endif
4392 
4393 void Internals::setShowAllPlugins(bool show)
4394 {
4395     Document* document = contextDocument();
4396     if (!document)
4397         return;
4398 
4399     Page* page = document-&gt;page();
4400     if (!page)
4401         return;
4402 
4403     page-&gt;setShowAllPlugins(show);
4404 }
4405 
4406 #if ENABLE(STREAMS_API)
4407 
<span class="line-modified">4408 bool Internals::isReadableStreamDisturbed(JSC::ExecState&amp; state, JSValue stream)</span>
4409 {
<span class="line-modified">4410     return ReadableStream::isDisturbed(state, stream);</span>
4411 }
4412 
<span class="line-modified">4413 JSValue Internals::cloneArrayBuffer(JSC::ExecState&amp; state, JSValue buffer, JSValue srcByteOffset, JSValue srcLength)</span>
4414 {
<span class="line-modified">4415     JSC::VM&amp; vm = state.vm();</span>
<span class="line-removed">4416     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(&amp;state);</span>
4417     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
4418     const Identifier&amp; privateName = clientData-&gt;builtinNames().cloneArrayBufferPrivateName();
4419     JSValue value;
4420     PropertySlot propertySlot(value, PropertySlot::InternalMethodType::Get);
<span class="line-modified">4421     globalObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(globalObject, &amp;state, privateName, propertySlot);</span>
<span class="line-modified">4422     value = propertySlot.getValue(&amp;state, privateName);</span>
4423     ASSERT(value.isFunction(vm));
4424 
4425     JSObject* function = value.getObject();
4426     CallData callData;
4427     CallType callType = JSC::getCallData(vm, function, callData);
4428     ASSERT(callType != JSC::CallType::None);
4429     MarkedArgumentBuffer arguments;
4430     arguments.append(buffer);
4431     arguments.append(srcByteOffset);
4432     arguments.append(srcLength);
4433     ASSERT(!arguments.hasOverflowed());
4434 
<span class="line-modified">4435     return JSC::call(&amp;state, function, callType, callData, JSC::jsUndefined(), arguments);</span>
4436 }
4437 
4438 #endif
4439 
4440 String Internals::resourceLoadStatisticsForURL(const DOMURL&amp; url)
4441 {
<span class="line-modified">4442     auto* document = contextDocument();</span>
<span class="line-removed">4443     if (!document)</span>
<span class="line-removed">4444         return emptyString();</span>
<span class="line-removed">4445 </span>
<span class="line-removed">4446     return ResourceLoadObserver::shared().statisticsForURL(document-&gt;sessionID(), url.href());</span>
4447 }
4448 
4449 void Internals::setResourceLoadStatisticsEnabled(bool enable)
4450 {
4451     DeprecatedGlobalSettings::setResourceLoadStatisticsEnabled(enable);
4452 }
4453 
4454 String Internals::composedTreeAsText(Node&amp; node)
4455 {
4456     if (!is&lt;ContainerNode&gt;(node))
4457         return emptyString();
4458     return WebCore::composedTreeAsText(downcast&lt;ContainerNode&gt;(node));
4459 }
4460 
4461 bool Internals::isProcessingUserGesture()
4462 {
4463     return UserGestureIndicator::processingUserGesture();
4464 }
4465 
4466 void Internals::withUserGesture(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
</pre>
<hr />
<pre>
4581     auto* document = contextDocument();
4582     if (!document)
4583         return;
4584 
4585     document-&gt;securityOrigin().setIsPotentiallyTrustworthy(false);
4586 }
4587 
4588 void Internals::postTask(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4589 {
4590     auto* document = contextDocument();
4591     if (!document) {
4592         callback-&gt;handleEvent();
4593         return;
4594     }
4595 
4596     document-&gt;postTask([callback = WTFMove(callback)](ScriptExecutionContext&amp;) {
4597         callback-&gt;handleEvent();
4598     });
4599 }
4600 





















































4601 Vector&lt;String&gt; Internals::accessKeyModifiers() const
4602 {
4603     Vector&lt;String&gt; accessKeyModifierStrings;
4604 
4605     for (auto modifier : EventHandler::accessKeyModifiers()) {
4606         switch (modifier) {
4607         case PlatformEvent::Modifier::AltKey:
4608             accessKeyModifierStrings.append(&quot;altKey&quot;_s);
4609             break;
4610         case PlatformEvent::Modifier::ControlKey:
4611             accessKeyModifierStrings.append(&quot;ctrlKey&quot;_s);
4612             break;
4613         case PlatformEvent::Modifier::MetaKey:
4614             accessKeyModifierStrings.append(&quot;metaKey&quot;_s);
4615             break;
4616         case PlatformEvent::Modifier::ShiftKey:
4617             accessKeyModifierStrings.append(&quot;shiftKey&quot;_s);
4618             break;
4619         case PlatformEvent::Modifier::CapsLockKey:
4620             accessKeyModifierStrings.append(&quot;capsLockKey&quot;_s);
4621             break;
4622         case PlatformEvent::Modifier::AltGraphKey:
4623             ASSERT_NOT_REACHED(); // AltGraph is only for DOM API.
4624             break;
4625         }
4626     }
4627 
4628     return accessKeyModifierStrings;
4629 }
4630 
4631 void Internals::setQuickLookPassword(const String&amp; password)
4632 {
4633 #if PLATFORM(IOS_FAMILY) &amp;&amp; USE(QUICK_LOOK)
4634     auto&amp; quickLookHandleClient = MockPreviewLoaderClient::singleton();
<span class="line-modified">4635     PreviewLoader::setClientForTesting(&amp;quickLookHandleClient);</span>
4636     quickLookHandleClient.setPassword(password);
4637 #else
4638     UNUSED_PARAM(password);
4639 #endif
4640 }
4641 
4642 void Internals::setAsRunningUserScripts(Document&amp; document)
4643 {
4644     document.setAsRunningUserScripts();
4645 }
4646 
4647 #if ENABLE(APPLE_PAY)
4648 void Internals::setApplePayIsActive(Document&amp; document)
4649 {
4650     document.setApplePayIsActive();
4651 }
4652 #endif
4653 
4654 #if ENABLE(WEBGL)
4655 void Internals::simulateWebGLContextChanged(WebGLRenderingContext&amp; context)
</pre>
<hr />
<pre>
4723     downcast&lt;MockRealtimeAudioSource&gt;(source).setChannelCount(channelNumber);
4724 }
4725 
4726 void Internals::setCameraMediaStreamTrackOrientation(MediaStreamTrack&amp; track, int orientation)
4727 {
4728     auto&amp; source = track.source();
4729     if (!source.isCaptureSource())
4730         return;
4731     m_orientationNotifier.orientationChanged(orientation);
4732     source.monitorOrientation(m_orientationNotifier);
4733 }
4734 
4735 void Internals::observeMediaStreamTrack(MediaStreamTrack&amp; track)
4736 {
4737     m_track = &amp;track;
4738     m_track-&gt;source().addObserver(*this);
4739 }
4740 
4741 void Internals::grabNextMediaStreamTrackFrame(TrackFramePromise&amp;&amp; promise)
4742 {
<span class="line-modified">4743     m_nextTrackFramePromise = WTFMove(promise);</span>
4744 }
4745 
4746 void Internals::videoSampleAvailable(MediaSample&amp; sample)
4747 {
4748     m_trackVideoSampleCount++;
4749     if (!m_nextTrackFramePromise)
4750         return;
4751 
4752     auto&amp; videoSettings = m_track-&gt;source().settings();
4753     if (!videoSettings.width() || !videoSettings.height())
4754         return;
4755 
4756     auto rgba = sample.getRGBAImageData();
4757     if (!rgba)
4758         return;
4759 
4760     auto imageData = ImageData::create(rgba.releaseNonNull(), videoSettings.width(), videoSettings.height());
4761     if (!imageData.hasException())
4762         m_nextTrackFramePromise-&gt;resolve(imageData.releaseReturnValue().releaseNonNull());
4763     else
4764         m_nextTrackFramePromise-&gt;reject(imageData.exception().code());
<span class="line-modified">4765     m_nextTrackFramePromise = WTF::nullopt;</span>
4766 }
4767 
4768 void Internals::delayMediaStreamTrackSamples(MediaStreamTrack&amp; track, float delay)
4769 {
4770     track.source().delaySamples(Seconds { delay });
4771 }
4772 
4773 void Internals::setMediaStreamTrackMuted(MediaStreamTrack&amp; track, bool muted)
4774 {
4775     track.source().setMuted(muted);
4776 }
4777 
4778 void Internals::removeMediaStreamTrack(MediaStream&amp; stream, MediaStreamTrack&amp; track)
4779 {
4780     stream.internalRemoveTrack(track.id(), MediaStream::StreamModifier::Platform);
4781 }
4782 
4783 void Internals::simulateMediaStreamTrackCaptureSourceFailure(MediaStreamTrack&amp; track)
4784 {
4785     track.source().captureFailed();
4786 }
4787 
4788 void Internals::setMediaStreamTrackIdentifier(MediaStreamTrack&amp; track, String&amp;&amp; id)
4789 {
4790     track.setIdForTesting(WTFMove(id));
4791 }
4792 
4793 void Internals::setMediaStreamSourceInterrupted(MediaStreamTrack&amp; track, bool interrupted)
4794 {
4795     track.source().setInterruptedForTesting(interrupted);
4796 }
4797 
<span class="line-modified">4798 void Internals::setDisableGetDisplayMediaUserGestureConstraint(bool value)</span>
4799 {
<span class="line-modified">4800     Document* document = contextDocument();</span>
<span class="line-removed">4801     if (!document || !document-&gt;domWindow())</span>
<span class="line-removed">4802         return;</span>
<span class="line-removed">4803 </span>
<span class="line-removed">4804     if (auto* mediaDevices = NavigatorMediaDevices::mediaDevices(document-&gt;domWindow()-&gt;navigator()))</span>
<span class="line-removed">4805         mediaDevices-&gt;setDisableGetDisplayMediaUserGestureConstraint(value);</span>
4806 }
4807 #endif
4808 









4809 String Internals::audioSessionCategory() const
4810 {
4811 #if USE(AUDIO_SESSION)
4812     switch (AudioSession::sharedSession().category()) {
4813     case AudioSession::AmbientSound:
4814         return &quot;AmbientSound&quot;_s;
4815     case AudioSession::SoloAmbientSound:
4816         return &quot;SoloAmbientSound&quot;_s;
4817     case AudioSession::MediaPlayback:
4818         return &quot;MediaPlayback&quot;_s;
4819     case AudioSession::RecordAudio:
4820         return &quot;RecordAudio&quot;_s;
4821     case AudioSession::PlayAndRecord:
4822         return &quot;PlayAndRecord&quot;_s;
4823     case AudioSession::AudioProcessing:
4824         return &quot;AudioProcessing&quot;_s;
4825     case AudioSession::None:
4826         return &quot;None&quot;_s;
4827     }
4828 #endif
</pre>
<hr />
<pre>
4834 #if USE(AUDIO_SESSION)
4835     return AudioSession::sharedSession().preferredBufferSize();
4836 #endif
4837     return 0;
4838 }
4839 
4840 bool Internals::audioSessionActive() const
4841 {
4842 #if USE(AUDIO_SESSION)
4843     return AudioSession::sharedSession().isActive();
4844 #endif
4845     return false;
4846 }
4847 
4848 void Internals::storeRegistrationsOnDisk(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
4849 {
4850 #if ENABLE(SERVICE_WORKER)
4851     if (!contextDocument())
4852         return;
4853 
<span class="line-modified">4854     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID());</span>
4855     connection.storeRegistrationsOnDiskForTesting([promise = WTFMove(promise)]() mutable {
4856         promise.resolve();
4857     });
4858 #else
4859     promise.resolve();
4860 #endif
4861 }
4862 
4863 void Internals::clearCacheStorageMemoryRepresentation(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
4864 {
4865     auto* document = contextDocument();
4866     if (!document)
4867         return;
4868 
4869     if (!m_cacheStorageConnection) {
4870         if (auto* page = contextDocument()-&gt;page())
<span class="line-modified">4871             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());</span>
4872         if (!m_cacheStorageConnection)
4873             return;
4874     }
4875     m_cacheStorageConnection-&gt;clearMemoryRepresentation(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() }, [promise = WTFMove(promise)] (auto &amp;&amp; result) mutable {
4876         ASSERT_UNUSED(result, !result);
4877         promise.resolve();
4878     });
4879 }
4880 
4881 void Internals::cacheStorageEngineRepresentation(DOMPromiseDeferred&lt;IDLDOMString&gt;&amp;&amp; promise)
4882 {
4883     auto* document = contextDocument();
4884     if (!document)
4885         return;
4886 
4887     if (!m_cacheStorageConnection) {
4888         if (auto* page = contextDocument()-&gt;page())
<span class="line-modified">4889             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());</span>
4890         if (!m_cacheStorageConnection)
4891             return;
4892     }
4893     m_cacheStorageConnection-&gt;engineRepresentation([promise = WTFMove(promise)](const String&amp; result) mutable {
4894         promise.resolve(result);
4895     });
4896 }
4897 
4898 void Internals::updateQuotaBasedOnSpaceUsage()
4899 {
4900     auto* document = contextDocument();
4901     if (!document)
4902         return;
4903 
4904     if (!m_cacheStorageConnection) {
4905         if (auto* page = contextDocument()-&gt;page())
<span class="line-modified">4906             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());</span>
4907         if (!m_cacheStorageConnection)
4908             return;
4909     }
4910 
4911     m_cacheStorageConnection-&gt;updateQuotaBasedOnSpaceUsage(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() });
4912 }
4913 
4914 void Internals::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
4915 {
4916     if (!contextDocument())
4917         return;
4918 
4919     contextDocument()-&gt;setConsoleMessageListener(WTFMove(listener));
4920 }
4921 
4922 void Internals::setResponseSizeWithPadding(FetchResponse&amp; response, uint64_t size)
4923 {
4924     response.setBodySizeWithPadding(size);
4925 }
4926 
4927 uint64_t Internals::responseSizeWithPadding(FetchResponse&amp; response) const
4928 {
4929     return response.bodySizeWithPadding();
4930 }
4931 
4932 #if ENABLE(SERVICE_WORKER)
4933 void Internals::hasServiceWorkerRegistration(const String&amp; clientURL, HasRegistrationPromise&amp;&amp; promise)
4934 {
4935     if (!contextDocument())
4936         return;
4937 
4938     URL parsedURL = contextDocument()-&gt;completeURL(clientURL);
4939 
<span class="line-modified">4940     return ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID()).matchRegistration(SecurityOriginData { contextDocument()-&gt;topOrigin().data() }, parsedURL, [promise = WTFMove(promise)] (auto&amp;&amp; result) mutable {</span>
4941         promise.resolve(!!result);
4942     });
4943 }
4944 
4945 void Internals::terminateServiceWorker(ServiceWorker&amp; worker)
4946 {
4947     if (!contextDocument())
4948         return;
4949 
<span class="line-modified">4950     ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID()).syncTerminateWorker(worker.identifier());</span>
4951 }
4952 
<span class="line-modified">4953 bool Internals::hasServiceWorkerConnection()</span>
4954 {
<span class="line-modified">4955     if (!contextDocument())</span>
<span class="line-modified">4956         return false;</span>
<span class="line-modified">4957 </span>
<span class="line-removed">4958     return ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(contextDocument()-&gt;sessionID());</span>
4959 }
4960 #endif
4961 
4962 #if ENABLE(APPLE_PAY)
4963 MockPaymentCoordinator&amp; Internals::mockPaymentCoordinator(Document&amp; document)
4964 {
4965     return downcast&lt;MockPaymentCoordinator&gt;(document.frame()-&gt;page()-&gt;paymentCoordinator().client());
4966 }
4967 #endif
4968 
4969 bool Internals::isSystemPreviewLink(Element&amp; element) const
4970 {
4971 #if USE(SYSTEM_PREVIEW)
4972     return is&lt;HTMLAnchorElement&gt;(element) &amp;&amp; downcast&lt;HTMLAnchorElement&gt;(element).isSystemPreviewLink();
4973 #else
4974     UNUSED_PARAM(element);
4975     return false;
4976 #endif
4977 }
4978 
</pre>
<hr />
<pre>
5063 
5064 bool Internals::capsLockIsOn()
5065 {
5066     return WebCore::PlatformKeyboardEvent::currentCapsLockState();
5067 }
5068 
5069 bool Internals::supportsVCPEncoder()
5070 {
5071 #if defined(ENABLE_VCP_ENCODER)
5072     return ENABLE_VCP_ENCODER || ENABLE_VCP_VTB_ENCODER;
5073 #else
5074     return false;
5075 #endif
5076 }
5077 
5078 Optional&lt;HEVCParameterSet&gt; Internals::parseHEVCCodecParameters(const String&amp; codecString)
5079 {
5080     return WebCore::parseHEVCCodecParameters(codecString);
5081 }
5082 





5083 auto Internals::getCookies() const -&gt; Vector&lt;CookieData&gt;
5084 {
5085     auto* document = contextDocument();
5086     if (!document)
5087         return { };
5088 
5089     auto* page = document-&gt;page();
5090     if (!page)
5091         return { };
5092 
5093     Vector&lt;Cookie&gt; cookies;
5094     page-&gt;cookieJar().getRawCookies(*document, document-&gt;cookieURL(), cookies);
5095     return WTF::map(cookies, [](auto&amp; cookie) {
5096         return CookieData { cookie };
5097     });
5098 }
5099 
5100 void Internals::setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive)
5101 {
5102     auto* localFrame = frame();
5103     if (!localFrame)
5104         return;
5105     localFrame-&gt;loader().setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchive);
5106 }
5107 
5108 void Internals::processWillSuspend()
5109 {

5110     PlatformMediaSessionManager::sharedManager().processWillSuspend();

5111 }
5112 
5113 void Internals::processDidResume()
5114 {

5115     PlatformMediaSessionManager::sharedManager().processDidResume();

5116 }
5117 
5118 void Internals::testDictionaryLogging()
5119 {
5120     auto* document = contextDocument();
5121     if (!document)
5122         return;
5123 
5124     auto* page = document-&gt;page();
5125     if (!page)
5126         return;
5127 
5128     DiagnosticLoggingClient::ValueDictionary dictionary;
5129     dictionary.set(&quot;stringKey&quot;_s, String(&quot;stringValue&quot;));
5130     dictionary.set(&quot;uint64Key&quot;_s, std::numeric_limits&lt;uint64_t&gt;::max());
5131     dictionary.set(&quot;int64Key&quot;_s, std::numeric_limits&lt;int64_t&gt;::min());
5132     dictionary.set(&quot;boolKey&quot;_s, true);
5133     dictionary.set(&quot;doubleKey&quot;_s, 2.7182818284590452353602874);
5134 
5135     page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValueDictionary(&quot;testMessage&quot;_s, &quot;testDescription&quot;_s, dictionary, ShouldSample::No);
5136 }
5137 
5138 void Internals::setXHRMaximumIntervalForUserGestureForwarding(XMLHttpRequest&amp; request, double interval)
5139 {
5140     request.setMaximumIntervalForUserGestureForwarding(interval);
5141 }
5142 





5143 void Internals::setIsPlayingToAutomotiveHeadUnit(bool isPlaying)
5144 {

5145     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(isPlaying);

















5146 }
5147 
5148 Internals::TextIndicatorInfo::TextIndicatorInfo()
5149 {
5150 }
5151 
5152 Internals::TextIndicatorInfo::TextIndicatorInfo(const WebCore::TextIndicatorData&amp; data)
5153     : textBoundingRectInRootViewCoordinates(DOMRect::create(data.textBoundingRectInRootViewCoordinates))
5154     , textRectsInBoundingRectCoordinates(DOMRectList::create(data.textRectsInBoundingRectCoordinates))
5155 {
5156 }
5157 
5158 Internals::TextIndicatorInfo::~TextIndicatorInfo() = default;
5159 
5160 Internals::TextIndicatorInfo Internals::textIndicatorForRange(const Range&amp; range, TextIndicatorOptions options)
5161 {
5162     auto indicator = TextIndicator::createWithRange(range, options.core(), TextIndicatorPresentationTransition::None);
5163     return indicator-&gt;data();
5164 }
5165 
5166 void Internals::addPrefetchLoadEventListener(HTMLLinkElement&amp; link, RefPtr&lt;EventListener&gt;&amp;&amp; listener)
5167 {
<span class="line-modified">5168     if (RuntimeEnabledFeatures::sharedFeatures().linkPrefetchEnabled() &amp;&amp; equalLettersIgnoringASCIICase(link.rel(), &quot;prefetch&quot;))</span>

5169         link.addEventListener(eventNames().loadEvent, listener.releaseNonNull(), false);


















































































































5170 }
5171 
5172 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Internals.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;

  31 #include &quot;ActivityState.h&quot;
  32 #include &quot;AnimationTimeline.h&quot;
  33 #include &quot;ApplicationCacheStorage.h&quot;
  34 #include &quot;AudioSession.h&quot;
  35 #include &quot;Autofill.h&quot;
<span class="line-added">  36 #include &quot;BackForwardCache.h&quot;</span>
  37 #include &quot;BackForwardController.h&quot;
  38 #include &quot;BitmapImage.h&quot;
  39 #include &quot;CSSAnimationController.h&quot;
  40 #include &quot;CSSKeyframesRule.h&quot;
  41 #include &quot;CSSMediaRule.h&quot;
<span class="line-added">  42 #include &quot;CSSPropertyParser.h&quot;</span>
  43 #include &quot;CSSStyleRule.h&quot;
  44 #include &quot;CSSSupportsRule.h&quot;
  45 #include &quot;CacheStorageConnection.h&quot;
  46 #include &quot;CacheStorageProvider.h&quot;
  47 #include &quot;CachedImage.h&quot;
  48 #include &quot;CachedResourceLoader.h&quot;
  49 #include &quot;CertificateInfo.h&quot;
  50 #include &quot;Chrome.h&quot;
  51 #include &quot;ChromeClient.h&quot;
  52 #include &quot;ClientOrigin.h&quot;
  53 #include &quot;ComposedTreeIterator.h&quot;
  54 #include &quot;CookieJar.h&quot;
  55 #include &quot;Cursor.h&quot;
  56 #include &quot;CustomHeaderFields.h&quot;
  57 #include &quot;DOMRect.h&quot;
  58 #include &quot;DOMRectList.h&quot;
  59 #include &quot;DOMStringList.h&quot;
  60 #include &quot;DOMWindow.h&quot;
  61 #include &quot;DeprecatedGlobalSettings.h&quot;
  62 #include &quot;DiagnosticLoggingClient.h&quot;
  63 #include &quot;DisabledAdaptations.h&quot;
  64 #include &quot;DisplayList.h&quot;
  65 #include &quot;Document.h&quot;
  66 #include &quot;DocumentLoader.h&quot;
  67 #include &quot;DocumentMarkerController.h&quot;
  68 #include &quot;DocumentTimeline.h&quot;
  69 #include &quot;Editor.h&quot;
  70 #include &quot;Element.h&quot;
  71 #include &quot;EventHandler.h&quot;
  72 #include &quot;EventListener.h&quot;
<span class="line-added">  73 #include &quot;EventLoop.h&quot;</span>
  74 #include &quot;EventNames.h&quot;
  75 #include &quot;ExtendableEvent.h&quot;
  76 #include &quot;ExtensionStyleSheets.h&quot;
  77 #include &quot;FetchResponse.h&quot;
  78 #include &quot;File.h&quot;
  79 #include &quot;FontCache.h&quot;
  80 #include &quot;FormController.h&quot;
  81 #include &quot;Frame.h&quot;
  82 #include &quot;FrameLoader.h&quot;
<span class="line-added">  83 #include &quot;FrameLoaderClient.h&quot;</span>
  84 #include &quot;FrameView.h&quot;
  85 #include &quot;FullscreenManager.h&quot;
  86 #include &quot;GCObservation.h&quot;
  87 #include &quot;GridPosition.h&quot;
  88 #include &quot;HEVCUtilities.h&quot;
  89 #include &quot;HTMLAnchorElement.h&quot;
  90 #include &quot;HTMLCanvasElement.h&quot;
  91 #include &quot;HTMLIFrameElement.h&quot;
  92 #include &quot;HTMLImageElement.h&quot;
  93 #include &quot;HTMLInputElement.h&quot;
  94 #include &quot;HTMLLinkElement.h&quot;
  95 #include &quot;HTMLNames.h&quot;
  96 #include &quot;HTMLPictureElement.h&quot;
  97 #include &quot;HTMLPlugInElement.h&quot;
  98 #include &quot;HTMLPreloadScanner.h&quot;
  99 #include &quot;HTMLSelectElement.h&quot;
 100 #include &quot;HTMLTextAreaElement.h&quot;
 101 #include &quot;HTMLVideoElement.h&quot;
 102 #include &quot;HistoryController.h&quot;
 103 #include &quot;HistoryItem.h&quot;
 104 #include &quot;HitTestResult.h&quot;
 105 #include &quot;InspectorClient.h&quot;
 106 #include &quot;InspectorController.h&quot;
<span class="line-added"> 107 #include &quot;InspectorDebuggableType.h&quot;</span>
 108 #include &quot;InspectorFrontendClientLocal.h&quot;
 109 #include &quot;InspectorOverlay.h&quot;
 110 #include &quot;InstrumentingAgents.h&quot;
 111 #include &quot;IntRect.h&quot;
 112 #include &quot;InternalSettings.h&quot;
<span class="line-added"> 113 #include &quot;InternalsMapLike.h&quot;</span>
<span class="line-added"> 114 #include &quot;InternalsSetLike.h&quot;</span>
<span class="line-added"> 115 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 116 #include &quot;JSImageData.h&quot;
<span class="line-added"> 117 #include &quot;LegacySchemeRegistry.h&quot;</span>
 118 #include &quot;LibWebRTCProvider.h&quot;
 119 #include &quot;LoaderStrategy.h&quot;
<span class="line-added"> 120 #include &quot;Location.h&quot;</span>
<span class="line-added"> 121 #include &quot;MIMETypeRegistry.h&quot;</span>
 122 #include &quot;MallocStatistics.h&quot;
 123 #include &quot;MediaDevices.h&quot;
 124 #include &quot;MediaEngineConfigurationFactory.h&quot;
 125 #include &quot;MediaPlayer.h&quot;
 126 #include &quot;MediaProducer.h&quot;
<span class="line-added"> 127 #include &quot;MediaRecorderProvider.h&quot;</span>
 128 #include &quot;MediaResourceLoader.h&quot;
 129 #include &quot;MediaStreamTrack.h&quot;
 130 #include &quot;MemoryCache.h&quot;
 131 #include &quot;MemoryInfo.h&quot;
<span class="line-added"> 132 #include &quot;MockAudioDestinationCocoa.h&quot;</span>
 133 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 134 #include &quot;MockPageOverlay.h&quot;
 135 #include &quot;MockPageOverlayClient.h&quot;
 136 #include &quot;NavigatorMediaDevices.h&quot;
 137 #include &quot;NetworkLoadInformation.h&quot;
 138 #include &quot;Page.h&quot;

 139 #include &quot;PageOverlay.h&quot;
 140 #include &quot;PathUtilities.h&quot;
 141 #include &quot;PlatformKeyboardEvent.h&quot;
 142 #include &quot;PlatformMediaSessionManager.h&quot;
 143 #include &quot;PlatformScreen.h&quot;
 144 #include &quot;PlatformStrategies.h&quot;
 145 #include &quot;PluginData.h&quot;
 146 #include &quot;PrintContext.h&quot;
 147 #include &quot;PseudoElement.h&quot;
 148 #include &quot;Range.h&quot;
 149 #include &quot;ReadableStream.h&quot;
 150 #include &quot;RenderEmbeddedObject.h&quot;
 151 #include &quot;RenderLayerBacking.h&quot;
 152 #include &quot;RenderLayerCompositor.h&quot;
 153 #include &quot;RenderMenuList.h&quot;
<span class="line-added"> 154 #include &quot;RenderTheme.h&quot;</span>
 155 #include &quot;RenderTreeAsText.h&quot;
 156 #include &quot;RenderView.h&quot;
 157 #include &quot;RenderedDocumentMarker.h&quot;
 158 #include &quot;ResourceLoadObserver.h&quot;
 159 #include &quot;RuntimeEnabledFeatures.h&quot;
 160 #include &quot;SMILTimeContainer.h&quot;
 161 #include &quot;SVGDocumentExtensions.h&quot;
 162 #include &quot;SVGPathStringBuilder.h&quot;
 163 #include &quot;SVGSVGElement.h&quot;
 164 #include &quot;SWClientConnection.h&quot;
<span class="line-modified"> 165 #include &quot;ScriptController.h&quot;</span>
 166 #include &quot;ScriptedAnimationController.h&quot;
 167 #include &quot;ScrollingCoordinator.h&quot;
 168 #include &quot;ScrollingMomentumCalculator.h&quot;
 169 #include &quot;SecurityOrigin.h&quot;
 170 #include &quot;SerializedScriptValue.h&quot;
 171 #include &quot;ServiceWorker.h&quot;
 172 #include &quot;ServiceWorkerProvider.h&quot;
 173 #include &quot;ServiceWorkerRegistrationData.h&quot;
 174 #include &quot;Settings.h&quot;
 175 #include &quot;ShadowRoot.h&quot;
 176 #include &quot;SourceBuffer.h&quot;
 177 #include &quot;SpellChecker.h&quot;
 178 #include &quot;StaticNodeList.h&quot;
<span class="line-added"> 179 #include &quot;StorageNamespace.h&quot;</span>
<span class="line-added"> 180 #include &quot;StorageNamespaceProvider.h&quot;</span>
 181 #include &quot;StringCallback.h&quot;
<span class="line-added"> 182 #include &quot;StyleResolver.h&quot;</span>
 183 #include &quot;StyleRule.h&quot;
 184 #include &quot;StyleScope.h&quot;
 185 #include &quot;StyleSheetContents.h&quot;
 186 #include &quot;TextIterator.h&quot;
 187 #include &quot;TreeScope.h&quot;
 188 #include &quot;TypeConversions.h&quot;
 189 #include &quot;UserGestureIndicator.h&quot;
 190 #include &quot;UserMediaController.h&quot;
 191 #include &quot;ViewportArguments.h&quot;
 192 #include &quot;VoidCallback.h&quot;
 193 #include &quot;WebCoreJSClientData.h&quot;
 194 #include &quot;WindowProxy.h&quot;
 195 #include &quot;WorkerThread.h&quot;
 196 #include &quot;WorkletGlobalScope.h&quot;
 197 #include &quot;WritingDirection.h&quot;
 198 #include &quot;XMLHttpRequest.h&quot;
 199 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 200 #include &lt;JavaScriptCore/InspectorAgentBase.h&gt;
 201 #include &lt;JavaScriptCore/InspectorFrontendChannel.h&gt;
 202 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 203 #include &lt;JavaScriptCore/JSCJSValue.h&gt;
 204 #include &lt;wtf/HexNumber.h&gt;
 205 #include &lt;wtf/JSONValues.h&gt;
 206 #include &lt;wtf/Language.h&gt;
 207 #include &lt;wtf/MemoryPressureHandler.h&gt;
 208 #include &lt;wtf/MonotonicTime.h&gt;
<span class="line-added"> 209 #include &lt;wtf/ProcessID.h&gt;</span>
 210 #include &lt;wtf/URLHelpers.h&gt;
 211 #include &lt;wtf/text/StringBuilder.h&gt;
 212 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 213 
 214 #if USE(CG)
 215 #include &quot;PDFDocumentImage.h&quot;
 216 #endif
 217 
 218 #if ENABLE(INPUT_TYPE_COLOR)
 219 #include &quot;ColorChooser.h&quot;
 220 #endif
 221 
 222 #if ENABLE(MOUSE_CURSOR_SCALE)
 223 #include &lt;wtf/dtoa.h&gt;
 224 #endif
 225 
 226 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 227 #include &quot;LegacyCDM.h&quot;
 228 #include &quot;LegacyMockCDM.h&quot;
 229 #endif
</pre>
<hr />
<pre>
 278 
 279 #if ENABLE(MEDIA_SESSION)
 280 #include &quot;MediaSession.h&quot;
 281 #include &quot;MediaSessionManager.h&quot;
 282 #endif
 283 
 284 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 285 #include &quot;MediaPlaybackTargetContext.h&quot;
 286 #endif
 287 
 288 #if ENABLE(POINTER_LOCK)
 289 #include &quot;PointerLockController.h&quot;
 290 #endif
 291 
 292 #if ENABLE(INDEXED_DATABASE)
 293 #include &quot;IDBRequest.h&quot;
 294 #include &quot;IDBTransaction.h&quot;
 295 #endif
 296 
 297 #if USE(QUICK_LOOK)
<span class="line-added"> 298 #include &quot;LegacyPreviewLoader.h&quot;</span>
 299 #include &quot;MockPreviewLoaderClient.h&quot;

 300 #endif
 301 
 302 #if ENABLE(APPLE_PAY)
 303 #include &quot;MockPaymentCoordinator.h&quot;
 304 #include &quot;PaymentCoordinator.h&quot;
 305 #endif
 306 
 307 #if PLATFORM(MAC) &amp;&amp; USE(LIBWEBRTC)
 308 #include &lt;webrtc/sdk/WebKit/VideoProcessingSoftLink.h&gt;
 309 #endif
 310 
 311 #if PLATFORM(MAC)
<span class="line-modified"> 312 #include &quot;GraphicsContextGLOpenGLManager.h&quot;</span>
<span class="line-added"> 313 #endif</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315 #if PLATFORM(COCOA)</span>
<span class="line-added"> 316 #include &quot;SystemBattery.h&quot;</span>
<span class="line-added"> 317 #include &lt;wtf/spi/darwin/SandboxSPI.h&gt;</span>
 318 #endif
 319 
 320 using JSC::CallData;
 321 using JSC::CallType;
 322 using JSC::CodeBlock;
 323 using JSC::FunctionExecutable;
 324 using JSC::Identifier;
 325 using JSC::JSFunction;
 326 using JSC::JSGlobalObject;
 327 using JSC::JSObject;
 328 using JSC::JSValue;
 329 using JSC::MarkedArgumentBuffer;
 330 using JSC::PropertySlot;
 331 using JSC::ScriptExecutable;
 332 using JSC::StackVisitor;
 333 
 334 
 335 namespace WebCore {
 336 using namespace Inspector;
 337 
 338 using namespace HTMLNames;
 339 
 340 class InspectorStubFrontend final : public InspectorFrontendClientLocal, public FrontendChannel {
 341 public:
 342     InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow);
 343     virtual ~InspectorStubFrontend();
 344 
 345 private:
 346     void attachWindow(DockSide) final { }
 347     void detachWindow() final { }
 348     void closeWindow() final;
 349     void reopen() final { }
 350     void bringToFront() final { }
<span class="line-modified"> 351     String localizedStringsURL() const final { return String(); }</span>
<span class="line-added"> 352     DebuggableType debuggableType() const final { return DebuggableType::Page; }</span>
<span class="line-added"> 353     String targetPlatformName() const { return &quot;Unknown&quot;_s; }</span>
<span class="line-added"> 354     String targetBuildVersion() const { return &quot;Unknown&quot;_s; }</span>
<span class="line-added"> 355     String targetProductVersion() const { return &quot;Unknown&quot;_s; }</span>
<span class="line-added"> 356     bool targetIsSimulator() const { return false; }</span>
 357     void inspectedURLChanged(const String&amp;) final { }
 358     void showCertificate(const CertificateInfo&amp;) final { }
 359     void setAttachedWindowHeight(unsigned) final { }
 360     void setAttachedWindowWidth(unsigned) final { }
 361     void setSheetRect(const FloatRect&amp;) final { }
 362 
 363     void sendMessageToFrontend(const String&amp; message) final;
 364     ConnectionType connectionType() const final { return ConnectionType::Local; }
 365 
 366     RefPtr&lt;DOMWindow&gt; m_frontendWindow;
 367 };
 368 
 369 InspectorStubFrontend::InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow)
 370     : InspectorFrontendClientLocal(&amp;inspectedPage.inspectorController(), frontendWindow-&gt;document()-&gt;page(), makeUnique&lt;InspectorFrontendClientLocal::Settings&gt;())
 371     , m_frontendWindow(frontendWindow.copyRef())
 372 {
 373     ASSERT_ARG(frontendWindow, frontendWindow);
 374 
 375     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(this);
 376     inspectedPage.inspectorController().connectFrontend(*this);
</pre>
<hr />
<pre>
 494 
 495     WTF::clearDefaultPortForProtocolMapForTesting();
 496     overrideUserPreferredLanguages(Vector&lt;String&gt;());
 497     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(false);
 498     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(false);
 499 #if ENABLE(VIDEO_TRACK)
 500     page.group().captionPreferences().setTestingMode(true);
 501     page.group().captionPreferences().setCaptionsStyleSheetOverride(emptyString());
 502     page.group().captionPreferences().setTestingMode(false);
 503 #endif
 504     if (!page.mainFrame().editor().isContinuousSpellCheckingEnabled())
 505         page.mainFrame().editor().toggleContinuousSpellChecking();
 506     if (page.mainFrame().editor().isOverwriteModeEnabled())
 507         page.mainFrame().editor().toggleOverwriteModeEnabled();
 508     page.mainFrame().loader().clearTestingOverrides();
 509     page.applicationCacheStorage().setDefaultOriginQuota(ApplicationCacheStorage::noQuota());
 510 #if ENABLE(VIDEO)
 511     PlatformMediaSessionManager::sharedManager().resetRestrictions();
 512     PlatformMediaSessionManager::sharedManager().setWillIgnoreSystemInterruptions(true);
 513 #endif
<span class="line-added"> 514 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)</span>
 515     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(false);
<span class="line-added"> 516 #endif</span>
 517 #if ENABLE(ACCESSIBILITY)
 518     AXObjectCache::setEnhancedUserInterfaceAccessibility(false);
 519     AXObjectCache::disableAccessibility();
 520 #endif
 521 
 522     MockPageOverlayClient::singleton().uninstallAllOverlays();
 523 
 524 #if ENABLE(CONTENT_FILTERING)
 525     MockContentFilterSettings::reset();
 526 #endif
 527 
 528 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 529     page.setMockMediaPlaybackTargetPickerEnabled(true);
 530     page.setMockMediaPlaybackTargetPickerState(emptyString(), MediaPlaybackTargetContext::Unknown);
 531 #endif
 532 
 533     page.setShowAllPlugins(false);
 534     page.setLowPowerModeEnabledOverrideForTesting(WTF::nullopt);
 535 
 536 #if USE(QUICK_LOOK)
 537     MockPreviewLoaderClient::singleton().setPassword(&quot;&quot;);
<span class="line-modified"> 538     LegacyPreviewLoader::setClientForTesting(nullptr);</span>
 539 #endif
 540 
 541     printContextForTesting() = nullptr;
 542 
 543 #if USE(LIBWEBRTC)
 544     auto&amp; rtcProvider = page.libWebRTCProvider();
 545     WebCore::useRealRTCPeerConnectionFactory(rtcProvider);
 546     rtcProvider.disableNonLocalhostConnections();
 547     RuntimeEnabledFeatures::sharedFeatures().setWebRTCVP8CodecEnabled(true);
 548     page.settings().setWebRTCEncryptionEnabled(true);
<span class="line-added"> 549     rtcProvider.setUseGPUProcess(false);</span>
 550 #endif
 551 
 552     page.settings().setStorageAccessAPIEnabled(false);
 553     page.setFullscreenAutoHideDuration(0_s);
 554     page.setFullscreenInsets({ });
 555     page.setFullscreenControlsHidden(false);
 556 
 557     MediaEngineConfigurationFactory::disableMock();
 558 
 559 #if ENABLE(MEDIA_STREAM)
 560     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(false);
<span class="line-added"> 561     WebCore::MediaRecorder::setCustomPrivateRecorderCreator(nullptr);</span>
<span class="line-added"> 562     page.mediaRecorderProvider().setUseGPUProcess(true);</span>
 563 #endif
<span class="line-added"> 564 </span>
<span class="line-added"> 565     HTMLCanvasElement::setMaxPixelMemoryForTesting(0); // This means use the default value.</span>
<span class="line-added"> 566     DOMWindow::overrideTransientActivationDurationForTesting(WTF::nullopt);</span>
 567 }
 568 
 569 Internals::Internals(Document&amp; document)
 570     : ContextDestructionObserver(&amp;document)
 571 #if ENABLE(MEDIA_STREAM)
 572     , m_orientationNotifier(0)
 573 #endif
 574 {
 575 #if ENABLE(VIDEO_TRACK)
 576     if (document.page())
 577         document.page()-&gt;group().captionPreferences().setTestingMode(true);
 578 #endif
 579 
 580 #if ENABLE(MEDIA_STREAM)

 581     setMediaCaptureRequiresSecureConnection(false);
 582 #endif
 583 
 584 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 585     if (document.page())
 586         document.page()-&gt;setMockMediaPlaybackTargetPickerEnabled(true);
 587 #endif
 588 
 589     if (contextDocument() &amp;&amp; contextDocument()-&gt;frame()) {
 590         setAutomaticSpellingCorrectionEnabled(true);
 591         setAutomaticQuoteSubstitutionEnabled(false);
 592         setAutomaticDashSubstitutionEnabled(false);
 593         setAutomaticLinkDetectionEnabled(false);
 594         setAutomaticTextReplacementEnabled(true);
 595     }
 596 
 597     setConsoleMessageListener(nullptr);
 598 
 599 #if ENABLE(APPLE_PAY)
 600     auto* frame = document.frame();
 601     if (frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;isMainFrame()) {
 602         auto mockPaymentCoordinator = new MockPaymentCoordinator(*frame-&gt;page());
 603         frame-&gt;page()-&gt;setPaymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*mockPaymentCoordinator));
 604     }
 605 #endif
<span class="line-added"> 606 </span>
<span class="line-added"> 607 #if PLATFORM(COCOA) &amp;&amp;  ENABLE(WEB_AUDIO)</span>
<span class="line-added"> 608     AudioDestinationCocoa::createOverride = nullptr;</span>
<span class="line-added"> 609 #endif</span>
 610 }
 611 
 612 Document* Internals::contextDocument() const
 613 {
 614     return downcast&lt;Document&gt;(scriptExecutionContext());
 615 }
 616 
 617 Frame* Internals::frame() const
 618 {
 619     if (!contextDocument())
 620         return nullptr;
 621     return contextDocument()-&gt;frame();
 622 }
 623 
 624 InternalSettings* Internals::settings() const
 625 {
 626     Document* document = contextDocument();
 627     if (!document)
 628         return nullptr;
 629     Page* page = document-&gt;page();
</pre>
<hr />
<pre>
 724 {
 725     if (response.isNull())
 726         return &quot;Null response&quot;;
 727     switch (response.source()) {
 728     case ResourceResponse::Source::Unknown:
 729         return &quot;Unknown&quot;;
 730     case ResourceResponse::Source::Network:
 731         return &quot;Network&quot;;
 732     case ResourceResponse::Source::ServiceWorker:
 733         return &quot;Service worker&quot;;
 734     case ResourceResponse::Source::DiskCache:
 735         return &quot;Disk cache&quot;;
 736     case ResourceResponse::Source::DiskCacheAfterValidation:
 737         return &quot;Disk cache after validation&quot;;
 738     case ResourceResponse::Source::MemoryCache:
 739         return &quot;Memory cache&quot;;
 740     case ResourceResponse::Source::MemoryCacheAfterValidation:
 741         return &quot;Memory cache after validation&quot;;
 742     case ResourceResponse::Source::ApplicationCache:
 743         return &quot;Application cache&quot;;
<span class="line-added"> 744     case ResourceResponse::Source::DOMCache:</span>
<span class="line-added"> 745         return &quot;DOM cache&quot;;</span>
<span class="line-added"> 746     case ResourceResponse::Source::InspectorOverride:</span>
<span class="line-added"> 747         return &quot;Inspector override&quot;;</span>
 748     }
 749     ASSERT_NOT_REACHED();
 750     return &quot;Error&quot;;
 751 }
 752 
 753 String Internals::xhrResponseSource(XMLHttpRequest&amp; request)
 754 {
 755     return responseSourceToString(request.resourceResponse());
 756 }
 757 
 758 String Internals::fetchResponseSource(FetchResponse&amp; response)
 759 {
 760     return responseSourceToString(response.resourceResponse());
 761 }
 762 
 763 bool Internals::isSharingStyleSheetContents(HTMLLinkElement&amp; a, HTMLLinkElement&amp; b)
 764 {
 765     if (!a.sheet() || !b.sheet())
 766         return false;
 767     return &amp;a.sheet()-&gt;contents() == &amp;b.sheet()-&gt;contents();
</pre>
<hr />
<pre>
 935 #endif
 936 }
 937 
 938 void Internals::setLargeImageAsyncDecodingEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 939 {
 940     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 941         bitmapImage-&gt;setLargeImageAsyncDecodingEnabledForTesting(enabled);
 942 }
 943 
 944 void Internals::setForceUpdateImageDataEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 945 {
 946     if (auto* cachedImage = element.cachedImage())
 947         cachedImage-&gt;setForceUpdateImageDataEnabledForTesting(enabled);
 948 }
 949 
 950 void Internals::setGridMaxTracksLimit(unsigned maxTrackLimit)
 951 {
 952     GridPosition::setMaxPositionForTesting(maxTrackLimit);
 953 }
 954 
<span class="line-modified"> 955 void Internals::clearBackForwardCache()</span>
 956 {
<span class="line-modified"> 957     BackForwardCache::singleton().pruneToSizeNow(0, PruningReason::None);</span>
 958 }
 959 
<span class="line-modified"> 960 unsigned Internals::backForwardCacheSize() const</span>
 961 {
<span class="line-modified"> 962     return BackForwardCache::singleton().pageCount();</span>
<span class="line-added"> 963 }</span>
<span class="line-added"> 964 </span>
<span class="line-added"> 965 void Internals::preventDocumentFromEnteringBackForwardCache()</span>
<span class="line-added"> 966 {</span>
<span class="line-added"> 967     if (auto* document = contextDocument())</span>
<span class="line-added"> 968         document-&gt;preventEnteringBackForwardCacheForTesting();</span>
 969 }
 970 
 971 void Internals::disableTileSizeUpdateDelay()
 972 {
 973     Document* document = contextDocument();
 974     if (!document || !document-&gt;frame())
 975         return;
 976 
 977     auto* view = document-&gt;frame()-&gt;view();
 978     if (!view)
 979         return;
 980 
 981     if (auto* backing = view-&gt;tiledBacking())
 982         backing-&gt;setTileSizeUpdateDelayDisabledForTesting(true);
 983 }
 984 
 985 void Internals::setSpeculativeTilingDelayDisabledForTesting(bool disabled)
 986 {
 987     Document* document = contextDocument();
 988     if (!document || !document-&gt;frame())
</pre>
<hr />
<pre>
1410     case WebCore::EventThrottlingBehavior::Unresponsive:
1411         return Internals::EventThrottlingBehavior::Unresponsive;
1412     }
1413 
1414     return WTF::nullopt;
1415 }
1416 
1417 String Internals::visiblePlaceholder(Element&amp; element)
1418 {
1419     if (is&lt;HTMLTextFormControlElement&gt;(element)) {
1420         const HTMLTextFormControlElement&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(element);
1421         if (!textFormControlElement.isPlaceholderVisible())
1422             return String();
1423         if (HTMLElement* placeholderElement = textFormControlElement.placeholderElement())
1424             return placeholderElement-&gt;textContent();
1425     }
1426 
1427     return String();
1428 }
1429 
<span class="line-added">1430 void Internals::setCanShowPlaceholder(Element&amp; element, bool canShowPlaceholder)</span>
<span class="line-added">1431 {</span>
<span class="line-added">1432     if (is&lt;HTMLTextFormControlElement&gt;(element))</span>
<span class="line-added">1433         downcast&lt;HTMLTextFormControlElement&gt;(element).setCanShowPlaceholder(canShowPlaceholder);</span>
<span class="line-added">1434 }</span>
<span class="line-added">1435 </span>
1436 void Internals::selectColorInColorChooser(HTMLInputElement&amp; element, const String&amp; colorValue)
1437 {
1438     element.selectColor(colorValue);
1439 }
1440 
1441 ExceptionOr&lt;Vector&lt;String&gt;&gt; Internals::formControlStateOfPreviousHistoryItem()
1442 {
1443     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1444     if (!mainItem)
1445         return Exception { InvalidAccessError };
1446     String uniqueName = frame()-&gt;tree().uniqueName();
1447     if (mainItem-&gt;target() != uniqueName &amp;&amp; !mainItem-&gt;childItemWithTarget(uniqueName))
1448         return Exception { InvalidAccessError };
1449     return Vector&lt;String&gt; { mainItem-&gt;target() == uniqueName ? mainItem-&gt;documentState() : mainItem-&gt;childItemWithTarget(uniqueName)-&gt;documentState() };
1450 }
1451 
1452 ExceptionOr&lt;void&gt; Internals::setFormControlStateOfPreviousHistoryItem(const Vector&lt;String&gt;&amp; state)
1453 {
1454     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1455     if (!mainItem)
</pre>
<hr />
<pre>
1475     if (!synthesis)
1476         return;
1477 
1478     synthesis-&gt;setPlatformSynthesizer(makeUnique&lt;PlatformSpeechSynthesizerMock&gt;(synthesis));
1479 }
1480 
1481 #endif
1482 
1483 #if ENABLE(WEB_RTC)
1484 
1485 void Internals::emulateRTCPeerConnectionPlatformEvent(RTCPeerConnection&amp; connection, const String&amp; action)
1486 {
1487     if (!LibWebRTCProvider::webRTCAvailable())
1488         return;
1489 
1490     connection.emulatePlatformEvent(action);
1491 }
1492 
1493 void Internals::useMockRTCPeerConnectionFactory(const String&amp; testCase)
1494 {

1495     if (!LibWebRTCProvider::webRTCAvailable())
1496         return;
1497 
1498 #if USE(LIBWEBRTC)
1499     Document* document = contextDocument();
1500     LibWebRTCProvider* provider = (document &amp;&amp; document-&gt;page()) ? &amp;document-&gt;page()-&gt;libWebRTCProvider() : nullptr;
1501     WebCore::useMockRTCPeerConnectionFactory(provider, testCase);
1502 #else
1503     UNUSED_PARAM(testCase);
1504 #endif
1505 }
1506 
1507 void Internals::setICECandidateFiltering(bool enabled)
1508 {
1509     auto* page = contextDocument()-&gt;page();
1510     if (!page)
1511         return;
1512 
1513     auto&amp; rtcController = page-&gt;rtcController();
1514     if (enabled)
</pre>
<hr />
<pre>
1543 void Internals::clearPeerConnectionFactory()
1544 {
1545 #if USE(LIBWEBRTC)
1546     if (auto* page = contextDocument()-&gt;page())
1547         page-&gt;libWebRTCProvider().clearFactory();
1548 #endif
1549 }
1550 
1551 void Internals::applyRotationForOutgoingVideoSources(RTCPeerConnection&amp; connection)
1552 {
1553     connection.applyRotationForOutgoingVideoSources();
1554 }
1555 
1556 void Internals::setEnableWebRTCEncryption(bool value)
1557 {
1558 #if USE(LIBWEBRTC)
1559     if (auto* page = contextDocument()-&gt;page())
1560         page-&gt;settings().setWebRTCEncryptionEnabled(value);
1561 #endif
1562 }
<span class="line-added">1563 </span>
<span class="line-added">1564 void Internals::setUseDTLS10(bool useDTLS10)</span>
<span class="line-added">1565 {</span>
<span class="line-added">1566 #if USE(LIBWEBRTC)</span>
<span class="line-added">1567     auto* document = contextDocument();</span>
<span class="line-added">1568     if (!document || !document-&gt;page())</span>
<span class="line-added">1569         return;</span>
<span class="line-added">1570     document-&gt;page()-&gt;libWebRTCProvider().setUseDTLS10(useDTLS10);</span>
1571 #endif
<span class="line-added">1572 }</span>
1573 
<span class="line-modified">1574 void Internals::setUseGPUProcessForWebRTC(bool useGPUProcess)</span>

1575 {
<span class="line-modified">1576 #if USE(LIBWEBRTC)</span>
<span class="line-added">1577     auto* document = contextDocument();</span>
<span class="line-added">1578     if (!document || !document-&gt;page())</span>
<span class="line-added">1579         return;</span>
<span class="line-added">1580 </span>
<span class="line-added">1581     document-&gt;page()-&gt;libWebRTCProvider().setUseGPUProcess(useGPUProcess);</span>
<span class="line-added">1582     document-&gt;page()-&gt;mediaRecorderProvider().setUseGPUProcess(useGPUProcess);</span>
<span class="line-added">1583 #endif</span>
1584 }
<span class="line-added">1585 #endif</span>
1586 
<span class="line-modified">1587 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">1588 void Internals::setShouldInterruptAudioOnPageVisibilityChange(bool shouldInterrupt)</span>
1589 {
<span class="line-modified">1590     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(shouldInterrupt);</span>


1591 }
1592 
1593 void Internals::setMediaCaptureRequiresSecureConnection(bool enabled)
1594 {
1595     Document* document = contextDocument();
1596     if (auto* page = document-&gt;page())
1597         page-&gt;settings().setMediaCaptureRequiresSecureConnection(enabled);
1598 }
1599 
1600 static std::unique_ptr&lt;MediaRecorderPrivate&gt; createRecorderMockSource()
1601 {
1602     return std::unique_ptr&lt;MediaRecorderPrivateMock&gt;(new MediaRecorderPrivateMock);
1603 }
1604 
1605 void Internals::setCustomPrivateRecorderCreator()
1606 {
1607     WebCore::MediaRecorder::setCustomPrivateRecorderCreator(createRecorderMockSource);
1608 }
1609 
1610 #endif
</pre>
<hr />
<pre>
1687 ExceptionOr&lt;String&gt; Internals::markerDescriptionForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1688 {
1689     auto result = markerAt(node, markerType, index);
1690     if (result.hasException())
1691         return result.releaseException();
1692     auto marker = result.releaseReturnValue();
1693     if (!marker)
1694         return String();
1695     return String { marker-&gt;description() };
1696 }
1697 
1698 ExceptionOr&lt;String&gt; Internals::dumpMarkerRects(const String&amp; markerTypeString)
1699 {
1700     DocumentMarker::MarkerType markerType;
1701     if (!markerTypeFrom(markerTypeString, markerType))
1702         return Exception { SyntaxError };
1703 
1704     contextDocument()-&gt;markers().updateRectsForInvalidatedMarkersOfType(markerType);
1705     auto rects = contextDocument()-&gt;markers().renderedRectsForMarkers(markerType);
1706 
<span class="line-added">1707     // FIXME: Using fixed precision here for width because of test results that contain numbers with specific precision. Would be nice to update the test results and move to default formatting.</span>
1708     StringBuilder rectString;
1709     rectString.appendLiteral(&quot;marker rects: &quot;);
<span class="line-modified">1710     for (const auto&amp; rect : rects)</span>
<span class="line-modified">1711         rectString.append(&#39;(&#39;, rect.x(), &quot;, &quot;, rect.y(), &quot;, &quot;, FormattedNumber::fixedPrecision(rect.width()), &quot;, &quot;, rect.height(), &quot;) &quot;);</span>









1712     return rectString.toString();
1713 }
1714 
1715 void Internals::addTextMatchMarker(const Range&amp; range, bool isActive)
1716 {
1717     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1718     range.ownerDocument().markers().addTextMatchMarker(range, isActive);
1719 }
1720 
1721 ExceptionOr&lt;void&gt; Internals::setMarkedTextMatchesAreHighlighted(bool flag)
1722 {
1723     Document* document = contextDocument();
1724     if (!document || !document-&gt;frame())
1725         return Exception { InvalidAccessError };
1726     document-&gt;frame()-&gt;editor().setMarkedTextMatchesAreHighlighted(flag);
1727     return { };
1728 }
1729 
1730 void Internals::invalidateFontCache()
1731 {
</pre>
<hr />
<pre>
1759     auto&amp; frameView = *document-&gt;view();
1760     bool constrainsScrollingToContentEdgeOldValue = frameView.constrainsScrollingToContentEdge();
1761     bool scrollbarsSuppressedOldValue = frameView.scrollbarsSuppressed();
1762 
1763     frameView.setConstrainsScrollingToContentEdge(false);
1764     frameView.setScrollbarsSuppressed(false);
1765     frameView.setScrollOffsetFromInternals({ x, y });
1766     frameView.setScrollbarsSuppressed(scrollbarsSuppressedOldValue);
1767     frameView.setConstrainsScrollingToContentEdge(constrainsScrollingToContentEdgeOldValue);
1768 
1769     return { };
1770 }
1771 
1772 ExceptionOr&lt;void&gt; Internals::unconstrainedScrollTo(Element&amp; element, double x, double y)
1773 {
1774     Document* document = contextDocument();
1775     if (!document || !document-&gt;view())
1776         return Exception { InvalidAccessError };
1777 
1778     element.scrollTo({ x, y }, ScrollClamping::Unclamped);
<span class="line-added">1779 </span>
<span class="line-added">1780     auto&amp; frameView = *document-&gt;view();</span>
<span class="line-added">1781     frameView.setViewportConstrainedObjectsNeedLayout();</span>
<span class="line-added">1782 </span>
1783     return { };
1784 }
1785 
1786 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::layoutViewportRect()
1787 {
1788     Document* document = contextDocument();
1789     if (!document || !document-&gt;frame())
1790         return Exception { InvalidAccessError };
1791 
1792     document-&gt;updateLayoutIgnorePendingStylesheets();
1793 
1794     auto&amp; frameView = *document-&gt;view();
1795     return DOMRect::create(frameView.layoutViewportRect());
1796 }
1797 
1798 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::visualViewportRect()
1799 {
1800     Document* document = contextDocument();
1801     if (!document || !document-&gt;frame())
1802         return Exception { InvalidAccessError };
</pre>
<hr />
<pre>
1876     Document* document = contextDocument();
1877     if (!document || !document-&gt;page())
1878         return Exception { InvalidAccessError };
1879     document-&gt;page()-&gt;setPaginationLineGridEnabled(enabled);
1880     return { };
1881 }
1882 
1883 ExceptionOr&lt;String&gt; Internals::configurationForViewport(float devicePixelRatio, int deviceWidth, int deviceHeight, int availableWidth, int availableHeight)
1884 {
1885     Document* document = contextDocument();
1886     if (!document || !document-&gt;page())
1887         return Exception { InvalidAccessError };
1888 
1889     const int defaultLayoutWidthForNonMobilePages = 980;
1890 
1891     ViewportArguments arguments = document-&gt;page()-&gt;viewportArguments();
1892     ViewportAttributes attributes = computeViewportAttributes(arguments, defaultLayoutWidthForNonMobilePages, deviceWidth, deviceHeight, devicePixelRatio, IntSize(availableWidth, availableHeight));
1893     restrictMinimumScaleFactorToViewportSize(attributes, IntSize(availableWidth, availableHeight), devicePixelRatio);
1894     restrictScaleFactorToInitialScaleIfNotUserScalable(attributes);
1895 
<span class="line-added">1896     // FIXME: Using fixed precision here because of test results that contain numbers with specific precision. Would be nice to update the test results and move to default formatting.</span>
1897     return makeString(&quot;viewport size &quot;, FormattedNumber::fixedPrecision(attributes.layoutSize.width()), &#39;x&#39;, FormattedNumber::fixedPrecision(attributes.layoutSize.height()), &quot; scale &quot;, FormattedNumber::fixedPrecision(attributes.initialScale), &quot; with limits [&quot;, FormattedNumber::fixedPrecision(attributes.minimumScale), &quot;, &quot;, FormattedNumber::fixedPrecision(attributes.maximumScale), &quot;] and userScalable &quot;, (attributes.userScalable ? &quot;true&quot; : &quot;false&quot;));
1898 }
1899 
1900 ExceptionOr&lt;bool&gt; Internals::wasLastChangeUserEdit(Element&amp; textField)
1901 {
1902     if (is&lt;HTMLInputElement&gt;(textField))
1903         return downcast&lt;HTMLInputElement&gt;(textField).lastChangeWasUserEdit();
1904 
1905     if (is&lt;HTMLTextAreaElement&gt;(textField))
1906         return downcast&lt;HTMLTextAreaElement&gt;(textField).lastChangeWasUserEdit();
1907 
1908     return Exception { InvalidNodeTypeError };
1909 }
1910 
1911 bool Internals::elementShouldAutoComplete(HTMLInputElement&amp; element)
1912 {
1913     return element.shouldAutocomplete();
1914 }
1915 
1916 void Internals::setAutofilled(HTMLInputElement&amp; element, bool enabled)
</pre>
<hr />
<pre>
2204     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
2205     {
2206         ++m_iterations;
2207         if (m_iterations &lt; 2)
2208             return StackVisitor::Continue;
2209 
2210         m_codeBlock = visitor-&gt;codeBlock();
2211         return StackVisitor::Done;
2212     }
2213 
2214     CodeBlock* codeBlock() const { return m_codeBlock; }
2215 
2216 private:
2217     mutable int m_iterations;
2218     mutable CodeBlock* m_codeBlock;
2219 };
2220 
2221 String Internals::parserMetaData(JSC::JSValue code)
2222 {
2223     JSC::VM&amp; vm = contextDocument()-&gt;vm();
<span class="line-modified">2224     JSC::CallFrame* callFrame = vm.topCallFrame;</span>
<span class="line-added">2225     JSC::JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject(vm);</span>
2226     ScriptExecutable* executable;
2227 
2228     if (!code || code.isNull() || code.isUndefined()) {
2229         GetCallerCodeBlockFunctor iter;
<span class="line-modified">2230         callFrame-&gt;iterate(vm, iter);</span>
2231         CodeBlock* codeBlock = iter.codeBlock();
2232         executable = codeBlock-&gt;ownerExecutable();
2233     } else if (code.isFunction(vm)) {
<span class="line-modified">2234         JSFunction* funcObj = JSC::jsCast&lt;JSFunction*&gt;(code.toObject(globalObject));</span>
2235         executable = funcObj-&gt;jsExecutable();
2236     } else
2237         return String();
2238 
2239     unsigned startLine = executable-&gt;firstLine();
2240     unsigned startColumn = executable-&gt;startColumn();
2241     unsigned endLine = executable-&gt;lastLine();
2242     unsigned endColumn = executable-&gt;endColumn();
2243 
2244     StringBuilder result;
2245 
2246     if (executable-&gt;isFunctionExecutable()) {
2247         FunctionExecutable* funcExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
2248         String inferredName = funcExecutable-&gt;ecmaName().string();
2249         result.appendLiteral(&quot;function \&quot;&quot;);
2250         result.append(inferredName);
2251         result.append(&#39;&quot;&#39;);
2252     } else if (executable-&gt;isEvalExecutable())
2253         result.appendLiteral(&quot;eval&quot;);
2254     else if (executable-&gt;isModuleProgramExecutable())
</pre>
<hr />
<pre>
2477     bool mark = markMatches == &quot;mark&quot;;
2478     return document-&gt;frame()-&gt;editor().countMatchesForText(text, nullptr, parsedOptions.releaseReturnValue(), 1000, mark, nullptr);
2479 }
2480 
2481 ExceptionOr&lt;unsigned&gt; Internals::countFindMatches(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions)
2482 {
2483     Document* document = contextDocument();
2484     if (!document || !document-&gt;page())
2485         return Exception { InvalidAccessError };
2486 
2487     auto parsedOptions = parseFindOptions(findOptions);
2488     if (parsedOptions.hasException())
2489         return parsedOptions.releaseException();
2490 
2491     return document-&gt;page()-&gt;countFindMatches(text, parsedOptions.releaseReturnValue(), 1000);
2492 }
2493 
2494 #if ENABLE(INDEXED_DATABASE)
2495 unsigned Internals::numberOfIDBTransactions() const
2496 {
<span class="line-added">2497 #if ENABLE(INDEXED_DATABASE)</span>
2498     return IDBTransaction::numberOfIDBTransactions;
<span class="line-added">2499 #else</span>
<span class="line-added">2500     return 0;</span>
<span class="line-added">2501 #endif</span>
2502 }
2503 #endif
2504 
2505 unsigned Internals::numberOfLiveNodes() const
2506 {
2507     unsigned nodeCount = 0;
2508     for (auto* document : Document::allDocuments())
2509         nodeCount += document-&gt;referencingNodeCount();
2510     return nodeCount;
2511 }
2512 
2513 unsigned Internals::numberOfLiveDocuments() const
2514 {
2515     return Document::allDocuments().size();
2516 }
2517 
2518 unsigned Internals::referencingNodeCount(const Document&amp; document) const
2519 {
2520     return document.referencingNodeCount();
2521 }
2522 
2523 #if ENABLE(INTERSECTION_OBSERVER)
2524 unsigned Internals::numberOfIntersectionObservers(const Document&amp; document) const
2525 {
2526     return document.numberOfIntersectionObservers();
2527 }
2528 #endif
2529 
2530 uint64_t Internals::documentIdentifier(const Document&amp; document) const
2531 {
2532     return document.identifier().toUInt64();
2533 }
2534 
2535 bool Internals::isDocumentAlive(uint64_t documentIdentifier) const
2536 {
2537     return Document::allDocumentsMap().contains(makeObjectIdentifier&lt;DocumentIdentifierType&gt;(documentIdentifier));
2538 }
2539 
<span class="line-added">2540 uint64_t Internals::storageAreaMapCount() const</span>
<span class="line-added">2541 {</span>
<span class="line-added">2542     auto* page = contextDocument() ? contextDocument()-&gt;page() : nullptr;</span>
<span class="line-added">2543     if (!page)</span>
<span class="line-added">2544         return 0;</span>
<span class="line-added">2545 </span>
<span class="line-added">2546     return page-&gt;storageNamespaceProvider().localStorageNamespace(page-&gt;sessionID()).storageAreaMapCountForTesting();</span>
<span class="line-added">2547 }</span>
<span class="line-added">2548 </span>
<span class="line-added">2549 uint64_t Internals::elementIdentifier(Element&amp; element) const</span>
<span class="line-added">2550 {</span>
<span class="line-added">2551     return element.document().identifierForElement(element).toUInt64();</span>
<span class="line-added">2552 }</span>
<span class="line-added">2553 </span>
<span class="line-added">2554 uint64_t Internals::frameIdentifier(const Document&amp; document) const</span>
<span class="line-added">2555 {</span>
<span class="line-added">2556     if (auto* page = document.page())</span>
<span class="line-added">2557         return page-&gt;mainFrame().loader().client().frameID().valueOr(FrameIdentifier { }).toUInt64();</span>
<span class="line-added">2558     return 0;</span>
<span class="line-added">2559 }</span>
<span class="line-added">2560 </span>
<span class="line-added">2561 uint64_t Internals::pageIdentifier(const Document&amp; document) const</span>
<span class="line-added">2562 {</span>
<span class="line-added">2563     return document.pageID().valueOr(PageIdentifier { }).toUInt64();</span>
<span class="line-added">2564 }</span>
<span class="line-added">2565 </span>
2566 bool Internals::isAnyWorkletGlobalScopeAlive() const
2567 {
2568 #if ENABLE(CSS_PAINTING_API)
2569     return !WorkletGlobalScope::allWorkletGlobalScopesSet().isEmpty();
2570 #else
2571     return false;
2572 #endif
2573 }
2574 
2575 String Internals::serviceWorkerClientIdentifier(const Document&amp; document) const
2576 {
2577 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">2578     return ServiceWorkerClientIdentifier { ServiceWorkerProvider::singleton().serviceWorkerConnection().serverConnectionIdentifier(), document.identifier() }.toString();</span>
2579 #else
2580     UNUSED_PARAM(document);
2581     return String();
2582 #endif
2583 }
2584 
2585 RefPtr&lt;WindowProxy&gt; Internals::openDummyInspectorFrontend(const String&amp; url)
2586 {
2587     auto* inspectedPage = contextDocument()-&gt;frame()-&gt;page();
2588     auto* window = inspectedPage-&gt;mainFrame().document()-&gt;domWindow();
2589     auto frontendWindowProxy = window-&gt;open(*window, *window, url, &quot;&quot;, &quot;&quot;).releaseReturnValue();
2590     m_inspectorFrontend = makeUnique&lt;InspectorStubFrontend&gt;(*inspectedPage, downcast&lt;DOMWindow&gt;(frontendWindowProxy-&gt;window()));
2591     return frontendWindowProxy;
2592 }
2593 
2594 void Internals::closeDummyInspectorFrontend()
2595 {
2596     m_inspectorFrontend = nullptr;
2597 }
2598 
</pre>
<hr />
<pre>
2649     if (flags &amp; Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS)
2650         layerTreeFlags |= LayerTreeFlagsIncludeVisibleRects;
2651     if (flags &amp; Internals::LAYER_TREE_INCLUDES_TILE_CACHES)
2652         layerTreeFlags |= LayerTreeFlagsIncludeTileCaches;
2653     if (flags &amp; Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS)
2654         layerTreeFlags |= LayerTreeFlagsIncludeRepaintRects;
2655     if (flags &amp; Internals::LAYER_TREE_INCLUDES_PAINTING_PHASES)
2656         layerTreeFlags |= LayerTreeFlagsIncludePaintingPhases;
2657     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CONTENT_LAYERS)
2658         layerTreeFlags |= LayerTreeFlagsIncludeContentLayers;
2659     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ACCELERATES_DRAWING)
2660         layerTreeFlags |= LayerTreeFlagsIncludeAcceleratesDrawing;
2661     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CLIPPING)
2662         layerTreeFlags |= LayerTreeFlagsIncludeClipping;
2663     if (flags &amp; Internals::LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED)
2664         layerTreeFlags |= LayerTreeFlagsIncludeBackingStoreAttached;
2665     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES)
2666         layerTreeFlags |= LayerTreeFlagsIncludeRootLayerProperties;
2667     if (flags &amp; Internals::LAYER_TREE_INCLUDES_EVENT_REGION)
2668         layerTreeFlags |= LayerTreeFlagsIncludeEventRegion;
<span class="line-added">2669     if (flags &amp; Internals::LAYER_TREE_INCLUDES_DEEP_COLOR)</span>
<span class="line-added">2670         layerTreeFlags |= LayerTreeFlagsIncludeDeepColor;</span>
2671 
2672     return layerTreeFlags;
2673 }
2674 
2675 // FIXME: Remove the document argument. It is almost always the same as
2676 // contextDocument(), with the exception of a few tests that pass a
2677 // different document, and could just make the call through another Internals
2678 // instance instead.
2679 ExceptionOr&lt;String&gt; Internals::layerTreeAsText(Document&amp; document, unsigned short flags) const
2680 {
2681     if (!document.frame())
2682         return Exception { InvalidAccessError };
2683 
2684     document.updateLayoutIgnorePendingStylesheets();
2685     return document.frame()-&gt;layerTreeAsText(toLayerTreeFlags(flags));
2686 }
2687 
2688 ExceptionOr&lt;uint64_t&gt; Internals::layerIDForElement(Element&amp; element)
2689 {
2690     Document* document = contextDocument();
</pre>
<hr />
<pre>
3201 }
3202 
3203 void Internals::setFullscreenControlsHidden(bool hidden)
3204 {
3205     Page* page = contextDocument()-&gt;frame()-&gt;page();
3206     ASSERT(page);
3207 
3208     page-&gt;setFullscreenControlsHidden(hidden);
3209 }
3210 
3211 void Internals::setApplicationCacheOriginQuota(unsigned long long quota)
3212 {
3213     Document* document = contextDocument();
3214     if (!document || !document-&gt;page())
3215         return;
3216     document-&gt;page()-&gt;applicationCacheStorage().storeUpdatedQuotaForOrigin(&amp;document-&gt;securityOrigin(), quota);
3217 }
3218 
3219 void Internals::registerURLSchemeAsBypassingContentSecurityPolicy(const String&amp; scheme)
3220 {
<span class="line-modified">3221     LegacySchemeRegistry::registerURLSchemeAsBypassingContentSecurityPolicy(scheme);</span>
3222 }
3223 
3224 void Internals::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(const String&amp; scheme)
3225 {
<span class="line-modified">3226     LegacySchemeRegistry::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);</span>
3227 }
3228 
3229 void Internals::registerDefaultPortForProtocol(unsigned short port, const String&amp; protocol)
3230 {
3231     registerDefaultPortForProtocolForTesting(port, protocol);
3232 }
3233 
3234 Ref&lt;MallocStatistics&gt; Internals::mallocStatistics() const
3235 {
3236     return MallocStatistics::create();
3237 }
3238 
3239 Ref&lt;TypeConversions&gt; Internals::typeConversions() const
3240 {
3241     return TypeConversions::create();
3242 }
3243 
3244 Ref&lt;MemoryInfo&gt; Internals::memoryInfo() const
3245 {
3246     return MemoryInfo::create();
</pre>
<hr />
<pre>
3452     case Cursor::Grab: return &quot;Grab&quot;;
3453     case Cursor::Grabbing: return &quot;Grabbing&quot;;
3454     case Cursor::Custom: return &quot;Custom&quot;;
3455     }
3456 
3457     ASSERT_NOT_REACHED();
3458     return &quot;UNKNOWN&quot;;
3459 }
3460 #endif
3461 
3462 ExceptionOr&lt;String&gt; Internals::getCurrentCursorInfo()
3463 {
3464     Document* document = contextDocument();
3465     if (!document || !document-&gt;frame())
3466         return Exception { InvalidAccessError };
3467 
3468 #if !PLATFORM(IOS_FAMILY)
3469     Cursor cursor = document-&gt;frame()-&gt;eventHandler().currentMouseCursor();
3470 
3471     StringBuilder result;
<span class="line-modified">3472     result.append(&quot;type=&quot;, cursorTypeToString(cursor.type()), &quot; hotSpot=&quot;, cursor.hotSpot().x(), &#39;,&#39;, cursor.hotSpot().y());</span>





3473     if (cursor.image()) {
3474         FloatSize size = cursor.image()-&gt;size();
<span class="line-modified">3475         result.append(&quot; image=&quot;, size.width(), &#39;x&#39;, size.height());</span>



3476     }
3477 #if ENABLE(MOUSE_CURSOR_SCALE)
<span class="line-modified">3478     if (cursor.imageScaleFactor() != 1)</span>
<span class="line-modified">3479         result.append(&quot; scale=&quot;, cursor.imageScaleFactor());</span>


3480 #endif
3481     return result.toString();
3482 #else
3483     return &quot;FAIL: Cursor details not available on this platform.&quot;_str;
3484 #endif
3485 }
3486 
3487 Ref&lt;ArrayBuffer&gt; Internals::serializeObject(const RefPtr&lt;SerializedScriptValue&gt;&amp; value) const
3488 {
3489     auto&amp; bytes = value-&gt;data();
3490     return ArrayBuffer::create(bytes.data(), bytes.size());
3491 }
3492 
3493 Ref&lt;SerializedScriptValue&gt; Internals::deserializeBuffer(ArrayBuffer&amp; buffer) const
3494 {
3495     Vector&lt;uint8_t&gt; bytes;
3496     bytes.append(static_cast&lt;const uint8_t*&gt;(buffer.data()), buffer.byteLength());
3497     return SerializedScriptValue::adopt(WTFMove(bytes));
3498 }
3499 
3500 bool Internals::isFromCurrentWorld(JSC::JSValue value) const
3501 {
<span class="line-modified">3502     JSC::VM&amp; vm = contextDocument()-&gt;vm();</span>
<span class="line-added">3503     return isWorldCompatible(*vm.topCallFrame-&gt;lexicalGlobalObject(vm), value);</span>
<span class="line-added">3504 }</span>
<span class="line-added">3505 </span>
<span class="line-added">3506 JSC::JSValue Internals::evaluateInWorldIgnoringException(const String&amp; name, const String&amp; source)</span>
<span class="line-added">3507 {</span>
<span class="line-added">3508     auto* document = contextDocument();</span>
<span class="line-added">3509     auto&amp; scriptController = document-&gt;frame()-&gt;script();</span>
<span class="line-added">3510     auto world = ScriptController::createWorld(name);</span>
<span class="line-added">3511     return scriptController.executeScriptInWorldIgnoringException(world, source);</span>
3512 }
3513 
3514 void Internals::setUsesOverlayScrollbars(bool enabled)
3515 {
3516     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(enabled);
3517 }
3518 
3519 void Internals::setUsesMockScrollAnimator(bool enabled)
3520 {
3521     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(enabled);
3522 }
3523 
3524 void Internals::forceReload(bool endToEnd)
3525 {
3526     OptionSet&lt;ReloadOption&gt; reloadOptions;
3527     if (endToEnd)
3528         reloadOptions.add(ReloadOption::FromOrigin);
3529 
3530     frame()-&gt;loader().reload(reloadOptions);
3531 }
</pre>
<hr />
<pre>
4098 
4099 void Internals::sendMediaControlEvent(MediaControlEvent event)
4100 {
4101     // FIXME: No good reason to use a single function with an argument instead of three functions.
4102     switch (event) {
4103     case MediControlEvent::PlayPause:
4104         MediaSessionManager::singleton().togglePlayback();
4105         break;
4106     case MediControlEvent::NextTrack:
4107         MediaSessionManager::singleton().skipToNextTrack();
4108         break;
4109     case MediControlEvent::PreviousTrack:
4110         MediaSessionManager::singleton().skipToPreviousTrack();
4111         break;
4112     }
4113 }
4114 
4115 #endif // ENABLE(MEDIA_SESSION)
4116 
4117 #if ENABLE(WEB_AUDIO)

4118 void Internals::setAudioContextRestrictions(AudioContext&amp; context, StringView restrictionsString)
4119 {
4120     AudioContext::BehaviorRestrictions restrictions = context.behaviorRestrictions();
4121     context.removeBehaviorRestriction(restrictions);
4122 
4123     restrictions = AudioContext::NoRestrictions;
4124 
4125     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
4126         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
4127             restrictions |= AudioContext::NoRestrictions;
4128         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudiostart&quot;))
4129             restrictions |= AudioContext::RequireUserGestureForAudioStartRestriction;
4130         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsentforaudiostart&quot;))
4131             restrictions |= AudioContext::RequirePageConsentForAudioStartRestriction;
4132     }
4133     context.addBehaviorRestriction(restrictions);
4134 }
4135 
<span class="line-added">4136 void Internals::useMockAudioDestinationCocoa()</span>
<span class="line-added">4137 {</span>
<span class="line-added">4138 #if PLATFORM(COCOA)</span>
<span class="line-added">4139     AudioDestinationCocoa::createOverride = MockAudioDestinationCocoa::create;</span>
<span class="line-added">4140 #endif</span>
<span class="line-added">4141 }</span>
4142 #endif
4143 
4144 void Internals::simulateSystemSleep() const
4145 {
4146 #if ENABLE(VIDEO)
4147     PlatformMediaSessionManager::sharedManager().systemWillSleep();
4148 #endif
4149 }
4150 
4151 void Internals::simulateSystemWake() const
4152 {
4153 #if ENABLE(VIDEO)
4154     PlatformMediaSessionManager::sharedManager().systemDidWake();
4155 #endif
4156 }
4157 
4158 ExceptionOr&lt;Internals::NowPlayingState&gt; Internals::nowPlayingState() const
4159 {
4160 #if ENABLE(VIDEO)
4161     return { { PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingTitle(),
</pre>
<hr />
<pre>
4195 ExceptionOr&lt;void&gt; Internals::setMockMediaPlaybackTargetPickerState(const String&amp; deviceName, const String&amp; deviceState)
4196 {
4197     Page* page = contextDocument()-&gt;frame()-&gt;page();
4198     ASSERT(page);
4199 
4200     MediaPlaybackTargetContext::State state = MediaPlaybackTargetContext::Unknown;
4201 
4202     if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceavailable&quot;))
4203         state = MediaPlaybackTargetContext::OutputDeviceAvailable;
4204     else if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceunavailable&quot;))
4205         state = MediaPlaybackTargetContext::OutputDeviceUnavailable;
4206     else if (equalLettersIgnoringASCIICase(deviceState, &quot;unknown&quot;))
4207         state = MediaPlaybackTargetContext::Unknown;
4208     else
4209         return Exception { InvalidAccessError };
4210 
4211     page-&gt;setMockMediaPlaybackTargetPickerState(deviceName, state);
4212     return { };
4213 }
4214 
<span class="line-added">4215 void Internals::mockMediaPlaybackTargetPickerDismissPopup()</span>
<span class="line-added">4216 {</span>
<span class="line-added">4217     auto* page = contextDocument()-&gt;frame()-&gt;page();</span>
<span class="line-added">4218     ASSERT(page);</span>
<span class="line-added">4219 </span>
<span class="line-added">4220     page-&gt;mockMediaPlaybackTargetPickerDismissPopup();</span>
<span class="line-added">4221 }</span>
<span class="line-added">4222 </span>
4223 #endif
4224 
4225 ExceptionOr&lt;Ref&lt;MockPageOverlay&gt;&gt; Internals::installMockPageOverlay(PageOverlayType type)
4226 {
4227     Document* document = contextDocument();
4228     if (!document || !document-&gt;page())
4229         return Exception { InvalidAccessError };
4230 
4231     return MockPageOverlayClient::singleton().installOverlay(*document-&gt;page(), type == PageOverlayType::View ? PageOverlay::OverlayType::View : PageOverlay::OverlayType::Document);
4232 }
4233 
4234 ExceptionOr&lt;String&gt; Internals::pageOverlayLayerTreeAsText(unsigned short flags) const
4235 {
4236     Document* document = contextDocument();
4237     if (!document || !document-&gt;page())
4238         return Exception { InvalidAccessError };
4239 
4240     document-&gt;updateLayoutIgnorePendingStylesheets();
4241 
4242     return MockPageOverlayClient::singleton().layerTreeAsText(*document-&gt;page(), toLayerTreeFlags(flags));
</pre>
<hr />
<pre>
4327 }
4328 
4329 ExceptionOr&lt;bool&gt; Internals::pageDefersLoading()
4330 {
4331     Document* document = contextDocument();
4332     if (!document || !document-&gt;page())
4333         return Exception { InvalidAccessError };
4334     return document-&gt;page()-&gt;defersLoading();
4335 }
4336 
4337 RefPtr&lt;File&gt; Internals::createFile(const String&amp; path)
4338 {
4339     Document* document = contextDocument();
4340     if (!document)
4341         return nullptr;
4342 
4343     URL url = document-&gt;completeURL(path);
4344     if (!url.isLocalFile())
4345         return nullptr;
4346 
<span class="line-modified">4347     return File::create(url.fileSystemPath());</span>
4348 }
4349 
4350 void Internals::queueMicroTask(int testNumber)
4351 {
4352     Document* document = contextDocument();
4353     if (!document)
4354         return;
4355 
<span class="line-modified">4356     ScriptExecutionContext* context = document;</span>
<span class="line-added">4357     auto&amp; eventLoop = context-&gt;eventLoop();</span>
<span class="line-added">4358     eventLoop.queueMicrotask([document = makeRef(*document), testNumber]() {</span>
4359         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Debug, makeString(&quot;MicroTask #&quot;, testNumber, &quot; has run.&quot;));
4360     });


4361 }
4362 
4363 #if ENABLE(CONTENT_FILTERING)
4364 
4365 MockContentFilterSettings&amp; Internals::mockContentFilterSettings()
4366 {
4367     return MockContentFilterSettings::singleton();
4368 }
4369 
4370 #endif
4371 
4372 #if ENABLE(CSS_SCROLL_SNAP)
4373 
4374 static void appendOffsets(StringBuilder&amp; builder, const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
4375 {
4376     bool justStarting = true;
4377 
4378     builder.appendLiteral(&quot;{ &quot;);
4379     for (auto&amp; coordinate : snapOffsets) {
4380         if (!justStarting)
</pre>
<hr />
<pre>
4441 
4442 #endif
4443 
4444 bool Internals::testPreloaderSettingViewport()
4445 {
4446     return testPreloadScannerViewportSupport(contextDocument());
4447 }
4448 
4449 ExceptionOr&lt;String&gt; Internals::pathStringWithShrinkWrappedRects(const Vector&lt;double&gt;&amp; rectComponents, double radius)
4450 {
4451     if (rectComponents.size() % 4)
4452         return Exception { InvalidAccessError };
4453 
4454     Vector&lt;FloatRect&gt; rects;
4455     for (unsigned i = 0; i &lt; rectComponents.size(); i += 4)
4456         rects.append(FloatRect(rectComponents[i], rectComponents[i + 1], rectComponents[i + 2], rectComponents[i + 3]));
4457 
4458     SVGPathStringBuilder builder;
4459     PathUtilities::pathWithShrinkWrappedRects(rects, radius).apply([&amp;builder](const PathElement&amp; element) {
4460         switch (element.type) {
<span class="line-modified">4461         case PathElement::Type::MoveToPoint:</span>
4462             builder.moveTo(element.points[0], false, AbsoluteCoordinates);
4463             return;
<span class="line-modified">4464         case PathElement::Type::AddLineToPoint:</span>
4465             builder.lineTo(element.points[0], AbsoluteCoordinates);
4466             return;
<span class="line-modified">4467         case PathElement::Type::AddQuadCurveToPoint:</span>
4468             builder.curveToQuadratic(element.points[0], element.points[1], AbsoluteCoordinates);
4469             return;
<span class="line-modified">4470         case PathElement::Type::AddCurveToPoint:</span>
4471             builder.curveToCubic(element.points[0], element.points[1], element.points[2], AbsoluteCoordinates);
4472             return;
<span class="line-modified">4473         case PathElement::Type::CloseSubpath:</span>
4474             builder.closePath();
4475             return;
4476         }
4477         ASSERT_NOT_REACHED();
4478     });
4479     return builder.result();
4480 }
4481 
4482 
4483 String Internals::getCurrentMediaControlsStatusForElement(HTMLMediaElement&amp; mediaElement)
4484 {
4485 #if !ENABLE(MEDIA_CONTROLS_SCRIPT)
4486     UNUSED_PARAM(mediaElement);
4487     return String();
4488 #else
4489     return mediaElement.getCurrentMediaControlsStatus();
4490 #endif
4491 }
4492 
4493 #if !PLATFORM(COCOA)
</pre>
<hr />
<pre>
4497     return WTF::URLHelpers::userVisibleURL(url.href().string().utf8());
4498 }
4499 
4500 #endif
4501 
4502 void Internals::setShowAllPlugins(bool show)
4503 {
4504     Document* document = contextDocument();
4505     if (!document)
4506         return;
4507 
4508     Page* page = document-&gt;page();
4509     if (!page)
4510         return;
4511 
4512     page-&gt;setShowAllPlugins(show);
4513 }
4514 
4515 #if ENABLE(STREAMS_API)
4516 
<span class="line-modified">4517 bool Internals::isReadableStreamDisturbed(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSValue stream)</span>
4518 {
<span class="line-modified">4519     return ReadableStream::isDisturbed(lexicalGlobalObject, stream);</span>
4520 }
4521 
<span class="line-modified">4522 JSValue Internals::cloneArrayBuffer(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSValue buffer, JSValue srcByteOffset, JSValue srcLength)</span>
4523 {
<span class="line-modified">4524     JSC::VM&amp; vm = lexicalGlobalObject.vm();</span>

4525     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
4526     const Identifier&amp; privateName = clientData-&gt;builtinNames().cloneArrayBufferPrivateName();
4527     JSValue value;
4528     PropertySlot propertySlot(value, PropertySlot::InternalMethodType::Get);
<span class="line-modified">4529     lexicalGlobalObject.methodTable(vm)-&gt;getOwnPropertySlot(&amp;lexicalGlobalObject, &amp;lexicalGlobalObject, privateName, propertySlot);</span>
<span class="line-modified">4530     value = propertySlot.getValue(&amp;lexicalGlobalObject, privateName);</span>
4531     ASSERT(value.isFunction(vm));
4532 
4533     JSObject* function = value.getObject();
4534     CallData callData;
4535     CallType callType = JSC::getCallData(vm, function, callData);
4536     ASSERT(callType != JSC::CallType::None);
4537     MarkedArgumentBuffer arguments;
4538     arguments.append(buffer);
4539     arguments.append(srcByteOffset);
4540     arguments.append(srcLength);
4541     ASSERT(!arguments.hasOverflowed());
4542 
<span class="line-modified">4543     return JSC::call(&amp;lexicalGlobalObject, function, callType, callData, JSC::jsUndefined(), arguments);</span>
4544 }
4545 
4546 #endif
4547 
4548 String Internals::resourceLoadStatisticsForURL(const DOMURL&amp; url)
4549 {
<span class="line-modified">4550     return ResourceLoadObserver::shared().statisticsForURL(url.href());</span>




4551 }
4552 
4553 void Internals::setResourceLoadStatisticsEnabled(bool enable)
4554 {
4555     DeprecatedGlobalSettings::setResourceLoadStatisticsEnabled(enable);
4556 }
4557 
4558 String Internals::composedTreeAsText(Node&amp; node)
4559 {
4560     if (!is&lt;ContainerNode&gt;(node))
4561         return emptyString();
4562     return WebCore::composedTreeAsText(downcast&lt;ContainerNode&gt;(node));
4563 }
4564 
4565 bool Internals::isProcessingUserGesture()
4566 {
4567     return UserGestureIndicator::processingUserGesture();
4568 }
4569 
4570 void Internals::withUserGesture(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
</pre>
<hr />
<pre>
4685     auto* document = contextDocument();
4686     if (!document)
4687         return;
4688 
4689     document-&gt;securityOrigin().setIsPotentiallyTrustworthy(false);
4690 }
4691 
4692 void Internals::postTask(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4693 {
4694     auto* document = contextDocument();
4695     if (!document) {
4696         callback-&gt;handleEvent();
4697         return;
4698     }
4699 
4700     document-&gt;postTask([callback = WTFMove(callback)](ScriptExecutionContext&amp;) {
4701         callback-&gt;handleEvent();
4702     });
4703 }
4704 
<span class="line-added">4705 static Optional&lt;TaskSource&gt; taskSourceFromString(const String&amp; taskSourceName)</span>
<span class="line-added">4706 {</span>
<span class="line-added">4707     if (taskSourceName == &quot;DOMManipulation&quot;)</span>
<span class="line-added">4708         return TaskSource::DOMManipulation;</span>
<span class="line-added">4709     return WTF::nullopt;</span>
<span class="line-added">4710 }</span>
<span class="line-added">4711 </span>
<span class="line-added">4712 ExceptionOr&lt;void&gt; Internals::queueTask(ScriptExecutionContext&amp; context, const String&amp; taskSourceName, RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)</span>
<span class="line-added">4713 {</span>
<span class="line-added">4714     auto source = taskSourceFromString(taskSourceName);</span>
<span class="line-added">4715     if (!source)</span>
<span class="line-added">4716         return Exception { NotSupportedError };</span>
<span class="line-added">4717 </span>
<span class="line-added">4718     context.eventLoop().queueTask(*source, [callback = WTFMove(callback)] {</span>
<span class="line-added">4719         callback-&gt;handleEvent();</span>
<span class="line-added">4720     });</span>
<span class="line-added">4721 </span>
<span class="line-added">4722     return { };</span>
<span class="line-added">4723 }</span>
<span class="line-added">4724 </span>
<span class="line-added">4725 ExceptionOr&lt;void&gt; Internals::queueTaskToQueueMicrotask(Document&amp; document, const String&amp; taskSourceName, RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)</span>
<span class="line-added">4726 {</span>
<span class="line-added">4727     auto source = taskSourceFromString(taskSourceName);</span>
<span class="line-added">4728     if (!source)</span>
<span class="line-added">4729         return Exception { NotSupportedError };</span>
<span class="line-added">4730 </span>
<span class="line-added">4731     ScriptExecutionContext&amp; context = document; // This avoids unnecessarily exporting Document::eventLoop.</span>
<span class="line-added">4732     context.eventLoop().queueTask(*source, [movedCallback = WTFMove(callback), protectedDocument = makeRef(document)]() mutable {</span>
<span class="line-added">4733         ScriptExecutionContext&amp; context = protectedDocument.get();</span>
<span class="line-added">4734         context.eventLoop().queueMicrotask([callback = WTFMove(movedCallback)] {</span>
<span class="line-added">4735             callback-&gt;handleEvent();</span>
<span class="line-added">4736         });</span>
<span class="line-added">4737     });</span>
<span class="line-added">4738 </span>
<span class="line-added">4739     return { };</span>
<span class="line-added">4740 }</span>
<span class="line-added">4741 </span>
<span class="line-added">4742 ExceptionOr&lt;bool&gt; Internals::hasSameEventLoopAs(WindowProxy&amp; proxy)</span>
<span class="line-added">4743 {</span>
<span class="line-added">4744     RefPtr&lt;ScriptExecutionContext&gt; context = contextDocument();</span>
<span class="line-added">4745     if (!context || !proxy.frame())</span>
<span class="line-added">4746         return Exception { InvalidStateError };</span>
<span class="line-added">4747 </span>
<span class="line-added">4748     auto&amp; proxyFrame = *proxy.frame();</span>
<span class="line-added">4749     if (!is&lt;Frame&gt;(proxyFrame))</span>
<span class="line-added">4750         return false;</span>
<span class="line-added">4751     RefPtr&lt;ScriptExecutionContext&gt; proxyContext = downcast&lt;Frame&gt;(proxyFrame).document();</span>
<span class="line-added">4752     if (!proxyContext)</span>
<span class="line-added">4753         return Exception { InvalidStateError };</span>
<span class="line-added">4754 </span>
<span class="line-added">4755     return context-&gt;eventLoop().hasSameEventLoopAs(proxyContext-&gt;eventLoop());</span>
<span class="line-added">4756 }</span>
<span class="line-added">4757 </span>
4758 Vector&lt;String&gt; Internals::accessKeyModifiers() const
4759 {
4760     Vector&lt;String&gt; accessKeyModifierStrings;
4761 
4762     for (auto modifier : EventHandler::accessKeyModifiers()) {
4763         switch (modifier) {
4764         case PlatformEvent::Modifier::AltKey:
4765             accessKeyModifierStrings.append(&quot;altKey&quot;_s);
4766             break;
4767         case PlatformEvent::Modifier::ControlKey:
4768             accessKeyModifierStrings.append(&quot;ctrlKey&quot;_s);
4769             break;
4770         case PlatformEvent::Modifier::MetaKey:
4771             accessKeyModifierStrings.append(&quot;metaKey&quot;_s);
4772             break;
4773         case PlatformEvent::Modifier::ShiftKey:
4774             accessKeyModifierStrings.append(&quot;shiftKey&quot;_s);
4775             break;
4776         case PlatformEvent::Modifier::CapsLockKey:
4777             accessKeyModifierStrings.append(&quot;capsLockKey&quot;_s);
4778             break;
4779         case PlatformEvent::Modifier::AltGraphKey:
4780             ASSERT_NOT_REACHED(); // AltGraph is only for DOM API.
4781             break;
4782         }
4783     }
4784 
4785     return accessKeyModifierStrings;
4786 }
4787 
4788 void Internals::setQuickLookPassword(const String&amp; password)
4789 {
4790 #if PLATFORM(IOS_FAMILY) &amp;&amp; USE(QUICK_LOOK)
4791     auto&amp; quickLookHandleClient = MockPreviewLoaderClient::singleton();
<span class="line-modified">4792     LegacyPreviewLoader::setClientForTesting(&amp;quickLookHandleClient);</span>
4793     quickLookHandleClient.setPassword(password);
4794 #else
4795     UNUSED_PARAM(password);
4796 #endif
4797 }
4798 
4799 void Internals::setAsRunningUserScripts(Document&amp; document)
4800 {
4801     document.setAsRunningUserScripts();
4802 }
4803 
4804 #if ENABLE(APPLE_PAY)
4805 void Internals::setApplePayIsActive(Document&amp; document)
4806 {
4807     document.setApplePayIsActive();
4808 }
4809 #endif
4810 
4811 #if ENABLE(WEBGL)
4812 void Internals::simulateWebGLContextChanged(WebGLRenderingContext&amp; context)
</pre>
<hr />
<pre>
4880     downcast&lt;MockRealtimeAudioSource&gt;(source).setChannelCount(channelNumber);
4881 }
4882 
4883 void Internals::setCameraMediaStreamTrackOrientation(MediaStreamTrack&amp; track, int orientation)
4884 {
4885     auto&amp; source = track.source();
4886     if (!source.isCaptureSource())
4887         return;
4888     m_orientationNotifier.orientationChanged(orientation);
4889     source.monitorOrientation(m_orientationNotifier);
4890 }
4891 
4892 void Internals::observeMediaStreamTrack(MediaStreamTrack&amp; track)
4893 {
4894     m_track = &amp;track;
4895     m_track-&gt;source().addObserver(*this);
4896 }
4897 
4898 void Internals::grabNextMediaStreamTrackFrame(TrackFramePromise&amp;&amp; promise)
4899 {
<span class="line-modified">4900     m_nextTrackFramePromise = WTF::makeUnique&lt;TrackFramePromise&gt;(promise);</span>
4901 }
4902 
4903 void Internals::videoSampleAvailable(MediaSample&amp; sample)
4904 {
4905     m_trackVideoSampleCount++;
4906     if (!m_nextTrackFramePromise)
4907         return;
4908 
4909     auto&amp; videoSettings = m_track-&gt;source().settings();
4910     if (!videoSettings.width() || !videoSettings.height())
4911         return;
4912 
4913     auto rgba = sample.getRGBAImageData();
4914     if (!rgba)
4915         return;
4916 
4917     auto imageData = ImageData::create(rgba.releaseNonNull(), videoSettings.width(), videoSettings.height());
4918     if (!imageData.hasException())
4919         m_nextTrackFramePromise-&gt;resolve(imageData.releaseReturnValue().releaseNonNull());
4920     else
4921         m_nextTrackFramePromise-&gt;reject(imageData.exception().code());
<span class="line-modified">4922     m_nextTrackFramePromise = nullptr;</span>
4923 }
4924 
4925 void Internals::delayMediaStreamTrackSamples(MediaStreamTrack&amp; track, float delay)
4926 {
4927     track.source().delaySamples(Seconds { delay });
4928 }
4929 
4930 void Internals::setMediaStreamTrackMuted(MediaStreamTrack&amp; track, bool muted)
4931 {
4932     track.source().setMuted(muted);
4933 }
4934 
4935 void Internals::removeMediaStreamTrack(MediaStream&amp; stream, MediaStreamTrack&amp; track)
4936 {
4937     stream.internalRemoveTrack(track.id(), MediaStream::StreamModifier::Platform);
4938 }
4939 
4940 void Internals::simulateMediaStreamTrackCaptureSourceFailure(MediaStreamTrack&amp; track)
4941 {
4942     track.source().captureFailed();
4943 }
4944 
4945 void Internals::setMediaStreamTrackIdentifier(MediaStreamTrack&amp; track, String&amp;&amp; id)
4946 {
4947     track.setIdForTesting(WTFMove(id));
4948 }
4949 
4950 void Internals::setMediaStreamSourceInterrupted(MediaStreamTrack&amp; track, bool interrupted)
4951 {
4952     track.source().setInterruptedForTesting(interrupted);
4953 }
4954 
<span class="line-modified">4955 bool Internals::isMockRealtimeMediaSourceCenterEnabled()</span>
4956 {
<span class="line-modified">4957     return MockRealtimeMediaSourceCenter::mockRealtimeMediaSourceCenterEnabled();</span>





4958 }
4959 #endif
4960 
<span class="line-added">4961 bool Internals::supportsAudioSession() const</span>
<span class="line-added">4962 {</span>
<span class="line-added">4963 #if USE(AUDIO_SESSION)</span>
<span class="line-added">4964     return true;</span>
<span class="line-added">4965 #else</span>
<span class="line-added">4966     return false;</span>
<span class="line-added">4967 #endif</span>
<span class="line-added">4968 }</span>
<span class="line-added">4969 </span>
4970 String Internals::audioSessionCategory() const
4971 {
4972 #if USE(AUDIO_SESSION)
4973     switch (AudioSession::sharedSession().category()) {
4974     case AudioSession::AmbientSound:
4975         return &quot;AmbientSound&quot;_s;
4976     case AudioSession::SoloAmbientSound:
4977         return &quot;SoloAmbientSound&quot;_s;
4978     case AudioSession::MediaPlayback:
4979         return &quot;MediaPlayback&quot;_s;
4980     case AudioSession::RecordAudio:
4981         return &quot;RecordAudio&quot;_s;
4982     case AudioSession::PlayAndRecord:
4983         return &quot;PlayAndRecord&quot;_s;
4984     case AudioSession::AudioProcessing:
4985         return &quot;AudioProcessing&quot;_s;
4986     case AudioSession::None:
4987         return &quot;None&quot;_s;
4988     }
4989 #endif
</pre>
<hr />
<pre>
4995 #if USE(AUDIO_SESSION)
4996     return AudioSession::sharedSession().preferredBufferSize();
4997 #endif
4998     return 0;
4999 }
5000 
5001 bool Internals::audioSessionActive() const
5002 {
5003 #if USE(AUDIO_SESSION)
5004     return AudioSession::sharedSession().isActive();
5005 #endif
5006     return false;
5007 }
5008 
5009 void Internals::storeRegistrationsOnDisk(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
5010 {
5011 #if ENABLE(SERVICE_WORKER)
5012     if (!contextDocument())
5013         return;
5014 
<span class="line-modified">5015     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();</span>
5016     connection.storeRegistrationsOnDiskForTesting([promise = WTFMove(promise)]() mutable {
5017         promise.resolve();
5018     });
5019 #else
5020     promise.resolve();
5021 #endif
5022 }
5023 
5024 void Internals::clearCacheStorageMemoryRepresentation(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
5025 {
5026     auto* document = contextDocument();
5027     if (!document)
5028         return;
5029 
5030     if (!m_cacheStorageConnection) {
5031         if (auto* page = contextDocument()-&gt;page())
<span class="line-modified">5032             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection();</span>
5033         if (!m_cacheStorageConnection)
5034             return;
5035     }
5036     m_cacheStorageConnection-&gt;clearMemoryRepresentation(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() }, [promise = WTFMove(promise)] (auto &amp;&amp; result) mutable {
5037         ASSERT_UNUSED(result, !result);
5038         promise.resolve();
5039     });
5040 }
5041 
5042 void Internals::cacheStorageEngineRepresentation(DOMPromiseDeferred&lt;IDLDOMString&gt;&amp;&amp; promise)
5043 {
5044     auto* document = contextDocument();
5045     if (!document)
5046         return;
5047 
5048     if (!m_cacheStorageConnection) {
5049         if (auto* page = contextDocument()-&gt;page())
<span class="line-modified">5050             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection();</span>
5051         if (!m_cacheStorageConnection)
5052             return;
5053     }
5054     m_cacheStorageConnection-&gt;engineRepresentation([promise = WTFMove(promise)](const String&amp; result) mutable {
5055         promise.resolve(result);
5056     });
5057 }
5058 
5059 void Internals::updateQuotaBasedOnSpaceUsage()
5060 {
5061     auto* document = contextDocument();
5062     if (!document)
5063         return;
5064 
5065     if (!m_cacheStorageConnection) {
5066         if (auto* page = contextDocument()-&gt;page())
<span class="line-modified">5067             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection();</span>
5068         if (!m_cacheStorageConnection)
5069             return;
5070     }
5071 
5072     m_cacheStorageConnection-&gt;updateQuotaBasedOnSpaceUsage(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() });
5073 }
5074 
5075 void Internals::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
5076 {
5077     if (!contextDocument())
5078         return;
5079 
5080     contextDocument()-&gt;setConsoleMessageListener(WTFMove(listener));
5081 }
5082 
5083 void Internals::setResponseSizeWithPadding(FetchResponse&amp; response, uint64_t size)
5084 {
5085     response.setBodySizeWithPadding(size);
5086 }
5087 
5088 uint64_t Internals::responseSizeWithPadding(FetchResponse&amp; response) const
5089 {
5090     return response.bodySizeWithPadding();
5091 }
5092 
5093 #if ENABLE(SERVICE_WORKER)
5094 void Internals::hasServiceWorkerRegistration(const String&amp; clientURL, HasRegistrationPromise&amp;&amp; promise)
5095 {
5096     if (!contextDocument())
5097         return;
5098 
5099     URL parsedURL = contextDocument()-&gt;completeURL(clientURL);
5100 
<span class="line-modified">5101     return ServiceWorkerProvider::singleton().serviceWorkerConnection().matchRegistration(SecurityOriginData { contextDocument()-&gt;topOrigin().data() }, parsedURL, [promise = WTFMove(promise)] (auto&amp;&amp; result) mutable {</span>
5102         promise.resolve(!!result);
5103     });
5104 }
5105 
5106 void Internals::terminateServiceWorker(ServiceWorker&amp; worker)
5107 {
5108     if (!contextDocument())
5109         return;
5110 
<span class="line-modified">5111     ServiceWorkerProvider::singleton().serviceWorkerConnection().syncTerminateWorker(worker.identifier());</span>
5112 }
5113 
<span class="line-modified">5114 void Internals::isServiceWorkerRunning(ServiceWorker&amp; worker, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)</span>
5115 {
<span class="line-modified">5116     return ServiceWorkerProvider::singleton().serviceWorkerConnection().isServiceWorkerRunning(worker.identifier(), [promise = WTFMove(promise)](bool result) mutable {</span>
<span class="line-modified">5117         promise.resolve(result);</span>
<span class="line-modified">5118     });</span>

5119 }
5120 #endif
5121 
5122 #if ENABLE(APPLE_PAY)
5123 MockPaymentCoordinator&amp; Internals::mockPaymentCoordinator(Document&amp; document)
5124 {
5125     return downcast&lt;MockPaymentCoordinator&gt;(document.frame()-&gt;page()-&gt;paymentCoordinator().client());
5126 }
5127 #endif
5128 
5129 bool Internals::isSystemPreviewLink(Element&amp; element) const
5130 {
5131 #if USE(SYSTEM_PREVIEW)
5132     return is&lt;HTMLAnchorElement&gt;(element) &amp;&amp; downcast&lt;HTMLAnchorElement&gt;(element).isSystemPreviewLink();
5133 #else
5134     UNUSED_PARAM(element);
5135     return false;
5136 #endif
5137 }
5138 
</pre>
<hr />
<pre>
5223 
5224 bool Internals::capsLockIsOn()
5225 {
5226     return WebCore::PlatformKeyboardEvent::currentCapsLockState();
5227 }
5228 
5229 bool Internals::supportsVCPEncoder()
5230 {
5231 #if defined(ENABLE_VCP_ENCODER)
5232     return ENABLE_VCP_ENCODER || ENABLE_VCP_VTB_ENCODER;
5233 #else
5234     return false;
5235 #endif
5236 }
5237 
5238 Optional&lt;HEVCParameterSet&gt; Internals::parseHEVCCodecParameters(const String&amp; codecString)
5239 {
5240     return WebCore::parseHEVCCodecParameters(codecString);
5241 }
5242 
<span class="line-added">5243 Optional&lt;DoViParameterSet&gt; Internals::parseDoViCodecParameters(const String&amp; codecString)</span>
<span class="line-added">5244 {</span>
<span class="line-added">5245     return WebCore::parseDoViCodecParameters(codecString);</span>
<span class="line-added">5246 }</span>
<span class="line-added">5247 </span>
5248 auto Internals::getCookies() const -&gt; Vector&lt;CookieData&gt;
5249 {
5250     auto* document = contextDocument();
5251     if (!document)
5252         return { };
5253 
5254     auto* page = document-&gt;page();
5255     if (!page)
5256         return { };
5257 
5258     Vector&lt;Cookie&gt; cookies;
5259     page-&gt;cookieJar().getRawCookies(*document, document-&gt;cookieURL(), cookies);
5260     return WTF::map(cookies, [](auto&amp; cookie) {
5261         return CookieData { cookie };
5262     });
5263 }
5264 
5265 void Internals::setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive)
5266 {
5267     auto* localFrame = frame();
5268     if (!localFrame)
5269         return;
5270     localFrame-&gt;loader().setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchive);
5271 }
5272 
5273 void Internals::processWillSuspend()
5274 {
<span class="line-added">5275 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)</span>
5276     PlatformMediaSessionManager::sharedManager().processWillSuspend();
<span class="line-added">5277 #endif</span>
5278 }
5279 
5280 void Internals::processDidResume()
5281 {
<span class="line-added">5282 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)</span>
5283     PlatformMediaSessionManager::sharedManager().processDidResume();
<span class="line-added">5284 #endif</span>
5285 }
5286 
5287 void Internals::testDictionaryLogging()
5288 {
5289     auto* document = contextDocument();
5290     if (!document)
5291         return;
5292 
5293     auto* page = document-&gt;page();
5294     if (!page)
5295         return;
5296 
5297     DiagnosticLoggingClient::ValueDictionary dictionary;
5298     dictionary.set(&quot;stringKey&quot;_s, String(&quot;stringValue&quot;));
5299     dictionary.set(&quot;uint64Key&quot;_s, std::numeric_limits&lt;uint64_t&gt;::max());
5300     dictionary.set(&quot;int64Key&quot;_s, std::numeric_limits&lt;int64_t&gt;::min());
5301     dictionary.set(&quot;boolKey&quot;_s, true);
5302     dictionary.set(&quot;doubleKey&quot;_s, 2.7182818284590452353602874);
5303 
5304     page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValueDictionary(&quot;testMessage&quot;_s, &quot;testDescription&quot;_s, dictionary, ShouldSample::No);
5305 }
5306 
5307 void Internals::setXHRMaximumIntervalForUserGestureForwarding(XMLHttpRequest&amp; request, double interval)
5308 {
5309     request.setMaximumIntervalForUserGestureForwarding(interval);
5310 }
5311 
<span class="line-added">5312 void Internals::setTransientActivationDuration(double seconds)</span>
<span class="line-added">5313 {</span>
<span class="line-added">5314     DOMWindow::overrideTransientActivationDurationForTesting(Seconds { seconds });</span>
<span class="line-added">5315 }</span>
<span class="line-added">5316 </span>
5317 void Internals::setIsPlayingToAutomotiveHeadUnit(bool isPlaying)
5318 {
<span class="line-added">5319 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)</span>
5320     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(isPlaying);
<span class="line-added">5321 #endif</span>
<span class="line-added">5322 }</span>
<span class="line-added">5323 </span>
<span class="line-added">5324 String Internals::highlightPseudoElementColor(const String&amp; highlightName, Element&amp; element)</span>
<span class="line-added">5325 {</span>
<span class="line-added">5326     element.document().updateStyleIfNeeded();</span>
<span class="line-added">5327 </span>
<span class="line-added">5328     auto&amp; styleResolver = element.document().styleScope().resolver();</span>
<span class="line-added">5329     auto* parentStyle = element.computedStyle();</span>
<span class="line-added">5330     if (!parentStyle)</span>
<span class="line-added">5331         return { };</span>
<span class="line-added">5332 </span>
<span class="line-added">5333     auto style = styleResolver.pseudoStyleForElement(element, { PseudoId::Highlight, highlightName }, *parentStyle);</span>
<span class="line-added">5334     if (!style)</span>
<span class="line-added">5335         return { };</span>
<span class="line-added">5336 </span>
<span class="line-added">5337     return style-&gt;color().cssText();</span>
5338 }
5339 
5340 Internals::TextIndicatorInfo::TextIndicatorInfo()
5341 {
5342 }
5343 
5344 Internals::TextIndicatorInfo::TextIndicatorInfo(const WebCore::TextIndicatorData&amp; data)
5345     : textBoundingRectInRootViewCoordinates(DOMRect::create(data.textBoundingRectInRootViewCoordinates))
5346     , textRectsInBoundingRectCoordinates(DOMRectList::create(data.textRectsInBoundingRectCoordinates))
5347 {
5348 }
5349 
5350 Internals::TextIndicatorInfo::~TextIndicatorInfo() = default;
5351 
5352 Internals::TextIndicatorInfo Internals::textIndicatorForRange(const Range&amp; range, TextIndicatorOptions options)
5353 {
5354     auto indicator = TextIndicator::createWithRange(range, options.core(), TextIndicatorPresentationTransition::None);
5355     return indicator-&gt;data();
5356 }
5357 
5358 void Internals::addPrefetchLoadEventListener(HTMLLinkElement&amp; link, RefPtr&lt;EventListener&gt;&amp;&amp; listener)
5359 {
<span class="line-modified">5360     if (RuntimeEnabledFeatures::sharedFeatures().linkPrefetchEnabled() &amp;&amp; equalLettersIgnoringASCIICase(link.rel(), &quot;prefetch&quot;)) {</span>
<span class="line-added">5361         link.allowPrefetchLoadAndErrorForTesting();</span>
5362         link.addEventListener(eventNames().loadEvent, listener.releaseNonNull(), false);
<span class="line-added">5363     }</span>
<span class="line-added">5364 }</span>
<span class="line-added">5365 </span>
<span class="line-added">5366 #if ENABLE(WEB_AUTHN)</span>
<span class="line-added">5367 void Internals::setMockWebAuthenticationConfiguration(const MockWebAuthenticationConfiguration&amp; configuration)</span>
<span class="line-added">5368 {</span>
<span class="line-added">5369     auto* document = contextDocument();</span>
<span class="line-added">5370     if (!document)</span>
<span class="line-added">5371         return;</span>
<span class="line-added">5372     auto* page = document-&gt;page();</span>
<span class="line-added">5373     if (!page)</span>
<span class="line-added">5374         return;</span>
<span class="line-added">5375     page-&gt;chrome().client().setMockWebAuthenticationConfiguration(configuration);</span>
<span class="line-added">5376 }</span>
<span class="line-added">5377 #endif</span>
<span class="line-added">5378 </span>
<span class="line-added">5379 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">5380 void Internals::setPictureInPictureAPITestEnabled(HTMLVideoElement&amp; videoElement, bool enabled)</span>
<span class="line-added">5381 {</span>
<span class="line-added">5382     videoElement.setPictureInPictureAPITestEnabled(enabled);</span>
<span class="line-added">5383 }</span>
<span class="line-added">5384 #endif</span>
<span class="line-added">5385 </span>
<span class="line-added">5386 void Internals::setMaxCanvasPixelMemory(unsigned size)</span>
<span class="line-added">5387 {</span>
<span class="line-added">5388     HTMLCanvasElement::setMaxPixelMemoryForTesting(size);</span>
<span class="line-added">5389 }</span>
<span class="line-added">5390 </span>
<span class="line-added">5391 int Internals::processIdentifier() const</span>
<span class="line-added">5392 {</span>
<span class="line-added">5393     return getCurrentProcessID();</span>
<span class="line-added">5394 }</span>
<span class="line-added">5395 </span>
<span class="line-added">5396 Ref&lt;InternalsMapLike&gt; Internals::createInternalsMapLike()</span>
<span class="line-added">5397 {</span>
<span class="line-added">5398     return InternalsMapLike::create();</span>
<span class="line-added">5399 }</span>
<span class="line-added">5400 </span>
<span class="line-added">5401 Ref&lt;InternalsSetLike&gt; Internals::createInternalsSetLike()</span>
<span class="line-added">5402 {</span>
<span class="line-added">5403     return InternalsSetLike::create();</span>
<span class="line-added">5404 }</span>
<span class="line-added">5405 </span>
<span class="line-added">5406 bool Internals::hasSandboxMachLookupAccessToGlobalName(const String&amp; process, const String&amp; service)</span>
<span class="line-added">5407 {</span>
<span class="line-added">5408 #if PLATFORM(COCOA)</span>
<span class="line-added">5409     pid_t pid;</span>
<span class="line-added">5410     if (process == &quot;com.apple.WebKit.WebContent&quot;)</span>
<span class="line-added">5411         pid = getpid();</span>
<span class="line-added">5412     else</span>
<span class="line-added">5413         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">5414 </span>
<span class="line-added">5415     return !sandbox_check(pid, &quot;mach-lookup&quot;, static_cast&lt;enum sandbox_filter_type&gt;(SANDBOX_FILTER_GLOBAL_NAME | SANDBOX_CHECK_NO_REPORT), service.utf8().data());</span>
<span class="line-added">5416 #else</span>
<span class="line-added">5417     UNUSED_PARAM(process);</span>
<span class="line-added">5418     UNUSED_PARAM(service);</span>
<span class="line-added">5419     return false;</span>
<span class="line-added">5420 #endif</span>
<span class="line-added">5421 }</span>
<span class="line-added">5422 </span>
<span class="line-added">5423 bool Internals::hasSandboxMachLookupAccessToXPCServiceName(const String&amp; process, const String&amp; service)</span>
<span class="line-added">5424 {</span>
<span class="line-added">5425 #if PLATFORM(COCOA)</span>
<span class="line-added">5426     pid_t pid;</span>
<span class="line-added">5427     if (process == &quot;com.apple.WebKit.WebContent&quot;)</span>
<span class="line-added">5428         pid = getpid();</span>
<span class="line-added">5429     else</span>
<span class="line-added">5430         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">5431 </span>
<span class="line-added">5432     return !sandbox_check(pid, &quot;mach-lookup&quot;, static_cast&lt;enum sandbox_filter_type&gt;(SANDBOX_FILTER_XPC_SERVICE_NAME | SANDBOX_CHECK_NO_REPORT), service.utf8().data());</span>
<span class="line-added">5433 #else</span>
<span class="line-added">5434     UNUSED_PARAM(process);</span>
<span class="line-added">5435     UNUSED_PARAM(service);</span>
<span class="line-added">5436     return false;</span>
<span class="line-added">5437 #endif</span>
<span class="line-added">5438 }</span>
<span class="line-added">5439 </span>
<span class="line-added">5440 String Internals::windowLocationHost(DOMWindow&amp; window)</span>
<span class="line-added">5441 {</span>
<span class="line-added">5442     return window.location().host();</span>
<span class="line-added">5443 }</span>
<span class="line-added">5444 </span>
<span class="line-added">5445 String Internals::systemColorForCSSValue(const String&amp; cssValue, bool useDarkModeAppearance, bool useElevatedUserInterfaceLevel)</span>
<span class="line-added">5446 {</span>
<span class="line-added">5447     CSSValueID id = cssValueKeywordID(cssValue);</span>
<span class="line-added">5448     RELEASE_ASSERT(StyleColor::isSystemColor(id));</span>
<span class="line-added">5449 </span>
<span class="line-added">5450     OptionSet&lt;StyleColor::Options&gt; options;</span>
<span class="line-added">5451     if (useDarkModeAppearance)</span>
<span class="line-added">5452         options.add(StyleColor::Options::UseDarkAppearance);</span>
<span class="line-added">5453     if (useElevatedUserInterfaceLevel)</span>
<span class="line-added">5454         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);</span>
<span class="line-added">5455 </span>
<span class="line-added">5456     return RenderTheme::singleton().systemColor(id, options).cssText();</span>
<span class="line-added">5457 }</span>
<span class="line-added">5458 </span>
<span class="line-added">5459 bool Internals::systemHasBattery() const</span>
<span class="line-added">5460 {</span>
<span class="line-added">5461 #if PLATFORM(COCOA)</span>
<span class="line-added">5462     return WebCore::systemHasBattery();</span>
<span class="line-added">5463 #else</span>
<span class="line-added">5464     return false;</span>
<span class="line-added">5465 #endif</span>
<span class="line-added">5466 }</span>
<span class="line-added">5467 </span>
<span class="line-added">5468 String Internals::mediaMIMETypeForExtension(const String&amp; extension)</span>
<span class="line-added">5469 {</span>
<span class="line-added">5470     return MIMETypeRegistry::getMediaMIMETypeForExtension(extension);</span>
<span class="line-added">5471 }</span>
<span class="line-added">5472 </span>
<span class="line-added">5473 String Internals::focusRingColor()</span>
<span class="line-added">5474 {</span>
<span class="line-added">5475     OptionSet&lt;StyleColor::Options&gt; options;</span>
<span class="line-added">5476     return RenderTheme::singleton().focusRingColor(options).cssText();</span>
5477 }
5478 
5479 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InternalSettings.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Internals.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
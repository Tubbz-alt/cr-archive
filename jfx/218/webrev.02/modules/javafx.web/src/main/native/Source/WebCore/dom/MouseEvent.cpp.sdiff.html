<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/MouseEvent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Microtasks.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MouseEvent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/MouseEvent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;MouseEvent.h&quot;
 25 
<span class="line-removed"> 26 #include &quot;DataTransfer.h&quot;</span>
 27 #include &quot;EventNames.h&quot;
 28 #include &quot;Frame.h&quot;
 29 #include &quot;FrameView.h&quot;
 30 #include &quot;HTMLIFrameElement.h&quot;
 31 #include &quot;JSDOMConvertInterface.h&quot;
 32 #include &quot;JSDOMConvertNullable.h&quot;
 33 #include &quot;JSEventTarget.h&quot;
 34 #include &quot;JSEventTargetCustom.h&quot;
 35 #include &quot;PlatformMouseEvent.h&quot;
 36 #include &quot;RuntimeApplicationChecks.h&quot;



 37 
 38 namespace WebCore {
 39 


 40 using namespace JSC;
 41 
 42 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; type, const MouseEventInit&amp; initializer)
 43 {
 44     return adoptRef(*new MouseEvent(type, initializer));
 45 }
 46 
 47 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; eventType, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, const PlatformMouseEvent&amp; event, int detail, Node* relatedTarget)
 48 {
 49     bool isMouseEnterOrLeave = eventType == eventNames().mouseenterEvent || eventType == eventNames().mouseleaveEvent;
 50     auto isCancelable = eventType != eventNames().mousemoveEvent &amp;&amp; !isMouseEnterOrLeave ? IsCancelable::Yes : IsCancelable::No;
 51     auto canBubble = !isMouseEnterOrLeave ? CanBubble::Yes : CanBubble::No;
 52     auto isComposed = !isMouseEnterOrLeave ? IsComposed::Yes : IsComposed::No;
 53 
 54     return MouseEvent::create(eventType, canBubble, isCancelable, isComposed, event.timestamp().approximateMonotonicTime(), WTFMove(view), detail,
 55         event.globalPosition(), event.position(),
 56 #if ENABLE(POINTER_LOCK)
 57         event.movementDelta(),
 58 #else
 59         { },
 60 #endif
 61         event.modifiers(), event.button(), event.buttons(), relatedTarget, event.force(), event.syntheticClickType());
 62 }
 63 
 64 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; type, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, MonotonicTime timestamp, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 65     const IntPoint&amp; screenLocation, const IntPoint&amp; windowLocation, const IntPoint&amp; movementDelta, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
<span class="line-modified"> 66     EventTarget* relatedTarget, double force, unsigned short syntheticClickType, DataTransfer* dataTransfer, IsSimulated isSimulated, IsTrusted isTrusted)</span>
 67 {
 68     return adoptRef(*new MouseEvent(type, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail,
<span class="line-modified"> 69         screenLocation, windowLocation, movementDelta, modifiers, button, buttons, relatedTarget, force, syntheticClickType, dataTransfer, isSimulated, isTrusted));</span>
 70 }
 71 
 72 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 73     int screenX, int screenY, int clientX, int clientY, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
 74     unsigned short syntheticClickType, EventTarget* relatedTarget)
 75 {
 76     return adoptRef(*new MouseEvent(eventType, canBubble, isCancelable, isComposed, WTFMove(view), detail, { screenX, screenY }, { clientX, clientY }, modifiers, button, buttons, syntheticClickType, relatedTarget));
 77 }
 78 
 79 MouseEvent::MouseEvent() = default;
 80 
 81 MouseEvent::MouseEvent(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
 82     MonotonicTime timestamp, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 83     const IntPoint&amp; screenLocation, const IntPoint&amp; windowLocation, const IntPoint&amp; movementDelta, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
<span class="line-modified"> 84     EventTarget* relatedTarget, double force, unsigned short syntheticClickType, DataTransfer* dataTransfer, IsSimulated isSimulated, IsTrusted isTrusted)</span>
 85     : MouseRelatedEvent(eventType, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail, screenLocation, windowLocation, movementDelta, modifiers, isSimulated, isTrusted)
 86     , m_button(button == -2 ? 0 : button)
 87     , m_buttons(buttons)
 88     , m_syntheticClickType(button == -2 ? 0 : syntheticClickType)
 89     , m_buttonDown(button != -2)
 90     , m_relatedTarget(relatedTarget)
 91     , m_force(force)
<span class="line-removed"> 92     , m_dataTransfer(dataTransfer)</span>
 93 {
 94 }
 95 
 96 MouseEvent::MouseEvent(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
 97     RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail, const IntPoint&amp; screenLocation, const IntPoint&amp; clientLocation,
 98     OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons, unsigned short syntheticClickType, EventTarget* relatedTarget)
 99     : MouseRelatedEvent(eventType, canBubble, isCancelable, isComposed, MonotonicTime::now(), WTFMove(view), detail, screenLocation, { }, { }, modifiers, IsSimulated::No)
100     , m_button(button == -2 ? 0 : button)
101     , m_buttons(buttons)
102     , m_syntheticClickType(button == -2 ? 0 : syntheticClickType)
103     , m_buttonDown(button != -2)
104     , m_relatedTarget(relatedTarget)
105 {
106     initCoordinates(clientLocation);
107 }
108 
109 MouseEvent::MouseEvent(const AtomString&amp; eventType, const MouseEventInit&amp; initializer)
110     : MouseRelatedEvent(eventType, initializer)
111     , m_button(initializer.button == -2 ? 0 : initializer.button)
112     , m_buttons(initializer.buttons)
</pre>
<hr />
<pre>
119 MouseEvent::~MouseEvent() = default;
120 
121 void MouseEvent::initMouseEvent(const AtomString&amp; type, bool canBubble, bool cancelable, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
122     int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, EventTarget* relatedTarget)
123 {
124     if (isBeingDispatched())
125         return;
126 
127     initUIEvent(type, canBubble, cancelable, WTFMove(view), detail);
128 
129     m_screenLocation = IntPoint(screenX, screenY);
130     setModifierKeys(ctrlKey, altKey, shiftKey, metaKey);
131     m_button = button == -2 ? 0 : button;
132     m_syntheticClickType = 0;
133     m_buttonDown = button != -2;
134     m_relatedTarget = relatedTarget;
135 
136     initCoordinates(IntPoint(clientX, clientY));
137 
138     setIsSimulated(false);
<span class="line-removed">139     m_dataTransfer = nullptr;</span>
140 }
141 
142 // FIXME: We need this quirk because iAd Producer is calling this function with a relatedTarget that is not an EventTarget (rdar://problem/30640101).
143 // We should remove this quirk when possible.
<span class="line-modified">144 void MouseEvent::initMouseEventQuirk(ExecState&amp; state, ScriptExecutionContext&amp; scriptExecutionContext, const AtomString&amp; type, bool canBubble, bool cancelable, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, JSValue relatedTargetValue)</span>
145 {
146     EventTarget* relatedTarget = nullptr;
147 #if PLATFORM(MAC)
148     // Impacts iBooks too because of widgets generated by iAd Producer (rdar://problem/30797958).
149     if (MacApplication::isIAdProducer() || MacApplication::isIBooks()) {
150         // jsEventTargetCast() does not throw and will silently convert bad input to nullptr.
151         auto jsRelatedTarget = jsEventTargetCast(state.vm(), relatedTargetValue);
152         if (!jsRelatedTarget &amp;&amp; !relatedTargetValue.isUndefinedOrNull())
153             scriptExecutionContext.addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Calling initMouseEvent() with a relatedTarget that is not an EventTarget is deprecated.&quot;_s);
154         relatedTarget = jsRelatedTarget ? &amp;jsRelatedTarget-&gt;wrapped() : nullptr;
155     } else {
156 #else
157     UNUSED_PARAM(scriptExecutionContext);
158 #endif
159         // This is what the bindings generator would have produced.
160         auto throwScope = DECLARE_THROW_SCOPE(state.vm());
<span class="line-modified">161         relatedTarget = convert&lt;IDLNullable&lt;IDLInterface&lt;EventTarget&gt;&gt;&gt;(state, relatedTargetValue, [](ExecState&amp; state, ThrowScope&amp; scope) {</span>
162             throwArgumentTypeError(state, scope, 14, &quot;relatedTarget&quot;, &quot;MouseEvent&quot;, &quot;initMouseEvent&quot;, &quot;EventTarget&quot;);
163         });
164         RETURN_IF_EXCEPTION(throwScope, void());
165 #if PLATFORM(MAC)
166     }
167 #endif
168     initMouseEvent(type, canBubble, cancelable, WTFMove(view), detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
169 }
170 
171 EventInterface MouseEvent::eventInterface() const
172 {
173     return MouseEventInterfaceType;
174 }
175 
176 bool MouseEvent::isMouseEvent() const
177 {
178     return true;
179 }
180 
<span class="line-removed">181 bool MouseEvent::isDragEvent() const</span>
<span class="line-removed">182 {</span>
<span class="line-removed">183     // This function is only used to decide to return nullptr for dataTransfer even when m_dataTransfer is non-null.</span>
<span class="line-removed">184     // FIXME: Is that really valuable? Why will m_dataTransfer be non-null but we need to return null for dataTransfer?</span>
<span class="line-removed">185     // Quite peculiar to decide based on the type string; may have been be provided by call to JavaScript constructor.</span>
<span class="line-removed">186     auto&amp; type = this-&gt;type();</span>
<span class="line-removed">187     return type == eventNames().dragEvent</span>
<span class="line-removed">188         || type == eventNames().dragendEvent</span>
<span class="line-removed">189         || type == eventNames().dragenterEvent</span>
<span class="line-removed">190         || type == eventNames().dragleaveEvent</span>
<span class="line-removed">191         || type == eventNames().dragoverEvent</span>
<span class="line-removed">192         || type == eventNames().dragstartEvent</span>
<span class="line-removed">193         || type == eventNames().dropEvent;</span>
<span class="line-removed">194 }</span>
<span class="line-removed">195 </span>
196 bool MouseEvent::canTriggerActivationBehavior(const Event&amp; event)
197 {
198     return event.type() == eventNames().clickEvent &amp;&amp; (!is&lt;MouseEvent&gt;(event) || downcast&lt;MouseEvent&gt;(event).button() != RightButton);
199 }
200 
201 int MouseEvent::which() const
202 {
203     // For the DOM, the return values for left, middle and right mouse buttons are 0, 1, 2, respectively.
204     // For the Netscape &quot;which&quot; property, the return values for left, middle and right mouse buttons are 1, 2, 3, respectively.
205     // So we must add 1.
206     if (!m_buttonDown)
207         return 0;
208     return m_button + 1;
209 }
210 
211 RefPtr&lt;Node&gt; MouseEvent::toElement() const
212 {
213     // MSIE extension - &quot;the object toward which the user is moving the mouse pointer&quot;
214     EventTarget* target;
215     if (type() == eventNames().mouseoutEvent || type() == eventNames().mouseleaveEvent)
</pre>
</td>
<td>
<hr />
<pre>
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;MouseEvent.h&quot;
 25 

 26 #include &quot;EventNames.h&quot;
 27 #include &quot;Frame.h&quot;
 28 #include &quot;FrameView.h&quot;
 29 #include &quot;HTMLIFrameElement.h&quot;
 30 #include &quot;JSDOMConvertInterface.h&quot;
 31 #include &quot;JSDOMConvertNullable.h&quot;
 32 #include &quot;JSEventTarget.h&quot;
 33 #include &quot;JSEventTargetCustom.h&quot;
 34 #include &quot;PlatformMouseEvent.h&quot;
 35 #include &quot;RuntimeApplicationChecks.h&quot;
<span class="line-added"> 36 #include &lt;JavaScriptCore/CallFrame.h&gt;</span>
<span class="line-added"> 37 #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;</span>
<span class="line-added"> 38 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
 39 
 40 namespace WebCore {
 41 
<span class="line-added"> 42 WTF_MAKE_ISO_ALLOCATED_IMPL(MouseEvent);</span>
<span class="line-added"> 43 </span>
 44 using namespace JSC;
 45 
 46 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; type, const MouseEventInit&amp; initializer)
 47 {
 48     return adoptRef(*new MouseEvent(type, initializer));
 49 }
 50 
 51 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; eventType, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, const PlatformMouseEvent&amp; event, int detail, Node* relatedTarget)
 52 {
 53     bool isMouseEnterOrLeave = eventType == eventNames().mouseenterEvent || eventType == eventNames().mouseleaveEvent;
 54     auto isCancelable = eventType != eventNames().mousemoveEvent &amp;&amp; !isMouseEnterOrLeave ? IsCancelable::Yes : IsCancelable::No;
 55     auto canBubble = !isMouseEnterOrLeave ? CanBubble::Yes : CanBubble::No;
 56     auto isComposed = !isMouseEnterOrLeave ? IsComposed::Yes : IsComposed::No;
 57 
 58     return MouseEvent::create(eventType, canBubble, isCancelable, isComposed, event.timestamp().approximateMonotonicTime(), WTFMove(view), detail,
 59         event.globalPosition(), event.position(),
 60 #if ENABLE(POINTER_LOCK)
 61         event.movementDelta(),
 62 #else
 63         { },
 64 #endif
 65         event.modifiers(), event.button(), event.buttons(), relatedTarget, event.force(), event.syntheticClickType());
 66 }
 67 
 68 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; type, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, MonotonicTime timestamp, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 69     const IntPoint&amp; screenLocation, const IntPoint&amp; windowLocation, const IntPoint&amp; movementDelta, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
<span class="line-modified"> 70     EventTarget* relatedTarget, double force, unsigned short syntheticClickType, IsSimulated isSimulated, IsTrusted isTrusted)</span>
 71 {
 72     return adoptRef(*new MouseEvent(type, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail,
<span class="line-modified"> 73         screenLocation, windowLocation, movementDelta, modifiers, button, buttons, relatedTarget, force, syntheticClickType, isSimulated, isTrusted));</span>
 74 }
 75 
 76 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 77     int screenX, int screenY, int clientX, int clientY, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
 78     unsigned short syntheticClickType, EventTarget* relatedTarget)
 79 {
 80     return adoptRef(*new MouseEvent(eventType, canBubble, isCancelable, isComposed, WTFMove(view), detail, { screenX, screenY }, { clientX, clientY }, modifiers, button, buttons, syntheticClickType, relatedTarget));
 81 }
 82 
 83 MouseEvent::MouseEvent() = default;
 84 
 85 MouseEvent::MouseEvent(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
 86     MonotonicTime timestamp, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 87     const IntPoint&amp; screenLocation, const IntPoint&amp; windowLocation, const IntPoint&amp; movementDelta, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
<span class="line-modified"> 88     EventTarget* relatedTarget, double force, unsigned short syntheticClickType, IsSimulated isSimulated, IsTrusted isTrusted)</span>
 89     : MouseRelatedEvent(eventType, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail, screenLocation, windowLocation, movementDelta, modifiers, isSimulated, isTrusted)
 90     , m_button(button == -2 ? 0 : button)
 91     , m_buttons(buttons)
 92     , m_syntheticClickType(button == -2 ? 0 : syntheticClickType)
 93     , m_buttonDown(button != -2)
 94     , m_relatedTarget(relatedTarget)
 95     , m_force(force)

 96 {
 97 }
 98 
 99 MouseEvent::MouseEvent(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
100     RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail, const IntPoint&amp; screenLocation, const IntPoint&amp; clientLocation,
101     OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons, unsigned short syntheticClickType, EventTarget* relatedTarget)
102     : MouseRelatedEvent(eventType, canBubble, isCancelable, isComposed, MonotonicTime::now(), WTFMove(view), detail, screenLocation, { }, { }, modifiers, IsSimulated::No)
103     , m_button(button == -2 ? 0 : button)
104     , m_buttons(buttons)
105     , m_syntheticClickType(button == -2 ? 0 : syntheticClickType)
106     , m_buttonDown(button != -2)
107     , m_relatedTarget(relatedTarget)
108 {
109     initCoordinates(clientLocation);
110 }
111 
112 MouseEvent::MouseEvent(const AtomString&amp; eventType, const MouseEventInit&amp; initializer)
113     : MouseRelatedEvent(eventType, initializer)
114     , m_button(initializer.button == -2 ? 0 : initializer.button)
115     , m_buttons(initializer.buttons)
</pre>
<hr />
<pre>
122 MouseEvent::~MouseEvent() = default;
123 
124 void MouseEvent::initMouseEvent(const AtomString&amp; type, bool canBubble, bool cancelable, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
125     int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, EventTarget* relatedTarget)
126 {
127     if (isBeingDispatched())
128         return;
129 
130     initUIEvent(type, canBubble, cancelable, WTFMove(view), detail);
131 
132     m_screenLocation = IntPoint(screenX, screenY);
133     setModifierKeys(ctrlKey, altKey, shiftKey, metaKey);
134     m_button = button == -2 ? 0 : button;
135     m_syntheticClickType = 0;
136     m_buttonDown = button != -2;
137     m_relatedTarget = relatedTarget;
138 
139     initCoordinates(IntPoint(clientX, clientY));
140 
141     setIsSimulated(false);

142 }
143 
144 // FIXME: We need this quirk because iAd Producer is calling this function with a relatedTarget that is not an EventTarget (rdar://problem/30640101).
145 // We should remove this quirk when possible.
<span class="line-modified">146 void MouseEvent::initMouseEventQuirk(JSGlobalObject&amp; state, ScriptExecutionContext&amp; scriptExecutionContext, const AtomString&amp; type, bool canBubble, bool cancelable, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, JSValue relatedTargetValue)</span>
147 {
148     EventTarget* relatedTarget = nullptr;
149 #if PLATFORM(MAC)
150     // Impacts iBooks too because of widgets generated by iAd Producer (rdar://problem/30797958).
151     if (MacApplication::isIAdProducer() || MacApplication::isIBooks()) {
152         // jsEventTargetCast() does not throw and will silently convert bad input to nullptr.
153         auto jsRelatedTarget = jsEventTargetCast(state.vm(), relatedTargetValue);
154         if (!jsRelatedTarget &amp;&amp; !relatedTargetValue.isUndefinedOrNull())
155             scriptExecutionContext.addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Calling initMouseEvent() with a relatedTarget that is not an EventTarget is deprecated.&quot;_s);
156         relatedTarget = jsRelatedTarget ? &amp;jsRelatedTarget-&gt;wrapped() : nullptr;
157     } else {
158 #else
159     UNUSED_PARAM(scriptExecutionContext);
160 #endif
161         // This is what the bindings generator would have produced.
162         auto throwScope = DECLARE_THROW_SCOPE(state.vm());
<span class="line-modified">163         relatedTarget = convert&lt;IDLNullable&lt;IDLInterface&lt;EventTarget&gt;&gt;&gt;(state, relatedTargetValue, [](JSGlobalObject&amp; state, ThrowScope&amp; scope) {</span>
164             throwArgumentTypeError(state, scope, 14, &quot;relatedTarget&quot;, &quot;MouseEvent&quot;, &quot;initMouseEvent&quot;, &quot;EventTarget&quot;);
165         });
166         RETURN_IF_EXCEPTION(throwScope, void());
167 #if PLATFORM(MAC)
168     }
169 #endif
170     initMouseEvent(type, canBubble, cancelable, WTFMove(view), detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
171 }
172 
173 EventInterface MouseEvent::eventInterface() const
174 {
175     return MouseEventInterfaceType;
176 }
177 
178 bool MouseEvent::isMouseEvent() const
179 {
180     return true;
181 }
182 















183 bool MouseEvent::canTriggerActivationBehavior(const Event&amp; event)
184 {
185     return event.type() == eventNames().clickEvent &amp;&amp; (!is&lt;MouseEvent&gt;(event) || downcast&lt;MouseEvent&gt;(event).button() != RightButton);
186 }
187 
188 int MouseEvent::which() const
189 {
190     // For the DOM, the return values for left, middle and right mouse buttons are 0, 1, 2, respectively.
191     // For the Netscape &quot;which&quot; property, the return values for left, middle and right mouse buttons are 1, 2, 3, respectively.
192     // So we must add 1.
193     if (!m_buttonDown)
194         return 0;
195     return m_button + 1;
196 }
197 
198 RefPtr&lt;Node&gt; MouseEvent::toElement() const
199 {
200     // MSIE extension - &quot;the object toward which the user is moving the mouse pointer&quot;
201     EventTarget* target;
202     if (type() == eventNames().mouseoutEvent || type() == eventNames().mouseleaveEvent)
</pre>
</td>
</tr>
</table>
<center><a href="Microtasks.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MouseEvent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
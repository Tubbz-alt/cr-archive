<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScopedArguments.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScopedArgumentsTable.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,20 +36,20 @@</span>
  // object will store the overflow arguments, if there are any. This object will use the symbol
  // table&#39;s ScopedArgumentsTable and the activation, or its overflow storage, to handle all indexed
  // lookups.
  class ScopedArguments final : public GenericArguments&lt;ScopedArguments&gt; {
  private:
<span class="udiff-line-modified-removed">-     ScopedArguments(VM&amp;, Structure*, WriteBarrier&lt;Unknown&gt;* storage);</span>
<span class="udiff-line-modified-added">+     ScopedArguments(VM&amp;, Structure*, WriteBarrier&lt;Unknown&gt;* storage, unsigned totalLength);</span>
      void finishCreation(VM&amp;, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*);
      using Base = GenericArguments&lt;ScopedArguments&gt;;
  
  public:
      template&lt;typename CellType, SubspaceAccess&gt;
<span class="udiff-line-modified-removed">-     static CompleteSubspace* subspaceFor(VM&amp; vm)</span>
<span class="udiff-line-modified-added">+     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
      {
          static_assert(!CellType::needsDestruction, &quot;&quot;);
<span class="udiff-line-modified-removed">-         return &amp;vm.jsValueGigacageCellSpace;</span>
<span class="udiff-line-modified-added">+         return &amp;vm.scopedArgumentsSpace;</span>
      }
  
      // Creates an arguments object but leaves it uninitialized. This is dangerous if we GC right
      // after allocation.
      static ScopedArguments* createUninitialized(VM&amp;, Structure*, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*, unsigned totalLength);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57,145 +57,113 @@</span>
      // Creates an arguments object and initializes everything to the empty value. Use this if you
      // cannot guarantee that you&#39;ll immediately initialize all of the elements.
      static ScopedArguments* create(VM&amp;, Structure*, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*, unsigned totalLength);
  
      // Creates an arguments object by copying the arguments from the stack.
<span class="udiff-line-modified-removed">-     static ScopedArguments* createByCopying(ExecState*, ScopedArgumentsTable*, JSLexicalEnvironment*);</span>
<span class="udiff-line-modified-added">+     static ScopedArguments* createByCopying(JSGlobalObject*, CallFrame*, ScopedArgumentsTable*, JSLexicalEnvironment*);</span>
  
      // Creates an arguments object by copying the arguments from a well-defined stack location.
      static ScopedArguments* createByCopyingFrom(VM&amp;, Structure*, Register* argumentsStart, unsigned totalLength, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*);
  
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
      uint32_t internalLength() const
      {
<span class="udiff-line-modified-removed">-         return storageHeader().totalLength;</span>
<span class="udiff-line-modified-added">+         return m_totalLength;</span>
      }
  
<span class="udiff-line-modified-removed">-     uint32_t length(ExecState* exec) const</span>
<span class="udiff-line-modified-added">+     uint32_t length(JSGlobalObject* globalObject) const</span>
      {
<span class="udiff-line-modified-removed">-         VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+         VM&amp; vm = getVM(globalObject);</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-         if (UNLIKELY(storageHeader().overrodeThings)) {</span>
<span class="udiff-line-modified-removed">-             auto value = get(exec, vm.propertyNames-&gt;length);</span>
<span class="udiff-line-modified-added">+         if (UNLIKELY(m_overrodeThings)) {</span>
<span class="udiff-line-modified-added">+             auto value = get(globalObject, vm.propertyNames-&gt;length);</span>
              RETURN_IF_EXCEPTION(scope, 0);
<span class="udiff-line-modified-removed">-             RELEASE_AND_RETURN(scope, value.toUInt32(exec));</span>
<span class="udiff-line-modified-added">+             RELEASE_AND_RETURN(scope, value.toUInt32(globalObject));</span>
          }
          return internalLength();
      }
  
      bool isMappedArgument(uint32_t i) const
      {
<span class="udiff-line-modified-removed">-         WriteBarrier&lt;Unknown&gt;* storage = overflowStorage();</span>
<span class="udiff-line-removed">-         if (i &gt;= storageHeader(storage).totalLength)</span>
<span class="udiff-line-modified-added">+         if (i &gt;= m_totalLength)</span>
              return false;
          unsigned namedLength = m_table-&gt;length();
          if (i &lt; namedLength)
              return !!m_table-&gt;get(i);
<span class="udiff-line-modified-removed">-         return !!storage[i - namedLength].get();</span>
<span class="udiff-line-modified-added">+         return !!storage()[i - namedLength].get();</span>
      }
  
      bool isMappedArgumentInDFG(uint32_t i) const
      {
          return isMappedArgument(i);
      }
  
      JSValue getIndexQuickly(uint32_t i) const
      {
          ASSERT_WITH_SECURITY_IMPLICATION(isMappedArgument(i));
<span class="udiff-line-removed">-         WriteBarrier&lt;Unknown&gt;* storage = overflowStorage();</span>
<span class="udiff-line-removed">-         unsigned totalLength = storageHeader(storage).totalLength;</span>
          unsigned namedLength = m_table-&gt;length();
          if (i &lt; namedLength)
<span class="udiff-line-modified-removed">-             return preciseIndexMaskPtr(i, totalLength, &amp;m_scope-&gt;variableAt(m_table-&gt;get(i)))-&gt;get();</span>
<span class="udiff-line-modified-removed">-         return preciseIndexMaskPtr(i, totalLength, storage + (i - namedLength))-&gt;get();</span>
<span class="udiff-line-modified-added">+             return m_scope-&gt;variableAt(m_table-&gt;get(i)).get();</span>
<span class="udiff-line-modified-added">+         return storage()[i - namedLength].get();</span>
      }
  
      void setIndexQuickly(VM&amp; vm, uint32_t i, JSValue value)
      {
          ASSERT_WITH_SECURITY_IMPLICATION(isMappedArgument(i));
<span class="udiff-line-removed">-         WriteBarrier&lt;Unknown&gt;* storage = overflowStorage();</span>
<span class="udiff-line-removed">-         unsigned totalLength = storageHeader(storage).totalLength;</span>
          unsigned namedLength = m_table-&gt;length();
          if (i &lt; namedLength)
<span class="udiff-line-modified-removed">-             preciseIndexMaskPtr(i, totalLength, &amp;m_scope-&gt;variableAt(m_table-&gt;get(i)))-&gt;set(vm, m_scope.get(), value);</span>
<span class="udiff-line-modified-added">+             m_scope-&gt;variableAt(m_table-&gt;get(i)).set(vm, m_scope.get(), value);</span>
          else
<span class="udiff-line-modified-removed">-             preciseIndexMaskPtr(i, totalLength, storage + (i - namedLength))-&gt;set(vm, this, value);</span>
<span class="udiff-line-modified-added">+             storage()[i - namedLength].set(vm, this, value);</span>
      }
  
      JSFunction* callee()
      {
          return m_callee.get();
      }
  
<span class="udiff-line-modified-removed">-     bool overrodeThings() const { return storageHeader().overrodeThings; }</span>
<span class="udiff-line-modified-removed">-     void overrideThings(VM&amp;);</span>
<span class="udiff-line-modified-removed">-     void overrideThingsIfNecessary(VM&amp;);</span>
<span class="udiff-line-modified-removed">-     void unmapArgument(VM&amp;, uint32_t index);</span>
<span class="udiff-line-modified-added">+     bool overrodeThings() const { return m_overrodeThings; }</span>
<span class="udiff-line-modified-added">+     void overrideThings(JSGlobalObject*);</span>
<span class="udiff-line-modified-added">+     void overrideThingsIfNecessary(JSGlobalObject*);</span>
<span class="udiff-line-modified-added">+     void unmapArgument(JSGlobalObject*, uint32_t index);</span>
  
<span class="udiff-line-modified-removed">-     void initModifiedArgumentsDescriptorIfNecessary(VM&amp; vm)</span>
<span class="udiff-line-modified-added">+     void initModifiedArgumentsDescriptorIfNecessary(JSGlobalObject* globalObject)</span>
      {
<span class="udiff-line-modified-removed">-         GenericArguments&lt;ScopedArguments&gt;::initModifiedArgumentsDescriptorIfNecessary(vm, m_table-&gt;length());</span>
<span class="udiff-line-modified-added">+         GenericArguments&lt;ScopedArguments&gt;::initModifiedArgumentsDescriptorIfNecessary(globalObject, m_table-&gt;length());</span>
      }
  
<span class="udiff-line-modified-removed">-     void setModifiedArgumentDescriptor(VM&amp; vm, unsigned index)</span>
<span class="udiff-line-modified-added">+     void setModifiedArgumentDescriptor(JSGlobalObject* globalObject, unsigned index)</span>
      {
<span class="udiff-line-modified-removed">-         GenericArguments&lt;ScopedArguments&gt;::setModifiedArgumentDescriptor(vm, index, m_table-&gt;length());</span>
<span class="udiff-line-modified-added">+         GenericArguments&lt;ScopedArguments&gt;::setModifiedArgumentDescriptor(globalObject, index, m_table-&gt;length());</span>
      }
  
      bool isModifiedArgumentDescriptor(unsigned index)
      {
          return GenericArguments&lt;ScopedArguments&gt;::isModifiedArgumentDescriptor(index, m_table-&gt;length());
      }
  
<span class="udiff-line-modified-removed">-     void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);</span>
<span class="udiff-line-modified-added">+     void copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length);</span>
  
      DECLARE_INFO;
  
      static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
  
<span class="udiff-line-modified-removed">-     static ptrdiff_t offsetOfStorage() { return OBJECT_OFFSETOF(ScopedArguments, m_storage); }</span>
<span class="udiff-line-modified-removed">-     static ptrdiff_t offsetOfOverrodeThingsInStorage() { return OBJECT_OFFSETOF(StorageHeader, overrodeThings) - sizeof(WriteBarrier&lt;Unknown&gt;); }</span>
<span class="udiff-line-removed">-     static ptrdiff_t offsetOfTotalLengthInStorage() { return OBJECT_OFFSETOF(StorageHeader, totalLength) - sizeof(WriteBarrier&lt;Unknown&gt;); }</span>
<span class="udiff-line-modified-added">+     static ptrdiff_t offsetOfOverrodeThings() { return OBJECT_OFFSETOF(ScopedArguments, m_overrodeThings); }</span>
<span class="udiff-line-modified-added">+     static ptrdiff_t offsetOfTotalLength() { return OBJECT_OFFSETOF(ScopedArguments, m_totalLength); }</span>
      static ptrdiff_t offsetOfTable() { return OBJECT_OFFSETOF(ScopedArguments, m_table); }
      static ptrdiff_t offsetOfScope() { return OBJECT_OFFSETOF(ScopedArguments, m_scope); }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     static size_t allocationSize(size_t inlineSize)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         RELEASE_ASSERT(!inlineSize);</span>
<span class="udiff-line-removed">-         return sizeof(ScopedArguments);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static size_t storageSize(Checked&lt;size_t&gt; capacity)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         return (sizeof(WriteBarrier&lt;Unknown&gt;) * (capacity + static_cast&lt;size_t&gt;(1))).unsafeGet();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static size_t storageHeaderSize() { return sizeof(WriteBarrier&lt;Unknown&gt;); }</span>
<span class="udiff-line-modified-added">+     static ptrdiff_t offsetOfStorage() { return OBJECT_OFFSETOF(ScopedArguments, m_storage); }</span>
  
  private:
<span class="udiff-line-modified-removed">-     struct StorageHeader {</span>
<span class="udiff-line-removed">-         unsigned totalLength;</span>
<span class="udiff-line-removed">-         bool overrodeThings; // True if length, callee, and caller are fully materialized in the object.</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     WriteBarrier&lt;Unknown&gt;* overflowStorage() const</span>
<span class="udiff-line-modified-added">+     WriteBarrier&lt;Unknown&gt;* storage() const</span>
      {
          return m_storage.get();
      }
  
<span class="udiff-line-modified-removed">-     static StorageHeader&amp; storageHeader(WriteBarrier&lt;Unknown&gt;* storage)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-removed">-         static_assert(sizeof(StorageHeader) &lt;= sizeof(WriteBarrier&lt;Unknown&gt;), &quot;StorageHeader needs to be no bigger than a JSValue&quot;);</span>
<span class="udiff-line-removed">-         return *bitwise_cast&lt;StorageHeader*&gt;(storage - 1);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     StorageHeader&amp; storageHeader() const</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         return storageHeader(overflowStorage());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     bool m_overrodeThings { false }; // True if length, callee, and caller are fully materialized in the object.</span>
<span class="udiff-line-modified-added">+     unsigned m_totalLength; // The length of declared plus overflow arguments.</span>
      WriteBarrier&lt;JSFunction&gt; m_callee;
      WriteBarrier&lt;ScopedArgumentsTable&gt; m_table;
      WriteBarrier&lt;JSLexicalEnvironment&gt; m_scope;
  
      AuxiliaryBarrier&lt;WriteBarrier&lt;Unknown&gt;*&gt; m_storage;
</pre>
<center><a href="ScopedArguments.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScopedArgumentsTable.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
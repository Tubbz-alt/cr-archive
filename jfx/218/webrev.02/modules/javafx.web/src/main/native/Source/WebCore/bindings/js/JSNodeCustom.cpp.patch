diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSNodeCustom.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSNodeCustom.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSNodeCustom.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSNodeCustom.cpp
@@ -49,14 +49,16 @@
 #include "JSDocumentFragment.h"
 #include "JSDocumentType.h"
 #include "JSEventListener.h"
 #include "JSHTMLElement.h"
 #include "JSHTMLElementWrapperFactory.h"
+#include "JSMathMLElementWrapperFactory.h"
 #include "JSProcessingInstruction.h"
 #include "JSSVGElementWrapperFactory.h"
 #include "JSShadowRoot.h"
 #include "JSText.h"
+#include "MathMLElement.h"
 #include "Node.h"
 #include "ProcessingInstruction.h"
 #include "RegisteredEventListener.h"
 #include "SVGElement.h"
 #include "ScriptState.h"
@@ -125,33 +127,37 @@
 {
     JSNode* jsNode = jsCast<JSNode*>(handle.slot()->asCell());
     return isReachableFromDOM(&jsNode->wrapped(), visitor, reason);
 }
 
-JSScope* JSNode::pushEventHandlerScope(ExecState* exec, JSScope* node) const
+JSScope* JSNode::pushEventHandlerScope(JSGlobalObject* lexicalGlobalObject, JSScope* node) const
 {
-    if (inherits<JSHTMLElement>(exec->vm()))
-        return jsCast<const JSHTMLElement*>(this)->pushEventHandlerScope(exec, node);
+    if (inherits<JSHTMLElement>(lexicalGlobalObject->vm()))
+        return jsCast<const JSHTMLElement*>(this)->pushEventHandlerScope(lexicalGlobalObject, node);
     return node;
 }
 
 void JSNode::visitAdditionalChildren(SlotVisitor& visitor)
 {
     visitor.addOpaqueRoot(root(wrapped()));
 }
 
-static ALWAYS_INLINE JSValue createWrapperInline(ExecState* exec, JSDOMGlobalObject* globalObject, Ref<Node>&& node)
+static ALWAYS_INLINE JSValue createWrapperInline(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Ref<Node>&& node)
 {
     ASSERT(!getCachedWrapper(globalObject->world(), node));
 
     JSDOMObject* wrapper;
     switch (node->nodeType()) {
         case Node::ELEMENT_NODE:
             if (is<HTMLElement>(node))
                 wrapper = createJSHTMLWrapper(globalObject, static_reference_cast<HTMLElement>(WTFMove(node)));
             else if (is<SVGElement>(node))
                 wrapper = createJSSVGWrapper(globalObject, static_reference_cast<SVGElement>(WTFMove(node)));
+#if ENABLE(MATHML)
+            else if (is<MathMLElement>(node))
+                wrapper = createJSMathMLWrapper(globalObject, static_reference_cast<MathMLElement>(WTFMove(node)));
+#endif
             else
                 wrapper = createWrapper<Element>(globalObject, WTFMove(node));
             break;
         case Node::ATTRIBUTE_NODE:
             wrapper = createWrapper<Attr>(globalObject, WTFMove(node));
@@ -168,11 +174,11 @@
         case Node::COMMENT_NODE:
             wrapper = createWrapper<Comment>(globalObject, WTFMove(node));
             break;
         case Node::DOCUMENT_NODE:
             // we don't want to cache the document itself in the per-document dictionary
-            return toJS(exec, globalObject, downcast<Document>(node.get()));
+            return toJS(lexicalGlobalObject, globalObject, downcast<Document>(node.get()));
         case Node::DOCUMENT_TYPE_NODE:
             wrapper = createWrapper<DocumentType>(globalObject, WTFMove(node));
             break;
         case Node::DOCUMENT_FRAGMENT_NODE:
             if (node->isShadowRoot())
@@ -185,32 +191,32 @@
     }
 
     return wrapper;
 }
 
-JSValue createWrapper(ExecState* exec, JSDOMGlobalObject* globalObject, Ref<Node>&& node)
+JSValue createWrapper(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Ref<Node>&& node)
 {
-    return createWrapperInline(exec, globalObject, WTFMove(node));
+    return createWrapperInline(lexicalGlobalObject, globalObject, WTFMove(node));
 }
 
-JSValue toJSNewlyCreated(ExecState* exec, JSDOMGlobalObject* globalObject, Ref<Node>&& node)
+JSValue toJSNewlyCreated(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Ref<Node>&& node)
 {
-    return createWrapperInline(exec, globalObject, WTFMove(node));
+    return createWrapperInline(lexicalGlobalObject, globalObject, WTFMove(node));
 }
 
 JSC::JSObject* getOutOfLineCachedWrapper(JSDOMGlobalObject* globalObject, Node& node)
 {
     ASSERT(!globalObject->world().isNormal());
     return globalObject->world().wrappers().get(&node);
 }
 
 void willCreatePossiblyOrphanedTreeByRemovalSlowCase(Node* root)
 {
-    JSC::ExecState* scriptState = mainWorldExecState(root->document().frame());
-    if (!scriptState)
+    JSC::JSGlobalObject* lexicalGlobalObject = mainWorldExecState(root->document().frame());
+    if (!lexicalGlobalObject)
         return;
 
-    JSLockHolder lock(scriptState);
-    toJS(scriptState, static_cast<JSDOMGlobalObject*>(scriptState->lexicalGlobalObject()), *root);
+    JSLockHolder lock(lexicalGlobalObject);
+    toJS(lexicalGlobalObject, static_cast<JSDOMGlobalObject*>(lexicalGlobalObject), *root);
 }
 
 } // namespace WebCore

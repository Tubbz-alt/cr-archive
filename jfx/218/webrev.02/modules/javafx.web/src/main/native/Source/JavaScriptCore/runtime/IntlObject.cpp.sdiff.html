<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntlNumberFormatPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   3  * Copyright (C) 2015 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">   4  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  29 #include &quot;IntlObject.h&quot;
  30 
  31 #if ENABLE(INTL)
  32 
  33 #include &quot;Error.h&quot;
  34 #include &quot;FunctionPrototype.h&quot;
  35 #include &quot;IntlCanonicalizeLanguage.h&quot;
  36 #include &quot;IntlCollatorConstructor.h&quot;
  37 #include &quot;IntlCollatorPrototype.h&quot;
  38 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  39 #include &quot;IntlDateTimeFormatPrototype.h&quot;
  40 #include &quot;IntlNumberFormatConstructor.h&quot;
  41 #include &quot;IntlNumberFormatPrototype.h&quot;
  42 #include &quot;IntlPluralRulesConstructor.h&quot;
  43 #include &quot;IntlPluralRulesPrototype.h&quot;
  44 #include &quot;JSCInlines.h&quot;
  45 #include &quot;JSCJSValueInlines.h&quot;
  46 #include &quot;Lookup.h&quot;
  47 #include &quot;ObjectPrototype.h&quot;
  48 #include &quot;Options.h&quot;


  49 #include &lt;unicode/uloc.h&gt;

  50 #include &lt;unicode/unumsys.h&gt;
  51 #include &lt;wtf/Assertions.h&gt;
  52 #include &lt;wtf/Language.h&gt;
  53 #include &lt;wtf/NeverDestroyed.h&gt;
  54 #include &lt;wtf/text/StringBuilder.h&gt;

  55 
  56 namespace JSC {
  57 
  58 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(IntlObject);
  59 
<span class="line-modified">  60 static EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState*);</span>
  61 
  62 static JSValue createCollatorConstructor(VM&amp; vm, JSObject* object)
  63 {
  64     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  65     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  66     return IntlCollatorConstructor::create(vm, IntlCollatorConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlCollatorPrototype*&gt;(globalObject-&gt;collatorStructure()-&gt;storedPrototypeObject()));
  67 }
  68 
  69 static JSValue createNumberFormatConstructor(VM&amp; vm, JSObject* object)
  70 {
  71     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  72     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  73     return IntlNumberFormatConstructor::create(vm, IntlNumberFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlNumberFormatPrototype*&gt;(globalObject-&gt;numberFormatStructure()-&gt;storedPrototypeObject()));
  74 }
  75 
  76 static JSValue createDateTimeFormatConstructor(VM&amp; vm, JSObject* object)
  77 {
  78     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  79     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  80     return IntlDateTimeFormatConstructor::create(vm, IntlDateTimeFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlDateTimeFormatPrototype*&gt;(globalObject-&gt;dateTimeFormatStructure()-&gt;storedPrototypeObject()));
</pre>
<hr />
<pre>
 111 
 112 const ClassInfo IntlObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, &amp;intlObjectTable, nullptr, CREATE_METHOD_TABLE(IntlObject) };
 113 
 114 IntlObject::IntlObject(VM&amp; vm, Structure* structure)
 115     : JSNonFinalObject(vm, structure)
 116 {
 117 }
 118 
 119 IntlObject* IntlObject::create(VM&amp; vm, Structure* structure)
 120 {
 121     IntlObject* object = new (NotNull, allocateCell&lt;IntlObject&gt;(vm.heap)) IntlObject(vm, structure);
 122     object-&gt;finishCreation(vm);
 123     return object;
 124 }
 125 
 126 Structure* IntlObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 127 {
 128     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 129 }
 130 
<span class="line-modified"> 131 String convertICULocaleToBCP47LanguageTag(const char* localeID)</span>
 132 {
 133     UErrorCode status = U_ZERO_ERROR;
 134     Vector&lt;char, 32&gt; buffer(32);
 135     auto length = uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
 136     if (status == U_BUFFER_OVERFLOW_ERROR) {
 137         buffer.grow(length);
 138         status = U_ZERO_ERROR;
 139         uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
 140     }
 141     if (!U_FAILURE(status))
<span class="line-modified"> 142         return String(buffer.data(), length);</span>
 143     return String();
 144 }
 145 
<span class="line-modified"> 146 bool intlBooleanOption(ExecState&amp; state, JSValue options, PropertyName property, bool&amp; usesFallback)</span>












































































 147 {
 148     // GetOption (options, property, type=&quot;boolean&quot;, values, fallback)
 149     // https://tc39.github.io/ecma402/#sec-getoption
 150 
<span class="line-modified"> 151     VM&amp; vm = state.vm();</span>
 152     auto scope = DECLARE_THROW_SCOPE(vm);
 153 
<span class="line-modified"> 154     JSObject* opts = options.toObject(&amp;state);</span>





 155     RETURN_IF_EXCEPTION(scope, false);
 156 
<span class="line-modified"> 157     JSValue value = opts-&gt;get(&amp;state, property);</span>
 158     RETURN_IF_EXCEPTION(scope, false);
 159 
 160     if (!value.isUndefined()) {
<span class="line-modified"> 161         bool booleanValue = value.toBoolean(&amp;state);</span>
 162         usesFallback = false;
 163         return booleanValue;
 164     }
 165 
 166     // Because fallback can be undefined, we let the caller handle it instead.
 167     usesFallback = true;
 168     return false;
 169 }
 170 
<span class="line-modified"> 171 String intlStringOption(ExecState&amp; state, JSValue options, PropertyName property, std::initializer_list&lt;const char*&gt; values, const char* notFound, const char* fallback)</span>
 172 {
 173     // GetOption (options, property, type=&quot;string&quot;, values, fallback)
 174     // https://tc39.github.io/ecma402/#sec-getoption
 175 
<span class="line-modified"> 176     VM&amp; vm = state.vm();</span>
 177     auto scope = DECLARE_THROW_SCOPE(vm);
 178 
<span class="line-modified"> 179     JSObject* opts = options.toObject(&amp;state);</span>



 180     RETURN_IF_EXCEPTION(scope, String());
 181 
<span class="line-modified"> 182     JSValue value = opts-&gt;get(&amp;state, property);</span>
 183     RETURN_IF_EXCEPTION(scope, String());
 184 
 185     if (!value.isUndefined()) {
<span class="line-modified"> 186         String stringValue = value.toWTFString(&amp;state);</span>
 187         RETURN_IF_EXCEPTION(scope, String());
 188 
 189         if (values.size() &amp;&amp; std::find(values.begin(), values.end(), stringValue) == values.end()) {
<span class="line-modified"> 190             throwException(&amp;state, scope, createRangeError(&amp;state, notFound));</span>
 191             return { };
 192         }
 193         return stringValue;
 194     }
 195 
 196     return fallback;
 197 }
 198 
<span class="line-modified"> 199 unsigned intlNumberOption(ExecState&amp; state, JSValue options, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
 200 {
 201     // GetNumberOption (options, property, minimum, maximum, fallback)
 202     // https://tc39.github.io/ecma402/#sec-getnumberoption
 203 
<span class="line-modified"> 204     VM&amp; vm = state.vm();</span>
 205     auto scope = DECLARE_THROW_SCOPE(vm);
 206 
<span class="line-modified"> 207     JSObject* opts = options.toObject(&amp;state);</span>



 208     RETURN_IF_EXCEPTION(scope, 0);
 209 
<span class="line-modified"> 210     JSValue value = opts-&gt;get(&amp;state, property);</span>
 211     RETURN_IF_EXCEPTION(scope, 0);
 212 
<span class="line-modified"> 213     RELEASE_AND_RETURN(scope, intlDefaultNumberOption(state, value, property, minimum, maximum, fallback));</span>
 214 }
 215 
<span class="line-modified"> 216 unsigned intlDefaultNumberOption(ExecState&amp; state, JSValue value, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
 217 {
 218     // DefaultNumberOption (value, minimum, maximum, fallback)
 219     // https://tc39.github.io/ecma402/#sec-defaultnumberoption
 220 
<span class="line-modified"> 221     VM&amp; vm = state.vm();</span>
 222     auto scope = DECLARE_THROW_SCOPE(vm);
 223 
 224     if (!value.isUndefined()) {
<span class="line-modified"> 225         double doubleValue = value.toNumber(&amp;state);</span>
 226         RETURN_IF_EXCEPTION(scope, 0);
 227 
 228         if (!(doubleValue &gt;= minimum &amp;&amp; doubleValue &lt;= maximum)) {
<span class="line-modified"> 229             throwException(&amp;state, scope, createRangeError(&amp;state, *property.publicName() + &quot; is out of range&quot;));</span>
 230             return 0;
 231         }
 232         return static_cast&lt;unsigned&gt;(doubleValue);
 233     }
 234     return fallback;
 235 }
 236 
 237 static String privateUseLangTag(const Vector&lt;String&gt;&amp; parts, size_t startIndex)
 238 {
 239     size_t numParts = parts.size();
 240     size_t currentIndex = startIndex;
 241 
 242     // Check for privateuse.
 243     // privateuse = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
 244     StringBuilder privateuse;
 245     while (currentIndex &lt; numParts) {
 246         const String&amp; singleton = parts[currentIndex];
 247         unsigned singletonLength = singleton.length();
 248         bool isValid = (singletonLength == 1 &amp;&amp; (singleton == &quot;x&quot; || singleton == &quot;X&quot;));
 249         if (!isValid)
</pre>
<hr />
<pre>
 478 
 479     // Language-Tag = langtag / privateuse / grandfathered
 480     String grandfather = intlGrandfatheredLanguageTag(locale.convertToASCIILowercase());
 481     if (!grandfather.isNull())
 482         return grandfather;
 483 
 484     Vector&lt;String&gt; parts = locale.splitAllowingEmptyEntries(&#39;-&#39;);
 485     if (!parts.isEmpty()) {
 486         String langtag = canonicalLangTag(parts);
 487         if (!langtag.isNull())
 488             return langtag;
 489 
 490         String privateuse = privateUseLangTag(parts, 0);
 491         if (!privateuse.isNull())
 492             return privateuse;
 493     }
 494 
 495     return String();
 496 }
 497 
<span class="line-modified"> 498 Vector&lt;String&gt; canonicalizeLocaleList(ExecState&amp; state, JSValue locales)</span>
 499 {
 500     // CanonicalizeLocaleList (locales)
 501     // https://tc39.github.io/ecma402/#sec-canonicalizelocalelist
 502 
<span class="line-modified"> 503     VM&amp; vm = state.vm();</span>
 504     auto scope = DECLARE_THROW_SCOPE(vm);
 505 
<span class="line-removed"> 506     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);</span>
 507     Vector&lt;String&gt; seen;
 508 
 509     if (locales.isUndefined())
 510         return seen;
 511 
 512     JSObject* localesObject;
 513     if (locales.isString()) {
 514         JSArray* localesArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
 515         if (!localesArray) {
<span class="line-modified"> 516             throwOutOfMemoryError(&amp;state, scope);</span>
 517             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 518         }
<span class="line-modified"> 519         localesArray-&gt;push(&amp;state, locales);</span>
 520         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 521 
 522         localesObject = localesArray;
 523     } else {
<span class="line-modified"> 524         localesObject = locales.toObject(&amp;state);</span>
 525         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 526     }
 527 
 528     // 6. Let len be ToLength(Get(O, &quot;length&quot;)).
<span class="line-modified"> 529     JSValue lengthProperty = localesObject-&gt;get(&amp;state, vm.propertyNames-&gt;length);</span>
 530     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 531 
<span class="line-modified"> 532     double length = lengthProperty.toLength(&amp;state);</span>
 533     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 534 
 535     HashSet&lt;String&gt; seenSet;
 536     for (double k = 0; k &lt; length; ++k) {
<span class="line-modified"> 537         bool kPresent = localesObject-&gt;hasProperty(&amp;state, k);</span>
 538         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 539 
 540         if (kPresent) {
<span class="line-modified"> 541             JSValue kValue = localesObject-&gt;get(&amp;state, k);</span>
 542             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 543 
 544             if (!kValue.isString() &amp;&amp; !kValue.isObject()) {
<span class="line-modified"> 545                 throwTypeError(&amp;state, scope, &quot;locale value must be a string or object&quot;_s);</span>
 546                 return Vector&lt;String&gt;();
 547             }
 548 
<span class="line-modified"> 549             JSString* tag = kValue.toString(&amp;state);</span>
 550             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 551 
<span class="line-modified"> 552             auto tagValue = tag-&gt;value(&amp;state);</span>
 553             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 554 
 555             String canonicalizedTag = canonicalizeLanguageTag(tagValue);
 556             if (canonicalizedTag.isNull()) {
<span class="line-modified"> 557                 throwException(&amp;state, scope, createRangeError(&amp;state, &quot;invalid language tag: &quot; + tagValue));</span>
 558                 return Vector&lt;String&gt;();
 559             }
 560 
 561             if (seenSet.add(canonicalizedTag).isNewEntry)
 562                 seen.append(canonicalizedTag);
 563         }
 564     }
 565 
 566     return seen;
 567 }
 568 
 569 String bestAvailableLocale(const HashSet&lt;String&gt;&amp; availableLocales, const String&amp; locale)
 570 {
 571     // BestAvailableLocale (availableLocales, locale)
 572     // https://tc39.github.io/ecma402/#sec-bestavailablelocale
 573 
 574     String candidate = locale;
 575     while (!candidate.isEmpty()) {
 576         if (availableLocales.contains(candidate))
 577             return candidate;
 578 
 579         size_t pos = candidate.reverseFind(&#39;-&#39;);
 580         if (pos == notFound)
 581             return String();
 582 
 583         if (pos &gt;= 2 &amp;&amp; candidate[pos - 2] == &#39;-&#39;)
 584             pos -= 2;
 585 
 586         candidate = candidate.substring(0, pos);
 587     }
 588 
 589     return String();
 590 }
 591 
<span class="line-modified"> 592 String defaultLocale(ExecState&amp; state)</span>
 593 {
 594     // DefaultLocale ()
 595     // https://tc39.github.io/ecma402/#sec-defaultlocale
 596 
 597     // WebCore&#39;s global objects will have their own ideas of how to determine the language. It may
 598     // be determined by WebCore-specific logic like some WK settings. Usually this will return the
 599     // same thing as userPreferredLanguages()[0].
<span class="line-modified"> 600     VM&amp; vm = state.vm();</span>
<span class="line-removed"> 601     if (auto defaultLanguage = state.jsCallee()-&gt;globalObject(vm)-&gt;globalObjectMethodTable()-&gt;defaultLanguage) {</span>
 602         String locale = canonicalizeLanguageTag(defaultLanguage());
 603         if (!locale.isEmpty())
 604             return locale;
 605     }
 606 
 607     Vector&lt;String&gt; languages = userPreferredLanguages();
 608     for (const auto&amp; language : languages) {
 609         String locale = canonicalizeLanguageTag(language);
 610         if (!locale.isEmpty())
 611             return locale;
 612     }
 613 
 614     // If all else fails, ask ICU. It will probably say something bogus like en_us even if the user
 615     // has configured some other language, but being wrong is better than crashing.
<span class="line-modified"> 616     String locale = convertICULocaleToBCP47LanguageTag(uloc_getDefault());</span>
<span class="line-modified"> 617     if (!locale.isEmpty())</span>
<span class="line-modified"> 618         return locale;</span>




 619 
 620     return &quot;en&quot;_s;
 621 }
 622 
 623 String removeUnicodeLocaleExtension(const String&amp; locale)
 624 {
 625     Vector&lt;String&gt; parts = locale.split(&#39;-&#39;);
 626     StringBuilder builder;
 627     size_t partsSize = parts.size();
 628     bool atPrivate = false;
 629     if (partsSize &gt; 0)
 630         builder.append(parts[0]);
 631     for (size_t p = 1; p &lt; partsSize; ++p) {
 632         if (parts[p] == &quot;x&quot;)
 633             atPrivate = true;
 634         if (!atPrivate &amp;&amp; parts[p] == &quot;u&quot; &amp;&amp; p + 1 &lt; partsSize) {
 635             // Skip the u- and anything that follows until another singleton.
 636             // While the next part is part of the unicode extension, skip it.
 637             while (p + 1 &lt; partsSize &amp;&amp; parts[p + 1].length() &gt; 1)
 638                 ++p;
 639         } else {
 640             builder.append(&#39;-&#39;);
 641             builder.append(parts[p]);
 642         }
 643     }
 644     return builder.toString();
 645 }
 646 
<span class="line-modified"> 647 static MatcherResult lookupMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 648 {
 649     // LookupMatcher (availableLocales, requestedLocales)
 650     // https://tc39.github.io/ecma402/#sec-lookupmatcher
 651 
 652     String locale;
 653     String noExtensionsLocale;
 654     String availableLocale;
 655     for (size_t i = 0; i &lt; requestedLocales.size() &amp;&amp; availableLocale.isNull(); ++i) {
 656         locale = requestedLocales[i];
 657         noExtensionsLocale = removeUnicodeLocaleExtension(locale);
 658         availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
 659     }
 660 
 661     MatcherResult result;
 662     if (!availableLocale.isEmpty()) {
 663         result.locale = availableLocale;
 664         if (locale != noExtensionsLocale) {
 665             size_t extensionIndex = locale.find(&quot;-u-&quot;);
 666             RELEASE_ASSERT(extensionIndex != notFound);
 667 
 668             size_t extensionLength = locale.length() - extensionIndex;
 669             size_t end = extensionIndex + 3;
 670             while (end &lt; locale.length()) {
 671                 end = locale.find(&#39;-&#39;, end);
 672                 if (end == notFound)
 673                     break;
 674                 if (end + 2 &lt; locale.length() &amp;&amp; locale[end + 2] == &#39;-&#39;) {
 675                     extensionLength = end - extensionIndex;
 676                     break;
 677                 }
 678                 end++;
 679             }
 680             result.extension = locale.substring(extensionIndex, extensionLength);
 681             result.extensionIndex = extensionIndex;
 682         }
 683     } else
<span class="line-modified"> 684         result.locale = defaultLocale(state);</span>
 685     return result;
 686 }
 687 
<span class="line-modified"> 688 static MatcherResult bestFitMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 689 {
 690     // BestFitMatcher (availableLocales, requestedLocales)
 691     // https://tc39.github.io/ecma402/#sec-bestfitmatcher
 692 
 693     // FIXME: Implement something better than lookup.
<span class="line-modified"> 694     return lookupMatcher(state, availableLocales, requestedLocales);</span>
 695 }
 696 
 697 static void unicodeExtensionSubTags(const String&amp; extension, Vector&lt;String&gt;&amp; subtags)
 698 {
 699     // UnicodeExtensionSubtags (extension)
 700     // https://tc39.github.io/ecma402/#sec-unicodeextensionsubtags
 701 
 702     auto extensionLength = extension.length();
 703     if (extensionLength &lt; 3)
 704         return;
 705 
 706     size_t subtagStart = 3; // Skip initial -u-.
 707     size_t valueStart = 3;
 708     bool isLeading = true;
 709     for (size_t index = subtagStart; index &lt; extensionLength; ++index) {
 710         if (extension[index] == &#39;-&#39;) {
 711             if (index - subtagStart == 2) {
 712                 // Tag is a key, first append prior key&#39;s value if there is one.
 713                 if (subtagStart - valueStart &gt; 1)
 714                     subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
</pre>
<hr />
<pre>
 716                 valueStart = index + 1;
 717                 isLeading = false;
 718             } else if (isLeading) {
 719                 // Leading subtags before first key.
 720                 subtags.append(extension.substring(subtagStart, index - subtagStart));
 721                 valueStart = index + 1;
 722             }
 723             subtagStart = index + 1;
 724         }
 725     }
 726     if (extensionLength - subtagStart == 2) {
 727         // Trailing an extension key, first append prior key&#39;s value if there is one.
 728         if (subtagStart - valueStart &gt; 1)
 729             subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
 730         valueStart = subtagStart;
 731     }
 732     // Append final key&#39;s value.
 733     subtags.append(extension.substring(valueStart, extensionLength - valueStart));
 734 }
 735 
<span class="line-modified"> 736 HashMap&lt;String, String&gt; resolveLocale(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, const HashMap&lt;String, String&gt;&amp; options, const char* const relevantExtensionKeys[], size_t relevantExtensionKeyCount, Vector&lt;String&gt; (*localeData)(const String&amp;, size_t))</span>
 737 {
 738     // ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData)
 739     // https://tc39.github.io/ecma402/#sec-resolvelocale
 740 
 741     const String&amp; matcher = options.get(&quot;localeMatcher&quot;_s);
 742     MatcherResult matcherResult = (matcher == &quot;lookup&quot;)
<span class="line-modified"> 743         ? lookupMatcher(state, availableLocales, requestedLocales)</span>
<span class="line-modified"> 744         : bestFitMatcher(state, availableLocales, requestedLocales);</span>
 745 
 746     String foundLocale = matcherResult.locale;
 747 
 748     Vector&lt;String&gt; extensionSubtags;
 749     if (!matcherResult.extension.isNull())
 750         unicodeExtensionSubTags(matcherResult.extension, extensionSubtags);
 751 
 752     HashMap&lt;String, String&gt; result;
 753     result.add(&quot;dataLocale&quot;_s, foundLocale);
 754 
 755     String supportedExtension = &quot;-u&quot;_s;
 756     for (size_t keyIndex = 0; keyIndex &lt; relevantExtensionKeyCount; ++keyIndex) {
 757         const char* key = relevantExtensionKeys[keyIndex];
 758         Vector&lt;String&gt; keyLocaleData = localeData(foundLocale, keyIndex);
 759         ASSERT(!keyLocaleData.isEmpty());
 760 
 761         String value = keyLocaleData[0];
 762         String supportedExtensionAddition;
 763 
 764         if (!extensionSubtags.isEmpty()) {
</pre>
<hr />
<pre>
 783             // Null will remove the extension.
 784             if ((optionsValue.isNull() || keyLocaleData.contains(optionsValue)) &amp;&amp; optionsValue != value) {
 785                 value = optionsValue;
 786                 supportedExtensionAddition = String();
 787             }
 788         }
 789         result.add(key, value);
 790         supportedExtension.append(supportedExtensionAddition);
 791     }
 792 
 793     if (supportedExtension.length() &gt; 2) {
 794         String preExtension = foundLocale.substring(0, matcherResult.extensionIndex);
 795         String postExtension = foundLocale.substring(matcherResult.extensionIndex);
 796         foundLocale = preExtension + supportedExtension + postExtension;
 797     }
 798 
 799     result.add(&quot;locale&quot;_s, foundLocale);
 800     return result;
 801 }
 802 
<span class="line-modified"> 803 static JSArray* lookupSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 804 {
 805     // LookupSupportedLocales (availableLocales, requestedLocales)
 806     // https://tc39.github.io/ecma402/#sec-lookupsupportedlocales
 807 
<span class="line-modified"> 808     VM&amp; vm = state.vm();</span>
 809     auto scope = DECLARE_THROW_SCOPE(vm);
 810 
 811     size_t len = requestedLocales.size();
<span class="line-removed"> 812     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);</span>
 813     JSArray* subset = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), 0);
 814     if (!subset) {
<span class="line-modified"> 815         throwOutOfMemoryError(&amp;state, scope);</span>
 816         return nullptr;
 817     }
 818 
 819     unsigned index = 0;
 820     for (size_t k = 0; k &lt; len; ++k) {
 821         const String&amp; locale = requestedLocales[k];
 822         String noExtensionsLocale = removeUnicodeLocaleExtension(locale);
 823         String availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
 824         if (!availableLocale.isNull()) {
<span class="line-modified"> 825             subset-&gt;putDirectIndex(&amp;state, index++, jsString(vm, locale));</span>
 826             RETURN_IF_EXCEPTION(scope, nullptr);
 827         }
 828     }
 829 
 830     return subset;
 831 }
 832 
<span class="line-modified"> 833 static JSArray* bestFitSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 834 {
 835     // BestFitSupportedLocales (availableLocales, requestedLocales)
 836     // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
 837 
 838     // FIXME: Implement something better than lookup.
<span class="line-modified"> 839     return lookupSupportedLocales(state, availableLocales, requestedLocales);</span>
 840 }
 841 
<span class="line-modified"> 842 JSValue supportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, JSValue options)</span>
 843 {
 844     // SupportedLocales (availableLocales, requestedLocales, options)
 845     // https://tc39.github.io/ecma402/#sec-supportedlocales
 846 
<span class="line-modified"> 847     VM&amp; vm = state.vm();</span>
 848     auto scope = DECLARE_THROW_SCOPE(vm);
 849     String matcher;
 850 
 851     if (!options.isUndefined()) {
<span class="line-modified"> 852         matcher = intlStringOption(state, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
 853         RETURN_IF_EXCEPTION(scope, JSValue());
 854     } else
 855         matcher = &quot;best fit&quot;_s;
 856 
 857     JSArray* supportedLocales = (matcher == &quot;best fit&quot;)
<span class="line-modified"> 858         ? bestFitSupportedLocales(state, availableLocales, requestedLocales)</span>
<span class="line-modified"> 859         : lookupSupportedLocales(state, availableLocales, requestedLocales);</span>
 860     RETURN_IF_EXCEPTION(scope, JSValue());
 861 
 862     PropertyNameArray keys(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified"> 863     supportedLocales-&gt;getOwnPropertyNames(supportedLocales, &amp;state, keys, EnumerationMode());</span>
 864     RETURN_IF_EXCEPTION(scope, JSValue());
 865 
 866     PropertyDescriptor desc;
 867     desc.setConfigurable(false);
 868     desc.setWritable(false);
 869 
 870     size_t len = keys.size();
 871     for (size_t i = 0; i &lt; len; ++i) {
<span class="line-modified"> 872         supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, keys[i], desc, true);</span>
 873         RETURN_IF_EXCEPTION(scope, JSValue());
 874     }
<span class="line-modified"> 875     supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, vm.propertyNames-&gt;length, desc, true);</span>
 876     RETURN_IF_EXCEPTION(scope, JSValue());
 877 
 878     return supportedLocales;
 879 }
 880 
 881 Vector&lt;String&gt; numberingSystemsForLocale(const String&amp; locale)
 882 {
 883     static NeverDestroyed&lt;Vector&lt;String&gt;&gt; cachedNumberingSystems;
 884     Vector&lt;String&gt;&amp; availableNumberingSystems = cachedNumberingSystems.get();
 885 
<span class="line-modified"> 886     if (UNLIKELY(availableNumberingSystems.isEmpty())) {</span>
<span class="line-modified"> 887         static Lock cachedNumberingSystemsMutex;</span>
<span class="line-modified"> 888         std::lock_guard&lt;Lock&gt; lock(cachedNumberingSystemsMutex);</span>
<span class="line-modified"> 889         if (availableNumberingSystems.isEmpty()) {</span>
<span class="line-modified"> 890             UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 891             UEnumeration* numberingSystemNames = unumsys_openAvailableNames(&amp;status);</span>
<span class="line-removed"> 892             ASSERT(U_SUCCESS(status));</span>
 893 
<span class="line-modified"> 894             int32_t resultLength;</span>
<span class="line-modified"> 895             // Numbering system names are always ASCII, so use char[].</span>
<span class="line-modified"> 896             while (const char* result = uenum_next(numberingSystemNames, &amp;resultLength, &amp;status)) {</span>
<span class="line-modified"> 897                 ASSERT(U_SUCCESS(status));</span>
<span class="line-modified"> 898                 auto numsys = unumsys_openByName(result, &amp;status);</span>
<span class="line-modified"> 899                 ASSERT(U_SUCCESS(status));</span>
<span class="line-modified"> 900                 // Only support algorithmic if it is the default fot the locale, handled below.</span>
<span class="line-modified"> 901                 if (!unumsys_isAlgorithmic(numsys))</span>
<span class="line-modified"> 902                     availableNumberingSystems.append(String(result, resultLength));</span>
<span class="line-modified"> 903                 unumsys_close(numsys);</span>
<span class="line-removed"> 904             }</span>
<span class="line-removed"> 905             uenum_close(numberingSystemNames);</span>
 906         }
<span class="line-modified"> 907     }</span>

 908 
 909     UErrorCode status = U_ZERO_ERROR;
 910     UNumberingSystem* defaultSystem = unumsys_open(locale.utf8().data(), &amp;status);
 911     ASSERT(U_SUCCESS(status));
 912     String defaultSystemName(unumsys_getName(defaultSystem));
 913     unumsys_close(defaultSystem);
 914 
 915     Vector&lt;String&gt; numberingSystems({ defaultSystemName });
 916     numberingSystems.appendVector(availableNumberingSystems);
 917     return numberingSystems;
 918 }
 919 
<span class="line-modified"> 920 EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState* state)</span>
 921 {
 922     // Intl.getCanonicalLocales(locales)
 923     // https://tc39.github.io/ecma402/#sec-intl.getcanonicallocales
 924 
<span class="line-modified"> 925     VM&amp; vm = state-&gt;vm();</span>
 926     auto scope = DECLARE_THROW_SCOPE(vm);
 927 
<span class="line-modified"> 928     Vector&lt;String&gt; localeList = canonicalizeLocaleList(*state, state-&gt;argument(0));</span>
 929     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 930     auto length = localeList.size();
 931 
<span class="line-removed"> 932     JSGlobalObject* globalObject = state-&gt;jsCallee()-&gt;globalObject(vm);</span>
 933     JSArray* localeArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), length);
 934     if (!localeArray) {
<span class="line-modified"> 935         throwOutOfMemoryError(state, scope);</span>
 936         return encodedJSValue();
 937     }
 938 
 939     for (size_t i = 0; i &lt; length; ++i) {
<span class="line-modified"> 940         localeArray-&gt;putDirectIndex(state, i, jsString(vm, localeList[i]));</span>
 941         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 942     }
 943     return JSValue::encode(localeArray);
 944 }
 945 
 946 } // namespace JSC
 947 
 948 #endif // ENABLE(INTL)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   3  * Copyright (C) 2015 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">   4  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.</span>
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  29 #include &quot;IntlObject.h&quot;
  30 
  31 #if ENABLE(INTL)
  32 
  33 #include &quot;Error.h&quot;
  34 #include &quot;FunctionPrototype.h&quot;
  35 #include &quot;IntlCanonicalizeLanguage.h&quot;
  36 #include &quot;IntlCollatorConstructor.h&quot;
  37 #include &quot;IntlCollatorPrototype.h&quot;
  38 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  39 #include &quot;IntlDateTimeFormatPrototype.h&quot;
  40 #include &quot;IntlNumberFormatConstructor.h&quot;
  41 #include &quot;IntlNumberFormatPrototype.h&quot;
  42 #include &quot;IntlPluralRulesConstructor.h&quot;
  43 #include &quot;IntlPluralRulesPrototype.h&quot;
  44 #include &quot;JSCInlines.h&quot;
  45 #include &quot;JSCJSValueInlines.h&quot;
  46 #include &quot;Lookup.h&quot;
  47 #include &quot;ObjectPrototype.h&quot;
  48 #include &quot;Options.h&quot;
<span class="line-added">  49 #include &lt;unicode/ucol.h&gt;</span>
<span class="line-added">  50 #include &lt;unicode/udat.h&gt;</span>
  51 #include &lt;unicode/uloc.h&gt;
<span class="line-added">  52 #include &lt;unicode/unum.h&gt;</span>
  53 #include &lt;unicode/unumsys.h&gt;
  54 #include &lt;wtf/Assertions.h&gt;
  55 #include &lt;wtf/Language.h&gt;
  56 #include &lt;wtf/NeverDestroyed.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-added">  58 #include &lt;wtf/text/StringImpl.h&gt;</span>
  59 
  60 namespace JSC {
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(IntlObject);
  63 
<span class="line-modified">  64 static EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(JSGlobalObject*, CallFrame*);</span>
  65 
  66 static JSValue createCollatorConstructor(VM&amp; vm, JSObject* object)
  67 {
  68     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  69     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  70     return IntlCollatorConstructor::create(vm, IntlCollatorConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlCollatorPrototype*&gt;(globalObject-&gt;collatorStructure()-&gt;storedPrototypeObject()));
  71 }
  72 
  73 static JSValue createNumberFormatConstructor(VM&amp; vm, JSObject* object)
  74 {
  75     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  76     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  77     return IntlNumberFormatConstructor::create(vm, IntlNumberFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlNumberFormatPrototype*&gt;(globalObject-&gt;numberFormatStructure()-&gt;storedPrototypeObject()));
  78 }
  79 
  80 static JSValue createDateTimeFormatConstructor(VM&amp; vm, JSObject* object)
  81 {
  82     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  83     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  84     return IntlDateTimeFormatConstructor::create(vm, IntlDateTimeFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlDateTimeFormatPrototype*&gt;(globalObject-&gt;dateTimeFormatStructure()-&gt;storedPrototypeObject()));
</pre>
<hr />
<pre>
 115 
 116 const ClassInfo IntlObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, &amp;intlObjectTable, nullptr, CREATE_METHOD_TABLE(IntlObject) };
 117 
 118 IntlObject::IntlObject(VM&amp; vm, Structure* structure)
 119     : JSNonFinalObject(vm, structure)
 120 {
 121 }
 122 
 123 IntlObject* IntlObject::create(VM&amp; vm, Structure* structure)
 124 {
 125     IntlObject* object = new (NotNull, allocateCell&lt;IntlObject&gt;(vm.heap)) IntlObject(vm, structure);
 126     object-&gt;finishCreation(vm);
 127     return object;
 128 }
 129 
 130 Structure* IntlObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 131 {
 132     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 133 }
 134 
<span class="line-modified"> 135 static String convertICULocaleToBCP47LanguageTag(const char* localeID)</span>
 136 {
 137     UErrorCode status = U_ZERO_ERROR;
 138     Vector&lt;char, 32&gt; buffer(32);
 139     auto length = uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
 140     if (status == U_BUFFER_OVERFLOW_ERROR) {
 141         buffer.grow(length);
 142         status = U_ZERO_ERROR;
 143         uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
 144     }
 145     if (!U_FAILURE(status))
<span class="line-modified"> 146         return String(StringImpl::createStaticStringImpl(buffer.data(), length));</span>
 147     return String();
 148 }
 149 
<span class="line-modified"> 150 static void addMissingScriptLocales(HashSet&lt;String&gt;&amp; availableLocales)</span>
<span class="line-added"> 151 {</span>
<span class="line-added"> 152     static const NeverDestroyed&lt;String&gt; pa_PK_String(MAKE_STATIC_STRING_IMPL(&quot;pa-PK&quot;));</span>
<span class="line-added"> 153     static const NeverDestroyed&lt;String&gt; zh_CN_String(MAKE_STATIC_STRING_IMPL(&quot;zh-CN&quot;));</span>
<span class="line-added"> 154     static const NeverDestroyed&lt;String&gt; zh_HK_String(MAKE_STATIC_STRING_IMPL(&quot;zh-HK&quot;));</span>
<span class="line-added"> 155     static const NeverDestroyed&lt;String&gt; zh_SG_String(MAKE_STATIC_STRING_IMPL(&quot;zh-SG&quot;));</span>
<span class="line-added"> 156     static const NeverDestroyed&lt;String&gt; zh_TW_String(MAKE_STATIC_STRING_IMPL(&quot;zh-TW&quot;));</span>
<span class="line-added"> 157     if (availableLocales.contains(&quot;pa-Arab-PK&quot;))</span>
<span class="line-added"> 158         availableLocales.add(pa_PK_String.get());</span>
<span class="line-added"> 159     if (availableLocales.contains(&quot;zh-Hans-CN&quot;))</span>
<span class="line-added"> 160         availableLocales.add(zh_CN_String.get());</span>
<span class="line-added"> 161     if (availableLocales.contains(&quot;zh-Hant-HK&quot;))</span>
<span class="line-added"> 162         availableLocales.add(zh_HK_String.get());</span>
<span class="line-added"> 163     if (availableLocales.contains(&quot;zh-Hans-SG&quot;))</span>
<span class="line-added"> 164         availableLocales.add(zh_SG_String.get());</span>
<span class="line-added"> 165     if (availableLocales.contains(&quot;zh-Hant-TW&quot;))</span>
<span class="line-added"> 166         availableLocales.add(zh_TW_String.get());</span>
<span class="line-added"> 167 }</span>
<span class="line-added"> 168 </span>
<span class="line-added"> 169 const HashSet&lt;String&gt;&amp; intlCollatorAvailableLocales()</span>
<span class="line-added"> 170 {</span>
<span class="line-added"> 171     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;</span>
<span class="line-added"> 172     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();</span>
<span class="line-added"> 173 </span>
<span class="line-added"> 174     static std::once_flag initializeOnce;</span>
<span class="line-added"> 175     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added"> 176         ASSERT(availableLocales.isEmpty());</span>
<span class="line-added"> 177         int32_t count = ucol_countAvailable();</span>
<span class="line-added"> 178         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-added"> 179             String locale = convertICULocaleToBCP47LanguageTag(ucol_getAvailable(i));</span>
<span class="line-added"> 180             if (!locale.isEmpty())</span>
<span class="line-added"> 181                 availableLocales.add(locale);</span>
<span class="line-added"> 182         }</span>
<span class="line-added"> 183         addMissingScriptLocales(availableLocales);</span>
<span class="line-added"> 184     });</span>
<span class="line-added"> 185     return availableLocales;</span>
<span class="line-added"> 186 }</span>
<span class="line-added"> 187 </span>
<span class="line-added"> 188 const HashSet&lt;String&gt;&amp; intlDateTimeFormatAvailableLocales()</span>
<span class="line-added"> 189 {</span>
<span class="line-added"> 190     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;</span>
<span class="line-added"> 191     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();</span>
<span class="line-added"> 192 </span>
<span class="line-added"> 193     static std::once_flag initializeOnce;</span>
<span class="line-added"> 194     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added"> 195         ASSERT(availableLocales.isEmpty());</span>
<span class="line-added"> 196         int32_t count = udat_countAvailable();</span>
<span class="line-added"> 197         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-added"> 198             String locale = convertICULocaleToBCP47LanguageTag(udat_getAvailable(i));</span>
<span class="line-added"> 199             if (!locale.isEmpty())</span>
<span class="line-added"> 200                 availableLocales.add(locale);</span>
<span class="line-added"> 201         }</span>
<span class="line-added"> 202         addMissingScriptLocales(availableLocales);</span>
<span class="line-added"> 203     });</span>
<span class="line-added"> 204     return availableLocales;</span>
<span class="line-added"> 205 }</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207 const HashSet&lt;String&gt;&amp; intlNumberFormatAvailableLocales()</span>
<span class="line-added"> 208 {</span>
<span class="line-added"> 209     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;</span>
<span class="line-added"> 210     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();</span>
<span class="line-added"> 211 </span>
<span class="line-added"> 212     static std::once_flag initializeOnce;</span>
<span class="line-added"> 213     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added"> 214         ASSERT(availableLocales.isEmpty());</span>
<span class="line-added"> 215         int32_t count = unum_countAvailable();</span>
<span class="line-added"> 216         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-added"> 217             String locale = convertICULocaleToBCP47LanguageTag(unum_getAvailable(i));</span>
<span class="line-added"> 218             if (!locale.isEmpty())</span>
<span class="line-added"> 219                 availableLocales.add(locale);</span>
<span class="line-added"> 220         }</span>
<span class="line-added"> 221         addMissingScriptLocales(availableLocales);</span>
<span class="line-added"> 222     });</span>
<span class="line-added"> 223     return availableLocales;</span>
<span class="line-added"> 224 }</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226 bool intlBooleanOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, bool&amp; usesFallback)</span>
 227 {
 228     // GetOption (options, property, type=&quot;boolean&quot;, values, fallback)
 229     // https://tc39.github.io/ecma402/#sec-getoption
 230 
<span class="line-modified"> 231     VM&amp; vm = globalObject-&gt;vm();</span>
 232     auto scope = DECLARE_THROW_SCOPE(vm);
 233 
<span class="line-modified"> 234     if (options.isUndefined()) {</span>
<span class="line-added"> 235         usesFallback = true;</span>
<span class="line-added"> 236         return false;</span>
<span class="line-added"> 237     }</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239     JSObject* opts = options.toObject(globalObject);</span>
 240     RETURN_IF_EXCEPTION(scope, false);
 241 
<span class="line-modified"> 242     JSValue value = opts-&gt;get(globalObject, property);</span>
 243     RETURN_IF_EXCEPTION(scope, false);
 244 
 245     if (!value.isUndefined()) {
<span class="line-modified"> 246         bool booleanValue = value.toBoolean(globalObject);</span>
 247         usesFallback = false;
 248         return booleanValue;
 249     }
 250 
 251     // Because fallback can be undefined, we let the caller handle it instead.
 252     usesFallback = true;
 253     return false;
 254 }
 255 
<span class="line-modified"> 256 String intlStringOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, std::initializer_list&lt;const char*&gt; values, const char* notFound, const char* fallback)</span>
 257 {
 258     // GetOption (options, property, type=&quot;string&quot;, values, fallback)
 259     // https://tc39.github.io/ecma402/#sec-getoption
 260 
<span class="line-modified"> 261     VM&amp; vm = globalObject-&gt;vm();</span>
 262     auto scope = DECLARE_THROW_SCOPE(vm);
 263 
<span class="line-modified"> 264     if (options.isUndefined())</span>
<span class="line-added"> 265         return fallback;</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267     JSObject* opts = options.toObject(globalObject);</span>
 268     RETURN_IF_EXCEPTION(scope, String());
 269 
<span class="line-modified"> 270     JSValue value = opts-&gt;get(globalObject, property);</span>
 271     RETURN_IF_EXCEPTION(scope, String());
 272 
 273     if (!value.isUndefined()) {
<span class="line-modified"> 274         String stringValue = value.toWTFString(globalObject);</span>
 275         RETURN_IF_EXCEPTION(scope, String());
 276 
 277         if (values.size() &amp;&amp; std::find(values.begin(), values.end(), stringValue) == values.end()) {
<span class="line-modified"> 278             throwException(globalObject, scope, createRangeError(globalObject, notFound));</span>
 279             return { };
 280         }
 281         return stringValue;
 282     }
 283 
 284     return fallback;
 285 }
 286 
<span class="line-modified"> 287 unsigned intlNumberOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
 288 {
 289     // GetNumberOption (options, property, minimum, maximum, fallback)
 290     // https://tc39.github.io/ecma402/#sec-getnumberoption
 291 
<span class="line-modified"> 292     VM&amp; vm = globalObject-&gt;vm();</span>
 293     auto scope = DECLARE_THROW_SCOPE(vm);
 294 
<span class="line-modified"> 295     if (options.isUndefined())</span>
<span class="line-added"> 296         return fallback;</span>
<span class="line-added"> 297 </span>
<span class="line-added"> 298     JSObject* opts = options.toObject(globalObject);</span>
 299     RETURN_IF_EXCEPTION(scope, 0);
 300 
<span class="line-modified"> 301     JSValue value = opts-&gt;get(globalObject, property);</span>
 302     RETURN_IF_EXCEPTION(scope, 0);
 303 
<span class="line-modified"> 304     RELEASE_AND_RETURN(scope, intlDefaultNumberOption(globalObject, value, property, minimum, maximum, fallback));</span>
 305 }
 306 
<span class="line-modified"> 307 unsigned intlDefaultNumberOption(JSGlobalObject* globalObject, JSValue value, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
 308 {
 309     // DefaultNumberOption (value, minimum, maximum, fallback)
 310     // https://tc39.github.io/ecma402/#sec-defaultnumberoption
 311 
<span class="line-modified"> 312     VM&amp; vm = globalObject-&gt;vm();</span>
 313     auto scope = DECLARE_THROW_SCOPE(vm);
 314 
 315     if (!value.isUndefined()) {
<span class="line-modified"> 316         double doubleValue = value.toNumber(globalObject);</span>
 317         RETURN_IF_EXCEPTION(scope, 0);
 318 
 319         if (!(doubleValue &gt;= minimum &amp;&amp; doubleValue &lt;= maximum)) {
<span class="line-modified"> 320             throwException(globalObject, scope, createRangeError(globalObject, *property.publicName() + &quot; is out of range&quot;));</span>
 321             return 0;
 322         }
 323         return static_cast&lt;unsigned&gt;(doubleValue);
 324     }
 325     return fallback;
 326 }
 327 
 328 static String privateUseLangTag(const Vector&lt;String&gt;&amp; parts, size_t startIndex)
 329 {
 330     size_t numParts = parts.size();
 331     size_t currentIndex = startIndex;
 332 
 333     // Check for privateuse.
 334     // privateuse = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
 335     StringBuilder privateuse;
 336     while (currentIndex &lt; numParts) {
 337         const String&amp; singleton = parts[currentIndex];
 338         unsigned singletonLength = singleton.length();
 339         bool isValid = (singletonLength == 1 &amp;&amp; (singleton == &quot;x&quot; || singleton == &quot;X&quot;));
 340         if (!isValid)
</pre>
<hr />
<pre>
 569 
 570     // Language-Tag = langtag / privateuse / grandfathered
 571     String grandfather = intlGrandfatheredLanguageTag(locale.convertToASCIILowercase());
 572     if (!grandfather.isNull())
 573         return grandfather;
 574 
 575     Vector&lt;String&gt; parts = locale.splitAllowingEmptyEntries(&#39;-&#39;);
 576     if (!parts.isEmpty()) {
 577         String langtag = canonicalLangTag(parts);
 578         if (!langtag.isNull())
 579             return langtag;
 580 
 581         String privateuse = privateUseLangTag(parts, 0);
 582         if (!privateuse.isNull())
 583             return privateuse;
 584     }
 585 
 586     return String();
 587 }
 588 
<span class="line-modified"> 589 Vector&lt;String&gt; canonicalizeLocaleList(JSGlobalObject* globalObject, JSValue locales)</span>
 590 {
 591     // CanonicalizeLocaleList (locales)
 592     // https://tc39.github.io/ecma402/#sec-canonicalizelocalelist
 593 
<span class="line-modified"> 594     VM&amp; vm = globalObject-&gt;vm();</span>
 595     auto scope = DECLARE_THROW_SCOPE(vm);
 596 

 597     Vector&lt;String&gt; seen;
 598 
 599     if (locales.isUndefined())
 600         return seen;
 601 
 602     JSObject* localesObject;
 603     if (locales.isString()) {
 604         JSArray* localesArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
 605         if (!localesArray) {
<span class="line-modified"> 606             throwOutOfMemoryError(globalObject, scope);</span>
 607             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 608         }
<span class="line-modified"> 609         localesArray-&gt;push(globalObject, locales);</span>
 610         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 611 
 612         localesObject = localesArray;
 613     } else {
<span class="line-modified"> 614         localesObject = locales.toObject(globalObject);</span>
 615         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 616     }
 617 
 618     // 6. Let len be ToLength(Get(O, &quot;length&quot;)).
<span class="line-modified"> 619     JSValue lengthProperty = localesObject-&gt;get(globalObject, vm.propertyNames-&gt;length);</span>
 620     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 621 
<span class="line-modified"> 622     double length = lengthProperty.toLength(globalObject);</span>
 623     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 624 
 625     HashSet&lt;String&gt; seenSet;
 626     for (double k = 0; k &lt; length; ++k) {
<span class="line-modified"> 627         bool kPresent = localesObject-&gt;hasProperty(globalObject, k);</span>
 628         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 629 
 630         if (kPresent) {
<span class="line-modified"> 631             JSValue kValue = localesObject-&gt;get(globalObject, k);</span>
 632             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 633 
 634             if (!kValue.isString() &amp;&amp; !kValue.isObject()) {
<span class="line-modified"> 635                 throwTypeError(globalObject, scope, &quot;locale value must be a string or object&quot;_s);</span>
 636                 return Vector&lt;String&gt;();
 637             }
 638 
<span class="line-modified"> 639             JSString* tag = kValue.toString(globalObject);</span>
 640             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 641 
<span class="line-modified"> 642             auto tagValue = tag-&gt;value(globalObject);</span>
 643             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 644 
 645             String canonicalizedTag = canonicalizeLanguageTag(tagValue);
 646             if (canonicalizedTag.isNull()) {
<span class="line-modified"> 647                 throwException(globalObject, scope, createRangeError(globalObject, &quot;invalid language tag: &quot; + tagValue));</span>
 648                 return Vector&lt;String&gt;();
 649             }
 650 
 651             if (seenSet.add(canonicalizedTag).isNewEntry)
 652                 seen.append(canonicalizedTag);
 653         }
 654     }
 655 
 656     return seen;
 657 }
 658 
 659 String bestAvailableLocale(const HashSet&lt;String&gt;&amp; availableLocales, const String&amp; locale)
 660 {
 661     // BestAvailableLocale (availableLocales, locale)
 662     // https://tc39.github.io/ecma402/#sec-bestavailablelocale
 663 
 664     String candidate = locale;
 665     while (!candidate.isEmpty()) {
 666         if (availableLocales.contains(candidate))
 667             return candidate;
 668 
 669         size_t pos = candidate.reverseFind(&#39;-&#39;);
 670         if (pos == notFound)
 671             return String();
 672 
 673         if (pos &gt;= 2 &amp;&amp; candidate[pos - 2] == &#39;-&#39;)
 674             pos -= 2;
 675 
 676         candidate = candidate.substring(0, pos);
 677     }
 678 
 679     return String();
 680 }
 681 
<span class="line-modified"> 682 String defaultLocale(JSGlobalObject* globalObject)</span>
 683 {
 684     // DefaultLocale ()
 685     // https://tc39.github.io/ecma402/#sec-defaultlocale
 686 
 687     // WebCore&#39;s global objects will have their own ideas of how to determine the language. It may
 688     // be determined by WebCore-specific logic like some WK settings. Usually this will return the
 689     // same thing as userPreferredLanguages()[0].
<span class="line-modified"> 690     if (auto defaultLanguage = globalObject-&gt;globalObjectMethodTable()-&gt;defaultLanguage) {</span>

 691         String locale = canonicalizeLanguageTag(defaultLanguage());
 692         if (!locale.isEmpty())
 693             return locale;
 694     }
 695 
 696     Vector&lt;String&gt; languages = userPreferredLanguages();
 697     for (const auto&amp; language : languages) {
 698         String locale = canonicalizeLanguageTag(language);
 699         if (!locale.isEmpty())
 700             return locale;
 701     }
 702 
 703     // If all else fails, ask ICU. It will probably say something bogus like en_us even if the user
 704     // has configured some other language, but being wrong is better than crashing.
<span class="line-modified"> 705     static NeverDestroyed&lt;String&gt; icuDefaultLocalString;</span>
<span class="line-modified"> 706     static std::once_flag initializeOnce;</span>
<span class="line-modified"> 707     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added"> 708         icuDefaultLocalString.get() = convertICULocaleToBCP47LanguageTag(uloc_getDefault());</span>
<span class="line-added"> 709     });</span>
<span class="line-added"> 710     if (!icuDefaultLocalString-&gt;isEmpty())</span>
<span class="line-added"> 711         return icuDefaultLocalString.get();</span>
 712 
 713     return &quot;en&quot;_s;
 714 }
 715 
 716 String removeUnicodeLocaleExtension(const String&amp; locale)
 717 {
 718     Vector&lt;String&gt; parts = locale.split(&#39;-&#39;);
 719     StringBuilder builder;
 720     size_t partsSize = parts.size();
 721     bool atPrivate = false;
 722     if (partsSize &gt; 0)
 723         builder.append(parts[0]);
 724     for (size_t p = 1; p &lt; partsSize; ++p) {
 725         if (parts[p] == &quot;x&quot;)
 726             atPrivate = true;
 727         if (!atPrivate &amp;&amp; parts[p] == &quot;u&quot; &amp;&amp; p + 1 &lt; partsSize) {
 728             // Skip the u- and anything that follows until another singleton.
 729             // While the next part is part of the unicode extension, skip it.
 730             while (p + 1 &lt; partsSize &amp;&amp; parts[p + 1].length() &gt; 1)
 731                 ++p;
 732         } else {
 733             builder.append(&#39;-&#39;);
 734             builder.append(parts[p]);
 735         }
 736     }
 737     return builder.toString();
 738 }
 739 
<span class="line-modified"> 740 static MatcherResult lookupMatcher(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 741 {
 742     // LookupMatcher (availableLocales, requestedLocales)
 743     // https://tc39.github.io/ecma402/#sec-lookupmatcher
 744 
 745     String locale;
 746     String noExtensionsLocale;
 747     String availableLocale;
 748     for (size_t i = 0; i &lt; requestedLocales.size() &amp;&amp; availableLocale.isNull(); ++i) {
 749         locale = requestedLocales[i];
 750         noExtensionsLocale = removeUnicodeLocaleExtension(locale);
 751         availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
 752     }
 753 
 754     MatcherResult result;
 755     if (!availableLocale.isEmpty()) {
 756         result.locale = availableLocale;
 757         if (locale != noExtensionsLocale) {
 758             size_t extensionIndex = locale.find(&quot;-u-&quot;);
 759             RELEASE_ASSERT(extensionIndex != notFound);
 760 
 761             size_t extensionLength = locale.length() - extensionIndex;
 762             size_t end = extensionIndex + 3;
 763             while (end &lt; locale.length()) {
 764                 end = locale.find(&#39;-&#39;, end);
 765                 if (end == notFound)
 766                     break;
 767                 if (end + 2 &lt; locale.length() &amp;&amp; locale[end + 2] == &#39;-&#39;) {
 768                     extensionLength = end - extensionIndex;
 769                     break;
 770                 }
 771                 end++;
 772             }
 773             result.extension = locale.substring(extensionIndex, extensionLength);
 774             result.extensionIndex = extensionIndex;
 775         }
 776     } else
<span class="line-modified"> 777         result.locale = defaultLocale(globalObject);</span>
 778     return result;
 779 }
 780 
<span class="line-modified"> 781 static MatcherResult bestFitMatcher(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 782 {
 783     // BestFitMatcher (availableLocales, requestedLocales)
 784     // https://tc39.github.io/ecma402/#sec-bestfitmatcher
 785 
 786     // FIXME: Implement something better than lookup.
<span class="line-modified"> 787     return lookupMatcher(globalObject, availableLocales, requestedLocales);</span>
 788 }
 789 
 790 static void unicodeExtensionSubTags(const String&amp; extension, Vector&lt;String&gt;&amp; subtags)
 791 {
 792     // UnicodeExtensionSubtags (extension)
 793     // https://tc39.github.io/ecma402/#sec-unicodeextensionsubtags
 794 
 795     auto extensionLength = extension.length();
 796     if (extensionLength &lt; 3)
 797         return;
 798 
 799     size_t subtagStart = 3; // Skip initial -u-.
 800     size_t valueStart = 3;
 801     bool isLeading = true;
 802     for (size_t index = subtagStart; index &lt; extensionLength; ++index) {
 803         if (extension[index] == &#39;-&#39;) {
 804             if (index - subtagStart == 2) {
 805                 // Tag is a key, first append prior key&#39;s value if there is one.
 806                 if (subtagStart - valueStart &gt; 1)
 807                     subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
</pre>
<hr />
<pre>
 809                 valueStart = index + 1;
 810                 isLeading = false;
 811             } else if (isLeading) {
 812                 // Leading subtags before first key.
 813                 subtags.append(extension.substring(subtagStart, index - subtagStart));
 814                 valueStart = index + 1;
 815             }
 816             subtagStart = index + 1;
 817         }
 818     }
 819     if (extensionLength - subtagStart == 2) {
 820         // Trailing an extension key, first append prior key&#39;s value if there is one.
 821         if (subtagStart - valueStart &gt; 1)
 822             subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
 823         valueStart = subtagStart;
 824     }
 825     // Append final key&#39;s value.
 826     subtags.append(extension.substring(valueStart, extensionLength - valueStart));
 827 }
 828 
<span class="line-modified"> 829 HashMap&lt;String, String&gt; resolveLocale(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, const HashMap&lt;String, String&gt;&amp; options, const char* const relevantExtensionKeys[], size_t relevantExtensionKeyCount, Vector&lt;String&gt; (*localeData)(const String&amp;, size_t))</span>
 830 {
 831     // ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData)
 832     // https://tc39.github.io/ecma402/#sec-resolvelocale
 833 
 834     const String&amp; matcher = options.get(&quot;localeMatcher&quot;_s);
 835     MatcherResult matcherResult = (matcher == &quot;lookup&quot;)
<span class="line-modified"> 836         ? lookupMatcher(globalObject, availableLocales, requestedLocales)</span>
<span class="line-modified"> 837         : bestFitMatcher(globalObject, availableLocales, requestedLocales);</span>
 838 
 839     String foundLocale = matcherResult.locale;
 840 
 841     Vector&lt;String&gt; extensionSubtags;
 842     if (!matcherResult.extension.isNull())
 843         unicodeExtensionSubTags(matcherResult.extension, extensionSubtags);
 844 
 845     HashMap&lt;String, String&gt; result;
 846     result.add(&quot;dataLocale&quot;_s, foundLocale);
 847 
 848     String supportedExtension = &quot;-u&quot;_s;
 849     for (size_t keyIndex = 0; keyIndex &lt; relevantExtensionKeyCount; ++keyIndex) {
 850         const char* key = relevantExtensionKeys[keyIndex];
 851         Vector&lt;String&gt; keyLocaleData = localeData(foundLocale, keyIndex);
 852         ASSERT(!keyLocaleData.isEmpty());
 853 
 854         String value = keyLocaleData[0];
 855         String supportedExtensionAddition;
 856 
 857         if (!extensionSubtags.isEmpty()) {
</pre>
<hr />
<pre>
 876             // Null will remove the extension.
 877             if ((optionsValue.isNull() || keyLocaleData.contains(optionsValue)) &amp;&amp; optionsValue != value) {
 878                 value = optionsValue;
 879                 supportedExtensionAddition = String();
 880             }
 881         }
 882         result.add(key, value);
 883         supportedExtension.append(supportedExtensionAddition);
 884     }
 885 
 886     if (supportedExtension.length() &gt; 2) {
 887         String preExtension = foundLocale.substring(0, matcherResult.extensionIndex);
 888         String postExtension = foundLocale.substring(matcherResult.extensionIndex);
 889         foundLocale = preExtension + supportedExtension + postExtension;
 890     }
 891 
 892     result.add(&quot;locale&quot;_s, foundLocale);
 893     return result;
 894 }
 895 
<span class="line-modified"> 896 static JSArray* lookupSupportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 897 {
 898     // LookupSupportedLocales (availableLocales, requestedLocales)
 899     // https://tc39.github.io/ecma402/#sec-lookupsupportedlocales
 900 
<span class="line-modified"> 901     VM&amp; vm = globalObject-&gt;vm();</span>
 902     auto scope = DECLARE_THROW_SCOPE(vm);
 903 
 904     size_t len = requestedLocales.size();

 905     JSArray* subset = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), 0);
 906     if (!subset) {
<span class="line-modified"> 907         throwOutOfMemoryError(globalObject, scope);</span>
 908         return nullptr;
 909     }
 910 
 911     unsigned index = 0;
 912     for (size_t k = 0; k &lt; len; ++k) {
 913         const String&amp; locale = requestedLocales[k];
 914         String noExtensionsLocale = removeUnicodeLocaleExtension(locale);
 915         String availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
 916         if (!availableLocale.isNull()) {
<span class="line-modified"> 917             subset-&gt;putDirectIndex(globalObject, index++, jsString(vm, locale));</span>
 918             RETURN_IF_EXCEPTION(scope, nullptr);
 919         }
 920     }
 921 
 922     return subset;
 923 }
 924 
<span class="line-modified"> 925 static JSArray* bestFitSupportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
 926 {
 927     // BestFitSupportedLocales (availableLocales, requestedLocales)
 928     // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
 929 
 930     // FIXME: Implement something better than lookup.
<span class="line-modified"> 931     return lookupSupportedLocales(globalObject, availableLocales, requestedLocales);</span>
 932 }
 933 
<span class="line-modified"> 934 JSValue supportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, JSValue options)</span>
 935 {
 936     // SupportedLocales (availableLocales, requestedLocales, options)
 937     // https://tc39.github.io/ecma402/#sec-supportedlocales
 938 
<span class="line-modified"> 939     VM&amp; vm = globalObject-&gt;vm();</span>
 940     auto scope = DECLARE_THROW_SCOPE(vm);
 941     String matcher;
 942 
 943     if (!options.isUndefined()) {
<span class="line-modified"> 944         matcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
 945         RETURN_IF_EXCEPTION(scope, JSValue());
 946     } else
 947         matcher = &quot;best fit&quot;_s;
 948 
 949     JSArray* supportedLocales = (matcher == &quot;best fit&quot;)
<span class="line-modified"> 950         ? bestFitSupportedLocales(globalObject, availableLocales, requestedLocales)</span>
<span class="line-modified"> 951         : lookupSupportedLocales(globalObject, availableLocales, requestedLocales);</span>
 952     RETURN_IF_EXCEPTION(scope, JSValue());
 953 
 954     PropertyNameArray keys(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified"> 955     supportedLocales-&gt;getOwnPropertyNames(supportedLocales, globalObject, keys, EnumerationMode());</span>
 956     RETURN_IF_EXCEPTION(scope, JSValue());
 957 
 958     PropertyDescriptor desc;
 959     desc.setConfigurable(false);
 960     desc.setWritable(false);
 961 
 962     size_t len = keys.size();
 963     for (size_t i = 0; i &lt; len; ++i) {
<span class="line-modified"> 964         supportedLocales-&gt;defineOwnProperty(supportedLocales, globalObject, keys[i], desc, true);</span>
 965         RETURN_IF_EXCEPTION(scope, JSValue());
 966     }
<span class="line-modified"> 967     supportedLocales-&gt;defineOwnProperty(supportedLocales, globalObject, vm.propertyNames-&gt;length, desc, true);</span>
 968     RETURN_IF_EXCEPTION(scope, JSValue());
 969 
 970     return supportedLocales;
 971 }
 972 
 973 Vector&lt;String&gt; numberingSystemsForLocale(const String&amp; locale)
 974 {
 975     static NeverDestroyed&lt;Vector&lt;String&gt;&gt; cachedNumberingSystems;
 976     Vector&lt;String&gt;&amp; availableNumberingSystems = cachedNumberingSystems.get();
 977 
<span class="line-modified"> 978     static std::once_flag initializeOnce;</span>
<span class="line-modified"> 979     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-modified"> 980         ASSERT(availableNumberingSystems.isEmpty());</span>
<span class="line-modified"> 981         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 982         UEnumeration* numberingSystemNames = unumsys_openAvailableNames(&amp;status);</span>
<span class="line-modified"> 983         ASSERT(U_SUCCESS(status));</span>

 984 
<span class="line-modified"> 985         int32_t resultLength;</span>
<span class="line-modified"> 986         // Numbering system names are always ASCII, so use char[].</span>
<span class="line-modified"> 987         while (const char* result = uenum_next(numberingSystemNames, &amp;resultLength, &amp;status)) {</span>
<span class="line-modified"> 988             ASSERT(U_SUCCESS(status));</span>
<span class="line-modified"> 989             auto numsys = unumsys_openByName(result, &amp;status);</span>
<span class="line-modified"> 990             ASSERT(U_SUCCESS(status));</span>
<span class="line-modified"> 991             // Only support algorithmic if it is the default fot the locale, handled below.</span>
<span class="line-modified"> 992             if (!unumsys_isAlgorithmic(numsys))</span>
<span class="line-modified"> 993                 availableNumberingSystems.append(String(StringImpl::createStaticStringImpl(result, resultLength)));</span>
<span class="line-modified"> 994             unumsys_close(numsys);</span>


 995         }
<span class="line-modified"> 996         uenum_close(numberingSystemNames);</span>
<span class="line-added"> 997     });</span>
 998 
 999     UErrorCode status = U_ZERO_ERROR;
1000     UNumberingSystem* defaultSystem = unumsys_open(locale.utf8().data(), &amp;status);
1001     ASSERT(U_SUCCESS(status));
1002     String defaultSystemName(unumsys_getName(defaultSystem));
1003     unumsys_close(defaultSystem);
1004 
1005     Vector&lt;String&gt; numberingSystems({ defaultSystemName });
1006     numberingSystems.appendVector(availableNumberingSystems);
1007     return numberingSystems;
1008 }
1009 
<span class="line-modified">1010 EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1011 {
1012     // Intl.getCanonicalLocales(locales)
1013     // https://tc39.github.io/ecma402/#sec-intl.getcanonicallocales
1014 
<span class="line-modified">1015     VM&amp; vm = globalObject-&gt;vm();</span>
1016     auto scope = DECLARE_THROW_SCOPE(vm);
1017 
<span class="line-modified">1018     Vector&lt;String&gt; localeList = canonicalizeLocaleList(globalObject, callFrame-&gt;argument(0));</span>
1019     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1020     auto length = localeList.size();
1021 

1022     JSArray* localeArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), length);
1023     if (!localeArray) {
<span class="line-modified">1024         throwOutOfMemoryError(globalObject, scope);</span>
1025         return encodedJSValue();
1026     }
1027 
1028     for (size_t i = 0; i &lt; length; ++i) {
<span class="line-modified">1029         localeArray-&gt;putDirectIndex(globalObject, i, jsString(vm, localeList[i]));</span>
1030         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1031     }
1032     return JSValue::encode(localeArray);
1033 }
1034 
1035 } // namespace JSC
1036 
1037 #endif // ENABLE(INTL)
</pre>
</td>
</tr>
</table>
<center><a href="IntlNumberFormatPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
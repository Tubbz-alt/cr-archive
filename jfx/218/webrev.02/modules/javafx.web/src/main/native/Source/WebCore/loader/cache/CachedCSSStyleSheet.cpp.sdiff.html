<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedCSSStyleSheet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../archive/mhtml/MHTMLArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedFont.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedCSSStyleSheet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;CachedCSSStyleSheet.h&quot;
 26 
 27 #include &quot;CSSStyleSheet.h&quot;
 28 #include &quot;CachedResourceClientWalker.h&quot;
 29 #include &quot;CachedResourceRequest.h&quot;
 30 #include &quot;CachedStyleSheetClient.h&quot;
 31 #include &quot;HTTPHeaderNames.h&quot;
 32 #include &quot;HTTPParsers.h&quot;
 33 #include &quot;MemoryCache.h&quot;

 34 #include &quot;SharedBuffer.h&quot;
 35 #include &quot;StyleSheetContents.h&quot;
 36 #include &quot;TextResourceDecoder.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 CachedCSSStyleSheet::CachedCSSStyleSheet(CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 41     : CachedResource(WTFMove(request), Type::CSSStyleSheet, sessionID, cookieJar)
 42     , m_decoder(TextResourceDecoder::create(&quot;text/css&quot;, request.charset()))
 43 {
 44 }
 45 
 46 CachedCSSStyleSheet::~CachedCSSStyleSheet()
 47 {
 48     if (m_parsedStyleSheetCache)
 49         m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
 50 }
 51 
 52 void CachedCSSStyleSheet::didAddClient(CachedResourceClient&amp; client)
 53 {
</pre>
<hr />
<pre>
134     if (errorOccurred())
135         return false;
136 
137     if (!mimeTypeAllowedByNosniff()) {
138         if (hasValidMIMEType)
139             *hasValidMIMEType = false;
140         return false;
141     }
142 
143     if (mimeTypeCheckHint == MIMETypeCheckHint::Lax)
144         return true;
145 
146     // This check exactly matches Firefox.  Note that we grab the Content-Type
147     // header directly because we want to see what the value is BEFORE content
148     // sniffing.  Firefox does this by setting a &quot;type hint&quot; on the channel.
149     // This implementation should be observationally equivalent.
150     //
151     // This code defaults to allowing the stylesheet for non-HTTP protocols so
152     // folks can use standards mode for local HTML documents.
153     String mimeType = responseMIMEType();
<span class="line-modified">154     bool typeOK = mimeType.isEmpty() || equalLettersIgnoringASCIICase(mimeType, &quot;text/css&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;application/x-unknown-content-type&quot;);</span>
155     if (hasValidMIMEType)
156         *hasValidMIMEType = typeOK;
157     return typeOK;
158 }
159 
160 void CachedCSSStyleSheet::destroyDecodedData()
161 {
162     if (!m_parsedStyleSheetCache)
163         return;
164 
165     m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
166     m_parsedStyleSheetCache = nullptr;
167 
168     setDecodedSize(0);
169 }
170 
171 RefPtr&lt;StyleSheetContents&gt; CachedCSSStyleSheet::restoreParsedStyleSheet(const CSSParserContext&amp; context, CachePolicy cachePolicy, FrameLoader&amp; loader)
172 {
173     if (!m_parsedStyleSheetCache)
174         return nullptr;
</pre>
</td>
<td>
<hr />
<pre>
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;CachedCSSStyleSheet.h&quot;
 26 
 27 #include &quot;CSSStyleSheet.h&quot;
 28 #include &quot;CachedResourceClientWalker.h&quot;
 29 #include &quot;CachedResourceRequest.h&quot;
 30 #include &quot;CachedStyleSheetClient.h&quot;
 31 #include &quot;HTTPHeaderNames.h&quot;
 32 #include &quot;HTTPParsers.h&quot;
 33 #include &quot;MemoryCache.h&quot;
<span class="line-added"> 34 #include &quot;ParsedContentType.h&quot;</span>
 35 #include &quot;SharedBuffer.h&quot;
 36 #include &quot;StyleSheetContents.h&quot;
 37 #include &quot;TextResourceDecoder.h&quot;
 38 
 39 namespace WebCore {
 40 
 41 CachedCSSStyleSheet::CachedCSSStyleSheet(CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 42     : CachedResource(WTFMove(request), Type::CSSStyleSheet, sessionID, cookieJar)
 43     , m_decoder(TextResourceDecoder::create(&quot;text/css&quot;, request.charset()))
 44 {
 45 }
 46 
 47 CachedCSSStyleSheet::~CachedCSSStyleSheet()
 48 {
 49     if (m_parsedStyleSheetCache)
 50         m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
 51 }
 52 
 53 void CachedCSSStyleSheet::didAddClient(CachedResourceClient&amp; client)
 54 {
</pre>
<hr />
<pre>
135     if (errorOccurred())
136         return false;
137 
138     if (!mimeTypeAllowedByNosniff()) {
139         if (hasValidMIMEType)
140             *hasValidMIMEType = false;
141         return false;
142     }
143 
144     if (mimeTypeCheckHint == MIMETypeCheckHint::Lax)
145         return true;
146 
147     // This check exactly matches Firefox.  Note that we grab the Content-Type
148     // header directly because we want to see what the value is BEFORE content
149     // sniffing.  Firefox does this by setting a &quot;type hint&quot; on the channel.
150     // This implementation should be observationally equivalent.
151     //
152     // This code defaults to allowing the stylesheet for non-HTTP protocols so
153     // folks can use standards mode for local HTML documents.
154     String mimeType = responseMIMEType();
<span class="line-modified">155     bool typeOK = mimeType.isEmpty() || equalLettersIgnoringASCIICase(mimeType, &quot;text/css&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;application/x-unknown-content-type&quot;) || !isValidContentType(mimeType);</span>
156     if (hasValidMIMEType)
157         *hasValidMIMEType = typeOK;
158     return typeOK;
159 }
160 
161 void CachedCSSStyleSheet::destroyDecodedData()
162 {
163     if (!m_parsedStyleSheetCache)
164         return;
165 
166     m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
167     m_parsedStyleSheetCache = nullptr;
168 
169     setDecodedSize(0);
170 }
171 
172 RefPtr&lt;StyleSheetContents&gt; CachedCSSStyleSheet::restoreParsedStyleSheet(const CSSParserContext&amp; context, CachePolicy cachePolicy, FrameLoader&amp; loader)
173 {
174     if (!m_parsedStyleSheetCache)
175         return nullptr;
</pre>
</td>
</tr>
</table>
<center><a href="../archive/mhtml/MHTMLArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedFont.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
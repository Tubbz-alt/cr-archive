<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilderRuby.h&quot;
 28 
 29 #include &quot;RenderAncestorIterator.h&quot;
 30 #include &quot;RenderRuby.h&quot;
 31 #include &quot;RenderRubyBase.h&quot;
 32 #include &quot;RenderRubyRun.h&quot;
 33 #include &quot;RenderTreeBuilder.h&quot;
 34 #include &quot;RenderTreeBuilderBlock.h&quot;
 35 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 36 #include &quot;RenderTreeBuilderInline.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static inline RenderRubyRun&amp; findRubyRunParent(RenderObject&amp; child)
 41 {
 42     return *lineageOfType&lt;RenderRubyRun&gt;(child).first();
 43 }
 44 
 45 static inline bool isAnonymousRubyInlineBlock(const RenderObject* object)
 46 {
 47     ASSERT(!object
 48         || !isRuby(object-&gt;parent())
 49         || is&lt;RenderRubyRun&gt;(*object)
 50         || (object-&gt;isInline() &amp;&amp; (object-&gt;isBeforeContent() || object-&gt;isAfterContent()))
<a name="1" id="anc1"></a><span class="line-modified"> 51         || (object-&gt;isAnonymous() &amp;&amp; is&lt;RenderBlock&gt;(*object) &amp;&amp; object-&gt;style().display() == DisplayType::InlineBlock)</span>
<span class="line-added"> 52         || object-&gt;isRenderMultiColumnFlow()</span>
<span class="line-added"> 53         || object-&gt;isRenderMultiColumnSet());</span>
 54 
 55     return object
 56         &amp;&amp; isRuby(object-&gt;parent())
 57         &amp;&amp; is&lt;RenderBlock&gt;(*object)
 58         &amp;&amp; !is&lt;RenderRubyRun&gt;(*object);
 59 }
 60 
 61 static inline bool isRubyBeforeBlock(const RenderObject* object)
 62 {
 63     return isAnonymousRubyInlineBlock(object)
 64         &amp;&amp; !object-&gt;previousSibling()
 65         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 66         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::Before;
 67 }
 68 
 69 static inline bool isRubyAfterBlock(const RenderObject* object)
 70 {
 71     return isAnonymousRubyInlineBlock(object)
 72         &amp;&amp; !object-&gt;nextSibling()
 73         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 74         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::After;
 75 }
 76 
<a name="2" id="anc2"></a><span class="line-modified"> 77 #if ASSERT_ENABLED</span>
 78 static inline bool isRubyChildForNormalRemoval(const RenderObject&amp; object)
 79 {
 80     return object.isRubyRun()
 81     || object.isBeforeContent()
 82     || object.isAfterContent()
 83     || object.isRenderMultiColumnFlow()
 84     || object.isRenderMultiColumnSet()
 85     || isAnonymousRubyInlineBlock(&amp;object);
 86 }
<a name="3" id="anc3"></a><span class="line-modified"> 87 #endif // ASSERT_ENABLED</span>
 88 
 89 static inline RenderBlock* rubyBeforeBlock(const RenderElement* ruby)
 90 {
 91     RenderObject* child = ruby-&gt;firstChild();
 92     return isRubyBeforeBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 93 }
 94 
 95 static inline RenderBlock* rubyAfterBlock(const RenderElement* ruby)
 96 {
 97     RenderObject* child = ruby-&gt;lastChild();
 98     return isRubyAfterBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 99 }
100 
101 static auto createAnonymousRubyInlineBlock(RenderObject&amp; ruby)
102 {
103     auto newBlock = createRenderer&lt;RenderBlockFlow&gt;(ruby.document(), RenderStyle::createAnonymousStyleWithDisplay(ruby.style(), DisplayType::InlineBlock));
104     newBlock-&gt;initializeStyle();
105     return newBlock;
106 }
107 
108 static RenderRubyRun* lastRubyRun(const RenderElement* ruby)
109 {
110     RenderObject* child = ruby-&gt;lastChild();
111     if (child &amp;&amp; !is&lt;RenderRubyRun&gt;(*child))
112         child = child-&gt;previousSibling();
113     if (!is&lt;RenderRubyRun&gt;(child)) {
<a name="4" id="anc4"></a><span class="line-modified">114         ASSERT(!child || child-&gt;isBeforeContent() || child == rubyBeforeBlock(ruby) || child-&gt;isRenderMultiColumnFlow() || child-&gt;isRenderMultiColumnSet());</span>
115         return nullptr;
116     }
117     return downcast&lt;RenderRubyRun&gt;(child);
118 }
119 
120 RenderTreeBuilder::Ruby::Ruby(RenderTreeBuilder&amp; builder)
121     : m_builder(builder)
122 {
123 }
124 
125 void RenderTreeBuilder::Ruby::moveInlineChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
126 {
127     ASSERT(from.childrenInline());
128 
129     if (!from.firstChild())
130         return;
131 
132     RenderBlock* toBlock = nullptr;
133     if (to.childrenInline()) {
134         // The standard and easy case: move the children into the target base
135         toBlock = &amp;to;
136     } else {
137         // We need to wrap the inline objects into an anonymous block.
138         // If toBase has a suitable block, we re-use it, otherwise create a new one.
139         auto* lastChild = to.lastChild();
140         if (lastChild &amp;&amp; lastChild-&gt;isAnonymousBlock() &amp;&amp; lastChild-&gt;childrenInline())
141             toBlock = downcast&lt;RenderBlock&gt;(lastChild);
142         else {
143             auto newToBlock = to.createAnonymousBlock();
144             toBlock = newToBlock.get();
145             m_builder.attachToRenderElementInternal(to, WTFMove(newToBlock));
146         }
147     }
148     ASSERT(toBlock);
149     // Move our inline children into the target block we determined above.
150     m_builder.moveChildren(from, *toBlock, from.firstChild(), beforeChild, RenderTreeBuilder::NormalizeAfterInsertion::No);
151 }
152 
153 void RenderTreeBuilder::Ruby::moveBlockChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
154 {
155     ASSERT(!from.childrenInline());
156 
157     if (!from.firstChild())
158         return;
159 
160     if (to.childrenInline())
161         m_builder.makeChildrenNonInline(to);
162 
163     // If an anonymous block would be put next to another such block, then merge those.
164     auto* firstChildHere = from.firstChild();
165     auto* lastChildThere = to.lastChild();
166     if (firstChildHere-&gt;isAnonymousBlock() &amp;&amp; firstChildHere-&gt;childrenInline()
167         &amp;&amp; lastChildThere &amp;&amp; lastChildThere-&gt;isAnonymousBlock() &amp;&amp; lastChildThere-&gt;childrenInline()) {
168         auto* anonBlockHere = downcast&lt;RenderBlock&gt;(firstChildHere);
169         auto* anonBlockThere = downcast&lt;RenderBlock&gt;(lastChildThere);
170         m_builder.moveAllChildren(*anonBlockHere, *anonBlockThere, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
171         anonBlockHere-&gt;deleteLines();
172         m_builder.destroy(*anonBlockHere);
173     }
174     // Move all remaining children normally.
175     m_builder.moveChildren(from, to, from.firstChild(), beforeChild, RenderTreeBuilder::NormalizeAfterInsertion::No);
176 }
177 
178 void RenderTreeBuilder::Ruby::moveChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to)
179 {
180     moveChildrenInternal(from, to);
181     from.addFloatsToNewParent(to);
182 }
183 
184 void RenderTreeBuilder::Ruby::moveChildrenInternal(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
185 {
186     // This function removes all children that are before (!) beforeChild
187     // and appends them to toBase.
188     if (beforeChild &amp;&amp; beforeChild-&gt;parent() != &amp;from)
189         beforeChild = m_builder.splitAnonymousBoxesAroundChild(from, *beforeChild);
190 
191     if (from.childrenInline())
192         moveInlineChildren(from, to, beforeChild);
193     else
194         moveBlockChildren(from, to, beforeChild);
195 
196     from.setNeedsLayoutAndPrefWidthsRecalc();
197     to.setNeedsLayoutAndPrefWidthsRecalc();
198 }
199 
200 void RenderTreeBuilder::Ruby::attach(RenderRubyRun&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
201 {
202     if (child-&gt;isRubyText()) {
203         if (!beforeChild) {
204             // RenderRuby has already ascertained that we can add the child here.
205             ASSERT(!parent.hasRubyText());
206             // prepend ruby texts as first child
207             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), parent.firstChild());
208             return;
209         }
210         if (beforeChild-&gt;isRubyText()) {
211             // New text is inserted just before another.
212             // In this case the new text takes the place of the old one, and
213             // the old text goes into a new run that is inserted as next sibling.
214             ASSERT(beforeChild-&gt;parent() == &amp;parent);
215             RenderElement* ruby = parent.parent();
216             ASSERT(isRuby(ruby));
217             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
<a name="5" id="anc5"></a><span class="line-added">218             auto&amp; run = *newRun;</span>
219             m_builder.attach(*ruby, WTFMove(newRun), parent.nextSibling());
220             // Add the new ruby text and move the old one to the new run
221             // Note: Doing it in this order and not using RenderRubyRun&#39;s methods,
222             // in order to avoid automatic removal of the ruby run in case there is no
223             // other child besides the old ruby text.
224             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), beforeChild);
225             auto takenBeforeChild = m_builder.blockBuilder().detach(parent, *beforeChild);
226 
<a name="6" id="anc6"></a><span class="line-modified">227             m_builder.attach(run, WTFMove(takenBeforeChild));</span>
228             return;
229         }
230         if (parent.hasRubyBase()) {
231             // Insertion before a ruby base object.
232             // In this case we need insert a new run before the current one and split the base.
233             RenderElement* ruby = parent.parent();
234             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
235             auto&amp; run = *newRun;
236             m_builder.attach(*ruby, WTFMove(newRun), &amp;parent);
237             m_builder.attach(run, WTFMove(child));
238             moveChildrenInternal(rubyBaseSafe(parent), rubyBaseSafe(run), beforeChild);
239         }
240         return;
241     }
242     // child is not a text -&gt; insert it into the base
243     // (append it instead if beforeChild is the ruby text)
244     if (beforeChild &amp;&amp; beforeChild-&gt;isRubyText())
245         beforeChild = nullptr;
246     m_builder.attach(rubyBaseSafe(parent), WTFMove(child), beforeChild);
247 }
248 
249 RenderElement&amp; RenderTreeBuilder::Ruby::findOrCreateParentForChild(RenderRubyAsBlock&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
250 {
251     // Insert :before and :after content before/after the RenderRubyRun(s)
252     if (child.isBeforeContent()) {
253         // Add generated inline content normally
254         if (child.isInline())
255             return parent;
256         // Wrap non-inline content in an anonymous inline-block.
257         auto* beforeBlock = rubyBeforeBlock(&amp;parent);
258         if (!beforeBlock) {
259             auto newBlock = createAnonymousRubyInlineBlock(parent);
260             beforeBlock = newBlock.get();
261             m_builder.blockFlowBuilder().attach(parent, WTFMove(newBlock), parent.firstChild());
262         }
263         beforeChild = nullptr;
264         return *beforeBlock;
265     }
266 
267     if (child.isAfterContent()) {
268         // Add generated inline content normally
269         if (child.isInline())
270             return parent;
271         // Wrap non-inline content with an anonymous inline-block.
272         auto* afterBlock = rubyAfterBlock(&amp;parent);
273         if (!afterBlock) {
274             auto newBlock = createAnonymousRubyInlineBlock(parent);
275             afterBlock = newBlock.get();
276             m_builder.blockFlowBuilder().attach(parent, WTFMove(newBlock), nullptr);
277         }
278         beforeChild = nullptr;
279         return *afterBlock;
280     }
281 
282     // If the child is a ruby run, just add it normally.
283     if (child.isRubyRun())
284         return parent;
285 
286     if (beforeChild &amp;&amp; !parent.isAfterContent(beforeChild)) {
287         // insert child into run
288         ASSERT(!beforeChild-&gt;isRubyRun());
289         auto* run = beforeChild-&gt;parent();
290         while (run &amp;&amp; !run-&gt;isRubyRun())
291             run = run-&gt;parent();
292         if (run)
293             return *run;
294         ASSERT_NOT_REACHED(); // beforeChild should always have a run as parent!
295         // Emergency fallback: fall through and just append.
296     }
297 
298     // If the new child would be appended, try to add the child to the previous run
299     // if possible, or create a new run otherwise.
300     // (The RenderRubyRun object will handle the details)
301     auto* lastRun = lastRubyRun(&amp;parent);
302     if (!lastRun || lastRun-&gt;hasRubyText()) {
303         auto newRun = RenderRubyRun::staticCreateRubyRun(&amp;parent);
304         lastRun = newRun.get();
305         m_builder.blockFlowBuilder().attach(parent, WTFMove(newRun), beforeChild);
306     }
307     beforeChild = nullptr;
308     return *lastRun;
309 }
310 
311 RenderElement&amp; RenderTreeBuilder::Ruby::findOrCreateParentForChild(RenderRubyAsInline&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
312 {
313     // Insert :before and :after content before/after the RenderRubyRun(s)
314     if (child.isBeforeContent()) {
315         // Add generated inline content normally
316         if (child.isInline())
317             return parent;
318         // Wrap non-inline content with an anonymous inline-block.
319         auto* beforeBlock = rubyBeforeBlock(&amp;parent);
320         if (!beforeBlock) {
321             auto newBlock = createAnonymousRubyInlineBlock(parent);
322             beforeBlock = newBlock.get();
323             m_builder.inlineBuilder().attach(parent, WTFMove(newBlock), parent.firstChild());
324         }
325         beforeChild = nullptr;
326         return *beforeBlock;
327     }
328 
329     if (child.isAfterContent()) {
330         // Add generated inline content normally
331         if (child.isInline())
332             return parent;
333         // Wrap non-inline content with an anonymous inline-block.
334         auto* afterBlock = rubyAfterBlock(&amp;parent);
335         if (!afterBlock) {
336             auto newBlock = createAnonymousRubyInlineBlock(parent);
337             afterBlock = newBlock.get();
338             m_builder.inlineBuilder().attach(parent, WTFMove(newBlock), nullptr);
339         }
340         beforeChild = nullptr;
341         return *afterBlock;
342     }
343 
344     // If the child is a ruby run, just add it normally.
345     if (child.isRubyRun())
346         return parent;
347 
348     if (beforeChild &amp;&amp; !parent.isAfterContent(beforeChild)) {
349         // insert child into run
350         ASSERT(!beforeChild-&gt;isRubyRun());
351         auto* run = beforeChild-&gt;parent();
352         while (run &amp;&amp; !run-&gt;isRubyRun())
353             run = run-&gt;parent();
354         if (run)
355             return *run;
356         ASSERT_NOT_REACHED(); // beforeChild should always have a run as parent!
357         // Emergency fallback: fall through and just append.
358     }
359 
360     // If the new child would be appended, try to add the child to the previous run
361     // if possible, or create a new run otherwise.
362     // (The RenderRubyRun object will handle the details)
363     auto* lastRun = lastRubyRun(&amp;parent);
364     if (!lastRun || lastRun-&gt;hasRubyText()) {
365         auto newRun = RenderRubyRun::staticCreateRubyRun(&amp;parent);
366         lastRun = newRun.get();
367         m_builder.inlineBuilder().attach(parent, WTFMove(newRun), beforeChild);
368     }
369     beforeChild = nullptr;
370     return *lastRun;
371 }
372 
373 RenderRubyBase&amp; RenderTreeBuilder::Ruby::rubyBaseSafe(RenderRubyRun&amp; rubyRun)
374 {
375     auto* base = rubyRun.rubyBase();
376     if (!base) {
377         auto newBase = rubyRun.createRubyBase();
378         base = newBase.get();
379         m_builder.blockFlowBuilder().attach(rubyRun, WTFMove(newBase), nullptr);
380     }
381     return *base;
382 }
383 
384 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsInline&amp; parent, RenderObject&amp; child)
385 {
386     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
387     // just use the normal remove method.
388     if (child.parent() == &amp;parent) {
<a name="7" id="anc7"></a>
389         ASSERT(isRubyChildForNormalRemoval(child));
<a name="8" id="anc8"></a>
390         return m_builder.detachFromRenderElement(parent, child);
391     }
392     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
393     // just use the block&#39;s remove method.
394     if (isAnonymousRubyInlineBlock(child.parent())) {
395         ASSERT(child.isBeforeContent() || child.isAfterContent());
396         auto&amp; parent = *child.parent();
397         auto takenChild = m_builder.detach(parent, child);
398         m_builder.destroy(parent);
399         return takenChild;
400     }
401 
402     // Otherwise find the containing run and remove it from there.
403     return m_builder.detach(findRubyRunParent(child), child);
404 }
405 
406 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsBlock&amp; parent, RenderObject&amp; child)
407 {
408     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
409     // just use the normal remove method.
410     if (child.parent() == &amp;parent) {
<a name="9" id="anc9"></a>
411         ASSERT(isRubyChildForNormalRemoval(child));
<a name="10" id="anc10"></a>
412         return m_builder.blockBuilder().detach(parent, child);
413     }
414     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
415     // just use the block&#39;s remove method.
416     if (isAnonymousRubyInlineBlock(child.parent())) {
417         ASSERT(child.isBeforeContent() || child.isAfterContent());
418         auto&amp; parent = *child.parent();
419         auto takenChild = m_builder.detach(parent, child);
420         m_builder.destroy(parent);
421         return takenChild;
422     }
423 
424     // Otherwise find the containing run and remove it from there.
425     return m_builder.detach(findRubyRunParent(child), child);
426 }
427 
428 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyRun&amp; parent, RenderObject&amp; child)
429 {
430     // If the child is a ruby text, then merge the ruby base with the base of
431     // the right sibling run, if possible.
432     if (!parent.beingDestroyed() &amp;&amp; !parent.renderTreeBeingDestroyed() &amp;&amp; child.isRubyText()) {
433         RenderRubyBase* base = parent.rubyBase();
434         RenderObject* rightNeighbour = parent.nextSibling();
435         if (base &amp;&amp; is&lt;RenderRubyRun&gt;(rightNeighbour)) {
436             // Ruby run without a base can happen only at the first run.
437             RenderRubyRun&amp; rightRun = downcast&lt;RenderRubyRun&gt;(*rightNeighbour);
438             if (rightRun.hasRubyBase()) {
439                 RenderRubyBase* rightBase = rightRun.rubyBase();
440                 // Collect all children in a single base, then swap the bases.
441                 moveChildren(*rightBase, *base);
442                 m_builder.move(parent, rightRun, *base, RenderTreeBuilder::NormalizeAfterInsertion::No);
443                 m_builder.move(rightRun, parent, *rightBase, RenderTreeBuilder::NormalizeAfterInsertion::No);
444                 // The now empty ruby base will be removed below.
445                 ASSERT(!parent.rubyBase()-&gt;firstChild());
446             }
447         }
448     }
449 
450     auto takenChild = m_builder.blockBuilder().detach(parent, child);
451 
452     if (!parent.beingDestroyed() &amp;&amp; !parent.renderTreeBeingDestroyed()) {
453         // Check if our base (if any) is now empty. If so, destroy it.
454         RenderBlock* base = parent.rubyBase();
455         if (base &amp;&amp; !base-&gt;firstChild()) {
456             auto takenBase = m_builder.blockBuilder().detach(parent, *base);
457             base-&gt;deleteLines();
458         }
459     }
460     return takenChild;
461 }
462 
463 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
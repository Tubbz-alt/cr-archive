<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/FastMalloc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FastBitVector.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/FastMalloc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -43,10 +43,24 @@</span>
  #if OS(DARWIN)
  #include &lt;mach/mach_init.h&gt;
  #include &lt;malloc/malloc.h&gt;
  #endif
  
<span class="udiff-line-added">+ #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="udiff-line-added">+ #include &lt;wtf/Atomics.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;wtf/HashMap.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;wtf/Lock.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;wtf/NeverDestroyed.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;wtf/SetForScope.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;wtf/StackShot.h&gt;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if PLATFORM(COCOA)</span>
<span class="udiff-line-added">+ #include &lt;notify.h&gt;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  namespace WTF {
  
  #if !defined(NDEBUG)
  namespace {
  // We do not use std::numeric_limits&lt;size_t&gt;::max() here due to the edge case in VC++.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -258,27 +272,222 @@</span>
      OSAllocator::decommit(ptr, size);
  }
  
  void fastEnableMiniMode() { }
  
<span class="udiff-line-added">+ void fastMallocDumpMallocStats() { }</span>
<span class="udiff-line-added">+ </span>
  } // namespace WTF
  
  #else // defined(USE_SYSTEM_MALLOC) &amp;&amp; USE_SYSTEM_MALLOC
  
  #include &lt;bmalloc/bmalloc.h&gt;
  
  namespace WTF {
  
<span class="udiff-line-added">+ #define TRACK_MALLOC_CALLSTACK 0</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static ThreadSpecificKey avoidRecordingCountKey { InvalidThreadSpecificKey };</span>
<span class="udiff-line-added">+ class AvoidRecordingScope {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+     AvoidRecordingScope();</span>
<span class="udiff-line-added">+     ~AvoidRecordingScope();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static uintptr_t avoidRecordingCount()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         return bitwise_cast&lt;uintptr_t&gt;(threadSpecificGet(avoidRecordingCountKey));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ AvoidRecordingScope::AvoidRecordingScope()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     static std::once_flag onceKey;</span>
<span class="udiff-line-added">+     std::call_once(onceKey, [] {</span>
<span class="udiff-line-added">+         // The value stored in TLS is initially 0.</span>
<span class="udiff-line-added">+         threadSpecificKeyCreate(&amp;avoidRecordingCountKey, [](void*) { });</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+     threadSpecificSet(avoidRecordingCountKey, bitwise_cast&lt;void*&gt;(avoidRecordingCount() + 1));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ AvoidRecordingScope::~AvoidRecordingScope()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     threadSpecificSet(avoidRecordingCountKey, bitwise_cast&lt;void*&gt;(avoidRecordingCount() - 1));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class MallocCallTracker {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+     MallocCallTracker();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void recordMalloc(void*, size_t);</span>
<span class="udiff-line-added">+     void recordRealloc(void* oldAddress, void* newAddress, size_t);</span>
<span class="udiff-line-added">+     void recordFree(void*);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void dumpStats();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static MallocCallTracker&amp; singleton();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     struct MallocSiteData {</span>
<span class="udiff-line-added">+         StackShot stack;</span>
<span class="udiff-line-added">+         size_t size;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         MallocSiteData(size_t stackSize, size_t allocationSize)</span>
<span class="udiff-line-added">+             : stack(stackSize)</span>
<span class="udiff-line-added">+             , size(allocationSize)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     HashMap&lt;void*, std::unique_ptr&lt;MallocSiteData&gt;&gt; m_addressMallocSiteData;</span>
<span class="udiff-line-added">+     Lock m_mutex;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ MallocCallTracker&amp; MallocCallTracker::singleton()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     AvoidRecordingScope avoidRecording;</span>
<span class="udiff-line-added">+     static NeverDestroyed&lt;MallocCallTracker&gt; tracker;</span>
<span class="udiff-line-added">+     return tracker;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ MallocCallTracker::MallocCallTracker()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     int token;</span>
<span class="udiff-line-added">+     notify_register_dispatch(&quot;com.apple.WebKit.dumpUntrackedMallocs&quot;, &amp;token, dispatch_get_main_queue(), ^(int) {</span>
<span class="udiff-line-added">+         MallocCallTracker::singleton().dumpStats();</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MallocCallTracker::recordMalloc(void* address, size_t allocationSize)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     AvoidRecordingScope avoidRecording;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Intentionally using std::make_unique not to use FastMalloc for data structure tracking FastMalloc.</span>
<span class="udiff-line-added">+     const size_t stackSize = 10;</span>
<span class="udiff-line-added">+     auto siteData = std::make_unique&lt;MallocSiteData&gt;(stackSize, allocationSize);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto locker = holdLock(m_mutex);</span>
<span class="udiff-line-added">+     auto addResult = m_addressMallocSiteData.add(address, WTFMove(siteData));</span>
<span class="udiff-line-added">+     UNUSED_PARAM(addResult);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MallocCallTracker::recordRealloc(void* oldAddress, void* newAddress, size_t newSize)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     AvoidRecordingScope avoidRecording;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto locker = holdLock(m_mutex);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto it = m_addressMallocSiteData.find(oldAddress);</span>
<span class="udiff-line-added">+     if (it == m_addressMallocSiteData.end()) {</span>
<span class="udiff-line-added">+         ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     it-&gt;value-&gt;size = newSize;</span>
<span class="udiff-line-added">+     if (oldAddress != newAddress) {</span>
<span class="udiff-line-added">+         auto value = WTFMove(it-&gt;value);</span>
<span class="udiff-line-added">+         m_addressMallocSiteData.remove(it);</span>
<span class="udiff-line-added">+         auto addResult = m_addressMallocSiteData.add(newAddress, WTFMove(value));</span>
<span class="udiff-line-added">+         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MallocCallTracker::recordFree(void* address)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     AvoidRecordingScope avoidRecording;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto locker = holdLock(m_mutex);</span>
<span class="udiff-line-added">+     bool removed = m_addressMallocSiteData.remove(address);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(removed);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MallocCallTracker::dumpStats()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     AvoidRecordingScope avoidRecording;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         auto locker = holdLock(m_mutex);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Build a hash of stack to address vector</span>
<span class="udiff-line-added">+         struct MallocSiteTotals {</span>
<span class="udiff-line-added">+             Vector&lt;MallocSiteData*&gt; siteData;</span>
<span class="udiff-line-added">+             size_t count { 0 };</span>
<span class="udiff-line-added">+             size_t totalSize { 0 };</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         size_t totalUntrackedSize = 0;</span>
<span class="udiff-line-added">+         size_t totalUntrackedCount = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         HashMap&lt;unsigned, std::unique_ptr&lt;MallocSiteTotals&gt;&gt; callSiteToMallocData;</span>
<span class="udiff-line-added">+         for (const auto&amp; it : m_addressMallocSiteData) {</span>
<span class="udiff-line-added">+             auto result = callSiteToMallocData.ensure(it.value-&gt;stack.hash(), [] () {</span>
<span class="udiff-line-added">+                 // Intentionally using std::make_unique not to use FastMalloc for data structure tracking FastMalloc.</span>
<span class="udiff-line-added">+                 return std::make_unique&lt;MallocSiteTotals&gt;();</span>
<span class="udiff-line-added">+             });</span>
<span class="udiff-line-added">+             auto&amp; siteTotal = result.iterator-&gt;value;</span>
<span class="udiff-line-added">+             siteTotal-&gt;siteData.append(it.value.get());</span>
<span class="udiff-line-added">+             ++siteTotal-&gt;count;</span>
<span class="udiff-line-added">+             siteTotal-&gt;totalSize += it.value-&gt;size;</span>
<span class="udiff-line-added">+             totalUntrackedSize += it.value-&gt;size;</span>
<span class="udiff-line-added">+             ++totalUntrackedCount;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Vector&lt;unsigned&gt; stackHashes;</span>
<span class="udiff-line-added">+         auto stackKeys = callSiteToMallocData.keys();</span>
<span class="udiff-line-added">+         for (auto key : stackKeys)</span>
<span class="udiff-line-added">+             stackHashes.append(key);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Sort by reverse total size.</span>
<span class="udiff-line-added">+         std::sort(stackHashes.begin(), stackHashes.end(), [&amp;] (unsigned a, unsigned b) {</span>
<span class="udiff-line-added">+             const auto&amp; aSiteTotals = callSiteToMallocData.get(a);</span>
<span class="udiff-line-added">+             const auto&amp; bSiteTotals = callSiteToMallocData.get(b);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             return aSiteTotals-&gt;totalSize &gt; bSiteTotals-&gt;totalSize;</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         WTFLogAlways(&quot;Total untracked bytes: %lu (%lu allocations)\n&quot;, totalUntrackedSize, totalUntrackedCount);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         const size_t numStacksToDump = 100;</span>
<span class="udiff-line-added">+         for (size_t i = 0; i &lt; std::min(numStacksToDump, stackHashes.size()); ++i) {</span>
<span class="udiff-line-added">+             const auto&amp; mallocDataForStack = callSiteToMallocData.get(stackHashes[i]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             WTFLogAlways(&quot;Total allocation size: %lu (%lu allocations)\n&quot;, mallocDataForStack-&gt;totalSize, mallocDataForStack-&gt;count);</span>
<span class="udiff-line-added">+             // FIXME: Add a way to remove some entries in StackShot in a programable way.</span>
<span class="udiff-line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=205701</span>
<span class="udiff-line-added">+             const size_t framesToSkip = 6;</span>
<span class="udiff-line-added">+             WTFPrintBacktrace(mallocDataForStack-&gt;siteData[0]-&gt;stack.array() + framesToSkip, mallocDataForStack-&gt;siteData[0]-&gt;stack.size() - framesToSkip);</span>
<span class="udiff-line-added">+             WTFLogAlways(&quot;\n&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ void fastMallocDumpMallocStats()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     MallocCallTracker::singleton().dumpStats();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ void fastMallocDumpMallocStats()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  bool isFastMallocEnabled()
  {
      return bmalloc::api::isEnabled();
  }
  
  void* fastMalloc(size_t size)
  {
      ASSERT_IS_WITHIN_LIMIT(size);
<span class="udiff-line-modified-removed">-     return bmalloc::api::malloc(size);</span>
<span class="udiff-line-modified-added">+     void* result = bmalloc::api::malloc(size);</span>
<span class="udiff-line-added">+ #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="udiff-line-added">+     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="udiff-line-added">+         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     return result;</span>
  }
  
  void* fastCalloc(size_t numElements, size_t elementSize)
  {
      ASSERT_IS_WITHIN_LIMIT(numElements * elementSize);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,16 +500,25 @@</span>
  }
  
  void* fastRealloc(void* object, size_t size)
  {
      ASSERT_IS_WITHIN_LIMIT(size);
<span class="udiff-line-modified-removed">-     return bmalloc::api::realloc(object, size);</span>
<span class="udiff-line-modified-added">+     void* result = bmalloc::api::realloc(object, size);</span>
<span class="udiff-line-added">+ #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="udiff-line-added">+     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="udiff-line-added">+         MallocCallTracker::singleton().recordRealloc(object, result, size);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     return result;</span>
  }
  
  void fastFree(void* object)
  {
      bmalloc::api::free(object);
<span class="udiff-line-added">+ #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="udiff-line-added">+     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="udiff-line-added">+         MallocCallTracker::singleton().recordFree(object);</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  size_t fastMallocSize(const void*)
  {
      // FIXME: This is incorrect; best fix is probably to remove this function.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -315,17 +533,27 @@</span>
  }
  
  void* fastAlignedMalloc(size_t alignment, size_t size)
  {
      ASSERT_IS_WITHIN_LIMIT(size);
<span class="udiff-line-modified-removed">-     return bmalloc::api::memalign(alignment, size);</span>
<span class="udiff-line-modified-added">+     void* result = bmalloc::api::memalign(alignment, size);</span>
<span class="udiff-line-added">+ #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="udiff-line-added">+     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="udiff-line-added">+         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     return result;</span>
  }
  
  void* tryFastAlignedMalloc(size_t alignment, size_t size)
  {
      FAIL_IF_EXCEEDS_LIMIT(size);
<span class="udiff-line-modified-removed">-     return bmalloc::api::tryMemalign(alignment, size);</span>
<span class="udiff-line-modified-added">+     void* result = bmalloc::api::tryMemalign(alignment, size);</span>
<span class="udiff-line-added">+ #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="udiff-line-added">+     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="udiff-line-added">+         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     return result;</span>
  }
  
  void fastAlignedFree(void* p)
  {
      bmalloc::api::free(p);
</pre>
<center><a href="FastBitVector.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPropertyParserHelpers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSSupportsParser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
192     case CSSSelector::PseudoClassIncrement:
193     case CSSSelector::PseudoClassStart:
194     case CSSSelector::PseudoClassEnd:
195     case CSSSelector::PseudoClassDoubleButton:
196     case CSSSelector::PseudoClassSingleButton:
197     case CSSSelector::PseudoClassNoButton:
198     case CSSSelector::PseudoClassCornerPresent:
199     case CSSSelector::PseudoClassWindowInactive:
200         return true;
201     default:
202         return false;
203     }
204 }
205 
206 bool isUserActionPseudoClass(CSSSelector::PseudoClassType pseudo)
207 {
208     switch (pseudo) {
209     case CSSSelector::PseudoClassHover:
210     case CSSSelector::PseudoClassFocus:
211     case CSSSelector::PseudoClassActive:

212         return true;
213     default:
214         return false;
215     }
216 }
217 
218 bool isPseudoClassValidAfterPseudoElement(CSSSelector::PseudoClassType pseudoClass, CSSSelector::PseudoElementType compoundPseudoElement)
219 {
220     switch (compoundPseudoElement) {


221     case CSSSelector::PseudoElementResizer:
222     case CSSSelector::PseudoElementScrollbar:
223     case CSSSelector::PseudoElementScrollbarCorner:
224     case CSSSelector::PseudoElementScrollbarButton:
225     case CSSSelector::PseudoElementScrollbarThumb:
226     case CSSSelector::PseudoElementScrollbarTrack:
227     case CSSSelector::PseudoElementScrollbarTrackPiece:
228         return isScrollbarPseudoClass(pseudoClass);
229     case CSSSelector::PseudoElementSelection:
230         return pseudoClass == CSSSelector::PseudoClassWindowInactive;
231     case CSSSelector::PseudoElementWebKitCustom:
232     case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
233         return isUserActionPseudoClass(pseudoClass);
234     default:
235         return false;
236     }
237 }
238 
239 bool isSimpleSelectorValidAfterPseudoElement(const CSSParserSelector&amp; simpleSelector, CSSSelector::PseudoElementType compoundPseudoElement)
240 {
241     if (compoundPseudoElement == CSSSelector::PseudoElementUnknown)
242         return true;
<span class="line-modified">243     // FIXME-NEWPARSER: This doesn&#39;t exist for us.</span>
<span class="line-modified">244     // if (compoundPseudoElement == CSSSelector::PseudoElementContent)</span>
<span class="line-modified">245     //    return simpleSelector.match() != CSSSelector::PseudoElement;</span>

246     if (simpleSelector.match() != CSSSelector::PseudoClass)
247         return false;
248     CSSSelector::PseudoClassType pseudo = simpleSelector.pseudoClassType();
249     if (pseudo == CSSSelector::PseudoClassNot) {
250         ASSERT(simpleSelector.selectorList());
251         ASSERT(simpleSelector.selectorList()-&gt;first());
252         pseudo = simpleSelector.selectorList()-&gt;first()-&gt;pseudoClassType();
253     }
254     return isPseudoClassValidAfterPseudoElement(pseudo, compoundPseudoElement);
255 }
256 
257 } // namespace
258 
259 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeCompoundSelector(CSSParserTokenRange&amp; range)
260 {
261     std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector;
262 
263     AtomString namespacePrefix;
264     AtomString elementName;
265     CSSSelector::PseudoElementType compoundPseudoElement = CSSSelector::PseudoElementUnknown;
</pre>
<hr />
<pre>
445     case CSSSelector::PseudoClassNthLastChild:
446     case CSSSelector::PseudoClassNthOfType:
447     case CSSSelector::PseudoClassNthLastOfType:
448     case CSSSelector::PseudoClassLang:
449     case CSSSelector::PseudoClassAny:
450 #if ENABLE(CSS_SELECTORS_LEVEL4)
451     case CSSSelector::PseudoClassDir:
452     case CSSSelector::PseudoClassRole:
453 #endif
454         return true;
455     default:
456         break;
457     }
458     return false;
459 }
460 
461 static bool isOnlyPseudoElementFunction(CSSSelector::PseudoElementType pseudoElementType)
462 {
463     // Note that we omit cue since it can be both an ident or a function.
464     switch (pseudoElementType) {

465     case CSSSelector::PseudoElementSlotted:
466         return true;
467     default:
468         break;
469     }
470     return false;
471 }
472 
473 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumePseudo(CSSParserTokenRange&amp; range)
474 {
475     ASSERT(range.peek().type() == ColonToken);
476     range.consume();
477 
478     int colons = 1;
479     if (range.peek().type() == ColonToken) {
480         range.consume();
481         colons++;
482     }
483 
484     const CSSParserToken&amp; token = range.peek();
485     if (token.type() != IdentToken &amp;&amp; token.type() != FunctionToken)
486         return nullptr;
487 
488     std::unique_ptr&lt;CSSParserSelector&gt; selector;
489 
490     if (colons == 1) {
491         selector = CSSParserSelector::parsePseudoClassSelector(token.value());
<span class="line-modified">492 #if ENABLE(ATTACHMENT_ELEMENT)</span>
<span class="line-removed">493         if (!m_context.attachmentEnabled &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassHasAttachment)</span>
494             return nullptr;






495 #endif

496     } else {
497         selector = CSSParserSelector::parsePseudoElementSelector(token.value());
498 #if ENABLE(VIDEO_TRACK)
499         // Treat the ident version of cue as PseudoElementWebkitCustom.
500         if (token.type() == IdentToken &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; selector-&gt;pseudoElementType() == CSSSelector::PseudoElementCue)
501             selector-&gt;setPseudoElementType(CSSSelector::PseudoElementWebKitCustom);
502 #endif
503     }
504 
505     if (!selector || (selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; m_disallowPseudoElements))
506         return nullptr;
507 
508     if (token.type() == IdentToken) {
509         range.consume();
510         if ((selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; (selector-&gt;pseudoElementType() == CSSSelector::PseudoElementUnknown || isOnlyPseudoElementFunction(selector-&gt;pseudoElementType())))
511             || (selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; (selector-&gt;pseudoClassType() == CSSSelector::PseudoClassUnknown || isOnlyPseudoClassFunction(selector-&gt;pseudoClassType()))))
512             return nullptr;
513         return selector;
514     }
515 
</pre>
<hr />
<pre>
550                 if (!equalIgnoringASCIICase(ident.value(), &quot;of&quot;))
551                     return nullptr;
552                 if (block.peek().type() != WhitespaceToken)
553                     return nullptr;
554                 DisallowPseudoElementsScope scope(this);
555                 block.consumeWhitespace();
556                 std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
557                 *selectorList = consumeComplexSelectorList(block);
558                 if (!selectorList-&gt;first() || !block.atEnd())
559                     return nullptr;
560                 selector-&gt;setSelectorList(WTFMove(selectorList));
561             }
562             selector-&gt;setNth(ab.first, ab.second);
563             return selector;
564         }
565         case CSSSelector::PseudoClassLang: {
566             // FIXME: CSS Selectors Level 4 allows :lang(*-foo)
567             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();
568             if (!consumeLangArgumentList(argumentList, block))
569                 return nullptr;
<span class="line-modified">570             selector-&gt;setLangArgumentList(WTFMove(argumentList));</span>
571             return selector;
572         }
573         case CSSSelector::PseudoClassMatches: {
574             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
575             *selectorList = consumeComplexSelectorList(block);
576             if (!selectorList-&gt;first() || !block.atEnd())
577                 return nullptr;
578             selector-&gt;setSelectorList(WTFMove(selectorList));
579             return selector;
580         }
581         case CSSSelector::PseudoClassAny:
582         case CSSSelector::PseudoClassHost: {
583             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
584             *selectorList = consumeCompoundSelectorList(block);
585             if (!selectorList-&gt;first() || !block.atEnd())
586                 return nullptr;
587             selector-&gt;setSelectorList(WTFMove(selectorList));
588             return selector;
589         }
590 #if ENABLE(CSS_SELECTORS_LEVEL4)
591         case CSSSelector::PseudoClassDir:
592         case CSSSelector::PseudoClassRole: {
593             const CSSParserToken&amp; ident = block.consumeIncludingWhitespace();
594             if (ident.type() != IdentToken || !block.atEnd())
595                 return nullptr;
596             selector-&gt;setArgument(ident.value().toAtomString());
597             return selector;
598         }
599 #endif
600         default:
601             break;
602         }
<span class="line-removed">603 </span>
604     }
605 
606     if (selector-&gt;match() == CSSSelector::PseudoElement) {
607         switch (selector-&gt;pseudoElementType()) {
608 #if ENABLE(VIDEO_TRACK)
609         case CSSSelector::PseudoElementCue: {
610             DisallowPseudoElementsScope scope(this);
611             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
612             *selectorList = consumeCompoundSelectorList(block);
613             if (!selectorList-&gt;isValid() || !block.atEnd())
614                 return nullptr;
615             selector-&gt;setSelectorList(WTFMove(selectorList));
616             return selector;
617         }
618 #endif

























619         case CSSSelector::PseudoElementSlotted: {
620             DisallowPseudoElementsScope scope(this);
621 
622             std::unique_ptr&lt;CSSParserSelector&gt; innerSelector = consumeCompoundSelector(block);
623             block.consumeWhitespace();
624             if (!innerSelector || !block.atEnd())
625                 return nullptr;
626             selector-&gt;adoptSelectorVector(Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(innerSelector)));
627             return selector;
628         }
629         default:
630             break;
631         }
632     }
633 
634     return nullptr;
635 }
636 
637 CSSSelector::RelationType CSSSelectorParser::consumeCombinator(CSSParserTokenRange&amp; range)
638 {
</pre>
<hr />
<pre>
834     // The tagHistory is a linked list that stores combinator separated compound selectors
835     // from right-to-left. Yet, within a single compound selector, stores the simple selectors
836     // from left-to-right.
837     //
838     // &quot;.a.b &gt; div#id&quot; is stored in a tagHistory as [div, #id, .a, .b], each element in the
839     // list stored with an associated relation (combinator or Subselector).
840     //
841     // ::cue, ::shadow, and custom pseudo elements have an implicit ShadowPseudo combinator
842     // to their left, which really makes for a new compound selector, yet it&#39;s consumed by
843     // the selector parser as a single compound selector.
844     //
845     // Example: input#x::-webkit-clear-button -&gt; [ ::-webkit-clear-button, input, #x ]
846     //
847     CSSParserSelector* splitAfter = compoundSelector.get();
848     while (splitAfter-&gt;tagHistory() &amp;&amp; !splitAfter-&gt;tagHistory()-&gt;needsImplicitShadowCombinatorForMatching())
849         splitAfter = splitAfter-&gt;tagHistory();
850 
851     if (!splitAfter || !splitAfter-&gt;tagHistory())
852         return compoundSelector;
853 
<span class="line-modified">854     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747</span>
<span class="line-modified">855     // We have to recur, since we have rules in media controls like video::a::b. This should not be allowed, and</span>
<span class="line-modified">856     // we should remove this recursion once those rules are gone.</span>
<span class="line-modified">857     std::unique_ptr&lt;CSSParserSelector&gt; secondCompound = context.mode != UASheetMode ? splitAfter-&gt;releaseTagHistory() : splitCompoundAtImplicitShadowCrossingCombinator(splitAfter-&gt;releaseTagHistory(), context);</span>








858     secondCompound-&gt;appendTagHistory(CSSSelector::ShadowDescendant, WTFMove(compoundSelector));
859     return secondCompound;
860 }
861 
862 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
192     case CSSSelector::PseudoClassIncrement:
193     case CSSSelector::PseudoClassStart:
194     case CSSSelector::PseudoClassEnd:
195     case CSSSelector::PseudoClassDoubleButton:
196     case CSSSelector::PseudoClassSingleButton:
197     case CSSSelector::PseudoClassNoButton:
198     case CSSSelector::PseudoClassCornerPresent:
199     case CSSSelector::PseudoClassWindowInactive:
200         return true;
201     default:
202         return false;
203     }
204 }
205 
206 bool isUserActionPseudoClass(CSSSelector::PseudoClassType pseudo)
207 {
208     switch (pseudo) {
209     case CSSSelector::PseudoClassHover:
210     case CSSSelector::PseudoClassFocus:
211     case CSSSelector::PseudoClassActive:
<span class="line-added">212     case CSSSelector::PseudoClassFocusWithin:</span>
213         return true;
214     default:
215         return false;
216     }
217 }
218 
219 bool isPseudoClassValidAfterPseudoElement(CSSSelector::PseudoClassType pseudoClass, CSSSelector::PseudoElementType compoundPseudoElement)
220 {
221     switch (compoundPseudoElement) {
<span class="line-added">222     case CSSSelector::PseudoElementPart:</span>
<span class="line-added">223         return !isTreeStructuralPseudoClass(pseudoClass);</span>
224     case CSSSelector::PseudoElementResizer:
225     case CSSSelector::PseudoElementScrollbar:
226     case CSSSelector::PseudoElementScrollbarCorner:
227     case CSSSelector::PseudoElementScrollbarButton:
228     case CSSSelector::PseudoElementScrollbarThumb:
229     case CSSSelector::PseudoElementScrollbarTrack:
230     case CSSSelector::PseudoElementScrollbarTrackPiece:
231         return isScrollbarPseudoClass(pseudoClass);
232     case CSSSelector::PseudoElementSelection:
233         return pseudoClass == CSSSelector::PseudoClassWindowInactive;
234     case CSSSelector::PseudoElementWebKitCustom:
235     case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
236         return isUserActionPseudoClass(pseudoClass);
237     default:
238         return false;
239     }
240 }
241 
242 bool isSimpleSelectorValidAfterPseudoElement(const CSSParserSelector&amp; simpleSelector, CSSSelector::PseudoElementType compoundPseudoElement)
243 {
244     if (compoundPseudoElement == CSSSelector::PseudoElementUnknown)
245         return true;
<span class="line-modified">246     if (compoundPseudoElement == CSSSelector::PseudoElementPart) {</span>
<span class="line-modified">247         if (simpleSelector.match() == CSSSelector::PseudoElement &amp;&amp; simpleSelector.pseudoElementType() != CSSSelector::PseudoElementPart)</span>
<span class="line-modified">248             return true;</span>
<span class="line-added">249     }</span>
250     if (simpleSelector.match() != CSSSelector::PseudoClass)
251         return false;
252     CSSSelector::PseudoClassType pseudo = simpleSelector.pseudoClassType();
253     if (pseudo == CSSSelector::PseudoClassNot) {
254         ASSERT(simpleSelector.selectorList());
255         ASSERT(simpleSelector.selectorList()-&gt;first());
256         pseudo = simpleSelector.selectorList()-&gt;first()-&gt;pseudoClassType();
257     }
258     return isPseudoClassValidAfterPseudoElement(pseudo, compoundPseudoElement);
259 }
260 
261 } // namespace
262 
263 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeCompoundSelector(CSSParserTokenRange&amp; range)
264 {
265     std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector;
266 
267     AtomString namespacePrefix;
268     AtomString elementName;
269     CSSSelector::PseudoElementType compoundPseudoElement = CSSSelector::PseudoElementUnknown;
</pre>
<hr />
<pre>
449     case CSSSelector::PseudoClassNthLastChild:
450     case CSSSelector::PseudoClassNthOfType:
451     case CSSSelector::PseudoClassNthLastOfType:
452     case CSSSelector::PseudoClassLang:
453     case CSSSelector::PseudoClassAny:
454 #if ENABLE(CSS_SELECTORS_LEVEL4)
455     case CSSSelector::PseudoClassDir:
456     case CSSSelector::PseudoClassRole:
457 #endif
458         return true;
459     default:
460         break;
461     }
462     return false;
463 }
464 
465 static bool isOnlyPseudoElementFunction(CSSSelector::PseudoElementType pseudoElementType)
466 {
467     // Note that we omit cue since it can be both an ident or a function.
468     switch (pseudoElementType) {
<span class="line-added">469     case CSSSelector::PseudoElementPart:</span>
470     case CSSSelector::PseudoElementSlotted:
471         return true;
472     default:
473         break;
474     }
475     return false;
476 }
477 
478 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumePseudo(CSSParserTokenRange&amp; range)
479 {
480     ASSERT(range.peek().type() == ColonToken);
481     range.consume();
482 
483     int colons = 1;
484     if (range.peek().type() == ColonToken) {
485         range.consume();
486         colons++;
487     }
488 
489     const CSSParserToken&amp; token = range.peek();
490     if (token.type() != IdentToken &amp;&amp; token.type() != FunctionToken)
491         return nullptr;
492 
493     std::unique_ptr&lt;CSSParserSelector&gt; selector;
494 
495     if (colons == 1) {
496         selector = CSSParserSelector::parsePseudoClassSelector(token.value());
<span class="line-modified">497         if (!selector)</span>

498             return nullptr;
<span class="line-added">499         if (selector-&gt;match() == CSSSelector::PseudoClass) {</span>
<span class="line-added">500             if (m_context.mode != UASheetMode &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassDirectFocus)</span>
<span class="line-added">501                 return nullptr;</span>
<span class="line-added">502 #if ENABLE(ATTACHMENT_ELEMENT)</span>
<span class="line-added">503             if (!m_context.attachmentEnabled &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassHasAttachment)</span>
<span class="line-added">504                 return nullptr;</span>
505 #endif
<span class="line-added">506         }</span>
507     } else {
508         selector = CSSParserSelector::parsePseudoElementSelector(token.value());
509 #if ENABLE(VIDEO_TRACK)
510         // Treat the ident version of cue as PseudoElementWebkitCustom.
511         if (token.type() == IdentToken &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; selector-&gt;pseudoElementType() == CSSSelector::PseudoElementCue)
512             selector-&gt;setPseudoElementType(CSSSelector::PseudoElementWebKitCustom);
513 #endif
514     }
515 
516     if (!selector || (selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; m_disallowPseudoElements))
517         return nullptr;
518 
519     if (token.type() == IdentToken) {
520         range.consume();
521         if ((selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; (selector-&gt;pseudoElementType() == CSSSelector::PseudoElementUnknown || isOnlyPseudoElementFunction(selector-&gt;pseudoElementType())))
522             || (selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; (selector-&gt;pseudoClassType() == CSSSelector::PseudoClassUnknown || isOnlyPseudoClassFunction(selector-&gt;pseudoClassType()))))
523             return nullptr;
524         return selector;
525     }
526 
</pre>
<hr />
<pre>
561                 if (!equalIgnoringASCIICase(ident.value(), &quot;of&quot;))
562                     return nullptr;
563                 if (block.peek().type() != WhitespaceToken)
564                     return nullptr;
565                 DisallowPseudoElementsScope scope(this);
566                 block.consumeWhitespace();
567                 std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
568                 *selectorList = consumeComplexSelectorList(block);
569                 if (!selectorList-&gt;first() || !block.atEnd())
570                     return nullptr;
571                 selector-&gt;setSelectorList(WTFMove(selectorList));
572             }
573             selector-&gt;setNth(ab.first, ab.second);
574             return selector;
575         }
576         case CSSSelector::PseudoClassLang: {
577             // FIXME: CSS Selectors Level 4 allows :lang(*-foo)
578             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();
579             if (!consumeLangArgumentList(argumentList, block))
580                 return nullptr;
<span class="line-modified">581             selector-&gt;setArgumentList(WTFMove(argumentList));</span>
582             return selector;
583         }
584         case CSSSelector::PseudoClassMatches: {
585             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
586             *selectorList = consumeComplexSelectorList(block);
587             if (!selectorList-&gt;first() || !block.atEnd())
588                 return nullptr;
589             selector-&gt;setSelectorList(WTFMove(selectorList));
590             return selector;
591         }
592         case CSSSelector::PseudoClassAny:
593         case CSSSelector::PseudoClassHost: {
594             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
595             *selectorList = consumeCompoundSelectorList(block);
596             if (!selectorList-&gt;first() || !block.atEnd())
597                 return nullptr;
598             selector-&gt;setSelectorList(WTFMove(selectorList));
599             return selector;
600         }
601 #if ENABLE(CSS_SELECTORS_LEVEL4)
602         case CSSSelector::PseudoClassDir:
603         case CSSSelector::PseudoClassRole: {
604             const CSSParserToken&amp; ident = block.consumeIncludingWhitespace();
605             if (ident.type() != IdentToken || !block.atEnd())
606                 return nullptr;
607             selector-&gt;setArgument(ident.value().toAtomString());
608             return selector;
609         }
610 #endif
611         default:
612             break;
613         }

614     }
615 
616     if (selector-&gt;match() == CSSSelector::PseudoElement) {
617         switch (selector-&gt;pseudoElementType()) {
618 #if ENABLE(VIDEO_TRACK)
619         case CSSSelector::PseudoElementCue: {
620             DisallowPseudoElementsScope scope(this);
621             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
622             *selectorList = consumeCompoundSelectorList(block);
623             if (!selectorList-&gt;isValid() || !block.atEnd())
624                 return nullptr;
625             selector-&gt;setSelectorList(WTFMove(selectorList));
626             return selector;
627         }
628 #endif
<span class="line-added">629         case CSSSelector::PseudoElementHighlight: {</span>
<span class="line-added">630             DisallowPseudoElementsScope scope(this);</span>
<span class="line-added">631 </span>
<span class="line-added">632             auto&amp; ident = block.consumeIncludingWhitespace();</span>
<span class="line-added">633             if (ident.type() != IdentToken || !block.atEnd())</span>
<span class="line-added">634                 return nullptr;</span>
<span class="line-added">635 </span>
<span class="line-added">636             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();</span>
<span class="line-added">637             argumentList-&gt;append(ident.value().toAtomString());</span>
<span class="line-added">638             selector-&gt;setArgumentList(WTFMove(argumentList));</span>
<span class="line-added">639 </span>
<span class="line-added">640             return selector;</span>
<span class="line-added">641         }</span>
<span class="line-added">642         case CSSSelector::PseudoElementPart: {</span>
<span class="line-added">643             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();</span>
<span class="line-added">644             do {</span>
<span class="line-added">645                 auto&amp; ident = block.consumeIncludingWhitespace();</span>
<span class="line-added">646                 if (ident.type() != IdentToken)</span>
<span class="line-added">647                     return nullptr;</span>
<span class="line-added">648                 argumentList-&gt;append(ident.value().toAtomString());</span>
<span class="line-added">649             } while (!block.atEnd());</span>
<span class="line-added">650 </span>
<span class="line-added">651             selector-&gt;setArgumentList(WTFMove(argumentList));</span>
<span class="line-added">652             return selector;</span>
<span class="line-added">653         }</span>
654         case CSSSelector::PseudoElementSlotted: {
655             DisallowPseudoElementsScope scope(this);
656 
657             std::unique_ptr&lt;CSSParserSelector&gt; innerSelector = consumeCompoundSelector(block);
658             block.consumeWhitespace();
659             if (!innerSelector || !block.atEnd())
660                 return nullptr;
661             selector-&gt;adoptSelectorVector(Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(innerSelector)));
662             return selector;
663         }
664         default:
665             break;
666         }
667     }
668 
669     return nullptr;
670 }
671 
672 CSSSelector::RelationType CSSSelectorParser::consumeCombinator(CSSParserTokenRange&amp; range)
673 {
</pre>
<hr />
<pre>
869     // The tagHistory is a linked list that stores combinator separated compound selectors
870     // from right-to-left. Yet, within a single compound selector, stores the simple selectors
871     // from left-to-right.
872     //
873     // &quot;.a.b &gt; div#id&quot; is stored in a tagHistory as [div, #id, .a, .b], each element in the
874     // list stored with an associated relation (combinator or Subselector).
875     //
876     // ::cue, ::shadow, and custom pseudo elements have an implicit ShadowPseudo combinator
877     // to their left, which really makes for a new compound selector, yet it&#39;s consumed by
878     // the selector parser as a single compound selector.
879     //
880     // Example: input#x::-webkit-clear-button -&gt; [ ::-webkit-clear-button, input, #x ]
881     //
882     CSSParserSelector* splitAfter = compoundSelector.get();
883     while (splitAfter-&gt;tagHistory() &amp;&amp; !splitAfter-&gt;tagHistory()-&gt;needsImplicitShadowCombinatorForMatching())
884         splitAfter = splitAfter-&gt;tagHistory();
885 
886     if (!splitAfter || !splitAfter-&gt;tagHistory())
887         return compoundSelector;
888 
<span class="line-modified">889     // ::part() combines with other pseudo elements.</span>
<span class="line-modified">890     bool isPart = splitAfter-&gt;tagHistory()-&gt;match() == CSSSelector::PseudoElement &amp;&amp; splitAfter-&gt;tagHistory()-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-modified">891 </span>
<span class="line-modified">892     std::unique_ptr&lt;CSSParserSelector&gt; secondCompound;</span>
<span class="line-added">893     if (context.mode == UASheetMode || isPart) {</span>
<span class="line-added">894         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747</span>
<span class="line-added">895         // We have to recur, since we have rules in media controls like video::a::b. This should not be allowed, and</span>
<span class="line-added">896         // we should remove this recursion once those rules are gone.</span>
<span class="line-added">897         secondCompound = splitCompoundAtImplicitShadowCrossingCombinator(splitAfter-&gt;releaseTagHistory(), context);</span>
<span class="line-added">898     } else</span>
<span class="line-added">899         secondCompound = splitAfter-&gt;releaseTagHistory();</span>
<span class="line-added">900 </span>
901     secondCompound-&gt;appendTagHistory(CSSSelector::ShadowDescendant, WTFMove(compoundSelector));
902     return secondCompound;
903 }
904 
905 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CSSPropertyParserHelpers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSSupportsParser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
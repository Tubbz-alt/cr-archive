<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceFilter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderSVGResourceClipper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceGradient.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceFilter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 86     if (filterElement().countChildNodes() &gt; maxCountChildNodes)
 87         return nullptr;
 88 
 89     FloatRect targetBoundingBox = filter.targetBoundingBox();
 90 
 91     // Add effects to the builder
 92     auto builder = makeUnique&lt;SVGFilterBuilder&gt;(SourceGraphic::create(filter));
 93     builder-&gt;setPrimitiveUnits(filterElement().primitiveUnits());
 94     builder-&gt;setTargetBoundingBox(targetBoundingBox);
 95 
 96     for (auto&amp; element : childrenOfType&lt;SVGFilterPrimitiveStandardAttributes&gt;(filterElement())) {
 97         RefPtr&lt;FilterEffect&gt; effect = element.build(builder.get(), filter);
 98         if (!effect) {
 99             builder-&gt;clearEffects();
100             return nullptr;
101         }
102         builder-&gt;appendEffectToEffectReferences(effect.copyRef(), element.renderer());
103         element.setStandardAttributes(effect.get());
104         effect-&gt;setEffectBoundaries(SVGLengthContext::resolveRectangle&lt;SVGFilterPrimitiveStandardAttributes&gt;(&amp;element, filterElement().primitiveUnits(), targetBoundingBox));
105         if (element.renderer())
<span class="line-modified">106             effect-&gt;setOperatingColorSpace(element.renderer()-&gt;style().svgStyle().colorInterpolationFilters() == ColorInterpolation::LinearRGB ? ColorSpaceLinearRGB : ColorSpaceSRGB);</span>
107         builder-&gt;add(element.result(), WTFMove(effect));
108     }
109     return builder;
110 }
111 
112 bool RenderSVGResourceFilter::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
113 {
114     ASSERT(context);
115     ASSERT_UNUSED(resourceMode, !resourceMode);
116 
117     LOG(Filters, &quot;RenderSVGResourceFilter %p applyResource renderer %p&quot;, this, &amp;renderer);
118 
119     if (m_rendererFilterDataMap.contains(&amp;renderer)) {
120         FilterData* filterData = m_rendererFilterDataMap.get(&amp;renderer);
121         if (filterData-&gt;state == FilterData::PaintingSource || filterData-&gt;state == FilterData::Applying)
122             filterData-&gt;state = FilterData::CycleDetected;
123         return false; // Already built, or we&#39;re in a cycle, or we&#39;re marked for removal. Regardless, just do nothing more now.
124     }
125 
126     auto filterData = makeUnique&lt;FilterData&gt;();
</pre>
<hr />
<pre>
174     // recalculate the effect sizes with new scale factors.
175     if (ImageBuffer::sizeNeedsClamping(subRegion.size(), scale)) {
176         filterData-&gt;filter-&gt;setFilterResolution(scale);
177         lastEffect-&gt;determineFilterPrimitiveSubregion();
178     }
179 
180     // If the drawingRegion is empty, we have something like &lt;g filter=&quot;..&quot;/&gt;.
181     // Even if the target objectBoundingBox() is empty, we still have to draw the last effect result image in postApplyResource.
182     if (filterData-&gt;drawingRegion.isEmpty()) {
183         ASSERT(!m_rendererFilterDataMap.contains(&amp;renderer));
184         filterData-&gt;savedContext = context;
185         m_rendererFilterDataMap.set(&amp;renderer, WTFMove(filterData));
186         return false;
187     }
188 
189     // Change the coordinate transformation applied to the filtered element to reflect the resolution of the filter.
190     AffineTransform effectiveTransform;
191     effectiveTransform.scale(scale.width(), scale.height());
192     effectiveTransform.multiply(filterData-&gt;shearFreeAbsoluteTransform);
193 
<span class="line-modified">194     RenderingMode renderingMode = renderer.settings().acceleratedFiltersEnabled() ? Accelerated : Unaccelerated;</span>
<span class="line-modified">195     auto sourceGraphic = SVGRenderingContext::createImageBuffer(filterData-&gt;drawingRegion, effectiveTransform, ColorSpaceLinearRGB, renderingMode, context);</span>
196     if (!sourceGraphic) {
197         ASSERT(!m_rendererFilterDataMap.contains(&amp;renderer));
198         filterData-&gt;savedContext = context;
199         m_rendererFilterDataMap.set(&amp;renderer, WTFMove(filterData));
200         return false;
201     }
202 
203     // Set the rendering mode from the page&#39;s settings.
204     filterData-&gt;filter-&gt;setRenderingMode(renderingMode);
205 
206     GraphicsContext&amp; sourceGraphicContext = sourceGraphic-&gt;context();
207 
208     filterData-&gt;sourceGraphicBuffer = WTFMove(sourceGraphic);
209     filterData-&gt;savedContext = context;
210 
211     context = &amp;sourceGraphicContext;
212 
213     ASSERT(!m_rendererFilterDataMap.contains(&amp;renderer));
214     m_rendererFilterDataMap.set(&amp;renderer, WTFMove(filterData));
215 
</pre>
<hr />
<pre>
254         break;
255 
256     case FilterData::Built:
257         break;
258     }
259 
260     FilterEffect* lastEffect = filterData.builder-&gt;lastEffect();
261 
262     if (lastEffect &amp;&amp; !filterData.boundaries.isEmpty() &amp;&amp; !lastEffect-&gt;filterPrimitiveSubregion().isEmpty()) {
263         // This is the real filtering of the object. It just needs to be called on the
264         // initial filtering process. We just take the stored filter result on a
265         // second drawing.
266         if (filterData.state != FilterData::Built)
267             filterData.filter-&gt;setSourceImage(WTFMove(filterData.sourceGraphicBuffer));
268 
269         // Always true if filterData is just built (filterData-&gt;state == FilterData::Built).
270         if (!lastEffect-&gt;hasResult()) {
271             filterData.state = FilterData::Applying;
272             lastEffect-&gt;apply();
273             lastEffect-&gt;correctFilterResultIfNeeded();
<span class="line-modified">274             lastEffect-&gt;transformResultColorSpace(ColorSpaceSRGB);</span>
275         }
276         filterData.state = FilterData::Built;
277 
278         ImageBuffer* resultImage = lastEffect-&gt;imageBufferResult();
279         if (resultImage) {
280             context-&gt;concatCTM(filterData.shearFreeAbsoluteTransform.inverse().valueOr(AffineTransform()));
281 
282             context-&gt;scale(FloatSize(1 / filterData.filter-&gt;filterResolution().width(), 1 / filterData.filter-&gt;filterResolution().height()));
283             context-&gt;drawImageBuffer(*resultImage, lastEffect-&gt;absolutePaintRect());
284             context-&gt;scale(filterData.filter-&gt;filterResolution());
285 
286             context-&gt;concatCTM(filterData.shearFreeAbsoluteTransform);
287         }
288     }
289     filterData.sourceGraphicBuffer.reset();
290 
291     LOG_WITH_STREAM(Filters, stream &lt;&lt; &quot;RenderSVGResourceFilter &quot; &lt;&lt; this &lt;&lt; &quot; postApplyResource done\n&quot;);
292 }
293 
294 FloatRect RenderSVGResourceFilter::resourceBoundingBox(const RenderObject&amp; object)
</pre>
</td>
<td>
<hr />
<pre>
 86     if (filterElement().countChildNodes() &gt; maxCountChildNodes)
 87         return nullptr;
 88 
 89     FloatRect targetBoundingBox = filter.targetBoundingBox();
 90 
 91     // Add effects to the builder
 92     auto builder = makeUnique&lt;SVGFilterBuilder&gt;(SourceGraphic::create(filter));
 93     builder-&gt;setPrimitiveUnits(filterElement().primitiveUnits());
 94     builder-&gt;setTargetBoundingBox(targetBoundingBox);
 95 
 96     for (auto&amp; element : childrenOfType&lt;SVGFilterPrimitiveStandardAttributes&gt;(filterElement())) {
 97         RefPtr&lt;FilterEffect&gt; effect = element.build(builder.get(), filter);
 98         if (!effect) {
 99             builder-&gt;clearEffects();
100             return nullptr;
101         }
102         builder-&gt;appendEffectToEffectReferences(effect.copyRef(), element.renderer());
103         element.setStandardAttributes(effect.get());
104         effect-&gt;setEffectBoundaries(SVGLengthContext::resolveRectangle&lt;SVGFilterPrimitiveStandardAttributes&gt;(&amp;element, filterElement().primitiveUnits(), targetBoundingBox));
105         if (element.renderer())
<span class="line-modified">106             effect-&gt;setOperatingColorSpace(element.renderer()-&gt;style().svgStyle().colorInterpolationFilters() == ColorInterpolation::LinearRGB ? ColorSpace::LinearRGB : ColorSpace::SRGB);</span>
107         builder-&gt;add(element.result(), WTFMove(effect));
108     }
109     return builder;
110 }
111 
112 bool RenderSVGResourceFilter::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
113 {
114     ASSERT(context);
115     ASSERT_UNUSED(resourceMode, !resourceMode);
116 
117     LOG(Filters, &quot;RenderSVGResourceFilter %p applyResource renderer %p&quot;, this, &amp;renderer);
118 
119     if (m_rendererFilterDataMap.contains(&amp;renderer)) {
120         FilterData* filterData = m_rendererFilterDataMap.get(&amp;renderer);
121         if (filterData-&gt;state == FilterData::PaintingSource || filterData-&gt;state == FilterData::Applying)
122             filterData-&gt;state = FilterData::CycleDetected;
123         return false; // Already built, or we&#39;re in a cycle, or we&#39;re marked for removal. Regardless, just do nothing more now.
124     }
125 
126     auto filterData = makeUnique&lt;FilterData&gt;();
</pre>
<hr />
<pre>
174     // recalculate the effect sizes with new scale factors.
175     if (ImageBuffer::sizeNeedsClamping(subRegion.size(), scale)) {
176         filterData-&gt;filter-&gt;setFilterResolution(scale);
177         lastEffect-&gt;determineFilterPrimitiveSubregion();
178     }
179 
180     // If the drawingRegion is empty, we have something like &lt;g filter=&quot;..&quot;/&gt;.
181     // Even if the target objectBoundingBox() is empty, we still have to draw the last effect result image in postApplyResource.
182     if (filterData-&gt;drawingRegion.isEmpty()) {
183         ASSERT(!m_rendererFilterDataMap.contains(&amp;renderer));
184         filterData-&gt;savedContext = context;
185         m_rendererFilterDataMap.set(&amp;renderer, WTFMove(filterData));
186         return false;
187     }
188 
189     // Change the coordinate transformation applied to the filtered element to reflect the resolution of the filter.
190     AffineTransform effectiveTransform;
191     effectiveTransform.scale(scale.width(), scale.height());
192     effectiveTransform.multiply(filterData-&gt;shearFreeAbsoluteTransform);
193 
<span class="line-modified">194     RenderingMode renderingMode = renderer.settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated;</span>
<span class="line-modified">195     auto sourceGraphic = SVGRenderingContext::createImageBuffer(filterData-&gt;drawingRegion, effectiveTransform, ColorSpace::LinearRGB, renderingMode, context);</span>
196     if (!sourceGraphic) {
197         ASSERT(!m_rendererFilterDataMap.contains(&amp;renderer));
198         filterData-&gt;savedContext = context;
199         m_rendererFilterDataMap.set(&amp;renderer, WTFMove(filterData));
200         return false;
201     }
202 
203     // Set the rendering mode from the page&#39;s settings.
204     filterData-&gt;filter-&gt;setRenderingMode(renderingMode);
205 
206     GraphicsContext&amp; sourceGraphicContext = sourceGraphic-&gt;context();
207 
208     filterData-&gt;sourceGraphicBuffer = WTFMove(sourceGraphic);
209     filterData-&gt;savedContext = context;
210 
211     context = &amp;sourceGraphicContext;
212 
213     ASSERT(!m_rendererFilterDataMap.contains(&amp;renderer));
214     m_rendererFilterDataMap.set(&amp;renderer, WTFMove(filterData));
215 
</pre>
<hr />
<pre>
254         break;
255 
256     case FilterData::Built:
257         break;
258     }
259 
260     FilterEffect* lastEffect = filterData.builder-&gt;lastEffect();
261 
262     if (lastEffect &amp;&amp; !filterData.boundaries.isEmpty() &amp;&amp; !lastEffect-&gt;filterPrimitiveSubregion().isEmpty()) {
263         // This is the real filtering of the object. It just needs to be called on the
264         // initial filtering process. We just take the stored filter result on a
265         // second drawing.
266         if (filterData.state != FilterData::Built)
267             filterData.filter-&gt;setSourceImage(WTFMove(filterData.sourceGraphicBuffer));
268 
269         // Always true if filterData is just built (filterData-&gt;state == FilterData::Built).
270         if (!lastEffect-&gt;hasResult()) {
271             filterData.state = FilterData::Applying;
272             lastEffect-&gt;apply();
273             lastEffect-&gt;correctFilterResultIfNeeded();
<span class="line-modified">274             lastEffect-&gt;transformResultColorSpace(ColorSpace::SRGB);</span>
275         }
276         filterData.state = FilterData::Built;
277 
278         ImageBuffer* resultImage = lastEffect-&gt;imageBufferResult();
279         if (resultImage) {
280             context-&gt;concatCTM(filterData.shearFreeAbsoluteTransform.inverse().valueOr(AffineTransform()));
281 
282             context-&gt;scale(FloatSize(1 / filterData.filter-&gt;filterResolution().width(), 1 / filterData.filter-&gt;filterResolution().height()));
283             context-&gt;drawImageBuffer(*resultImage, lastEffect-&gt;absolutePaintRect());
284             context-&gt;scale(filterData.filter-&gt;filterResolution());
285 
286             context-&gt;concatCTM(filterData.shearFreeAbsoluteTransform);
287         }
288     }
289     filterData.sourceGraphicBuffer.reset();
290 
291     LOG_WITH_STREAM(Filters, stream &lt;&lt; &quot;RenderSVGResourceFilter &quot; &lt;&lt; this &lt;&lt; &quot; postApplyResource done\n&quot;);
292 }
293 
294 FloatRect RenderSVGResourceFilter::resourceBoundingBox(const RenderObject&amp; object)
</pre>
</td>
</tr>
</table>
<center><a href="RenderSVGResourceClipper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceGradient.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
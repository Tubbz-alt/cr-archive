<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PutByIdStatus.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxyableAccessCase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PutByIdStatus.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PutByIdStatus.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;CodeBlock.h&quot;
 31 #include &quot;ComplexGetStatus.h&quot;
 32 #include &quot;GetterSetterAccessCase.h&quot;
 33 #include &quot;ICStatusUtils.h&quot;
 34 #include &quot;LLIntData.h&quot;
 35 #include &quot;LowLevelInterpreter.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;PolymorphicAccess.h&quot;
 38 #include &quot;Structure.h&quot;
 39 #include &quot;StructureChain.h&quot;
 40 #include &quot;StructureStubInfo.h&quot;
 41 #include &lt;wtf/ListDump.h&gt;
 42 
 43 namespace JSC {
 44 
 45 bool PutByIdStatus::appendVariant(const PutByIdVariant&amp; variant)
 46 {
 47     return appendICStatusVariant(m_variants, variant);
 48 }
 49 
<span class="line-modified"> 50 PutByIdStatus PutByIdStatus::computeFromLLInt(CodeBlock* profiledBlock, unsigned bytecodeIndex, UniquedStringImpl* uid)</span>
 51 {
 52     VM&amp; vm = profiledBlock-&gt;vm();
 53 
<span class="line-modified"> 54     auto instruction = profiledBlock-&gt;instructions().at(bytecodeIndex);</span>
 55     auto bytecode = instruction-&gt;as&lt;OpPutById&gt;();
 56     auto&amp; metadata = bytecode.metadata(profiledBlock);
 57 
 58     StructureID structureID = metadata.m_oldStructureID;
 59     if (!structureID)
 60         return PutByIdStatus(NoInformation);
 61 
 62     Structure* structure = vm.heap.structureIDTable().get(structureID);
 63 
 64     StructureID newStructureID = metadata.m_newStructureID;
 65     if (!newStructureID) {
 66         PropertyOffset offset = structure-&gt;getConcurrently(uid);
 67         if (!isValidOffset(offset))
 68             return PutByIdStatus(NoInformation);
 69 
 70         return PutByIdVariant::replace(structure, offset);
 71     }
 72 
 73     Structure* newStructure = vm.heap.structureIDTable().get(newStructureID);
 74 
 75     ASSERT(structure-&gt;transitionWatchpointSetHasBeenInvalidated());
 76 
 77     PropertyOffset offset = newStructure-&gt;getConcurrently(uid);
 78     if (!isValidOffset(offset))
 79         return PutByIdStatus(NoInformation);
 80 
 81     ObjectPropertyConditionSet conditionSet;
 82     if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {
 83         conditionSet =
 84             generateConditionsForPropertySetterMissConcurrently(
 85                 vm, profiledBlock-&gt;globalObject(), structure, uid);
 86         if (!conditionSet.isValid())
 87             return PutByIdStatus(NoInformation);
 88     }
 89 
 90     return PutByIdVariant::transition(
 91         structure, newStructure, conditionSet, offset);
 92 }
 93 
 94 #if ENABLE(JIT)
<span class="line-modified"> 95 PutByIdStatus PutByIdStatus::computeFor(CodeBlock* profiledBlock, ICStatusMap&amp; map, unsigned bytecodeIndex, UniquedStringImpl* uid, ExitFlag didExit, CallLinkStatus::ExitSiteData callExitSiteData)</span>
 96 {
 97     ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
 98 
 99     UNUSED_PARAM(profiledBlock);
100     UNUSED_PARAM(bytecodeIndex);
101     UNUSED_PARAM(uid);
102 #if ENABLE(DFG_JIT)
103     if (didExit)
104         return PutByIdStatus(TakesSlowPath);
105 
106     StructureStubInfo* stubInfo = map.get(CodeOrigin(bytecodeIndex)).stubInfo;
107     PutByIdStatus result = computeForStubInfo(
108         locker, profiledBlock, stubInfo, uid, callExitSiteData);
109     if (!result)
110         return computeFromLLInt(profiledBlock, bytecodeIndex, uid);
111 
112     return result;
113 #else // ENABLE(JIT)
114     UNUSED_PARAM(map);
115     UNUSED_PARAM(didExit);
116     UNUSED_PARAM(callExitSiteData);
117     return PutByIdStatus(NoInformation);
118 #endif // ENABLE(JIT)
119 }
120 
121 PutByIdStatus PutByIdStatus::computeForStubInfo(const ConcurrentJSLocker&amp; locker, CodeBlock* baselineBlock, StructureStubInfo* stubInfo, CodeOrigin codeOrigin, UniquedStringImpl* uid)
122 {
123     return computeForStubInfo(
124         locker, baselineBlock, stubInfo, uid,
125         CallLinkStatus::computeExitSiteData(baselineBlock, codeOrigin.bytecodeIndex()));
126 }
127 
128 PutByIdStatus PutByIdStatus::computeForStubInfo(
129     const ConcurrentJSLocker&amp; locker, CodeBlock* profiledBlock, StructureStubInfo* stubInfo,
130     UniquedStringImpl* uid, CallLinkStatus::ExitSiteData callExitSiteData)
131 {
<span class="line-modified">132     StubInfoSummary summary = StructureStubInfo::summary(stubInfo);</span>
133     if (!isInlineable(summary))
134         return PutByIdStatus(summary);
135 
<span class="line-modified">136     switch (stubInfo-&gt;cacheType) {</span>
137     case CacheType::Unset:
138         // This means that we attempted to cache but failed for some reason.
139         return PutByIdStatus(JSC::slowVersion(summary));
140 
141     case CacheType::PutByIdReplace: {
142         PropertyOffset offset =
143             stubInfo-&gt;u.byIdSelf.baseObjectStructure-&gt;getConcurrently(uid);
144         if (isValidOffset(offset)) {
145             return PutByIdVariant::replace(
146                 stubInfo-&gt;u.byIdSelf.baseObjectStructure.get(), offset);
147         }
148         return PutByIdStatus(JSC::slowVersion(summary));
149     }
150 
151     case CacheType::Stub: {
152         PolymorphicAccess* list = stubInfo-&gt;u.stub;
153 
154         PutByIdStatus result;
155         result.m_state = Simple;
156 
</pre>
<hr />
<pre>
220                 return PutByIdStatus(MakesCalls);
221 
222             default:
223                 return PutByIdStatus(JSC::slowVersion(summary));
224             }
225 
226             if (!result.appendVariant(variant))
227                 return PutByIdStatus(JSC::slowVersion(summary));
228         }
229 
230         return result;
231     }
232 
233     default:
234         return PutByIdStatus(JSC::slowVersion(summary));
235     }
236 }
237 
238 PutByIdStatus PutByIdStatus::computeFor(CodeBlock* baselineBlock, ICStatusMap&amp; baselineMap, ICStatusContextStack&amp; contextStack, CodeOrigin codeOrigin, UniquedStringImpl* uid)
239 {
<span class="line-modified">240     unsigned bytecodeIndex = codeOrigin.bytecodeIndex();</span>
241     CallLinkStatus::ExitSiteData callExitSiteData = CallLinkStatus::computeExitSiteData(baselineBlock, bytecodeIndex);
242     ExitFlag didExit = hasBadCacheExitSite(baselineBlock, bytecodeIndex);
243 
244     for (ICStatusContext* context : contextStack) {
245         ICStatus status = context-&gt;get(codeOrigin);
246 
247         auto bless = [&amp;] (const PutByIdStatus&amp; result) -&gt; PutByIdStatus {
248             if (!context-&gt;isInlined(codeOrigin)) {
249                 PutByIdStatus baselineResult = computeFor(
250                     baselineBlock, baselineMap, bytecodeIndex, uid, didExit,
251                     callExitSiteData);
252                 baselineResult.merge(result);
253                 return baselineResult;
254             }
255             if (didExit.isSet(ExitFromInlined))
256                 return result.slowVersion();
257             return result;
258         };
259 
260         if (status.stubInfo) {
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;CodeBlock.h&quot;
 31 #include &quot;ComplexGetStatus.h&quot;
 32 #include &quot;GetterSetterAccessCase.h&quot;
 33 #include &quot;ICStatusUtils.h&quot;
 34 #include &quot;LLIntData.h&quot;
 35 #include &quot;LowLevelInterpreter.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;PolymorphicAccess.h&quot;
 38 #include &quot;Structure.h&quot;
 39 #include &quot;StructureChain.h&quot;
 40 #include &quot;StructureStubInfo.h&quot;
 41 #include &lt;wtf/ListDump.h&gt;
 42 
 43 namespace JSC {
 44 
 45 bool PutByIdStatus::appendVariant(const PutByIdVariant&amp; variant)
 46 {
 47     return appendICStatusVariant(m_variants, variant);
 48 }
 49 
<span class="line-modified"> 50 PutByIdStatus PutByIdStatus::computeFromLLInt(CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex, UniquedStringImpl* uid)</span>
 51 {
 52     VM&amp; vm = profiledBlock-&gt;vm();
 53 
<span class="line-modified"> 54     auto instruction = profiledBlock-&gt;instructions().at(bytecodeIndex.offset());</span>
 55     auto bytecode = instruction-&gt;as&lt;OpPutById&gt;();
 56     auto&amp; metadata = bytecode.metadata(profiledBlock);
 57 
 58     StructureID structureID = metadata.m_oldStructureID;
 59     if (!structureID)
 60         return PutByIdStatus(NoInformation);
 61 
 62     Structure* structure = vm.heap.structureIDTable().get(structureID);
 63 
 64     StructureID newStructureID = metadata.m_newStructureID;
 65     if (!newStructureID) {
 66         PropertyOffset offset = structure-&gt;getConcurrently(uid);
 67         if (!isValidOffset(offset))
 68             return PutByIdStatus(NoInformation);
 69 
 70         return PutByIdVariant::replace(structure, offset);
 71     }
 72 
 73     Structure* newStructure = vm.heap.structureIDTable().get(newStructureID);
 74 
 75     ASSERT(structure-&gt;transitionWatchpointSetHasBeenInvalidated());
 76 
 77     PropertyOffset offset = newStructure-&gt;getConcurrently(uid);
 78     if (!isValidOffset(offset))
 79         return PutByIdStatus(NoInformation);
 80 
 81     ObjectPropertyConditionSet conditionSet;
 82     if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {
 83         conditionSet =
 84             generateConditionsForPropertySetterMissConcurrently(
 85                 vm, profiledBlock-&gt;globalObject(), structure, uid);
 86         if (!conditionSet.isValid())
 87             return PutByIdStatus(NoInformation);
 88     }
 89 
 90     return PutByIdVariant::transition(
 91         structure, newStructure, conditionSet, offset);
 92 }
 93 
 94 #if ENABLE(JIT)
<span class="line-modified"> 95 PutByIdStatus PutByIdStatus::computeFor(CodeBlock* profiledBlock, ICStatusMap&amp; map, BytecodeIndex bytecodeIndex, UniquedStringImpl* uid, ExitFlag didExit, CallLinkStatus::ExitSiteData callExitSiteData)</span>
 96 {
 97     ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
 98 
 99     UNUSED_PARAM(profiledBlock);
100     UNUSED_PARAM(bytecodeIndex);
101     UNUSED_PARAM(uid);
102 #if ENABLE(DFG_JIT)
103     if (didExit)
104         return PutByIdStatus(TakesSlowPath);
105 
106     StructureStubInfo* stubInfo = map.get(CodeOrigin(bytecodeIndex)).stubInfo;
107     PutByIdStatus result = computeForStubInfo(
108         locker, profiledBlock, stubInfo, uid, callExitSiteData);
109     if (!result)
110         return computeFromLLInt(profiledBlock, bytecodeIndex, uid);
111 
112     return result;
113 #else // ENABLE(JIT)
114     UNUSED_PARAM(map);
115     UNUSED_PARAM(didExit);
116     UNUSED_PARAM(callExitSiteData);
117     return PutByIdStatus(NoInformation);
118 #endif // ENABLE(JIT)
119 }
120 
121 PutByIdStatus PutByIdStatus::computeForStubInfo(const ConcurrentJSLocker&amp; locker, CodeBlock* baselineBlock, StructureStubInfo* stubInfo, CodeOrigin codeOrigin, UniquedStringImpl* uid)
122 {
123     return computeForStubInfo(
124         locker, baselineBlock, stubInfo, uid,
125         CallLinkStatus::computeExitSiteData(baselineBlock, codeOrigin.bytecodeIndex()));
126 }
127 
128 PutByIdStatus PutByIdStatus::computeForStubInfo(
129     const ConcurrentJSLocker&amp; locker, CodeBlock* profiledBlock, StructureStubInfo* stubInfo,
130     UniquedStringImpl* uid, CallLinkStatus::ExitSiteData callExitSiteData)
131 {
<span class="line-modified">132     StubInfoSummary summary = StructureStubInfo::summary(profiledBlock-&gt;vm(), stubInfo);</span>
133     if (!isInlineable(summary))
134         return PutByIdStatus(summary);
135 
<span class="line-modified">136     switch (stubInfo-&gt;cacheType()) {</span>
137     case CacheType::Unset:
138         // This means that we attempted to cache but failed for some reason.
139         return PutByIdStatus(JSC::slowVersion(summary));
140 
141     case CacheType::PutByIdReplace: {
142         PropertyOffset offset =
143             stubInfo-&gt;u.byIdSelf.baseObjectStructure-&gt;getConcurrently(uid);
144         if (isValidOffset(offset)) {
145             return PutByIdVariant::replace(
146                 stubInfo-&gt;u.byIdSelf.baseObjectStructure.get(), offset);
147         }
148         return PutByIdStatus(JSC::slowVersion(summary));
149     }
150 
151     case CacheType::Stub: {
152         PolymorphicAccess* list = stubInfo-&gt;u.stub;
153 
154         PutByIdStatus result;
155         result.m_state = Simple;
156 
</pre>
<hr />
<pre>
220                 return PutByIdStatus(MakesCalls);
221 
222             default:
223                 return PutByIdStatus(JSC::slowVersion(summary));
224             }
225 
226             if (!result.appendVariant(variant))
227                 return PutByIdStatus(JSC::slowVersion(summary));
228         }
229 
230         return result;
231     }
232 
233     default:
234         return PutByIdStatus(JSC::slowVersion(summary));
235     }
236 }
237 
238 PutByIdStatus PutByIdStatus::computeFor(CodeBlock* baselineBlock, ICStatusMap&amp; baselineMap, ICStatusContextStack&amp; contextStack, CodeOrigin codeOrigin, UniquedStringImpl* uid)
239 {
<span class="line-modified">240     BytecodeIndex bytecodeIndex = codeOrigin.bytecodeIndex();</span>
241     CallLinkStatus::ExitSiteData callExitSiteData = CallLinkStatus::computeExitSiteData(baselineBlock, bytecodeIndex);
242     ExitFlag didExit = hasBadCacheExitSite(baselineBlock, bytecodeIndex);
243 
244     for (ICStatusContext* context : contextStack) {
245         ICStatus status = context-&gt;get(codeOrigin);
246 
247         auto bless = [&amp;] (const PutByIdStatus&amp; result) -&gt; PutByIdStatus {
248             if (!context-&gt;isInlined(codeOrigin)) {
249                 PutByIdStatus baselineResult = computeFor(
250                     baselineBlock, baselineMap, bytecodeIndex, uid, didExit,
251                     callExitSiteData);
252                 baselineResult.merge(result);
253                 return baselineResult;
254             }
255             if (didExit.isSet(ExitFromInlined))
256                 return result.slowVersion();
257             return result;
258         };
259 
260         if (status.stubInfo) {
</pre>
</td>
</tr>
</table>
<center><a href="ProxyableAccessCase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PutByIdStatus.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
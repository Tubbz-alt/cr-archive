diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp
@@ -35,10 +35,11 @@
 #include "MessageWithMessagePorts.h"
 #include "WorkerGlobalScope.h"
 #include "WorkerThread.h"
 #include <wtf/CompletionHandler.h>
 #include <wtf/IsoMallocInlines.h>
+#include <wtf/Scope.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(MessagePort);
 
@@ -122,21 +123,21 @@
         m_scriptExecutionContext->destroyedMessagePort(*this);
 }
 
 void MessagePort::entangle()
 {
-    MessagePortChannelProvider::singleton().entangleLocalPortInThisProcessToRemote(m_identifier, m_remoteIdentifier);
+    MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).entangleLocalPortInThisProcessToRemote(m_identifier, m_remoteIdentifier);
 }
 
-ExceptionOr<void> MessagePort::postMessage(JSC::ExecState& state, JSC::JSValue messageValue, Vector<JSC::Strong<JSC::JSObject>>&& transfer)
+ExceptionOr<void> MessagePort::postMessage(JSC::JSGlobalObject& state, JSC::JSValue messageValue, PostMessageOptions&& options)
 {
     LOG(MessagePorts, "Attempting to post message to port %s (to be received by port %s)", m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
 
     registerLocalActivity();
 
     Vector<RefPtr<MessagePort>> ports;
-    auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports);
+    auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(options.transfer), ports);
     if (messageData.hasException())
         return messageData.releaseException();
 
     if (!isEntangled())
         return { };
@@ -158,25 +159,24 @@
 
     MessageWithMessagePorts message { messageData.releaseReturnValue(), WTFMove(transferredPorts) };
 
     LOG(MessagePorts, "Actually posting message to port %s (to be received by port %s)", m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
 
-    MessagePortChannelProvider::singleton().postMessageToRemote(WTFMove(message), m_remoteIdentifier);
+    MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).postMessageToRemote(WTFMove(message), m_remoteIdentifier);
     return { };
 }
 
 void MessagePort::disentangle()
 {
     ASSERT(m_entangled);
     m_entangled = false;
 
     registerLocalActivity();
 
-    MessagePortChannelProvider::singleton().messagePortDisentangled(m_identifier);
+    MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).messagePortDisentangled(m_identifier);
 
     // We can't receive any messages or generate any events after this, so remove ourselves from the list of active ports.
-    ASSERT(m_scriptExecutionContext);
     m_scriptExecutionContext->destroyedMessagePort(*this);
     m_scriptExecutionContext->willDestroyActiveDOMObject(*this);
     m_scriptExecutionContext->willDestroyDestructionObserver(*this);
 
     m_scriptExecutionContext = nullptr;
@@ -223,11 +223,18 @@
 
     if (m_closed)
         return;
     m_closed = true;
 
-    MessagePortChannelProvider::singleton().messagePortClosed(m_identifier);
+    if (isMainThread())
+        MessagePortChannelProvider::singleton().messagePortClosed(m_identifier);
+    else {
+        callOnMainThread([identifier = m_identifier] {
+            MessagePortChannelProvider::singleton().messagePortClosed(identifier);
+        });
+    }
+
     removeAllEventListeners();
 }
 
 void MessagePort::contextDestroyed()
 {
@@ -244,54 +251,49 @@
     ASSERT(started());
 
     if (!m_scriptExecutionContext || m_scriptExecutionContext->activeDOMObjectsAreSuspended() || !isEntangled())
         return;
 
-    RefPtr<WorkerThread> workerThread;
-    if (is<WorkerGlobalScope>(*m_scriptExecutionContext))
-        workerThread = &downcast<WorkerGlobalScope>(*m_scriptExecutionContext).thread();
+    auto messagesTakenHandler = [this, weakThis = makeWeakPtr(this)](Vector<MessageWithMessagePorts>&& messages, Function<void()>&& completionCallback) mutable {
+        auto scopeExit = makeScopeExit(WTFMove(completionCallback));
 
-    auto messagesTakenHandler = [this, weakThis = makeWeakPtr(this), workerThread = WTFMove(workerThread)](Vector<MessageWithMessagePorts>&& messages, Function<void()>&& completionCallback) mutable {
-        ASSERT(isMainThread());
-        auto innerHandler = [this, weakThis = WTFMove(weakThis)](auto&& messages) {
-            if (!weakThis)
-                return;
+        if (!weakThis)
+            return;
 
-            LOG(MessagePorts, "MessagePort %s (%p) dispatching %zu messages", m_identifier.logString().utf8().data(), this, messages.size());
+        LOG(MessagePorts, "MessagePort %s (%p) dispatching %zu messages", m_identifier.logString().utf8().data(), this, messages.size());
 
-            if (!m_scriptExecutionContext)
-                return;
+        if (!m_scriptExecutionContext)
+            return;
 
-            if (!messages.isEmpty())
-                registerLocalActivity();
+        if (!messages.isEmpty())
+            registerLocalActivity();
 
-            ASSERT(m_scriptExecutionContext->isContextThread());
+        ASSERT(m_scriptExecutionContext->isContextThread());
 
-            bool contextIsWorker = is<WorkerGlobalScope>(*m_scriptExecutionContext);
-            for (auto& message : messages) {
-                // close() in Worker onmessage handler should prevent next message from dispatching.
-                if (contextIsWorker && downcast<WorkerGlobalScope>(*m_scriptExecutionContext).isClosing())
-                    return;
-                auto ports = MessagePort::entanglePorts(*m_scriptExecutionContext, WTFMove(message.transferredPorts));
-                dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));
-            }
-        };
-
-        if (!workerThread) {
-            innerHandler(WTFMove(messages));
-            completionCallback();
-            return;
+        bool contextIsWorker = is<WorkerGlobalScope>(*m_scriptExecutionContext);
+        for (auto& message : messages) {
+            // close() in Worker onmessage handler should prevent next message from dispatching.
+            if (contextIsWorker && downcast<WorkerGlobalScope>(*m_scriptExecutionContext).isClosing())
+                return;
+            auto ports = MessagePort::entanglePorts(*m_scriptExecutionContext, WTFMove(message.transferredPorts));
+            // Per specification, each MessagePort object has a task source called the port message queue.
+            queueTaskToDispatchEvent(*this, TaskSource::PostedMessageQueue, MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));
         }
-        workerThread->runLoop().postTaskForMode([innerHandler = WTFMove(innerHandler), messages = WTFMove(messages), completionCallback = WTFMove(completionCallback)](auto&) mutable {
-            innerHandler(WTFMove(messages));
-            callOnMainThread([completionCallback = WTFMove(completionCallback)] {
-                completionCallback();
-            });
-        }, WorkerRunLoop::defaultMode());
     };
 
-    MessagePortChannelProvider::singleton().takeAllMessagesForPort(m_identifier, WTFMove(messagesTakenHandler));
+    MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).takeAllMessagesForPort(m_identifier, WTFMove(messagesTakenHandler));
+}
+
+void MessagePort::dispatchEvent(Event& event)
+{
+    if (m_closed)
+        return;
+
+    if (is<WorkerGlobalScope>(*m_scriptExecutionContext) && downcast<WorkerGlobalScope>(*m_scriptExecutionContext).isClosing())
+        return;
+
+    EventTarget::dispatchEvent(event);
 }
 
 void MessagePort::updateActivity(MessagePortChannelProvider::HasActivity hasActivity)
 {
     bool hasHadLocalActivity = m_hasHadLocalActivitySinceLastCheck;
@@ -326,23 +328,23 @@
     if (!m_isAskingRemoteAboutGC) {
         RefPtr<WorkerThread> workerThread;
         if (is<WorkerGlobalScope>(*m_scriptExecutionContext))
             workerThread = &downcast<WorkerGlobalScope>(*m_scriptExecutionContext).thread();
 
-        MessagePortChannelProvider::singleton().checkRemotePortForActivity(m_remoteIdentifier, [weakThis = makeWeakPtr(const_cast<MessagePort*>(this)), workerThread = WTFMove(workerThread)](MessagePortChannelProvider::HasActivity hasActivity) mutable {
-
-            ASSERT(isMainThread());
-            if (!workerThread) {
-                if (weakThis)
-                    weakThis->updateActivity(hasActivity);
-                return;
-            }
+        callOnMainThread([remoteIdentifier = m_remoteIdentifier, weakThis = makeWeakPtr(const_cast<MessagePort*>(this)), workerThread = WTFMove(workerThread)]() mutable {
+            MessagePortChannelProvider::singleton().checkRemotePortForActivity(remoteIdentifier, [weakThis = WTFMove(weakThis), workerThread = WTFMove(workerThread)](auto hasActivity) mutable {
+                if (!workerThread) {
+                    if (weakThis)
+                        weakThis->updateActivity(hasActivity);
+                    return;
+                }
 
-            workerThread->runLoop().postTaskForMode([weakThis = WTFMove(weakThis), hasActivity](auto&) mutable {
-                if (weakThis)
-                    weakThis->updateActivity(hasActivity);
-            }, WorkerRunLoop::defaultMode());
+                workerThread->runLoop().postTaskForMode([weakThis = WTFMove(weakThis), hasActivity](auto&) mutable {
+                    if (weakThis)
+                        weakThis->updateActivity(hasActivity);
+                }, WorkerRunLoop::defaultMode());
+            });
         });
         m_isAskingRemoteAboutGC = true;
     }
 
     // Since we need an answer from the remote object, we have to pretend we have pending activity for now.
@@ -426,11 +428,6 @@
 const char* MessagePort::activeDOMObjectName() const
 {
     return "MessagePort";
 }
 
-bool MessagePort::canSuspendForDocumentSuspension() const
-{
-    return true;
-}
-
 } // namespace WebCore

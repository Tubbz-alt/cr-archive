<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/RegistrationDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../context/ServiceWorkerThreadProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="RegistrationDatabase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/RegistrationDatabase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 79 {
 80     ASSERT(isMainThread());
 81     static NeverDestroyed&lt;String&gt; filename = databaseFilenameFromVersion(schemaVersion);
 82     return filename;
 83 }
 84 
 85 String serviceWorkerRegistrationDatabaseFilename(const String&amp; databaseDirectory)
 86 {
 87     return FileSystem::pathByAppendingComponent(databaseDirectory, databaseFilename());
 88 }
 89 
 90 static inline void cleanOldDatabases(const String&amp; databaseDirectory)
 91 {
 92     for (uint64_t version = 1; version &lt; schemaVersion; ++version)
 93         SQLiteFileSystem::deleteDatabaseFile(FileSystem::pathByAppendingComponent(databaseDirectory, databaseFilenameFromVersion(version)));
 94 }
 95 
 96 RegistrationDatabase::RegistrationDatabase(RegistrationStore&amp; store, String&amp;&amp; databaseDirectory)
 97     : m_workQueue(WorkQueue::create(&quot;ServiceWorker I/O Thread&quot;, WorkQueue::Type::Serial))
 98     , m_store(makeWeakPtr(store))
<span class="line-removed"> 99     , m_sessionID(m_store-&gt;server().sessionID())</span>
100     , m_databaseDirectory(WTFMove(databaseDirectory))
101     , m_databaseFilePath(FileSystem::pathByAppendingComponent(m_databaseDirectory, databaseFilename()))
102 {
103     ASSERT(isMainThread());
104 
105     postTaskToWorkQueue([this] {
106         importRecordsIfNecessary();
107     });
108 }
109 
110 RegistrationDatabase::~RegistrationDatabase()
111 {
112     ASSERT(isMainThread());
113 
114     // The database needs to be destroyed on the background thread.
115     if (m_database)
116         m_workQueue-&gt;dispatch([database = WTFMove(m_database)] { });
117 }
118 
119 void RegistrationDatabase::postTaskToWorkQueue(Function&lt;void()&gt;&amp;&amp; task)
</pre>
<hr />
<pre>
401         Vector&lt;uint8_t&gt; scriptResourceMapData;
402         sql.getColumnBlobAsVector(11, scriptResourceMapData);
403         HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; scriptResourceMap;
404 
405         WTF::Persistence::Decoder scriptResourceMapDecoder(scriptResourceMapData.data(), scriptResourceMapData.size());
406         if (scriptResourceMapData.size()) {
407             if (!scriptResourceMapDecoder.decode(scriptResourceMap))
408                 continue;
409         }
410 
411         // Validate the input for this registration.
412         // If any part of this input is invalid, let&#39;s skip this registration.
413         // FIXME: Should we return an error skipping *all* registrations?
414         if (!key || !originURL.isValid() || !topOrigin || !updateViaCache || !scriptURL.isValid() || !workerType)
415             continue;
416 
417         auto workerIdentifier = ServiceWorkerIdentifier::generate();
418         auto registrationIdentifier = ServiceWorkerRegistrationIdentifier::generate();
419         auto serviceWorkerData = ServiceWorkerData { workerIdentifier, scriptURL, ServiceWorkerState::Activated, *workerType, registrationIdentifier };
420         auto registration = ServiceWorkerRegistrationData { WTFMove(*key), registrationIdentifier, URL(originURL, scopePath), *updateViaCache, lastUpdateCheckTime, WTF::nullopt, WTF::nullopt, WTFMove(serviceWorkerData) };
<span class="line-modified">421         auto contextData = ServiceWorkerContextData { WTF::nullopt, WTFMove(registration), workerIdentifier, WTFMove(script), WTFMove(contentSecurityPolicy), WTFMove(referrerPolicy), WTFMove(scriptURL), *workerType, m_sessionID, true, WTFMove(scriptResourceMap) };</span>
422 
423         callOnMainThread([protectedThis = makeRef(*this), contextData = contextData.isolatedCopy()]() mutable {
424             protectedThis-&gt;addRegistrationToStore(WTFMove(contextData));
425         });
426     }
427 
428     if (result != SQLITE_DONE)
429         return makeString(&quot;Failed to import at least one registration from records table (&quot;, m_database-&gt;lastError(), &quot;) - &quot;, m_database-&gt;lastErrorMsg());
430 
431     return { };
432 }
433 
434 void RegistrationDatabase::addRegistrationToStore(ServiceWorkerContextData&amp;&amp; context)
435 {
436     if (m_store)
437         m_store-&gt;addRegistrationFromDatabase(WTFMove(context));
438 }
439 
440 void RegistrationDatabase::databaseFailedToOpen()
441 {
</pre>
</td>
<td>
<hr />
<pre>
 79 {
 80     ASSERT(isMainThread());
 81     static NeverDestroyed&lt;String&gt; filename = databaseFilenameFromVersion(schemaVersion);
 82     return filename;
 83 }
 84 
 85 String serviceWorkerRegistrationDatabaseFilename(const String&amp; databaseDirectory)
 86 {
 87     return FileSystem::pathByAppendingComponent(databaseDirectory, databaseFilename());
 88 }
 89 
 90 static inline void cleanOldDatabases(const String&amp; databaseDirectory)
 91 {
 92     for (uint64_t version = 1; version &lt; schemaVersion; ++version)
 93         SQLiteFileSystem::deleteDatabaseFile(FileSystem::pathByAppendingComponent(databaseDirectory, databaseFilenameFromVersion(version)));
 94 }
 95 
 96 RegistrationDatabase::RegistrationDatabase(RegistrationStore&amp; store, String&amp;&amp; databaseDirectory)
 97     : m_workQueue(WorkQueue::create(&quot;ServiceWorker I/O Thread&quot;, WorkQueue::Type::Serial))
 98     , m_store(makeWeakPtr(store))

 99     , m_databaseDirectory(WTFMove(databaseDirectory))
100     , m_databaseFilePath(FileSystem::pathByAppendingComponent(m_databaseDirectory, databaseFilename()))
101 {
102     ASSERT(isMainThread());
103 
104     postTaskToWorkQueue([this] {
105         importRecordsIfNecessary();
106     });
107 }
108 
109 RegistrationDatabase::~RegistrationDatabase()
110 {
111     ASSERT(isMainThread());
112 
113     // The database needs to be destroyed on the background thread.
114     if (m_database)
115         m_workQueue-&gt;dispatch([database = WTFMove(m_database)] { });
116 }
117 
118 void RegistrationDatabase::postTaskToWorkQueue(Function&lt;void()&gt;&amp;&amp; task)
</pre>
<hr />
<pre>
400         Vector&lt;uint8_t&gt; scriptResourceMapData;
401         sql.getColumnBlobAsVector(11, scriptResourceMapData);
402         HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; scriptResourceMap;
403 
404         WTF::Persistence::Decoder scriptResourceMapDecoder(scriptResourceMapData.data(), scriptResourceMapData.size());
405         if (scriptResourceMapData.size()) {
406             if (!scriptResourceMapDecoder.decode(scriptResourceMap))
407                 continue;
408         }
409 
410         // Validate the input for this registration.
411         // If any part of this input is invalid, let&#39;s skip this registration.
412         // FIXME: Should we return an error skipping *all* registrations?
413         if (!key || !originURL.isValid() || !topOrigin || !updateViaCache || !scriptURL.isValid() || !workerType)
414             continue;
415 
416         auto workerIdentifier = ServiceWorkerIdentifier::generate();
417         auto registrationIdentifier = ServiceWorkerRegistrationIdentifier::generate();
418         auto serviceWorkerData = ServiceWorkerData { workerIdentifier, scriptURL, ServiceWorkerState::Activated, *workerType, registrationIdentifier };
419         auto registration = ServiceWorkerRegistrationData { WTFMove(*key), registrationIdentifier, URL(originURL, scopePath), *updateViaCache, lastUpdateCheckTime, WTF::nullopt, WTF::nullopt, WTFMove(serviceWorkerData) };
<span class="line-modified">420         auto contextData = ServiceWorkerContextData { WTF::nullopt, WTFMove(registration), workerIdentifier, WTFMove(script), WTFMove(contentSecurityPolicy), WTFMove(referrerPolicy), WTFMove(scriptURL), *workerType, true, WTFMove(scriptResourceMap) };</span>
421 
422         callOnMainThread([protectedThis = makeRef(*this), contextData = contextData.isolatedCopy()]() mutable {
423             protectedThis-&gt;addRegistrationToStore(WTFMove(contextData));
424         });
425     }
426 
427     if (result != SQLITE_DONE)
428         return makeString(&quot;Failed to import at least one registration from records table (&quot;, m_database-&gt;lastError(), &quot;) - &quot;, m_database-&gt;lastErrorMsg());
429 
430     return { };
431 }
432 
433 void RegistrationDatabase::addRegistrationToStore(ServiceWorkerContextData&amp;&amp; context)
434 {
435     if (m_store)
436         m_store-&gt;addRegistrationFromDatabase(WTFMove(context));
437 }
438 
439 void RegistrationDatabase::databaseFailedToOpen()
440 {
</pre>
</td>
</tr>
</table>
<center><a href="../context/ServiceWorkerThreadProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="RegistrationDatabase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerCommon.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 namespace JSC {
 29 
<a name="2" id="anc2"></a><span class="line-added"> 30 ALWAYS_INLINE constexpr bool isDarwin()</span>
<span class="line-added"> 31 {</span>
<span class="line-added"> 32 #if OS(DARWIN)</span>
<span class="line-added"> 33     return true;</span>
<span class="line-added"> 34 #else</span>
<span class="line-added"> 35     return false;</span>
<span class="line-added"> 36 #endif</span>
<span class="line-added"> 37 }</span>
<span class="line-added"> 38 </span>
 39 ALWAYS_INLINE constexpr bool isIOS()
 40 {
 41 #if PLATFORM(IOS_FAMILY)
 42     return true;
 43 #else
 44     return false;
 45 #endif
 46 }
 47 
 48 ALWAYS_INLINE bool isInt9(int32_t value)
 49 {
 50     return value == ((value &lt;&lt; 23) &gt;&gt; 23);
 51 }
 52 
 53 template&lt;typename Type&gt;
 54 ALWAYS_INLINE bool isUInt12(Type value)
 55 {
 56     return !(value &amp; ~static_cast&lt;Type&gt;(0xfff));
 57 }
 58 
 59 template&lt;int datasize&gt;
 60 ALWAYS_INLINE bool isValidScaledUImm12(int32_t offset)
 61 {
 62     int32_t maxPImm = 4095 * (datasize / 8);
 63     if (offset &lt; 0)
 64         return false;
 65     if (offset &gt; maxPImm)
 66         return false;
 67     if (offset &amp; ((datasize / 8) - 1))
 68         return false;
 69     return true;
 70 }
 71 
 72 ALWAYS_INLINE bool isValidSignedImm9(int32_t value)
 73 {
 74     return isInt9(value);
 75 }
 76 
 77 class ARM64LogicalImmediate {
 78 public:
 79     static ARM64LogicalImmediate create32(uint32_t value)
 80     {
 81         // Check for 0, -1 - these cannot be encoded.
 82         if (!value || !~value)
 83             return InvalidLogicalImmediate;
 84 
 85         // First look for a 32-bit pattern, then for repeating 16-bit
 86         // patterns, 8-bit, 4-bit, and finally 2-bit.
 87 
 88         unsigned hsb, lsb;
 89         bool inverted;
 90         if (findBitRange&lt;32&gt;(value, hsb, lsb, inverted))
 91             return encodeLogicalImmediate&lt;32&gt;(hsb, lsb, inverted);
 92 
 93         if ((value &amp; 0xffff) != (value &gt;&gt; 16))
 94             return InvalidLogicalImmediate;
 95         value &amp;= 0xffff;
 96 
 97         if (findBitRange&lt;16&gt;(value, hsb, lsb, inverted))
 98             return encodeLogicalImmediate&lt;16&gt;(hsb, lsb, inverted);
 99 
100         if ((value &amp; 0xff) != (value &gt;&gt; 8))
101             return InvalidLogicalImmediate;
102         value &amp;= 0xff;
103 
104         if (findBitRange&lt;8&gt;(value, hsb, lsb, inverted))
105             return encodeLogicalImmediate&lt;8&gt;(hsb, lsb, inverted);
106 
107         if ((value &amp; 0xf) != (value &gt;&gt; 4))
108             return InvalidLogicalImmediate;
109         value &amp;= 0xf;
110 
111         if (findBitRange&lt;4&gt;(value, hsb, lsb, inverted))
112             return encodeLogicalImmediate&lt;4&gt;(hsb, lsb, inverted);
113 
114         if ((value &amp; 0x3) != (value &gt;&gt; 2))
115             return InvalidLogicalImmediate;
116         value &amp;= 0x3;
117 
118         if (findBitRange&lt;2&gt;(value, hsb, lsb, inverted))
119             return encodeLogicalImmediate&lt;2&gt;(hsb, lsb, inverted);
120 
121         return InvalidLogicalImmediate;
122     }
123 
124     static ARM64LogicalImmediate create64(uint64_t value)
125     {
126         // Check for 0, -1 - these cannot be encoded.
127         if (!value || !~value)
128             return InvalidLogicalImmediate;
129 
130         // Look for a contiguous bit range.
131         unsigned hsb, lsb;
132         bool inverted;
133         if (findBitRange&lt;64&gt;(value, hsb, lsb, inverted))
134             return encodeLogicalImmediate&lt;64&gt;(hsb, lsb, inverted);
135 
136         // If the high &amp; low 32 bits are equal, we can try for a 32-bit (or narrower) pattern.
137         if (static_cast&lt;uint32_t&gt;(value) == static_cast&lt;uint32_t&gt;(value &gt;&gt; 32))
138             return create32(static_cast&lt;uint32_t&gt;(value));
139         return InvalidLogicalImmediate;
140     }
141 
142     int value() const
143     {
144         ASSERT(isValid());
145         return m_value;
146     }
147 
148     bool isValid() const
149     {
150         return m_value != InvalidLogicalImmediate;
151     }
152 
153     bool is64bit() const
154     {
155         return m_value &amp; (1 &lt;&lt; 12);
156     }
157 
158 private:
159     ARM64LogicalImmediate(int value)
160         : m_value(value)
161     {
162     }
163 
164     // Generate a mask with bits in the range hsb..0 set, for example:
165     //   hsb:63 = 0xffffffffffffffff
166     //   hsb:42 = 0x000007ffffffffff
167     //   hsb: 0 = 0x0000000000000001
168     static uint64_t mask(unsigned hsb)
169     {
170         ASSERT(hsb &lt; 64);
171         return 0xffffffffffffffffull &gt;&gt; (63 - hsb);
172     }
173 
174     template&lt;unsigned N&gt;
175     static void partialHSB(uint64_t&amp; value, unsigned&amp;result)
176     {
177         if (value &amp; (0xffffffffffffffffull &lt;&lt; N)) {
178             result += N;
179             value &gt;&gt;= N;
180         }
181     }
182 
183     // Find the bit number of the highest bit set in a non-zero value, for example:
184     //   0x8080808080808080 = hsb:63
185     //   0x0000000000000001 = hsb: 0
186     //   0x000007ffffe00000 = hsb:42
187     static unsigned highestSetBit(uint64_t value)
188     {
189         ASSERT(value);
190         unsigned hsb = 0;
191         partialHSB&lt;32&gt;(value, hsb);
192         partialHSB&lt;16&gt;(value, hsb);
193         partialHSB&lt;8&gt;(value, hsb);
194         partialHSB&lt;4&gt;(value, hsb);
195         partialHSB&lt;2&gt;(value, hsb);
196         partialHSB&lt;1&gt;(value, hsb);
197         return hsb;
198     }
199 
200     // This function takes a value and a bit width, where value obeys the following constraints:
201     //   * bits outside of the width of the value must be zero.
202     //   * bits within the width of value must neither be all clear or all set.
203     // The input is inspected to detect values that consist of either two or three contiguous
204     // ranges of bits. The output range hsb..lsb will describe the second range of the value.
205     // if the range is set, inverted will be false, and if the range is clear, inverted will
206     // be true. For example (with width 8):
207     //   00001111 = hsb:3, lsb:0, inverted:false
208     //   11110000 = hsb:3, lsb:0, inverted:true
209     //   00111100 = hsb:5, lsb:2, inverted:false
210     //   11000011 = hsb:5, lsb:2, inverted:true
211     template&lt;unsigned width&gt;
212     static bool findBitRange(uint64_t value, unsigned&amp; hsb, unsigned&amp; lsb, bool&amp; inverted)
213     {
214         ASSERT(value &amp; mask(width - 1));
215         ASSERT(value != mask(width - 1));
216         ASSERT(!(value &amp; ~mask(width - 1)));
217 
218         // Detect cases where the top bit is set; if so, flip all the bits &amp; set invert.
219         // This halves the number of patterns we need to look for.
220         const uint64_t msb = 1ull &lt;&lt; (width - 1);
221         if ((inverted = (value &amp; msb)))
222             value ^= mask(width - 1);
223 
224         // Find the highest set bit in value, generate a corresponding mask &amp; flip all
225         // bits under it.
226         hsb = highestSetBit(value);
227         value ^= mask(hsb);
228         if (!value) {
229             // If this cleared the value, then the range hsb..0 was all set.
230             lsb = 0;
231             return true;
232         }
233 
234         // Try making one more mask, and flipping the bits!
235         lsb = highestSetBit(value);
236         value ^= mask(lsb);
237         if (!value) {
238             // Success - but lsb actually points to the hsb of a third range - add one
239             // to get to the lsb of the mid range.
240             ++lsb;
241             return true;
242         }
243 
244         return false;
245     }
246 
247     // Encodes the set of immN:immr:imms fields found in a logical immediate.
248     template&lt;unsigned width&gt;
249     static int encodeLogicalImmediate(unsigned hsb, unsigned lsb, bool inverted)
250     {
251         // Check width is a power of 2!
252         ASSERT(!(width &amp; (width -1)));
253         ASSERT(width &lt;= 64 &amp;&amp; width &gt;= 2);
254         ASSERT(hsb &gt;= lsb);
255         ASSERT(hsb &lt; width);
256 
257         int immN = 0;
258         int imms = 0;
259         int immr = 0;
260 
261         // For 64-bit values this is easy - just set immN to true, and imms just
262         // contains the bit number of the highest set bit of the set range. For
263         // values with narrower widths, these are encoded by a leading set of
264         // one bits, followed by a zero bit, followed by the remaining set of bits
265         // being the high bit of the range. For a 32-bit immediate there are no
266         // leading one bits, just a zero followed by a five bit number. For a
267         // 16-bit immediate there is one one bit, a zero bit, and then a four bit
268         // bit-position, etc.
269         if (width == 64)
270             immN = 1;
271         else
272             imms = 63 &amp; ~(width + width - 1);
273 
274         if (inverted) {
275             // if width is 64 &amp; hsb is 62, then we have a value something like:
276             //   0x80000000ffffffff (in this case with lsb 32).
277             // The ror should be by 1, imms (effectively set width minus 1) is
278             // 32. Set width is full width minus cleared width.
279             immr = (width - 1) - hsb;
280             imms |= (width - ((hsb - lsb) + 1)) - 1;
281         } else {
282             // if width is 64 &amp; hsb is 62, then we have a value something like:
283             //   0x7fffffff00000000 (in this case with lsb 32).
284             // The value is effectively rol&#39;ed by lsb, which is equivalent to
285             // a ror by width - lsb (or 0, in the case where lsb is 0). imms
286             // is hsb - lsb.
287             immr = (width - lsb) &amp; (width - 1);
288             imms |= hsb - lsb;
289         }
290 
291         return immN &lt;&lt; 12 | immr &lt;&lt; 6 | imms;
292     }
293 
<a name="3" id="anc3"></a><span class="line-modified">294     static constexpr int InvalidLogicalImmediate = -1;</span>
295 
296     int m_value;
297 };
298 
299 } // namespace JSC.
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
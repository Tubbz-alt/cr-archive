diff a/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h b/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h
@@ -41,23 +41,24 @@
 class CSSStyleSheet;
 class Document;
 class Element;
 class Node;
 class ProcessingInstruction;
-class StyleResolver;
 class StyleSheet;
 class StyleSheetContents;
 class StyleSheetList;
 class ShadowRoot;
 class TreeScope;
 
 namespace Style {
 
+class Resolver;
+
 // This is used to identify style scopes that can affect an element.
 // Scopes are in tree-of-trees order. Styles from earlier scopes win over later ones (modulo !important).
 enum class ScopeOrdinal : int {
-    ContainingHost = -1, // Author-exposed UA pseudo classes from the host tree scope.
+    ContainingHost = -1, // ::part rules and author-exposed UA pseudo classes from the host tree scope.
     Element = 0, // Normal rules in the same tree where the element is.
     FirstSlot = 1, // ::slotted rules in the parent's shadow tree. Values greater than FirstSlot indicate subsequent slots in the chain.
     Shadow = std::numeric_limits<int>::max(), // :host rules in element's own shadow tree.
 };
 
@@ -105,23 +106,28 @@
     void didChangeStyleSheetContents();
     // This is called when the environment where we intrepret the stylesheets changes (for example switching to printing).
     // The change is assumed to potentially affect all author and user stylesheets including shadow roots.
     WEBCORE_EXPORT void didChangeStyleSheetEnvironment();
 
+    void invalidateMatchedDeclarationsCache();
+
     bool hasPendingUpdate() const { return m_pendingUpdate || m_hasDescendantWithPendingUpdate; }
     void flushPendingUpdate();
 
 #if ENABLE(XSLT)
     Vector<Ref<ProcessingInstruction>> collectXSLTransforms();
 #endif
 
-    StyleResolver& resolver();
-    StyleResolver* resolverIfExists();
+    WEBCORE_EXPORT Resolver& resolver();
+    Resolver* resolverIfExists();
     void clearResolver();
     void releaseMemory();
 
     const Document& document() const { return m_document; }
+    Document& document() { return m_document; }
+    const ShadowRoot* shadowRoot() const { return m_shadowRoot; }
+    ShadowRoot* shadowRoot() { return m_shadowRoot; }
 
     static Scope& forNode(Node&);
     static Scope* forOrdinal(Element&, ScopeOrdinal);
 
 private:
@@ -138,25 +144,31 @@
     WEBCORE_EXPORT void flushPendingSelfUpdate();
     WEBCORE_EXPORT void flushPendingDescendantUpdates();
 
     void collectActiveStyleSheets(Vector<RefPtr<StyleSheet>>&);
 
-    enum StyleResolverUpdateType {
+    enum class ResolverUpdateType {
         Reconstruct,
         Reset,
         Additive
     };
-    StyleResolverUpdateType analyzeStyleSheetChange(const Vector<RefPtr<CSSStyleSheet>>& newStylesheets, bool& requiresFullStyleRecalc);
-    void updateStyleResolver(Vector<RefPtr<CSSStyleSheet>>&, StyleResolverUpdateType);
+    struct StyleSheetChange {
+        ResolverUpdateType resolverUpdateType;
+        Vector<StyleSheetContents*> addedSheets { };
+    };
+    StyleSheetChange analyzeStyleSheetChange(const Vector<RefPtr<CSSStyleSheet>>& newStylesheets);
+    void invalidateStyleAfterStyleSheetChange(const StyleSheetChange&);
+
+    void updateResolver(Vector<RefPtr<CSSStyleSheet>>&, ResolverUpdateType);
 
     void pendingUpdateTimerFired();
     void clearPendingUpdate();
 
     Document& m_document;
     ShadowRoot* m_shadowRoot { nullptr };
 
-    std::unique_ptr<StyleResolver> m_resolver;
+    std::unique_ptr<Resolver> m_resolver;
 
     Vector<RefPtr<StyleSheet>> m_styleSheetsForStyleSheetList;
     Vector<RefPtr<CSSStyleSheet>> m_activeStyleSheets;
 
     Timer m_pendingUpdateTimer;

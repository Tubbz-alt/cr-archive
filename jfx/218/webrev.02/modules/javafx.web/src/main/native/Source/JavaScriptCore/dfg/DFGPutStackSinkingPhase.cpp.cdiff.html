<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPureValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGRegisterBank.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,15 ***</span>
  
  namespace JSC { namespace DFG {
  
  namespace {
  
<span class="line-removed">- namespace DFGPutStackSinkingPhaseInternal {</span>
<span class="line-removed">- static const bool verbose = false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  class PutStackSinkingPhase : public Phase {
  public:
      PutStackSinkingPhase(Graph&amp; graph)
          : Phase(graph, &quot;PutStack sinking&quot;)
      {
      }
<span class="line-new-header">--- 40,12 ---</span>
  
  namespace JSC { namespace DFG {
  
  namespace {
  
  class PutStackSinkingPhase : public Phase {
<span class="line-added">+     static constexpr bool verbose = false;</span>
  public:
      PutStackSinkingPhase(Graph&amp; graph)
          : Phase(graph, &quot;PutStack sinking&quot;)
      {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,11 ***</span>
          // More important is that KillStack should swallow any deferral. After a KillStack, the
          // local should behave like a TOP deferral because it would be invalid for anyone to trust
          // the stack. It&#39;s not clear to me if this is important or not.
          // https://bugs.webkit.org/show_bug.cgi?id=145296
  
<span class="line-modified">!         if (DFGPutStackSinkingPhaseInternal::verbose) {</span>
              dataLog(&quot;Graph before PutStack sinking:\n&quot;);
              m_graph.dump();
          }
  
          m_graph.ensureSSADominators();
<span class="line-new-header">--- 68,11 ---</span>
          // More important is that KillStack should swallow any deferral. After a KillStack, the
          // local should behave like a TOP deferral because it would be invalid for anyone to trust
          // the stack. It&#39;s not clear to me if this is important or not.
          // https://bugs.webkit.org/show_bug.cgi?id=145296
  
<span class="line-modified">!         if (verbose) {</span>
              dataLog(&quot;Graph before PutStack sinking:\n&quot;);
              m_graph.dump();
          }
  
          m_graph.ensureSSADominators();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,15 ***</span>
          // First figure out where various locals are live.
          BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtHead(m_graph);
          BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtTail(m_graph);
  
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="line-modified">!             liveAtHead[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="line-modified">!             liveAtTail[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             liveAtHead[block].fill(false);</span>
<span class="line-removed">-             liveAtTail[block].fill(false);</span>
          }
  
          bool changed;
          do {
              changed = false;
<span class="line-new-header">--- 83,12 ---</span>
          // First figure out where various locals are live.
          BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtHead(m_graph);
          BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtTail(m_graph);
  
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="line-modified">!             liveAtHead[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead, false);</span>
<span class="line-modified">!             liveAtTail[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead, false);</span>
          }
  
          bool changed;
          do {
              changed = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,37 ***</span>
                      continue;
  
                  Operands&lt;bool&gt; live = liveAtTail[block];
                  for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
                      Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">!                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                          dataLog(&quot;Live at &quot;, node, &quot;: &quot;, live, &quot;\n&quot;);
  
<span class="line-modified">!                     Vector&lt;VirtualRegister, 4&gt; reads;</span>
<span class="line-modified">!                     Vector&lt;VirtualRegister, 4&gt; writes;</span>
<span class="line-modified">!                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
                          if (operand.isHeader())
                              return;
<span class="line-modified">!                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                              dataLog(&quot;    &quot;, operand, &quot; is live at &quot;, node, &quot;\n&quot;);
                          reads.append(operand);
                      };
  
<span class="line-modified">!                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>
                          if (operand.isHeader())
                              return;
<span class="line-modified">!                         RELEASE_ASSERT(node-&gt;op() == PutStack || node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs || node-&gt;op() == KillStack);</span>
                          writes.append(operand);
                      };
  
                      preciseLocalClobberize(
                          m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">!                         [&amp;] (VirtualRegister, LazyNode) { });</span>
  
<span class="line-modified">!                     for (VirtualRegister operand : writes)</span>
                          live.operand(operand) = false;
<span class="line-modified">!                     for (VirtualRegister operand : reads)</span>
                          live.operand(operand) = true;
                  }
  
                  if (live == liveAtHead[block])
                      continue;
<span class="line-new-header">--- 99,38 ---</span>
                      continue;
  
                  Operands&lt;bool&gt; live = liveAtTail[block];
                  for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
                      Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;Live at &quot;, node, &quot;: &quot;, live, &quot;\n&quot;);
  
<span class="line-modified">!                     Vector&lt;Operand, 4&gt; reads;</span>
<span class="line-modified">!                     Vector&lt;Operand, 4&gt; writes;</span>
<span class="line-modified">!                     auto escapeHandler = [&amp;] (Operand operand) {</span>
                          if (operand.isHeader())
                              return;
<span class="line-modified">!                         if (verbose)</span>
                              dataLog(&quot;    &quot;, operand, &quot; is live at &quot;, node, &quot;\n&quot;);
                          reads.append(operand);
                      };
  
<span class="line-modified">!                     auto writeHandler = [&amp;] (Operand operand) {</span>
                          if (operand.isHeader())
                              return;
<span class="line-modified">!                         auto op = node-&gt;op();</span>
<span class="line-added">+                         RELEASE_ASSERT(op == PutStack || op == LoadVarargs || op == ForwardVarargs || op == KillStack);</span>
                          writes.append(operand);
                      };
  
                      preciseLocalClobberize(
                          m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">!                         [&amp;] (Operand, LazyNode) { });</span>
  
<span class="line-modified">!                     for (Operand operand : writes)</span>
                          live.operand(operand) = false;
<span class="line-modified">!                     for (Operand operand : reads)</span>
                          live.operand(operand) = true;
                  }
  
                  if (live == liveAtHead[block])
                      continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,11 ***</span>
  
              for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
                  Operands&lt;FlushFormat&gt; deferred = deferredAtHead[block];
  
                  for (Node* node : *block) {
<span class="line-modified">!                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                          dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
  
                      if (node-&gt;op() == GetStack) {
                          // Handle the case that the input doesn&#39;t match our requirements. This is
                          // really a bug, but it&#39;s a benign one if we simply don&#39;t run this phase.
<span class="line-new-header">--- 227,11 ---</span>
  
              for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
                  Operands&lt;FlushFormat&gt; deferred = deferredAtHead[block];
  
                  for (Node* node : *block) {
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
  
                      if (node-&gt;op() == GetStack) {
                          // Handle the case that the input doesn&#39;t match our requirements. This is
                          // really a bug, but it&#39;s a benign one if we simply don&#39;t run this phase.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,11 ***</span>
                          // disabled we silently let this fly and we just abort this phase.
                          // FIXME: Get rid of all remaining cases of conflicting GetStacks.
                          // https://bugs.webkit.org/show_bug.cgi?id=150398
  
                          bool isConflicting =
<span class="line-modified">!                             deferred.operand(node-&gt;stackAccessData()-&gt;local) == ConflictingFlush;</span>
  
                          if (validationEnabled())
                              DFG_ASSERT(m_graph, node, !isConflicting);
  
                          if (isConflicting) {
<span class="line-new-header">--- 254,11 ---</span>
                          // disabled we silently let this fly and we just abort this phase.
                          // FIXME: Get rid of all remaining cases of conflicting GetStacks.
                          // https://bugs.webkit.org/show_bug.cgi?id=150398
  
                          bool isConflicting =
<span class="line-modified">!                             deferred.operand(node-&gt;stackAccessData()-&gt;operand) == ConflictingFlush;</span>
  
                          if (validationEnabled())
                              DFG_ASSERT(m_graph, node, !isConflicting);
  
                          if (isConflicting) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,55 ***</span>
  
                          // A GetStack doesn&#39;t affect anything, since we know which local we are reading
                          // from.
                          continue;
                      } else if (node-&gt;op() == PutStack) {
<span class="line-modified">!                         VirtualRegister operand = node-&gt;stackAccessData()-&gt;local;</span>
                          deferred.operand(operand) = node-&gt;stackAccessData()-&gt;format;
                          continue;
                      } else if (node-&gt;op() == KillStack) {
                          // We don&#39;t want to sink a PutStack past a KillStack.
<span class="line-modified">!                         deferred.operand(node-&gt;unlinkedLocal()) = ConflictingFlush;</span>
                          continue;
                      }
  
<span class="line-modified">!                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">!                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                              dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
                          if (operand.isHeader())
                              return;
                          // We will materialize just before any reads.
                          deferred.operand(operand) = DeadFlush;
                      };
  
<span class="line-modified">!                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>
                          if (operand.isHeader())
                              return;
<span class="line-modified">!                         RELEASE_ASSERT(node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
                          deferred.operand(operand) = DeadFlush;
                      };
  
                      preciseLocalClobberize(
                          m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">!                         [&amp;] (VirtualRegister, LazyNode) { });</span>
                  }
  
                  if (deferred == deferredAtTail[block])
                      continue;
  
                  deferredAtTail[block] = deferred;
                  changed = true;
  
                  for (BasicBlock* successor : block-&gt;successors()) {
                      for (size_t i = deferred.size(); i--;) {
<span class="line-modified">!                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
<span class="line-modified">!                             dataLog(&quot;Considering &quot;, VirtualRegister(deferred.operandForIndex(i)), &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successor), &quot;: &quot;, deferred[i], &quot; and &quot;, deferredAtHead[successor][i], &quot; merges to &quot;);</span>
  
                          deferredAtHead[successor][i] =
                              merge(deferredAtHead[successor][i], deferred[i]);
  
<span class="line-modified">!                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                              dataLog(deferredAtHead[successor][i], &quot;\n&quot;);
                      }
                  }
              }
  
<span class="line-new-header">--- 268,60 ---</span>
  
                          // A GetStack doesn&#39;t affect anything, since we know which local we are reading
                          // from.
                          continue;
                      } else if (node-&gt;op() == PutStack) {
<span class="line-modified">!                         Operand operand = node-&gt;stackAccessData()-&gt;operand;</span>
<span class="line-added">+                         dataLogLnIf(verbose, &quot;Setting flush format for &quot;, node, &quot; at operand &quot;, operand);</span>
                          deferred.operand(operand) = node-&gt;stackAccessData()-&gt;format;
                          continue;
                      } else if (node-&gt;op() == KillStack) {
                          // We don&#39;t want to sink a PutStack past a KillStack.
<span class="line-modified">!                         if (verbose)</span>
<span class="line-added">+                             dataLogLn(&quot;Killing stack for &quot;, node-&gt;unlinkedOperand());</span>
<span class="line-added">+                         deferred.operand(node-&gt;unlinkedOperand()) = ConflictingFlush;</span>
                          continue;
                      }
  
<span class="line-modified">!                     auto escapeHandler = [&amp;] (Operand operand) {</span>
<span class="line-modified">!                         if (verbose)</span>
                              dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
                          if (operand.isHeader())
                              return;
                          // We will materialize just before any reads.
                          deferred.operand(operand) = DeadFlush;
                      };
  
<span class="line-modified">!                     auto writeHandler = [&amp;] (Operand operand) {</span>
<span class="line-added">+                         ASSERT(!operand.isTmp());</span>
                          if (operand.isHeader())
                              return;
<span class="line-modified">!                         RELEASE_ASSERT(node-&gt;op() == VarargsLength || node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
<span class="line-added">+                         dataLogLnIf(verbose, &quot;Writing dead flush for &quot;, node, &quot; at operand &quot;, operand);</span>
                          deferred.operand(operand) = DeadFlush;
                      };
  
                      preciseLocalClobberize(
                          m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">!                         [&amp;] (Operand, LazyNode) { });</span>
                  }
  
                  if (deferred == deferredAtTail[block])
                      continue;
  
                  deferredAtTail[block] = deferred;
                  changed = true;
  
                  for (BasicBlock* successor : block-&gt;successors()) {
                      for (size_t i = deferred.size(); i--;) {
<span class="line-modified">!                         if (verbose)</span>
<span class="line-modified">!                             dataLog(&quot;Considering &quot;, deferred.operandForIndex(i), &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successor), &quot;: &quot;, deferred[i], &quot; and &quot;, deferredAtHead[successor][i], &quot; merges to &quot;);</span>
  
                          deferredAtHead[successor][i] =
                              merge(deferredAtHead[successor][i], deferred[i]);
  
<span class="line-modified">!                         if (verbose)</span>
                              dataLog(deferredAtHead[successor][i], &quot;\n&quot;);
                      }
                  }
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,13 ***</span>
          // This means that we have an SSACalculator::Variable for each local, and a Def is any
          // PutStack in the original program. The original PutStacks will simply vanish.
  
          Operands&lt;SSACalculator::Variable*&gt; operandToVariable(
              OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
<span class="line-modified">!         Vector&lt;VirtualRegister&gt; indexToOperand;</span>
          for (size_t i = m_graph.block(0)-&gt;variablesAtHead.size(); i--;) {
<span class="line-modified">!             VirtualRegister operand(m_graph.block(0)-&gt;variablesAtHead.operandForIndex(i));</span>
  
              SSACalculator::Variable* variable = ssaCalculator.newVariable();
              operandToVariable.operand(operand) = variable;
              ASSERT(indexToOperand.size() == variable-&gt;index());
              indexToOperand.append(operand);
<span class="line-new-header">--- 350,13 ---</span>
          // This means that we have an SSACalculator::Variable for each local, and a Def is any
          // PutStack in the original program. The original PutStacks will simply vanish.
  
          Operands&lt;SSACalculator::Variable*&gt; operandToVariable(
              OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
<span class="line-modified">!         Vector&lt;Operand&gt; indexToOperand;</span>
          for (size_t i = m_graph.block(0)-&gt;variablesAtHead.size(); i--;) {
<span class="line-modified">!             Operand operand = m_graph.block(0)-&gt;variablesAtHead.operandForIndex(i);</span>
  
              SSACalculator::Variable* variable = ssaCalculator.newVariable();
              operandToVariable.operand(operand) = variable;
              ASSERT(indexToOperand.size() == variable-&gt;index());
              indexToOperand.append(operand);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,38 ***</span>
              for (Node* node : *block) {
                  switch (node-&gt;op()) {
                  case PutStack:
                      putStacksToSink.add(node);
                      ssaCalculator.newDef(
<span class="line-modified">!                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;local),</span>
                          block, node-&gt;child1().node());
                      break;
                  case GetStack:
                      ssaCalculator.newDef(
<span class="line-modified">!                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;local),</span>
                          block, node);
                      break;
                  default:
                      break;
                  }
              }
          }
  
          ssaCalculator.computePhis(
              [&amp;] (SSACalculator::Variable* variable, BasicBlock* block) -&gt; Node* {
<span class="line-modified">!                 VirtualRegister operand = indexToOperand[variable-&gt;index()];</span>
  
                  if (!liveAtHead[block].operand(operand))
                      return nullptr;
  
                  FlushFormat format = deferredAtHead[block].operand(operand);
  
                  // We could have an invalid deferral because liveness is imprecise.
                  if (!isConcrete(format))
                      return nullptr;
  
<span class="line-modified">!                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                      dataLog(&quot;Adding Phi for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;\n&quot;);
  
                  Node* phiNode = m_graph.addNode(SpecHeapTop, Phi, block-&gt;at(0)-&gt;origin.withInvalidExit());
                  phiNode-&gt;mergeFlags(resultFor(format));
                  return phiNode;
<span class="line-new-header">--- 368,38 ---</span>
              for (Node* node : *block) {
                  switch (node-&gt;op()) {
                  case PutStack:
                      putStacksToSink.add(node);
                      ssaCalculator.newDef(
<span class="line-modified">!                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;operand),</span>
                          block, node-&gt;child1().node());
                      break;
                  case GetStack:
                      ssaCalculator.newDef(
<span class="line-modified">!                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;operand),</span>
                          block, node);
                      break;
                  default:
                      break;
                  }
              }
          }
  
          ssaCalculator.computePhis(
              [&amp;] (SSACalculator::Variable* variable, BasicBlock* block) -&gt; Node* {
<span class="line-modified">!                 Operand operand = indexToOperand[variable-&gt;index()];</span>
  
                  if (!liveAtHead[block].operand(operand))
                      return nullptr;
  
                  FlushFormat format = deferredAtHead[block].operand(operand);
  
                  // We could have an invalid deferral because liveness is imprecise.
                  if (!isConcrete(format))
                      return nullptr;
  
<span class="line-modified">!                 if (verbose)</span>
                      dataLog(&quot;Adding Phi for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;\n&quot;);
  
                  Node* phiNode = m_graph.addNode(SpecHeapTop, Phi, block-&gt;at(0)-&gt;origin.withInvalidExit());
                  phiNode-&gt;mergeFlags(resultFor(format));
                  return phiNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,85 ***</span>
          Operands&lt;FlushFormat&gt; deferred;
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
              mapping.fill(nullptr);
  
              for (size_t i = mapping.size(); i--;) {
<span class="line-modified">!                 VirtualRegister operand(mapping.operandForIndex(i));</span>
  
                  SSACalculator::Variable* variable = operandToVariable.operand(operand);
                  SSACalculator::Def* def = ssaCalculator.reachingDefAtHead(block, variable);
                  if (!def)
                      continue;
  
                  mapping.operand(operand) = def-&gt;value();
              }
  
<span class="line-modified">!             if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                  dataLog(&quot;Mapping at top of &quot;, pointerDump(block), &quot;: &quot;, mapping, &quot;\n&quot;);
  
              for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(block)) {
<span class="line-modified">!                 VirtualRegister operand = indexToOperand[phiDef-&gt;variable()-&gt;index()];</span>
  
                  insertionSet.insert(0, phiDef-&gt;value());
  
<span class="line-modified">!                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                      dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, phiDef-&gt;value(), &quot;\n&quot;);
                  mapping.operand(operand) = phiDef-&gt;value();
              }
  
              deferred = deferredAtHead[block];
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
                  Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">!                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                      dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
  
                  switch (node-&gt;op()) {
                  case PutStack: {
                      StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!                     VirtualRegister operand = data-&gt;local;</span>
                      deferred.operand(operand) = data-&gt;format;
<span class="line-modified">!                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                          dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, node-&gt;child1().node(), &quot; at &quot;, node, &quot;\n&quot;);
                      mapping.operand(operand) = node-&gt;child1().node();
                      break;
                  }
  
                  case GetStack: {
                      StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!                     FlushFormat format = deferred.operand(data-&gt;local);</span>
                      if (!isConcrete(format)) {
                          DFG_ASSERT(
                              m_graph, node,
<span class="line-modified">!                             deferred.operand(data-&gt;local) != ConflictingFlush, deferred.operand(data-&gt;local));</span>
  
                          // This means there is no deferral. No deferral means that the most
                          // authoritative value for this stack slot is what is stored in the stack. So,
                          // keep the GetStack.
<span class="line-modified">!                         mapping.operand(data-&gt;local) = node;</span>
                          break;
                      }
  
                      // We have a concrete deferral, which means a PutStack that hasn&#39;t executed yet. It
                      // would have stored a value with a certain format. That format must match our
                      // format. But more importantly, we can simply use the value that the PutStack would
                      // have stored and get rid of the GetStack.
                      DFG_ASSERT(m_graph, node, format == data-&gt;format, format, data-&gt;format);
  
<span class="line-modified">!                     Node* incoming = mapping.operand(data-&gt;local);</span>
                      node-&gt;child1() = incoming-&gt;defaultEdge();
                      node-&gt;convertToIdentity();
                      break;
                  }
  
                  case KillStack: {
<span class="line-modified">!                     deferred.operand(node-&gt;unlinkedLocal()) = ConflictingFlush;</span>
                      break;
                  }
  
                  default: {
<span class="line-modified">!                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">!                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                              dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
  
                          if (operand.isHeader())
                              return;
  
<span class="line-new-header">--- 409,85 ---</span>
          Operands&lt;FlushFormat&gt; deferred;
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
              mapping.fill(nullptr);
  
              for (size_t i = mapping.size(); i--;) {
<span class="line-modified">!                 Operand operand(mapping.operandForIndex(i));</span>
  
                  SSACalculator::Variable* variable = operandToVariable.operand(operand);
                  SSACalculator::Def* def = ssaCalculator.reachingDefAtHead(block, variable);
                  if (!def)
                      continue;
  
                  mapping.operand(operand) = def-&gt;value();
              }
  
<span class="line-modified">!             if (verbose)</span>
                  dataLog(&quot;Mapping at top of &quot;, pointerDump(block), &quot;: &quot;, mapping, &quot;\n&quot;);
  
              for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(block)) {
<span class="line-modified">!                 Operand operand = indexToOperand[phiDef-&gt;variable()-&gt;index()];</span>
  
                  insertionSet.insert(0, phiDef-&gt;value());
  
<span class="line-modified">!                 if (verbose)</span>
                      dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, phiDef-&gt;value(), &quot;\n&quot;);
                  mapping.operand(operand) = phiDef-&gt;value();
              }
  
              deferred = deferredAtHead[block];
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
                  Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">!                 if (verbose)</span>
                      dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
  
                  switch (node-&gt;op()) {
                  case PutStack: {
                      StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!                     Operand operand = data-&gt;operand;</span>
                      deferred.operand(operand) = data-&gt;format;
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, node-&gt;child1().node(), &quot; at &quot;, node, &quot;\n&quot;);
                      mapping.operand(operand) = node-&gt;child1().node();
                      break;
                  }
  
                  case GetStack: {
                      StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!                     FlushFormat format = deferred.operand(data-&gt;operand);</span>
                      if (!isConcrete(format)) {
                          DFG_ASSERT(
                              m_graph, node,
<span class="line-modified">!                             deferred.operand(data-&gt;operand) != ConflictingFlush, deferred.operand(data-&gt;operand));</span>
  
                          // This means there is no deferral. No deferral means that the most
                          // authoritative value for this stack slot is what is stored in the stack. So,
                          // keep the GetStack.
<span class="line-modified">!                         mapping.operand(data-&gt;operand) = node;</span>
                          break;
                      }
  
                      // We have a concrete deferral, which means a PutStack that hasn&#39;t executed yet. It
                      // would have stored a value with a certain format. That format must match our
                      // format. But more importantly, we can simply use the value that the PutStack would
                      // have stored and get rid of the GetStack.
                      DFG_ASSERT(m_graph, node, format == data-&gt;format, format, data-&gt;format);
  
<span class="line-modified">!                     Node* incoming = mapping.operand(data-&gt;operand);</span>
                      node-&gt;child1() = incoming-&gt;defaultEdge();
                      node-&gt;convertToIdentity();
                      break;
                  }
  
                  case KillStack: {
<span class="line-modified">!                     deferred.operand(node-&gt;unlinkedOperand()) = ConflictingFlush;</span>
                      break;
                  }
  
                  default: {
<span class="line-modified">!                     auto escapeHandler = [&amp;] (Operand operand) {</span>
<span class="line-modified">!                         if (verbose)</span>
                              dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
  
                          if (operand.isHeader())
                              return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 497,11 ***</span>
                              deferred.operand(operand) = DeadFlush;
                              return;
                          }
  
                          // Gotta insert a PutStack.
<span class="line-modified">!                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                              dataLog(&quot;Inserting a PutStack for &quot;, operand, &quot; at &quot;, node, &quot;\n&quot;);
  
                          Node* incoming = mapping.operand(operand);
                          DFG_ASSERT(m_graph, node, incoming);
  
<span class="line-new-header">--- 497,11 ---</span>
                              deferred.operand(operand) = DeadFlush;
                              return;
                          }
  
                          // Gotta insert a PutStack.
<span class="line-modified">!                         if (verbose)</span>
                              dataLog(&quot;Inserting a PutStack for &quot;, operand, &quot; at &quot;, node, &quot;\n&quot;);
  
                          Node* incoming = mapping.operand(operand);
                          DFG_ASSERT(m_graph, node, incoming);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,25 ***</span>
                              Edge(incoming, uncheckedUseKindFor(format)));
  
                          deferred.operand(operand) = DeadFlush;
                      };
  
<span class="line-modified">!                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>
                          if (operand.isHeader())
                              return;
                          // LoadVarargs and ForwardVarargs are unconditional writes to the stack
                          // locations they claim to write to. They do not read from the stack
                          // locations they write to. This makes those stack locations dead right
                          // before a LoadVarargs/ForwardVarargs. This means we should never sink
                          // PutStacks right to this point.
<span class="line-modified">!                         RELEASE_ASSERT(node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
                          deferred.operand(operand) = DeadFlush;
                      };
  
                      preciseLocalClobberize(
                          m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">!                         [&amp;] (VirtualRegister, LazyNode) { });</span>
                      break;
                  } }
              }
  
              NodeAndIndex terminal = block-&gt;findTerminal();
<span class="line-new-header">--- 511,25 ---</span>
                              Edge(incoming, uncheckedUseKindFor(format)));
  
                          deferred.operand(operand) = DeadFlush;
                      };
  
<span class="line-modified">!                     auto writeHandler = [&amp;] (Operand operand) {</span>
                          if (operand.isHeader())
                              return;
                          // LoadVarargs and ForwardVarargs are unconditional writes to the stack
                          // locations they claim to write to. They do not read from the stack
                          // locations they write to. This makes those stack locations dead right
                          // before a LoadVarargs/ForwardVarargs. This means we should never sink
                          // PutStacks right to this point.
<span class="line-modified">!                         RELEASE_ASSERT(node-&gt;op() == VarargsLength || node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
                          deferred.operand(operand) = DeadFlush;
                      };
  
                      preciseLocalClobberize(
                          m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">!                         [&amp;] (Operand, LazyNode) { });</span>
                      break;
                  } }
              }
  
              NodeAndIndex terminal = block-&gt;findTerminal();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 537,12 ***</span>
              NodeOrigin upsilonOrigin = terminal.node-&gt;origin;
              for (BasicBlock* successorBlock : block-&gt;successors()) {
                  for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(successorBlock)) {
                      Node* phiNode = phiDef-&gt;value();
                      SSACalculator::Variable* variable = phiDef-&gt;variable();
<span class="line-modified">!                     VirtualRegister operand = indexToOperand[variable-&gt;index()];</span>
<span class="line-modified">!                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
                          dataLog(&quot;Creating Upsilon for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successorBlock), &quot;\n&quot;);
                      FlushFormat format = deferredAtHead[successorBlock].operand(operand);
                      DFG_ASSERT(m_graph, nullptr, isConcrete(format), format);
                      UseKind useKind = uncheckedUseKindFor(format);
  
<span class="line-new-header">--- 537,12 ---</span>
              NodeOrigin upsilonOrigin = terminal.node-&gt;origin;
              for (BasicBlock* successorBlock : block-&gt;successors()) {
                  for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(successorBlock)) {
                      Node* phiNode = phiDef-&gt;value();
                      SSACalculator::Variable* variable = phiDef-&gt;variable();
<span class="line-modified">!                     Operand operand = indexToOperand[variable-&gt;index()];</span>
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;Creating Upsilon for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successorBlock), &quot;\n&quot;);
                      FlushFormat format = deferredAtHead[successorBlock].operand(operand);
                      DFG_ASSERT(m_graph, nullptr, isConcrete(format), format);
                      UseKind useKind = uncheckedUseKindFor(format);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,11 ***</span>
  
                  node-&gt;remove(m_graph);
              }
          }
  
<span class="line-modified">!         if (DFGPutStackSinkingPhaseInternal::verbose) {</span>
              dataLog(&quot;Graph after PutStack sinking:\n&quot;);
              m_graph.dump();
          }
  
          return true;
<span class="line-new-header">--- 583,11 ---</span>
  
                  node-&gt;remove(m_graph);
              }
          }
  
<span class="line-modified">!         if (verbose) {</span>
              dataLog(&quot;Graph after PutStack sinking:\n&quot;);
              m_graph.dump();
          }
  
          return true;
</pre>
<center><a href="DFGPureValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGRegisterBank.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
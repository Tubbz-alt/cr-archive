diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp b/modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp
@@ -104,15 +104,14 @@
     if (!request.url().protocolIsBlob())
         return { };
 
     // Create a new temporary blobURL in case this one gets revoked during the asynchronous navigation policy decision.
     URL temporaryBlobURL = BlobURL::createPublicURL(&m_frame.document()->securityOrigin());
-    auto sessionID = m_frame.document()->sessionID();
-    blobRegistry().registerBlobURL(sessionID, temporaryBlobURL, request.url());
+    blobRegistry().registerBlobURL(temporaryBlobURL, request.url());
     request.setURL(temporaryBlobURL);
-    return CompletionHandler<void()>([sessionID, temporaryBlobURL = WTFMove(temporaryBlobURL)] {
-        blobRegistry().unregisterBlobURL(sessionID, temporaryBlobURL);
+    return CompletionHandler<void()>([temporaryBlobURL = WTFMove(temporaryBlobURL)] {
+        blobRegistry().unregisterBlobURL(temporaryBlobURL);
     });
 }
 
 void PolicyChecker::checkNavigationPolicy(ResourceRequest&& request, const ResourceResponse& redirectResponse, DocumentLoader* loader, RefPtr<FormState>&& formState, NavigationPolicyDecisionFunction&& function, PolicyDecisionMode policyDecisionMode)
 {
@@ -158,14 +157,10 @@
         return;
     }
 
     loader->setLastCheckedRequest(ResourceRequest(request));
 
-    // Initial 'about:blank' load needs to happen synchronously so the policy check needs to be synchronous in this case.
-    if (!m_frame.loader().stateMachine().committedFirstRealDocumentLoad() && request.url().protocolIsAbout() && !substituteData.isValid())
-        policyDecisionMode = PolicyDecisionMode::Synchronous;
-
 #if USE(QUICK_LOOK)
     // Always allow QuickLook-generated URLs based on the protocol scheme.
     if (!request.isNull() && isQuickLookPreviewURL(request.url()))
         return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
 #endif
@@ -184,17 +179,16 @@
 
     m_frame.loader().clearProvisionalLoadForPolicyCheck();
 
     auto blobURLLifetimeExtension = policyDecisionMode == PolicyDecisionMode::Asynchronous ? extendBlobURLLifetimeIfNecessary(request) : CompletionHandlerCallingScope { };
 
+    bool isInitialEmptyDocumentLoad = !m_frame.loader().stateMachine().committedFirstRealDocumentLoad() && request.url().protocolIsAbout() && !substituteData.isValid();
     auto requestIdentifier = PolicyCheckIdentifier::create();
     m_delegateIsDecidingNavigationPolicy = true;
     String suggestedFilename = action.downloadAttribute().isEmpty() ? nullAtom() : action.downloadAttribute();
-    m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier,
-        [this, function = WTFMove(function), request = ResourceRequest(request), formState = WTFMove(formState), suggestedFilename = WTFMove(suggestedFilename),
+    FramePolicyFunction decisionHandler = [this, function = WTFMove(function), request = ResourceRequest(request), formState = WTFMove(formState), suggestedFilename = WTFMove(suggestedFilename),
          blobURLLifetimeExtension = WTFMove(blobURLLifetimeExtension), requestIdentifier] (PolicyAction policyAction, PolicyCheckIdentifier responseIdentifier) mutable {
-
         if (!responseIdentifier.isValidFor(requestIdentifier))
             return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
 
         m_delegateIsDecidingNavigationPolicy = false;
 
@@ -214,11 +208,18 @@
                 return function({ }, { }, NavigationPolicyDecision::IgnoreLoad);
             }
             return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
         }
         ASSERT_NOT_REACHED();
-    });
+    };
+
+    if (isInitialEmptyDocumentLoad) {
+        // We ignore the response from the client for initial empty document loads and proceed with the load synchronously.
+        m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier, [](PolicyAction, PolicyCheckIdentifier) { });
+        decisionHandler(PolicyAction::Use, requestIdentifier);
+    } else
+        m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier, WTFMove(decisionHandler));
 }
 
 void PolicyChecker::checkNewWindowPolicy(NavigationAction&& navigationAction, ResourceRequest&& request, RefPtr<FormState>&& formState, const String& frameName, NewWindowPolicyDecisionFunction&& function)
 {
     if (m_frame.document() && m_frame.document()->isSandboxed(SandboxPopups))

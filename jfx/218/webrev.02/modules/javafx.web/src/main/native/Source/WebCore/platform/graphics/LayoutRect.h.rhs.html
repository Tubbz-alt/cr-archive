<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/LayoutRect.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #pragma once
 32 
 33 #include &quot;FloatRect.h&quot;
 34 #include &quot;IntRect.h&quot;
 35 #include &quot;LayoutPoint.h&quot;
 36 #include &quot;LengthBox.h&quot;
 37 #include &lt;wtf/Forward.h&gt;
 38 
 39 namespace WTF {
 40 class TextStream;
 41 }
 42 
 43 namespace WebCore {
 44 
 45 class LayoutRect {
 46 public:
 47     LayoutRect() { }
 48     LayoutRect(const LayoutPoint&amp; location, const LayoutSize&amp; size)
 49         : m_location(location), m_size(size) { }
 50     template&lt;typename T1, typename T2, typename U1, typename U2&gt;
 51     LayoutRect(T1 x, T2 y, U1 width, U2 height)
 52         : m_location(LayoutPoint(x, y)), m_size(LayoutSize(width, height)) { }
 53     LayoutRect(const LayoutPoint&amp; topLeft, const LayoutPoint&amp; bottomRight)
 54         : m_location(topLeft), m_size(LayoutSize(bottomRight.x() - topLeft.x(), bottomRight.y() - topLeft.y())) { }
 55     LayoutRect(const FloatPoint&amp; location, const FloatSize&amp; size)
 56         : m_location(location), m_size(size) { }
 57     LayoutRect(const IntRect&amp; rect) : m_location(rect.location()), m_size(rect.size()) { }
 58 
 59     WEBCORE_EXPORT explicit LayoutRect(const FloatRect&amp;); // don&#39;t do this implicitly since it&#39;s lossy
 60 
<a name="1" id="anc1"></a><span class="line-added"> 61     template&lt;class Encoder&gt;</span>
<span class="line-added"> 62     void encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 63     {</span>
<span class="line-added"> 64         encoder &lt;&lt; m_location &lt;&lt; m_size;</span>
<span class="line-added"> 65     }</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67     template&lt;class Decoder&gt;</span>
<span class="line-added"> 68     static Optional&lt;LayoutRect&gt; decode(Decoder&amp; decoder)</span>
<span class="line-added"> 69     {</span>
<span class="line-added"> 70         Optional&lt;LayoutPoint&gt; layoutPoint;</span>
<span class="line-added"> 71         decoder &gt;&gt; layoutPoint;</span>
<span class="line-added"> 72         if (!layoutPoint)</span>
<span class="line-added"> 73             return WTF::nullopt;</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75         Optional&lt;LayoutSize&gt; layoutSize;</span>
<span class="line-added"> 76         decoder &gt;&gt; layoutSize;</span>
<span class="line-added"> 77         if (!layoutSize)</span>
<span class="line-added"> 78             return WTF::nullopt;</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80         return {{ *layoutPoint, *layoutSize }};</span>
<span class="line-added"> 81     }</span>
<span class="line-added"> 82 </span>
 83     LayoutPoint location() const { return m_location; }
 84     LayoutSize size() const { return m_size; }
 85 
 86     void setLocation(const LayoutPoint&amp; location) { m_location = location; }
 87     void setSize(const LayoutSize&amp; size) { m_size = size; }
 88 
 89     LayoutUnit x() const { return m_location.x(); }
 90     LayoutUnit y() const { return m_location.y(); }
 91     LayoutUnit maxX() const { return x() + width(); }
 92     LayoutUnit maxY() const { return y() + height(); }
 93     LayoutUnit width() const { return m_size.width(); }
 94     LayoutUnit height() const { return m_size.height(); }
 95 
 96     template&lt;typename T&gt; void setX(T x) { m_location.setX(x); }
 97     template&lt;typename T&gt; void setY(T y) { m_location.setY(y); }
 98     template&lt;typename T&gt; void setWidth(T width) { m_size.setWidth(width); }
 99     template&lt;typename T&gt; void setHeight(T height) { m_size.setHeight(height); }
100 
101     bool isEmpty() const { return m_size.isEmpty(); }
102 
103     // NOTE: The result is rounded to integer values, and thus may be not the exact
104     // center point.
105     LayoutPoint center() const { return LayoutPoint(x() + width() / 2, y() + height() / 2); }
106 
107     void move(const LayoutSize&amp; size) { m_location += size; }
108     void moveBy(const LayoutPoint&amp; offset) { m_location.move(offset.x(), offset.y()); }
109     template&lt;typename T, typename U&gt; void move(T dx, U dy) { m_location.move(dx, dy); }
110 
111     void expand(const LayoutSize&amp; size) { m_size += size; }
112     void expand(const LayoutBoxExtent&amp; box)
113     {
114         m_location.move(-box.left(), -box.top());
115         m_size.expand(box.left() + box.right(), box.top() + box.bottom());
116     }
117     template&lt;typename T, typename U&gt; void expand(T dw, U dh) { m_size.expand(dw, dh); }
118     void contract(const LayoutSize&amp; size) { m_size -= size; }
119     void contract(const LayoutBoxExtent&amp; box)
120     {
121         m_location.move(box.left(), box.top());
122         m_size.shrink(box.left() + box.right(), box.top() + box.bottom());
123     }
124     template&lt;typename T, typename U&gt; void contract(T dw, U dh) { m_size.expand(-dw, -dh); }
125 
126     void shiftXEdgeTo(LayoutUnit edge)
127     {
128         LayoutUnit delta = edge - x();
129         setX(edge);
130         setWidth(std::max&lt;LayoutUnit&gt;(0, width() - delta));
131     }
132     void shiftMaxXEdgeTo(LayoutUnit edge)
133     {
134         LayoutUnit delta = edge - maxX();
135         setWidth(std::max&lt;LayoutUnit&gt;(0, width() + delta));
136     }
137     void shiftYEdgeTo(LayoutUnit edge)
138     {
139         LayoutUnit delta = edge - y();
140         setY(edge);
141         setHeight(std::max&lt;LayoutUnit&gt;(0, height() - delta));
142     }
143     void shiftMaxYEdgeTo(LayoutUnit edge)
144     {
145         LayoutUnit delta = edge - maxY();
146         setHeight(std::max&lt;LayoutUnit&gt;(0, height() + delta));
147     }
148 
149     template&lt;typename T&gt; void shiftXEdgeTo(T edge) { shiftXEdgeTo(LayoutUnit(edge)); }
150     template&lt;typename T&gt; void shiftMaxXEdgeTo(T edge) { shiftMaxXEdgeTo(LayoutUnit(edge)); }
151     template&lt;typename T&gt; void shiftYEdgeTo(T edge) { shiftYEdgeTo(LayoutUnit(edge)); }
152     template&lt;typename T&gt; void shiftMaxYEdgeTo(T edge) { shiftMaxYEdgeTo(LayoutUnit(edge)); }
153 
154     LayoutPoint minXMinYCorner() const { return m_location; } // typically topLeft
155     LayoutPoint maxXMinYCorner() const { return LayoutPoint(m_location.x() + m_size.width(), m_location.y()); } // typically topRight
156     LayoutPoint minXMaxYCorner() const { return LayoutPoint(m_location.x(), m_location.y() + m_size.height()); } // typically bottomLeft
157     LayoutPoint maxXMaxYCorner() const { return LayoutPoint(m_location.x() + m_size.width(), m_location.y() + m_size.height()); } // typically bottomRight
158     bool isMaxXMaxYRepresentable() const
159     {
160         FloatRect rect = *this;
161         float maxX = rect.maxX();
162         float maxY = rect.maxY();
163         return maxX &gt; LayoutUnit::nearlyMin() &amp;&amp; maxX &lt; LayoutUnit::nearlyMax() &amp;&amp; maxY &gt; LayoutUnit::nearlyMin() &amp;&amp; maxY &lt; LayoutUnit::nearlyMax();
164     }
165 
166     bool intersects(const LayoutRect&amp;) const;
167     WEBCORE_EXPORT bool contains(const LayoutRect&amp;) const;
168 
169     // This checks to see if the rect contains x,y in the traditional sense.
170     // Equivalent to checking if the rect contains a 1x1 rect below and to the right of (px,py).
171     bool contains(LayoutUnit px, LayoutUnit py) const
172         { return px &gt;= x() &amp;&amp; px &lt; maxX() &amp;&amp; py &gt;= y() &amp;&amp; py &lt; maxY(); }
173     bool contains(const LayoutPoint&amp; point) const { return contains(point.x(), point.y()); }
174 
175     void intersect(const LayoutRect&amp;);
176     bool edgeInclusiveIntersect(const LayoutRect&amp;);
177     WEBCORE_EXPORT void unite(const LayoutRect&amp;);
178     void uniteIfNonZero(const LayoutRect&amp;);
179     bool checkedUnite(const LayoutRect&amp;);
180 
181     void inflateX(LayoutUnit dx)
182     {
183         m_location.setX(m_location.x() - dx);
184         m_size.setWidth(m_size.width() + dx + dx);
185     }
186     void inflateY(LayoutUnit dy)
187     {
188         m_location.setY(m_location.y() - dy);
189         m_size.setHeight(m_size.height() + dy + dy);
190     }
191     void inflate(LayoutSize size) { inflateX(size.width()); inflateY(size.height()); }
192     template&lt;typename T&gt; void inflateX(T dx) { inflateX(LayoutUnit(dx)); }
193     template&lt;typename T&gt; void inflateY(T dy) { inflateY(LayoutUnit(dy)); }
194     template&lt;typename T&gt; void inflate(T d) { inflateX(d); inflateY(d); }
195 
196     WEBCORE_EXPORT void scale(float);
197     void scale(float xScale, float yScale);
198 
199     LayoutRect transposedRect() const { return LayoutRect(m_location.transposedPoint(), m_size.transposedSize()); }
200     bool isInfinite() const;
201 
202     static LayoutRect infiniteRect()
203     {
204         // Return a rect that is slightly smaller than the true max rect to allow pixelSnapping to round up to the nearest IntRect without overflowing.
205         return LayoutRect(LayoutUnit::nearlyMin() / 2, LayoutUnit::nearlyMin() / 2, LayoutUnit::nearlyMax(), LayoutUnit::nearlyMax());
206     }
207 
208     operator FloatRect() const { return FloatRect(m_location, m_size); }
209 
210 private:
211     LayoutPoint m_location;
212     LayoutSize m_size;
213 };
214 
215 inline LayoutRect intersection(const LayoutRect&amp; a, const LayoutRect&amp; b)
216 {
217     LayoutRect c = a;
218     c.intersect(b);
219     return c;
220 }
221 
222 inline LayoutRect unionRect(const LayoutRect&amp; a, const LayoutRect&amp; b)
223 {
224     LayoutRect c = a;
225     c.unite(b);
226     return c;
227 }
228 
229 LayoutRect unionRect(const Vector&lt;LayoutRect&gt;&amp;);
230 
231 inline bool operator==(const LayoutRect&amp; a, const LayoutRect&amp; b)
232 {
233     return a.location() == b.location() &amp;&amp; a.size() == b.size();
234 }
235 
236 inline bool operator!=(const LayoutRect&amp; a, const LayoutRect&amp; b)
237 {
238     return a.location() != b.location() || a.size() != b.size();
239 }
240 
241 inline bool LayoutRect::isInfinite() const
242 {
243     return *this == LayoutRect::infiniteRect();
244 }
245 
246 // Integral snapping functions.
247 inline IntRect snappedIntRect(const LayoutRect&amp; rect)
248 {
249     return IntRect(roundedIntPoint(rect.location()), snappedIntSize(rect.size(), rect.location()));
250 }
251 
252 inline IntRect snappedIntRect(LayoutUnit left, LayoutUnit top, LayoutUnit width, LayoutUnit height)
253 {
254     return IntRect(IntPoint(left.round(), top.round()), snappedIntSize(LayoutSize(width, height), LayoutPoint(left, top)));
255 }
256 
257 inline IntRect snappedIntRect(LayoutPoint location, LayoutSize size)
258 {
259     return IntRect(roundedIntPoint(location), snappedIntSize(size, location));
260 }
261 
262 WEBCORE_EXPORT IntRect enclosingIntRect(const LayoutRect&amp;);
263 WEBCORE_EXPORT LayoutRect enclosingLayoutRect(const FloatRect&amp;);
264 
265 // Device pixel snapping functions.
266 inline FloatRect snapRectToDevicePixels(const LayoutRect&amp; rect, float pixelSnappingFactor)
267 {
268     return FloatRect(FloatPoint(roundToDevicePixel(rect.x(), pixelSnappingFactor), roundToDevicePixel(rect.y(), pixelSnappingFactor)), snapSizeToDevicePixel(rect.size(), rect.location(), pixelSnappingFactor));
269 }
270 
271 inline FloatRect snapRectToDevicePixels(LayoutUnit x, LayoutUnit y, LayoutUnit width, LayoutUnit height, float pixelSnappingFactor)
272 {
273     return snapRectToDevicePixels(LayoutRect(x, y, width, height), pixelSnappingFactor);
274 }
275 
276 // FIXME: This needs to take vertical centering into account too.
277 inline FloatRect snapRectToDevicePixelsWithWritingDirection(const LayoutRect&amp; rect, float deviceScaleFactor, bool ltr)
278 {
279     if (!ltr) {
280         FloatPoint snappedTopRight = roundPointToDevicePixels(rect.maxXMinYCorner(), deviceScaleFactor, ltr);
281         FloatSize snappedSize = snapSizeToDevicePixel(rect.size(), rect.maxXMinYCorner(), deviceScaleFactor);
282         return FloatRect(snappedTopRight.x() - snappedSize.width(), snappedTopRight.y(), snappedSize.width(), snappedSize.height());
283     }
284     return snapRectToDevicePixels(rect, deviceScaleFactor);
285 }
286 
287 FloatRect encloseRectToDevicePixels(const LayoutRect&amp;, float pixelSnappingFactor);
288 
289 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const LayoutRect&amp;);
290 
291 } // namespace WebCore
292 
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
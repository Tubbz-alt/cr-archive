diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -50,33 +50,33 @@
         void* passedPointer, const Func& func)
     {
         const HashSet<MarkedBlock*>& set = heap.objectSpace().blocks().set();
 
         ASSERT(heap.objectSpace().isMarking());
-        static const bool isMarking = true;
+        static constexpr bool isMarking = true;
 
         char* pointer = static_cast<char*>(passedPointer);
 
         // It could point to a large allocation.
-        if (heap.objectSpace().largeAllocationsForThisCollectionSize()) {
-            if (heap.objectSpace().largeAllocationsForThisCollectionBegin()[0]->aboveLowerBound(pointer)
-                && heap.objectSpace().largeAllocationsForThisCollectionEnd()[-1]->belowUpperBound(pointer)) {
-                LargeAllocation** result = approximateBinarySearch<LargeAllocation*>(
-                    heap.objectSpace().largeAllocationsForThisCollectionBegin(),
-                    heap.objectSpace().largeAllocationsForThisCollectionSize(),
-                    LargeAllocation::fromCell(pointer),
-                    [] (LargeAllocation** ptr) -> LargeAllocation* { return *ptr; });
+        if (heap.objectSpace().preciseAllocationsForThisCollectionSize()) {
+            if (heap.objectSpace().preciseAllocationsForThisCollectionBegin()[0]->aboveLowerBound(pointer)
+                && heap.objectSpace().preciseAllocationsForThisCollectionEnd()[-1]->belowUpperBound(pointer)) {
+                PreciseAllocation** result = approximateBinarySearch<PreciseAllocation*>(
+                    heap.objectSpace().preciseAllocationsForThisCollectionBegin(),
+                    heap.objectSpace().preciseAllocationsForThisCollectionSize(),
+                    PreciseAllocation::fromCell(pointer),
+                    [] (PreciseAllocation** ptr) -> PreciseAllocation* { return *ptr; });
                 if (result) {
-                    auto attemptLarge = [&] (LargeAllocation* allocation) {
-                        if (allocation->contains(pointer))
+                    auto attemptLarge = [&] (PreciseAllocation* allocation) {
+                        if (allocation->contains(pointer) && allocation->hasValidCell())
                             func(allocation->cell(), allocation->attributes().cellKind);
                     };
 
-                    if (result > heap.objectSpace().largeAllocationsForThisCollectionBegin())
+                    if (result > heap.objectSpace().preciseAllocationsForThisCollectionBegin())
                         attemptLarge(result[-1]);
                     attemptLarge(result[0]);
-                    if (result + 1 < heap.objectSpace().largeAllocationsForThisCollectionEnd())
+                    if (result + 1 < heap.objectSpace().preciseAllocationsForThisCollectionEnd())
                         attemptLarge(result[1]);
                 }
             }
         }
 
@@ -121,41 +121,24 @@
         char* alignedPointer = static_cast<char*>(candidate->handle().cellAlign(pointer));
         tryPointer(alignedPointer);
 
         // Also, a butterfly could point at the end of an object plus sizeof(IndexingHeader). In that
         // case, this is pointing to the object to the right of the one we should be marking.
-        if (candidate->atomNumber(alignedPointer) > 0
+        if (candidate->candidateAtomNumber(alignedPointer) > 0
             && pointer <= alignedPointer + sizeof(IndexingHeader))
             tryPointer(alignedPointer - candidate->cellSize());
     }
 
-    static bool isPointerGCObjectJSCell(
-        Heap& heap, TinyBloomFilter filter, const void* pointer)
+    static bool isPointerGCObjectJSCell(Heap& heap, TinyBloomFilter filter, JSCell* pointer)
     {
         // It could point to a large allocation.
-        const Vector<LargeAllocation*>& largeAllocations = heap.objectSpace().largeAllocations();
-        if (!largeAllocations.isEmpty()) {
-            if (largeAllocations[0]->aboveLowerBound(pointer)
-                && largeAllocations.last()->belowUpperBound(pointer)) {
-                LargeAllocation*const* result = approximateBinarySearch<LargeAllocation*const>(
-                    largeAllocations.begin(), largeAllocations.size(),
-                    LargeAllocation::fromCell(pointer),
-                    [] (LargeAllocation*const* ptr) -> LargeAllocation* { return *ptr; });
-                if (result) {
-                    if (result > largeAllocations.begin()
-                        && result[-1]->cell() == pointer
-                        && isJSCellKind(result[-1]->attributes().cellKind))
-                        return true;
-                    if (result[0]->cell() == pointer
-                        && isJSCellKind(result[0]->attributes().cellKind))
-                        return true;
-                    if (result + 1 < largeAllocations.end()
-                        && result[1]->cell() == pointer
-                        && isJSCellKind(result[1]->attributes().cellKind))
-                        return true;
-                }
-            }
+        if (pointer->isPreciseAllocation()) {
+            auto* set = heap.objectSpace().preciseAllocationSet();
+            ASSERT(set);
+            if (set->isEmpty())
+                return false;
+            return set->contains(pointer);
         }
 
         const HashSet<MarkedBlock*>& set = heap.objectSpace().blocks().set();
 
         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
@@ -177,16 +160,18 @@
             return false;
 
         return true;
     }
 
+    // This does not find the cell if the pointer is pointing at the middle of a JSCell.
     static bool isValueGCObject(
         Heap& heap, TinyBloomFilter filter, JSValue value)
     {
+        ASSERT(heap.objectSpace().preciseAllocationSet());
         if (!value.isCell())
             return false;
-        return isPointerGCObjectJSCell(heap, filter, static_cast<void*>(value.asCell()));
+        return isPointerGCObjectJSCell(heap, filter, value.asCell());
     }
 };
 
 } // namespace JSC
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/text/TextStream.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2008 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Forward.h&gt;
 29 #include &lt;wtf/Markable.h&gt;
 30 #include &lt;wtf/Optional.h&gt;
 31 #include &lt;wtf/text/StringBuilder.h&gt;
 32 
 33 namespace WTF {
 34 
 35 class TextStream {
 36     WTF_MAKE_FAST_ALLOCATED;
 37 public:
 38     struct FormatNumberRespectingIntegers {
 39         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 40         FormatNumberRespectingIntegers(double number)
 41             : value(number) { }
 42 
 43         double value;
 44     };
 45 
 46     enum Formatting {
 47         SVGStyleRect                = 1 &lt;&lt; 0, // &quot;at (0,0) size 10x10&quot;
 48         NumberRespectingIntegers    = 1 &lt;&lt; 1,
 49         LayoutUnitsAsIntegers       = 1 &lt;&lt; 2,
 50     };
 51 
 52     using FormattingFlags = unsigned;
 53 
 54     enum class LineMode { SingleLine, MultipleLine };
 55     TextStream(LineMode lineMode = LineMode::MultipleLine, FormattingFlags formattingFlags = 0)
 56         : m_formattingFlags(formattingFlags)
 57         , m_multiLineMode(lineMode == LineMode::MultipleLine)
 58     {
 59     }
 60 
 61     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(bool);
 62     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(char);
 63     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(int);
 64     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(unsigned);
 65     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(long);
 66     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(unsigned long);
 67     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(long long);
 68 
 69     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(unsigned long long);
 70     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(float);
 71     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(double);
 72     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(const char*);
 73     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(const void*);
 74     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(const String&amp;);
 75     // Deprecated. Use the NumberRespectingIntegers FormattingFlag instead.
 76     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(const FormatNumberRespectingIntegers&amp;);
 77 
 78 #ifdef __OBJC__
 79     WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(id&lt;NSObject&gt;);
 80 #endif
 81 
 82     FormattingFlags formattingFlags() const { return m_formattingFlags; }
 83     void setFormattingFlags(FormattingFlags flags) { m_formattingFlags = flags; }
 84 
 85     bool hasFormattingFlag(Formatting flag) const { return m_formattingFlags &amp; flag; }
 86 
 87     template&lt;typename T&gt;
 88     void dumpProperty(const String&amp; name, const T&amp; value)
 89     {
 90         TextStream&amp; ts = *this;
 91         ts.startGroup();
 92         ts &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; value;
 93         ts.endGroup();
 94     }
 95 
 96     WTF_EXPORT_PRIVATE String release();
 97 
 98     WTF_EXPORT_PRIVATE void startGroup();
 99     WTF_EXPORT_PRIVATE void endGroup();
100     WTF_EXPORT_PRIVATE void nextLine(); // Output newline and indent.
101 
102     int indent() const { return m_indent; }
103     void setIndent(int indent) { m_indent = indent; }
104     void increaseIndent(int amount = 1) { m_indent += amount; }
105     void decreaseIndent(int amount = 1) { m_indent -= amount; ASSERT(m_indent &gt;= 0); }
106 
107     WTF_EXPORT_PRIVATE void writeIndent();
108 
109     // Stream manipulators.
110     TextStream&amp; operator&lt;&lt;(TextStream&amp; (*func)(TextStream&amp;))
111     {
112         return (*func)(*this);
113     }
114 
115     struct Repeat {
116         WTF_MAKE_STRUCT_FAST_ALLOCATED;
117         Repeat(unsigned inWidth, char inCharacter)
118             : width(inWidth), character(inCharacter)
119         { }
120         unsigned width { 0 };
121         char character { &#39; &#39; };
122     };
123 
124     TextStream&amp; operator&lt;&lt;(const Repeat&amp; repeated)
125     {
126         for (unsigned i = 0; i &lt; repeated.width; ++i)
127             m_text.append(repeated.character);
128 
129         return *this;
130     }
131 
132     class IndentScope {
133     public:
134         IndentScope(TextStream&amp; ts, int amount = 1)
135             : m_stream(ts)
136             , m_amount(amount)
137         {
138             m_stream.increaseIndent(m_amount);
139         }
140         ~IndentScope()
141         {
142             m_stream.decreaseIndent(m_amount);
143         }
144 
145     private:
146         TextStream&amp; m_stream;
147         int m_amount;
148     };
149 
150     class GroupScope {
151     public:
152         GroupScope(TextStream&amp; ts)
153             : m_stream(ts)
154         {
155             m_stream.startGroup();
156         }
157         ~GroupScope()
158         {
159             m_stream.endGroup();
160         }
161 
162     private:
163         TextStream&amp; m_stream;
164     };
165 
166 private:
167     StringBuilder m_text;
168     FormattingFlags m_formattingFlags { 0 };
169     int m_indent { 0 };
170     bool m_multiLineMode { true };
171 };
172 
173 inline TextStream&amp; indent(TextStream&amp; ts)
174 {
175     ts.writeIndent();
176     return ts;
177 }
178 
179 template&lt;typename Item&gt;
180 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Optional&lt;Item&gt;&amp; item)
181 {
182     if (item)
183         return ts &lt;&lt; item.value();
184 
185     return ts &lt;&lt; &quot;nullopt&quot;;
186 }
187 
188 template&lt;typename T, typename Traits&gt;
189 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Markable&lt;T, Traits&gt;&amp; item)
190 {
191     if (item)
192         return ts &lt;&lt; item.value();
193 
194     return ts &lt;&lt; &quot;unset&quot;;
195 }
196 
197 template&lt;typename Item&gt;
198 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Vector&lt;Item&gt;&amp; vector)
199 {
200     ts &lt;&lt; &quot;[&quot;;
201 
202     unsigned size = vector.size();
203     for (unsigned i = 0; i &lt; size; ++i) {
204         ts &lt;&lt; vector[i];
205         if (i &lt; size - 1)
206             ts &lt;&lt; &quot;, &quot;;
207     }
208 
209     return ts &lt;&lt; &quot;]&quot;;
210 }
211 
212 template&lt;typename KeyArg, typename MappedArg, typename HashArg, typename KeyTraitsArg, typename MappedTraitsArg&gt;
213 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const HashMap&lt;KeyArg, MappedArg, HashArg, KeyTraitsArg, MappedTraitsArg&gt;&amp; map)
214 {
215     ts &lt;&lt; &quot;{&quot;;
216 
217     bool first = true;
218     for (const auto&amp; keyValuePair : map) {
219         ts &lt;&lt; keyValuePair.key &lt;&lt; &quot;: &quot; &lt;&lt; keyValuePair.value;
220         if (!first)
221             ts &lt;&lt; &quot;, &quot;;
222         first = false;
223     }
224 
225     return ts &lt;&lt; &quot;}&quot;;
226 }
227 
228 template&lt;typename ValueArg, typename HashArg, typename TraitsArg&gt;
229 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const HashSet&lt;ValueArg, HashArg, TraitsArg&gt;&amp; set)
230 {
231     ts &lt;&lt; &quot;[&quot;;
232 
233     bool first = true;
234     for (const auto&amp; item : set) {
235         ts &lt;&lt; item;
236         if (!first)
237             ts &lt;&lt; &quot;, &quot;;
238         first = false;
239     }
240 
241     return ts &lt;&lt; &quot;]&quot;;
242 }
243 
244 template&lt;typename Option&gt;
245 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const OptionSet&lt;Option&gt;&amp; options)
246 {
247     ts &lt;&lt; &quot;[&quot;;
248     bool needComma = false;
249     for (auto option : options) {
250         if (needComma)
251             ts &lt;&lt; &quot;, &quot;;
252         needComma = true;
253         ts &lt;&lt; option;
254     }
255     return ts &lt;&lt; &quot;]&quot;;
256 }
257 
258 // Deprecated. Use TextStream::writeIndent() instead.
259 WTF_EXPORT_PRIVATE void writeIndent(TextStream&amp;, int indent);
260 
261 } // namespace WTF
262 
263 using WTF::TextStream;
264 using WTF::indent;
    </pre>
  </body>
</html>
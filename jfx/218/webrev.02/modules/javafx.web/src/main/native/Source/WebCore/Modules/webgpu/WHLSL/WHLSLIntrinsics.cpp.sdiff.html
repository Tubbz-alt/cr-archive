<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLIntrinsics.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLInferTypes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLIntrinsics.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLIntrinsics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
186 {
187     if (nativeTypeDeclaration.name() != &quot;matrix&quot;)
188         return false;
189 
190     nativeTypeDeclaration.setIsMatrix();
191 
192     ASSERT(nativeTypeDeclaration.typeArguments().size() == 3);
193     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));
194     ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
195     ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[2]));
196     return true;
197 }
198 
199 bool Intrinsics::addFullTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)
200 {
201     auto textureTypeIndex = std::find(m_textureTypeNames, m_textureTypeNames + WTF_ARRAY_LENGTH(m_textureTypeNames), nativeTypeDeclaration.name()) - m_textureTypeNames;
202     if (textureTypeIndex == WTF_ARRAY_LENGTH(m_textureTypeNames))
203         return false;
204 
205     unsigned innerTypeIndex = WTF_ARRAY_LENGTH(m_textureInnerTypeNames);
<span class="line-modified">206     unsigned vectorLength;</span>
207     for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(m_textureInnerTypeNames); ++i) {
208         if (innerType.name().startsWith(m_textureInnerTypeNames[i])) {
209             innerTypeIndex = i;
210             if (innerType.name() == m_textureInnerTypeNames[i])
211                 vectorLength = 1;
212             else {
<span class="line-modified">213                 ASSERT(innerType.name().length() == strlen(m_textureInnerTypeNames[i]) + 1);</span>
<span class="line-modified">214                 ASSERT(innerType.name()[innerType.name().length() - 1] == &#39;2&#39;</span>
215                     || innerType.name()[innerType.name().length() - 1] == &#39;3&#39;
216                     || innerType.name()[innerType.name().length() - 1] == &#39;4&#39;);
217                 vectorLength = innerType.name()[innerType.name().length() - 1] - &#39;0&#39;;
218             }
219         }
220     }
<span class="line-modified">221     ASSERT(innerTypeIndex != WTF_ARRAY_LENGTH(m_textureInnerTypeNames));</span>

222     nativeTypeDeclaration.setIsTexture();
223     nativeTypeDeclaration.setIsOpaqueType();
224     if (nativeTypeDeclaration.name() == &quot;Texture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot; || nativeTypeDeclaration.name() == &quot;Texture2DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)
225         nativeTypeDeclaration.setIsTextureArray();
226     if (nativeTypeDeclaration.name() == &quot;RWTexture1D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture3D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)
227         nativeTypeDeclaration.setIsWritableTexture();
228     if (nativeTypeDeclaration.name() == &quot;Texture1D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1D&quot; || nativeTypeDeclaration.name() == &quot;Texture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot;)
229         nativeTypeDeclaration.setTextureDimension(1);
230     if (nativeTypeDeclaration.name() == &quot;Texture2D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2D&quot; || nativeTypeDeclaration.name() == &quot;TextureCube&quot; || nativeTypeDeclaration.name() == &quot;Texture2DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)
231         nativeTypeDeclaration.setTextureDimension(2);
232     if (nativeTypeDeclaration.name() == &quot;Texture3D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture3D&quot;)
233         nativeTypeDeclaration.setTextureDimension(3);


234     m_fullTextures[textureTypeIndex][innerTypeIndex][vectorLength - 1] = &amp;nativeTypeDeclaration;
235     return true;
236 }
237 
238 void Intrinsics::addDepthTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)
239 {
240     AST::NativeTypeDeclaration** texture = nullptr;
241     if (nativeTypeDeclaration.name() == &quot;TextureDepth2D&quot;)
242         texture = m_textureDepth2D;
243     else if (nativeTypeDeclaration.name() == &quot;TextureDepth2DArray&quot;)
244         texture = m_textureDepth2DArray;
245     else {
246         ASSERT(nativeTypeDeclaration.name() == &quot;TextureDepthCube&quot;);
247         texture = m_textureDepthCube;
248     }
249     auto innerTypeIndex = std::find(m_depthTextureInnerTypes, m_depthTextureInnerTypes + WTF_ARRAY_LENGTH(m_depthTextureInnerTypes), innerType.name()) - m_depthTextureInnerTypes;
250     ASSERT(innerTypeIndex != WTF_ARRAY_LENGTH(m_depthTextureInnerTypes));
251     nativeTypeDeclaration.setIsTexture();
252     nativeTypeDeclaration.setIsOpaqueType();
253     if (texture == m_textureDepth2DArray)
254         nativeTypeDeclaration.setIsTextureArray();


255     nativeTypeDeclaration.setTextureDimension(2);
256     nativeTypeDeclaration.setIsDepthTexture();
257     texture[innerTypeIndex] = &amp;nativeTypeDeclaration;
258 }
259 
260 void Intrinsics::addTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
261 {
262     ASSERT(nativeTypeDeclaration.typeArguments().size() == 1);
263     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));
264     auto&amp; innerType = static_cast&lt;AST::TypeReference&amp;&gt;(WTF::get&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));
265     ASSERT(!innerType.typeArguments().size());
266     if (addFullTexture(nativeTypeDeclaration, innerType)) {
267         m_textureSet.add(&amp;nativeTypeDeclaration);
268         return;
269     }
270     addDepthTexture(nativeTypeDeclaration, innerType);
271     m_textureSet.add(&amp;nativeTypeDeclaration);
272 }
273 
274 void Intrinsics::add(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
</pre>
</td>
<td>
<hr />
<pre>
186 {
187     if (nativeTypeDeclaration.name() != &quot;matrix&quot;)
188         return false;
189 
190     nativeTypeDeclaration.setIsMatrix();
191 
192     ASSERT(nativeTypeDeclaration.typeArguments().size() == 3);
193     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));
194     ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
195     ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[2]));
196     return true;
197 }
198 
199 bool Intrinsics::addFullTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)
200 {
201     auto textureTypeIndex = std::find(m_textureTypeNames, m_textureTypeNames + WTF_ARRAY_LENGTH(m_textureTypeNames), nativeTypeDeclaration.name()) - m_textureTypeNames;
202     if (textureTypeIndex == WTF_ARRAY_LENGTH(m_textureTypeNames))
203         return false;
204 
205     unsigned innerTypeIndex = WTF_ARRAY_LENGTH(m_textureInnerTypeNames);
<span class="line-modified">206     unsigned vectorLength = 0;</span>
207     for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(m_textureInnerTypeNames); ++i) {
208         if (innerType.name().startsWith(m_textureInnerTypeNames[i])) {
209             innerTypeIndex = i;
210             if (innerType.name() == m_textureInnerTypeNames[i])
211                 vectorLength = 1;
212             else {
<span class="line-modified">213                 ASSERT_WITH_SECURITY_IMPLICATION(innerType.name().length() == strlen(m_textureInnerTypeNames[i]) + 1);</span>
<span class="line-modified">214                 ASSERT_WITH_SECURITY_IMPLICATION(innerType.name()[innerType.name().length() - 1] == &#39;2&#39;</span>
215                     || innerType.name()[innerType.name().length() - 1] == &#39;3&#39;
216                     || innerType.name()[innerType.name().length() - 1] == &#39;4&#39;);
217                 vectorLength = innerType.name()[innerType.name().length() - 1] - &#39;0&#39;;
218             }
219         }
220     }
<span class="line-modified">221     RELEASE_ASSERT(vectorLength &amp;&amp; vectorLength &lt; 5);</span>
<span class="line-added">222     ASSERT_WITH_SECURITY_IMPLICATION(innerTypeIndex != WTF_ARRAY_LENGTH(m_textureInnerTypeNames));</span>
223     nativeTypeDeclaration.setIsTexture();
224     nativeTypeDeclaration.setIsOpaqueType();
225     if (nativeTypeDeclaration.name() == &quot;Texture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot; || nativeTypeDeclaration.name() == &quot;Texture2DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)
226         nativeTypeDeclaration.setIsTextureArray();
227     if (nativeTypeDeclaration.name() == &quot;RWTexture1D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture3D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)
228         nativeTypeDeclaration.setIsWritableTexture();
229     if (nativeTypeDeclaration.name() == &quot;Texture1D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1D&quot; || nativeTypeDeclaration.name() == &quot;Texture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot;)
230         nativeTypeDeclaration.setTextureDimension(1);
231     if (nativeTypeDeclaration.name() == &quot;Texture2D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2D&quot; || nativeTypeDeclaration.name() == &quot;TextureCube&quot; || nativeTypeDeclaration.name() == &quot;Texture2DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)
232         nativeTypeDeclaration.setTextureDimension(2);
233     if (nativeTypeDeclaration.name() == &quot;Texture3D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture3D&quot;)
234         nativeTypeDeclaration.setTextureDimension(3);
<span class="line-added">235     if (nativeTypeDeclaration.name() == &quot;TextureCube&quot;)</span>
<span class="line-added">236         nativeTypeDeclaration.setIsCubeTexture();</span>
237     m_fullTextures[textureTypeIndex][innerTypeIndex][vectorLength - 1] = &amp;nativeTypeDeclaration;
238     return true;
239 }
240 
241 void Intrinsics::addDepthTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)
242 {
243     AST::NativeTypeDeclaration** texture = nullptr;
244     if (nativeTypeDeclaration.name() == &quot;TextureDepth2D&quot;)
245         texture = m_textureDepth2D;
246     else if (nativeTypeDeclaration.name() == &quot;TextureDepth2DArray&quot;)
247         texture = m_textureDepth2DArray;
248     else {
249         ASSERT(nativeTypeDeclaration.name() == &quot;TextureDepthCube&quot;);
250         texture = m_textureDepthCube;
251     }
252     auto innerTypeIndex = std::find(m_depthTextureInnerTypes, m_depthTextureInnerTypes + WTF_ARRAY_LENGTH(m_depthTextureInnerTypes), innerType.name()) - m_depthTextureInnerTypes;
253     ASSERT(innerTypeIndex != WTF_ARRAY_LENGTH(m_depthTextureInnerTypes));
254     nativeTypeDeclaration.setIsTexture();
255     nativeTypeDeclaration.setIsOpaqueType();
256     if (texture == m_textureDepth2DArray)
257         nativeTypeDeclaration.setIsTextureArray();
<span class="line-added">258     if (texture == m_textureDepthCube)</span>
<span class="line-added">259         nativeTypeDeclaration.setIsCubeTexture();</span>
260     nativeTypeDeclaration.setTextureDimension(2);
261     nativeTypeDeclaration.setIsDepthTexture();
262     texture[innerTypeIndex] = &amp;nativeTypeDeclaration;
263 }
264 
265 void Intrinsics::addTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
266 {
267     ASSERT(nativeTypeDeclaration.typeArguments().size() == 1);
268     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));
269     auto&amp; innerType = static_cast&lt;AST::TypeReference&amp;&gt;(WTF::get&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));
270     ASSERT(!innerType.typeArguments().size());
271     if (addFullTexture(nativeTypeDeclaration, innerType)) {
272         m_textureSet.add(&amp;nativeTypeDeclaration);
273         return;
274     }
275     addDepthTexture(nativeTypeDeclaration, innerType);
276     m_textureSet.add(&amp;nativeTypeDeclaration);
277 }
278 
279 void Intrinsics::add(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLInferTypes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLIntrinsics.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DisplayListItems.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListRecorder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45 }
 46 
 47 Recorder::~Recorder()
 48 {
 49     ASSERT(m_stateStack.size() == 1); // If this fires, it indicates mismatched save/restore.
 50     LOG(DisplayLists, &quot;Recorded display list:\n%s&quot;, m_displayList.description().data());
 51 }
 52 
 53 void Recorder::willAppendItem(const Item&amp; item)
 54 {
 55     if (item.isDrawingItem()
 56 #if USE(CG)
 57         || item.type() == ItemType::ApplyStrokePattern || item.type() == ItemType::ApplyStrokePattern
 58 #endif
 59     ) {
 60         GraphicsContextStateChange&amp; stateChanges = currentState().stateChange;
 61         GraphicsContextState::StateChangeFlags changesFromLastState = stateChanges.changesFromState(currentState().lastDrawingState);
 62         if (changesFromLastState) {
 63             LOG_WITH_STREAM(DisplayLists, stream &lt;&lt; &quot;pre-drawing, saving state &quot; &lt;&lt; GraphicsContextStateChange(stateChanges.m_state, changesFromLastState));
 64             m_displayList.append(SetState::create(stateChanges.m_state, changesFromLastState));
<span class="line-modified"> 65             stateChanges.m_changeFlags = 0;</span>
 66             currentState().lastDrawingState = stateChanges.m_state;
 67         }
 68         currentState().wasUsedForDrawing = true;
 69     }
 70 }
 71 
 72 void Recorder::updateState(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 73 {
 74     currentState().stateChange.accumulate(state, flags);
 75 }
 76 
 77 void Recorder::clearShadow()
 78 {
 79     appendItem(ClearShadow::create());
 80 }
 81 
 82 void Recorder::setLineCap(LineCap lineCap)
 83 {
 84     appendItem(SetLineCap::create(lineCap));
 85 }
</pre>
<hr />
<pre>
179 }
180 
181 void Recorder::rotate(float angleInRadians)
182 {
183     currentState().rotate(angleInRadians);
184     appendItem(Rotate::create(angleInRadians));
185 }
186 
187 void Recorder::scale(const FloatSize&amp; size)
188 {
189     currentState().scale(size);
190     appendItem(Scale::create(size));
191 }
192 
193 void Recorder::concatCTM(const AffineTransform&amp; transform)
194 {
195     currentState().concatCTM(transform);
196     appendItem(ConcatenateCTM::create(transform));
197 }
198 
<span class="line-modified">199 void Recorder::setCTM(const AffineTransform&amp;)</span>
200 {
<span class="line-modified">201     WTFLogAlways(&quot;GraphicsContext::setCTM() is not compatible with DisplayList::Recorder.&quot;);</span>

202 }
203 
204 AffineTransform Recorder::getCTM(GraphicsContext::IncludeDeviceScale)
205 {
<span class="line-modified">206     WTFLogAlways(&quot;GraphicsContext::getCTM() is not yet compatible with DisplayList::Recorder.&quot;);</span>
<span class="line-modified">207     return { };</span>
208 }
209 
210 void Recorder::beginTransparencyLayer(float opacity)
211 {
212     DrawingItem&amp; newItem = downcast&lt;DrawingItem&gt;(appendItem(BeginTransparencyLayer::create(opacity)));
213     updateItemExtent(newItem);
214 }
215 
216 void Recorder::endTransparencyLayer()
217 {
218     appendItem(EndTransparencyLayer::create());
219 }
220 
221 void Recorder::drawRect(const FloatRect&amp; rect, float borderThickness)
222 {
223     DrawingItem&amp; newItem = downcast&lt;DrawingItem&gt;(appendItem(DrawRect::create(rect, borderThickness)));
224     updateItemExtent(newItem);
225 }
226 
227 void Recorder::drawLine(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
</pre>
<hr />
<pre>
466 }
467 
468 void Recorder::ContextState::rotate(float angleInRadians)
469 {
470     double angleInDegrees = rad2deg(static_cast&lt;double&gt;(angleInRadians));
471     ctm.rotate(angleInDegrees);
472 
473     AffineTransform rotation;
474     rotation.rotate(angleInDegrees);
475 
476     if (Optional&lt;AffineTransform&gt; inverse = rotation.inverse())
477         clipBounds = inverse.value().mapRect(clipBounds);
478 }
479 
480 void Recorder::ContextState::scale(const FloatSize&amp; size)
481 {
482     ctm.scale(size);
483     clipBounds.scale(1 / size.width(), 1 / size.height());
484 }
485 












486 void Recorder::ContextState::concatCTM(const AffineTransform&amp; matrix)
487 {
488     ctm *= matrix;
489 
490     if (Optional&lt;AffineTransform&gt; inverse = matrix.inverse())
491         clipBounds = inverse.value().mapRect(clipBounds);
492 }
493 
494 } // namespace DisplayList
495 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 45 }
 46 
 47 Recorder::~Recorder()
 48 {
 49     ASSERT(m_stateStack.size() == 1); // If this fires, it indicates mismatched save/restore.
 50     LOG(DisplayLists, &quot;Recorded display list:\n%s&quot;, m_displayList.description().data());
 51 }
 52 
 53 void Recorder::willAppendItem(const Item&amp; item)
 54 {
 55     if (item.isDrawingItem()
 56 #if USE(CG)
 57         || item.type() == ItemType::ApplyStrokePattern || item.type() == ItemType::ApplyStrokePattern
 58 #endif
 59     ) {
 60         GraphicsContextStateChange&amp; stateChanges = currentState().stateChange;
 61         GraphicsContextState::StateChangeFlags changesFromLastState = stateChanges.changesFromState(currentState().lastDrawingState);
 62         if (changesFromLastState) {
 63             LOG_WITH_STREAM(DisplayLists, stream &lt;&lt; &quot;pre-drawing, saving state &quot; &lt;&lt; GraphicsContextStateChange(stateChanges.m_state, changesFromLastState));
 64             m_displayList.append(SetState::create(stateChanges.m_state, changesFromLastState));
<span class="line-modified"> 65             stateChanges.m_changeFlags = { };</span>
 66             currentState().lastDrawingState = stateChanges.m_state;
 67         }
 68         currentState().wasUsedForDrawing = true;
 69     }
 70 }
 71 
 72 void Recorder::updateState(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 73 {
 74     currentState().stateChange.accumulate(state, flags);
 75 }
 76 
 77 void Recorder::clearShadow()
 78 {
 79     appendItem(ClearShadow::create());
 80 }
 81 
 82 void Recorder::setLineCap(LineCap lineCap)
 83 {
 84     appendItem(SetLineCap::create(lineCap));
 85 }
</pre>
<hr />
<pre>
179 }
180 
181 void Recorder::rotate(float angleInRadians)
182 {
183     currentState().rotate(angleInRadians);
184     appendItem(Rotate::create(angleInRadians));
185 }
186 
187 void Recorder::scale(const FloatSize&amp; size)
188 {
189     currentState().scale(size);
190     appendItem(Scale::create(size));
191 }
192 
193 void Recorder::concatCTM(const AffineTransform&amp; transform)
194 {
195     currentState().concatCTM(transform);
196     appendItem(ConcatenateCTM::create(transform));
197 }
198 
<span class="line-modified">199 void Recorder::setCTM(const AffineTransform&amp; transform)</span>
200 {
<span class="line-modified">201     currentState().setCTM(transform);</span>
<span class="line-added">202     appendItem(SetCTM::create(transform));</span>
203 }
204 
205 AffineTransform Recorder::getCTM(GraphicsContext::IncludeDeviceScale)
206 {
<span class="line-modified">207     // FIXME: Respect the given value of IncludeDeviceScale.</span>
<span class="line-modified">208     return currentState().ctm;</span>
209 }
210 
211 void Recorder::beginTransparencyLayer(float opacity)
212 {
213     DrawingItem&amp; newItem = downcast&lt;DrawingItem&gt;(appendItem(BeginTransparencyLayer::create(opacity)));
214     updateItemExtent(newItem);
215 }
216 
217 void Recorder::endTransparencyLayer()
218 {
219     appendItem(EndTransparencyLayer::create());
220 }
221 
222 void Recorder::drawRect(const FloatRect&amp; rect, float borderThickness)
223 {
224     DrawingItem&amp; newItem = downcast&lt;DrawingItem&gt;(appendItem(DrawRect::create(rect, borderThickness)));
225     updateItemExtent(newItem);
226 }
227 
228 void Recorder::drawLine(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
</pre>
<hr />
<pre>
467 }
468 
469 void Recorder::ContextState::rotate(float angleInRadians)
470 {
471     double angleInDegrees = rad2deg(static_cast&lt;double&gt;(angleInRadians));
472     ctm.rotate(angleInDegrees);
473 
474     AffineTransform rotation;
475     rotation.rotate(angleInDegrees);
476 
477     if (Optional&lt;AffineTransform&gt; inverse = rotation.inverse())
478         clipBounds = inverse.value().mapRect(clipBounds);
479 }
480 
481 void Recorder::ContextState::scale(const FloatSize&amp; size)
482 {
483     ctm.scale(size);
484     clipBounds.scale(1 / size.width(), 1 / size.height());
485 }
486 
<span class="line-added">487 void Recorder::ContextState::setCTM(const AffineTransform&amp; matrix)</span>
<span class="line-added">488 {</span>
<span class="line-added">489     Optional&lt;AffineTransform&gt; inverseTransformForClipBounds;</span>
<span class="line-added">490     if (auto originalCTMInverse = ctm.inverse())</span>
<span class="line-added">491         inverseTransformForClipBounds = originalCTMInverse-&gt;multiply(matrix).inverse();</span>
<span class="line-added">492 </span>
<span class="line-added">493     ctm = matrix;</span>
<span class="line-added">494 </span>
<span class="line-added">495     if (inverseTransformForClipBounds)</span>
<span class="line-added">496         clipBounds = inverseTransformForClipBounds-&gt;mapRect(clipBounds);</span>
<span class="line-added">497 }</span>
<span class="line-added">498 </span>
499 void Recorder::ContextState::concatCTM(const AffineTransform&amp; matrix)
500 {
501     ctm *= matrix;
502 
503     if (Optional&lt;AffineTransform&gt; inverse = matrix.inverse())
504         clipBounds = inverse.value().mapRect(clipBounds);
505 }
506 
507 } // namespace DisplayList
508 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DisplayListItems.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListRecorder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
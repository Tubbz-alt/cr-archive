<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/risc.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 # Copyright (C) 2011-2018 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require &#39;config&#39;
 25 require &#39;ast&#39;
 26 require &#39;opt&#39;
 27 
 28 # This file contains utilities that are useful for implementing a backend
 29 # for RISC-like processors (ARM, MIPS, etc).
 30 
 31 #
 32 # Lowering of simple branch ops. For example:
 33 #
 34 # baddiz foo, bar, baz
 35 #
 36 # will become:
 37 #
 38 # addi foo, bar
 39 # bz baz
 40 #
 41 
 42 def riscLowerSimpleBranchOps(list)
 43     newList = []
 44     list.each {
 45         | node |
 46         if node.is_a? Instruction
 47             annotation = node.annotation
 48             case node.opcode
 49             when /^b(addi|subi|ori|addp)/
 50                 op = $1
 51                 branch = &quot;b&quot; + $~.post_match
 52                 
 53                 case op
 54                 when &quot;addi&quot;
 55                     op = &quot;addis&quot;
 56                 when &quot;addp&quot;
 57                     op = &quot;addps&quot;
 58                 when &quot;subi&quot;
 59                     op = &quot;subis&quot;
 60                 when &quot;ori&quot;
 61                     op = &quot;oris&quot;
 62                 end
 63                 
 64                 newList &lt;&lt; Instruction.new(node.codeOrigin, op, node.operands[0..-2], annotation)
 65                 newList &lt;&lt; Instruction.new(node.codeOrigin, branch, [node.operands[-1]])
 66             when &#39;bmulis&#39;, &#39;bmulz&#39;, &#39;bmulnz&#39;
 67                 condition = $~.post_match
 68                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;muli&quot;, node.operands[0..-2], annotation)
 69                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bti&quot; + condition, [node.operands[-2], node.operands[-1]])
 70             else
 71                 newList &lt;&lt; node
 72             end
 73         else
 74             newList &lt;&lt; node
 75         end
 76     }
 77     newList
 78 end
 79 
 80 #
 81 # Lowing of complex branch ops. For example:
 82 #
 83 # bmulio foo, bar, baz
 84 #
 85 # becomes:
 86 #
 87 # smulli foo, bar, bar, tmp1
 88 # rshifti bar, 31, tmp2
 89 # bineq tmp1, tmp2, baz
 90 #
 91 
 92 def riscLowerHardBranchOps(list)
 93     newList = []
 94     list.each {
 95         | node |
 96         if node.is_a? Instruction and node.opcode == &quot;bmulio&quot;
 97             tmp1 = Tmp.new(node.codeOrigin, :gpr)
 98             tmp2 = Tmp.new(node.codeOrigin, :gpr)
 99             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;smulli&quot;, [node.operands[0], node.operands[1], node.operands[1], tmp1], node.annotation)
100             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;rshifti&quot;, [node.operands[-2], Immediate.new(node.codeOrigin, 31), tmp2])
101             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bineq&quot;, [tmp1, tmp2, node.operands[-1]])
102         else
103             newList &lt;&lt; node
104         end
105     }
106     newList
107 end
108 
109 #
110 # Lowering of shift ops. For example:
111 #
112 # lshifti foo, bar
113 #
114 # will become:
115 #
116 # andi foo, 31, tmp
117 # lshifti tmp, bar
118 #
119 
120 def riscSanitizeShift(operand, list)
121     return operand if operand.immediate?
122     
123     tmp = Tmp.new(operand.codeOrigin, :gpr)
124     list &lt;&lt; Instruction.new(operand.codeOrigin, &quot;andi&quot;, [operand, Immediate.new(operand.codeOrigin, 31), tmp])
125     tmp
126 end
127 
128 def riscLowerShiftOps(list)
129     newList = []
130     list.each {
131         | node |
132         if node.is_a? Instruction
133             case node.opcode
134             when &quot;lshifti&quot;, &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;lshiftp&quot;, &quot;rshiftp&quot;, &quot;urshiftp&quot;
135                 if node.operands.size == 2
136                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [riscSanitizeShift(node.operands[0], newList), node.operands[1]], node.annotation)
137                 else
138                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [node.operands[0], riscSanitizeShift(node.operands[1], newList), node.operands[2]], node.annotation)
139                     raise &quot;Wrong number of operands for shift at #{node.codeOriginString}&quot; unless node.operands.size == 3
140                 end
141             else
142                 newList &lt;&lt; node
143             end
144         else
145             newList &lt;&lt; node
146         end
147     }
148     newList
149 end
150 
151 #
152 # Lowering of malformed addresses. For example:
153 #
154 # loadp 10000[foo], bar
155 #
156 # will become:
157 #
158 # move 10000, tmp
159 # addp foo, tmp
160 # loadp 0[tmp], bar
161 #
162 # Note that you use this lowering phase by passing it a block that returns true
163 # if you don&#39;t want to lower the address, or false if you do. For example to get
164 # the effect of the example above, the block would have to say something like:
165 #
166 # riscLowerMalformedAddresses(thingy) {
167 #     | node, address |
168 #     if address.is_a? Address
169 #         address.offset.value &gt; 1000
170 #     else
171 #         true # don&#39;t lower anything else, in this example
172 #     end
173 # }
174 #
175 # See arm.rb for a different example, in which we lower all BaseIndex addresses
176 # that have non-zero offset, all Address addresses that have large offsets, and
177 # all other addresses (like AbsoluteAddress).
178 #
179 
180 class Node
181     def riscLowerMalformedAddressesRecurse(list, topLevelNode, &amp;block)
182         mapChildren {
183             | subNode |
184             subNode.riscLowerMalformedAddressesRecurse(list, topLevelNode, &amp;block)
185         }
186     end
187 end
188 
189 class Address
190     def riscLowerMalformedAddressesRecurse(list, node, &amp;block)
191         return self if yield node, self
192 
193         tmp = Tmp.new(codeOrigin, :gpr)
194         list &lt;&lt; Instruction.new(codeOrigin, &quot;move&quot;, [offset, tmp])
195         list &lt;&lt; Instruction.new(codeOrigin, &quot;addp&quot;, [base, tmp])
196         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, 0))
197     end
198 end
199 
200 class BaseIndex
201     def riscLowerMalformedAddressesRecurse(list, node, &amp;block)
202         return self if yield node, self
203         
204         tmp = Tmp.new(codeOrigin, :gpr)
205         list &lt;&lt; Instruction.new(codeOrigin, &quot;leap&quot;, [BaseIndex.new(codeOrigin, base, index, scale, Immediate.new(codeOrigin, 0)), tmp])
206         Address.new(codeOrigin, tmp, offset).riscLowerMalformedAddressesRecurse(list, node, &amp;block)
207     end
208 end
209 
210 class AbsoluteAddress
211     def riscLowerMalformedAddressesRecurse(list, node, &amp;block)
212         return self if yield node, self
213         
214         tmp = Tmp.new(codeOrigin, :gpr)
215         list &lt;&lt; Instruction.new(codeOrigin, &quot;move&quot;, [address, tmp])
216         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, 0))
217     end
218 end
219 
220 def riscLowerMalformedAddresses(list, &amp;block)
221     newList = []
222     list.each {
223         | node |
224         newList &lt;&lt; node.riscLowerMalformedAddressesRecurse(newList, node, &amp;block)
225     }
226     newList
227 end
228 
229 #
230 # Lowering of malformed addresses in double loads and stores. For example:
231 #
232 # loadd [foo, bar, 8], baz
233 #
234 # becomes:
235 #
236 # leap [foo, bar, 8], tmp
237 # loadd [tmp], baz
238 #
239 
240 class Node
241     def riscDoubleAddress(list)
242         self
243     end
244 end
245 
246 class BaseIndex
247     def riscDoubleAddress(list)
248         tmp = Tmp.new(codeOrigin, :gpr)
249         list &lt;&lt; Instruction.new(codeOrigin, &quot;leap&quot;, [self, tmp])
250         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, 0))
251     end
252 end
253 
254 def riscLowerMalformedAddressesDouble(list)
255     newList = []
256     list.each {
257         | node |
258         if node.is_a? Instruction
259             case node.opcode
260             when &quot;loadd&quot;
261                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;loadd&quot;, [node.operands[0].riscDoubleAddress(newList), node.operands[1]], node.annotation)
262             when &quot;stored&quot;
263                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;stored&quot;, [node.operands[0], node.operands[1].riscDoubleAddress(newList)], node.annotation)
264             else
265                 newList &lt;&lt; node
266             end
267         else
268             newList &lt;&lt; node
269         end
270     }
271     newList
272 end
273 
274 #
275 # Lowering of misplaced immediates for opcodes in opcodeList. For example, if storei is in opcodeList:
276 #
277 # storei 0, [foo]
278 #
279 # will become:
280 #
281 # move 0, tmp
282 # storei tmp, [foo]
283 #
284 
285 def riscLowerMisplacedImmediates(list, opcodeList)
286     newList = []
287     list.each {
288         | node |
289         if node.is_a? Instruction
290             if opcodeList.include? node.opcode
291                 operands = node.operands
292                 newOperands = []
293                 operands.each {
294                     | operand |
295                     if operand.is_a? Immediate
296                         tmp = Tmp.new(operand.codeOrigin, :gpr)
297                         newList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [operand, tmp])
298                         newOperands &lt;&lt; tmp
299                     else
300                         newOperands &lt;&lt; operand
301                     end
302                 }
303                 newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, newOperands, node.annotation)
304             else
305                 newList &lt;&lt; node
306             end
307         else
308             newList &lt;&lt; node
309         end
310     }
311     newList
312 end
313 
314 #
315 # Lowering of malformed immediates except when used in a &quot;move&quot; instruction.
316 # For example:
317 #
318 # addp 642641, foo
319 #
320 # will become:
321 #
322 # move 642641, tmp
323 # addp tmp, foo
324 #
325 
326 class Node
327     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
328         mapChildren {
329             | node |
330             node.riscLowerMalformedImmediatesRecurse(list, validImmediates)
331         }
332     end
333 end
334 
335 class Address
336     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
337         self
338     end
339 end
340 
341 class BaseIndex
342     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
343         self
344     end
345 end
346 
347 class AbsoluteAddress
348     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
349         self
350     end
351 end
352 
353 class Immediate
354     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
355         unless validImmediates.include? value
356             tmp = Tmp.new(codeOrigin, :gpr)
357             list &lt;&lt; Instruction.new(codeOrigin, &quot;move&quot;, [self, tmp])
358             tmp
359         else
360             self
361         end
362     end
363 end
364 
<a name="1" id="anc1"></a><span class="line-modified">365 def riscLowerMalformedImmediates(list, validImmediates)</span>
366     newList = []
367     list.each {
368         | node |
369         if node.is_a? Instruction
370             annotation = node.annotation
371             case node.opcode
372             when &quot;move&quot;
373                 newList &lt;&lt; node
374             when &quot;addi&quot;, &quot;addp&quot;, &quot;addq&quot;, &quot;addis&quot;, &quot;subi&quot;, &quot;subp&quot;, &quot;subq&quot;, &quot;subis&quot;
375                 if node.operands[0].is_a? Immediate and
376                         (not validImmediates.include? node.operands[0].value) and
377                         validImmediates.include? -node.operands[0].value and
378                         node.operands.size == 2
379                     if node.opcode =~ /add/
380                         newOpcode = &quot;sub&quot; + $~.post_match
381                     else
382                         newOpcode = &quot;add&quot; + $~.post_match
383                     end
384                     newList &lt;&lt; Instruction.new(node.codeOrigin, newOpcode,
385                                                [Immediate.new(node.codeOrigin, -node.operands[0].value)] + node.operands[1..-1],
386                                                annotation)
387                 else
388                     newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, validImmediates)
389                 end
390             when &quot;muli&quot;, &quot;mulp&quot;, &quot;mulq&quot;
391                 if node.operands[0].is_a? Immediate
392                     tmp = Tmp.new(codeOrigin, :gpr)
393                     newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[0], tmp], annotation)
394                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [tmp] + node.operands[1..-1])
395                 else
396                     newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, validImmediates)
397                 end
<a name="2" id="anc2"></a>

398             else
399                 newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, validImmediates)
400             end
401         else
402             newList &lt;&lt; node
403         end
404     }
405     newList
406 end
407 
408 #
409 # Lowering of misplaced addresses. For example:
410 #
411 # addi foo, [bar]
412 #
413 # will become:
414 #
415 # loadi [bar], tmp
416 # addi foo, tmp
417 # storei tmp, [bar]
418 #
419 # Another example:
420 #
421 # addi [foo], bar
422 #
423 # will become:
424 #
425 # loadi [foo], tmp
426 # addi tmp, bar
427 #
428 
429 def riscAsRegister(preList, postList, operand, suffix, needStore)
430     return operand unless operand.address?
431     
432     tmp = Tmp.new(operand.codeOrigin, if suffix == &quot;d&quot; then :fpr else :gpr end)
433     preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;load&quot; + suffix, [operand, tmp])
434     if needStore
435         postList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;store&quot; + suffix, [tmp, operand])
436     end
437     tmp
438 end
439 
440 def riscAsRegisters(preList, postList, operands, suffix)
441     newOperands = []
442     operands.each_with_index {
443         | operand, index |
444         newOperands &lt;&lt; riscAsRegister(preList, postList, operand, suffix, index == operands.size - 1)
445     }
446     newOperands
447 end
448 
449 def riscLowerMisplacedAddresses(list)
450     newList = []
451     hasBackendSpecificLowering = Instruction.respond_to? &quot;lowerMisplacedAddresses#{$activeBackend}&quot;
452     list.each {
453         | node |
454         if node.is_a? Instruction
455             if hasBackendSpecificLowering
456                 wasHandled, newList = Instruction.send(&quot;lowerMisplacedAddresses#{$activeBackend}&quot;, node, newList)
457                 next if wasHandled
458             end
459 
460             postInstructions = []
461             annotation = node.annotation
462             case node.opcode
<a name="3" id="anc3"></a><span class="line-modified">463             when &quot;addi&quot;, &quot;addis&quot;, &quot;andi&quot;, &quot;lshifti&quot;, &quot;muli&quot;, &quot;negi&quot;, &quot;noti&quot;, &quot;ori&quot;, &quot;oris&quot;,</span>
464                 &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;subi&quot;, &quot;subis&quot;, &quot;xori&quot;, /^bi/, /^bti/, /^ci/, /^ti/
465                 newList &lt;&lt; Instruction.new(node.codeOrigin,
466                                            node.opcode,
467                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;i&quot;),
468                                            annotation)
469             when &quot;addp&quot;, &quot;andp&quot;, &quot;lshiftp&quot;, &quot;mulp&quot;, &quot;negp&quot;, &quot;orp&quot;, &quot;rshiftp&quot;, &quot;urshiftp&quot;,
470                 &quot;subp&quot;, &quot;xorp&quot;, /^bp/, /^btp/, /^cp/
471                 newList &lt;&lt; Instruction.new(node.codeOrigin,
472                                            node.opcode,
473                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;p&quot;),
474                                            annotation)
475             when &quot;addq&quot;, &quot;andq&quot;, &quot;lshiftq&quot;, &quot;mulq&quot;, &quot;negq&quot;, &quot;orq&quot;, &quot;rshiftq&quot;, &quot;urshiftq&quot;,
476                 &quot;subq&quot;, &quot;xorq&quot;, /^bq/, /^btq/, /^cq/
477                 newList &lt;&lt; Instruction.new(node.codeOrigin,
478                                            node.opcode,
479                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;q&quot;),
480                                            annotation)
481             when &quot;bbeq&quot;, &quot;bbneq&quot;, &quot;bba&quot;, &quot;bbaeq&quot;, &quot;bbb&quot;, &quot;bbbeq&quot;, &quot;btbz&quot;, &quot;btbnz&quot;, &quot;tbz&quot;, &quot;tbnz&quot;,
482                 &quot;cbeq&quot;, &quot;cbneq&quot;, &quot;cba&quot;, &quot;cbaeq&quot;, &quot;cbb&quot;, &quot;cbbeq&quot;
483                 newList &lt;&lt; Instruction.new(node.codeOrigin,
484                                            node.opcode,
485                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;b&quot;),
486                                            annotation)
487             when &quot;bbgt&quot;, &quot;bbgteq&quot;, &quot;bblt&quot;, &quot;bblteq&quot;, &quot;btbs&quot;, &quot;tbs&quot;, &quot;cbgt&quot;, &quot;cbgteq&quot;, &quot;cblt&quot;, &quot;cblteq&quot;
488                 newList &lt;&lt; Instruction.new(node.codeOrigin,
489                                            node.opcode,
490                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;bs&quot;),
491                                            annotation)
492             when &quot;addd&quot;, &quot;divd&quot;, &quot;subd&quot;, &quot;muld&quot;, &quot;sqrtd&quot;, /^bd/
493                 newList &lt;&lt; Instruction.new(node.codeOrigin,
494                                            node.opcode,
495                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;d&quot;),
496                                            annotation)
497             when &quot;jmp&quot;, &quot;call&quot;
498                 newList &lt;&lt; Instruction.new(node.codeOrigin,
499                                            node.opcode,
500                                            [riscAsRegister(newList, postInstructions, node.operands[0], &quot;p&quot;, false)],
501                                            annotation)
502             else
503                 newList &lt;&lt; node
504             end
505             newList += postInstructions
506         else
507             newList &lt;&lt; node
508         end
509     }
510     newList
511 end
512 
513 #
514 # Lowering of register reuse in compare instructions. For example:
515 #
516 # cieq t0, t1, t0
517 #
518 # will become:
519 #
520 # mov tmp, t0
521 # cieq tmp, t1, t0
522 #
523 
524 def riscLowerRegisterReuse(list)
525     newList = []
526     list.each {
527         | node |
528         if node.is_a? Instruction
529             annotation = node.annotation
530             case node.opcode
531             when &quot;cieq&quot;, &quot;cineq&quot;, &quot;cia&quot;, &quot;ciaeq&quot;, &quot;cib&quot;, &quot;cibeq&quot;, &quot;cigt&quot;, &quot;cigteq&quot;, &quot;cilt&quot;, &quot;cilteq&quot;,
532                 &quot;cpeq&quot;, &quot;cpneq&quot;, &quot;cpa&quot;, &quot;cpaeq&quot;, &quot;cpb&quot;, &quot;cpbeq&quot;, &quot;cpgt&quot;, &quot;cpgteq&quot;, &quot;cplt&quot;, &quot;cplteq&quot;,
533                 &quot;tis&quot;, &quot;tiz&quot;, &quot;tinz&quot;, &quot;tbs&quot;, &quot;tbz&quot;, &quot;tbnz&quot;, &quot;tps&quot;, &quot;tpz&quot;, &quot;tpnz&quot;, &quot;cbeq&quot;, &quot;cbneq&quot;,
534                 &quot;cba&quot;, &quot;cbaeq&quot;, &quot;cbb&quot;, &quot;cbbeq&quot;, &quot;cbgt&quot;, &quot;cbgteq&quot;, &quot;cblt&quot;, &quot;cblteq&quot;
535                 if node.operands.size == 2
536                     if node.operands[0] == node.operands[1]
537                         tmp = Tmp.new(node.codeOrigin, :gpr)
538                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[0], tmp], annotation)
539                         newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [tmp, node.operands[1]])
540                     else
541                         newList &lt;&lt; node
542                     end
543                 else
544                     raise &quot;Wrong number of arguments at #{node.codeOriginString}&quot; unless node.operands.size == 3
545                     if node.operands[0] == node.operands[2]
546                         tmp = Tmp.new(node.codeOrigin, :gpr)
547                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[0], tmp], annotation)
548                         newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [tmp, node.operands[1], node.operands[2]])
549                     elsif node.operands[1] == node.operands[2]
550                         tmp = Tmp.new(node.codeOrigin, :gpr)
551                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[1], tmp], annotation)
552                         newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [node.operands[0], tmp, node.operands[2]])
553                     else
554                         newList &lt;&lt; node
555                     end
556                 end
557             else
558                 newList &lt;&lt; node
559             end
560         else
561             newList &lt;&lt; node
562         end
563     }
564     newList
565 end
566 
567 #
568 # Lowering of the not instruction. The following:
569 #
570 # noti t0
571 #
572 # becomes:
573 #
574 # xori -1, t0
575 #
576 
577 def riscLowerNot(list)
578     newList = []
579     list.each {
580         | node |
581         if node.is_a? Instruction
582             case node.opcode
583             when &quot;noti&quot;, &quot;notp&quot;
584                 raise &quot;Wrong number of operands at #{node.codeOriginString}&quot; unless node.operands.size == 1
585                 suffix = node.opcode[-1..-1]
586                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xor&quot; + suffix,
587                                            [Immediate.new(node.codeOrigin, -1), node.operands[0]])
588             else
589                 newList &lt;&lt; node
590             end
591         else
592             newList &lt;&lt; node
593         end
594     }
595     return newList
596 end
597 
598 #
599 # Lowing of complex branch ops on 64-bit. For example:
600 #
601 # bmulio foo, bar, baz
602 #
603 # becomes:
604 #
605 # smulli foo, bar, bar
606 # rshiftp bar, 32, tmp1
607 # rshifti bar, 31, tmp2
608 # zxi2p bar, bar 
609 # bineq tmp1, tmp2, baz
610 #
611 
612 def riscLowerHardBranchOps64(list)
613     newList = []
614     list.each {
615         | node |
616         if node.is_a? Instruction and node.opcode == &quot;bmulio&quot;
617             tmp1 = Tmp.new(node.codeOrigin, :gpr)
618             tmp2 = Tmp.new(node.codeOrigin, :gpr)
619             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;smulli&quot;, [node.operands[0], node.operands[1], node.operands[1]])
620             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;rshiftp&quot;, [node.operands[1], Immediate.new(node.codeOrigin, 32), tmp1])
621             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;rshifti&quot;, [node.operands[1], Immediate.new(node.codeOrigin, 31), tmp2])
622             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;zxi2p&quot;, [node.operands[1], node.operands[1]])
623             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bineq&quot;, [tmp1, tmp2, node.operands[2]])
624         else
625             newList &lt;&lt; node
626         end
627     }
628     newList
629 end
630 
631 #
632 # Lowering of test instructions. For example:
633 #
634 # btiz t0, t1, .foo
635 #
636 # becomes:
637 #
638 # andi t0, t1, tmp
639 # bieq tmp, 0, .foo
640 #
641 # and another example:
642 #
643 # tiz t0, t1, t2
644 #
645 # becomes:
646 #
647 # andi t0, t1, tmp
648 # cieq tmp, 0, t2
649 #
650 
651 def riscLowerTest(list)
652     def emit(newList, andOpcode, branchOpcode, node)
653         if node.operands.size == 2
654             newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [node.operands[0], Immediate.new(node.codeOrigin, 0), node.operands[1]])
655             return
656         end
657 
658         raise &quot;Incorrect number of operands at #{codeOriginString}&quot; unless node.operands.size == 3
659 
660         if node.operands[0].immediate? and node.operands[0].value == -1
661             newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [node.operands[1], Immediate.new(node.codeOrigin, 0), node.operands[2]])
662             return
663         end
664 
665         if node.operands[1].immediate? and node.operands[1].value == -1
666             newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [node.operands[0], Immediate.new(node.codeOrigin, 0), node.operands[2]])
667             return
668         end
669         
670         tmp = Tmp.new(node.codeOrigin, :gpr)
671         newList &lt;&lt; Instruction.new(node.codeOrigin, andOpcode, [node.operands[0], node.operands[1], tmp])
672         newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [tmp, Immediate.new(node.codeOrigin, 0), node.operands[2]])
673     end
674 
675     newList = []
676     list.each {
677         | node |
678         if node.is_a? Instruction
679             case node.opcode
680             when &quot;btis&quot;
681                 emit(newList, &quot;andi&quot;, &quot;bilt&quot;, node)
682             when &quot;btiz&quot;
683                 emit(newList, &quot;andi&quot;, &quot;bieq&quot;, node)
684             when &quot;btinz&quot;
685                 emit(newList, &quot;andi&quot;, &quot;bineq&quot;, node)
686             when &quot;btps&quot;
687                 emit(newList, &quot;andp&quot;, &quot;bplt&quot;, node)
688             when &quot;btpz&quot;
689                 emit(newList, &quot;andp&quot;, &quot;bpeq&quot;, node)
690             when &quot;btpnz&quot;
691                 emit(newList, &quot;andp&quot;, &quot;bpneq&quot;, node)
692             when &quot;btqs&quot;
693                 emit(newList, &quot;andq&quot;, &quot;bqlt&quot;, node)
694             when &quot;btqz&quot;
695                 emit(newList, &quot;andq&quot;, &quot;bqeq&quot;, node)
696             when &quot;btqnz&quot;
697                 emit(newList, &quot;andq&quot;, &quot;bqneq&quot;, node)
698             when &quot;btbs&quot;
699                 emit(newList, &quot;andi&quot;, &quot;bblt&quot;, node)
700             when &quot;btbz&quot;
701                 emit(newList, &quot;andi&quot;, &quot;bbeq&quot;, node)
702             when &quot;btbnz&quot;
703                 emit(newList, &quot;andi&quot;, &quot;bbneq&quot;, node)
704             when &quot;tis&quot;
705                 emit(newList, &quot;andi&quot;, &quot;cilt&quot;, node)
706             when &quot;tiz&quot;
707                 emit(newList, &quot;andi&quot;, &quot;cieq&quot;, node)
708             when &quot;tinz&quot;
709                 emit(newList, &quot;andi&quot;, &quot;cineq&quot;, node)
710             when &quot;tps&quot;
711                 emit(newList, &quot;andp&quot;, &quot;cplt&quot;, node)
712             when &quot;tpz&quot;
713                 emit(newList, &quot;andp&quot;, &quot;cpeq&quot;, node)
714             when &quot;tpnz&quot;
715                 emit(newList, &quot;andp&quot;, &quot;cpneq&quot;, node)
716             when &quot;tqs&quot;
717                 emit(newList, &quot;andq&quot;, &quot;cqlt&quot;, node)
718             when &quot;tqz&quot;
719                 emit(newList, &quot;andq&quot;, &quot;cqeq&quot;, node)
720             when &quot;tqnz&quot;
721                 emit(newList, &quot;andq&quot;, &quot;cqneq&quot;, node)
722             when &quot;tbs&quot;
723                 emit(newList, &quot;andi&quot;, &quot;cblt&quot;, node)
724             when &quot;tbz&quot;
725                 emit(newList, &quot;andi&quot;, &quot;cbeq&quot;, node)
726             when &quot;tbnz&quot;
727                 emit(newList, &quot;andi&quot;, &quot;cbneq&quot;, node)
728             else
729                 newList &lt;&lt; node
730             end
731         else
732             newList &lt;&lt; node
733         end
734     }
735     return newList
736 end
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
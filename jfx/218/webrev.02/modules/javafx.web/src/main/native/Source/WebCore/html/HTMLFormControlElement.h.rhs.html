<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLFormControlElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;Autofill.h&quot;
 27 #include &quot;FormAssociatedElement.h&quot;
 28 #include &quot;LabelableElement.h&quot;
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #if ENABLE(AUTOCAPITALIZE)</span>
 31 #include &quot;Autocapitalize.h&quot;
 32 #endif
 33 
 34 namespace WebCore {
 35 
 36 class DOMFormData;
 37 class HTMLFieldSetElement;
 38 class HTMLFormElement;
 39 class HTMLLegendElement;
 40 class ValidationMessage;
 41 
 42 // HTMLFormControlElement is the default implementation of FormAssociatedElement,
 43 // and form-associated element implementations should use HTMLFormControlElement
 44 // unless there is a special reason.
 45 class HTMLFormControlElement : public LabelableElement, public FormAssociatedElement {
 46     WTF_MAKE_ISO_ALLOCATED(HTMLFormControlElement);
 47 public:
 48     virtual ~HTMLFormControlElement();
 49 
 50     HTMLFormElement* form() const final { return FormAssociatedElement::form(); }
 51 
 52     WEBCORE_EXPORT String formEnctype() const;
 53     WEBCORE_EXPORT void setFormEnctype(const String&amp;);
 54     WEBCORE_EXPORT String formMethod() const;
 55     WEBCORE_EXPORT void setFormMethod(const String&amp;);
 56     bool formNoValidate() const;
 57     WEBCORE_EXPORT String formAction() const;
 58     WEBCORE_EXPORT void setFormAction(const AtomString&amp;);
 59 
 60     void setAncestorDisabled(bool isDisabled);
 61 
 62     virtual void reset() { }
 63 
 64     bool formControlValueMatchesRenderer() const { return m_valueMatchesRenderer; }
 65     void setFormControlValueMatchesRenderer(bool b) { m_valueMatchesRenderer = b; }
 66 
 67     bool wasChangedSinceLastFormControlChangeEvent() const { return m_wasChangedSinceLastFormControlChangeEvent; }
 68     void setChangedSinceLastFormControlChangeEvent(bool);
 69 
 70     virtual void dispatchFormControlChangeEvent();
 71     void dispatchChangeEvent();
 72     void dispatchFormControlInputEvent();
 73 
 74     bool isDisabledFormControl() const override;
 75 
 76     bool isEnumeratable() const override { return false; }
 77 
 78     bool isRequired() const;
 79 
 80     const AtomString&amp; type() const { return formControlType(); }
 81 
 82     virtual const AtomString&amp; formControlType() const = 0;
 83 
 84     virtual bool canTriggerImplicitSubmission() const { return false; }
 85 
 86     // Override in derived classes to get the encoded name=value pair for submitting.
 87     // Return true for a successful control (see HTML4-17.13.2).
 88     bool appendFormData(DOMFormData&amp;, bool) override { return false; }
 89 
 90     virtual bool isSuccessfulSubmitButton() const { return false; }
 91     virtual bool isActivatedSubmit() const { return false; }
 92     virtual void setActivatedSubmit(bool) { }
 93 
<a name="2" id="anc2"></a><span class="line-modified"> 94 #if ENABLE(AUTOCORRECT)</span>
 95     WEBCORE_EXPORT bool shouldAutocorrect() const final;
<a name="3" id="anc3"></a><span class="line-added"> 96 #endif</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 #if ENABLE(AUTOCAPITALIZE)</span>
 99     WEBCORE_EXPORT AutocapitalizeType autocapitalizeType() const final;
100 #endif
101 
102     WEBCORE_EXPORT bool willValidate() const final;
103     void updateVisibleValidationMessage();
104     void hideVisibleValidationMessage();
105     WEBCORE_EXPORT bool checkValidity(Vector&lt;RefPtr&lt;HTMLFormControlElement&gt;&gt;* unhandledInvalidControls = nullptr);
106     bool reportValidity();
107     void focusAndShowValidationMessage();
108     bool isShowingValidationMessage() const;
109     // This must be called when a validation constraint or control value is changed.
110     void updateValidity();
111     void setCustomValidity(const String&amp;) override;
112 
113     bool isReadOnly() const { return m_isReadOnly; }
114     bool isDisabledOrReadOnly() const { return isDisabledFormControl() || m_isReadOnly; }
115 
116     bool hasAutofocused() { return m_hasAutofocused; }
117     void setAutofocused() { m_hasAutofocused = true; }
118 
119     static HTMLFormControlElement* enclosingFormControlElement(Node*);
120 
121     WEBCORE_EXPORT String autocomplete() const;
122     WEBCORE_EXPORT void setAutocomplete(const String&amp;);
123 
124     AutofillMantle autofillMantle() const;
125 
126     WEBCORE_EXPORT AutofillData autofillData() const;
127 
128     using Node::ref;
129     using Node::deref;
130 
131 protected:
132     HTMLFormControlElement(const QualifiedName&amp; tagName, Document&amp;, HTMLFormElement*);
133 
134     bool disabledByAncestorFieldset() const { return m_disabledByAncestorFieldset; }
135 
136     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
137     virtual void disabledAttributeChanged();
138     virtual void disabledStateChanged();
139     virtual void readOnlyStateChanged();
140     virtual void requiredStateChanged();
141     void didAttachRenderers() override;
142     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
143     void didFinishInsertingNode() override;
144     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
145     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
146 
147     bool supportsFocus() const override;
148     bool isKeyboardFocusable(KeyboardEvent*) const override;
149     bool isMouseFocusable() const override;
150 
151     void didRecalcStyle(Style::Change) override;
152 
153     void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement) override;
154 
155     // This must be called any time the result of willValidate() has changed.
156     void setNeedsWillValidateCheck();
157     virtual bool computeWillValidate() const;
158 
159     bool validationMessageShadowTreeContains(const Node&amp;) const;
160 
161     void willChangeForm() override;
162     void didChangeForm() override;
163 
164 private:
165     void refFormAssociatedElement() override { ref(); }
166     void derefFormAssociatedElement() override { deref(); }
167 
168     bool matchesValidPseudoClass() const override;
169     bool matchesInvalidPseudoClass() const override;
170 
171     bool isFormControlElement() const final { return true; }
172 
173     bool isValidFormControlElement() const;
174 
175     bool computeIsDisabledByFieldsetAncestor() const;
176 
177     HTMLElement&amp; asHTMLElement() final { return *this; }
178     const HTMLFormControlElement&amp; asHTMLElement() const final { return *this; }
179     FormNamedItem* asFormNamedItem() final { return this; }
180     FormAssociatedElement* asFormAssociatedElement() final { return this; }
181 
182     bool needsMouseFocusableQuirk() const;
183 
184     std::unique_ptr&lt;ValidationMessage&gt; m_validationMessage;
185     unsigned m_disabled : 1;
186     unsigned m_isReadOnly : 1;
187     unsigned m_isRequired : 1;
188     unsigned m_valueMatchesRenderer : 1;
189     unsigned m_disabledByAncestorFieldset : 1;
190 
191     enum DataListAncestorState { Unknown, InsideDataList, NotInsideDataList };
192     mutable unsigned m_dataListAncestorState : 2;
193 
194     // The initial value of m_willValidate depends on the derived class. We can&#39;t
195     // initialize it with a virtual function in the constructor. m_willValidate
196     // is not deterministic as long as m_willValidateInitialized is false.
197     mutable bool m_willValidateInitialized: 1;
198     mutable bool m_willValidate : 1;
199 
200     // Cache of validity()-&gt;valid().
201     // But &quot;candidate for constraint validation&quot; doesn&#39;t affect m_isValid.
202     unsigned m_isValid : 1;
203 
204     unsigned m_wasChangedSinceLastFormControlChangeEvent : 1;
205 
206     unsigned m_hasAutofocused : 1;
207 };
208 
209 } // namespace WebCore
210 
211 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLFormControlElement)
212     static bool isType(const WebCore::Element&amp; element) { return element.isFormControlElement(); }
213     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
214     static bool isType(const WebCore::FormAssociatedElement&amp; element) { return element.isFormControlElement(); }
215 SPECIALIZE_TYPE_TRAITS_END()
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/ResourceLoadNotifier.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  4  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  * 1.  Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  * 2.  Redistributions in binary form must reproduce the above copyright
 13  *     notice, this list of conditions and the following disclaimer in the
 14  *     documentation and/or other materials provided with the distribution.
 15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 16  *     its contributors may be used to endorse or promote products derived
 17  *     from this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;ResourceLoadNotifier.h&quot;
 33 
 34 #include &quot;DocumentLoader.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;FrameLoaderClient.h&quot;
 38 #include &quot;InspectorInstrumentation.h&quot;
 39 #include &quot;Page.h&quot;
 40 #include &quot;ProgressTracker.h&quot;
 41 #include &quot;ResourceLoader.h&quot;
<a name="1" id="anc1"></a>
 42 
 43 #if USE(QUICK_LOOK)
 44 #include &quot;QuickLook.h&quot;
 45 #endif
 46 
 47 namespace WebCore {
 48 
 49 ResourceLoadNotifier::ResourceLoadNotifier(Frame&amp; frame)
 50     : m_frame(frame)
 51 {
 52 }
 53 
 54 void ResourceLoadNotifier::didReceiveAuthenticationChallenge(ResourceLoader* loader, const AuthenticationChallenge&amp; currentWebChallenge)
 55 {
 56     didReceiveAuthenticationChallenge(loader-&gt;identifier(), loader-&gt;documentLoader(), currentWebChallenge);
 57 }
 58 
 59 void ResourceLoadNotifier::didReceiveAuthenticationChallenge(unsigned long identifier, DocumentLoader* loader, const AuthenticationChallenge&amp; currentWebChallenge)
 60 {
 61     m_frame.loader().client().dispatchDidReceiveAuthenticationChallenge(loader, identifier, currentWebChallenge);
 62 }
 63 
 64 void ResourceLoadNotifier::willSendRequest(ResourceLoader* loader, ResourceRequest&amp; clientRequest, const ResourceResponse&amp; redirectResponse)
 65 {
 66     m_frame.loader().applyUserAgentIfNeeded(clientRequest);
 67 
 68     dispatchWillSendRequest(loader-&gt;documentLoader(), loader-&gt;identifier(), clientRequest, redirectResponse);
 69 }
 70 
 71 void ResourceLoadNotifier::didReceiveResponse(ResourceLoader* loader, const ResourceResponse&amp; r)
 72 {
 73     loader-&gt;documentLoader()-&gt;addResponse(r);
 74 
 75     if (Page* page = m_frame.page())
 76         page-&gt;progress().incrementProgress(loader-&gt;identifier(), r);
 77 
 78     dispatchDidReceiveResponse(loader-&gt;documentLoader(), loader-&gt;identifier(), r, loader);
 79 }
 80 
 81 void ResourceLoadNotifier::didReceiveData(ResourceLoader* loader, const char* data, int dataLength, int encodedDataLength)
 82 {
 83     if (Page* page = m_frame.page())
 84         page-&gt;progress().incrementProgress(loader-&gt;identifier(), dataLength);
 85 
 86     dispatchDidReceiveData(loader-&gt;documentLoader(), loader-&gt;identifier(), data, dataLength, encodedDataLength);
 87 }
 88 
 89 void ResourceLoadNotifier::didFinishLoad(ResourceLoader* loader, const NetworkLoadMetrics&amp; networkLoadMetrics)
 90 {
 91     if (Page* page = m_frame.page())
 92         page-&gt;progress().completeProgress(loader-&gt;identifier());
 93 
 94     dispatchDidFinishLoading(loader-&gt;documentLoader(), loader-&gt;identifier(), networkLoadMetrics, loader);
 95 }
 96 
 97 void ResourceLoadNotifier::didFailToLoad(ResourceLoader* loader, const ResourceError&amp; error)
 98 {
 99     if (Page* page = m_frame.page())
100         page-&gt;progress().completeProgress(loader-&gt;identifier());
101 
102     // Notifying the FrameLoaderClient may cause the frame to be destroyed.
103     Ref&lt;Frame&gt; protect(m_frame);
104     if (!error.isNull())
105         m_frame.loader().client().dispatchDidFailLoading(loader-&gt;documentLoader(), loader-&gt;identifier(), error);
106 
107     InspectorInstrumentation::didFailLoading(&amp;m_frame, loader-&gt;documentLoader(), loader-&gt;identifier(), error);
108 }
109 
110 void ResourceLoadNotifier::assignIdentifierToInitialRequest(unsigned long identifier, DocumentLoader* loader, const ResourceRequest&amp; request)
111 {
112     m_frame.loader().client().assignIdentifierToInitialRequest(identifier, loader, request);
113 }
114 
115 void ResourceLoadNotifier::dispatchWillSendRequest(DocumentLoader* loader, unsigned long identifier, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse)
116 {
117 #if USE(QUICK_LOOK)
118     // Always allow QuickLook-generated URLs based on the protocol scheme.
119     if (!request.isNull() &amp;&amp; isQuickLookPreviewURL(request.url()))
120         return;
121 #endif
122 
123     String oldRequestURL = request.url().string();
124 
125     ASSERT(m_frame.loader().documentLoader());
126     if (m_frame.loader().documentLoader())
127         m_frame.loader().documentLoader()-&gt;didTellClientAboutLoad(request.url());
128 
129     // Notifying the FrameLoaderClient may cause the frame to be destroyed.
130     Ref&lt;Frame&gt; protect(m_frame);
131     m_frame.loader().client().dispatchWillSendRequest(loader, identifier, request, redirectResponse);
132 
133     // If the URL changed, then we want to put that new URL in the &quot;did tell client&quot; set too.
134     if (!request.isNull() &amp;&amp; oldRequestURL != request.url().string() &amp;&amp; m_frame.loader().documentLoader())
135         m_frame.loader().documentLoader()-&gt;didTellClientAboutLoad(request.url());
136 
137     InspectorInstrumentation::willSendRequest(&amp;m_frame, identifier, loader, request, redirectResponse);
138 }
139 
140 void ResourceLoadNotifier::dispatchDidReceiveResponse(DocumentLoader* loader, unsigned long identifier, const ResourceResponse&amp; r, ResourceLoader* resourceLoader)
141 {
142     // Notifying the FrameLoaderClient may cause the frame to be destroyed.
143     Ref&lt;Frame&gt; protect(m_frame);
144     m_frame.loader().client().dispatchDidReceiveResponse(loader, identifier, r);
145 
146     InspectorInstrumentation::didReceiveResourceResponse(m_frame, identifier, loader, r, resourceLoader);
147 }
148 
149 void ResourceLoadNotifier::dispatchDidReceiveData(DocumentLoader* loader, unsigned long identifier, const char* data, int dataLength, int encodedDataLength)
150 {
151     // Notifying the FrameLoaderClient may cause the frame to be destroyed.
152     Ref&lt;Frame&gt; protect(m_frame);
153     m_frame.loader().client().dispatchDidReceiveContentLength(loader, identifier, dataLength);
154 
155     InspectorInstrumentation::didReceiveData(&amp;m_frame, identifier, data, dataLength, encodedDataLength);
156 }
157 
158 void ResourceLoadNotifier::dispatchDidFinishLoading(DocumentLoader* loader, unsigned long identifier, const NetworkLoadMetrics&amp; networkLoadMetrics, ResourceLoader* resourceLoader)
159 {
160     // Notifying the FrameLoaderClient may cause the frame to be destroyed.
161     Ref&lt;Frame&gt; protect(m_frame);
162     m_frame.loader().client().dispatchDidFinishLoading(loader, identifier);
163 
164     InspectorInstrumentation::didFinishLoading(&amp;m_frame, loader, identifier, networkLoadMetrics, resourceLoader);
165 }
166 
167 void ResourceLoadNotifier::dispatchDidFailLoading(DocumentLoader* loader, unsigned long identifier, const ResourceError&amp; error)
168 {
169     // Notifying the FrameLoaderClient may cause the frame to be destroyed.
170     Ref&lt;Frame&gt; protect(m_frame);
171     m_frame.loader().client().dispatchDidFailLoading(loader, identifier, error);
172 
173     InspectorInstrumentation::didFailLoading(&amp;m_frame, loader, identifier, error);
174 }
175 
176 void ResourceLoadNotifier::sendRemainingDelegateMessages(DocumentLoader* loader, unsigned long identifier, const ResourceRequest&amp; request, const ResourceResponse&amp; response, const char* data, int dataLength, int encodedDataLength, const ResourceError&amp; error)
177 {
178     // If the request is null, willSendRequest cancelled the load. We should
179     // only dispatch didFailLoading in this case.
180     if (request.isNull()) {
181         ASSERT(error.isCancellation());
182         dispatchDidFailLoading(loader, identifier, error);
183         return;
184     }
185 
186     if (!response.isNull())
187         dispatchDidReceiveResponse(loader, identifier, response);
188 
189     if (dataLength &gt; 0)
190         dispatchDidReceiveData(loader, identifier, data, dataLength, encodedDataLength);
191 
192     if (error.isNull()) {
193         NetworkLoadMetrics emptyMetrics;
194         dispatchDidFinishLoading(loader, identifier, emptyMetrics, nullptr);
195     } else
196         dispatchDidFailLoading(loader, identifier, error);
197 }
198 
199 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
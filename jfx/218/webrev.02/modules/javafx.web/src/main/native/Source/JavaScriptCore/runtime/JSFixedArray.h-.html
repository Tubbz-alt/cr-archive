<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSFixedArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSGlobalObject.h&quot;
 29 #include &quot;JSObject.h&quot;
 30 
 31 namespace JSC {
 32 
 33 class JSFixedArray final : public JSCell {
 34     typedef JSCell Base;
 35 
 36 public:
 37     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
 38 
 39     DECLARE_INFO;
 40 
 41     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 42     {
 43         return Structure::create(vm, globalObject, prototype, TypeInfo(JSFixedArrayType, StructureFlags), info());
 44     }
 45 
 46     ALWAYS_INLINE static JSFixedArray* tryCreate(VM&amp; vm, Structure* structure, unsigned size)
 47     {
 48         Checked&lt;size_t, RecordOverflow&gt; checkedAllocationSize = allocationSize(size);
 49         if (UNLIKELY(checkedAllocationSize.hasOverflowed()))
 50             return nullptr;
 51 
 52         void* buffer = tryAllocateCell&lt;JSFixedArray&gt;(vm.heap, checkedAllocationSize.unsafeGet());
 53         if (UNLIKELY(!buffer))
 54             return nullptr;
 55         JSFixedArray* result = new (NotNull, buffer) JSFixedArray(vm, structure, size);
 56         result-&gt;finishCreation(vm);
 57         return result;
 58     }
 59 
 60     static JSFixedArray* create(VM&amp; vm, unsigned length)
 61     {
 62         auto* array = tryCreate(vm, vm.fixedArrayStructure.get(), length);
 63         RELEASE_ASSERT(array);
 64         return array;
 65     }
 66 
 67     ALWAYS_INLINE static JSFixedArray* createFromArray(ExecState* exec, VM&amp; vm, JSArray* array)
 68     {
 69         auto throwScope = DECLARE_THROW_SCOPE(vm);
 70 
 71         IndexingType indexingType = array-&gt;indexingType() &amp; IndexingShapeMask;
 72         unsigned length = array-&gt;length();
 73         JSFixedArray* result = JSFixedArray::tryCreate(vm, vm.fixedArrayStructure.get(), length);
 74         if (UNLIKELY(!result)) {
 75             throwOutOfMemoryError(exec, throwScope);
 76             return nullptr;
 77         }
 78 
 79         if (!length)
 80             return result;
 81 
 82         if (indexingType == ContiguousShape || indexingType == Int32Shape) {
 83             for (unsigned i = 0; i &lt; length; i++) {
 84                 JSValue value = array-&gt;butterfly()-&gt;contiguous().at(array, i).get();
 85                 value = !!value ? value : jsUndefined();
 86                 result-&gt;buffer()[i].set(vm, result, value);
 87             }
 88             return result;
 89         }
 90 
 91         if (indexingType == DoubleShape) {
 92             for (unsigned i = 0; i &lt; length; i++) {
 93                 double d = array-&gt;butterfly()-&gt;contiguousDouble().at(array, i);
 94                 JSValue value = std::isnan(d) ? jsUndefined() : JSValue(JSValue::EncodeAsDouble, d);
 95                 result-&gt;buffer()[i].set(vm, result, value);
 96             }
 97             return result;
 98         }
 99 
100         for (unsigned i = 0; i &lt; length; i++) {
101             JSValue value = array-&gt;getDirectIndex(exec, i);
102             if (!value) {
103                 // When we see a hole, we assume that it&#39;s safe to assume the get would have returned undefined.
104                 // We may still call into this function when !globalObject-&gt;isArrayIteratorProtocolFastAndNonObservable(),
105                 // however, if we do that, we ensure we&#39;re calling in with an array with all self properties between
106                 // [0, length).
107                 //
108                 // We may also call into this during OSR exit to materialize a phantom fixed array.
109                 // We may be creating a fixed array during OSR exit even after the iterator protocol changed.
110                 // But, when the phantom would have logically been created, the protocol hadn&#39;t been
111                 // changed. Therefore, it is sound to assume empty indices are jsUndefined().
112                 value = jsUndefined();
113             }
114             RETURN_IF_EXCEPTION(throwScope, nullptr);
115             result-&gt;buffer()[i].set(vm, result, value);
116         }
117         return result;
118     }
119 
120     ALWAYS_INLINE JSValue get(unsigned index) const
121     {
122         ASSERT(index &lt; m_size);
123         return buffer()[index].get();
124     }
125 
126     void set(VM&amp; vm, unsigned index, JSValue value)
127     {
128         ASSERT(index &lt; m_size);
129         return buffer()[index].set(vm, this, value);
130     }
131 
132     ALWAYS_INLINE WriteBarrier&lt;Unknown&gt;* buffer() { return bitwise_cast&lt;WriteBarrier&lt;Unknown&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + offsetOfData()); }
133     ALWAYS_INLINE WriteBarrier&lt;Unknown&gt;* buffer() const { return const_cast&lt;JSFixedArray*&gt;(this)-&gt;buffer(); }
134     ALWAYS_INLINE const JSValue* values() const { return bitwise_cast&lt;const JSValue*&gt;(buffer()); }
135 
136     static void visitChildren(JSCell*, SlotVisitor&amp;);
137 
138     unsigned size() const { return m_size; }
139     unsigned length() const { return m_size; }
140 
141     static size_t offsetOfSize() { return OBJECT_OFFSETOF(JSFixedArray, m_size); }
142 
143     static size_t offsetOfData()
144     {
145         return WTF::roundUpToMultipleOf&lt;sizeof(WriteBarrier&lt;Unknown&gt;)&gt;(sizeof(JSFixedArray));
146     }
147 
148     void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);
149 
150     static void dumpToStream(const JSCell*, PrintStream&amp;);
151 
152     static Checked&lt;size_t, RecordOverflow&gt; allocationSize(Checked&lt;size_t, RecordOverflow&gt; numItems)
153     {
154         return offsetOfData() + numItems * sizeof(WriteBarrier&lt;Unknown&gt;);
155     }
156 
157 private:
158     JSFixedArray(VM&amp; vm, Structure* structure, unsigned size)
159         : Base(vm, structure)
160         , m_size(size)
161     {
162         for (unsigned i = 0; i &lt; m_size; i++)
163             buffer()[i].setStartingValue(JSValue());
164     }
165 
166     unsigned m_size;
167 };
168 
169 } // namespace JSC
    </pre>
  </body>
</html>
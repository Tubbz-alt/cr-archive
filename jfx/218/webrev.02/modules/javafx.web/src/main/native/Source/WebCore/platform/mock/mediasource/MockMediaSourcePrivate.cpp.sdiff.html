<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/mock/mediasource/MockMediaSourcePrivate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MockMediaPlayerMediaSource.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MockSourceBufferPrivate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/mock/mediasource/MockMediaSourcePrivate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45 MockMediaSourcePrivate::MockMediaSourcePrivate(MockMediaPlayerMediaSource&amp; parent, MediaSourcePrivateClient&amp; client)
 46     : m_player(parent)
 47     , m_client(client)
 48 {
 49 #if !RELEASE_LOG_DISABLED
 50     m_client-&gt;setLogIdentifier(m_player.mediaPlayerLogIdentifier());
 51 #endif
 52 }
 53 
 54 MockMediaSourcePrivate::~MockMediaSourcePrivate()
 55 {
 56     for (auto&amp; buffer : m_sourceBuffers)
 57         buffer-&gt;clearMediaSource();
 58 }
 59 
 60 MediaSourcePrivate::AddStatus MockMediaSourcePrivate::addSourceBuffer(const ContentType&amp; contentType, RefPtr&lt;SourceBufferPrivate&gt;&amp; outPrivate)
 61 {
 62     MediaEngineSupportParameters parameters;
 63     parameters.isMediaSource = true;
 64     parameters.type = contentType;
<span class="line-modified"> 65     if (MockMediaPlayerMediaSource::supportsType(parameters) == MediaPlayer::IsNotSupported)</span>
 66         return NotSupported;
 67 
 68     m_sourceBuffers.append(MockSourceBufferPrivate::create(this));
 69     outPrivate = m_sourceBuffers.last();
 70 
 71     return Ok;
 72 }
 73 
 74 void MockMediaSourcePrivate::removeSourceBuffer(SourceBufferPrivate* buffer)
 75 {
 76     ASSERT(m_sourceBuffers.contains(buffer));
 77     m_activeSourceBuffers.removeFirst(buffer);
 78     m_sourceBuffers.removeFirst(buffer);
 79 }
 80 
 81 MediaTime MockMediaSourcePrivate::duration()
 82 {
 83     return m_client-&gt;duration();
 84 }
 85 
 86 std::unique_ptr&lt;PlatformTimeRanges&gt; MockMediaSourcePrivate::buffered()
 87 {
 88     return m_client-&gt;buffered();
 89 }
 90 
 91 void MockMediaSourcePrivate::durationChanged()
 92 {
 93     m_player.updateDuration(duration());
 94 }
 95 
 96 void MockMediaSourcePrivate::markEndOfStream(EndOfStreamStatus status)
 97 {
 98     if (status == EosNoError)
<span class="line-modified"> 99         m_player.setNetworkState(MediaPlayer::Loaded);</span>
100     m_isEnded = true;
101 }
102 
103 void MockMediaSourcePrivate::unmarkEndOfStream()
104 {
105     m_isEnded = false;
106 }
107 
108 MediaPlayer::ReadyState MockMediaSourcePrivate::readyState() const
109 {
110     return m_player.readyState();
111 }
112 
113 void MockMediaSourcePrivate::setReadyState(MediaPlayer::ReadyState readyState)
114 {
115     m_player.setReadyState(readyState);
116 }
117 
118 void MockMediaSourcePrivate::waitForSeekCompleted()
119 {
</pre>
</td>
<td>
<hr />
<pre>
 45 MockMediaSourcePrivate::MockMediaSourcePrivate(MockMediaPlayerMediaSource&amp; parent, MediaSourcePrivateClient&amp; client)
 46     : m_player(parent)
 47     , m_client(client)
 48 {
 49 #if !RELEASE_LOG_DISABLED
 50     m_client-&gt;setLogIdentifier(m_player.mediaPlayerLogIdentifier());
 51 #endif
 52 }
 53 
 54 MockMediaSourcePrivate::~MockMediaSourcePrivate()
 55 {
 56     for (auto&amp; buffer : m_sourceBuffers)
 57         buffer-&gt;clearMediaSource();
 58 }
 59 
 60 MediaSourcePrivate::AddStatus MockMediaSourcePrivate::addSourceBuffer(const ContentType&amp; contentType, RefPtr&lt;SourceBufferPrivate&gt;&amp; outPrivate)
 61 {
 62     MediaEngineSupportParameters parameters;
 63     parameters.isMediaSource = true;
 64     parameters.type = contentType;
<span class="line-modified"> 65     if (MockMediaPlayerMediaSource::supportsType(parameters) == MediaPlayer::SupportsType::IsNotSupported)</span>
 66         return NotSupported;
 67 
 68     m_sourceBuffers.append(MockSourceBufferPrivate::create(this));
 69     outPrivate = m_sourceBuffers.last();
 70 
 71     return Ok;
 72 }
 73 
 74 void MockMediaSourcePrivate::removeSourceBuffer(SourceBufferPrivate* buffer)
 75 {
 76     ASSERT(m_sourceBuffers.contains(buffer));
 77     m_activeSourceBuffers.removeFirst(buffer);
 78     m_sourceBuffers.removeFirst(buffer);
 79 }
 80 
 81 MediaTime MockMediaSourcePrivate::duration()
 82 {
 83     return m_client-&gt;duration();
 84 }
 85 
 86 std::unique_ptr&lt;PlatformTimeRanges&gt; MockMediaSourcePrivate::buffered()
 87 {
 88     return m_client-&gt;buffered();
 89 }
 90 
 91 void MockMediaSourcePrivate::durationChanged()
 92 {
 93     m_player.updateDuration(duration());
 94 }
 95 
 96 void MockMediaSourcePrivate::markEndOfStream(EndOfStreamStatus status)
 97 {
 98     if (status == EosNoError)
<span class="line-modified"> 99         m_player.setNetworkState(MediaPlayer::NetworkState::Loaded);</span>
100     m_isEnded = true;
101 }
102 
103 void MockMediaSourcePrivate::unmarkEndOfStream()
104 {
105     m_isEnded = false;
106 }
107 
108 MediaPlayer::ReadyState MockMediaSourcePrivate::readyState() const
109 {
110     return m_player.readyState();
111 }
112 
113 void MockMediaSourcePrivate::setReadyState(MediaPlayer::ReadyState readyState)
114 {
115     m_player.setReadyState(readyState);
116 }
117 
118 void MockMediaSourcePrivate::waitForSeekCompleted()
119 {
</pre>
</td>
</tr>
</table>
<center><a href="MockMediaPlayerMediaSource.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MockSourceBufferPrivate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
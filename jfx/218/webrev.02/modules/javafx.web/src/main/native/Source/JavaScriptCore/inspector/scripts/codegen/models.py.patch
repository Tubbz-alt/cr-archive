diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py
@@ -36,10 +36,28 @@
 
 def find_duplicates(l):
     return [key for key, count in list(collections.Counter(l).items()) if count > 1]
 
 
+def validate_target_types(debuggable_types, target_types):
+    for target_type in target_types:
+        required_debuggable_types = set()
+        if target_type == 'javascript':
+            if not 'javascript' in debuggable_types:
+                return False
+        elif target_type == 'page' or target_type == 'worker':
+            if not 'page' in debuggable_types:
+                return False
+        elif target_type == 'service-worker':
+            if not 'service-worker' in debuggable_types:
+                return False
+        elif target_type == 'web-page':
+            if not 'web-page' in debuggable_types:
+                return False
+    return True
+
+
 _FRAMEWORK_CONFIG_MAP = {
     "Global": {
     },
     "JavaScriptCore": {
         "cpp_protocol_group": "Inspector",
@@ -64,10 +82,13 @@
         "objc_protocol_group": "Test",
         "objc_prefix": "Test",
     }
 }
 
+_ALLOWED_DEBUGGABLE_TYPE_STRINGS = frozenset(['javascript', 'page', 'service-worker', 'web-page'])
+_ALLOWED_TARGET_TYPE_STRINGS = frozenset(['javascript', 'page', 'service-worker', 'web-page', 'worker'])
+
 
 class ParseException(Exception):
     pass
 
 
@@ -366,15 +387,40 @@
 
     def parse_domain(self, json, isSupplemental):
         check_for_required_properties(['domain'], json, "domain")
         log.debug("parse domain " + json['domain'])
 
+        debuggable_types = None
+        target_types = None
         version = None
         types = []
         commands = []
         events = []
 
+        if 'debuggableTypes' in json:
+            if not isinstance(json['debuggableTypes'], list):
+                raise ParseException("Malformed domain specification: debuggableTypes for domain %s is not an array" % json['domain'])
+
+            for debuggable_types in json['debuggableTypes']:
+                if debuggable_types not in _ALLOWED_DEBUGGABLE_TYPE_STRINGS:
+                    raise ParseException('Malformed domain specification: debuggableTypes for domain %s is an unsupported string. Was: "%s", Allowed values: %s' % (json['domain'], json['debuggableTypes'], ', '.join(_ALLOWED_DEBUGGABLE_TYPE_STRINGS)))
+
+            debuggable_types = json.get('debuggableTypes')
+
+        if 'targetTypes' in json:
+            if not isinstance(json['targetTypes'], list):
+                raise ParseException("Malformed domain specification: targetTypes for domain %s is not an array" % json['domain'])
+
+            for target_types in json['targetTypes']:
+                if target_types not in _ALLOWED_TARGET_TYPE_STRINGS:
+                    raise ParseException('Malformed domain specification: targetTypes for domain %s is an unsupported string. Was: "%s", Allowed values: %s' % (json['domain'], json['targetTypes'], ', '.join(_ALLOWED_TARGET_TYPE_STRINGS)))
+
+            target_types = json.get('targetTypes')
+
+            if debuggable_types and not validate_target_types(debuggable_types, target_types):
+                raise ParseException('Malformed domain specification: domain %s has an item in targetTypes "%s" that is not supported by any value in debuggableTypes "%s".' % (json['domain'], target_types, debuggable_types))
+
         if 'version' in json:
             if not isinstance(json['version'], int):
                 raise ParseException("Malformed domain specification: version is not a number or string")
             version = json['version']
 
@@ -384,26 +430,18 @@
             types.extend([self.parse_type_declaration(declaration) for declaration in json['types']])
 
         if 'commands' in json:
             if not isinstance(json['commands'], list):
                 raise ParseException("Malformed domain specification: commands is not an array")
-            commands.extend([self.parse_command(command) for command in json['commands']])
+            commands.extend([self.parse_command(command, debuggable_types) for command in json['commands']])
 
         if 'events' in json:
             if not isinstance(json['events'], list):
                 raise ParseException("Malformed domain specification: events is not an array")
-            events.extend([self.parse_event(event) for event in json['events']])
+            events.extend([self.parse_event(event, debuggable_types) for event in json['events']])
 
-        if 'availability' in json:
-            if not isinstance(json['availability'], list):
-                raise ParseException("Malformed domain specification: availability is not an array")
-            allowed_activation_strings = set(['javascript', 'web', 'worker', 'service-worker'])
-            for availability_type in json['availability']:
-                if availability_type not in allowed_activation_strings:
-                    raise ParseException('Malformed domain specification: availability is an unsupported string. Was: "%s", Allowed values: %s' % (json['availability'], ', '.join(allowed_activation_strings)))
-
-        self.domains.append(Domain(json['domain'], json.get('description', ''), json.get('featureGuard'), json.get('availability'), isSupplemental, version, types, commands, events))
+        self.domains.append(Domain(json['domain'], json.get('description', ''), json.get('featureGuard'), debuggable_types, target_types, isSupplemental, version, types, commands, events))
 
     def parse_type_declaration(self, json):
         check_for_required_properties(['id', 'type'], json, "type")
         log.debug("parse type %s" % json['id'])
 
@@ -427,17 +465,34 @@
         log.debug("parse type member %s" % json['name'])
 
         type_ref = TypeReference(json.get('type'), json.get('$ref'), json.get('enum'), json.get('items'))
         return TypeMember(json['name'], type_ref, json.get('optional', False), json.get('description', ""))
 
-    def parse_command(self, json):
+    def parse_command(self, json, debuggable_types):
         check_for_required_properties(['name'], json, "command")
         log.debug("parse command %s" % json['name'])
 
+        target_types = None
         call_parameters = []
         return_parameters = []
 
+        if 'targetTypes' in json:
+            if not isinstance(json['targetTypes'], list):
+                raise ParseException("Malformed domain specification: targetTypes list for command %s is not an array" % json['name'])
+            target_types = json['targetTypes']
+
+            for target_type in target_types:
+                if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:
+                    raise ParseException('Malformed domain specification: targetTypes list for command %s is an unsupported string. Was: "%s", Allowed values: %s' % (json['name'], json['targetTypes'], ', '.join(_ALLOWED_TARGET_TYPE_STRINGS)))
+
+            duplicate_types = find_duplicates(target_types)
+            if len(duplicate_types) > 0:
+                raise ParseException("Malformed domain specification: targetTypes list for command %s has duplicate items" % json['name'])
+
+            if debuggable_types and not validate_target_types(debuggable_types, target_types):
+                raise ParseException('Malformed domain specification: command %s has an item in targetTypes "%s" that is not supported by any value in debuggableTypes "%s".' % (json['name'], target_types, debuggable_types))
+
         if 'parameters' in json:
             if not isinstance(json['parameters'], list):
                 raise ParseException("Malformed command specification: parameters is not an array")
             call_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json['parameters']])
 
@@ -453,29 +508,46 @@
             duplicate_names = find_duplicates([param.parameter_name for param in return_parameters])
             if len(duplicate_names) > 0:
                 raise ParseException("Malformed domain specification: return parameter list for command %s has duplicate parameter names" % json['name'])
 
         platform = Platform.fromString(json.get('platform', 'generic'))
-        return Command(json['name'], call_parameters, return_parameters, json.get('description', ""), platform, json.get('async', False))
+        return Command(json['name'], target_types, call_parameters, return_parameters, json.get('description', ""), platform, json.get('async', False))
 
-    def parse_event(self, json):
+    def parse_event(self, json, debuggable_types):
         check_for_required_properties(['name'], json, "event")
         log.debug("parse event %s" % json['name'])
 
+        target_types = None
         event_parameters = []
 
+        if 'targetTypes' in json:
+            if not isinstance(json['targetTypes'], list):
+                raise ParseException("Malformed domain specification: targetTypes for event %s is not an array" % json['name'])
+            target_types = json['targetTypes']
+
+            for target_type in target_types:
+                if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:
+                    raise ParseException('Malformed domain specification: targetTypes for event %s is an unsupported string. Was: "%s", Allowed values: %s' % (json['name'], json['targetTypes'], ', '.join(_ALLOWED_TARGET_TYPE_STRINGS)))
+
+            duplicate_types = find_duplicates(target_types)
+            if len(duplicate_types) > 0:
+                raise ParseException("Malformed domain specification: targetTypes list for event %s has duplicate items" % json['name'])
+
+            if debuggable_types and not validate_target_types(debuggable_types, target_types):
+                raise ParseException('Malformed domain specification: event %s has an item in targetTypes "%s" that is not supported by any value in debuggableTypes "%s".' % (json['name'], target_types, debuggable_types))
+
         if 'parameters' in json:
             if not isinstance(json['parameters'], list):
                 raise ParseException("Malformed event specification: parameters is not an array")
             event_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json['parameters']])
 
             duplicate_names = find_duplicates([param.parameter_name for param in event_parameters])
             if len(duplicate_names) > 0:
                 raise ParseException("Malformed domain specification: parameter list for event %s has duplicate parameter names" % json['name'])
 
         platform = Platform.fromString(json.get('platform', 'generic'))
-        return Event(json['name'], event_parameters, json.get('description', ""), platform)
+        return Event(json['name'], target_types, event_parameters, json.get('description', ""), platform)
 
     def parse_call_or_return_parameter(self, json):
         check_for_required_properties(['name'], json, "parameter")
         log.debug("parse parameter %s" % json['name'])
 
@@ -569,15 +641,16 @@
 
         raise TypecheckException("Lookup failed for type reference: %s (referenced from domain: %s)" % (type_ref.referenced_name(), domain.domain_name))
 
 
 class Domain:
-    def __init__(self, domain_name, description, feature_guard, availability, isSupplemental, version, type_declarations, commands, events):
+    def __init__(self, domain_name, description, feature_guard, debuggable_types, target_types, isSupplemental, version, type_declarations, commands, events):
         self.domain_name = domain_name
         self.description = description
         self.feature_guard = feature_guard
-        self.availability = availability
+        self.debuggable_types = debuggable_types
+        self.target_types = target_types
         self.is_supplemental = isSupplemental
         self._version = version
         self._type_declarations = type_declarations
         self._commands = commands
         self._events = events
@@ -607,11 +680,11 @@
         for event in self._events:
             event.resolve_type_references(protocol, self)
 
 
 class Domains:
-    GLOBAL = Domain("", "The global domain, in which primitive types are implicitly declared.", None, None, False, None, [], [], [])
+    GLOBAL = Domain("", "The global domain, in which primitive types are implicitly declared.", None, None, None, False, None, [], [], [])
 
 
 class TypeDeclaration:
     def __init__(self, type_name, type_ref, description, platform, type_members):
         self.type_name = type_name
@@ -659,12 +732,13 @@
         log.debug(">>> Resolving type references for parameter: %s" % self.parameter_name)
         self.type = protocol.lookup_type_reference(self.type_ref, domain)
 
 
 class Command:
-    def __init__(self, command_name, call_parameters, return_parameters, description, platform, is_async):
+    def __init__(self, command_name, target_types, call_parameters, return_parameters, description, platform, is_async):
         self.command_name = command_name
+        self.target_types = target_types
         self.call_parameters = call_parameters
         self.return_parameters = return_parameters
         self.description = description
         self.platform = platform
         self.is_async = is_async
@@ -678,12 +752,13 @@
         for parameter in self.return_parameters:
             parameter.resolve_type_references(protocol, domain)
 
 
 class Event:
-    def __init__(self, event_name, event_parameters, description, platform):
+    def __init__(self, event_name, target_types, event_parameters, description, platform):
         self.event_name = event_name
+        self.target_types = target_types
         self.event_parameters = event_parameters
         self.description = description
         self.platform = platform
 
     def resolve_type_references(self, protocol, domain):

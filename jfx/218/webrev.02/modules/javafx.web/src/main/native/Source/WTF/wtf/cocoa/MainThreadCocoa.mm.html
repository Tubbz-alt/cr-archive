<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/cocoa/MainThreadCocoa.mm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007, 2008 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer. 
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution. 
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission. 
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #import &quot;config.h&quot;
 30 #import &lt;wtf/MainThread.h&gt;
 31 
 32 #import &lt;CoreFoundation/CoreFoundation.h&gt;
 33 #import &lt;Foundation/NSThread.h&gt;
 34 #import &lt;dispatch/dispatch.h&gt;
 35 #import &lt;stdio.h&gt;
 36 #import &lt;wtf/Assertions.h&gt;
 37 #import &lt;wtf/HashSet.h&gt;
 38 #import &lt;wtf/RetainPtr.h&gt;
 39 #import &lt;wtf/SchedulePair.h&gt;
 40 #import &lt;wtf/Threading.h&gt;
 41 
 42 #if USE(WEB_THREAD)
 43 #include &lt;wtf/ios/WebCoreThread.h&gt;
 44 #endif
 45 
 46 @interface JSWTFMainThreadCaller : NSObject
 47 - (void)call;
 48 @end
 49 
 50 @implementation JSWTFMainThreadCaller
 51 
 52 - (void)call
 53 {
 54     WTF::dispatchFunctionsFromMainThread();
 55 }
 56 
 57 @end
 58 
 59 #define LOG_CHANNEL_PREFIX Log
 60 
 61 namespace WTF {
 62 
 63 #if RELEASE_LOG_DISABLED
 64 WTFLogChannel LogThreading = { WTFLogChannelState::On, &quot;Threading&quot;, WTFLogLevel::Error };
 65 #else
 66 WTFLogChannel LogThreading = { WTFLogChannelState::On, &quot;Threading&quot;, WTFLogLevel::Error, LOG_CHANNEL_WEBKIT_SUBSYSTEM, OS_LOG_DEFAULT };
 67 #endif
 68 
 69 
 70 static JSWTFMainThreadCaller* staticMainThreadCaller;
 71 static bool isTimerPosted; // This is only accessed on the main thread.
 72 
 73 #if USE(WEB_THREAD)
 74 // When the Web thread is enabled, we consider it to be the main thread, not pthread main.
 75 static pthread_t mainThreadPthread { nullptr };
 76 static NSThread* mainThreadNSThread { nullptr };
 77 
 78 static Thread* sApplicationUIThread;
 79 static Thread* sWebThread;
 80 #endif
 81 
 82 void initializeMainThreadPlatform()
 83 {
 84     if (!pthread_main_np())
 85         RELEASE_LOG_FAULT(Threading, &quot;WebKit Threading Violation - initial use of WebKit from a secondary thread.&quot;);
 86     ASSERT(pthread_main_np());
 87 
 88     ASSERT(!staticMainThreadCaller);
 89     staticMainThreadCaller = [[JSWTFMainThreadCaller alloc] init];
 90 }
 91 
 92 static void timerFired(CFRunLoopTimerRef timer, void*)
 93 {
 94     CFRelease(timer);
 95     isTimerPosted = false;
 96 
 97     @autoreleasepool {
 98         WTF::dispatchFunctionsFromMainThread();
 99     }
100 }
101 
102 static void postTimer()
103 {
104     ASSERT(isMainThread());
105 
106     if (isTimerPosted)
107         return;
108 
109     isTimerPosted = true;
110     CFRunLoopAddTimer(CFRunLoopGetCurrent(), CFRunLoopTimerCreate(0, 0, 0, 0, 0, timerFired, 0), kCFRunLoopCommonModes);
111 }
112 
113 void scheduleDispatchFunctionsOnMainThread()
114 {
115     ASSERT(staticMainThreadCaller);
116 
117 #if USE(WEB_THREAD)
118     if (isWebThread()) {
119         postTimer();
120         return;
121     }
122 
123     if (mainThreadPthread) {
124         [staticMainThreadCaller performSelector:@selector(call) onThread:mainThreadNSThread withObject:nil waitUntilDone:NO];
125         return;
126     }
127 #else
128     if (isMainThread()) {
129         postTimer();
130         return;
131     }
132 #endif
133 
134     [staticMainThreadCaller performSelectorOnMainThread:@selector(call) withObject:nil waitUntilDone:NO];
135 }
136 
137 void dispatchAsyncOnMainThreadWithWebThreadLockIfNeeded(void (^block)())
138 {
139 #if USE(WEB_THREAD)
140     if (WebCoreWebThreadIsEnabled &amp;&amp; WebCoreWebThreadIsEnabled()) {
141         dispatch_async(dispatch_get_main_queue(), ^{
142             WebCoreWebThreadLock();
143             block();
144         });
145         return;
146     }
147 #endif
148     dispatch_async(dispatch_get_main_queue(), block);
149 }
150 
151 void callOnWebThreadOrDispatchAsyncOnMainThread(void (^block)())
152 {
153 #if USE(WEB_THREAD)
154     if (WebCoreWebThreadIsEnabled &amp;&amp; WebCoreWebThreadIsEnabled()) {
155         WebCoreWebThreadRun(block);
156         return;
157     }
158 #endif
159     dispatch_async(dispatch_get_main_queue(), block);
160 }
161 
162 #if USE(WEB_THREAD)
163 
164 static bool webThreadIsUninitializedOrLockedOrDisabled()
165 {
166     return !WebCoreWebThreadIsLockedOrDisabled || WebCoreWebThreadIsLockedOrDisabled();
167 }
168 
169 bool isMainThread()
170 {
171     return (isWebThread() || pthread_main_np()) &amp;&amp; webThreadIsUninitializedOrLockedOrDisabled();
172 }
173 
174 bool isUIThread()
175 {
176     return pthread_main_np();
177 }
178 
179 // Keep in mind that isWebThread can be called even when destroying the current thread.
180 bool isWebThread()
181 {
182     return pthread_equal(pthread_self(), mainThreadPthread);
183 }
184 
185 void initializeApplicationUIThread()
186 {
187     ASSERT(pthread_main_np());
188     sApplicationUIThread = &amp;Thread::current();
189 }
190 
191 void initializeWebThread()
192 {
193     static std::once_flag initializeKey;
194     std::call_once(initializeKey, [] {
195         ASSERT(!pthread_main_np());
196         mainThreadPthread = pthread_self();
197         mainThreadNSThread = [NSThread currentThread];
198         sWebThread = &amp;Thread::current();
199     });
200 }
201 
202 bool canCurrentThreadAccessThreadLocalData(Thread&amp; thread)
203 {
204     Thread&amp; currentThread = Thread::current();
205     if (&amp;thread == &amp;currentThread)
206         return true;
207 
208     if (&amp;thread == sWebThread || &amp;thread == sApplicationUIThread)
209         return (&amp;currentThread == sWebThread || &amp;currentThread == sApplicationUIThread) &amp;&amp; webThreadIsUninitializedOrLockedOrDisabled();
210 
211     return false;
212 }
213 
214 #else
215 
216 bool isMainThread()
217 {
218     return pthread_main_np();
219 }
220 
221 #endif // USE(WEB_THREAD)
222 
223 } // namespace WTF
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/svg/SVGPathStringBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
  3  * Copyright (C) 2015 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;SVGPathStringBuilder.h&quot;
 23 
 24 #include &lt;wtf/text/WTFString.h&gt;
 25 
 26 namespace WebCore {
 27 
 28 SVGPathStringBuilder::SVGPathStringBuilder() = default;
 29 
 30 SVGPathStringBuilder::~SVGPathStringBuilder() = default;
 31 
 32 String SVGPathStringBuilder::result()
 33 {
 34     unsigned size = m_stringBuilder.length();
 35     if (!size)
 36         return String();
 37 
 38     // Remove trailing space.
 39     m_stringBuilder.resize(size - 1);
 40     return m_stringBuilder.toString();
 41 }
 42 
 43 void SVGPathStringBuilder::incrementPathSegmentCount()
 44 {
 45 }
 46 
 47 bool SVGPathStringBuilder::continueConsuming()
 48 {
 49     return true;
 50 }
 51 
 52 static void appendFlag(StringBuilder&amp; stringBuilder, bool flag)
 53 {
<a name="1" id="anc1"></a><span class="line-modified"> 54     stringBuilder.append(flag ? &#39;1&#39; : &#39;0&#39;, &#39; &#39;);</span>

 55 }
 56 
 57 static void appendNumber(StringBuilder&amp; stringBuilder, float number)
 58 {
<a name="2" id="anc2"></a><span class="line-modified"> 59     // FIXME: Shortest form would be better, but fixed precision is required for now to smooth over precision errors caused by converting float to double and back in CGPath on Cocoa platforms.</span>
<span class="line-modified"> 60     stringBuilder.append(FormattedNumber::fixedPrecision(number), &#39; &#39;);</span>
 61 }
 62 
 63 static void appendPoint(StringBuilder&amp; stringBuilder, const FloatPoint&amp; point)
 64 {
<a name="3" id="anc3"></a><span class="line-modified"> 65     appendNumber(stringBuilder, point.x());</span>
<span class="line-modified"> 66     appendNumber(stringBuilder, point.y());</span>


 67 }
 68 
 69 void SVGPathStringBuilder::moveTo(const FloatPoint&amp; targetPoint, bool, PathCoordinateMode mode)
 70 {
 71     if (mode == AbsoluteCoordinates)
 72         m_stringBuilder.appendLiteral(&quot;M &quot;);
 73     else
 74         m_stringBuilder.appendLiteral(&quot;m &quot;);
 75 
 76     appendPoint(m_stringBuilder, targetPoint);
 77 }
 78 
 79 void SVGPathStringBuilder::lineTo(const FloatPoint&amp; targetPoint, PathCoordinateMode mode)
 80 {
 81     if (mode == AbsoluteCoordinates)
 82         m_stringBuilder.appendLiteral(&quot;L &quot;);
 83     else
 84         m_stringBuilder.appendLiteral(&quot;l &quot;);
 85 
 86     appendPoint(m_stringBuilder, targetPoint);
 87 }
 88 
 89 void SVGPathStringBuilder::lineToHorizontal(float x, PathCoordinateMode mode)
 90 {
 91     if (mode == AbsoluteCoordinates)
 92         m_stringBuilder.appendLiteral(&quot;H &quot;);
 93     else
 94         m_stringBuilder.appendLiteral(&quot;h &quot;);
 95 
 96     appendNumber(m_stringBuilder, x);
 97 }
 98 
 99 void SVGPathStringBuilder::lineToVertical(float y, PathCoordinateMode mode)
100 {
101     if (mode == AbsoluteCoordinates)
102         m_stringBuilder.appendLiteral(&quot;V &quot;);
103     else
104         m_stringBuilder.appendLiteral(&quot;v &quot;);
105 
106     appendNumber(m_stringBuilder, y);
107 }
108 
109 void SVGPathStringBuilder::curveToCubic(const FloatPoint&amp; point1, const FloatPoint&amp; point2, const FloatPoint&amp; targetPoint, PathCoordinateMode mode)
110 {
111     if (mode == AbsoluteCoordinates)
112         m_stringBuilder.appendLiteral(&quot;C &quot;);
113     else
114         m_stringBuilder.appendLiteral(&quot;c &quot;);
115 
116     appendPoint(m_stringBuilder, point1);
117     appendPoint(m_stringBuilder, point2);
118     appendPoint(m_stringBuilder, targetPoint);
119 }
120 
121 void SVGPathStringBuilder::curveToCubicSmooth(const FloatPoint&amp; point2, const FloatPoint&amp; targetPoint, PathCoordinateMode mode)
122 {
123     if (mode == AbsoluteCoordinates)
124         m_stringBuilder.appendLiteral(&quot;S &quot;);
125     else
126         m_stringBuilder.appendLiteral(&quot;s &quot;);
127 
128     appendPoint(m_stringBuilder, point2);
129     appendPoint(m_stringBuilder, targetPoint);
130 }
131 
132 void SVGPathStringBuilder::curveToQuadratic(const FloatPoint&amp; point1, const FloatPoint&amp; targetPoint, PathCoordinateMode mode)
133 {
134     if (mode == AbsoluteCoordinates)
135         m_stringBuilder.appendLiteral(&quot;Q &quot;);
136     else
137         m_stringBuilder.appendLiteral(&quot;q &quot;);
138 
139     appendPoint(m_stringBuilder, point1);
140     appendPoint(m_stringBuilder, targetPoint);
141 }
142 
143 void SVGPathStringBuilder::curveToQuadraticSmooth(const FloatPoint&amp; targetPoint, PathCoordinateMode mode)
144 {
145     if (mode == AbsoluteCoordinates)
146         m_stringBuilder.appendLiteral(&quot;T &quot;);
147     else
148         m_stringBuilder.appendLiteral(&quot;t &quot;);
149 
150     appendPoint(m_stringBuilder, targetPoint);
151 }
152 
153 void SVGPathStringBuilder::arcTo(float r1, float r2, float angle, bool largeArcFlag, bool sweepFlag, const FloatPoint&amp; targetPoint, PathCoordinateMode mode)
154 {
155     if (mode == AbsoluteCoordinates)
156         m_stringBuilder.appendLiteral(&quot;A &quot;);
157     else
158         m_stringBuilder.appendLiteral(&quot;a &quot;);
159 
160     appendNumber(m_stringBuilder, r1);
161     appendNumber(m_stringBuilder, r2);
162     appendNumber(m_stringBuilder, angle);
163     appendFlag(m_stringBuilder, largeArcFlag);
164     appendFlag(m_stringBuilder, sweepFlag);
165     appendPoint(m_stringBuilder, targetPoint);
166 }
167 
168 void SVGPathStringBuilder::closePath()
169 {
170     m_stringBuilder.appendLiteral(&quot;Z &quot;);
171 }
172 
173 } // namespace WebCore
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebKitLegacy/java/WebCoreSupport/BackForwardList.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2005, 2006 Apple Inc.  All rights reserved.
  3  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;BackForwardList.h&quot;
 28 
 29 #include &lt;WebCore/BackForwardController.h&gt;
 30 #include &lt;WebCore/Frame.h&gt;
 31 #include &lt;WebCore/FrameLoader.h&gt;
 32 #include &lt;WebCore/FrameLoaderClient.h&gt;
 33 #include &lt;WebCore/HistoryItem.h&gt;
 34 #include &lt;WebCore/Logging.h&gt;
 35 #include &lt;WebCore/Page.h&gt;
 36 #include &lt;WebCore/PageCache.h&gt;
 37 #include &lt;WebCore/SerializedScriptValue.h&gt;
 38 
 39 #include &quot;BackForwardList.h&quot;
 40 #include &quot;WebPage.h&quot;
 41 #include &quot;PlatformJavaClasses.h&quot;
 42 
 43 static const unsigned DefaultCapacity = 100;
 44 static const unsigned NoCurrentItemIndex = UINT_MAX;
 45 
 46 using namespace WebCore;
 47 
 48 extern &quot;C&quot; {
 49 
 50 namespace {
 51 
 52 Page* getPage(jlong jpage)
 53 {
 54     return WebPage::pageFromJLong(jpage);
 55 }
 56 
 57 BackForwardList* getBfl(jlong jpage)
 58 {
 59     return &amp;static_cast&lt;BackForwardList&amp;&gt;(getPage(jpage)-&gt;backForward().client());
 60 }
 61 
 62 HistoryItem* getItem(jlong jitem)
 63 {
 64     return static_cast&lt;HistoryItem*&gt;(jlong_to_ptr(jitem));
 65 }
 66 
 67 jmethodID initMethod(JNIEnv* env, jclass cls, const char* name, const char* signature)
 68 {
 69     jmethodID mid = env-&gt;GetMethodID(cls, name, signature);
 70     ASSERT(mid);
 71     return mid;
 72 }
 73 
 74 jmethodID initCtor(JNIEnv* env, jclass cls, const char* signature)
 75 {
 76     return initMethod(env, cls, &quot;&lt;init&gt;&quot;, signature);
 77 }
 78 
 79 // ENTRY-RELATED METHODS
 80 
 81 jclass getJEntryClass()
 82 {
 83     JNIEnv* env = WTF::GetJavaEnv();
 84 
 85     static JGClass jEntryClass(env-&gt;FindClass(&quot;com/sun/webkit/BackForwardList$Entry&quot;));
 86     ASSERT(jEntryClass);
 87 
 88     return jEntryClass;
 89 }
 90 
 91 jclass getJBFLClass()
 92 {
 93     JNIEnv* env = WTF::GetJavaEnv();
 94 
 95     static JGClass jBFLClass(env-&gt;FindClass(&quot;com/sun/webkit/BackForwardList&quot;));
 96     ASSERT(jBFLClass);
 97 
 98     return jBFLClass;
 99 }
100 
101 static JLObject createEntry(HistoryItem* item, jlong jpage)
102 {
103 
104     JNIEnv* env = WTF::GetJavaEnv();
105     static jmethodID entryCtorMID = initCtor(env, getJEntryClass(), &quot;(JJ)V&quot;);
106 
107     JLObject jEntry(env-&gt;NewObject(getJEntryClass(), entryCtorMID, ptr_to_jlong(item), jpage));
108     WTF::CheckAndClearException(env);
109 
110     item-&gt;setHostObject(jEntry);
111 
112     return jEntry;
113 }
114 
115 void notifyHistoryItemChangedImpl(HistoryItem&amp; item) {
116     JNIEnv* env = WTF::GetJavaEnv();
117     static jmethodID notifyItemChangedMID = initMethod(env, getJEntryClass(), &quot;notifyItemChanged&quot;, &quot;()V&quot;);
118     if (item.hostObject()) {
119         env-&gt;CallVoidMethod(item.hostObject(), notifyItemChangedMID);
120         WTF::CheckAndClearException(env);
121     }
122 }
123 
124 // BACKFORWARDLIST METHODS
125 int getSize(BackForwardList* bfl)
126 {
127     int size = 0;
128     if (bfl-&gt;currentItem())
129         size = bfl-&gt;forwardListCount() + bfl-&gt;backListCount() + 1;
130     return size;
131 }
132 
133 HistoryItem* itemAtIndex(BackForwardList* bfl, int index)
134 {
135     // Note: WebKit counts from the *current* position
136     return bfl-&gt;itemAtIndex(index - bfl-&gt;backListCount()).get();
137 }
138 
139 // ChangeListener support
140 void notifyBackForwardListChanged(const JLObject &amp;host)
141 {
142     JNIEnv* env = WTF::GetJavaEnv();
143 
144     if (!host) {
145         return;
146     }
147 
148     static jmethodID notifyChangedMID = initMethod(
149         env,
150     getJBFLClass(),
151         &quot;notifyChanged&quot;,
152         &quot;()V&quot;);
153     ASSERT(notifyChangedMID);
154 
155     env-&gt;CallVoidMethod(host, notifyChangedMID);
156     WTF::CheckAndClearException(env);
157 }
158 } // namespace
159 
160 void notifyHistoryItemDestroyed(const JLObject &amp;host)
161 {
162     WC_GETJAVAENV_CHKRET(env);
163     static jmethodID notifyItemDestroyedMID =
164             initMethod(env, getJEntryClass(), &quot;notifyItemDestroyed&quot;, &quot;()V&quot;);
165     if (host) {
166         env-&gt;CallVoidMethod(host, notifyItemDestroyedMID);
167         WTF::CheckAndClearException(env);
168     }
169 }
170 
171 // entry.getURL()
172 JNIEXPORT jstring JNICALL Java_com_sun_webkit_BackForwardList_bflItemGetURL(JNIEnv* env, jclass, jlong jitem)
173 {
174     HistoryItem* item = getItem(jitem);
175     String urlString = item-&gt;urlString();
176     return urlString.toJavaString(env).releaseLocal();
177 }
178 
179 // entry.getTitle()
180 JNIEXPORT jstring JNICALL Java_com_sun_webkit_BackForwardList_bflItemGetTitle(JNIEnv* env, jclass, jlong jitem)
181 {
182     HistoryItem* item = getItem(jitem);
183     String title = item-&gt;title();
184     return title.toJavaString(env).releaseLocal();
185 }
186 
187 // entry.getIcon()
188 JNIEXPORT jobject JNICALL Java_com_sun_webkit_BackForwardList_bflItemGetIcon(JNIEnv*, jclass, jlong)
189 {
190 /*
191     HistoryItem* item = getItem(jitem);
192     if (item != nullptr) {
193     // TODO: crashes with DRT
194         return *WebCore::iconDatabase().synchronousIconForPageURL(item-&gt;url(), WebCore::IntSize(16, 16))-&gt;nativeImageForCurrentFrame();
195         Image* icon = item-&gt;icon();
196         if (icon != nullptr) {
197             return *icon-&gt;javaImage();
198         }
199     }
200 */
201     return nullptr;
202 }
203 
204 // entry.getLastVisited()
205 JNIEXPORT jlong JNICALL Java_com_sun_webkit_BackForwardList_bflItemGetLastVisitedDate(JNIEnv*, jclass, jlong)
206 {
207 //    HistoryItem* item = getItem(jitem);
208 //    double lastVisitedDate = item-&gt;lastVisitedTime();
209 //    return (jlong) (lastVisitedDate * 1000);
210     return 0; // todo tav where is lastVisitedDate field?
211 }
212 
213 // entry.isTargetItem()
214 JNIEXPORT jboolean JNICALL Java_com_sun_webkit_BackForwardList_bflItemIsTargetItem(JNIEnv*, jclass, jlong jitem)
215 {
216     HistoryItem* item = getItem(jitem);
217     return (jboolean)item-&gt;isTargetItem();
218 }
219 
220 // entry.getTarget()
221 JNIEXPORT jstring JNICALL Java_com_sun_webkit_BackForwardList_bflItemGetTarget(JNIEnv* env, jclass, jlong jitem)
222 {
223     HistoryItem* item = getItem(jitem);
224     String target = item-&gt;target();
225     if (!target.isEmpty()) {
226         return target.toJavaString(env).releaseLocal();
227     } else {
228         return nullptr;
229     }
230 }
231 
232 JNIEXPORT void JNICALL Java_com_sun_webkit_BackForwardList_bflClearBackForwardListForDRT(JNIEnv*, jclass, jlong jpage)
233 {
234     BackForwardList* bfl = getBfl(jpage);
235     RefPtr&lt;HistoryItem&gt; current = bfl-&gt;currentItem();
236     int capacity = bfl-&gt;capacity();
237     bfl-&gt;setCapacity(0);
238     bfl-&gt;setCapacity(capacity);
239     bfl-&gt;addItem(*current);
240     bfl-&gt;goToItem(*current);
241 }
242 
243 // entry.getChildren()
244 JNIEXPORT jobjectArray JNICALL Java_com_sun_webkit_BackForwardList_bflItemGetChildren(JNIEnv* env, jclass, jlong jitem, jlong jpage)
245 {
246     HistoryItem* item = getItem(jitem);
247     if (!item-&gt;hasChildren()) {
248         return nullptr;
249     }
250     jobjectArray children = env-&gt;NewObjectArray(item-&gt;children().size(), getJEntryClass(), nullptr);
251     int i = 0;
252     for (const auto&amp; it : item-&gt;children()) {
253         env-&gt;SetObjectArrayElement(children, i++, (jobject)createEntry(&amp;it.get(), jpage));
254     }
255     return children;
256 }
257 
258 // BackForwardList.size()
259 JNIEXPORT jint JNICALL Java_com_sun_webkit_BackForwardList_bflSize(JNIEnv*, jclass, jlong jpage)
260 {
261     return getSize(getBfl(jpage));
262 }
263 
264 // BackForwardList.getMaximumSize()
265 JNIEXPORT jint JNICALL Java_com_sun_webkit_BackForwardList_bflGetMaximumSize(JNIEnv*, jclass, jlong jpage)
266 {
267     BackForwardList* bfl = static_cast&lt;BackForwardList *&gt;(getBfl(jpage));
268     return bfl-&gt;capacity();
269 }
270 
271 // BackForwardList.setMaximumSize()
272 JNIEXPORT void JNICALL Java_com_sun_webkit_BackForwardList_bflSetMaximumSize(JNIEnv*, jclass, jlong jpage, jint size)
273 {
274     BackForwardList* bfl = static_cast&lt;BackForwardList *&gt;(getBfl(jpage));
275     bfl-&gt;setCapacity(size);
276 }
277 
278 // BackForwardList.getCurrentIndex()
279 JNIEXPORT jint JNICALL Java_com_sun_webkit_BackForwardList_bflGetCurrentIndex(JNIEnv*, jclass, jlong jpage)
280 {
281     BackForwardList* bfl = getBfl(jpage);
282     return bfl-&gt;currentItem() ? bfl-&gt;backListCount() : -1;
283 }
284 
285 // BackForwardList.setEnabled()
286 JNIEXPORT void JNICALL Java_com_sun_webkit_BackForwardList_bflSetEnabled(JNIEnv*, jclass, jlong jpage, jboolean flag)
287 {
288     BackForwardList* bfl = static_cast&lt;BackForwardList *&gt;(getBfl(jpage));
289     bfl-&gt;setEnabled(flag);
290 }
291 
292 // BackForwardList.isEnabled()
293 JNIEXPORT jboolean JNICALL Java_com_sun_webkit_BackForwardList_bflIsEnabled(JNIEnv*, jclass, jlong jpage)
294 {
295     BackForwardList* bfl = static_cast&lt;BackForwardList *&gt;(getBfl(jpage));
296     return bfl-&gt;enabled();
297 }
298 
299 // BackForwardList.get()
300 JNIEXPORT jobject JNICALL Java_com_sun_webkit_BackForwardList_bflGet(JNIEnv*, jclass, jlong jpage, jint index)
301 {
302     BackForwardList* bfl = getBfl(jpage);
303     HistoryItem* item = itemAtIndex(bfl, index);
304     if (!item)
305         return 0;
306     JLObject host(item-&gt;hostObject());
307     if (!host) {
308         host = createEntry(item, jpage);
309     }
310     return host.releaseLocal();
311 }
312 
313 // BackForwardList.setCurrentIndex()
314 JNIEXPORT jint JNICALL Java_com_sun_webkit_BackForwardList_bflSetCurrentIndex(JNIEnv*, jclass, jlong jpage, jint index)
315 {
316     Page* page = getPage(jpage);
317     BackForwardList* bfl = &amp;static_cast&lt;BackForwardList&amp;&gt;(page-&gt;backForward().client());
318     if (index &lt; 0 || index &gt;= getSize(bfl))
319         return -1;
320     int distance = index - bfl-&gt;backListCount();
321     page-&gt;backForward().goBackOrForward(distance);
322     return index;
323 }
324 
325 // BackForwardList.get[Last]IndexOf()
326 JNIEXPORT jint JNICALL Java_com_sun_webkit_BackForwardList_bflIndexOf(JNIEnv*, jclass, jlong jpage, jlong jitem, jboolean reverse)
327 {
328     if (!jitem)
329         return -1;
330     BackForwardList* bfl = getBfl(jpage);
331     int size = getSize(bfl);
332     int start = reverse ? size - 1 : 0;
333     int end = reverse ? -1 : size;
334     int inc = reverse ? -1 : 1;
335     HistoryItem* item = static_cast&lt;HistoryItem*&gt;(jlong_to_ptr(jitem));
336     for (int i = start; i != end; i += inc)
337         if (item == itemAtIndex(bfl, i))
338             return i;
339     return -1;
340 }
341 
342 JNIEXPORT void JNICALL Java_com_sun_webkit_BackForwardList_bflSetHostObject(JNIEnv*, jclass, jlong jpage, jobject host)
343 {
344     BackForwardList* bfl = getBfl(jpage);
345     bfl-&gt;setHostObject(JLObject(host, true));
346 
347     notifyHistoryItemChanged = notifyHistoryItemChangedImpl;
348 }
349 
350 }
351 
352 BackForwardList::BackForwardList()
353     : m_current(NoCurrentItemIndex)
354     , m_capacity(DefaultCapacity)
355     , m_closed(true)
356     , m_enabled(true)
357 {
358 }
359 
360 BackForwardList::~BackForwardList()
361 {
362     ASSERT(m_closed);
363 }
364 
365 void BackForwardList::addItem(Ref&lt;HistoryItem&gt;&amp;&amp; newItem)
366 {
367     if (!m_capacity || !m_enabled)
368         return;
369 
370     // Toss anything in the forward list
371     if (m_current != NoCurrentItemIndex) {
372         unsigned targetSize = m_current + 1;
373         while (m_entries.size() &gt; targetSize) {
374             Ref&lt;HistoryItem&gt; item = m_entries.takeLast();
375             m_entryHash.remove(item.ptr());
376             PageCache::singleton().remove(item);
377         }
378     }
379 
380     // Toss the first item if the list is getting too big, as long as we&#39;re not using it
381     // (or even if we are, if we only want 1 entry).
382     if (m_entries.size() == m_capacity &amp;&amp; (m_current || m_capacity == 1)) {
383         Ref&lt;HistoryItem&gt; item = WTFMove(m_entries[0]);
384         m_entries.remove(0);
385         m_entryHash.remove(item.ptr());
386         PageCache::singleton().remove(item);
387         --m_current;
388     }
389 
390     m_entryHash.add(newItem.ptr());
391     m_entries.insert(m_current + 1, WTFMove(newItem));
392     ++m_current;
393 
394     notifyBackForwardListChanged(m_hostObject);
395 }
396 
397 void BackForwardList::goBack()
398 {
399     ASSERT(m_current &gt; 0);
400     if (m_current &gt; 0) {
401         m_current--;
402     }
403 }
404 
405 void BackForwardList::goForward()
406 {
407     ASSERT(m_current &lt; m_entries.size() - 1);
408     if (m_current &lt; m_entries.size() - 1) {
409         m_current++;
410     }
411 }
412 
413 void BackForwardList::goToItem(HistoryItem&amp; item)
414 {
415     if (!m_entries.size())
416         return;
417 
418     unsigned int index = 0;
419     for (; index &lt; m_entries.size(); ++index)
420         if (m_entries[index].ptr() == &amp;item)
421             break;
422     if (index &lt; m_entries.size()) {
423         m_current = index;
424     }
425 
426     notifyBackForwardListChanged(m_hostObject);
427 }
428 
429 RefPtr&lt;HistoryItem&gt; BackForwardList::backItem()
430 {
431     if (m_current &amp;&amp; m_current != NoCurrentItemIndex)
432         return m_entries[m_current - 1].copyRef();
433     return nullptr;
434 }
435 
436 RefPtr&lt;HistoryItem&gt; BackForwardList::currentItem()
437 {
438     if (m_current != NoCurrentItemIndex)
439         return m_entries[m_current].copyRef();
440     return nullptr;
441 }
442 
443 RefPtr&lt;HistoryItem&gt; BackForwardList::forwardItem()
444 {
445     if (m_entries.size() &amp;&amp; m_current &lt; m_entries.size() - 1)
446         return m_entries[m_current + 1].copyRef();
447     return nullptr;
448 }
449 
450 void BackForwardList::backListWithLimit(int limit, Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; list)
451 {
452     list.clear();
453     if (m_current != NoCurrentItemIndex) {
454         unsigned first = std::max(static_cast&lt;int&gt;(m_current) - limit, 0);
455         for (; first &lt; m_current; ++first)
456             list.append(m_entries[first].get());
457     }
458 }
459 
460 void BackForwardList::forwardListWithLimit(int limit, Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; list)
461 {
462     ASSERT(limit &gt; -1);
463     list.clear();
464     if (!m_entries.size())
465         return;
466 
467     unsigned lastEntry = m_entries.size() - 1;
468     if (m_current &lt; lastEntry) {
469         int last = std::min(m_current + limit, lastEntry);
470         limit = m_current + 1;
471         for (; limit &lt;= last; ++limit)
472             list.append(m_entries[limit].get());
473     }
474 }
475 
476 int BackForwardList::capacity()
477 {
478     return m_capacity;
479 }
480 
481 void BackForwardList::setCapacity(int size)
482 {
483     while (size &lt; static_cast&lt;int&gt;(m_entries.size())) {
484         Ref&lt;HistoryItem&gt; item = m_entries.takeLast();
485         m_entryHash.remove(item.ptr());
486         PageCache::singleton().remove(item);
487     }
488 
489     if (!size)
490         m_current = NoCurrentItemIndex;
491     else if (m_current &gt; m_entries.size() - 1) {
492         m_current = m_entries.size() - 1;
493     }
494     m_capacity = size;
495 
496     notifyBackForwardListChanged(m_hostObject);
497 }
498 
499 bool BackForwardList::enabled()
500 {
501     return m_enabled;
502 }
503 
504 void BackForwardList::setEnabled(bool enabled)
505 {
506     m_enabled = enabled;
507     if (!enabled) {
508         int capacity = m_capacity;
509         setCapacity(0);
510         setCapacity(capacity);
511     }
512 }
513 
514 unsigned BackForwardList::backListCount() const
515 {
516     return m_current == NoCurrentItemIndex ? 0 : m_current;
517 }
518 
519 unsigned BackForwardList::forwardListCount() const
520 {
521     return m_current == NoCurrentItemIndex ? 0 : m_entries.size() - m_current - 1;
522 }
523 
524 RefPtr&lt;HistoryItem&gt; BackForwardList::itemAtIndex(int index)
525 {
526     // Do range checks without doing math on index to avoid overflow.
527     if (index &lt; -static_cast&lt;int&gt;(m_current))
528         return nullptr;
529 
530     if (index &gt; static_cast&lt;int&gt;(forwardListCount()))
531         return nullptr;
532 
533     return m_entries[index + m_current].copyRef();
534 }
535 
536 Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; BackForwardList::entries()
537 {
538     return m_entries;
539 }
540 
541 void BackForwardList::close()
542 {
543     m_entries.clear();
544     m_entryHash.clear();
545     m_closed = true;
546 }
547 
548 bool BackForwardList::closed()
549 {
550     return m_closed;
551 }
552 
553 void BackForwardList::removeItem(HistoryItem* item)
554 {
555     if (!item)
556         return;
557 
558     for (unsigned i = 0; i &lt; m_entries.size(); ++i) {
559         if (m_entries[i].ptr() == item) {
560             m_entries.remove(i);
561             m_entryHash.remove(item);
562             if (m_current == NoCurrentItemIndex || m_current &lt; i)
563                 break;
564             if (m_current &gt; i)
565                 m_current--;
566             else {
567                 size_t count = m_entries.size();
568                 if (m_current &gt;= count)
569                     m_current = count ? count - 1 : NoCurrentItemIndex;
570             }
571             break;
572         }
573     }
574 
575     notifyBackForwardListChanged(m_hostObject);
576 }
577 
578 bool BackForwardList::containsItem(HistoryItem* entry)
579 {
580     return m_entryHash.contains(entry);
581 }
    </pre>
  </body>
</html>
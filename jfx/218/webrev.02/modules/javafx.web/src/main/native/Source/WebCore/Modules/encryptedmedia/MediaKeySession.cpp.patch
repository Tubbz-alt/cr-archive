diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp
@@ -31,11 +31,13 @@
 
 #if ENABLE(ENCRYPTED_MEDIA)
 
 #include "CDM.h"
 #include "CDMInstance.h"
+#include "DOMPromiseProxy.h"
 #include "Document.h"
+#include "EventLoop.h"
 #include "EventNames.h"
 #include "Logging.h"
 #include "MediaKeyMessageEvent.h"
 #include "MediaKeyMessageType.h"
 #include "MediaKeyStatusMap.h"
@@ -61,16 +63,16 @@
 
 MediaKeySession::MediaKeySession(ScriptExecutionContext& context, WeakPtr<MediaKeys>&& keys, MediaKeySessionType sessionType, bool useDistinctiveIdentifier, Ref<CDM>&& implementation, Ref<CDMInstanceSession>&& instanceSession)
     : ActiveDOMObject(&context)
     , m_keys(WTFMove(keys))
     , m_expiration(std::numeric_limits<double>::quiet_NaN())
+    , m_closedPromise(makeUniqueRef<ClosedPromise>())
     , m_keyStatuses(MediaKeyStatusMap::create(*this))
     , m_useDistinctiveIdentifier(useDistinctiveIdentifier)
     , m_sessionType(sessionType)
     , m_implementation(WTFMove(implementation))
     , m_instanceSession(WTFMove(instanceSession))
-    , m_eventQueue(*this)
 {
     // https://w3c.github.io/encrypted-media/#dom-mediakeys-createsession
     // W3C Editor's Draft 09 November 2016
     // createSession(), ctd.
 
@@ -153,11 +155,11 @@
 
     // 7. Let init data be a copy of the contents of the initData parameter.
     // 8. Let session type be this object's session type.
     // 9. Let promise be a new promise.
     // 10. Run the following steps in parallel:
-    m_taskQueue.enqueueTask([this, initData = SharedBuffer::create(initData.data(), initData.length()), initDataType, promise = WTFMove(promise)] () mutable {
+    queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, initData = SharedBuffer::create(initData.data(), initData.length()), initDataType, promise = WTFMove(promise)] () mutable {
         // 10.1. If the init data is not valid for initDataType, reject promise with a newly created TypeError.
         // 10.2. Let sanitized init data be a validated and sanitized version of init data.
         RefPtr<SharedBuffer> sanitizedInitData = m_implementation->sanitizeInitData(initDataType, initData);
 
         // 10.3. If the preceding step failed, reject promise with a newly created TypeError.
@@ -222,11 +224,11 @@
                 // 10.9.5.2. Let message type reflect the type of message, either "license-request" or "individualization-request".
                 messageType = MediaKeyMessageType::IndividualizationRequest;
             }
 
             // 10.10. Queue a task to run the following steps:
-            m_taskQueue.enqueueTask([this, promise = WTFMove(promise), message = WTFMove(message), messageType, sessionId, succeeded] () mutable {
+            queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise), message = WTFMove(message), messageType, sessionId, succeeded] () mutable {
                 // 10.10.1. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
                     promise->reject(NotSupportedError);
                     return;
                 }
@@ -273,11 +275,11 @@
     // 6. Let origin be the origin of this object's Document.
     // This is retrieved in the following task.
 
     // 7. Let promise be a new promise.
     // 8. Run the following steps in parallel:
-    m_taskQueue.enqueueTask([this, sessionId, promise = WTFMove(promise)] () mutable {
+    queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, sessionId, promise = WTFMove(promise)] () mutable {
         // 8.1. Let sanitized session ID be a validated and/or sanitized version of sessionId.
         // 8.2. If the preceding step failed, or if sanitized session ID is empty, reject promise with a newly created TypeError.
         Optional<String> sanitizedSessionId = m_implementation->sanitizeSessionId(sessionId);
         if (!sanitizedSessionId || sanitizedSessionId->isEmpty()) {
             promise->reject(TypeError);
@@ -325,11 +327,11 @@
                     break;
                 }
             }
 
             // 8.9. Queue a task to run the following steps:
-            m_taskQueue.enqueueTask([this, knownKeys = WTFMove(knownKeys), expiration = WTFMove(expiration), message = WTFMove(message), sanitizedSessionId, succeeded, promise = WTFMove(promise)] () mutable {
+            queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, knownKeys = WTFMove(knownKeys), expiration = WTFMove(expiration), message = WTFMove(message), sanitizedSessionId, succeeded, promise = WTFMove(promise)] () mutable {
                 // 8.9.1. If any of the preceding steps failed, reject promise with a the appropriate error name.
                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
                     promise->reject(NotSupportedError);
                     return;
                 }
@@ -382,11 +384,11 @@
     }
 
     // 4. Let response copy be a copy of the contents of the response parameter.
     // 5. Let promise be a new promise.
     // 6. Run the following steps in parallel:
-    m_taskQueue.enqueueTask([this, response = SharedBuffer::create(response.data(), response.length()), promise = WTFMove(promise)] () mutable {
+    queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, response = SharedBuffer::create(response.data(), response.length()), promise = WTFMove(promise)] () mutable {
         // 6.1. Let sanitized response be a validated and/or sanitized version of response copy.
         RefPtr<SharedBuffer> sanitizedResponse = m_implementation->sanitizeResponse(response);
 
         // 6.2. If the preceding step failed, or if sanitized response is empty, reject promise with a newly created TypeError.
         if (!sanitizedResponse || sanitizedResponse->isEmpty()) {
@@ -433,11 +435,11 @@
 
             // 6.7.3. If a message needs to be sent to the server, execute the following steps:
             //   6.7.3.1. Let message be that message.
             //   6.7.3.2. Let message type be the appropriate MediaKeyMessageType for the message.
             // 6.8. Queue a task to run the following steps:
-            m_taskQueue.enqueueTask([this, sessionWasClosed, changedKeys = WTFMove(changedKeys), changedExpiration = WTFMove(changedExpiration), message = WTFMove(message), promise = WTFMove(promise)] () mutable {
+            queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, sessionWasClosed, changedKeys = WTFMove(changedKeys), changedExpiration = WTFMove(changedExpiration), message = WTFMove(message), promise = WTFMove(promise)] () mutable {
                 LOG(EME, "EME - updating CDM license succeeded for session %s, sending a message to the license server", m_sessionId.utf8().data());
                 // 6.8.1.
                 if (sessionWasClosed) {
                     // â†³ If session closed is true:
                     //   Run the Session Closed algorithm on this object.
@@ -510,20 +512,20 @@
         return;
     }
 
     // 4. Let promise be a new promise.
     // 5. Run the following steps in parallel:
-    m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {
+    queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {
         // 5.1. Let cdm be the CDM instance represented by session's cdm instance value.
         // 5.2. Use cdm to close the key session associated with session.
         LOG(EME, "EME - closing CDM session %s", m_sessionId.utf8().data());
         m_instanceSession->closeSession(m_sessionId, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] () mutable {
             if (!weakThis)
                 return;
 
             // 5.3. Queue a task to run the following steps:
-            m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {
+            queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {
                 // 5.3.1. Run the Session Closed algorithm on the session.
                 sessionClosed();
 
                 // 5.3.2. Resolve promise.
                 promise->resolve();
@@ -548,11 +550,11 @@
         return;
     }
 
     // 3. Let promise be a new promise.
     // 4. Run the following steps in parallel:
-    m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {
+    queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {
         // 4.1. Let cdm be the CDM instance represented by this object's cdm instance value.
         // 4.2. Let message be null.
         // 4.3. Let message type be null.
 
         // 4.4. Use the cdm to execute the following steps:
@@ -573,11 +575,11 @@
             //       4.4.1.2.3.1. Store this object's record of key usage.
             //       4.4.1.2.3.2. Let message be a message containing or reflecting this object's record of key usage.
             // NOTE: Step 4.4.1. should be implemented in CDMInstance.
 
             // 4.5. Queue a task to run the following steps:
-            m_taskQueue.enqueueTask([this, keys = WTFMove(keys), message = WTFMove(message), succeeded, promise = WTFMove(promise)] () mutable {
+            queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, keys = WTFMove(keys), message = WTFMove(message), succeeded, promise = WTFMove(promise)] () mutable {
                 // 4.5.1. Run the Update Key Statuses algorithm on the session, providing all key ID(s) in the session along with the "released" MediaKeyStatus value for each.
                 updateKeyStatuses(WTFMove(keys));
 
                 // 4.5.2. Run the Update Expiration algorithm on the session, providing NaN.
                 updateExpiration(std::numeric_limits<double>::quiet_NaN());
@@ -612,11 +614,11 @@
     // 1. Let the session be the specified MediaKeySession object.
     // 2. Queue a task to create an event named message that does not bubble and is not cancellable using the MediaKeyMessageEvent
     //    interface with its type attribute set to message and its isTrusted attribute initialized to true, and dispatch it at the
     //    session.
     auto messageEvent = MediaKeyMessageEvent::create(eventNames().messageEvent, {messageType, message.tryCreateArrayBuffer()}, Event::IsTrusted::Yes);
-    m_eventQueue.enqueueEvent(WTFMove(messageEvent));
+    queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(messageEvent));
 }
 
 void MediaKeySession::updateKeyStatuses(CDMInstanceSession::KeyStatusVector&& inputStatuses)
 {
     // https://w3c.github.io/encrypted-media/#update-key-statuses
@@ -657,14 +659,14 @@
     m_statuses.reserveCapacity(inputStatuses.size());
     for (auto& status : inputStatuses)
         m_statuses.uncheckedAppend({ WTFMove(status.first), toMediaKeyStatus(status.second) });
 
     // 5. Queue a task to fire a simple event named keystatuseschange at the session.
-    m_eventQueue.enqueueEvent(Event::create(eventNames().keystatuseschangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    queueTaskToDispatchEvent(*this, TaskSource::Networking, Event::create(eventNames().keystatuseschangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 
     // 6. Queue a task to run the Attempt to Resume Playback If Necessary algorithm on each of the media element(s) whose mediaKeys attribute is the MediaKeys object that created the session.
-    m_taskQueue.enqueueTask(
+    queueTaskKeepingObjectAlive(*this, TaskSource::Networking,
         [this] () mutable {
             if (m_keys)
                 m_keys->attemptToResumePlaybackOnClients();
         });
 }
@@ -707,11 +709,11 @@
     // Let's consider the session closed before any promise on the 'closed' attribute is resolved.
     m_closed = true;
 
     // 5. Let promise be the closed attribute of the session.
     // 6. Resolve promise.
-    m_closedPromise.resolve();
+    m_closedPromise->resolve();
 }
 
 String MediaKeySession::mediaKeysStorageDirectory() const
 {
     auto* document = downcast<Document>(scriptExecutionContext());
@@ -729,29 +731,17 @@
     return FileSystem::pathByAppendingComponent(storageDirectory, document->securityOrigin().data().databaseIdentifier());
 }
 
 bool MediaKeySession::hasPendingActivity() const
 {
-    notImplemented();
-    return false;
+    // A MediaKeySession object SHALL NOT be destroyed and SHALL continue to receive events if it is not closed and the MediaKeys object that created it remains accessible.
+    return (!m_closed && m_keys) || ActiveDOMObject::hasPendingActivity();
 }
 
 const char* MediaKeySession::activeDOMObjectName() const
 {
-    notImplemented();
     return "MediaKeySession";
 }
 
-bool MediaKeySession::canSuspendForDocumentSuspension() const
-{
-    notImplemented();
-    return false;
-}
-
-void MediaKeySession::stop()
-{
-    notImplemented();
-}
-
 } // namespace WebCore
 
 #endif

diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h
@@ -42,14 +42,15 @@
 {
     if (LIKELY(ptr != nullptr))
         ptr->deref();
 }
 
-template<typename T, typename PtrTraits>
+template<typename T, typename Traits>
 class RefPtr {
     WTF_MAKE_FAST_ALLOCATED;
 public:
+    using PtrTraits = Traits;
     typedef T ValueType;
     typedef ValueType* PtrType;
 
     static constexpr bool isRefPtr = true;
 
@@ -61,12 +62,12 @@
     ALWAYS_INLINE RefPtr(RefPtr&& o) : m_ptr(o.leakRef()) { }
     template<typename X, typename Y> RefPtr(RefPtr<X, Y>&& o) : m_ptr(o.leakRef()) { }
     template<typename X, typename Y> RefPtr(Ref<X, Y>&&);
 
     // Hash table deleted values, which are only constructed and never copied or destroyed.
-    RefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }
-    bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }
+    RefPtr(HashTableDeletedValueType) : m_ptr(PtrTraits::hashTableDeletedValue()) { }
+    bool isHashTableDeletedValue() const { return PtrTraits::isHashTableDeletedValue(m_ptr); }
 
     ALWAYS_INLINE ~RefPtr() { derefIfNotNull(PtrTraits::exchange(m_ptr, nullptr)); }
 
     T* get() const { return PtrTraits::unwrap(m_ptr); }
 
@@ -79,12 +80,12 @@
     ALWAYS_INLINE T* operator->() const { return PtrTraits::unwrap(m_ptr); }
 
     bool operator!() const { return !m_ptr; }
 
     // This conversion operator allows implicit conversion to bool but not to other integer types.
-    typedef T* (RefPtr::*UnspecifiedBoolType);
-    operator UnspecifiedBoolType() const { return m_ptr ? &RefPtr::m_ptr : nullptr; }
+    using UnspecifiedBoolType = void (RefPtr::*)() const;
+    operator UnspecifiedBoolType() const { return m_ptr ? &RefPtr::unspecifiedBoolTypeInstance : nullptr; }
 
     explicit operator bool() const { return !!m_ptr; }
 
     RefPtr& operator=(const RefPtr&);
     RefPtr& operator=(T*);
@@ -94,16 +95,16 @@
     template<typename X, typename Y> RefPtr& operator=(RefPtr<X, Y>&&);
     template<typename X> RefPtr& operator=(Ref<X>&&);
 
     template<typename X, typename Y> void swap(RefPtr<X, Y>&);
 
-    static T* hashTableDeletedValue() { return reinterpret_cast<T*>(-1); }
-
     RefPtr copyRef() && = delete;
     RefPtr copyRef() const & WARN_UNUSED_RETURN { return RefPtr(m_ptr); }
 
 private:
+    void unspecifiedBoolTypeInstance() const { }
+
     friend RefPtr adoptRef<T, PtrTraits>(T*);
     template<typename X, typename Y> friend class RefPtr;
 
     enum AdoptTag { Adopt };
     RefPtr(T* ptr, AdoptTag) : m_ptr(ptr) { }
@@ -237,11 +238,11 @@
     return RefPtr<T, U>(static_cast<T*>(p.get()));
 }
 
 template <typename T, typename U>
 struct IsSmartPtr<RefPtr<T, U>> {
-    static const bool value = true;
+    static constexpr bool value = true;
 };
 
 template<typename T, typename U>
 inline RefPtr<T, U> adoptRef(T* p)
 {

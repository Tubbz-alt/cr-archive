<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSClassRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCallbackObjectFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSClassRef.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
130     if (jsClass-&gt;m_staticValues) {
131         staticValues = makeUnique&lt;OpaqueJSClassStaticValuesTable&gt;();
132         OpaqueJSClassStaticValuesTable::const_iterator end = jsClass-&gt;m_staticValues-&gt;end();
133         for (OpaqueJSClassStaticValuesTable::const_iterator it = jsClass-&gt;m_staticValues-&gt;begin(); it != end; ++it) {
134             ASSERT(!it-&gt;key-&gt;isAtom());
135             String valueName = it-&gt;key-&gt;isolatedCopy();
136             staticValues-&gt;add(valueName.impl(), makeUnique&lt;StaticValueEntry&gt;(it-&gt;value-&gt;getProperty, it-&gt;value-&gt;setProperty, it-&gt;value-&gt;attributes, valueName));
137         }
138     }
139 
140     if (jsClass-&gt;m_staticFunctions) {
141         staticFunctions = makeUnique&lt;OpaqueJSClassStaticFunctionsTable&gt;();
142         OpaqueJSClassStaticFunctionsTable::const_iterator end = jsClass-&gt;m_staticFunctions-&gt;end();
143         for (OpaqueJSClassStaticFunctionsTable::const_iterator it = jsClass-&gt;m_staticFunctions-&gt;begin(); it != end; ++it) {
144             ASSERT(!it-&gt;key-&gt;isAtom());
145             staticFunctions-&gt;add(it-&gt;key-&gt;isolatedCopy(), makeUnique&lt;StaticFunctionEntry&gt;(it-&gt;value-&gt;callAsFunction, it-&gt;value-&gt;attributes));
146         }
147     }
148 }
149 
<span class="line-modified">150 OpaqueJSClassContextData&amp; OpaqueJSClass::contextData(ExecState* exec)</span>
151 {
<span class="line-modified">152     std::unique_ptr&lt;OpaqueJSClassContextData&gt;&amp; contextData = exec-&gt;lexicalGlobalObject()-&gt;opaqueJSClassData().add(this, nullptr).iterator-&gt;value;</span>
153     if (!contextData)
<span class="line-modified">154         contextData = makeUnique&lt;OpaqueJSClassContextData&gt;(exec-&gt;vm(), this);</span>
155     return *contextData;
156 }
157 
158 String OpaqueJSClass::className()
159 {
160     // Make a deep copy, so that the caller has no chance to put the original into AtomStringTable.
161     return m_className.isolatedCopy();
162 }
163 
<span class="line-modified">164 OpaqueJSClassStaticValuesTable* OpaqueJSClass::staticValues(JSC::ExecState* exec)</span>
165 {
<span class="line-modified">166     return contextData(exec).staticValues.get();</span>
167 }
168 
<span class="line-modified">169 OpaqueJSClassStaticFunctionsTable* OpaqueJSClass::staticFunctions(JSC::ExecState* exec)</span>
170 {
<span class="line-modified">171     return contextData(exec).staticFunctions.get();</span>
172 }
173 
<span class="line-modified">174 JSObject* OpaqueJSClass::prototype(ExecState* exec)</span>
175 {
176     /* Class (C++) and prototype (JS) inheritance are parallel, so:
177      *     (C++)      |        (JS)
178      *   ParentClass  |   ParentClassPrototype
179      *       ^        |          ^
180      *       |        |          |
181      *  DerivedClass  |  DerivedClassPrototype
182      */
183 
184     if (!prototypeClass)
185         return 0;
186 
<span class="line-modified">187     OpaqueJSClassContextData&amp; jsClassData = contextData(exec);</span>
188 
189     if (JSObject* prototype = jsClassData.cachedPrototype.get())
190         return prototype;
191 
192     // Recursive, but should be good enough for our purposes
<span class="line-modified">193     JSObject* prototype = JSCallbackObject&lt;JSDestructibleObject&gt;::create(exec, exec-&gt;lexicalGlobalObject(), exec-&gt;lexicalGlobalObject()-&gt;callbackObjectStructure(), prototypeClass, &amp;jsClassData); // set jsClassData as the object&#39;s private data, so it can clear our reference on destruction</span>
194     if (parentClass) {
<span class="line-modified">195         if (JSObject* parentPrototype = parentClass-&gt;prototype(exec))</span>
<span class="line-modified">196             prototype-&gt;setPrototypeDirect(exec-&gt;vm(), parentPrototype);</span>
197     }
198 
199     jsClassData.cachedPrototype = Weak&lt;JSObject&gt;(prototype);
200     return prototype;
201 }
</pre>
</td>
<td>
<hr />
<pre>
130     if (jsClass-&gt;m_staticValues) {
131         staticValues = makeUnique&lt;OpaqueJSClassStaticValuesTable&gt;();
132         OpaqueJSClassStaticValuesTable::const_iterator end = jsClass-&gt;m_staticValues-&gt;end();
133         for (OpaqueJSClassStaticValuesTable::const_iterator it = jsClass-&gt;m_staticValues-&gt;begin(); it != end; ++it) {
134             ASSERT(!it-&gt;key-&gt;isAtom());
135             String valueName = it-&gt;key-&gt;isolatedCopy();
136             staticValues-&gt;add(valueName.impl(), makeUnique&lt;StaticValueEntry&gt;(it-&gt;value-&gt;getProperty, it-&gt;value-&gt;setProperty, it-&gt;value-&gt;attributes, valueName));
137         }
138     }
139 
140     if (jsClass-&gt;m_staticFunctions) {
141         staticFunctions = makeUnique&lt;OpaqueJSClassStaticFunctionsTable&gt;();
142         OpaqueJSClassStaticFunctionsTable::const_iterator end = jsClass-&gt;m_staticFunctions-&gt;end();
143         for (OpaqueJSClassStaticFunctionsTable::const_iterator it = jsClass-&gt;m_staticFunctions-&gt;begin(); it != end; ++it) {
144             ASSERT(!it-&gt;key-&gt;isAtom());
145             staticFunctions-&gt;add(it-&gt;key-&gt;isolatedCopy(), makeUnique&lt;StaticFunctionEntry&gt;(it-&gt;value-&gt;callAsFunction, it-&gt;value-&gt;attributes));
146         }
147     }
148 }
149 
<span class="line-modified">150 OpaqueJSClassContextData&amp; OpaqueJSClass::contextData(JSGlobalObject* globalObject)</span>
151 {
<span class="line-modified">152     std::unique_ptr&lt;OpaqueJSClassContextData&gt;&amp; contextData = globalObject-&gt;opaqueJSClassData().add(this, nullptr).iterator-&gt;value;</span>
153     if (!contextData)
<span class="line-modified">154         contextData = makeUnique&lt;OpaqueJSClassContextData&gt;(globalObject-&gt;vm(), this);</span>
155     return *contextData;
156 }
157 
158 String OpaqueJSClass::className()
159 {
160     // Make a deep copy, so that the caller has no chance to put the original into AtomStringTable.
161     return m_className.isolatedCopy();
162 }
163 
<span class="line-modified">164 OpaqueJSClassStaticValuesTable* OpaqueJSClass::staticValues(JSC::JSGlobalObject* globalObject)</span>
165 {
<span class="line-modified">166     return contextData(globalObject).staticValues.get();</span>
167 }
168 
<span class="line-modified">169 OpaqueJSClassStaticFunctionsTable* OpaqueJSClass::staticFunctions(JSC::JSGlobalObject* globalObject)</span>
170 {
<span class="line-modified">171     return contextData(globalObject).staticFunctions.get();</span>
172 }
173 
<span class="line-modified">174 JSObject* OpaqueJSClass::prototype(JSGlobalObject* globalObject)</span>
175 {
176     /* Class (C++) and prototype (JS) inheritance are parallel, so:
177      *     (C++)      |        (JS)
178      *   ParentClass  |   ParentClassPrototype
179      *       ^        |          ^
180      *       |        |          |
181      *  DerivedClass  |  DerivedClassPrototype
182      */
183 
184     if (!prototypeClass)
185         return 0;
186 
<span class="line-modified">187     OpaqueJSClassContextData&amp; jsClassData = contextData(globalObject);</span>
188 
189     if (JSObject* prototype = jsClassData.cachedPrototype.get())
190         return prototype;
191 
192     // Recursive, but should be good enough for our purposes
<span class="line-modified">193     JSObject* prototype = JSCallbackObject&lt;JSNonFinalObject&gt;::create(globalObject, globalObject-&gt;callbackObjectStructure(), prototypeClass, &amp;jsClassData); // set jsClassData as the object&#39;s private data, so it can clear our reference on destruction</span>
194     if (parentClass) {
<span class="line-modified">195         if (JSObject* parentPrototype = parentClass-&gt;prototype(globalObject))</span>
<span class="line-modified">196             prototype-&gt;setPrototypeDirect(globalObject-&gt;vm(), parentPrototype);</span>
197     }
198 
199     jsClassData.cachedPrototype = Weak&lt;JSObject&gt;(prototype);
200     return prototype;
201 }
</pre>
</td>
</tr>
</table>
<center><a href="JSCallbackObjectFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.cpp
@@ -112,38 +112,32 @@
     return { };
 }
 #endif
 
 #if !(USE(CG) || USE(DIRECT2D))
-
-FloatSize ImageBuffer::sizeForDestinationSize(FloatSize size) const
-{
-    return size;
-}
-
 void ImageBuffer::transformColorSpace(ColorSpace srcColorSpace, ColorSpace dstColorSpace)
 {
     if (srcColorSpace == dstColorSpace)
         return;
 
     // only sRGB <-> linearRGB are supported at the moment
-    if ((srcColorSpace != ColorSpaceLinearRGB && srcColorSpace != ColorSpaceSRGB)
-        || (dstColorSpace != ColorSpaceLinearRGB && dstColorSpace != ColorSpaceSRGB))
+    if ((srcColorSpace != ColorSpace::LinearRGB && srcColorSpace != ColorSpace::SRGB)
+        || (dstColorSpace != ColorSpace::LinearRGB && dstColorSpace != ColorSpace::SRGB))
         return;
 
-    if (dstColorSpace == ColorSpaceLinearRGB) {
+    if (dstColorSpace == ColorSpace::LinearRGB) {
         static const std::array<uint8_t, 256> linearRgbLUT = [] {
             std::array<uint8_t, 256> array;
             for (unsigned i = 0; i < 256; i++) {
                 float color = i / 255.0f;
                 color = sRGBToLinearColorComponent(color);
                 array[i] = static_cast<uint8_t>(round(color * 255));
             }
             return array;
         }();
         platformTransformColorSpace(linearRgbLUT);
-    } else if (dstColorSpace == ColorSpaceSRGB) {
+    } else if (dstColorSpace == ColorSpace::SRGB) {
         static const std::array<uint8_t, 256> deviceRgbLUT= [] {
             std::array<uint8_t, 256> array;
             for (unsigned i = 0; i < 256; i++) {
                 float color = i / 255.0f;
                 color = linearToSRGBColorComponent(color);
@@ -189,11 +183,11 @@
 PlatformLayer* ImageBuffer::platformLayer() const
 {
     return 0;
 }
 
-bool ImageBuffer::copyToPlatformTexture(GraphicsContext3D&, GC3Denum, Platform3DObject, GC3Denum, bool, bool)
+bool ImageBuffer::copyToPlatformTexture(GraphicsContextGLOpenGL&, GCGLenum, PlatformGLObject, GCGLenum, bool, bool)
 {
     return false;
 }
 #endif
 
@@ -242,15 +236,10 @@
     // Enlarge the buffer size if the context's transform is scaling it so we need a higher
     // resolution than one pixel per unit.
     return expandedIntSize(size * context.scaleFactor());
 }
 
-bool ImageBuffer::isCompatibleWithContext(const GraphicsContext& context) const
-{
-    return areEssentiallyEqual(context.scaleFactor(), this->context().scaleFactor());
-}
-
 #if !USE(IOSURFACE_CANVAS_BACKING_STORE)
 size_t ImageBuffer::memoryCost() const
 {
     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful about what data we access here and how.
     // It's safe to access internalSize() because it doesn't do any pointer chasing.

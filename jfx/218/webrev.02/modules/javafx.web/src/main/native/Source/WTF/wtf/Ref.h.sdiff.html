<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Ref.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RAMSize.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RefCounted.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Ref.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/DumbPtrTraits.h&gt;
 30 #include &lt;wtf/Forward.h&gt;
 31 #include &lt;wtf/GetPtr.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
 33 #include &lt;wtf/TypeCasts.h&gt;
 34 
 35 #if ASAN_ENABLED
 36 extern &quot;C&quot; void __asan_poison_memory_region(void const volatile *addr, size_t size);
 37 extern &quot;C&quot; void __asan_unpoison_memory_region(void const volatile *addr, size_t size);
 38 extern &quot;C&quot; int __asan_address_is_poisoned(void const volatile *addr);
 39 #endif
 40 
 41 namespace WTF {
 42 
 43 inline void adopted(const void*) { }
 44 
 45 template&lt;typename T, typename PtrTraits&gt; class Ref;
 46 template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt; Ref&lt;T, PtrTraits&gt; adoptRef(T&amp;);
 47 
<span class="line-modified"> 48 template&lt;typename T, typename PtrTraits&gt;</span>
 49 class Ref {
 50 public:

 51     static constexpr bool isRef = true;
 52 
 53     ~Ref()
 54     {
 55 #if ASAN_ENABLED
 56         if (__asan_address_is_poisoned(this))
 57             __asan_unpoison_memory_region(this, sizeof(*this));
 58 #endif
 59         if (m_ptr)
 60             PtrTraits::unwrap(m_ptr)-&gt;deref();
 61     }
 62 
 63     Ref(T&amp; object)
 64         : m_ptr(&amp;object)
 65     {
 66         object.ref();
 67     }
 68 
 69     // Use copyRef() instead.
 70     Ref(const Ref&amp; other) = delete;
</pre>
<hr />
<pre>
 77     }
 78 
 79     template&lt;typename X, typename Y&gt;
 80     Ref(Ref&lt;X, Y&gt;&amp;&amp; other)
 81         : m_ptr(&amp;other.leakRef())
 82     {
 83         ASSERT(m_ptr);
 84     }
 85 
 86     Ref&amp; operator=(T&amp;);
 87     Ref&amp; operator=(Ref&amp;&amp;);
 88     template&lt;typename X, typename Y&gt; Ref&amp; operator=(Ref&lt;X, Y&gt;&amp;&amp;);
 89 
 90     // Use copyRef() and the move assignment operators instead.
 91     Ref&amp; operator=(const Ref&amp;) = delete;
 92     template&lt;typename X, typename Y&gt; Ref&amp; operator=(const Ref&lt;X, Y&gt;&amp;) = delete;
 93 
 94     template&lt;typename X, typename Y&gt; void swap(Ref&lt;X, Y&gt;&amp;);
 95 
 96     // Hash table deleted values, which are only constructed and never copied or destroyed.
<span class="line-modified"> 97     Ref(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }</span>
<span class="line-modified"> 98     bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }</span>
<span class="line-removed"> 99     static T* hashTableDeletedValue() { return reinterpret_cast&lt;T*&gt;(-1); }</span>
100 
101     Ref(HashTableEmptyValueType) : m_ptr(hashTableEmptyValue()) { }
102     bool isHashTableEmptyValue() const { return m_ptr == hashTableEmptyValue(); }
103     static T* hashTableEmptyValue() { return nullptr; }
104 
105     const T* ptrAllowingHashTableEmptyValue() const { ASSERT(m_ptr || isHashTableEmptyValue()); return PtrTraits::unwrap(m_ptr); }
106     T* ptrAllowingHashTableEmptyValue() { ASSERT(m_ptr || isHashTableEmptyValue()); return PtrTraits::unwrap(m_ptr); }
107 
108     void assignToHashTableEmptyValue(Ref&amp;&amp; reference)
109     {
110 #if ASAN_ENABLED
111         if (__asan_address_is_poisoned(this))
112             __asan_unpoison_memory_region(this, sizeof(*this));
113 #endif
114         ASSERT(m_ptr == hashTableEmptyValue());
115         m_ptr = &amp;reference.leakRef();
116         ASSERT(m_ptr);
117     }
118 
119     T* operator-&gt;() const { ASSERT(m_ptr); return PtrTraits::unwrap(m_ptr); }
</pre>
<hr />
<pre>
222 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
223 inline Ref&lt;T, U&gt; static_reference_cast(Ref&lt;X, Y&gt;&amp;&amp; reference)
224 {
225     return adoptRef(static_cast&lt;T&amp;&gt;(reference.leakRef()));
226 }
227 
228 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
229 inline Ref&lt;T, U&gt; static_reference_cast(const Ref&lt;X, Y&gt;&amp; reference)
230 {
231     return Ref&lt;T, U&gt;(static_cast&lt;T&amp;&gt;(reference.copyRef().get()));
232 }
233 
234 template &lt;typename T, typename U&gt;
235 struct GetPtrHelper&lt;Ref&lt;T, U&gt;&gt; {
236     typedef T* PtrType;
237     static T* getPtr(const Ref&lt;T, U&gt;&amp; p) { return const_cast&lt;T*&gt;(p.ptr()); }
238 };
239 
240 template &lt;typename T, typename U&gt;
241 struct IsSmartPtr&lt;Ref&lt;T, U&gt;&gt; {
<span class="line-modified">242     static const bool value = true;</span>
243 };
244 
245 template&lt;typename T, typename U&gt;
246 inline Ref&lt;T, U&gt; adoptRef(T&amp; reference)
247 {
248     adopted(&amp;reference);
249     return Ref&lt;T, U&gt;(reference, Ref&lt;T, U&gt;::Adopt);
250 }
251 
252 template&lt;typename T&gt;
253 inline Ref&lt;T&gt; makeRef(T&amp; reference)
254 {
255     return Ref&lt;T&gt;(reference);
256 }
257 
258 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
259 inline bool is(Ref&lt;ArgType, PtrTraits&gt;&amp; source)
260 {
261     return is&lt;ExpectedType&gt;(source.get());
262 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/DumbPtrTraits.h&gt;
 30 #include &lt;wtf/Forward.h&gt;
 31 #include &lt;wtf/GetPtr.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
 33 #include &lt;wtf/TypeCasts.h&gt;
 34 
 35 #if ASAN_ENABLED
 36 extern &quot;C&quot; void __asan_poison_memory_region(void const volatile *addr, size_t size);
 37 extern &quot;C&quot; void __asan_unpoison_memory_region(void const volatile *addr, size_t size);
 38 extern &quot;C&quot; int __asan_address_is_poisoned(void const volatile *addr);
 39 #endif
 40 
 41 namespace WTF {
 42 
 43 inline void adopted(const void*) { }
 44 
 45 template&lt;typename T, typename PtrTraits&gt; class Ref;
 46 template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt; Ref&lt;T, PtrTraits&gt; adoptRef(T&amp;);
 47 
<span class="line-modified"> 48 template&lt;typename T, typename Traits&gt;</span>
 49 class Ref {
 50 public:
<span class="line-added"> 51     using PtrTraits = Traits;</span>
 52     static constexpr bool isRef = true;
 53 
 54     ~Ref()
 55     {
 56 #if ASAN_ENABLED
 57         if (__asan_address_is_poisoned(this))
 58             __asan_unpoison_memory_region(this, sizeof(*this));
 59 #endif
 60         if (m_ptr)
 61             PtrTraits::unwrap(m_ptr)-&gt;deref();
 62     }
 63 
 64     Ref(T&amp; object)
 65         : m_ptr(&amp;object)
 66     {
 67         object.ref();
 68     }
 69 
 70     // Use copyRef() instead.
 71     Ref(const Ref&amp; other) = delete;
</pre>
<hr />
<pre>
 78     }
 79 
 80     template&lt;typename X, typename Y&gt;
 81     Ref(Ref&lt;X, Y&gt;&amp;&amp; other)
 82         : m_ptr(&amp;other.leakRef())
 83     {
 84         ASSERT(m_ptr);
 85     }
 86 
 87     Ref&amp; operator=(T&amp;);
 88     Ref&amp; operator=(Ref&amp;&amp;);
 89     template&lt;typename X, typename Y&gt; Ref&amp; operator=(Ref&lt;X, Y&gt;&amp;&amp;);
 90 
 91     // Use copyRef() and the move assignment operators instead.
 92     Ref&amp; operator=(const Ref&amp;) = delete;
 93     template&lt;typename X, typename Y&gt; Ref&amp; operator=(const Ref&lt;X, Y&gt;&amp;) = delete;
 94 
 95     template&lt;typename X, typename Y&gt; void swap(Ref&lt;X, Y&gt;&amp;);
 96 
 97     // Hash table deleted values, which are only constructed and never copied or destroyed.
<span class="line-modified"> 98     Ref(HashTableDeletedValueType) : m_ptr(PtrTraits::hashTableDeletedValue()) { }</span>
<span class="line-modified"> 99     bool isHashTableDeletedValue() const { return PtrTraits::isHashTableDeletedValue(m_ptr); }</span>

100 
101     Ref(HashTableEmptyValueType) : m_ptr(hashTableEmptyValue()) { }
102     bool isHashTableEmptyValue() const { return m_ptr == hashTableEmptyValue(); }
103     static T* hashTableEmptyValue() { return nullptr; }
104 
105     const T* ptrAllowingHashTableEmptyValue() const { ASSERT(m_ptr || isHashTableEmptyValue()); return PtrTraits::unwrap(m_ptr); }
106     T* ptrAllowingHashTableEmptyValue() { ASSERT(m_ptr || isHashTableEmptyValue()); return PtrTraits::unwrap(m_ptr); }
107 
108     void assignToHashTableEmptyValue(Ref&amp;&amp; reference)
109     {
110 #if ASAN_ENABLED
111         if (__asan_address_is_poisoned(this))
112             __asan_unpoison_memory_region(this, sizeof(*this));
113 #endif
114         ASSERT(m_ptr == hashTableEmptyValue());
115         m_ptr = &amp;reference.leakRef();
116         ASSERT(m_ptr);
117     }
118 
119     T* operator-&gt;() const { ASSERT(m_ptr); return PtrTraits::unwrap(m_ptr); }
</pre>
<hr />
<pre>
222 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
223 inline Ref&lt;T, U&gt; static_reference_cast(Ref&lt;X, Y&gt;&amp;&amp; reference)
224 {
225     return adoptRef(static_cast&lt;T&amp;&gt;(reference.leakRef()));
226 }
227 
228 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
229 inline Ref&lt;T, U&gt; static_reference_cast(const Ref&lt;X, Y&gt;&amp; reference)
230 {
231     return Ref&lt;T, U&gt;(static_cast&lt;T&amp;&gt;(reference.copyRef().get()));
232 }
233 
234 template &lt;typename T, typename U&gt;
235 struct GetPtrHelper&lt;Ref&lt;T, U&gt;&gt; {
236     typedef T* PtrType;
237     static T* getPtr(const Ref&lt;T, U&gt;&amp; p) { return const_cast&lt;T*&gt;(p.ptr()); }
238 };
239 
240 template &lt;typename T, typename U&gt;
241 struct IsSmartPtr&lt;Ref&lt;T, U&gt;&gt; {
<span class="line-modified">242     static constexpr bool value = true;</span>
243 };
244 
245 template&lt;typename T, typename U&gt;
246 inline Ref&lt;T, U&gt; adoptRef(T&amp; reference)
247 {
248     adopted(&amp;reference);
249     return Ref&lt;T, U&gt;(reference, Ref&lt;T, U&gt;::Adopt);
250 }
251 
252 template&lt;typename T&gt;
253 inline Ref&lt;T&gt; makeRef(T&amp; reference)
254 {
255     return Ref&lt;T&gt;(reference);
256 }
257 
258 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
259 inline bool is(Ref&lt;ArgType, PtrTraits&gt;&amp; source)
260 {
261     return is&lt;ExpectedType&gt;(source.get());
262 }
</pre>
</td>
</tr>
</table>
<center><a href="RAMSize.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RefCounted.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
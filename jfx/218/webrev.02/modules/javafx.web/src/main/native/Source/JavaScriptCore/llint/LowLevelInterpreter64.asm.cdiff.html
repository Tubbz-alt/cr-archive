<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LowLevelInterpreter32_64.asm.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../offlineasm/arm.rb.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,51 ***</span>
  # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  # THE POSSIBILITY OF SUCH DAMAGE.
  
  
  # Utilities.
<span class="line-modified">! </span>
<span class="line-modified">! macro nextInstruction()</span>
<span class="line-removed">-     loadb [PB, PC, 1], t0</span>
<span class="line-removed">-     leap _g_opcodeMap, t1</span>
<span class="line-removed">-     jmp [t1, t0, PtrSize], BytecodePtrTag</span>
<span class="line-removed">- end</span>
<span class="line-removed">- </span>
<span class="line-removed">- macro nextInstructionWide16()</span>
<span class="line-removed">-     loadh 1[PB, PC, 1], t0</span>
<span class="line-removed">-     leap _g_opcodeMapWide16, t1</span>
<span class="line-removed">-     jmp [t1, t0, PtrSize], BytecodePtrTag</span>
  end
  
<span class="line-modified">! macro nextInstructionWide32()</span>
<span class="line-modified">!     loadi 1[PB, PC, 1], t0</span>
<span class="line-removed">-     leap _g_opcodeMapWide32, t1</span>
<span class="line-removed">-     jmp [t1, t0, PtrSize], BytecodePtrTag</span>
  end
  
  macro getuOperandNarrow(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadb constexpr %opcodeStruct%_%fieldName%_index[PB, PC, 1], dst</span>
  end
  
  macro getOperandNarrow(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadbsq constexpr %opcodeStruct%_%fieldName%_index[PB, PC, 1], dst</span>
  end
  
  macro getuOperandWide16(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadh constexpr %opcodeStruct%_%fieldName%_index * 2 + 1[PB, PC, 1], dst</span>
  end
  
  macro getOperandWide16(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadhsq constexpr %opcodeStruct%_%fieldName%_index * 2 + 1[PB, PC, 1], dst</span>
  end
  
  macro getuOperandWide32(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadi constexpr %opcodeStruct%_%fieldName%_index * 4 + 1[PB, PC, 1], dst</span>
  end
  
  macro getOperandWide32(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadis constexpr %opcodeStruct%_%fieldName%_index * 4 + 1[PB, PC, 1], dst</span>
  end
  
  macro makeReturn(get, dispatch, fn)
      fn(macro (value)
          move value, t2
<span class="line-new-header">--- 21,40 ---</span>
  # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  # THE POSSIBILITY OF SUCH DAMAGE.
  
  
  # Utilities.
<span class="line-modified">! macro storePC()</span>
<span class="line-modified">!     storei PC, LLIntReturnPC[cfr]</span>
  end
  
<span class="line-modified">! macro loadPC()</span>
<span class="line-modified">!     loadi LLIntReturnPC[cfr], PC</span>
  end
  
  macro getuOperandNarrow(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadb constexpr %opcodeStruct%_%fieldName%_index + OpcodeIDNarrowSize[PB, PC, 1], dst</span>
  end
  
  macro getOperandNarrow(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadbsq constexpr %opcodeStruct%_%fieldName%_index + OpcodeIDNarrowSize[PB, PC, 1], dst</span>
  end
  
  macro getuOperandWide16(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadh constexpr %opcodeStruct%_%fieldName%_index * 2 + OpcodeIDWide16Size[PB, PC, 1], dst</span>
  end
  
  macro getOperandWide16(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadhsq constexpr %opcodeStruct%_%fieldName%_index * 2 + OpcodeIDWide16Size[PB, PC, 1], dst</span>
  end
  
  macro getuOperandWide32(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadi constexpr %opcodeStruct%_%fieldName%_index * 4 + OpcodeIDWide32Size[PB, PC, 1], dst</span>
  end
  
  macro getOperandWide32(opcodeStruct, fieldName, dst)
<span class="line-modified">!     loadis constexpr %opcodeStruct%_%fieldName%_index * 4 + OpcodeIDWide32Size[PB, PC, 1], dst</span>
  end
  
  macro makeReturn(get, dispatch, fn)
      fn(macro (value)
          move value, t2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,12 ***</span>
  
  macro valueProfile(opcodeStruct, metadata, value)
      storeq value, %opcodeStruct%::Metadata::m_profile.m_buckets[metadata]
  end
  
  macro dispatchAfterCall(size, opcodeStruct, dispatch)
<span class="line-modified">!     loadi ArgumentCount + TagOffset[cfr], PC</span>
      loadp CodeBlock[cfr], PB
      loadp CodeBlock::m_instructionsRawPointer[PB], PB
      get(size, opcodeStruct, m_dst, t1)
      storeq r0, [cfr, t1, 8]
      metadata(size, opcodeStruct, t2, t1)
<span class="line-new-header">--- 77,13 ---</span>
  
  macro valueProfile(opcodeStruct, metadata, value)
      storeq value, %opcodeStruct%::Metadata::m_profile.m_buckets[metadata]
  end
  
<span class="line-added">+ # After calling, calling bytecode is claiming input registers are not used.</span>
  macro dispatchAfterCall(size, opcodeStruct, dispatch)
<span class="line-modified">!     loadPC()</span>
      loadp CodeBlock[cfr], PB
      loadp CodeBlock::m_instructionsRawPointer[PB], PB
      get(size, opcodeStruct, m_dst, t1)
      storeq r0, [cfr, t1, 8]
      metadata(size, opcodeStruct, t2, t1)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,11 ***</span>
  .stackHeightOK:
      move t3, sp
      move (constexpr ProtoCallFrame::numberOfRegisters), t3
  
  .copyHeaderLoop:
<span class="line-modified">!     # Copy the CodeBlock/Callee/ArgumentCount/|this| from protoCallFrame into the callee frame.</span>
      subi 1, t3
      loadq [protoCallFrame, t3, 8], extraTempReg
      storeq extraTempReg, CodeBlock[sp, t3, 8]
      btinz t3, .copyHeaderLoop
  
<span class="line-new-header">--- 204,11 ---</span>
  .stackHeightOK:
      move t3, sp
      move (constexpr ProtoCallFrame::numberOfRegisters), t3
  
  .copyHeaderLoop:
<span class="line-modified">!     # Copy the CodeBlock/Callee/ArgumentCountIncludingThis/|this| from protoCallFrame into the callee frame.</span>
      subi 1, t3
      loadq [protoCallFrame, t3, 8], extraTempReg
      storeq extraTempReg, CodeBlock[sp, t3, 8]
      btinz t3, .copyHeaderLoop
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
      end
      storep cfr, VM::topEntryFrame[vm]
  
      checkStackPointerAlignment(extraTempReg, 0xbad0dc02)
  
<span class="line-modified">!     makeCall(entry, t3, t4)</span>
  
      # We may have just made a call into a JS function, so we can&#39;t rely on sp
      # for anything but the fact that our own locals (ie the VMEntryRecord) are
      # not below it. It also still has to be aligned, though.
      checkStackPointerAlignment(t2, 0xbad0dc03)
<span class="line-new-header">--- 243,11 ---</span>
      end
      storep cfr, VM::topEntryFrame[vm]
  
      checkStackPointerAlignment(extraTempReg, 0xbad0dc02)
  
<span class="line-modified">!     makeCall(entry, protoCallFrame, t3, t4)</span>
  
      # We may have just made a call into a JS function, so we can&#39;t rely on sp
      # for anything but the fact that our own locals (ie the VMEntryRecord) are
      # not below it. It also still has to be aligned, though.
      checkStackPointerAlignment(t2, 0xbad0dc03)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,41 ***</span>
      functionEpilogue()
      ret
  end
  
  
<span class="line-modified">! macro makeJavaScriptCall(entry, temp, unused)</span>
      addp 16, sp
      if C_LOOP or C_LOOP_WIN
          cloopCallJSFunction entry
      else
          call entry, JSEntryPtrTag
      end
      subp 16, sp
  end
  
<span class="line-modified">! macro makeHostFunctionCall(entry, temp, unused)</span>
<span class="line-modified">!     move entry, temp</span>
      storep cfr, [sp]
<span class="line-modified">!     move sp, a0</span>
      if C_LOOP or C_LOOP_WIN
          storep lr, 8[sp]
<span class="line-modified">!         cloopCallNative temp</span>
      elsif X86_64_WIN
          # We need to allocate 32 bytes on the stack for the shadow space.
          subp 32, sp
<span class="line-modified">!         call temp, JSEntryPtrTag</span>
          addp 32, sp
      else
<span class="line-modified">!         call temp, JSEntryPtrTag</span>
      end
  end
  
  op(handleUncaughtException, macro ()
      loadp Callee[cfr], t3
<span class="line-modified">!     andp MarkedBlockMask, t3</span>
<span class="line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
      restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
      storep 0, VM::callFrameForCatch[t3]
  
      loadp VM::topEntryFrame[t3], cfr
      vmEntryRecord(cfr, t2)
<span class="line-new-header">--- 285,43 ---</span>
      functionEpilogue()
      ret
  end
  
  
<span class="line-modified">! # a0, a2, t3, t4</span>
<span class="line-added">+ macro makeJavaScriptCall(entry, protoCallFrame, temp1, temp2)</span>
      addp 16, sp
      if C_LOOP or C_LOOP_WIN
          cloopCallJSFunction entry
      else
          call entry, JSEntryPtrTag
      end
      subp 16, sp
  end
  
<span class="line-modified">! # a0, a2, t3, t4</span>
<span class="line-modified">! macro makeHostFunctionCall(entry, protoCallFrame, temp1, temp2)</span>
<span class="line-added">+     move entry, temp1</span>
      storep cfr, [sp]
<span class="line-modified">!     loadp ProtoCallFrame::globalObject[protoCallFrame], a0</span>
<span class="line-added">+     move sp, a1</span>
      if C_LOOP or C_LOOP_WIN
          storep lr, 8[sp]
<span class="line-modified">!         cloopCallNative temp1</span>
      elsif X86_64_WIN
          # We need to allocate 32 bytes on the stack for the shadow space.
          subp 32, sp
<span class="line-modified">!         call temp1, JSEntryPtrTag</span>
          addp 32, sp
      else
<span class="line-modified">!         call temp1, JSEntryPtrTag</span>
      end
  end
  
  op(handleUncaughtException, macro ()
      loadp Callee[cfr], t3
<span class="line-modified">!     convertCalleeToVM(t3)</span>
      restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
      storep 0, VM::callFrameForCatch[t3]
  
      loadp VM::topEntryFrame[t3], cfr
      vmEntryRecord(cfr, t2)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,44 ***</span>
      move PC, a1
      cCall4(_llint_trace_value)
      restoreStateAfterCCall()
  end
  
<span class="line-modified">! # Call a slow path for call call opcodes.</span>
  macro callCallSlowPath(slowPath, action)
<span class="line-modified">!     storei PC, ArgumentCount + TagOffset[cfr]</span>
      prepareStateForCCall()
      move cfr, a0
      move PC, a1
      cCall2(slowPath)
      action(r0, r1)
  end
  
  macro callTrapHandler(throwHandler)
<span class="line-modified">!     storei PC, ArgumentCount + TagOffset[cfr]</span>
      prepareStateForCCall()
      move cfr, a0
      move PC, a1
      cCall2(_llint_slow_path_handle_traps)
      btpnz r0, throwHandler
<span class="line-modified">!     loadi ArgumentCount + TagOffset[cfr], PC</span>
  end
  
  macro checkSwitchToJITForLoop()
      checkSwitchToJIT(
          1,
          macro()
<span class="line-modified">!             storei PC, ArgumentCount + TagOffset[cfr]</span>
              prepareStateForCCall()
              move cfr, a0
              move PC, a1
              cCall2(_llint_loop_osr)
              btpz r0, .recover
              move r1, sp
              jmp r0, JSEntryPtrTag
          .recover:
<span class="line-modified">!             loadi ArgumentCount + TagOffset[cfr], PC</span>
          end)
  end
  
  macro cage(basePtr, mask, ptr, scratch)
      if GIGACAGE_ENABLED and not (C_LOOP or C_LOOP_WIN)
<span class="line-new-header">--- 375,44 ---</span>
      move PC, a1
      cCall4(_llint_trace_value)
      restoreStateAfterCCall()
  end
  
<span class="line-modified">! # Call a slow path for call opcodes.</span>
  macro callCallSlowPath(slowPath, action)
<span class="line-modified">!     storePC()</span>
      prepareStateForCCall()
      move cfr, a0
      move PC, a1
      cCall2(slowPath)
      action(r0, r1)
  end
  
  macro callTrapHandler(throwHandler)
<span class="line-modified">!     storePC()</span>
      prepareStateForCCall()
      move cfr, a0
      move PC, a1
      cCall2(_llint_slow_path_handle_traps)
      btpnz r0, throwHandler
<span class="line-modified">!     loadi LLIntReturnPC[cfr], PC</span>
  end
  
  macro checkSwitchToJITForLoop()
      checkSwitchToJIT(
          1,
          macro()
<span class="line-modified">!             storePC()</span>
              prepareStateForCCall()
              move cfr, a0
              move PC, a1
              cCall2(_llint_loop_osr)
              btpz r0, .recover
              move r1, sp
              jmp r0, JSEntryPtrTag
          .recover:
<span class="line-modified">!             loadPC()</span>
          end)
  end
  
  macro cage(basePtr, mask, ptr, scratch)
      if GIGACAGE_ENABLED and not (C_LOOP or C_LOOP_WIN)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,11 ***</span>
          move ptr, scratch2
      else
          const source = ptr
      end
      if GIGACAGE_ENABLED
<span class="line-modified">!         cage(_g_gigacageBasePtrs + Gigacage::BasePtrs::primitive, constexpr Gigacage::primitiveGigacageMask, source, scratch)</span>
          if ARM64E
              const numberOfPACBits = constexpr MacroAssembler::numberOfPACBits
              bfiq scratch2, 0, 64 - numberOfPACBits, ptr
          end
      end
<span class="line-new-header">--- 430,11 ---</span>
          move ptr, scratch2
      else
          const source = ptr
      end
      if GIGACAGE_ENABLED
<span class="line-modified">!         cage(_g_gigacageConfig + Gigacage::Config::basePtrs + GigacagePrimitiveBasePtrOffset, constexpr Gigacage::primitiveGigacageMask, source, scratch)</span>
          if ARM64E
              const numberOfPACBits = constexpr MacroAssembler::numberOfPACBits
              bfiq scratch2, 0, 64 - numberOfPACBits, ptr
          end
      end
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,65 ***</span>
      end
  end
  
  macro loadCagedJSValue(source, dest, scratchOrLength)
      loadp source, dest
<span class="line-modified">!     cage(_g_gigacageBasePtrs + Gigacage::BasePtrs::jsValue, constexpr Gigacage::jsValueGigacageMask, dest, scratchOrLength)</span>
  end
  
  macro loadVariable(get, fieldName, valueReg)
      get(fieldName, valueReg)
      loadq [cfr, valueReg, 8], valueReg
  end
  
  # Index and value must be different registers. Index may be clobbered.
  macro loadConstantOrVariable(size, index, value)
      macro loadNarrow()
          bpgteq index, FirstConstantRegisterIndexNarrow, .constant
          loadq [cfr, index, 8], value
          jmp .done
      .constant:
<span class="line-modified">!         loadp CodeBlock[cfr], value</span>
<span class="line-removed">-         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-removed">-         loadq -(FirstConstantRegisterIndexNarrow * 8)[value, index, 8], value</span>
      .done:
      end
  
      macro loadWide16()
          bpgteq index, FirstConstantRegisterIndexWide16, .constant
          loadq [cfr, index, 8], value
          jmp .done
      .constant:
<span class="line-modified">!         loadp CodeBlock[cfr], value</span>
<span class="line-removed">-         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-removed">-         loadq -(FirstConstantRegisterIndexWide16 * 8)[value, index, 8], value</span>
      .done:
      end
  
      macro loadWide32()
          bpgteq index, FirstConstantRegisterIndexWide32, .constant
          loadq [cfr, index, 8], value
          jmp .done
      .constant:
<span class="line-modified">!         loadp CodeBlock[cfr], value</span>
<span class="line-removed">-         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-removed">-         subp FirstConstantRegisterIndexWide32, index</span>
<span class="line-removed">-         loadq [value, index, 8], value</span>
      .done:
      end
  
      size(loadNarrow, loadWide16, loadWide32, macro (load) load() end)
  end
  
  macro loadConstantOrVariableInt32(size, index, value, slow)
      loadConstantOrVariable(size, index, value)
<span class="line-modified">!     bqb value, tagTypeNumber, slow</span>
  end
  
  macro loadConstantOrVariableCell(size, index, value, slow)
      loadConstantOrVariable(size, index, value)
<span class="line-modified">!     btqnz value, tagMask, slow</span>
  end
  
  macro writeBarrierOnCellWithReload(cell, reloadAfterSlowPath)
      skipIfIsRememberedOrInEden(
          cell,
<span class="line-new-header">--- 443,84 ---</span>
      end
  end
  
  macro loadCagedJSValue(source, dest, scratchOrLength)
      loadp source, dest
<span class="line-modified">!     if GIGACAGE_ENABLED</span>
<span class="line-added">+         cage(_g_gigacageConfig + Gigacage::Config::basePtrs + GigacageJSValueBasePtrOffset, constexpr Gigacage::jsValueGigacageMask, dest, scratchOrLength)</span>
<span class="line-added">+     end</span>
  end
  
  macro loadVariable(get, fieldName, valueReg)
      get(fieldName, valueReg)
      loadq [cfr, valueReg, 8], valueReg
  end
  
<span class="line-added">+ # Index and value must be different registers. Index may be clobbered.</span>
<span class="line-added">+ macro loadConstant(size, index, value)</span>
<span class="line-added">+     macro loadNarrow()</span>
<span class="line-added">+         loadp CodeBlock[cfr], value</span>
<span class="line-added">+         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-added">+         loadq -(FirstConstantRegisterIndexNarrow * 8)[value, index, 8], value</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     macro loadWide16()</span>
<span class="line-added">+         loadp CodeBlock[cfr], value</span>
<span class="line-added">+         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-added">+         loadq -(FirstConstantRegisterIndexWide16 * 8)[value, index, 8], value</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     macro loadWide32()</span>
<span class="line-added">+         loadp CodeBlock[cfr], value</span>
<span class="line-added">+         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-added">+         subp FirstConstantRegisterIndexWide32, index</span>
<span class="line-added">+         loadq [value, index, 8], value</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     size(loadNarrow, loadWide16, loadWide32, macro (load) load() end)</span>
<span class="line-added">+ end</span>
<span class="line-added">+ </span>
  # Index and value must be different registers. Index may be clobbered.
  macro loadConstantOrVariable(size, index, value)
      macro loadNarrow()
          bpgteq index, FirstConstantRegisterIndexNarrow, .constant
          loadq [cfr, index, 8], value
          jmp .done
      .constant:
<span class="line-modified">!         loadConstant(size, index, value)</span>
      .done:
      end
  
      macro loadWide16()
          bpgteq index, FirstConstantRegisterIndexWide16, .constant
          loadq [cfr, index, 8], value
          jmp .done
      .constant:
<span class="line-modified">!         loadConstant(size, index, value)</span>
      .done:
      end
  
      macro loadWide32()
          bpgteq index, FirstConstantRegisterIndexWide32, .constant
          loadq [cfr, index, 8], value
          jmp .done
      .constant:
<span class="line-modified">!         loadConstant(size, index, value)</span>
      .done:
      end
  
      size(loadNarrow, loadWide16, loadWide32, macro (load) load() end)
  end
  
  macro loadConstantOrVariableInt32(size, index, value, slow)
      loadConstantOrVariable(size, index, value)
<span class="line-modified">!     bqb value, numberTag, slow</span>
  end
  
  macro loadConstantOrVariableCell(size, index, value, slow)
      loadConstantOrVariable(size, index, value)
<span class="line-modified">!     btqnz value, notCellMask, slow</span>
  end
  
  macro writeBarrierOnCellWithReload(cell, reloadAfterSlowPath)
      skipIfIsRememberedOrInEden(
          cell,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 521,10 ***</span>
<span class="line-new-header">--- 532,17 ---</span>
              pop PC, PB
              reloadAfterSlowPath()
          end)
  end
  
<span class="line-added">+ macro writeBarrierOnCellAndValueWithReload(cell, value, reloadAfterSlowPath)</span>
<span class="line-added">+     btqnz value, notCellMask, .writeBarrierDone</span>
<span class="line-added">+     btqz value, .writeBarrierDone</span>
<span class="line-added">+     writeBarrierOnCellWithReload(cell, reloadAfterSlowPath)</span>
<span class="line-added">+ .writeBarrierDone:</span>
<span class="line-added">+ end</span>
<span class="line-added">+ </span>
  macro writeBarrierOnOperandWithReload(size, get, cellFieldName, reloadAfterSlowPath)
      get(cellFieldName, t1)
      loadConstantOrVariableCell(size, t1, t2, .writeBarrierDone)
      writeBarrierOnCellWithReload(t2, reloadAfterSlowPath)
  .writeBarrierDone:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,11 ***</span>
  
  # Entrypoints into the interpreter.
  
  # Expects that CodeBlock is in t1, which is what prologue() leaves behind.
  macro functionArityCheck(doneLabel, slowPath)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
      biaeq t0, CodeBlock::m_numParameters[t1], doneLabel
      prepareStateForCCall()
      move cfr, a0
      move PC, a1
      cCall2(slowPath)   # This slowPath has the protocol: r0 = 0 =&gt; no error, r0 != 0 =&gt; error
<span class="line-new-header">--- 606,11 ---</span>
  
  # Entrypoints into the interpreter.
  
  # Expects that CodeBlock is in t1, which is what prologue() leaves behind.
  macro functionArityCheck(doneLabel, slowPath)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      biaeq t0, CodeBlock::m_numParameters[t1], doneLabel
      prepareStateForCCall()
      move cfr, a0
      move PC, a1
      cCall2(slowPath)   # This slowPath has the protocol: r0 = 0 =&gt; no error, r0 != 0 =&gt; error
</pre>
<hr />
<pre>
<span class="line-old-header">*** 607,11 ***</span>
      jmp _llint_throw_from_slow_path_trampoline
  
  .noError:
      move r1, t1 # r1 contains slotsToAdd.
      btiz t1, .continue
<span class="line-modified">!     loadi PayloadOffset + ArgumentCount[cfr], t2</span>
      addi CallFrameHeaderSlots, t2
  
      // Check if there are some unaligned slots we can use
      move t1, t3
      andi StackAlignmentSlots - 1, t3
<span class="line-new-header">--- 625,11 ---</span>
      jmp _llint_throw_from_slow_path_trampoline
  
  .noError:
      move r1, t1 # r1 contains slotsToAdd.
      btiz t1, .continue
<span class="line-modified">!     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t2</span>
      addi CallFrameHeaderSlots, t2
  
      // Check if there are some unaligned slots we can use
      move t1, t3
      andi StackAlignmentSlots - 1, t3
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,25 ***</span>
      loadp CodeBlock::m_instructionsRawPointer[t1], PB
      move 0, PC
      jmp doneLabel
  end
  
<span class="line-removed">- macro branchIfException(label)</span>
<span class="line-removed">-     loadp Callee[cfr], t3</span>
<span class="line-removed">-     andp MarkedBlockMask, t3</span>
<span class="line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="line-removed">-     btpz VM::m_exception[t3], .noException</span>
<span class="line-removed">-     jmp label</span>
<span class="line-removed">- .noException:</span>
<span class="line-removed">- end</span>
<span class="line-removed">- </span>
  # Instruction implementations
  _llint_op_enter:
      traceExecution()
      checkStackPointerAlignment(t2, 0xdead00e1)
<span class="line-modified">!     loadp CodeBlock[cfr], t3                // t3&lt;CodeBlock&gt; = cfr.CodeBlock</span>
<span class="line-modified">!     loadi CodeBlock::m_numVars[t3], t2      // t2&lt;size_t&gt; = t3&lt;CodeBlock&gt;.m_numVars</span>
      subq CalleeSaveSpaceAsVirtualRegisters, t2
      move cfr, t1
      subq CalleeSaveSpaceAsVirtualRegisters * 8, t1
      btiz t2, .opEnterDone
      move ValueUndefined, t0
<span class="line-new-header">--- 685,17 ---</span>
      loadp CodeBlock::m_instructionsRawPointer[t1], PB
      move 0, PC
      jmp doneLabel
  end
  
  # Instruction implementations
<span class="line-added">+ </span>
  _llint_op_enter:
      traceExecution()
      checkStackPointerAlignment(t2, 0xdead00e1)
<span class="line-modified">!     loadp CodeBlock[cfr], t2                // t2&lt;CodeBlock&gt; = cfr.CodeBlock</span>
<span class="line-modified">!     loadi CodeBlock::m_numVars[t2], t2      // t2&lt;size_t&gt; = t2&lt;CodeBlock&gt;.m_numVars</span>
      subq CalleeSaveSpaceAsVirtualRegisters, t2
      move cfr, t1
      subq CalleeSaveSpaceAsVirtualRegisters * 8, t1
      btiz t2, .opEnterDone
      move ValueUndefined, t0
</pre>
<hr />
<pre>
<span class="line-old-header">*** 694,37 ***</span>
  .opEnterLoop:
      storeq t0, [t1, t2, 8]
      addq 1, t2
      btqnz t2, .opEnterLoop
  .opEnterDone:
<span class="line-modified">!     writeBarrierOnCellWithReload(t3, macro ()</span>
<span class="line-removed">-         loadp CodeBlock[cfr], t3 # Reload CodeBlock</span>
<span class="line-removed">-     end)</span>
<span class="line-removed">-     loadp CodeBlock::m_vm[t3], t1</span>
<span class="line-removed">-     btbnz VM::m_traps + VMTraps::m_needTrapHandling[t1], .handleTraps</span>
<span class="line-removed">- .afterHandlingTraps:</span>
      dispatchOp(narrow, op_enter)
<span class="line-modified">! .handleTraps:</span>
<span class="line-removed">-     callTrapHandler(_llint_throw_from_slow_path_trampoline)</span>
<span class="line-removed">-     jmp .afterHandlingTraps</span>
  
  llintOpWithProfile(op_get_argument, OpGetArgument, macro (size, get, dispatch, return)
      get(m_index, t2)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
      bilteq t0, t2, .opGetArgumentOutOfBounds
      loadq ThisArgumentOffset[cfr, t2, 8], t0
      return(t0)
  
  .opGetArgumentOutOfBounds:
      return(ValueUndefined)
  end)
  
  
  llintOpWithReturn(op_argument_count, OpArgumentCount, macro (size, get, dispatch, return)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
      subi 1, t0
<span class="line-modified">!     orq TagTypeNumber, t0</span>
      return(t0)
  end)
  
  
  llintOpWithReturn(op_get_scope, OpGetScope, macro (size, get, dispatch, return)
<span class="line-new-header">--- 704,30 ---</span>
  .opEnterLoop:
      storeq t0, [t1, t2, 8]
      addq 1, t2
      btqnz t2, .opEnterLoop
  .opEnterDone:
<span class="line-modified">!     callSlowPath(_slow_path_enter)</span>
      dispatchOp(narrow, op_enter)
<span class="line-modified">! </span>
  
  llintOpWithProfile(op_get_argument, OpGetArgument, macro (size, get, dispatch, return)
      get(m_index, t2)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      bilteq t0, t2, .opGetArgumentOutOfBounds
      loadq ThisArgumentOffset[cfr, t2, 8], t0
      return(t0)
  
  .opGetArgumentOutOfBounds:
      return(ValueUndefined)
  end)
  
  
  llintOpWithReturn(op_argument_count, OpArgumentCount, macro (size, get, dispatch, return)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      subi 1, t0
<span class="line-modified">!     orq TagNumber, t0</span>
      return(t0)
  end)
  
  
  llintOpWithReturn(op_get_scope, OpGetScope, macro (size, get, dispatch, return)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,11 ***</span>
  
  
  llintOpWithMetadata(op_to_this, OpToThis, macro (size, get, dispatch, metadata, return)
      get(m_srcDst, t0)
      loadq [cfr, t0, 8], t0
<span class="line-modified">!     btqnz t0, tagMask, .opToThisSlow</span>
      bbneq JSCell::m_type[t0], FinalObjectType, .opToThisSlow
      loadi JSCell::m_structureID[t0], t1
      metadata(t2, t3)
      loadi OpToThis::Metadata::m_cachedStructureID[t2], t2
      bineq t1, t2, .opToThisSlow
<span class="line-new-header">--- 738,11 ---</span>
  
  
  llintOpWithMetadata(op_to_this, OpToThis, macro (size, get, dispatch, metadata, return)
      get(m_srcDst, t0)
      loadq [cfr, t0, 8], t0
<span class="line-modified">!     btqnz t0, notCellMask, .opToThisSlow</span>
      bbneq JSCell::m_type[t0], FinalObjectType, .opToThisSlow
      loadi JSCell::m_structureID[t0], t1
      metadata(t2, t3)
      loadi OpToThis::Metadata::m_cachedStructureID[t2], t2
      bineq t1, t2, .opToThisSlow
</pre>
<hr />
<pre>
<span class="line-old-header">*** 802,22 ***</span>
  
  macro equalNullComparisonOp(opcodeName, opcodeStruct, fn)
      llintOpWithReturn(opcodeName, opcodeStruct, macro (size, get, dispatch, return)
          get(m_operand, t0)
          loadq [cfr, t0, 8], t0
<span class="line-modified">!         btqnz t0, tagMask, .immediate</span>
          btbnz JSCell::m_flags[t0], MasqueradesAsUndefined, .masqueradesAsUndefined
          move 0, t0
          jmp .done
      .masqueradesAsUndefined:
          loadStructureWithScratch(t0, t2, t1, t3)
          loadp CodeBlock[cfr], t0
          loadp CodeBlock::m_globalObject[t0], t0
          cpeq Structure::m_globalObject[t2], t0, t0
          jmp .done
      .immediate:
<span class="line-modified">!         andq ~TagBitUndefined, t0</span>
          cqeq t0, ValueNull, t0
      .done:
          fn(t0)
          return(t0)
      end)
<span class="line-new-header">--- 805,22 ---</span>
  
  macro equalNullComparisonOp(opcodeName, opcodeStruct, fn)
      llintOpWithReturn(opcodeName, opcodeStruct, macro (size, get, dispatch, return)
          get(m_operand, t0)
          loadq [cfr, t0, 8], t0
<span class="line-modified">!         btqnz t0, notCellMask, .immediate</span>
          btbnz JSCell::m_flags[t0], MasqueradesAsUndefined, .masqueradesAsUndefined
          move 0, t0
          jmp .done
      .masqueradesAsUndefined:
          loadStructureWithScratch(t0, t2, t1, t3)
          loadp CodeBlock[cfr], t0
          loadp CodeBlock::m_globalObject[t0], t0
          cpeq Structure::m_globalObject[t2], t0, t0
          jmp .done
      .immediate:
<span class="line-modified">!         andq ~TagUndefined, t0</span>
          cqeq t0, ValueNull, t0
      .done:
          fn(t0)
          return(t0)
      end)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 832,11 ***</span>
  
  
  llintOpWithReturn(op_is_undefined_or_null, OpIsUndefinedOrNull, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     andq ~TagBitUndefined, t0</span>
      cqeq t0, ValueNull, t0
      orq ValueFalse, t0
      return(t0)
  end)
  
<span class="line-new-header">--- 835,11 ---</span>
  
  
  llintOpWithReturn(op_is_undefined_or_null, OpIsUndefinedOrNull, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     andq ~TagUndefined, t0</span>
      cqeq t0, ValueNull, t0
      orq ValueFalse, t0
      return(t0)
  end)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 847,16 ***</span>
          get(m_lhs, t2)
          loadConstantOrVariable(size, t0, t1)
          loadConstantOrVariable(size, t2, t0)
          move t0, t2
          orq t1, t2
<span class="line-modified">!         btqz t2, tagMask, .slow</span>
<span class="line-modified">!         bqaeq t0, tagTypeNumber, .leftOK</span>
<span class="line-modified">!         btqnz t0, tagTypeNumber, .slow</span>
      .leftOK:
<span class="line-modified">!         bqaeq t1, tagTypeNumber, .rightOK</span>
<span class="line-modified">!         btqnz t1, tagTypeNumber, .slow</span>
      .rightOK:
          equalityOperation(t0, t1, t0)
          orq ValueFalse, t0
          return(t0)
  
<span class="line-new-header">--- 850,16 ---</span>
          get(m_lhs, t2)
          loadConstantOrVariable(size, t0, t1)
          loadConstantOrVariable(size, t2, t0)
          move t0, t2
          orq t1, t2
<span class="line-modified">!         btqz t2, notCellMask, .slow</span>
<span class="line-modified">!         bqaeq t0, numberTag, .leftOK</span>
<span class="line-modified">!         btqnz t0, numberTag, .slow</span>
      .leftOK:
<span class="line-modified">!         bqaeq t1, numberTag, .rightOK</span>
<span class="line-modified">!         btqnz t1, numberTag, .slow</span>
      .rightOK:
          equalityOperation(t0, t1, t0)
          orq ValueFalse, t0
          return(t0)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,16 ***</span>
          get(m_rhs, t3)
          loadConstantOrVariable(size, t2, t0)
          loadConstantOrVariable(size, t3, t1)
          move t0, t2
          orq t1, t2
<span class="line-modified">!         btqz t2, tagMask, .slow</span>
<span class="line-modified">!         bqaeq t0, tagTypeNumber, .leftOK</span>
<span class="line-modified">!         btqnz t0, tagTypeNumber, .slow</span>
      .leftOK:
<span class="line-modified">!         bqaeq t1, tagTypeNumber, .rightOK</span>
<span class="line-modified">!         btqnz t1, tagTypeNumber, .slow</span>
      .rightOK:
          equalityOperation(t0, t1, .jumpTarget)
          dispatch()
  
      .jumpTarget:
<span class="line-new-header">--- 884,16 ---</span>
          get(m_rhs, t3)
          loadConstantOrVariable(size, t2, t0)
          loadConstantOrVariable(size, t3, t1)
          move t0, t2
          orq t1, t2
<span class="line-modified">!         btqz t2, notCellMask, .slow</span>
<span class="line-modified">!         bqaeq t0, numberTag, .leftOK</span>
<span class="line-modified">!         btqnz t0, numberTag, .slow</span>
      .leftOK:
<span class="line-modified">!         bqaeq t1, numberTag, .rightOK</span>
<span class="line-modified">!         btqnz t1, numberTag, .slow</span>
      .rightOK:
          equalityOperation(t0, t1, .jumpTarget)
          dispatch()
  
      .jumpTarget:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 908,44 ***</span>
  
  
  strictEqualityJumpOp(jnstricteq, OpJnstricteq,
      macro (left, right, target) bqneq left, right, target end)
  
  
<span class="line-removed">- macro preOp(opcodeName, opcodeStruct, arithmeticOperation)</span>
<span class="line-removed">-     llintOp(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch)</span>
          get(m_srcDst, t0)
<span class="line-modified">!         loadq [cfr, t0, 8], t1</span>
<span class="line-modified">!         bqb t1, tagTypeNumber, .slow</span>
<span class="line-modified">!         arithmeticOperation(t1, .slow)</span>
<span class="line-modified">!         orq tagTypeNumber, t1</span>
<span class="line-modified">!         storeq t1, [cfr, t0, 8]</span>
          dispatch()
      .slow:
          callSlowPath(_slow_path_%opcodeName%)
          dispatch()
      end)
  end
  
  llintOpWithProfile(op_to_number, OpToNumber, macro (size, get, dispatch, return)
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t2)
<span class="line-modified">!     bqaeq t2, tagTypeNumber, .opToNumberIsImmediate</span>
<span class="line-modified">!     btqz t2, tagTypeNumber, .opToNumberSlow</span>
  .opToNumberIsImmediate:
      return(t2)
  
  .opToNumberSlow:
      callSlowPath(_slow_path_to_number)
      dispatch()
  end)
  
  
  llintOpWithReturn(op_to_string, OpToString, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     btqnz t0, tagMask, .opToStringSlow</span>
      bbneq JSCell::m_type[t0], StringType, .opToStringSlow
  .opToStringIsString:
      return(t0)
  
  .opToStringSlow:
<span class="line-new-header">--- 911,64 ---</span>
  
  
  strictEqualityJumpOp(jnstricteq, OpJnstricteq,
      macro (left, right, target) bqneq left, right, target end)
  
<span class="line-added">+ macro preOp(opcodeName, opcodeStruct, integerOperation)</span>
<span class="line-added">+     llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)</span>
<span class="line-added">+         macro updateArithProfile(type)</span>
<span class="line-added">+             orh type, %opcodeStruct%::Metadata::m_arithProfile + UnaryArithProfile::m_bits[t1]</span>
<span class="line-added">+         end</span>
  
          get(m_srcDst, t0)
<span class="line-modified">!         loadq [cfr, t0, 8], t3</span>
<span class="line-modified">!         metadata(t1, t2)</span>
<span class="line-modified">!         # Metadata in t1, srcDst in t3</span>
<span class="line-modified">!         bqb t3, numberTag, .slow</span>
<span class="line-modified">!         integerOperation(t3, .slow)</span>
<span class="line-added">+         orq numberTag, t3</span>
<span class="line-added">+         storeq t3, [cfr, t0, 8]</span>
<span class="line-added">+         updateArithProfile(ArithProfileInt)</span>
          dispatch()
<span class="line-added">+ </span>
      .slow:
          callSlowPath(_slow_path_%opcodeName%)
          dispatch()
      end)
  end
  
  llintOpWithProfile(op_to_number, OpToNumber, macro (size, get, dispatch, return)
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t2)
<span class="line-modified">!     bqaeq t2, numberTag, .opToNumberIsImmediate</span>
<span class="line-modified">!     btqz t2, numberTag, .opToNumberSlow</span>
  .opToNumberIsImmediate:
      return(t2)
  
  .opToNumberSlow:
      callSlowPath(_slow_path_to_number)
      dispatch()
  end)
  
<span class="line-added">+ llintOpWithProfile(op_to_numeric, OpToNumeric, macro (size, get, dispatch, return)</span>
<span class="line-added">+     get(m_operand, t0)</span>
<span class="line-added">+     loadConstantOrVariable(size, t0, t2)</span>
<span class="line-added">+     bqaeq t2, numberTag, .opToNumericIsImmediate</span>
<span class="line-added">+     btqz t2, numberTag, .opToNumericSlow</span>
<span class="line-added">+ .opToNumericIsImmediate:</span>
<span class="line-added">+     return(t2)</span>
<span class="line-added">+ </span>
<span class="line-added">+ .opToNumericSlow:</span>
<span class="line-added">+     callSlowPath(_slow_path_to_numeric)</span>
<span class="line-added">+     dispatch()</span>
<span class="line-added">+ end)</span>
<span class="line-added">+ </span>
  
  llintOpWithReturn(op_to_string, OpToString, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     btqnz t0, notCellMask, .opToStringSlow</span>
      bbneq JSCell::m_type[t0], StringType, .opToStringSlow
  .opToStringIsString:
      return(t0)
  
  .opToStringSlow:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 955,37 ***</span>
  
  
  llintOpWithProfile(op_to_object, OpToObject, macro (size, get, dispatch, return)
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t2)
<span class="line-modified">!     btqnz t2, tagMask, .opToObjectSlow</span>
      bbb JSCell::m_type[t2], ObjectType, .opToObjectSlow
      return(t2)
  
  .opToObjectSlow:
      callSlowPath(_slow_path_to_object)
      dispatch()
  end)
  
  
  llintOpWithMetadata(op_negate, OpNegate, macro (size, get, dispatch, metadata, return)
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t3)
      metadata(t1, t2)
<span class="line-modified">!     loadi OpNegate::Metadata::m_arithProfile + ArithProfile::m_bits[t1], t2</span>
<span class="line-removed">-     bqb t3, tagTypeNumber, .opNegateNotInt</span>
      btiz t3, 0x7fffffff, .opNegateSlow
      negi t3
<span class="line-modified">!     orq tagTypeNumber, t3</span>
<span class="line-modified">!     ori ArithProfileInt, t2</span>
<span class="line-removed">-     storei t2, OpNegate::Metadata::m_arithProfile + ArithProfile::m_bits[t1]</span>
      return(t3)
  .opNegateNotInt:
<span class="line-modified">!     btqz t3, tagTypeNumber, .opNegateSlow</span>
      xorq 0x8000000000000000, t3
<span class="line-modified">!     ori ArithProfileNumber, t2</span>
<span class="line-removed">-     storei t2, OpNegate::Metadata::m_arithProfile + ArithProfile::m_bits[t1]</span>
      return(t3)
  
  .opNegateSlow:
      callSlowPath(_slow_path_negate)
      dispatch()
<span class="line-new-header">--- 978,39 ---</span>
  
  
  llintOpWithProfile(op_to_object, OpToObject, macro (size, get, dispatch, return)
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t2)
<span class="line-modified">!     btqnz t2, notCellMask, .opToObjectSlow</span>
      bbb JSCell::m_type[t2], ObjectType, .opToObjectSlow
      return(t2)
  
  .opToObjectSlow:
      callSlowPath(_slow_path_to_object)
      dispatch()
  end)
  
  
  llintOpWithMetadata(op_negate, OpNegate, macro (size, get, dispatch, metadata, return)
<span class="line-added">+ </span>
<span class="line-added">+     macro updateArithProfile(type)</span>
<span class="line-added">+         orh type, OpNegate::Metadata::m_arithProfile + UnaryArithProfile::m_bits[t1]</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t3)
      metadata(t1, t2)
<span class="line-modified">!     bqb t3, numberTag, .opNegateNotInt</span>
      btiz t3, 0x7fffffff, .opNegateSlow
      negi t3
<span class="line-modified">!     orq numberTag, t3</span>
<span class="line-modified">!     updateArithProfile(ArithProfileInt)</span>
      return(t3)
  .opNegateNotInt:
<span class="line-modified">!     btqz t3, numberTag, .opNegateSlow</span>
      xorq 0x8000000000000000, t3
<span class="line-modified">!     updateArithProfile(ArithProfileNumber)</span>
      return(t3)
  
  .opNegateSlow:
      callSlowPath(_slow_path_negate)
      dispatch()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 995,58 ***</span>
  macro binaryOpCustomStore(opcodeName, opcodeStruct, integerOperationAndStore, doubleOperation)
      llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
          metadata(t5, t0)
  
          macro profile(type)
<span class="line-modified">!             ori type, %opcodeStruct%::Metadata::m_arithProfile + ArithProfile::m_bits[t5]</span>
          end
  
          get(m_rhs, t0)
          get(m_lhs, t2)
          loadConstantOrVariable(size, t0, t1)
          loadConstantOrVariable(size, t2, t0)
<span class="line-modified">!         bqb t0, tagTypeNumber, .op1NotInt</span>
<span class="line-modified">!         bqb t1, tagTypeNumber, .op2NotInt</span>
          get(m_dst, t2)
          integerOperationAndStore(t1, t0, .slow, t2)
  
          profile(ArithProfileIntInt)
          dispatch()
  
      .op1NotInt:
          # First operand is definitely not an int, the second operand could be anything.
<span class="line-modified">!         btqz t0, tagTypeNumber, .slow</span>
<span class="line-modified">!         bqaeq t1, tagTypeNumber, .op1NotIntOp2Int</span>
<span class="line-modified">!         btqz t1, tagTypeNumber, .slow</span>
<span class="line-modified">!         addq tagTypeNumber, t1</span>
          fq2d t1, ft1
          profile(ArithProfileNumberNumber)
          jmp .op1NotIntReady
      .op1NotIntOp2Int:
          profile(ArithProfileNumberInt)
<span class="line-modified">!         ci2d t1, ft1</span>
      .op1NotIntReady:
          get(m_dst, t2)
<span class="line-modified">!         addq tagTypeNumber, t0</span>
          fq2d t0, ft0
          doubleOperation(ft1, ft0)
          fd2q ft0, t0
<span class="line-modified">!         subq tagTypeNumber, t0</span>
          storeq t0, [cfr, t2, 8]
          dispatch()
  
      .op2NotInt:
          # First operand is definitely an int, the second is definitely not.
          get(m_dst, t2)
<span class="line-modified">!         btqz t1, tagTypeNumber, .slow</span>
          profile(ArithProfileIntNumber)
<span class="line-modified">!         ci2d t0, ft0</span>
<span class="line-modified">!         addq tagTypeNumber, t1</span>
          fq2d t1, ft1
          doubleOperation(ft1, ft0)
          fd2q ft0, t0
<span class="line-modified">!         subq tagTypeNumber, t0</span>
          storeq t0, [cfr, t2, 8]
          dispatch()
  
      .slow:
          callSlowPath(_slow_path_%opcodeName%)
<span class="line-new-header">--- 1020,58 ---</span>
  macro binaryOpCustomStore(opcodeName, opcodeStruct, integerOperationAndStore, doubleOperation)
      llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
          metadata(t5, t0)
  
          macro profile(type)
<span class="line-modified">!             orh type, %opcodeStruct%::Metadata::m_arithProfile + BinaryArithProfile::m_bits[t5]</span>
          end
  
          get(m_rhs, t0)
          get(m_lhs, t2)
          loadConstantOrVariable(size, t0, t1)
          loadConstantOrVariable(size, t2, t0)
<span class="line-modified">!         bqb t0, numberTag, .op1NotInt</span>
<span class="line-modified">!         bqb t1, numberTag, .op2NotInt</span>
          get(m_dst, t2)
          integerOperationAndStore(t1, t0, .slow, t2)
  
          profile(ArithProfileIntInt)
          dispatch()
  
      .op1NotInt:
          # First operand is definitely not an int, the second operand could be anything.
<span class="line-modified">!         btqz t0, numberTag, .slow</span>
<span class="line-modified">!         bqaeq t1, numberTag, .op1NotIntOp2Int</span>
<span class="line-modified">!         btqz t1, numberTag, .slow</span>
<span class="line-modified">!         addq numberTag, t1</span>
          fq2d t1, ft1
          profile(ArithProfileNumberNumber)
          jmp .op1NotIntReady
      .op1NotIntOp2Int:
          profile(ArithProfileNumberInt)
<span class="line-modified">!         ci2ds t1, ft1</span>
      .op1NotIntReady:
          get(m_dst, t2)
<span class="line-modified">!         addq numberTag, t0</span>
          fq2d t0, ft0
          doubleOperation(ft1, ft0)
          fd2q ft0, t0
<span class="line-modified">!         subq numberTag, t0</span>
          storeq t0, [cfr, t2, 8]
          dispatch()
  
      .op2NotInt:
          # First operand is definitely an int, the second is definitely not.
          get(m_dst, t2)
<span class="line-modified">!         btqz t1, numberTag, .slow</span>
          profile(ArithProfileIntNumber)
<span class="line-modified">!         ci2ds t0, ft0</span>
<span class="line-modified">!         addq numberTag, t1</span>
          fq2d t1, ft1
          doubleOperation(ft1, ft0)
          fd2q ft0, t0
<span class="line-modified">!         subq numberTag, t0</span>
          storeq t0, [cfr, t2, 8]
          dispatch()
  
      .slow:
          callSlowPath(_slow_path_%opcodeName%)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1068,11 ***</span>
              move left, t3
              move right, t0
              cdqi
              idivi t3
              btinz t1, slow
<span class="line-modified">!             orq tagTypeNumber, t0</span>
              storeq t0, [cfr, index, 8]
          end,
          macro (left, right) divd left, right end)
  else
      slowPathOp(div)
<span class="line-new-header">--- 1093,11 ---</span>
              move left, t3
              move right, t0
              cdqi
              idivi t3
              btinz t1, slow
<span class="line-modified">!             orq numberTag, t0</span>
              storeq t0, [cfr, index, 8]
          end,
          macro (left, right) divd left, right end)
  else
      slowPathOp(div)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1086,21 ***</span>
          bmulio left, t3, slow
          btinz t3, .done
          bilt left, 0, slow
          bilt right, 0, slow
      .done:
<span class="line-modified">!         orq tagTypeNumber, t3</span>
          storeq t3, [cfr, index, 8]
      end,
      macro (left, right) muld left, right end)
  
  
  macro binaryOp(opcodeName, opcodeStruct, integerOperation, doubleOperation)
      binaryOpCustomStore(opcodeName, opcodeStruct,
          macro (left, right, slow, index)
              integerOperation(left, right, slow)
<span class="line-modified">!             orq tagTypeNumber, right</span>
              storeq right, [cfr, index, 8]
          end,
          doubleOperation)
  end
  
<span class="line-new-header">--- 1111,21 ---</span>
          bmulio left, t3, slow
          btinz t3, .done
          bilt left, 0, slow
          bilt right, 0, slow
      .done:
<span class="line-modified">!         orq numberTag, t3</span>
          storeq t3, [cfr, index, 8]
      end,
      macro (left, right) muld left, right end)
  
  
  macro binaryOp(opcodeName, opcodeStruct, integerOperation, doubleOperation)
      binaryOpCustomStore(opcodeName, opcodeStruct,
          macro (left, right, slow, index)
              integerOperation(left, right, slow)
<span class="line-modified">!             orq numberTag, right</span>
              storeq right, [cfr, index, 8]
          end,
          doubleOperation)
  end
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1129,14 ***</span>
      opKind(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, return)
          get(m_rhs, t0)
          get(m_lhs, t2)
          loadConstantOrVariable(size, t0, t1)
          loadConstantOrVariable(size, t2, t0)
<span class="line-modified">!         bqb t0, tagTypeNumber, .slow</span>
<span class="line-modified">!         bqb t1, tagTypeNumber, .slow</span>
          operation(t1, t0)
<span class="line-modified">!         orq tagTypeNumber, t0</span>
          return(t0)
  
      .slow:
          callSlowPath(_slow_path_%opcodeName%)
          dispatch()
<span class="line-new-header">--- 1154,14 ---</span>
      opKind(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, return)
          get(m_rhs, t0)
          get(m_lhs, t2)
          loadConstantOrVariable(size, t0, t1)
          loadConstantOrVariable(size, t2, t0)
<span class="line-modified">!         bqb t0, numberTag, .slow</span>
<span class="line-modified">!         bqb t1, numberTag, .slow</span>
          operation(t1, t0)
<span class="line-modified">!         orq numberTag, t0</span>
          return(t0)
  
      .slow:
          callSlowPath(_slow_path_%opcodeName%)
          dispatch()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1153,11 ***</span>
  
  bitOpProfiled(lshift, OpLshift,
      macro (left, right) lshifti left, right end)
  
  
<span class="line-modified">! bitOp(rshift, OpRshift,</span>
      macro (left, right) rshifti left, right end)
  
  
  bitOp(urshift, OpUrshift,
      macro (left, right) urshifti left, right end)
<span class="line-new-header">--- 1178,11 ---</span>
  
  bitOpProfiled(lshift, OpLshift,
      macro (left, right) lshifti left, right end)
  
  
<span class="line-modified">! bitOpProfiled(rshift, OpRshift,</span>
      macro (left, right) rshifti left, right end)
  
  
  bitOp(urshift, OpUrshift,
      macro (left, right) urshifti left, right end)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1173,11 ***</span>
  
  llintOpWithProfile(op_bitnot, OpBitnot, macro (size, get, dispatch, return)
      get(m_operand, t0)
      loadConstantOrVariableInt32(size, t0, t3, .opBitNotSlow)
      noti t3
<span class="line-modified">!     orq tagTypeNumber, t3</span>
      return(t3)
  .opBitNotSlow:
      callSlowPath(_slow_path_bitnot)
      dispatch()
  end)
<span class="line-new-header">--- 1198,11 ---</span>
  
  llintOpWithProfile(op_bitnot, OpBitnot, macro (size, get, dispatch, return)
      get(m_operand, t0)
      loadConstantOrVariableInt32(size, t0, t3, .opBitNotSlow)
      noti t3
<span class="line-modified">!     orq numberTag, t3</span>
      return(t3)
  .opBitNotSlow:
      callSlowPath(_slow_path_bitnot)
      dispatch()
  end)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1216,11 ***</span>
  
  
  llintOpWithReturn(op_is_undefined, OpIsUndefined, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     btqz t0, tagMask, .opIsUndefinedCell</span>
      cqeq t0, ValueUndefined, t3
      orq ValueFalse, t3
      return(t3)
  .opIsUndefinedCell:
      btbnz JSCell::m_flags[t0], MasqueradesAsUndefined, .masqueradesAsUndefined
<span class="line-new-header">--- 1241,11 ---</span>
  
  
  llintOpWithReturn(op_is_undefined, OpIsUndefined, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     btqz t0, notCellMask, .opIsUndefinedCell</span>
      cqeq t0, ValueUndefined, t3
      orq ValueFalse, t3
      return(t3)
  .opIsUndefinedCell:
      btbnz JSCell::m_flags[t0], MasqueradesAsUndefined, .masqueradesAsUndefined
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1247,21 ***</span>
  
  
  llintOpWithReturn(op_is_number, OpIsNumber, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     tqnz t0, tagTypeNumber, t1</span>
      orq ValueFalse, t1
      return(t1)
  end)
  
  
  llintOpWithReturn(op_is_cell_with_type, OpIsCellWithType, macro (size, get, dispatch, return)
      getu(size, OpIsCellWithType, m_type, t0)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t3)
<span class="line-modified">!     btqnz t3, tagMask, .notCellCase</span>
      cbeq JSCell::m_type[t3], t0, t1
      orq ValueFalse, t1
      return(t1)
  .notCellCase:
      return(ValueFalse)
<span class="line-new-header">--- 1272,21 ---</span>
  
  
  llintOpWithReturn(op_is_number, OpIsNumber, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     tqnz t0, numberTag, t1</span>
      orq ValueFalse, t1
      return(t1)
  end)
  
  
  llintOpWithReturn(op_is_cell_with_type, OpIsCellWithType, macro (size, get, dispatch, return)
      getu(size, OpIsCellWithType, m_type, t0)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t3)
<span class="line-modified">!     btqnz t3, notCellMask, .notCellCase</span>
      cbeq JSCell::m_type[t3], t0, t1
      orq ValueFalse, t1
      return(t1)
  .notCellCase:
      return(ValueFalse)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1269,11 ***</span>
  
  
  llintOpWithReturn(op_is_object, OpIsObject, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     btqnz t0, tagMask, .opIsObjectNotCell</span>
      cbaeq JSCell::m_type[t0], ObjectType, t1
      orq ValueFalse, t1
      return(t1)
  .opIsObjectNotCell:
      return(ValueFalse)
<span class="line-new-header">--- 1294,11 ---</span>
  
  
  llintOpWithReturn(op_is_object, OpIsObject, macro (size, get, dispatch, return)
      get(m_operand, t1)
      loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!     btqnz t0, notCellMask, .opIsObjectNotCell</span>
      cbaeq JSCell::m_type[t0], ObjectType, t1
      orq ValueFalse, t1
      return(t1)
  .opIsObjectNotCell:
      return(ValueFalse)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1321,11 ***</span>
  .opGetByIdDirectSlow:
      callSlowPath(_llint_slow_path_get_by_id_direct)
      dispatch()
  end)
  
<span class="line-removed">- </span>
  llintOpWithMetadata(op_get_by_id, OpGetById, macro (size, get, dispatch, metadata, return)
      metadata(t2, t1)
      loadb OpGetById::Metadata::m_modeMetadata.mode[t2], t1
      get(m_base, t0)
      loadConstantOrVariableCell(size, t0, t3, .opGetByIdSlow)
<span class="line-new-header">--- 1346,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1358,11 ***</span>
      btiz t0, IsArray, .opGetByIdSlow
      btiz t0, IndexingShapeMask, .opGetByIdSlow
      loadCagedJSValue(JSObject::m_butterfly[t3], t0, t1)
      loadi -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], t0
      bilt t0, 0, .opGetByIdSlow
<span class="line-modified">!     orq tagTypeNumber, t0</span>
      valueProfile(OpGetById, t2, t0)
      return(t0)
  
  .opGetByIdUnset:
      loadi JSCell::m_structureID[t3], t1
<span class="line-new-header">--- 1382,11 ---</span>
      btiz t0, IsArray, .opGetByIdSlow
      btiz t0, IndexingShapeMask, .opGetByIdSlow
      loadCagedJSValue(JSObject::m_butterfly[t3], t0, t1)
      loadi -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], t0
      bilt t0, 0, .opGetByIdSlow
<span class="line-modified">!     orq numberTag, t0</span>
      valueProfile(OpGetById, t2, t0)
      return(t0)
  
  .opGetByIdUnset:
      loadi JSCell::m_structureID[t3], t1
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1372,10 ***</span>
<span class="line-new-header">--- 1396,17 ---</span>
      return(ValueUndefined)
  
  .opGetByIdSlow:
      callSlowPath(_llint_slow_path_get_by_id)
      dispatch()
<span class="line-added">+ </span>
<span class="line-added">+ .osrReturnPoint:</span>
<span class="line-added">+     getterSetterOSRExitReturnPoint(op_get_by_id, size)</span>
<span class="line-added">+     metadata(t2, t3)</span>
<span class="line-added">+     valueProfile(OpGetById, t2, r0)</span>
<span class="line-added">+     return(r0)</span>
<span class="line-added">+ </span>
  end)
  
  
  llintOpWithMetadata(op_put_by_id, OpPutById, macro (size, get, dispatch, metadata, return)
      get(m_base, t3)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1396,35 ***</span>
      # If we have a chain, we need to check it. t0 is the base. We may clobber t1 to use it as
      # scratch.
      loadp OpPutById::Metadata::m_structureChain[t5], t3
      btpz t3, .opPutByIdTransitionDirect
  
<span class="line-modified">!     structureIDToStructureWithScratch(t2, t1, t3)</span>
  
<span class="line-modified">!     # reload the StructureChain since we used t3 as a scratch above</span>
<span class="line-removed">-     loadp OpPutById::Metadata::m_structureChain[t5], t3</span>
  
      loadp StructureChain::m_vector[t3], t3
      assert(macro (ok) btpnz t3, ok end)
  
      loadq Structure::m_prototype[t2], t2
      bqeq t2, ValueNull, .opPutByIdTransitionChainDone
  .opPutByIdTransitionChainLoop:
<span class="line-removed">-     # At this point, t2 contains a prototye, and [t3] contains the Structure* that we want that</span>
<span class="line-removed">-     # prototype to have. We don&#39;t want to have to load the Structure* for t2. Instead, we load</span>
<span class="line-removed">-     # the Structure* from [t3], and then we compare its id to the id in the header of t2.</span>
<span class="line-removed">-     loadp [t3], t1</span>
      loadi JSCell::m_structureID[t2], t2
<span class="line-modified">!     # Now, t1 has the Structure* and t2 has the StructureID that we want that Structure* to have.</span>
<span class="line-modified">!     bineq t2, Structure::m_blob + StructureIDBlob::u.fields.structureID[t1], .opPutByIdSlow</span>
<span class="line-modified">!     addp PtrSize, t3</span>
<span class="line-modified">!     loadq Structure::m_prototype[t1], t2</span>
      bqneq t2, ValueNull, .opPutByIdTransitionChainLoop
  
  .opPutByIdTransitionChainDone:
      # Reload the new structure, since we clobbered it above.
      loadi OpPutById::Metadata::m_newStructureID[t5], t1
  
  .opPutByIdTransitionDirect:
      storei t1, JSCell::m_structureID[t0]
      writeBarrierOnOperandWithReload(size, get, m_base, macro ()
          # Reload metadata into t5
<span class="line-new-header">--- 1427,43 ---</span>
      # If we have a chain, we need to check it. t0 is the base. We may clobber t1 to use it as
      # scratch.
      loadp OpPutById::Metadata::m_structureChain[t5], t3
      btpz t3, .opPutByIdTransitionDirect
  
<span class="line-modified">!     loadp CodeBlock[cfr], t1</span>
<span class="line-added">+     loadp CodeBlock::m_vm[t1], t1</span>
<span class="line-added">+     loadp VM::heap + Heap::m_structureIDTable + StructureIDTable::m_table[t1], t1</span>
<span class="line-added">+ </span>
<span class="line-added">+     macro structureIDToStructureWithScratchAndTable(structureIDThenStructure, table, scratch)</span>
<span class="line-added">+         move structureIDThenStructure, scratch</span>
<span class="line-added">+         rshifti NumberOfStructureIDEntropyBits, scratch</span>
<span class="line-added">+         loadp [table, scratch, PtrSize], scratch</span>
<span class="line-added">+         lshiftp StructureEntropyBitsShift, structureIDThenStructure</span>
<span class="line-added">+         xorp scratch, structureIDThenStructure</span>
<span class="line-added">+     end</span>
  
<span class="line-modified">!     structureIDToStructureWithScratchAndTable(t2, t1, t0)</span>
  
      loadp StructureChain::m_vector[t3], t3
      assert(macro (ok) btpnz t3, ok end)
  
      loadq Structure::m_prototype[t2], t2
      bqeq t2, ValueNull, .opPutByIdTransitionChainDone
  .opPutByIdTransitionChainLoop:
      loadi JSCell::m_structureID[t2], t2
<span class="line-modified">!     bineq t2, [t3], .opPutByIdSlow</span>
<span class="line-modified">!     addp 4, t3</span>
<span class="line-modified">!     structureIDToStructureWithScratchAndTable(t2, t1, t0)</span>
<span class="line-modified">!     loadq Structure::m_prototype[t2], t2</span>
      bqneq t2, ValueNull, .opPutByIdTransitionChainLoop
  
  .opPutByIdTransitionChainDone:
      # Reload the new structure, since we clobbered it above.
      loadi OpPutById::Metadata::m_newStructureID[t5], t1
<span class="line-added">+     # Reload base into t0</span>
<span class="line-added">+     get(m_base, t3)</span>
<span class="line-added">+     loadConstantOrVariable(size, t3, t0)</span>
  
  .opPutByIdTransitionDirect:
      storei t1, JSCell::m_structureID[t0]
      writeBarrierOnOperandWithReload(size, get, m_base, macro ()
          # Reload metadata into t5
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1444,10 ***</span>
<span class="line-new-header">--- 1483,15 ---</span>
      dispatch()
  
  .opPutByIdSlow:
      callSlowPath(_llint_slow_path_put_by_id)
      dispatch()
<span class="line-added">+ </span>
<span class="line-added">+ .osrReturnPoint:</span>
<span class="line-added">+     getterSetterOSRExitReturnPoint(op_put_by_id, size)</span>
<span class="line-added">+     dispatch()</span>
<span class="line-added">+ </span>
  end)
  
  
  llintOpWithMetadata(op_get_by_val, OpGetByVal, macro (size, get, dispatch, metadata, return)
      macro finishGetByVal(result, scratch)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1456,17 ***</span>
          valueProfile(OpGetByVal, t5, result)
          dispatch()
      end
  
      macro finishIntGetByVal(result, scratch)
<span class="line-modified">!         orq tagTypeNumber, result</span>
          finishGetByVal(result, scratch)
      end
  
      macro finishDoubleGetByVal(result, scratch1, scratch2)
          fd2q result, scratch1
<span class="line-modified">!         subq tagTypeNumber, scratch1</span>
          finishGetByVal(scratch1, scratch2)
      end
  
      metadata(t5, t2)
  
<span class="line-new-header">--- 1500,17 ---</span>
          valueProfile(OpGetByVal, t5, result)
          dispatch()
      end
  
      macro finishIntGetByVal(result, scratch)
<span class="line-modified">!         orq numberTag, result</span>
          finishGetByVal(result, scratch)
      end
  
      macro finishDoubleGetByVal(result, scratch1, scratch2)
          fd2q result, scratch1
<span class="line-modified">!         subq numberTag, scratch1</span>
          finishGetByVal(scratch1, scratch2)
      end
  
      metadata(t5, t2)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1478,12 ***</span>
  
      get(m_property, t3)
      loadConstantOrVariableInt32(size, t3, t1, .opGetByValSlow)
      sxi2q t1, t1
  
<span class="line-modified">!     loadCagedJSValue(JSObject::m_butterfly[t0], t3, tagTypeNumber)</span>
<span class="line-modified">!     move TagTypeNumber, tagTypeNumber</span>
  
      andi IndexingShapeMask, t2
      bieq t2, Int32Shape, .opGetByValIsContiguous
      bineq t2, ContiguousShape, .opGetByValNotContiguous
  
<span class="line-new-header">--- 1522,12 ---</span>
  
      get(m_property, t3)
      loadConstantOrVariableInt32(size, t3, t1, .opGetByValSlow)
      sxi2q t1, t1
  
<span class="line-modified">!     loadCagedJSValue(JSObject::m_butterfly[t0], t3, numberTag)</span>
<span class="line-modified">!     move TagNumber, numberTag</span>
  
      andi IndexingShapeMask, t2
      bieq t2, Int32Shape, .opGetByValIsContiguous
      bineq t2, ContiguousShape, .opGetByValNotContiguous
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1499,11 ***</span>
      biaeq t1, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t3], .opGetByValSlow
      get(m_dst, t0)
      loadd [t3, t1, 8], ft0
      bdnequn ft0, ft0, .opGetByValSlow
      fd2q ft0, t2
<span class="line-modified">!     subq tagTypeNumber, t2</span>
      jmp .opGetByValDone
      
  .opGetByValNotDouble:
      subi ArrayStorageShape, t2
      bia t2, SlowPutArrayStorageShape - ArrayStorageShape, .opGetByValNotIndexedStorage
<span class="line-new-header">--- 1543,11 ---</span>
      biaeq t1, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t3], .opGetByValSlow
      get(m_dst, t0)
      loadd [t3, t1, 8], ft0
      bdnequn ft0, ft0, .opGetByValSlow
      fd2q ft0, t2
<span class="line-modified">!     subq numberTag, t2</span>
      jmp .opGetByValDone
      
  .opGetByValNotDouble:
      subi ArrayStorageShape, t2
      bia t2, SlowPutArrayStorageShape - ArrayStorageShape, .opGetByValNotIndexedStorage
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1615,14 ***</span>
      finishDoubleGetByVal(ft0, t0, t1)
  
  .opGetByValSlow:
      callSlowPath(_llint_slow_path_get_by_val)
      dispatch()
  end)
  
  
<span class="line-modified">! macro putByValOp(opcodeName, opcodeStruct)</span>
      llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
          macro contiguousPutByVal(storeCallback)
              biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], .outOfBounds
          .storeResult:
              get(m_value, t2)
<span class="line-new-header">--- 1659,21 ---</span>
      finishDoubleGetByVal(ft0, t0, t1)
  
  .opGetByValSlow:
      callSlowPath(_llint_slow_path_get_by_val)
      dispatch()
<span class="line-added">+ </span>
<span class="line-added">+ .osrReturnPoint:</span>
<span class="line-added">+     getterSetterOSRExitReturnPoint(op_get_by_val, size)</span>
<span class="line-added">+     metadata(t5, t2)</span>
<span class="line-added">+     valueProfile(OpGetByVal, t5, r0)</span>
<span class="line-added">+     return(r0)</span>
<span class="line-added">+ </span>
  end)
  
  
<span class="line-modified">! macro putByValOp(opcodeName, opcodeStruct, osrExitPoint)</span>
      llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
          macro contiguousPutByVal(storeCallback)
              biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], .outOfBounds
          .storeResult:
              get(m_value, t2)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1643,33 ***</span>
          metadata(t5, t0)
          arrayProfile(%opcodeStruct%::Metadata::m_arrayProfile, t2, t5, t0)
          get(m_property, t0)
          loadConstantOrVariableInt32(size, t0, t3, .opPutByValSlow)
          sxi2q t3, t3
<span class="line-modified">!         loadCagedJSValue(JSObject::m_butterfly[t1], t0, tagTypeNumber)</span>
<span class="line-modified">!         move TagTypeNumber, tagTypeNumber</span>
          btinz t2, CopyOnWrite, .opPutByValSlow
          andi IndexingShapeMask, t2
          bineq t2, Int32Shape, .opPutByValNotInt32
          contiguousPutByVal(
              macro (operand, scratch, address)
                  loadConstantOrVariable(size, operand, scratch)
<span class="line-modified">!                 bqb scratch, tagTypeNumber, .opPutByValSlow</span>
                  storeq scratch, address
                  writeBarrierOnOperands(size, get, m_base, m_value)
              end)
  
      .opPutByValNotInt32:
          bineq t2, DoubleShape, .opPutByValNotDouble
          contiguousPutByVal(
              macro (operand, scratch, address)
                  loadConstantOrVariable(size, operand, scratch)
<span class="line-modified">!                 bqb scratch, tagTypeNumber, .notInt</span>
<span class="line-modified">!                 ci2d scratch, ft0</span>
                  jmp .ready
              .notInt:
<span class="line-modified">!                 addq tagTypeNumber, scratch</span>
                  fq2d scratch, ft0
                  bdnequn ft0, ft0, .opPutByValSlow
              .ready:
                  stored ft0, address
                  writeBarrierOnOperands(size, get, m_base, m_value)
<span class="line-new-header">--- 1694,33 ---</span>
          metadata(t5, t0)
          arrayProfile(%opcodeStruct%::Metadata::m_arrayProfile, t2, t5, t0)
          get(m_property, t0)
          loadConstantOrVariableInt32(size, t0, t3, .opPutByValSlow)
          sxi2q t3, t3
<span class="line-modified">!         loadCagedJSValue(JSObject::m_butterfly[t1], t0, numberTag)</span>
<span class="line-modified">!         move TagNumber, numberTag</span>
          btinz t2, CopyOnWrite, .opPutByValSlow
          andi IndexingShapeMask, t2
          bineq t2, Int32Shape, .opPutByValNotInt32
          contiguousPutByVal(
              macro (operand, scratch, address)
                  loadConstantOrVariable(size, operand, scratch)
<span class="line-modified">!                 bqb scratch, numberTag, .opPutByValSlow</span>
                  storeq scratch, address
                  writeBarrierOnOperands(size, get, m_base, m_value)
              end)
  
      .opPutByValNotInt32:
          bineq t2, DoubleShape, .opPutByValNotDouble
          contiguousPutByVal(
              macro (operand, scratch, address)
                  loadConstantOrVariable(size, operand, scratch)
<span class="line-modified">!                 bqb scratch, numberTag, .notInt</span>
<span class="line-modified">!                 ci2ds scratch, ft0</span>
                  jmp .ready
              .notInt:
<span class="line-modified">!                 addq numberTag, scratch</span>
                  fq2d scratch, ft0
                  bdnequn ft0, ft0, .opPutByValSlow
              .ready:
                  stored ft0, address
                  writeBarrierOnOperands(size, get, m_base, m_value)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1706,16 ***</span>
      .opPutByValOutOfBounds:
          storeb 1, %opcodeStruct%::Metadata::m_arrayProfile.m_outOfBounds[t5]
      .opPutByValSlow:
          callSlowPath(_llint_slow_path_%opcodeName%)
          dispatch()
      end)
  end
  
<span class="line-modified">! putByValOp(put_by_val, OpPutByVal)</span>
  
<span class="line-modified">! putByValOp(put_by_val_direct, OpPutByValDirect)</span>
  
  
  macro llintJumpTrueOrFalseOp(opcodeName, opcodeStruct, conditionOp)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_condition, t1)
<span class="line-new-header">--- 1757,23 ---</span>
      .opPutByValOutOfBounds:
          storeb 1, %opcodeStruct%::Metadata::m_arrayProfile.m_outOfBounds[t5]
      .opPutByValSlow:
          callSlowPath(_llint_slow_path_%opcodeName%)
          dispatch()
<span class="line-added">+ </span>
<span class="line-added">+         osrExitPoint(size, dispatch)</span>
<span class="line-added">+ </span>
      end)
  end
  
<span class="line-modified">! putByValOp(put_by_val, OpPutByVal, macro (size, dispatch)</span>
<span class="line-added">+ .osrReturnPoint:</span>
<span class="line-added">+     getterSetterOSRExitReturnPoint(op_put_by_val, size)</span>
<span class="line-added">+     dispatch()</span>
<span class="line-added">+ end)</span>
  
<span class="line-modified">! putByValOp(put_by_val_direct, OpPutByValDirect, macro (a, b) end)</span>
  
  
  macro llintJumpTrueOrFalseOp(opcodeName, opcodeStruct, conditionOp)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_condition, t1)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1737,20 ***</span>
  macro equalNullJumpOp(opcodeName, opcodeStruct, cellHandler, immediateHandler)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_value, t0)
          assertNotConstant(size, t0)
          loadq [cfr, t0, 8], t0
<span class="line-modified">!         btqnz t0, tagMask, .immediate</span>
          loadStructureWithScratch(t0, t2, t1, t3)
          cellHandler(t2, JSCell::m_flags[t0], .target)
          dispatch()
  
      .target:
          jump(m_targetLabel)
  
      .immediate:
<span class="line-modified">!         andq ~TagBitUndefined, t0</span>
          immediateHandler(t0, .target)
          dispatch()
      end)
  end
  
<span class="line-new-header">--- 1795,20 ---</span>
  macro equalNullJumpOp(opcodeName, opcodeStruct, cellHandler, immediateHandler)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_value, t0)
          assertNotConstant(size, t0)
          loadq [cfr, t0, 8], t0
<span class="line-modified">!         btqnz t0, notCellMask, .immediate</span>
          loadStructureWithScratch(t0, t2, t1, t3)
          cellHandler(t2, JSCell::m_flags[t0], .target)
          dispatch()
  
      .target:
          jump(m_targetLabel)
  
      .immediate:
<span class="line-modified">!         andq ~TagUndefined, t0</span>
          immediateHandler(t0, .target)
          dispatch()
      end)
  end
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1776,11 ***</span>
  
  macro undefinedOrNullJumpOp(opcodeName, opcodeStruct, fn)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_value, t1)
          loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!         andq ~TagBitUndefined, t0</span>
          fn(t0, .target)
          dispatch()
  
      .target:
          jump(m_targetLabel)
<span class="line-new-header">--- 1834,11 ---</span>
  
  macro undefinedOrNullJumpOp(opcodeName, opcodeStruct, fn)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_value, t1)
          loadConstantOrVariable(size, t1, t0)
<span class="line-modified">!         andq ~TagUndefined, t0</span>
          fn(t0, .target)
          dispatch()
  
      .target:
          jump(m_targetLabel)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1793,55 ***</span>
  undefinedOrNullJumpOp(jnundefined_or_null, OpJnundefinedOrNull,
      macro (value, target) bqneq value, ValueNull, target end)
  
  llintOpWithMetadata(op_jneq_ptr, OpJneqPtr, macro (size, get, dispatch, metadata, return)
      get(m_value, t0)
<span class="line-modified">!     getu(size, OpJneqPtr, m_specialPointer, t1)</span>
<span class="line-modified">!     loadp CodeBlock[cfr], t2</span>
<span class="line-modified">!     loadp CodeBlock::m_globalObject[t2], t2</span>
<span class="line-removed">-     loadp JSGlobalObject::m_specialPointers[t2, t1, PtrSize], t1</span>
<span class="line-removed">-     bpneq t1, [cfr, t0, 8], .opJneqPtrTarget</span>
      dispatch()
  
  .opJneqPtrTarget:
      metadata(t5, t0)
      storeb 1, OpJneqPtr::Metadata::m_hasJumped[t5]
      get(m_targetLabel, t0)
<span class="line-modified">!     jumpImpl(t0)</span>
  end)
  
  
  macro compareJumpOp(opcodeName, opcodeStruct, integerCompare, doubleCompare)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_lhs, t2)
          get(m_rhs, t3)
          loadConstantOrVariable(size, t2, t0)
          loadConstantOrVariable(size, t3, t1)
<span class="line-modified">!         bqb t0, tagTypeNumber, .op1NotInt</span>
<span class="line-modified">!         bqb t1, tagTypeNumber, .op2NotInt</span>
          integerCompare(t0, t1, .jumpTarget)
          dispatch()
  
      .op1NotInt:
<span class="line-modified">!         btqz t0, tagTypeNumber, .slow</span>
<span class="line-modified">!         bqb t1, tagTypeNumber, .op1NotIntOp2NotInt</span>
<span class="line-modified">!         ci2d t1, ft1</span>
          jmp .op1NotIntReady
      .op1NotIntOp2NotInt:
<span class="line-modified">!         btqz t1, tagTypeNumber, .slow</span>
<span class="line-modified">!         addq tagTypeNumber, t1</span>
          fq2d t1, ft1
      .op1NotIntReady:
<span class="line-modified">!         addq tagTypeNumber, t0</span>
          fq2d t0, ft0
          doubleCompare(ft0, ft1, .jumpTarget)
          dispatch()
  
      .op2NotInt:
<span class="line-modified">!         ci2d t0, ft0</span>
<span class="line-modified">!         btqz t1, tagTypeNumber, .slow</span>
<span class="line-modified">!         addq tagTypeNumber, t1</span>
          fq2d t1, ft1
          doubleCompare(ft0, ft1, .jumpTarget)
          dispatch()
  
      .jumpTarget:
<span class="line-new-header">--- 1851,53 ---</span>
  undefinedOrNullJumpOp(jnundefined_or_null, OpJnundefinedOrNull,
      macro (value, target) bqneq value, ValueNull, target end)
  
  llintOpWithMetadata(op_jneq_ptr, OpJneqPtr, macro (size, get, dispatch, metadata, return)
      get(m_value, t0)
<span class="line-modified">!     get(m_specialPointer, t1)</span>
<span class="line-modified">!     loadConstant(size, t1, t2)</span>
<span class="line-modified">!     bpneq t2, [cfr, t0, 8], .opJneqPtrTarget</span>
      dispatch()
  
  .opJneqPtrTarget:
      metadata(t5, t0)
      storeb 1, OpJneqPtr::Metadata::m_hasJumped[t5]
      get(m_targetLabel, t0)
<span class="line-modified">!     jumpImpl(dispatchIndirect, t0)</span>
  end)
  
  
  macro compareJumpOp(opcodeName, opcodeStruct, integerCompare, doubleCompare)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_lhs, t2)
          get(m_rhs, t3)
          loadConstantOrVariable(size, t2, t0)
          loadConstantOrVariable(size, t3, t1)
<span class="line-modified">!         bqb t0, numberTag, .op1NotInt</span>
<span class="line-modified">!         bqb t1, numberTag, .op2NotInt</span>
          integerCompare(t0, t1, .jumpTarget)
          dispatch()
  
      .op1NotInt:
<span class="line-modified">!         btqz t0, numberTag, .slow</span>
<span class="line-modified">!         bqb t1, numberTag, .op1NotIntOp2NotInt</span>
<span class="line-modified">!         ci2ds t1, ft1</span>
          jmp .op1NotIntReady
      .op1NotIntOp2NotInt:
<span class="line-modified">!         btqz t1, numberTag, .slow</span>
<span class="line-modified">!         addq numberTag, t1</span>
          fq2d t1, ft1
      .op1NotIntReady:
<span class="line-modified">!         addq numberTag, t0</span>
          fq2d t0, ft0
          doubleCompare(ft0, ft1, .jumpTarget)
          dispatch()
  
      .op2NotInt:
<span class="line-modified">!         ci2ds t0, ft0</span>
<span class="line-modified">!         btqz t1, numberTag, .slow</span>
<span class="line-modified">!         addq numberTag, t1</span>
          fq2d t1, ft1
          doubleCompare(ft0, ft1, .jumpTarget)
          dispatch()
  
      .jumpTarget:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1908,20 ***</span>
      loadp CodeBlock[cfr], t2
      loadp CodeBlock::m_rareData[t2], t2
      muli sizeof SimpleJumpTable, t3
      loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
      addp t3, t2
<span class="line-modified">!     bqb t1, tagTypeNumber, .opSwitchImmNotInt</span>
      subi SimpleJumpTable::min[t2], t1
      biaeq t1, SimpleJumpTable::branchOffsets + VectorSizeOffset[t2], .opSwitchImmFallThrough
      loadp SimpleJumpTable::branchOffsets + VectorBufferOffset[t2], t3
      loadis [t3, t1, 4], t1
      btiz t1, .opSwitchImmFallThrough
      dispatchIndirect(t1)
  
  .opSwitchImmNotInt:
<span class="line-modified">!     btqnz t1, tagTypeNumber, .opSwitchImmSlow   # Go slow if it&#39;s a double.</span>
  .opSwitchImmFallThrough:
      jump(m_defaultOffset)
  
  .opSwitchImmSlow:
      callSlowPath(_llint_slow_path_switch_imm)
<span class="line-new-header">--- 1964,20 ---</span>
      loadp CodeBlock[cfr], t2
      loadp CodeBlock::m_rareData[t2], t2
      muli sizeof SimpleJumpTable, t3
      loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
      addp t3, t2
<span class="line-modified">!     bqb t1, numberTag, .opSwitchImmNotInt</span>
      subi SimpleJumpTable::min[t2], t1
      biaeq t1, SimpleJumpTable::branchOffsets + VectorSizeOffset[t2], .opSwitchImmFallThrough
      loadp SimpleJumpTable::branchOffsets + VectorBufferOffset[t2], t3
      loadis [t3, t1, 4], t1
      btiz t1, .opSwitchImmFallThrough
      dispatchIndirect(t1)
  
  .opSwitchImmNotInt:
<span class="line-modified">!     btqnz t1, numberTag, .opSwitchImmSlow   # Go slow if it&#39;s a double.</span>
  .opSwitchImmFallThrough:
      jump(m_defaultOffset)
  
  .opSwitchImmSlow:
      callSlowPath(_llint_slow_path_switch_imm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1936,11 ***</span>
      loadp CodeBlock[cfr], t2
      loadp CodeBlock::m_rareData[t2], t2
      muli sizeof SimpleJumpTable, t3
      loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
      addp t3, t2
<span class="line-modified">!     btqnz t1, tagMask, .opSwitchCharFallThrough</span>
      bbneq JSCell::m_type[t1], StringType, .opSwitchCharFallThrough
      loadp JSString::m_fiber[t1], t0
      btpnz t0, isRopeInPointer, .opSwitchOnRope
      bineq StringImpl::m_length[t0], 1, .opSwitchCharFallThrough
      loadp StringImpl::m_data8[t0], t1
<span class="line-new-header">--- 1992,11 ---</span>
      loadp CodeBlock[cfr], t2
      loadp CodeBlock::m_rareData[t2], t2
      muli sizeof SimpleJumpTable, t3
      loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
      addp t3, t2
<span class="line-modified">!     btqnz t1, notCellMask, .opSwitchCharFallThrough</span>
      bbneq JSCell::m_type[t1], StringType, .opSwitchCharFallThrough
      loadp JSString::m_fiber[t1], t0
      btpnz t0, isRopeInPointer, .opSwitchOnRope
      bineq StringImpl::m_length[t0], 1, .opSwitchCharFallThrough
      loadp StringImpl::m_data8[t0], t1
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1972,11 ***</span>
  # we assume t5 contains the metadata, and we should not scratch that
  macro arrayProfileForCall(opcodeStruct, getu)
      getu(m_argv, t3)
      negp t3
      loadq ThisArgumentOffset[cfr, t3, 8], t0
<span class="line-modified">!     btqnz t0, tagMask, .done</span>
      loadi JSCell::m_structureID[t0], t3
      storei t3, %opcodeStruct%::Metadata::m_callLinkInfo.m_arrayProfile.m_lastSeenStructureID[t5]
  .done:
  end
  
<span class="line-new-header">--- 2028,11 ---</span>
  # we assume t5 contains the metadata, and we should not scratch that
  macro arrayProfileForCall(opcodeStruct, getu)
      getu(m_argv, t3)
      negp t3
      loadq ThisArgumentOffset[cfr, t3, 8], t0
<span class="line-modified">!     btqnz t0, notCellMask, .done</span>
      loadi JSCell::m_structureID[t0], t3
      storei t3, %opcodeStruct%::Metadata::m_callLinkInfo.m_arrayProfile.m_lastSeenStructureID[t5]
  .done:
  end
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1996,18 ***</span>
          lshifti 3, t3
          negp t3
          addp cfr, t3
          storeq t2, Callee[t3]
          getu(size, opcodeStruct, m_argc, t2)
<span class="line-modified">!         storei PC, ArgumentCount + TagOffset[cfr]</span>
<span class="line-modified">!         storei t2, ArgumentCount + PayloadOffset[t3]</span>
          move t3, sp
          prepareCall(%opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], t2, t3, t4, JSEntryPtrTag)
<span class="line-modified">!         callTargetFunction(size, opcodeStruct, dispatch, %opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], JSEntryPtrTag)</span>
  
      .opCallSlow:
<span class="line-modified">!         slowPathForCall(size, opcodeStruct, dispatch, slowPath, prepareCall)</span>
      end)
  end
  
  llintOp(op_ret, OpRet, macro (size, get, dispatch)
      checkSwitchToJITForEpilogue()
<span class="line-new-header">--- 2052,18 ---</span>
          lshifti 3, t3
          negp t3
          addp cfr, t3
          storeq t2, Callee[t3]
          getu(size, opcodeStruct, m_argc, t2)
<span class="line-modified">!         storePC()</span>
<span class="line-modified">!         storei t2, ArgumentCountIncludingThis + PayloadOffset[t3]</span>
          move t3, sp
          prepareCall(%opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], t2, t3, t4, JSEntryPtrTag)
<span class="line-modified">!         callTargetFunction(opcodeName, size, opcodeStruct, dispatch, %opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], JSEntryPtrTag)</span>
  
      .opCallSlow:
<span class="line-modified">!         slowPathForCall(opcodeName, size, opcodeStruct, dispatch, slowPath, prepareCall)</span>
      end)
  end
  
  llintOp(op_ret, OpRet, macro (size, get, dispatch)
      checkSwitchToJITForEpilogue()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2018,30 ***</span>
  
  
  llintOpWithReturn(op_to_primitive, OpToPrimitive, macro (size, get, dispatch, return)
      get(m_src, t2)
      loadConstantOrVariable(size, t2, t0)
<span class="line-modified">!     btqnz t0, tagMask, .opToPrimitiveIsImm</span>
      bbaeq JSCell::m_type[t0], ObjectType, .opToPrimitiveSlowCase
  .opToPrimitiveIsImm:
      return(t0)
  
  .opToPrimitiveSlowCase:
      callSlowPath(_slow_path_to_primitive)
      dispatch()
  end)
  
  
  commonOp(llint_op_catch, macro() end, macro (size)
      # This is where we end up from the JIT&#39;s throw trampoline (because the
      # machine code return address will be set to _llint_op_catch), and from
      # the interpreter&#39;s throw trampoline (see _llint_throw_trampoline).
      # The throwing code must have known that we were throwing to the interpreter,
      # and have set VM::targetInterpreterPCForThrow.
      loadp Callee[cfr], t3
<span class="line-modified">!     andp MarkedBlockMask, t3</span>
<span class="line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
      restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
      loadp VM::callFrameForCatch[t3], cfr
      storep 0, VM::callFrameForCatch[t3]
      restoreStackPointerAfterCall()
  
<span class="line-new-header">--- 2074,46 ---</span>
  
  
  llintOpWithReturn(op_to_primitive, OpToPrimitive, macro (size, get, dispatch, return)
      get(m_src, t2)
      loadConstantOrVariable(size, t2, t0)
<span class="line-modified">!     btqnz t0, notCellMask, .opToPrimitiveIsImm</span>
      bbaeq JSCell::m_type[t0], ObjectType, .opToPrimitiveSlowCase
  .opToPrimitiveIsImm:
      return(t0)
  
  .opToPrimitiveSlowCase:
      callSlowPath(_slow_path_to_primitive)
      dispatch()
  end)
  
  
<span class="line-added">+ llintOpWithReturn(op_to_property_key, OpToPropertyKey, macro (size, get, dispatch, return)</span>
<span class="line-added">+     get(m_src, t2)</span>
<span class="line-added">+     loadConstantOrVariable(size, t2, t0)</span>
<span class="line-added">+ </span>
<span class="line-added">+     btqnz t0, notCellMask, .opToPropertyKeySlow</span>
<span class="line-added">+     bbeq JSCell::m_type[t0], SymbolType, .done</span>
<span class="line-added">+     bbneq JSCell::m_type[t0], StringType, .opToPropertyKeySlow</span>
<span class="line-added">+ </span>
<span class="line-added">+ .done:</span>
<span class="line-added">+     return(t0)</span>
<span class="line-added">+ </span>
<span class="line-added">+ .opToPropertyKeySlow:</span>
<span class="line-added">+     callSlowPath(_slow_path_to_property_key)</span>
<span class="line-added">+     dispatch()</span>
<span class="line-added">+ end)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  commonOp(llint_op_catch, macro() end, macro (size)
      # This is where we end up from the JIT&#39;s throw trampoline (because the
      # machine code return address will be set to _llint_op_catch), and from
      # the interpreter&#39;s throw trampoline (see _llint_throw_trampoline).
      # The throwing code must have known that we were throwing to the interpreter,
      # and have set VM::targetInterpreterPCForThrow.
      loadp Callee[cfr], t3
<span class="line-modified">!     convertCalleeToVM(t3)</span>
      restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
      loadp VM::callFrameForCatch[t3], cfr
      storep 0, VM::callFrameForCatch[t3]
      restoreStackPointerAfterCall()
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2054,13 ***</span>
      callSlowPath(_llint_slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
      bpeq r1, 0, .isCatchableException
      jmp _llint_throw_from_slow_path_trampoline
  
  .isCatchableException:
<span class="line-modified">!     loadp Callee[cfr], t3</span>
<span class="line-modified">!     andp MarkedBlockMask, t3</span>
<span class="line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
  
      loadp VM::m_exception[t3], t0
      storep 0, VM::m_exception[t3]
      get(size, OpCatch, m_exception, t2)
      storeq t0, [cfr, t2, 8]
<span class="line-new-header">--- 2126,12 ---</span>
      callSlowPath(_llint_slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
      bpeq r1, 0, .isCatchableException
      jmp _llint_throw_from_slow_path_trampoline
  
  .isCatchableException:
<span class="line-modified">!     loadp CodeBlock[cfr], t3</span>
<span class="line-modified">!     loadp CodeBlock::m_vm[t3], t3</span>
  
      loadp VM::m_exception[t3], t0
      storep 0, VM::m_exception[t3]
      get(size, OpCatch, m_exception, t2)
      storeq t0, [cfr, t2, 8]
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2086,22 ***</span>
  end)
  
  
  op(llint_throw_from_slow_path_trampoline, macro ()
      loadp Callee[cfr], t1
<span class="line-modified">!     andp MarkedBlockMask, t1</span>
<span class="line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
      copyCalleeSavesToVMEntryFrameCalleeSavesBuffer(t1, t2)
  
      callSlowPath(_llint_slow_path_handle_exception)
  
      # When throwing from the interpreter (i.e. throwing from LLIntSlowPaths), so
      # the throw target is not necessarily interpreted code, we come to here.
      # This essentially emulates the JIT&#39;s throwing protocol.
      loadp Callee[cfr], t1
<span class="line-modified">!     andp MarkedBlockMask, t1</span>
<span class="line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
      jmp VM::targetMachinePCForThrow[t1], ExceptionHandlerPtrTag
  end)
  
  
  op(llint_throw_during_call_trampoline, macro ()
<span class="line-new-header">--- 2157,20 ---</span>
  end)
  
  
  op(llint_throw_from_slow_path_trampoline, macro ()
      loadp Callee[cfr], t1
<span class="line-modified">!     convertCalleeToVM(t1)</span>
      copyCalleeSavesToVMEntryFrameCalleeSavesBuffer(t1, t2)
  
      callSlowPath(_llint_slow_path_handle_exception)
  
      # When throwing from the interpreter (i.e. throwing from LLIntSlowPaths), so
      # the throw target is not necessarily interpreted code, we come to here.
      # This essentially emulates the JIT&#39;s throwing protocol.
      loadp Callee[cfr], t1
<span class="line-modified">!     convertCalleeToVM(t1)</span>
      jmp VM::targetMachinePCForThrow[t1], ExceptionHandlerPtrTag
  end)
  
  
  op(llint_throw_during_call_trampoline, macro ()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2109,39 ***</span>
      jmp _llint_throw_from_slow_path_trampoline
  end)
  
  
  macro nativeCallTrampoline(executableOffsetToFunction)
<span class="line-removed">- </span>
      functionPrologue()
      storep 0, CodeBlock[cfr]
<span class="line-modified">!     loadp Callee[cfr], t0</span>
<span class="line-modified">!     andp MarkedBlockMask, t0, t1</span>
<span class="line-modified">!     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
<span class="line-modified">!     storep cfr, VM::topCallFrame[t1]</span>
      if ARM64 or ARM64E or C_LOOP or C_LOOP_WIN
          storep lr, ReturnPC[cfr]
      end
<span class="line-modified">!     move cfr, a0</span>
<span class="line-removed">-     loadp Callee[cfr], t1</span>
<span class="line-removed">-     loadp JSFunction::m_executable[t1], t1</span>
      checkStackPointerAlignment(t3, 0xdead0001)
      if C_LOOP or C_LOOP_WIN
<span class="line-modified">!         cloopCallNative executableOffsetToFunction[t1]</span>
      else
          if X86_64_WIN
              subp 32, sp
<span class="line-modified">!             call executableOffsetToFunction[t1], JSEntryPtrTag</span>
              addp 32, sp
          else
<span class="line-modified">!             call executableOffsetToFunction[t1], JSEntryPtrTag</span>
          end
      end
  
      loadp Callee[cfr], t3
<span class="line-modified">!     andp MarkedBlockMask, t3</span>
<span class="line-modified">!     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
  
      btpnz VM::m_exception[t3], .handleException
  
      functionEpilogue()
      ret
<span class="line-new-header">--- 2178,40 ---</span>
      jmp _llint_throw_from_slow_path_trampoline
  end)
  
  
  macro nativeCallTrampoline(executableOffsetToFunction)
      functionPrologue()
      storep 0, CodeBlock[cfr]
<span class="line-modified">!     loadp Callee[cfr], a0</span>
<span class="line-modified">!     loadp JSFunction::m_executableOrRareData[a0], a2</span>
<span class="line-modified">!     btpz a2, (constexpr JSFunction::rareDataTag), .isExecutable</span>
<span class="line-modified">!     loadp (FunctionRareData::m_executable - (constexpr JSFunction::rareDataTag))[a2], a2</span>
<span class="line-added">+ .isExecutable:</span>
<span class="line-added">+     loadp JSFunction::m_scope[a0], a0</span>
<span class="line-added">+     loadp JSGlobalObject::m_vm[a0], a1</span>
<span class="line-added">+     storep cfr, VM::topCallFrame[a1]</span>
      if ARM64 or ARM64E or C_LOOP or C_LOOP_WIN
          storep lr, ReturnPC[cfr]
      end
<span class="line-modified">!     move cfr, a1</span>
      checkStackPointerAlignment(t3, 0xdead0001)
      if C_LOOP or C_LOOP_WIN
<span class="line-modified">!         cloopCallNative executableOffsetToFunction[a2]</span>
      else
          if X86_64_WIN
              subp 32, sp
<span class="line-modified">!             call executableOffsetToFunction[a2], JSEntryPtrTag</span>
              addp 32, sp
          else
<span class="line-modified">!             call executableOffsetToFunction[a2], JSEntryPtrTag</span>
          end
      end
  
      loadp Callee[cfr], t3
<span class="line-modified">!     loadp JSFunction::m_scope[t3], t3</span>
<span class="line-modified">!     loadp JSGlobalObject::m_vm[t3], t3</span>
  
      btpnz VM::m_exception[t3], .handleException
  
      functionEpilogue()
      ret
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2152,35 ***</span>
  end
  
  macro internalFunctionCallTrampoline(offsetOfFunction)
      functionPrologue()
      storep 0, CodeBlock[cfr]
<span class="line-modified">!     loadp Callee[cfr], t0</span>
<span class="line-modified">!     andp MarkedBlockMask, t0, t1</span>
<span class="line-modified">!     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
<span class="line-modified">!     storep cfr, VM::topCallFrame[t1]</span>
      if ARM64 or ARM64E or C_LOOP or C_LOOP_WIN
          storep lr, ReturnPC[cfr]
      end
<span class="line-modified">!     move cfr, a0</span>
<span class="line-removed">-     loadp Callee[cfr], t1</span>
      checkStackPointerAlignment(t3, 0xdead0001)
      if C_LOOP or C_LOOP_WIN
<span class="line-modified">!         cloopCallNative offsetOfFunction[t1]</span>
      else
          if X86_64_WIN
              subp 32, sp
<span class="line-modified">!             call offsetOfFunction[t1], JSEntryPtrTag</span>
              addp 32, sp
          else
<span class="line-modified">!             call offsetOfFunction[t1], JSEntryPtrTag</span>
          end
      end
  
      loadp Callee[cfr], t3
<span class="line-modified">!     andp MarkedBlockMask, t3</span>
<span class="line-modified">!     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
  
      btpnz VM::m_exception[t3], .handleException
  
      functionEpilogue()
      ret
<span class="line-new-header">--- 2222,34 ---</span>
  end
  
  macro internalFunctionCallTrampoline(offsetOfFunction)
      functionPrologue()
      storep 0, CodeBlock[cfr]
<span class="line-modified">!     loadp Callee[cfr], a2</span>
<span class="line-modified">!     loadp InternalFunction::m_globalObject[a2], a0</span>
<span class="line-modified">!     loadp JSGlobalObject::m_vm[a0], a1</span>
<span class="line-modified">!     storep cfr, VM::topCallFrame[a1]</span>
      if ARM64 or ARM64E or C_LOOP or C_LOOP_WIN
          storep lr, ReturnPC[cfr]
      end
<span class="line-modified">!     move cfr, a1</span>
      checkStackPointerAlignment(t3, 0xdead0001)
      if C_LOOP or C_LOOP_WIN
<span class="line-modified">!         cloopCallNative offsetOfFunction[a2]</span>
      else
          if X86_64_WIN
              subp 32, sp
<span class="line-modified">!             call offsetOfFunction[a2], JSEntryPtrTag</span>
              addp 32, sp
          else
<span class="line-modified">!             call offsetOfFunction[a2], JSEntryPtrTag</span>
          end
      end
  
      loadp Callee[cfr], t3
<span class="line-modified">!     loadp InternalFunction::m_globalObject[t3], t3</span>
<span class="line-modified">!     loadp JSGlobalObject::m_vm[t3], t3</span>
  
      btpnz VM::m_exception[t3], .handleException
  
      functionEpilogue()
      ret
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2540,11 ***</span>
      # Store the TypeLocation onto the log entry.
      metadata(t5, t3)
      loadp OpProfileType::Metadata::m_typeLocation[t5], t3
      storep t3, TypeProfilerLog::LogEntry::location[t2]
  
<span class="line-modified">!     btqz t0, tagMask, .opProfileTypeIsCell</span>
      storei 0, TypeProfilerLog::LogEntry::structureID[t2]
      jmp .opProfileTypeSkipIsCell
  .opProfileTypeIsCell:
      loadi JSCell::m_structureID[t0], t3
      storei t3, TypeProfilerLog::LogEntry::structureID[t2]
<span class="line-new-header">--- 2609,11 ---</span>
      # Store the TypeLocation onto the log entry.
      metadata(t5, t3)
      loadp OpProfileType::Metadata::m_typeLocation[t5], t3
      storep t3, TypeProfilerLog::LogEntry::location[t2]
  
<span class="line-modified">!     btqz t0, notCellMask, .opProfileTypeIsCell</span>
      storei 0, TypeProfilerLog::LogEntry::structureID[t2]
      jmp .opProfileTypeSkipIsCell
  .opProfileTypeIsCell:
      loadi JSCell::m_structureID[t0], t3
      storei t3, TypeProfilerLog::LogEntry::structureID[t2]
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2570,23 ***</span>
      dispatch()
  end)
  
  
  llintOpWithReturn(op_get_rest_length, OpGetRestLength, macro (size, get, dispatch, return)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
      subi 1, t0
      getu(size, OpGetRestLength, m_numParametersToSkip, t1)
      bilteq t0, t1, .storeZero
      subi t1, t0
      jmp .boxUp
  .storeZero:
      move 0, t0
  .boxUp:
<span class="line-modified">!     orq tagTypeNumber, t0</span>
      return(t0)
  end)
  
  
  llintOp(op_log_shadow_chicken_prologue, OpLogShadowChickenPrologue, macro (size, get, dispatch)
      acquireShadowChickenPacket(.opLogShadowChickenPrologueSlow)
      storep cfr, ShadowChicken::Packet::frame[t0]
      loadp CallerFrame[cfr], t1
<span class="line-new-header">--- 2639,41 ---</span>
      dispatch()
  end)
  
  
  llintOpWithReturn(op_get_rest_length, OpGetRestLength, macro (size, get, dispatch, return)
<span class="line-modified">!     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      subi 1, t0
      getu(size, OpGetRestLength, m_numParametersToSkip, t1)
      bilteq t0, t1, .storeZero
      subi t1, t0
      jmp .boxUp
  .storeZero:
      move 0, t0
  .boxUp:
<span class="line-modified">!     orq numberTag, t0</span>
<span class="line-added">+     return(t0)</span>
<span class="line-added">+ end)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ llintOpWithProfile(op_get_internal_field, OpGetInternalField, macro (size, get, dispatch, return)</span>
<span class="line-added">+     loadVariable(get, m_base, t1)</span>
<span class="line-added">+     getu(size, OpGetInternalField, m_index, t2)</span>
<span class="line-added">+     loadq JSInternalFieldObjectImpl_internalFields[t1, t2, SlotSize], t0</span>
      return(t0)
  end)
  
<span class="line-added">+ llintOp(op_put_internal_field, OpPutInternalField, macro (size, get, dispatch)</span>
<span class="line-added">+     loadVariable(get, m_base, t0)</span>
<span class="line-added">+     get(m_value, t1)</span>
<span class="line-added">+     loadConstantOrVariable(size, t1, t2)</span>
<span class="line-added">+     getu(size, OpPutInternalField, m_index, t1)</span>
<span class="line-added">+     storeq t2, JSInternalFieldObjectImpl_internalFields[t0, t1, SlotSize]</span>
<span class="line-added">+     writeBarrierOnCellAndValueWithReload(t0, t2, macro() end)</span>
<span class="line-added">+     dispatch()</span>
<span class="line-added">+ end)</span>
<span class="line-added">+ </span>
  
  llintOp(op_log_shadow_chicken_prologue, OpLogShadowChickenPrologue, macro (size, get, dispatch)
      acquireShadowChickenPacket(.opLogShadowChickenPrologueSlow)
      storep cfr, ShadowChicken::Packet::frame[t0]
      loadp CallerFrame[cfr], t1
</pre>
<center><a href="LowLevelInterpreter32_64.asm.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../offlineasm/arm.rb.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextIterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TypingCommand.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 // FIXME: Move each iterator class into a separate header file.
 29 
 30 #include &quot;FindOptions.h&quot;

 31 #include &quot;Range.h&quot;
 32 #include &quot;TextIteratorBehavior.h&quot;
 33 #include &lt;wtf/Vector.h&gt;
 34 #include &lt;wtf/text/StringView.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 class InlineTextBox;
 39 class RenderText;
 40 class RenderTextFragment;
 41 
 42 namespace SimpleLineLayout {
 43 class RunResolver;
 44 }
 45 
 46 WEBCORE_EXPORT String plainText(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 47 WEBCORE_EXPORT String plainTextReplacingNoBreakSpace(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 48 
 49 WEBCORE_EXPORT String plainText(const Range*, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 50 WEBCORE_EXPORT String plainTextReplacingNoBreakSpace(const Range*, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
</pre>
<hr />
<pre>
150     bool m_handledChildren { false };
151     BitStack m_fullyClippedStack;
152 
153     // The range.
154     Node* m_startContainer { nullptr };
155     int m_startOffset { 0 };
156     Node* m_endContainer { nullptr };
157     int m_endOffset { 0 };
158     Node* m_pastEndNode { nullptr };
159 
160     // The current text and its position, in the form to be returned from the iterator.
161     Node* m_positionNode { nullptr };
162     mutable Node* m_positionOffsetBaseNode { nullptr };
163     mutable int m_positionStartOffset { 0 };
164     mutable int m_positionEndOffset { 0 };
165     TextIteratorCopyableText m_copyableText;
166     StringView m_text;
167 
168     // Used when there is still some pending text from the current node; when these are false and null, we go back to normal iterating.
169     Node* m_nodeForAdditionalNewline { nullptr };
<span class="line-modified">170     InlineTextBox* m_textBox { nullptr };</span>
171 
172     // Used when iterating over :first-letter text to save pointer to remaining text box.
<span class="line-modified">173     InlineTextBox* m_remainingTextBox { nullptr };</span>
174 
175     // Used to point to RenderText object for :first-letter.
176     RenderText* m_firstLetterText { nullptr };
177 
178     // Used to do the whitespace collapsing logic.
179     Text* m_lastTextNode { nullptr };
180     bool m_lastTextNodeEndedWithCollapsedSpace { false };
181     UChar m_lastCharacter { 0 };
182 
<span class="line-removed">183     // Used to do simple line layout run logic.</span>
<span class="line-removed">184     bool m_nextRunNeedsWhitespace { false };</span>
<span class="line-removed">185     unsigned m_accumulatedSimpleTextLengthInFlow { 0 };</span>
<span class="line-removed">186     Text* m_previousSimpleTextNodeInFlow { nullptr };</span>
<span class="line-removed">187     std::unique_ptr&lt;SimpleLineLayout::RunResolver&gt; m_flowRunResolverCache;</span>
<span class="line-removed">188 </span>
<span class="line-removed">189     // Used when text boxes are out of order (Hebrew/Arabic with embedded LTR text)</span>
<span class="line-removed">190     Vector&lt;InlineTextBox*&gt; m_sortedTextBoxes;</span>
<span class="line-removed">191     size_t m_sortedTextBoxesPosition { 0 };</span>
<span class="line-removed">192 </span>
193     // Used when deciding whether to emit a &quot;positioning&quot; (e.g. newline) before any other content
194     bool m_hasEmitted { false };
195 
196     // Used when deciding text fragment created by :first-letter should be looked into.
197     bool m_handledFirstLetter { false };
198 };
199 
200 // Iterates through the DOM range, returning all the text, and 0-length boundaries
201 // at points where replaced elements break up the text flow. The text comes back in
202 // chunks so as to optimize for performance of the iteration.
203 class SimplifiedBackwardsTextIterator {
204 public:
205     explicit SimplifiedBackwardsTextIterator(const Range&amp;);
206 
207     bool atEnd() const { return !m_positionNode; }
208     void advance();
209 
210     StringView text() const { ASSERT(!atEnd()); return m_text; }
211     WEBCORE_EXPORT Ref&lt;Range&gt; range() const;
212     Node* node() const { ASSERT(!atEnd()); return m_node; }
</pre>
<hr />
<pre>
240     int m_positionStartOffset { 0 };
241     int m_positionEndOffset { 0 };
242     TextIteratorCopyableText m_copyableText;
243     StringView m_text;
244 
245     // Used to do the whitespace logic.
246     Text* m_lastTextNode { nullptr };
247     UChar m_lastCharacter { 0 };
248 
249     // Whether m_node has advanced beyond the iteration range (i.e. m_startContainer).
250     bool m_havePassedStartContainer { false };
251 
252     // Should handle first-letter renderer in the next call to handleTextNode.
253     bool m_shouldHandleFirstLetter { false };
254 };
255 
256 // Builds on the text iterator, adding a character position so we can walk one
257 // character at a time, or faster, as needed. Useful for searching.
258 class CharacterIterator {
259 public:
<span class="line-modified">260     explicit CharacterIterator(const Range&amp;, TextIteratorBehavior = TextIteratorDefaultBehavior);</span>
261     WEBCORE_EXPORT explicit CharacterIterator(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior);
262 
263     bool atEnd() const { return m_underlyingIterator.atEnd(); }
264     WEBCORE_EXPORT void advance(int numCharacters);
265 
266     StringView text() const { return m_underlyingIterator.text().substring(m_runOffset); }
267     WEBCORE_EXPORT Ref&lt;Range&gt; range() const;
268 
269     bool atBreak() const { return m_atBreak; }
270     int characterOffset() const { return m_offset; }
271 
272 private:
273     TextIterator m_underlyingIterator;
274 
275     int m_offset { 0 };
276     int m_runOffset { 0 };
277     bool m_atBreak { true };
278 };
279 
280 class BackwardsCharacterIterator {
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 // FIXME: Move each iterator class into a separate header file.
 29 
 30 #include &quot;FindOptions.h&quot;
<span class="line-added"> 31 #include &quot;LineLayoutTraversal.h&quot;</span>
 32 #include &quot;Range.h&quot;
 33 #include &quot;TextIteratorBehavior.h&quot;
 34 #include &lt;wtf/Vector.h&gt;
 35 #include &lt;wtf/text/StringView.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 class InlineTextBox;
 40 class RenderText;
 41 class RenderTextFragment;
 42 
 43 namespace SimpleLineLayout {
 44 class RunResolver;
 45 }
 46 
 47 WEBCORE_EXPORT String plainText(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 48 WEBCORE_EXPORT String plainTextReplacingNoBreakSpace(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 49 
 50 WEBCORE_EXPORT String plainText(const Range*, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 51 WEBCORE_EXPORT String plainTextReplacingNoBreakSpace(const Range*, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
</pre>
<hr />
<pre>
151     bool m_handledChildren { false };
152     BitStack m_fullyClippedStack;
153 
154     // The range.
155     Node* m_startContainer { nullptr };
156     int m_startOffset { 0 };
157     Node* m_endContainer { nullptr };
158     int m_endOffset { 0 };
159     Node* m_pastEndNode { nullptr };
160 
161     // The current text and its position, in the form to be returned from the iterator.
162     Node* m_positionNode { nullptr };
163     mutable Node* m_positionOffsetBaseNode { nullptr };
164     mutable int m_positionStartOffset { 0 };
165     mutable int m_positionEndOffset { 0 };
166     TextIteratorCopyableText m_copyableText;
167     StringView m_text;
168 
169     // Used when there is still some pending text from the current node; when these are false and null, we go back to normal iterating.
170     Node* m_nodeForAdditionalNewline { nullptr };
<span class="line-modified">171     LineLayoutTraversal::TextBoxIterator m_textBox;</span>
172 
173     // Used when iterating over :first-letter text to save pointer to remaining text box.
<span class="line-modified">174     LineLayoutTraversal::TextBoxIterator m_remainingTextBox;</span>
175 
176     // Used to point to RenderText object for :first-letter.
177     RenderText* m_firstLetterText { nullptr };
178 
179     // Used to do the whitespace collapsing logic.
180     Text* m_lastTextNode { nullptr };
181     bool m_lastTextNodeEndedWithCollapsedSpace { false };
182     UChar m_lastCharacter { 0 };
183 










184     // Used when deciding whether to emit a &quot;positioning&quot; (e.g. newline) before any other content
185     bool m_hasEmitted { false };
186 
187     // Used when deciding text fragment created by :first-letter should be looked into.
188     bool m_handledFirstLetter { false };
189 };
190 
191 // Iterates through the DOM range, returning all the text, and 0-length boundaries
192 // at points where replaced elements break up the text flow. The text comes back in
193 // chunks so as to optimize for performance of the iteration.
194 class SimplifiedBackwardsTextIterator {
195 public:
196     explicit SimplifiedBackwardsTextIterator(const Range&amp;);
197 
198     bool atEnd() const { return !m_positionNode; }
199     void advance();
200 
201     StringView text() const { ASSERT(!atEnd()); return m_text; }
202     WEBCORE_EXPORT Ref&lt;Range&gt; range() const;
203     Node* node() const { ASSERT(!atEnd()); return m_node; }
</pre>
<hr />
<pre>
231     int m_positionStartOffset { 0 };
232     int m_positionEndOffset { 0 };
233     TextIteratorCopyableText m_copyableText;
234     StringView m_text;
235 
236     // Used to do the whitespace logic.
237     Text* m_lastTextNode { nullptr };
238     UChar m_lastCharacter { 0 };
239 
240     // Whether m_node has advanced beyond the iteration range (i.e. m_startContainer).
241     bool m_havePassedStartContainer { false };
242 
243     // Should handle first-letter renderer in the next call to handleTextNode.
244     bool m_shouldHandleFirstLetter { false };
245 };
246 
247 // Builds on the text iterator, adding a character position so we can walk one
248 // character at a time, or faster, as needed. Useful for searching.
249 class CharacterIterator {
250 public:
<span class="line-modified">251     WEBCORE_EXPORT explicit CharacterIterator(const Range&amp;, TextIteratorBehavior = TextIteratorDefaultBehavior);</span>
252     WEBCORE_EXPORT explicit CharacterIterator(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior);
253 
254     bool atEnd() const { return m_underlyingIterator.atEnd(); }
255     WEBCORE_EXPORT void advance(int numCharacters);
256 
257     StringView text() const { return m_underlyingIterator.text().substring(m_runOffset); }
258     WEBCORE_EXPORT Ref&lt;Range&gt; range() const;
259 
260     bool atBreak() const { return m_atBreak; }
261     int characterOffset() const { return m_offset; }
262 
263 private:
264     TextIterator m_underlyingIterator;
265 
266     int m_offset { 0 };
267     int m_runOffset { 0 };
268     bool m_atBreak { true };
269 };
270 
271 class BackwardsCharacterIterator {
</pre>
</td>
</tr>
</table>
<center><a href="TextIterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TypingCommand.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ClassInfo.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ClonedArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ClassInfo.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
<span class="line-removed"> 25 #include &quot;CallFrame.h&quot;</span>
 26 #include &quot;ConstructData.h&quot;
 27 #include &quot;JSCast.h&quot;
 28 #include &lt;wtf/PtrTag.h&gt;
 29 
 30 namespace WTF {
 31 class PrintStream;
 32 };
 33 
 34 namespace JSC {
 35 
 36 class HeapAnalyzer;
 37 class JSArrayBufferView;
 38 class Snippet;
 39 struct HashTable;
 40 
 41 #define METHOD_TABLE_ENTRY(method) \
 42     WTF_VTBL_FUNCPTR_PTRAUTH_STR(&quot;MethodTable.&quot; #method) method
 43 
 44 struct MethodTable {
 45     using DestroyFunctionPtr = void (*)(JSCell*);
 46     DestroyFunctionPtr METHOD_TABLE_ENTRY(destroy);
 47 
 48     using VisitChildrenFunctionPtr = void (*)(JSCell*, SlotVisitor&amp;);
 49     VisitChildrenFunctionPtr METHOD_TABLE_ENTRY(visitChildren);
 50 
 51     using GetCallDataFunctionPtr = CallType (*)(JSCell*, CallData&amp;);
 52     GetCallDataFunctionPtr METHOD_TABLE_ENTRY(getCallData);
 53 
 54     using GetConstructDataFunctionPtr = ConstructType (*)(JSCell*, ConstructData&amp;);
 55     GetConstructDataFunctionPtr METHOD_TABLE_ENTRY(getConstructData);
 56 
<span class="line-modified"> 57     using PutFunctionPtr = bool (*)(JSCell*, ExecState*, PropertyName propertyName, JSValue, PutPropertySlot&amp;);</span>
 58     PutFunctionPtr METHOD_TABLE_ENTRY(put);
 59 
<span class="line-modified"> 60     using PutByIndexFunctionPtr = bool (*)(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
 61     PutByIndexFunctionPtr METHOD_TABLE_ENTRY(putByIndex);
 62 
<span class="line-modified"> 63     using DeletePropertyFunctionPtr = bool (*)(JSCell*, ExecState*, PropertyName);</span>
 64     DeletePropertyFunctionPtr METHOD_TABLE_ENTRY(deleteProperty);
 65 
<span class="line-modified"> 66     using DeletePropertyByIndexFunctionPtr = bool (*)(JSCell*, ExecState*, unsigned);</span>
 67     DeletePropertyByIndexFunctionPtr METHOD_TABLE_ENTRY(deletePropertyByIndex);
 68 
<span class="line-modified"> 69     using GetOwnPropertySlotFunctionPtr = bool (*)(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
 70     GetOwnPropertySlotFunctionPtr METHOD_TABLE_ENTRY(getOwnPropertySlot);
 71 
<span class="line-modified"> 72     using GetOwnPropertySlotByIndexFunctionPtr = bool (*)(JSObject*, ExecState*, unsigned, PropertySlot&amp;);</span>
 73     GetOwnPropertySlotByIndexFunctionPtr METHOD_TABLE_ENTRY(getOwnPropertySlotByIndex);
 74 
<span class="line-modified"> 75     using DoPutPropertySecurityCheckFunctionPtr = void (*)(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;);</span>
 76     DoPutPropertySecurityCheckFunctionPtr METHOD_TABLE_ENTRY(doPutPropertySecurityCheck);
 77 
<span class="line-modified"> 78     using ToThisFunctionPtr = JSValue (*)(JSCell*, ExecState*, ECMAMode);</span>
 79     ToThisFunctionPtr METHOD_TABLE_ENTRY(toThis);
 80 
<span class="line-modified"> 81     using DefaultValueFunctionPtr = JSValue (*)(const JSObject*, ExecState*, PreferredPrimitiveType);</span>
 82     DefaultValueFunctionPtr METHOD_TABLE_ENTRY(defaultValue);
 83 
<span class="line-modified"> 84     using GetOwnPropertyNamesFunctionPtr = void (*)(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
 85     GetOwnPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getOwnPropertyNames);
 86 
<span class="line-modified"> 87     using GetOwnNonIndexPropertyNamesFunctionPtr = void (*)(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
 88     GetOwnNonIndexPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getOwnNonIndexPropertyNames);
 89 
<span class="line-modified"> 90     using GetPropertyNamesFunctionPtr = void (*)(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
 91     GetPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getPropertyNames);
 92 
<span class="line-modified"> 93     using GetEnumerableLengthFunctionPtr = uint32_t (*)(ExecState*, JSObject*);</span>
 94     GetEnumerableLengthFunctionPtr METHOD_TABLE_ENTRY(getEnumerableLength);
 95 
 96     GetPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getStructurePropertyNames);
 97     GetPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getGenericPropertyNames);
 98 
 99     using ClassNameFunctionPtr = String (*)(const JSObject*, VM&amp;);
100     ClassNameFunctionPtr METHOD_TABLE_ENTRY(className);
101 
<span class="line-modified">102     using ToStringNameFunctionPtr = String (*)(const JSObject*, ExecState*);</span>
103     ToStringNameFunctionPtr METHOD_TABLE_ENTRY(toStringName);
104 
<span class="line-modified">105     using CustomHasInstanceFunctionPtr = bool (*)(JSObject*, ExecState*, JSValue);</span>
106     CustomHasInstanceFunctionPtr METHOD_TABLE_ENTRY(customHasInstance);
107 
<span class="line-modified">108     using DefineOwnPropertyFunctionPtr = bool (*)(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool);</span>
109     DefineOwnPropertyFunctionPtr METHOD_TABLE_ENTRY(defineOwnProperty);
110 
<span class="line-modified">111     using PreventExtensionsFunctionPtr = bool (*)(JSObject*, ExecState*);</span>
112     PreventExtensionsFunctionPtr METHOD_TABLE_ENTRY(preventExtensions);
113 
<span class="line-modified">114     using IsExtensibleFunctionPtr = bool (*)(JSObject*, ExecState*);</span>
115     IsExtensibleFunctionPtr METHOD_TABLE_ENTRY(isExtensible);
116 
<span class="line-modified">117     using SetPrototypeFunctionPtr = bool (*)(JSObject*, ExecState*, JSValue, bool shouldThrowIfCantSet);</span>
118     SetPrototypeFunctionPtr METHOD_TABLE_ENTRY(setPrototype);
119 
<span class="line-modified">120     using GetPrototypeFunctionPtr = JSValue (*)(JSObject*, ExecState*);</span>
121     GetPrototypeFunctionPtr METHOD_TABLE_ENTRY(getPrototype);
122 
123     using DumpToStreamFunctionPtr = void (*)(const JSCell*, PrintStream&amp;);
124     DumpToStreamFunctionPtr METHOD_TABLE_ENTRY(dumpToStream);
125 
126     using AnalyzeHeapFunctionPtr = void (*)(JSCell*, HeapAnalyzer&amp;);
127     AnalyzeHeapFunctionPtr METHOD_TABLE_ENTRY(analyzeHeap);
128 
129     using EstimatedSizeFunctionPtr = size_t (*)(JSCell*, VM&amp;);
130     EstimatedSizeFunctionPtr METHOD_TABLE_ENTRY(estimatedSize);
131 
132     using VisitOutputConstraintsPtr = void (*)(JSCell*, SlotVisitor&amp;);
133     VisitOutputConstraintsPtr METHOD_TABLE_ENTRY(visitOutputConstraints);
134 };
135 
136 #define CREATE_MEMBER_CHECKER(member) \
137     template &lt;typename T&gt; \
138     struct MemberCheck##member { \
139         struct Fallback { \
140             void member(...); \
</pre>
<hr />
<pre>
168         &amp;ClassName::defaultValue, \
169         &amp;ClassName::getOwnPropertyNames, \
170         &amp;ClassName::getOwnNonIndexPropertyNames, \
171         &amp;ClassName::getPropertyNames, \
172         &amp;ClassName::getEnumerableLength, \
173         &amp;ClassName::getStructurePropertyNames, \
174         &amp;ClassName::getGenericPropertyNames, \
175         &amp;ClassName::className, \
176         &amp;ClassName::toStringName, \
177         &amp;ClassName::customHasInstance, \
178         &amp;ClassName::defineOwnProperty, \
179         &amp;ClassName::preventExtensions, \
180         &amp;ClassName::isExtensible, \
181         &amp;ClassName::setPrototype, \
182         &amp;ClassName::getPrototype, \
183         &amp;ClassName::dumpToStream, \
184         &amp;ClassName::analyzeHeap, \
185         &amp;ClassName::estimatedSize, \
186         &amp;ClassName::visitOutputConstraints, \
187     }, \
<span class="line-modified">188     ClassName::TypedArrayStorageType</span>

189 
190 struct ClassInfo {


191     // A string denoting the class name. Example: &quot;Window&quot;.
192     const char* className;
<span class="line-removed">193 </span>
194     // Pointer to the class information of the base class.
195     // nullptrif there is none.
196     const ClassInfo* parentClass;





197 
198     static ptrdiff_t offsetOfParentClass()
199     {
200         return OBJECT_OFFSETOF(ClassInfo, parentClass);
201     }
202 
203     bool isSubClassOf(const ClassInfo* other) const
204     {
205         for (const ClassInfo* ci = this; ci; ci = ci-&gt;parentClass) {
206             if (ci == other)
207                 return true;
208         }
209         return false;
210     }
211 
212     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
213 
214     JS_EXPORT_PRIVATE bool hasStaticSetterOrReadonlyProperties() const;
<span class="line-removed">215 </span>
<span class="line-removed">216     const HashTable* staticPropHashTable;</span>
<span class="line-removed">217 </span>
<span class="line-removed">218     using CheckSubClassSnippetFunctionPtr = Ref&lt;Snippet&gt; (*)(void);</span>
<span class="line-removed">219     CheckSubClassSnippetFunctionPtr checkSubClassSnippet;</span>
<span class="line-removed">220 </span>
<span class="line-removed">221     MethodTable methodTable;</span>
<span class="line-removed">222 </span>
<span class="line-removed">223     TypedArrayType typedArrayStorageType;</span>
224 };
225 
226 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 

 25 #include &quot;ConstructData.h&quot;
 26 #include &quot;JSCast.h&quot;
 27 #include &lt;wtf/PtrTag.h&gt;
 28 
 29 namespace WTF {
 30 class PrintStream;
 31 };
 32 
 33 namespace JSC {
 34 
 35 class HeapAnalyzer;
 36 class JSArrayBufferView;
 37 class Snippet;
 38 struct HashTable;
 39 
 40 #define METHOD_TABLE_ENTRY(method) \
 41     WTF_VTBL_FUNCPTR_PTRAUTH_STR(&quot;MethodTable.&quot; #method) method
 42 
 43 struct MethodTable {
 44     using DestroyFunctionPtr = void (*)(JSCell*);
 45     DestroyFunctionPtr METHOD_TABLE_ENTRY(destroy);
 46 
 47     using VisitChildrenFunctionPtr = void (*)(JSCell*, SlotVisitor&amp;);
 48     VisitChildrenFunctionPtr METHOD_TABLE_ENTRY(visitChildren);
 49 
 50     using GetCallDataFunctionPtr = CallType (*)(JSCell*, CallData&amp;);
 51     GetCallDataFunctionPtr METHOD_TABLE_ENTRY(getCallData);
 52 
 53     using GetConstructDataFunctionPtr = ConstructType (*)(JSCell*, ConstructData&amp;);
 54     GetConstructDataFunctionPtr METHOD_TABLE_ENTRY(getConstructData);
 55 
<span class="line-modified"> 56     using PutFunctionPtr = bool (*)(JSCell*, JSGlobalObject*, PropertyName propertyName, JSValue, PutPropertySlot&amp;);</span>
 57     PutFunctionPtr METHOD_TABLE_ENTRY(put);
 58 
<span class="line-modified"> 59     using PutByIndexFunctionPtr = bool (*)(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
 60     PutByIndexFunctionPtr METHOD_TABLE_ENTRY(putByIndex);
 61 
<span class="line-modified"> 62     using DeletePropertyFunctionPtr = bool (*)(JSCell*, JSGlobalObject*, PropertyName);</span>
 63     DeletePropertyFunctionPtr METHOD_TABLE_ENTRY(deleteProperty);
 64 
<span class="line-modified"> 65     using DeletePropertyByIndexFunctionPtr = bool (*)(JSCell*, JSGlobalObject*, unsigned);</span>
 66     DeletePropertyByIndexFunctionPtr METHOD_TABLE_ENTRY(deletePropertyByIndex);
 67 
<span class="line-modified"> 68     using GetOwnPropertySlotFunctionPtr = bool (*)(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
 69     GetOwnPropertySlotFunctionPtr METHOD_TABLE_ENTRY(getOwnPropertySlot);
 70 
<span class="line-modified"> 71     using GetOwnPropertySlotByIndexFunctionPtr = bool (*)(JSObject*, JSGlobalObject*, unsigned, PropertySlot&amp;);</span>
 72     GetOwnPropertySlotByIndexFunctionPtr METHOD_TABLE_ENTRY(getOwnPropertySlotByIndex);
 73 
<span class="line-modified"> 74     using DoPutPropertySecurityCheckFunctionPtr = void (*)(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;);</span>
 75     DoPutPropertySecurityCheckFunctionPtr METHOD_TABLE_ENTRY(doPutPropertySecurityCheck);
 76 
<span class="line-modified"> 77     using ToThisFunctionPtr = JSValue (*)(JSCell*, JSGlobalObject*, ECMAMode);</span>
 78     ToThisFunctionPtr METHOD_TABLE_ENTRY(toThis);
 79 
<span class="line-modified"> 80     using DefaultValueFunctionPtr = JSValue (*)(const JSObject*, JSGlobalObject*, PreferredPrimitiveType);</span>
 81     DefaultValueFunctionPtr METHOD_TABLE_ENTRY(defaultValue);
 82 
<span class="line-modified"> 83     using GetOwnPropertyNamesFunctionPtr = void (*)(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
 84     GetOwnPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getOwnPropertyNames);
 85 
<span class="line-modified"> 86     using GetOwnNonIndexPropertyNamesFunctionPtr = void (*)(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
 87     GetOwnNonIndexPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getOwnNonIndexPropertyNames);
 88 
<span class="line-modified"> 89     using GetPropertyNamesFunctionPtr = void (*)(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
 90     GetPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getPropertyNames);
 91 
<span class="line-modified"> 92     using GetEnumerableLengthFunctionPtr = uint32_t (*)(JSGlobalObject*, JSObject*);</span>
 93     GetEnumerableLengthFunctionPtr METHOD_TABLE_ENTRY(getEnumerableLength);
 94 
 95     GetPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getStructurePropertyNames);
 96     GetPropertyNamesFunctionPtr METHOD_TABLE_ENTRY(getGenericPropertyNames);
 97 
 98     using ClassNameFunctionPtr = String (*)(const JSObject*, VM&amp;);
 99     ClassNameFunctionPtr METHOD_TABLE_ENTRY(className);
100 
<span class="line-modified">101     using ToStringNameFunctionPtr = String (*)(const JSObject*, JSGlobalObject*);</span>
102     ToStringNameFunctionPtr METHOD_TABLE_ENTRY(toStringName);
103 
<span class="line-modified">104     using CustomHasInstanceFunctionPtr = bool (*)(JSObject*, JSGlobalObject*, JSValue);</span>
105     CustomHasInstanceFunctionPtr METHOD_TABLE_ENTRY(customHasInstance);
106 
<span class="line-modified">107     using DefineOwnPropertyFunctionPtr = bool (*)(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool);</span>
108     DefineOwnPropertyFunctionPtr METHOD_TABLE_ENTRY(defineOwnProperty);
109 
<span class="line-modified">110     using PreventExtensionsFunctionPtr = bool (*)(JSObject*, JSGlobalObject*);</span>
111     PreventExtensionsFunctionPtr METHOD_TABLE_ENTRY(preventExtensions);
112 
<span class="line-modified">113     using IsExtensibleFunctionPtr = bool (*)(JSObject*, JSGlobalObject*);</span>
114     IsExtensibleFunctionPtr METHOD_TABLE_ENTRY(isExtensible);
115 
<span class="line-modified">116     using SetPrototypeFunctionPtr = bool (*)(JSObject*, JSGlobalObject*, JSValue, bool shouldThrowIfCantSet);</span>
117     SetPrototypeFunctionPtr METHOD_TABLE_ENTRY(setPrototype);
118 
<span class="line-modified">119     using GetPrototypeFunctionPtr = JSValue (*)(JSObject*, JSGlobalObject*);</span>
120     GetPrototypeFunctionPtr METHOD_TABLE_ENTRY(getPrototype);
121 
122     using DumpToStreamFunctionPtr = void (*)(const JSCell*, PrintStream&amp;);
123     DumpToStreamFunctionPtr METHOD_TABLE_ENTRY(dumpToStream);
124 
125     using AnalyzeHeapFunctionPtr = void (*)(JSCell*, HeapAnalyzer&amp;);
126     AnalyzeHeapFunctionPtr METHOD_TABLE_ENTRY(analyzeHeap);
127 
128     using EstimatedSizeFunctionPtr = size_t (*)(JSCell*, VM&amp;);
129     EstimatedSizeFunctionPtr METHOD_TABLE_ENTRY(estimatedSize);
130 
131     using VisitOutputConstraintsPtr = void (*)(JSCell*, SlotVisitor&amp;);
132     VisitOutputConstraintsPtr METHOD_TABLE_ENTRY(visitOutputConstraints);
133 };
134 
135 #define CREATE_MEMBER_CHECKER(member) \
136     template &lt;typename T&gt; \
137     struct MemberCheck##member { \
138         struct Fallback { \
139             void member(...); \
</pre>
<hr />
<pre>
167         &amp;ClassName::defaultValue, \
168         &amp;ClassName::getOwnPropertyNames, \
169         &amp;ClassName::getOwnNonIndexPropertyNames, \
170         &amp;ClassName::getPropertyNames, \
171         &amp;ClassName::getEnumerableLength, \
172         &amp;ClassName::getStructurePropertyNames, \
173         &amp;ClassName::getGenericPropertyNames, \
174         &amp;ClassName::className, \
175         &amp;ClassName::toStringName, \
176         &amp;ClassName::customHasInstance, \
177         &amp;ClassName::defineOwnProperty, \
178         &amp;ClassName::preventExtensions, \
179         &amp;ClassName::isExtensible, \
180         &amp;ClassName::setPrototype, \
181         &amp;ClassName::getPrototype, \
182         &amp;ClassName::dumpToStream, \
183         &amp;ClassName::analyzeHeap, \
184         &amp;ClassName::estimatedSize, \
185         &amp;ClassName::visitOutputConstraints, \
186     }, \
<span class="line-modified">187     ClassName::TypedArrayStorageType, \</span>
<span class="line-added">188     sizeof(ClassName)</span>
189 
190 struct ClassInfo {
<span class="line-added">191     using CheckSubClassSnippetFunctionPtr = Ref&lt;Snippet&gt; (*)(void);</span>
<span class="line-added">192 </span>
193     // A string denoting the class name. Example: &quot;Window&quot;.
194     const char* className;

195     // Pointer to the class information of the base class.
196     // nullptrif there is none.
197     const ClassInfo* parentClass;
<span class="line-added">198     const HashTable* staticPropHashTable;</span>
<span class="line-added">199     CheckSubClassSnippetFunctionPtr checkSubClassSnippet;</span>
<span class="line-added">200     MethodTable methodTable;</span>
<span class="line-added">201     TypedArrayType typedArrayStorageType;</span>
<span class="line-added">202     unsigned staticClassSize;</span>
203 
204     static ptrdiff_t offsetOfParentClass()
205     {
206         return OBJECT_OFFSETOF(ClassInfo, parentClass);
207     }
208 
209     bool isSubClassOf(const ClassInfo* other) const
210     {
211         for (const ClassInfo* ci = this; ci; ci = ci-&gt;parentClass) {
212             if (ci == other)
213                 return true;
214         }
215         return false;
216     }
217 
218     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
219 
220     JS_EXPORT_PRIVATE bool hasStaticSetterOrReadonlyProperties() const;









221 };
222 
223 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="CallData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ClonedArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
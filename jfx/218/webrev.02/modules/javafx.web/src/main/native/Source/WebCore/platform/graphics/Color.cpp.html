<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Color.h&quot;
 28 
 29 #include &quot;AnimationUtilities.h&quot;
 30 #include &quot;ColorUtilities.h&quot;
 31 #include &quot;HashTools.h&quot;
 32 #include &lt;wtf/Assertions.h&gt;
 33 #include &lt;wtf/HexNumber.h&gt;
 34 #include &lt;wtf/MathExtras.h&gt;
 35 #include &lt;wtf/text/StringBuilder.h&gt;
 36 #include &lt;wtf/text/TextStream.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 static constexpr SimpleColor lightenedBlack { 0xFF545454 };
 41 static constexpr SimpleColor darkenedWhite { 0xFFABABAB };
 42 
 43 static inline unsigned premultipliedChannel(unsigned c, unsigned a, bool ceiling = true)
 44 {
 45     return fastDivideBy255(ceiling ? c * a + 254 : c * a);
 46 }
 47 
 48 static inline unsigned unpremultipliedChannel(unsigned c, unsigned a)
 49 {
 50     return (fastMultiplyBy255(c) + a - 1) / a;
 51 }
 52 
 53 RGBA32 makeRGB(int r, int g, int b)
 54 {
 55     return makeRGBA(r, g, b, 0xFF);
 56 }
 57 
 58 RGBA32 makeRGBA(int r, int g, int b, int a)
 59 {
 60     return { static_cast&lt;unsigned&gt;(std::max(0, std::min(a, 0xFF)) &lt;&lt; 24 | std::max(0, std::min(r, 0xFF)) &lt;&lt; 16 | std::max(0, std::min(g, 0xFF)) &lt;&lt; 8 | std::max(0, std::min(b, 0xFF))) };
 61 }
 62 
 63 RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling)
 64 {
 65     return makeRGBA(premultipliedChannel(r, a, ceiling), premultipliedChannel(g, a, ceiling), premultipliedChannel(b, a, ceiling), a);
 66 }
 67 
 68 RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a)
 69 {
 70     return makeRGBA(unpremultipliedChannel(r, a), unpremultipliedChannel(g, a), unpremultipliedChannel(b, a), a);
 71 }
 72 
 73 static int colorFloatToRGBAByte(float f)
 74 {
 75     // We use lroundf and 255 instead of nextafterf(256, 0) to match CG&#39;s rounding
 76     return std::max(0, std::min(static_cast&lt;int&gt;(lroundf(255.0f * f)), 255));
 77 }
 78 
 79 RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a)
 80 {
 81     return makeRGBA(colorFloatToRGBAByte(r), colorFloatToRGBAByte(g), colorFloatToRGBAByte(b), colorFloatToRGBAByte(a));
 82 }
 83 
 84 RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha)
 85 {
 86     return { (color.value() &amp; 0x00FFFFFF) | colorFloatToRGBAByte(overrideAlpha) &lt;&lt; 24 };
 87 }
 88 
 89 RGBA32 makeRGBAFromHSLA(float hue, float saturation, float lightness, float alpha)
 90 {
 91     const float scaleFactor = 255.0;
 92     FloatComponents floatResult = HSLToSRGB({ hue, saturation, lightness, alpha });
 93     return makeRGBA(
 94         round(floatResult.components[0] * scaleFactor),
 95         round(floatResult.components[1] * scaleFactor),
 96         round(floatResult.components[2] * scaleFactor),
 97         round(floatResult.components[3] * scaleFactor));
 98 }
 99 
100 RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a)
101 {
102     double colors = 1 - k;
103     int r = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - c)));
104     int g = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - m)));
105     int b = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - y)));
106     return makeRGBA(r, g, b, static_cast&lt;float&gt;(nextafter(256, 0) * a));
107 }
108 
109 // originally moved here from the CSS parser
110 template &lt;typename CharacterType&gt;
111 static inline bool parseHexColorInternal(const CharacterType* name, unsigned length, RGBA32&amp; rgb)
112 {
113     if (length != 3 &amp;&amp; length != 4 &amp;&amp; length != 6 &amp;&amp; length != 8)
114         return false;
115     unsigned value = 0;
116     for (unsigned i = 0; i &lt; length; ++i) {
117         if (!isASCIIHexDigit(name[i]))
118             return false;
119         value &lt;&lt;= 4;
120         value |= toASCIIHexValue(name[i]);
121     }
122     if (length == 6) {
123         rgb = { 0xFF000000 | value };
124         return true;
125     }
126     if (length == 8) {
127         // We parsed the values into RGBA order, but the RGBA32 type
128         // expects them to be in ARGB order, so we right rotate eight bits.
129         rgb = { value &lt;&lt; 24 | value &gt;&gt; 8 };
130         return true;
131     }
132     if (length == 4) {
133         // #abcd converts to ddaabbcc in RGBA32.
134         rgb = { (value &amp; 0xF) &lt;&lt; 28 | (value &amp; 0xF) &lt;&lt; 24
135             | (value &amp; 0xF000) &lt;&lt; 8 | (value &amp; 0xF000) &lt;&lt; 4
136             | (value &amp; 0xF00) &lt;&lt; 4 | (value &amp; 0xF00)
137             | (value &amp; 0xF0) | (value &amp; 0xF0) &gt;&gt; 4 };
138         return true;
139     }
140     // #abc converts to #aabbcc
141     rgb = { 0xFF000000
142         | (value &amp; 0xF00) &lt;&lt; 12 | (value &amp; 0xF00) &lt;&lt; 8
143         | (value &amp; 0xF0) &lt;&lt; 8 | (value &amp; 0xF0) &lt;&lt; 4
144         | (value &amp; 0xF) &lt;&lt; 4 | (value &amp; 0xF) };
145     return true;
146 }
147 
148 bool Color::parseHexColor(const LChar* name, unsigned length, RGBA32&amp; rgb)
149 {
150     return parseHexColorInternal(name, length, rgb);
151 }
152 
153 bool Color::parseHexColor(const UChar* name, unsigned length, RGBA32&amp; rgb)
154 {
155     return parseHexColorInternal(name, length, rgb);
156 }
157 
158 bool Color::parseHexColor(const String&amp; name, RGBA32&amp; rgb)
159 {
160     unsigned length = name.length();
161     if (!length)
162         return false;
163     if (name.is8Bit())
164         return parseHexColor(name.characters8(), name.length(), rgb);
165     return parseHexColor(name.characters16(), name.length(), rgb);
166 }
167 
168 bool Color::parseHexColor(const StringView&amp; name, RGBA32&amp; rgb)
169 {
170     unsigned length = name.length();
171     if (!length)
172         return false;
173     if (name.is8Bit())
174         return parseHexColor(name.characters8(), name.length(), rgb);
175     return parseHexColor(name.characters16(), name.length(), rgb);
176 }
177 
178 int differenceSquared(const Color&amp; c1, const Color&amp; c2)
179 {
180     // FIXME: This is assuming that the colors are in the same colorspace.
181     // FIXME: This should probably return a floating point number, but many of the call
182     // sites have picked comparison values based on feel. We&#39;d need to break out
183     // our logarithm tables to change them :)
184     int c1Red = c1.isExtended() ? c1.asExtended().red() * 255 : c1.red();
185     int c1Green = c1.isExtended() ? c1.asExtended().green() * 255 : c1.green();
186     int c1Blue = c1.isExtended() ? c1.asExtended().blue() * 255 : c1.blue();
187     int c2Red = c2.isExtended() ? c2.asExtended().red() * 255 : c2.red();
188     int c2Green = c2.isExtended() ? c2.asExtended().green() * 255 : c2.green();
189     int c2Blue = c2.isExtended() ? c2.asExtended().blue() * 255 : c2.blue();
190     int dR = c1Red - c2Red;
191     int dG = c1Green - c2Green;
192     int dB = c1Blue - c2Blue;
193     return dR * dR + dG * dG + dB * dB;
194 }
195 
196 static inline const NamedColor* findNamedColor(const String&amp; name)
197 {
198     char buffer[64]; // easily big enough for the longest color name
199     unsigned length = name.length();
200     if (length &gt; sizeof(buffer) - 1)
201         return nullptr;
202     for (unsigned i = 0; i &lt; length; ++i) {
203         UChar c = name[i];
204         if (!c || !WTF::isASCII(c))
205             return nullptr;
206         buffer[i] = toASCIILower(static_cast&lt;char&gt;(c));
207     }
208     buffer[length] = &#39;\0&#39;;
209     return findColor(buffer, length);
210 }
211 
212 Color::Color(const String&amp; name)
213 {
214     if (name[0] == &#39;#&#39;) {
215         RGBA32 color;
216         bool valid;
217 
218         if (name.is8Bit())
219             valid = parseHexColor(name.characters8() + 1, name.length() - 1, color);
220         else
221             valid = parseHexColor(name.characters16() + 1, name.length() - 1, color);
222 
223         if (valid)
224             setRGB(color);
225     } else {
226         if (auto* foundColor = findNamedColor(name))
227             setRGB({ foundColor-&gt;ARGBValue });
228     }
229 }
230 
231 Color::Color(const char* name)
232 {
233     if (name[0] == &#39;#&#39;) {
234         SimpleColor color;
235         if (parseHexColor(reinterpret_cast&lt;const LChar*&gt;(&amp;name[1]), std::strlen(&amp;name[1]), color))
236             setRGB(color);
237     } else if (auto* foundColor = findColor(name, strlen(name)))
238         setRGB({ foundColor-&gt;ARGBValue });
239 }
240 
241 Color::Color(const Color&amp; other)
242     : m_colorData(other.m_colorData)
243 {
244     if (isExtended())
245         m_colorData.extendedColor-&gt;ref();
246 }
247 
248 Color::Color(Color&amp;&amp; other)
249 {
250     *this = WTFMove(other);
251 }
252 
253 Color::Color(float r, float g, float b, float a, ColorSpace colorSpace)
254 {
255     // Zero the union, just in case a 32-bit system only assigns the
256     // top 32 bits when copying the extendedColor pointer below.
257     m_colorData.rgbaAndFlags = 0;
258     auto extendedColorRef = ExtendedColor::create(r, g, b, a, colorSpace);
259     m_colorData.extendedColor = &amp;extendedColorRef.leakRef();
260     ASSERT(isExtended());
261 }
262 
263 Color&amp; Color::operator=(const Color&amp; other)
264 {
265     if (*this == other)
266         return *this;
267 
268     if (isExtended())
269         m_colorData.extendedColor-&gt;deref();
270 
271     m_colorData = other.m_colorData;
272 
273     if (isExtended())
274         m_colorData.extendedColor-&gt;ref();
275     return *this;
276 }
277 
278 Color&amp; Color::operator=(Color&amp;&amp; other)
279 {
280     if (*this == other)
281         return *this;
282 
283     if (isExtended())
284         m_colorData.extendedColor-&gt;deref();
285 
286     m_colorData = other.m_colorData;
287     other.m_colorData.rgbaAndFlags = invalidRGBAColor;
288 
289     return *this;
290 }
291 
292 String SimpleColor::serializationForHTML() const
293 {
294     if (isOpaque())
295         return makeString(&#39;#&#39;, hex(redComponent(), 2, Lowercase), hex(greenComponent(), 2, Lowercase), hex(blueComponent(), 2, Lowercase));
296     return serializationForCSS();
297 }
298 
299 String Color::serialized() const
300 {
301     if (isExtended())
302         return asExtended().cssText();
303     return rgb().serializationForHTML();
304 }
305 
306 static char decimalDigit(unsigned number)
307 {
308     ASSERT(number &lt; 10);
309     return &#39;0&#39; + number;
310 }
311 
312 static std::array&lt;char, 4&gt; fractionDigitsForFractionalAlphaValue(uint8_t alpha)
313 {
314     ASSERT(alpha &gt; 0);
315     ASSERT(alpha &lt; 0xFF);
316     if (((alpha * 100 + 0x7F) / 0xFF * 0xFF + 50) / 100 != alpha)
317         return { { decimalDigit(alpha * 10 / 0xFF % 10), decimalDigit(alpha * 100 / 0xFF % 10), decimalDigit((alpha * 1000 + 0x7F) / 0xFF % 10), &#39;\0&#39; } };
318     if (int thirdDigit = (alpha * 100 + 0x7F) / 0xFF % 10)
319         return { { decimalDigit(alpha * 10 / 0xFF), decimalDigit(thirdDigit), &#39;\0&#39;, &#39;\0&#39; } };
320     return { { decimalDigit((alpha * 10 + 0x7F) / 0xFF), &#39;\0&#39;, &#39;\0&#39;, &#39;\0&#39; } };
321 }
322 
323 String SimpleColor::serializationForCSS() const
324 {
325     switch (alphaComponent()) {
326     case 0:
327         return makeString(&quot;rgba(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &quot;, 0)&quot;);
328     case 0xFF:
329         return makeString(&quot;rgb(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &#39;)&#39;);
330     default:
331         return makeString(&quot;rgba(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &quot;, 0.&quot;, fractionDigitsForFractionalAlphaValue(alphaComponent()).data(), &#39;)&#39;);
332     }
333 }
334 
335 String Color::cssText() const
336 {
337     if (isExtended())
338         return asExtended().cssText();
339     return rgb().serializationForCSS();
340 }
341 
342 String RGBA32::serializationForRenderTreeAsText() const
343 {
344     if (alphaComponent() &lt; 0xFF)
345         return makeString(&#39;#&#39;, hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2), hex(alphaComponent(), 2));
346     return makeString(&#39;#&#39;, hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2));
347 }
348 
349 String Color::nameForRenderTreeAsText() const
350 {
351     // FIXME: Handle extended colors.
352     return rgb().serializationForRenderTreeAsText();
353 }
354 
355 Color Color::light() const
356 {
357     // Hardcode this common case for speed.
358     if (rgb() == black)
359         return lightenedBlack;
360 
361     const float scaleFactor = nextafterf(256.0f, 0.0f);
362 
363     float r, g, b, a;
364     getRGBA(r, g, b, a);
365 
366     float v = std::max(r, std::max(g, b));
367 
368     if (v == 0.0f)
369         // Lightened black with alpha.
370         return Color(0x54, 0x54, 0x54, alpha());
371 
372     float multiplier = std::min(1.0f, v + 0.33f) / v;
373 
374     return Color(static_cast&lt;int&gt;(multiplier * r * scaleFactor),
375                  static_cast&lt;int&gt;(multiplier * g * scaleFactor),
376                  static_cast&lt;int&gt;(multiplier * b * scaleFactor),
377                  alpha());
378 }
379 
380 Color Color::dark() const
381 {
382     // Hardcode this common case for speed.
383     if (rgb() == white)
384         return darkenedWhite;
385 
386     const float scaleFactor = nextafterf(256.0f, 0.0f);
387 
388     float r, g, b, a;
389     getRGBA(r, g, b, a);
390 
391     float v = std::max(r, std::max(g, b));
392     float multiplier = std::max(0.0f, (v - 0.33f) / v);
393 
394     return Color(static_cast&lt;int&gt;(multiplier * r * scaleFactor),
395                  static_cast&lt;int&gt;(multiplier * g * scaleFactor),
396                  static_cast&lt;int&gt;(multiplier * b * scaleFactor),
397                  alpha());
398 }
399 
400 bool Color::isDark() const
401 {
402     float red;
403     float green;
404     float blue;
405     float alpha;
406     getRGBA(red, green, blue, alpha);
407     float largestNonAlphaChannel = std::max(red, std::max(green, blue));
408     return alpha &gt; 0.5 &amp;&amp; largestNonAlphaChannel &lt; 0.5;
409 }
410 
411 static int blendComponent(int c, int a)
412 {
413     // We use white.
414     float alpha = a / 255.0f;
415     int whiteBlend = 255 - a;
416     c -= whiteBlend;
417     return static_cast&lt;int&gt;(c / alpha);
418 }
419 
420 const int cStartAlpha = 153; // 60%
421 const int cEndAlpha = 204; // 80%;
422 const int cAlphaIncrement = 17; // Increments in between.
423 
424 Color Color::blend(const Color&amp; source) const
425 {
426     if (!isVisible() || source.isOpaque())
427         return source;
428 
429     if (!source.alpha())
430         return *this;
431 
432     int d = 255 * (alpha() + source.alpha()) - alpha() * source.alpha();
433     int a = d / 255;
434     int r = (red() * alpha() * (255 - source.alpha()) + 255 * source.alpha() * source.red()) / d;
435     int g = (green() * alpha() * (255 - source.alpha()) + 255 * source.alpha() * source.green()) / d;
436     int b = (blue() * alpha() * (255 - source.alpha()) + 255 * source.alpha() * source.blue()) / d;
437     return Color(r, g, b, a);
438 }
439 
440 Color Color::blendWithWhite() const
441 {
442     // If the color contains alpha already, we leave it alone.
443     if (!isOpaque())
444         return *this;
445 
446     Color newColor;
447     for (int alpha = cStartAlpha; alpha &lt;= cEndAlpha; alpha += cAlphaIncrement) {
448         // We have a solid color.  Convert to an equivalent color that looks the same when blended with white
449         // at the current alpha.  Try using less transparency if the numbers end up being negative.
450         int r = blendComponent(red(), alpha);
451         int g = blendComponent(green(), alpha);
452         int b = blendComponent(blue(), alpha);
453 
454         newColor = Color(r, g, b, alpha);
455 
456         if (r &gt;= 0 &amp;&amp; g &gt;= 0 &amp;&amp; b &gt;= 0)
457             break;
458     }
459 
460     if (isSemantic())
461         newColor.setIsSemantic();
462     return newColor;
463 }
464 
465 Color Color::colorWithAlphaMultipliedBy(float amount) const
466 {
467     float newAlpha = amount * (isExtended() ? m_colorData.extendedColor-&gt;alpha() : static_cast&lt;float&gt;(alpha()) / 255);
468     return colorWithAlpha(newAlpha);
469 }
470 
471 Color Color::colorWithAlpha(float alpha) const
472 {
473     if (isExtended())
474         return Color { m_colorData.extendedColor-&gt;red(), m_colorData.extendedColor-&gt;green(), m_colorData.extendedColor-&gt;blue(), alpha, m_colorData.extendedColor-&gt;colorSpace() };
475 
476     int newAlpha = alpha * 255; // Why doesn&#39;t this use colorFloatToRGBAByte() like colorWithOverrideAlpha()?
477 
478     Color result = { red(), green(), blue(), newAlpha };
479     if (isSemantic())
480         result.setIsSemantic();
481     return result;
482 }
483 
484 void Color::getRGBA(float&amp; r, float&amp; g, float&amp; b, float&amp; a) const
485 {
486     r = red() / 255.0f;
487     g = green() / 255.0f;
488     b = blue() / 255.0f;
489     a = alpha() / 255.0f;
490 }
491 
492 void Color::getRGBA(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const
493 {
494     r = red() / 255.0;
495     g = green() / 255.0;
496     b = blue() / 255.0;
497     a = alpha() / 255.0;
498 }
499 
500 // FIXME: Use sRGBToHSL().
501 void Color::getHSL(double&amp; hue, double&amp; saturation, double&amp; lightness) const
502 {
503     // http://en.wikipedia.org/wiki/HSL_color_space. This is a direct copy of
504     // the algorithm therein, although it&#39;s 360^o based and we end up wanting
505     // [0...6) based. It&#39;s clearer if we stick to 360^o until the end.
506     double r = static_cast&lt;double&gt;(red()) / 255.0;
507     double g = static_cast&lt;double&gt;(green()) / 255.0;
508     double b = static_cast&lt;double&gt;(blue()) / 255.0;
509     double max = std::max(std::max(r, g), b);
510     double min = std::min(std::min(r, g), b);
511     double chroma = max - min;
512 
513     if (!chroma)
514         hue = 0.0;
515     else if (max == r)
516         hue = (60.0 * ((g - b) / chroma)) + 360.0;
517     else if (max == g)
518         hue = (60.0 * ((b - r) / chroma)) + 120.0;
519     else
520         hue = (60.0 * ((r - g) / chroma)) + 240.0;
521 
522     if (hue &gt;= 360.0)
523         hue -= 360.0;
524 
525     // makeRGBAFromHSLA assumes that hue is in [0...6).
526     hue /= 60.0;
527 
528     lightness = 0.5 * (max + min);
529     if (!chroma)
530         saturation = 0.0;
531     else if (lightness &lt;= 0.5)
532         saturation = (chroma / (max + min));
533     else
534         saturation = (chroma / (2.0 - (max + min)));
535 }
536 
537 void Color::getHSV(double&amp; hue, double&amp; saturation, double&amp; value) const
538 {
539     double r = static_cast&lt;double&gt;(red()) / 255.0;
540     double g = static_cast&lt;double&gt;(green()) / 255.0;
541     double b = static_cast&lt;double&gt;(blue()) / 255.0;
542     double max = std::max(std::max(r, g), b);
543     double min = std::min(std::min(r, g), b);
544     double chroma = max - min;
545 
546     if (!chroma)
547         hue = 0.0;
548     else if (max == r)
549         hue = (60.0 * ((g - b) / chroma)) + 360.0;
550     else if (max == g)
551         hue = (60.0 * ((b - r) / chroma)) + 120.0;
552     else
553         hue = (60.0 * ((r - g) / chroma)) + 240.0;
554 
555     if (hue &gt;= 360.0)
556         hue -= 360.0;
557 
558     hue /= 360.0;
559 
560     if (!max)
561         saturation = 0;
562     else
563         saturation = chroma / max;
564 
565     value = max;
566 }
567 
568 Color colorFromPremultipliedARGB(RGBA32 pixelColor)
569 {
570     if (pixelColor.isVisible() &amp;&amp; !pixelColor.isOpaque())
571         return makeUnPremultipliedRGBA(pixelColor.redComponent(), pixelColor.greenComponent(), pixelColor.blueComponent(), pixelColor.alphaComponent());
572     return pixelColor;
573 }
574 
575 RGBA32 premultipliedARGBFromColor(const Color&amp; color)
576 {
577     if (color.isOpaque()) {
578         if (color.isExtended())
579             return makeRGB(color.asExtended().red() * 255, color.asExtended().green() * 255, color.asExtended().blue() * 255);
580         return color.rgb();
581     }
582 
583     if (color.isExtended())
584         return makePremultipliedRGBA(color.asExtended().red() * 255, color.asExtended().green() * 255, color.asExtended().blue() * 255, color.asExtended().alpha() * 255);
585 
586     return makePremultipliedRGBA(color.red(), color.green(), color.blue(), color.alpha());
587 }
588 
589 Color blend(const Color&amp; from, const Color&amp; to, double progress, bool blendPremultiplied)
590 {
591     // FIXME: ExtendedColor - needs to handle color spaces.
592     // We need to preserve the state of the valid flag at the end of the animation
593     if (progress == 1 &amp;&amp; !to.isValid())
594         return Color();
595 
596     if (blendPremultiplied) {
597         // Since premultipliedARGBFromColor() bails on zero alpha, special-case that.
598         Color premultFrom = from.alpha() ? premultipliedARGBFromColor(from) : Color::transparent;
599         Color premultTo = to.alpha() ? premultipliedARGBFromColor(to) : Color::transparent;
600 
601         Color premultBlended(blend(premultFrom.red(), premultTo.red(), progress),
602             blend(premultFrom.green(), premultTo.green(), progress),
603             blend(premultFrom.blue(), premultTo.blue(), progress),
604             blend(premultFrom.alpha(), premultTo.alpha(), progress));
605 
606         return Color(colorFromPremultipliedARGB(premultBlended.rgb()));
607     }
608 
609     return Color(blend(from.red(), to.red(), progress),
610         blend(from.green(), to.green(), progress),
611         blend(from.blue(), to.blue(), progress),
612         blend(from.alpha(), to.alpha(), progress));
613 }
614 
615 void Color::tagAsValid()
616 {
617     m_colorData.rgbaAndFlags |= validRGBAColor;
618 }
619 
620 ExtendedColor&amp; Color::asExtended() const
621 {
622     ASSERT(isExtended());
623     return *m_colorData.extendedColor;
624 }
625 
626 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Color&amp; color)
627 {
628     return ts &lt;&lt; color.nameForRenderTreeAsText();
629 }
630 
631 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ColorSpace colorSpace)
632 {
633     switch (colorSpace) {
634     case ColorSpace::SRGB:
635         ts &lt;&lt; &quot;sRGB&quot;;
636         break;
637     case ColorSpace::LinearRGB:
638         ts &lt;&lt; &quot;LinearRGB&quot;;
639         break;
640     case ColorSpace::DisplayP3:
641         ts &lt;&lt; &quot;DisplayP3&quot;;
642         break;
643     }
644     return ts;
645 }
646 
647 } // namespace WebCore
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLCompile.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLCompile.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLCompile.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLCompile.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -51,10 +51,12 @@
 #include "ScratchRegisterAllocator.h"
 #include <wtf/RecursableLambda.h>
 
 namespace JSC { namespace FTL {
 
+const char* const tierName = "FTL ";
+
 using namespace DFG;
 
 void compile(State& state, Safepoint::Result& safepointResult)
 {
     Graph& graph = state.graph;
@@ -78,19 +80,19 @@
         return;
 
     std::unique_ptr<RegisterAtOffsetList> registerOffsets =
         makeUnique<RegisterAtOffsetList>(state.proc->calleeSaveRegisterAtOffsetList());
     if (shouldDumpDisassembly())
-        dataLog("Unwind info for ", CodeBlockWithJITType(codeBlock, JITType::FTLJIT), ": ", *registerOffsets, "\n");
+        dataLog(tierName, "Unwind info for ", CodeBlockWithJITType(codeBlock, JITType::FTLJIT), ": ", *registerOffsets, "\n");
     codeBlock->setCalleeSaveRegisters(WTFMove(registerOffsets));
     ASSERT(!(state.proc->frameSize() % sizeof(EncodedJSValue)));
     state.jitCode->common.frameRegisterCount = state.proc->frameSize() / sizeof(EncodedJSValue);
 
     int localsOffset =
         state.capturedValue->offsetFromFP() / sizeof(EncodedJSValue) + graph.m_nextMachineLocal;
     if (shouldDumpDisassembly()) {
-        dataLog(
+        dataLog(tierName,
             "localsOffset = ", localsOffset, " for stack slot: ",
             pointerDump(state.capturedValue), " at ", RawPointer(state.capturedValue), "\n");
     }
 
     for (unsigned i = graph.m_inlineVariableData.size(); i--;) {
@@ -132,16 +134,16 @@
 
     // Emit the exception handler.
     *state.exceptionHandler = jit.label();
     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
     jit.move(MacroAssembler::TrustedImmPtr(&vm), GPRInfo::argumentGPR0);
-    jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);
+    jit.prepareCallOperation(vm);
     CCallHelpers::Call call = jit.call(OperationPtrTag);
     jit.jumpToExceptionHandler(vm);
     jit.addLinkTask(
         [=] (LinkBuffer& linkBuffer) {
-            linkBuffer.link(call, FunctionPtr<OperationPtrTag>(lookupExceptionHandler));
+            linkBuffer.link(call, FunctionPtr<OperationPtrTag>(operationLookupExceptionHandler));
         });
 
     state.finalizer->b3CodeLinkBuffer = makeUnique<LinkBuffer>(jit, codeBlock, JITCompilationCanFail);
 
     if (state.finalizer->b3CodeLinkBuffer->didFailToAllocate()) {
@@ -151,20 +153,19 @@
 
     B3::PCToOriginMap originMap = state.proc->releasePCToOriginMap();
     if (vm.shouldBuilderPCToCodeOriginMapping())
         codeBlock->setPCToCodeOriginMap(makeUnique<PCToCodeOriginMap>(PCToCodeOriginMapBuilder(vm, WTFMove(originMap)), *state.finalizer->b3CodeLinkBuffer));
 
-    CodeLocationLabel<JSEntryPtrTag> label = state.finalizer->b3CodeLinkBuffer->locationOf<JSEntryPtrTag>(state.proc->entrypointLabel(0));
+    CodeLocationLabel<JSEntryPtrTag> label = state.finalizer->b3CodeLinkBuffer->locationOf<JSEntryPtrTag>(state.proc->code().entrypointLabel(0));
     state.generatedFunction = label;
     state.jitCode->initializeB3Byproducts(state.proc->releaseByproducts());
 
-    for (auto pair : state.graph.m_entrypointIndexToCatchBytecodeOffset) {
-        unsigned catchBytecodeOffset = pair.value;
+    for (auto pair : state.graph.m_entrypointIndexToCatchBytecodeIndex) {
+        BytecodeIndex catchBytecodeIndex = pair.value;
         unsigned entrypointIndex = pair.key;
         Vector<FlushFormat> argumentFormats = state.graph.m_argumentFormats[entrypointIndex];
-        state.jitCode->common.appendCatchEntrypoint(
-            catchBytecodeOffset, state.finalizer->b3CodeLinkBuffer->locationOf<ExceptionHandlerPtrTag>(state.proc->entrypointLabel(entrypointIndex)), WTFMove(argumentFormats));
+        state.jitCode->common.appendCatchEntrypoint(catchBytecodeIndex, state.finalizer->b3CodeLinkBuffer->locationOf<ExceptionHandlerPtrTag>(state.proc->code().entrypointLabel(entrypointIndex)), WTFMove(argumentFormats));
     }
     state.jitCode->common.finalizeCatchEntrypoints();
 
     if (B3::Air::Disassembler* disassembler = state.proc->code().disassembler()) {
         PrintStream& out = WTF::dataFile();
@@ -175,14 +176,14 @@
         B3::Value* currentB3Value = nullptr;
         Node* currentDFGNode = nullptr;
 
         HashSet<B3::Value*> printedValues;
         HashSet<Node*> printedNodes;
-        const char* dfgPrefix = "    ";
-        const char* b3Prefix  = "          ";
-        const char* airPrefix = "              ";
-        const char* asmPrefix = "                ";
+        const char* dfgPrefix = "DFG " "    ";
+        const char* b3Prefix  = "b3  " "          ";
+        const char* airPrefix = "Air " "              ";
+        const char* asmPrefix = "asm " "                ";
 
         auto printDFGNode = [&] (Node* node) {
             if (currentDFGNode == node)
                 return;
 

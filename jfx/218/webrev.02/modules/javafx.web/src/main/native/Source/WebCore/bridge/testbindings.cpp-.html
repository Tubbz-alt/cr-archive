<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bridge/testbindings.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2004, 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Library General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Library General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Library General Public License
 16  *  along with this library; see the file COPYING.LIB.  If not, write to
 17  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  *  Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 #include &quot;config.h&quot;
 22 
 23 #include &quot;BridgeJSC.h&quot;
 24 #include &quot;JSCJSValue.h&quot;
 25 #include &quot;JSObject.h&quot;
 26 #include &quot;interpreter.h&quot;
 27 #include &quot;npruntime_internal.h&quot;
 28 #include &quot;runtime_object.h&quot;
 29 #include &quot;types.h&quot;
 30 #include &lt;assert.h&gt;
 31 #include &lt;stdio.h&gt;
 32 #include &lt;string.h&gt;
 33 
 34 
 35 #define LOG(formatAndArgs...) { \
 36     fprintf (stderr, &quot;%s:  &quot;, __PRETTY_FUNCTION__); \
 37     fprintf(stderr, formatAndArgs); \
 38 }
 39 
 40 
 41 // ------------------ NP Interface definition --------------------
 42 typedef struct
 43 {
 44     NPObject object;
 45     double doubleValue;
 46     int intValue;
 47     NPVariant stringValue;
 48     bool boolValue;
 49 } MyObject;
 50 
 51 
 52 static bool identifiersInitialized = false;
 53 
 54 #define ID_DOUBLE_VALUE                         0
 55 #define ID_INT_VALUE                            1
 56 #define ID_STRING_VALUE                         2
 57 #define ID_BOOLEAN_VALUE                        3
 58 #define ID_NULL_VALUE                           4
 59 #define ID_UNDEFINED_VALUE                      5
 60 #define NUM_PROPERTY_IDENTIFIERS                6
 61 
 62 static NPIdentifier myPropertyIdentifiers[NUM_PROPERTY_IDENTIFIERS];
 63 static const NPUTF8 *myPropertyIdentifierNames[NUM_PROPERTY_IDENTIFIERS] = {
 64     &quot;doubleValue&quot;,
 65     &quot;intValue&quot;,
 66     &quot;stringValue&quot;,
 67     &quot;booleanValue&quot;,
 68     &quot;nullValue&quot;,
 69     &quot;undefinedValue&quot;
 70 };
 71 
 72 #define ID_LOG_MESSAGE                          0
 73 #define ID_SET_DOUBLE_VALUE                     1
 74 #define ID_SET_INT_VALUE                        2
 75 #define ID_SET_STRING_VALUE                     3
 76 #define ID_SET_BOOLEAN_VALUE                    4
 77 #define ID_GET_DOUBLE_VALUE                     5
 78 #define ID_GET_INT_VALUE                        6
 79 #define ID_GET_STRING_VALUE                     7
 80 #define ID_GET_BOOLEAN_VALUE                    8
 81 #define NUM_METHOD_IDENTIFIERS                  9
 82 
 83 static NPIdentifier myMethodIdentifiers[NUM_METHOD_IDENTIFIERS];
 84 static const NPUTF8 *myMethodIdentifierNames[NUM_METHOD_IDENTIFIERS] = {
 85     &quot;logMessage&quot;,
 86     &quot;setDoubleValue&quot;,
 87     &quot;setIntValue&quot;,
 88     &quot;setStringValue&quot;,
 89     &quot;setBooleanValue&quot;,
 90     &quot;getDoubleValue&quot;,
 91     &quot;getIntValue&quot;,
 92     &quot;getStringValue&quot;,
 93     &quot;getBooleanValue&quot;
 94 };
 95 
 96 static void initializeIdentifiers()
 97 {
 98     NPN_GetStringIdentifiers (myPropertyIdentifierNames, NUM_PROPERTY_IDENTIFIERS, myPropertyIdentifiers);
 99     NPN_GetStringIdentifiers (myMethodIdentifierNames, NUM_METHOD_IDENTIFIERS, myMethodIdentifiers);
100 };
101 
102 bool myHasProperty (NPClass *theClass, NPIdentifier name)
103 {
104     int i;
105     for (i = 0; i &lt; NUM_PROPERTY_IDENTIFIERS; i++) {
106         if (name == myPropertyIdentifiers[i]){
107             return true;
108         }
109     }
110     return false;
111 }
112 
113 bool myHasMethod (NPClass *theClass, NPIdentifier name)
114 {
115     int i;
116     for (i = 0; i &lt; NUM_METHOD_IDENTIFIERS; i++) {
117         if (name == myMethodIdentifiers[i]){
118             return true;
119         }
120     }
121     return false;
122 }
123 
124 
125 void logMessage (const NPVariant *message)
126 {
127     if (message-&gt;type == NPVariantStringType) {
128         char msgBuf[1024];
129         strncpy (msgBuf, message-&gt;value.stringValue.UTF8Characters, message-&gt;value.stringValue.UTF8Length);
130         msgBuf[message-&gt;value.stringValue.UTF8Length] = 0;
131         printf (&quot;%s\n&quot;, msgBuf);
132     }
133     else if (message-&gt;type == NPVariantDoubleType)
134         printf (&quot;%f\n&quot;, (float)message-&gt;value.doubleValue);
135     else if (message-&gt;type == NPVariantInt32Type)
136         printf (&quot;%d\n&quot;, message-&gt;value.intValue);
137     else if (message-&gt;type == NPVariantObjectType)
138         printf (&quot;%p\n&quot;, message-&gt;value.objectValue);
139 }
140 
141 void setDoubleValue (MyObject *obj, const NPVariant *variant)
142 {
143     if (!NPN_VariantToDouble (variant, &amp;obj-&gt;doubleValue)) {
144         NPUTF8 *msg = &quot;Attempt to set double value with invalid type.&quot;;
145         NPString aString;
146         aString.UTF8Characters = msg;
147         aString.UTF8Length = strlen (msg);
148         NPN_SetException ((NPObject *)obj, &amp;aString);
149     }
150 }
151 
152 void setIntValue (MyObject *obj, const NPVariant *variant)
153 {
154     if (!NPN_VariantToInt32 (variant, &amp;obj-&gt;intValue)) {
155         NPUTF8 *msg = &quot;Attempt to set int value with invalid type.&quot;;
156         NPString aString;
157         aString.UTF8Characters = msg;
158         aString.UTF8Length = strlen (msg);
159         NPN_SetException ((NPObject *)obj, &amp;aString);
160     }
161 }
162 
163 void setStringValue (MyObject *obj, const NPVariant *variant)
164 {
165     NPN_ReleaseVariantValue (&amp;obj-&gt;stringValue);
166     NPN_InitializeVariantWithVariant (&amp;obj-&gt;stringValue, variant);
167 }
168 
169 void setBooleanValue (MyObject *obj, const NPVariant *variant)
170 {
171     if (!NPN_VariantToBool (variant, (NPBool *)&amp;obj-&gt;boolValue)) {
172         NPUTF8 *msg = &quot;Attempt to set bool value with invalid type.&quot;;
173         NPString aString;
174         aString.UTF8Characters = msg;
175         aString.UTF8Length = strlen (msg);
176         NPN_SetException ((NPObject *)obj, &amp;aString);
177     }
178 }
179 
180 void getDoubleValue (MyObject *obj, NPVariant *variant)
181 {
182     NPN_InitializeVariantWithDouble (variant, obj-&gt;doubleValue);
183 }
184 
185 void getIntValue (MyObject *obj, NPVariant *variant)
186 {
187     NPN_InitializeVariantWithInt32 (variant, obj-&gt;intValue);
188 }
189 
190 void getStringValue (MyObject *obj, NPVariant *variant)
191 {
192     NPN_InitializeVariantWithVariant (variant, &amp;obj-&gt;stringValue);
193 }
194 
195 void getBooleanValue (MyObject *obj, NPVariant *variant)
196 {
197     NPN_InitializeVariantWithBool (variant, obj-&gt;boolValue);
198 }
199 
200 void myGetProperty (MyObject *obj, NPIdentifier name, NPVariant *variant)
201 {
202     if (name == myPropertyIdentifiers[ID_DOUBLE_VALUE]){
203         getDoubleValue (obj, variant);
204     }
205     else if (name == myPropertyIdentifiers[ID_INT_VALUE]){
206         getIntValue (obj, variant);
207     }
208     else if (name == myPropertyIdentifiers[ID_STRING_VALUE]){
209         getStringValue (obj, variant);
210     }
211     else if (name == myPropertyIdentifiers[ID_BOOLEAN_VALUE]){
212         getBooleanValue (obj, variant);
213     }
214     else if (name == myPropertyIdentifiers[ID_NULL_VALUE]){
215         return NPN_InitializeVariantAsNull (variant);
216     }
217     else if (name == myPropertyIdentifiers[ID_UNDEFINED_VALUE]){
218         return NPN_InitializeVariantAsUndefined (variant);
219     }
220     else
221         NPN_InitializeVariantAsUndefined(variant);
222 }
223 
224 void mySetProperty (MyObject *obj, NPIdentifier name, const NPVariant *variant)
225 {
226     if (name == myPropertyIdentifiers[ID_DOUBLE_VALUE]) {
227         setDoubleValue (obj, variant);
228     }
229     else if (name == myPropertyIdentifiers[ID_INT_VALUE]) {
230         setIntValue (obj, variant);
231     }
232     else if (name == myPropertyIdentifiers[ID_STRING_VALUE]) {
233         setStringValue (obj, variant);
234     }
235     else if (name == myPropertyIdentifiers[ID_BOOLEAN_VALUE]) {
236         setBooleanValue (obj, variant);
237     }
238     else if (name == myPropertyIdentifiers[ID_NULL_VALUE]) {
239         // Do nothing!
240     }
241     else if (name == myPropertyIdentifiers[ID_UNDEFINED_VALUE]) {
242         // Do nothing!
243     }
244 }
245 
246 void myInvoke (MyObject *obj, NPIdentifier name, NPVariant *args, unsigned argCount, NPVariant *result)
247 {
248     if (name == myMethodIdentifiers[ID_LOG_MESSAGE]) {
249         if (argCount == 1 &amp;&amp; NPN_VariantIsString(&amp;args[0]))
250             logMessage (&amp;args[0]);
251         NPN_InitializeVariantAsVoid (result);
252     }
253     else if (name == myMethodIdentifiers[ID_SET_DOUBLE_VALUE]) {
254         if (argCount == 1 &amp;&amp; NPN_VariantIsDouble (&amp;args[0]))
255             setDoubleValue (obj, &amp;args[0]);
256         NPN_InitializeVariantAsVoid (result);
257     }
258     else if (name == myMethodIdentifiers[ID_SET_INT_VALUE]) {
259         if (argCount == 1 &amp;&amp; (NPN_VariantIsDouble (&amp;args[0]) || NPN_VariantIsInt32 (&amp;args[0])))
260             setIntValue (obj, &amp;args[0]);
261         NPN_InitializeVariantAsVoid (result);
262     }
263     else if (name == myMethodIdentifiers[ID_SET_STRING_VALUE]) {
264         if (argCount == 1 &amp;&amp; NPN_VariantIsString (&amp;args[0]))
265             setStringValue (obj, &amp;args[0]);
266         NPN_InitializeVariantAsVoid (result);
267     }
268     else if (name == myMethodIdentifiers[ID_SET_BOOLEAN_VALUE]) {
269         if (argCount == 1 &amp;&amp; NPN_VariantIsBool (&amp;args[0]))
270             setBooleanValue (obj, &amp;args[0]);
271         NPN_InitializeVariantAsVoid (result);
272     }
273     else if (name == myMethodIdentifiers[ID_GET_DOUBLE_VALUE]) {
274         getDoubleValue (obj, result);
275     }
276     else if (name == myMethodIdentifiers[ID_GET_INT_VALUE]) {
277         getIntValue (obj, result);
278     }
279     else if (name == myMethodIdentifiers[ID_GET_STRING_VALUE]) {
280         getStringValue (obj, result);
281     }
282     else if (name == myMethodIdentifiers[ID_GET_BOOLEAN_VALUE]) {
283         getBooleanValue (obj, result);
284     }
285     else
286         NPN_InitializeVariantAsUndefined (result);
287 }
288 
289 NPObject *myAllocate ()
290 {
291     MyObject *newInstance = (MyObject *)malloc (sizeof(MyObject));
292 
293     if (!identifiersInitialized) {
294         identifiersInitialized = true;
295         initializeIdentifiers();
296     }
297 
298 
299     newInstance-&gt;doubleValue = 666.666;
300     newInstance-&gt;intValue = 1234;
301     newInstance-&gt;boolValue = true;
302     newInstance-&gt;stringValue.type = NPVariantType_String;
303     newInstance-&gt;stringValue.value.stringValue.UTF8Length = strlen (&quot;Hello world&quot;);
304     newInstance-&gt;stringValue.value.stringValue.UTF8Characters = strdup (&quot;Hello world&quot;);
305 
306     return (NPObject *)newInstance;
307 }
308 
309 void myInvalidate ()
310 {
311     // Make sure we&#39;ve released any remaining references to JavaScript objects.
312 }
313 
314 void myDeallocate (MyObject *obj)
315 {
316     free ((void *)obj);
317 }
318 
319 static NPClass _myFunctionPtrs = {
320     kNPClassStructVersionCurrent,
321     (NPAllocateFunctionPtr) myAllocate,
322     (NPDeallocateFunctionPtr) myDeallocate,
323     (NPInvalidateFunctionPtr) myInvalidate,
324     (NPHasMethodFunctionPtr) myHasMethod,
325     (NPInvokeFunctionPtr) myInvoke,
326     (NPHasPropertyFunctionPtr) myHasProperty,
327     (NPGetPropertyFunctionPtr) myGetProperty,
328     (NPSetPropertyFunctionPtr) mySetProperty,
329 };
330 static NPClass *myFunctionPtrs = &amp;_myFunctionPtrs;
331 
332 // --------------------------------------------------------
333 
334 using namespace JSC;
335 using namespace JSC::Bindings;
336 
337 class GlobalImp : public ObjectImp {
338 public:
339     virtual String className() const { return &quot;global&quot;; }
340 };
341 
342 #define BufferSize 200000
343 static char code[BufferSize];
344 
345 const char *readJavaScriptFromFile (const char *file)
346 {
347     FILE *f = fopen(file, &quot;r&quot;);
348     if (!f) {
349         fprintf(stderr, &quot;Error opening %s.\n&quot;, file);
350         return 0;
351     }
352 
353     int num = fread(code, 1, BufferSize, f);
354     code[num] = &#39;\0&#39;;
355     if(num &gt;= BufferSize)
356         fprintf(stderr, &quot;Warning: File may have been too long.\n&quot;);
357 
358     fclose(f);
359 
360     return code;
361 }
362 
363 int main(int argc, char **argv)
364 {
365     // expecting a filename
366     if (argc &lt; 2) {
367         fprintf(stderr, &quot;You have to specify at least one filename\n&quot;);
368         return -1;
369     }
370 
371     bool ret = true;
372     {
373         JSLock lock;
374 
375         // create interpreter w/ global object
376         Object global(new GlobalImp());
377         Interpreter interp;
378         interp.setGlobalObject(global);
379         ExecState *exec = interp.globalExec();
380 
381         MyObject *myObject = (MyObject *)NPN_CreateObject (myFunctionPtrs);
382 
383         global.put(exec, Identifier::fromString(exec, &quot;myInterface&quot;), Instance::createRuntimeObject(Instance::CLanguage, (void *)myObject));
384 
385         for (int i = 1; i &lt; argc; i++) {
386             const char *code = readJavaScriptFromFile(argv[i]);
387 
388             if (code) {
389                 // run
390                 Completion comp(interp.evaluate(code));
391 
392                 if (comp.complType() == Throw) {
393                     Value exVal = comp.value();
394                     String message = exVal.toWTFString(exec);
395                     auto cstring = msg.ascii();
396                     const char* msg = cstring.data();
397                     int lineno = -1;
398                     if (exVal.type() == ObjectType) {
399                         Value lineVal = Object::dynamicCast(exVal).get(exec, Identifier::fromString(exec, &quot;line&quot;));
400                         if (lineVal.type() == NumberType)
401                             lineno = int(lineVal.toNumber(exec));
402                     }
403                     if (lineno != -1)
404                         fprintf(stderr,&quot;Exception, line %d: %s\n&quot;,lineno,msg);
405                     else
406                         fprintf(stderr,&quot;Exception: %s\n&quot;,msg);
407                     ret = false;
408                 }
409                 else if (comp.complType() == ReturnValue) {
410                     char *msg = comp.value().toString(interp.globalExec()).ascii();
411                     fprintf(stderr,&quot;Return value: %s\n&quot;,msg);
412                 }
413             }
414         }
415 
416         NPN_ReleaseObject ((NPObject *)myObject);
417 
418     } // end block, so that Interpreter and global get deleted
419 
420     return ret ? 0 : 3;
421 }
    </pre>
  </body>
</html>
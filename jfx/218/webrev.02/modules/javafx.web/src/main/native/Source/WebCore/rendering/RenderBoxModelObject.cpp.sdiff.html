<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBoxModelObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBoxModelObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  45 #include &quot;Path.h&quot;
  46 #include &quot;RenderBlock.h&quot;
  47 #include &quot;RenderFlexibleBox.h&quot;
  48 #include &quot;RenderFragmentContainer.h&quot;
  49 #include &quot;RenderInline.h&quot;
  50 #include &quot;RenderLayer.h&quot;
  51 #include &quot;RenderLayerBacking.h&quot;
  52 #include &quot;RenderLayerCompositor.h&quot;
  53 #include &quot;RenderMultiColumnFlow.h&quot;
  54 #include &quot;RenderTable.h&quot;
  55 #include &quot;RenderTableRow.h&quot;
  56 #include &quot;RenderText.h&quot;
  57 #include &quot;RenderTextFragment.h&quot;
  58 #include &quot;RenderTreeBuilder.h&quot;
  59 #include &quot;RenderView.h&quot;
  60 #include &quot;ScrollingConstraints.h&quot;
  61 #include &quot;Settings.h&quot;
  62 #include &quot;TransformState.h&quot;
  63 #include &lt;wtf/IsoMallocInlines.h&gt;
  64 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">  65 #if !ASSERT_DISABLED</span>
  66 #include &lt;wtf/SetForScope.h&gt;
  67 #endif
  68 
  69 #if PLATFORM(IOS_FAMILY)
  70 #include &quot;RuntimeApplicationChecks.h&quot;
  71 #endif
  72 
  73 namespace WebCore {
  74 
  75 using namespace HTMLNames;
  76 
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBoxModelObject);
  78 
  79 // The HashMap for storing continuation pointers.
  80 // An inline can be split with blocks occuring in between the inline content.
  81 // When this occurs we need a pointer to the next object. We can basically be
  82 // split into a sequence of inlines and blocks. The continuation will either be
  83 // an anonymous block (that houses other blocks) or it will be an inline flow.
  84 // &lt;b&gt;&lt;i&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/i&gt;&lt;/b&gt;. In this example the &lt;i&gt; will have a block as
  85 // its continuation but the &lt;b&gt; will just have an inline as its continuation.
</pre>
<hr />
<pre>
 428                 } else if (!isOutOfFlowPositioned()) {
 429                     if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor))
 430                         referencePoint.moveBy(downcast&lt;RenderBox&gt;(*ancestor).topLeftLocation());
 431                 }
 432 
 433                 ancestor = ancestor-&gt;parent();
 434             }
 435 
 436             if (is&lt;RenderBox&gt;(*offsetParent) &amp;&amp; offsetParent-&gt;isBody() &amp;&amp; !offsetParent-&gt;isPositioned())
 437                 referencePoint.moveBy(downcast&lt;RenderBox&gt;(*offsetParent).topLeftLocation());
 438         }
 439     }
 440 
 441     return referencePoint;
 442 }
 443 
 444 const RenderBox&amp; RenderBoxModelObject::enclosingClippingBoxForStickyPosition(const RenderLayer** enclosingClippingLayer) const
 445 {
 446     ASSERT(isStickilyPositioned());
 447 
<span class="line-modified"> 448     auto* clipLayer = layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf);</span>

 449     if (enclosingClippingLayer)
 450         *enclosingClippingLayer = clipLayer;
 451 
 452     return clipLayer ? downcast&lt;RenderBox&gt;(clipLayer-&gt;renderer()) : view();
 453 }
 454 
 455 void RenderBoxModelObject::computeStickyPositionConstraints(StickyPositionViewportConstraints&amp; constraints, const FloatRect&amp; constrainingRect) const
 456 {
 457     constraints.setConstrainingRectAtLastLayout(constrainingRect);
 458 
 459     RenderBlock* containingBlock = this-&gt;containingBlock();
 460     const RenderLayer* enclosingClippingLayer = nullptr;
 461     auto&amp; enclosingClippingBox = enclosingClippingBoxForStickyPosition(&amp;enclosingClippingLayer);
 462 
 463     LayoutRect containerContentRect;
 464     if (!enclosingClippingLayer || (containingBlock != &amp;enclosingClippingBox))
 465         containerContentRect = containingBlock-&gt;contentBoxRect();
 466     else {
 467         containerContentRect = containingBlock-&gt;layoutOverflowRect();
 468         LayoutPoint containerLocation = containerContentRect.location() + LayoutPoint(containingBlock-&gt;borderLeft() + containingBlock-&gt;paddingLeft(),
</pre>
<hr />
<pre>
 519     }
 520 
 521     if (!style().right().isAuto()) {
 522         constraints.setRightOffset(valueForLength(style().right(), constrainingRect.width()));
 523         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
 524     }
 525 
 526     if (!style().top().isAuto()) {
 527         constraints.setTopOffset(valueForLength(style().top(), constrainingRect.height()));
 528         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
 529     }
 530 
 531     if (!style().bottom().isAuto()) {
 532         constraints.setBottomOffset(valueForLength(style().bottom(), constrainingRect.height()));
 533         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
 534     }
 535 }
 536 
 537 FloatRect RenderBoxModelObject::constrainingRectForStickyPosition() const
 538 {
<span class="line-modified"> 539     RenderLayer* enclosingClippingLayer = layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf);</span>

 540     if (enclosingClippingLayer) {
 541         RenderBox&amp; enclosingClippingBox = downcast&lt;RenderBox&gt;(enclosingClippingLayer-&gt;renderer());
 542         LayoutRect clipRect = enclosingClippingBox.overflowClipRect(LayoutPoint(), nullptr); // FIXME: make this work in regions.
 543         clipRect.contract(LayoutSize(enclosingClippingBox.paddingLeft() + enclosingClippingBox.paddingRight(),
 544             enclosingClippingBox.paddingTop() + enclosingClippingBox.paddingBottom()));
 545 
 546         FloatRect constrainingRect = enclosingClippingBox.localToContainerQuad(FloatRect(clipRect), &amp;view()).boundingBox();
 547 
 548         FloatPoint scrollOffset = FloatPoint() + enclosingClippingLayer-&gt;scrollOffset();
 549 
 550         float scrollbarOffset = 0;
 551         if (enclosingClippingBox.hasLayer() &amp;&amp; enclosingClippingBox.shouldPlaceBlockDirectionScrollbarOnLeft())
 552             scrollbarOffset = enclosingClippingBox.layer()-&gt;verticalScrollbarWidth(IgnoreOverlayScrollbarSize);
 553 
 554         constrainingRect.setLocation(FloatPoint(scrollOffset.x() + scrollbarOffset, scrollOffset.y()));
 555         return constrainingRect;
 556     }
 557 
 558     return view().frameView().rectForFixedPositionLayout();
 559 }
 560 
 561 LayoutSize RenderBoxModelObject::stickyPositionOffset() const
 562 {
<span class="line-removed"> 563     ASSERT(hasLayer());</span>
<span class="line-removed"> 564 </span>
 565     FloatRect constrainingRect = constrainingRectForStickyPosition();
 566     StickyPositionViewportConstraints constraints;
 567     computeStickyPositionConstraints(constraints, constrainingRect);
 568 
 569     // The sticky offset is physical, so we can just return the delta computed in absolute coords (though it may be wrong with transforms).
 570     return LayoutSize(constraints.computeStickyOffset(constrainingRect));
 571 }
 572 
 573 LayoutSize RenderBoxModelObject::offsetForInFlowPosition() const
 574 {
 575     if (isRelativelyPositioned())
 576         return relativePositionOffset();
 577 
 578     if (isStickilyPositioned())
 579         return stickyPositionOffset();
 580 
 581     return LayoutSize();
 582 }
 583 
 584 LayoutUnit RenderBoxModelObject::offsetLeft() const
</pre>
<hr />
<pre>
 663     // We shrink the rectangle by one device pixel on each side to make it fully overlap the anti-aliased background border
 664     return shrinkRectByOneDevicePixel(context, rect, document().deviceScaleFactor());
 665 }
 666 
 667 RoundedRect RenderBoxModelObject::backgroundRoundedRectAdjustedForBleedAvoidance(const GraphicsContext&amp; context, const LayoutRect&amp; borderRect, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* box, const LayoutSize&amp; boxSize, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
 668 {
 669     if (bleedAvoidance == BackgroundBleedShrinkBackground) {
 670         // We shrink the rectangle by one device pixel on each side because the bleed is one pixel maximum.
 671         return getBackgroundRoundedRect(shrinkRectByOneDevicePixel(context, borderRect, document().deviceScaleFactor()), box, boxSize.width(), boxSize.height(),
 672             includeLogicalLeftEdge, includeLogicalRightEdge);
 673     }
 674     if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
 675         return style().getRoundedInnerBorderFor(borderRect, includeLogicalLeftEdge, includeLogicalRightEdge);
 676 
 677     return getBackgroundRoundedRect(borderRect, box, boxSize.width(), boxSize.height(), includeLogicalLeftEdge, includeLogicalRightEdge);
 678 }
 679 
 680 static void applyBoxShadowForBackground(GraphicsContext&amp; context, const RenderStyle&amp; style)
 681 {
 682     const ShadowData* boxShadow = style.boxShadow();
<span class="line-modified"> 683     while (boxShadow-&gt;style() != Normal)</span>
 684         boxShadow = boxShadow-&gt;next();
 685 
 686     FloatSize shadowOffset(boxShadow-&gt;x(), boxShadow-&gt;y());
 687     if (!boxShadow-&gt;isWebkitBoxShadow())
 688         context.setShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 689     else
 690         context.setLegacyShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 691 }
 692 
 693 InterpolationQuality RenderBoxModelObject::chooseInterpolationQuality(GraphicsContext&amp; context, Image&amp; image, const void* layer, const LayoutSize&amp; size)
 694 {
 695     return view().imageQualityController().chooseInterpolationQuality(context, this, image, layer, size);
 696 }
 697 
 698 void RenderBoxModelObject::paintMaskForTextFillBox(ImageBuffer* maskImage, const IntRect&amp; maskRect, InlineFlowBox* box, const LayoutRect&amp; scrolledPaintRect)
 699 {
 700     GraphicsContext&amp; maskImageContext = maskImage-&gt;context();
 701     maskImageContext.translate(-maskRect.location());
 702 
 703     // Now add the text to the clip. We do this by painting using a special paint phase that signals to
</pre>
<hr />
<pre>
 844 
 845     if (bgLayer.clip() == FillBox::Padding || bgLayer.clip() == FillBox::Content) {
 846         // Clip to the padding or content boxes as necessary.
 847         if (!clipToBorderRadius) {
 848             bool includePadding = bgLayer.clip() == FillBox::Content;
 849             LayoutRect clipRect = LayoutRect(scrolledPaintRect.x() + bLeft + (includePadding ? pLeft : 0_lu),
 850                 scrolledPaintRect.y() + borderTop() + (includePadding ? paddingTop() : 0_lu),
 851                 scrolledPaintRect.width() - bLeft - bRight - (includePadding ? pLeft + pRight : 0_lu),
 852                 scrolledPaintRect.height() - borderTop() - borderBottom() - (includePadding ? paddingTop() + paddingBottom() : 0_lu));
 853             backgroundClipStateSaver.save();
 854             context.clip(clipRect);
 855         }
 856     } else if (bgLayer.clip() == FillBox::Text) {
 857         // We have to draw our text into a mask that can then be used to clip background drawing.
 858         // First figure out how big the mask has to be.  It should be no bigger than what we need
 859         // to actually render, so we should intersect the dirty rect with the border box of the background.
 860         maskRect = snappedIntRect(rect);
 861         maskRect.intersect(snappedIntRect(paintInfo.rect));
 862 
 863         // Now create the mask.
<span class="line-modified"> 864         maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpaceSRGB, context);</span>
 865         if (!maskImage)
 866             return;
 867         paintMaskForTextFillBox(maskImage.get(), maskRect, box, scrolledPaintRect);
 868 
 869         // The mask has been created.  Now we just need to clip to it.
 870         backgroundClipStateSaver.save();
 871         context.clip(maskRect);
 872         context.beginTransparencyLayer(1);
 873     }
 874 
 875     // Only fill with a base color (e.g., white) if we&#39;re the root document, since iframes/frames with
 876     // no background in the child document should show the parent&#39;s background.
 877     bool isOpaqueRoot = false;
 878     if (isRoot) {
 879         isOpaqueRoot = true;
 880         if (!bgLayer.next() &amp;&amp; !bgColor.isOpaque()) {
 881             HTMLFrameOwnerElement* ownerElement = document().ownerElement();
 882             if (ownerElement) {
 883                 if (!ownerElement-&gt;hasTagName(frameTag)) {
 884                     // Locate the &lt;body&gt; element using the DOM.  This is easier than trying
</pre>
<hr />
<pre>
 909             if (!boxShadowShouldBeAppliedToBackground)
 910                 backgroundRect.intersect(paintInfo.rect);
 911 
 912             // If we have an alpha and we are painting the root element, blend with the base background color.
 913             Color baseColor;
 914             bool shouldClearBackground = false;
 915             if ((baseBgColorUsage != BaseBackgroundColorSkip) &amp;&amp; isOpaqueRoot) {
 916                 baseColor = view().frameView().baseBackgroundColor();
 917                 if (!baseColor.isVisible())
 918                     shouldClearBackground = true;
 919             }
 920 
 921             GraphicsContextStateSaver shadowStateSaver(context, boxShadowShouldBeAppliedToBackground);
 922             if (boxShadowShouldBeAppliedToBackground)
 923                 applyBoxShadowForBackground(context, style());
 924 
 925             FloatRect backgroundRectForPainting = snapRectToDevicePixels(backgroundRect, deviceScaleFactor);
 926             if (baseColor.isVisible()) {
 927                 if (!baseBgColorOnly &amp;&amp; bgColor.isVisible())
 928                     baseColor = baseColor.blend(bgColor);
<span class="line-modified"> 929                 context.fillRect(backgroundRectForPainting, baseColor, CompositeCopy);</span>
 930             } else if (!baseBgColorOnly &amp;&amp; bgColor.isVisible()) {
 931                 auto operation = context.compositeOperation();
 932                 if (shouldClearBackground) {
<span class="line-modified"> 933                     if (op == CompositeDestinationOut) // We&#39;re punching out the background.</span>
 934                         operation = op;
 935                     else
<span class="line-modified"> 936                         operation = CompositeCopy;</span>
 937                 }
 938                 context.fillRect(backgroundRectForPainting, bgColor, operation);
 939             } else if (shouldClearBackground)
 940                 context.clearRect(backgroundRectForPainting);
 941         }
 942     }
 943 
 944     // no progressive loading of the background image
 945     if (!baseBgColorOnly &amp;&amp; shouldPaintBackgroundImage) {
 946         auto geometry = calculateBackgroundImageGeometry(paintInfo.paintContainer, bgLayer, rect.location(), scrolledPaintRect, backgroundObject);
 947         geometry.clip(LayoutRect(pixelSnappedRect));
 948         RefPtr&lt;Image&gt; image;
 949         if (!geometry.destRect().isEmpty() &amp;&amp; (image = bgImage-&gt;image(backgroundObject ? backgroundObject : this, geometry.tileSize()))) {
<span class="line-removed"> 950             auto compositeOp = op == CompositeSourceOver ? bgLayer.composite() : op;</span>
 951             context.setDrawLuminanceMask(bgLayer.maskSourceType() == MaskSourceType::Luminance);
 952 
 953             if (is&lt;BitmapImage&gt;(image))
 954                 downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
 955 
<span class="line-modified"> 956             auto interpolation = chooseInterpolationQuality(context, *image, &amp;bgLayer, geometry.tileSize());</span>
<span class="line-modified"> 957             auto decodingMode = decodingModeForImageDraw(*image, paintInfo);</span>
<span class="line-modified"> 958             auto drawResult = context.drawTiledImage(*image, geometry.destRect(), toLayoutPoint(geometry.relativePhase()), geometry.tileSize(), geometry.spaceSize(), { compositeOp, bgLayer.blendMode(), decodingMode, interpolation });</span>






 959             if (drawResult == ImageDrawResult::DidRequestDecoding) {
<span class="line-modified"> 960                 ASSERT(bgImage-&gt;isCachedImage());</span>
 961                 bgImage-&gt;cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
 962             }
 963         }
 964     }
 965 
 966     if (maskImage &amp;&amp; bgLayer.clip() == FillBox::Text) {
<span class="line-modified"> 967         context.drawConsumingImageBuffer(WTFMove(maskImage), maskRect, CompositeDestinationIn);</span>
 968         context.endTransparencyLayer();
 969     }
 970 }
 971 
 972 static inline LayoutUnit resolveWidthForRatio(LayoutUnit height, const LayoutSize&amp; intrinsicRatio)
 973 {
 974     return height * intrinsicRatio.width() / intrinsicRatio.height();
 975 }
 976 
 977 static inline LayoutUnit resolveHeightForRatio(LayoutUnit width, const LayoutSize&amp; intrinsicRatio)
 978 {
 979     return width * intrinsicRatio.height() / intrinsicRatio.width();
 980 }
 981 
 982 static inline LayoutSize resolveAgainstIntrinsicWidthOrHeightAndRatio(const LayoutSize&amp; size, const LayoutSize&amp; intrinsicRatio, LayoutUnit useWidth, LayoutUnit useHeight)
 983 {
 984     if (intrinsicRatio.isEmpty()) {
 985         if (useWidth)
 986             return LayoutSize(useWidth, size.height());
 987         return LayoutSize(size.width(), useHeight);
</pre>
<hr />
<pre>
2263 
2264     for (int i = BSTop; i &lt;= BSLeft; ++i) {
2265         const BorderEdge&amp; currEdge = edges[i];
2266         if (!currEdge.obscuresBackground())
2267             return false;
2268     }
2269 
2270     return true;
2271 }
2272 
2273 bool RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp;, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* inlineFlowBox) const
2274 {
2275     if (bleedAvoidance != BackgroundBleedNone)
2276         return false;
2277 
2278     if (style().hasAppearance())
2279         return false;
2280 
2281     bool hasOneNormalBoxShadow = false;
2282     for (const ShadowData* currentShadow = style().boxShadow(); currentShadow; currentShadow = currentShadow-&gt;next()) {
<span class="line-modified">2283         if (currentShadow-&gt;style() != Normal)</span>
2284             continue;
2285 
2286         if (hasOneNormalBoxShadow)
2287             return false;
2288         hasOneNormalBoxShadow = true;
2289 
2290         if (currentShadow-&gt;spread())
2291             return false;
2292     }
2293 
2294     if (!hasOneNormalBoxShadow)
2295         return false;
2296 
2297     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
2298     if (!backgroundColor.isOpaque())
2299         return false;
2300 
2301     auto* lastBackgroundLayer = &amp;style().backgroundLayers();
2302     while (auto* next = lastBackgroundLayer-&gt;next())
2303         lastBackgroundLayer = next;
2304 
2305     if (lastBackgroundLayer-&gt;clip() != FillBox::Border)
2306         return false;
2307 
2308     if (lastBackgroundLayer-&gt;image() &amp;&amp; style().hasBorderRadius())
2309         return false;
2310 
2311     if (inlineFlowBox &amp;&amp; !inlineFlowBox-&gt;boxShadowCanBeAppliedToBackground(*lastBackgroundLayer))
2312         return false;
2313 
2314     if (hasOverflowClip() &amp;&amp; lastBackgroundLayer-&gt;attachment() == FillAttachment::LocalBackground)
2315         return false;
2316 
2317     return true;
2318 }
2319 
<span class="line-modified">2320 static inline LayoutRect areaCastingShadowInHole(const LayoutRect&amp; holeRect, int shadowExtent, int shadowSpread, const IntSize&amp; shadowOffset)</span>
2321 {
2322     LayoutRect bounds(holeRect);
2323 
2324     bounds.inflate(shadowExtent);
2325 
2326     if (shadowSpread &lt; 0)
2327         bounds.inflate(-shadowSpread);
2328 
2329     LayoutRect offsetBounds = bounds;
2330     offsetBounds.move(-shadowOffset);
2331     return unionRect(bounds, offsetBounds);
2332 }
2333 
2334 void RenderBoxModelObject::paintBoxShadow(const PaintInfo&amp; info, const LayoutRect&amp; paintRect, const RenderStyle&amp; style, ShadowStyle shadowStyle, bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
2335 {
2336     // FIXME: Deal with border-image.  Would be great to use border-image as a mask.
2337     GraphicsContext&amp; context = info.context();
2338     if (context.paintingDisabled() || !style.boxShadow())
2339         return;
2340 
<span class="line-modified">2341     RoundedRect border = (shadowStyle == Inset) ? style.getRoundedInnerBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge)</span>
2342         : style.getRoundedBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge);
2343 
2344     bool hasBorderRadius = style.hasBorderRadius();
2345     bool isHorizontal = style.isHorizontalWritingMode();
2346     float deviceScaleFactor = document().deviceScaleFactor();
2347 
2348     bool hasOpaqueBackground = style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isOpaque();
2349     for (const ShadowData* shadow = style.boxShadow(); shadow; shadow = shadow-&gt;next()) {
2350         if (shadow-&gt;style() != shadowStyle)
2351             continue;
2352 
<span class="line-modified">2353         // FIXME: Add subpixel support for the shadow values. Soon after the shadow offset becomes fractional,</span>
<span class="line-modified">2354         // all the early snappings here need to be pushed to the actual painting operations.</span>
<span class="line-modified">2355         IntSize shadowOffset(shadow-&gt;x(), shadow-&gt;y());</span>
2356         int shadowRadius = shadow-&gt;radius();
<span class="line-removed">2357         int shadowPaintingExtent = shadow-&gt;paintingExtent();</span>
<span class="line-removed">2358         int shadowSpread = shadow-&gt;spread();</span>
2359 
2360         if (shadowOffset.isZero() &amp;&amp; !shadowRadius &amp;&amp; !shadowSpread)
2361             continue;
2362 
2363         Color shadowColor = style.colorByApplyingColorFilter(shadow-&gt;color());
2364 
<span class="line-modified">2365         if (shadow-&gt;style() == Normal) {</span>
2366             RoundedRect fillRect = border;
2367             fillRect.inflate(shadowSpread);
2368             if (fillRect.isEmpty())
2369                 continue;
2370 
<span class="line-modified">2371             FloatRect pixelSnappedShadowRect = snapRectToDevicePixels(border.rect(), deviceScaleFactor);</span>
<span class="line-modified">2372             pixelSnappedShadowRect.inflate(shadowPaintingExtent + shadowSpread);</span>
<span class="line-modified">2373             pixelSnappedShadowRect.move(shadowOffset);</span>

2374 
2375             GraphicsContextStateSaver stateSaver(context);
2376             context.clip(pixelSnappedShadowRect);
2377 
<span class="line-modified">2378             // Move the fill just outside the clip, adding 1 pixel separation so that the fill does not</span>
2379             // bleed in (due to antialiasing) if the context is transformed.
<span class="line-modified">2380             IntSize extraOffset(roundToInt(paintRect.width()) + std::max(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + 1, 0);</span>

2381             shadowOffset -= extraOffset;
2382             fillRect.move(extraOffset);
2383 







2384             if (shadow-&gt;isWebkitBoxShadow())
<span class="line-modified">2385                 context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);</span>
2386             else
<span class="line-modified">2387                 context.setShadow(shadowOffset, shadowRadius, shadowColor);</span>
2388 
<span class="line-removed">2389             FloatRoundedRect rectToClipOut = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-removed">2390             FloatRoundedRect pixelSnappedFillRect = fillRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
2391             if (hasBorderRadius) {
2392                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2393                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2394                 // corners. Those are avoided by insetting the clipping path by one pixel.
2395                 if (hasOpaqueBackground)
<span class="line-modified">2396                     rectToClipOut.inflateWithRadii(-1.0f);</span>
2397 
<span class="line-modified">2398                 if (!rectToClipOut.isEmpty())</span>
<span class="line-modified">2399                     context.clipOutRoundedRect(rectToClipOut);</span>
2400 
2401                 RoundedRect influenceRect(LayoutRect(pixelSnappedShadowRect), border.radii());
2402                 influenceRect.expandRadii(2 * shadowPaintingExtent + shadowSpread);
2403 
2404                 if (allCornersClippedOut(influenceRect, info.rect))
2405                     context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2406                 else {
2407                     pixelSnappedFillRect.expandRadii(shadowSpread);
2408                     if (!pixelSnappedFillRect.isRenderable())
2409                         pixelSnappedFillRect.adjustRadii();
2410                     context.fillRoundedRect(pixelSnappedFillRect, Color::black);
2411                 }
2412             } else {
2413                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2414                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2415                 // edges if they are not pixel-aligned. Those are avoided by insetting the clipping path
2416                 // by one pixel.
2417                 if (hasOpaqueBackground) {
2418                     // FIXME: The function to decide on the policy based on the transform should be a named function.
2419                     // FIXME: It&#39;s not clear if this check is right. What about integral scale factors?
2420                     AffineTransform transform = context.getCTM();
2421                     if (transform.a() != 1 || (transform.d() != 1 &amp;&amp; transform.d() != -1) || transform.b() || transform.c())
<span class="line-modified">2422                         rectToClipOut.inflate(-1.0f);</span>
2423                 }
2424 
<span class="line-modified">2425                 if (!rectToClipOut.isEmpty())</span>
<span class="line-modified">2426                     context.clipOut(rectToClipOut.rect());</span>

2427                 context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2428             }
2429         } else {
2430             // Inset shadow.



2431             FloatRoundedRect pixelSnappedBorderRect = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
<span class="line-removed">2432             FloatRect pixelSnappedHoleRect = pixelSnappedBorderRect.rect();</span>
<span class="line-removed">2433             pixelSnappedHoleRect.inflate(-shadowSpread);</span>
2434 
2435             if (pixelSnappedHoleRect.isEmpty()) {
2436                 if (hasBorderRadius)
2437                     context.fillRoundedRect(pixelSnappedBorderRect, shadowColor);
2438                 else
2439                     context.fillRect(pixelSnappedBorderRect.rect(), shadowColor);
2440                 continue;
2441             }
2442 
2443             if (!includeLogicalLeftEdge) {
2444                 if (isHorizontal) {
<span class="line-modified">2445                     pixelSnappedHoleRect.move(-std::max(shadowOffset.width(), 0) - shadowPaintingExtent, 0);</span>
<span class="line-modified">2446                     pixelSnappedHoleRect.setWidth(pixelSnappedHoleRect.width() + std::max(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
2447                 } else {
<span class="line-modified">2448                     pixelSnappedHoleRect.move(0, -std::max(shadowOffset.height(), 0) - shadowPaintingExtent);</span>
<span class="line-modified">2449                     pixelSnappedHoleRect.setHeight(pixelSnappedHoleRect.height() + std::max(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
2450                 }
2451             }

2452             if (!includeLogicalRightEdge) {
2453                 if (isHorizontal)
<span class="line-modified">2454                     pixelSnappedHoleRect.setWidth(pixelSnappedHoleRect.width() - std::min(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
2455                 else
<span class="line-modified">2456                     pixelSnappedHoleRect.setHeight(pixelSnappedHoleRect.height() - std::min(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
2457             }
2458 



2459             Color fillColor(shadowColor.red(), shadowColor.green(), shadowColor.blue(), 255);
2460 
<span class="line-modified">2461             FloatRect pixelSnappedOuterRect = snapRectToDevicePixels(areaCastingShadowInHole(LayoutRect(pixelSnappedBorderRect.rect()), shadowPaintingExtent, shadowSpread, shadowOffset), deviceScaleFactor);</span>
<span class="line-modified">2462             FloatRoundedRect pixelSnappedRoundedHole = FloatRoundedRect(pixelSnappedHoleRect, pixelSnappedBorderRect.radii());</span>



2463 
2464             GraphicsContextStateSaver stateSaver(context);
2465             if (hasBorderRadius) {
2466                 context.clipRoundedRect(pixelSnappedBorderRect);
2467                 pixelSnappedRoundedHole.shrinkRadii(shadowSpread);
2468             } else
2469                 context.clip(pixelSnappedBorderRect.rect());
2470 
<span class="line-modified">2471             IntSize extraOffset(2 * roundToInt(paintRect.width()) + std::max(0, shadowOffset.width()) + shadowPaintingExtent - 2 * shadowSpread + 1, 0);</span>


2472             context.translate(extraOffset);
2473             shadowOffset -= extraOffset;
2474 
2475             if (shadow-&gt;isWebkitBoxShadow())
2476                 context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
2477             else
2478                 context.setShadow(shadowOffset, shadowRadius, shadowColor);
2479 
<span class="line-modified">2480             context.fillRectWithRoundedHole(pixelSnappedOuterRect, pixelSnappedRoundedHole, fillColor);</span>
2481         }
2482     }
2483 }
2484 
2485 LayoutUnit RenderBoxModelObject::containingBlockLogicalWidthForContent() const
2486 {
2487     if (auto* containingBlock = this-&gt;containingBlock())
2488         return containingBlock-&gt;availableLogicalWidth();
2489     return { };
2490 }
2491 
2492 RenderBoxModelObject* RenderBoxModelObject::continuation() const
2493 {
2494     if (!hasContinuationChainNode())
2495         return nullptr;
2496 
2497     auto&amp; continuationChainNode = *continuationChainNodeMap().get(this);
2498     if (!continuationChainNode.next)
2499         return nullptr;
2500     return continuationChainNode.next-&gt;renderer.get();
</pre>
<hr />
<pre>
2657     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint());
2658 
2659     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
2660     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
2661         TransformationMatrix t;
2662         getTransformFromContainer(container, containerOffset, t);
2663         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2664     } else
2665         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2666 }
2667 
2668 bool RenderBoxModelObject::hasRunningAcceleratedAnimations() const
2669 {
2670     if (auto* node = element()) {
2671         if (auto* timeline = node-&gt;document().existingTimeline())
2672             return timeline-&gt;runningAnimationsForElementAreAllAccelerated(*node);
2673     }
2674     return false;
2675 }
2676 

















2677 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  45 #include &quot;Path.h&quot;
  46 #include &quot;RenderBlock.h&quot;
  47 #include &quot;RenderFlexibleBox.h&quot;
  48 #include &quot;RenderFragmentContainer.h&quot;
  49 #include &quot;RenderInline.h&quot;
  50 #include &quot;RenderLayer.h&quot;
  51 #include &quot;RenderLayerBacking.h&quot;
  52 #include &quot;RenderLayerCompositor.h&quot;
  53 #include &quot;RenderMultiColumnFlow.h&quot;
  54 #include &quot;RenderTable.h&quot;
  55 #include &quot;RenderTableRow.h&quot;
  56 #include &quot;RenderText.h&quot;
  57 #include &quot;RenderTextFragment.h&quot;
  58 #include &quot;RenderTreeBuilder.h&quot;
  59 #include &quot;RenderView.h&quot;
  60 #include &quot;ScrollingConstraints.h&quot;
  61 #include &quot;Settings.h&quot;
  62 #include &quot;TransformState.h&quot;
  63 #include &lt;wtf/IsoMallocInlines.h&gt;
  64 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">  65 #if ASSERT_ENABLED</span>
  66 #include &lt;wtf/SetForScope.h&gt;
  67 #endif
  68 
  69 #if PLATFORM(IOS_FAMILY)
  70 #include &quot;RuntimeApplicationChecks.h&quot;
  71 #endif
  72 
  73 namespace WebCore {
  74 
  75 using namespace HTMLNames;
  76 
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBoxModelObject);
  78 
  79 // The HashMap for storing continuation pointers.
  80 // An inline can be split with blocks occuring in between the inline content.
  81 // When this occurs we need a pointer to the next object. We can basically be
  82 // split into a sequence of inlines and blocks. The continuation will either be
  83 // an anonymous block (that houses other blocks) or it will be an inline flow.
  84 // &lt;b&gt;&lt;i&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/i&gt;&lt;/b&gt;. In this example the &lt;i&gt; will have a block as
  85 // its continuation but the &lt;b&gt; will just have an inline as its continuation.
</pre>
<hr />
<pre>
 428                 } else if (!isOutOfFlowPositioned()) {
 429                     if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor))
 430                         referencePoint.moveBy(downcast&lt;RenderBox&gt;(*ancestor).topLeftLocation());
 431                 }
 432 
 433                 ancestor = ancestor-&gt;parent();
 434             }
 435 
 436             if (is&lt;RenderBox&gt;(*offsetParent) &amp;&amp; offsetParent-&gt;isBody() &amp;&amp; !offsetParent-&gt;isPositioned())
 437                 referencePoint.moveBy(downcast&lt;RenderBox&gt;(*offsetParent).topLeftLocation());
 438         }
 439     }
 440 
 441     return referencePoint;
 442 }
 443 
 444 const RenderBox&amp; RenderBoxModelObject::enclosingClippingBoxForStickyPosition(const RenderLayer** enclosingClippingLayer) const
 445 {
 446     ASSERT(isStickilyPositioned());
 447 
<span class="line-modified"> 448     RenderLayer* clipLayer = hasLayer() ? layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf) : nullptr;</span>
<span class="line-added"> 449 </span>
 450     if (enclosingClippingLayer)
 451         *enclosingClippingLayer = clipLayer;
 452 
 453     return clipLayer ? downcast&lt;RenderBox&gt;(clipLayer-&gt;renderer()) : view();
 454 }
 455 
 456 void RenderBoxModelObject::computeStickyPositionConstraints(StickyPositionViewportConstraints&amp; constraints, const FloatRect&amp; constrainingRect) const
 457 {
 458     constraints.setConstrainingRectAtLastLayout(constrainingRect);
 459 
 460     RenderBlock* containingBlock = this-&gt;containingBlock();
 461     const RenderLayer* enclosingClippingLayer = nullptr;
 462     auto&amp; enclosingClippingBox = enclosingClippingBoxForStickyPosition(&amp;enclosingClippingLayer);
 463 
 464     LayoutRect containerContentRect;
 465     if (!enclosingClippingLayer || (containingBlock != &amp;enclosingClippingBox))
 466         containerContentRect = containingBlock-&gt;contentBoxRect();
 467     else {
 468         containerContentRect = containingBlock-&gt;layoutOverflowRect();
 469         LayoutPoint containerLocation = containerContentRect.location() + LayoutPoint(containingBlock-&gt;borderLeft() + containingBlock-&gt;paddingLeft(),
</pre>
<hr />
<pre>
 520     }
 521 
 522     if (!style().right().isAuto()) {
 523         constraints.setRightOffset(valueForLength(style().right(), constrainingRect.width()));
 524         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
 525     }
 526 
 527     if (!style().top().isAuto()) {
 528         constraints.setTopOffset(valueForLength(style().top(), constrainingRect.height()));
 529         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
 530     }
 531 
 532     if (!style().bottom().isAuto()) {
 533         constraints.setBottomOffset(valueForLength(style().bottom(), constrainingRect.height()));
 534         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
 535     }
 536 }
 537 
 538 FloatRect RenderBoxModelObject::constrainingRectForStickyPosition() const
 539 {
<span class="line-modified"> 540     RenderLayer* enclosingClippingLayer = hasLayer() ? layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf) : nullptr;</span>
<span class="line-added"> 541 </span>
 542     if (enclosingClippingLayer) {
 543         RenderBox&amp; enclosingClippingBox = downcast&lt;RenderBox&gt;(enclosingClippingLayer-&gt;renderer());
 544         LayoutRect clipRect = enclosingClippingBox.overflowClipRect(LayoutPoint(), nullptr); // FIXME: make this work in regions.
 545         clipRect.contract(LayoutSize(enclosingClippingBox.paddingLeft() + enclosingClippingBox.paddingRight(),
 546             enclosingClippingBox.paddingTop() + enclosingClippingBox.paddingBottom()));
 547 
 548         FloatRect constrainingRect = enclosingClippingBox.localToContainerQuad(FloatRect(clipRect), &amp;view()).boundingBox();
 549 
 550         FloatPoint scrollOffset = FloatPoint() + enclosingClippingLayer-&gt;scrollOffset();
 551 
 552         float scrollbarOffset = 0;
 553         if (enclosingClippingBox.hasLayer() &amp;&amp; enclosingClippingBox.shouldPlaceBlockDirectionScrollbarOnLeft())
 554             scrollbarOffset = enclosingClippingBox.layer()-&gt;verticalScrollbarWidth(IgnoreOverlayScrollbarSize);
 555 
 556         constrainingRect.setLocation(FloatPoint(scrollOffset.x() + scrollbarOffset, scrollOffset.y()));
 557         return constrainingRect;
 558     }
 559 
 560     return view().frameView().rectForFixedPositionLayout();
 561 }
 562 
 563 LayoutSize RenderBoxModelObject::stickyPositionOffset() const
 564 {


 565     FloatRect constrainingRect = constrainingRectForStickyPosition();
 566     StickyPositionViewportConstraints constraints;
 567     computeStickyPositionConstraints(constraints, constrainingRect);
 568 
 569     // The sticky offset is physical, so we can just return the delta computed in absolute coords (though it may be wrong with transforms).
 570     return LayoutSize(constraints.computeStickyOffset(constrainingRect));
 571 }
 572 
 573 LayoutSize RenderBoxModelObject::offsetForInFlowPosition() const
 574 {
 575     if (isRelativelyPositioned())
 576         return relativePositionOffset();
 577 
 578     if (isStickilyPositioned())
 579         return stickyPositionOffset();
 580 
 581     return LayoutSize();
 582 }
 583 
 584 LayoutUnit RenderBoxModelObject::offsetLeft() const
</pre>
<hr />
<pre>
 663     // We shrink the rectangle by one device pixel on each side to make it fully overlap the anti-aliased background border
 664     return shrinkRectByOneDevicePixel(context, rect, document().deviceScaleFactor());
 665 }
 666 
 667 RoundedRect RenderBoxModelObject::backgroundRoundedRectAdjustedForBleedAvoidance(const GraphicsContext&amp; context, const LayoutRect&amp; borderRect, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* box, const LayoutSize&amp; boxSize, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
 668 {
 669     if (bleedAvoidance == BackgroundBleedShrinkBackground) {
 670         // We shrink the rectangle by one device pixel on each side because the bleed is one pixel maximum.
 671         return getBackgroundRoundedRect(shrinkRectByOneDevicePixel(context, borderRect, document().deviceScaleFactor()), box, boxSize.width(), boxSize.height(),
 672             includeLogicalLeftEdge, includeLogicalRightEdge);
 673     }
 674     if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
 675         return style().getRoundedInnerBorderFor(borderRect, includeLogicalLeftEdge, includeLogicalRightEdge);
 676 
 677     return getBackgroundRoundedRect(borderRect, box, boxSize.width(), boxSize.height(), includeLogicalLeftEdge, includeLogicalRightEdge);
 678 }
 679 
 680 static void applyBoxShadowForBackground(GraphicsContext&amp; context, const RenderStyle&amp; style)
 681 {
 682     const ShadowData* boxShadow = style.boxShadow();
<span class="line-modified"> 683     while (boxShadow-&gt;style() != ShadowStyle::Normal)</span>
 684         boxShadow = boxShadow-&gt;next();
 685 
 686     FloatSize shadowOffset(boxShadow-&gt;x(), boxShadow-&gt;y());
 687     if (!boxShadow-&gt;isWebkitBoxShadow())
 688         context.setShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 689     else
 690         context.setLegacyShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 691 }
 692 
 693 InterpolationQuality RenderBoxModelObject::chooseInterpolationQuality(GraphicsContext&amp; context, Image&amp; image, const void* layer, const LayoutSize&amp; size)
 694 {
 695     return view().imageQualityController().chooseInterpolationQuality(context, this, image, layer, size);
 696 }
 697 
 698 void RenderBoxModelObject::paintMaskForTextFillBox(ImageBuffer* maskImage, const IntRect&amp; maskRect, InlineFlowBox* box, const LayoutRect&amp; scrolledPaintRect)
 699 {
 700     GraphicsContext&amp; maskImageContext = maskImage-&gt;context();
 701     maskImageContext.translate(-maskRect.location());
 702 
 703     // Now add the text to the clip. We do this by painting using a special paint phase that signals to
</pre>
<hr />
<pre>
 844 
 845     if (bgLayer.clip() == FillBox::Padding || bgLayer.clip() == FillBox::Content) {
 846         // Clip to the padding or content boxes as necessary.
 847         if (!clipToBorderRadius) {
 848             bool includePadding = bgLayer.clip() == FillBox::Content;
 849             LayoutRect clipRect = LayoutRect(scrolledPaintRect.x() + bLeft + (includePadding ? pLeft : 0_lu),
 850                 scrolledPaintRect.y() + borderTop() + (includePadding ? paddingTop() : 0_lu),
 851                 scrolledPaintRect.width() - bLeft - bRight - (includePadding ? pLeft + pRight : 0_lu),
 852                 scrolledPaintRect.height() - borderTop() - borderBottom() - (includePadding ? paddingTop() + paddingBottom() : 0_lu));
 853             backgroundClipStateSaver.save();
 854             context.clip(clipRect);
 855         }
 856     } else if (bgLayer.clip() == FillBox::Text) {
 857         // We have to draw our text into a mask that can then be used to clip background drawing.
 858         // First figure out how big the mask has to be.  It should be no bigger than what we need
 859         // to actually render, so we should intersect the dirty rect with the border box of the background.
 860         maskRect = snappedIntRect(rect);
 861         maskRect.intersect(snappedIntRect(paintInfo.rect));
 862 
 863         // Now create the mask.
<span class="line-modified"> 864         maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpace::SRGB, context);</span>
 865         if (!maskImage)
 866             return;
 867         paintMaskForTextFillBox(maskImage.get(), maskRect, box, scrolledPaintRect);
 868 
 869         // The mask has been created.  Now we just need to clip to it.
 870         backgroundClipStateSaver.save();
 871         context.clip(maskRect);
 872         context.beginTransparencyLayer(1);
 873     }
 874 
 875     // Only fill with a base color (e.g., white) if we&#39;re the root document, since iframes/frames with
 876     // no background in the child document should show the parent&#39;s background.
 877     bool isOpaqueRoot = false;
 878     if (isRoot) {
 879         isOpaqueRoot = true;
 880         if (!bgLayer.next() &amp;&amp; !bgColor.isOpaque()) {
 881             HTMLFrameOwnerElement* ownerElement = document().ownerElement();
 882             if (ownerElement) {
 883                 if (!ownerElement-&gt;hasTagName(frameTag)) {
 884                     // Locate the &lt;body&gt; element using the DOM.  This is easier than trying
</pre>
<hr />
<pre>
 909             if (!boxShadowShouldBeAppliedToBackground)
 910                 backgroundRect.intersect(paintInfo.rect);
 911 
 912             // If we have an alpha and we are painting the root element, blend with the base background color.
 913             Color baseColor;
 914             bool shouldClearBackground = false;
 915             if ((baseBgColorUsage != BaseBackgroundColorSkip) &amp;&amp; isOpaqueRoot) {
 916                 baseColor = view().frameView().baseBackgroundColor();
 917                 if (!baseColor.isVisible())
 918                     shouldClearBackground = true;
 919             }
 920 
 921             GraphicsContextStateSaver shadowStateSaver(context, boxShadowShouldBeAppliedToBackground);
 922             if (boxShadowShouldBeAppliedToBackground)
 923                 applyBoxShadowForBackground(context, style());
 924 
 925             FloatRect backgroundRectForPainting = snapRectToDevicePixels(backgroundRect, deviceScaleFactor);
 926             if (baseColor.isVisible()) {
 927                 if (!baseBgColorOnly &amp;&amp; bgColor.isVisible())
 928                     baseColor = baseColor.blend(bgColor);
<span class="line-modified"> 929                 context.fillRect(backgroundRectForPainting, baseColor, CompositeOperator::Copy);</span>
 930             } else if (!baseBgColorOnly &amp;&amp; bgColor.isVisible()) {
 931                 auto operation = context.compositeOperation();
 932                 if (shouldClearBackground) {
<span class="line-modified"> 933                     if (op == CompositeOperator::DestinationOut) // We&#39;re punching out the background.</span>
 934                         operation = op;
 935                     else
<span class="line-modified"> 936                         operation = CompositeOperator::Copy;</span>
 937                 }
 938                 context.fillRect(backgroundRectForPainting, bgColor, operation);
 939             } else if (shouldClearBackground)
 940                 context.clearRect(backgroundRectForPainting);
 941         }
 942     }
 943 
 944     // no progressive loading of the background image
 945     if (!baseBgColorOnly &amp;&amp; shouldPaintBackgroundImage) {
 946         auto geometry = calculateBackgroundImageGeometry(paintInfo.paintContainer, bgLayer, rect.location(), scrolledPaintRect, backgroundObject);
 947         geometry.clip(LayoutRect(pixelSnappedRect));
 948         RefPtr&lt;Image&gt; image;
 949         if (!geometry.destRect().isEmpty() &amp;&amp; (image = bgImage-&gt;image(backgroundObject ? backgroundObject : this, geometry.tileSize()))) {

 950             context.setDrawLuminanceMask(bgLayer.maskSourceType() == MaskSourceType::Luminance);
 951 
 952             if (is&lt;BitmapImage&gt;(image))
 953                 downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
 954 
<span class="line-modified"> 955             ImagePaintingOptions options = {</span>
<span class="line-modified"> 956                 op == CompositeOperator::SourceOver ? bgLayer.composite() : op,</span>
<span class="line-modified"> 957                 bgLayer.blendMode(),</span>
<span class="line-added"> 958                 decodingModeForImageDraw(*image, paintInfo),</span>
<span class="line-added"> 959                 ImageOrientation::FromImage,</span>
<span class="line-added"> 960                 chooseInterpolationQuality(context, *image, &amp;bgLayer, geometry.tileSize())</span>
<span class="line-added"> 961             };</span>
<span class="line-added"> 962 </span>
<span class="line-added"> 963             auto drawResult = context.drawTiledImage(*image, geometry.destRect(), toLayoutPoint(geometry.relativePhase()), geometry.tileSize(), geometry.spaceSize(), options);</span>
 964             if (drawResult == ImageDrawResult::DidRequestDecoding) {
<span class="line-modified"> 965                 ASSERT(bgImage-&gt;hasCachedImage());</span>
 966                 bgImage-&gt;cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
 967             }
 968         }
 969     }
 970 
 971     if (maskImage &amp;&amp; bgLayer.clip() == FillBox::Text) {
<span class="line-modified"> 972         context.drawConsumingImageBuffer(WTFMove(maskImage), maskRect, CompositeOperator::DestinationIn);</span>
 973         context.endTransparencyLayer();
 974     }
 975 }
 976 
 977 static inline LayoutUnit resolveWidthForRatio(LayoutUnit height, const LayoutSize&amp; intrinsicRatio)
 978 {
 979     return height * intrinsicRatio.width() / intrinsicRatio.height();
 980 }
 981 
 982 static inline LayoutUnit resolveHeightForRatio(LayoutUnit width, const LayoutSize&amp; intrinsicRatio)
 983 {
 984     return width * intrinsicRatio.height() / intrinsicRatio.width();
 985 }
 986 
 987 static inline LayoutSize resolveAgainstIntrinsicWidthOrHeightAndRatio(const LayoutSize&amp; size, const LayoutSize&amp; intrinsicRatio, LayoutUnit useWidth, LayoutUnit useHeight)
 988 {
 989     if (intrinsicRatio.isEmpty()) {
 990         if (useWidth)
 991             return LayoutSize(useWidth, size.height());
 992         return LayoutSize(size.width(), useHeight);
</pre>
<hr />
<pre>
2268 
2269     for (int i = BSTop; i &lt;= BSLeft; ++i) {
2270         const BorderEdge&amp; currEdge = edges[i];
2271         if (!currEdge.obscuresBackground())
2272             return false;
2273     }
2274 
2275     return true;
2276 }
2277 
2278 bool RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp;, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* inlineFlowBox) const
2279 {
2280     if (bleedAvoidance != BackgroundBleedNone)
2281         return false;
2282 
2283     if (style().hasAppearance())
2284         return false;
2285 
2286     bool hasOneNormalBoxShadow = false;
2287     for (const ShadowData* currentShadow = style().boxShadow(); currentShadow; currentShadow = currentShadow-&gt;next()) {
<span class="line-modified">2288         if (currentShadow-&gt;style() != ShadowStyle::Normal)</span>
2289             continue;
2290 
2291         if (hasOneNormalBoxShadow)
2292             return false;
2293         hasOneNormalBoxShadow = true;
2294 
2295         if (currentShadow-&gt;spread())
2296             return false;
2297     }
2298 
2299     if (!hasOneNormalBoxShadow)
2300         return false;
2301 
2302     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
2303     if (!backgroundColor.isOpaque())
2304         return false;
2305 
2306     auto* lastBackgroundLayer = &amp;style().backgroundLayers();
2307     while (auto* next = lastBackgroundLayer-&gt;next())
2308         lastBackgroundLayer = next;
2309 
2310     if (lastBackgroundLayer-&gt;clip() != FillBox::Border)
2311         return false;
2312 
2313     if (lastBackgroundLayer-&gt;image() &amp;&amp; style().hasBorderRadius())
2314         return false;
2315 
2316     if (inlineFlowBox &amp;&amp; !inlineFlowBox-&gt;boxShadowCanBeAppliedToBackground(*lastBackgroundLayer))
2317         return false;
2318 
2319     if (hasOverflowClip() &amp;&amp; lastBackgroundLayer-&gt;attachment() == FillAttachment::LocalBackground)
2320         return false;
2321 
2322     return true;
2323 }
2324 
<span class="line-modified">2325 static inline LayoutRect areaCastingShadowInHole(const LayoutRect&amp; holeRect, LayoutUnit shadowExtent, LayoutUnit shadowSpread, const LayoutSize&amp; shadowOffset)</span>
2326 {
2327     LayoutRect bounds(holeRect);
2328 
2329     bounds.inflate(shadowExtent);
2330 
2331     if (shadowSpread &lt; 0)
2332         bounds.inflate(-shadowSpread);
2333 
2334     LayoutRect offsetBounds = bounds;
2335     offsetBounds.move(-shadowOffset);
2336     return unionRect(bounds, offsetBounds);
2337 }
2338 
2339 void RenderBoxModelObject::paintBoxShadow(const PaintInfo&amp; info, const LayoutRect&amp; paintRect, const RenderStyle&amp; style, ShadowStyle shadowStyle, bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
2340 {
2341     // FIXME: Deal with border-image.  Would be great to use border-image as a mask.
2342     GraphicsContext&amp; context = info.context();
2343     if (context.paintingDisabled() || !style.boxShadow())
2344         return;
2345 
<span class="line-modified">2346     RoundedRect border = (shadowStyle == ShadowStyle::Inset) ? style.getRoundedInnerBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge)</span>
2347         : style.getRoundedBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge);
2348 
2349     bool hasBorderRadius = style.hasBorderRadius();
2350     bool isHorizontal = style.isHorizontalWritingMode();
2351     float deviceScaleFactor = document().deviceScaleFactor();
2352 
2353     bool hasOpaqueBackground = style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isOpaque();
2354     for (const ShadowData* shadow = style.boxShadow(); shadow; shadow = shadow-&gt;next()) {
2355         if (shadow-&gt;style() != shadowStyle)
2356             continue;
2357 
<span class="line-modified">2358         LayoutSize shadowOffset(shadow-&gt;x(), shadow-&gt;y());</span>
<span class="line-modified">2359         LayoutUnit shadowPaintingExtent = shadow-&gt;paintingExtent();</span>
<span class="line-modified">2360         LayoutUnit shadowSpread = shadow-&gt;spread();</span>
2361         int shadowRadius = shadow-&gt;radius();


2362 
2363         if (shadowOffset.isZero() &amp;&amp; !shadowRadius &amp;&amp; !shadowSpread)
2364             continue;
2365 
2366         Color shadowColor = style.colorByApplyingColorFilter(shadow-&gt;color());
2367 
<span class="line-modified">2368         if (shadow-&gt;style() == ShadowStyle::Normal) {</span>
2369             RoundedRect fillRect = border;
2370             fillRect.inflate(shadowSpread);
2371             if (fillRect.isEmpty())
2372                 continue;
2373 
<span class="line-modified">2374             LayoutRect shadowRect = border.rect();</span>
<span class="line-modified">2375             shadowRect.inflate(shadowPaintingExtent + shadowSpread);</span>
<span class="line-modified">2376             shadowRect.move(shadowOffset);</span>
<span class="line-added">2377             FloatRect pixelSnappedShadowRect = snapRectToDevicePixels(shadowRect, deviceScaleFactor);</span>
2378 
2379             GraphicsContextStateSaver stateSaver(context);
2380             context.clip(pixelSnappedShadowRect);
2381 
<span class="line-modified">2382             // Move the fill just outside the clip, adding at least 1 pixel of separation so that the fill does not</span>
2383             // bleed in (due to antialiasing) if the context is transformed.
<span class="line-modified">2384             LayoutUnit xOffset = paintRect.width() + std::max&lt;LayoutUnit&gt;(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + LayoutUnit(1);</span>
<span class="line-added">2385             LayoutSize extraOffset(xOffset.ceil(), 0);</span>
2386             shadowOffset -= extraOffset;
2387             fillRect.move(extraOffset);
2388 
<span class="line-added">2389             FloatRoundedRect pixelSnappedRectToClipOut = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-added">2390             FloatRoundedRect pixelSnappedFillRect = fillRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-added">2391 </span>
<span class="line-added">2392             LayoutPoint shadowRectOrigin = fillRect.rect().location() + shadowOffset;</span>
<span class="line-added">2393             FloatPoint snappedShadowOrigin = FloatPoint(roundToDevicePixel(shadowRectOrigin.x(), deviceScaleFactor), roundToDevicePixel(shadowRectOrigin.y(), deviceScaleFactor));</span>
<span class="line-added">2394             FloatSize snappedShadowOffset = snappedShadowOrigin - pixelSnappedFillRect.rect().location();</span>
<span class="line-added">2395 </span>
2396             if (shadow-&gt;isWebkitBoxShadow())
<span class="line-modified">2397                 context.setLegacyShadow(snappedShadowOffset, shadowRadius, shadowColor);</span>
2398             else
<span class="line-modified">2399                 context.setShadow(snappedShadowOffset, shadowRadius, shadowColor);</span>
2400 


2401             if (hasBorderRadius) {
2402                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2403                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2404                 // corners. Those are avoided by insetting the clipping path by one pixel.
2405                 if (hasOpaqueBackground)
<span class="line-modified">2406                     pixelSnappedRectToClipOut.inflateWithRadii(-1.0f);</span>
2407 
<span class="line-modified">2408                 if (!pixelSnappedRectToClipOut.isEmpty())</span>
<span class="line-modified">2409                     context.clipOutRoundedRect(pixelSnappedRectToClipOut);</span>
2410 
2411                 RoundedRect influenceRect(LayoutRect(pixelSnappedShadowRect), border.radii());
2412                 influenceRect.expandRadii(2 * shadowPaintingExtent + shadowSpread);
2413 
2414                 if (allCornersClippedOut(influenceRect, info.rect))
2415                     context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2416                 else {
2417                     pixelSnappedFillRect.expandRadii(shadowSpread);
2418                     if (!pixelSnappedFillRect.isRenderable())
2419                         pixelSnappedFillRect.adjustRadii();
2420                     context.fillRoundedRect(pixelSnappedFillRect, Color::black);
2421                 }
2422             } else {
2423                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2424                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2425                 // edges if they are not pixel-aligned. Those are avoided by insetting the clipping path
2426                 // by one pixel.
2427                 if (hasOpaqueBackground) {
2428                     // FIXME: The function to decide on the policy based on the transform should be a named function.
2429                     // FIXME: It&#39;s not clear if this check is right. What about integral scale factors?
2430                     AffineTransform transform = context.getCTM();
2431                     if (transform.a() != 1 || (transform.d() != 1 &amp;&amp; transform.d() != -1) || transform.b() || transform.c())
<span class="line-modified">2432                         pixelSnappedRectToClipOut.inflate(-1.0f);</span>
2433                 }
2434 
<span class="line-modified">2435                 if (!pixelSnappedRectToClipOut.isEmpty())</span>
<span class="line-modified">2436                     context.clipOut(pixelSnappedRectToClipOut.rect());</span>
<span class="line-added">2437 </span>
2438                 context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2439             }
2440         } else {
2441             // Inset shadow.
<span class="line-added">2442             LayoutRect holeRect = border.rect();</span>
<span class="line-added">2443             holeRect.inflate(-shadowSpread);</span>
<span class="line-added">2444             FloatRect pixelSnappedHoleRect = snapRectToDevicePixels(holeRect, deviceScaleFactor);</span>
2445             FloatRoundedRect pixelSnappedBorderRect = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);


2446 
2447             if (pixelSnappedHoleRect.isEmpty()) {
2448                 if (hasBorderRadius)
2449                     context.fillRoundedRect(pixelSnappedBorderRect, shadowColor);
2450                 else
2451                     context.fillRect(pixelSnappedBorderRect.rect(), shadowColor);
2452                 continue;
2453             }
2454 
2455             if (!includeLogicalLeftEdge) {
2456                 if (isHorizontal) {
<span class="line-modified">2457                     holeRect.move(-std::max&lt;LayoutUnit&gt;(shadowOffset.width(), 0) - shadowPaintingExtent, 0);</span>
<span class="line-modified">2458                     holeRect.setWidth(holeRect.width() + std::max&lt;LayoutUnit&gt;(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
2459                 } else {
<span class="line-modified">2460                     holeRect.move(0, -std::max&lt;LayoutUnit&gt;(shadowOffset.height(), 0) - shadowPaintingExtent);</span>
<span class="line-modified">2461                     holeRect.setHeight(holeRect.height() + std::max&lt;LayoutUnit&gt;(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
2462                 }
2463             }
<span class="line-added">2464 </span>
2465             if (!includeLogicalRightEdge) {
2466                 if (isHorizontal)
<span class="line-modified">2467                     holeRect.setWidth(holeRect.width() - std::min&lt;LayoutUnit&gt;(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
2468                 else
<span class="line-modified">2469                     holeRect.setHeight(holeRect.height() - std::min&lt;LayoutUnit&gt;(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
2470             }
2471 
<span class="line-added">2472             if (!includeLogicalLeftEdge || !includeLogicalRightEdge)</span>
<span class="line-added">2473                 pixelSnappedHoleRect = snapRectToDevicePixels(holeRect, deviceScaleFactor);</span>
<span class="line-added">2474 </span>
2475             Color fillColor(shadowColor.red(), shadowColor.green(), shadowColor.blue(), 255);
2476 
<span class="line-modified">2477             LayoutRect shadowCastingRect = areaCastingShadowInHole(border.rect(), shadowPaintingExtent, shadowSpread, shadowOffset);</span>
<span class="line-modified">2478             RoundedRect roundedHoleRect(holeRect, border.radii());</span>
<span class="line-added">2479 </span>
<span class="line-added">2480             FloatRect pixelSnappedOuterRect = snapRectToDevicePixels(shadowCastingRect, deviceScaleFactor);</span>
<span class="line-added">2481             FloatRoundedRect pixelSnappedRoundedHole = roundedHoleRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
2482 
2483             GraphicsContextStateSaver stateSaver(context);
2484             if (hasBorderRadius) {
2485                 context.clipRoundedRect(pixelSnappedBorderRect);
2486                 pixelSnappedRoundedHole.shrinkRadii(shadowSpread);
2487             } else
2488                 context.clip(pixelSnappedBorderRect.rect());
2489 
<span class="line-modified">2490             LayoutUnit xOffset = 2 * paintRect.width() + std::max&lt;LayoutUnit&gt;(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + LayoutUnit(1);</span>
<span class="line-added">2491             LayoutSize extraOffset(xOffset.ceil(), 0);</span>
<span class="line-added">2492 </span>
2493             context.translate(extraOffset);
2494             shadowOffset -= extraOffset;
2495 
2496             if (shadow-&gt;isWebkitBoxShadow())
2497                 context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
2498             else
2499                 context.setShadow(shadowOffset, shadowRadius, shadowColor);
2500 
<span class="line-modified">2501             context.fillRectWithRoundedHole(enclosingIntRect(pixelSnappedOuterRect), pixelSnappedRoundedHole, fillColor); // todo tav IntRect is required as first param</span>
2502         }
2503     }
2504 }
2505 
2506 LayoutUnit RenderBoxModelObject::containingBlockLogicalWidthForContent() const
2507 {
2508     if (auto* containingBlock = this-&gt;containingBlock())
2509         return containingBlock-&gt;availableLogicalWidth();
2510     return { };
2511 }
2512 
2513 RenderBoxModelObject* RenderBoxModelObject::continuation() const
2514 {
2515     if (!hasContinuationChainNode())
2516         return nullptr;
2517 
2518     auto&amp; continuationChainNode = *continuationChainNodeMap().get(this);
2519     if (!continuationChainNode.next)
2520         return nullptr;
2521     return continuationChainNode.next-&gt;renderer.get();
</pre>
<hr />
<pre>
2678     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint());
2679 
2680     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
2681     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
2682         TransformationMatrix t;
2683         getTransformFromContainer(container, containerOffset, t);
2684         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2685     } else
2686         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2687 }
2688 
2689 bool RenderBoxModelObject::hasRunningAcceleratedAnimations() const
2690 {
2691     if (auto* node = element()) {
2692         if (auto* timeline = node-&gt;document().existingTimeline())
2693             return timeline-&gt;runningAnimationsForElementAreAllAccelerated(*node);
2694     }
2695     return false;
2696 }
2697 
<span class="line-added">2698 void RenderBoxModelObject::collectAbsoluteQuadsForContinuation(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const</span>
<span class="line-added">2699 {</span>
<span class="line-added">2700     ASSERT(continuation());</span>
<span class="line-added">2701     for (auto* nextInContinuation = this-&gt;continuation(); nextInContinuation; nextInContinuation = nextInContinuation-&gt;continuation()) {</span>
<span class="line-added">2702         if (is&lt;RenderBlock&gt;(*nextInContinuation)) {</span>
<span class="line-added">2703             auto&amp; blockBox = downcast&lt;RenderBlock&gt;(*nextInContinuation);</span>
<span class="line-added">2704             // For blocks inside inlines, we include margins so that we run right up to the inline boxes</span>
<span class="line-added">2705             // above and below us (thus getting merged with them to form a single irregular shape).</span>
<span class="line-added">2706             auto logicalRect = FloatRect { 0, -blockBox.collapsedMarginBefore(), blockBox.width(),</span>
<span class="line-added">2707                 blockBox.height() + blockBox.collapsedMarginBefore() + blockBox.collapsedMarginAfter() };</span>
<span class="line-added">2708             nextInContinuation-&gt;absoluteQuadsIgnoringContinuation(logicalRect, quads, wasFixed);</span>
<span class="line-added">2709             continue;</span>
<span class="line-added">2710         }</span>
<span class="line-added">2711         nextInContinuation-&gt;absoluteQuadsIgnoringContinuation({ }, quads, wasFixed);</span>
<span class="line-added">2712     }</span>
<span class="line-added">2713 }</span>
<span class="line-added">2714 </span>
2715 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="RenderBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSWindowProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSWebAnimationCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSWindowProxy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSWindowProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;JSWindowProxy.h&quot;
 31 
 32 #include &quot;AbstractFrame.h&quot;
 33 #include &quot;CommonVM.h&quot;
 34 #include &quot;GCController.h&quot;
 35 #include &quot;JSDOMWindow.h&quot;
 36 #include &quot;JSDOMWindowProperties.h&quot;
 37 #include &quot;JSEventTarget.h&quot;
 38 #include &quot;JSRemoteDOMWindow.h&quot;
 39 #include &quot;ScriptController.h&quot;

 40 #include &lt;JavaScriptCore/Debugger.h&gt;
 41 #include &lt;JavaScriptCore/JSObject.h&gt;
 42 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 43 
 44 namespace WebCore {

 45 
 46 using namespace JSC;
 47 
 48 const ClassInfo JSWindowProxy::s_info = { &quot;JSWindowProxy&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWindowProxy) };
 49 
 50 inline JSWindowProxy::JSWindowProxy(VM&amp; vm, Structure&amp; structure, DOMWrapperWorld&amp; world)
 51     : Base(vm, &amp;structure)
 52     , m_world(world)
 53 {
 54 }
 55 
 56 void JSWindowProxy::finishCreation(VM&amp; vm, AbstractDOMWindow&amp; window)
 57 {
 58     Base::finishCreation(vm);
 59     ASSERT(inherits(vm, info()));
 60     setWindow(window);
 61 }
 62 
 63 JSWindowProxy&amp; JSWindowProxy::create(VM&amp; vm, AbstractDOMWindow&amp; window, DOMWrapperWorld&amp; world)
 64 {
 65     auto&amp; structure = *Structure::create(vm, 0, jsNull(), TypeInfo(PureForwardingProxyType, StructureFlags), info());
 66     auto&amp; proxy = *new (NotNull, allocateCell&lt;JSWindowProxy&gt;(vm.heap)) JSWindowProxy(vm, structure, world);
 67     proxy.finishCreation(vm, window);
 68     return proxy;
 69 }
 70 
 71 void JSWindowProxy::destroy(JSCell* cell)
 72 {
 73     static_cast&lt;JSWindowProxy*&gt;(cell)-&gt;JSWindowProxy::~JSWindowProxy();
 74 }
 75 
 76 void JSWindowProxy::setWindow(VM&amp; vm, JSDOMGlobalObject&amp; window)
 77 {
<span class="line-modified"> 78     ASSERT(window.classInfo() == JSDOMWindow::info() || window.classInfo() == JSRemoteDOMWindow::info());</span>
 79     setTarget(vm, &amp;window);
 80     structure(vm)-&gt;setGlobalObject(vm, &amp;window);
 81     GCController::singleton().garbageCollectSoon();
 82 }
 83 
 84 void JSWindowProxy::setWindow(AbstractDOMWindow&amp; domWindow)
 85 {
 86     // Replacing JSDOMWindow via telling JSWindowProxy to use the same DOMWindow it already uses makes no sense,
 87     // so we&#39;d better never try to.
 88     ASSERT(!window() || &amp;domWindow != &amp;wrapped());
 89 
 90     bool isRemoteDOMWindow = is&lt;RemoteDOMWindow&gt;(domWindow);
 91 
 92     VM&amp; vm = commonVM();
 93     auto&amp; prototypeStructure = isRemoteDOMWindow ? *JSRemoteDOMWindowPrototype::createStructure(vm, nullptr, jsNull()) : *JSDOMWindowPrototype::createStructure(vm, nullptr, jsNull());
 94 
 95     // Explicitly protect the prototype so it isn&#39;t collected when we allocate the global object.
 96     // (Once the global object is fully constructed, it will mark its own prototype.)
 97     // FIXME: Why do we need to protect this when there&#39;s a pointer to it on the stack?
 98     // Perhaps the issue is that structure objects aren&#39;t seen when scanning the stack?
</pre>
<hr />
<pre>
128 
129 void JSWindowProxy::attachDebugger(JSC::Debugger* debugger)
130 {
131     auto* globalObject = window();
132     JSLockHolder lock(globalObject-&gt;vm());
133 
134     if (debugger)
135         debugger-&gt;attach(globalObject);
136     else if (auto* currentDebugger = globalObject-&gt;debugger())
137         currentDebugger-&gt;detach(globalObject, JSC::Debugger::TerminatingDebuggingSession);
138 }
139 
140 AbstractDOMWindow&amp; JSWindowProxy::wrapped() const
141 {
142     auto* window = this-&gt;window();
143     if (auto* jsWindow = jsDynamicCast&lt;JSRemoteDOMWindowBase*&gt;(window-&gt;vm(), window))
144         return jsWindow-&gt;wrapped();
145     return jsCast&lt;JSDOMWindowBase*&gt;(window)-&gt;wrapped();
146 }
147 
<span class="line-modified">148 JSValue toJS(ExecState* state, WindowProxy&amp; windowProxy)</span>
149 {
<span class="line-modified">150     auto* jsWindowProxy = windowProxy.jsWindowProxy(currentWorld(*state));</span>
151     return jsWindowProxy ? JSValue(jsWindowProxy) : jsNull();
152 }
153 
154 JSWindowProxy* toJSWindowProxy(WindowProxy&amp; windowProxy, DOMWrapperWorld&amp; world)
155 {
156     return windowProxy.jsWindowProxy(world);
157 }
158 
159 WindowProxy* JSWindowProxy::toWrapped(VM&amp; vm, JSValue value)
160 {
161     if (!value.isObject())
162         return nullptr;
163     JSObject* object = asObject(value);
164     if (object-&gt;inherits&lt;JSWindowProxy&gt;(vm))
165         return jsCast&lt;JSWindowProxy*&gt;(object)-&gt;windowProxy();
166     return nullptr;
167 }
168 





169 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;JSWindowProxy.h&quot;
 31 
 32 #include &quot;AbstractFrame.h&quot;
 33 #include &quot;CommonVM.h&quot;
 34 #include &quot;GCController.h&quot;
 35 #include &quot;JSDOMWindow.h&quot;
 36 #include &quot;JSDOMWindowProperties.h&quot;
 37 #include &quot;JSEventTarget.h&quot;
 38 #include &quot;JSRemoteDOMWindow.h&quot;
 39 #include &quot;ScriptController.h&quot;
<span class="line-added"> 40 #include &quot;WebCoreJSClientData.h&quot;</span>
 41 #include &lt;JavaScriptCore/Debugger.h&gt;
 42 #include &lt;JavaScriptCore/JSObject.h&gt;
 43 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 44 
 45 namespace WebCore {
<span class="line-added"> 46 using namespace JSC;</span>
 47 
 48 using namespace JSC;
 49 
 50 const ClassInfo JSWindowProxy::s_info = { &quot;JSWindowProxy&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWindowProxy) };
 51 
 52 inline JSWindowProxy::JSWindowProxy(VM&amp; vm, Structure&amp; structure, DOMWrapperWorld&amp; world)
 53     : Base(vm, &amp;structure)
 54     , m_world(world)
 55 {
 56 }
 57 
 58 void JSWindowProxy::finishCreation(VM&amp; vm, AbstractDOMWindow&amp; window)
 59 {
 60     Base::finishCreation(vm);
 61     ASSERT(inherits(vm, info()));
 62     setWindow(window);
 63 }
 64 
 65 JSWindowProxy&amp; JSWindowProxy::create(VM&amp; vm, AbstractDOMWindow&amp; window, DOMWrapperWorld&amp; world)
 66 {
 67     auto&amp; structure = *Structure::create(vm, 0, jsNull(), TypeInfo(PureForwardingProxyType, StructureFlags), info());
 68     auto&amp; proxy = *new (NotNull, allocateCell&lt;JSWindowProxy&gt;(vm.heap)) JSWindowProxy(vm, structure, world);
 69     proxy.finishCreation(vm, window);
 70     return proxy;
 71 }
 72 
 73 void JSWindowProxy::destroy(JSCell* cell)
 74 {
 75     static_cast&lt;JSWindowProxy*&gt;(cell)-&gt;JSWindowProxy::~JSWindowProxy();
 76 }
 77 
 78 void JSWindowProxy::setWindow(VM&amp; vm, JSDOMGlobalObject&amp; window)
 79 {
<span class="line-modified"> 80     ASSERT(window.classInfo(vm) == JSDOMWindow::info() || window.classInfo(vm) == JSRemoteDOMWindow::info());</span>
 81     setTarget(vm, &amp;window);
 82     structure(vm)-&gt;setGlobalObject(vm, &amp;window);
 83     GCController::singleton().garbageCollectSoon();
 84 }
 85 
 86 void JSWindowProxy::setWindow(AbstractDOMWindow&amp; domWindow)
 87 {
 88     // Replacing JSDOMWindow via telling JSWindowProxy to use the same DOMWindow it already uses makes no sense,
 89     // so we&#39;d better never try to.
 90     ASSERT(!window() || &amp;domWindow != &amp;wrapped());
 91 
 92     bool isRemoteDOMWindow = is&lt;RemoteDOMWindow&gt;(domWindow);
 93 
 94     VM&amp; vm = commonVM();
 95     auto&amp; prototypeStructure = isRemoteDOMWindow ? *JSRemoteDOMWindowPrototype::createStructure(vm, nullptr, jsNull()) : *JSDOMWindowPrototype::createStructure(vm, nullptr, jsNull());
 96 
 97     // Explicitly protect the prototype so it isn&#39;t collected when we allocate the global object.
 98     // (Once the global object is fully constructed, it will mark its own prototype.)
 99     // FIXME: Why do we need to protect this when there&#39;s a pointer to it on the stack?
100     // Perhaps the issue is that structure objects aren&#39;t seen when scanning the stack?
</pre>
<hr />
<pre>
130 
131 void JSWindowProxy::attachDebugger(JSC::Debugger* debugger)
132 {
133     auto* globalObject = window();
134     JSLockHolder lock(globalObject-&gt;vm());
135 
136     if (debugger)
137         debugger-&gt;attach(globalObject);
138     else if (auto* currentDebugger = globalObject-&gt;debugger())
139         currentDebugger-&gt;detach(globalObject, JSC::Debugger::TerminatingDebuggingSession);
140 }
141 
142 AbstractDOMWindow&amp; JSWindowProxy::wrapped() const
143 {
144     auto* window = this-&gt;window();
145     if (auto* jsWindow = jsDynamicCast&lt;JSRemoteDOMWindowBase*&gt;(window-&gt;vm(), window))
146         return jsWindow-&gt;wrapped();
147     return jsCast&lt;JSDOMWindowBase*&gt;(window)-&gt;wrapped();
148 }
149 
<span class="line-modified">150 JSValue toJS(JSGlobalObject* lexicalGlobalObject, WindowProxy&amp; windowProxy)</span>
151 {
<span class="line-modified">152     auto* jsWindowProxy = windowProxy.jsWindowProxy(currentWorld(*lexicalGlobalObject));</span>
153     return jsWindowProxy ? JSValue(jsWindowProxy) : jsNull();
154 }
155 
156 JSWindowProxy* toJSWindowProxy(WindowProxy&amp; windowProxy, DOMWrapperWorld&amp; world)
157 {
158     return windowProxy.jsWindowProxy(world);
159 }
160 
161 WindowProxy* JSWindowProxy::toWrapped(VM&amp; vm, JSValue value)
162 {
163     if (!value.isObject())
164         return nullptr;
165     JSObject* object = asObject(value);
166     if (object-&gt;inherits&lt;JSWindowProxy&gt;(vm))
167         return jsCast&lt;JSWindowProxy*&gt;(object)-&gt;windowProxy();
168     return nullptr;
169 }
170 
<span class="line-added">171 JSC::IsoSubspace* JSWindowProxy::subspaceForImpl(JSC::VM&amp; vm)</span>
<span class="line-added">172 {</span>
<span class="line-added">173     return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;windowProxySpace();</span>
<span class="line-added">174 }</span>
<span class="line-added">175 </span>
176 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSWebAnimationCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSWindowProxy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMPromiseDeferred.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowBase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,97 ***</span>
   * THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
  #include &quot;ExceptionOr.h&quot;
  #include &quot;JSDOMConvert.h&quot;
  #include &quot;JSDOMGuardedObject.h&quot;
  #include &lt;JavaScriptCore/CatchScope.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/JSPromiseDeferred.h&gt;</span>
  
  namespace WebCore {
  
  class JSDOMWindow;
  
<span class="line-modified">! class DeferredPromise : public DOMGuarded&lt;JSC::JSPromiseDeferred&gt; {</span>
  public:
      enum class Mode {
          ClearPromiseOnResolve,
          RetainPromiseOnResolve
      };
  
<span class="line-modified">!     static RefPtr&lt;DeferredPromise&gt; create(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, Mode mode = Mode::ClearPromiseOnResolve)</span>
      {
<span class="line-modified">!         auto* promiseDeferred = JSC::JSPromiseDeferred::tryCreate(&amp;state, &amp;globalObject);</span>
<span class="line-modified">!         if (!promiseDeferred)</span>
<span class="line-modified">!             return nullptr;</span>
<span class="line-modified">!         return adoptRef(new DeferredPromise(globalObject, *promiseDeferred, mode));</span>
      }
  
<span class="line-modified">!     static Ref&lt;DeferredPromise&gt; create(JSDOMGlobalObject&amp; globalObject, JSC::JSPromiseDeferred&amp; deferred, Mode mode = Mode::ClearPromiseOnResolve)</span>
      {
          return adoptRef(*new DeferredPromise(globalObject, deferred, mode));
      }
  
      template&lt;class IDLType&gt;
      void resolve(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         if (isSuspended())</span>
              return;
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::ExecState* exec = globalObject()-&gt;globalExec();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(exec);</span>
<span class="line-modified">!         resolve(*exec, toJS&lt;IDLType&gt;(*exec, *globalObject(), std::forward&lt;typename IDLType::ParameterType&gt;(value)));</span>
      }
  
      void resolve()
      {
<span class="line-modified">!         if (isSuspended())</span>
              return;
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::ExecState* exec = globalObject()-&gt;globalExec();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(exec);</span>
<span class="line-modified">!         resolve(*exec, JSC::jsUndefined());</span>
      }
  
      template&lt;class IDLType&gt;
      void resolveWithNewlyCreated(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         if (isSuspended())</span>
              return;
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::ExecState* exec = globalObject()-&gt;globalExec();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(exec);</span>
<span class="line-modified">!         resolve(*exec, toJSNewlyCreated&lt;IDLType&gt;(*exec, *globalObject(), std::forward&lt;typename IDLType::ParameterType&gt;(value)));</span>
      }
  
      template&lt;class IDLType&gt;
      void resolveCallbackValueWithNewlyCreated(const Function&lt;typename IDLType::InnerParameterType(ScriptExecutionContext&amp;)&gt;&amp; createValue)
      {
<span class="line-modified">!         if (isSuspended())</span>
              return;
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         auto* exec = globalObject()-&gt;globalExec();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(exec);</span>
<span class="line-modified">!         resolve(*exec, toJSNewlyCreated&lt;IDLType&gt;(*exec, *globalObject(), createValue(*globalObject()-&gt;scriptExecutionContext())));</span>
      }
  
      template&lt;class IDLType&gt;
      void reject(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         if (isSuspended())</span>
              return;
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::ExecState* exec = globalObject()-&gt;globalExec();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(exec);</span>
<span class="line-modified">!         reject(*exec, toJS&lt;IDLType&gt;(*exec, *globalObject(), std::forward&lt;typename IDLType::ParameterType&gt;(value)));</span>
      }
  
      void reject();
      void reject(std::nullptr_t);
      void reject(Exception);
<span class="line-new-header">--- 23,104 ---</span>
   * THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;ExceptionOr.h&quot;
  #include &quot;JSDOMConvert.h&quot;
  #include &quot;JSDOMGuardedObject.h&quot;
<span class="line-added">+ #include &quot;ScriptExecutionContext.h&quot;</span>
  #include &lt;JavaScriptCore/CatchScope.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/JSPromise.h&gt;</span>
  
  namespace WebCore {
  
  class JSDOMWindow;
  
<span class="line-modified">! class DeferredPromise : public DOMGuarded&lt;JSC::JSPromise&gt; {</span>
  public:
      enum class Mode {
          ClearPromiseOnResolve,
          RetainPromiseOnResolve
      };
  
<span class="line-modified">!     static RefPtr&lt;DeferredPromise&gt; create(JSDOMGlobalObject&amp; globalObject, Mode mode = Mode::ClearPromiseOnResolve)</span>
      {
<span class="line-modified">!         JSC::VM&amp; vm = JSC::getVM(&amp;globalObject);</span>
<span class="line-modified">!         auto* promise = JSC::JSPromise::create(vm, globalObject.promiseStructure());</span>
<span class="line-modified">!         ASSERT(promise);</span>
<span class="line-modified">!         return adoptRef(new DeferredPromise(globalObject, *promise, mode));</span>
      }
  
<span class="line-modified">!     static Ref&lt;DeferredPromise&gt; create(JSDOMGlobalObject&amp; globalObject, JSC::JSPromise&amp; deferred, Mode mode = Mode::ClearPromiseOnResolve)</span>
      {
          return adoptRef(*new DeferredPromise(globalObject, deferred, mode));
      }
  
      template&lt;class IDLType&gt;
      void resolve(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         if (shouldIgnoreRequestToFulfill())</span>
              return;
<span class="line-added">+ </span>
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::JSGlobalObject* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!         resolve(*lexicalGlobalObject, toJS&lt;IDLType&gt;(*lexicalGlobalObject, *globalObject(), std::forward&lt;typename IDLType::ParameterType&gt;(value)));</span>
      }
  
      void resolve()
      {
<span class="line-modified">!         if (shouldIgnoreRequestToFulfill())</span>
              return;
<span class="line-added">+ </span>
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::JSGlobalObject* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!         resolve(*lexicalGlobalObject, JSC::jsUndefined());</span>
      }
  
      template&lt;class IDLType&gt;
      void resolveWithNewlyCreated(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         if (shouldIgnoreRequestToFulfill())</span>
              return;
<span class="line-added">+ </span>
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::JSGlobalObject* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!         resolve(*lexicalGlobalObject, toJSNewlyCreated&lt;IDLType&gt;(*lexicalGlobalObject, *globalObject(), std::forward&lt;typename IDLType::ParameterType&gt;(value)));</span>
      }
  
      template&lt;class IDLType&gt;
      void resolveCallbackValueWithNewlyCreated(const Function&lt;typename IDLType::InnerParameterType(ScriptExecutionContext&amp;)&gt;&amp; createValue)
      {
<span class="line-modified">!         if (shouldIgnoreRequestToFulfill())</span>
              return;
<span class="line-added">+ </span>
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         auto* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!         resolve(*lexicalGlobalObject, toJSNewlyCreated&lt;IDLType&gt;(*lexicalGlobalObject, *globalObject(), createValue(*globalObject()-&gt;scriptExecutionContext())));</span>
      }
  
      template&lt;class IDLType&gt;
      void reject(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         if (shouldIgnoreRequestToFulfill())</span>
              return;
<span class="line-added">+ </span>
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::JSGlobalObject* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!         reject(*lexicalGlobalObject, toJS&lt;IDLType&gt;(*lexicalGlobalObject, *globalObject(), std::forward&lt;typename IDLType::ParameterType&gt;(value)));</span>
      }
  
      void reject();
      void reject(std::nullptr_t);
      void reject(Exception);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,102 ***</span>
      void reject(const JSC::PrivateName&amp;);
  
      template&lt;typename Callback&gt;
      void resolveWithCallback(Callback callback)
      {
<span class="line-modified">!         if (isSuspended())</span>
              return;
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::ExecState* exec = globalObject()-&gt;globalExec();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(exec);</span>
<span class="line-modified">!         resolve(*exec, callback(*exec, *globalObject()));</span>
      }
  
      template&lt;typename Callback&gt;
      void rejectWithCallback(Callback callback)
      {
<span class="line-modified">!         if (isSuspended())</span>
              return;
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::ExecState* exec = globalObject()-&gt;globalExec();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(exec);</span>
<span class="line-modified">!         reject(*exec, callback(*exec, *globalObject()));</span>
      }
  
      JSC::JSValue promise() const;
  
<span class="line-modified">!     void whenSettled(std::function&lt;void()&gt;&amp;&amp;);</span>
  
  private:
<span class="line-modified">!     DeferredPromise(JSDOMGlobalObject&amp; globalObject, JSC::JSPromiseDeferred&amp; deferred, Mode mode)</span>
<span class="line-modified">!         : DOMGuarded&lt;JSC::JSPromiseDeferred&gt;(globalObject, deferred)</span>
          , m_mode(mode)
      {
      }
  
<span class="line-modified">!     JSC::JSPromiseDeferred* deferred() const { return guarded(); }</span>
  
<span class="line-modified">!     WEBCORE_EXPORT void callFunction(JSC::ExecState&amp;, JSC::JSValue function, JSC::JSValue resolution);</span>
  
<span class="line-modified">!     void resolve(JSC::ExecState&amp; state, JSC::JSValue resolution) { callFunction(state, deferred()-&gt;resolve(), resolution); }</span>
<span class="line-modified">!     void reject(JSC::ExecState&amp; state, JSC::JSValue resolution) { callFunction(state, deferred()-&gt;reject(), resolution); }</span>
  
      Mode m_mode;
  };
  
  class DOMPromiseDeferredBase {
  public:
      DOMPromiseDeferredBase(Ref&lt;DeferredPromise&gt;&amp;&amp; genericPromise)
<span class="line-modified">!         : m_promiseDeferred(WTFMove(genericPromise))</span>
      {
      }
  
      DOMPromiseDeferredBase(DOMPromiseDeferredBase&amp;&amp; promise)
<span class="line-modified">!         : m_promiseDeferred(WTFMove(promise.m_promiseDeferred))</span>
      {
      }
  
      DOMPromiseDeferredBase(const DOMPromiseDeferredBase&amp; other)
<span class="line-modified">!         : m_promiseDeferred(other.m_promiseDeferred.copyRef())</span>
      {
      }
  
      DOMPromiseDeferredBase&amp; operator=(const DOMPromiseDeferredBase&amp; other)
      {
<span class="line-modified">!         m_promiseDeferred = other.m_promiseDeferred.copyRef();</span>
          return *this;
      }
  
      DOMPromiseDeferredBase&amp; operator=(DOMPromiseDeferredBase&amp;&amp; other)
      {
<span class="line-modified">!         m_promiseDeferred = WTFMove(other.m_promiseDeferred);</span>
          return *this;
      }
  
      void reject()
      {
<span class="line-modified">!         m_promiseDeferred-&gt;reject();</span>
      }
  
      template&lt;typename... ErrorType&gt;
      void reject(ErrorType&amp;&amp;... error)
      {
<span class="line-modified">!         m_promiseDeferred-&gt;reject(std::forward&lt;ErrorType&gt;(error)...);</span>
      }
  
      template&lt;typename IDLType&gt;
      void rejectType(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         m_promiseDeferred-&gt;reject&lt;IDLType&gt;(std::forward&lt;typename IDLType::ParameterType&gt;(value));</span>
      }
  
<span class="line-modified">!     JSC::JSValue promise() const { return m_promiseDeferred-&gt;promise(); };</span>
  
  protected:
<span class="line-modified">!     Ref&lt;DeferredPromise&gt; m_promiseDeferred;</span>
  };
  
  template&lt;typename IDLType&gt;
  class DOMPromiseDeferred : public DOMPromiseDeferredBase {
  public:
<span class="line-new-header">--- 128,113 ---</span>
      void reject(const JSC::PrivateName&amp;);
  
      template&lt;typename Callback&gt;
      void resolveWithCallback(Callback callback)
      {
<span class="line-modified">!         if (shouldIgnoreRequestToFulfill())</span>
              return;
<span class="line-added">+ </span>
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::JSGlobalObject* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!         resolve(*lexicalGlobalObject, callback(*globalObject()));</span>
      }
  
      template&lt;typename Callback&gt;
      void rejectWithCallback(Callback callback)
      {
<span class="line-modified">!         if (shouldIgnoreRequestToFulfill())</span>
              return;
<span class="line-added">+ </span>
          ASSERT(deferred());
          ASSERT(globalObject());
<span class="line-modified">!         JSC::JSGlobalObject* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!         JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!         reject(*lexicalGlobalObject, callback(*globalObject()));</span>
      }
  
      JSC::JSValue promise() const;
  
<span class="line-modified">!     void whenSettled(Function&lt;void()&gt;&amp;&amp;);</span>
  
  private:
<span class="line-modified">!     DeferredPromise(JSDOMGlobalObject&amp; globalObject, JSC::JSPromise&amp; deferred, Mode mode)</span>
<span class="line-modified">!         : DOMGuarded&lt;JSC::JSPromise&gt;(globalObject, deferred)</span>
          , m_mode(mode)
      {
      }
  
<span class="line-modified">!     bool shouldIgnoreRequestToFulfill() const { return isEmpty() || activeDOMObjectAreStopped(); }</span>
  
<span class="line-modified">!     JSC::JSPromise* deferred() const { return guarded(); }</span>
  
<span class="line-modified">!     enum class ResolveMode { Resolve, Reject };</span>
<span class="line-modified">!     WEBCORE_EXPORT void callFunction(JSC::JSGlobalObject&amp;, ResolveMode, JSC::JSValue resolution);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void resolve(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue resolution) { callFunction(lexicalGlobalObject, ResolveMode::Resolve, resolution); }</span>
<span class="line-added">+     void reject(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue resolution) { callFunction(lexicalGlobalObject, ResolveMode::Reject, resolution); }</span>
  
      Mode m_mode;
  };
  
  class DOMPromiseDeferredBase {
<span class="line-added">+     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
      DOMPromiseDeferredBase(Ref&lt;DeferredPromise&gt;&amp;&amp; genericPromise)
<span class="line-modified">!         : m_promise(WTFMove(genericPromise))</span>
      {
      }
  
      DOMPromiseDeferredBase(DOMPromiseDeferredBase&amp;&amp; promise)
<span class="line-modified">!         : m_promise(WTFMove(promise.m_promise))</span>
      {
      }
  
      DOMPromiseDeferredBase(const DOMPromiseDeferredBase&amp; other)
<span class="line-modified">!         : m_promise(other.m_promise.copyRef())</span>
      {
      }
  
      DOMPromiseDeferredBase&amp; operator=(const DOMPromiseDeferredBase&amp; other)
      {
<span class="line-modified">!         m_promise = other.m_promise.copyRef();</span>
          return *this;
      }
  
      DOMPromiseDeferredBase&amp; operator=(DOMPromiseDeferredBase&amp;&amp; other)
      {
<span class="line-modified">!         m_promise = WTFMove(other.m_promise);</span>
          return *this;
      }
  
      void reject()
      {
<span class="line-modified">!         m_promise-&gt;reject();</span>
      }
  
      template&lt;typename... ErrorType&gt;
      void reject(ErrorType&amp;&amp;... error)
      {
<span class="line-modified">!         m_promise-&gt;reject(std::forward&lt;ErrorType&gt;(error)...);</span>
      }
  
      template&lt;typename IDLType&gt;
      void rejectType(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         m_promise-&gt;reject&lt;IDLType&gt;(std::forward&lt;typename IDLType::ParameterType&gt;(value));</span>
      }
  
<span class="line-modified">!     JSC::JSValue promise() const { return m_promise-&gt;promise(); };</span>
<span class="line-added">+ </span>
<span class="line-added">+     void whenSettled(Function&lt;void()&gt;&amp;&amp; function)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_promise-&gt;whenSettled(WTFMove(function));</span>
<span class="line-added">+     }</span>
  
  protected:
<span class="line-modified">!     Ref&lt;DeferredPromise&gt; m_promise;</span>
  };
  
  template&lt;typename IDLType&gt;
  class DOMPromiseDeferred : public DOMPromiseDeferredBase {
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,11 ***</span>
      using DOMPromiseDeferredBase::promise;
      using DOMPromiseDeferredBase::reject;
  
      void resolve(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         m_promiseDeferred-&gt;resolve&lt;IDLType&gt;(std::forward&lt;typename IDLType::ParameterType&gt;(value));</span>
      }
  
      void settle(ExceptionOr&lt;typename IDLType::ParameterType&gt;&amp;&amp; result)
      {
          if (result.hasException()) {
<span class="line-new-header">--- 243,11 ---</span>
      using DOMPromiseDeferredBase::promise;
      using DOMPromiseDeferredBase::reject;
  
      void resolve(typename IDLType::ParameterType value)
      {
<span class="line-modified">!         m_promise-&gt;resolve&lt;IDLType&gt;(std::forward&lt;typename IDLType::ParameterType&gt;(value));</span>
      }
  
      void settle(ExceptionOr&lt;typename IDLType::ParameterType&gt;&amp;&amp; result)
      {
          if (result.hasException()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,11 ***</span>
      using DOMPromiseDeferredBase::promise;
      using DOMPromiseDeferredBase::reject;
  
      void resolve()
      {
<span class="line-modified">!         m_promiseDeferred-&gt;resolve();</span>
      }
  
      void settle(ExceptionOr&lt;void&gt;&amp;&amp; result)
      {
          if (result.hasException()) {
<span class="line-new-header">--- 265,11 ---</span>
      using DOMPromiseDeferredBase::promise;
      using DOMPromiseDeferredBase::reject;
  
      void resolve()
      {
<span class="line-modified">!         m_promise-&gt;resolve();</span>
      }
  
      void settle(ExceptionOr&lt;void&gt;&amp;&amp; result)
      {
          if (result.hasException()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,73 ***</span>
          resolve();
      }
  };
  
  
<span class="line-modified">! Ref&lt;DeferredPromise&gt; createDeferredPromise(JSC::ExecState&amp;, JSDOMWindow&amp;);</span>
  
  void fulfillPromiseWithJSON(Ref&lt;DeferredPromise&gt;&amp;&amp;, const String&amp;);
  void fulfillPromiseWithArrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp;, ArrayBuffer*);
  void fulfillPromiseWithArrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp;, const void*, size_t);
<span class="line-modified">! WEBCORE_EXPORT void rejectPromiseWithExceptionIfAny(JSC::ExecState&amp;, JSDOMGlobalObject&amp;, JSC::JSPromiseDeferred&amp;);</span>
  
  enum class RejectedPromiseWithTypeErrorCause { NativeGetter, InvalidThis };
<span class="line-modified">! JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::ExecState&amp;, const String&amp;, RejectedPromiseWithTypeErrorCause);</span>
  
<span class="line-modified">! using PromiseFunction = void(JSC::ExecState&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp;);</span>
  
<span class="line-modified">! enum class PromiseExecutionScope { WindowOnly, WindowOrWorker };</span>
<span class="line-modified">! </span>
<span class="line-removed">- template&lt;PromiseFunction promiseFunction, PromiseExecutionScope executionScope&gt;</span>
<span class="line-removed">- inline JSC::JSValue callPromiseFunction(JSC::ExecState&amp; state)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     auto&amp; globalObject = callerGlobalObject(state);</span>
<span class="line-modified">!     JSC::JSPromiseDeferred* promiseDeferred = JSC::JSPromiseDeferred::tryCreate(&amp;state, &amp;globalObject);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     // promiseDeferred can be null when terminating a Worker abruptly.</span>
<span class="line-removed">-     if (executionScope == PromiseExecutionScope::WindowOrWorker &amp;&amp; !promiseDeferred)</span>
<span class="line-removed">-         return JSC::jsUndefined();</span>
  
<span class="line-modified">!     promiseFunction(state, DeferredPromise::create(globalObject, *promiseDeferred));</span>
  
<span class="line-modified">!     rejectPromiseWithExceptionIfAny(state, globalObject, *promiseDeferred);</span>
<span class="line-modified">!     EXCEPTION_ASSERT_UNUSED(scope, !scope.exception());</span>
<span class="line-modified">!     return promiseDeferred-&gt;promise();</span>
  }
  
<span class="line-modified">! template&lt;PromiseExecutionScope executionScope, typename PromiseFunctor&gt;</span>
<span class="line-modified">! inline JSC::JSValue callPromiseFunction(JSC::ExecState&amp; state, PromiseFunctor functor)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     auto&amp; globalObject = callerGlobalObject(state);</span>
<span class="line-modified">!     JSC::JSPromiseDeferred* promiseDeferred = JSC::JSPromiseDeferred::tryCreate(&amp;state, &amp;globalObject);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     // promiseDeferred can be null when terminating a Worker abruptly.</span>
<span class="line-removed">-     if (executionScope == PromiseExecutionScope::WindowOrWorker &amp;&amp; !promiseDeferred)</span>
<span class="line-removed">-         return JSC::jsUndefined();</span>
  
<span class="line-modified">!     functor(state, DeferredPromise::create(globalObject, *promiseDeferred));</span>
  
<span class="line-modified">!     rejectPromiseWithExceptionIfAny(state, globalObject, *promiseDeferred);</span>
<span class="line-modified">!     EXCEPTION_ASSERT_UNUSED(scope, !scope.exception());</span>
<span class="line-modified">!     return promiseDeferred-&gt;promise();</span>
  }
  
<span class="line-modified">! using BindingPromiseFunction = JSC::EncodedJSValue(JSC::ExecState*, Ref&lt;DeferredPromise&gt;&amp;&amp;);</span>
  template&lt;BindingPromiseFunction bindingFunction&gt;
<span class="line-modified">! inline void bindingPromiseFunctionAdapter(JSC::ExecState&amp; state, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
<span class="line-modified">!     bindingFunction(&amp;state, WTFMove(promise));</span>
  }
  
<span class="line-modified">! template&lt;BindingPromiseFunction bindingPromiseFunction, PromiseExecutionScope executionScope&gt;</span>
<span class="line-modified">! inline JSC::JSValue callPromiseFunction(JSC::ExecState&amp; state)</span>
  {
<span class="line-modified">!     return callPromiseFunction&lt;bindingPromiseFunctionAdapter&lt;bindingPromiseFunction&gt;, executionScope&gt;(state);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 279,69 ---</span>
          resolve();
      }
  };
  
  
<span class="line-modified">! Ref&lt;DeferredPromise&gt; createDeferredPromise(JSC::JSGlobalObject&amp;, JSDOMWindow&amp;);</span>
  
  void fulfillPromiseWithJSON(Ref&lt;DeferredPromise&gt;&amp;&amp;, const String&amp;);
  void fulfillPromiseWithArrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp;, ArrayBuffer*);
  void fulfillPromiseWithArrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp;, const void*, size_t);
<span class="line-modified">! WEBCORE_EXPORT void rejectPromiseWithExceptionIfAny(JSC::JSGlobalObject&amp;, JSDOMGlobalObject&amp;, JSC::JSPromise&amp;);</span>
  
  enum class RejectedPromiseWithTypeErrorCause { NativeGetter, InvalidThis };
<span class="line-modified">! JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::JSGlobalObject&amp;, const String&amp;, RejectedPromiseWithTypeErrorCause);</span>
  
<span class="line-modified">! using PromiseFunction = void(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp;);</span>
  
<span class="line-modified">! template&lt;PromiseFunction promiseFunction&gt;</span>
<span class="line-modified">! inline JSC::JSValue callPromiseFunction(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     auto&amp; globalObject = callerGlobalObject(lexicalGlobalObject, callFrame);</span>
<span class="line-modified">!     auto* promise = JSC::JSPromise::create(vm, globalObject.promiseStructure());</span>
<span class="line-modified">!     ASSERT(promise);</span>
  
<span class="line-modified">!     promiseFunction(lexicalGlobalObject, callFrame, DeferredPromise::create(globalObject, *promise));</span>
  
<span class="line-modified">!     rejectPromiseWithExceptionIfAny(lexicalGlobalObject, globalObject, *promise);</span>
<span class="line-modified">!     // FIXME: We could have error since any JS call can throw stack-overflow errors.</span>
<span class="line-modified">!     // https://bugs.webkit.org/show_bug.cgi?id=203402</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, JSC::jsUndefined());</span>
<span class="line-added">+     return promise;</span>
  }
  
<span class="line-modified">! template&lt;typename PromiseFunctor&gt;</span>
<span class="line-modified">! inline JSC::JSValue callPromiseFunction(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, PromiseFunctor functor)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     auto&amp; globalObject = callerGlobalObject(lexicalGlobalObject, callFrame);</span>
<span class="line-modified">!     auto* promise = JSC::JSPromise::create(vm, globalObject.promiseStructure());</span>
<span class="line-modified">!     ASSERT(promise);</span>
  
<span class="line-modified">!     functor(lexicalGlobalObject, callFrame, DeferredPromise::create(globalObject, *promise));</span>
  
<span class="line-modified">!     rejectPromiseWithExceptionIfAny(lexicalGlobalObject, globalObject, *promise);</span>
<span class="line-modified">!     // FIXME: We could have error since any JS call can throw stack-overflow errors.</span>
<span class="line-modified">!     // https://bugs.webkit.org/show_bug.cgi?id=203402</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, JSC::jsUndefined());</span>
<span class="line-added">+     return promise;</span>
  }
  
<span class="line-modified">! using BindingPromiseFunction = JSC::EncodedJSValue(JSC::JSGlobalObject*, JSC::CallFrame*, Ref&lt;DeferredPromise&gt;&amp;&amp;);</span>
  template&lt;BindingPromiseFunction bindingFunction&gt;
<span class="line-modified">! inline void bindingPromiseFunctionAdapter(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
<span class="line-modified">!     bindingFunction(&amp;lexicalGlobalObject, &amp;callFrame, WTFMove(promise));</span>
  }
  
<span class="line-modified">! template&lt;BindingPromiseFunction bindingPromiseFunction&gt;</span>
<span class="line-modified">! inline JSC::JSValue callPromiseFunction(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     return callPromiseFunction&lt;bindingPromiseFunctionAdapter&lt;bindingPromiseFunction&gt;&gt;(lexicalGlobalObject, callFrame);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="JSDOMPromiseDeferred.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowBase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
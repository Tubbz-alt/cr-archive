<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITCall.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITCode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &quot;CodeBlock.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;JITInlines.h&quot;
 35 #include &quot;JSArray.h&quot;
 36 #include &quot;JSFunction.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;LinkBuffer.h&quot;
 39 #include &quot;OpcodeInlines.h&quot;
 40 #include &quot;ResultType.h&quot;
 41 #include &quot;SetupVarargsFrame.h&quot;
 42 #include &quot;StackAlignment.h&quot;
 43 #include &quot;ThunkGenerators.h&quot;
 44 #include &lt;wtf/StringPrintStream.h&gt;
 45 
 46 namespace JSC {
 47 
 48 template&lt;typename Op&gt;
 49 void JIT::emitPutCallResult(const Op&amp; bytecode)
 50 {
 51     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-modified"> 52     emitStore(bytecode.m_dst.offset(), regT1, regT0);</span>
 53 }
 54 
 55 void JIT::emit_op_ret(const Instruction* currentInstruction)
 56 {
 57     auto bytecode = currentInstruction-&gt;as&lt;OpRet&gt;();
<span class="line-modified"> 58     int value = bytecode.m_value.offset();</span>
 59 
 60     emitLoad(value, regT1, regT0);
 61 
 62     checkStackPointerAlignment();
 63     emitRestoreCalleeSaves();
 64     emitFunctionEpilogue();
 65     ret();
 66 }
 67 
 68 void JIT::emitSlow_op_call(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 69 {
 70     compileOpCallSlowCase&lt;OpCall&gt;(currentInstruction, iter, m_callLinkInfoIndex++);
 71 }
 72 
 73 void JIT::emitSlow_op_tail_call(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 74 {
 75     compileOpCallSlowCase&lt;OpTailCall&gt;(currentInstruction, iter, m_callLinkInfoIndex++);
 76 }
 77 
 78 void JIT::emitSlow_op_call_eval(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
</pre>
<hr />
<pre>
140     compileOpCall&lt;OpConstructVarargs&gt;(currentInstruction, m_callLinkInfoIndex++);
141 }
142 
143 void JIT::emit_op_construct(const Instruction* currentInstruction)
144 {
145     compileOpCall&lt;OpConstruct&gt;(currentInstruction, m_callLinkInfoIndex++);
146 }
147 
148 template &lt;typename Op&gt;
149 std::enable_if_t&lt;
150     Op::opcodeID != op_call_varargs &amp;&amp; Op::opcodeID != op_construct_varargs
151     &amp;&amp; Op::opcodeID != op_tail_call_varargs &amp;&amp; Op::opcodeID != op_tail_call_forward_arguments
152 , void&gt;
153 JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo*)
154 {
155     auto&amp; metadata = bytecode.metadata(m_codeBlock);
156     int argCount = bytecode.m_argc;
157     int registerOffset = -static_cast&lt;int&gt;(bytecode.m_argv);
158 
159     if (Op::opcodeID == op_call &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">160         emitLoad(registerOffset + CallFrame::argumentOffsetIncludingThis(0), regT0, regT1);</span>
161         Jump done = branchIfNotCell(regT0);
162         load32(Address(regT1, JSCell::structureIDOffset()), regT1);
163         store32(regT1, metadata.m_callLinkInfo.m_arrayProfile.addressOfLastSeenStructureID());
164         done.link(this);
165     }
166 
167     addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
<span class="line-modified">168     store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));</span>
169 }
170 
171 template&lt;typename Op&gt;
172 std::enable_if_t&lt;
173     Op::opcodeID == op_call_varargs || Op::opcodeID == op_construct_varargs
174     || Op::opcodeID == op_tail_call_varargs || Op::opcodeID == op_tail_call_forward_arguments
175 , void&gt;
176 JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo* info)
177 {
178     OpcodeID opcodeID = Op::opcodeID;
<span class="line-modified">179     int thisValue = bytecode.m_thisValue.offset();</span>
<span class="line-modified">180     int arguments = bytecode.m_arguments.offset();</span>
181     int firstFreeRegister = bytecode.m_firstFree.offset();
182     int firstVarArgOffset = bytecode.m_firstVarArg;
183 
184     emitLoad(arguments, regT1, regT0);
<span class="line-modified">185     Z_JITOperation_EJZZ sizeOperation;</span>
186     if (Op::opcodeID == op_tail_call_forward_arguments)
187         sizeOperation = operationSizeFrameForForwardArguments;
188     else
189         sizeOperation = operationSizeFrameForVarargs;
<span class="line-modified">190     callOperation(sizeOperation, JSValueRegs(regT1, regT0), -firstFreeRegister, firstVarArgOffset);</span>
191     move(TrustedImm32(-firstFreeRegister), regT1);
192     emitSetVarargsFrame(*this, returnValueGPR, false, regT1, regT1);
193     addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), regT1, stackPointerRegister);
194     emitLoad(arguments, regT2, regT4);
<span class="line-modified">195     F_JITOperation_EFJZZ setupOperation;</span>
196     if (opcodeID == op_tail_call_forward_arguments)
197         setupOperation = operationSetupForwardArgumentsFrame;
198     else
199         setupOperation = operationSetupVarargsFrame;
<span class="line-modified">200     callOperation(setupOperation, regT1, JSValueRegs(regT2, regT4), firstVarArgOffset, regT0);</span>
201     move(returnValueGPR, regT1);
202 
203     // Profile the argument count.
<span class="line-modified">204     load32(Address(regT1, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), regT2);</span>
<span class="line-modified">205     load32(info-&gt;addressOfMaxNumArguments(), regT0);</span>
206     Jump notBiggest = branch32(Above, regT0, regT2);
<span class="line-modified">207     store32(regT2, info-&gt;addressOfMaxNumArguments());</span>
208     notBiggest.link(this);
209 
210     // Initialize &#39;this&#39;.
211     emitLoad(thisValue, regT2, regT0);
212     store32(regT0, Address(regT1, PayloadOffset + (CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register)))));
213     store32(regT2, Address(regT1, TagOffset + (CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register)))));
214 
215     addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), regT1, stackPointerRegister);
216 }
217 
218 template&lt;typename Op&gt;
219 bool JIT::compileCallEval(const Op&amp;)
220 {
221     return false;
222 }
223 
224 template&lt;&gt;
225 bool JIT::compileCallEval(const OpCallEval&amp; bytecode)
226 {
227     addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), stackPointerRegister, regT1);
228     storePtr(callFrameRegister, Address(regT1, CallFrame::callerFrameOffset()));
229 
230     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
231 
<span class="line-modified">232     callOperation(operationCallEval, regT1);</span>
233 
234     addSlowCase(branchIfEmpty(regT1));
235 
236     sampleCodeBlock(m_codeBlock);
237 
238     emitPutCallResult(bytecode);
239 
240     return true;
241 }
242 
243 void JIT::compileCallEvalSlowCase(const Instruction* instruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
244 {
245     linkAllSlowCases(iter);
246 
247     auto bytecode = instruction-&gt;as&lt;OpCallEval&gt;();
248     CallLinkInfo* info = m_codeBlock-&gt;addCallLinkInfo();
<span class="line-modified">249     info-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeOffset), regT0);</span>
250 
251     int registerOffset = -bytecode.m_argv;
<span class="line-modified">252     int callee = bytecode.m_callee.offset();</span>
253 
254     addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
255 
256     emitLoad(callee, regT1, regT0);
<span class="line-modified">257     emitDumbVirtualCall(vm(), info);</span>
258     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
259     checkStackPointerAlignment();
260 
261     sampleCodeBlock(m_codeBlock);
262 
263     emitPutCallResult(bytecode);
264 }
265 
266 template &lt;typename Op&gt;
267 void JIT::compileOpCall(const Instruction* instruction, unsigned callLinkInfoIndex)
268 {
269     OpcodeID opcodeID = Op::opcodeID;
270     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">271     int callee = bytecode.m_callee.offset();</span>
272 
273     /* Caller always:
274         - Updates callFrameRegister to callee callFrame.
275         - Initializes ArgumentCount; CallerFrame; Callee.
276 
277        For a JS call:
278         - Callee initializes ReturnPC; CodeBlock.
279         - Callee restores callFrameRegister before return.
280 
281        For a non-JS call:
282         - Caller initializes ReturnPC; CodeBlock.
283         - Caller restores callFrameRegister after return.
284     */
285     CallLinkInfo* info = nullptr;
286     if (opcodeID != op_call_eval)
287         info = m_codeBlock-&gt;addCallLinkInfo();
288     compileSetupFrame(bytecode, info);
289     // SP holds newCallFrame + sizeof(CallerFrameAndPC), with ArgumentCount initialized.
290 
<span class="line-modified">291     uint32_t locationBits = CallSiteIndex(instruction).bits();</span>
<span class="line-modified">292     store32(TrustedImm32(locationBits), tagFor(CallFrameSlot::argumentCount));</span>

293     emitLoad(callee, regT1, regT0); // regT1, regT0 holds callee.
294 
295     store32(regT0, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));
296     store32(regT1, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + TagOffset - sizeof(CallerFrameAndPC)));
297 
298     if (compileCallEval(bytecode))
299         return;
300 
301     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs)
302         emitRestoreCalleeSaves();
303 
304     addSlowCase(branchIfNotCell(regT1));
305 
306     DataLabelPtr addressOfLinkedFunctionCheck;
307     Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(nullptr));
308 
309     addSlowCase(slowCase);
310 
311     ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
<span class="line-modified">312     info-&gt;setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeOffset), regT0);</span>
313     m_callCompilationInfo.append(CallCompilationInfo());
314     m_callCompilationInfo[callLinkInfoIndex].hotPathBegin = addressOfLinkedFunctionCheck;
315     m_callCompilationInfo[callLinkInfoIndex].callLinkInfo = info;
316 
317     checkStackPointerAlignment();
318     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs || opcodeID == op_tail_call_forward_arguments) {
319         prepareForTailCallSlow();
320         m_callCompilationInfo[callLinkInfoIndex].hotPathOther = emitNakedTailCall();
321         return;
322     }
323 
324     m_callCompilationInfo[callLinkInfoIndex].hotPathOther = emitNakedCall();
325 
326     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
327     checkStackPointerAlignment();
328 
329     sampleCodeBlock(m_codeBlock);
330     emitPutCallResult(bytecode);
331 }
332 
333 template &lt;typename Op&gt;
334 void JIT::compileOpCallSlowCase(const Instruction* instruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter, unsigned callLinkInfoIndex)
335 {
336     OpcodeID opcodeID = Op::opcodeID;
337 
338     if (opcodeID == op_call_eval) {
339         compileCallEvalSlowCase(instruction, iter);
340         return;
341     }
342 
343     linkAllSlowCases(iter);
344 

345     move(TrustedImmPtr(m_callCompilationInfo[callLinkInfoIndex].callLinkInfo), regT2);
346 
347     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs || opcodeID == op_tail_call_forward_arguments)
348         emitRestoreCalleeSaves();
349 
350     m_callCompilationInfo[callLinkInfoIndex].callReturnLocation = emitNakedCall(m_vm-&gt;getCTIStub(linkCallThunkGenerator).retaggedCode&lt;NoPtrTag&gt;());
351 
352     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs) {
353         abortWithReason(JITDidReturnFromTailCall);
354         return;
355     }
356 
357     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
358     checkStackPointerAlignment();
359 
360     sampleCodeBlock(m_codeBlock);
361 
362     auto bytecode = instruction-&gt;as&lt;Op&gt;();
363     emitPutCallResult(bytecode);
364 }
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &quot;CodeBlock.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;JITInlines.h&quot;
 35 #include &quot;JSArray.h&quot;
 36 #include &quot;JSFunction.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;LinkBuffer.h&quot;
 39 #include &quot;OpcodeInlines.h&quot;
 40 #include &quot;ResultType.h&quot;
 41 #include &quot;SetupVarargsFrame.h&quot;
 42 #include &quot;StackAlignment.h&quot;
 43 #include &quot;ThunkGenerators.h&quot;
 44 #include &lt;wtf/StringPrintStream.h&gt;
 45 
 46 namespace JSC {
 47 
 48 template&lt;typename Op&gt;
 49 void JIT::emitPutCallResult(const Op&amp; bytecode)
 50 {
 51     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-modified"> 52     emitStore(bytecode.m_dst, regT1, regT0);</span>
 53 }
 54 
 55 void JIT::emit_op_ret(const Instruction* currentInstruction)
 56 {
 57     auto bytecode = currentInstruction-&gt;as&lt;OpRet&gt;();
<span class="line-modified"> 58     VirtualRegister value = bytecode.m_value;</span>
 59 
 60     emitLoad(value, regT1, regT0);
 61 
 62     checkStackPointerAlignment();
 63     emitRestoreCalleeSaves();
 64     emitFunctionEpilogue();
 65     ret();
 66 }
 67 
 68 void JIT::emitSlow_op_call(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 69 {
 70     compileOpCallSlowCase&lt;OpCall&gt;(currentInstruction, iter, m_callLinkInfoIndex++);
 71 }
 72 
 73 void JIT::emitSlow_op_tail_call(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 74 {
 75     compileOpCallSlowCase&lt;OpTailCall&gt;(currentInstruction, iter, m_callLinkInfoIndex++);
 76 }
 77 
 78 void JIT::emitSlow_op_call_eval(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
</pre>
<hr />
<pre>
140     compileOpCall&lt;OpConstructVarargs&gt;(currentInstruction, m_callLinkInfoIndex++);
141 }
142 
143 void JIT::emit_op_construct(const Instruction* currentInstruction)
144 {
145     compileOpCall&lt;OpConstruct&gt;(currentInstruction, m_callLinkInfoIndex++);
146 }
147 
148 template &lt;typename Op&gt;
149 std::enable_if_t&lt;
150     Op::opcodeID != op_call_varargs &amp;&amp; Op::opcodeID != op_construct_varargs
151     &amp;&amp; Op::opcodeID != op_tail_call_varargs &amp;&amp; Op::opcodeID != op_tail_call_forward_arguments
152 , void&gt;
153 JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo*)
154 {
155     auto&amp; metadata = bytecode.metadata(m_codeBlock);
156     int argCount = bytecode.m_argc;
157     int registerOffset = -static_cast&lt;int&gt;(bytecode.m_argv);
158 
159     if (Op::opcodeID == op_call &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">160         emitLoad(VirtualRegister(registerOffset + CallFrame::argumentOffsetIncludingThis(0)), regT0, regT1);</span>
161         Jump done = branchIfNotCell(regT0);
162         load32(Address(regT1, JSCell::structureIDOffset()), regT1);
163         store32(regT1, metadata.m_callLinkInfo.m_arrayProfile.addressOfLastSeenStructureID());
164         done.link(this);
165     }
166 
167     addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
<span class="line-modified">168     store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));</span>
169 }
170 
171 template&lt;typename Op&gt;
172 std::enable_if_t&lt;
173     Op::opcodeID == op_call_varargs || Op::opcodeID == op_construct_varargs
174     || Op::opcodeID == op_tail_call_varargs || Op::opcodeID == op_tail_call_forward_arguments
175 , void&gt;
176 JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo* info)
177 {
178     OpcodeID opcodeID = Op::opcodeID;
<span class="line-modified">179     VirtualRegister thisValue = bytecode.m_thisValue;</span>
<span class="line-modified">180     VirtualRegister arguments = bytecode.m_arguments;</span>
181     int firstFreeRegister = bytecode.m_firstFree.offset();
182     int firstVarArgOffset = bytecode.m_firstVarArg;
183 
184     emitLoad(arguments, regT1, regT0);
<span class="line-modified">185     Z_JITOperation_GJZZ sizeOperation;</span>
186     if (Op::opcodeID == op_tail_call_forward_arguments)
187         sizeOperation = operationSizeFrameForForwardArguments;
188     else
189         sizeOperation = operationSizeFrameForVarargs;
<span class="line-modified">190     callOperation(sizeOperation, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), -firstFreeRegister, firstVarArgOffset);</span>
191     move(TrustedImm32(-firstFreeRegister), regT1);
192     emitSetVarargsFrame(*this, returnValueGPR, false, regT1, regT1);
193     addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), regT1, stackPointerRegister);
194     emitLoad(arguments, regT2, regT4);
<span class="line-modified">195     F_JITOperation_GFJZZ setupOperation;</span>
196     if (opcodeID == op_tail_call_forward_arguments)
197         setupOperation = operationSetupForwardArgumentsFrame;
198     else
199         setupOperation = operationSetupVarargsFrame;
<span class="line-modified">200     callOperation(setupOperation, m_codeBlock-&gt;globalObject(), regT1, JSValueRegs(regT2, regT4), firstVarArgOffset, regT0);</span>
201     move(returnValueGPR, regT1);
202 
203     // Profile the argument count.
<span class="line-modified">204     load32(Address(regT1, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), regT2);</span>
<span class="line-modified">205     load32(info-&gt;addressOfMaxArgumentCountIncludingThis(), regT0);</span>
206     Jump notBiggest = branch32(Above, regT0, regT2);
<span class="line-modified">207     store32(regT2, info-&gt;addressOfMaxArgumentCountIncludingThis());</span>
208     notBiggest.link(this);
209 
210     // Initialize &#39;this&#39;.
211     emitLoad(thisValue, regT2, regT0);
212     store32(regT0, Address(regT1, PayloadOffset + (CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register)))));
213     store32(regT2, Address(regT1, TagOffset + (CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register)))));
214 
215     addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), regT1, stackPointerRegister);
216 }
217 
218 template&lt;typename Op&gt;
219 bool JIT::compileCallEval(const Op&amp;)
220 {
221     return false;
222 }
223 
224 template&lt;&gt;
225 bool JIT::compileCallEval(const OpCallEval&amp; bytecode)
226 {
227     addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), stackPointerRegister, regT1);
228     storePtr(callFrameRegister, Address(regT1, CallFrame::callerFrameOffset()));
229 
230     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
231 
<span class="line-modified">232     callOperation(operationCallEval, m_codeBlock-&gt;globalObject(), regT1);</span>
233 
234     addSlowCase(branchIfEmpty(regT1));
235 
236     sampleCodeBlock(m_codeBlock);
237 
238     emitPutCallResult(bytecode);
239 
240     return true;
241 }
242 
243 void JIT::compileCallEvalSlowCase(const Instruction* instruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
244 {
245     linkAllSlowCases(iter);
246 
247     auto bytecode = instruction-&gt;as&lt;OpCallEval&gt;();
248     CallLinkInfo* info = m_codeBlock-&gt;addCallLinkInfo();
<span class="line-modified">249     info-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeIndex), regT0);</span>
250 
251     int registerOffset = -bytecode.m_argv;
<span class="line-modified">252     VirtualRegister callee = bytecode.m_callee;</span>
253 
254     addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
255 
256     emitLoad(callee, regT1, regT0);
<span class="line-modified">257     emitDumbVirtualCall(vm(), m_codeBlock-&gt;globalObject(), info);</span>
258     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
259     checkStackPointerAlignment();
260 
261     sampleCodeBlock(m_codeBlock);
262 
263     emitPutCallResult(bytecode);
264 }
265 
266 template &lt;typename Op&gt;
267 void JIT::compileOpCall(const Instruction* instruction, unsigned callLinkInfoIndex)
268 {
269     OpcodeID opcodeID = Op::opcodeID;
270     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">271     VirtualRegister callee = bytecode.m_callee;</span>
272 
273     /* Caller always:
274         - Updates callFrameRegister to callee callFrame.
275         - Initializes ArgumentCount; CallerFrame; Callee.
276 
277        For a JS call:
278         - Callee initializes ReturnPC; CodeBlock.
279         - Callee restores callFrameRegister before return.
280 
281        For a non-JS call:
282         - Caller initializes ReturnPC; CodeBlock.
283         - Caller restores callFrameRegister after return.
284     */
285     CallLinkInfo* info = nullptr;
286     if (opcodeID != op_call_eval)
287         info = m_codeBlock-&gt;addCallLinkInfo();
288     compileSetupFrame(bytecode, info);
289     // SP holds newCallFrame + sizeof(CallerFrameAndPC), with ArgumentCount initialized.
290 
<span class="line-modified">291     auto bytecodeIndex = m_codeBlock-&gt;bytecodeIndex(instruction);</span>
<span class="line-modified">292     uint32_t locationBits = CallSiteIndex(bytecodeIndex).bits();</span>
<span class="line-added">293     store32(TrustedImm32(locationBits), tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
294     emitLoad(callee, regT1, regT0); // regT1, regT0 holds callee.
295 
296     store32(regT0, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));
297     store32(regT1, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + TagOffset - sizeof(CallerFrameAndPC)));
298 
299     if (compileCallEval(bytecode))
300         return;
301 
302     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs)
303         emitRestoreCalleeSaves();
304 
305     addSlowCase(branchIfNotCell(regT1));
306 
307     DataLabelPtr addressOfLinkedFunctionCheck;
308     Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(nullptr));
309 
310     addSlowCase(slowCase);
311 
312     ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
<span class="line-modified">313     info-&gt;setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeIndex), regT0);</span>
314     m_callCompilationInfo.append(CallCompilationInfo());
315     m_callCompilationInfo[callLinkInfoIndex].hotPathBegin = addressOfLinkedFunctionCheck;
316     m_callCompilationInfo[callLinkInfoIndex].callLinkInfo = info;
317 
318     checkStackPointerAlignment();
319     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs || opcodeID == op_tail_call_forward_arguments) {
320         prepareForTailCallSlow();
321         m_callCompilationInfo[callLinkInfoIndex].hotPathOther = emitNakedTailCall();
322         return;
323     }
324 
325     m_callCompilationInfo[callLinkInfoIndex].hotPathOther = emitNakedCall();
326 
327     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
328     checkStackPointerAlignment();
329 
330     sampleCodeBlock(m_codeBlock);
331     emitPutCallResult(bytecode);
332 }
333 
334 template &lt;typename Op&gt;
335 void JIT::compileOpCallSlowCase(const Instruction* instruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter, unsigned callLinkInfoIndex)
336 {
337     OpcodeID opcodeID = Op::opcodeID;
338 
339     if (opcodeID == op_call_eval) {
340         compileCallEvalSlowCase(instruction, iter);
341         return;
342     }
343 
344     linkAllSlowCases(iter);
345 
<span class="line-added">346     move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT3);</span>
347     move(TrustedImmPtr(m_callCompilationInfo[callLinkInfoIndex].callLinkInfo), regT2);
348 
349     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs || opcodeID == op_tail_call_forward_arguments)
350         emitRestoreCalleeSaves();
351 
352     m_callCompilationInfo[callLinkInfoIndex].callReturnLocation = emitNakedCall(m_vm-&gt;getCTIStub(linkCallThunkGenerator).retaggedCode&lt;NoPtrTag&gt;());
353 
354     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs) {
355         abortWithReason(JITDidReturnFromTailCall);
356         return;
357     }
358 
359     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
360     checkStackPointerAlignment();
361 
362     sampleCodeBlock(m_codeBlock);
363 
364     auto bytecode = instruction-&gt;as&lt;Op&gt;();
365     emitPutCallResult(bytecode);
366 }
</pre>
</td>
</tr>
</table>
<center><a href="JITCall.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITCode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/RuleSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012 Google Inc. All rights reserved.
 12  *
 13  * This library is free software; you can redistribute it and/or
 14  * modify it under the terms of the GNU Library General Public
 15  * License as published by the Free Software Foundation; either
 16  * version 2 of the License, or (at your option) any later version.
 17  *
 18  * This library is distributed in the hope that it will be useful,
 19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 21  * Library General Public License for more details.
 22  *
 23  * You should have received a copy of the GNU Library General Public License
 24  * along with this library; see the file COPYING.LIB.  If not, write to
 25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 26  * Boston, MA 02110-1301, USA.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;RuleSet.h&quot;
 31 
 32 #include &quot;CSSFontSelector.h&quot;
 33 #include &quot;CSSKeyframesRule.h&quot;
 34 #include &quot;CSSSelector.h&quot;
 35 #include &quot;CSSSelectorList.h&quot;
 36 #include &quot;HTMLNames.h&quot;
 37 #include &quot;MediaQueryEvaluator.h&quot;
 38 #include &quot;SecurityOrigin.h&quot;
 39 #include &quot;SelectorChecker.h&quot;
 40 #include &quot;SelectorFilter.h&quot;
 41 #include &quot;StyleResolver.h&quot;
 42 #include &quot;StyleRule.h&quot;
 43 #include &quot;StyleRuleImport.h&quot;
 44 #include &quot;StyleSheetContents.h&quot;
 45 #include &quot;ViewportStyleResolver.h&quot;
 46 
 47 #if ENABLE(VIDEO_TRACK)
 48 #include &quot;TextTrackCue.h&quot;
 49 #endif
 50 
 51 namespace WebCore {
 52 namespace Style {
 53 
 54 using namespace HTMLNames;
 55 
 56 RuleSet::RuleSet() = default;
 57 
 58 RuleSet::~RuleSet() = default;
 59 
 60 void RuleSet::addToRuleSet(const AtomString&amp; key, AtomRuleMap&amp; map, const RuleData&amp; ruleData)
 61 {
 62     if (key.isNull())
 63         return;
 64     auto&amp; rules = map.add(key, nullptr).iterator-&gt;value;
 65     if (!rules)
 66         rules = makeUnique&lt;RuleDataVector&gt;();
 67     rules-&gt;append(ruleData);
 68 }
 69 
 70 static unsigned rulesCountForName(const RuleSet::AtomRuleMap&amp; map, const AtomString&amp; name)
 71 {
 72     if (const auto* rules = map.get(name))
 73         return rules-&gt;size();
 74     return 0;
 75 }
 76 
 77 static bool isHostSelectorMatchingInShadowTree(const CSSSelector&amp; startSelector)
 78 {
 79     auto* leftmostSelector = &amp;startSelector;
 80     bool hasDescendantOrChildRelation = false;
 81     while (auto* previous = leftmostSelector-&gt;tagHistory()) {
 82         hasDescendantOrChildRelation = leftmostSelector-&gt;hasDescendantOrChildRelation();
 83         leftmostSelector = previous;
 84     }
 85     if (!hasDescendantOrChildRelation)
 86         return false;
 87 
 88     return leftmostSelector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; leftmostSelector-&gt;pseudoClassType() == CSSSelector::PseudoClassHost;
 89 }
 90 
 91 void RuleSet::addRule(const StyleRule&amp; rule, unsigned selectorIndex, unsigned selectorListIndex, MediaQueryCollector* mediaQueryCollector)
 92 {
 93     RuleData ruleData(rule, selectorIndex, selectorListIndex, m_ruleCount++);
 94 
 95     m_features.collectFeatures(ruleData);
 96 
 97     if (mediaQueryCollector)
 98         mediaQueryCollector-&gt;addRuleIfNeeded(ruleData);
 99 
100     unsigned classBucketSize = 0;
101     const CSSSelector* idSelector = nullptr;
102     const CSSSelector* tagSelector = nullptr;
103     const CSSSelector* classSelector = nullptr;
104     const CSSSelector* linkSelector = nullptr;
105     const CSSSelector* focusSelector = nullptr;
106     const CSSSelector* hostPseudoClassSelector = nullptr;
107     const CSSSelector* customPseudoElementSelector = nullptr;
108     const CSSSelector* slottedPseudoElementSelector = nullptr;
109     const CSSSelector* partPseudoElementSelector = nullptr;
110 #if ENABLE(VIDEO_TRACK)
111     const CSSSelector* cuePseudoElementSelector = nullptr;
112 #endif
113     const CSSSelector* selector = ruleData.selector();
114     do {
115         switch (selector-&gt;match()) {
116         case CSSSelector::Id:
117             idSelector = selector;
118             break;
119         case CSSSelector::Class: {
120             auto&amp; className = selector-&gt;value();
121             if (!classSelector) {
122                 classSelector = selector;
123                 classBucketSize = rulesCountForName(m_classRules, className);
124             } else if (classBucketSize) {
125                 unsigned newClassBucketSize = rulesCountForName(m_classRules, className);
126                 if (newClassBucketSize &lt; classBucketSize) {
127                     classSelector = selector;
128                     classBucketSize = newClassBucketSize;
129                 }
130             }
131             break;
132         }
133         case CSSSelector::Tag:
134             if (selector-&gt;tagQName().localName() != starAtom())
135                 tagSelector = selector;
136             break;
137         case CSSSelector::PseudoElement:
138             switch (selector-&gt;pseudoElementType()) {
139             case CSSSelector::PseudoElementWebKitCustom:
140             case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
141                 customPseudoElementSelector = selector;
142                 break;
143             case CSSSelector::PseudoElementSlotted:
144                 slottedPseudoElementSelector = selector;
145                 break;
146             case CSSSelector::PseudoElementPart:
147                 partPseudoElementSelector = selector;
148                 break;
149 #if ENABLE(VIDEO_TRACK)
150             case CSSSelector::PseudoElementCue:
151                 cuePseudoElementSelector = selector;
152                 break;
153 #endif
154             default:
155                 break;
156             }
157             break;
158         case CSSSelector::PseudoClass:
159             switch (selector-&gt;pseudoClassType()) {
160             case CSSSelector::PseudoClassLink:
161             case CSSSelector::PseudoClassVisited:
162             case CSSSelector::PseudoClassAnyLink:
163             case CSSSelector::PseudoClassAnyLinkDeprecated:
164                 linkSelector = selector;
165                 break;
166             case CSSSelector::PseudoClassDirectFocus:
167             case CSSSelector::PseudoClassFocus:
168                 focusSelector = selector;
169                 break;
170             case CSSSelector::PseudoClassHost:
171                 hostPseudoClassSelector = selector;
172                 break;
173             default:
174                 break;
175             }
176             break;
177         case CSSSelector::Unknown:
178         case CSSSelector::Exact:
179         case CSSSelector::Set:
180         case CSSSelector::List:
181         case CSSSelector::Hyphen:
182         case CSSSelector::Contain:
183         case CSSSelector::Begin:
184         case CSSSelector::End:
185         case CSSSelector::PagePseudoClass:
186             break;
187         }
188         if (selector-&gt;relation() != CSSSelector::Subselector)
189             break;
190         selector = selector-&gt;tagHistory();
191     } while (selector);
192 
193 #if ENABLE(VIDEO_TRACK)
194     if (cuePseudoElementSelector) {
195         m_cuePseudoRules.append(ruleData);
196         return;
197     }
198 #endif
199 
200     if (slottedPseudoElementSelector) {
201         // ::slotted pseudo elements work accross shadow boundary making filtering difficult.
202         ruleData.disableSelectorFiltering();
203         m_slottedPseudoElementRules.append(ruleData);
204         return;
205     }
206 
207     if (partPseudoElementSelector) {
208         // Filtering doesn&#39;t work accross shadow boundaries.
209         ruleData.disableSelectorFiltering();
210         m_partPseudoElementRules.append(ruleData);
211         return;
212     }
213 
214     if (customPseudoElementSelector) {
215         // FIXME: Custom pseudo elements are handled by the shadow tree&#39;s selector filter. It doesn&#39;t know about the main DOM.
216         ruleData.disableSelectorFiltering();
217 
218         auto* nextSelector = customPseudoElementSelector-&gt;tagHistory();
219         if (nextSelector &amp;&amp; nextSelector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; nextSelector-&gt;pseudoElementType() == CSSSelector::PseudoElementPart) {
220             // Handle selectors like ::part(foo)::placeholder with the part codepath.
221             m_partPseudoElementRules.append(ruleData);
222             return;
223         }
224 
225         addToRuleSet(customPseudoElementSelector-&gt;value(), m_shadowPseudoElementRules, ruleData);
226         return;
227     }
228 
229     if (!m_hasHostPseudoClassRulesMatchingInShadowTree)
230         m_hasHostPseudoClassRulesMatchingInShadowTree = isHostSelectorMatchingInShadowTree(*ruleData.selector());
231 
232     if (hostPseudoClassSelector) {
233         m_hostPseudoClassRules.append(ruleData);
234         return;
235     }
236 
237     if (idSelector) {
238         addToRuleSet(idSelector-&gt;value(), m_idRules, ruleData);
239         return;
240     }
241 
242     if (classSelector) {
243         addToRuleSet(classSelector-&gt;value(), m_classRules, ruleData);
244         return;
245     }
246 
247     if (linkSelector) {
248         m_linkPseudoClassRules.append(ruleData);
249         return;
250     }
251 
252     if (focusSelector) {
253         m_focusPseudoClassRules.append(ruleData);
254         return;
255     }
256 
257     if (tagSelector) {
258         addToRuleSet(tagSelector-&gt;tagQName().localName(), m_tagLocalNameRules, ruleData);
259         addToRuleSet(tagSelector-&gt;tagLowercaseLocalName(), m_tagLowercaseLocalNameRules, ruleData);
260         return;
261     }
262 
263     // If we didn&#39;t find a specialized map to stick it in, file under universal rules.
264     m_universalRules.append(ruleData);
265 }
266 
267 void RuleSet::addPageRule(StyleRulePage&amp; rule)
268 {
269     m_pageRules.append(&amp;rule);
270 }
271 
272 void RuleSet::addChildRules(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; rules, MediaQueryCollector&amp; mediaQueryCollector, Resolver* resolver, AddRulesMode mode)
273 {
274     for (auto&amp; rule : rules) {
275         if (mode == AddRulesMode::ResolverMutationScan &amp;&amp; mediaQueryCollector.didMutateResolverWithinDynamicMediaQuery)
276             break;
277 
278         if (is&lt;StyleRule&gt;(*rule)) {
279             if (mode == AddRulesMode::Normal)
280                 addStyleRule(downcast&lt;StyleRule&gt;(*rule), mediaQueryCollector);
281             continue;
282         }
283         if (is&lt;StyleRulePage&gt;(*rule)) {
284             if (mode == AddRulesMode::Normal)
285                 addPageRule(downcast&lt;StyleRulePage&gt;(*rule));
286             continue;
287         }
288         if (is&lt;StyleRuleMedia&gt;(*rule)) {
289             auto&amp; mediaRule = downcast&lt;StyleRuleMedia&gt;(*rule);
290             if (mediaQueryCollector.pushAndEvaluate(mediaRule.mediaQueries())) {
291                 addChildRules(mediaRule.childRules(), mediaQueryCollector, resolver, mode);
292                 mediaQueryCollector.pop(mediaRule.mediaQueries());
293             }
294             continue;
295         }
296         if (is&lt;StyleRuleFontFace&gt;(*rule)) {
297             // Add this font face to our set.
298             if (resolver) {
299                 resolver-&gt;document().fontSelector().addFontFaceRule(downcast&lt;StyleRuleFontFace&gt;(*rule.get()), false);
300                 resolver-&gt;invalidateMatchedDeclarationsCache();
301             }
302             mediaQueryCollector.didMutateResolver();
303             continue;
304         }
305         if (is&lt;StyleRuleKeyframes&gt;(*rule)) {
306             if (resolver)
307                 resolver-&gt;addKeyframeStyle(downcast&lt;StyleRuleKeyframes&gt;(*rule));
308             mediaQueryCollector.didMutateResolver();
309             continue;
310         }
311         if (is&lt;StyleRuleSupports&gt;(*rule) &amp;&amp; downcast&lt;StyleRuleSupports&gt;(*rule).conditionIsSupported()) {
312             addChildRules(downcast&lt;StyleRuleSupports&gt;(*rule).childRules(), mediaQueryCollector, resolver, mode);
313             continue;
314         }
315 #if ENABLE(CSS_DEVICE_ADAPTATION)
316         if (is&lt;StyleRuleViewport&gt;(*rule)) {
317             if (resolver)
318                 resolver-&gt;viewportStyleResolver()-&gt;addViewportRule(downcast&lt;StyleRuleViewport&gt;(rule.get()));
319             mediaQueryCollector.didMutateResolver();
320             continue;
321         }
322 #endif
323     }
324 }
325 
326 void RuleSet::addRulesFromSheet(StyleSheetContents&amp; sheet, const MediaQueryEvaluator&amp; evaluator)
327 {
328     auto mediaQueryCollector = MediaQueryCollector { evaluator };
329     addRulesFromSheet(sheet, mediaQueryCollector, nullptr, AddRulesMode::Normal);
330 }
331 
332 void RuleSet::addRulesFromSheet(StyleSheetContents&amp; sheet, MediaQuerySet* sheetQuery, const MediaQueryEvaluator&amp; evaluator, Style::Resolver&amp; resolver)
333 {
334     auto canUseDynamicMediaQueryResolution = [&amp;] {
335         auto mediaQueryCollector = MediaQueryCollector { evaluator, true };
336         if (mediaQueryCollector.pushAndEvaluate(sheetQuery))
337             addRulesFromSheet(sheet, mediaQueryCollector, nullptr, AddRulesMode::ResolverMutationScan);
338         return !mediaQueryCollector.didMutateResolverWithinDynamicMediaQuery;
339     }();
340 
341     auto mediaQueryCollector = MediaQueryCollector { evaluator, canUseDynamicMediaQueryResolution };
342 
343     if (mediaQueryCollector.pushAndEvaluate(sheetQuery)) {
344         addRulesFromSheet(sheet, mediaQueryCollector, &amp;resolver, AddRulesMode::Normal);
345         mediaQueryCollector.pop(sheetQuery);
346     }
347 
348     m_hasViewportDependentMediaQueries = mediaQueryCollector.hasViewportDependentMediaQueries;
349 
350     if (mediaQueryCollector.dynamicMediaQueryRules.isEmpty())
351         return;
352 
353     auto firstNewIndex = m_dynamicMediaQueryRules.size();
354     m_dynamicMediaQueryRules.appendVector(WTFMove(mediaQueryCollector.dynamicMediaQueryRules));
355 
356     // Set the initial values.
357     evaluteDynamicMediaQueryRules(evaluator, firstNewIndex);
358 }
359 
360 void RuleSet::addRulesFromSheet(StyleSheetContents&amp; sheet, MediaQueryCollector&amp; mediaQueryCollector, Resolver* resolver, AddRulesMode mode)
361 {
362     for (auto&amp; rule : sheet.importRules()) {
363         if (!rule-&gt;styleSheet())
364             continue;
365 
366         if (mediaQueryCollector.pushAndEvaluate(rule-&gt;mediaQueries())) {
367             addRulesFromSheet(*rule-&gt;styleSheet(), mediaQueryCollector, resolver, mode);
368             mediaQueryCollector.pop(rule-&gt;mediaQueries());
369         }
370     }
371 
372     addChildRules(sheet.childRules(), mediaQueryCollector, resolver, mode);
373 
374     if (m_autoShrinkToFitEnabled &amp;&amp; mode == AddRulesMode::Normal)
375         shrinkToFit();
376 }
377 
378 void RuleSet::addStyleRule(const StyleRule&amp; rule, MediaQueryCollector&amp; mediaQueryCollector)
379 {
380     unsigned selectorListIndex = 0;
381     for (size_t selectorIndex = 0; selectorIndex != notFound; selectorIndex = rule.selectorList().indexOfNextSelectorAfter(selectorIndex))
382         addRule(rule, selectorIndex, selectorListIndex++, &amp;mediaQueryCollector);
383 }
384 
385 template&lt;typename Function&gt;
386 void RuleSet::traverseRuleDatas(Function&amp;&amp; function)
387 {
388     auto traverseVector = [&amp;](auto&amp; vector) {
389         for (auto&amp; ruleData : vector)
390             function(ruleData);
391     };
392 
393     auto traverseMap = [&amp;](auto&amp; map) {
394         for (auto&amp; ruleDatas : map.values())
395             traverseVector(*ruleDatas);
396     };
397 
398     traverseMap(m_idRules);
399     traverseMap(m_classRules);
400     traverseMap(m_tagLocalNameRules);
401     traverseMap(m_tagLowercaseLocalNameRules);
402     traverseMap(m_shadowPseudoElementRules);
403     traverseVector(m_linkPseudoClassRules);
404 #if ENABLE(VIDEO_TRACK)
405     traverseVector(m_cuePseudoRules);
406 #endif
407     traverseVector(m_hostPseudoClassRules);
408     traverseVector(m_slottedPseudoElementRules);
409     traverseVector(m_partPseudoElementRules);
410     traverseVector(m_focusPseudoClassRules);
411     traverseVector(m_universalRules);
412 }
413 
414 Optional&lt;DynamicMediaQueryEvaluationChanges&gt; RuleSet::evaluteDynamicMediaQueryRules(const MediaQueryEvaluator&amp; evaluator)
415 {
416     auto collectedChanges = evaluteDynamicMediaQueryRules(evaluator, 0);
417 
418     if (collectedChanges.requiredFullReset)
419         return { { DynamicMediaQueryEvaluationChanges::Type::ResetStyle } };
420 
421     if (collectedChanges.changedQueryIndexes.isEmpty())
422         return { };
423 
424     auto&amp; ruleSet = m_mediaQueryInvalidationRuleSetCache.ensure(collectedChanges.changedQueryIndexes, [&amp;] {
425         auto ruleSet = RuleSet::create();
426         for (auto* featureVector : collectedChanges.ruleFeatures) {
427             for (auto&amp; feature : *featureVector)
428                 ruleSet-&gt;addRule(*feature.styleRule, feature.selectorIndex, feature.selectorListIndex);
429         }
430         return ruleSet;
431     }).iterator-&gt;value;
432 
433     return { { DynamicMediaQueryEvaluationChanges::Type::InvalidateStyle, { ruleSet.copyRef() } } };
434 }
435 
436 RuleSet::CollectedMediaQueryChanges RuleSet::evaluteDynamicMediaQueryRules(const MediaQueryEvaluator&amp; evaluator, size_t startIndex)
437 {
438     CollectedMediaQueryChanges collectedChanges;
439 
440     for (size_t i = startIndex; i &lt; m_dynamicMediaQueryRules.size(); ++i) {
441         auto&amp; dynamicRules = m_dynamicMediaQueryRules[i];
442         bool result = true;
443         for (auto&amp; set : dynamicRules.mediaQuerySets) {
444             if (!evaluator.evaluate(set.get())) {
445                 result = false;
446                 break;
447             }
448         }
449 
450         if (result != dynamicRules.result) {
451             dynamicRules.result = result;
452 
453             if (dynamicRules.requiresFullReset) {
454                 collectedChanges.requiredFullReset = true;
455                 return collectedChanges;
456             }
457 
458             traverseRuleDatas([&amp;](RuleData&amp; ruleData) {
459                 if (!dynamicRules.affectedRulePositions.contains(ruleData.position()))
460                     return;
461                 ruleData.setEnabled(result);
462             });
463 
464             collectedChanges.changedQueryIndexes.append(i);
465             collectedChanges.ruleFeatures.append(&amp;dynamicRules.ruleFeatures);
466         }
467     }
468 
469     return collectedChanges;
470 }
471 
472 bool RuleSet::hasShadowPseudoElementRules() const
473 {
474     if (!m_shadowPseudoElementRules.isEmpty())
475         return true;
476 #if ENABLE(VIDEO_TRACK)
477     if (!m_cuePseudoRules.isEmpty())
478         return true;
479 #endif
480     return false;
481 }
482 
483 static inline void shrinkMapVectorsToFit(RuleSet::AtomRuleMap&amp; map)
484 {
485     for (auto&amp; vector : map.values())
486         vector-&gt;shrinkToFit();
487 }
488 
489 void RuleSet::shrinkToFit()
490 {
491     shrinkMapVectorsToFit(m_idRules);
492     shrinkMapVectorsToFit(m_classRules);
493     shrinkMapVectorsToFit(m_tagLocalNameRules);
494     shrinkMapVectorsToFit(m_tagLowercaseLocalNameRules);
495     shrinkMapVectorsToFit(m_shadowPseudoElementRules);
496     m_linkPseudoClassRules.shrinkToFit();
497 #if ENABLE(VIDEO_TRACK)
498     m_cuePseudoRules.shrinkToFit();
499 #endif
500     m_hostPseudoClassRules.shrinkToFit();
501     m_slottedPseudoElementRules.shrinkToFit();
502     m_focusPseudoClassRules.shrinkToFit();
503     m_universalRules.shrinkToFit();
504     m_pageRules.shrinkToFit();
505     m_features.shrinkToFit();
506 }
507 
508 RuleSet::MediaQueryCollector::~MediaQueryCollector() = default;
509 
510 bool RuleSet::MediaQueryCollector::pushAndEvaluate(const MediaQuerySet* set)
511 {
512     if (!set)
513         return true;
514 
515     // Only evaluate static expressions that require style rebuild.
516     MediaQueryDynamicResults dynamicResults;
517     auto mode = collectDynamic ? MediaQueryEvaluator::Mode::AlwaysMatchDynamic : MediaQueryEvaluator::Mode::Normal;
518 
519     bool result = evaluator.evaluate(*set, &amp;dynamicResults, mode);
520 
521     if (!dynamicResults.viewport.isEmpty())
522         hasViewportDependentMediaQueries = true;
523 
524     if (!result)
525         return false;
526 
527     if (!dynamicResults.isEmpty())
528         dynamicContextStack.append({ *set });
529 
530     return true;
531 }
532 
533 void RuleSet::MediaQueryCollector::pop(const MediaQuerySet* set)
534 {
535     if (!set || dynamicContextStack.isEmpty() || set != &amp;dynamicContextStack.last().set.get())
536         return;
537 
538     if (!dynamicContextStack.last().affectedRulePositions.isEmpty()) {
539         DynamicMediaQueryRules rules;
540         for (auto&amp; context : dynamicContextStack)
541             rules.mediaQuerySets.append(context.set.get());
542 
543         if (collectDynamic) {
544             auto&amp; toAdd = dynamicContextStack.last().affectedRulePositions;
545             rules.affectedRulePositions.add(toAdd.begin(), toAdd.end());
546 
547             rules.ruleFeatures = WTFMove(dynamicContextStack.last().ruleFeatures);
548             rules.ruleFeatures.shrinkToFit();
549         } else
550             rules.requiresFullReset = true;
551 
552         dynamicMediaQueryRules.append(WTFMove(rules));
553     }
554 
555     dynamicContextStack.removeLast();
556 }
557 
558 void RuleSet::MediaQueryCollector::didMutateResolver()
559 {
560     if (dynamicContextStack.isEmpty())
561         return;
562     didMutateResolverWithinDynamicMediaQuery = true;
563 }
564 
565 void RuleSet::MediaQueryCollector::addRuleIfNeeded(const RuleData&amp; ruleData)
566 {
567     if (dynamicContextStack.isEmpty())
568         return;
569 
570     auto&amp; context = dynamicContextStack.last();
571     context.affectedRulePositions.append(ruleData.position());
572     context.ruleFeatures.append({ ruleData });
573 }
574 
575 
576 } // namespace Style
577 } // namespace WebCore
    </pre>
  </body>
</html>
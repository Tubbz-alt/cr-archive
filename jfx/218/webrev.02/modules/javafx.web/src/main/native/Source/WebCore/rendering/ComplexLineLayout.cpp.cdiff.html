<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFilter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComplexLineLayout.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 56,11 ***</span>
  ComplexLineLayout::ComplexLineLayout(RenderBlockFlow&amp; flow)
      : m_flow(flow)
  {
  }
  
<span class="line-modified">! ComplexLineLayout::~ComplexLineLayout() = default;</span>
  
  static void determineDirectionality(TextDirection&amp; dir, InlineIterator iter)
  {
      while (!iter.atEnd()) {
          if (iter.atParagraphSeparator())
<span class="line-new-header">--- 56,17 ---</span>
  ComplexLineLayout::ComplexLineLayout(RenderBlockFlow&amp; flow)
      : m_flow(flow)
  {
  }
  
<span class="line-modified">! ComplexLineLayout::~ComplexLineLayout()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_flow.containsFloats())</span>
<span class="line-added">+         m_flow.floatingObjects()-&gt;clearLineBoxTreePointers();</span>
<span class="line-added">+ </span>
<span class="line-added">+     lineBoxes().deleteLineBoxTree();</span>
<span class="line-added">+ };</span>
  
  static void determineDirectionality(TextDirection&amp; dir, InlineIterator iter)
  {
      while (!iter.atEnd()) {
          if (iter.atParagraphSeparator())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 568,11 ***</span>
      auto&amp; rubyBase = *rubyRun.rubyBase();
      auto&amp; rootBox = *rubyBase.firstRootBox();
  
      float totalExpansion = 0;
      unsigned totalOpportunitiesInRun = 0;
<span class="line-modified">!     for (auto* leafChild = rootBox.firstLeafChild(); leafChild; leafChild = leafChild-&gt;nextLeafChild()) {</span>
          if (!leafChild-&gt;isInlineTextBox())
              continue;
  
          unsigned opportunitiesInRun = expansionOpportunities[i++];
          ASSERT(opportunitiesInRun &lt;= expansionOpportunityCount);
<span class="line-new-header">--- 574,11 ---</span>
      auto&amp; rubyBase = *rubyRun.rubyBase();
      auto&amp; rootBox = *rubyBase.firstRootBox();
  
      float totalExpansion = 0;
      unsigned totalOpportunitiesInRun = 0;
<span class="line-modified">!     for (auto* leafChild = rootBox.firstLeafDescendant(); leafChild; leafChild = leafChild-&gt;nextLeafOnLine()) {</span>
          if (!leafChild-&gt;isInlineTextBox())
              continue;
  
          unsigned opportunitiesInRun = expansionOpportunities[i++];
          ASSERT(opportunitiesInRun &lt;= expansionOpportunityCount);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 733,11 ***</span>
      if (textAlign == TextAlignMode::Justify) {
          // If the next box is ruby, and we&#39;re justifying, and the first box in the ruby base has a leading expansion, and we are a text box, then force a trailing expansion.
          if (nextRun &amp;&amp; is&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase() &amp;&amp; nextRun-&gt;renderer().style().collapseWhiteSpace()) {
              auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase();
              if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified">!                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;firstLeafChild()) {</span>
                      if (is&lt;InlineTextBox&gt;(*leafChild)) {
                          // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
                          if (FontCascade::leadingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
                              setTrailingExpansion = true;
                              result |= ForceTrailingExpansion;
<span class="line-new-header">--- 739,11 ---</span>
      if (textAlign == TextAlignMode::Justify) {
          // If the next box is ruby, and we&#39;re justifying, and the first box in the ruby base has a leading expansion, and we are a text box, then force a trailing expansion.
          if (nextRun &amp;&amp; is&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase() &amp;&amp; nextRun-&gt;renderer().style().collapseWhiteSpace()) {
              auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase();
              if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified">!                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;firstLeafDescendant()) {</span>
                      if (is&lt;InlineTextBox&gt;(*leafChild)) {
                          // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
                          if (FontCascade::leadingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
                              setTrailingExpansion = true;
                              result |= ForceTrailingExpansion;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,11 ***</span>
          }
          // Same thing, except if we&#39;re following a ruby
          if (previousRun &amp;&amp; is&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase() &amp;&amp; previousRun-&gt;renderer().style().collapseWhiteSpace()) {
              auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase();
              if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified">!                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;lastLeafChild()) {</span>
                      if (is&lt;InlineTextBox&gt;(*leafChild)) {
                          // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
                          if (FontCascade::trailingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
                              setLeadingExpansion = true;
                              result |= ForceLeadingExpansion;
<span class="line-new-header">--- 754,11 ---</span>
          }
          // Same thing, except if we&#39;re following a ruby
          if (previousRun &amp;&amp; is&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase() &amp;&amp; previousRun-&gt;renderer().style().collapseWhiteSpace()) {
              auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase();
              if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
<span class="line-modified">!                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;lastLeafDescendant()) {</span>
                      if (is&lt;InlineTextBox&gt;(*leafChild)) {
                          // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
                          if (FontCascade::trailingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
                              setLeadingExpansion = true;
                              result |= ForceLeadingExpansion;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,14 ***</span>
              }
          }
          // If we&#39;re the first box inside a ruby base, forbid a leading expansion, and vice-versa
          if (is&lt;RenderRubyBase&gt;(block)) {
              RenderRubyBase&amp; rubyBase = downcast&lt;RenderRubyBase&gt;(block);
<span class="line-modified">!             if (&amp;textBox == rubyBase.firstRootBox()-&gt;firstLeafChild()) {</span>
                  setLeadingExpansion = true;
                  result |= ForbidLeadingExpansion;
<span class="line-modified">!             } if (&amp;textBox == rubyBase.firstRootBox()-&gt;lastLeafChild()) {</span>
                  setTrailingExpansion = true;
                  result |= ForbidTrailingExpansion;
              }
          }
      }
<span class="line-new-header">--- 768,14 ---</span>
              }
          }
          // If we&#39;re the first box inside a ruby base, forbid a leading expansion, and vice-versa
          if (is&lt;RenderRubyBase&gt;(block)) {
              RenderRubyBase&amp; rubyBase = downcast&lt;RenderRubyBase&gt;(block);
<span class="line-modified">!             if (&amp;textBox == rubyBase.firstRootBox()-&gt;firstLeafDescendant()) {</span>
                  setLeadingExpansion = true;
                  result |= ForbidLeadingExpansion;
<span class="line-modified">!             } if (&amp;textBox == rubyBase.firstRootBox()-&gt;lastLeafDescendant()) {</span>
                  setTrailingExpansion = true;
                  result |= ForbidTrailingExpansion;
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,11 ***</span>
              bool encounteredJustifiedRuby = false;
              if (is&lt;RenderRubyRun&gt;(run-&gt;renderer()) &amp;&amp; textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun &amp;&amp; downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase()) {
                  auto* rubyBase = downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase();
                  if (rubyBase-&gt;firstRootBox() &amp;&amp; !rubyBase-&gt;firstRootBox()-&gt;nextRootBox() &amp;&amp; run-&gt;renderer().style().collapseWhiteSpace()) {
                      rubyBase-&gt;setIsAfterExpansion(isAfterExpansion);
<span class="line-modified">!                     for (auto* leafChild = rubyBase-&gt;firstRootBox()-&gt;firstLeafChild(); leafChild; leafChild = leafChild-&gt;nextLeafChild()) {</span>
                          if (!is&lt;InlineTextBox&gt;(*leafChild))
                              continue;
                          encounteredJustifiedRuby = true;
                          computeExpansionOpportunities(*rubyBase, downcast&lt;InlineTextBox&gt;(*leafChild), nullptr, nullptr,
                              downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction());
<span class="line-new-header">--- 924,11 ---</span>
              bool encounteredJustifiedRuby = false;
              if (is&lt;RenderRubyRun&gt;(run-&gt;renderer()) &amp;&amp; textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun &amp;&amp; downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase()) {
                  auto* rubyBase = downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase();
                  if (rubyBase-&gt;firstRootBox() &amp;&amp; !rubyBase-&gt;firstRootBox()-&gt;nextRootBox() &amp;&amp; run-&gt;renderer().style().collapseWhiteSpace()) {
                      rubyBase-&gt;setIsAfterExpansion(isAfterExpansion);
<span class="line-modified">!                     for (auto* leafChild = rubyBase-&gt;firstRootBox()-&gt;firstLeafDescendant(); leafChild; leafChild = leafChild-&gt;nextLeafOnLine()) {</span>
                          if (!is&lt;InlineTextBox&gt;(*leafChild))
                              continue;
                          encounteredJustifiedRuby = true;
                          computeExpansionOpportunities(*rubyBase, downcast&lt;InlineTextBox&gt;(*leafChild), nullptr, nullptr,
                              downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 969,11 ***</span>
  }
  
  void ComplexLineLayout::removeInlineBox(BidiRun&amp; run, const RootInlineBox&amp; rootLineBox) const
  {
      auto* inlineBox = run.box();
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      auto* inlineParent = inlineBox-&gt;parent();
      while (inlineParent &amp;&amp; inlineParent != &amp;rootLineBox) {
          ASSERT(!inlineParent-&gt;isDirty());
          inlineParent = inlineParent-&gt;parent();
      }
<span class="line-new-header">--- 975,11 ---</span>
  }
  
  void ComplexLineLayout::removeInlineBox(BidiRun&amp; run, const RootInlineBox&amp; rootLineBox) const
  {
      auto* inlineBox = run.box();
<span class="line-modified">! #if ASSERT_ENABLED</span>
      auto* inlineParent = inlineBox-&gt;parent();
      while (inlineParent &amp;&amp; inlineParent != &amp;rootLineBox) {
          ASSERT(!inlineParent-&gt;isDirty());
          inlineParent = inlineParent-&gt;parent();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1315,14 ***</span>
  
      if (!layoutState.isFullLayout() &amp;&amp; lastRootBox() &amp;&amp; lastRootBox()-&gt;endsWithBreak()) {
          // If the last line before the start line ends with a line break that clear floats,
          // adjust the height accordingly.
          // A line break can be either the first or the last object on a line, depending on its direction.
<span class="line-modified">!         if (InlineBox* lastLeafChild = lastRootBox()-&gt;lastLeafChild()) {</span>
<span class="line-modified">!             RenderObject* lastObject = &amp;lastLeafChild-&gt;renderer();</span>
              if (!lastObject-&gt;isBR())
<span class="line-modified">!                 lastObject = &amp;lastRootBox()-&gt;firstLeafChild()-&gt;renderer();</span>
              if (lastObject-&gt;isBR()) {
                  Clear clear = lastObject-&gt;style().clear();
                  if (clear != Clear::None)
                      m_flow.clearFloats(clear);
              }
<span class="line-new-header">--- 1321,14 ---</span>
  
      if (!layoutState.isFullLayout() &amp;&amp; lastRootBox() &amp;&amp; lastRootBox()-&gt;endsWithBreak()) {
          // If the last line before the start line ends with a line break that clear floats,
          // adjust the height accordingly.
          // A line break can be either the first or the last object on a line, depending on its direction.
<span class="line-modified">!         if (InlineBox* lastLeafDescendant = lastRootBox()-&gt;lastLeafDescendant()) {</span>
<span class="line-modified">!             RenderObject* lastObject = &amp;lastLeafDescendant-&gt;renderer();</span>
              if (!lastObject-&gt;isBR())
<span class="line-modified">!                 lastObject = &amp;lastRootBox()-&gt;firstLeafDescendant()-&gt;renderer();</span>
              if (lastObject-&gt;isBR()) {
                  Clear clear = lastObject-&gt;style().clear();
                  if (clear != Clear::None)
                      m_flow.clearFloats(clear);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1548,11 ***</span>
              lineBox = currentFirstLineOfNewPage;
              for (int i = 0; i &lt; numLinesToTake; ++i)
                  lineBox = lineBox-&gt;prevRootBox();
  
              // We now want to break at this line. Remember for next layout and trigger relayout.
<span class="line-modified">!             m_flow.setBreakAtLineToAvoidWidow(m_flow.lineCount(lineBox));</span>
              m_flow.markLinesDirtyInBlockRange(lastRootBox()-&gt;lineBottomWithLeading(), lineBox-&gt;lineBottomWithLeading(), lineBox);
          }
      }
      m_flow.clearDidBreakAtLineToAvoidWidow();
  }
<span class="line-new-header">--- 1554,11 ---</span>
              lineBox = currentFirstLineOfNewPage;
              for (int i = 0; i &lt; numLinesToTake; ++i)
                  lineBox = lineBox-&gt;prevRootBox();
  
              // We now want to break at this line. Remember for next layout and trigger relayout.
<span class="line-modified">!             m_flow.setBreakAtLineToAvoidWidow(lineCountUntil(lineBox));</span>
              m_flow.markLinesDirtyInBlockRange(lastRootBox()-&gt;lineBottomWithLeading(), lineBox-&gt;lineBottomWithLeading(), lineBox);
          }
      }
      m_flow.clearDidBreakAtLineToAvoidWidow();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2100,10 ***</span>
<span class="line-new-header">--- 2106,31 ---</span>
                  fragment-&gt;addVisualOverflowForBox(&amp;m_flow, childVisualOverflowRect);
          }
      }
  }
  
<span class="line-added">+ size_t ComplexLineLayout::lineCount() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     size_t count = 0;</span>
<span class="line-added">+     for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox())</span>
<span class="line-added">+         ++count;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return count;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t ComplexLineLayout::lineCountUntil(const RootInlineBox* stopRootInlineBox) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     size_t count = 0;</span>
<span class="line-added">+     for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {</span>
<span class="line-added">+         ++count;</span>
<span class="line-added">+         if (box == stopRootInlineBox)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return count;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ComplexLineLayout::deleteEllipsisLineBoxes()
  {
      TextAlignMode textAlign = style().textAlign();
      bool ltr = style().isLeftToRightDirection();
      IndentTextOrNot shouldIndentText = IndentText;
</pre>
<center><a href="CSSFilter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComplexLineLayout.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;ComplexTextController.h&quot;
 27 
 28 #include &quot;CharacterProperties.h&quot;
 29 #include &quot;FloatSize.h&quot;
 30 #include &quot;FontCascade.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 #include &quot;RenderText.h&quot;
 33 #include &quot;TextRun.h&quot;
 34 #include &lt;unicode/ubrk.h&gt;
 35 #include &lt;wtf/Optional.h&gt;
 36 #include &lt;wtf/StdLibExtras.h&gt;
 37 #include &lt;wtf/text/TextBreakIterator.h&gt;
 38 #include &lt;wtf/unicode/CharacterNames.h&gt;
 39 
 40 #if PLATFORM(IOS_FAMILY)
 41 #include &lt;CoreText/CoreText.h&gt;
 42 #endif
 43 
 44 namespace WebCore {
 45 
<a name="2" id="anc2"></a>





















 46 class TextLayout {
 47     WTF_MAKE_FAST_ALLOCATED;
 48 public:
 49     static bool isNeeded(RenderText&amp; text, const FontCascade&amp; font)
 50     {
 51         TextRun run = RenderBlock::constructTextRun(text, text.style());
 52         return font.codePath(run) == FontCascade::Complex;
 53     }
 54 
 55     TextLayout(RenderText&amp; text, const FontCascade&amp; font, float xPos)
 56         : m_font(font)
 57         , m_run(constructTextRun(text, xPos))
 58         , m_controller(makeUnique&lt;ComplexTextController&gt;(m_font, m_run, true))
 59     {
 60     }
 61 
 62     float width(unsigned from, unsigned len, HashSet&lt;const Font*&gt;* fallbackFonts)
 63     {
 64         m_controller-&gt;advance(from, 0, ByWholeGlyphs, fallbackFonts);
 65         float beforeWidth = m_controller-&gt;runWidthSoFar();
 66         if (m_font.wordSpacing() &amp;&amp; from &amp;&amp; FontCascade::treatAsSpace(m_run[from]))
 67             beforeWidth += m_font.wordSpacing();
 68         m_controller-&gt;advance(from + len, 0, ByWholeGlyphs, fallbackFonts);
 69         float afterWidth = m_controller-&gt;runWidthSoFar();
 70         return afterWidth - beforeWidth;
 71     }
 72 
 73 private:
 74     static TextRun constructTextRun(RenderText&amp; text, float xPos)
 75     {
 76         TextRun run = RenderBlock::constructTextRun(text, text.style());
 77         run.setXPos(xPos);
 78         return run;
 79     }
 80 
 81     // ComplexTextController has only references to its FontCascade and TextRun so they must be kept alive here.
 82     FontCascade m_font;
 83     TextRun m_run;
 84     std::unique_ptr&lt;ComplexTextController&gt; m_controller;
 85 };
 86 
 87 void TextLayoutDeleter::operator()(TextLayout* layout) const
 88 {
 89     delete layout;
 90 }
 91 
 92 std::unique_ptr&lt;TextLayout, TextLayoutDeleter&gt; FontCascade::createLayout(RenderText&amp; text, float xPos, bool collapseWhiteSpace) const
 93 {
 94     if (!collapseWhiteSpace || !TextLayout::isNeeded(text, *this))
 95         return nullptr;
 96     return std::unique_ptr&lt;TextLayout, TextLayoutDeleter&gt;(new TextLayout(text, *this, xPos));
 97 }
 98 
 99 float FontCascade::width(TextLayout&amp; layout, unsigned from, unsigned len, HashSet&lt;const Font*&gt;* fallbackFonts)
100 {
101     return layout.width(from, len, fallbackFonts);
102 }
103 
104 void ComplexTextController::computeExpansionOpportunity()
105 {
106     if (!m_expansion)
107         m_expansionPerOpportunity = 0;
108     else {
109         unsigned expansionOpportunityCount = FontCascade::expansionOpportunityCount(m_run.text(), m_run.ltr() ? TextDirection::LTR : TextDirection::RTL, m_run.expansionBehavior()).first;
110 
111         if (!expansionOpportunityCount)
112             m_expansionPerOpportunity = 0;
113         else
114             m_expansionPerOpportunity = m_expansion / expansionOpportunityCount;
115     }
116 }
117 
118 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, bool mayUseNaturalWritingDirection, HashSet&lt;const Font*&gt;* fallbackFonts, bool forTextEmphasis)
119     : m_fallbackFonts(fallbackFonts)
120     , m_font(font)
121     , m_run(run)
122     , m_end(run.length())
123     , m_expansion(run.expansion())
124     , m_mayUseNaturalWritingDirection(mayUseNaturalWritingDirection)
125     , m_forTextEmphasis(forTextEmphasis)
126 {
<a name="3" id="anc3"></a>



127     computeExpansionOpportunity();
128 
129     collectComplexTextRuns();
130 
131     finishConstruction();
132 }
133 
134 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, Vector&lt;Ref&lt;ComplexTextRun&gt;&gt;&amp; runs)
135     : m_font(font)
136     , m_run(run)
137     , m_end(run.length())
138     , m_expansion(run.expansion())
139 {
140     computeExpansionOpportunity();
141 
142     for (auto&amp; run : runs)
143         m_complexTextRuns.append(run.ptr());
144 
145     finishConstruction();
146 }
147 
148 void ComplexTextController::finishConstruction()
149 {
150     adjustGlyphsAndAdvances();
151 
152     if (!m_isLTROnly) {
153         m_runIndices.reserveInitialCapacity(m_complexTextRuns.size());
154 
155         m_glyphCountFromStartToIndex.reserveInitialCapacity(m_complexTextRuns.size());
156         unsigned glyphCountSoFar = 0;
157         for (unsigned i = 0; i &lt; m_complexTextRuns.size(); ++i) {
158             m_glyphCountFromStartToIndex.uncheckedAppend(glyphCountSoFar);
159             glyphCountSoFar += m_complexTextRuns[i]-&gt;glyphCount();
160         }
161     }
162 }
163 
164 unsigned ComplexTextController::offsetForPosition(float h, bool includePartialGlyphs)
165 {
<a name="4" id="anc4"></a><span class="line-modified">166     if (h &gt;= m_totalAdvance.width())</span>
167         return m_run.ltr() ? m_end : 0;
168 
169     if (h &lt; 0)
170         return m_run.ltr() ? 0 : m_end;
171 
172     float x = h;
173 
174     size_t runCount = m_complexTextRuns.size();
175     unsigned offsetIntoAdjustedGlyphs = 0;
176 
177     for (size_t r = 0; r &lt; runCount; ++r) {
178         const ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[r];
179         for (unsigned j = 0; j &lt; complexTextRun.glyphCount(); ++j) {
180             unsigned index = offsetIntoAdjustedGlyphs + j;
181             float adjustedAdvance = m_adjustedBaseAdvances[index].width();
182             bool hit = m_run.ltr() ? x &lt; adjustedAdvance : (x &lt;= adjustedAdvance &amp;&amp; adjustedAdvance);
183             if (hit) {
184                 unsigned hitGlyphStart = complexTextRun.indexAt(j);
185                 unsigned hitGlyphEnd;
186                 if (m_run.ltr())
187                     hitGlyphEnd = std::max(hitGlyphStart, j + 1 &lt; complexTextRun.glyphCount() ? complexTextRun.indexAt(j + 1) : complexTextRun.indexEnd());
188                 else
189                     hitGlyphEnd = std::max(hitGlyphStart, j &gt; 0 ? complexTextRun.indexAt(j - 1) : complexTextRun.indexEnd());
190 
191                 // FIXME: Instead of dividing the glyph&#39;s advance equally between the characters, this
192                 // could use the glyph&#39;s &quot;ligature carets&quot;. This is available in CoreText via CTFontGetLigatureCaretPositions().
193                 unsigned hitIndex;
194                 if (m_run.ltr())
195                     hitIndex = hitGlyphStart + (hitGlyphEnd - hitGlyphStart) * (x / adjustedAdvance);
196                 else {
197                     if (hitGlyphStart == hitGlyphEnd)
198                         hitIndex = hitGlyphStart;
199                     else if (x)
200                         hitIndex = hitGlyphEnd - (hitGlyphEnd - hitGlyphStart) * (x / adjustedAdvance);
201                     else
202                         hitIndex = hitGlyphEnd - 1;
203                 }
204 
205                 unsigned stringLength = complexTextRun.stringLength();
206                 CachedTextBreakIterator cursorPositionIterator(StringView(complexTextRun.characters(), stringLength), TextBreakIterator::Mode::Caret, nullAtom());
207                 unsigned clusterStart;
208                 if (cursorPositionIterator.isBoundary(hitIndex))
209                     clusterStart = hitIndex;
210                 else
211                     clusterStart = cursorPositionIterator.preceding(hitIndex).valueOr(0);
212 
213                 if (!includePartialGlyphs)
214                     return complexTextRun.stringLocation() + clusterStart;
215 
216                 unsigned clusterEnd = cursorPositionIterator.following(hitIndex).valueOr(stringLength);
217 
218                 float clusterWidth;
219                 // FIXME: The search stops at the boundaries of complexTextRun. In theory, it should go on into neighboring ComplexTextRuns
220                 // derived from the same CTLine. In practice, we do not expect there to be more than one CTRun in a CTLine, as no
221                 // reordering and no font fallback should occur within a CTLine.
222                 if (clusterEnd - clusterStart &gt; 1) {
223                     clusterWidth = adjustedAdvance;
224                     if (j) {
225                         unsigned firstGlyphBeforeCluster = j - 1;
226                         while (complexTextRun.indexAt(firstGlyphBeforeCluster) &gt;= clusterStart &amp;&amp; complexTextRun.indexAt(firstGlyphBeforeCluster) &lt; clusterEnd) {
227                             float width = m_adjustedBaseAdvances[offsetIntoAdjustedGlyphs + firstGlyphBeforeCluster].width();
228                             clusterWidth += width;
229                             x += width;
230                             if (!firstGlyphBeforeCluster)
231                                 break;
232                             firstGlyphBeforeCluster--;
233                         }
234                     }
235                     unsigned firstGlyphAfterCluster = j + 1;
236                     while (firstGlyphAfterCluster &lt; complexTextRun.glyphCount() &amp;&amp; complexTextRun.indexAt(firstGlyphAfterCluster) &gt;= clusterStart &amp;&amp; complexTextRun.indexAt(firstGlyphAfterCluster) &lt; clusterEnd) {
237                         clusterWidth += m_adjustedBaseAdvances[offsetIntoAdjustedGlyphs + firstGlyphAfterCluster].width();
238                         firstGlyphAfterCluster++;
239                     }
240                 } else {
241                     clusterWidth = adjustedAdvance / (hitGlyphEnd - hitGlyphStart);
242                     x -=  clusterWidth * (m_run.ltr() ? hitIndex - hitGlyphStart : hitGlyphEnd - hitIndex - 1);
243                 }
244                 if (x &lt;= clusterWidth / 2)
245                     return complexTextRun.stringLocation() + (m_run.ltr() ? clusterStart : clusterEnd);
246                 return complexTextRun.stringLocation() + (m_run.ltr() ? clusterEnd : clusterStart);
247             }
248             x -= adjustedAdvance;
249         }
250         offsetIntoAdjustedGlyphs += complexTextRun.glyphCount();
251     }
252 
253     ASSERT_NOT_REACHED();
254     return 0;
255 }
256 
257 // FIXME: We should consider reimplementing this function using ICU to advance by grapheme.
258 // The current implementation only considers explicitly emoji sequences and emoji variations.
259 static bool advanceByCombiningCharacterSequence(const UChar*&amp; iterator, const UChar* end, UChar32&amp; baseCharacter, unsigned&amp; markCount)
260 {
261     ASSERT(iterator &lt; end);
262 
263     markCount = 0;
264 
265     unsigned i = 0;
266     unsigned remainingCharacters = end - iterator;
267     U16_NEXT(iterator, i, remainingCharacters, baseCharacter);
268     iterator = iterator + i;
269     if (U_IS_SURROGATE(baseCharacter))
270         return false;
271 
272     // Consume marks.
273     bool sawEmojiGroupCandidate = isEmojiGroupCandidate(baseCharacter);
274     bool sawJoiner = false;
275     bool sawRegionalIndicator = isEmojiRegionalIndicator(baseCharacter);
276     while (iterator &lt; end) {
277         UChar32 nextCharacter;
278         unsigned markLength = 0;
279         bool shouldContinue = false;
280         ASSERT(end &gt;= iterator);
281         U16_NEXT(iterator, markLength, static_cast&lt;unsigned&gt;(end - iterator), nextCharacter);
282 
283         if (isVariationSelector(nextCharacter) || isEmojiFitzpatrickModifier(nextCharacter))
284             shouldContinue = true;
285 
286         if (sawRegionalIndicator &amp;&amp; isEmojiRegionalIndicator(nextCharacter)) {
287             shouldContinue = true;
288             sawRegionalIndicator = false;
289         }
290 
291         if (sawJoiner &amp;&amp; isEmojiGroupCandidate(nextCharacter))
292             shouldContinue = true;
293 
294         sawJoiner = false;
295         if (sawEmojiGroupCandidate &amp;&amp; nextCharacter == zeroWidthJoiner) {
296             sawJoiner = true;
297             shouldContinue = true;
298         }
299 
300         if (!shouldContinue &amp;&amp; !(U_GET_GC_MASK(nextCharacter) &amp; U_GC_M_MASK))
301             break;
302 
303         markCount += markLength;
304         iterator += markLength;
305     }
306 
307     return true;
308 }
309 
310 // FIXME: Capitalization is language-dependent and context-dependent and should operate on grapheme clusters instead of codepoints.
311 static inline Optional&lt;UChar32&gt; capitalized(UChar32 baseCharacter)
312 {
313     if (U_GET_GC_MASK(baseCharacter) &amp; U_GC_M_MASK)
314         return WTF::nullopt;
315 
316     UChar32 uppercaseCharacter = u_toupper(baseCharacter);
317     ASSERT(uppercaseCharacter == baseCharacter || (U_IS_BMP(baseCharacter) == U_IS_BMP(uppercaseCharacter)));
318     if (uppercaseCharacter != baseCharacter)
319         return uppercaseCharacter;
320     return WTF::nullopt;
321 }
322 
323 static bool shouldSynthesize(bool dontSynthesizeSmallCaps, const Font* nextFont, UChar32 baseCharacter, Optional&lt;UChar32&gt; capitalizedBase, FontVariantCaps fontVariantCaps, bool engageAllSmallCapsProcessing)
324 {
325     if (dontSynthesizeSmallCaps)
326         return false;
327     if (!nextFont || nextFont == Font::systemFallback())
328         return false;
329     if (engageAllSmallCapsProcessing &amp;&amp; isASCIISpace(baseCharacter))
330         return false;
331     if (!engageAllSmallCapsProcessing &amp;&amp; !capitalizedBase)
332         return false;
333     return !nextFont-&gt;variantCapsSupportsCharacterForSynthesis(fontVariantCaps, baseCharacter);
334 }
335 
336 void ComplexTextController::collectComplexTextRuns()
337 {
338     if (!m_end)
339         return;
340 
341     // We break up glyph run generation for the string by Font.
342     const UChar* cp;
343 
344     if (m_run.is8Bit()) {
345         String stringFor8BitRun = String::make16BitFrom8BitSource(m_run.characters8(), m_run.length());
346         m_stringsFor8BitRuns.append(WTFMove(stringFor8BitRun));
347         cp = m_stringsFor8BitRuns.last().characters16();
348     } else
349         cp = m_run.characters16();
350 
351     auto fontVariantCaps = m_font.fontDescription().variantCaps();
352     bool dontSynthesizeSmallCaps = !static_cast&lt;bool&gt;(m_font.fontDescription().fontSynthesis() &amp; FontSynthesisSmallCaps);
353     bool engageAllSmallCapsProcessing = fontVariantCaps == FontVariantCaps::AllSmall || fontVariantCaps == FontVariantCaps::AllPetite;
354     bool engageSmallCapsProcessing = engageAllSmallCapsProcessing || fontVariantCaps == FontVariantCaps::Small || fontVariantCaps == FontVariantCaps::Petite;
355 
356     if (engageAllSmallCapsProcessing || engageSmallCapsProcessing)
357         m_smallCapsBuffer.resize(m_end);
358 
359     unsigned indexOfFontTransition = 0;
360     const UChar* curr = cp;
361     const UChar* end = cp + m_end;
362 
363     const Font* font;
364     const Font* nextFont;
365     const Font* synthesizedFont = nullptr;
366     const Font* smallSynthesizedFont = nullptr;
367 
368     unsigned markCount;
369     UChar32 baseCharacter;
370     if (!advanceByCombiningCharacterSequence(curr, end, baseCharacter, markCount))
371         return;
372 
373     nextFont = m_font.fontForCombiningCharacterSequence(cp, curr - cp);
374 
375     bool isSmallCaps = false;
376     bool nextIsSmallCaps = false;
377 
378     auto capitalizedBase = capitalized(baseCharacter);
379     if (shouldSynthesize(dontSynthesizeSmallCaps, nextFont, baseCharacter, capitalizedBase, fontVariantCaps, engageAllSmallCapsProcessing)) {
380         synthesizedFont = &amp;nextFont-&gt;noSynthesizableFeaturesFont();
381         smallSynthesizedFont = synthesizedFont-&gt;smallCapsFont(m_font.fontDescription());
382         UChar32 characterToWrite = capitalizedBase ? capitalizedBase.value() : cp[0];
383         unsigned characterIndex = 0;
384         U16_APPEND_UNSAFE(m_smallCapsBuffer, characterIndex, characterToWrite);
385         for (unsigned i = characterIndex; cp + i &lt; curr; ++i)
386             m_smallCapsBuffer[i] = cp[i];
387         nextIsSmallCaps = true;
388     }
389 
390     while (curr &lt; end) {
391         font = nextFont;
392         isSmallCaps = nextIsSmallCaps;
393         unsigned index = curr - cp;
394 
395         if (!advanceByCombiningCharacterSequence(curr, end, baseCharacter, markCount))
396             return;
397 
398         if (synthesizedFont) {
399             if (auto capitalizedBase = capitalized(baseCharacter)) {
400                 unsigned characterIndex = index;
401                 U16_APPEND_UNSAFE(m_smallCapsBuffer, characterIndex, capitalizedBase.value());
402                 for (unsigned i = 0; i &lt; markCount; ++i)
403                     m_smallCapsBuffer[i + characterIndex] = cp[i + characterIndex];
404                 nextIsSmallCaps = true;
405             } else {
406                 if (engageAllSmallCapsProcessing) {
407                     for (unsigned i = 0; i &lt; curr - cp - index; ++i)
408                         m_smallCapsBuffer[index + i] = cp[index + i];
409                 }
410                 nextIsSmallCaps = engageAllSmallCapsProcessing;
411             }
412         }
413 
414         if (baseCharacter == zeroWidthJoiner)
415             nextFont = font;
416         else
417             nextFont = m_font.fontForCombiningCharacterSequence(cp + index, curr - cp - index);
418 
419         capitalizedBase = capitalized(baseCharacter);
420         if (!synthesizedFont &amp;&amp; shouldSynthesize(dontSynthesizeSmallCaps, nextFont, baseCharacter, capitalizedBase, fontVariantCaps, engageAllSmallCapsProcessing)) {
421             // Rather than synthesize each character individually, we should synthesize the entire &quot;run&quot; if any character requires synthesis.
422             synthesizedFont = &amp;nextFont-&gt;noSynthesizableFeaturesFont();
423             smallSynthesizedFont = synthesizedFont-&gt;smallCapsFont(m_font.fontDescription());
424             nextIsSmallCaps = true;
425             curr = cp + indexOfFontTransition;
426             continue;
427         }
428 
429         if (nextFont != font || nextIsSmallCaps != isSmallCaps) {
430             unsigned itemLength = index - indexOfFontTransition;
431             if (itemLength) {
432                 unsigned itemStart = indexOfFontTransition;
433                 if (synthesizedFont) {
434                     if (isSmallCaps)
435                         collectComplexTextRunsForCharacters(m_smallCapsBuffer.data() + itemStart, itemLength, itemStart, smallSynthesizedFont);
436                     else
437                         collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, synthesizedFont);
438                 } else
439                     collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, font);
440                 if (nextFont != font) {
441                     synthesizedFont = nullptr;
442                     smallSynthesizedFont = nullptr;
443                     nextIsSmallCaps = false;
444                 }
445             }
446             indexOfFontTransition = index;
447         }
448     }
449 
450     ASSERT(m_end &gt;= indexOfFontTransition);
451     unsigned itemLength = m_end - indexOfFontTransition;
452     if (itemLength) {
453         unsigned itemStart = indexOfFontTransition;
454         if (synthesizedFont) {
455             if (nextIsSmallCaps)
456                 collectComplexTextRunsForCharacters(m_smallCapsBuffer.data() + itemStart, itemLength, itemStart, smallSynthesizedFont);
457             else
458                 collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, synthesizedFont);
459         } else
460             collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, nextFont);
461     }
462 
463     if (!m_run.ltr())
464         m_complexTextRuns.reverse();
465 }
466 
467 unsigned ComplexTextController::ComplexTextRun::indexAt(unsigned i) const
468 {
469     ASSERT(i &lt; m_glyphCount);
470 
471     return m_coreTextIndices[i];
472 }
473 
474 void ComplexTextController::ComplexTextRun::setIsNonMonotonic()
475 {
476     ASSERT(m_isMonotonic);
477     m_isMonotonic = false;
478 
479     Vector&lt;bool, 64&gt; mappedIndices(m_stringLength, false);
480     for (unsigned i = 0; i &lt; m_glyphCount; ++i) {
481         ASSERT(indexAt(i) &lt; m_stringLength);
482         mappedIndices[indexAt(i)] = true;
483     }
484 
485     m_glyphEndOffsets.grow(m_glyphCount);
486     for (unsigned i = 0; i &lt; m_glyphCount; ++i) {
487         unsigned nextMappedIndex = m_indexEnd;
488         for (unsigned j = indexAt(i) + 1; j &lt; m_stringLength; ++j) {
489             if (mappedIndices[j]) {
490                 nextMappedIndex = j;
491                 break;
492             }
493         }
494         m_glyphEndOffsets[i] = nextMappedIndex;
495     }
496 }
497 
498 unsigned ComplexTextController::indexOfCurrentRun(unsigned&amp; leftmostGlyph)
499 {
500     leftmostGlyph = 0;
501 
502     size_t runCount = m_complexTextRuns.size();
503     if (m_currentRun &gt;= runCount)
504         return runCount;
505 
506     if (m_isLTROnly) {
507         for (unsigned i = 0; i &lt; m_currentRun; ++i)
508             leftmostGlyph += m_complexTextRuns[i]-&gt;glyphCount();
509         return m_currentRun;
510     }
511 
512     if (m_runIndices.isEmpty()) {
513         unsigned firstRun = 0;
514         unsigned firstRunOffset = stringBegin(*m_complexTextRuns[0]);
515         for (unsigned i = 1; i &lt; runCount; ++i) {
516             unsigned offset = stringBegin(*m_complexTextRuns[i]);
517             if (offset &lt; firstRunOffset) {
518                 firstRun = i;
519                 firstRunOffset = offset;
520             }
521         }
522         m_runIndices.uncheckedAppend(firstRun);
523     }
524 
525     while (m_runIndices.size() &lt;= m_currentRun) {
526         unsigned offset = stringEnd(*m_complexTextRuns[m_runIndices.last()]);
527 
528         for (unsigned i = 0; i &lt; runCount; ++i) {
529             if (offset == stringBegin(*m_complexTextRuns[i])) {
530                 m_runIndices.uncheckedAppend(i);
531                 break;
532             }
533         }
534     }
535 
536     unsigned currentRunIndex = m_runIndices[m_currentRun];
537     leftmostGlyph = m_glyphCountFromStartToIndex[currentRunIndex];
538     return currentRunIndex;
539 }
540 
541 unsigned ComplexTextController::incrementCurrentRun(unsigned&amp; leftmostGlyph)
542 {
543     if (m_isLTROnly) {
544         leftmostGlyph += m_complexTextRuns[m_currentRun++]-&gt;glyphCount();
545         return m_currentRun;
546     }
547 
548     m_currentRun++;
549     leftmostGlyph = 0;
550     return indexOfCurrentRun(leftmostGlyph);
551 }
552 
553 float ComplexTextController::runWidthSoFarFraction(unsigned glyphStartOffset, unsigned glyphEndOffset, unsigned oldCharacterInCurrentGlyph, GlyphIterationStyle iterationStyle) const
554 {
555     // FIXME: Instead of dividing the glyph&#39;s advance equally between the characters, this
556     // could use the glyph&#39;s &quot;ligature carets&quot;. This is available in CoreText via CTFontGetLigatureCaretPositions().
557     if (glyphStartOffset == glyphEndOffset) {
558         // When there are multiple glyphs per character we need to advance by the full width of the glyph.
559         ASSERT(m_characterInCurrentGlyph == oldCharacterInCurrentGlyph);
560         return 1;
561     }
562 
563     if (iterationStyle == ByWholeGlyphs) {
564         if (!oldCharacterInCurrentGlyph)
565             return 1;
566         return 0;
567     }
568 
569     return static_cast&lt;float&gt;(m_characterInCurrentGlyph - oldCharacterInCurrentGlyph) / (glyphEndOffset - glyphStartOffset);
570 }
571 
572 void ComplexTextController::advance(unsigned offset, GlyphBuffer* glyphBuffer, GlyphIterationStyle iterationStyle, HashSet&lt;const Font*&gt;* fallbackFonts)
573 {
574     if (offset &gt; m_end)
575         offset = m_end;
576 
577     if (offset &lt;= m_currentCharacter) {
578         m_runWidthSoFar = 0;
579         m_numGlyphsSoFar = 0;
580         m_currentRun = 0;
581         m_glyphInCurrentRun = 0;
582         m_characterInCurrentGlyph = 0;
583     }
584 
585     m_currentCharacter = offset;
586 
587     size_t runCount = m_complexTextRuns.size();
588 
589     unsigned indexOfLeftmostGlyphInCurrentRun = 0; // Relative to the beginning of ComplexTextController.
590     unsigned currentRunIndex = indexOfCurrentRun(indexOfLeftmostGlyphInCurrentRun);
591     while (m_currentRun &lt; runCount) {
592         const ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[currentRunIndex];
593         bool ltr = complexTextRun.isLTR();
594         unsigned glyphCount = complexTextRun.glyphCount();
595         unsigned glyphIndexIntoCurrentRun = ltr ? m_glyphInCurrentRun : glyphCount - 1 - m_glyphInCurrentRun;
596         unsigned glyphIndexIntoComplexTextController = indexOfLeftmostGlyphInCurrentRun + glyphIndexIntoCurrentRun;
597         if (fallbackFonts &amp;&amp; &amp;complexTextRun.font() != &amp;m_font.primaryFont())
598             fallbackFonts-&gt;add(&amp;complexTextRun.font());
599 
600         // We must store the initial advance for the first glyph we are going to draw.
601         // When leftmostGlyph is 0, it represents the first glyph to draw, taking into
602         // account the text direction.
603         if (!indexOfLeftmostGlyphInCurrentRun &amp;&amp; glyphBuffer)
604             glyphBuffer-&gt;setInitialAdvance(GlyphBufferAdvance(complexTextRun.initialAdvance().width(), complexTextRun.initialAdvance().height()));
605 
606         while (m_glyphInCurrentRun &lt; glyphCount) {
607             unsigned glyphStartOffset = complexTextRun.indexAt(glyphIndexIntoCurrentRun);
608             unsigned glyphEndOffset;
609             if (complexTextRun.isMonotonic()) {
610                 if (ltr)
611                     glyphEndOffset = std::max(glyphStartOffset, glyphIndexIntoCurrentRun + 1 &lt; glyphCount ? complexTextRun.indexAt(glyphIndexIntoCurrentRun + 1) : complexTextRun.indexEnd());
612                 else
613                     glyphEndOffset = std::max(glyphStartOffset, glyphIndexIntoCurrentRun &gt; 0 ? complexTextRun.indexAt(glyphIndexIntoCurrentRun - 1) : complexTextRun.indexEnd());
614             } else
615                 glyphEndOffset = complexTextRun.endOffsetAt(glyphIndexIntoCurrentRun);
616 
617             FloatSize adjustedBaseAdvance = m_adjustedBaseAdvances[glyphIndexIntoComplexTextController];
618 
619             if (glyphStartOffset + complexTextRun.stringLocation() &gt;= m_currentCharacter)
620                 return;
621 
622             if (glyphBuffer &amp;&amp; !m_characterInCurrentGlyph) {
623                 auto currentGlyphOrigin = glyphOrigin(glyphIndexIntoComplexTextController);
624                 GlyphBufferAdvance paintAdvance(adjustedBaseAdvance);
625                 if (!glyphIndexIntoCurrentRun) {
626                     // The first layout advance of every run includes the &quot;initial layout advance.&quot; However, here, we need
627                     // paint advances, so subtract it out before transforming the layout advance into a paint advance.
628                     paintAdvance.setWidth(paintAdvance.width() - (complexTextRun.initialAdvance().width() - currentGlyphOrigin.x()));
629                     paintAdvance.setHeight(paintAdvance.height() - (complexTextRun.initialAdvance().height() - currentGlyphOrigin.y()));
630                 }
631                 paintAdvance.setWidth(paintAdvance.width() + glyphOrigin(glyphIndexIntoComplexTextController + 1).x() - currentGlyphOrigin.x());
632                 paintAdvance.setHeight(paintAdvance.height() + glyphOrigin(glyphIndexIntoComplexTextController + 1).y() - currentGlyphOrigin.y());
633                 if (glyphIndexIntoCurrentRun == glyphCount - 1 &amp;&amp; currentRunIndex + 1 &lt; runCount) {
634                     // Our paint advance points to the end of the run. However, the next run may have an
635                     // initial advance, and our paint advance needs to point to the location of the next
636                     // glyph. So, we need to add in the next run&#39;s initial advance.
637                     paintAdvance.setWidth(paintAdvance.width() - glyphOrigin(glyphIndexIntoComplexTextController + 1).x() + m_complexTextRuns[currentRunIndex + 1]-&gt;initialAdvance().width());
638                     paintAdvance.setHeight(paintAdvance.height() - glyphOrigin(glyphIndexIntoComplexTextController + 1).y() + m_complexTextRuns[currentRunIndex + 1]-&gt;initialAdvance().height());
639                 }
640                 paintAdvance.setHeight(-paintAdvance.height()); // Increasing y points down
641                 glyphBuffer-&gt;add(m_adjustedGlyphs[glyphIndexIntoComplexTextController], &amp;complexTextRun.font(), paintAdvance, complexTextRun.indexAt(m_glyphInCurrentRun));
642             }
643 
644             unsigned oldCharacterInCurrentGlyph = m_characterInCurrentGlyph;
645             m_characterInCurrentGlyph = std::min(m_currentCharacter - complexTextRun.stringLocation(), glyphEndOffset) - glyphStartOffset;
646             m_runWidthSoFar += adjustedBaseAdvance.width() * runWidthSoFarFraction(glyphStartOffset, glyphEndOffset, oldCharacterInCurrentGlyph, iterationStyle);
647 
648             if (glyphEndOffset + complexTextRun.stringLocation() &gt; m_currentCharacter)
649                 return;
650 
651             m_numGlyphsSoFar++;
652             m_glyphInCurrentRun++;
653             m_characterInCurrentGlyph = 0;
654             if (ltr) {
655                 glyphIndexIntoCurrentRun++;
656                 glyphIndexIntoComplexTextController++;
657             } else {
658                 glyphIndexIntoCurrentRun--;
659                 glyphIndexIntoComplexTextController--;
660             }
661         }
662         currentRunIndex = incrementCurrentRun(indexOfLeftmostGlyphInCurrentRun);
663         m_glyphInCurrentRun = 0;
664     }
665 }
666 
667 static inline std::pair&lt;bool, bool&gt; expansionLocation(bool ideograph, bool treatAsSpace, bool ltr, bool isAfterExpansion, bool forbidLeadingExpansion, bool forbidTrailingExpansion, bool forceLeadingExpansion, bool forceTrailingExpansion)
668 {
669     bool expandLeft = ideograph;
670     bool expandRight = ideograph;
671     if (treatAsSpace) {
672         if (ltr)
673             expandRight = true;
674         else
675             expandLeft = true;
676     }
677     if (isAfterExpansion)
678         expandLeft = false;
679     ASSERT(!forbidLeadingExpansion || !forceLeadingExpansion);
680     ASSERT(!forbidTrailingExpansion || !forceTrailingExpansion);
681     if (forbidLeadingExpansion)
682         expandLeft = false;
683     if (forbidTrailingExpansion)
684         expandRight = false;
685     if (forceLeadingExpansion)
686         expandLeft = true;
687     if (forceTrailingExpansion)
688         expandRight = true;
689     return std::make_pair(expandLeft, expandRight);
690 }
691 
692 void ComplexTextController::adjustGlyphsAndAdvances()
693 {
694     bool afterExpansion = (m_run.expansionBehavior() &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
695     size_t runCount = m_complexTextRuns.size();
696     bool hasExtraSpacing = (m_font.letterSpacing() || m_font.wordSpacing() || m_expansion) &amp;&amp; !m_run.spacingDisabled();
697     bool runForcesLeadingExpansion = (m_run.expansionBehavior() &amp; LeadingExpansionMask) == ForceLeadingExpansion;
698     bool runForcesTrailingExpansion = (m_run.expansionBehavior() &amp; TrailingExpansionMask) == ForceTrailingExpansion;
699     bool runForbidsLeadingExpansion = (m_run.expansionBehavior() &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
700     bool runForbidsTrailingExpansion = (m_run.expansionBehavior() &amp; TrailingExpansionMask) == ForbidTrailingExpansion;
701 
702     // We are iterating in glyph order, not string order. Compare this to WidthIterator::advanceInternal()
703     for (size_t runIndex = 0; runIndex &lt; runCount; ++runIndex) {
704         ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[runIndex];
705         unsigned glyphCount = complexTextRun.glyphCount();
706         const Font&amp; font = complexTextRun.font();
707 
708         if (!complexTextRun.isLTR())
709             m_isLTROnly = false;
710 
711         const CGGlyph* glyphs = complexTextRun.glyphs();
712         const FloatSize* advances = complexTextRun.baseAdvances();
713 
714         float spaceWidth = font.spaceWidth() - font.syntheticBoldOffset();
715         const UChar* cp = complexTextRun.characters();
716         FloatPoint glyphOrigin;
717         unsigned lastCharacterIndex = m_run.ltr() ? std::numeric_limits&lt;unsigned&gt;::min() : std::numeric_limits&lt;unsigned&gt;::max();
718         bool isMonotonic = true;
719 
720         for (unsigned i = 0; i &lt; glyphCount; i++) {
721             unsigned characterIndex = complexTextRun.indexAt(i);
722             if (m_run.ltr()) {
723                 if (characterIndex &lt; lastCharacterIndex)
724                     isMonotonic = false;
725             } else {
726                 if (characterIndex &gt; lastCharacterIndex)
727                     isMonotonic = false;
728             }
729             UChar ch = *(cp + characterIndex);
730 
731             bool treatAsSpace = FontCascade::treatAsSpace(ch);
732             CGGlyph glyph = treatAsSpace ? font.spaceGlyph() : glyphs[i];
733             FloatSize advance = treatAsSpace ? FloatSize(spaceWidth, advances[i].height()) : advances[i];
734 
735             if (ch == &#39;\t&#39; &amp;&amp; m_run.allowTabs())
<a name="5" id="anc5"></a><span class="line-modified">736                 advance.setWidth(m_font.tabWidth(font, m_run.tabSize(), m_run.xPos() + m_totalAdvance.width()));</span>
737             else if (FontCascade::treatAsZeroWidthSpace(ch) &amp;&amp; !treatAsSpace) {
738                 advance.setWidth(0);
739                 glyph = font.spaceGlyph();
740             }
741 
742             if (!i) {
743                 advance.expand(complexTextRun.initialAdvance().width(), complexTextRun.initialAdvance().height());
744                 if (auto* origins = complexTextRun.glyphOrigins())
745                     advance.expand(-origins[0].x(), -origins[0].y());
746             }
747 
748             advance.expand(font.syntheticBoldOffset(), 0);
749 
750             if (hasExtraSpacing) {
751                 // If we&#39;re a glyph with an advance, add in letter-spacing.
752                 // That way we weed out zero width lurkers. This behavior matches the fast text code path.
753                 if (advance.width())
754                     advance.expand(m_font.letterSpacing(), 0);
755 
756                 unsigned characterIndexInRun = characterIndex + complexTextRun.stringLocation();
757                 bool isFirstCharacter = !(characterIndex + complexTextRun.stringLocation());
758                 bool isLastCharacter = characterIndexInRun + 1 == m_run.length() || (U16_IS_LEAD(ch) &amp;&amp; characterIndexInRun + 2 == m_run.length() &amp;&amp; U16_IS_TRAIL(*(cp + characterIndex + 1)));
759 
760                 bool forceLeadingExpansion = false; // On the left, regardless of m_run.ltr()
761                 bool forceTrailingExpansion = false; // On the right, regardless of m_run.ltr()
762                 bool forbidLeadingExpansion = false;
763                 bool forbidTrailingExpansion = false;
764                 if (runForcesLeadingExpansion)
765                     forceLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
766                 if (runForcesTrailingExpansion)
767                     forceTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
768                 if (runForbidsLeadingExpansion)
769                     forbidLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
770                 if (runForbidsTrailingExpansion)
771                     forbidTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
772                 // Handle justification and word-spacing.
<a name="6" id="anc6"></a><span class="line-modified">773                 static bool expandAroundIdeographs = FontCascade::canExpandAroundIdeographsInComplexText();</span>
<span class="line-added">774                 bool ideograph = expandAroundIdeographs &amp;&amp; FontCascade::isCJKIdeographOrSymbol(ch);</span>
775                 if (treatAsSpace || ideograph || forceLeadingExpansion || forceTrailingExpansion) {
776                     // Distribute the run&#39;s total expansion evenly over all expansion opportunities in the run.
777                     if (m_expansion) {
778                         auto [expandLeft, expandRight] = expansionLocation(ideograph, treatAsSpace, m_run.ltr(), afterExpansion, forbidLeadingExpansion, forbidTrailingExpansion, forceLeadingExpansion, forceTrailingExpansion);
779                         if (expandLeft) {
780                             m_expansion -= m_expansionPerOpportunity;
781                             // Increase previous width
782                             if (m_adjustedBaseAdvances.isEmpty()) {
783                                 advance.expand(m_expansionPerOpportunity, 0);
784                                 complexTextRun.growInitialAdvanceHorizontally(m_expansionPerOpportunity);
785                             } else {
786                                 m_adjustedBaseAdvances.last().expand(m_expansionPerOpportunity, 0);
<a name="7" id="anc7"></a><span class="line-modified">787                                 m_totalAdvance.expand(m_expansionPerOpportunity, 0);</span>
788                             }
789                         }
790                         if (expandRight) {
791                             m_expansion -= m_expansionPerOpportunity;
792                             advance.expand(m_expansionPerOpportunity, 0);
793                             afterExpansion = true;
794                         }
795                     } else
796                         afterExpansion = false;
797 
798                     // Account for word-spacing.
799                     if (treatAsSpace &amp;&amp; (ch != &#39;\t&#39; || !m_run.allowTabs()) &amp;&amp; (characterIndex &gt; 0 || runIndex &gt; 0 || ch == noBreakSpace) &amp;&amp; m_font.wordSpacing())
800                         advance.expand(m_font.wordSpacing(), 0);
801                 } else
802                     afterExpansion = false;
803             }
804 
<a name="8" id="anc8"></a><span class="line-modified">805             m_totalAdvance += advance;</span>
806 
807             // FIXME: Combining marks should receive a text emphasis mark if they are combine with a space.
808             if (m_forTextEmphasis &amp;&amp; (!FontCascade::canReceiveTextEmphasis(ch) || (U_GET_GC_MASK(ch) &amp; U_GC_M_MASK)))
809                 glyph = 0;
810 
811             m_adjustedBaseAdvances.append(advance);
812             if (auto* origins = complexTextRun.glyphOrigins()) {
813                 ASSERT(m_glyphOrigins.size() &lt; m_adjustedBaseAdvances.size());
814                 m_glyphOrigins.grow(m_adjustedBaseAdvances.size());
815                 m_glyphOrigins[m_glyphOrigins.size() - 1] = origins[i];
816                 ASSERT(m_glyphOrigins.size() == m_adjustedBaseAdvances.size());
817             }
818             m_adjustedGlyphs.append(glyph);
819 
820             FloatRect glyphBounds = font.boundsForGlyph(glyph);
821             glyphBounds.move(glyphOrigin.x(), glyphOrigin.y());
822             m_minGlyphBoundingBoxX = std::min(m_minGlyphBoundingBoxX, glyphBounds.x());
823             m_maxGlyphBoundingBoxX = std::max(m_maxGlyphBoundingBoxX, glyphBounds.maxX());
824             m_minGlyphBoundingBoxY = std::min(m_minGlyphBoundingBoxY, glyphBounds.y());
825             m_maxGlyphBoundingBoxY = std::max(m_maxGlyphBoundingBoxY, glyphBounds.maxY());
826             glyphOrigin.move(advance);
827 
828             lastCharacterIndex = characterIndex;
829         }
830         if (!isMonotonic)
831             complexTextRun.setIsNonMonotonic();
832     }
833 }
834 
835 // Missing glyphs run constructor. Core Text will not generate a run of missing glyphs, instead falling back on
836 // glyphs from LastResort. We want to use the primary font&#39;s missing glyph in order to match the fast text code path.
837 ComplexTextController::ComplexTextRun::ComplexTextRun(const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
838     : m_font(font)
839     , m_characters(characters)
840     , m_stringLength(stringLength)
841     , m_indexBegin(indexBegin)
842     , m_indexEnd(indexEnd)
843     , m_stringLocation(stringLocation)
844     , m_isLTR(ltr)
845 {
846     auto runLengthInCodeUnits = m_indexEnd - m_indexBegin;
847     m_coreTextIndices.reserveInitialCapacity(runLengthInCodeUnits);
848     unsigned r = m_indexBegin;
849     while (r &lt; m_indexEnd) {
850         m_coreTextIndices.uncheckedAppend(r);
851         UChar32 character;
852         U16_NEXT(m_characters, r, m_stringLength, character);
853     }
854     m_glyphCount = m_coreTextIndices.size();
855     if (!ltr) {
856         for (unsigned r = 0, end = m_glyphCount - 1; r &lt; m_glyphCount / 2; ++r, --end)
857             std::swap(m_coreTextIndices[r], m_coreTextIndices[end]);
858     }
859 
860     // Synthesize a run of missing glyphs.
861     m_glyphs.fill(0, m_glyphCount);
862     m_baseAdvances.fill(FloatSize(m_font.widthForGlyph(0), 0), m_glyphCount);
863 }
864 
865 ComplexTextController::ComplexTextRun::ComplexTextRun(const Vector&lt;FloatSize&gt;&amp; advances, const Vector&lt;FloatPoint&gt;&amp; origins, const Vector&lt;Glyph&gt;&amp; glyphs, const Vector&lt;unsigned&gt;&amp; stringIndices, FloatSize initialAdvance, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
866     : m_baseAdvances(advances)
867     , m_glyphOrigins(origins)
868     , m_glyphs(glyphs)
869     , m_coreTextIndices(stringIndices)
870     , m_initialAdvance(initialAdvance)
871     , m_font(font)
872     , m_characters(characters)
873     , m_stringLength(stringLength)
874     , m_indexBegin(indexBegin)
875     , m_indexEnd(indexEnd)
876     , m_glyphCount(glyphs.size())
877     , m_stringLocation(stringLocation)
878     , m_isLTR(ltr)
879 {
880 }
881 
<a name="9" id="anc9"></a>

882 } // namespace WebCore
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/RuleData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012 Google Inc. All rights reserved.
 12  *
 13  * This library is free software; you can redistribute it and/or
 14  * modify it under the terms of the GNU Library General Public
 15  * License as published by the Free Software Foundation; either
 16  * version 2 of the License, or (at your option) any later version.
 17  *
 18  * This library is distributed in the hope that it will be useful,
 19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 21  * Library General Public License for more details.
 22  *
 23  * You should have received a copy of the GNU Library General Public License
 24  * along with this library; see the file COPYING.LIB.  If not, write to
 25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 26  * Boston, MA 02110-1301, USA.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;RuleData.h&quot;
 31 
 32 #include &quot;CSSFontSelector.h&quot;
 33 #include &quot;CSSKeyframesRule.h&quot;
 34 #include &quot;CSSSelector.h&quot;
 35 #include &quot;CSSSelectorList.h&quot;
 36 #include &quot;HTMLNames.h&quot;
 37 #include &quot;MediaQueryEvaluator.h&quot;
 38 #include &quot;SecurityOrigin.h&quot;
 39 #include &quot;SelectorChecker.h&quot;
 40 #include &quot;SelectorFilter.h&quot;
 41 #include &quot;StyleResolver.h&quot;
 42 #include &quot;StyleRule.h&quot;
 43 #include &quot;StyleRuleImport.h&quot;
 44 #include &quot;StyleSheetContents.h&quot;
 45 #include &quot;ViewportStyleResolver.h&quot;
 46 
 47 #if ENABLE(VIDEO_TRACK)
 48 #include &quot;TextTrackCue.h&quot;
 49 #endif
 50 
 51 namespace WebCore {
 52 namespace Style {
 53 
 54 using namespace HTMLNames;
 55 
 56 struct SameSizeAsRuleData {
 57     void* a;
 58     unsigned b;
 59     unsigned c;
 60     unsigned d[4];
 61 };
 62 
 63 COMPILE_ASSERT(sizeof(RuleData) == sizeof(SameSizeAsRuleData), RuleData_should_stay_small);
 64 
 65 static inline MatchBasedOnRuleHash computeMatchBasedOnRuleHash(const CSSSelector&amp; selector)
 66 {
 67     if (selector.tagHistory())
 68         return MatchBasedOnRuleHash::None;
 69 
 70     if (selector.match() == CSSSelector::Tag) {
 71         const QualifiedName&amp; tagQualifiedName = selector.tagQName();
 72         const AtomString&amp; selectorNamespace = tagQualifiedName.namespaceURI();
 73         if (selectorNamespace == starAtom() || selectorNamespace == xhtmlNamespaceURI) {
 74             if (tagQualifiedName == anyQName())
 75                 return MatchBasedOnRuleHash::Universal;
 76             return MatchBasedOnRuleHash::ClassC;
 77         }
 78         return MatchBasedOnRuleHash::None;
 79     }
 80     if (SelectorChecker::isCommonPseudoClassSelector(&amp;selector))
 81         return MatchBasedOnRuleHash::ClassB;
 82     if (selector.match() == CSSSelector::Id)
 83         return MatchBasedOnRuleHash::ClassA;
 84     if (selector.match() == CSSSelector::Class)
 85         return MatchBasedOnRuleHash::ClassB;
 86     return MatchBasedOnRuleHash::None;
 87 }
 88 
 89 static bool selectorCanMatchPseudoElement(const CSSSelector&amp; rootSelector)
 90 {
 91     const CSSSelector* selector = &amp;rootSelector;
 92     do {
 93         if (selector-&gt;matchesPseudoElement())
 94             return true;
 95 
 96         if (const CSSSelectorList* selectorList = selector-&gt;selectorList()) {
 97             for (const CSSSelector* subSelector = selectorList-&gt;first(); subSelector; subSelector = CSSSelectorList::next(subSelector)) {
 98                 if (selectorCanMatchPseudoElement(*subSelector))
 99                     return true;
100             }
101         }
102 
103         selector = selector-&gt;tagHistory();
104     } while (selector);
105     return false;
106 }
107 
108 static inline bool isCommonAttributeSelectorAttribute(const QualifiedName&amp; attribute)
109 {
110     // These are explicitly tested for equality in canShareStyleWithElement.
111     return attribute == typeAttr || attribute == readonlyAttr;
112 }
113 
114 static bool computeContainsUncommonAttributeSelector(const CSSSelector&amp; rootSelector, bool matchesRightmostElement = true)
115 {
116     const CSSSelector* selector = &amp;rootSelector;
117     do {
118         if (selector-&gt;isAttributeSelector()) {
119             // FIXME: considering non-rightmost simple selectors is necessary because of the style sharing of cousins.
120             // It is a primitive solution which disable a lot of style sharing on pages that rely on attributes for styling.
121             // We should investigate better ways of doing this.
122             if (!isCommonAttributeSelectorAttribute(selector-&gt;attribute()) || !matchesRightmostElement)
123                 return true;
124         }
125 
126         if (const CSSSelectorList* selectorList = selector-&gt;selectorList()) {
127             for (const CSSSelector* subSelector = selectorList-&gt;first(); subSelector; subSelector = CSSSelectorList::next(subSelector)) {
128                 if (computeContainsUncommonAttributeSelector(*subSelector, matchesRightmostElement))
129                     return true;
130             }
131         }
132 
133         if (selector-&gt;relation() != CSSSelector::Subselector)
134             matchesRightmostElement = false;
135 
136         selector = selector-&gt;tagHistory();
137     } while (selector);
138     return false;
139 }
140 
141 static inline PropertyWhitelistType determinePropertyWhitelistType(const CSSSelector* selector)
142 {
143     for (const CSSSelector* component = selector; component; component = component-&gt;tagHistory()) {
144 #if ENABLE(VIDEO_TRACK)
145         if (component-&gt;match() == CSSSelector::PseudoElement &amp;&amp; (component-&gt;pseudoElementType() == CSSSelector::PseudoElementCue || component-&gt;value() == TextTrackCue::cueShadowPseudoId()))
146             return PropertyWhitelistCue;
147 #endif
148         if (component-&gt;match() == CSSSelector::PseudoElement &amp;&amp; component-&gt;pseudoElementType() == CSSSelector::PseudoElementMarker)
149             return PropertyWhitelistMarker;
150 
151         if (const auto* selectorList = selector-&gt;selectorList()) {
152             for (const auto* subSelector = selectorList-&gt;first(); subSelector; subSelector = CSSSelectorList::next(subSelector)) {
153                 auto whitelistType = determinePropertyWhitelistType(subSelector);
154                 if (whitelistType != PropertyWhitelistNone)
155                     return whitelistType;
156             }
157         }
158     }
159     return PropertyWhitelistNone;
160 }
161 
162 RuleData::RuleData(const StyleRule&amp; styleRule, unsigned selectorIndex, unsigned selectorListIndex, unsigned position)
163     : m_styleRule(&amp;styleRule)
164     , m_selectorIndex(selectorIndex)
165     , m_selectorListIndex(selectorListIndex)
166     , m_position(position)
167     , m_matchBasedOnRuleHash(static_cast&lt;unsigned&gt;(computeMatchBasedOnRuleHash(*selector())))
168     , m_canMatchPseudoElement(selectorCanMatchPseudoElement(*selector()))
169     , m_containsUncommonAttributeSelector(computeContainsUncommonAttributeSelector(*selector()))
170     , m_linkMatchType(SelectorChecker::determineLinkMatchType(selector()))
171     , m_propertyWhitelistType(determinePropertyWhitelistType(selector()))
172     , m_isEnabled(true)
173     , m_descendantSelectorIdentifierHashes(SelectorFilter::collectHashes(*selector()))
174 {
175     ASSERT(m_position == position);
176     ASSERT(m_selectorIndex == selectorIndex);
177 }
178 
179 } // namespace Style
180 } // namespace WebCore
    </pre>
  </body>
</html>
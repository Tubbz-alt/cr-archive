<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/FastBitVector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FastBitVector.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/FastBitVector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,11 ***</span>
  
  namespace WTF {
  
  class PrintStream;
  
<span class="line-modified">! inline size_t fastBitVectorArrayLength(size_t numBits) { return (numBits + 31) / 32; }</span>
  
  class FastBitVectorWordView {
      WTF_MAKE_FAST_ALLOCATED;
  public:
      typedef FastBitVectorWordView ViewType;
<span class="line-new-header">--- 33,13 ---</span>
  
  namespace WTF {
  
  class PrintStream;
  
<span class="line-modified">! DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(FastBitVector);</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline constexpr size_t fastBitVectorArrayLength(size_t numBits) { return (numBits + 31) / 32; }</span>
  
  class FastBitVectorWordView {
      WTF_MAKE_FAST_ALLOCATED;
  public:
      typedef FastBitVectorWordView ViewType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,11 ***</span>
      }
  
      ~FastBitVectorWordOwner()
      {
          if (m_words)
<span class="line-modified">!             fastFree(m_words);</span>
      }
  
      FastBitVectorWordView view() const { return FastBitVectorWordView(m_words, m_numBits); }
  
      FastBitVectorWordOwner&amp; operator=(const FastBitVectorWordOwner&amp; other)
<span class="line-new-header">--- 87,11 ---</span>
      }
  
      ~FastBitVectorWordOwner()
      {
          if (m_words)
<span class="line-modified">!             FastBitVectorMalloc::free(m_words);</span>
      }
  
      FastBitVectorWordView view() const { return FastBitVectorWordView(m_words, m_numBits); }
  
      FastBitVectorWordOwner&amp; operator=(const FastBitVectorWordOwner&amp; other)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,10 ***</span>
<span class="line-new-header">--- 422,13 ---</span>
              out.print((*this)[i] ? &quot;1&quot; : &quot;-&quot;);
      }
  
      typename Words::ViewType wordView() const { return m_words.view(); }
  
<span class="line-added">+     Words&amp; unsafeWords() { return m_words; }</span>
<span class="line-added">+     const Words&amp; unsafeWords() const { return m_words; }</span>
<span class="line-added">+ </span>
  private:
      // You&#39;d think that we could remove this friend if we used protected, but you&#39;d be wrong,
      // because templates.
      friend class FastBitVector;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,10 ***</span>
<span class="line-new-header">--- 439,45 ---</span>
      }
  
      Words m_words;
  };
  
<span class="line-added">+ class FastBitReference {</span>
<span class="line-added">+     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     FastBitReference() = default;</span>
<span class="line-added">+ </span>
<span class="line-added">+     FastBitReference(uint32_t* word, uint32_t mask)</span>
<span class="line-added">+         : m_word(word)</span>
<span class="line-added">+         , m_mask(mask)</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     operator bool() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return !!(*m_word &amp; m_mask);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     FastBitReference&amp; operator=(bool value)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (value)</span>
<span class="line-added">+             *m_word |= m_mask;</span>
<span class="line-added">+         else</span>
<span class="line-added">+             *m_word &amp;= ~m_mask;</span>
<span class="line-added">+         return *this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     FastBitReference&amp; operator|=(bool value) { return value ? *this = value : *this; }</span>
<span class="line-added">+     FastBitReference&amp; operator&amp;=(bool value) { return value ? *this : *this = value; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     uint32_t* m_word { nullptr };</span>
<span class="line-added">+     uint32_t m_mask { 0 };</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  class FastBitVector : public FastBitVectorImpl&lt;FastBitVectorWordOwner&gt; {
  public:
      FastBitVector() { }
  
      FastBitVector(const FastBitVector&amp;) = default;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 473,10 ***</span>
<span class="line-new-header">--- 513,14 ---</span>
      void clearAll()
      {
          m_words.clearAll();
      }
  
<span class="line-added">+     // For templating as Vector&lt;bool&gt;</span>
<span class="line-added">+     void fill(bool value) { value ? setAll() : clearAll(); }</span>
<span class="line-added">+     void grow(size_t newSize) { resize(newSize); }</span>
<span class="line-added">+ </span>
      WTF_EXPORT_PRIVATE void clearRange(size_t begin, size_t end);
  
      // Returns true if the contents of this bitvector changed.
      template&lt;typename OtherWords&gt;
      bool setAndCheck(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 516,46 ***</span>
      bool operator[](size_t index) const
      {
          return atImpl(index);
      }
  
<span class="line-modified">!     class BitReference {</span>
<span class="line-removed">-     public:</span>
<span class="line-removed">-         BitReference() { }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         BitReference(uint32_t* word, uint32_t mask)</span>
<span class="line-removed">-             : m_word(word)</span>
<span class="line-removed">-             , m_mask(mask)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         explicit operator bool() const</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             return !!(*m_word &amp; m_mask);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         BitReference&amp; operator=(bool value)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (value)</span>
<span class="line-removed">-                 *m_word |= m_mask;</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 *m_word &amp;= ~m_mask;</span>
<span class="line-removed">-             return *this;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private:</span>
<span class="line-removed">-         uint32_t* m_word { nullptr };</span>
<span class="line-removed">-         uint32_t m_mask { 0 };</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     BitReference at(size_t index)</span>
      {
          ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
<span class="line-modified">!         return BitReference(&amp;m_words.word(index &gt;&gt; 5), 1 &lt;&lt; (index &amp; 31));</span>
      }
  
<span class="line-modified">!     BitReference operator[](size_t index)</span>
      {
          return at(index);
      }
  
      // Returns true if the contents changed.
<span class="line-new-header">--- 560,17 ---</span>
      bool operator[](size_t index) const
      {
          return atImpl(index);
      }
  
<span class="line-modified">!     FastBitReference at(size_t index)</span>
      {
          ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
<span class="line-modified">!         return FastBitReference(&amp;m_words.word(index &gt;&gt; 5), 1 &lt;&lt; (index &amp; 31));</span>
      }
  
<span class="line-modified">!     FastBitReference operator[](size_t index)</span>
      {
          return at(index);
      }
  
      // Returns true if the contents changed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 581,6 ***</span>
<span class="line-new-header">--- 596,7 ---</span>
      }
  };
  
  } // namespace WTF
  
<span class="line-added">+ using WTF::FastBitReference;</span>
  using WTF::FastBitVector;
</pre>
<center><a href="FastBitVector.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
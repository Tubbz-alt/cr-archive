<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;SecurityOriginData.h&quot;
 32 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 33 #include &lt;wtf/text/WTFString.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 class SecurityOrigin : public ThreadSafeRefCounted&lt;SecurityOrigin&gt; {
 38 public:
 39     enum Policy {
 40         AlwaysDeny = 0,
 41         AlwaysAllow,
 42         Ask
 43     };
 44 
 45     enum StorageBlockingPolicy {
 46         AllowAllStorage = 0,
 47         BlockThirdPartyStorage,
 48         BlockAllStorage
 49     };
 50 
 51     WEBCORE_EXPORT static Ref&lt;SecurityOrigin&gt; create(const URL&amp;);
 52     WEBCORE_EXPORT static Ref&lt;SecurityOrigin&gt; createUnique();
 53 
 54     WEBCORE_EXPORT static Ref&lt;SecurityOrigin&gt; createFromString(const String&amp;);
 55     WEBCORE_EXPORT static Ref&lt;SecurityOrigin&gt; create(const String&amp; protocol, const String&amp; host, Optional&lt;uint16_t&gt; port);
 56 
 57     // QuickLook documents are in non-local origins even when loaded from file: URLs. They need to
 58     // be allowed to display their own file: URLs in order to perform reloads and same-document
 59     // navigations. This lets those documents specify the file path that should be allowed to be
 60     // displayed from their non-local origin.
 61     static Ref&lt;SecurityOrigin&gt; createNonLocalWithAllowedFilePath(const URL&amp;, const String&amp; filePath);
 62 
 63     // Some URL schemes use nested URLs for their security context. For example,
 64     // filesystem URLs look like the following:
 65     //
 66     //   filesystem:http://example.com/temporary/path/to/file.png
 67     //
 68     // We&#39;re supposed to use &quot;http://example.com&quot; as the origin.
 69     //
 70     // Generally, we add URL schemes to this list when WebKit support them. For
 71     // example, we don&#39;t include the &quot;jar&quot; scheme, even though Firefox
 72     // understands that &quot;jar&quot; uses an inner URL for it&#39;s security origin.
 73     static bool shouldUseInnerURL(const URL&amp;);
 74     static URL extractInnerURL(const URL&amp;);
 75 
 76     // Create a deep copy of this SecurityOrigin. This method is useful
 77     // when marshalling a SecurityOrigin to another thread.
 78     WEBCORE_EXPORT Ref&lt;SecurityOrigin&gt; isolatedCopy() const;
 79 
 80     // Set the domain property of this security origin to newDomain. This
 81     // function does not check whether newDomain is a suffix of the current
 82     // domain. The caller is responsible for validating newDomain.
 83     void setDomainFromDOM(const String&amp; newDomain);
 84     bool domainWasSetInDOM() const { return m_domainWasSetInDOM; }
 85 
 86     const String&amp; protocol() const { return m_data.protocol; }
 87     const String&amp; host() const { return m_data.host; }
 88     const String&amp; domain() const { return m_domain; }
 89     Optional&lt;uint16_t&gt; port() const { return m_data.port; }
 90 
 91     static bool shouldIgnoreHost(const URL&amp;);
 92 
 93     // Returns true if a given URL is secure, based either directly on its
 94     // own protocol, or, when relevant, on the protocol of its &quot;inner URL&quot;
 95     // Protocols like blob: and filesystem: fall into this latter category.
 96     static bool isSecure(const URL&amp;);
 97 
 98     // Returns true if this SecurityOrigin can script objects in the given
 99     // SecurityOrigin. For example, call this function before allowing
100     // script from one security origin to read or write objects from
101     // another SecurityOrigin.
102     WEBCORE_EXPORT bool canAccess(const SecurityOrigin&amp;) const;
103 
104     // Returns true if this SecurityOrigin can read content retrieved from
105     // the given URL. For example, call this function before issuing
106     // XMLHttpRequests.
107     WEBCORE_EXPORT bool canRequest(const URL&amp;) const;
108 
109     // Returns true if this SecurityOrigin can receive drag content from the
110     // initiator. For example, call this function before allowing content to be
111     // dropped onto a target.
112     bool canReceiveDragData(const SecurityOrigin&amp; dragInitiator) const;
113 
114     // Returns true if |document| can display content from the given URL (e.g.,
115     // in an iframe or as an image). For example, web sites generally cannot
116     // display content from the user&#39;s files system.
117     WEBCORE_EXPORT bool canDisplay(const URL&amp;) const;
118 
119     // Returns true if this SecurityOrigin can load local resources, such
120     // as images, iframes, and style sheets, and can link to local URLs.
121     // For example, call this function before creating an iframe to a
122     // file:// URL.
123     //
124     // Note: A SecurityOrigin might be allowed to load local resources
125     //       without being able to issue an XMLHttpRequest for a local URL.
126     //       To determine whether the SecurityOrigin can issue an
127     //       XMLHttpRequest for a URL, call canRequest(url).
128     bool canLoadLocalResources() const { return m_canLoadLocalResources; }
129 
130     // Explicitly grant the ability to load local resources to this
131     // SecurityOrigin.
132     //
133     // Note: This method exists only to support backwards compatibility
134     //       with older versions of WebKit.
135     void grantLoadLocalResources();
136 
137     // Explicitly grant the ability to access very other SecurityOrigin.
138     //
139     // WARNING: This is an extremely powerful ability. Use with caution!
140     void grantUniversalAccess();
141     bool hasUniversalAccess() const { return m_universalAccess; }
142 
143     void setStorageBlockingPolicy(StorageBlockingPolicy policy) { m_storageBlockingPolicy = policy; }
144 
145     void grantStorageAccessFromFileURLsQuirk();
146     bool needsStorageAccessFromFileURLsQuirk() const { return m_needsStorageAccessFromFileURLsQuirk; }
147 
148     WEBCORE_EXPORT String domainForCachePartition() const;
149 
150     bool canAccessDatabase(const SecurityOrigin&amp; topOrigin) const { return canAccessStorage(&amp;topOrigin); };
151     bool canAccessSessionStorage(const SecurityOrigin&amp; topOrigin) const { return canAccessStorage(&amp;topOrigin, AlwaysAllowFromThirdParty); }
152     bool canAccessLocalStorage(const SecurityOrigin* topOrigin) const { return canAccessStorage(topOrigin); };
153     bool canAccessPluginStorage(const SecurityOrigin&amp; topOrigin) const { return canAccessStorage(&amp;topOrigin); }
154     bool canAccessApplicationCache(const SecurityOrigin&amp; topOrigin) const { return canAccessStorage(&amp;topOrigin); }
155     bool canAccessCookies() const { return !isUnique(); }
156     bool canRequestGeolocation() const { return !isUnique(); }
157     Policy canShowNotifications() const;
158 
159     // The local SecurityOrigin is the most privileged SecurityOrigin.
160     // The local SecurityOrigin can script any document, navigate to local
161     // resources, and can set arbitrary headers on XMLHttpRequests.
162     bool isLocal() const { return m_isLocal; }
163 
164     // The origin is a globally unique identifier assigned when the Document is
165     // created. http://www.whatwg.org/specs/web-apps/current-work/#sandboxOrigin
166     //
167     // There&#39;s a subtle difference between a unique origin and an origin that
168     // has the SandboxOrigin flag set. The latter implies the former, and, in
169     // addition, the SandboxOrigin flag is inherited by iframes.
170     bool isUnique() const { return m_isUnique; }
171 
172     // Marks a file:// origin as being in a domain defined by its path.
173     // FIXME 81578: The naming of this is confusing. Files with restricted access to other local files
174     // still can have other privileges that can be remembered, thereby not making them unique.
175     void setEnforcesFilePathSeparation();
176     bool enforcesFilePathSeparation() const { return m_enforcesFilePathSeparation; }
177 
178     // Convert this SecurityOrigin into a string. The string
179     // representation of a SecurityOrigin is similar to a URL, except it
180     // lacks a path component. The string representation does not encode
181     // the value of the SecurityOrigin&#39;s domain property.
182     //
183     // When using the string value, it&#39;s important to remember that it might be
184     // &quot;null&quot;. This happens when this SecurityOrigin is unique. For example,
185     // this SecurityOrigin might have come from a sandboxed iframe, the
186     // SecurityOrigin might be empty, or we might have explicitly decided that
187     // we shouldTreatURLSchemeAsNoAccess.
188     WEBCORE_EXPORT String toString() const;
189 
190     // Similar to toString(), but does not take into account any factors that
191     // could make the string return &quot;null&quot;.
192     WEBCORE_EXPORT String toRawString() const;
193 
194     // This method checks for equality between SecurityOrigins, not whether
195     // one origin can access another. It is used for hash table keys.
196     // For access checks, use canAccess().
197     // FIXME: If this method is really only useful for hash table keys, it
198     // should be refactored into SecurityOriginHash.
199     WEBCORE_EXPORT bool equal(const SecurityOrigin*) const;
200 
201     // This method checks for equality, ignoring the value of document.domain
202     // (and whether it was set) but considering the host. It is used for postMessage.
203     WEBCORE_EXPORT bool isSameSchemeHostPort(const SecurityOrigin&amp;) const;
204 
205     // This method implements the &quot;same origin&quot; algorithm from the HTML Standard:
206     // https://html.spec.whatwg.org/multipage/browsers.html#same-origin
207     WEBCORE_EXPORT bool isSameOriginAs(const SecurityOrigin&amp;) const;
208 
209     // This method implements the &quot;is a registrable domain suffix of or is equal to&quot; algorithm from the HTML Standard:
210     // https://html.spec.whatwg.org/multipage/origin.html#is-a-registrable-domain-suffix-of-or-is-equal-to
211     WEBCORE_EXPORT bool isMatchingRegistrableDomainSuffix(const String&amp;, bool treatIPAddressAsDomain = false) const;
212 
213     bool isPotentiallyTrustworthy() const { return m_isPotentiallyTrustworthy; }
214     void setIsPotentiallyTrustworthy(bool value) { m_isPotentiallyTrustworthy = value; }
215 
216     WEBCORE_EXPORT static bool isLocalHostOrLoopbackIPAddress(StringView);
217 
218     const SecurityOriginData&amp; data() const { return m_data; }
219 
220     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
221     template&lt;class Decoder&gt; static RefPtr&lt;SecurityOrigin&gt; decode(Decoder&amp;);
222 
223 private:
224     SecurityOrigin();
225     explicit SecurityOrigin(const URL&amp;);
226     explicit SecurityOrigin(const SecurityOrigin*);
227 
228     // FIXME: Rename this function to something more semantic.
229     bool passesFileCheck(const SecurityOrigin&amp;) const;
230 
231     // This method checks that the scheme for this origin is an HTTP-family
232     // scheme, e.g. HTTP and HTTPS.
233     bool isHTTPFamily() const { return m_data.protocol == &quot;http&quot; || m_data.protocol == &quot;https&quot;; }
234 
235     enum ShouldAllowFromThirdParty { AlwaysAllowFromThirdParty, MaybeAllowFromThirdParty };
236     WEBCORE_EXPORT bool canAccessStorage(const SecurityOrigin*, ShouldAllowFromThirdParty = MaybeAllowFromThirdParty) const;
237 
238     SecurityOriginData m_data;
239     String m_domain;
240     String m_filePath;
241     bool m_isUnique { false };
242     bool m_universalAccess { false };
243     bool m_domainWasSetInDOM { false };
244     bool m_canLoadLocalResources { false };
245     StorageBlockingPolicy m_storageBlockingPolicy { AllowAllStorage };
246     bool m_enforcesFilePathSeparation { false };
247     bool m_needsStorageAccessFromFileURLsQuirk { false };
248     bool m_isPotentiallyTrustworthy { false };
249     bool m_isLocal { false };
250 };
251 
252 bool shouldTreatAsPotentiallyTrustworthy(const URL&amp;);
253 
254 // Returns true if the Origin header values serialized from these two origins would be the same.
255 bool serializedOriginsMatch(const SecurityOrigin&amp;, const SecurityOrigin&amp;);
256 bool serializedOriginsMatch(const SecurityOrigin*, const SecurityOrigin*);
257 
258 template&lt;class Encoder&gt; inline void SecurityOrigin::encode(Encoder&amp; encoder) const
259 {
260     encoder &lt;&lt; m_data;
261     encoder &lt;&lt; m_domain;
262     encoder &lt;&lt; m_filePath;
263     encoder &lt;&lt; m_isUnique;
264     encoder &lt;&lt; m_universalAccess;
265     encoder &lt;&lt; m_domainWasSetInDOM;
266     encoder &lt;&lt; m_canLoadLocalResources;
267     encoder.encodeEnum(m_storageBlockingPolicy);
268     encoder &lt;&lt; m_enforcesFilePathSeparation;
269     encoder &lt;&lt; m_needsStorageAccessFromFileURLsQuirk;
270     encoder &lt;&lt; m_isPotentiallyTrustworthy;
271     encoder &lt;&lt; m_isLocal;
272 }
273 
274 template&lt;class Decoder&gt; inline RefPtr&lt;SecurityOrigin&gt; SecurityOrigin::decode(Decoder&amp; decoder)
275 {
276     Optional&lt;SecurityOriginData&gt; data;
277     decoder &gt;&gt; data;
278     if (!data)
279         return nullptr;
280 
281     auto origin = SecurityOrigin::create(data-&gt;protocol, data-&gt;host, data-&gt;port);
282 
283     if (!decoder.decode(origin-&gt;m_domain))
284         return nullptr;
285     if (!decoder.decode(origin-&gt;m_filePath))
286         return nullptr;
287     if (!decoder.decode(origin-&gt;m_isUnique))
288         return nullptr;
289     if (!decoder.decode(origin-&gt;m_universalAccess))
290         return nullptr;
291     if (!decoder.decode(origin-&gt;m_domainWasSetInDOM))
292         return nullptr;
293     if (!decoder.decode(origin-&gt;m_canLoadLocalResources))
294         return nullptr;
295     if (!decoder.decodeEnum(origin-&gt;m_storageBlockingPolicy))
296         return nullptr;
297     if (!decoder.decode(origin-&gt;m_enforcesFilePathSeparation))
298         return nullptr;
299     if (!decoder.decode(origin-&gt;m_needsStorageAccessFromFileURLsQuirk))
300         return nullptr;
301     if (!decoder.decode(origin-&gt;m_isPotentiallyTrustworthy))
302         return nullptr;
303     if (!decoder.decode(origin-&gt;m_isLocal))
304         return nullptr;
305 
306     return origin;
307 }
308 
309 } // namespace WebCore
    </pre>
  </body>
</html>
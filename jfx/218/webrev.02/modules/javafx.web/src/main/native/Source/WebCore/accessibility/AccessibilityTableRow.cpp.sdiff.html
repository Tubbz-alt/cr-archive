<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityTableRow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityTableColumn.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityTableRow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityTableRow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93 
 94 AccessibilityTable* AccessibilityTableRow::parentTable() const
 95 {
 96     // The parent table might not be the direct ancestor of the row unfortunately. ARIA states that role=&quot;grid&quot; should
 97     // only have &quot;row&quot; elements, but if not, we still should handle it gracefully by finding the right table.
 98     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
 99         // If this is a non-anonymous table object, but not an accessibility table, we should stop because we don&#39;t want to
100         // choose another ancestor table as this row&#39;s table.
101         if (is&lt;AccessibilityTable&gt;(*parent)) {
102             auto&amp; parentTable = downcast&lt;AccessibilityTable&gt;(*parent);
103             if (parentTable.isExposableThroughAccessibility())
104                 return &amp;parentTable;
105             if (parentTable.node())
106                 break;
107         }
108     }
109 
110     return nullptr;
111 }
112 
<span class="line-modified">113 AccessibilityObject* AccessibilityTableRow::headerObject()</span>
114 {
115     if (!m_renderer || !m_renderer-&gt;isTableRow())
116         return nullptr;
117 
118     const auto&amp; rowChildren = children();
119     if (!rowChildren.size())
120         return nullptr;
121 
122     // check the first element in the row to see if it is a TH element
<span class="line-modified">123     AccessibilityObject* cell = rowChildren[0].get();</span>
124     if (!is&lt;AccessibilityTableCell&gt;(*cell))
125         return nullptr;
126 
127     RenderObject* cellRenderer = downcast&lt;AccessibilityTableCell&gt;(*cell).renderer();
128     if (!cellRenderer)
129         return nullptr;
130 
131     Node* cellNode = cellRenderer-&gt;node();
132     if (!cellNode || !cellNode-&gt;hasTagName(thTag))
133         return nullptr;
134 
135     // Verify that the row header is not part of an entire row of headers.
136     // In that case, it is unlikely this is a row header.
137     bool allHeadersInRow = true;
138     for (const auto&amp; cell : rowChildren) {
139         if (cell-&gt;node() &amp;&amp; !cell-&gt;node()-&gt;hasTagName(thTag)) {
140             allHeadersInRow = false;
141             break;
142         }
143     }
</pre>
</td>
<td>
<hr />
<pre>
 93 
 94 AccessibilityTable* AccessibilityTableRow::parentTable() const
 95 {
 96     // The parent table might not be the direct ancestor of the row unfortunately. ARIA states that role=&quot;grid&quot; should
 97     // only have &quot;row&quot; elements, but if not, we still should handle it gracefully by finding the right table.
 98     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
 99         // If this is a non-anonymous table object, but not an accessibility table, we should stop because we don&#39;t want to
100         // choose another ancestor table as this row&#39;s table.
101         if (is&lt;AccessibilityTable&gt;(*parent)) {
102             auto&amp; parentTable = downcast&lt;AccessibilityTable&gt;(*parent);
103             if (parentTable.isExposableThroughAccessibility())
104                 return &amp;parentTable;
105             if (parentTable.node())
106                 break;
107         }
108     }
109 
110     return nullptr;
111 }
112 
<span class="line-modified">113 AXCoreObject* AccessibilityTableRow::headerObject()</span>
114 {
115     if (!m_renderer || !m_renderer-&gt;isTableRow())
116         return nullptr;
117 
118     const auto&amp; rowChildren = children();
119     if (!rowChildren.size())
120         return nullptr;
121 
122     // check the first element in the row to see if it is a TH element
<span class="line-modified">123     AXCoreObject* cell = rowChildren[0].get();</span>
124     if (!is&lt;AccessibilityTableCell&gt;(*cell))
125         return nullptr;
126 
127     RenderObject* cellRenderer = downcast&lt;AccessibilityTableCell&gt;(*cell).renderer();
128     if (!cellRenderer)
129         return nullptr;
130 
131     Node* cellNode = cellRenderer-&gt;node();
132     if (!cellNode || !cellNode-&gt;hasTagName(thTag))
133         return nullptr;
134 
135     // Verify that the row header is not part of an entire row of headers.
136     // In that case, it is unlikely this is a row header.
137     bool allHeadersInRow = true;
138     for (const auto&amp; cell : rowChildren) {
139         if (cell-&gt;node() &amp;&amp; !cell-&gt;node()-&gt;hasTagName(thTag)) {
140             allHeadersInRow = false;
141             break;
142         }
143     }
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityTableColumn.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityTableRow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
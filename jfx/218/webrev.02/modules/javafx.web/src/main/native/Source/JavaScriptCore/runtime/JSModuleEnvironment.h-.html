<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleEnvironment.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;JSLexicalEnvironment.h&quot;
 32 
 33 namespace JSC {
 34 
 35 class AbstractModuleRecord;
 36 class Register;
 37 
 38 class JSModuleEnvironment final : public JSLexicalEnvironment {
 39     friend class JIT;
 40     friend class LLIntOffsetsExtractor;
 41 public:
 42     using Base = JSLexicalEnvironment;
 43     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | OverridesGetPropertyNames;
 44 
 45     static JSModuleEnvironment* create(VM&amp;, Structure*, JSScope*, SymbolTable*, JSValue initialValue, AbstractModuleRecord*);
 46 
 47     static JSModuleEnvironment* create(VM&amp; vm, JSGlobalObject* globalObject, JSScope* currentScope, SymbolTable* symbolTable, JSValue initialValue, AbstractModuleRecord* moduleRecord)
 48     {
 49         Structure* structure = globalObject-&gt;moduleEnvironmentStructure();
 50         return create(vm, structure, currentScope, symbolTable, initialValue, moduleRecord);
 51     }
 52 
 53     DECLARE_INFO;
 54 
 55     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
 56     {
 57         return Structure::create(vm, globalObject, jsNull(), TypeInfo(ModuleEnvironmentType, StructureFlags), info());
 58     }
 59 
 60     static size_t offsetOfModuleRecord(SymbolTable* symbolTable)
 61     {
 62         size_t offset = Base::allocationSize(symbolTable);
 63         ASSERT(WTF::roundUpToMultipleOf&lt;sizeof(WriteBarrier&lt;AbstractModuleRecord&gt;)&gt;(offset) == offset);
 64         return offset;
 65     }
 66 
 67     static size_t allocationSize(SymbolTable* symbolTable)
 68     {
 69         return offsetOfModuleRecord(symbolTable) + sizeof(WriteBarrier&lt;AbstractModuleRecord&gt;);
 70     }
 71 
 72     AbstractModuleRecord* moduleRecord()
 73     {
 74         return moduleRecordSlot().get();
 75     }
 76 
 77     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);
 78     static void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);
 79     static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 80     static bool deleteProperty(JSCell*, ExecState*, PropertyName);
 81 
 82 private:
 83     JSModuleEnvironment(VM&amp;, Structure*, JSScope*, SymbolTable*);
 84 
 85     void finishCreation(VM&amp;, JSValue initialValue, AbstractModuleRecord*);
 86 
 87     WriteBarrierBase&lt;AbstractModuleRecord&gt;&amp; moduleRecordSlot()
 88     {
 89         return *bitwise_cast&lt;WriteBarrierBase&lt;AbstractModuleRecord&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + offsetOfModuleRecord(symbolTable()));
 90     }
 91 
 92     static void visitChildren(JSCell*, SlotVisitor&amp;);
 93 };
 94 
 95 inline JSModuleEnvironment::JSModuleEnvironment(VM&amp; vm, Structure* structure, JSScope* currentScope, SymbolTable* symbolTable)
 96     : Base(vm, structure, currentScope, symbolTable)
 97 {
 98 }
 99 
100 } // namespace JSC
    </pre>
  </body>
</html>
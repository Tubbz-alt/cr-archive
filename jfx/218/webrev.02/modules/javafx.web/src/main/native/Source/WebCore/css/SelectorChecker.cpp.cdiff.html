<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/SelectorChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGCSSComputedStyleDeclaration.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorChecker.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/SelectorChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 266,11 ***</span>
  SelectorChecker::MatchResult SelectorChecker::matchRecursively(CheckingContext&amp; checkingContext, const LocalContext&amp; context, PseudoIdSet&amp; dynamicPseudoIdSet, unsigned&amp; specificity) const
  {
      MatchType matchType = MatchType::Element;
  
      // The first selector has to match.
<span class="line-modified">!     if (!checkOne(checkingContext, context, dynamicPseudoIdSet, matchType, specificity))</span>
          return MatchResult::fails(Match::SelectorFailsLocally);
  
      if (context.selector-&gt;match() == CSSSelector::PseudoElement) {
          if (context.selector-&gt;isCustomPseudoElement()) {
              // In functional pseudo class, custom pseudo elements are always disabled.
<span class="line-new-header">--- 266,11 ---</span>
  SelectorChecker::MatchResult SelectorChecker::matchRecursively(CheckingContext&amp; checkingContext, const LocalContext&amp; context, PseudoIdSet&amp; dynamicPseudoIdSet, unsigned&amp; specificity) const
  {
      MatchType matchType = MatchType::Element;
  
      // The first selector has to match.
<span class="line-modified">!     if (!checkOne(checkingContext, context, matchType, specificity))</span>
          return MatchResult::fails(Match::SelectorFailsLocally);
  
      if (context.selector-&gt;match() == CSSSelector::PseudoElement) {
          if (context.selector-&gt;isCustomPseudoElement()) {
              // In functional pseudo class, custom pseudo elements are always disabled.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,12 ***</span>
          // Disable :visited matching when we try to match anything else than an ancestors.
          if (!context.selector-&gt;hasDescendantOrChildRelation())
              nextContext.visitedMatchType = VisitedMatchType::Disabled;
  
          nextContext.pseudoId = PseudoId::None;
          // Virtual pseudo element is only effective in the rightmost fragment.
<span class="line-modified">!         nextContext.pseudoElementEffective = false;</span>
          nextContext.isMatchElement = false;
      }
  
      switch (relation) {
      case CSSSelector::DescendantSpace:
<span class="line-new-header">--- 318,17 ---</span>
          // Disable :visited matching when we try to match anything else than an ancestors.
          if (!context.selector-&gt;hasDescendantOrChildRelation())
              nextContext.visitedMatchType = VisitedMatchType::Disabled;
  
          nextContext.pseudoId = PseudoId::None;
<span class="line-added">+ </span>
<span class="line-added">+         bool nextIsPart = leftSelector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; leftSelector-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-added">+         bool allowMultiplePseudoElements = relation == CSSSelector::ShadowDescendant &amp;&amp; nextIsPart;</span>
          // Virtual pseudo element is only effective in the rightmost fragment.
<span class="line-modified">!         if (!allowMultiplePseudoElements)</span>
<span class="line-added">+             nextContext.pseudoElementEffective = false;</span>
<span class="line-added">+ </span>
          nextContext.isMatchElement = false;
      }
  
      switch (relation) {
      case CSSSelector::DescendantSpace:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,14 ***</span>
  
              return MatchResult::updateWithMatchType(result, matchType);
          }
      case CSSSelector::ShadowDescendant:
          {
<span class="line-modified">!             Element* shadowHostNode = context.element-&gt;shadowHost();</span>
<span class="line-modified">!             if (!shadowHostNode)</span>
                  return MatchResult::fails(Match::SelectorFailsCompletely);
<span class="line-modified">!             nextContext.element = shadowHostNode;</span>
              nextContext.firstSelectorOfTheFragment = nextContext.selector;
              nextContext.isSubjectOrAdjacentElement = false;
              PseudoIdSet ignoreDynamicPseudo;
              unsigned shadowDescendantSpecificity = 0;
              MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, shadowDescendantSpecificity);
<span class="line-new-header">--- 432,16 ---</span>
  
              return MatchResult::updateWithMatchType(result, matchType);
          }
      case CSSSelector::ShadowDescendant:
          {
<span class="line-modified">!             // When matching foo::part(bar) we skip directly to the tree of element &#39;foo&#39;.</span>
<span class="line-modified">!             bool isPart = context.selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; context.selector-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-added">+             auto* shadowHost = isPart ? checkingContext.shadowHostInPartRuleScope : context.element-&gt;shadowHost();</span>
<span class="line-added">+             if (!shadowHost)</span>
                  return MatchResult::fails(Match::SelectorFailsCompletely);
<span class="line-modified">!             nextContext.element = shadowHost;</span>
              nextContext.firstSelectorOfTheFragment = nextContext.selector;
              nextContext.isSubjectOrAdjacentElement = false;
              PseudoIdSet ignoreDynamicPseudo;
              unsigned shadowDescendantSpecificity = 0;
              MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, shadowDescendantSpecificity);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 642,11 ***</span>
          return false;
      const AtomString&amp; namespaceURI = tagQName.namespaceURI();
      return namespaceURI == starAtom() || namespaceURI == element.namespaceURI();
  }
  
<span class="line-modified">! bool SelectorChecker::checkOne(CheckingContext&amp; checkingContext, const LocalContext&amp; context, PseudoIdSet&amp; dynamicPseudoIdSet, MatchType&amp; matchType, unsigned&amp; specificity) const</span>
  {
      const Element&amp; element = *context.element;
      const CSSSelector&amp; selector = *context.selector;
  
      specificity = CSSSelector::addSpecificities(specificity, selector.simpleSelectorSpecificity());
<span class="line-new-header">--- 649,11 ---</span>
          return false;
      const AtomString&amp; namespaceURI = tagQName.namespaceURI();
      return namespaceURI == starAtom() || namespaceURI == element.namespaceURI();
  }
  
<span class="line-modified">! bool SelectorChecker::checkOne(CheckingContext&amp; checkingContext, const LocalContext&amp; context, MatchType&amp; matchType, unsigned&amp; specificity) const</span>
  {
      const Element&amp; element = *context.element;
      const CSSSelector&amp; selector = *context.selector;
  
      specificity = CSSSelector::addSpecificities(specificity, selector.simpleSelectorSpecificity());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 832,20 ***</span>
                      LocalContext subcontext(context);
                      subcontext.inFunctionalPseudoClass = true;
                      subcontext.pseudoElementEffective = context.pseudoElementEffective;
                      subcontext.selector = subselector;
                      subcontext.firstSelectorOfTheFragment = subselector;
                      PseudoIdSet localDynamicPseudoIdSet;
                      unsigned localSpecificity = 0;
                      MatchResult result = matchRecursively(checkingContext, subcontext, localDynamicPseudoIdSet, localSpecificity);
                      if (result.match == Match::SelectorMatches) {
                          maxSpecificity = std::max(maxSpecificity, localSpecificity);
  
                          if (result.matchType == MatchType::Element)
                              localMatchType = MatchType::Element;
  
<span class="line-removed">-                         dynamicPseudoIdSet.merge(localDynamicPseudoIdSet);</span>
                          hasMatchedAnything = true;
                      }
                  }
                  if (hasMatchedAnything) {
                      matchType = localMatchType;
<span class="line-new-header">--- 839,25 ---</span>
                      LocalContext subcontext(context);
                      subcontext.inFunctionalPseudoClass = true;
                      subcontext.pseudoElementEffective = context.pseudoElementEffective;
                      subcontext.selector = subselector;
                      subcontext.firstSelectorOfTheFragment = subselector;
<span class="line-added">+                     subcontext.pseudoId = PseudoId::None;</span>
                      PseudoIdSet localDynamicPseudoIdSet;
                      unsigned localSpecificity = 0;
                      MatchResult result = matchRecursively(checkingContext, subcontext, localDynamicPseudoIdSet, localSpecificity);
<span class="line-added">+ </span>
<span class="line-added">+                     // Pseudo elements are not valid inside :matches</span>
<span class="line-added">+                     if (localDynamicPseudoIdSet)</span>
<span class="line-added">+                         continue;</span>
<span class="line-added">+ </span>
                      if (result.match == Match::SelectorMatches) {
                          maxSpecificity = std::max(maxSpecificity, localSpecificity);
  
                          if (result.matchType == MatchType::Element)
                              localMatchType = MatchType::Element;
  
                          hasMatchedAnything = true;
                      }
                  }
                  if (hasMatchedAnything) {
                      matchType = localMatchType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,10 ***</span>
<span class="line-new-header">--- 994,12 ---</span>
              // ...except if :visited matching is disabled for ancestor/sibling matching.
              // Inside functional pseudo class except for :not, :visited never matches.
              if (context.inFunctionalPseudoClass)
                  return false;
              return element.isLink() &amp;&amp; context.visitedMatchType == VisitedMatchType::Enabled;
<span class="line-added">+         case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added">+             return matchesDirectFocusPseudoClass(element);</span>
          case CSSSelector::PseudoClassDrag:
              addStyleRelation(checkingContext, element, Style::Relation::AffectedByDrag);
  
              if (element.renderer() &amp;&amp; element.renderer()-&gt;isDragging())
                  return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1043,12 ***</span>
              if (&amp;element == element.document().documentElement())
                  return true;
              break;
          case CSSSelector::PseudoClassLang:
              {
<span class="line-modified">!                 ASSERT(selector.langArgumentList() &amp;&amp; !selector.langArgumentList()-&gt;isEmpty());</span>
<span class="line-modified">!                 return matchesLangPseudoClass(element, *selector.langArgumentList());</span>
              }
  #if ENABLE(FULLSCREEN_API)
          case CSSSelector::PseudoClassFullScreen:
              return matchesFullScreenPseudoClass(element);
          case CSSSelector::PseudoClassAnimatingFullScreenTransition:
<span class="line-new-header">--- 1057,12 ---</span>
              if (&amp;element == element.document().documentElement())
                  return true;
              break;
          case CSSSelector::PseudoClassLang:
              {
<span class="line-modified">!                 ASSERT(selector.argumentList() &amp;&amp; !selector.argumentList()-&gt;isEmpty());</span>
<span class="line-modified">!                 return matchesLangPseudoClass(element, *selector.argumentList());</span>
              }
  #if ENABLE(FULLSCREEN_API)
          case CSSSelector::PseudoClassFullScreen:
              return matchesFullScreenPseudoClass(element);
          case CSSSelector::PseudoClassAnimatingFullScreenTransition:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1057,10 ***</span>
<span class="line-new-header">--- 1071,14 ---</span>
              return matchesFullScreenAncestorPseudoClass(element);
          case CSSSelector::PseudoClassFullScreenDocument:
              return matchesFullScreenDocumentPseudoClass(element);
          case CSSSelector::PseudoClassFullScreenControlsHidden:
              return matchesFullScreenControlsHiddenPseudoClass(element);
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+         case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added">+             return matchesPictureInPicturePseudoClass(element);</span>
  #endif
          case CSSSelector::PseudoClassInRange:
              return isInRange(element);
          case CSSSelector::PseudoClassOutOfRange:
              return isOutOfRange(element);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,31 ***</span>
              ASSERT_NOT_REACHED();
              break;
          }
          return false;
      }
  #if ENABLE(VIDEO_TRACK)
<span class="line-modified">!     if (selector.match() == CSSSelector::PseudoElement &amp;&amp; selector.pseudoElementType() == CSSSelector::PseudoElementCue) {</span>
<span class="line-modified">!         LocalContext subcontext(context);</span>
  
<span class="line-modified">!         const CSSSelector* const &amp; selector = context.selector;</span>
<span class="line-modified">!         for (subcontext.selector = selector-&gt;selectorList()-&gt;first(); subcontext.selector; subcontext.selector = CSSSelectorList::next(subcontext.selector)) {</span>
<span class="line-modified">!             subcontext.firstSelectorOfTheFragment = subcontext.selector;</span>
<span class="line-modified">!             subcontext.inFunctionalPseudoClass = true;</span>
<span class="line-modified">!             subcontext.pseudoElementEffective = false;</span>
<span class="line-modified">!             PseudoIdSet ignoredDynamicPseudo;</span>
<span class="line-modified">!             unsigned ignoredSpecificity = 0;</span>
<span class="line-modified">!             if (matchRecursively(checkingContext, subcontext, ignoredDynamicPseudo, ignoredSpecificity).match == Match::SelectorMatches)</span>
<span class="line-modified">!                 return true;</span>
          }
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
  #endif
<span class="line-modified">!     if (selector.match() == CSSSelector::PseudoElement &amp;&amp; selector.pseudoElementType() == CSSSelector::PseudoElementSlotted) {</span>
<span class="line-modified">!         // We see ::slotted() pseudo elements when collecting slotted rules from the slot shadow tree only.</span>
<span class="line-modified">!         ASSERT(checkingContext.resolvingMode == Mode::CollectingRules);</span>
<span class="line-modified">!         return is&lt;HTMLSlotElement&gt;(element);</span>
      }
      return true;
  }
  
  bool SelectorChecker::matchSelectorList(CheckingContext&amp; checkingContext, const LocalContext&amp; context, const Element&amp; element, const CSSSelectorList&amp; selectorList, unsigned&amp; specificity) const
<span class="line-new-header">--- 1140,76 ---</span>
              ASSERT_NOT_REACHED();
              break;
          }
          return false;
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (selector.match() == CSSSelector::PseudoElement) {</span>
<span class="line-added">+         switch (selector.pseudoElementType()) {</span>
  #if ENABLE(VIDEO_TRACK)
<span class="line-modified">!         case CSSSelector::PseudoElementCue: {</span>
<span class="line-modified">!             LocalContext subcontext(context);</span>
  
<span class="line-modified">!             const CSSSelector* const &amp; selector = context.selector;</span>
<span class="line-modified">!             for (subcontext.selector = selector-&gt;selectorList()-&gt;first(); subcontext.selector; subcontext.selector = CSSSelectorList::next(subcontext.selector)) {</span>
<span class="line-modified">!                 subcontext.firstSelectorOfTheFragment = subcontext.selector;</span>
<span class="line-modified">!                 subcontext.inFunctionalPseudoClass = true;</span>
<span class="line-modified">!                 subcontext.pseudoElementEffective = false;</span>
<span class="line-modified">!                 PseudoIdSet ignoredDynamicPseudo;</span>
<span class="line-modified">!                 unsigned ignoredSpecificity = 0;</span>
<span class="line-modified">!                 if (matchRecursively(checkingContext, subcontext, ignoredDynamicPseudo, ignoredSpecificity).match == Match::SelectorMatches)</span>
<span class="line-modified">!                     return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return false;</span>
          }
  #endif
<span class="line-modified">!         case CSSSelector::PseudoElementSlotted:</span>
<span class="line-modified">!             // We see ::slotted() pseudo elements when collecting slotted rules from the slot shadow tree only.</span>
<span class="line-modified">!             ASSERT(checkingContext.resolvingMode == Mode::CollectingRules);</span>
<span class="line-modified">!             return is&lt;HTMLSlotElement&gt;(element);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case CSSSelector::PseudoElementPart: {</span>
<span class="line-added">+             auto translatePartNameToRuleScope = [&amp;](AtomString partName) {</span>
<span class="line-added">+                 Vector&lt;AtomString, 1&gt; mappedNames { partName };</span>
<span class="line-added">+                 for (auto* shadowRoot = element.containingShadowRoot(); shadowRoot; shadowRoot = shadowRoot-&gt;host()-&gt;containingShadowRoot()) {</span>
<span class="line-added">+                     // Apply mappings up to the scope the rules are coming from.</span>
<span class="line-added">+                     if (shadowRoot-&gt;host() == checkingContext.shadowHostInPartRuleScope)</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     Vector&lt;AtomString, 1&gt; newMappedNames;</span>
<span class="line-added">+                     for (auto&amp; name : mappedNames)</span>
<span class="line-added">+                         newMappedNames.appendVector(shadowRoot-&gt;partMappings().get(name));</span>
<span class="line-added">+                     mappedNames = newMappedNames;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (mappedNames.isEmpty())</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return mappedNames;</span>
<span class="line-added">+             };</span>
<span class="line-added">+ </span>
<span class="line-added">+             Vector&lt;AtomString, 4&gt; translatedPartNames;</span>
<span class="line-added">+             for (unsigned i = 0; i &lt; element.partNames().size(); ++i)</span>
<span class="line-added">+                 translatedPartNames.appendVector(translatePartNameToRuleScope(element.partNames()[i]));</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (auto&amp; part : *selector.argumentList()) {</span>
<span class="line-added">+                 if (!translatedPartNames.contains(part))</span>
<span class="line-added">+                     return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case CSSSelector::PseudoElementHighlight:</span>
<span class="line-added">+             // Always matches when not specifically requested so it gets added to the pseudoIdSet.</span>
<span class="line-added">+             if (checkingContext.pseudoId == PseudoId::None)</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             if (checkingContext.pseudoId != PseudoId::Highlight)</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             return selector.argumentList()-&gt;first() == checkingContext.nameForHightlightPseudoElement;</span>
<span class="line-added">+ </span>
<span class="line-added">+         default:</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
      }
      return true;
  }
  
  bool SelectorChecker::matchSelectorList(CheckingContext&amp; checkingContext, const LocalContext&amp; context, const Element&amp; element, const CSSSelectorList&amp; selectorList, unsigned&amp; specificity) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1246,13 ***</span>
<span class="line-new-header">--- 1309,30 ---</span>
  static bool isFrameFocused(const Element&amp; element)
  {
      return element.document().frame() &amp;&amp; element.document().frame()-&gt;selection().isFocusedAndActive();
  }
  
<span class="line-added">+ static bool doesShadowTreeContainFocusedElement(const Element&amp; element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* shadowRoot = element.shadowRoot();</span>
<span class="line-added">+     return shadowRoot &amp;&amp; shadowRoot-&gt;containsFocusedElement();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool SelectorChecker::matchesFocusPseudoClass(const Element&amp; element)
  {
      if (InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassFocus))
          return true;
<span class="line-added">+ </span>
<span class="line-added">+     return (element.focused() || doesShadowTreeContainFocusedElement(element)) &amp;&amp; isFrameFocused(element);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This needs to match a subset of elements matchesFocusPseudoClass match since direct focus is treated</span>
<span class="line-added">+ // as a part of focus pseudo class selectors in ElementRuleCollector::collectMatchingRules.</span>
<span class="line-added">+ bool SelectorChecker::matchesDirectFocusPseudoClass(const Element&amp; element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassFocus))</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
      return element.focused() &amp;&amp; isFrameFocused(element);
  }
  
  }
</pre>
<center><a href="SVGCSSComputedStyleDeclaration.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorChecker.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
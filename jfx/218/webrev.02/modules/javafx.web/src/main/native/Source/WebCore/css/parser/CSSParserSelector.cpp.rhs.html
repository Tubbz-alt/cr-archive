<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2003 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004, 2005, 2006, 2008, 2014 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;CSSParserSelector.h&quot;
 23 
 24 #include &quot;CSSSelector.h&quot;
 25 #include &quot;CSSSelectorList.h&quot;
 26 #include &quot;SelectorPseudoTypeMap.h&quot;
 27 
 28 #if COMPILER(MSVC)
 29 // See https://msdn.microsoft.com/en-us/library/1wea5zwe.aspx
 30 #pragma warning(disable: 4701)
 31 #endif
 32 
 33 namespace WebCore {
 34 
 35 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::parsePagePseudoSelector(StringView pseudoTypeString)
 36 {
 37     CSSSelector::PagePseudoClassType pseudoType;
 38     if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;first&quot;))
 39         pseudoType = CSSSelector::PagePseudoClassFirst;
 40     else if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;left&quot;))
 41         pseudoType = CSSSelector::PagePseudoClassLeft;
 42     else if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;right&quot;))
 43         pseudoType = CSSSelector::PagePseudoClassRight;
 44     else
 45         return nullptr;
 46 
 47     auto selector = makeUnique&lt;CSSParserSelector&gt;();
 48     selector-&gt;m_selector-&gt;setMatch(CSSSelector::PagePseudoClass);
 49     selector-&gt;m_selector-&gt;setPagePseudoType(pseudoType);
 50     return selector;
 51 }
 52 
 53 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::parsePseudoElementSelector(StringView pseudoTypeString)
 54 {
 55     auto pseudoType = CSSSelector::parsePseudoElementType(pseudoTypeString);
<a name="1" id="anc1"></a><span class="line-modified"> 56     if (pseudoType == CSSSelector::PseudoElementUnknown)</span>
<span class="line-modified"> 57         return nullptr;</span>







 58 
 59     auto selector = makeUnique&lt;CSSParserSelector&gt;();
 60     selector-&gt;m_selector-&gt;setMatch(CSSSelector::PseudoElement);
 61     selector-&gt;m_selector-&gt;setPseudoElementType(pseudoType);
 62     AtomString name;
 63     if (pseudoType != CSSSelector::PseudoElementWebKitCustomLegacyPrefixed)
 64         name = pseudoTypeString.convertToASCIILowercase();
 65     else {
 66         ASSERT_WITH_MESSAGE(equalLettersIgnoringASCIICase(pseudoTypeString, &quot;-webkit-input-placeholder&quot;), &quot;-webkit-input-placeholder is the only LegacyPrefix pseudo type.&quot;);
 67         if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;-webkit-input-placeholder&quot;))
 68             name = AtomString(&quot;placeholder&quot;, AtomString::ConstructFromLiteral);
 69         else
 70             name = pseudoTypeString.convertToASCIILowercase();
 71     }
 72     selector-&gt;m_selector-&gt;setValue(name);
 73     return selector;
 74 }
 75 
 76 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::parsePseudoClassSelector(StringView pseudoTypeString)
 77 {
 78     auto pseudoType = parsePseudoClassAndCompatibilityElementString(pseudoTypeString);
 79     if (pseudoType.pseudoClass != CSSSelector::PseudoClassUnknown) {
 80         auto selector = makeUnique&lt;CSSParserSelector&gt;();
 81         selector-&gt;m_selector-&gt;setMatch(CSSSelector::PseudoClass);
 82         selector-&gt;m_selector-&gt;setPseudoClassType(pseudoType.pseudoClass);
 83         return selector;
 84     }
 85     if (pseudoType.compatibilityPseudoElement != CSSSelector::PseudoElementUnknown) {
 86         auto selector = makeUnique&lt;CSSParserSelector&gt;();
 87         selector-&gt;m_selector-&gt;setMatch(CSSSelector::PseudoElement);
 88         selector-&gt;m_selector-&gt;setPseudoElementType(pseudoType.compatibilityPseudoElement);
 89         selector-&gt;m_selector-&gt;setValue(pseudoTypeString.convertToASCIILowercase());
 90         return selector;
 91     }
 92     return nullptr;
 93 }
 94 
 95 CSSParserSelector::CSSParserSelector()
 96     : m_selector(makeUnique&lt;CSSSelector&gt;())
 97 {
 98 }
 99 
100 CSSParserSelector::CSSParserSelector(const QualifiedName&amp; tagQName)
101     : m_selector(makeUnique&lt;CSSSelector&gt;(tagQName))
102 {
103 }
104 
105 CSSParserSelector::~CSSParserSelector()
106 {
107     if (!m_tagHistory)
108         return;
109     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;, 16&gt; toDelete;
110     std::unique_ptr&lt;CSSParserSelector&gt; selector = WTFMove(m_tagHistory);
111     while (true) {
112         std::unique_ptr&lt;CSSParserSelector&gt; next = WTFMove(selector-&gt;m_tagHistory);
113         toDelete.append(WTFMove(selector));
114         if (!next)
115             break;
116         selector = WTFMove(next);
117     }
118 }
119 
120 void CSSParserSelector::adoptSelectorVector(Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;&amp;&amp; selectorVector)
121 {
122     m_selector-&gt;setSelectorList(makeUnique&lt;CSSSelectorList&gt;(WTFMove(selectorVector)));
123 }
124 
<a name="2" id="anc2"></a><span class="line-modified">125 void CSSParserSelector::setArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)</span>
126 {
127     ASSERT_WITH_MESSAGE(!argumentList-&gt;isEmpty(), &quot;No CSS Selector takes an empty argument list.&quot;);
<a name="3" id="anc3"></a><span class="line-modified">128     m_selector-&gt;setArgumentList(WTFMove(argumentList));</span>
129 }
130 
131 void CSSParserSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
132 {
133     m_selector-&gt;setSelectorList(WTFMove(selectorList));
134 }
135 
136 static bool selectorListMatchesPseudoElement(const CSSSelectorList* selectorList)
137 {
138     if (!selectorList)
139         return false;
140 
141     for (const CSSSelector* subSelector = selectorList-&gt;first(); subSelector; subSelector = CSSSelectorList::next(subSelector)) {
142         for (const CSSSelector* selector = subSelector; selector; selector = selector-&gt;tagHistory()) {
143             if (selector-&gt;matchesPseudoElement())
144                 return true;
145             if (const CSSSelectorList* subselectorList = selector-&gt;selectorList()) {
146                 if (selectorListMatchesPseudoElement(subselectorList))
147                     return true;
148             }
149         }
150     }
151     return false;
152 }
153 
154 bool CSSParserSelector::matchesPseudoElement() const
155 {
156     return m_selector-&gt;matchesPseudoElement() || selectorListMatchesPseudoElement(m_selector-&gt;selectorList());
157 }
158 
159 void CSSParserSelector::insertTagHistory(CSSSelector::RelationType before, std::unique_ptr&lt;CSSParserSelector&gt; selector, CSSSelector::RelationType after)
160 {
161     if (m_tagHistory)
162         selector-&gt;setTagHistory(WTFMove(m_tagHistory));
163     setRelation(before);
164     selector-&gt;setRelation(after);
165     m_tagHistory = WTFMove(selector);
166 }
167 
168 void CSSParserSelector::appendTagHistory(CSSSelector::RelationType relation, std::unique_ptr&lt;CSSParserSelector&gt; selector)
169 {
170     CSSParserSelector* end = this;
171     while (end-&gt;tagHistory())
172         end = end-&gt;tagHistory();
173 
174     end-&gt;setRelation(relation);
175     end-&gt;setTagHistory(WTFMove(selector));
176 }
177 
178 void CSSParserSelector::appendTagHistory(CSSParserSelectorCombinator relation, std::unique_ptr&lt;CSSParserSelector&gt; selector)
179 {
180     CSSParserSelector* end = this;
181     while (end-&gt;tagHistory())
182         end = end-&gt;tagHistory();
183 
184     CSSSelector::RelationType selectorRelation;
185     switch (relation) {
186     case CSSParserSelectorCombinator::Child:
187         selectorRelation = CSSSelector::Child;
188         break;
189     case CSSParserSelectorCombinator::DescendantSpace:
190         selectorRelation = CSSSelector::DescendantSpace;
191         break;
192     case CSSParserSelectorCombinator::DirectAdjacent:
193         selectorRelation = CSSSelector::DirectAdjacent;
194         break;
195     case CSSParserSelectorCombinator::IndirectAdjacent:
196         selectorRelation = CSSSelector::IndirectAdjacent;
197         break;
198     }
199     end-&gt;setRelation(selectorRelation);
200     end-&gt;setTagHistory(WTFMove(selector));
201 }
202 
203 void CSSParserSelector::prependTagSelector(const QualifiedName&amp; tagQName, bool tagIsForNamespaceRule)
204 {
205     auto second = makeUnique&lt;CSSParserSelector&gt;();
206     second-&gt;m_selector = WTFMove(m_selector);
207     second-&gt;m_tagHistory = WTFMove(m_tagHistory);
208     m_tagHistory = WTFMove(second);
209 
210     m_selector = makeUnique&lt;CSSSelector&gt;(tagQName, tagIsForNamespaceRule);
211     m_selector-&gt;setRelation(CSSSelector::Subselector);
212 }
213 
214 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::releaseTagHistory()
215 {
216     setRelation(CSSSelector::Subselector);
217     return WTFMove(m_tagHistory);
218 }
219 
220 // FIXME-NEWPARSER: Add support for :host-context
221 bool CSSParserSelector::isHostPseudoSelector() const
222 {
223     return match() == CSSSelector::PseudoClass &amp;&amp; pseudoClassType() == CSSSelector::PseudoClassHost;
224 }
225 
226 }
227 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
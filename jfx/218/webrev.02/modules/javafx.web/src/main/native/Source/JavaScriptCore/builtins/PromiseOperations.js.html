<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseOperations.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  3  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 // @internal
 28 
 29 @globalPrivate
 30 function newPromiseReaction(promiseOrCapability, onFulfilled, onRejected)
 31 {
 32     &quot;use strict&quot;;
 33 
 34     return {
 35         @promiseOrCapability: promiseOrCapability,
 36         @onFulfilled: onFulfilled,
 37         @onRejected: onRejected,
 38         @next: @undefined,
 39     };
 40 }
 41 
 42 @globalPrivate
 43 function newPromiseCapabilitySlow(constructor)
 44 {
 45     var promiseCapability = {
 46         @resolve: @undefined,
 47         @reject: @undefined,
 48         @promise: @undefined,
 49     };
 50 
 51     if (!@isConstructor(constructor))
 52         @throwTypeError(&quot;promise capability requires a constructor function&quot;);
 53 
 54     var promise = new constructor(function (resolve, reject) {
 55         if (promiseCapability.@resolve !== @undefined)
 56             @throwTypeError(&quot;resolve function is already set&quot;);
 57         if (promiseCapability.@reject !== @undefined)
 58             @throwTypeError(&quot;reject function is already set&quot;);
 59 
 60         promiseCapability.@resolve = resolve;
 61         promiseCapability.@reject = reject;
 62     });
 63 
 64     if (typeof promiseCapability.@resolve !== &quot;function&quot;)
 65         @throwTypeError(&quot;executor did not take a resolve function&quot;);
 66 
 67     if (typeof promiseCapability.@reject !== &quot;function&quot;)
 68         @throwTypeError(&quot;executor did not take a reject function&quot;);
 69 
 70     promiseCapability.@promise = promise;
 71 
 72     return promiseCapability;
 73 }
 74 
 75 @globalPrivate
 76 function newPromiseCapability(constructor)
 77 {
 78     &quot;use strict&quot;;
 79 
 80     if (constructor === @Promise) {
 81         var promise = @newPromise();
 82         var capturedPromise = promise;
 83         function @resolve(resolution) {
 84             return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);
 85         }
 86         function @reject(reason) {
 87             return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);
 88         }
 89         return { @resolve, @reject, @promise: promise };
 90     }
 91 
 92     return @newPromiseCapabilitySlow(constructor);
 93 }
 94 
 95 @globalPrivate
 96 function promiseResolveSlow(constructor, value)
 97 {
 98     @assert(constructor !== @Promise);
 99     var promiseCapability = @newPromiseCapabilitySlow(constructor);
100     promiseCapability.@resolve.@call(@undefined, value);
101     return promiseCapability.@promise;
102 }
103 
104 @globalPrivate
105 function promiseRejectSlow(constructor, reason)
106 {
107     @assert(constructor !== @Promise);
108     var promiseCapability = @newPromiseCapabilitySlow(constructor);
109     promiseCapability.@reject.@call(@undefined, reason);
110     return promiseCapability.@promise;
111 }
112 
113 @globalPrivate
114 function newHandledRejectedPromise(error)
115 {
116     &quot;use strict&quot;;
117     var promise = @newPromise();
118     @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);
119     @putPromiseInternalField(promise, @promiseFieldFlags, @getPromiseInternalField(promise, @promiseFieldFlags) | @promiseFlagsIsHandled);
120     return promise;
121 }
122 
123 @globalPrivate
124 function triggerPromiseReactions(state, reactions, argument)
125 {
126     &quot;use strict&quot;;
127 
128     // Reverse the order of singly-linked-list.
129     var previous = @undefined;
130     var current = reactions;
131     while (current) {
132         var next = current.@next;
133         current.@next = previous;
134         previous = current;
135         current = next;
136     }
137     reactions = previous;
138 
139     current = reactions;
140     while (current) {
141         @enqueueJob(@promiseReactionJob, state, current, argument);
142         current = current.@next;
143     }
144 }
145 
146 @globalPrivate
147 function resolvePromise(promise, resolution)
148 {
149     &quot;use strict&quot;;
150 
151     @assert(@isPromise(promise));
152 
153     if (resolution === promise)
154         return @rejectPromise(promise, @makeTypeError(&quot;Cannot resolve a promise with itself&quot;));
155 
156     if (!@isObject(resolution))
157         return @fulfillPromise(promise, resolution);
158 
159     var then;
160     try {
161         then = resolution.then;
162     } catch (error) {
163         return @rejectPromise(promise, error);
164     }
165 
166     if (@isPromise(resolution) &amp;&amp; then === @defaultPromiseThen) {
167         @enqueueJob(@promiseResolveThenableJobFast, resolution, promise);
168         return;
169     }
170 
171     if (typeof then !== &#39;function&#39;)
172         return @fulfillPromise(promise, resolution);
173 
174     @enqueueJob(@promiseResolveThenableJob, resolution, then, @createResolvingFunctions(promise));
175 }
176 
177 @globalPrivate
178 function rejectPromise(promise, reason)
179 {
180     &quot;use strict&quot;;
181 
182     @assert(@isPromise(promise));
183     @assert((@getPromiseInternalField(promise, @promiseFieldFlags) &amp; @promiseStateMask) == @promiseStatePending);
184 
185     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);
186     var reactions = @getPromiseInternalField(promise, @promiseFieldReactionsOrResult);
187     @putPromiseInternalField(promise, @promiseFieldReactionsOrResult, reason);
188     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseStateRejected);
189 
190     @InspectorInstrumentation.promiseRejected(promise, reason, reactions);
191 
192     if (!(flags &amp; @promiseFlagsIsHandled))
193         @hostPromiseRejectionTracker(promise, @promiseRejectionReject);
194 
195     @triggerPromiseReactions(@promiseStateRejected, reactions, reason);
196 }
197 
198 @globalPrivate
199 function fulfillPromise(promise, value)
200 {
201     &quot;use strict&quot;;
202 
203     @assert(@isPromise(promise));
204     @assert((@getPromiseInternalField(promise, @promiseFieldFlags) &amp; @promiseStateMask) == @promiseStatePending);
205 
206     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);
207     var reactions = @getPromiseInternalField(promise, @promiseFieldReactionsOrResult);
208     @putPromiseInternalField(promise, @promiseFieldReactionsOrResult, value);
209     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseStateFulfilled);
210 
211     @InspectorInstrumentation.promiseFulfilled(promise, value, reactions);
212 
213     @triggerPromiseReactions(@promiseStateFulfilled, reactions, value);
214 }
215 
216 @globalPrivate
217 function resolvePromiseWithFirstResolvingFunctionCallCheck(promise, value)
218 {
219     @assert(@isPromise(promise));
220     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);
221     if (flags &amp; @promiseFlagsIsFirstResolvingFunctionCalled)
222         return;
223     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseFlagsIsFirstResolvingFunctionCalled);
224     return @resolvePromise(promise, value);
225 }
226 
227 @globalPrivate
228 function rejectPromiseWithFirstResolvingFunctionCallCheck(promise, reason)
229 {
230     @assert(@isPromise(promise));
231     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);
232     if (flags &amp; @promiseFlagsIsFirstResolvingFunctionCalled)
233         return;
234     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseFlagsIsFirstResolvingFunctionCalled);
235     return @rejectPromise(promise, reason);
236 }
237 
238 @globalPrivate
239 function createResolvingFunctions(promise)
240 {
241     &quot;use strict&quot;;
242 
243     @assert(@isPromise(promise));
244 
245     var alreadyResolved = false;
246 
247     function @resolve(resolution) {
248         if (alreadyResolved)
249             return @undefined;
250         alreadyResolved = true;
251 
252         return @resolvePromise(promise, resolution);
253     }
254 
255     function @reject(reason) {
256         if (alreadyResolved)
257             return @undefined;
258         alreadyResolved = true;
259 
260         return @rejectPromise(promise, reason);
261     }
262 
263     return { @resolve, @reject };
264 }
265 
266 @globalPrivate
267 function promiseReactionJobWithoutPromise(handler, argument)
268 {
269     &quot;use strict&quot;;
270 
271     try {
272         handler(argument);
273     } catch {
274         // This is user-uncatchable promise. We just ignore the error here.
275     }
276 }
277 
278 // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.
279 @globalPrivate
280 function resolveWithoutPromise(resolution, onFulfilled, onRejected)
281 {
282     &quot;use strict&quot;;
283 
284     if (!@isObject(resolution)) {
285         @fulfillWithoutPromise(resolution, onFulfilled, onRejected);
286         return;
287     }
288 
289     var then;
290     try {
291         then = resolution.then;
292     } catch (error) {
293         @rejectWithoutPromise(error, onFulfilled, onRejected);
294         return;
295     }
296 
297     if (@isPromise(resolution) &amp;&amp; then === @defaultPromiseThen) {
298         @enqueueJob(@promiseResolveThenableJobWithoutPromiseFast, resolution, onFulfilled, onRejected);
299         return;
300     }
301 
302     if (typeof then !== &#39;function&#39;) {
303         @fulfillWithoutPromise(resolution, onFulfilled, onRejected);
304         return;
305     }
306 
307     // Wrap onFulfilled and onRejected with @createResolvingFunctionsWithoutPromise to ensure that each function will be called at most once.
308     @enqueueJob(@promiseResolveThenableJob, resolution, then, @createResolvingFunctionsWithoutPromise(onFulfilled, onRejected));
309 }
310 
311 // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.
312 @globalPrivate
313 function rejectWithoutPromise(reason, onFulfilled, onRejected)
314 {
315     &quot;use strict&quot;;
316 
317     @enqueueJob(@promiseReactionJobWithoutPromise, onRejected, reason);
318 }
319 
320 // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.
321 @globalPrivate
322 function fulfillWithoutPromise(value, onFulfilled, onRejected)
323 {
324     &quot;use strict&quot;;
325 
326     @enqueueJob(@promiseReactionJobWithoutPromise, onFulfilled, value);
327 }
328 
329 @globalPrivate
330 function createResolvingFunctionsWithoutPromise(onFulfilled, onRejected)
331 {
332     &quot;use strict&quot;;
333 
334     var alreadyResolved = false;
335 
336     function @resolve(resolution) {
337         if (alreadyResolved)
338             return @undefined;
339         alreadyResolved = true;
340 
341         @resolveWithoutPromise(resolution, onFulfilled, onRejected);
342     }
343 
344     function @reject(reason) {
345         if (alreadyResolved)
346             return @undefined;
347         alreadyResolved = true;
348 
349         @rejectWithoutPromise(reason, onFulfilled, onRejected);
350     }
351 
352     return { @resolve, @reject };
353 }
354 
355 @globalPrivate
356 function promiseReactionJob(state, reaction, argument)
357 {
358     // Promise Reaction has four types.
359     // 1. @promiseOrCapability is PromiseCapability, and having handlers.
360     //     The most generic one.
361     // 2. @promiseOrCapability is Promise, and having handlers.
362     //     We just have promise.
363     // 3. @promiseOrCapability is Promise, and not having handlers.
364     //     It only has promise. Just resolving it with the value.
365     // 4. Only having @onFulfilled and @onRejected
366     //     It does not have promise capability. Just handlers are passed.
367     &quot;use strict&quot;;
368 
369     var promiseOrCapability = reaction.@promiseOrCapability;
370 
371     // Case (3).
372     if (!reaction.@onRejected) {
373         @assert(!reaction.@onFulfilled);
374         try {
375             @assert(@isPromise(promiseOrCapability));
376             if (state === @promiseStateFulfilled)
377                 @resolvePromise(promiseOrCapability, argument);
378             else
379                 @rejectPromise(promiseOrCapability, argument);
380         } catch {
381             // This is user-uncatchable promise. We just ignore the error here.
382         }
383         return;
384     }
385 
386     var handler = (state === @promiseStateFulfilled) ? reaction.@onFulfilled: reaction.@onRejected;
387 
388     // Case (4).
389     if (!promiseOrCapability) {
390         @promiseReactionJobWithoutPromise(handler, argument);
391         return;
392     }
393 
394     // Case (1), or (2).
395     var result;
396     try {
397         result = handler(argument);
398     } catch (error) {
399         if (@isPromise(promiseOrCapability)) {
400             @rejectPromise(promiseOrCapability, error);
401             return;
402         }
403         promiseOrCapability.@reject.@call(@undefined, error);
404         return;
405     }
406 
407     if (@isPromise(promiseOrCapability)) {
408         @resolvePromise(promiseOrCapability, result);
409         return;
410     }
411     promiseOrCapability.@resolve.@call(@undefined, result);
412 }
413 
414 @globalPrivate
415 function promiseResolveThenableJobFast(thenable, promiseToResolve)
416 {
417     &quot;use strict&quot;;
418 
419     @assert(@isPromise(thenable));
420     @assert(@isPromise(promiseToResolve));
421 
422     var flags = @getPromiseInternalField(thenable, @promiseFieldFlags);
423     var state = flags &amp; @promiseStateMask;
424     var reaction = @newPromiseReaction(promiseToResolve, @undefined, @undefined);
425     if (state === @promiseStatePending) {
426         reaction.@next = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);
427         @putPromiseInternalField(thenable, @promiseFieldReactionsOrResult, reaction);
428     } else {
429         if (state === @promiseStateRejected &amp;&amp; !(flags &amp; @promiseFlagsIsHandled))
430             @hostPromiseRejectionTracker(thenable, @promiseRejectionHandle);
431         @enqueueJob(@promiseReactionJob, state, reaction, @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult));
432     }
433     @putPromiseInternalField(thenable, @promiseFieldFlags, @getPromiseInternalField(thenable, @promiseFieldFlags) | @promiseFlagsIsHandled);
434 }
435 
436 @globalPrivate
437 function promiseResolveThenableJobWithoutPromiseFast(thenable, onFulfilled, onRejected)
438 {
439     &quot;use strict&quot;;
440 
441     @assert(@isPromise(thenable));
442 
443     var flags = @getPromiseInternalField(thenable, @promiseFieldFlags);
444     var state = flags &amp; @promiseStateMask;
445     if (state === @promiseStatePending) {
446         var reaction = @newPromiseReaction(@undefined, onFulfilled, onRejected);
447         reaction.@next = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);
448         @putPromiseInternalField(thenable, @promiseFieldReactionsOrResult, reaction);
449     } else {
450         var result = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);
451         if (state === @promiseStateRejected) {
452             if (!(flags &amp; @promiseFlagsIsHandled))
453                 @hostPromiseRejectionTracker(thenable, @promiseRejectionHandle);
454             @rejectWithoutPromise(result, onFulfilled, onRejected);
455         } else
456             @fulfillWithoutPromise(result, onFulfilled, onRejected);
457     }
458     @putPromiseInternalField(thenable, @promiseFieldFlags, @getPromiseInternalField(thenable, @promiseFieldFlags) | @promiseFlagsIsHandled);
459 }
460 
461 @globalPrivate
462 function promiseResolveThenableJob(thenable, then, resolvingFunctions)
463 {
464     &quot;use strict&quot;;
465 
466     try {
467         return then.@call(thenable, resolvingFunctions.@resolve, resolvingFunctions.@reject);
468     } catch (error) {
469         return resolvingFunctions.@reject.@call(@undefined, error);
470     }
471 }
    </pre>
  </body>
</html>
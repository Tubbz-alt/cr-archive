diff a/modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp b/modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp
@@ -25,17 +25,19 @@
 
 #include "config.h"
 #include "Editing.h"
 
 #include "AXObjectCache.h"
+#include "CachedImage.h"
 #include "Document.h"
 #include "Editor.h"
 #include "Frame.h"
 #include "HTMLBodyElement.h"
 #include "HTMLDListElement.h"
 #include "HTMLDivElement.h"
 #include "HTMLElementFactory.h"
+#include "HTMLImageElement.h"
 #include "HTMLInterchange.h"
 #include "HTMLLIElement.h"
 #include "HTMLNames.h"
 #include "HTMLOListElement.h"
 #include "HTMLParagraphElement.h"
@@ -1120,18 +1122,15 @@
     auto range = Range::create(node.document());
     range->selectNodeContents(node);
     CharacterIterator it(range.get());
     it.advance(index - 1);
 
-    if (!it.atEnd() && it.text()[0] == '\n') {
+    if (!it.atEnd() && it.text().length() == 1 && it.text()[0] == '\n') {
         // FIXME: workaround for collapsed range (where only start position is correct) emitted for some emitted newlines.
-        auto iteratorRange = it.range();
-        if (iteratorRange->startPosition() == iteratorRange->endPosition()) {
-            it.advance(1);
-            if (!it.atEnd())
-                return VisiblePosition(it.range()->startPosition());
-        }
+        it.advance(1);
+        if (!it.atEnd())
+            return VisiblePosition(it.range()->startPosition());
     }
 
     return { it.atEnd() ? range->endPosition() : it.range()->endPosition(), UPSTREAM };
 }
 
@@ -1303,6 +1302,21 @@
     LayoutRect localRect(rect);
     rendererForCaretPainting->flipForWritingMode(localRect);
     return rendererForCaretPainting->localToAbsoluteQuad(FloatRect(localRect), UseTransforms, insideFixed).enclosingBoundingBox();
 }
 
+HashSet<RefPtr<HTMLImageElement>> visibleImageElementsInRangeWithNonLoadedImages(const Range& range)
+{
+    HashSet<RefPtr<HTMLImageElement>> result;
+    for (TextIterator iterator(&range); !iterator.atEnd(); iterator.advance()) {
+        if (!is<HTMLImageElement>(iterator.node()))
+            continue;
+
+        auto& imageElement = downcast<HTMLImageElement>(*iterator.node());
+        auto* cachedImage = imageElement.cachedImage();
+        if (cachedImage && cachedImage->isLoading())
+            result.add(&imageElement);
+    }
+    return result;
+}
+
 } // namespace WebCore

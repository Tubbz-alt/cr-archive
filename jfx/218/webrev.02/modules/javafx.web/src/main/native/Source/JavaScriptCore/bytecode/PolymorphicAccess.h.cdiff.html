<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PolymorphicAccess.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PreciseJumpTargets.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2014-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,10 ***</span>
<span class="line-new-header">--- 43,12 ---</span>
  class PolymorphicAccess;
  class StructureStubInfo;
  class WatchpointsOnStructureStubInfo;
  class ScratchRegisterAllocator;
  
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
<span class="line-added">+ </span>
  class AccessGenerationResult {
  public:
      enum Kind {
          MadeNoChanges,
          GaveUp,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,30 ***</span>
      Vector&lt;std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;&gt; m_watchpointsToFire;
  };
  
  class PolymorphicAccess {
      WTF_MAKE_NONCOPYABLE(PolymorphicAccess);
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
      PolymorphicAccess();
      ~PolymorphicAccess();
  
      // When this fails (returns GaveUp), this will leave the old stub intact but you should not try
      // to call this method again for that PolymorphicAccess instance.
      AccessGenerationResult addCases(
<span class="line-modified">!         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;, Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt;);</span>
  
      AccessGenerationResult addCase(
<span class="line-modified">!         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
  
<span class="line-modified">!     AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;);</span>
  
      bool isEmpty() const { return m_list.isEmpty(); }
      unsigned size() const { return m_list.size(); }
      const AccessCase&amp; at(unsigned i) const { return *m_list[i]; }
      const AccessCase&amp; operator[](unsigned i) const { return *m_list[i]; }
  
      // If this returns false then we are requesting a reset of the owning StructureStubInfo.
      bool visitWeak(VM&amp;) const;
  
      // This returns true if it has marked everything it will ever marked. This can be used as an
      // optimization to then avoid calling this method again during the fixpoint.
<span class="line-new-header">--- 129,32 ---</span>
      Vector&lt;std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;&gt; m_watchpointsToFire;
  };
  
  class PolymorphicAccess {
      WTF_MAKE_NONCOPYABLE(PolymorphicAccess);
<span class="line-modified">!     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
  public:
      PolymorphicAccess();
      ~PolymorphicAccess();
  
      // When this fails (returns GaveUp), this will leave the old stub intact but you should not try
      // to call this method again for that PolymorphicAccess instance.
      AccessGenerationResult addCases(
<span class="line-modified">!         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt;);</span>
  
      AccessGenerationResult addCase(
<span class="line-modified">!         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
  
<span class="line-modified">!     AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;);</span>
  
      bool isEmpty() const { return m_list.isEmpty(); }
      unsigned size() const { return m_list.size(); }
      const AccessCase&amp; at(unsigned i) const { return *m_list[i]; }
      const AccessCase&amp; operator[](unsigned i) const { return *m_list[i]; }
  
<span class="line-added">+     void visitAggregate(SlotVisitor&amp;);</span>
<span class="line-added">+ </span>
      // If this returns false then we are requesting a reset of the owning StructureStubInfo.
      bool visitWeak(VM&amp;) const;
  
      // This returns true if it has marked everything it will ever marked. This can be used as an
      // optimization to then avoid calling this method again during the fixpoint.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,11 ***</span>
  
      typedef Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; ListType;
  
      void commit(
          const GCSafeConcurrentJSLocker&amp;, VM&amp;, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp;, CodeBlock*, StructureStubInfo&amp;,
<span class="line-modified">!         const Identifier&amp;, AccessCase&amp;);</span>
  
      ListType m_list;
      RefPtr&lt;JITStubRoutine&gt; m_stubRoutine;
      std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; m_watchpoints;
      std::unique_ptr&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt; m_weakReferences;
<span class="line-new-header">--- 179,11 ---</span>
  
      typedef Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; ListType;
  
      void commit(
          const GCSafeConcurrentJSLocker&amp;, VM&amp;, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp;, CodeBlock*, StructureStubInfo&amp;,
<span class="line-modified">!         AccessCase&amp;);</span>
  
      ListType m_list;
      RefPtr&lt;JITStubRoutine&gt; m_stubRoutine;
      std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; m_watchpoints;
      std::unique_ptr&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt; m_weakReferences;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,10 ***</span>
<span class="line-new-header">--- 195,11 ---</span>
          , m_globalObject(globalObject)
          , m_calculatedRegistersForCallAndExceptionHandling(false)
          , m_needsToRestoreRegistersIfException(false)
          , m_calculatedCallSiteIndex(false)
      {
<span class="line-added">+         u.thisGPR = InvalidGPRReg;</span>
      }
      VM&amp; m_vm;
      JSGlobalObject* m_globalObject;
      CCallHelpers* jit { nullptr };
      ScratchRegisterAllocator* allocator;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,18 ***</span>
      StructureStubInfo* stubInfo { nullptr };
      MacroAssembler::JumpList success;
      MacroAssembler::JumpList failAndRepatch;
      MacroAssembler::JumpList failAndIgnore;
      GPRReg baseGPR { InvalidGPRReg };
<span class="line-modified">!     GPRReg thisGPR { InvalidGPRReg };</span>
      JSValueRegs valueRegs;
      GPRReg scratchGPR { InvalidGPRReg };
<span class="line-modified">!     const Identifier* ident;</span>
      std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; watchpoints;
      Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;
  
<span class="line-modified">!     Watchpoint* addWatchpoint(const ObjectPropertyCondition&amp; = ObjectPropertyCondition());</span>
  
      void restoreScratch();
      void succeed();
  
      struct SpillState {
<span class="line-new-header">--- 208,23 ---</span>
      StructureStubInfo* stubInfo { nullptr };
      MacroAssembler::JumpList success;
      MacroAssembler::JumpList failAndRepatch;
      MacroAssembler::JumpList failAndIgnore;
      GPRReg baseGPR { InvalidGPRReg };
<span class="line-modified">!     union {</span>
<span class="line-added">+         GPRReg thisGPR;</span>
<span class="line-added">+         GPRReg prototypeGPR;</span>
<span class="line-added">+         GPRReg propertyGPR;</span>
<span class="line-added">+     } u;</span>
      JSValueRegs valueRegs;
      GPRReg scratchGPR { InvalidGPRReg };
<span class="line-modified">!     FPRReg scratchFPR { InvalidFPRReg };</span>
      std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; watchpoints;
      Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;
<span class="line-added">+     Bag&lt;CallLinkInfo&gt; m_callLinkInfos;</span>
  
<span class="line-modified">!     void installWatchpoint(const ObjectPropertyCondition&amp;);</span>
  
      void restoreScratch();
      void succeed();
  
      struct SpillState {
</pre>
<center><a href="PolymorphicAccess.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PreciseJumpTargets.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  * Copyright (C) 2003-2019 Apple Inc. All right reserved.
   4  * Copyright (C) 2010 Google Inc. All rights reserved.
   5  * Copyright (C) 2013 ChangSeok Oh &lt;shivamidow@gmail.com&gt;
   6  * Copyright (C) 2013 Adobe Systems Inc. All right reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;ComplexLineLayout.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;BidiResolver.h&quot;
  30 #include &quot;BreakingContext.h&quot;
  31 #include &quot;FloatingObjects.h&quot;
  32 #include &quot;HTMLParserIdioms.h&quot;
  33 #include &quot;InlineElementBox.h&quot;
  34 #include &quot;InlineIterator.h&quot;
  35 #include &quot;InlineTextBox.h&quot;
  36 #include &quot;InlineTextBoxStyle.h&quot;
  37 #include &quot;LineLayoutState.h&quot;
  38 #include &quot;Logging.h&quot;
  39 #include &quot;RenderBlockFlow.h&quot;
  40 #include &quot;RenderFragmentContainer.h&quot;
  41 #include &quot;RenderFragmentedFlow.h&quot;
  42 #include &quot;RenderLayoutState.h&quot;
  43 #include &quot;RenderLineBreak.h&quot;
  44 #include &quot;RenderRubyBase.h&quot;
  45 #include &quot;RenderRubyText.h&quot;
  46 #include &quot;RenderSVGText.h&quot;
  47 #include &quot;RenderView.h&quot;
  48 #include &quot;SVGRootInlineBox.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;TrailingFloatsRootInlineBox.h&quot;
  51 #include &quot;VerticalPositionCache.h&quot;
  52 #include &lt;wtf/StdLibExtras.h&gt;
  53 
  54 namespace WebCore {
  55 
  56 ComplexLineLayout::ComplexLineLayout(RenderBlockFlow&amp; flow)
  57     : m_flow(flow)
  58 {
  59 }
  60 
  61 ComplexLineLayout::~ComplexLineLayout()
  62 {
  63     if (m_flow.containsFloats())
  64         m_flow.floatingObjects()-&gt;clearLineBoxTreePointers();
  65 
  66     lineBoxes().deleteLineBoxTree();
  67 };
  68 
  69 static void determineDirectionality(TextDirection&amp; dir, InlineIterator iter)
  70 {
  71     while (!iter.atEnd()) {
  72         if (iter.atParagraphSeparator())
  73             return;
  74         if (UChar current = iter.current()) {
  75             UCharDirection charDirection = u_charDirection(current);
  76             if (charDirection == U_LEFT_TO_RIGHT) {
  77                 dir = TextDirection::LTR;
  78                 return;
  79             }
  80             if (charDirection == U_RIGHT_TO_LEFT || charDirection == U_RIGHT_TO_LEFT_ARABIC) {
  81                 dir = TextDirection::RTL;
  82                 return;
  83             }
  84         }
  85         iter.increment();
  86     }
  87 }
  88 
  89 inline std::unique_ptr&lt;BidiRun&gt; createRun(int start, int end, RenderObject&amp; obj, InlineBidiResolver&amp; resolver)
  90 {
  91     return makeUnique&lt;BidiRun&gt;(start, end, obj, resolver.context(), resolver.dir());
  92 }
  93 
  94 void ComplexLineLayout::appendRunsForObject(BidiRunList&lt;BidiRun&gt;* runs, int start, int end, RenderObject&amp; obj, InlineBidiResolver&amp; resolver)
  95 {
  96     if (start &gt; end || RenderBlock::shouldSkipCreatingRunsForObject(obj))
  97         return;
  98 
  99     LineWhitespaceCollapsingState&amp; lineWhitespaceCollapsingState = resolver.whitespaceCollapsingState();
 100     bool haveNextTransition = (lineWhitespaceCollapsingState.currentTransition() &lt; lineWhitespaceCollapsingState.numTransitions());
 101     InlineIterator nextTransition;
 102     if (haveNextTransition)
 103         nextTransition = lineWhitespaceCollapsingState.transitions()[lineWhitespaceCollapsingState.currentTransition()];
 104     if (lineWhitespaceCollapsingState.betweenTransitions()) {
 105         if (!haveNextTransition || (&amp;obj != nextTransition.renderer()))
 106             return;
 107         // This is a new start point. Stop ignoring objects and
 108         // adjust our start.
 109         start = nextTransition.offset();
 110         lineWhitespaceCollapsingState.incrementCurrentTransition();
 111         if (start &lt; end) {
 112             appendRunsForObject(runs, start, end, obj, resolver);
 113             return;
 114         }
 115     } else {
 116         if (!haveNextTransition || (&amp;obj != nextTransition.renderer())) {
 117             if (runs)
 118                 runs-&gt;appendRun(createRun(start, end, obj, resolver));
 119             return;
 120         }
 121 
 122         // An end transition has been encountered within our object. We need to append a run with our endpoint.
 123         if (static_cast&lt;int&gt;(nextTransition.offset() + 1) &lt;= end) {
 124             lineWhitespaceCollapsingState.incrementCurrentTransition();
 125             // The end of the line is before the object we&#39;re inspecting. Skip everything and return
 126             if (nextTransition.refersToEndOfPreviousNode())
 127                 return;
 128             if (static_cast&lt;int&gt;(nextTransition.offset() + 1) &gt; start &amp;&amp; runs)
 129                 runs-&gt;appendRun(createRun(start, nextTransition.offset() + 1, obj, resolver));
 130             appendRunsForObject(runs, nextTransition.offset() + 1, end, obj, resolver);
 131         } else if (runs)
 132             runs-&gt;appendRun(createRun(start, end, obj, resolver));
 133     }
 134 }
 135 
 136 std::unique_ptr&lt;RootInlineBox&gt; ComplexLineLayout::createRootInlineBox()
 137 {
 138     if (is&lt;RenderSVGText&gt;(m_flow)) {
 139         auto box = makeUnique&lt;SVGRootInlineBox&gt;(downcast&lt;RenderSVGText&gt;(m_flow));
 140         box-&gt;setHasVirtualLogicalHeight();
 141         return box;
 142     }
 143 
 144     return makeUnique&lt;RootInlineBox&gt;(m_flow);
 145 }
 146 
 147 RootInlineBox* ComplexLineLayout::createAndAppendRootInlineBox()
 148 {
 149     auto newRootBox = createRootInlineBox();
 150     RootInlineBox* rootBox = newRootBox.get();
 151     m_lineBoxes.appendLineBox(WTFMove(newRootBox));
 152 
 153     if (UNLIKELY(AXObjectCache::accessibilityEnabled()) &amp;&amp; firstRootBox() == rootBox) {
 154         if (AXObjectCache* cache = m_flow.document().existingAXObjectCache())
 155             cache-&gt;deferRecomputeIsIgnored(m_flow.element());
 156     }
 157 
 158     return rootBox;
 159 }
 160 
 161 InlineBox* ComplexLineLayout::createInlineBoxForRenderer(RenderObject* renderer, bool isOnlyRun)
 162 {
 163     if (renderer == &amp;m_flow)
 164         return createAndAppendRootInlineBox();
 165 
 166     if (is&lt;RenderText&gt;(*renderer))
 167         return downcast&lt;RenderText&gt;(*renderer).createInlineTextBox();
 168 
 169     if (is&lt;RenderBox&gt;(*renderer)) {
 170         // FIXME: This is terrible. This branch returns an *owned* pointer!
 171         return downcast&lt;RenderBox&gt;(*renderer).createInlineBox().release();
 172     }
 173 
 174     if (is&lt;RenderLineBreak&gt;(*renderer)) {
 175         // FIXME: This is terrible. This branch returns an *owned* pointer!
 176         auto inlineBox = downcast&lt;RenderLineBreak&gt;(*renderer).createInlineBox().release();
 177         // We only treat a box as text for a &lt;br&gt; if we are on a line by ourself or in strict mode
 178         // (Note the use of strict mode. In &quot;almost strict&quot; mode, we don&#39;t treat the box for &lt;br&gt; as text.)
 179         inlineBox-&gt;setBehavesLikeText(isOnlyRun || renderer-&gt;document().inNoQuirksMode() || renderer-&gt;isLineBreakOpportunity());
 180         return inlineBox;
 181     }
 182 
 183     return downcast&lt;RenderInline&gt;(*renderer).createAndAppendInlineFlowBox();
 184 }
 185 
 186 static inline void dirtyLineBoxesForRenderer(RenderObject&amp; renderer, bool fullLayout)
 187 {
 188     if (is&lt;RenderText&gt;(renderer)) {
 189         RenderText&amp; renderText = downcast&lt;RenderText&gt;(renderer);
 190         updateCounterIfNeeded(renderText);
 191         renderText.dirtyLineBoxes(fullLayout);
 192     } else if (is&lt;RenderLineBreak&gt;(renderer))
 193         downcast&lt;RenderLineBreak&gt;(renderer).dirtyLineBoxes(fullLayout);
 194     else
 195         downcast&lt;RenderInline&gt;(renderer).dirtyLineBoxes(fullLayout);
 196 }
 197 
 198 static bool parentIsConstructedOrHaveNext(InlineFlowBox* parentBox)
 199 {
 200     do {
 201         if (parentBox-&gt;isConstructed() || parentBox-&gt;nextOnLine())
 202             return true;
 203         parentBox = parentBox-&gt;parent();
 204     } while (parentBox);
 205     return false;
 206 }
 207 
 208 InlineFlowBox* ComplexLineLayout::createLineBoxes(RenderObject* obj, const LineInfo&amp; lineInfo, InlineBox* childBox)
 209 {
 210     // See if we have an unconstructed line box for this object that is also
 211     // the last item on the line.
 212     unsigned lineDepth = 1;
 213     InlineFlowBox* parentBox = nullptr;
 214     InlineFlowBox* result = nullptr;
 215     bool hasDefaultLineBoxContain = style().lineBoxContain() == RenderStyle::initialLineBoxContain();
 216     do {
 217         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(is&lt;RenderInline&gt;(*obj) || obj == &amp;m_flow);
 218 
 219         RenderInline* inlineFlow = obj != &amp;m_flow ? downcast&lt;RenderInline&gt;(obj) : nullptr;
 220 
 221         // Get the last box we made for this render object.
 222         parentBox = inlineFlow ? inlineFlow-&gt;lastLineBox() : downcast&lt;RenderBlockFlow&gt;(*obj).lastRootBox();
 223 
 224         // If this box or its ancestor is constructed then it is from a previous line, and we need
 225         // to make a new box for our line. If this box or its ancestor is unconstructed but it has
 226         // something following it on the line, then we know we have to make a new box
 227         // as well. In this situation our inline has actually been split in two on
 228         // the same line (this can happen with very fancy language mixtures).
 229         bool constructedNewBox = false;
 230         bool allowedToConstructNewBox = !hasDefaultLineBoxContain || !inlineFlow || inlineFlow-&gt;alwaysCreateLineBoxes();
 231         bool canUseExistingParentBox = parentBox &amp;&amp; !parentIsConstructedOrHaveNext(parentBox);
 232         if (allowedToConstructNewBox &amp;&amp; !canUseExistingParentBox) {
 233             // We need to make a new box for this render object. Once
 234             // made, we need to place it at the end of the current line.
 235             InlineBox* newBox = createInlineBoxForRenderer(obj);
 236             parentBox = downcast&lt;InlineFlowBox&gt;(newBox);
 237             parentBox-&gt;setIsFirstLine(lineInfo.isFirstLine());
 238             parentBox-&gt;setIsHorizontal(m_flow.isHorizontalWritingMode());
 239             if (!hasDefaultLineBoxContain)
 240                 parentBox-&gt;clearDescendantsHaveSameLineHeightAndBaseline();
 241             constructedNewBox = true;
 242         }
 243 
 244         if (constructedNewBox || canUseExistingParentBox) {
 245             if (!result)
 246                 result = parentBox;
 247 
 248             // If we have hit the block itself, then |box| represents the root
 249             // inline box for the line, and it doesn&#39;t have to be appended to any parent
 250             // inline.
 251             if (childBox)
 252                 parentBox-&gt;addToLine(childBox);
 253 
 254             if (!constructedNewBox || obj == &amp;m_flow)
 255                 break;
 256 
 257             childBox = parentBox;
 258         }
 259 
 260         // If we&#39;ve exceeded our line depth, then jump straight to the root and skip all the remaining
 261         // intermediate inline flows.
 262         obj = (++lineDepth &gt;= cMaxLineDepth) ? &amp;m_flow : obj-&gt;parent();
 263 
 264     } while (true);
 265 
 266     return result;
 267 }
 268 
 269 template&lt;typename CharacterType&gt; static inline bool endsWithHTMLSpaces(const CharacterType* characters, unsigned position, unsigned end)
 270 {
 271     for (unsigned i = position; i &lt; end; ++i) {
 272         if (!isHTMLSpace(characters[i]))
 273             return false;
 274     }
 275     return true;
 276 }
 277 
 278 static bool reachedEndOfTextRenderer(const BidiRunList&lt;BidiRun&gt;&amp; bidiRuns)
 279 {
 280     BidiRun* run = bidiRuns.logicallyLastRun();
 281     if (!run)
 282         return true;
 283     if (!is&lt;RenderText&gt;(run-&gt;renderer()))
 284         return false;
 285     auto&amp; text = downcast&lt;RenderText&gt;(run-&gt;renderer()).text();
 286     unsigned position = run-&gt;stop();
 287     unsigned length = text.length();
 288     if (text.is8Bit())
 289         return endsWithHTMLSpaces(text.characters8(), position, length);
 290     return endsWithHTMLSpaces(text.characters16(), position, length);
 291 }
 292 
 293 RootInlineBox* ComplexLineLayout::constructLine(BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, const LineInfo&amp; lineInfo)
 294 {
 295     ASSERT(bidiRuns.firstRun());
 296 
 297     bool rootHasSelectedChildren = false;
 298     InlineFlowBox* parentBox = 0;
 299     int runCount = bidiRuns.runCount() - lineInfo.runsFromLeadingWhitespace();
 300 
 301     for (BidiRun* r = bidiRuns.firstRun(); r; r = r-&gt;next()) {
 302         // Create a box for our object.
 303         bool isOnlyRun = (runCount == 1);
 304         if (runCount == 2 &amp;&amp; !r-&gt;renderer().isListMarker())
 305             isOnlyRun = (!style().isLeftToRightDirection() ? bidiRuns.lastRun() : bidiRuns.firstRun())-&gt;renderer().isListMarker();
 306 
 307         if (lineInfo.isEmpty())
 308             continue;
 309 
 310         InlineBox* box = createInlineBoxForRenderer(&amp;r-&gt;renderer(), isOnlyRun);
 311         r-&gt;setBox(box);
 312 
 313         if (!rootHasSelectedChildren &amp;&amp; box-&gt;renderer().selectionState() != RenderObject::SelectionNone)
 314             rootHasSelectedChildren = true;
 315 
 316         // If we have no parent box yet, or if the run is not simply a sibling,
 317         // then we need to construct inline boxes as necessary to properly enclose the
 318         // run&#39;s inline box. Segments can only be siblings at the root level, as
 319         // they are positioned separately.
 320         if (!parentBox || &amp;parentBox-&gt;renderer() != r-&gt;renderer().parent()) {
 321             // Create new inline boxes all the way back to the appropriate insertion point.
 322             RenderObject* parentToUse = r-&gt;renderer().parent();
 323             parentBox = createLineBoxes(parentToUse, lineInfo, box);
 324         } else {
 325             // Append the inline box to this line.
 326             parentBox-&gt;addToLine(box);
 327         }
 328 
 329         bool visuallyOrdered = r-&gt;renderer().style().rtlOrdering() == Order::Visual;
 330         box-&gt;setBidiLevel(r-&gt;level());
 331 
 332         if (is&lt;InlineTextBox&gt;(*box)) {
 333             auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*box);
 334             textBox.setStart(r-&gt;m_start);
 335             textBox.setLen(r-&gt;m_stop - r-&gt;m_start);
 336             textBox.setDirOverride(r-&gt;dirOverride(visuallyOrdered));
 337             if (r-&gt;m_hasHyphen)
 338                 textBox.setHasHyphen(true);
 339         }
 340     }
 341 
 342     // We should have a root inline box. It should be unconstructed and
 343     // be the last continuation of our line list.
 344     ASSERT(lastRootBox() &amp;&amp; !lastRootBox()-&gt;isConstructed());
 345 
 346     // Set the m_selectedChildren flag on the root inline box if one of the leaf inline box
 347     // from the bidi runs walk above has a selection state.
 348     if (rootHasSelectedChildren)
 349         lastRootBox()-&gt;root().setHasSelectedChildren(true);
 350 
 351     // Set bits on our inline flow boxes that indicate which sides should
 352     // paint borders/margins/padding. This knowledge will ultimately be used when
 353     // we determine the horizontal positions and widths of all the inline boxes on
 354     // the line.
 355     bool isLogicallyLastRunWrapped = bidiRuns.logicallyLastRun()-&gt;renderer().isText() ? !reachedEndOfTextRenderer(bidiRuns) : !is&lt;RenderInline&gt;(bidiRuns.logicallyLastRun()-&gt;renderer());
 356     lastRootBox()-&gt;determineSpacingForFlowBoxes(lineInfo.isLastLine(), isLogicallyLastRunWrapped, &amp;bidiRuns.logicallyLastRun()-&gt;renderer());
 357 
 358     // Now mark the line boxes as being constructed.
 359     lastRootBox()-&gt;setConstructed();
 360 
 361     // Return the last line.
 362     return lastRootBox();
 363 }
 364 
 365 TextAlignMode ComplexLineLayout::textAlignmentForLine(bool endsWithSoftBreak) const
 366 {
 367     if (auto overrideAlignment = m_flow.overrideTextAlignmentForLine(endsWithSoftBreak))
 368         return *overrideAlignment;
 369 
 370     TextAlignMode alignment = style().textAlign();
 371 #if ENABLE(CSS3_TEXT)
 372     TextJustify textJustify = style().textJustify();
 373     if (alignment == TextAlignMode::Justify &amp;&amp; textJustify == TextJustify::None)
 374         return style().direction() == TextDirection::LTR ? TextAlignMode::Left : TextAlignMode::Right;
 375 #endif
 376 
 377     if (endsWithSoftBreak)
 378         return alignment;
 379 
 380 #if !ENABLE(CSS3_TEXT)
 381     return (alignment == TextAlignMode::Justify) ? TextAlignMode::Start : alignment;
 382 #else
 383     if (alignment != TextAlignMode::Justify)
 384         return alignment;
 385 
 386     TextAlignLast alignmentLast = style().textAlignLast();
 387     switch (alignmentLast) {
 388     case TextAlignLast::Start:
 389         return TextAlignMode::Start;
 390     case TextAlignLast::End:
 391         return TextAlignMode::End;
 392     case TextAlignLast::Left:
 393         return TextAlignMode::Left;
 394     case TextAlignLast::Right:
 395         return TextAlignMode::Right;
 396     case TextAlignLast::Center:
 397         return TextAlignMode::Center;
 398     case TextAlignLast::Justify:
 399         return TextAlignMode::Justify;
 400     case TextAlignLast::Auto:
 401         if (textJustify == TextJustify::Distribute)
 402             return TextAlignMode::Justify;
 403         return TextAlignMode::Start;
 404     }
 405     return alignment;
 406 #endif
 407 }
 408 
 409 static void updateLogicalWidthForLeftAlignedBlock(bool isLeftToRightDirection, BidiRun* trailingSpaceRun, float&amp; logicalLeft, float&amp; totalLogicalWidth, float availableLogicalWidth)
 410 {
 411     // The direction of the block should determine what happens with wide lines.
 412     // In particular with RTL blocks, wide lines should still spill out to the left.
 413     if (isLeftToRightDirection) {
 414         if (totalLogicalWidth &gt; availableLogicalWidth &amp;&amp; trailingSpaceRun)
 415             trailingSpaceRun-&gt;box()-&gt;setLogicalWidth(std::max&lt;float&gt;(0, trailingSpaceRun-&gt;box()-&gt;logicalWidth() - totalLogicalWidth + availableLogicalWidth));
 416         return;
 417     }
 418 
 419     if (trailingSpaceRun)
 420         trailingSpaceRun-&gt;box()-&gt;setLogicalWidth(0);
 421     else if (totalLogicalWidth &gt; availableLogicalWidth)
 422         logicalLeft -= (totalLogicalWidth - availableLogicalWidth);
 423 }
 424 
 425 static void updateLogicalWidthForRightAlignedBlock(bool isLeftToRightDirection, BidiRun* trailingSpaceRun, float&amp; logicalLeft, float&amp; totalLogicalWidth, float availableLogicalWidth)
 426 {
 427     // Wide lines spill out of the block based off direction.
 428     // So even if text-align is right, if direction is LTR, wide lines should overflow out of the right
 429     // side of the block.
 430     if (isLeftToRightDirection) {
 431         if (trailingSpaceRun) {
 432             totalLogicalWidth -= trailingSpaceRun-&gt;box()-&gt;logicalWidth();
 433             trailingSpaceRun-&gt;box()-&gt;setLogicalWidth(0);
 434         }
 435         logicalLeft += std::max(0.f, availableLogicalWidth - totalLogicalWidth);
 436         return;
 437     }
 438 
 439     if (totalLogicalWidth &gt; availableLogicalWidth &amp;&amp; trailingSpaceRun) {
 440         trailingSpaceRun-&gt;box()-&gt;setLogicalWidth(std::max&lt;float&gt;(0, trailingSpaceRun-&gt;box()-&gt;logicalWidth() - totalLogicalWidth + availableLogicalWidth));
 441         totalLogicalWidth -= trailingSpaceRun-&gt;box()-&gt;logicalWidth();
 442     } else
 443         logicalLeft += availableLogicalWidth - totalLogicalWidth;
 444 }
 445 
 446 static void updateLogicalWidthForCenterAlignedBlock(bool isLeftToRightDirection, BidiRun* trailingSpaceRun, float&amp; logicalLeft, float&amp; totalLogicalWidth, float availableLogicalWidth)
 447 {
 448     float trailingSpaceWidth = 0;
 449     if (trailingSpaceRun) {
 450         totalLogicalWidth -= trailingSpaceRun-&gt;box()-&gt;logicalWidth();
 451         trailingSpaceWidth = std::min(trailingSpaceRun-&gt;box()-&gt;logicalWidth(), (availableLogicalWidth - totalLogicalWidth + 1) / 2);
 452         trailingSpaceRun-&gt;box()-&gt;setLogicalWidth(std::max&lt;float&gt;(0, trailingSpaceWidth));
 453     }
 454     if (isLeftToRightDirection)
 455         logicalLeft += std::max&lt;float&gt;((availableLogicalWidth - totalLogicalWidth) / 2, 0);
 456     else
 457         logicalLeft += totalLogicalWidth &gt; availableLogicalWidth ? (availableLogicalWidth - totalLogicalWidth) : (availableLogicalWidth - totalLogicalWidth) / 2 - trailingSpaceWidth;
 458 }
 459 
 460 void ComplexLineLayout::setMarginsForRubyRun(BidiRun* run, RenderRubyRun&amp; renderer, RenderObject* previousObject, const LineInfo&amp; lineInfo)
 461 {
 462     float startOverhang;
 463     float endOverhang;
 464     RenderObject* nextObject = 0;
 465     for (BidiRun* runWithNextObject = run-&gt;next(); runWithNextObject; runWithNextObject = runWithNextObject-&gt;next()) {
 466         if (!runWithNextObject-&gt;renderer().isOutOfFlowPositioned() &amp;&amp; !runWithNextObject-&gt;box()-&gt;isLineBreak()) {
 467             nextObject = &amp;runWithNextObject-&gt;renderer();
 468             break;
 469         }
 470     }
 471     renderer.getOverhang(lineInfo.isFirstLine(), renderer.style().isLeftToRightDirection() ? previousObject : nextObject, renderer.style().isLeftToRightDirection() ? nextObject : previousObject, startOverhang, endOverhang);
 472     m_flow.setMarginStartForChild(renderer, LayoutUnit(-startOverhang));
 473     m_flow.setMarginEndForChild(renderer, LayoutUnit(-endOverhang));
 474 }
 475 
 476 static inline void setLogicalWidthForTextRun(RootInlineBox* lineBox, BidiRun* run, RenderText&amp; renderer, float xPos, const LineInfo&amp; lineInfo,
 477     GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp; verticalPositionCache, WordMeasurements&amp; wordMeasurements)
 478 {
 479     HashSet&lt;const Font*&gt; fallbackFonts;
 480     GlyphOverflow glyphOverflow;
 481 
 482     const FontCascade&amp; font = lineStyle(*renderer.parent(), lineInfo).fontCascade();
 483     // Always compute glyph overflow if the block&#39;s line-box-contain value is &quot;glyphs&quot;.
 484     if (lineBox-&gt;fitsToGlyphs()) {
 485         // If we don&#39;t stick out of the root line&#39;s font box, then don&#39;t bother computing our glyph overflow. This optimization
 486         // will keep us from computing glyph bounds in nearly all cases.
 487         bool includeRootLine = lineBox-&gt;includesRootLineBoxFontOrLeading();
 488         int baselineShift = lineBox-&gt;verticalPositionForBox(run-&gt;box(), verticalPositionCache);
 489         int rootDescent = includeRootLine ? font.fontMetrics().descent() : 0;
 490         int rootAscent = includeRootLine ? font.fontMetrics().ascent() : 0;
 491         int boxAscent = font.fontMetrics().ascent() - baselineShift;
 492         int boxDescent = font.fontMetrics().descent() + baselineShift;
 493         if (boxAscent &gt; rootDescent ||  boxDescent &gt; rootAscent)
 494             glyphOverflow.computeBounds = true;
 495     }
 496 
 497     LayoutUnit hyphenWidth;
 498     if (downcast&lt;InlineTextBox&gt;(*run-&gt;box()).hasHyphen())
 499         hyphenWidth = measureHyphenWidth(renderer, font, &amp;fallbackFonts);
 500 
 501     float measuredWidth = 0;
 502 
 503     bool kerningIsEnabled = font.enableKerning();
 504     bool canUseSimpleFontCodePath = renderer.canUseSimpleFontCodePath();
 505 
 506     // Since we don&#39;t cache glyph overflows, we need to re-measure the run if
 507     // the style is linebox-contain: glyph.
 508     if (!lineBox-&gt;fitsToGlyphs() &amp;&amp; canUseSimpleFontCodePath) {
 509         unsigned lastEndOffset = run-&gt;m_start;
 510         bool atFirstWordMeasurement = true;
 511         for (size_t i = 0, size = wordMeasurements.size(); i &lt; size &amp;&amp; lastEndOffset &lt; run-&gt;m_stop; ++i) {
 512             WordMeasurement&amp; wordMeasurement = wordMeasurements[i];
 513             if (wordMeasurement.width &lt;= 0 || wordMeasurement.startOffset == wordMeasurement.endOffset)
 514                 continue;
 515             if (wordMeasurement.renderer != &amp;renderer || wordMeasurement.startOffset != lastEndOffset || wordMeasurement.endOffset &gt; run-&gt;m_stop)
 516                 continue;
 517 
 518             lastEndOffset = wordMeasurement.endOffset;
 519             if (kerningIsEnabled &amp;&amp; lastEndOffset == run-&gt;m_stop) {
 520                 int wordLength = lastEndOffset - wordMeasurement.startOffset;
 521                 GlyphOverflow overflow;
 522                 measuredWidth += renderer.width(wordMeasurement.startOffset, wordLength, xPos + measuredWidth, lineInfo.isFirstLine(),
 523                     &amp;wordMeasurement.fallbackFonts, &amp;overflow);
 524                 UChar c = renderer.characterAt(wordMeasurement.startOffset);
 525                 // renderer.width() omits word-spacing value for leading whitespace, so let&#39;s just add it back here.
 526                 if (!atFirstWordMeasurement &amp;&amp; FontCascade::treatAsSpace(c))
 527                     measuredWidth += renderer.style().fontCascade().wordSpacing();
 528             } else
 529                 measuredWidth += wordMeasurement.width;
 530             atFirstWordMeasurement = false;
 531 
 532             if (!wordMeasurement.fallbackFonts.isEmpty()) {
 533                 HashSet&lt;const Font*&gt;::const_iterator end = wordMeasurement.fallbackFonts.end();
 534                 for (HashSet&lt;const Font*&gt;::const_iterator it = wordMeasurement.fallbackFonts.begin(); it != end; ++it)
 535                     fallbackFonts.add(*it);
 536             }
 537         }
 538         if (measuredWidth &amp;&amp; lastEndOffset != run-&gt;m_stop) {
 539             // If we don&#39;t have enough cached data, we&#39;ll measure the run again.
 540             measuredWidth = 0;
 541             fallbackFonts.clear();
 542         }
 543     }
 544 
 545     if (!measuredWidth)
 546         measuredWidth = renderer.width(run-&gt;m_start, run-&gt;m_stop - run-&gt;m_start, xPos, lineInfo.isFirstLine(), &amp;fallbackFonts, &amp;glyphOverflow);
 547 
 548     run-&gt;box()-&gt;setLogicalWidth(measuredWidth + hyphenWidth);
 549     if (!fallbackFonts.isEmpty()) {
 550         ASSERT(run-&gt;box()-&gt;behavesLikeText());
 551         GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.add(downcast&lt;InlineTextBox&gt;(run-&gt;box()), std::make_pair(Vector&lt;const Font*&gt;(), GlyphOverflow())).iterator;
 552         ASSERT(it-&gt;value.first.isEmpty());
 553         it-&gt;value.first = copyToVector(fallbackFonts);
 554         run-&gt;box()-&gt;parent()-&gt;clearDescendantsHaveSameLineHeightAndBaseline();
 555     }
 556 
 557     // Include text decoration visual overflow as part of the glyph overflow.
 558     if (!renderer.style().textDecorationsInEffect().isEmpty())
 559         glyphOverflow.extendTo(visualOverflowForDecorations(run-&gt;box()-&gt;lineStyle(), downcast&lt;InlineTextBox&gt;(run-&gt;box())));
 560 
 561     if (!glyphOverflow.isEmpty()) {
 562         ASSERT(run-&gt;box()-&gt;behavesLikeText());
 563         GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.add(downcast&lt;InlineTextBox&gt;(run-&gt;box()), std::make_pair(Vector&lt;const Font*&gt;(), GlyphOverflow())).iterator;
 564         it-&gt;value.second = glyphOverflow;
 565         run-&gt;box()-&gt;clearKnownToHaveNoOverflow();
 566     }
 567 }
 568 
 569 void ComplexLineLayout::updateRubyForJustifiedText(RenderRubyRun&amp; rubyRun, BidiRun&amp; r, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned&amp; expansionOpportunityCount, float&amp; totalLogicalWidth, float availableLogicalWidth, size_t&amp; i)
 570 {
 571     if (!rubyRun.rubyBase() || !rubyRun.rubyBase()-&gt;firstRootBox() || rubyRun.rubyBase()-&gt;firstRootBox()-&gt;nextRootBox() || !r.renderer().style().collapseWhiteSpace())
 572         return;
 573 
 574     auto&amp; rubyBase = *rubyRun.rubyBase();
 575     auto&amp; rootBox = *rubyBase.firstRootBox();
 576 
 577     float totalExpansion = 0;
 578     unsigned totalOpportunitiesInRun = 0;
 579     for (auto* leafChild = rootBox.firstLeafDescendant(); leafChild; leafChild = leafChild-&gt;nextLeafOnLine()) {
 580         if (!leafChild-&gt;isInlineTextBox())
 581             continue;
 582 
 583         unsigned opportunitiesInRun = expansionOpportunities[i++];
 584         ASSERT(opportunitiesInRun &lt;= expansionOpportunityCount);
 585         auto expansion = (availableLogicalWidth - totalLogicalWidth) * opportunitiesInRun / expansionOpportunityCount;
 586         totalExpansion += expansion;
 587         totalOpportunitiesInRun += opportunitiesInRun;
 588     }
 589 
 590     ASSERT(!rubyRun.hasOverrideContentLogicalWidth());
 591     float newBaseWidth = rubyRun.logicalWidth() + totalExpansion + m_flow.marginStartForChild(rubyRun) + m_flow.marginEndForChild(rubyRun);
 592     float newRubyRunWidth = rubyRun.logicalWidth() + totalExpansion;
 593     rubyBase.setInitialOffset((newRubyRunWidth - newBaseWidth) / 2);
 594     rubyRun.setOverrideContentLogicalWidth(LayoutUnit(newRubyRunWidth));
 595     rubyRun.setNeedsLayout(MarkOnlyThis);
 596     rootBox.markDirty();
 597     if (RenderRubyText* rubyText = rubyRun.rubyText()) {
 598         if (RootInlineBox* textRootBox = rubyText-&gt;firstRootBox())
 599             textRootBox-&gt;markDirty();
 600     }
 601     rubyRun.layoutBlock(true);
 602     rubyRun.clearOverrideContentLogicalWidth();
 603     r.box()-&gt;setExpansion(newRubyRunWidth - r.box()-&gt;logicalWidth());
 604 
 605     totalLogicalWidth += totalExpansion;
 606     expansionOpportunityCount -= totalOpportunitiesInRun;
 607 }
 608 
 609 void ComplexLineLayout::computeExpansionForJustifiedText(BidiRun* firstRun, BidiRun* trailingSpaceRun, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned expansionOpportunityCount, float totalLogicalWidth, float availableLogicalWidth)
 610 {
 611     if (!expansionOpportunityCount || availableLogicalWidth &lt;= totalLogicalWidth)
 612         return;
 613 
 614     size_t i = 0;
 615     for (BidiRun* run = firstRun; run; run = run-&gt;next()) {
 616         if (!run-&gt;box() || run == trailingSpaceRun)
 617             continue;
 618 
 619         if (is&lt;RenderText&gt;(run-&gt;renderer())) {
 620             unsigned opportunitiesInRun = expansionOpportunities[i++];
 621 
 622             ASSERT(opportunitiesInRun &lt;= expansionOpportunityCount);
 623 
 624             // Only justify text if whitespace is collapsed.
 625             if (run-&gt;renderer().style().collapseWhiteSpace()) {
 626                 InlineTextBox&amp; textBox = downcast&lt;InlineTextBox&gt;(*run-&gt;box());
 627                 float expansion = (availableLogicalWidth - totalLogicalWidth) * opportunitiesInRun / expansionOpportunityCount;
 628                 textBox.setExpansion(expansion);
 629                 totalLogicalWidth += expansion;
 630             }
 631             expansionOpportunityCount -= opportunitiesInRun;
 632         } else if (is&lt;RenderRubyRun&gt;(run-&gt;renderer()))
 633             updateRubyForJustifiedText(downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()), *run, expansionOpportunities, expansionOpportunityCount, totalLogicalWidth, availableLogicalWidth, i);
 634 
 635         if (!expansionOpportunityCount)
 636             break;
 637     }
 638 }
 639 
 640 void ComplexLineLayout::updateLogicalWidthForAlignment(RenderBlockFlow&amp; flow, const TextAlignMode&amp; textAlign, const RootInlineBox* rootInlineBox, BidiRun* trailingSpaceRun, float&amp; logicalLeft, float&amp; totalLogicalWidth, float&amp; availableLogicalWidth, int expansionOpportunityCount)
 641 {
 642     TextDirection direction;
 643     if (rootInlineBox &amp;&amp; flow.style().unicodeBidi() == Plaintext)
 644         direction = rootInlineBox-&gt;direction();
 645     else
 646         direction = flow.style().direction();
 647 
 648     bool isLeftToRightDirection = flow.style().isLeftToRightDirection();
 649 
 650     // Armed with the total width of the line (without justification),
 651     // we now examine our text-align property in order to determine where to position the
 652     // objects horizontally. The total width of the line can be increased if we end up
 653     // justifying text.
 654     switch (textAlign) {
 655     case TextAlignMode::Left:
 656     case TextAlignMode::WebKitLeft:
 657         updateLogicalWidthForLeftAlignedBlock(isLeftToRightDirection, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth);
 658         break;
 659     case TextAlignMode::Right:
 660     case TextAlignMode::WebKitRight:
 661         updateLogicalWidthForRightAlignedBlock(isLeftToRightDirection, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth);
 662         break;
 663     case TextAlignMode::Center:
 664     case TextAlignMode::WebKitCenter:
 665         updateLogicalWidthForCenterAlignedBlock(isLeftToRightDirection, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth);
 666         break;
 667     case TextAlignMode::Justify:
 668         flow.adjustInlineDirectionLineBounds(expansionOpportunityCount, logicalLeft, availableLogicalWidth);
 669         if (expansionOpportunityCount) {
 670             if (trailingSpaceRun) {
 671                 totalLogicalWidth -= trailingSpaceRun-&gt;box()-&gt;logicalWidth();
 672                 trailingSpaceRun-&gt;box()-&gt;setLogicalWidth(0);
 673             }
 674             break;
 675         }
 676         FALLTHROUGH;
 677     case TextAlignMode::Start:
 678         if (direction == TextDirection::LTR)
 679             updateLogicalWidthForLeftAlignedBlock(isLeftToRightDirection, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth);
 680         else
 681             updateLogicalWidthForRightAlignedBlock(isLeftToRightDirection, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth);
 682         break;
 683     case TextAlignMode::End:
 684         if (direction == TextDirection::LTR)
 685             updateLogicalWidthForRightAlignedBlock(isLeftToRightDirection, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth);
 686         else
 687             updateLogicalWidthForLeftAlignedBlock(isLeftToRightDirection, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth);
 688         break;
 689     }
 690 }
 691 
 692 static void updateLogicalInlinePositions(RenderBlockFlow&amp; block, float&amp; lineLogicalLeft, float&amp; lineLogicalRight, float&amp; availableLogicalWidth, bool firstLine,
 693     IndentTextOrNot shouldIndentText, LayoutUnit boxLogicalHeight)
 694 {
 695     LayoutUnit lineLogicalHeight = block.minLineHeightForReplacedRenderer(firstLine, boxLogicalHeight);
 696     lineLogicalLeft = block.logicalLeftOffsetForLine(block.logicalHeight(), shouldIndentText, lineLogicalHeight);
 697     lineLogicalRight = block.logicalRightOffsetForLine(block.logicalHeight(), shouldIndentText, lineLogicalHeight);
 698     availableLogicalWidth = lineLogicalRight - lineLogicalLeft;
 699 }
 700 
 701 void ComplexLineLayout::computeInlineDirectionPositionsForLine(RootInlineBox* lineBox, const LineInfo&amp; lineInfo, BidiRun* firstRun, BidiRun* trailingSpaceRun, bool reachedEnd, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp; verticalPositionCache, WordMeasurements&amp; wordMeasurements)
 702 {
 703     TextAlignMode textAlign = textAlignmentForLine(!reachedEnd &amp;&amp; !lineBox-&gt;endsWithBreak());
 704 
 705     // CSS 2.1: &quot;&#39;Text-indent&#39; only affects a line if it is the first formatted line of an element. For example, the first line of an anonymous block
 706     // box is only affected if it is the first child of its parent element.&quot;
 707     // CSS3 &quot;text-indent&quot;, &quot;-webkit-each-line&quot; affects the first line of the block container as well as each line after a forced line break,
 708     // but does not affect lines after a soft wrap break.
 709     bool isFirstLine = lineInfo.isFirstLine() &amp;&amp; !(m_flow.isAnonymousBlock() &amp;&amp; m_flow.parent()-&gt;firstChild() != &amp;m_flow);
 710     bool isAfterHardLineBreak = lineBox-&gt;prevRootBox() &amp;&amp; lineBox-&gt;prevRootBox()-&gt;endsWithBreak();
 711     IndentTextOrNot shouldIndentText = requiresIndent(isFirstLine, isAfterHardLineBreak, style());
 712     float lineLogicalLeft;
 713     float lineLogicalRight;
 714     float availableLogicalWidth;
 715     updateLogicalInlinePositions(m_flow, lineLogicalLeft, lineLogicalRight, availableLogicalWidth, isFirstLine, shouldIndentText, 0);
 716     bool needsWordSpacing;
 717 
 718     if (firstRun &amp;&amp; firstRun-&gt;renderer().isReplaced()) {
 719         RenderBox&amp; renderBox = downcast&lt;RenderBox&gt;(firstRun-&gt;renderer());
 720         updateLogicalInlinePositions(m_flow, lineLogicalLeft, lineLogicalRight, availableLogicalWidth, isFirstLine, shouldIndentText, renderBox.logicalHeight());
 721     }
 722 
 723     computeInlineDirectionPositionsForSegment(lineBox, lineInfo, textAlign, lineLogicalLeft, availableLogicalWidth, firstRun, trailingSpaceRun, textBoxDataMap, verticalPositionCache, wordMeasurements);
 724     // The widths of all runs are now known. We can now place every inline box (and
 725     // compute accurate widths for the inline flow boxes).
 726     needsWordSpacing = false;
 727     lineBox-&gt;placeBoxesInInlineDirection(lineLogicalLeft, needsWordSpacing);
 728 }
 729 
 730 static inline ExpansionBehavior expansionBehaviorForInlineTextBox(RenderBlockFlow&amp; block, InlineTextBox&amp; textBox, BidiRun* previousRun, BidiRun* nextRun, TextAlignMode textAlign, bool isAfterExpansion)
 731 {
 732     // Tatechuyoko is modeled as the Object Replacement Character (U+FFFC), which can never have expansion opportunities inside nor intrinsically adjacent to it.
 733     if (textBox.renderer().style().textCombine() == TextCombine::Horizontal)
 734         return ForbidLeadingExpansion | ForbidTrailingExpansion;
 735 
 736     ExpansionBehavior result = 0;
 737     bool setLeadingExpansion = false;
 738     bool setTrailingExpansion = false;
 739     if (textAlign == TextAlignMode::Justify) {
 740         // If the next box is ruby, and we&#39;re justifying, and the first box in the ruby base has a leading expansion, and we are a text box, then force a trailing expansion.
 741         if (nextRun &amp;&amp; is&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase() &amp;&amp; nextRun-&gt;renderer().style().collapseWhiteSpace()) {
 742             auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(nextRun-&gt;renderer()).rubyBase();
 743             if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
 744                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;firstLeafDescendant()) {
 745                     if (is&lt;InlineTextBox&gt;(*leafChild)) {
 746                         // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
 747                         if (FontCascade::leadingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
 748                             setTrailingExpansion = true;
 749                             result |= ForceTrailingExpansion;
 750                         }
 751                     }
 752                 }
 753             }
 754         }
 755         // Same thing, except if we&#39;re following a ruby
 756         if (previousRun &amp;&amp; is&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()) &amp;&amp; downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase() &amp;&amp; previousRun-&gt;renderer().style().collapseWhiteSpace()) {
 757             auto&amp; rubyBase = *downcast&lt;RenderRubyRun&gt;(previousRun-&gt;renderer()).rubyBase();
 758             if (rubyBase.firstRootBox() &amp;&amp; !rubyBase.firstRootBox()-&gt;nextRootBox()) {
 759                 if (auto* leafChild = rubyBase.firstRootBox()-&gt;lastLeafDescendant()) {
 760                     if (is&lt;InlineTextBox&gt;(*leafChild)) {
 761                         // FIXME: This leadingExpansionOpportunity doesn&#39;t actually work because it doesn&#39;t perform the UBA
 762                         if (FontCascade::trailingExpansionOpportunity(downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction())) {
 763                             setLeadingExpansion = true;
 764                             result |= ForceLeadingExpansion;
 765                         }
 766                     }
 767                 }
 768             }
 769         }
 770         // If we&#39;re the first box inside a ruby base, forbid a leading expansion, and vice-versa
 771         if (is&lt;RenderRubyBase&gt;(block)) {
 772             RenderRubyBase&amp; rubyBase = downcast&lt;RenderRubyBase&gt;(block);
 773             if (&amp;textBox == rubyBase.firstRootBox()-&gt;firstLeafDescendant()) {
 774                 setLeadingExpansion = true;
 775                 result |= ForbidLeadingExpansion;
 776             } if (&amp;textBox == rubyBase.firstRootBox()-&gt;lastLeafDescendant()) {
 777                 setTrailingExpansion = true;
 778                 result |= ForbidTrailingExpansion;
 779             }
 780         }
 781     }
 782     if (!setLeadingExpansion)
 783         result |= isAfterExpansion ? ForbidLeadingExpansion : AllowLeadingExpansion;
 784     if (!setTrailingExpansion)
 785         result |= AllowTrailingExpansion;
 786     return result;
 787 }
 788 
 789 static inline void applyExpansionBehavior(InlineTextBox&amp; textBox, ExpansionBehavior expansionBehavior)
 790 {
 791     switch (expansionBehavior &amp; LeadingExpansionMask) {
 792     case ForceLeadingExpansion:
 793         textBox.setForceLeadingExpansion();
 794         break;
 795     case ForbidLeadingExpansion:
 796         textBox.setCanHaveLeadingExpansion(false);
 797         break;
 798     case AllowLeadingExpansion:
 799         textBox.setCanHaveLeadingExpansion(true);
 800         break;
 801     default:
 802         ASSERT_NOT_REACHED();
 803         break;
 804     }
 805     switch (expansionBehavior &amp; TrailingExpansionMask) {
 806     case ForceTrailingExpansion:
 807         textBox.setForceTrailingExpansion();
 808         break;
 809     case ForbidTrailingExpansion:
 810         textBox.setCanHaveTrailingExpansion(false);
 811         break;
 812     case AllowTrailingExpansion:
 813         textBox.setCanHaveTrailingExpansion(true);
 814         break;
 815     default:
 816         ASSERT_NOT_REACHED();
 817         break;
 818     }
 819 }
 820 
 821 static bool inlineAncestorHasStartBorderPaddingOrMargin(const RenderBlockFlow&amp; block, const InlineBox&amp; box)
 822 {
 823     bool isLTR = block.style().isLeftToRightDirection();
 824     for (auto* currentBox = box.parent(); currentBox; currentBox = currentBox-&gt;parent()) {
 825         if ((isLTR &amp;&amp; currentBox-&gt;marginBorderPaddingLogicalLeft() &gt; 0)
 826             || (!isLTR &amp;&amp; currentBox-&gt;marginBorderPaddingLogicalRight() &gt; 0))
 827             return true;
 828     }
 829     return false;
 830 }
 831 
 832 static bool inlineAncestorHasEndBorderPaddingOrMargin(const RenderBlockFlow&amp; block, const InlineBox&amp; box)
 833 {
 834     bool isLTR = block.style().isLeftToRightDirection();
 835     for (auto* currentBox = box.parent(); currentBox; currentBox = currentBox-&gt;parent()) {
 836         if ((isLTR &amp;&amp; currentBox-&gt;marginBorderPaddingLogicalRight() &gt; 0)
 837             || (!isLTR &amp;&amp; currentBox-&gt;marginBorderPaddingLogicalLeft() &gt; 0))
 838             return true;
 839     }
 840     return false;
 841 }
 842 
 843 static bool isLastInFlowRun(BidiRun&amp; runToCheck)
 844 {
 845     for (auto* run = runToCheck.next(); run; run = run-&gt;next()) {
 846         if (!run-&gt;box() || run-&gt;renderer().isOutOfFlowPositioned() || run-&gt;box()-&gt;isLineBreak())
 847             continue;
 848         return false;
 849     }
 850     return true;
 851 }
 852 
 853 BidiRun* ComplexLineLayout::computeInlineDirectionPositionsForSegment(RootInlineBox* lineBox, const LineInfo&amp; lineInfo, TextAlignMode textAlign, float&amp; logicalLeft,
 854     float&amp; availableLogicalWidth, BidiRun* firstRun, BidiRun* trailingSpaceRun, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp; verticalPositionCache,
 855     WordMeasurements&amp; wordMeasurements)
 856 {
 857     bool needsWordSpacing = false;
 858     bool canHangPunctuationAtStart = style().hangingPunctuation().contains(HangingPunctuation::First);
 859     bool canHangPunctuationAtEnd = style().hangingPunctuation().contains(HangingPunctuation::Last);
 860     bool isLTR = style().isLeftToRightDirection();
 861     float totalLogicalWidth = lineBox-&gt;getFlowSpacingLogicalWidth();
 862     unsigned expansionOpportunityCount = 0;
 863     bool isAfterExpansion = is&lt;RenderRubyBase&gt;(m_flow) ? downcast&lt;RenderRubyBase&gt;(m_flow).isAfterExpansion() : true;
 864     Vector&lt;unsigned, 16&gt; expansionOpportunities;
 865 
 866     BidiRun* run = firstRun;
 867     BidiRun* previousRun = nullptr;
 868     for (; run; run = run-&gt;next()) {
 869         auto computeExpansionOpportunities = [&amp;expansionOpportunities, &amp;expansionOpportunityCount, textAlign, &amp;isAfterExpansion] (RenderBlockFlow&amp; block,
 870             InlineTextBox&amp; textBox, BidiRun* previousRun, BidiRun* nextRun, const StringView&amp; stringView, TextDirection direction)
 871         {
 872             if (stringView.isEmpty()) {
 873                 // Empty runs should still produce an entry in expansionOpportunities list so that the number of items matches the number of runs.
 874                 expansionOpportunities.append(0);
 875                 return;
 876             }
 877             ExpansionBehavior expansionBehavior = expansionBehaviorForInlineTextBox(block, textBox, previousRun, nextRun, textAlign, isAfterExpansion);
 878             applyExpansionBehavior(textBox, expansionBehavior);
 879             unsigned opportunitiesInRun;
 880             std::tie(opportunitiesInRun, isAfterExpansion) = FontCascade::expansionOpportunityCount(stringView, direction, expansionBehavior);
 881             expansionOpportunities.append(opportunitiesInRun);
 882             expansionOpportunityCount += opportunitiesInRun;
 883         };
 884         if (!run-&gt;box() || run-&gt;renderer().isOutOfFlowPositioned() || run-&gt;box()-&gt;isLineBreak()) {
 885             // Positioned objects are only participating to figure out their correct static x position.
 886             // They have no effect on the width. Similarly, line break boxes have no effect on the width.
 887             continue;
 888         }
 889         if (is&lt;RenderText&gt;(run-&gt;renderer())) {
 890             auto&amp; renderText = downcast&lt;RenderText&gt;(run-&gt;renderer());
 891             auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*run-&gt;box());
 892             if (canHangPunctuationAtStart &amp;&amp; lineInfo.isFirstLine() &amp;&amp; (isLTR || isLastInFlowRun(*run))
 893                 &amp;&amp; !inlineAncestorHasStartBorderPaddingOrMargin(m_flow, *run-&gt;box())) {
 894                 float hangStartWidth = renderText.hangablePunctuationStartWidth(run-&gt;m_start);
 895                 availableLogicalWidth += hangStartWidth;
 896                 if (style().isLeftToRightDirection())
 897                     logicalLeft -= hangStartWidth;
 898                 canHangPunctuationAtStart = false;
 899             }
 900 
 901             if (canHangPunctuationAtEnd &amp;&amp; lineInfo.isLastLine() &amp;&amp; run-&gt;m_stop &gt; 0 &amp;&amp; (!isLTR || isLastInFlowRun(*run))
 902                 &amp;&amp; !inlineAncestorHasEndBorderPaddingOrMargin(m_flow, *run-&gt;box())) {
 903                 float hangEndWidth = renderText.hangablePunctuationEndWidth(run-&gt;m_stop - 1);
 904                 availableLogicalWidth += hangEndWidth;
 905                 if (!style().isLeftToRightDirection())
 906                     logicalLeft -= hangEndWidth;
 907                 canHangPunctuationAtEnd = false;
 908             }
 909 
 910             if (textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun)
 911                 computeExpansionOpportunities(m_flow, textBox, previousRun, run-&gt;next(), renderText.stringView(run-&gt;m_start, run-&gt;m_stop), run-&gt;box()-&gt;direction());
 912 
 913             if (unsigned length = renderText.text().length()) {
 914                 if (!run-&gt;m_start &amp;&amp; needsWordSpacing &amp;&amp; isSpaceOrNewline(renderText.characterAt(run-&gt;m_start)))
 915                     totalLogicalWidth += lineStyle(*renderText.parent(), lineInfo).fontCascade().wordSpacing();
 916                 // run-&gt;m_start == run-&gt;m_stop should only be true iff the run is a replaced run for bidi: isolate.
 917                 ASSERT(run-&gt;m_stop &gt; 0 || run-&gt;m_start == run-&gt;m_stop);
 918                 needsWordSpacing = run-&gt;m_stop == length &amp;&amp; !isSpaceOrNewline(renderText.characterAt(run-&gt;m_stop - 1));
 919             }
 920 
 921             setLogicalWidthForTextRun(lineBox, run, renderText, totalLogicalWidth, lineInfo, textBoxDataMap, verticalPositionCache, wordMeasurements);
 922         } else {
 923             canHangPunctuationAtStart = false;
 924             bool encounteredJustifiedRuby = false;
 925             if (is&lt;RenderRubyRun&gt;(run-&gt;renderer()) &amp;&amp; textAlign == TextAlignMode::Justify &amp;&amp; run != trailingSpaceRun &amp;&amp; downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase()) {
 926                 auto* rubyBase = downcast&lt;RenderRubyRun&gt;(run-&gt;renderer()).rubyBase();
 927                 if (rubyBase-&gt;firstRootBox() &amp;&amp; !rubyBase-&gt;firstRootBox()-&gt;nextRootBox() &amp;&amp; run-&gt;renderer().style().collapseWhiteSpace()) {
 928                     rubyBase-&gt;setIsAfterExpansion(isAfterExpansion);
 929                     for (auto* leafChild = rubyBase-&gt;firstRootBox()-&gt;firstLeafDescendant(); leafChild; leafChild = leafChild-&gt;nextLeafOnLine()) {
 930                         if (!is&lt;InlineTextBox&gt;(*leafChild))
 931                             continue;
 932                         encounteredJustifiedRuby = true;
 933                         computeExpansionOpportunities(*rubyBase, downcast&lt;InlineTextBox&gt;(*leafChild), nullptr, nullptr,
 934                             downcast&lt;RenderText&gt;(leafChild-&gt;renderer()).stringView(), leafChild-&gt;direction());
 935                     }
 936                 }
 937             }
 938 
 939             if (!encounteredJustifiedRuby)
 940                 isAfterExpansion = false;
 941 
 942             if (!is&lt;RenderInline&gt;(run-&gt;renderer())) {
 943                 auto&amp; renderBox = downcast&lt;RenderBox&gt;(run-&gt;renderer());
 944                 if (is&lt;RenderRubyRun&gt;(renderBox))
 945                     setMarginsForRubyRun(run, downcast&lt;RenderRubyRun&gt;(renderBox), previousRun ? &amp;previousRun-&gt;renderer() : nullptr, lineInfo);
 946                 run-&gt;box()-&gt;setLogicalWidth(m_flow.logicalWidthForChild(renderBox));
 947                 totalLogicalWidth += m_flow.marginStartForChild(renderBox) + m_flow.marginEndForChild(renderBox);
 948             }
 949         }
 950 
 951         totalLogicalWidth += run-&gt;box()-&gt;logicalWidth();
 952         previousRun = run;
 953     }
 954 
 955     if (isAfterExpansion &amp;&amp; !expansionOpportunities.isEmpty()) {
 956         // FIXME: see &lt;webkit.org/b/139393#c11&gt;
 957         int lastValidExpansionOpportunitiesIndex = expansionOpportunities.size() - 1;
 958         while (lastValidExpansionOpportunitiesIndex &gt;= 0 &amp;&amp; !expansionOpportunities.at(lastValidExpansionOpportunitiesIndex))
 959             --lastValidExpansionOpportunitiesIndex;
 960         if (lastValidExpansionOpportunitiesIndex &gt;= 0) {
 961             ASSERT(expansionOpportunities.at(lastValidExpansionOpportunitiesIndex));
 962             expansionOpportunities.at(lastValidExpansionOpportunitiesIndex)--;
 963             expansionOpportunityCount--;
 964         }
 965     }
 966 
 967     if (is&lt;RenderRubyBase&gt;(m_flow) &amp;&amp; !expansionOpportunityCount)
 968         textAlign = TextAlignMode::Center;
 969 
 970     updateLogicalWidthForAlignment(m_flow, textAlign, lineBox, trailingSpaceRun, logicalLeft, totalLogicalWidth, availableLogicalWidth, expansionOpportunityCount);
 971 
 972     computeExpansionForJustifiedText(firstRun, trailingSpaceRun, expansionOpportunities, expansionOpportunityCount, totalLogicalWidth, availableLogicalWidth);
 973 
 974     return run;
 975 }
 976 
 977 void ComplexLineLayout::removeInlineBox(BidiRun&amp; run, const RootInlineBox&amp; rootLineBox) const
 978 {
 979     auto* inlineBox = run.box();
 980 #if ASSERT_ENABLED
 981     auto* inlineParent = inlineBox-&gt;parent();
 982     while (inlineParent &amp;&amp; inlineParent != &amp;rootLineBox) {
 983         ASSERT(!inlineParent-&gt;isDirty());
 984         inlineParent = inlineParent-&gt;parent();
 985     }
 986     ASSERT(!rootLineBox.isDirty());
 987 #endif
 988     auto* parent = inlineBox-&gt;parent();
 989     inlineBox-&gt;removeFromParent();
 990 
 991     auto&amp; renderer = run.renderer();
 992     if (is&lt;RenderText&gt;(renderer))
 993         downcast&lt;RenderText&gt;(renderer).removeTextBox(downcast&lt;InlineTextBox&gt;(*inlineBox));
 994     delete inlineBox;
 995     run.setBox(nullptr);
 996     // removeFromParent() unnecessarily dirties the ancestor subtree.
 997     auto* ancestor = parent;
 998     while (ancestor) {
 999         ancestor-&gt;markDirty(false);
1000         if (ancestor == &amp;rootLineBox)
1001             break;
1002         ancestor = ancestor-&gt;parent();
1003     }
1004 }
1005 
1006 void ComplexLineLayout::computeBlockDirectionPositionsForLine(RootInlineBox* lineBox, BidiRun* firstRun, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp; verticalPositionCache)
1007 {
1008     m_flow.setLogicalHeight(lineBox-&gt;alignBoxesInBlockDirection(m_flow.logicalHeight(), textBoxDataMap, verticalPositionCache));
1009 
1010     // Now make sure we place replaced render objects correctly.
1011     for (auto* run = firstRun; run; run = run-&gt;next()) {
1012         ASSERT(run-&gt;box());
1013         if (!run-&gt;box())
1014             continue; // Skip runs with no line boxes.
1015 
1016         // Align positioned boxes with the top of the line box. This is
1017         // a reasonable approximation of an appropriate y position.
1018         auto&amp; renderer = run-&gt;renderer();
1019         if (renderer.isOutOfFlowPositioned())
1020             run-&gt;box()-&gt;setLogicalTop(m_flow.logicalHeight());
1021 
1022         // Position is used to properly position both replaced elements and
1023         // to update the static normal flow x/y of positioned elements.
1024         bool inlineBoxIsRedundant = false;
1025         if (is&lt;RenderText&gt;(renderer)) {
1026             auto&amp; inlineTextBox = downcast&lt;InlineTextBox&gt;(*run-&gt;box());
1027             downcast&lt;RenderText&gt;(renderer).positionLineBox(inlineTextBox);
1028             inlineBoxIsRedundant = !inlineTextBox.hasTextContent();
1029         } else if (is&lt;RenderBox&gt;(renderer)) {
1030             downcast&lt;RenderBox&gt;(renderer).positionLineBox(downcast&lt;InlineElementBox&gt;(*run-&gt;box()));
1031             inlineBoxIsRedundant = renderer.isOutOfFlowPositioned();
1032         } else if (is&lt;RenderLineBreak&gt;(renderer))
1033             downcast&lt;RenderLineBreak&gt;(renderer).replaceInlineBoxWrapper(downcast&lt;InlineElementBox&gt;(*run-&gt;box()));
1034         // Check if we need to keep this box on the line at all.
1035         if (inlineBoxIsRedundant)
1036             removeInlineBox(*run, *lineBox);
1037     }
1038 }
1039 
1040 static inline bool isCollapsibleSpace(UChar character, const RenderText&amp; renderer)
1041 {
1042     if (character == &#39; &#39; || character == &#39;\t&#39; || character == softHyphen)
1043         return true;
1044     if (character == &#39;\n&#39;)
1045         return !renderer.style().preserveNewline();
1046     if (character == noBreakSpace)
1047         return renderer.style().nbspMode() == NBSPMode::Space;
1048     return false;
1049 }
1050 
1051 template &lt;typename CharacterType&gt;
1052 static inline unsigned findFirstTrailingSpace(const RenderText&amp; lastText, const CharacterType* characters, unsigned start, unsigned stop)
1053 {
1054     unsigned firstSpace = stop;
1055     while (firstSpace &gt; start) {
1056         UChar current = characters[firstSpace - 1];
1057         if (!isCollapsibleSpace(current, lastText))
1058             break;
1059         firstSpace--;
1060     }
1061 
1062     return firstSpace;
1063 }
1064 
1065 inline BidiRun* ComplexLineLayout::handleTrailingSpaces(BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, BidiContext* currentContext)
1066 {
1067     if (!bidiRuns.runCount()
1068         || !bidiRuns.logicallyLastRun()-&gt;renderer().style().breakOnlyAfterWhiteSpace()
1069         || !bidiRuns.logicallyLastRun()-&gt;renderer().style().autoWrap())
1070         return nullptr;
1071 
1072     BidiRun* trailingSpaceRun = bidiRuns.logicallyLastRun();
1073     const RenderObject&amp; lastObject = trailingSpaceRun-&gt;renderer();
1074     if (!is&lt;RenderText&gt;(lastObject))
1075         return nullptr;
1076 
1077     const RenderText&amp; lastText = downcast&lt;RenderText&gt;(lastObject);
1078     unsigned firstSpace;
1079     if (lastText.text().is8Bit())
1080         firstSpace = findFirstTrailingSpace(lastText, lastText.text().characters8(), trailingSpaceRun-&gt;start(), trailingSpaceRun-&gt;stop());
1081     else
1082         firstSpace = findFirstTrailingSpace(lastText, lastText.text().characters16(), trailingSpaceRun-&gt;start(), trailingSpaceRun-&gt;stop());
1083 
1084     if (firstSpace == trailingSpaceRun-&gt;stop())
1085         return nullptr;
1086 
1087     TextDirection direction = style().direction();
1088     bool shouldReorder = trailingSpaceRun != (direction == TextDirection::LTR ? bidiRuns.lastRun() : bidiRuns.firstRun());
1089     if (firstSpace != trailingSpaceRun-&gt;start()) {
1090         BidiContext* baseContext = currentContext;
1091         while (BidiContext* parent = baseContext-&gt;parent())
1092             baseContext = parent;
1093 
1094         std::unique_ptr&lt;BidiRun&gt; newTrailingRun = makeUnique&lt;BidiRun&gt;(firstSpace, trailingSpaceRun-&gt;m_stop, trailingSpaceRun-&gt;renderer(), baseContext, U_OTHER_NEUTRAL);
1095         trailingSpaceRun-&gt;m_stop = firstSpace;
1096         trailingSpaceRun = newTrailingRun.get();
1097         if (direction == TextDirection::LTR)
1098             bidiRuns.appendRun(WTFMove(newTrailingRun));
1099         else
1100             bidiRuns.prependRun(WTFMove(newTrailingRun));
1101         return trailingSpaceRun;
1102     }
1103     if (!shouldReorder)
1104         return trailingSpaceRun;
1105 
1106     if (direction == TextDirection::LTR) {
1107         bidiRuns.moveRunToEnd(trailingSpaceRun);
1108         trailingSpaceRun-&gt;m_level = 0;
1109     } else {
1110         bidiRuns.moveRunToBeginning(trailingSpaceRun);
1111         trailingSpaceRun-&gt;m_level = 1;
1112     }
1113     return trailingSpaceRun;
1114 }
1115 
1116 void ComplexLineLayout::appendFloatingObjectToLastLine(FloatingObject&amp; floatingObject)
1117 {
1118     ASSERT_WITH_SECURITY_IMPLICATION(!floatingObject.originatingLine());
1119     ASSERT(lastRootBox());
1120     floatingObject.setOriginatingLine(*lastRootBox());
1121     lastRootBox()-&gt;appendFloat(floatingObject.renderer());
1122 }
1123 
1124 static inline void notifyResolverToResumeInIsolate(InlineBidiResolver&amp; resolver, RenderObject* root, RenderObject* startObject)
1125 {
1126     if (root != startObject) {
1127         RenderObject* parent = startObject-&gt;parent();
1128         notifyResolverToResumeInIsolate(resolver, root, parent);
1129         notifyObserverEnteredObject(&amp;resolver, startObject);
1130     }
1131 }
1132 
1133 static inline void setUpResolverToResumeInIsolate(InlineBidiResolver&amp; resolver, InlineBidiResolver&amp; topResolver, BidiRun&amp; isolatedRun, RenderObject* root, RenderObject* startObject)
1134 {
1135     // Set up m_whitespaceCollapsingState
1136     resolver.whitespaceCollapsingState() = topResolver.whitespaceCollapsingState();
1137     resolver.whitespaceCollapsingState().setCurrentTransition(topResolver.whitespaceCollapsingTransitionForIsolatedRun(isolatedRun));
1138 
1139     // Set up m_nestedIsolateCount
1140     notifyResolverToResumeInIsolate(resolver, root, startObject);
1141 }
1142 
1143 // FIXME: BidiResolver should have this logic.
1144 static inline void constructBidiRunsForSegment(InlineBidiResolver&amp; topResolver, BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, const InlineIterator&amp; endOfRuns, VisualDirectionOverride override, bool previousLineBrokeCleanly)
1145 {
1146     // FIXME: We should pass a BidiRunList into createBidiRunsForLine instead
1147     // of the resolver owning the runs.
1148     ASSERT(&amp;topResolver.runs() == &amp;bidiRuns);
1149     ASSERT(topResolver.position() != endOfRuns);
1150     RenderObject* currentRoot = topResolver.position().root();
1151     topResolver.createBidiRunsForLine(endOfRuns, override, previousLineBrokeCleanly);
1152 
1153     while (!topResolver.isolatedRuns().isEmpty()) {
1154         // It does not matter which order we resolve the runs as long as we resolve them all.
1155         auto isolatedRun = WTFMove(topResolver.isolatedRuns().last());
1156         topResolver.isolatedRuns().removeLast();
1157         currentRoot = &amp;isolatedRun.root;
1158 
1159         RenderObject&amp; startObject = isolatedRun.object;
1160 
1161         // Only inlines make sense with unicode-bidi: isolate (blocks are already isolated).
1162         // FIXME: Because enterIsolate is not passed a RenderObject, we have to crawl up the
1163         // tree to see which parent inline is the isolate. We could change enterIsolate
1164         // to take a RenderObject and do this logic there, but that would be a layering
1165         // violation for BidiResolver (which knows nothing about RenderObject).
1166         RenderInline* isolatedInline = downcast&lt;RenderInline&gt;(highestContainingIsolateWithinRoot(startObject, currentRoot));
1167         ASSERT(isolatedInline);
1168 
1169         InlineBidiResolver isolatedResolver;
1170         EUnicodeBidi unicodeBidi = isolatedInline-&gt;style().unicodeBidi();
1171         TextDirection direction;
1172         if (unicodeBidi == Plaintext)
1173             determineDirectionality(direction, InlineIterator(isolatedInline, &amp;isolatedRun.object, 0));
1174         else {
1175             ASSERT(unicodeBidi == Isolate || unicodeBidi == IsolateOverride);
1176             direction = isolatedInline-&gt;style().direction();
1177         }
1178         isolatedResolver.setStatus(BidiStatus(direction, isOverride(unicodeBidi)));
1179 
1180         setUpResolverToResumeInIsolate(isolatedResolver, topResolver, isolatedRun.runToReplace, isolatedInline, &amp;startObject);
1181 
1182         // The starting position is the beginning of the first run within the isolate that was identified
1183         // during the earlier call to createBidiRunsForLine. This can be but is not necessarily the
1184         // first run within the isolate.
1185         InlineIterator iter = InlineIterator(isolatedInline, &amp;startObject, isolatedRun.position);
1186         isolatedResolver.setPositionIgnoringNestedIsolates(iter);
1187 
1188         // We stop at the next end of line; we may re-enter this isolate in the next call to constructBidiRuns().
1189         // FIXME: What should end and previousLineBrokeCleanly be?
1190         // rniwa says previousLineBrokeCleanly is just a WinIE hack and could always be false here?
1191         isolatedResolver.createBidiRunsForLine(endOfRuns, NoVisualOverride, previousLineBrokeCleanly);
1192         // Note that we do not delete the runs from the resolver.
1193         // We&#39;re not guaranteed to get any BidiRuns in the previous step. If we don&#39;t, we allow the placeholder
1194         // itself to be turned into an InlineBox. We can&#39;t remove it here without potentially losing track of
1195         // the logically last run.
1196         if (isolatedResolver.runs().runCount())
1197             bidiRuns.replaceRunWithRuns(&amp;isolatedRun.runToReplace, isolatedResolver.runs());
1198 
1199         // If we encountered any nested isolate runs, just move them
1200         // to the top resolver&#39;s list for later processing.
1201         while (!isolatedResolver.isolatedRuns().isEmpty()) {
1202             auto runWithContext = WTFMove(isolatedResolver.isolatedRuns().last());
1203             isolatedResolver.isolatedRuns().removeLast();
1204             topResolver.setWhitespaceCollapsingTransitionForIsolatedRun(runWithContext.runToReplace, isolatedResolver.whitespaceCollapsingTransitionForIsolatedRun(runWithContext.runToReplace));
1205             topResolver.isolatedRuns().append(WTFMove(runWithContext));
1206         }
1207     }
1208 }
1209 
1210 // This function constructs line boxes for all of the text runs in the resolver and computes their position.
1211 RootInlineBox* ComplexLineLayout::createLineBoxesFromBidiRuns(unsigned bidiLevel, BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, const InlineIterator&amp; end, LineInfo&amp; lineInfo, VerticalPositionCache&amp; verticalPositionCache, BidiRun* trailingSpaceRun, WordMeasurements&amp; wordMeasurements)
1212 {
1213     if (!bidiRuns.runCount())
1214         return nullptr;
1215 
1216     // FIXME: Why is this only done when we had runs?
1217     lineInfo.setLastLine(!end.renderer());
1218 
1219     RootInlineBox* lineBox = constructLine(bidiRuns, lineInfo);
1220     if (!lineBox)
1221         return nullptr;
1222 
1223     lineBox-&gt;setBidiLevel(bidiLevel);
1224     lineBox-&gt;setEndsWithBreak(lineInfo.previousLineBrokeCleanly());
1225 
1226     bool isSVGRootInlineBox = is&lt;SVGRootInlineBox&gt;(*lineBox);
1227 
1228     GlyphOverflowAndFallbackFontsMap textBoxDataMap;
1229 
1230     // Now we position all of our text runs horizontally.
1231     if (!isSVGRootInlineBox)
1232         computeInlineDirectionPositionsForLine(lineBox, lineInfo, bidiRuns.firstRun(), trailingSpaceRun, end.atEnd(), textBoxDataMap, verticalPositionCache, wordMeasurements);
1233 
1234     // Now position our text runs vertically.
1235     computeBlockDirectionPositionsForLine(lineBox, bidiRuns.firstRun(), textBoxDataMap, verticalPositionCache);
1236 
1237     // SVG text layout code computes vertical &amp; horizontal positions on its own.
1238     // Note that we still need to execute computeVerticalPositionsForLine() as
1239     // it calls InlineTextBox::positionLineBox(), which tracks whether the box
1240     // contains reversed text or not. If we wouldn&#39;t do that editing and thus
1241     // text selection in RTL boxes would not work as expected.
1242     if (isSVGRootInlineBox) {
1243         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_flow.isSVGText());
1244         downcast&lt;SVGRootInlineBox&gt;(*lineBox).computePerCharacterLayoutInformation();
1245     }
1246 
1247     // Compute our overflow now.
1248     lineBox-&gt;computeOverflow(lineBox-&gt;lineTop(), lineBox-&gt;lineBottom(), textBoxDataMap);
1249 
1250     return lineBox;
1251 }
1252 
1253 static void deleteLineRange(LineLayoutState&amp; layoutState, RootInlineBox* startLine, RootInlineBox* stopLine = 0)
1254 {
1255     RootInlineBox* boxToDelete = startLine;
1256     while (boxToDelete &amp;&amp; boxToDelete != stopLine) {
1257         layoutState.updateRepaintRangeFromBox(boxToDelete);
1258         // Note: deleteLineRange(firstRootBox()) is not identical to deleteLineBoxTree().
1259         // deleteLineBoxTree uses nextLineBox() instead of nextRootBox() when traversing.
1260         RootInlineBox* next = boxToDelete-&gt;nextRootBox();
1261         boxToDelete-&gt;deleteLine();
1262         boxToDelete = next;
1263     }
1264 }
1265 
1266 static void repaintDirtyFloats(LineLayoutState::FloatList&amp; floats)
1267 {
1268     // Floats that did not have layout did not repaint when we laid them out. They would have
1269     // painted by now if they had moved, but if they stayed at (0, 0), they still need to be
1270     // painted.
1271     for (auto&amp; floatBox : floats) {
1272         if (floatBox-&gt;everHadLayout())
1273             continue;
1274         auto&amp; box = floatBox-&gt;renderer();
1275         if (!box.x() &amp;&amp; !box.y() &amp;&amp; box.checkForRepaintDuringLayout())
1276             box.repaint();
1277     }
1278 }
1279 
1280 void ComplexLineLayout::layoutRunsAndFloats(LineLayoutState&amp; layoutState, bool hasInlineChild)
1281 {
1282     // We want to skip ahead to the first dirty line
1283     InlineBidiResolver resolver;
1284     RootInlineBox* startLine = determineStartPosition(layoutState, resolver);
1285 
1286     unsigned consecutiveHyphenatedLines = 0;
1287     if (startLine) {
1288         for (RootInlineBox* line = startLine-&gt;prevRootBox(); line &amp;&amp; line-&gt;isHyphenated(); line = line-&gt;prevRootBox())
1289             consecutiveHyphenatedLines++;
1290     }
1291 
1292     // FIXME: This would make more sense outside of this function, but since
1293     // determineStartPosition can change the fullLayout flag we have to do this here. Failure to call
1294     // determineStartPosition first will break fast/repaint/line-flow-with-floats-9.html.
1295     if (layoutState.isFullLayout() &amp;&amp; hasInlineChild &amp;&amp; !m_flow.selfNeedsLayout()) {
1296         m_flow.setNeedsLayout(MarkOnlyThis); // Mark as needing a full layout to force us to repaint.
1297         if (!layoutContext().needsFullRepaint() &amp;&amp; m_flow.hasSelfPaintingLayer() &amp;&amp; m_flow.hasRepaintLayoutRects()) {
1298             // Because we waited until we were already inside layout to discover
1299             // that the block really needed a full layout, we missed our chance to repaint the layer
1300             // before layout started. Luckily the layer has cached the repaint rect for its original
1301             // position and size, and so we can use that to make a repaint happen now.
1302             m_flow.repaintUsingContainer(m_flow.containerForRepaint(), m_flow.repaintLayoutRects().m_repaintRect);
1303         }
1304     }
1305 
1306     if (m_flow.containsFloats())
1307         layoutState.floatList().setLastFloat(m_flow.floatingObjects()-&gt;set().last().get());
1308 
1309     // We also find the first clean line and extract these lines. We will add them back
1310     // if we determine that we&#39;re able to synchronize after handling all our dirty lines.
1311     InlineIterator cleanLineStart;
1312     BidiStatus cleanLineBidiStatus;
1313     if (!layoutState.isFullLayout() &amp;&amp; startLine)
1314         determineEndPosition(layoutState, startLine, cleanLineStart, cleanLineBidiStatus);
1315 
1316     if (startLine) {
1317         if (!layoutState.usesRepaintBounds())
1318             layoutState.setRepaintRange(m_flow.logicalHeight());
1319         deleteLineRange(layoutState, startLine);
1320     }
1321 
1322     if (!layoutState.isFullLayout() &amp;&amp; lastRootBox() &amp;&amp; lastRootBox()-&gt;endsWithBreak()) {
1323         // If the last line before the start line ends with a line break that clear floats,
1324         // adjust the height accordingly.
1325         // A line break can be either the first or the last object on a line, depending on its direction.
1326         if (InlineBox* lastLeafDescendant = lastRootBox()-&gt;lastLeafDescendant()) {
1327             RenderObject* lastObject = &amp;lastLeafDescendant-&gt;renderer();
1328             if (!lastObject-&gt;isBR())
1329                 lastObject = &amp;lastRootBox()-&gt;firstLeafDescendant()-&gt;renderer();
1330             if (lastObject-&gt;isBR()) {
1331                 Clear clear = lastObject-&gt;style().clear();
1332                 if (clear != Clear::None)
1333                     m_flow.clearFloats(clear);
1334             }
1335         }
1336     }
1337 
1338     layoutRunsAndFloatsInRange(layoutState, resolver, cleanLineStart, cleanLineBidiStatus, consecutiveHyphenatedLines);
1339     linkToEndLineIfNeeded(layoutState);
1340     repaintDirtyFloats(layoutState.floatList());
1341 }
1342 
1343 // Before restarting the layout loop with a new logicalHeight, remove all floats that were added and reset the resolver.
1344 inline const InlineIterator&amp; ComplexLineLayout::restartLayoutRunsAndFloatsInRange(LayoutUnit oldLogicalHeight, LayoutUnit newLogicalHeight,  FloatingObject* lastFloatFromPreviousLine, InlineBidiResolver&amp; resolver,  const InlineIterator&amp; oldEnd)
1345 {
1346     m_flow.removeFloatingObjectsBelow(lastFloatFromPreviousLine, oldLogicalHeight);
1347     m_flow.setLogicalHeight(newLogicalHeight);
1348     resolver.setPositionIgnoringNestedIsolates(oldEnd);
1349     return oldEnd;
1350 }
1351 
1352 void ComplexLineLayout::layoutRunsAndFloatsInRange(LineLayoutState&amp; layoutState, InlineBidiResolver&amp; resolver, const InlineIterator&amp; cleanLineStart, const BidiStatus&amp; cleanLineBidiStatus, unsigned consecutiveHyphenatedLines)
1353 {
1354     const RenderStyle&amp; styleToUse = style();
1355     bool paginated = layoutContext().layoutState() &amp;&amp; layoutContext().layoutState()-&gt;isPaginated();
1356     LineWhitespaceCollapsingState&amp; lineWhitespaceCollapsingState = resolver.whitespaceCollapsingState();
1357     InlineIterator end = resolver.position();
1358     bool checkForEndLineMatch = layoutState.endLine();
1359     RenderTextInfo renderTextInfo;
1360     VerticalPositionCache verticalPositionCache;
1361 
1362     LineBreaker lineBreaker(m_flow);
1363 
1364     while (!end.atEnd()) {
1365         // FIXME: Is this check necessary before the first iteration or can it be moved to the end?
1366         if (checkForEndLineMatch) {
1367             layoutState.setEndLineMatched(matchedEndLine(layoutState, resolver, cleanLineStart, cleanLineBidiStatus));
1368             if (layoutState.endLineMatched()) {
1369                 resolver.setPosition(InlineIterator(resolver.position().root(), 0, 0), 0);
1370                 layoutState.marginInfo().clearMargin();
1371                 break;
1372             }
1373         }
1374 
1375         lineWhitespaceCollapsingState.reset();
1376 
1377         layoutState.lineInfo().setEmpty(true);
1378         layoutState.lineInfo().resetRunsFromLeadingWhitespace();
1379 
1380         const InlineIterator oldEnd = end;
1381         bool isNewUBAParagraph = layoutState.lineInfo().previousLineBrokeCleanly();
1382         FloatingObject* lastFloatFromPreviousLine = (m_flow.containsFloats()) ? m_flow.floatingObjects()-&gt;set().last().get() : nullptr;
1383 
1384         WordMeasurements wordMeasurements;
1385         end = lineBreaker.nextLineBreak(resolver, layoutState.lineInfo(), renderTextInfo, lastFloatFromPreviousLine, consecutiveHyphenatedLines, wordMeasurements);
1386         m_flow.cachePriorCharactersIfNeeded(renderTextInfo.lineBreakIterator);
1387         renderTextInfo.lineBreakIterator.resetPriorContext();
1388         if (resolver.position().atEnd()) {
1389             // FIXME: We shouldn&#39;t be creating any runs in nextLineBreak to begin with!
1390             // Once BidiRunList is separated from BidiResolver this will not be needed.
1391             resolver.runs().clear();
1392             resolver.markCurrentRunEmpty(); // FIXME: This can probably be replaced by an ASSERT (or just removed).
1393             layoutState.setCheckForFloatsFromLastLine(true);
1394             resolver.setPosition(InlineIterator(resolver.position().root(), 0, 0), 0);
1395             break;
1396         }
1397 
1398         ASSERT(end != resolver.position());
1399 
1400         // This is a short-cut for empty lines.
1401         if (layoutState.lineInfo().isEmpty()) {
1402             if (lastRootBox())
1403                 lastRootBox()-&gt;setLineBreakInfo(end.renderer(), end.offset(), resolver.status());
1404         } else {
1405             VisualDirectionOverride override = (styleToUse.rtlOrdering() == Order::Visual ? (styleToUse.direction() == TextDirection::LTR ? VisualLeftToRightOverride : VisualRightToLeftOverride) : NoVisualOverride);
1406 
1407             if (isNewUBAParagraph &amp;&amp; styleToUse.unicodeBidi() == Plaintext &amp;&amp; !resolver.context()-&gt;parent()) {
1408                 TextDirection direction = styleToUse.direction();
1409                 determineDirectionality(direction, resolver.position());
1410                 resolver.setStatus(BidiStatus(direction, isOverride(styleToUse.unicodeBidi())));
1411             }
1412             // FIXME: This ownership is reversed. We should own the BidiRunList and pass it to createBidiRunsForLine.
1413             BidiRunList&lt;BidiRun&gt;&amp; bidiRuns = resolver.runs();
1414             constructBidiRunsForSegment(resolver, bidiRuns, end, override, layoutState.lineInfo().previousLineBrokeCleanly());
1415             ASSERT(resolver.position() == end);
1416 
1417             BidiRun* trailingSpaceRun = !layoutState.lineInfo().previousLineBrokeCleanly() ? handleTrailingSpaces(bidiRuns, resolver.context()) : nullptr;
1418 
1419             if (bidiRuns.runCount() &amp;&amp; lineBreaker.lineWasHyphenated()) {
1420                 bidiRuns.logicallyLastRun()-&gt;m_hasHyphen = true;
1421                 consecutiveHyphenatedLines++;
1422             } else
1423                 consecutiveHyphenatedLines = 0;
1424 
1425             // Now that the runs have been ordered, we create the line boxes.
1426             // At the same time we figure out where border/padding/margin should be applied for
1427             // inline flow boxes.
1428 
1429             LayoutUnit oldLogicalHeight = m_flow.logicalHeight();
1430             RootInlineBox* lineBox = createLineBoxesFromBidiRuns(resolver.status().context-&gt;level(), bidiRuns, end, layoutState.lineInfo(), verticalPositionCache, trailingSpaceRun, wordMeasurements);
1431 
1432             bidiRuns.clear();
1433             resolver.markCurrentRunEmpty(); // FIXME: This can probably be replaced by an ASSERT (or just removed).
1434 
1435             if (lineBox) {
1436                 lineBox-&gt;setLineBreakInfo(end.renderer(), end.offset(), resolver.status());
1437                 if (layoutState.usesRepaintBounds())
1438                     layoutState.updateRepaintRangeFromBox(lineBox);
1439 
1440                 LayoutUnit adjustment;
1441                 bool overflowsFragment = false;
1442 
1443                 layoutState.marginInfo().setAtBeforeSideOfBlock(false);
1444 
1445                 if (paginated)
1446                     m_flow.adjustLinePositionForPagination(lineBox, adjustment, overflowsFragment, layoutState.fragmentedFlow());
1447                 if (adjustment) {
1448                     IndentTextOrNot shouldIndentText = layoutState.lineInfo().isFirstLine() ? IndentText : DoNotIndentText;
1449                     LayoutUnit oldLineWidth = m_flow.availableLogicalWidthForLine(oldLogicalHeight, shouldIndentText);
1450                     lineBox-&gt;adjustBlockDirectionPosition(adjustment);
1451                     if (layoutState.usesRepaintBounds())
1452                         layoutState.updateRepaintRangeFromBox(lineBox);
1453 
1454                     if (m_flow.availableLogicalWidthForLine(oldLogicalHeight + adjustment, shouldIndentText) != oldLineWidth) {
1455                         // We have to delete this line, remove all floats that got added, and let line layout re-run.
1456                         lineBox-&gt;deleteLine();
1457                         end = restartLayoutRunsAndFloatsInRange(oldLogicalHeight, oldLogicalHeight + adjustment, lastFloatFromPreviousLine, resolver, oldEnd);
1458                         continue;
1459                     }
1460 
1461                     m_flow.setLogicalHeight(lineBox-&gt;lineBottomWithLeading());
1462                 }
1463 
1464                 if (paginated) {
1465                     if (layoutState.fragmentedFlow())
1466                         updateFragmentForLine(lineBox);
1467                 }
1468             }
1469         }
1470 
1471         for (size_t i = 0; i &lt; lineBreaker.positionedObjects().size(); ++i)
1472             setStaticPositions(m_flow, *lineBreaker.positionedObjects()[i], DoNotIndentText);
1473 
1474         if (!layoutState.lineInfo().isEmpty()) {
1475             layoutState.lineInfo().setFirstLine(false);
1476             m_flow.clearFloats(lineBreaker.clear());
1477         }
1478 
1479         if (m_flow.floatingObjects() &amp;&amp; lastRootBox()) {
1480             const FloatingObjectSet&amp; floatingObjectSet = m_flow.floatingObjects()-&gt;set();
1481             auto it = floatingObjectSet.begin();
1482             auto end = floatingObjectSet.end();
1483             if (auto* lastFloat = layoutState.floatList().lastFloat()) {
1484                 auto lastFloatIterator = floatingObjectSet.find(lastFloat);
1485                 ASSERT(lastFloatIterator != end);
1486                 ++lastFloatIterator;
1487                 it = lastFloatIterator;
1488             }
1489             for (; it != end; ++it) {
1490                 auto&amp; floatingObject = *it;
1491                 appendFloatingObjectToLastLine(*floatingObject);
1492                 // If a float&#39;s geometry has changed, give up on syncing with clean lines.
1493                 auto* floatWithRect = layoutState.floatList().floatWithRect(floatingObject-&gt;renderer());
1494                 if (!floatWithRect || floatWithRect-&gt;rect() != floatingObject-&gt;frameRect())
1495                     checkForEndLineMatch = false;
1496             }
1497             layoutState.floatList().setLastFloat(!floatingObjectSet.isEmpty() ? floatingObjectSet.last().get() : nullptr);
1498         }
1499 
1500         lineWhitespaceCollapsingState.reset();
1501         resolver.setPosition(end, numberOfIsolateAncestors(end));
1502     }
1503 
1504     // In case we already adjusted the line positions during this layout to avoid widows
1505     // then we need to ignore the possibility of having a new widows situation.
1506     // Otherwise, we risk leaving empty containers which is against the block fragmentation principles.
1507     if (paginated &amp;&amp; !style().hasAutoWidows() &amp;&amp; !m_flow.didBreakAtLineToAvoidWidow()) {
1508         // Check the line boxes to make sure we didn&#39;t create unacceptable widows.
1509         // However, we&#39;ll prioritize orphans - so nothing we do here should create
1510         // a new orphan.
1511 
1512         RootInlineBox* lineBox = lastRootBox();
1513 
1514         // Count from the end of the block backwards, to see how many hanging
1515         // lines we have.
1516         RootInlineBox* firstLineInBlock = firstRootBox();
1517         int numLinesHanging = 1;
1518         while (lineBox &amp;&amp; lineBox != firstLineInBlock &amp;&amp; !lineBox-&gt;isFirstAfterPageBreak()) {
1519             ++numLinesHanging;
1520             lineBox = lineBox-&gt;prevRootBox();
1521         }
1522 
1523         // If there were no breaks in the block, we didn&#39;t create any widows.
1524         if (!lineBox || !lineBox-&gt;isFirstAfterPageBreak() || lineBox == firstLineInBlock)
1525             return;
1526 
1527         if (numLinesHanging &lt; style().widows()) {
1528             // We have detected a widow. Now we need to work out how many
1529             // lines there are on the previous page, and how many we need
1530             // to steal.
1531             int numLinesNeeded = style().widows() - numLinesHanging;
1532             RootInlineBox* currentFirstLineOfNewPage = lineBox;
1533 
1534             // Count the number of lines in the previous page.
1535             lineBox = lineBox-&gt;prevRootBox();
1536             int numLinesInPreviousPage = 1;
1537             while (lineBox &amp;&amp; lineBox != firstLineInBlock &amp;&amp; !lineBox-&gt;isFirstAfterPageBreak()) {
1538                 ++numLinesInPreviousPage;
1539                 lineBox = lineBox-&gt;prevRootBox();
1540             }
1541 
1542             // If there was an explicit value for orphans, respect that. If not, we still
1543             // shouldn&#39;t create a situation where we make an orphan bigger than the initial value.
1544             // This means that setting widows implies we also care about orphans, but given
1545             // the specification says the initial orphan value is non-zero, this is ok. The
1546             // author is always free to set orphans explicitly as well.
1547             int orphans = style().hasAutoOrphans() ? style().initialOrphans() : style().orphans();
1548             int numLinesAvailable = numLinesInPreviousPage - orphans;
1549             if (numLinesAvailable &lt;= 0)
1550                 return;
1551 
1552             int numLinesToTake = std::min(numLinesAvailable, numLinesNeeded);
1553             // Wind back from our first widowed line.
1554             lineBox = currentFirstLineOfNewPage;
1555             for (int i = 0; i &lt; numLinesToTake; ++i)
1556                 lineBox = lineBox-&gt;prevRootBox();
1557 
1558             // We now want to break at this line. Remember for next layout and trigger relayout.
1559             m_flow.setBreakAtLineToAvoidWidow(lineCountUntil(lineBox));
1560             m_flow.markLinesDirtyInBlockRange(lastRootBox()-&gt;lineBottomWithLeading(), lineBox-&gt;lineBottomWithLeading(), lineBox);
1561         }
1562     }
1563     m_flow.clearDidBreakAtLineToAvoidWidow();
1564 }
1565 
1566 void ComplexLineLayout::reattachCleanLineFloats(RootInlineBox&amp; cleanLine, LayoutUnit delta, bool isFirstCleanLine)
1567 {
1568     auto* cleanLineFloats = cleanLine.floatsPtr();
1569     if (!cleanLineFloats)
1570         return;
1571 
1572     for (auto&amp; floatingBox : *cleanLineFloats) {
1573         if (!floatingBox)
1574             continue;
1575         auto* floatingObject = m_flow.insertFloatingObject(*floatingBox);
1576         if (isFirstCleanLine &amp;&amp; floatingObject-&gt;originatingLine()) {
1577             // Float box does not belong to this line anymore.
1578             ASSERT_WITH_SECURITY_IMPLICATION(cleanLine.prevRootBox() == floatingObject-&gt;originatingLine());
1579             cleanLine.removeFloat(*floatingBox);
1580             continue;
1581         }
1582         ASSERT_WITH_SECURITY_IMPLICATION(!floatingObject-&gt;originatingLine());
1583         floatingObject-&gt;setOriginatingLine(cleanLine);
1584         m_flow.setLogicalHeight(m_flow.logicalTopForChild(*floatingBox) - m_flow.marginBeforeForChild(*floatingBox) + delta);
1585         m_flow.positionNewFloats();
1586     }
1587 }
1588 
1589 void ComplexLineLayout::linkToEndLineIfNeeded(LineLayoutState&amp; layoutState)
1590 {
1591     auto* firstCleanLine = layoutState.endLine();
1592     if (firstCleanLine) {
1593         if (layoutState.endLineMatched()) {
1594             bool paginated = layoutContext().layoutState() &amp;&amp; layoutContext().layoutState()-&gt;isPaginated();
1595             // Attach all the remaining lines, and then adjust their y-positions as needed.
1596             LayoutUnit delta = m_flow.logicalHeight() - layoutState.endLineLogicalTop();
1597             for (auto* line = firstCleanLine; line; line = line-&gt;nextRootBox()) {
1598                 line-&gt;attachLine();
1599                 if (paginated) {
1600                     delta -= line-&gt;paginationStrut();
1601                     bool overflowsFragment;
1602                     m_flow.adjustLinePositionForPagination(line, delta, overflowsFragment, layoutState.fragmentedFlow());
1603                 }
1604                 if (delta) {
1605                     layoutState.updateRepaintRangeFromBox(line, delta);
1606                     line-&gt;adjustBlockDirectionPosition(delta);
1607                 }
1608                 if (layoutState.fragmentedFlow())
1609                     updateFragmentForLine(line);
1610                 reattachCleanLineFloats(*line, delta, line == firstCleanLine);
1611             }
1612             m_flow.setLogicalHeight(lastRootBox()-&gt;lineBottomWithLeading());
1613         } else {
1614             // Delete all the remaining lines.
1615             deleteLineRange(layoutState, layoutState.endLine());
1616         }
1617     }
1618 
1619     if (m_flow.floatingObjects() &amp;&amp; (layoutState.checkForFloatsFromLastLine() || m_flow.positionNewFloats()) &amp;&amp; lastRootBox()) {
1620         // In case we have a float on the last line, it might not be positioned up to now.
1621         // This has to be done before adding in the bottom border/padding, or the float will
1622         // include the padding incorrectly. -dwh
1623         if (layoutState.checkForFloatsFromLastLine()) {
1624             LayoutUnit bottomVisualOverflow = lastRootBox()-&gt;logicalBottomVisualOverflow();
1625             LayoutUnit bottomLayoutOverflow = lastRootBox()-&gt;logicalBottomLayoutOverflow();
1626             auto newLineBox = makeUnique&lt;TrailingFloatsRootInlineBox&gt;(m_flow);
1627             auto trailingFloatsLineBox = newLineBox.get();
1628             m_lineBoxes.appendLineBox(WTFMove(newLineBox));
1629             trailingFloatsLineBox-&gt;setConstructed();
1630             GlyphOverflowAndFallbackFontsMap textBoxDataMap;
1631             VerticalPositionCache verticalPositionCache;
1632             LayoutUnit blockLogicalHeight = m_flow.logicalHeight();
1633             trailingFloatsLineBox-&gt;alignBoxesInBlockDirection(blockLogicalHeight, textBoxDataMap, verticalPositionCache);
1634             trailingFloatsLineBox-&gt;setLineTopBottomPositions(blockLogicalHeight, blockLogicalHeight, blockLogicalHeight, blockLogicalHeight);
1635             trailingFloatsLineBox-&gt;setPaginatedLineWidth(m_flow.availableLogicalWidthForContent(blockLogicalHeight));
1636             LayoutRect logicalLayoutOverflow(0_lu, blockLogicalHeight, 1_lu, bottomLayoutOverflow - blockLogicalHeight);
1637             LayoutRect logicalVisualOverflow(0_lu, blockLogicalHeight, 1_lu, bottomVisualOverflow - blockLogicalHeight);
1638             trailingFloatsLineBox-&gt;setOverflowFromLogicalRects(logicalLayoutOverflow, logicalVisualOverflow, trailingFloatsLineBox-&gt;lineTop(), trailingFloatsLineBox-&gt;lineBottom());
1639             if (layoutState.fragmentedFlow())
1640                 updateFragmentForLine(trailingFloatsLineBox);
1641         }
1642 
1643         const FloatingObjectSet&amp; floatingObjectSet = m_flow.floatingObjects()-&gt;set();
1644         auto it = floatingObjectSet.begin();
1645         auto end = floatingObjectSet.end();
1646         if (auto* lastFloat = layoutState.floatList().lastFloat()) {
1647             auto lastFloatIterator = floatingObjectSet.find(lastFloat);
1648             ASSERT(lastFloatIterator != end);
1649             ++lastFloatIterator;
1650             it = lastFloatIterator;
1651         }
1652         for (; it != end; ++it)
1653             appendFloatingObjectToLastLine(**it);
1654         layoutState.floatList().setLastFloat(!floatingObjectSet.isEmpty() ? floatingObjectSet.last().get() : nullptr);
1655     }
1656 }
1657 
1658 void ComplexLineLayout::layoutLineBoxes(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
1659 {
1660     ASSERT(!m_flow.simpleLineLayout());
1661 
1662     m_flow.setLogicalHeight(m_flow.borderAndPaddingBefore());
1663 
1664     // Lay out our hypothetical grid line as though it occurs at the top of the block.
1665     if (layoutContext().layoutState() &amp;&amp; layoutContext().layoutState()-&gt;lineGrid() == &amp;m_flow)
1666         m_flow.layoutLineGridBox();
1667 
1668     RenderFragmentedFlow* fragmentedFlow = m_flow.enclosingFragmentedFlow();
1669     bool clearLinesForPagination = firstRootBox() &amp;&amp; fragmentedFlow &amp;&amp; !fragmentedFlow-&gt;hasFragments();
1670 
1671     // Figure out if we should clear out our line boxes.
1672     // FIXME: Handle resize eventually!
1673     bool isFullLayout = !firstRootBox() || m_flow.selfNeedsLayout() || relayoutChildren || clearLinesForPagination;
1674     LineLayoutState layoutState(m_flow, isFullLayout, repaintLogicalTop, repaintLogicalBottom, fragmentedFlow);
1675 
1676     if (isFullLayout)
1677         lineBoxes().deleteLineBoxes();
1678 
1679     // Text truncation kicks in in two cases:
1680     //     1) If your overflow isn&#39;t visible and your text-overflow-mode isn&#39;t clip.
1681     //     2) If you&#39;re an anonymous block with a block parent that satisfies #1.
1682     // FIXME: CSS3 says that descendants that are clipped must also know how to truncate. This is insanely
1683     // difficult to figure out in general (especially in the middle of doing layout), so we only handle the
1684     // simple case of an anonymous block truncating when it&#39;s parent is clipped.
1685     auto* parent = m_flow.parent();
1686     bool hasTextOverflow = (style().textOverflow() == TextOverflow::Ellipsis &amp;&amp; m_flow.hasOverflowClip())
1687         || (m_flow.isAnonymousBlock() &amp;&amp; parent &amp;&amp; parent-&gt;isRenderBlock() &amp;&amp; parent-&gt;style().textOverflow() == TextOverflow::Ellipsis &amp;&amp; parent-&gt;hasOverflowClip());
1688 
1689     // Walk all the lines and delete our ellipsis line boxes if they exist.
1690     if (hasTextOverflow)
1691         deleteEllipsisLineBoxes();
1692 
1693     if (m_flow.firstChild()) {
1694         // In full layout mode, clear the line boxes of children upfront. Otherwise,
1695         // siblings can run into stale root lineboxes during layout. Then layout
1696         // the replaced elements later. In partial layout mode, line boxes are not
1697         // deleted and only dirtied. In that case, we can layout the replaced
1698         // elements at the same time.
1699         bool hasInlineChild = false;
1700         Vector&lt;RenderBox*&gt; replacedChildren;
1701         for (InlineWalker walker(m_flow); !walker.atEnd(); walker.advance()) {
1702             RenderObject&amp; o = *walker.current();
1703 
1704             if (!hasInlineChild &amp;&amp; o.isInline())
1705                 hasInlineChild = true;
1706 
1707             if (o.isReplaced() || o.isFloating() || o.isOutOfFlowPositioned()) {
1708                 RenderBox&amp; box = downcast&lt;RenderBox&gt;(o);
1709 
1710                 if (relayoutChildren || box.hasRelativeDimensions())
1711                     box.setChildNeedsLayout(MarkOnlyThis);
1712 
1713                 // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
1714                 if (relayoutChildren &amp;&amp; box.needsPreferredWidthsRecalculation())
1715                     box.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
1716 
1717                 if (box.isOutOfFlowPositioned())
1718                     box.containingBlock()-&gt;insertPositionedObject(box);
1719                 else if (box.isFloating())
1720                     layoutState.floatList().append(FloatWithRect::create(box));
1721                 else if (isFullLayout || box.needsLayout()) {
1722                     // Replaced element.
1723                     if (isFullLayout &amp;&amp; is&lt;RenderRubyRun&gt;(box)) {
1724                         // FIXME: This resets the overhanging margins that we set during line layout (see computeInlineDirectionPositionsForSegment)
1725                         // Find a more suitable place for this.
1726                         m_flow.setMarginStartForChild(box, 0);
1727                         m_flow.setMarginEndForChild(box, 0);
1728                     }
1729                     box.dirtyLineBoxes(isFullLayout);
1730                     if (isFullLayout)
1731                         replacedChildren.append(&amp;box);
1732                     else
1733                         box.layoutIfNeeded();
1734                 }
1735             } else if (o.isTextOrLineBreak() || (is&lt;RenderInline&gt;(o) &amp;&amp; !walker.atEndOfInline())) {
1736                 if (is&lt;RenderInline&gt;(o))
1737                     downcast&lt;RenderInline&gt;(o).updateAlwaysCreateLineBoxes(layoutState.isFullLayout());
1738                 if (layoutState.isFullLayout() || o.selfNeedsLayout())
1739                     dirtyLineBoxesForRenderer(o, layoutState.isFullLayout());
1740                 o.clearNeedsLayout();
1741             }
1742         }
1743 
1744         for (size_t i = 0; i &lt; replacedChildren.size(); i++)
1745             replacedChildren[i]-&gt;layoutIfNeeded();
1746 
1747         layoutRunsAndFloats(layoutState, hasInlineChild);
1748     }
1749 
1750     // Expand the last line to accommodate Ruby and emphasis marks.
1751     int lastLineAnnotationsAdjustment = 0;
1752     if (lastRootBox()) {
1753         LayoutUnit lowestAllowedPosition = std::max(lastRootBox()-&gt;lineBottom(), m_flow.logicalHeight() + m_flow.paddingAfter());
1754         if (!style().isFlippedLinesWritingMode())
1755             lastLineAnnotationsAdjustment = lastRootBox()-&gt;computeUnderAnnotationAdjustment(lowestAllowedPosition);
1756         else
1757             lastLineAnnotationsAdjustment = lastRootBox()-&gt;computeOverAnnotationAdjustment(lowestAllowedPosition);
1758     }
1759 
1760     // Now do the handling of the bottom of the block, adding in our bottom border/padding and
1761     // determining the correct collapsed bottom margin information. This collapse is only necessary
1762     // if our last child was an anonymous inline block that might need to propagate margin information out to
1763     // us.
1764     LayoutUnit afterEdge = m_flow.borderAndPaddingAfter() + m_flow.scrollbarLogicalHeight() + lastLineAnnotationsAdjustment;
1765     m_flow.setLogicalHeight(m_flow.logicalHeight() + afterEdge);
1766 
1767     if (!firstRootBox() &amp;&amp; m_flow.hasLineIfEmpty())
1768         m_flow.setLogicalHeight(m_flow.logicalHeight() + m_flow.lineHeight(true, m_flow.isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
1769 
1770     // See if we have any lines that spill out of our block. If we do, then we will possibly need to
1771     // truncate text.
1772     if (hasTextOverflow)
1773         checkLinesForTextOverflow();
1774 }
1775 
1776 void ComplexLineLayout::checkFloatInCleanLine(RootInlineBox&amp; cleanLine, RenderBox&amp; floatBoxOnCleanLine, FloatWithRect&amp; matchingFloatWithRect,
1777     bool&amp; encounteredNewFloat, bool&amp; dirtiedByFloat)
1778 {
1779     ASSERT_WITH_SECURITY_IMPLICATION(!floatBoxOnCleanLine.style().deletionHasBegun());
1780     if (&amp;matchingFloatWithRect.renderer() != &amp;floatBoxOnCleanLine) {
1781         encounteredNewFloat = true;
1782         return;
1783     }
1784     floatBoxOnCleanLine.layoutIfNeeded();
1785     LayoutRect originalFloatRect = matchingFloatWithRect.rect();
1786     LayoutSize newSize(
1787         floatBoxOnCleanLine.width() + floatBoxOnCleanLine.horizontalMarginExtent(),
1788         floatBoxOnCleanLine.height() + floatBoxOnCleanLine.verticalMarginExtent());
1789 
1790     // We have to reset the cap-height alignment done by the first-letter floats when initial-letter is set, so just always treat first-letter floats as dirty.
1791     if (originalFloatRect.size() == newSize &amp;&amp; (floatBoxOnCleanLine.style().styleType() != PseudoId::FirstLetter || !floatBoxOnCleanLine.style().initialLetterDrop()))
1792         return;
1793 
1794     LayoutUnit floatTop = m_flow.isHorizontalWritingMode() ? originalFloatRect.y() : originalFloatRect.x();
1795     LayoutUnit floatHeight = m_flow.isHorizontalWritingMode() ? std::max(originalFloatRect.height(), newSize.height())
1796         : std::max(originalFloatRect.width(), newSize.width());
1797     floatHeight = std::min(floatHeight, LayoutUnit::max() - floatTop);
1798     cleanLine.markDirty();
1799     m_flow.markLinesDirtyInBlockRange(cleanLine.lineBottomWithLeading(), floatTop + floatHeight, &amp;cleanLine);
1800     LayoutRect newFloatRect = originalFloatRect;
1801     newFloatRect.setSize(newSize);
1802     matchingFloatWithRect.adjustRect(newFloatRect);
1803     dirtiedByFloat = true;
1804 }
1805 
1806 RootInlineBox* ComplexLineLayout::determineStartPosition(LineLayoutState&amp; layoutState, InlineBidiResolver&amp; resolver)
1807 {
1808     RootInlineBox* currentLine = nullptr;
1809     RootInlineBox* lastLine = nullptr;
1810 
1811     // FIXME: This entire float-checking block needs to be broken into a new function.
1812     auto&amp; floats = layoutState.floatList();
1813     bool dirtiedByFloat = false;
1814     if (!layoutState.isFullLayout()) {
1815         // Paginate all of the clean lines.
1816         bool paginated = layoutContext().layoutState() &amp;&amp; layoutContext().layoutState()-&gt;isPaginated();
1817         LayoutUnit paginationDelta;
1818         auto floatsIterator = floats.begin();
1819         auto end = floats.end();
1820         for (currentLine = firstRootBox(); currentLine &amp;&amp; !currentLine-&gt;isDirty(); currentLine = currentLine-&gt;nextRootBox()) {
1821             if (paginated) {
1822                 if (lineWidthForPaginatedLineChanged(currentLine, 0, layoutState.fragmentedFlow())) {
1823                     currentLine-&gt;markDirty();
1824                     break;
1825                 }
1826                 paginationDelta -= currentLine-&gt;paginationStrut();
1827                 bool overflowsFragment;
1828                 m_flow.adjustLinePositionForPagination(currentLine, paginationDelta, overflowsFragment, layoutState.fragmentedFlow());
1829                 if (paginationDelta) {
1830                     if (m_flow.containsFloats() || !floats.isEmpty()) {
1831                         // FIXME: Do better eventually. For now if we ever shift because of pagination and floats are present just go to a full layout.
1832                         layoutState.markForFullLayout();
1833                         break;
1834                     }
1835 
1836                     layoutState.updateRepaintRangeFromBox(currentLine, paginationDelta);
1837                     currentLine-&gt;adjustBlockDirectionPosition(paginationDelta);
1838                 }
1839                 if (layoutState.fragmentedFlow())
1840                     updateFragmentForLine(currentLine);
1841             }
1842 
1843             if (auto* cleanLineFloats = currentLine-&gt;floatsPtr()) {
1844                 // If a new float has been inserted before this line or before its last known float, just do a full layout.
1845                 bool encounteredNewFloat = false;
1846                 for (auto&amp; floatBoxOnCleanLine : *cleanLineFloats) {
1847                     ASSERT(floatsIterator != end);
1848                     if (!floatBoxOnCleanLine)
1849                         continue;
1850                     checkFloatInCleanLine(*currentLine, *floatBoxOnCleanLine, *floatsIterator, encounteredNewFloat, dirtiedByFloat);
1851                     ++floatsIterator;
1852                     if (floatsIterator == end || encounteredNewFloat) {
1853                         layoutState.markForFullLayout();
1854                         break;
1855                     }
1856                 }
1857                 if (dirtiedByFloat || encounteredNewFloat)
1858                     break;
1859             }
1860         }
1861         // Check if a new float has been inserted after the last known float.
1862         if (floatsIterator != end) {
1863             if (!currentLine)
1864                 layoutState.markForFullLayout();
1865             else {
1866                 for (; floatsIterator != end; ++floatsIterator) {
1867                     auto&amp; floatWithRect = *floatsIterator;
1868                     if (!floatWithRect-&gt;renderer().needsLayout())
1869                         continue;
1870                     layoutState.markForFullLayout();
1871                     break;
1872                 }
1873             }
1874         }
1875     }
1876 
1877     if (layoutState.isFullLayout()) {
1878         m_lineBoxes.deleteLineBoxTree();
1879         currentLine = nullptr;
1880         ASSERT(!firstRootBox() &amp;&amp; !lastRootBox());
1881     } else {
1882         if (currentLine) {
1883             // We have a dirty line.
1884             if (RootInlineBox* prevRootBox = currentLine-&gt;prevRootBox()) {
1885                 // We have a previous line.
1886                 if (!dirtiedByFloat &amp;&amp; (!prevRootBox-&gt;endsWithBreak()
1887                     || !prevRootBox-&gt;lineBreakObj()
1888                     || (is&lt;RenderText&gt;(*prevRootBox-&gt;lineBreakObj())
1889                     &amp;&amp; prevRootBox-&gt;lineBreakPos() &gt;= downcast&lt;RenderText&gt;(*prevRootBox-&gt;lineBreakObj()).text().length()))) {
1890                     // The previous line didn&#39;t break cleanly or broke at a newline
1891                     // that has been deleted, so treat it as dirty too.
1892                     currentLine = prevRootBox;
1893                 }
1894             }
1895         }
1896         // If we have no dirty lines, then last is just the last root box.
1897         lastLine = currentLine ? currentLine-&gt;prevRootBox() : lastRootBox();
1898     }
1899 
1900     if (!floats.isEmpty()) {
1901         LayoutUnit savedLogicalHeight = m_flow.logicalHeight();
1902         // Restore floats from clean lines.
1903         RootInlineBox* line = firstRootBox();
1904         while (line != currentLine) {
1905             if (auto* cleanLineFloats = line-&gt;floatsPtr()) {
1906                 for (auto&amp; floatingBox : *cleanLineFloats) {
1907                     if (!floatingBox)
1908                         continue;
1909                     auto* floatingObject = m_flow.insertFloatingObject(*floatingBox);
1910                     ASSERT_WITH_SECURITY_IMPLICATION(!floatingObject-&gt;originatingLine());
1911                     floatingObject-&gt;setOriginatingLine(*line);
1912                     m_flow.setLogicalHeight(m_flow.logicalTopForChild(*floatingBox) - m_flow.marginBeforeForChild(*floatingBox));
1913                     m_flow.positionNewFloats();
1914                     floats.setLastCleanFloat(*floatingBox);
1915                 }
1916             }
1917             line = line-&gt;nextRootBox();
1918         }
1919         m_flow.setLogicalHeight(savedLogicalHeight);
1920     }
1921 
1922     layoutState.lineInfo().setFirstLine(!lastLine);
1923     layoutState.lineInfo().setPreviousLineBrokeCleanly(!lastLine || lastLine-&gt;endsWithBreak());
1924 
1925     if (lastLine) {
1926         m_flow.setLogicalHeight(lastLine-&gt;lineBottomWithLeading());
1927         InlineIterator iter = InlineIterator(&amp;m_flow, lastLine-&gt;lineBreakObj(), lastLine-&gt;lineBreakPos());
1928         resolver.setPosition(iter, numberOfIsolateAncestors(iter));
1929         resolver.setStatus(lastLine-&gt;lineBreakBidiStatus());
1930     } else {
1931         TextDirection direction = style().direction();
1932         if (style().unicodeBidi() == Plaintext)
1933             determineDirectionality(direction, InlineIterator(&amp;m_flow, bidiFirstSkippingEmptyInlines(m_flow), 0));
1934         resolver.setStatus(BidiStatus(direction, isOverride(style().unicodeBidi())));
1935         InlineIterator iter = InlineIterator(&amp;m_flow, bidiFirstSkippingEmptyInlines(m_flow, &amp;resolver), 0);
1936         resolver.setPosition(iter, numberOfIsolateAncestors(iter));
1937     }
1938     return currentLine;
1939 }
1940 
1941 void ComplexLineLayout::determineEndPosition(LineLayoutState&amp; layoutState, RootInlineBox* startLine, InlineIterator&amp; cleanLineStart, BidiStatus&amp; cleanLineBidiStatus)
1942 {
1943     auto iteratorForFirstDirtyFloat = [](LineLayoutState::FloatList&amp; floats) {
1944         auto lastCleanFloat = floats.lastCleanFloat();
1945         if (!lastCleanFloat)
1946             return floats.begin();
1947         auto* lastCleanFloatWithRect = floats.floatWithRect(*lastCleanFloat);
1948         ASSERT(lastCleanFloatWithRect);
1949         return ++floats.find(*lastCleanFloatWithRect);
1950     };
1951 
1952     ASSERT(!layoutState.endLine());
1953     auto floatsIterator = iteratorForFirstDirtyFloat(layoutState.floatList());
1954     auto end = layoutState.floatList().end();
1955     RootInlineBox* lastLine = nullptr;
1956     for (RootInlineBox* currentLine = startLine-&gt;nextRootBox(); currentLine; currentLine = currentLine-&gt;nextRootBox()) {
1957         if (!currentLine-&gt;isDirty()) {
1958             if (auto* cleanLineFloats = currentLine-&gt;floatsPtr()) {
1959                 bool encounteredNewFloat = false;
1960                 bool dirtiedByFloat = false;
1961                 for (auto&amp; floatBoxOnCleanLine : *cleanLineFloats) {
1962                     if (!floatBoxOnCleanLine)
1963                         continue;
1964                     ASSERT(floatsIterator != end);
1965                     checkFloatInCleanLine(*currentLine, *floatBoxOnCleanLine, *floatsIterator, encounteredNewFloat, dirtiedByFloat);
1966                     ++floatsIterator;
1967                     if (floatsIterator == end || encounteredNewFloat)
1968                         return;
1969                 }
1970             }
1971         }
1972         if (currentLine-&gt;isDirty())
1973             lastLine = nullptr;
1974         else if (!lastLine)
1975             lastLine = currentLine;
1976     }
1977 
1978     if (!lastLine)
1979         return;
1980 
1981     // At this point, |last| is the first line in a run of clean lines that ends with the last line
1982     // in the block.
1983     RootInlineBox* previousLine = lastLine-&gt;prevRootBox();
1984     cleanLineStart = InlineIterator(&amp;m_flow, previousLine-&gt;lineBreakObj(), previousLine-&gt;lineBreakPos());
1985     cleanLineBidiStatus = previousLine-&gt;lineBreakBidiStatus();
1986     layoutState.setEndLineLogicalTop(previousLine-&gt;lineBottomWithLeading());
1987 
1988     for (RootInlineBox* line = lastLine; line; line = line-&gt;nextRootBox()) {
1989         // Disconnect all line boxes from their render objects while preserving their connections to one another.
1990         line-&gt;extractLine();
1991     }
1992     layoutState.setEndLine(lastLine);
1993 }
1994 
1995 bool ComplexLineLayout::checkPaginationAndFloatsAtEndLine(LineLayoutState&amp; layoutState)
1996 {
1997     LayoutUnit lineDelta = m_flow.logicalHeight() - layoutState.endLineLogicalTop();
1998 
1999     bool paginated = layoutContext().layoutState() &amp;&amp; layoutContext().layoutState()-&gt;isPaginated();
2000     if (paginated &amp;&amp; layoutState.fragmentedFlow()) {
2001         // Check all lines from here to the end, and see if the hypothetical new position for the lines will result
2002         // in a different available line width.
2003         for (RootInlineBox* lineBox = layoutState.endLine(); lineBox; lineBox = lineBox-&gt;nextRootBox()) {
2004             if (paginated) {
2005                 // This isn&#39;t the real move we&#39;re going to do, so don&#39;t update the line box&#39;s pagination
2006                 // strut yet.
2007                 LayoutUnit oldPaginationStrut = lineBox-&gt;paginationStrut();
2008                 bool overflowsFragment;
2009                 lineDelta -= oldPaginationStrut;
2010                 m_flow.adjustLinePositionForPagination(lineBox, lineDelta, overflowsFragment, layoutState.fragmentedFlow());
2011                 lineBox-&gt;setPaginationStrut(oldPaginationStrut);
2012             }
2013             if (lineWidthForPaginatedLineChanged(lineBox, lineDelta, layoutState.fragmentedFlow()))
2014                 return false;
2015         }
2016     }
2017 
2018     if (!lineDelta || !m_flow.floatingObjects())
2019         return true;
2020 
2021     // See if any floats end in the range along which we want to shift the lines vertically.
2022     LayoutUnit logicalTop = std::min(m_flow.logicalHeight(), layoutState.endLineLogicalTop());
2023 
2024     RootInlineBox* lastLine = layoutState.endLine();
2025     while (RootInlineBox* nextLine = lastLine-&gt;nextRootBox())
2026         lastLine = nextLine;
2027 
2028     LayoutUnit logicalBottom = lastLine-&gt;lineBottomWithLeading() + absoluteValue(lineDelta);
2029 
2030     const FloatingObjectSet&amp; floatingObjectSet = m_flow.floatingObjects()-&gt;set();
2031     auto end = floatingObjectSet.end();
2032     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2033         const auto&amp; floatingObject = *it-&gt;get();
2034         if (m_flow.logicalBottomForFloat(floatingObject) &gt;= logicalTop &amp;&amp; m_flow.logicalBottomForFloat(floatingObject) &lt; logicalBottom)
2035             return false;
2036     }
2037 
2038     return true;
2039 }
2040 
2041 bool ComplexLineLayout::lineWidthForPaginatedLineChanged(RootInlineBox* rootBox, LayoutUnit lineDelta, RenderFragmentedFlow* fragmentedFlow) const
2042 {
2043     if (!fragmentedFlow)
2044         return false;
2045 
2046     RenderFragmentContainer* currentFragment = m_flow.fragmentAtBlockOffset(rootBox-&gt;lineTopWithLeading() + lineDelta);
2047     // Just bail if the fragment didn&#39;t change.
2048     if (rootBox-&gt;containingFragment() == currentFragment)
2049         return false;
2050     return rootBox-&gt;paginatedLineWidth() != m_flow.availableLogicalWidthForContent(currentFragment);
2051 }
2052 
2053 bool ComplexLineLayout::matchedEndLine(LineLayoutState&amp; layoutState, const InlineBidiResolver&amp; resolver, const InlineIterator&amp; endLineStart, const BidiStatus&amp; endLineStatus)
2054 {
2055     if (resolver.position() == endLineStart) {
2056         if (resolver.status() != endLineStatus)
2057             return false;
2058         return checkPaginationAndFloatsAtEndLine(layoutState);
2059     }
2060 
2061     // The first clean line doesn&#39;t match, but we can check a handful of following lines to try
2062     // to match back up.
2063     static const int numLines = 8; // The # of lines we&#39;re willing to match against.
2064     RootInlineBox* originalEndLine = layoutState.endLine();
2065     RootInlineBox* line = originalEndLine;
2066     for (int i = 0; i &lt; numLines &amp;&amp; line; i++, line = line-&gt;nextRootBox()) {
2067         if (line-&gt;lineBreakObj() == resolver.position().renderer() &amp;&amp; line-&gt;lineBreakPos() == resolver.position().offset()) {
2068             // We have a match.
2069             if (line-&gt;lineBreakBidiStatus() != resolver.status())
2070                 return false; // ...but the bidi state doesn&#39;t match.
2071 
2072             bool matched = false;
2073             RootInlineBox* result = line-&gt;nextRootBox();
2074             layoutState.setEndLine(result);
2075             if (result) {
2076                 layoutState.setEndLineLogicalTop(line-&gt;lineBottomWithLeading());
2077                 matched = checkPaginationAndFloatsAtEndLine(layoutState);
2078             }
2079 
2080             // Now delete the lines that we failed to sync.
2081             deleteLineRange(layoutState, originalEndLine, result);
2082             return matched;
2083         }
2084     }
2085 
2086     return false;
2087 }
2088 
2089 void ComplexLineLayout::addOverflowFromInlineChildren()
2090 {
2091     ASSERT(!m_flow.simpleLineLayout());
2092 
2093     LayoutUnit endPadding = m_flow.hasOverflowClip() ? m_flow.paddingEnd() : 0_lu;
2094     // FIXME: Need to find another way to do this, since scrollbars could show when we don&#39;t want them to.
2095     if (m_flow.hasOverflowClip() &amp;&amp; !endPadding &amp;&amp; m_flow.element() &amp;&amp; m_flow.element()-&gt;isRootEditableElement() &amp;&amp; style().isLeftToRightDirection())
2096         endPadding = 1;
2097     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
2098         m_flow.addLayoutOverflow(curr-&gt;paddedLayoutOverflowRect(endPadding));
2099         RenderFragmentContainer* fragment = m_flow.enclosingFragmentedFlow() ? curr-&gt;containingFragment() : nullptr;
2100         if (fragment)
2101             fragment-&gt;addLayoutOverflowForBox(&amp;m_flow, curr-&gt;paddedLayoutOverflowRect(endPadding));
2102         if (!m_flow.hasOverflowClip()) {
2103             LayoutRect childVisualOverflowRect = curr-&gt;visualOverflowRect(curr-&gt;lineTop(), curr-&gt;lineBottom());
2104             m_flow.addVisualOverflow(childVisualOverflowRect);
2105             if (fragment)
2106                 fragment-&gt;addVisualOverflowForBox(&amp;m_flow, childVisualOverflowRect);
2107         }
2108     }
2109 }
2110 
2111 size_t ComplexLineLayout::lineCount() const
2112 {
2113     size_t count = 0;
2114     for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox())
2115         ++count;
2116 
2117     return count;
2118 }
2119 
2120 size_t ComplexLineLayout::lineCountUntil(const RootInlineBox* stopRootInlineBox) const
2121 {
2122     size_t count = 0;
2123     for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
2124         ++count;
2125         if (box == stopRootInlineBox)
2126             break;
2127     }
2128 
2129     return count;
2130 }
2131 
2132 void ComplexLineLayout::deleteEllipsisLineBoxes()
2133 {
2134     TextAlignMode textAlign = style().textAlign();
2135     bool ltr = style().isLeftToRightDirection();
2136     IndentTextOrNot shouldIndentText = IndentText;
2137     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
2138         if (curr-&gt;hasEllipsisBox()) {
2139             curr-&gt;clearTruncation();
2140 
2141             // Shift the line back where it belongs if we cannot accomodate an ellipsis.
2142             float logicalLeft = m_flow.logicalLeftOffsetForLine(curr-&gt;lineTop(), shouldIndentText);
2143             float availableLogicalWidth = m_flow.logicalRightOffsetForLine(curr-&gt;lineTop(), DoNotIndentText) - logicalLeft;
2144             float totalLogicalWidth = curr-&gt;logicalWidth();
2145             updateLogicalWidthForAlignment(m_flow, textAlign, curr, 0, logicalLeft, totalLogicalWidth, availableLogicalWidth, 0);
2146 
2147             if (ltr)
2148                 curr-&gt;adjustLogicalPosition((logicalLeft - curr-&gt;logicalLeft()), 0);
2149             else
2150                 curr-&gt;adjustLogicalPosition(-(curr-&gt;logicalLeft() - logicalLeft), 0);
2151         }
2152         shouldIndentText = DoNotIndentText;
2153     }
2154 }
2155 
2156 void ComplexLineLayout::checkLinesForTextOverflow()
2157 {
2158     // Determine the width of the ellipsis using the current font.
2159     // FIXME: CSS3 says this is configurable, also need to use 0x002E (FULL STOP) if horizontal ellipsis is &quot;not renderable&quot;
2160     const FontCascade&amp; font = style().fontCascade();
2161     static NeverDestroyed&lt;AtomString&gt; ellipsisStr(&amp;horizontalEllipsis, 1);
2162     const FontCascade&amp; firstLineFont = m_flow.firstLineStyle().fontCascade();
2163     float firstLineEllipsisWidth = firstLineFont.width(m_flow.constructTextRun(&amp;horizontalEllipsis, 1, m_flow.firstLineStyle()));
2164     float ellipsisWidth = (font == firstLineFont) ? firstLineEllipsisWidth : font.width(m_flow.constructTextRun(&amp;horizontalEllipsis, 1, style()));
2165 
2166     // For LTR text truncation, we want to get the right edge of our padding box, and then we want to see
2167     // if the right edge of a line box exceeds that. For RTL, we use the left edge of the padding box and
2168     // check the left edge of the line box to see if it is less
2169     // Include the scrollbar for overflow blocks, which means we want to use &quot;contentWidth()&quot;
2170     bool ltr = style().isLeftToRightDirection();
2171     TextAlignMode textAlign = style().textAlign();
2172     bool firstLine = true;
2173     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
2174         IndentTextOrNot shouldIndentText = firstLine ? IndentText : DoNotIndentText;
2175         LayoutUnit blockRightEdge = m_flow.logicalRightOffsetForLine(curr-&gt;lineTop(), shouldIndentText);
2176         LayoutUnit blockLeftEdge = m_flow.logicalLeftOffsetForLine(curr-&gt;lineTop(), shouldIndentText);
2177         LayoutUnit lineBoxEdge { ltr ? curr-&gt;x() + curr-&gt;logicalWidth() : curr-&gt;x() };
2178         if ((ltr &amp;&amp; lineBoxEdge &gt; blockRightEdge) || (!ltr &amp;&amp; lineBoxEdge &lt; blockLeftEdge)) {
2179             // This line spills out of our box in the appropriate direction. Now we need to see if the line
2180             // can be truncated. In order for truncation to be possible, the line must have sufficient space to
2181             // accommodate our truncation string, and no replaced elements (images, tables) can overlap the ellipsis
2182             // space.
2183             LayoutUnit width { firstLine ? firstLineEllipsisWidth : ellipsisWidth };
2184             LayoutUnit blockEdge { ltr ? blockRightEdge : blockLeftEdge };
2185             if (curr-&gt;lineCanAccommodateEllipsis(ltr, blockEdge, lineBoxEdge, width)) {
2186                 float totalLogicalWidth = curr-&gt;placeEllipsis(ellipsisStr, ltr, blockLeftEdge, blockRightEdge, width);
2187 
2188                 float logicalLeft = 0; // We are only interested in the delta from the base position.
2189                 float truncatedWidth = m_flow.availableLogicalWidthForLine(curr-&gt;lineTop(), shouldIndentText);
2190                 updateLogicalWidthForAlignment(m_flow, textAlign, curr, nullptr, logicalLeft, totalLogicalWidth, truncatedWidth, 0);
2191                 if (ltr)
2192                     curr-&gt;adjustLogicalPosition(logicalLeft, 0);
2193                 else
2194                     curr-&gt;adjustLogicalPosition(-(truncatedWidth - (logicalLeft + totalLogicalWidth)), 0);
2195             }
2196         }
2197         firstLine = false;
2198     }
2199 }
2200 
2201 bool ComplexLineLayout::positionNewFloatOnLine(const FloatingObject&amp; newFloat, FloatingObject* lastFloatFromPreviousLine, LineInfo&amp; lineInfo, LineWidth&amp; width)
2202 {
2203     if (!m_flow.positionNewFloats())
2204         return false;
2205 
2206     width.shrinkAvailableWidthForNewFloatIfNeeded(newFloat);
2207 
2208     // We only connect floats to lines for pagination purposes if the floats occur at the start of
2209     // the line and the previous line had a hard break (so this line is either the first in the block
2210     // or follows a &lt;br&gt;).
2211     if (!newFloat.paginationStrut() || !lineInfo.previousLineBrokeCleanly() || !lineInfo.isEmpty())
2212         return true;
2213 
2214     const FloatingObjectSet&amp; floatingObjectSet = m_flow.floatingObjects()-&gt;set();
2215     ASSERT(floatingObjectSet.last().get() == &amp;newFloat);
2216 
2217     LayoutUnit floatLogicalTop = m_flow.logicalTopForFloat(newFloat);
2218     LayoutUnit paginationStrut = newFloat.paginationStrut();
2219 
2220     if (floatLogicalTop - paginationStrut != m_flow.logicalHeight() + lineInfo.floatPaginationStrut())
2221         return true;
2222 
2223     auto it = floatingObjectSet.end();
2224     --it; // Last float is newFloat, skip that one.
2225     auto begin = floatingObjectSet.begin();
2226     while (it != begin) {
2227         --it;
2228         auto&amp; floatingObject = *it-&gt;get();
2229         if (&amp;floatingObject == lastFloatFromPreviousLine)
2230             break;
2231         if (m_flow.logicalTopForFloat(floatingObject) == m_flow.logicalHeight() + lineInfo.floatPaginationStrut()) {
2232             floatingObject.setPaginationStrut(paginationStrut + floatingObject.paginationStrut());
2233             RenderBox&amp; floatBox = floatingObject.renderer();
2234             m_flow.setLogicalTopForChild(floatBox, m_flow.logicalTopForChild(floatBox) + m_flow.marginBeforeForChild(floatBox) + paginationStrut);
2235 
2236             if (m_flow.updateFragmentRangeForBoxChild(floatBox))
2237                 floatBox.setNeedsLayout(MarkOnlyThis);
2238             else if (is&lt;RenderBlock&gt;(floatBox))
2239                 downcast&lt;RenderBlock&gt;(floatBox).setChildNeedsLayout(MarkOnlyThis);
2240             floatBox.layoutIfNeeded();
2241 
2242             // Save the old logical top before calling removePlacedObject which will set
2243             // isPlaced to false. Otherwise it will trigger an assert in logicalTopForFloat.
2244             LayoutUnit oldLogicalTop = m_flow.logicalTopForFloat(floatingObject);
2245             m_flow.floatingObjects()-&gt;removePlacedObject(&amp;floatingObject);
2246             m_flow.setLogicalTopForFloat(floatingObject, oldLogicalTop + paginationStrut);
2247             m_flow.floatingObjects()-&gt;addPlacedObject(&amp;floatingObject);
2248         }
2249     }
2250 
2251     // Just update the line info&#39;s pagination strut without altering our logical height yet. If the line ends up containing
2252     // no content, then we don&#39;t want to improperly grow the height of the block.
2253     lineInfo.setFloatPaginationStrut(lineInfo.floatPaginationStrut() + paginationStrut);
2254     return true;
2255 }
2256 
2257 void ComplexLineLayout::updateFragmentForLine(RootInlineBox* lineBox) const
2258 {
2259     ASSERT(lineBox);
2260 
2261     if (!m_flow.hasFragmentRangeInFragmentedFlow())
2262         lineBox-&gt;clearContainingFragment();
2263     else {
2264         if (auto containingFragment = m_flow.fragmentAtBlockOffset(lineBox-&gt;lineTopWithLeading()))
2265             lineBox-&gt;setContainingFragment(*containingFragment);
2266         else
2267             lineBox-&gt;clearContainingFragment();
2268     }
2269 
2270     RootInlineBox* prevLineBox = lineBox-&gt;prevRootBox();
2271     if (!prevLineBox)
2272         return;
2273 
2274     // This check is more accurate than the one in |adjustLinePositionForPagination| because it takes into
2275     // account just the container changes between lines. The before mentioned function doesn&#39;t set the flag
2276     // correctly if the line is positioned at the top of the last fragment container.
2277     if (lineBox-&gt;containingFragment() != prevLineBox-&gt;containingFragment())
2278         lineBox-&gt;setIsFirstAfterPageBreak(true);
2279 }
2280 
2281 const RenderStyle&amp; ComplexLineLayout::style() const
2282 {
2283     return m_flow.style();
2284 }
2285 
2286 const FrameViewLayoutContext&amp; ComplexLineLayout::layoutContext() const
2287 {
2288     return m_flow.view().frameView().layoutContext();
2289 }
2290 
2291 
2292 }
    </pre>
  </body>
</html>
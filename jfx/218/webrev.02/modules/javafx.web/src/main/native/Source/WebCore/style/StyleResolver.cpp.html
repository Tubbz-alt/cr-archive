<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012, 2013 Google Inc. All rights reserved.
 12  * Copyright (C) 2014 Igalia S.L.
 13  *
 14  * This library is free software; you can redistribute it and/or
 15  * modify it under the terms of the GNU Library General Public
 16  * License as published by the Free Software Foundation; either
 17  * version 2 of the License, or (at your option) any later version.
 18  *
 19  * This library is distributed in the hope that it will be useful,
 20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 22  * Library General Public License for more details.
 23  *
 24  * You should have received a copy of the GNU Library General Public License
 25  * along with this library; see the file COPYING.LIB.  If not, write to
 26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 27  * Boston, MA 02110-1301, USA.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;StyleResolver.h&quot;
 32 
 33 #include &quot;CSSFontSelector.h&quot;
 34 #include &quot;CSSKeyframeRule.h&quot;
 35 #include &quot;CSSKeyframesRule.h&quot;
 36 #include &quot;CSSParser.h&quot;
 37 #include &quot;CSSPrimitiveValueMappings.h&quot;
 38 #include &quot;CSSPropertyNames.h&quot;
 39 #include &quot;CSSSelector.h&quot;
 40 #include &quot;CSSStyleRule.h&quot;
 41 #include &quot;CSSStyleSheet.h&quot;
 42 #include &quot;CachedResourceLoader.h&quot;
 43 #include &quot;ElementRuleCollector.h&quot;
 44 #include &quot;Frame.h&quot;
 45 #include &quot;FrameSelection.h&quot;
 46 #include &quot;FrameView.h&quot;
 47 #include &quot;InspectorInstrumentation.h&quot;
 48 #include &quot;KeyframeList.h&quot;
 49 #include &quot;Logging.h&quot;
 50 #include &quot;MediaList.h&quot;
 51 #include &quot;MediaQueryEvaluator.h&quot;
 52 #include &quot;NodeRenderStyle.h&quot;
 53 #include &quot;PageRuleCollector.h&quot;
 54 #include &quot;Pair.h&quot;
 55 #include &quot;RenderScrollbar.h&quot;
 56 #include &quot;RenderStyleConstants.h&quot;
 57 #include &quot;RenderView.h&quot;
 58 #include &quot;RuleSet.h&quot;
 59 #include &quot;RuntimeEnabledFeatures.h&quot;
 60 #include &quot;SVGDocumentExtensions.h&quot;
 61 #include &quot;SVGElement.h&quot;
 62 #include &quot;SVGFontFaceElement.h&quot;
 63 #include &quot;Settings.h&quot;
 64 #include &quot;ShadowRoot.h&quot;
 65 #include &quot;SharedStringHash.h&quot;
 66 #include &quot;StyleAdjuster.h&quot;
 67 #include &quot;StyleBuilder.h&quot;
 68 #include &quot;StyleFontSizeFunctions.h&quot;
 69 #include &quot;StyleProperties.h&quot;
 70 #include &quot;StylePropertyShorthand.h&quot;
 71 #include &quot;StyleResolveForDocument.h&quot;
 72 #include &quot;StyleRule.h&quot;
 73 #include &quot;StyleSheetContents.h&quot;
 74 #include &quot;UserAgentStyle.h&quot;
 75 #include &quot;ViewportStyleResolver.h&quot;
 76 #include &quot;VisitedLinkState.h&quot;
 77 #include &quot;WebKitFontFamilyNames.h&quot;
 78 #include &lt;wtf/Seconds.h&gt;
 79 #include &lt;wtf/StdLibExtras.h&gt;
 80 #include &lt;wtf/Vector.h&gt;
 81 #include &lt;wtf/text/AtomStringHash.h&gt;
 82 
 83 namespace WebCore {
 84 namespace Style {
 85 
 86 using namespace HTMLNames;
 87 
 88 Resolver::Resolver(Document&amp; document)
 89     : m_ruleSets(*this)
 90     , m_document(document)
 91 #if ENABLE(CSS_DEVICE_ADAPTATION)
 92     , m_viewportStyleResolver(ViewportStyleResolver::create(&amp;document))
 93 #endif
 94     , m_matchAuthorAndUserStyles(m_document.settings().authorAndUserStylesEnabled())
 95 {
 96     Element* root = m_document.documentElement();
 97 
 98     UserAgentStyle::initDefaultStyle(root);
 99 
100     // construct document root element default style. this is needed
101     // to evaluate media queries that contain relative constraints, like &quot;screen and (max-width: 10em)&quot;
102     // This is here instead of constructor, because when constructor is run,
103     // document doesn&#39;t have documentElement
104     // NOTE: this assumes that element that gets passed to styleForElement -call
105     // is always from the document that owns the style selector
106     FrameView* view = m_document.view();
107     if (view)
108         m_mediaQueryEvaluator = MediaQueryEvaluator { view-&gt;mediaType() };
109     else
110         m_mediaQueryEvaluator = MediaQueryEvaluator { &quot;all&quot; };
111 
112     if (root) {
113         m_rootDefaultStyle = styleForElement(*root, m_document.renderStyle(), nullptr, RuleMatchingBehavior::MatchOnlyUserAgentRules).renderStyle;
114         // Turn off assertion against font lookups during style resolver initialization. We may need root style font for media queries.
115         m_document.fontSelector().incrementIsComputingRootStyleFont();
116         m_rootDefaultStyle-&gt;fontCascade().update(&amp;m_document.fontSelector());
117         m_rootDefaultStyle-&gt;fontCascade().primaryFont();
118         m_document.fontSelector().decrementIsComputingRootStyleFont();
119     }
120 
121     if (m_rootDefaultStyle &amp;&amp; view)
122         m_mediaQueryEvaluator = MediaQueryEvaluator { view-&gt;mediaType(), m_document, m_rootDefaultStyle.get() };
123 
124     m_ruleSets.resetAuthorStyle();
125     m_ruleSets.resetUserAgentMediaQueryStyle();
126 }
127 
128 void Resolver::addCurrentSVGFontFaceRules()
129 {
130 #if ENABLE(SVG_FONTS)
131     if (m_document.svgExtensions()) {
132         const HashSet&lt;SVGFontFaceElement*&gt;&amp; svgFontFaceElements = m_document.svgExtensions()-&gt;svgFontFaceElements();
133         for (auto* svgFontFaceElement : svgFontFaceElements)
134             m_document.fontSelector().addFontFaceRule(svgFontFaceElement-&gt;fontFaceRule(), svgFontFaceElement-&gt;isInUserAgentShadowTree());
135     }
136 #endif
137 }
138 
139 void Resolver::appendAuthorStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; styleSheets)
140 {
141     m_ruleSets.appendAuthorStyleSheets(styleSheets, &amp;m_mediaQueryEvaluator, m_inspectorCSSOMWrappers);
142 
143     if (auto renderView = document().renderView())
144         renderView-&gt;style().fontCascade().update(&amp;document().fontSelector());
145 
146 #if ENABLE(CSS_DEVICE_ADAPTATION)
147     viewportStyleResolver()-&gt;resolve();
148 #endif
149 }
150 
151 // This is a simplified style setting function for keyframe styles
152 void Resolver::addKeyframeStyle(Ref&lt;StyleRuleKeyframes&gt;&amp;&amp; rule)
153 {
154     AtomString s(rule-&gt;name());
155     m_keyframesRuleMap.set(s.impl(), WTFMove(rule));
156 }
157 
158 Resolver::~Resolver()
159 {
160     RELEASE_ASSERT(!m_document.isResolvingTreeStyle());
161     RELEASE_ASSERT(!m_isDeleted);
162     m_isDeleted = true;
163 
164 #if ENABLE(CSS_DEVICE_ADAPTATION)
165     m_viewportStyleResolver-&gt;clearDocument();
166 #endif
167 }
168 
169 Resolver::State::State(const Element&amp; element, const RenderStyle* parentStyle, const RenderStyle* documentElementStyle)
170     : m_element(&amp;element)
171     , m_parentStyle(parentStyle)
172 {
173     bool resetStyleInheritance = hasShadowRootParent(element) &amp;&amp; downcast&lt;ShadowRoot&gt;(element.parentNode())-&gt;resetStyleInheritance();
174     if (resetStyleInheritance)
175         m_parentStyle = nullptr;
176 
177     auto&amp; document = element.document();
178     auto* documentElement = document.documentElement();
179     if (!documentElement || documentElement == &amp;element)
180         m_rootElementStyle = document.renderStyle();
181     else
182         m_rootElementStyle = documentElementStyle ? documentElementStyle : documentElement-&gt;renderStyle();
183 }
184 
185 inline void Resolver::State::setStyle(std::unique_ptr&lt;RenderStyle&gt; style)
186 {
187     m_style = WTFMove(style);
188 }
189 
190 inline void Resolver::State::setParentStyle(std::unique_ptr&lt;RenderStyle&gt; parentStyle)
191 {
192     m_ownedParentStyle = WTFMove(parentStyle);
193     m_parentStyle = m_ownedParentStyle.get();
194 }
195 
196 static inline bool isAtShadowBoundary(const Element&amp; element)
197 {
198     auto* parentNode = element.parentNode();
199     return parentNode &amp;&amp; parentNode-&gt;isShadowRoot();
200 }
201 
202 BuilderContext Resolver::builderContext(const State&amp; state)
203 {
204     return {
205         m_document,
206         *state.parentStyle(),
207         state.rootElementStyle(),
208         state.element()
209     };
210 }
211 
212 ElementStyle Resolver::styleForElement(const Element&amp; element, const RenderStyle* parentStyle, const RenderStyle* parentBoxStyle, RuleMatchingBehavior matchingBehavior, const SelectorFilter* selectorFilter)
213 {
214     RELEASE_ASSERT(!m_isDeleted);
215 
216     auto state = State(element, parentStyle, m_overrideDocumentElementStyle);
217 
218     if (state.parentStyle()) {
219         state.setStyle(RenderStyle::createPtr());
220         state.style()-&gt;inheritFrom(*state.parentStyle());
221     } else {
222         state.setStyle(defaultStyleForElement(&amp;element));
223         state.setParentStyle(RenderStyle::clonePtr(*state.style()));
224     }
225 
226     auto&amp; style = *state.style();
227 
228     if (element.isLink()) {
229         style.setIsLink(true);
230         InsideLink linkState = document().visitedLinkState().determineLinkState(element);
231         if (linkState != InsideLink::NotInside) {
232             bool forceVisited = InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassVisited);
233             if (forceVisited)
234                 linkState = InsideLink::InsideVisited;
235         }
236         style.setInsideLink(linkState);
237     }
238 
239     UserAgentStyle::ensureDefaultStyleSheetsForElement(element);
240 
241     ElementRuleCollector collector(element, m_ruleSets, selectorFilter);
242     collector.setMedium(&amp;m_mediaQueryEvaluator);
243 
244     if (matchingBehavior == RuleMatchingBehavior::MatchOnlyUserAgentRules)
245         collector.matchUARules();
246     else
247         collector.matchAllRules(m_matchAuthorAndUserStyles, matchingBehavior != RuleMatchingBehavior::MatchAllRulesExcludingSMIL);
248 
249     if (collector.matchedPseudoElementIds())
250         style.setHasPseudoStyles(collector.matchedPseudoElementIds());
251 
252     // This is required for style sharing.
253     if (collector.didMatchUncommonAttributeSelector())
254         style.setUnique();
255 
256     auto elementStyleRelations = commitRelationsToRenderStyle(style, element, collector.styleRelations());
257 
258     applyMatchedProperties(state, collector.matchResult());
259 
260     Adjuster adjuster(document(), *state.parentStyle(), parentBoxStyle, &amp;element);
261     adjuster.adjust(*state.style(), state.userAgentAppearanceStyle());
262 
263     if (state.style()-&gt;hasViewportUnits())
264         document().setHasStyleWithViewportUnits();
265 
266     return { state.takeStyle(), WTFMove(elementStyleRelations) };
267 }
268 
269 std::unique_ptr&lt;RenderStyle&gt; Resolver::styleForKeyframe(const Element&amp; element, const RenderStyle* elementStyle, const StyleRuleKeyframe* keyframe, KeyframeValue&amp; keyframeValue)
270 {
271     RELEASE_ASSERT(!m_isDeleted);
272 
273     MatchResult result;
274     result.authorDeclarations.append({ &amp;keyframe-&gt;properties() });
275 
276     auto state = State(element, nullptr);
277 
278     state.setStyle(RenderStyle::clonePtr(*elementStyle));
279     state.setParentStyle(RenderStyle::clonePtr(*elementStyle));
280 
281     Builder builder(*state.style(), builderContext(state), result, { CascadeLevel::Author });
282     builder.applyAllProperties();
283 
284     Adjuster adjuster(document(), *state.parentStyle(), nullptr, nullptr);
285     adjuster.adjust(*state.style(), state.userAgentAppearanceStyle());
286 
287     // Add all the animating properties to the keyframe.
288     unsigned propertyCount = keyframe-&gt;properties().propertyCount();
289     for (unsigned i = 0; i &lt; propertyCount; ++i) {
290         CSSPropertyID property = keyframe-&gt;properties().propertyAt(i).id();
291         // Timing-function within keyframes is special, because it is not animated; it just
292         // describes the timing function between this keyframe and the next.
293         if (property != CSSPropertyAnimationTimingFunction)
294             keyframeValue.addProperty(property);
295     }
296 
297     return state.takeStyle();
298 }
299 
300 bool Resolver::isAnimationNameValid(const String&amp; name)
301 {
302     return m_keyframesRuleMap.find(AtomString(name).impl()) != m_keyframesRuleMap.end();
303 }
304 
305 void Resolver::keyframeStylesForAnimation(const Element&amp; element, const RenderStyle* elementStyle, KeyframeList&amp; list)
306 {
307     list.clear();
308 
309     // Get the keyframesRule for this name.
310     if (list.animationName().isEmpty())
311         return;
312 
313     m_keyframesRuleMap.checkConsistency();
314 
315     KeyframesRuleMap::iterator it = m_keyframesRuleMap.find(list.animationName().impl());
316     if (it == m_keyframesRuleMap.end())
317         return;
318 
319     const StyleRuleKeyframes* keyframesRule = it-&gt;value.get();
320 
321     auto* keyframes = &amp;keyframesRule-&gt;keyframes();
322     Vector&lt;Ref&lt;StyleRuleKeyframe&gt;&gt; newKeyframesIfNecessary;
323 
324     bool hasDuplicateKeys = false;
325     HashSet&lt;double&gt; keyframeKeys;
326     for (auto&amp; keyframe : *keyframes) {
327         for (auto key : keyframe-&gt;keys()) {
328             if (!keyframeKeys.add(key)) {
329                 hasDuplicateKeys = true;
330                 break;
331             }
332         }
333         if (hasDuplicateKeys)
334             break;
335     }
336 
337     // FIXME: If HashMaps could have Ref&lt;&gt; as value types, we wouldn&#39;t need
338     // to copy the HashMap into a Vector.
339     if (hasDuplicateKeys) {
340         // Merge duplicate key times.
341         HashMap&lt;double, RefPtr&lt;StyleRuleKeyframe&gt;&gt; keyframesMap;
342 
343         for (auto&amp; originalKeyframe : keyframesRule-&gt;keyframes()) {
344             for (auto key : originalKeyframe-&gt;keys()) {
345                 if (auto keyframe = keyframesMap.get(key))
346                     keyframe-&gt;mutableProperties().mergeAndOverrideOnConflict(originalKeyframe-&gt;properties());
347                 else {
348                     auto StyleRuleKeyframe = StyleRuleKeyframe::create(MutableStyleProperties::create());
349                     StyleRuleKeyframe.ptr()-&gt;setKey(key);
350                     StyleRuleKeyframe.ptr()-&gt;mutableProperties().mergeAndOverrideOnConflict(originalKeyframe-&gt;properties());
351                     keyframesMap.set(key, StyleRuleKeyframe.ptr());
352                 }
353             }
354         }
355 
356         for (auto&amp; keyframe : keyframesMap.values())
357             newKeyframesIfNecessary.append(*keyframe.get());
358 
359         keyframes = &amp;newKeyframesIfNecessary;
360     }
361 
362     // Construct and populate the style for each keyframe.
363     for (auto&amp; keyframe : *keyframes) {
364         // Add this keyframe style to all the indicated key times
365         for (auto key : keyframe-&gt;keys()) {
366             KeyframeValue keyframeValue(0, nullptr);
367             keyframeValue.setStyle(styleForKeyframe(element, elementStyle, keyframe.ptr(), keyframeValue));
368             keyframeValue.setKey(key);
369             if (auto timingFunctionCSSValue = keyframe-&gt;properties().getPropertyCSSValue(CSSPropertyAnimationTimingFunction))
370                 keyframeValue.setTimingFunction(TimingFunction::createFromCSSValue(*timingFunctionCSSValue.get()));
371             list.insert(WTFMove(keyframeValue));
372         }
373     }
374 
375     // If the 0% keyframe is missing, create it (but only if there is at least one other keyframe).
376     int initialListSize = list.size();
377     if (initialListSize &gt; 0 &amp;&amp; list[0].key()) {
378         static StyleRuleKeyframe* zeroPercentKeyframe;
379         if (!zeroPercentKeyframe) {
380             zeroPercentKeyframe = &amp;StyleRuleKeyframe::create(MutableStyleProperties::create()).leakRef();
381             zeroPercentKeyframe-&gt;setKey(0);
382         }
383         KeyframeValue keyframeValue(0, nullptr);
384         keyframeValue.setStyle(styleForKeyframe(element, elementStyle, zeroPercentKeyframe, keyframeValue));
385         list.insert(WTFMove(keyframeValue));
386     }
387 
388     // If the 100% keyframe is missing, create it (but only if there is at least one other keyframe).
389     if (initialListSize &gt; 0 &amp;&amp; (list[list.size() - 1].key() != 1)) {
390         static StyleRuleKeyframe* hundredPercentKeyframe;
391         if (!hundredPercentKeyframe) {
392             hundredPercentKeyframe = &amp;StyleRuleKeyframe::create(MutableStyleProperties::create()).leakRef();
393             hundredPercentKeyframe-&gt;setKey(1);
394         }
395         KeyframeValue keyframeValue(1, nullptr);
396         keyframeValue.setStyle(styleForKeyframe(element, elementStyle, hundredPercentKeyframe, keyframeValue));
397         list.insert(WTFMove(keyframeValue));
398     }
399 }
400 
401 std::unique_ptr&lt;RenderStyle&gt; Resolver::pseudoStyleForElement(const Element&amp; element, const PseudoElementRequest&amp; pseudoElementRequest, const RenderStyle&amp; parentStyle, const RenderStyle* parentBoxStyle, const SelectorFilter* selectorFilter)
402 {
403     auto state = State(element, &amp;parentStyle, m_overrideDocumentElementStyle);
404 
405     if (state.parentStyle()) {
406         state.setStyle(RenderStyle::createPtr());
407         state.style()-&gt;inheritFrom(*state.parentStyle());
408     } else {
409         state.setStyle(defaultStyleForElement(&amp;element));
410         state.setParentStyle(RenderStyle::clonePtr(*state.style()));
411     }
412 
413     ElementRuleCollector collector(element, m_ruleSets, selectorFilter);
414     collector.setPseudoElementRequest(pseudoElementRequest);
415     collector.setMedium(&amp;m_mediaQueryEvaluator);
416     collector.matchUARules();
417 
418     if (m_matchAuthorAndUserStyles) {
419         collector.matchUserRules();
420         collector.matchAuthorRules();
421     }
422 
423     ASSERT(!collector.matchedPseudoElementIds());
424 
425     if (collector.matchResult().isEmpty())
426         return nullptr;
427 
428     state.style()-&gt;setStyleType(pseudoElementRequest.pseudoId);
429 
430     applyMatchedProperties(state, collector.matchResult());
431 
432     Adjuster adjuster(document(), *state.parentStyle(), parentBoxStyle, nullptr);
433     adjuster.adjust(*state.style(), state.userAgentAppearanceStyle());
434 
435     if (state.style()-&gt;hasViewportUnits())
436         document().setHasStyleWithViewportUnits();
437 
438     return state.takeStyle();
439 }
440 
441 std::unique_ptr&lt;RenderStyle&gt; Resolver::styleForPage(int pageIndex)
442 {
443     RELEASE_ASSERT(!m_isDeleted);
444 
445     auto* documentElement = m_document.documentElement();
446     if (!documentElement)
447         return RenderStyle::createPtr();
448 
449     auto state = State(*documentElement, m_document.renderStyle());
450 
451     state.setStyle(RenderStyle::createPtr());
452     state.style()-&gt;inheritFrom(*state.rootElementStyle());
453 
454     PageRuleCollector collector(state, m_ruleSets);
455     collector.matchAllPageRules(pageIndex);
456 
457     auto&amp; result = collector.matchResult();
458 
459     Builder builder(*state.style(), builderContext(state), result, { CascadeLevel::Author });
460     builder.applyAllProperties();
461 
462     // Now return the style.
463     return state.takeStyle();
464 }
465 
466 std::unique_ptr&lt;RenderStyle&gt; Resolver::defaultStyleForElement(const Element* element)
467 {
468     auto style = RenderStyle::createPtr();
469 
470     FontCascadeDescription fontDescription;
471     fontDescription.setRenderingMode(settings().fontRenderingMode());
472     fontDescription.setOneFamily(standardFamily);
473     fontDescription.setKeywordSizeFromIdentifier(CSSValueMedium);
474 
475     auto size = fontSizeForKeyword(CSSValueMedium, false, document());
476     fontDescription.setSpecifiedSize(size);
477     fontDescription.setComputedSize(computedFontSizeFromSpecifiedSize(size, fontDescription.isAbsoluteSize(), is&lt;SVGElement&gt;(element), style.get(), document()));
478 
479     fontDescription.setShouldAllowUserInstalledFonts(settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No);
480     style-&gt;setFontDescription(WTFMove(fontDescription));
481 
482     style-&gt;fontCascade().update(&amp;document().fontSelector());
483 
484     return style;
485 }
486 
487 Vector&lt;RefPtr&lt;const StyleRule&gt;&gt; Resolver::styleRulesForElement(const Element* element, unsigned rulesToInclude)
488 {
489     return pseudoStyleRulesForElement(element, PseudoId::None, rulesToInclude);
490 }
491 
492 Vector&lt;RefPtr&lt;const StyleRule&gt;&gt; Resolver::pseudoStyleRulesForElement(const Element* element, PseudoId pseudoId, unsigned rulesToInclude)
493 {
494     if (!element)
495         return { };
496 
497     auto state = State(*element, nullptr);
498 
499     ElementRuleCollector collector(*element, m_ruleSets, nullptr);
500     collector.setMode(SelectorChecker::Mode::CollectingRules);
501     collector.setPseudoElementRequest({ pseudoId });
502     collector.setMedium(&amp;m_mediaQueryEvaluator);
503     collector.setIncludeEmptyRules(rulesToInclude &amp; EmptyCSSRules);
504 
505     if (rulesToInclude &amp; UAAndUserCSSRules) {
506         // First we match rules from the user agent sheet.
507         collector.matchUARules();
508 
509         // Now we check user sheet rules.
510         if (m_matchAuthorAndUserStyles)
511             collector.matchUserRules();
512     }
513 
514     if (m_matchAuthorAndUserStyles &amp;&amp; (rulesToInclude &amp; AuthorCSSRules))
515         collector.matchAuthorRules();
516 
517     return collector.matchedRuleList();
518 }
519 
520 static bool elementTypeHasAppearanceFromUAStyle(const Element&amp; element)
521 {
522     // NOTE: This is just a hard-coded list of elements that have some -webkit-appearance value in html.css
523     const auto&amp; localName = element.localName();
524     return localName == HTMLNames::inputTag
525         || localName == HTMLNames::textareaTag
526         || localName == HTMLNames::buttonTag
527         || localName == HTMLNames::progressTag
528         || localName == HTMLNames::selectTag
529         || localName == HTMLNames::meterTag;
530 }
531 
532 void Resolver::invalidateMatchedDeclarationsCache()
533 {
534     m_matchedDeclarationsCache.invalidate();
535 }
536 
537 void Resolver::clearCachedDeclarationsAffectedByViewportUnits()
538 {
539     m_matchedDeclarationsCache.clearEntriesAffectedByViewportUnits();
540 }
541 
542 void Resolver::applyMatchedProperties(State&amp; state, const MatchResult&amp; matchResult, UseMatchedDeclarationsCache useMatchedDeclarationsCache)
543 {
544     unsigned cacheHash = useMatchedDeclarationsCache == UseMatchedDeclarationsCache::Yes ? MatchedDeclarationsCache::computeHash(matchResult) : 0;
545     auto includedProperties = PropertyCascade::IncludedProperties::All;
546 
547     auto&amp; style = *state.style();
548     auto&amp; parentStyle = *state.parentStyle();
549     auto&amp; element = *state.element();
550 
551     auto* cacheEntry = m_matchedDeclarationsCache.find(cacheHash, matchResult);
552     if (cacheEntry &amp;&amp; MatchedDeclarationsCache::isCacheable(element, style, parentStyle)) {
553         // We can build up the style by copying non-inherited properties from an earlier style object built using the same exact
554         // style declarations. We then only need to apply the inherited properties, if any, as their values can depend on the
555         // element context. This is fast and saves memory by reusing the style data structures.
556         style.copyNonInheritedFrom(*cacheEntry-&gt;renderStyle);
557 
558         if (parentStyle.inheritedEqual(*cacheEntry-&gt;parentRenderStyle) &amp;&amp; !isAtShadowBoundary(element)) {
559             InsideLink linkStatus = state.style()-&gt;insideLink();
560             // If the cache item parent style has identical inherited properties to the current parent style then the
561             // resulting style will be identical too. We copy the inherited properties over from the cache and are done.
562             style.inheritFrom(*cacheEntry-&gt;renderStyle);
563 
564             // Unfortunately the link status is treated like an inherited property. We need to explicitly restore it.
565             style.setInsideLink(linkStatus);
566             return;
567         }
568 
569         includedProperties = PropertyCascade::IncludedProperties::InheritedOnly;
570     }
571 
572     if (elementTypeHasAppearanceFromUAStyle(element)) {
573         // Find out if there&#39;s a -webkit-appearance property in effect from the UA sheet.
574         // If so, we cache the border and background styles so that RenderTheme::adjustStyle()
575         // can look at them later to figure out if this is a styled form control or not.
576         auto userAgentStyle = RenderStyle::clonePtr(style);
577         Builder builder(*userAgentStyle, builderContext(state), matchResult, { CascadeLevel::UserAgent });
578         builder.applyAllProperties();
579 
580         state.setUserAgentAppearanceStyle(WTFMove(userAgentStyle));
581     }
582 
583     Builder builder(*state.style(), builderContext(state), matchResult, allCascadeLevels(), includedProperties);
584 
585     // High priority properties may affect resolution of other properties (they are mostly font related).
586     builder.applyHighPriorityProperties();
587 
588     if (cacheEntry &amp;&amp; !cacheEntry-&gt;isUsableAfterHighPriorityProperties(style)) {
589         // We need to resolve all properties without caching.
590         applyMatchedProperties(state, matchResult, UseMatchedDeclarationsCache::No);
591         return;
592     }
593 
594     builder.applyLowPriorityProperties();
595 
596     for (auto&amp; contentAttribute : builder.state().registeredContentAttributes())
597         ruleSets().mutableFeatures().registerContentAttribute(contentAttribute);
598 
599     if (cacheEntry || !cacheHash)
600         return;
601 
602     if (MatchedDeclarationsCache::isCacheable(element, style, parentStyle))
603         m_matchedDeclarationsCache.add(style, parentStyle, cacheHash, matchResult);
604 }
605 
606 bool Resolver::hasViewportDependentMediaQueries() const
607 {
608     return m_ruleSets.hasViewportDependentMediaQueries();
609 }
610 
611 Optional&lt;DynamicMediaQueryEvaluationChanges&gt; Resolver::evaluateDynamicMediaQueries()
612 {
613     return m_ruleSets.evaluteDynamicMediaQueryRules(m_mediaQueryEvaluator);
614 }
615 
616 } // namespace Style
617 } // namespace WebCore
    </pre>
  </body>
</html>
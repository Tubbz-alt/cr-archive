<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpObjectInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpPrototype.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,21 ***</span>
  #include &quot;YarrFlags.h&quot;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoFuncExec(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoFuncCompile(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoFuncToString(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterGlobal(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterIgnoreCase(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterMultiline(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterDotAll(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterSticky(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterUnicode(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterSource(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterFlags(ExecState*);</span>
  
  const ClassInfo RegExpPrototype::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RegExpPrototype) };
  
  RegExpPrototype::RegExpPrototype(VM&amp; vm, Structure* structure)
      : JSNonFinalObject(vm, structure)
<span class="line-new-header">--- 40,21 ---</span>
  #include &quot;YarrFlags.h&quot;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoFuncExec(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoFuncCompile(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoFuncToString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterGlobal(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterIgnoreCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterMultiline(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterDotAll(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterSticky(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterUnicode(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterSource(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL regExpProtoGetterFlags(JSGlobalObject*, CallFrame*);</span>
  
  const ClassInfo RegExpPrototype::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RegExpPrototype) };
  
  RegExpPrototype::RegExpPrototype(VM&amp; vm, Structure* structure)
      : JSNonFinalObject(vm, structure)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,266 ***</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;test, regExpPrototypeTestCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  }
  
  // ------------------------------ Functions ---------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncTestFast(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     JSString* string = exec-&gt;argument(0).toStringOrNull(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !string);
      if (!string)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(regexp-&gt;test(exec, exec-&gt;lexicalGlobalObject(), string))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncExec(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp))
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Builtin RegExp exec can only be called on a RegExp object&quot;);</span>
<span class="line-modified">!     JSString* string = exec-&gt;argument(0).toStringOrNull(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !string);
      if (!string)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(exec, exec-&gt;lexicalGlobalObject(), string)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncMatchFast(ExecState* exec)</span>
  {
<span class="line-modified">!     RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(exec-&gt;thisValue());</span>
<span class="line-modified">!     JSString* string = jsCast&lt;JSString*&gt;(exec-&gt;uncheckedArgument(0));</span>
      if (!thisObject-&gt;regExp()-&gt;global())
<span class="line-modified">!         return JSValue::encode(thisObject-&gt;exec(exec, exec-&gt;lexicalGlobalObject(), string));</span>
<span class="line-modified">!     return JSValue::encode(thisObject-&gt;matchGlobal(exec, exec-&gt;lexicalGlobalObject(), string));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncCompile(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* thisRegExp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!thisRegExp))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
      RegExp* regExp;
<span class="line-modified">!     JSValue arg0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue arg1 = exec-&gt;argument(1);</span>
  
      if (auto* regExpObject = jsDynamicCast&lt;RegExpObject*&gt;(vm, arg0)) {
          if (!arg1.isUndefined())
<span class="line-modified">!             return throwVMTypeError(exec, scope, &quot;Cannot supply flags when constructing one RegExp from another.&quot;_s);</span>
          regExp = regExpObject-&gt;regExp();
      } else {
<span class="line-modified">!         String pattern = arg0.isUndefined() ? emptyString() : arg0.toWTFString(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!         auto flags = arg1.isUndefined() ? makeOptional(OptionSet&lt;Yarr::Flags&gt; { }) : Yarr::parseFlags(arg1.toWTFString(exec));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (!flags)
<span class="line-modified">!             return throwVMError(exec, scope, createSyntaxError(exec, &quot;Invalid flags supplied to RegExp constructor.&quot;_s));</span>
  
          regExp = RegExp::create(vm, pattern, flags.value());
      }
  
      if (!regExp-&gt;isValid())
<span class="line-modified">!         return throwVMError(exec, scope, regExp-&gt;errorToThrow(exec));</span>
  
      thisRegExp-&gt;setRegExp(vm, regExp);
      scope.release();
<span class="line-modified">!     thisRegExp-&gt;setLastIndex(exec, 0);</span>
      return JSValue::encode(thisRegExp);
  }
  
  typedef std::array&lt;char, 6 + 1&gt; FlagsString; // 6 different flags and a null character terminator.
  
<span class="line-modified">! static inline FlagsString flagsString(ExecState* exec, JSObject* regexp)</span>
  {
<span class="line-modified">!     FlagsString string;</span>
<span class="line-removed">-     string[0] = 0;</span>
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue globalValue = regexp-&gt;get(exec, vm.propertyNames-&gt;global);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue ignoreCaseValue = regexp-&gt;get(exec, vm.propertyNames-&gt;ignoreCase);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue multilineValue = regexp-&gt;get(exec, vm.propertyNames-&gt;multiline);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue dotAllValue = regexp-&gt;get(exec, vm.propertyNames-&gt;dotAll);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue unicodeValue = regexp-&gt;get(exec, vm.propertyNames-&gt;unicode);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue stickyValue = regexp-&gt;get(exec, vm.propertyNames-&gt;sticky);</span>
      RETURN_IF_EXCEPTION(scope, string);
  
      unsigned index = 0;
<span class="line-modified">!     if (globalValue.toBoolean(exec))</span>
          string[index++] = &#39;g&#39;;
<span class="line-modified">!     if (ignoreCaseValue.toBoolean(exec))</span>
          string[index++] = &#39;i&#39;;
<span class="line-modified">!     if (multilineValue.toBoolean(exec))</span>
          string[index++] = &#39;m&#39;;
<span class="line-modified">!     if (dotAllValue.toBoolean(exec))</span>
          string[index++] = &#39;s&#39;;
<span class="line-modified">!     if (unicodeValue.toBoolean(exec))</span>
          string[index++] = &#39;u&#39;;
<span class="line-modified">!     if (stickyValue.toBoolean(exec))</span>
          string[index++] = &#39;y&#39;;
      ASSERT(index &lt; string.size());
      string[index] = 0;
      return string;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncToString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!thisValue.isObject())
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
      JSObject* thisObject = asObject(thisValue);
  
<span class="line-modified">!     StringRecursionChecker checker(exec, thisObject);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
<span class="line-modified">!     JSValue sourceValue = thisObject-&gt;get(exec, vm.propertyNames-&gt;source);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String source = sourceValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue flagsValue = thisObject-&gt;get(exec, vm.propertyNames-&gt;flags);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String flags = flagsValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &#39;/&#39;, source, &#39;/&#39;, flags)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterGlobal(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.global getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;global()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterIgnoreCase(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.ignoreCase getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;ignoreCase()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterMultiline(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.multiline getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;multiline()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterDotAll(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.dotAll getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;dotAll()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterSticky(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.sticky getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;sticky()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterUnicode(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.unicode getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;unicode()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterFlags(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (UNLIKELY(!thisValue.isObject()))
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.flags getter can only be called on an object&quot;_s);</span>
  
<span class="line-modified">!     auto flags = flagsString(exec, asObject(thisValue));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      return JSValue::encode(jsString(vm, flags.data()));
  }
  
<span class="line-new-header">--- 84,265 ---</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;test, regExpPrototypeTestCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  }
  
  // ------------------------------ Functions ---------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncTestFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     JSString* string = callFrame-&gt;argument(0).toStringOrNull(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !string);
      if (!string)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(regexp-&gt;test(globalObject, string))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncExec(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Builtin RegExp exec can only be called on a RegExp object&quot;);</span>
<span class="line-modified">!     JSString* string = callFrame-&gt;argument(0).toStringOrNull(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !string);
      if (!string)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(globalObject, string)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncMatchFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(callFrame-&gt;thisValue());</span>
<span class="line-modified">!     JSString* string = jsCast&lt;JSString*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
      if (!thisObject-&gt;regExp()-&gt;global())
<span class="line-modified">!         return JSValue::encode(thisObject-&gt;exec(globalObject, string));</span>
<span class="line-modified">!     return JSValue::encode(thisObject-&gt;matchGlobal(globalObject, string));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncCompile(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* thisRegExp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!thisRegExp))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
      RegExp* regExp;
<span class="line-modified">!     JSValue arg0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue arg1 = callFrame-&gt;argument(1);</span>
  
      if (auto* regExpObject = jsDynamicCast&lt;RegExpObject*&gt;(vm, arg0)) {
          if (!arg1.isUndefined())
<span class="line-modified">!             return throwVMTypeError(globalObject, scope, &quot;Cannot supply flags when constructing one RegExp from another.&quot;_s);</span>
          regExp = regExpObject-&gt;regExp();
      } else {
<span class="line-modified">!         String pattern = arg0.isUndefined() ? emptyString() : arg0.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!         auto flags = arg1.isUndefined() ? makeOptional(OptionSet&lt;Yarr::Flags&gt; { }) : Yarr::parseFlags(arg1.toWTFString(globalObject));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (!flags)
<span class="line-modified">!             return throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Invalid flags supplied to RegExp constructor.&quot;_s));</span>
  
          regExp = RegExp::create(vm, pattern, flags.value());
      }
  
      if (!regExp-&gt;isValid())
<span class="line-modified">!         return throwVMError(globalObject, scope, regExp-&gt;errorToThrow(globalObject));</span>
  
      thisRegExp-&gt;setRegExp(vm, regExp);
      scope.release();
<span class="line-modified">!     thisRegExp-&gt;setLastIndex(globalObject, 0);</span>
      return JSValue::encode(thisRegExp);
  }
  
  typedef std::array&lt;char, 6 + 1&gt; FlagsString; // 6 different flags and a null character terminator.
  
<span class="line-modified">! static inline FlagsString flagsString(JSGlobalObject* globalObject, JSObject* regexp)</span>
  {
<span class="line-modified">!     FlagsString string{};</span>
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue globalValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;global);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue ignoreCaseValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;ignoreCase);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue multilineValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;multiline);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue dotAllValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;dotAll);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue unicodeValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;unicode);</span>
      RETURN_IF_EXCEPTION(scope, string);
<span class="line-modified">!     JSValue stickyValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;sticky);</span>
      RETURN_IF_EXCEPTION(scope, string);
  
      unsigned index = 0;
<span class="line-modified">!     if (globalValue.toBoolean(globalObject))</span>
          string[index++] = &#39;g&#39;;
<span class="line-modified">!     if (ignoreCaseValue.toBoolean(globalObject))</span>
          string[index++] = &#39;i&#39;;
<span class="line-modified">!     if (multilineValue.toBoolean(globalObject))</span>
          string[index++] = &#39;m&#39;;
<span class="line-modified">!     if (dotAllValue.toBoolean(globalObject))</span>
          string[index++] = &#39;s&#39;;
<span class="line-modified">!     if (unicodeValue.toBoolean(globalObject))</span>
          string[index++] = &#39;u&#39;;
<span class="line-modified">!     if (stickyValue.toBoolean(globalObject))</span>
          string[index++] = &#39;y&#39;;
      ASSERT(index &lt; string.size());
      string[index] = 0;
      return string;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!thisValue.isObject())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
      JSObject* thisObject = asObject(thisValue);
  
<span class="line-modified">!     StringRecursionChecker checker(globalObject, thisObject);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
<span class="line-modified">!     JSValue sourceValue = thisObject-&gt;get(globalObject, vm.propertyNames-&gt;source);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String source = sourceValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue flagsValue = thisObject-&gt;get(globalObject, vm.propertyNames-&gt;flags);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String flags = flagsValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(globalObject, &#39;/&#39;, source, &#39;/&#39;, flags)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterGlobal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.global getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;global()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterIgnoreCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.ignoreCase getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;ignoreCase()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterMultiline(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.multiline getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;multiline()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterDotAll(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.dotAll getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;dotAll()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterSticky(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.sticky getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;sticky()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterUnicode(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
              return JSValue::encode(jsUndefined());
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.unicode getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;unicode()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterFlags(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (UNLIKELY(!thisValue.isObject()))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.flags getter can only be called on an object&quot;_s);</span>
  
<span class="line-modified">!     auto flags = flagsString(globalObject, asObject(thisValue));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      return JSValue::encode(jsString(vm, flags.data()));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,13 ***</span>
      else
          builder.appendLiteral(&quot;u2029&quot;);
  }
  
  template &lt;typename CharacterType&gt;
<span class="line-modified">! static inline JSValue regExpProtoGetterSourceInternal(ExecState* exec, const String&amp; pattern, const CharacterType* characters, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      bool previousCharacterWasBackslash = false;
      bool inBrackets = false;
      bool shouldEscape = false;
  
      // 15.10.6.4 specifies that RegExp.prototype.toString must return &#39;/&#39; + source + &#39;/&#39;,
<span class="line-new-header">--- 370,13 ---</span>
      else
          builder.appendLiteral(&quot;u2029&quot;);
  }
  
  template &lt;typename CharacterType&gt;
<span class="line-modified">! static inline JSValue regExpProtoGetterSourceInternal(JSGlobalObject* globalObject, const String&amp; pattern, const CharacterType* characters, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      bool previousCharacterWasBackslash = false;
      bool inBrackets = false;
      bool shouldEscape = false;
  
      // 15.10.6.4 specifies that RegExp.prototype.toString must return &#39;/&#39; + source + &#39;/&#39;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,41 ***</span>
      }
  
      return jsString(vm, result.toString());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterSource(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
<span class="line-modified">!             return JSValue::encode(jsString(vm, &quot;(?:)&quot;_s));</span>
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;The RegExp.prototype.source getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      String pattern = regexp-&gt;regExp()-&gt;pattern();
      if (pattern.is8Bit())
<span class="line-modified">!         return JSValue::encode(regExpProtoGetterSourceInternal(exec, pattern, pattern.characters8(), pattern.length()));</span>
<span class="line-modified">!     return JSValue::encode(regExpProtoGetterSourceInternal(exec, pattern, pattern.characters16(), pattern.length()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncSearchFast(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      RegExp* regExp = jsCast&lt;RegExpObject*&gt;(thisValue)-&gt;regExp();
  
<span class="line-modified">!     JSString* string = exec-&gt;uncheckedArgument(0).toString(exec);</span>
<span class="line-modified">!     String s = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, s, 0);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(result ? jsNumber(result.start) : jsNumber(-1));
  }
  
<span class="line-new-header">--- 451,40 ---</span>
      }
  
      return jsString(vm, result.toString());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoGetterSource(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
      if (UNLIKELY(!regexp)) {
          if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
<span class="line-modified">!             return JSValue::encode(jsNontrivialString(vm, &quot;(?:)&quot;_s));</span>
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.source getter can only be called on a RegExp object&quot;_s);</span>
      }
  
      String pattern = regexp-&gt;regExp()-&gt;pattern();
      if (pattern.is8Bit())
<span class="line-modified">!         return JSValue::encode(regExpProtoGetterSourceInternal(globalObject, pattern, pattern.characters8(), pattern.length()));</span>
<span class="line-modified">!     return JSValue::encode(regExpProtoGetterSourceInternal(globalObject, pattern, pattern.characters16(), pattern.length()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncSearchFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      RegExp* regExp = jsCast&lt;RegExpObject*&gt;(thisValue)-&gt;regExp();
  
<span class="line-modified">!     JSString* string = callFrame-&gt;uncheckedArgument(0).toString(globalObject);</span>
<span class="line-modified">!     String s = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, s, 0);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(result ? jsNumber(result.start) : jsNumber(-1));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,23 ***</span>
          matchPosition = position;
      }
  }
  
  // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncSplitFast(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. [handled by JS builtin] Let rx be the this value.
      // 2. [handled by JS builtin] If Type(rx) is not Object, throw a TypeError exception.
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      RegExp* regexp = jsCast&lt;RegExpObject*&gt;(thisValue)-&gt;regExp();
  
      // 3. [handled by JS builtin] Let S be ? ToString(string).
<span class="line-modified">!     JSString* inputString = exec-&gt;argument(0).toString(exec);</span>
<span class="line-modified">!     String input = inputString-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      ASSERT(!input.isNull());
  
      // 4. [handled by JS builtin] Let C be ? SpeciesConstructor(rx, %RegExp%).
      // 5. [handled by JS builtin] Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
<span class="line-new-header">--- 574,23 ---</span>
          matchPosition = position;
      }
  }
  
  // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL regExpProtoFuncSplitFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. [handled by JS builtin] Let rx be the this value.
      // 2. [handled by JS builtin] If Type(rx) is not Object, throw a TypeError exception.
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      RegExp* regexp = jsCast&lt;RegExpObject*&gt;(thisValue)-&gt;regExp();
  
      // 3. [handled by JS builtin] Let S be ? ToString(string).
<span class="line-modified">!     JSString* inputString = callFrame-&gt;argument(0).toString(globalObject);</span>
<span class="line-modified">!     String input = inputString-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      ASSERT(!input.isNull());
  
      // 4. [handled by JS builtin] Let C be ? SpeciesConstructor(rx, %RegExp%).
      // 5. [handled by JS builtin] Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,17 ***</span>
      // 9. [handled by JS builtin] Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
      // 10. [handled by JS builtin] Let splitter be ? Construct(C, « rx, newFlags »).
  
      // 11. Let A be ArrayCreate(0).
      // 12. Let lengthA be 0.
<span class="line-modified">!     JSArray* result = constructEmptyArray(exec, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned resultLength = 0;
  
      // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).
<span class="line-modified">!     JSValue limitValue = exec-&gt;argument(1);</span>
<span class="line-modified">!     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 14. Let size be the number of elements in S.
      unsigned inputSize = input.length();
  
<span class="line-new-header">--- 600,17 ---</span>
      // 9. [handled by JS builtin] Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
      // 10. [handled by JS builtin] Let splitter be ? Construct(C, « rx, newFlags »).
  
      // 11. Let A be ArrayCreate(0).
      // 12. Let lengthA be 0.
<span class="line-modified">!     JSArray* result = constructEmptyArray(globalObject, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned resultLength = 0;
  
      // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).
<span class="line-modified">!     JSValue limitValue = callFrame-&gt;argument(1);</span>
<span class="line-modified">!     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 14. Let size be the number of elements in S.
      unsigned inputSize = input.length();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 628,11 ***</span>
          // a. Let z be ? RegExpExec(splitter, S).
          // b. If z is not null, return A.
          // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
          // d. Return A.
          if (!regexp-&gt;match(vm, input, 0)) {
<span class="line-modified">!             result-&gt;putDirectIndex(exec, 0, inputString);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
          return JSValue::encode(result);
      }
  
<span class="line-new-header">--- 626,11 ---</span>
          // a. Let z be ? RegExpExec(splitter, S).
          // b. If z is not null, return A.
          // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
          // d. Return A.
          if (!regexp-&gt;match(vm, input, 0)) {
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, 0, inputString);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
          return JSValue::encode(result);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,11 ***</span>
              if (resultLength &gt;= maxSizeForDirectPath)
                  return AbortSplit;
              return ContinueSplit;
          },
          [&amp;] (bool isDefined, unsigned start, unsigned length) -&gt; SplitControl {
<span class="line-modified">!             result-&gt;putDirectIndex(exec, resultLength++, isDefined ? jsSubstringOfResolved(vm, inputString, start, length) : jsUndefined());</span>
              RETURN_IF_EXCEPTION(scope, AbortSplit);
              if (resultLength &gt;= limit)
                  return AbortSplit;
              return ContinueSplit;
          });
<span class="line-new-header">--- 648,11 ---</span>
              if (resultLength &gt;= maxSizeForDirectPath)
                  return AbortSplit;
              return ContinueSplit;
          },
          [&amp;] (bool isDefined, unsigned start, unsigned length) -&gt; SplitControl {
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, resultLength++, isDefined ? jsSubstringOfResolved(vm, inputString, start, length) : jsUndefined());</span>
              RETURN_IF_EXCEPTION(scope, AbortSplit);
              if (resultLength &gt;= limit)
                  return AbortSplit;
              return ContinueSplit;
          });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 664,11 ***</span>
          return JSValue::encode(result);
      if (resultLength &lt; maxSizeForDirectPath) {
          // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
          // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
          scope.release();
<span class="line-modified">!         result-&gt;putDirectIndex(exec, resultLength, jsSubstringOfResolved(vm, inputString, position, inputSize - position));</span>
  
          // 22. Return A.
          return JSValue::encode(result);
      }
  
<span class="line-new-header">--- 662,11 ---</span>
          return JSValue::encode(result);
      if (resultLength &lt; maxSizeForDirectPath) {
          // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
          // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
          scope.release();
<span class="line-modified">!         result-&gt;putDirectIndex(globalObject, resultLength, jsSubstringOfResolved(vm, inputString, position, inputSize - position));</span>
  
          // 22. Return A.
          return JSValue::encode(result);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 689,11 ***</span>
                  return AbortSplit;
              return ContinueSplit;
          });
  
      if (resultLength + dryRunCount &gt; MAX_STORAGE_VECTOR_LENGTH) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
      // OK, we know that if we finish the split, we won&#39;t have to OOM.
      position = savedPosition;
<span class="line-new-header">--- 687,11 ---</span>
                  return AbortSplit;
              return ContinueSplit;
          });
  
      if (resultLength + dryRunCount &gt; MAX_STORAGE_VECTOR_LENGTH) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
      // OK, we know that if we finish the split, we won&#39;t have to OOM.
      position = savedPosition;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 703,11 ***</span>
          vm, regexp, input, inputSize, position, matchPosition, regExpIsSticky, regExpIsUnicode,
          [&amp;] () -&gt; SplitControl {
              return ContinueSplit;
          },
          [&amp;] (bool isDefined, unsigned start, unsigned length) -&gt; SplitControl {
<span class="line-modified">!             result-&gt;putDirectIndex(exec, resultLength++, isDefined ? jsSubstringOfResolved(vm, inputString, start, length) : jsUndefined());</span>
              RETURN_IF_EXCEPTION(scope, AbortSplit);
              if (resultLength &gt;= limit)
                  return AbortSplit;
              return ContinueSplit;
          });
<span class="line-new-header">--- 701,11 ---</span>
          vm, regexp, input, inputSize, position, matchPosition, regExpIsSticky, regExpIsUnicode,
          [&amp;] () -&gt; SplitControl {
              return ContinueSplit;
          },
          [&amp;] (bool isDefined, unsigned start, unsigned length) -&gt; SplitControl {
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, resultLength++, isDefined ? jsSubstringOfResolved(vm, inputString, start, length) : jsUndefined());</span>
              RETURN_IF_EXCEPTION(scope, AbortSplit);
              if (resultLength &gt;= limit)
                  return AbortSplit;
              return ContinueSplit;
          });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 717,11 ***</span>
          return JSValue::encode(result);
  
      // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
      // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
      scope.release();
<span class="line-modified">!     result-&gt;putDirectIndex(exec, resultLength, jsSubstringOfResolved(vm, inputString, position, inputSize - position));</span>
      // 22. Return A.
      return JSValue::encode(result);
  }
  
  } // namespace JSC
<span class="line-new-header">--- 715,11 ---</span>
          return JSValue::encode(result);
  
      // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
      // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
      scope.release();
<span class="line-modified">!     result-&gt;putDirectIndex(globalObject, resultLength, jsSubstringOfResolved(vm, inputString, position, inputSize - position));</span>
      // 22. Return A.
      return JSValue::encode(result);
  }
  
  } // namespace JSC
</pre>
<center><a href="RegExpObjectInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpPrototype.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/audio/PlatformMediaSessionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PlatformMediaSessionManager.h&quot;
 28 
 29 #include &quot;AudioSession.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Logging.h&quot;
 32 #include &quot;PlatformMediaSession.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
 37 
 38 #if !PLATFORM(COCOA)
 39 static PlatformMediaSessionManager* platformMediaSessionManager = nullptr;
 40 
 41 PlatformMediaSessionManager&amp; PlatformMediaSessionManager::sharedManager()
 42 {
 43     if (!platformMediaSessionManager)
 44         platformMediaSessionManager = new PlatformMediaSessionManager;
 45     return *platformMediaSessionManager;
 46 }
 47 
 48 PlatformMediaSessionManager* PlatformMediaSessionManager::sharedManagerIfExists()
 49 {
 50     return platformMediaSessionManager;
 51 }
 52 #endif // !PLATFORM(COCOA)
 53 
 54 void PlatformMediaSessionManager::updateNowPlayingInfoIfNecessary()
 55 {
 56     if (auto existingManager = PlatformMediaSessionManager::sharedManagerIfExists())
 57         existingManager-&gt;scheduleUpdateNowPlayingInfo();
 58 }
 59 
 60 PlatformMediaSessionManager::PlatformMediaSessionManager()
 61     : m_systemSleepListener(PAL::SystemSleepListener::create(*this))
 62 #if !RELEASE_LOG_DISABLED
 63     , m_logger(AggregateLogger::create(this))
 64 #endif
 65 {
 66     resetRestrictions();
 67 }
 68 
 69 void PlatformMediaSessionManager::resetRestrictions()
 70 {
 71     m_restrictions[PlatformMediaSession::Video] = NoRestrictions;
 72     m_restrictions[PlatformMediaSession::Audio] = NoRestrictions;
 73     m_restrictions[PlatformMediaSession::VideoAudio] = NoRestrictions;
 74     m_restrictions[PlatformMediaSession::WebAudio] = NoRestrictions;
 75     m_restrictions[PlatformMediaSession::MediaStreamCapturingAudio] = NoRestrictions;
 76 }
 77 
 78 bool PlatformMediaSessionManager::has(PlatformMediaSession::MediaType type) const
 79 {
 80     ASSERT(type &gt;= PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
 81 
 82     return anyOfSessions([type] (auto&amp; session) {
 83         return session.mediaType() == type;
 84     });
 85 }
 86 
 87 bool PlatformMediaSessionManager::activeAudioSessionRequired() const
 88 {
 89     return anyOfSessions([] (auto&amp; session) {
 90         return session.activeAudioSessionRequired();
 91     });
 92 }
 93 
 94 bool PlatformMediaSessionManager::canProduceAudio() const
 95 {
 96     return anyOfSessions([] (auto&amp; session) {
 97         return session.canProduceAudio();
 98     });
 99 }
100 
101 int PlatformMediaSessionManager::count(PlatformMediaSession::MediaType type) const
102 {
103     ASSERT(type &gt;= PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
104 
105     int count = 0;
106     for (const auto&amp; session : m_sessions) {
107         if (session-&gt;mediaType() == type)
108             ++count;
109     }
110 
111     return count;
112 }
113 
114 void PlatformMediaSessionManager::beginInterruption(PlatformMediaSession::InterruptionType type)
115 {
116     ALWAYS_LOG(LOGIDENTIFIER);
117 
118     m_interrupted = true;
119     forEachSession([type] (auto&amp; session) {
120         session.beginInterruption(type);
121     });
122     updateSessionState();
123 }
124 
125 void PlatformMediaSessionManager::endInterruption(PlatformMediaSession::EndInterruptionFlags flags)
126 {
127     ALWAYS_LOG(LOGIDENTIFIER);
128 
129     m_interrupted = false;
130     forEachSession([flags] (auto&amp; session) {
131         session.endInterruption(flags);
132     });
133 }
134 
135 void PlatformMediaSessionManager::addSession(PlatformMediaSession&amp; session)
136 {
137     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
138     m_sessions.append(makeWeakPtr(session));
139     if (m_interrupted)
140         session.setState(PlatformMediaSession::Interrupted);
141 
142     if (!m_remoteCommandListener)
143         m_remoteCommandListener = RemoteCommandListener::create(*this);
144 
145     if (!m_audioHardwareListener)
146         m_audioHardwareListener = AudioHardwareListener::create(*this);
147 
148 #if !RELEASE_LOG_DISABLED
149     m_logger-&gt;addLogger(session.logger());
150 #endif
151 
152     updateSessionState();
153 }
154 
155 void PlatformMediaSessionManager::removeSession(PlatformMediaSession&amp; session)
156 {
157     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
158 
159     size_t index = m_sessions.find(&amp;session);
160     if (index == notFound)
161         return;
162 
163     m_sessions.remove(index);
164 
165     if (m_sessions.isEmpty() || std::all_of(m_sessions.begin(), m_sessions.end(), std::logical_not&lt;void&gt;())) {
166         m_remoteCommandListener = nullptr;
167         m_audioHardwareListener = nullptr;
168 #if USE(AUDIO_SESSION)
169         maybeDeactivateAudioSession();
170 #endif
171     }
172 
173 #if !RELEASE_LOG_DISABLED
174     m_logger-&gt;removeLogger(session.logger());
175 #endif
176 
177     updateSessionState();
178 }
179 
180 void PlatformMediaSessionManager::addRestriction(PlatformMediaSession::MediaType type, SessionRestrictions restriction)
181 {
182     ASSERT(type &gt; PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
183     m_restrictions[type] |= restriction;
184 }
185 
186 void PlatformMediaSessionManager::removeRestriction(PlatformMediaSession::MediaType type, SessionRestrictions restriction)
187 {
188     ASSERT(type &gt; PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
189     m_restrictions[type] &amp;= ~restriction;
190 }
191 
192 PlatformMediaSessionManager::SessionRestrictions PlatformMediaSessionManager::restrictions(PlatformMediaSession::MediaType type)
193 {
194     ASSERT(type &gt; PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
195     return m_restrictions[type];
196 }
197 
198 bool PlatformMediaSessionManager::sessionWillBeginPlayback(PlatformMediaSession&amp; session)
199 {
200     setCurrentSession(session);
201 
202     PlatformMediaSession::MediaType sessionType = session.mediaType();
203     SessionRestrictions restrictions = m_restrictions[sessionType];
204     if (session.state() == PlatformMediaSession::Interrupted &amp;&amp; restrictions &amp; InterruptedPlaybackNotPermitted) {
205         ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier(), &quot; returning false because session.state() is Interrupted, and InterruptedPlaybackNotPermitted&quot;);
206         return false;
207     }
208 
209 #if USE(AUDIO_SESSION)
210     if (activeAudioSessionRequired()) {
211         if (!AudioSession::sharedSession().tryToSetActive(true)) {
212             ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier(), &quot; returning false failed to set active AudioSession&quot;);
213             return false;
214         }
215 
216         ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier(), &quot; sucessfully activated AudioSession&quot;);
217         m_becameActive = true;
218     }
219 #endif
220 
221     if (m_interrupted)
222         endInterruption(PlatformMediaSession::NoFlags);
223 
224     if (restrictions &amp; ConcurrentPlaybackNotPermitted) {
225         forEachMatchingSession([&amp;session, sessionType](auto&amp; oneSession) {
226             return &amp;oneSession != &amp;session
227                 &amp;&amp; oneSession.mediaType() == sessionType
228                 &amp;&amp; oneSession.state() == PlatformMediaSession::Playing
229                 &amp;&amp; !oneSession.canPlayConcurrently(session);
230         }, [](auto&amp; oneSession) {
231             oneSession.pauseSession();
232         });
233     }
234     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier(), &quot; returning true&quot;);
235     return true;
236 }
237 
238 void PlatformMediaSessionManager::sessionWillEndPlayback(PlatformMediaSession&amp; session, DelayCallingUpdateNowPlaying)
239 {
240     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
241 
242     if (m_sessions.size() &lt; 2)
243         return;
244 
245     size_t pausingSessionIndex = notFound;
246     size_t lastPlayingSessionIndex = notFound;
247     for (size_t i = 0, size = m_sessions.size(); i &lt; size; ++i) {
248         const auto&amp; oneSession = *m_sessions[i];
249         if (&amp;oneSession == &amp;session)
250             pausingSessionIndex = i;
251         else if (oneSession.state() == PlatformMediaSession::Playing)
252             lastPlayingSessionIndex = i;
253         else
254             break;
255     }
256 
257     if (lastPlayingSessionIndex == notFound || pausingSessionIndex == notFound)
258         return;
259 
260     if (pausingSessionIndex &gt; lastPlayingSessionIndex)
261         return;
262 
263     m_sessions.remove(pausingSessionIndex);
264     m_sessions.append(makeWeakPtr(session));
265 
266     ALWAYS_LOG(LOGIDENTIFIER, &quot;session moved from index &quot;, pausingSessionIndex, &quot; to &quot;, lastPlayingSessionIndex);
267 }
268 
269 void PlatformMediaSessionManager::sessionStateChanged(PlatformMediaSession&amp;)
270 {
271     updateSessionState();
272 }
273 
274 void PlatformMediaSessionManager::setCurrentSession(PlatformMediaSession&amp; session)
275 {
276     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
277 
278     if (m_sessions.size() &lt; 2)
279         return;
280 
281     size_t index = m_sessions.find(&amp;session);
282     ASSERT(index != notFound);
283     if (!index || index == notFound)
284         return;
285 
286     m_sessions.remove(index);
287     m_sessions.insert(0, makeWeakPtr(session));
288     if (m_remoteCommandListener)
289         m_remoteCommandListener-&gt;updateSupportedCommands();
290 
291     ALWAYS_LOG(LOGIDENTIFIER, &quot;session moved from index &quot;, index, &quot; to 0&quot;);
292 }
293 
294 PlatformMediaSession* PlatformMediaSessionManager::currentSession() const
295 {
296     if (!m_sessions.size())
297         return nullptr;
298 
299     return m_sessions[0].get();
300 }
301 
302 void PlatformMediaSessionManager::applicationWillBecomeInactive()
303 {
304     ALWAYS_LOG(LOGIDENTIFIER);
305 
306     forEachMatchingSession([&amp;](auto&amp; session) {
307         return m_restrictions[session.mediaType()] &amp; InactiveProcessPlaybackRestricted;
308     }, [](auto&amp; session) {
309         session.beginInterruption(PlatformMediaSession::ProcessInactive);
310     });
311 }
312 
313 void PlatformMediaSessionManager::applicationDidBecomeActive()
314 {
315     ALWAYS_LOG(LOGIDENTIFIER);
316 
317     forEachMatchingSession([&amp;](auto&amp; session) {
318         return m_restrictions[session.mediaType()] &amp; InactiveProcessPlaybackRestricted;
319     }, [](auto&amp; session) {
320         session.endInterruption(PlatformMediaSession::MayResumePlaying);
321     });
322 }
323 
324 void PlatformMediaSessionManager::applicationDidEnterBackground(bool suspendedUnderLock)
325 {
326     ALWAYS_LOG(LOGIDENTIFIER, &quot;suspendedUnderLock: &quot;, suspendedUnderLock);
327 
328     if (m_isApplicationInBackground)
329         return;
330 
331     m_isApplicationInBackground = true;
332 
333     forEachSession([&amp;] (auto&amp; session) {
334         if (suspendedUnderLock &amp;&amp; m_restrictions[session.mediaType()] &amp; SuspendedUnderLockPlaybackRestricted)
335             session.beginInterruption(PlatformMediaSession::SuspendedUnderLock);
336         else if (m_restrictions[session.mediaType()] &amp; BackgroundProcessPlaybackRestricted)
337             session.beginInterruption(PlatformMediaSession::EnteringBackground);
338     });
339 }
340 
341 void PlatformMediaSessionManager::applicationWillEnterForeground(bool suspendedUnderLock)
342 {
343     ALWAYS_LOG(LOGIDENTIFIER, &quot;suspendedUnderLock: &quot;, suspendedUnderLock);
344 
345     if (!m_isApplicationInBackground)
346         return;
347 
348     m_isApplicationInBackground = false;
349 
350     forEachMatchingSession([&amp;](auto&amp; session) {
351         return (suspendedUnderLock &amp;&amp; m_restrictions[session.mediaType()] &amp; SuspendedUnderLockPlaybackRestricted) || m_restrictions[session.mediaType()] &amp; BackgroundProcessPlaybackRestricted;
352     }, [](auto&amp; session) {
353         session.endInterruption(PlatformMediaSession::MayResumePlaying);
354     });
355 }
356 
357 void PlatformMediaSessionManager::processWillSuspend()
358 {
359     if (m_processIsSuspended)
360         return;
361     m_processIsSuspended = true;
362 
363     ALWAYS_LOG(LOGIDENTIFIER);
364 
365     forEachSession([&amp;] (auto&amp; session) {
366         session.client().processIsSuspendedChanged();
367     });
368 
369 #if USE(AUDIO_SESSION)
370     maybeDeactivateAudioSession();
371 #endif
372 }
373 
374 void PlatformMediaSessionManager::processDidResume()
375 {
376     if (!m_processIsSuspended)
377         return;
378     m_processIsSuspended = false;
379 
380     forEachSession([&amp;] (auto&amp; session) {
381         session.client().processIsSuspendedChanged();
382     });
383 
384 #if USE(AUDIO_SESSION)
385     if (!m_becameActive &amp;&amp; activeAudioSessionRequired()) {
386         m_becameActive = AudioSession::sharedSession().tryToSetActive(true);
387         ALWAYS_LOG(LOGIDENTIFIER, &quot;tried to set active AudioSession, &quot;, m_becameActive ? &quot;succeeded&quot; : &quot;failed&quot;);
388     }
389 #endif
390 }
391 
392 void PlatformMediaSessionManager::setIsPlayingToAutomotiveHeadUnit(bool isPlayingToAutomotiveHeadUnit)
393 {
394     if (isPlayingToAutomotiveHeadUnit == m_isPlayingToAutomotiveHeadUnit)
395         return;
396 
397     ALWAYS_LOG(LOGIDENTIFIER, isPlayingToAutomotiveHeadUnit);
398     m_isPlayingToAutomotiveHeadUnit = isPlayingToAutomotiveHeadUnit;
399 }
400 
401 void PlatformMediaSessionManager::sessionIsPlayingToWirelessPlaybackTargetChanged(PlatformMediaSession&amp; session)
402 {
403     if (!m_isApplicationInBackground || !(m_restrictions[session.mediaType()] &amp; BackgroundProcessPlaybackRestricted))
404         return;
405 
406     if (session.state() != PlatformMediaSession::Interrupted)
407         session.beginInterruption(PlatformMediaSession::EnteringBackground);
408 }
409 
410 void PlatformMediaSessionManager::sessionCanProduceAudioChanged()
411 {
412     updateSessionState();
413 }
414 
415 void PlatformMediaSessionManager::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
416 {
417     PlatformMediaSession* activeSession = currentSession();
418     if (!activeSession || !activeSession-&gt;canReceiveRemoteControlCommands())
419         return;
420     activeSession-&gt;didReceiveRemoteControlCommand(command, argument);
421 }
422 
423 bool PlatformMediaSessionManager::supportsSeeking() const
424 {
425     PlatformMediaSession* activeSession = currentSession();
426     if (!activeSession)
427         return false;
428     return activeSession-&gt;supportsSeeking();
429 }
430 
431 void PlatformMediaSessionManager::systemWillSleep()
432 {
433     if (m_interrupted)
434         return;
435 
436     forEachSession([] (auto&amp; session) {
437         session.beginInterruption(PlatformMediaSession::SystemSleep);
438     });
439 }
440 
441 void PlatformMediaSessionManager::systemDidWake()
442 {
443     if (m_interrupted)
444         return;
445 
446     forEachSession([] (auto&amp; session) {
447         session.endInterruption(PlatformMediaSession::MayResumePlaying);
448     });
449 }
450 
451 void PlatformMediaSessionManager::audioOutputDeviceChanged()
452 {
453     updateSessionState();
454 }
455 
456 void PlatformMediaSessionManager::stopAllMediaPlaybackForDocument(const Document&amp; document)
457 {
458     forEachDocumentSession(document, [](auto&amp; session) {
459         session.pauseSession();
460     });
461 }
462 
463 void PlatformMediaSessionManager::stopAllMediaPlaybackForProcess()
464 {
465     forEachSession([] (auto&amp; session) {
466         session.stopSession();
467     });
468 }
469 
470 void PlatformMediaSessionManager::suspendAllMediaPlaybackForDocument(const Document&amp; document)
471 {
472     forEachDocumentSession(document, [](auto&amp; session) {
473         session.beginInterruption(PlatformMediaSession::PlaybackSuspended);
474     });
475 }
476 
477 void PlatformMediaSessionManager::resumeAllMediaPlaybackForDocument(const Document&amp; document)
478 {
479     forEachDocumentSession(document, [](auto&amp; session) {
480         session.endInterruption(PlatformMediaSession::MayResumePlaying);
481     });
482 }
483 
484 void PlatformMediaSessionManager::suspendAllMediaBufferingForDocument(const Document&amp; document)
485 {
486     forEachDocumentSession(document, [](auto&amp; session) {
487         session.suspendBuffering();
488     });
489 }
490 
491 void PlatformMediaSessionManager::resumeAllMediaBufferingForDocument(const Document&amp; document)
492 {
493     forEachDocumentSession(document, [](auto&amp; session) {
494         session.resumeBuffering();
495     });
496 }
497 
498 Vector&lt;WeakPtr&lt;PlatformMediaSession&gt;&gt; PlatformMediaSessionManager::sessionsMatching(const WTF::Function&lt;bool(const PlatformMediaSession&amp;)&gt;&amp; filter) const
499 {
500     Vector&lt;WeakPtr&lt;PlatformMediaSession&gt;&gt; matchingSessions;
501     for (auto&amp; session : m_sessions) {
502         if (filter(*session))
503             matchingSessions.append(session);
504     }
505     return matchingSessions;
506 }
507 
508 void PlatformMediaSessionManager::forEachMatchingSession(const Function&lt;bool(const PlatformMediaSession&amp;)&gt;&amp; predicate, const Function&lt;void(PlatformMediaSession&amp;)&gt;&amp; callback)
509 {
510     for (auto&amp; session : sessionsMatching(predicate)) {
511         ASSERT(session);
512         if (session)
513             callback(*session);
514     }
515 }
516 
517 void PlatformMediaSessionManager::forEachDocumentSession(const Document&amp; document, const Function&lt;void(PlatformMediaSession&amp;)&gt;&amp; callback)
518 {
519     forEachMatchingSession([&amp;document](auto&amp; session) {
520         return session.client().hostingDocument() == &amp;document;
521     }, [&amp;callback](auto&amp; session) {
522         callback(session);
523     });
524 }
525 
526 void PlatformMediaSessionManager::forEachSession(const Function&lt;void(PlatformMediaSession&amp;)&gt;&amp; callback)
527 {
528     auto sessions = m_sessions;
529     for (auto&amp; session : sessions) {
530         ASSERT(session);
531         if (session)
532             callback(*session);
533     }
534 }
535 
536 bool PlatformMediaSessionManager::anyOfSessions(const Function&lt;bool(const PlatformMediaSession&amp;)&gt;&amp; predicate) const
537 {
538     return WTF::anyOf(m_sessions, [&amp;predicate](const auto&amp; session) {
539         return predicate(*session);
540     });
541 }
542 
543 #if USE(AUDIO_SESSION)
544 void PlatformMediaSessionManager::maybeDeactivateAudioSession()
545 {
546     if (!m_becameActive || !shouldDeactivateAudioSession())
547         return;
548 
549     ALWAYS_LOG(LOGIDENTIFIER, &quot;tried to set inactive AudioSession&quot;);
550     AudioSession::sharedSession().tryToSetActive(false);
551     m_becameActive = false;
552 }
553 #endif
554 
555 static bool&amp; deactivateAudioSession()
556 {
557     static bool deactivate;
558     return deactivate;
559 }
560 
561 bool PlatformMediaSessionManager::shouldDeactivateAudioSession()
562 {
563     return deactivateAudioSession();
564 }
565 
566 void PlatformMediaSessionManager::setShouldDeactivateAudioSession(bool deactivate)
567 {
568     deactivateAudioSession() = deactivate;
569 }
570 
571 #else // ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
572 
573 void PlatformMediaSessionManager::updateNowPlayingInfoIfNecessary()
574 {
575 
576 }
577 
578 #endif // ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
579 
580 #if !RELEASE_LOG_DISABLED
581 WTFLogChannel&amp; PlatformMediaSessionManager::logChannel() const
582 {
583     return LogMedia;
584 }
585 #endif
586 
587 } // namespace WebCore
    </pre>
  </body>
</html>
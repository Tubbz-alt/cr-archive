<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentStorageAccess.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Peter Kelly (pmk@post.com)
   5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   6  *           (C) 2007 David Smith (catfish.man@gmail.com)
<span class="line-modified">   7  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.</span>
   8  *           (C) 2007 Eric Seidel (eric@webkit.org)
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Element.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;Attr.h&quot;
  31 #include &quot;AttributeChangeInvalidation.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CSSParser.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ClassChangeInvalidation.h&quot;
  37 #include &quot;ComposedTreeAncestorIterator.h&quot;

  38 #include &quot;ContainerNodeAlgorithms.h&quot;
  39 #include &quot;CustomElementReactionQueue.h&quot;
  40 #include &quot;CustomElementRegistry.h&quot;
  41 #include &quot;DOMRect.h&quot;
  42 #include &quot;DOMRectList.h&quot;
  43 #include &quot;DOMTokenList.h&quot;
  44 #include &quot;DOMWindow.h&quot;
  45 #include &quot;DocumentSharedObjectPool.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;Editing.h&quot;
  48 #include &quot;ElementIterator.h&quot;
  49 #include &quot;ElementRareData.h&quot;
  50 #include &quot;EventDispatcher.h&quot;
  51 #include &quot;EventHandler.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;FocusController.h&quot;
  54 #include &quot;FocusEvent.h&quot;
  55 #include &quot;Frame.h&quot;
  56 #include &quot;FrameSelection.h&quot;
  57 #include &quot;FrameView.h&quot;
  58 #include &quot;FullscreenManager.h&quot;

  59 #include &quot;HTMLBodyElement.h&quot;
  60 #include &quot;HTMLCanvasElement.h&quot;
  61 #include &quot;HTMLCollection.h&quot;
  62 #include &quot;HTMLDocument.h&quot;
  63 #include &quot;HTMLHtmlElement.h&quot;
  64 #include &quot;HTMLLabelElement.h&quot;
  65 #include &quot;HTMLNameCollection.h&quot;
  66 #include &quot;HTMLObjectElement.h&quot;
  67 #include &quot;HTMLOptGroupElement.h&quot;
  68 #include &quot;HTMLOptionElement.h&quot;
  69 #include &quot;HTMLParserIdioms.h&quot;
  70 #include &quot;HTMLSelectElement.h&quot;
  71 #include &quot;HTMLTemplateElement.h&quot;
  72 #include &quot;IdChangeInvalidation.h&quot;
  73 #include &quot;IdTargetObserverRegistry.h&quot;
  74 #include &quot;InspectorInstrumentation.h&quot;
  75 #include &quot;JSLazyEventListener.h&quot;
  76 #include &quot;KeyboardEvent.h&quot;

  77 #include &quot;KeyframeEffect.h&quot;
  78 #include &quot;MutationObserverInterestGroup.h&quot;
  79 #include &quot;MutationRecord.h&quot;
  80 #include &quot;NodeRenderStyle.h&quot;

  81 #include &quot;PlatformWheelEvent.h&quot;
  82 #include &quot;PointerCaptureController.h&quot;
  83 #include &quot;PointerEvent.h&quot;
  84 #include &quot;PointerLockController.h&quot;
<span class="line-modified">  85 #include &quot;RenderFragmentContainer.h&quot;</span>
  86 #include &quot;RenderLayer.h&quot;
  87 #include &quot;RenderLayerBacking.h&quot;
  88 #include &quot;RenderLayerCompositor.h&quot;
  89 #include &quot;RenderListBox.h&quot;
  90 #include &quot;RenderTheme.h&quot;
  91 #include &quot;RenderTreeUpdater.h&quot;
  92 #include &quot;RenderView.h&quot;
  93 #include &quot;RenderWidget.h&quot;
  94 #include &quot;RuntimeEnabledFeatures.h&quot;
  95 #include &quot;SVGDocumentExtensions.h&quot;
  96 #include &quot;SVGElement.h&quot;
  97 #include &quot;SVGNames.h&quot;
  98 #include &quot;SVGSVGElement.h&quot;
  99 #include &quot;ScriptDisallowedScope.h&quot;
 100 #include &quot;ScrollIntoViewOptions.h&quot;
 101 #include &quot;ScrollLatchingState.h&quot;
 102 #include &quot;SelectorQuery.h&quot;
 103 #include &quot;Settings.h&quot;
 104 #include &quot;SimulatedClick.h&quot;
 105 #include &quot;SlotAssignment.h&quot;

 106 #include &quot;StyleProperties.h&quot;
 107 #include &quot;StyleResolver.h&quot;
 108 #include &quot;StyleScope.h&quot;
 109 #include &quot;StyleTreeResolver.h&quot;
 110 #include &quot;TextIterator.h&quot;
 111 #include &quot;TouchAction.h&quot;
 112 #include &quot;VoidCallback.h&quot;
 113 #include &quot;WebAnimation.h&quot;
 114 #include &quot;WheelEvent.h&quot;
 115 #include &quot;XLinkNames.h&quot;
 116 #include &quot;XMLNSNames.h&quot;
 117 #include &quot;XMLNames.h&quot;
 118 #include &quot;markup.h&quot;
 119 #include &lt;wtf/IsoMallocInlines.h&gt;
 120 #include &lt;wtf/NeverDestroyed.h&gt;
 121 #include &lt;wtf/text/CString.h&gt;
 122 
 123 namespace WebCore {
 124 
 125 WTF_MAKE_ISO_ALLOCATED_IMPL(Element);
</pre>
<hr />
<pre>
 250     return elementRareData()-&gt;tabIndex();
 251 }
 252 
 253 int Element::defaultTabIndex() const
 254 {
 255     return -1;
 256 }
 257 
 258 bool Element::supportsFocus() const
 259 {
 260     return !!tabIndexSetExplicitly();
 261 }
 262 
 263 RefPtr&lt;Element&gt; Element::focusDelegate()
 264 {
 265     return this;
 266 }
 267 
 268 int Element::tabIndexForBindings() const
 269 {
<span class="line-modified"> 270     auto defaultIndex = defaultTabIndex();</span>
<span class="line-removed"> 271     ASSERT(!defaultIndex || defaultIndex == -1);</span>
<span class="line-removed"> 272     // FIXME: supportsFocus() check shouldn&#39;t be here.</span>
<span class="line-removed"> 273     if (!defaultIndex || supportsFocus())</span>
<span class="line-removed"> 274         return tabIndexSetExplicitly().valueOr(0);</span>
<span class="line-removed"> 275     return defaultIndex;</span>
 276 }
 277 
 278 void Element::setTabIndexForBindings(int value)
 279 {
 280     setIntegralAttribute(tabindexAttr, value);
 281 }
 282 
 283 bool Element::isKeyboardFocusable(KeyboardEvent*) const
 284 {
<span class="line-modified"> 285     return isFocusable() &amp;&amp; !shouldBeIgnoredInSequentialFocusNavigation() &amp;&amp; tabIndexSetExplicitly().valueOr(0) &gt;= 0;</span>






 286 }
 287 
 288 bool Element::isMouseFocusable() const
 289 {
 290     return isFocusable();
 291 }
 292 
 293 bool Element::shouldUseInputMethod()
 294 {
 295     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 296 }
 297 
 298 static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
 299 {
 300     return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
 301 }
 302 
<span class="line-modified"> 303 #if ENABLE(POINTER_EVENTS) &amp;&amp; !ENABLE(TOUCH_EVENTS)</span>

 304 static bool isCompatibilityMouseEvent(const MouseEvent&amp; mouseEvent)
 305 {
 306     // https://www.w3.org/TR/pointerevents/#compatibility-mapping-with-mouse-events
 307     const auto&amp; type = mouseEvent.type();
 308     return type != eventNames().clickEvent &amp;&amp; type != eventNames().mouseoverEvent &amp;&amp; type != eventNames().mouseoutEvent &amp;&amp; type != eventNames().mouseenterEvent &amp;&amp; type != eventNames().mouseleaveEvent;
 309 }

 310 #endif
 311 
<span class="line-modified"> 312 bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomString&amp; eventType, int detail, Element* relatedTarget)</span>

 313 {
<span class="line-removed"> 314     if (isDisabledFormControl())</span>
<span class="line-removed"> 315         return false;</span>
<span class="line-removed"> 316 </span>
<span class="line-removed"> 317     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))</span>
<span class="line-removed"> 318         return false;</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);</span>
<span class="line-removed"> 321 </span>
<span class="line-removed"> 322     if (mouseEvent-&gt;type().isEmpty())</span>
<span class="line-removed"> 323         return true; // Shouldn&#39;t happen.</span>
<span class="line-removed"> 324 </span>
<span class="line-removed"> 325     bool didNotSwallowEvent = true;</span>
<span class="line-removed"> 326 </span>
 327 #if ENABLE(POINTER_EVENTS)
 328     if (RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled()) {
<span class="line-modified"> 329         if (auto* page = document().page()) {</span>
 330             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();
 331 #if ENABLE(TOUCH_EVENTS)
<span class="line-modified"> 332             if (mouseEvent-&gt;type() != eventNames().clickEvent &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(platformEvent.pointerId()))</span>
<span class="line-modified"> 333                 return false;</span>
 334 #else





 335             if (auto pointerEvent = pointerCaptureController.pointerEventForMouseEvent(mouseEvent)) {
<span class="line-modified"> 336                 pointerCaptureController.dispatchEvent(*pointerEvent, this);</span>
 337                 if (isCompatibilityMouseEvent(mouseEvent) &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(pointerEvent-&gt;pointerId()))
<span class="line-modified"> 338                     return false;</span>
 339                 if (pointerEvent-&gt;defaultPrevented() || pointerEvent-&gt;defaultHandled()) {
 340                     didNotSwallowEvent = false;
 341                     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent)
<span class="line-modified"> 342                         return false;</span>
 343                 }
 344             }
<span class="line-removed"> 345 #endif</span>
 346         }
 347     }





 348 #endif
 349 





















 350     ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
 351     dispatchEvent(mouseEvent);
 352     if (mouseEvent-&gt;defaultPrevented() || mouseEvent-&gt;defaultHandled())
 353         didNotSwallowEvent = false;
 354 
 355     if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
 356         // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
 357         // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
 358         // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
 359         // FIXME: Is it okay that mouseEvent may have been mutated by scripts via initMouseEvent in dispatchEvent above?
 360         Ref&lt;MouseEvent&gt; doubleClickEvent = MouseEvent::create(eventNames().dblclickEvent,
 361             mouseEvent-&gt;bubbles() ? Event::CanBubble::Yes : Event::CanBubble::No,
 362             mouseEvent-&gt;cancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No,
 363             Event::IsComposed::Yes,
 364             mouseEvent-&gt;view(), mouseEvent-&gt;detail(),
 365             mouseEvent-&gt;screenX(), mouseEvent-&gt;screenY(), mouseEvent-&gt;clientX(), mouseEvent-&gt;clientY(),
 366             mouseEvent-&gt;modifierKeys(), mouseEvent-&gt;button(), mouseEvent-&gt;buttons(), mouseEvent-&gt;syntheticClickType(), relatedTarget);
 367 
 368         if (mouseEvent-&gt;defaultHandled())
 369             doubleClickEvent-&gt;setDefaultHandled();
</pre>
<hr />
<pre>
 665             renderer()-&gt;repaint();
 666 
 667         // FIXME: Come up with a less ridiculous way of doing this.
 668 #ifdef HAVE_FUNC_USLEEP
 669         // Now pause for a small amount of time (1/10th of a second from before we repainted in the pressed state)
 670         Seconds remainingTime = 100_ms - (MonotonicTime::now() - startTime);
 671         if (remainingTime &gt; 0_s)
 672             usleep(static_cast&lt;useconds_t&gt;(remainingTime.microseconds()));
 673 #endif
 674     }
 675 }
 676 
 677 void Element::setFocus(bool flag)
 678 {
 679     if (flag == focused())
 680         return;
 681 
 682     document().userActionElements().setFocused(*this, flag);
 683     invalidateStyleForSubtree();
 684 






 685     for (Element* element = this; element; element = element-&gt;parentElementInComposedTree())
 686         element-&gt;setHasFocusWithin(flag);
 687 }
 688 
 689 void Element::setHovered(bool flag)
 690 {
 691     if (flag == hovered())
 692         return;
 693 
 694     document().userActionElements().setHovered(*this, flag);
 695 
 696     auto* style = renderOrDisplayContentsStyle();
 697     if (style &amp;&amp; (style-&gt;affectedByHover() || childrenAffectedByHover()))
 698         invalidateStyleForSubtree();
 699 
 700     if (!renderer()) {
 701         // When setting hover to false, the style needs to be recalc&#39;d even when
 702         // there&#39;s no renderer (imagine setting display:none in the :hover class,
 703         // if a nil renderer would prevent this element from recalculating its
 704         // style, it would never go back to its normal style and remain
</pre>
<hr />
<pre>
 894 
 895 void Element::scrollTo(const ScrollToOptions&amp; options, ScrollClamping clamping)
 896 {
 897     if (!document().settings().CSSOMViewScrollingAPIEnabled()) {
 898         // If the element is the root element and document is in quirks mode, terminate these steps.
 899         // Note that WebKit always uses quirks mode document scrolling behavior. See Document::scrollingElement().
 900         if (this == document().documentElement())
 901             return;
 902     }
 903 
 904     document().updateLayoutIgnorePendingStylesheets();
 905 
 906     if (document().scrollingElement() == this) {
 907         // If the element is the scrolling element and is not potentially scrollable,
 908         // invoke scroll() on window with options as the only argument, and terminate these steps.
 909         // FIXME: Scrolling an independently scrollable body is broken: webkit.org/b/161612.
 910         auto window = makeRefPtr(document().domWindow());
 911         if (!window)
 912             return;
 913 
<span class="line-modified"> 914         window-&gt;scrollTo(options);</span>
 915         return;
 916     }
 917 
 918     // If the element does not have any associated CSS layout box, the element has no associated scrolling box,
 919     // or the element has no overflow, terminate these steps.
 920     RenderBox* renderer = renderBox();
 921     if (!renderer || !renderer-&gt;hasOverflowClip())
 922         return;
 923 
 924     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
 925         adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
 926         adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
 927     );
 928     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);
 929     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);
 930 }
 931 
 932 void Element::scrollTo(double x, double y)
 933 {
 934     scrollTo({ x, y });
</pre>
<hr />
<pre>
1157     return 0;
1158 }
1159 
1160 double Element::clientWidth()
1161 {
1162     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1163 
1164     if (!document().hasLivingRenderTree())
1165         return 0;
1166 
1167     RenderView&amp; renderView = *document().renderView();
1168 
1169     // When in strict mode, clientWidth for the document element should return the width of the containing frame.
1170     // When in quirks mode, clientWidth for the body element should return the width of the containing frame.
1171     bool inQuirksMode = document().inQuirksMode();
1172     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1173         return adjustForAbsoluteZoom(renderView.frameView().layoutWidth(), renderView);
1174 
1175     if (RenderBox* renderer = renderBox()) {
1176         LayoutUnit clientWidth = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientWidth() : LayoutUnit(roundToInt(renderer-&gt;clientWidth()));












1177         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientWidth, *renderer).toDouble(), renderer-&gt;document());
1178     }
1179     return 0;
1180 }
1181 
1182 double Element::clientHeight()
1183 {
1184     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
1185     if (!document().hasLivingRenderTree())
1186         return 0;
1187 
1188     RenderView&amp; renderView = *document().renderView();
1189 
1190     // When in strict mode, clientHeight for the document element should return the height of the containing frame.
1191     // When in quirks mode, clientHeight for the body element should return the height of the containing frame.
1192     bool inQuirksMode = document().inQuirksMode();
1193     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1194         return adjustForAbsoluteZoom(renderView.frameView().layoutHeight(), renderView);
1195 
1196     if (RenderBox* renderer = renderBox()) {
1197         LayoutUnit clientHeight = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientHeight() : LayoutUnit(roundToInt(renderer-&gt;clientHeight()));












1198         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientHeight, *renderer).toDouble(), renderer-&gt;document());
1199     }
1200     return 0;
1201 }
1202 
1203 ALWAYS_INLINE Frame* Element::documentFrameWithNonNullView() const
1204 {
1205     auto* frame = document().frame();
1206     return frame &amp;&amp; frame-&gt;view() ? frame : nullptr;
1207 }
1208 
1209 int Element::scrollLeft()
1210 {
1211     document().updateLayoutIgnorePendingStylesheets();
1212 
1213     if (document().scrollingElement() == this) {
1214         if (auto* frame = documentFrameWithNonNullView())
1215             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().x(), *frame);
1216         return 0;
1217     }
</pre>
<hr />
<pre>
1705             AtomString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());
1706             if (newId != oldId) {
1707                 Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
1708                 elementData()-&gt;setIdForStyleResolution(newId);
1709             }
1710 
1711             if (!oldValue.isEmpty())
1712                 treeScope().idTargetObserverRegistry().notifyObservers(*oldValue.impl());
1713             if (!newValue.isEmpty())
1714                 treeScope().idTargetObserverRegistry().notifyObservers(*newValue.impl());
1715         } else if (name == HTMLNames::nameAttr)
1716             elementData()-&gt;setHasNameAttribute(!newValue.isNull());
1717         else if (name == HTMLNames::pseudoAttr) {
1718             if (needsStyleInvalidation() &amp;&amp; isInShadowTree())
1719                 invalidateStyleForSubtree();
1720         } else if (name == HTMLNames::slotAttr) {
1721             if (auto* parent = parentElement()) {
1722                 if (auto* shadowRoot = parent-&gt;shadowRoot())
1723                     shadowRoot-&gt;hostChildElementDidChangeSlotAttribute(*this, oldValue, newValue);
1724             }







1725         }
1726     }
1727 
1728     parseAttribute(name, newValue);
1729 
1730     document().incDOMTreeVersion();
1731 
1732     if (UNLIKELY(isDefinedCustomElement()))
1733         CustomElementReactionQueue::enqueueAttributeChangedCallbackIfNeeded(*this, name, oldValue, newValue);
1734 
1735     if (valueIsSameAsBefore)
1736         return;
1737 
1738     invalidateNodeListAndCollectionCachesInAncestorsForAttribute(name);
1739 
1740     if (AXObjectCache* cache = document().existingAXObjectCache())
1741         cache-&gt;deferAttributeChangeIfNeeded(name, this);
1742 }
1743 
1744 template &lt;typename CharacterType&gt;
<span class="line-modified">1745 static inline bool classStringHasClassName(const CharacterType* characters, unsigned length)</span>
1746 {
1747     ASSERT(length &gt; 0);
1748 
1749     unsigned i = 0;
1750     do {
1751         if (isNotHTMLSpace(characters[i]))
1752             break;
1753         ++i;
1754     } while (i &lt; length);
1755 
1756     return i &lt; length;
1757 }
1758 
<span class="line-modified">1759 static inline bool classStringHasClassName(const AtomString&amp; newClassString)</span>
1760 {
<span class="line-modified">1761     unsigned length = newClassString.length();</span>
1762 
1763     if (!length)
1764         return false;
1765 
<span class="line-modified">1766     if (newClassString.is8Bit())</span>
<span class="line-modified">1767         return classStringHasClassName(newClassString.characters8(), length);</span>
<span class="line-modified">1768     return classStringHasClassName(newClassString.characters16(), length);</span>
1769 }
1770 
1771 void Element::classAttributeChanged(const AtomString&amp; newClassString)
1772 {
1773     // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
1774     if (!elementData())
1775         ensureUniqueElementData();
1776 
1777     bool shouldFoldCase = document().inQuirksMode();
<span class="line-modified">1778     bool newStringHasClasses = classStringHasClassName(newClassString);</span>
1779 
1780     auto oldClassNames = elementData()-&gt;classNames();
1781     auto newClassNames = newStringHasClasses ? SpaceSplitString(newClassString, shouldFoldCase) : SpaceSplitString();
1782     {
1783         Style::ClassChangeInvalidation styleInvalidation(*this, oldClassNames, newClassNames);
1784         elementData()-&gt;setClassNames(newClassNames);
1785     }
1786 
1787     if (hasRareData()) {
1788         if (auto* classList = elementRareData()-&gt;classList())
1789             classList-&gt;associatedAttributeValueChanged(newClassString);
1790     }
1791 }
1792 




















1793 URL Element::absoluteLinkURL() const
1794 {
1795     if (!isLink())
1796         return URL();
1797 
1798     AtomString linkAttribute;
1799     if (hasTagName(SVGNames::aTag))
1800         linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
1801     else
1802         linkAttribute = getAttribute(HTMLNames::hrefAttr);
1803 
1804     if (linkAttribute.isEmpty())
1805         return URL();
1806 
1807     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(linkAttribute));
1808 }
1809 
1810 #if ENABLE(TOUCH_EVENTS)

1811 bool Element::allowsDoubleTapGesture() const
1812 {
1813 #if ENABLE(POINTER_EVENTS)
1814     if (renderStyle() &amp;&amp; renderStyle()-&gt;touchActions() != TouchAction::Auto)
1815         return false;
1816 #endif
1817 
1818     Element* parent = parentElement();
1819     return !parent || parent-&gt;allowsDoubleTapGesture();
1820 }

1821 #endif
1822 
<span class="line-modified">1823 StyleResolver&amp; Element::styleResolver()</span>
1824 {
1825     if (auto* shadowRoot = containingShadowRoot())
1826         return shadowRoot-&gt;styleScope().resolver();
1827 
1828     return document().styleScope().resolver();
1829 }
1830 
<span class="line-modified">1831 ElementStyle Element::resolveStyle(const RenderStyle* parentStyle)</span>
1832 {
1833     return styleResolver().styleForElement(*this, parentStyle);
1834 }
1835 
1836 static void invalidateForSiblingCombinators(Element* sibling)
1837 {
1838     for (; sibling; sibling = sibling-&gt;nextElementSibling()) {
1839         if (sibling-&gt;styleIsAffectedByPreviousSibling())
1840             sibling-&gt;invalidateStyleInternal();
1841         if (sibling-&gt;descendantsAffectedByPreviousSibling()) {
1842             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
1843                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
1844         }
1845         if (!sibling-&gt;affectsNextSiblingElementStyle())
1846             return;
1847     }
1848 }
1849 
1850 static void invalidateSiblingsIfNeeded(Element&amp; element)
1851 {
</pre>
<hr />
<pre>
2013     return m_tagName.toString();
2014 }
2015 
2016 ExceptionOr&lt;void&gt; Element::setPrefix(const AtomString&amp; prefix)
2017 {
2018     auto result = checkSetPrefix(prefix);
2019     if (result.hasException())
2020         return result.releaseException();
2021 
2022     m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
2023     return { };
2024 }
2025 
2026 const AtomString&amp; Element::imageSourceURL() const
2027 {
2028     return attributeWithoutSynchronization(srcAttr);
2029 }
2030 
2031 bool Element::rendererIsNeeded(const RenderStyle&amp; style)
2032 {
<span class="line-modified">2033     return style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;</span>
2034 }
2035 
2036 RenderPtr&lt;RenderElement&gt; Element::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
2037 {
2038     return RenderElement::createFor(*this, WTFMove(style));
2039 }
2040 
2041 Node::InsertedIntoAncestorResult Element::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
2042 {
2043     ContainerNode::insertedIntoAncestor(insertionType, parentOfInsertedTree);
2044 
2045 #if ENABLE(FULLSCREEN_API)
2046     if (containsFullScreenElement() &amp;&amp; parentElement() &amp;&amp; !parentElement()-&gt;containsFullScreenElement())
2047         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
2048 #endif
2049 
2050     if (parentNode() == &amp;parentOfInsertedTree) {
2051         if (auto* shadowRoot = parentNode()-&gt;shadowRoot())
2052             shadowRoot-&gt;hostChildElementDidChange(*this);
2053     }
</pre>
<hr />
<pre>
2152         if (removalType.disconnectedFromDocument &amp;&amp; UNLIKELY(isDefinedCustomElement()))
2153             CustomElementReactionQueue::enqueueDisconnectedCallbackIfNeeded(*this);
2154     }
2155 
2156     if (!parentNode()) {
2157         if (auto* shadowRoot = oldParentOfRemovedTree.shadowRoot())
2158             shadowRoot-&gt;hostChildElementDidChange(*this);
2159     }
2160 
2161     clearBeforePseudoElement();
2162     clearAfterPseudoElement();
2163 
2164     ContainerNode::removedFromAncestor(removalType, oldParentOfRemovedTree);
2165 
2166     if (hasPendingResources())
2167         document().accessSVGExtensions().removeElementFromPendingResources(*this);
2168 
2169     RefPtr&lt;Frame&gt; frame = document().frame();
2170     if (auto* timeline = document().existingTimeline())
2171         timeline-&gt;elementWasRemoved(*this);

2172     if (frame)
2173         frame-&gt;animation().cancelAnimations(*this);
2174 
2175 #if PLATFORM(MAC)
2176     if (frame &amp;&amp; frame-&gt;page())
2177         frame-&gt;page()-&gt;removeLatchingStateForTarget(*this);
2178 #endif
2179 
2180     if (hasRareData() &amp;&amp; elementRareData()-&gt;hasElementIdentifier()) {
2181         document().identifiedElementWasRemovedFromDocument(*this);
2182         elementRareData()-&gt;setHasElementIdentifier(false);
2183     }
2184 }
2185 
2186 ShadowRoot* Element::shadowRoot() const
2187 {
2188     return hasRareData() ? elementRareData()-&gt;shadowRoot() : nullptr;
2189 }
2190 
2191 void Element::addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp; newShadowRoot)
2192 {
2193     ASSERT(!newShadowRoot-&gt;hasChildNodes());
2194     ASSERT(!shadowRoot());
2195 
2196     ShadowRoot&amp; shadowRoot = newShadowRoot;
2197     {

2198         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2199         if (renderer())
2200             RenderTreeUpdater::tearDownRenderers(*this);
2201 
2202         ensureElementRareData().setShadowRoot(WTFMove(newShadowRoot));
2203 
2204         shadowRoot.setHost(this);
2205         shadowRoot.setParentTreeScope(treeScope());
2206 
<span class="line-modified">2207 #if !ASSERT_DISABLED</span>
2208         ASSERT(notifyChildNodeInserted(*this, shadowRoot).isEmpty());
2209 #else
2210         notifyChildNodeInserted(*this, shadowRoot);
2211 #endif
2212 
2213         invalidateStyleAndRenderersForSubtree();
2214     }
2215 
2216     if (shadowRoot.mode() == ShadowRootMode::UserAgent)
2217         didAddUserAgentShadowRoot(shadowRoot);
2218 
2219     InspectorInstrumentation::didPushShadowRoot(*this, shadowRoot);
2220 }
2221 
2222 void Element::removeShadowRoot()
2223 {
2224     RefPtr&lt;ShadowRoot&gt; oldRoot = shadowRoot();
2225     if (!oldRoot)
2226         return;
2227 
</pre>
<hr />
<pre>
2236     oldRoot-&gt;setParentTreeScope(document());
2237 }
2238 
2239 static bool canAttachAuthorShadowRoot(const Element&amp; element)
2240 {
2241     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {
2242         static const HTMLQualifiedName* const tagList[] = {
2243             &amp;articleTag.get(),
2244             &amp;asideTag.get(),
2245             &amp;blockquoteTag.get(),
2246             &amp;bodyTag.get(),
2247             &amp;divTag.get(),
2248             &amp;footerTag.get(),
2249             &amp;h1Tag.get(),
2250             &amp;h2Tag.get(),
2251             &amp;h3Tag.get(),
2252             &amp;h4Tag.get(),
2253             &amp;h5Tag.get(),
2254             &amp;h6Tag.get(),
2255             &amp;headerTag.get(),

2256             &amp;navTag.get(),
2257             &amp;pTag.get(),
2258             &amp;sectionTag.get(),
2259             &amp;spanTag.get()
2260         };
2261         HashSet&lt;AtomString&gt; set;
2262         for (auto&amp; name : tagList)
2263             set.add(name-&gt;localName());
2264         return set;
2265     }();
2266 
2267     if (!is&lt;HTMLElement&gt;(element))
2268         return false;
2269 
2270     const auto&amp; localName = element.localName();
2271     return tagNames.get().contains(localName) || Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid;
2272 }
2273 
2274 ExceptionOr&lt;ShadowRoot&amp;&gt; Element::attachShadow(const ShadowRootInit&amp; init)
2275 {
2276     if (!canAttachAuthorShadowRoot(*this))
2277         return Exception { NotSupportedError };
2278     if (shadowRoot())
<span class="line-modified">2279         return Exception { InvalidStateError };</span>
2280     if (init.mode == ShadowRootMode::UserAgent)
2281         return Exception { TypeError };
<span class="line-modified">2282     auto shadow = ShadowRoot::create(document(), init.mode);</span>
2283     auto&amp; result = shadow.get();
2284     addShadowRoot(WTFMove(shadow));
2285     return result;
2286 }
2287 
<span class="line-modified">2288 ShadowRoot* Element::shadowRootForBindings(JSC::ExecState&amp; state) const</span>
2289 {
2290     auto* shadow = shadowRoot();
2291     if (!shadow)
2292         return nullptr;
2293     if (shadow-&gt;mode() == ShadowRootMode::Open)
2294         return shadow;
<span class="line-modified">2295     if (JSC::jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())-&gt;world().shadowRootIsAlwaysOpen())</span>
2296         return shadow;
2297     return nullptr;
2298 }
2299 
2300 RefPtr&lt;ShadowRoot&gt; Element::userAgentShadowRoot() const
2301 {
2302     ASSERT(!shadowRoot() || shadowRoot()-&gt;mode() == ShadowRootMode::UserAgent);
2303     return shadowRoot();
2304 }
2305 
2306 ShadowRoot&amp; Element::ensureUserAgentShadowRoot()
2307 {
2308     if (auto shadow = userAgentShadowRoot())
2309         return *shadow;
2310     auto newShadow = ShadowRoot::create(document(), ShadowRootMode::UserAgent);
2311     ShadowRoot&amp; shadow = newShadow;
2312     addShadowRoot(WTFMove(newShadow));
2313     return shadow;
2314 }
2315 
</pre>
<hr />
<pre>
2534 void Element::removeAllEventListeners()
2535 {
2536     ContainerNode::removeAllEventListeners();
2537     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot())
2538         shadowRoot-&gt;removeAllEventListeners();
2539 }
2540 
2541 void Element::beginParsingChildren()
2542 {
2543     clearIsParsingChildrenFinished();
2544 }
2545 
2546 void Element::finishParsingChildren()
2547 {
2548     ContainerNode::finishParsingChildren();
2549     setIsParsingChildrenFinished();
2550     checkForSiblingStyleChanges(*this, FinishedParsingChildren, ElementTraversal::lastChild(*this), nullptr);
2551 }
2552 
2553 #if ENABLE(TREE_DEBUGGING)

2554 void Element::formatForDebugger(char* buffer, unsigned length) const
2555 {
2556     StringBuilder result;
2557     String s;
2558 
2559     result.append(nodeName());
2560 
2561     s = getIdAttribute();
2562     if (s.length() &gt; 0) {
2563         if (result.length() &gt; 0)
2564             result.appendLiteral(&quot;; &quot;);
2565         result.appendLiteral(&quot;id=&quot;);
2566         result.append(s);
2567     }
2568 
2569     s = getAttribute(classAttr);
2570     if (s.length() &gt; 0) {
2571         if (result.length() &gt; 0)
2572             result.appendLiteral(&quot;; &quot;);
2573         result.appendLiteral(&quot;class=&quot;);
2574         result.append(s);
2575     }
2576 
2577     strncpy(buffer, result.toString().utf8().data(), length - 1);
2578 }

2579 #endif
2580 
2581 const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; Element::attrNodeList()
2582 {
2583     ASSERT(hasSyntheticAttrChildNodes());
2584     return *attrNodeListForElement(*this);
2585 }
2586 
2587 void Element::attachAttributeNodeIfNeeded(Attr&amp; attrNode)
2588 {
2589     ASSERT(!attrNode.ownerElement() || attrNode.ownerElement() == this);
2590     if (attrNode.ownerElement() == this)
2591         return;
2592 
2593     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2594 
2595     attrNode.attachToElement(*this);
2596     ensureAttrNodeListForElement(*this).append(&amp;attrNode);
2597 }
2598 
</pre>
<hr />
<pre>
2810     return ensureAttr(attribute-&gt;name());
2811 }
2812 
2813 bool Element::hasAttribute(const AtomString&amp; qualifiedName) const
2814 {
2815     if (!elementData())
2816         return false;
2817     synchronizeAttribute(qualifiedName);
2818     return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2819 }
2820 
2821 bool Element::hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const
2822 {
2823     if (!elementData())
2824         return false;
2825     QualifiedName qName(nullAtom(), localName, namespaceURI);
2826     synchronizeAttribute(qName);
2827     return elementData()-&gt;findAttributeByName(qName);
2828 }
2829 






































2830 void Element::focus(bool restorePreviousSelection, FocusDirection direction)
2831 {
2832     if (!isConnected())
2833         return;
2834 
<span class="line-modified">2835     if (document().focusedElement() == this) {</span>
<span class="line-modified">2836         if (document().page())</span>
<span class="line-modified">2837             document().page()-&gt;chrome().client().elementDidRefocus(*this);</span>
<span class="line-modified">2838 </span>
2839         return;
2840     }
2841 
<span class="line-modified">2842     // If the stylesheets have already been loaded we can reliably check isFocusable.</span>
<span class="line-modified">2843     // If not, we continue and set the focused node on the focus controller below so</span>
<span class="line-modified">2844     // that it can be updated soon after attach.</span>
<span class="line-modified">2845     if (document().haveStylesheetsLoaded()) {</span>
<span class="line-modified">2846         document().updateStyleIfNeeded();</span>
<span class="line-modified">2847         if (!isFocusable())</span>






2848             return;
<span class="line-modified">2849     }</span>
2850 
<span class="line-modified">2851     if (!supportsFocus())</span>



2852         return;
2853 
<span class="line-modified">2854     RefPtr&lt;Node&gt; protect;</span>
<span class="line-modified">2855     if (Page* page = document().page()) {</span>
<span class="line-modified">2856         auto&amp; frame = *document().frame();</span>
<span class="line-removed">2857         if (!frame.hasHadUserInteraction() &amp;&amp; !frame.isMainFrame() &amp;&amp; !document().topDocument().securityOrigin().canAccess(document().securityOrigin()))</span>
2858             return;
2859 
2860         // Focus and change event handlers can cause us to lose our last ref.
2861         // If a focus event handler changes the focus to a different node it
2862         // does not make sense to continue and update appearence.
<span class="line-modified">2863         protect = this;</span>
<span class="line-removed">2864         if (!page-&gt;focusController().setFocusedElement(this, *document().frame(), direction))</span>
2865             return;
2866     }
2867 
2868     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;

2869 #if PLATFORM(IOS_FAMILY)
2870     // Focusing a form element triggers animation in UIKit to scroll to the right position.
2871     // Calling updateFocusAppearance() would generate an unnecessary call to ScrollView::setScrollPosition(),
2872     // which would jump us around during this animation. See &lt;rdar://problem/6699741&gt;.
<span class="line-modified">2873     bool isFormControl = is&lt;HTMLFormControlElement&gt;(*this);</span>
<span class="line-removed">2874     if (isFormControl)</span>
2875         revealMode = SelectionRevealMode::RevealUpToMainFrame;
2876 #endif
2877 
2878     auto target = focusAppearanceUpdateTarget();
2879     if (!target)
2880         return;
2881 
2882     target-&gt;updateFocusAppearance(restorePreviousSelection ? SelectionRestorationMode::Restore : SelectionRestorationMode::SetDefault, revealMode);
2883 }
2884 

2885 RefPtr&lt;Element&gt; Element::focusAppearanceUpdateTarget()
2886 {
2887     return this;
2888 }
2889 
2890 void Element::updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode revealMode)
2891 {
2892     if (isRootEditableElement()) {
2893         // Keep frame alive in this method, since setSelection() may release the last reference to |frame|.
2894         RefPtr&lt;Frame&gt; frame = document().frame();
2895         if (!frame)
2896             return;
2897 
2898         // When focusing an editable element in an iframe, don&#39;t reset the selection if it already contains a selection.
2899         if (this == frame-&gt;selection().selection().rootEditableElement())
2900             return;
2901 
2902         // FIXME: We should restore the previous selection if there is one.
2903         VisibleSelection newSelection = VisibleSelection(firstPositionInOrBeforeNode(this), DOWNSTREAM);
2904 
</pre>
<hr />
<pre>
3378 }
3379 
3380 bool Element::shouldAppearIndeterminate() const
3381 {
3382     return false;
3383 }
3384 
3385 bool Element::mayCauseRepaintInsideViewport(const IntRect* visibleRect) const
3386 {
3387     return renderer() &amp;&amp; renderer()-&gt;mayCauseRepaintInsideViewport(visibleRect);
3388 }
3389 
3390 DOMTokenList&amp; Element::classList()
3391 {
3392     ElementRareData&amp; data = ensureElementRareData();
3393     if (!data.classList())
3394         data.setClassList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));
3395     return *data.classList();
3396 }
3397 













3398 DatasetDOMStringMap&amp; Element::dataset()
3399 {
3400     ElementRareData&amp; data = ensureElementRareData();
3401     if (!data.dataset())
3402         data.setDataset(makeUnique&lt;DatasetDOMStringMap&gt;(*this));
3403     return *data.dataset();
3404 }
3405 
3406 URL Element::getURLAttribute(const QualifiedName&amp; name) const
3407 {
<span class="line-modified">3408 #if !ASSERT_DISABLED</span>
3409     if (elementData()) {
3410         if (const Attribute* attribute = findAttributeByName(name))
3411             ASSERT(isURLAttribute(*attribute));
3412     }
3413 #endif
3414     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(getAttribute(name)));
3415 }
3416 
3417 URL Element::getNonEmptyURLAttribute(const QualifiedName&amp; name) const
3418 {
<span class="line-modified">3419 #if !ASSERT_DISABLED</span>
3420     if (elementData()) {
3421         if (const Attribute* attribute = findAttributeByName(name))
3422             ASSERT(isURLAttribute(*attribute));
3423     }
3424 #endif
3425     String value = stripLeadingAndTrailingHTMLSpaces(getAttribute(name));
3426     if (value.isEmpty())
3427         return URL();
3428     return document().completeURL(value);
3429 }
3430 
3431 int Element::getIntegralAttribute(const QualifiedName&amp; attributeName) const
3432 {
3433     return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
3434 }
3435 
3436 void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
3437 {
3438     setAttribute(attributeName, AtomString::number(value));
3439 }
</pre>
<hr />
<pre>
3443     return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
3444 }
3445 
3446 void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
3447 {
3448     setAttribute(attributeName, AtomString::number(limitToOnlyHTMLNonNegative(value)));
3449 }
3450 
3451 bool Element::childShouldCreateRenderer(const Node&amp; child) const
3452 {
3453     // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
3454     if (child.isSVGElement()) {
3455         ASSERT(!isSVGElement());
3456         const SVGElement&amp; childElement = downcast&lt;SVGElement&gt;(child);
3457         return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
3458     }
3459     return true;
3460 }
3461 
3462 #if ENABLE(FULLSCREEN_API)

3463 static Element* parentCrossingFrameBoundaries(const Element* element)
3464 {
3465     ASSERT(element);
3466     if (auto* parent = element-&gt;parentElementInComposedTree())
3467         return parent;
3468     return element-&gt;document().ownerElement();
3469 }
3470 
3471 void Element::webkitRequestFullscreen()
3472 {
3473     document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::EnforceIFrameAllowFullscreenRequirement);
3474 }
3475 
3476 bool Element::containsFullScreenElement() const
3477 {
3478     return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
3479 }
3480 
3481 void Element::setContainsFullScreenElement(bool flag)
3482 {
3483     ensureElementRareData().setContainsFullScreenElement(flag);
3484     invalidateStyleAndLayerComposition();
3485 }
3486 
3487 void Element::setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool flag)
3488 {
3489     Element* element = this;
3490     while ((element = parentCrossingFrameBoundaries(element)))
3491         element-&gt;setContainsFullScreenElement(flag);
3492 }

3493 #endif
3494 
3495 #if ENABLE(POINTER_EVENTS)

3496 ExceptionOr&lt;void&gt; Element::setPointerCapture(int32_t pointerId)
3497 {
3498     if (document().page())
3499         return document().page()-&gt;pointerCaptureController().setPointerCapture(this, pointerId);
3500     return { };
3501 }
3502 
3503 ExceptionOr&lt;void&gt; Element::releasePointerCapture(int32_t pointerId)
3504 {
3505     if (document().page())
3506         return document().page()-&gt;pointerCaptureController().releasePointerCapture(this, pointerId);
3507     return { };
3508 }
3509 
3510 bool Element::hasPointerCapture(int32_t pointerId)
3511 {
3512     if (document().page())
3513         return document().page()-&gt;pointerCaptureController().hasPointerCapture(this, pointerId);
3514     return false;
3515 }

3516 #endif
3517 
3518 #if ENABLE(POINTER_LOCK)

3519 void Element::requestPointerLock()
3520 {
3521     if (document().page())
3522         document().page()-&gt;pointerLockController().requestPointerLock(this);
3523 }

3524 #endif
3525 
3526 #if ENABLE(INTERSECTION_OBSERVER)

3527 void Element::disconnectFromIntersectionObservers()
3528 {
3529     auto* observerData = intersectionObserverData();
3530     if (!observerData)
3531         return;
3532 
3533     for (const auto&amp; registration : observerData-&gt;registrations)
3534         registration.observer-&gt;targetDestroyed(*this);
3535     observerData-&gt;registrations.clear();
3536 
3537     for (const auto&amp; observer : observerData-&gt;observers)
3538         observer-&gt;rootDestroyed();
3539     observerData-&gt;observers.clear();
3540 }
3541 
3542 IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
3543 {
3544     auto&amp; rareData = ensureElementRareData();
3545     if (!rareData.intersectionObserverData())
3546         rareData.setIntersectionObserverData(makeUnique&lt;IntersectionObserverData&gt;());
3547     return *rareData.intersectionObserverData();
3548 }
3549 
3550 IntersectionObserverData* Element::intersectionObserverData()
3551 {
3552     return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
3553 }

3554 #endif
3555 








































3556 #if ENABLE(RESIZE_OBSERVER)

3557 void Element::disconnectFromResizeObservers()
3558 {
3559     auto* observerData = resizeObserverData();
3560     if (!observerData)
3561         return;
3562 
3563     for (const auto&amp; observer : observerData-&gt;observers)
3564         observer-&gt;targetDestroyed(*this);
3565     observerData-&gt;observers.clear();
3566 }
3567 
3568 ResizeObserverData&amp; Element::ensureResizeObserverData()
3569 {
3570     auto&amp; rareData = ensureElementRareData();
3571     if (!rareData.resizeObserverData())
3572         rareData.setResizeObserverData(makeUnique&lt;ResizeObserverData&gt;());
3573     return *rareData.resizeObserverData();
3574 }
3575 
3576 ResizeObserverData* Element::resizeObserverData()
3577 {
3578     return hasRareData() ? elementRareData()-&gt;resizeObserverData() : nullptr;
3579 }
<span class="line-removed">3580 #endif</span>
3581 
<span class="line-modified">3582 SpellcheckAttributeState Element::spellcheckAttributeState() const</span>
<span class="line-removed">3583 {</span>
<span class="line-removed">3584     const AtomString&amp; value = attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
<span class="line-removed">3585     if (value.isNull())</span>
<span class="line-removed">3586         return SpellcheckAttributeDefault;</span>
<span class="line-removed">3587     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))</span>
<span class="line-removed">3588         return SpellcheckAttributeTrue;</span>
<span class="line-removed">3589     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))</span>
<span class="line-removed">3590         return SpellcheckAttributeFalse;</span>
<span class="line-removed">3591     return SpellcheckAttributeDefault;</span>
<span class="line-removed">3592 }</span>
3593 
3594 bool Element::isSpellCheckingEnabled() const
3595 {
<span class="line-modified">3596     for (const Element* element = this; element; element = element-&gt;parentOrShadowHostElement()) {</span>
<span class="line-modified">3597         switch (element-&gt;spellcheckAttributeState()) {</span>
<span class="line-modified">3598         case SpellcheckAttributeTrue:</span>


3599             return true;
<span class="line-modified">3600         case SpellcheckAttributeFalse:</span>
3601             return false;
<span class="line-removed">3602         case SpellcheckAttributeDefault:</span>
<span class="line-removed">3603             break;</span>
<span class="line-removed">3604         }</span>
3605     }
<span class="line-removed">3606 </span>
3607     return true;
3608 }
3609 
<span class="line-modified">3610 #ifndef NDEBUG</span>
3611 bool Element::fastAttributeLookupAllowed(const QualifiedName&amp; name) const
3612 {
3613     if (name == HTMLNames::styleAttr)
3614         return false;
3615 
3616     if (isSVGElement())
3617         return !downcast&lt;SVGElement&gt;(*this).isAnimatedPropertyAttribute(name);
3618 
3619     return true;
3620 }
3621 #endif
3622 
3623 #if DUMP_NODE_STATISTICS
3624 bool Element::hasNamedNodeMap() const
3625 {
3626     return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
3627 }
3628 #endif
3629 
3630 inline void Element::updateName(const AtomString&amp; oldName, const AtomString&amp; newName)
</pre>
<hr />
<pre>
3906 void Element::willAttachRenderers()
3907 {
3908     ASSERT(hasCustomStyleResolveCallbacks());
3909 }
3910 
3911 void Element::didAttachRenderers()
3912 {
3913     ASSERT(hasCustomStyleResolveCallbacks());
3914 }
3915 
3916 void Element::willDetachRenderers()
3917 {
3918     ASSERT(hasCustomStyleResolveCallbacks());
3919 }
3920 
3921 void Element::didDetachRenderers()
3922 {
3923     ASSERT(hasCustomStyleResolveCallbacks());
3924 }
3925 
<span class="line-modified">3926 Optional&lt;ElementStyle&gt; Element::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle*)</span>
3927 {
3928     ASSERT(hasCustomStyleResolveCallbacks());
3929     return WTF::nullopt;
3930 }
3931 
3932 void Element::cloneAttributesFromElement(const Element&amp; other)
3933 {
3934     if (hasSyntheticAttrChildNodes())
3935         detachAllAttrNodesFromElement();
3936 
3937     other.synchronizeAllAttributes();
3938     if (!other.m_elementData) {
3939         m_elementData = nullptr;
3940         return;
3941     }
3942 
3943     // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
3944     // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
3945     ASSERT(!isConnected());
3946 
</pre>
<hr />
<pre>
4153     if (!isLink())
4154         return nullptr;
4155 
4156     const AtomString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);
4157     if (href.isNull())
4158         return nullptr;
4159 
4160     Document&amp; document = this-&gt;document();
4161     URL url = document.completeURL(href);
4162     if (!url.isValid())
4163         return nullptr;
4164 
4165     if (url.hasFragmentIdentifier() &amp;&amp; equalIgnoringFragmentIdentifier(url, document.baseURL())) {
4166         outAnchorName = url.fragmentIdentifier();
4167         return document.findAnchor(outAnchorName);
4168     }
4169 
4170     return nullptr;
4171 }
4172 
<span class="line-modified">4173 ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::ExecState&amp; state, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)</span>
4174 {
4175     String id = &quot;&quot;;
4176     Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt; keyframeEffectOptions;
4177     if (options) {
4178         auto optionsValue = options.value();
4179         Variant&lt;double, KeyframeEffectOptions&gt; keyframeEffectOptionsVariant;
4180         if (WTF::holds_alternative&lt;double&gt;(optionsValue))
4181             keyframeEffectOptionsVariant = WTF::get&lt;double&gt;(optionsValue);
4182         else {
4183             auto keyframeEffectOptions = WTF::get&lt;KeyframeAnimationOptions&gt;(optionsValue);
4184             id = keyframeEffectOptions.id;
4185             keyframeEffectOptionsVariant = WTFMove(keyframeEffectOptions);
4186         }
4187         keyframeEffectOptions = keyframeEffectOptionsVariant;
4188     }
4189 
<span class="line-modified">4190     auto keyframeEffectResult = KeyframeEffect::create(state, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));</span>
4191     if (keyframeEffectResult.hasException())
4192         return keyframeEffectResult.releaseException();
4193 
4194     auto animation = WebAnimation::create(document(), &amp;keyframeEffectResult.returnValue().get());
4195     animation-&gt;setId(id);
4196 
4197     auto animationPlayResult = animation-&gt;play();
4198     if (animationPlayResult.hasException())
4199         return animationPlayResult.releaseException();
4200 
4201     return animation;
4202 }
4203 
<span class="line-modified">4204 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations()</span>
<span class="line-modified">4205 {</span>
<span class="line-modified">4206     // FIXME: Filter and order the list as specified (webkit.org/b/179535).</span>

















4207 
4208     // For the list of animations to be current, we need to account for any pending CSS changes,
4209     // such as updates to CSS Animations and CSS Transitions.
4210     // FIXME: We might be able to use ComputedStyleExtractor which is more optimized.
4211     document().updateStyleIfNeeded();
4212 
4213     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
4214     if (auto timeline = document().existingTimeline()) {
4215         for (auto&amp; animation : timeline-&gt;animationsForElement(*this, AnimationTimeline::Ordering::Sorted)) {
4216             if (animation-&gt;isRelevant())
4217                 animations.append(animation);
4218         }
4219     }
4220     return animations;
4221 }
4222 
4223 ElementIdentifier Element::createElementIdentifier()
4224 {
4225     auto&amp; rareData = ensureElementRareData();
4226     ASSERT(!rareData.hasElementIdentifier());
4227 
4228     rareData.setHasElementIdentifier(true);
4229     return ElementIdentifier::generate();
4230 }
4231 
4232 #if ENABLE(CSS_TYPED_OM)

4233 StylePropertyMap* Element::attributeStyleMap()
4234 {
4235     if (!hasRareData())
4236         return nullptr;
4237     return elementRareData()-&gt;attributeStyleMap();
4238 }
4239 
4240 void Element::setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map)
4241 {
4242     ensureElementRareData().setAttributeStyleMap(WTFMove(map));
4243 }

4244 #endif
4245 
4246 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Peter Kelly (pmk@post.com)
   5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   6  *           (C) 2007 David Smith (catfish.man@gmail.com)
<span class="line-modified">   7  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   8  *           (C) 2007 Eric Seidel (eric@webkit.org)
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Element.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;Attr.h&quot;
  31 #include &quot;AttributeChangeInvalidation.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CSSParser.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ClassChangeInvalidation.h&quot;
  37 #include &quot;ComposedTreeAncestorIterator.h&quot;
<span class="line-added">  38 #include &quot;ComposedTreeIterator.h&quot;</span>
  39 #include &quot;ContainerNodeAlgorithms.h&quot;
  40 #include &quot;CustomElementReactionQueue.h&quot;
  41 #include &quot;CustomElementRegistry.h&quot;
  42 #include &quot;DOMRect.h&quot;
  43 #include &quot;DOMRectList.h&quot;
  44 #include &quot;DOMTokenList.h&quot;
  45 #include &quot;DOMWindow.h&quot;
  46 #include &quot;DocumentSharedObjectPool.h&quot;
  47 #include &quot;DocumentTimeline.h&quot;
  48 #include &quot;Editing.h&quot;
  49 #include &quot;ElementIterator.h&quot;
  50 #include &quot;ElementRareData.h&quot;
  51 #include &quot;EventDispatcher.h&quot;
  52 #include &quot;EventHandler.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;FocusController.h&quot;
  55 #include &quot;FocusEvent.h&quot;
  56 #include &quot;Frame.h&quot;
  57 #include &quot;FrameSelection.h&quot;
  58 #include &quot;FrameView.h&quot;
  59 #include &quot;FullscreenManager.h&quot;
<span class="line-added">  60 #include &quot;GetAnimationsOptions.h&quot;</span>
  61 #include &quot;HTMLBodyElement.h&quot;
  62 #include &quot;HTMLCanvasElement.h&quot;
  63 #include &quot;HTMLCollection.h&quot;
  64 #include &quot;HTMLDocument.h&quot;
  65 #include &quot;HTMLHtmlElement.h&quot;
  66 #include &quot;HTMLLabelElement.h&quot;
  67 #include &quot;HTMLNameCollection.h&quot;
  68 #include &quot;HTMLObjectElement.h&quot;
  69 #include &quot;HTMLOptGroupElement.h&quot;
  70 #include &quot;HTMLOptionElement.h&quot;
  71 #include &quot;HTMLParserIdioms.h&quot;
  72 #include &quot;HTMLSelectElement.h&quot;
  73 #include &quot;HTMLTemplateElement.h&quot;
  74 #include &quot;IdChangeInvalidation.h&quot;
  75 #include &quot;IdTargetObserverRegistry.h&quot;
  76 #include &quot;InspectorInstrumentation.h&quot;
  77 #include &quot;JSLazyEventListener.h&quot;
  78 #include &quot;KeyboardEvent.h&quot;
<span class="line-added">  79 #include &quot;KeyframeAnimationOptions.h&quot;</span>
  80 #include &quot;KeyframeEffect.h&quot;
  81 #include &quot;MutationObserverInterestGroup.h&quot;
  82 #include &quot;MutationRecord.h&quot;
  83 #include &quot;NodeRenderStyle.h&quot;
<span class="line-added">  84 #include &quot;PlatformMouseEvent.h&quot;</span>
  85 #include &quot;PlatformWheelEvent.h&quot;
  86 #include &quot;PointerCaptureController.h&quot;
  87 #include &quot;PointerEvent.h&quot;
  88 #include &quot;PointerLockController.h&quot;
<span class="line-modified">  89 #include &quot;RenderFragmentedFlow.h&quot;</span>
  90 #include &quot;RenderLayer.h&quot;
  91 #include &quot;RenderLayerBacking.h&quot;
  92 #include &quot;RenderLayerCompositor.h&quot;
  93 #include &quot;RenderListBox.h&quot;
  94 #include &quot;RenderTheme.h&quot;
  95 #include &quot;RenderTreeUpdater.h&quot;
  96 #include &quot;RenderView.h&quot;
  97 #include &quot;RenderWidget.h&quot;
  98 #include &quot;RuntimeEnabledFeatures.h&quot;
  99 #include &quot;SVGDocumentExtensions.h&quot;
 100 #include &quot;SVGElement.h&quot;
 101 #include &quot;SVGNames.h&quot;
 102 #include &quot;SVGSVGElement.h&quot;
 103 #include &quot;ScriptDisallowedScope.h&quot;
 104 #include &quot;ScrollIntoViewOptions.h&quot;
 105 #include &quot;ScrollLatchingState.h&quot;
 106 #include &quot;SelectorQuery.h&quot;
 107 #include &quot;Settings.h&quot;
 108 #include &quot;SimulatedClick.h&quot;
 109 #include &quot;SlotAssignment.h&quot;
<span class="line-added"> 110 #include &quot;StyleInvalidator.h&quot;</span>
 111 #include &quot;StyleProperties.h&quot;
 112 #include &quot;StyleResolver.h&quot;
 113 #include &quot;StyleScope.h&quot;
 114 #include &quot;StyleTreeResolver.h&quot;
 115 #include &quot;TextIterator.h&quot;
 116 #include &quot;TouchAction.h&quot;
 117 #include &quot;VoidCallback.h&quot;
 118 #include &quot;WebAnimation.h&quot;
 119 #include &quot;WheelEvent.h&quot;
 120 #include &quot;XLinkNames.h&quot;
 121 #include &quot;XMLNSNames.h&quot;
 122 #include &quot;XMLNames.h&quot;
 123 #include &quot;markup.h&quot;
 124 #include &lt;wtf/IsoMallocInlines.h&gt;
 125 #include &lt;wtf/NeverDestroyed.h&gt;
 126 #include &lt;wtf/text/CString.h&gt;
 127 
 128 namespace WebCore {
 129 
 130 WTF_MAKE_ISO_ALLOCATED_IMPL(Element);
</pre>
<hr />
<pre>
 255     return elementRareData()-&gt;tabIndex();
 256 }
 257 
 258 int Element::defaultTabIndex() const
 259 {
 260     return -1;
 261 }
 262 
 263 bool Element::supportsFocus() const
 264 {
 265     return !!tabIndexSetExplicitly();
 266 }
 267 
 268 RefPtr&lt;Element&gt; Element::focusDelegate()
 269 {
 270     return this;
 271 }
 272 
 273 int Element::tabIndexForBindings() const
 274 {
<span class="line-modified"> 275     return valueOrCompute(tabIndexSetExplicitly(), [&amp;] { return defaultTabIndex(); });</span>





 276 }
 277 
 278 void Element::setTabIndexForBindings(int value)
 279 {
 280     setIntegralAttribute(tabindexAttr, value);
 281 }
 282 
 283 bool Element::isKeyboardFocusable(KeyboardEvent*) const
 284 {
<span class="line-modified"> 285     if (!(isFocusable() &amp;&amp; !shouldBeIgnoredInSequentialFocusNavigation() &amp;&amp; tabIndexSetExplicitly().valueOr(0) &gt;= 0))</span>
<span class="line-added"> 286         return false;</span>
<span class="line-added"> 287     if (auto* root = shadowRoot()) {</span>
<span class="line-added"> 288         if (root-&gt;delegatesFocus())</span>
<span class="line-added"> 289             return false;</span>
<span class="line-added"> 290     }</span>
<span class="line-added"> 291     return true;</span>
 292 }
 293 
 294 bool Element::isMouseFocusable() const
 295 {
 296     return isFocusable();
 297 }
 298 
 299 bool Element::shouldUseInputMethod()
 300 {
 301     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 302 }
 303 
 304 static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
 305 {
 306     return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
 307 }
 308 
<span class="line-modified"> 309 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 310 </span>
 311 static bool isCompatibilityMouseEvent(const MouseEvent&amp; mouseEvent)
 312 {
 313     // https://www.w3.org/TR/pointerevents/#compatibility-mapping-with-mouse-events
 314     const auto&amp; type = mouseEvent.type();
 315     return type != eventNames().clickEvent &amp;&amp; type != eventNames().mouseoverEvent &amp;&amp; type != eventNames().mouseoutEvent &amp;&amp; type != eventNames().mouseenterEvent &amp;&amp; type != eventNames().mouseleaveEvent;
 316 }
<span class="line-added"> 317 </span>
 318 #endif
 319 
<span class="line-modified"> 320 enum class ShouldIgnoreMouseEvent : bool { No, Yes };</span>
<span class="line-added"> 321 static ShouldIgnoreMouseEvent dispatchPointerEventIfNeeded(Element&amp; element, const MouseEvent&amp; mouseEvent, const PlatformMouseEvent&amp; platformEvent, bool&amp; didNotSwallowEvent)</span>
 322 {













 323 #if ENABLE(POINTER_EVENTS)
 324     if (RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled()) {
<span class="line-modified"> 325         if (auto* page = element.document().page()) {</span>
 326             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();
 327 #if ENABLE(TOUCH_EVENTS)
<span class="line-modified"> 328             if (platformEvent.pointerId() != mousePointerID &amp;&amp; mouseEvent.type() != eventNames().clickEvent &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(platformEvent.pointerId()))</span>
<span class="line-modified"> 329                 return ShouldIgnoreMouseEvent::Yes;</span>
 330 #else
<span class="line-added"> 331             UNUSED_PARAM(platformEvent);</span>
<span class="line-added"> 332 #endif</span>
<span class="line-added"> 333             if (platformEvent.syntheticClickType() != NoTap)</span>
<span class="line-added"> 334                 return ShouldIgnoreMouseEvent::No;</span>
<span class="line-added"> 335 </span>
 336             if (auto pointerEvent = pointerCaptureController.pointerEventForMouseEvent(mouseEvent)) {
<span class="line-modified"> 337                 pointerCaptureController.dispatchEvent(*pointerEvent, &amp;element);</span>
 338                 if (isCompatibilityMouseEvent(mouseEvent) &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(pointerEvent-&gt;pointerId()))
<span class="line-modified"> 339                     return ShouldIgnoreMouseEvent::Yes;</span>
 340                 if (pointerEvent-&gt;defaultPrevented() || pointerEvent-&gt;defaultHandled()) {
 341                     didNotSwallowEvent = false;
 342                     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent)
<span class="line-modified"> 343                         return ShouldIgnoreMouseEvent::Yes;</span>
 344                 }
 345             }

 346         }
 347     }
<span class="line-added"> 348 #else</span>
<span class="line-added"> 349     UNUSED_PARAM(element);</span>
<span class="line-added"> 350     UNUSED_PARAM(mouseEvent);</span>
<span class="line-added"> 351     UNUSED_PARAM(platformEvent);</span>
<span class="line-added"> 352     UNUSED_PARAM(didNotSwallowEvent);</span>
 353 #endif
 354 
<span class="line-added"> 355     return ShouldIgnoreMouseEvent::No;</span>
<span class="line-added"> 356 }</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358 bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomString&amp; eventType, int detail, Element* relatedTarget)</span>
<span class="line-added"> 359 {</span>
<span class="line-added"> 360     if (isDisabledFormControl())</span>
<span class="line-added"> 361         return false;</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))</span>
<span class="line-added"> 364         return false;</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);</span>
<span class="line-added"> 367 </span>
<span class="line-added"> 368     if (mouseEvent-&gt;type().isEmpty())</span>
<span class="line-added"> 369         return true; // Shouldn&#39;t happen.</span>
<span class="line-added"> 370 </span>
<span class="line-added"> 371     bool didNotSwallowEvent = true;</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373     if (dispatchPointerEventIfNeeded(*this, mouseEvent.get(), platformEvent, didNotSwallowEvent) == ShouldIgnoreMouseEvent::Yes)</span>
<span class="line-added"> 374         return false;</span>
<span class="line-added"> 375 </span>
 376     ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
 377     dispatchEvent(mouseEvent);
 378     if (mouseEvent-&gt;defaultPrevented() || mouseEvent-&gt;defaultHandled())
 379         didNotSwallowEvent = false;
 380 
 381     if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
 382         // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
 383         // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
 384         // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
 385         // FIXME: Is it okay that mouseEvent may have been mutated by scripts via initMouseEvent in dispatchEvent above?
 386         Ref&lt;MouseEvent&gt; doubleClickEvent = MouseEvent::create(eventNames().dblclickEvent,
 387             mouseEvent-&gt;bubbles() ? Event::CanBubble::Yes : Event::CanBubble::No,
 388             mouseEvent-&gt;cancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No,
 389             Event::IsComposed::Yes,
 390             mouseEvent-&gt;view(), mouseEvent-&gt;detail(),
 391             mouseEvent-&gt;screenX(), mouseEvent-&gt;screenY(), mouseEvent-&gt;clientX(), mouseEvent-&gt;clientY(),
 392             mouseEvent-&gt;modifierKeys(), mouseEvent-&gt;button(), mouseEvent-&gt;buttons(), mouseEvent-&gt;syntheticClickType(), relatedTarget);
 393 
 394         if (mouseEvent-&gt;defaultHandled())
 395             doubleClickEvent-&gt;setDefaultHandled();
</pre>
<hr />
<pre>
 691             renderer()-&gt;repaint();
 692 
 693         // FIXME: Come up with a less ridiculous way of doing this.
 694 #ifdef HAVE_FUNC_USLEEP
 695         // Now pause for a small amount of time (1/10th of a second from before we repainted in the pressed state)
 696         Seconds remainingTime = 100_ms - (MonotonicTime::now() - startTime);
 697         if (remainingTime &gt; 0_s)
 698             usleep(static_cast&lt;useconds_t&gt;(remainingTime.microseconds()));
 699 #endif
 700     }
 701 }
 702 
 703 void Element::setFocus(bool flag)
 704 {
 705     if (flag == focused())
 706         return;
 707 
 708     document().userActionElements().setFocused(*this, flag);
 709     invalidateStyleForSubtree();
 710 
<span class="line-added"> 711     // Shadow host with a slot that contain focused element is not considered focused.</span>
<span class="line-added"> 712     for (auto* root = containingShadowRoot(); root; root = root-&gt;host()-&gt;containingShadowRoot()) {</span>
<span class="line-added"> 713         root-&gt;setContainsFocusedElement(flag);</span>
<span class="line-added"> 714         root-&gt;host()-&gt;invalidateStyle();</span>
<span class="line-added"> 715     }</span>
<span class="line-added"> 716 </span>
 717     for (Element* element = this; element; element = element-&gt;parentElementInComposedTree())
 718         element-&gt;setHasFocusWithin(flag);
 719 }
 720 
 721 void Element::setHovered(bool flag)
 722 {
 723     if (flag == hovered())
 724         return;
 725 
 726     document().userActionElements().setHovered(*this, flag);
 727 
 728     auto* style = renderOrDisplayContentsStyle();
 729     if (style &amp;&amp; (style-&gt;affectedByHover() || childrenAffectedByHover()))
 730         invalidateStyleForSubtree();
 731 
 732     if (!renderer()) {
 733         // When setting hover to false, the style needs to be recalc&#39;d even when
 734         // there&#39;s no renderer (imagine setting display:none in the :hover class,
 735         // if a nil renderer would prevent this element from recalculating its
 736         // style, it would never go back to its normal style and remain
</pre>
<hr />
<pre>
 926 
 927 void Element::scrollTo(const ScrollToOptions&amp; options, ScrollClamping clamping)
 928 {
 929     if (!document().settings().CSSOMViewScrollingAPIEnabled()) {
 930         // If the element is the root element and document is in quirks mode, terminate these steps.
 931         // Note that WebKit always uses quirks mode document scrolling behavior. See Document::scrollingElement().
 932         if (this == document().documentElement())
 933             return;
 934     }
 935 
 936     document().updateLayoutIgnorePendingStylesheets();
 937 
 938     if (document().scrollingElement() == this) {
 939         // If the element is the scrolling element and is not potentially scrollable,
 940         // invoke scroll() on window with options as the only argument, and terminate these steps.
 941         // FIXME: Scrolling an independently scrollable body is broken: webkit.org/b/161612.
 942         auto window = makeRefPtr(document().domWindow());
 943         if (!window)
 944             return;
 945 
<span class="line-modified"> 946         window-&gt;scrollTo(options, clamping);</span>
 947         return;
 948     }
 949 
 950     // If the element does not have any associated CSS layout box, the element has no associated scrolling box,
 951     // or the element has no overflow, terminate these steps.
 952     RenderBox* renderer = renderBox();
 953     if (!renderer || !renderer-&gt;hasOverflowClip())
 954         return;
 955 
 956     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
 957         adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
 958         adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
 959     );
 960     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);
 961     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);
 962 }
 963 
 964 void Element::scrollTo(double x, double y)
 965 {
 966     scrollTo({ x, y });
</pre>
<hr />
<pre>
1189     return 0;
1190 }
1191 
1192 double Element::clientWidth()
1193 {
1194     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1195 
1196     if (!document().hasLivingRenderTree())
1197         return 0;
1198 
1199     RenderView&amp; renderView = *document().renderView();
1200 
1201     // When in strict mode, clientWidth for the document element should return the width of the containing frame.
1202     // When in quirks mode, clientWidth for the body element should return the width of the containing frame.
1203     bool inQuirksMode = document().inQuirksMode();
1204     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1205         return adjustForAbsoluteZoom(renderView.frameView().layoutWidth(), renderView);
1206 
1207     if (RenderBox* renderer = renderBox()) {
1208         LayoutUnit clientWidth = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientWidth() : LayoutUnit(roundToInt(renderer-&gt;clientWidth()));
<span class="line-added">1209         // clientWidth/Height is the visual portion of the box content, not including</span>
<span class="line-added">1210         // borders or scroll bars, but includes padding. And per</span>
<span class="line-added">1211         // https://www.w3.org/TR/CSS2/tables.html#model,</span>
<span class="line-added">1212         // table wrapper box is a principal block box that contains the table box</span>
<span class="line-added">1213         // itself and any caption boxes, and table grid box is a block-level box that</span>
<span class="line-added">1214         // contains the table&#39;s internal table boxes. When table&#39;s border is specified</span>
<span class="line-added">1215         // in CSS, the border is added to table grid box, not table wrapper box.</span>
<span class="line-added">1216         // Currently, WebKit doesn&#39;t have table wrapper box, and we are supposed to</span>
<span class="line-added">1217         // retrieve clientWidth/Height from table wrapper box, not table grid box. So</span>
<span class="line-added">1218         // when we retrieve clientWidth/Height, it includes table&#39;s border size.</span>
<span class="line-added">1219         if (renderer-&gt;isTable())</span>
<span class="line-added">1220             clientWidth += renderer-&gt;borderLeft() + renderer-&gt;borderRight();</span>
1221         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientWidth, *renderer).toDouble(), renderer-&gt;document());
1222     }
1223     return 0;
1224 }
1225 
1226 double Element::clientHeight()
1227 {
1228     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
1229     if (!document().hasLivingRenderTree())
1230         return 0;
1231 
1232     RenderView&amp; renderView = *document().renderView();
1233 
1234     // When in strict mode, clientHeight for the document element should return the height of the containing frame.
1235     // When in quirks mode, clientHeight for the body element should return the height of the containing frame.
1236     bool inQuirksMode = document().inQuirksMode();
1237     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1238         return adjustForAbsoluteZoom(renderView.frameView().layoutHeight(), renderView);
1239 
1240     if (RenderBox* renderer = renderBox()) {
1241         LayoutUnit clientHeight = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientHeight() : LayoutUnit(roundToInt(renderer-&gt;clientHeight()));
<span class="line-added">1242         // clientWidth/Height is the visual portion of the box content, not including</span>
<span class="line-added">1243         // borders or scroll bars, but includes padding. And per</span>
<span class="line-added">1244         // https://www.w3.org/TR/CSS2/tables.html#model,</span>
<span class="line-added">1245         // table wrapper box is a principal block box that contains the table box</span>
<span class="line-added">1246         // itself and any caption boxes, and table grid box is a block-level box that</span>
<span class="line-added">1247         // contains the table&#39;s internal table boxes. When table&#39;s border is specified</span>
<span class="line-added">1248         // in CSS, the border is added to table grid box, not table wrapper box.</span>
<span class="line-added">1249         // Currently, WebKit doesn&#39;t have table wrapper box, and we are supposed to</span>
<span class="line-added">1250         // retrieve clientWidth/Height from table wrapper box, not table grid box. So</span>
<span class="line-added">1251         // when we retrieve clientWidth/Height, it includes table&#39;s border size.</span>
<span class="line-added">1252         if (renderer-&gt;isTable())</span>
<span class="line-added">1253             clientHeight += renderer-&gt;borderTop() + renderer-&gt;borderBottom();</span>
1254         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientHeight, *renderer).toDouble(), renderer-&gt;document());
1255     }
1256     return 0;
1257 }
1258 
1259 ALWAYS_INLINE Frame* Element::documentFrameWithNonNullView() const
1260 {
1261     auto* frame = document().frame();
1262     return frame &amp;&amp; frame-&gt;view() ? frame : nullptr;
1263 }
1264 
1265 int Element::scrollLeft()
1266 {
1267     document().updateLayoutIgnorePendingStylesheets();
1268 
1269     if (document().scrollingElement() == this) {
1270         if (auto* frame = documentFrameWithNonNullView())
1271             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().x(), *frame);
1272         return 0;
1273     }
</pre>
<hr />
<pre>
1761             AtomString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());
1762             if (newId != oldId) {
1763                 Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
1764                 elementData()-&gt;setIdForStyleResolution(newId);
1765             }
1766 
1767             if (!oldValue.isEmpty())
1768                 treeScope().idTargetObserverRegistry().notifyObservers(*oldValue.impl());
1769             if (!newValue.isEmpty())
1770                 treeScope().idTargetObserverRegistry().notifyObservers(*newValue.impl());
1771         } else if (name == HTMLNames::nameAttr)
1772             elementData()-&gt;setHasNameAttribute(!newValue.isNull());
1773         else if (name == HTMLNames::pseudoAttr) {
1774             if (needsStyleInvalidation() &amp;&amp; isInShadowTree())
1775                 invalidateStyleForSubtree();
1776         } else if (name == HTMLNames::slotAttr) {
1777             if (auto* parent = parentElement()) {
1778                 if (auto* shadowRoot = parent-&gt;shadowRoot())
1779                     shadowRoot-&gt;hostChildElementDidChangeSlotAttribute(*this, oldValue, newValue);
1780             }
<span class="line-added">1781         } else if (name == HTMLNames::partAttr)</span>
<span class="line-added">1782             partAttributeChanged(newValue);</span>
<span class="line-added">1783         else if (name == HTMLNames::exportpartsAttr) {</span>
<span class="line-added">1784             if (auto* shadowRoot = this-&gt;shadowRoot()) {</span>
<span class="line-added">1785                 shadowRoot-&gt;invalidatePartMappings();</span>
<span class="line-added">1786                 Style::Invalidator::invalidateShadowParts(*shadowRoot);</span>
<span class="line-added">1787             }</span>
1788         }
1789     }
1790 
1791     parseAttribute(name, newValue);
1792 
1793     document().incDOMTreeVersion();
1794 
1795     if (UNLIKELY(isDefinedCustomElement()))
1796         CustomElementReactionQueue::enqueueAttributeChangedCallbackIfNeeded(*this, name, oldValue, newValue);
1797 
1798     if (valueIsSameAsBefore)
1799         return;
1800 
1801     invalidateNodeListAndCollectionCachesInAncestorsForAttribute(name);
1802 
1803     if (AXObjectCache* cache = document().existingAXObjectCache())
1804         cache-&gt;deferAttributeChangeIfNeeded(name, this);
1805 }
1806 
1807 template &lt;typename CharacterType&gt;
<span class="line-modified">1808 static inline bool isNonEmptyTokenList(const CharacterType* characters, unsigned length)</span>
1809 {
1810     ASSERT(length &gt; 0);
1811 
1812     unsigned i = 0;
1813     do {
1814         if (isNotHTMLSpace(characters[i]))
1815             break;
1816         ++i;
1817     } while (i &lt; length);
1818 
1819     return i &lt; length;
1820 }
1821 
<span class="line-modified">1822 static inline bool isNonEmptyTokenList(const AtomString&amp; stringValue)</span>
1823 {
<span class="line-modified">1824     unsigned length = stringValue.length();</span>
1825 
1826     if (!length)
1827         return false;
1828 
<span class="line-modified">1829     if (stringValue.is8Bit())</span>
<span class="line-modified">1830         return isNonEmptyTokenList(stringValue.characters8(), length);</span>
<span class="line-modified">1831     return isNonEmptyTokenList(stringValue.characters16(), length);</span>
1832 }
1833 
1834 void Element::classAttributeChanged(const AtomString&amp; newClassString)
1835 {
1836     // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
1837     if (!elementData())
1838         ensureUniqueElementData();
1839 
1840     bool shouldFoldCase = document().inQuirksMode();
<span class="line-modified">1841     bool newStringHasClasses = isNonEmptyTokenList(newClassString);</span>
1842 
1843     auto oldClassNames = elementData()-&gt;classNames();
1844     auto newClassNames = newStringHasClasses ? SpaceSplitString(newClassString, shouldFoldCase) : SpaceSplitString();
1845     {
1846         Style::ClassChangeInvalidation styleInvalidation(*this, oldClassNames, newClassNames);
1847         elementData()-&gt;setClassNames(newClassNames);
1848     }
1849 
1850     if (hasRareData()) {
1851         if (auto* classList = elementRareData()-&gt;classList())
1852             classList-&gt;associatedAttributeValueChanged(newClassString);
1853     }
1854 }
1855 
<span class="line-added">1856 void Element::partAttributeChanged(const AtomString&amp; newValue)</span>
<span class="line-added">1857 {</span>
<span class="line-added">1858     if (!RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())</span>
<span class="line-added">1859         return;</span>
<span class="line-added">1860 </span>
<span class="line-added">1861     bool hasParts = isNonEmptyTokenList(newValue);</span>
<span class="line-added">1862     if (hasParts || !partNames().isEmpty()) {</span>
<span class="line-added">1863         auto newParts = hasParts ? SpaceSplitString(newValue, false) : SpaceSplitString();</span>
<span class="line-added">1864         ensureElementRareData().setPartNames(WTFMove(newParts));</span>
<span class="line-added">1865     }</span>
<span class="line-added">1866 </span>
<span class="line-added">1867     if (hasRareData()) {</span>
<span class="line-added">1868         if (auto* partList = elementRareData()-&gt;partList())</span>
<span class="line-added">1869             partList-&gt;associatedAttributeValueChanged(newValue);</span>
<span class="line-added">1870     }</span>
<span class="line-added">1871 </span>
<span class="line-added">1872     if (needsStyleInvalidation() &amp;&amp; isInShadowTree())</span>
<span class="line-added">1873         invalidateStyleInternal();</span>
<span class="line-added">1874 }</span>
<span class="line-added">1875 </span>
1876 URL Element::absoluteLinkURL() const
1877 {
1878     if (!isLink())
1879         return URL();
1880 
1881     AtomString linkAttribute;
1882     if (hasTagName(SVGNames::aTag))
1883         linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
1884     else
1885         linkAttribute = getAttribute(HTMLNames::hrefAttr);
1886 
1887     if (linkAttribute.isEmpty())
1888         return URL();
1889 
1890     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(linkAttribute));
1891 }
1892 
1893 #if ENABLE(TOUCH_EVENTS)
<span class="line-added">1894 </span>
1895 bool Element::allowsDoubleTapGesture() const
1896 {
1897 #if ENABLE(POINTER_EVENTS)
1898     if (renderStyle() &amp;&amp; renderStyle()-&gt;touchActions() != TouchAction::Auto)
1899         return false;
1900 #endif
1901 
1902     Element* parent = parentElement();
1903     return !parent || parent-&gt;allowsDoubleTapGesture();
1904 }
<span class="line-added">1905 </span>
1906 #endif
1907 
<span class="line-modified">1908 Style::Resolver&amp; Element::styleResolver()</span>
1909 {
1910     if (auto* shadowRoot = containingShadowRoot())
1911         return shadowRoot-&gt;styleScope().resolver();
1912 
1913     return document().styleScope().resolver();
1914 }
1915 
<span class="line-modified">1916 Style::ElementStyle Element::resolveStyle(const RenderStyle* parentStyle)</span>
1917 {
1918     return styleResolver().styleForElement(*this, parentStyle);
1919 }
1920 
1921 static void invalidateForSiblingCombinators(Element* sibling)
1922 {
1923     for (; sibling; sibling = sibling-&gt;nextElementSibling()) {
1924         if (sibling-&gt;styleIsAffectedByPreviousSibling())
1925             sibling-&gt;invalidateStyleInternal();
1926         if (sibling-&gt;descendantsAffectedByPreviousSibling()) {
1927             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
1928                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
1929         }
1930         if (!sibling-&gt;affectsNextSiblingElementStyle())
1931             return;
1932     }
1933 }
1934 
1935 static void invalidateSiblingsIfNeeded(Element&amp; element)
1936 {
</pre>
<hr />
<pre>
2098     return m_tagName.toString();
2099 }
2100 
2101 ExceptionOr&lt;void&gt; Element::setPrefix(const AtomString&amp; prefix)
2102 {
2103     auto result = checkSetPrefix(prefix);
2104     if (result.hasException())
2105         return result.releaseException();
2106 
2107     m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
2108     return { };
2109 }
2110 
2111 const AtomString&amp; Element::imageSourceURL() const
2112 {
2113     return attributeWithoutSynchronization(srcAttr);
2114 }
2115 
2116 bool Element::rendererIsNeeded(const RenderStyle&amp; style)
2117 {
<span class="line-modified">2118     return rendererIsEverNeeded() &amp;&amp; style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;</span>
2119 }
2120 
2121 RenderPtr&lt;RenderElement&gt; Element::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
2122 {
2123     return RenderElement::createFor(*this, WTFMove(style));
2124 }
2125 
2126 Node::InsertedIntoAncestorResult Element::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
2127 {
2128     ContainerNode::insertedIntoAncestor(insertionType, parentOfInsertedTree);
2129 
2130 #if ENABLE(FULLSCREEN_API)
2131     if (containsFullScreenElement() &amp;&amp; parentElement() &amp;&amp; !parentElement()-&gt;containsFullScreenElement())
2132         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
2133 #endif
2134 
2135     if (parentNode() == &amp;parentOfInsertedTree) {
2136         if (auto* shadowRoot = parentNode()-&gt;shadowRoot())
2137             shadowRoot-&gt;hostChildElementDidChange(*this);
2138     }
</pre>
<hr />
<pre>
2237         if (removalType.disconnectedFromDocument &amp;&amp; UNLIKELY(isDefinedCustomElement()))
2238             CustomElementReactionQueue::enqueueDisconnectedCallbackIfNeeded(*this);
2239     }
2240 
2241     if (!parentNode()) {
2242         if (auto* shadowRoot = oldParentOfRemovedTree.shadowRoot())
2243             shadowRoot-&gt;hostChildElementDidChange(*this);
2244     }
2245 
2246     clearBeforePseudoElement();
2247     clearAfterPseudoElement();
2248 
2249     ContainerNode::removedFromAncestor(removalType, oldParentOfRemovedTree);
2250 
2251     if (hasPendingResources())
2252         document().accessSVGExtensions().removeElementFromPendingResources(*this);
2253 
2254     RefPtr&lt;Frame&gt; frame = document().frame();
2255     if (auto* timeline = document().existingTimeline())
2256         timeline-&gt;elementWasRemoved(*this);
<span class="line-added">2257 </span>
2258     if (frame)
2259         frame-&gt;animation().cancelAnimations(*this);
2260 
2261 #if PLATFORM(MAC)
2262     if (frame &amp;&amp; frame-&gt;page())
2263         frame-&gt;page()-&gt;removeLatchingStateForTarget(*this);
2264 #endif
2265 
2266     if (hasRareData() &amp;&amp; elementRareData()-&gt;hasElementIdentifier()) {
2267         document().identifiedElementWasRemovedFromDocument(*this);
2268         elementRareData()-&gt;setHasElementIdentifier(false);
2269     }
2270 }
2271 
2272 ShadowRoot* Element::shadowRoot() const
2273 {
2274     return hasRareData() ? elementRareData()-&gt;shadowRoot() : nullptr;
2275 }
2276 
2277 void Element::addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp; newShadowRoot)
2278 {
2279     ASSERT(!newShadowRoot-&gt;hasChildNodes());
2280     ASSERT(!shadowRoot());
2281 
2282     ShadowRoot&amp; shadowRoot = newShadowRoot;
2283     {
<span class="line-added">2284         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;</span>
2285         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2286         if (renderer())
2287             RenderTreeUpdater::tearDownRenderers(*this);
2288 
2289         ensureElementRareData().setShadowRoot(WTFMove(newShadowRoot));
2290 
2291         shadowRoot.setHost(this);
2292         shadowRoot.setParentTreeScope(treeScope());
2293 
<span class="line-modified">2294 #if ASSERT_ENABLED</span>
2295         ASSERT(notifyChildNodeInserted(*this, shadowRoot).isEmpty());
2296 #else
2297         notifyChildNodeInserted(*this, shadowRoot);
2298 #endif
2299 
2300         invalidateStyleAndRenderersForSubtree();
2301     }
2302 
2303     if (shadowRoot.mode() == ShadowRootMode::UserAgent)
2304         didAddUserAgentShadowRoot(shadowRoot);
2305 
2306     InspectorInstrumentation::didPushShadowRoot(*this, shadowRoot);
2307 }
2308 
2309 void Element::removeShadowRoot()
2310 {
2311     RefPtr&lt;ShadowRoot&gt; oldRoot = shadowRoot();
2312     if (!oldRoot)
2313         return;
2314 
</pre>
<hr />
<pre>
2323     oldRoot-&gt;setParentTreeScope(document());
2324 }
2325 
2326 static bool canAttachAuthorShadowRoot(const Element&amp; element)
2327 {
2328     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {
2329         static const HTMLQualifiedName* const tagList[] = {
2330             &amp;articleTag.get(),
2331             &amp;asideTag.get(),
2332             &amp;blockquoteTag.get(),
2333             &amp;bodyTag.get(),
2334             &amp;divTag.get(),
2335             &amp;footerTag.get(),
2336             &amp;h1Tag.get(),
2337             &amp;h2Tag.get(),
2338             &amp;h3Tag.get(),
2339             &amp;h4Tag.get(),
2340             &amp;h5Tag.get(),
2341             &amp;h6Tag.get(),
2342             &amp;headerTag.get(),
<span class="line-added">2343             &amp;mainTag.get(),</span>
2344             &amp;navTag.get(),
2345             &amp;pTag.get(),
2346             &amp;sectionTag.get(),
2347             &amp;spanTag.get()
2348         };
2349         HashSet&lt;AtomString&gt; set;
2350         for (auto&amp; name : tagList)
2351             set.add(name-&gt;localName());
2352         return set;
2353     }();
2354 
2355     if (!is&lt;HTMLElement&gt;(element))
2356         return false;
2357 
2358     const auto&amp; localName = element.localName();
2359     return tagNames.get().contains(localName) || Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid;
2360 }
2361 
2362 ExceptionOr&lt;ShadowRoot&amp;&gt; Element::attachShadow(const ShadowRootInit&amp; init)
2363 {
2364     if (!canAttachAuthorShadowRoot(*this))
2365         return Exception { NotSupportedError };
2366     if (shadowRoot())
<span class="line-modified">2367         return Exception { NotSupportedError };</span>
2368     if (init.mode == ShadowRootMode::UserAgent)
2369         return Exception { TypeError };
<span class="line-modified">2370     auto shadow = ShadowRoot::create(document(), init.mode, init.delegatesFocus ? ShadowRoot::DelegatesFocus::Yes : ShadowRoot::DelegatesFocus::No);</span>
2371     auto&amp; result = shadow.get();
2372     addShadowRoot(WTFMove(shadow));
2373     return result;
2374 }
2375 
<span class="line-modified">2376 ShadowRoot* Element::shadowRootForBindings(JSC::JSGlobalObject&amp; lexicalGlobalObject) const</span>
2377 {
2378     auto* shadow = shadowRoot();
2379     if (!shadow)
2380         return nullptr;
2381     if (shadow-&gt;mode() == ShadowRootMode::Open)
2382         return shadow;
<span class="line-modified">2383     if (JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)-&gt;world().shadowRootIsAlwaysOpen())</span>
2384         return shadow;
2385     return nullptr;
2386 }
2387 
2388 RefPtr&lt;ShadowRoot&gt; Element::userAgentShadowRoot() const
2389 {
2390     ASSERT(!shadowRoot() || shadowRoot()-&gt;mode() == ShadowRootMode::UserAgent);
2391     return shadowRoot();
2392 }
2393 
2394 ShadowRoot&amp; Element::ensureUserAgentShadowRoot()
2395 {
2396     if (auto shadow = userAgentShadowRoot())
2397         return *shadow;
2398     auto newShadow = ShadowRoot::create(document(), ShadowRootMode::UserAgent);
2399     ShadowRoot&amp; shadow = newShadow;
2400     addShadowRoot(WTFMove(newShadow));
2401     return shadow;
2402 }
2403 
</pre>
<hr />
<pre>
2622 void Element::removeAllEventListeners()
2623 {
2624     ContainerNode::removeAllEventListeners();
2625     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot())
2626         shadowRoot-&gt;removeAllEventListeners();
2627 }
2628 
2629 void Element::beginParsingChildren()
2630 {
2631     clearIsParsingChildrenFinished();
2632 }
2633 
2634 void Element::finishParsingChildren()
2635 {
2636     ContainerNode::finishParsingChildren();
2637     setIsParsingChildrenFinished();
2638     checkForSiblingStyleChanges(*this, FinishedParsingChildren, ElementTraversal::lastChild(*this), nullptr);
2639 }
2640 
2641 #if ENABLE(TREE_DEBUGGING)
<span class="line-added">2642 </span>
2643 void Element::formatForDebugger(char* buffer, unsigned length) const
2644 {
2645     StringBuilder result;
2646     String s;
2647 
2648     result.append(nodeName());
2649 
2650     s = getIdAttribute();
2651     if (s.length() &gt; 0) {
2652         if (result.length() &gt; 0)
2653             result.appendLiteral(&quot;; &quot;);
2654         result.appendLiteral(&quot;id=&quot;);
2655         result.append(s);
2656     }
2657 
2658     s = getAttribute(classAttr);
2659     if (s.length() &gt; 0) {
2660         if (result.length() &gt; 0)
2661             result.appendLiteral(&quot;; &quot;);
2662         result.appendLiteral(&quot;class=&quot;);
2663         result.append(s);
2664     }
2665 
2666     strncpy(buffer, result.toString().utf8().data(), length - 1);
2667 }
<span class="line-added">2668 </span>
2669 #endif
2670 
2671 const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; Element::attrNodeList()
2672 {
2673     ASSERT(hasSyntheticAttrChildNodes());
2674     return *attrNodeListForElement(*this);
2675 }
2676 
2677 void Element::attachAttributeNodeIfNeeded(Attr&amp; attrNode)
2678 {
2679     ASSERT(!attrNode.ownerElement() || attrNode.ownerElement() == this);
2680     if (attrNode.ownerElement() == this)
2681         return;
2682 
2683     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2684 
2685     attrNode.attachToElement(*this);
2686     ensureAttrNodeListForElement(*this).append(&amp;attrNode);
2687 }
2688 
</pre>
<hr />
<pre>
2900     return ensureAttr(attribute-&gt;name());
2901 }
2902 
2903 bool Element::hasAttribute(const AtomString&amp; qualifiedName) const
2904 {
2905     if (!elementData())
2906         return false;
2907     synchronizeAttribute(qualifiedName);
2908     return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2909 }
2910 
2911 bool Element::hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const
2912 {
2913     if (!elementData())
2914         return false;
2915     QualifiedName qName(nullAtom(), localName, namespaceURI);
2916     synchronizeAttribute(qName);
2917     return elementData()-&gt;findAttributeByName(qName);
2918 }
2919 
<span class="line-added">2920 static RefPtr&lt;ShadowRoot&gt; shadowRootWithDelegatesFocus(const Element&amp; element)</span>
<span class="line-added">2921 {</span>
<span class="line-added">2922     if (auto* root = element.shadowRoot()) {</span>
<span class="line-added">2923         if (root-&gt;delegatesFocus())</span>
<span class="line-added">2924             return root;</span>
<span class="line-added">2925     }</span>
<span class="line-added">2926     return nullptr;</span>
<span class="line-added">2927 }</span>
<span class="line-added">2928 </span>
<span class="line-added">2929 static bool isProgramaticallyFocusable(Element&amp; element)</span>
<span class="line-added">2930 {</span>
<span class="line-added">2931     ScriptDisallowedScope::InMainThread scriptDisallowedScope;</span>
<span class="line-added">2932 </span>
<span class="line-added">2933     if (shadowRootWithDelegatesFocus(element))</span>
<span class="line-added">2934         return false;</span>
<span class="line-added">2935 </span>
<span class="line-added">2936     // If the stylesheets have already been loaded we can reliably check isFocusable.</span>
<span class="line-added">2937     // If not, we continue and set the focused node on the focus controller below so that it can be updated soon after attach.</span>
<span class="line-added">2938     if (element.document().haveStylesheetsLoaded()) {</span>
<span class="line-added">2939         if (!element.isFocusable())</span>
<span class="line-added">2940             return false;</span>
<span class="line-added">2941     }</span>
<span class="line-added">2942     return element.supportsFocus();</span>
<span class="line-added">2943 }</span>
<span class="line-added">2944 </span>
<span class="line-added">2945 static RefPtr&lt;Element&gt; findFirstProgramaticallyFocusableElementInComposedTree(Element&amp; host)</span>
<span class="line-added">2946 {</span>
<span class="line-added">2947     ASSERT(host.shadowRoot());</span>
<span class="line-added">2948     for (auto&amp; node : composedTreeDescendants(host)) {</span>
<span class="line-added">2949         if (!is&lt;Element&gt;(node))</span>
<span class="line-added">2950             continue;</span>
<span class="line-added">2951         auto&amp; element = downcast&lt;Element&gt;(node);</span>
<span class="line-added">2952         if (isProgramaticallyFocusable(element))</span>
<span class="line-added">2953             return &amp;element;</span>
<span class="line-added">2954     }</span>
<span class="line-added">2955     return nullptr;</span>
<span class="line-added">2956 }</span>
<span class="line-added">2957 </span>
2958 void Element::focus(bool restorePreviousSelection, FocusDirection direction)
2959 {
2960     if (!isConnected())
2961         return;
2962 
<span class="line-modified">2963     auto document = makeRef(this-&gt;document());</span>
<span class="line-modified">2964     if (document-&gt;focusedElement() == this) {</span>
<span class="line-modified">2965         if (document-&gt;page())</span>
<span class="line-modified">2966             document-&gt;page()-&gt;chrome().client().elementDidRefocus(*this);</span>
2967         return;
2968     }
2969 
<span class="line-modified">2970     RefPtr&lt;Element&gt; newTarget = this;</span>
<span class="line-modified">2971     if (document-&gt;haveStylesheetsLoaded())</span>
<span class="line-modified">2972         document-&gt;updateStyleIfNeeded();</span>
<span class="line-modified">2973 </span>
<span class="line-modified">2974     if (&amp;newTarget-&gt;document() != document.ptr())</span>
<span class="line-modified">2975         return;</span>
<span class="line-added">2976 </span>
<span class="line-added">2977     if (auto root = shadowRootWithDelegatesFocus(*this)) {</span>
<span class="line-added">2978         auto currentlyFocusedElement = makeRefPtr(document-&gt;focusedElement());</span>
<span class="line-added">2979         if (root-&gt;containsIncludingShadowDOM(currentlyFocusedElement.get())) {</span>
<span class="line-added">2980             if (document-&gt;page())</span>
<span class="line-added">2981                 document-&gt;page()-&gt;chrome().client().elementDidRefocus(*currentlyFocusedElement);</span>
2982             return;
<span class="line-modified">2983         }</span>
2984 
<span class="line-modified">2985         newTarget = findFirstProgramaticallyFocusableElementInComposedTree(*this);</span>
<span class="line-added">2986         if (!newTarget)</span>
<span class="line-added">2987             return;</span>
<span class="line-added">2988     } else if (!isProgramaticallyFocusable(*newTarget))</span>
2989         return;
2990 
<span class="line-modified">2991     if (Page* page = document-&gt;page()) {</span>
<span class="line-modified">2992         auto&amp; frame = *document-&gt;frame();</span>
<span class="line-modified">2993         if (!frame.hasHadUserInteraction() &amp;&amp; !frame.isMainFrame() &amp;&amp; !document-&gt;topDocument().securityOrigin().canAccess(document-&gt;securityOrigin()))</span>

2994             return;
2995 
2996         // Focus and change event handlers can cause us to lose our last ref.
2997         // If a focus event handler changes the focus to a different node it
2998         // does not make sense to continue and update appearence.
<span class="line-modified">2999         if (!page-&gt;focusController().setFocusedElement(newTarget.get(), *document-&gt;frame(), direction))</span>

3000             return;
3001     }
3002 
3003     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<span class="line-added">3004 </span>
3005 #if PLATFORM(IOS_FAMILY)
3006     // Focusing a form element triggers animation in UIKit to scroll to the right position.
3007     // Calling updateFocusAppearance() would generate an unnecessary call to ScrollView::setScrollPosition(),
3008     // which would jump us around during this animation. See &lt;rdar://problem/6699741&gt;.
<span class="line-modified">3009     if (is&lt;HTMLFormControlElement&gt;(newTarget))</span>

3010         revealMode = SelectionRevealMode::RevealUpToMainFrame;
3011 #endif
3012 
3013     auto target = focusAppearanceUpdateTarget();
3014     if (!target)
3015         return;
3016 
3017     target-&gt;updateFocusAppearance(restorePreviousSelection ? SelectionRestorationMode::Restore : SelectionRestorationMode::SetDefault, revealMode);
3018 }
3019 
<span class="line-added">3020 // https://html.spec.whatwg.org/#focus-processing-model</span>
3021 RefPtr&lt;Element&gt; Element::focusAppearanceUpdateTarget()
3022 {
3023     return this;
3024 }
3025 
3026 void Element::updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode revealMode)
3027 {
3028     if (isRootEditableElement()) {
3029         // Keep frame alive in this method, since setSelection() may release the last reference to |frame|.
3030         RefPtr&lt;Frame&gt; frame = document().frame();
3031         if (!frame)
3032             return;
3033 
3034         // When focusing an editable element in an iframe, don&#39;t reset the selection if it already contains a selection.
3035         if (this == frame-&gt;selection().selection().rootEditableElement())
3036             return;
3037 
3038         // FIXME: We should restore the previous selection if there is one.
3039         VisibleSelection newSelection = VisibleSelection(firstPositionInOrBeforeNode(this), DOWNSTREAM);
3040 
</pre>
<hr />
<pre>
3514 }
3515 
3516 bool Element::shouldAppearIndeterminate() const
3517 {
3518     return false;
3519 }
3520 
3521 bool Element::mayCauseRepaintInsideViewport(const IntRect* visibleRect) const
3522 {
3523     return renderer() &amp;&amp; renderer()-&gt;mayCauseRepaintInsideViewport(visibleRect);
3524 }
3525 
3526 DOMTokenList&amp; Element::classList()
3527 {
3528     ElementRareData&amp; data = ensureElementRareData();
3529     if (!data.classList())
3530         data.setClassList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));
3531     return *data.classList();
3532 }
3533 
<span class="line-added">3534 SpaceSplitString Element::partNames() const</span>
<span class="line-added">3535 {</span>
<span class="line-added">3536     return hasRareData() ? elementRareData()-&gt;partNames() : SpaceSplitString();</span>
<span class="line-added">3537 }</span>
<span class="line-added">3538 </span>
<span class="line-added">3539 DOMTokenList&amp; Element::part()</span>
<span class="line-added">3540 {</span>
<span class="line-added">3541     auto&amp; data = ensureElementRareData();</span>
<span class="line-added">3542     if (!data.partList())</span>
<span class="line-added">3543         data.setPartList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::partAttr));</span>
<span class="line-added">3544     return *data.partList();</span>
<span class="line-added">3545 }</span>
<span class="line-added">3546 </span>
3547 DatasetDOMStringMap&amp; Element::dataset()
3548 {
3549     ElementRareData&amp; data = ensureElementRareData();
3550     if (!data.dataset())
3551         data.setDataset(makeUnique&lt;DatasetDOMStringMap&gt;(*this));
3552     return *data.dataset();
3553 }
3554 
3555 URL Element::getURLAttribute(const QualifiedName&amp; name) const
3556 {
<span class="line-modified">3557 #if ASSERT_ENABLED</span>
3558     if (elementData()) {
3559         if (const Attribute* attribute = findAttributeByName(name))
3560             ASSERT(isURLAttribute(*attribute));
3561     }
3562 #endif
3563     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(getAttribute(name)));
3564 }
3565 
3566 URL Element::getNonEmptyURLAttribute(const QualifiedName&amp; name) const
3567 {
<span class="line-modified">3568 #if ASSERT_ENABLED</span>
3569     if (elementData()) {
3570         if (const Attribute* attribute = findAttributeByName(name))
3571             ASSERT(isURLAttribute(*attribute));
3572     }
3573 #endif
3574     String value = stripLeadingAndTrailingHTMLSpaces(getAttribute(name));
3575     if (value.isEmpty())
3576         return URL();
3577     return document().completeURL(value);
3578 }
3579 
3580 int Element::getIntegralAttribute(const QualifiedName&amp; attributeName) const
3581 {
3582     return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
3583 }
3584 
3585 void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
3586 {
3587     setAttribute(attributeName, AtomString::number(value));
3588 }
</pre>
<hr />
<pre>
3592     return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
3593 }
3594 
3595 void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
3596 {
3597     setAttribute(attributeName, AtomString::number(limitToOnlyHTMLNonNegative(value)));
3598 }
3599 
3600 bool Element::childShouldCreateRenderer(const Node&amp; child) const
3601 {
3602     // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
3603     if (child.isSVGElement()) {
3604         ASSERT(!isSVGElement());
3605         const SVGElement&amp; childElement = downcast&lt;SVGElement&gt;(child);
3606         return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
3607     }
3608     return true;
3609 }
3610 
3611 #if ENABLE(FULLSCREEN_API)
<span class="line-added">3612 </span>
3613 static Element* parentCrossingFrameBoundaries(const Element* element)
3614 {
3615     ASSERT(element);
3616     if (auto* parent = element-&gt;parentElementInComposedTree())
3617         return parent;
3618     return element-&gt;document().ownerElement();
3619 }
3620 
3621 void Element::webkitRequestFullscreen()
3622 {
3623     document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::EnforceIFrameAllowFullscreenRequirement);
3624 }
3625 
3626 bool Element::containsFullScreenElement() const
3627 {
3628     return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
3629 }
3630 
3631 void Element::setContainsFullScreenElement(bool flag)
3632 {
3633     ensureElementRareData().setContainsFullScreenElement(flag);
3634     invalidateStyleAndLayerComposition();
3635 }
3636 
3637 void Element::setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool flag)
3638 {
3639     Element* element = this;
3640     while ((element = parentCrossingFrameBoundaries(element)))
3641         element-&gt;setContainsFullScreenElement(flag);
3642 }
<span class="line-added">3643 </span>
3644 #endif
3645 
3646 #if ENABLE(POINTER_EVENTS)
<span class="line-added">3647 </span>
3648 ExceptionOr&lt;void&gt; Element::setPointerCapture(int32_t pointerId)
3649 {
3650     if (document().page())
3651         return document().page()-&gt;pointerCaptureController().setPointerCapture(this, pointerId);
3652     return { };
3653 }
3654 
3655 ExceptionOr&lt;void&gt; Element::releasePointerCapture(int32_t pointerId)
3656 {
3657     if (document().page())
3658         return document().page()-&gt;pointerCaptureController().releasePointerCapture(this, pointerId);
3659     return { };
3660 }
3661 
3662 bool Element::hasPointerCapture(int32_t pointerId)
3663 {
3664     if (document().page())
3665         return document().page()-&gt;pointerCaptureController().hasPointerCapture(this, pointerId);
3666     return false;
3667 }
<span class="line-added">3668 </span>
3669 #endif
3670 
3671 #if ENABLE(POINTER_LOCK)
<span class="line-added">3672 </span>
3673 void Element::requestPointerLock()
3674 {
3675     if (document().page())
3676         document().page()-&gt;pointerLockController().requestPointerLock(this);
3677 }
<span class="line-added">3678 </span>
3679 #endif
3680 
3681 #if ENABLE(INTERSECTION_OBSERVER)
<span class="line-added">3682 </span>
3683 void Element::disconnectFromIntersectionObservers()
3684 {
3685     auto* observerData = intersectionObserverData();
3686     if (!observerData)
3687         return;
3688 
3689     for (const auto&amp; registration : observerData-&gt;registrations)
3690         registration.observer-&gt;targetDestroyed(*this);
3691     observerData-&gt;registrations.clear();
3692 
3693     for (const auto&amp; observer : observerData-&gt;observers)
3694         observer-&gt;rootDestroyed();
3695     observerData-&gt;observers.clear();
3696 }
3697 
3698 IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
3699 {
3700     auto&amp; rareData = ensureElementRareData();
3701     if (!rareData.intersectionObserverData())
3702         rareData.setIntersectionObserverData(makeUnique&lt;IntersectionObserverData&gt;());
3703     return *rareData.intersectionObserverData();
3704 }
3705 
3706 IntersectionObserverData* Element::intersectionObserverData()
3707 {
3708     return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
3709 }
<span class="line-added">3710 </span>
3711 #endif
3712 
<span class="line-added">3713 KeyframeEffectStack* Element::keyframeEffectStack() const</span>
<span class="line-added">3714 {</span>
<span class="line-added">3715     return hasRareData() ? elementRareData()-&gt;keyframeEffectStack() : nullptr;</span>
<span class="line-added">3716 }</span>
<span class="line-added">3717 </span>
<span class="line-added">3718 KeyframeEffectStack&amp; Element::ensureKeyframeEffectStack()</span>
<span class="line-added">3719 {</span>
<span class="line-added">3720     auto&amp; rareData = ensureElementRareData();</span>
<span class="line-added">3721     if (!rareData.keyframeEffectStack())</span>
<span class="line-added">3722         rareData.setKeyframeEffectStack(makeUnique&lt;KeyframeEffectStack&gt;());</span>
<span class="line-added">3723     return *rareData.keyframeEffectStack();</span>
<span class="line-added">3724 }</span>
<span class="line-added">3725 </span>
<span class="line-added">3726 bool Element::hasKeyframeEffects() const</span>
<span class="line-added">3727 {</span>
<span class="line-added">3728     if (!hasRareData())</span>
<span class="line-added">3729         return false;</span>
<span class="line-added">3730 </span>
<span class="line-added">3731     auto* keyframeEffectStack = elementRareData()-&gt;keyframeEffectStack();</span>
<span class="line-added">3732     return keyframeEffectStack &amp;&amp; keyframeEffectStack-&gt;hasEffects();</span>
<span class="line-added">3733 }</span>
<span class="line-added">3734 </span>
<span class="line-added">3735 OptionSet&lt;AnimationImpact&gt; Element::applyKeyframeEffects(RenderStyle&amp; targetStyle)</span>
<span class="line-added">3736 {</span>
<span class="line-added">3737     OptionSet&lt;AnimationImpact&gt; impact;</span>
<span class="line-added">3738 </span>
<span class="line-added">3739     for (const auto&amp; effect : ensureKeyframeEffectStack().sortedEffects()) {</span>
<span class="line-added">3740         ASSERT(effect-&gt;animation());</span>
<span class="line-added">3741         effect-&gt;animation()-&gt;resolve(targetStyle);</span>
<span class="line-added">3742 </span>
<span class="line-added">3743         if (effect-&gt;isRunningAccelerated() || effect-&gt;isAboutToRunAccelerated())</span>
<span class="line-added">3744             impact.add(AnimationImpact::RequiresRecomposite);</span>
<span class="line-added">3745 </span>
<span class="line-added">3746         if (effect-&gt;triggersStackingContext())</span>
<span class="line-added">3747             impact.add(AnimationImpact::ForcesStackingContext);</span>
<span class="line-added">3748     }</span>
<span class="line-added">3749 </span>
<span class="line-added">3750     return impact;</span>
<span class="line-added">3751 }</span>
<span class="line-added">3752 </span>
3753 #if ENABLE(RESIZE_OBSERVER)
<span class="line-added">3754 </span>
3755 void Element::disconnectFromResizeObservers()
3756 {
3757     auto* observerData = resizeObserverData();
3758     if (!observerData)
3759         return;
3760 
3761     for (const auto&amp; observer : observerData-&gt;observers)
3762         observer-&gt;targetDestroyed(*this);
3763     observerData-&gt;observers.clear();
3764 }
3765 
3766 ResizeObserverData&amp; Element::ensureResizeObserverData()
3767 {
3768     auto&amp; rareData = ensureElementRareData();
3769     if (!rareData.resizeObserverData())
3770         rareData.setResizeObserverData(makeUnique&lt;ResizeObserverData&gt;());
3771     return *rareData.resizeObserverData();
3772 }
3773 
3774 ResizeObserverData* Element::resizeObserverData()
3775 {
3776     return hasRareData() ? elementRareData()-&gt;resizeObserverData() : nullptr;
3777 }

3778 
<span class="line-modified">3779 #endif</span>










3780 
3781 bool Element::isSpellCheckingEnabled() const
3782 {
<span class="line-modified">3783     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parentOrShadowHostElement()) {</span>
<span class="line-modified">3784         auto&amp; value = ancestor-&gt;attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
<span class="line-modified">3785         if (value.isNull())</span>
<span class="line-added">3786             continue;</span>
<span class="line-added">3787         if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))</span>
3788             return true;
<span class="line-modified">3789         if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))</span>
3790             return false;



3791     }

3792     return true;
3793 }
3794 
<span class="line-modified">3795 #if ASSERT_ENABLED</span>
3796 bool Element::fastAttributeLookupAllowed(const QualifiedName&amp; name) const
3797 {
3798     if (name == HTMLNames::styleAttr)
3799         return false;
3800 
3801     if (isSVGElement())
3802         return !downcast&lt;SVGElement&gt;(*this).isAnimatedPropertyAttribute(name);
3803 
3804     return true;
3805 }
3806 #endif
3807 
3808 #if DUMP_NODE_STATISTICS
3809 bool Element::hasNamedNodeMap() const
3810 {
3811     return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
3812 }
3813 #endif
3814 
3815 inline void Element::updateName(const AtomString&amp; oldName, const AtomString&amp; newName)
</pre>
<hr />
<pre>
4091 void Element::willAttachRenderers()
4092 {
4093     ASSERT(hasCustomStyleResolveCallbacks());
4094 }
4095 
4096 void Element::didAttachRenderers()
4097 {
4098     ASSERT(hasCustomStyleResolveCallbacks());
4099 }
4100 
4101 void Element::willDetachRenderers()
4102 {
4103     ASSERT(hasCustomStyleResolveCallbacks());
4104 }
4105 
4106 void Element::didDetachRenderers()
4107 {
4108     ASSERT(hasCustomStyleResolveCallbacks());
4109 }
4110 
<span class="line-modified">4111 Optional&lt;Style::ElementStyle&gt; Element::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle*)</span>
4112 {
4113     ASSERT(hasCustomStyleResolveCallbacks());
4114     return WTF::nullopt;
4115 }
4116 
4117 void Element::cloneAttributesFromElement(const Element&amp; other)
4118 {
4119     if (hasSyntheticAttrChildNodes())
4120         detachAllAttrNodesFromElement();
4121 
4122     other.synchronizeAllAttributes();
4123     if (!other.m_elementData) {
4124         m_elementData = nullptr;
4125         return;
4126     }
4127 
4128     // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
4129     // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
4130     ASSERT(!isConnected());
4131 
</pre>
<hr />
<pre>
4338     if (!isLink())
4339         return nullptr;
4340 
4341     const AtomString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);
4342     if (href.isNull())
4343         return nullptr;
4344 
4345     Document&amp; document = this-&gt;document();
4346     URL url = document.completeURL(href);
4347     if (!url.isValid())
4348         return nullptr;
4349 
4350     if (url.hasFragmentIdentifier() &amp;&amp; equalIgnoringFragmentIdentifier(url, document.baseURL())) {
4351         outAnchorName = url.fragmentIdentifier();
4352         return document.findAnchor(outAnchorName);
4353     }
4354 
4355     return nullptr;
4356 }
4357 
<span class="line-modified">4358 ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)</span>
4359 {
4360     String id = &quot;&quot;;
4361     Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt; keyframeEffectOptions;
4362     if (options) {
4363         auto optionsValue = options.value();
4364         Variant&lt;double, KeyframeEffectOptions&gt; keyframeEffectOptionsVariant;
4365         if (WTF::holds_alternative&lt;double&gt;(optionsValue))
4366             keyframeEffectOptionsVariant = WTF::get&lt;double&gt;(optionsValue);
4367         else {
4368             auto keyframeEffectOptions = WTF::get&lt;KeyframeAnimationOptions&gt;(optionsValue);
4369             id = keyframeEffectOptions.id;
4370             keyframeEffectOptionsVariant = WTFMove(keyframeEffectOptions);
4371         }
4372         keyframeEffectOptions = keyframeEffectOptionsVariant;
4373     }
4374 
<span class="line-modified">4375     auto keyframeEffectResult = KeyframeEffect::create(lexicalGlobalObject, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));</span>
4376     if (keyframeEffectResult.hasException())
4377         return keyframeEffectResult.releaseException();
4378 
4379     auto animation = WebAnimation::create(document(), &amp;keyframeEffectResult.returnValue().get());
4380     animation-&gt;setId(id);
4381 
4382     auto animationPlayResult = animation-&gt;play();
4383     if (animationPlayResult.hasException())
4384         return animationPlayResult.releaseException();
4385 
4386     return animation;
4387 }
4388 
<span class="line-modified">4389 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations(Optional&lt;GetAnimationsOptions&gt; options)</span>
<span class="line-modified">4390 {</span>
<span class="line-modified">4391     // If we are to return animations in the subtree, we can get all of the document&#39;s animations and filter</span>
<span class="line-added">4392     // animations targeting that are not registered on this element, one of its pseudo elements or a child&#39;s</span>
<span class="line-added">4393     // pseudo element.</span>
<span class="line-added">4394     if (options &amp;&amp; options-&gt;subtree) {</span>
<span class="line-added">4395         Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;</span>
<span class="line-added">4396         for (auto&amp; animation : document().getAnimations()) {</span>
<span class="line-added">4397             auto* effect = animation-&gt;effect();</span>
<span class="line-added">4398             ASSERT(is&lt;KeyframeEffect&gt;(animation-&gt;effect()));</span>
<span class="line-added">4399             auto* target = downcast&lt;KeyframeEffect&gt;(*effect).target();</span>
<span class="line-added">4400             ASSERT(target);</span>
<span class="line-added">4401             if (is&lt;PseudoElement&gt;(target)) {</span>
<span class="line-added">4402                 if (contains(downcast&lt;PseudoElement&gt;(*target).hostElement()))</span>
<span class="line-added">4403                     animations.append(animation);</span>
<span class="line-added">4404             } else if (contains(target))</span>
<span class="line-added">4405                 animations.append(animation);</span>
<span class="line-added">4406         }</span>
<span class="line-added">4407         return animations;</span>
<span class="line-added">4408     }</span>
4409 
4410     // For the list of animations to be current, we need to account for any pending CSS changes,
4411     // such as updates to CSS Animations and CSS Transitions.
4412     // FIXME: We might be able to use ComputedStyleExtractor which is more optimized.
4413     document().updateStyleIfNeeded();
4414 
4415     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
4416     if (auto timeline = document().existingTimeline()) {
4417         for (auto&amp; animation : timeline-&gt;animationsForElement(*this, AnimationTimeline::Ordering::Sorted)) {
4418             if (animation-&gt;isRelevant())
4419                 animations.append(animation);
4420         }
4421     }
4422     return animations;
4423 }
4424 
4425 ElementIdentifier Element::createElementIdentifier()
4426 {
4427     auto&amp; rareData = ensureElementRareData();
4428     ASSERT(!rareData.hasElementIdentifier());
4429 
4430     rareData.setHasElementIdentifier(true);
4431     return ElementIdentifier::generate();
4432 }
4433 
4434 #if ENABLE(CSS_TYPED_OM)
<span class="line-added">4435 </span>
4436 StylePropertyMap* Element::attributeStyleMap()
4437 {
4438     if (!hasRareData())
4439         return nullptr;
4440     return elementRareData()-&gt;attributeStyleMap();
4441 }
4442 
4443 void Element::setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map)
4444 {
4445     ensureElementRareData().setAttributeStyleMap(WTFMove(map));
4446 }
<span class="line-added">4447 </span>
4448 #endif
4449 
4450 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DocumentStorageAccess.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPreserveVariableLifetimes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLPreserveVariableLifetimes.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLAST.h&quot;
 32 #include &quot;WHLSLASTDumper.h&quot;
 33 #include &quot;WHLSLLexer.h&quot;
 34 #include &quot;WHLSLProgram.h&quot;
 35 #include &quot;WHLSLReplaceWith.h&quot;
 36 #include &quot;WHLSLVisitor.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 namespace WHLSL {
 41 
 42 // This pass works by ensuring proper variable lifetimes. In WHLSL, each variable
 43 // has global lifetime. So returning a pointer to a local variable is a totally
 44 // legitimate and well-specified thing to do.
 45 //
 46 // We implement this by:
 47 // - We note every variable whose address we take.
 48 // - Each such variable gets defined as a field in a struct.
 49 // - Each function which is an entry point defines this struct.
 50 // - Each non entry point takes a pointer to this struct as its final parameter.
 51 // - Each call to a non-native function is rewritten to pass a pointer to the
 52 //   struct as the last call argument.
 53 // - Each variable reference to &quot;x&quot;, where &quot;x&quot; ends up in the struct, is
 54 //   modified to instead be &quot;struct-&gt;x&quot;. We store to &quot;struct-&gt;x&quot; after declaring
 55 //   &quot;x&quot;. If &quot;x&quot; is a function parameter, we store to &quot;struct-&gt;x&quot; as the first
 56 //   thing we do in the function body.
 57 
 58 class EscapedVariableCollector final : public Visitor {
 59     using Base = Visitor;
 60 public:
 61 
 62     void escapeVariableUse(AST::Expression&amp; expression)
 63     {
 64         if (!is&lt;AST::VariableReference&gt;(expression)) {
 65             // FIXME: Are we missing any interesting productions here?
 66             // https://bugs.webkit.org/show_bug.cgi?id=198311
 67             Base::visit(expression);
 68             return;
 69         }
 70 
 71         auto* variable = downcast&lt;AST::VariableReference&gt;(expression).variable();
 72         ASSERT(variable);
 73         // FIXME: We could skip this if we mark all internal variables with a bit, since we
 74         // never make any internal variable escape the current scope it is defined in:
 75         // https://bugs.webkit.org/show_bug.cgi?id=198383
 76         m_escapedVariables.add(variable, makeString(&quot;_&quot;, variable-&gt;name(), &quot;_&quot;, m_count++));
 77     }
 78 
 79     void visit(AST::MakePointerExpression&amp; makePointerExpression) override
 80     {
 81         if (makePointerExpression.mightEscape())
 82             escapeVariableUse(makePointerExpression.leftValue());
 83     }
 84 
 85     void visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression) override
 86     {
 87         if (makeArrayReferenceExpression.mightEscape())
 88             escapeVariableUse(makeArrayReferenceExpression.leftValue());
 89     }
 90 
 91     void visit(AST::FunctionDefinition&amp; functionDefinition) override
 92     {
 93         if (functionDefinition.parsingMode() != ParsingMode::StandardLibrary)
 94             Base::visit(functionDefinition);
 95     }
 96 
 97     HashMap&lt;AST::VariableDeclaration*, String&gt; takeEscapedVariables() { return WTFMove(m_escapedVariables); }
 98 
 99 private:
100     size_t m_count { 1 };
101     HashMap&lt;AST::VariableDeclaration*, String&gt; m_escapedVariables;
102 };
103 
104 static ALWAYS_INLINE Token anonymousToken(Token::Type type)
105 {
106     return Token { { }, type };
107 }
108 
109 class PreserveLifetimes : public Visitor {
110     using Base = Visitor;
111 public:
112     PreserveLifetimes(Ref&lt;AST::TypeReference&gt; structType, const HashMap&lt;AST::VariableDeclaration*, AST::StructureElement*&gt;&amp; variableMapping)
113         : m_structType(WTFMove(structType))
114         , m_pointerToStructType(AST::PointerType::create(anonymousToken(Token::Type::Identifier), AST::AddressSpace::Thread, m_structType.copyRef()))
115         , m_variableMapping(variableMapping)
116     { }
117 
118     UniqueRef&lt;AST::VariableReference&gt; makeStructVariableReference()
119     {
120         auto structVariableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*m_structVariable));
121         structVariableReference-&gt;setType(*m_structVariable-&gt;type());
122         structVariableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
123         return structVariableReference;
124     }
125 
126     UniqueRef&lt;AST::AssignmentExpression&gt; assignVariableIntoStruct(AST::VariableDeclaration&amp; variable, AST::StructureElement* element)
127     {
128         auto lhs = makeUniqueRef&lt;AST::GlobalVariableReference&gt;(variable.codeLocation(), makeStructVariableReference(), element);
129         lhs-&gt;setType(*variable.type());
130         lhs-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
131 
132         auto rhs = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variable));
133         rhs-&gt;setType(*variable.type());
134         rhs-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
135 
136         auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(variable.codeLocation(), WTFMove(lhs), WTFMove(rhs));
137         assignment-&gt;setType(*variable.type());
138         assignment-&gt;setTypeAnnotation(AST::RightValue());
139 
140         return assignment;
141     }
142 
143     void visit(AST::FunctionDefinition&amp; functionDefinition) override
144     {
145         if (functionDefinition.parsingMode() == ParsingMode::StandardLibrary)
146             return;
147 
148         bool isEntryPoint = !!functionDefinition.entryPointType();
149         if (isEntryPoint) {
150             auto structVariableDeclaration = makeUniqueRef&lt;AST::VariableDeclaration&gt;(functionDefinition.codeLocation(), AST::Qualifiers(),
151                 m_structType.copyRef(), String(), nullptr, nullptr);
152 
153             auto structVariableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(structVariableDeclaration));
154             structVariableReference-&gt;setType(m_structType.copyRef());
155             structVariableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
156 
157             AST::VariableDeclarations structVariableDeclarations;
158             structVariableDeclarations.append(WTFMove(structVariableDeclaration));
159             auto structDeclarationStatement = makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.codeLocation(), WTFMove(structVariableDeclarations));
160 
161             std::unique_ptr&lt;AST::Expression&gt; makePointerExpression(new AST::MakePointerExpression(functionDefinition.codeLocation(), WTFMove(structVariableReference), AST::AddressEscapeMode::DoesNotEscape));
162             makePointerExpression-&gt;setType(m_pointerToStructType.copyRef());
163             makePointerExpression-&gt;setTypeAnnotation(AST::RightValue());
164 
165             auto pointerDeclaration = makeUniqueRef&lt;AST::VariableDeclaration&gt;(functionDefinition.codeLocation(), AST::Qualifiers(),
166                 m_pointerToStructType.copyRef(), &quot;wrapper&quot;_s, nullptr, WTFMove(makePointerExpression));
167             m_structVariable = &amp;pointerDeclaration;
168 
169             AST::VariableDeclarations pointerVariableDeclarations;
170             pointerVariableDeclarations.append(WTFMove(pointerDeclaration));
171             auto pointerDeclarationStatement = makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.codeLocation(), WTFMove(pointerVariableDeclarations));
172 
173             functionDefinition.block().statements().insert(0, WTFMove(structDeclarationStatement));
174             functionDefinition.block().statements().insert(1, WTFMove(pointerDeclarationStatement));
175         } else {
176             auto pointerDeclaration = makeUniqueRef&lt;AST::VariableDeclaration&gt;(functionDefinition.codeLocation(), AST::Qualifiers(),
177                 m_pointerToStructType.copyRef(), &quot;wrapper&quot;_s, nullptr, nullptr);
178             m_structVariable = &amp;pointerDeclaration;
179             functionDefinition.parameters().append(WTFMove(pointerDeclaration));
180         }
181 
182         Base::visit(functionDefinition);
183 
184         for (auto&amp; parameter : functionDefinition.parameters()) {
185             auto iter = m_variableMapping.find(&amp;parameter);
186             if (iter == m_variableMapping.end())
187                 continue;
188 
189             functionDefinition.block().statements().insert(isEntryPoint ? 2 : 0,
190                 makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(assignVariableIntoStruct(parameter, iter-&gt;value)));
191         }
192 
193         // Inner functions are not allowed in WHLSL. So this is fine.
194         m_structVariable = nullptr;
195     }
196 
197     void visit(AST::CallExpression&amp; callExpression) override
198     {
199         RELEASE_ASSERT(m_structVariable);
200 
201         Base::visit(callExpression);
202 
203         // This works because it&#39;s illegal to call an entrypoint. Therefore, we can only
204         // call functions where we&#39;ve already appended this struct as its final parameter.
205         if (!callExpression.function().isNativeFunctionDeclaration() &amp;&amp; callExpression.function().parsingMode() != ParsingMode::StandardLibrary)
206             callExpression.arguments().append(makeStructVariableReference());
207     }
208 
209     void visit(AST::VariableReference&amp; variableReference) override
210     {
211         RELEASE_ASSERT(m_structVariable);
212 
213         auto iter = m_variableMapping.find(variableReference.variable());
214         if (iter == m_variableMapping.end())
215             return;
216 
217         Ref&lt;AST::UnnamedType&gt; type = *variableReference.variable()-&gt;type();
218         AST::TypeAnnotation typeAnnotation = variableReference.typeAnnotation();
219         auto* internalField = AST::replaceWith&lt;AST::GlobalVariableReference&gt;(variableReference, variableReference.codeLocation(), makeStructVariableReference(), iter-&gt;value);
220         internalField-&gt;setType(WTFMove(type));
221         internalField-&gt;setTypeAnnotation(WTFMove(typeAnnotation));
222     }
223 
224     void visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) override
225     {
226         RELEASE_ASSERT(m_structVariable);
227 
228         Base::visit(variableDeclarationsStatement);
229 
230         AST::Statements statements;
231         for (UniqueRef&lt;AST::VariableDeclaration&gt;&amp; variableDeclaration : variableDeclarationsStatement.variableDeclarations()) {
232             AST::VariableDeclaration&amp; variable = variableDeclaration.get();
233 
234             {
235                 AST::VariableDeclarations declarations;
236                 declarations.append(WTFMove(variableDeclaration));
237                 statements.append(makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(variable.codeLocation(), WTFMove(declarations)));
238             }
239 
240             auto iter = m_variableMapping.find(&amp;variable);
241             if (iter != m_variableMapping.end())
242                 statements.append(makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(assignVariableIntoStruct(variable, iter-&gt;value)));
243         }
244 
245         AST::replaceWith&lt;AST::StatementList&gt;(variableDeclarationsStatement, variableDeclarationsStatement.codeLocation(), WTFMove(statements));
246     }
247 
248 private:
249     AST::VariableDeclaration* m_structVariable { nullptr };
250 
251     Ref&lt;AST::TypeReference&gt; m_structType;
252     Ref&lt;AST::PointerType&gt; m_pointerToStructType;
253     // If this mapping contains the variable, it means that the variable&#39;s canonical location
254     // is in the struct we use to preserve variable lifetimes.
255     const HashMap&lt;AST::VariableDeclaration*, AST::StructureElement*&gt;&amp; m_variableMapping;
256 };
257 
258 void preserveVariableLifetimes(Program&amp; program)
259 {
260     HashMap&lt;AST::VariableDeclaration*, String&gt; escapedVariables;
261     {
262         EscapedVariableCollector collector;
263         for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
264             collector.visit(program.functionDefinitions()[i]);
265         escapedVariables = collector.takeEscapedVariables();
266     }
267 
268     AST::StructureElements elements;
269     for (auto&amp; pair : escapedVariables) {
270         auto* variable = pair.key;
271         String name = pair.value;
272         elements.append(AST::StructureElement { variable-&gt;codeLocation(), { }, *variable-&gt;type(), WTFMove(name), nullptr });
273     }
274 
275     // Name of this doesn&#39;t matter, since we don&#39;t use struct names when
276     // generating Metal type names. We just pick something here to make it
277     // easy to read in AST dumps.
278     auto wrapperStructDefinition = makeUniqueRef&lt;AST::StructureDefinition&gt;(anonymousToken(Token::Type::Struct), &quot;__WrapperStruct__&quot;_s, WTFMove(elements));
279 
280     HashMap&lt;AST::VariableDeclaration*, AST::StructureElement*&gt; variableMapping;
281     unsigned index = 0;
282     for (auto&amp; pair : escapedVariables)
283         variableMapping.add(pair.key, &amp;wrapperStructDefinition-&gt;structureElements()[index++]);
284 
285     {
286         auto wrapperStructType = AST::TypeReference::wrap(anonymousToken(Token::Type::Identifier), wrapperStructDefinition);
287         PreserveLifetimes preserveLifetimes(WTFMove(wrapperStructType), variableMapping);
288         preserveLifetimes.Visitor::visit(program);
289     }
290 
291     program.structureDefinitions().append(WTFMove(wrapperStructDefinition));
292 }
293 
294 } // namespace WHLSL
295 
296 } // namespace WebCore
297 
298 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>
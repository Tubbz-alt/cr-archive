diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp
@@ -26,10 +26,11 @@
 
 #include "config.h"
 #include "MIMETypeRegistry.h"
 
 #include "MediaPlayer.h"
+#include "ThreadGlobalData.h"
 #include <wtf/HashMap.h>
 #include <wtf/MainThread.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/StdLibExtras.h>
 
@@ -73,10 +74,11 @@
         "image/tiff"_s,
         "image/gif"_s,
         "image/jpeg"_s,
         "image/vnd.microsoft.icon"_s,
         "image/jp2"_s,
+        "image/apng"_s,
         "image/png"_s,
         "image/bmp"_s,
 
         "image/x-icon"_s, // Favicons don't have a MIME type in the registry either.
         "image/pjpeg"_s, //  We only get one MIME type per UTI, hence our need to add these manually
@@ -133,10 +135,13 @@
         "image/gif"_s,
         "image/bmp"_s,
         "image/vnd.microsoft.icon"_s, // ico
         "image/x-icon"_s, // ico
         "image/x-xbitmap"_s, // xbm
+#if ENABLE(APNG)
+        "image/apng"_s,
+#endif
 #if USE(OPENJPEG)
         "image/jp2"_s,
         "image/jpeg2000"_s,
 #endif
 #if USE(WEBP)
@@ -164,51 +169,10 @@
 {
     static NeverDestroyed<HashSet<String, ASCIICaseInsensitiveHash>> additionalSupportedImageMIMETypes;
     return additionalSupportedImageMIMETypes;
 }
 
-static const HashSet<String, ASCIICaseInsensitiveHash>& supportedImageMIMETypesForEncoding()
-{
-#if PLATFORM(COCOA)
-    static const auto supportedImageMIMETypesForEncoding = makeNeverDestroyed([] {
-        RetainPtr<CFArrayRef> supportedTypes = adoptCF(CGImageDestinationCopyTypeIdentifiers());
-        HashSet<String, ASCIICaseInsensitiveHash> supportedImageMIMETypesForEncoding;
-        CFIndex count = CFArrayGetCount(supportedTypes.get());
-        for (CFIndex i = 0; i < count; i++) {
-            CFStringRef supportedType = reinterpret_cast<CFStringRef>(CFArrayGetValueAtIndex(supportedTypes.get(), i));
-            String mimeType = MIMETypeForImageType(supportedType);
-            if (!mimeType.isEmpty())
-                supportedImageMIMETypesForEncoding.add(mimeType);
-        }
-        return supportedImageMIMETypesForEncoding;
-    }());
-#else
-    static NeverDestroyed<HashSet<String, ASCIICaseInsensitiveHash>> supportedImageMIMETypesForEncoding =std::initializer_list<String> {
-#if USE(CG) || USE(DIRECT2D)
-        // FIXME: Add Windows support for all the supported UTI's when a way to convert from MIMEType to UTI reliably is found.
-        // For now, only support PNG, JPEG and GIF. See <rdar://problem/6095286>.
-        "image/png"_s,
-        "image/jpeg"_s,
-        "image/gif"_s,
-#elif PLATFORM(JAVA)
-        "image/png"_s,
-        "image/jpeg"_s,
-        "image/bmp"_s,
-#elif PLATFORM(GTK)
-        "image/png"_s,
-        "image/jpeg"_s,
-        "image/tiff"_s,
-        "image/bmp"_s,
-        "image/ico"_s,
-#elif USE(CAIRO)
-        "image/png"_s,
-#endif
-    };
-#endif
-    return supportedImageMIMETypesForEncoding;
-}
-
 static const HashSet<String, ASCIICaseInsensitiveHash>& supportedJavaScriptMIMETypes()
 {
     static NeverDestroyed<HashSet<String, ASCIICaseInsensitiveHash>> supportedJavaScriptMIMETypes = std::initializer_list<String> {
         // https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type
         "text/javascript"_s,
@@ -308,102 +272,108 @@
 #endif
     };
     return unsupportedTextMIMETypes;
 }
 
-static const Vector<String>* typesForCommonExtension(const String& extension)
-{
-    static const auto map = makeNeverDestroyed([] {
-        struct TypeExtensionPair {
-            ASCIILiteral type;
-            ASCIILiteral extension;
-        };
-
-        // A table of common media MIME types and file extentions used when a platform's
-        // specific MIME type lookup doesn't have a match for a media file extension.
-        static const TypeExtensionPair commonMediaTypes[] = {
-            // Ogg
-            { "application/ogg"_s, "ogx"_s },
-            { "audio/ogg"_s, "ogg"_s },
-            { "audio/ogg"_s, "oga"_s },
-            { "video/ogg"_s, "ogv"_s },
-
-            // Annodex
-            { "application/annodex"_s, "anx"_s },
-            { "audio/annodex"_s, "axa"_s },
-            { "video/annodex"_s, "axv"_s },
-            { "audio/speex"_s, "spx"_s },
-
-            // WebM
-            { "video/webm"_s, "webm"_s },
-            { "audio/webm"_s, "webm"_s },
-
-            // MPEG
-            { "audio/mpeg"_s, "m1a"_s },
-            { "audio/mpeg"_s, "m2a"_s },
-            { "audio/mpeg"_s, "m1s"_s },
-            { "audio/mpeg"_s, "mpa"_s },
-            { "video/mpeg"_s, "mpg"_s },
-            { "video/mpeg"_s, "m15"_s },
-            { "video/mpeg"_s, "m1s"_s },
-            { "video/mpeg"_s, "m1v"_s },
-            { "video/mpeg"_s, "m75"_s },
-            { "video/mpeg"_s, "mpa"_s },
-            { "video/mpeg"_s, "mpeg"_s },
-            { "video/mpeg"_s, "mpm"_s },
-            { "video/mpeg"_s, "mpv"_s },
-
-            // MPEG playlist
-            { "application/vnd.apple.mpegurl"_s, "m3u8"_s },
-            { "application/mpegurl"_s, "m3u8"_s },
-            { "application/x-mpegurl"_s, "m3u8"_s },
-            { "audio/mpegurl"_s, "m3url"_s },
-            { "audio/x-mpegurl"_s, "m3url"_s },
-            { "audio/mpegurl"_s, "m3u"_s },
-            { "audio/x-mpegurl"_s, "m3u"_s },
-
-            // MPEG-4
-            { "video/x-m4v"_s, "m4v"_s },
-            { "audio/x-m4a"_s, "m4a"_s },
-            { "audio/x-m4b"_s, "m4b"_s },
-            { "audio/x-m4p"_s, "m4p"_s },
-            { "audio/mp4"_s, "m4a"_s },
-
-            // MP3
-            { "audio/mp3"_s, "mp3"_s },
-            { "audio/x-mp3"_s, "mp3"_s },
-            { "audio/x-mpeg"_s, "mp3"_s },
-
-            // MPEG-2
-            { "video/x-mpeg2"_s, "mp2"_s },
-            { "video/mpeg2"_s, "vob"_s },
-            { "video/mpeg2"_s, "mod"_s },
-            { "video/m2ts"_s, "m2ts"_s },
-            { "video/x-m2ts"_s, "m2t"_s },
-            { "video/x-m2ts"_s, "ts"_s },
-
-            // 3GP/3GP2
-            { "audio/3gpp"_s, "3gpp"_s },
-            { "audio/3gpp2"_s, "3g2"_s },
-            { "application/x-mpeg"_s, "amc"_s },
-
-            // AAC
-            { "audio/aac"_s, "aac"_s },
-            { "audio/aac"_s, "adts"_s },
-            { "audio/x-aac"_s, "m4r"_s },
-
-            // CoreAudio File
-            { "audio/x-caf"_s, "caf"_s },
-            { "audio/x-gsm"_s, "gsm"_s },
-
-            // ADPCM
-            { "audio/x-wav"_s, "wav"_s },
-            { "audio/vnd.wave"_s, "wav"_s },
-        };
+Optional<HashMap<String, Vector<String>, ASCIICaseInsensitiveHash>>& overriddenMimeTypesMap()
+{
+    static NeverDestroyed<Optional<HashMap<String, Vector<String>, ASCIICaseInsensitiveHash>>> map;
+    return map;
+}
+
+const std::initializer_list<TypeExtensionPair>& commonMediaTypes()
+{
+    // A table of common media MIME types and file extensions used when a platform's
+    // specific MIME type lookup doesn't have a match for a media file extension.
+    static std::initializer_list<TypeExtensionPair> commonMediaTypes = {
+        // Ogg
+        { "application/ogg"_s, "ogx"_s },
+        { "audio/ogg"_s, "ogg"_s },
+        { "audio/ogg"_s, "oga"_s },
+        { "video/ogg"_s, "ogv"_s },
+
+        // Annodex
+        { "application/annodex"_s, "anx"_s },
+        { "audio/annodex"_s, "axa"_s },
+        { "video/annodex"_s, "axv"_s },
+        { "audio/speex"_s, "spx"_s },
+
+        // WebM
+        { "video/webm"_s, "webm"_s },
+        { "audio/webm"_s, "webm"_s },
+
+        // MPEG
+        { "audio/mpeg"_s, "m1a"_s },
+        { "audio/mpeg"_s, "m2a"_s },
+        { "audio/mpeg"_s, "m1s"_s },
+        { "audio/mpeg"_s, "mpa"_s },
+        { "video/mpeg"_s, "mpg"_s },
+        { "video/mpeg"_s, "m15"_s },
+        { "video/mpeg"_s, "m1s"_s },
+        { "video/mpeg"_s, "m1v"_s },
+        { "video/mpeg"_s, "m75"_s },
+        { "video/mpeg"_s, "mpa"_s },
+        { "video/mpeg"_s, "mpeg"_s },
+        { "video/mpeg"_s, "mpm"_s },
+        { "video/mpeg"_s, "mpv"_s },
+
+        // MPEG playlist
+        { "application/vnd.apple.mpegurl"_s, "m3u8"_s },
+        { "application/mpegurl"_s, "m3u8"_s },
+        { "application/x-mpegurl"_s, "m3u8"_s },
+        { "audio/mpegurl"_s, "m3url"_s },
+        { "audio/x-mpegurl"_s, "m3url"_s },
+        { "audio/mpegurl"_s, "m3u"_s },
+        { "audio/x-mpegurl"_s, "m3u"_s },
+
+        // MPEG-4
+        { "video/x-m4v"_s, "m4v"_s },
+        { "audio/x-m4a"_s, "m4a"_s },
+        { "audio/x-m4b"_s, "m4b"_s },
+        { "audio/x-m4p"_s, "m4p"_s },
+        { "audio/mp4"_s, "m4a"_s },
+
+        // MP3
+        { "audio/mp3"_s, "mp3"_s },
+        { "audio/x-mp3"_s, "mp3"_s },
+        { "audio/x-mpeg"_s, "mp3"_s },
+
+        // MPEG-2
+        { "video/x-mpeg2"_s, "mp2"_s },
+        { "video/mpeg2"_s, "vob"_s },
+        { "video/mpeg2"_s, "mod"_s },
+        { "video/m2ts"_s, "m2ts"_s },
+        { "video/x-m2ts"_s, "m2t"_s },
+        { "video/x-m2ts"_s, "ts"_s },
+
+        // 3GP/3GP2
+        { "audio/3gpp"_s, "3gpp"_s },
+        { "audio/3gpp2"_s, "3g2"_s },
+        { "application/x-mpeg"_s, "amc"_s },
+
+        // AAC
+        { "audio/aac"_s, "aac"_s },
+        { "audio/aac"_s, "adts"_s },
+        { "audio/x-aac"_s, "m4r"_s },
+
+        // CoreAudio File
+        { "audio/x-caf"_s, "caf"_s },
+        { "audio/x-gsm"_s, "gsm"_s },
+
+        // ADPCM
+        { "audio/x-wav"_s, "wav"_s },
+        { "audio/vnd.wave"_s, "wav"_s },
+    };
+    return commonMediaTypes;
+}
 
+const HashMap<String, Vector<String>, ASCIICaseInsensitiveHash>& commonMimeTypesMap()
+{
+    ASSERT(isMainThread());
+    static NeverDestroyed<HashMap<String, Vector<String>, ASCIICaseInsensitiveHash>> mimeTypesMap = [] {
         HashMap<String, Vector<String>, ASCIICaseInsensitiveHash> map;
-        for (auto& pair : commonMediaTypes) {
+        for (auto& pair : commonMediaTypes()) {
             ASCIILiteral type = pair.type;
             ASCIILiteral extension = pair.extension;
             map.ensure(extension, [type, extension] {
                 // First type in the vector must always be the one from getMIMETypeForExtension,
                 // so we can use the map without also calling getMIMETypeForExtension each time.
@@ -413,13 +383,24 @@
                     synonyms.append(systemType);
                 return synonyms;
             }).iterator->value.append(type);
         }
         return map;
-    }());
-    auto mapEntry = map.get().find(extension);
-    if (mapEntry == map.get().end())
+    }();
+    return mimeTypesMap;
+}
+
+static const Vector<String>* typesForCommonExtension(const String& extension)
+{
+    if (overriddenMimeTypesMap().hasValue()) {
+        auto mapEntry = overriddenMimeTypesMap()->find(extension);
+        if (mapEntry == overriddenMimeTypesMap()->end())
+            return nullptr;
+        return &mapEntry->value;
+    }
+    auto mapEntry = commonMimeTypesMap().find(extension);
+    if (mapEntry == commonMimeTypesMap().end())
         return nullptr;
     return &mapEntry->value;
 }
 
 String MIMETypeRegistry::getMediaMIMETypeForExtension(const String& extension)
@@ -465,24 +446,61 @@
 {
     if (isSupportedImageMIMEType(mimeType) || equalLettersIgnoringASCIICase(mimeType, "image/svg+xml"))
         return true;
 
 #if HAVE(AVASSETREADER)
-    if (ImageDecoderAVFObjC::supportsContentType(ContentType(mimeType)))
+    if (ImageDecoderAVFObjC::supportsContainerType(mimeType))
         return true;
 #endif
 
     return false;
 }
 
-bool MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(const String& mimeType)
+std::unique_ptr<MIMETypeRegistryThreadGlobalData> MIMETypeRegistry::createMIMETypeRegistryThreadGlobalData()
 {
-    ASSERT(isMainThread());
+#if PLATFORM(COCOA)
+    RetainPtr<CFArrayRef> supportedTypes = adoptCF(CGImageDestinationCopyTypeIdentifiers());
+    HashSet<String, ASCIICaseInsensitiveHash> supportedImageMIMETypesForEncoding;
+    CFIndex count = CFArrayGetCount(supportedTypes.get());
+    for (CFIndex i = 0; i < count; i++) {
+        CFStringRef supportedType = reinterpret_cast<CFStringRef>(CFArrayGetValueAtIndex(supportedTypes.get(), i));
+        if (isSupportedImageType(supportedType)) {
+            String mimeType = MIMETypeForImageType(supportedType);
+            supportedImageMIMETypesForEncoding.add(mimeType);
+        }
+    }
+#else
+    HashSet<String, ASCIICaseInsensitiveHash> supportedImageMIMETypesForEncoding = std::initializer_list<String> {
+#if USE(CG) || USE(DIRECT2D)
+        // FIXME: Add Windows support for all the supported UTI's when a way to convert from MIMEType to UTI reliably is found.
+        // For now, only support PNG, JPEG and GIF. See <rdar://problem/6095286>.
+        "image/png"_s,
+        "image/jpeg"_s,
+        "image/gif"_s,
+#elif PLATFORM(JAVA)
+        "image/png"_s,
+        "image/jpeg"_s,
+        "image/bmp"_s,
+#elif PLATFORM(GTK)
+        "image/png"_s,
+        "image/jpeg"_s,
+        "image/tiff"_s,
+        "image/bmp"_s,
+        "image/ico"_s,
+#elif USE(CAIRO)
+        "image/png"_s,
+#endif
+    };
+#endif
+    return makeUnique<MIMETypeRegistryThreadGlobalData>(WTFMove(supportedImageMIMETypesForEncoding));
+}
 
+bool MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(const String& mimeType)
+{
     if (mimeType.isEmpty())
         return false;
-    return supportedImageMIMETypesForEncoding().contains(mimeType);
+    return threadGlobalData().mimeTypeRegistryThreadGlobalData().supportedImageMIMETypesForEncoding().contains(mimeType);
 }
 
 bool MIMETypeRegistry::isSupportedJavaScriptMIMEType(const String& mimeType)
 {
     if (mimeType.isEmpty())
@@ -774,16 +792,19 @@
 String MIMETypeRegistry::appendFileExtensionIfNecessary(const String& filename, const String& mimeType)
 {
     if (filename.isEmpty())
         return emptyString();
 
+    if (equalIgnoringASCIICase(mimeType, defaultMIMEType()))
+        return filename;
+
     if (filename.reverseFind('.') != notFound)
         return filename;
 
     String preferredExtension = getPreferredExtensionForMIMEType(mimeType);
     if (preferredExtension.isEmpty())
         return filename;
 
-    return filename + "." + preferredExtension;
+    return makeString(filename, '.', preferredExtension);
 }
 
 } // namespace WebCore

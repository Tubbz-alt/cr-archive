<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SliderThumbElement.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextControlInnerElements.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 78,11 ***</span>
  static inline bool isStrongPasswordTextField(const Element* element)
  {
      return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element)-&gt;hasAutoFillStrongPasswordButton();
  }
  
<span class="line-modified">! Optional&lt;ElementStyle&gt; TextControlInnerContainer::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
  {
      auto elementStyle = resolveStyle(&amp;parentStyle);
      if (isStrongPasswordTextField(shadowHost())) {
          elementStyle.renderStyle-&gt;setFlexWrap(FlexWrap::Wrap);
          elementStyle.renderStyle-&gt;setOverflowX(Overflow::Hidden);
<span class="line-new-header">--- 78,11 ---</span>
  static inline bool isStrongPasswordTextField(const Element* element)
  {
      return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element)-&gt;hasAutoFillStrongPasswordButton();
  }
  
<span class="line-modified">! Optional&lt;Style::ElementStyle&gt; TextControlInnerContainer::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
  {
      auto elementStyle = resolveStyle(&amp;parentStyle);
      if (isStrongPasswordTextField(shadowHost())) {
          elementStyle.renderStyle-&gt;setFlexWrap(FlexWrap::Wrap);
          elementStyle.renderStyle-&gt;setOverflowX(Overflow::Hidden);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,11 ***</span>
  Ref&lt;TextControlInnerElement&gt; TextControlInnerElement::create(Document&amp; document)
  {
      return adoptRef(*new TextControlInnerElement(document));
  }
  
<span class="line-modified">! Optional&lt;ElementStyle&gt; TextControlInnerElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
  {
      auto newStyle = RenderStyle::createPtr();
      newStyle-&gt;inheritFrom(*shadowHostStyle);
      newStyle-&gt;setFlexGrow(1);
      newStyle-&gt;setMinWidth(Length { 0, Fixed }); // Needed for correct shrinking.
<span class="line-new-header">--- 100,11 ---</span>
  Ref&lt;TextControlInnerElement&gt; TextControlInnerElement::create(Document&amp; document)
  {
      return adoptRef(*new TextControlInnerElement(document));
  }
  
<span class="line-modified">! Optional&lt;Style::ElementStyle&gt; TextControlInnerElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
  {
      auto newStyle = RenderStyle::createPtr();
      newStyle-&gt;inheritFrom(*shadowHostStyle);
      newStyle-&gt;setFlexGrow(1);
      newStyle-&gt;setMinWidth(Length { 0, Fixed }); // Needed for correct shrinking.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,16 ***</span>
          newStyle-&gt;setOverflowY(Overflow::Hidden);
  
          // Set &quot;flex-basis: 1em&quot;. Note that CSSPrimitiveValue::computeLengthInt() only needs the element&#39;s
          // style to calculate em lengths. Since the element might not be in a document, just pass nullptr
          // for the root element style and the render view.
<span class="line-modified">!         auto emSize = CSSPrimitiveValue::create(1, CSSPrimitiveValue::CSS_EMS);</span>
          int pixels = emSize-&gt;computeLength&lt;int&gt;(CSSToLengthConversionData { newStyle.get(), nullptr, nullptr, 1.0, false });
          newStyle-&gt;setFlexBasis(Length { pixels, Fixed });
      }
  
<span class="line-modified">!     return ElementStyle { WTFMove(newStyle) };</span>
  }
  
  // MARK: TextControlInnerTextElement
  
  inline TextControlInnerTextElement::TextControlInnerTextElement(Document&amp; document)
<span class="line-new-header">--- 120,16 ---</span>
          newStyle-&gt;setOverflowY(Overflow::Hidden);
  
          // Set &quot;flex-basis: 1em&quot;. Note that CSSPrimitiveValue::computeLengthInt() only needs the element&#39;s
          // style to calculate em lengths. Since the element might not be in a document, just pass nullptr
          // for the root element style and the render view.
<span class="line-modified">!         auto emSize = CSSPrimitiveValue::create(1, CSSUnitType::CSS_EMS);</span>
          int pixels = emSize-&gt;computeLength&lt;int&gt;(CSSToLengthConversionData { newStyle.get(), nullptr, nullptr, 1.0, false });
          newStyle-&gt;setFlexBasis(Length { pixels, Fixed });
      }
  
<span class="line-modified">!     return { WTFMove(newStyle) };</span>
  }
  
  // MARK: TextControlInnerTextElement
  
  inline TextControlInnerTextElement::TextControlInnerTextElement(Document&amp; document)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,14 ***</span>
  RenderTextControlInnerBlock* TextControlInnerTextElement::renderer() const
  {
      return downcast&lt;RenderTextControlInnerBlock&gt;(HTMLDivElement::renderer());
  }
  
<span class="line-modified">! Optional&lt;ElementStyle&gt; TextControlInnerTextElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
  {
      auto style = downcast&lt;HTMLTextFormControlElement&gt;(*shadowHost()).createInnerTextStyle(*shadowHostStyle);
<span class="line-modified">!     return ElementStyle(makeUnique&lt;RenderStyle&gt;(WTFMove(style)));</span>
  }
  
  // MARK: TextControlPlaceholderElement
  
  inline TextControlPlaceholderElement::TextControlPlaceholderElement(Document&amp; document)
<span class="line-new-header">--- 169,14 ---</span>
  RenderTextControlInnerBlock* TextControlInnerTextElement::renderer() const
  {
      return downcast&lt;RenderTextControlInnerBlock&gt;(HTMLDivElement::renderer());
  }
  
<span class="line-modified">! Optional&lt;Style::ElementStyle&gt; TextControlInnerTextElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* shadowHostStyle)</span>
  {
      auto style = downcast&lt;HTMLTextFormControlElement&gt;(*shadowHost()).createInnerTextStyle(*shadowHostStyle);
<span class="line-modified">!     return { makeUnique&lt;RenderStyle&gt;(WTFMove(style)) };</span>
  }
  
  // MARK: TextControlPlaceholderElement
  
  inline TextControlPlaceholderElement::TextControlPlaceholderElement(Document&amp; document)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,11 ***</span>
  Ref&lt;TextControlPlaceholderElement&gt; TextControlPlaceholderElement::create(Document&amp; document)
  {
      return adoptRef(*new TextControlPlaceholderElement(document));
  }
  
<span class="line-modified">! Optional&lt;ElementStyle&gt; TextControlPlaceholderElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle)</span>
  {
      auto style = resolveStyle(&amp;parentStyle);
  
      auto&amp; controlElement = downcast&lt;HTMLTextFormControlElement&gt;(*containingShadowRoot()-&gt;host());
      style.renderStyle-&gt;setDisplay(controlElement.isPlaceholderVisible() ? DisplayType::Block : DisplayType::None);
<span class="line-new-header">--- 189,11 ---</span>
  Ref&lt;TextControlPlaceholderElement&gt; TextControlPlaceholderElement::create(Document&amp; document)
  {
      return adoptRef(*new TextControlPlaceholderElement(document));
  }
  
<span class="line-modified">! Optional&lt;Style::ElementStyle&gt; TextControlPlaceholderElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle)</span>
  {
      auto style = resolveStyle(&amp;parentStyle);
  
      auto&amp; controlElement = downcast&lt;HTMLTextFormControlElement&gt;(*containingShadowRoot()-&gt;host());
      style.renderStyle-&gt;setDisplay(controlElement.isPlaceholderVisible() ? DisplayType::Block : DisplayType::None);
</pre>
<center><a href="SliderThumbElement.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextControlInnerElements.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
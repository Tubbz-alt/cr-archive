<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedRawResourceClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;CachedResource.h&quot;
 26 
 27 #include &quot;CachedResourceClient.h&quot;
 28 #include &quot;CachedResourceClientWalker.h&quot;
 29 #include &quot;CachedResourceHandle.h&quot;
 30 #include &quot;CachedResourceLoader.h&quot;
 31 #include &quot;CookieJar.h&quot;
 32 #include &quot;CrossOriginAccessControl.h&quot;
 33 #include &quot;DiagnosticLoggingClient.h&quot;
 34 #include &quot;DiagnosticLoggingKeys.h&quot;
 35 #include &quot;Document.h&quot;
 36 #include &quot;DocumentLoader.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameLoader.h&quot;
 39 #include &quot;FrameLoaderClient.h&quot;
 40 #include &quot;HTTPHeaderNames.h&quot;

 41 #include &quot;InspectorInstrumentation.h&quot;

 42 #include &quot;LoaderStrategy.h&quot;
 43 #include &quot;Logging.h&quot;
 44 #include &quot;MemoryCache.h&quot;
 45 #include &quot;PlatformStrategies.h&quot;
 46 #include &quot;ProgressTracker.h&quot;
 47 #include &quot;ResourceHandle.h&quot;
<span class="line-removed"> 48 #include &quot;SchemeRegistry.h&quot;</span>
 49 #include &quot;SecurityOrigin.h&quot;
 50 #include &quot;SubresourceLoader.h&quot;
 51 #include &lt;wtf/CompletionHandler.h&gt;
 52 #include &lt;wtf/MathExtras.h&gt;
 53 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 54 #include &lt;wtf/StdLibExtras.h&gt;
 55 #include &lt;wtf/URL.h&gt;
 56 #include &lt;wtf/Vector.h&gt;
 57 #include &lt;wtf/text/CString.h&gt;
 58 
 59 #if USE(QUICK_LOOK)
 60 #include &quot;QuickLook.h&quot;
 61 #endif
 62 
 63 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(cachedResourceLoader.isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResource::&quot; fmt, this, ##__VA_ARGS__)
 64 
 65 namespace WebCore {
 66 


 67 ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)
 68 {
 69     switch (type) {
 70     case Type::MainResource:
 71         return ResourceLoadPriority::VeryHigh;
 72     case Type::CSSStyleSheet:
 73     case Type::Script:
 74         return ResourceLoadPriority::High;
 75 #if ENABLE(SVG_FONTS)
 76     case Type::SVGFontResource:
 77 #endif
 78     case Type::MediaResource:
 79     case Type::FontResource:
 80     case Type::RawResource:
 81     case Type::Icon:
 82         return ResourceLoadPriority::Medium;
 83     case Type::ImageResource:
 84         return ResourceLoadPriority::Low;
 85 #if ENABLE(XSLT)
 86     case Type::XSLStyleSheet:
</pre>
<hr />
<pre>
109 static Seconds deadDecodedDataDeletionIntervalForResourceType(CachedResource::Type type)
110 {
111     if (type == CachedResource::Type::Script)
112         return 0_s;
113 
114     return MemoryCache::singleton().deadDecodedDataDeletionInterval();
115 }
116 
117 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, cachedResourceLeakCounter, (&quot;CachedResource&quot;));
118 
119 CachedResource::CachedResource(CachedResourceRequest&amp;&amp; request, Type type, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
120     : m_options(request.options())
121     , m_resourceRequest(request.releaseResourceRequest())
122     , m_decodedDataDeletionTimer(*this, &amp;CachedResource::destroyDecodedData, deadDecodedDataDeletionIntervalForResourceType(type))
123     , m_sessionID(sessionID)
124     , m_cookieJar(cookieJar)
125     , m_responseTimestamp(WallTime::now())
126     , m_fragmentIdentifierForRequest(request.releaseFragmentIdentifier())
127     , m_origin(request.releaseOrigin())
128     , m_initiatorName(request.initiatorName())
<span class="line-removed">129     , m_loadPriority(defaultPriorityForResourceType(type))</span>
130     , m_type(type)







131     , m_isLinkPreload(request.isLinkPreload())
132     , m_hasUnknownEncoding(request.isLinkPreload())

133     , m_ignoreForRequestCount(request.ignoreForRequestCount())
134 {
135     ASSERT(m_sessionID.isValid());
136 
137     setLoadPriority(request.priority());
138 #ifndef NDEBUG
139     cachedResourceLeakCounter.increment();
140 #endif
141 
142     // FIXME: We should have a better way of checking for Navigation loads, maybe FetchMode::Options::Navigate.
143     ASSERT(m_origin || m_type == Type::MainResource);
144 
145     if (isRequestCrossOrigin(m_origin.get(), m_resourceRequest.url(), m_options))
146         setCrossOrigin();
147 }
148 
149 // FIXME: For this constructor, we should probably mandate that the URL has no fragment identifier.
150 CachedResource::CachedResource(const URL&amp; url, Type type, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
151     : m_resourceRequest(url)
152     , m_decodedDataDeletionTimer(*this, &amp;CachedResource::destroyDecodedData, deadDecodedDataDeletionIntervalForResourceType(type))
153     , m_sessionID(sessionID)
154     , m_cookieJar(cookieJar)
155     , m_responseTimestamp(WallTime::now())
156     , m_fragmentIdentifierForRequest(CachedResourceRequest::splitFragmentIdentifierFromRequestURL(m_resourceRequest))
<span class="line-removed">157     , m_status(Cached)</span>
158     , m_type(type)










159 {
160     ASSERT(m_sessionID.isValid());
161 #ifndef NDEBUG
162     cachedResourceLeakCounter.increment();
163 #endif
164 }
165 
166 CachedResource::~CachedResource()
167 {
168     ASSERT(!m_resourceToRevalidate); // Should be true because canDelete() checks this.
169     ASSERT(canDelete());
170     ASSERT(!inCache());
171     ASSERT(!m_deleted);
172     ASSERT(url().isNull() || !allowsCaching() || MemoryCache::singleton().resourceForRequest(resourceRequest(), sessionID()) != this);
173 
174 #ifndef NDEBUG
175     m_deleted = true;
176     cachedResourceLeakCounter.decrement();
177 #endif
178 }
179 
180 void CachedResource::failBeforeStarting()
181 {
182     // FIXME: What if resources in other frames were waiting for this revalidation?
183     LOG(ResourceLoading, &quot;Cannot start loading &#39;%s&#39;&quot;, url().string().latin1().data());
184     if (allowsCaching() &amp;&amp; m_resourceToRevalidate)
185         MemoryCache::singleton().revalidationFailed(*this);
186     error(CachedResource::LoadError);
187 }
188 
189 void CachedResource::load(CachedResourceLoader&amp; cachedResourceLoader)
190 {
191     if (!cachedResourceLoader.frame()) {
192         RELEASE_LOG_IF_ALLOWED(&quot;load: No associated frame&quot;);
193         failBeforeStarting();
194         return;
195     }
196     Frame&amp; frame = *cachedResourceLoader.frame();
197 
<span class="line-modified">198     // Prevent new loads if we are in the PageCache or being added to the PageCache.</span>
199     // We query the top document because new frames may be created in pagehide event handlers
<span class="line-modified">200     // and their pageCacheState will not reflect the fact that they are about to enter page</span>
201     // cache.
202     if (auto* topDocument = frame.mainFrame().document()) {
<span class="line-modified">203         switch (topDocument-&gt;pageCacheState()) {</span>
<span class="line-modified">204         case Document::NotInPageCache:</span>
205             break;
<span class="line-modified">206         case Document::AboutToEnterPageCache:</span>
207             // Beacons are allowed to go through in &#39;pagehide&#39; event handlers.
208             if (shouldUsePingLoad(type()))
209                 break;
<span class="line-modified">210             RELEASE_LOG_IF_ALLOWED(&quot;load: About to enter page cache (frame = %p)&quot;, &amp;frame);</span>
211             failBeforeStarting();
212             return;
<span class="line-modified">213         case Document::InPageCache:</span>
<span class="line-modified">214             RELEASE_LOG_IF_ALLOWED(&quot;load: Already in page cache (frame = %p)&quot;, &amp;frame);</span>
215             failBeforeStarting();
216             return;
217         }
218     }
219 
220     FrameLoader&amp; frameLoader = frame.loader();
221     if (m_options.securityCheck == SecurityCheckPolicy::DoSecurityCheck &amp;&amp; !shouldUsePingLoad(type())) {
222         while (true) {
223             if (frameLoader.state() == FrameStateProvisional)
224                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- state is provisional (frame = %p)&quot;, &amp;frame);
225             else if (!frameLoader.activeDocumentLoader())
226                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- not active document (frame = %p)&quot;, &amp;frame);
227             else if (frameLoader.activeDocumentLoader()-&gt;isStopping())
228                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- active loader is stopping (frame = %p)&quot;, &amp;frame);
229             else
230                 break;
231             failBeforeStarting();
232             return;
233         }
234     }
235 
236     m_loading = true;
237 
238     if (isCacheValidator()) {
239         CachedResource* resourceToRevalidate = m_resourceToRevalidate;
240         ASSERT(resourceToRevalidate-&gt;canUseCacheValidator());
241         ASSERT(resourceToRevalidate-&gt;isLoaded());
242         const String&amp; lastModified = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::LastModified);
243         const String&amp; eTag = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::ETag);
244         if (!lastModified.isEmpty() || !eTag.isEmpty()) {
245             ASSERT(cachedResourceLoader.cachePolicy(type(), url()) != CachePolicyReload);
246             if (cachedResourceLoader.cachePolicy(type(), url()) == CachePolicyRevalidate)
<span class="line-modified">247                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;max-age=0&quot;);</span>
248             if (!lastModified.isEmpty())
249                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfModifiedSince, lastModified);
250             if (!eTag.isEmpty())
251                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfNoneMatch, eTag);
252         }
253     }
254 
255     if (type() == Type::LinkPrefetch)
256         m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::Purpose, &quot;prefetch&quot;);
257     m_resourceRequest.setPriority(loadPriority());
258 
259     // Navigation algorithm is setting up the request before sending it to CachedResourceLoader?CachedResource.
260     // So no need for extra fields for MainResource.
261     if (type() != Type::MainResource)
262         frameLoader.addExtraFieldsToSubresourceRequest(m_resourceRequest);
263 
264 
265     // FIXME: It&#39;s unfortunate that the cache layer and below get to know anything about fragment identifiers.
266     // We should look into removing the expectation of that knowledge from the platform network stacks.
267     ResourceRequest request(m_resourceRequest);
</pre>
<hr />
<pre>
292             if (!error.isNull()) {
293                 setResourceError(error);
294                 this-&gt;error(LoadError);
295                 InspectorInstrumentation::didFailLoading(protectedFrame.ptr(), protectedFrame-&gt;loader().activeDocumentLoader(), identifier, error);
296                 return;
297             }
298             finishLoading(nullptr);
299             NetworkLoadMetrics emptyMetrics;
300             InspectorInstrumentation::didFinishLoading(protectedFrame.ptr(), protectedFrame-&gt;loader().activeDocumentLoader(), identifier, emptyMetrics, nullptr);
301         });
302         return;
303     }
304 
305     platformStrategies()-&gt;loaderStrategy()-&gt;loadResource(frame, *this, WTFMove(request), m_options, [this, protectedThis = CachedResourceHandle&lt;CachedResource&gt;(this), frame = makeRef(frame), loggingAllowed = cachedResourceLoader.isAlwaysOnLoggingAllowed()] (RefPtr&lt;SubresourceLoader&gt;&amp;&amp; loader) {
306         m_loader = WTFMove(loader);
307         if (!m_loader) {
308             RELEASE_LOG_IF(loggingAllowed, Network, &quot;%p - CachedResource::load: Unable to create SubresourceLoader (frame = %p)&quot;, this, frame.ptr());
309             failBeforeStarting();
310             return;
311         }
<span class="line-modified">312         m_status = Pending;</span>
313     });
314 }
315 
316 void CachedResource::loadFrom(const CachedResource&amp; resource)
317 {
318     ASSERT(url() == resource.url());
319     ASSERT(type() == resource.type());
320     ASSERT(resource.status() == Status::Cached);
321 
322     if (isCrossOrigin() &amp;&amp; m_options.mode == FetchOptions::Mode::Cors) {
323         ASSERT(m_origin);
324         String errorMessage;
325         if (!WebCore::passesAccessControlCheck(resource.response(), m_options.storedCredentialsPolicy, *m_origin, errorMessage)) {
326             setResourceError(ResourceError(String(), 0, url(), errorMessage, ResourceError::Type::AccessControl));
327             return;
328         }
329     }
330 
331     setBodyDataFrom(resource);
332     setStatus(Status::Cached);
</pre>
<hr />
<pre>
379 }
380 
381 void CachedResource::cancelLoad()
382 {
383     if (!isLoading() &amp;&amp; !stillNeedsLoad())
384         return;
385 
386     auto* documentLoader = (m_loader &amp;&amp; m_loader-&gt;frame()) ? m_loader-&gt;frame()-&gt;loader().activeDocumentLoader() : nullptr;
387     if (m_options.keepAlive &amp;&amp; (!documentLoader || documentLoader-&gt;isStopping()))
388         m_error = { };
389     else
390         setStatus(LoadError);
391 
392     setLoading(false);
393     checkNotify();
394 }
395 
396 void CachedResource::finish()
397 {
398     if (!errorOccurred())
<span class="line-modified">399         m_status = Cached;</span>
400 }
401 
402 void CachedResource::setCrossOrigin()
403 {
404     ASSERT(m_options.mode != FetchOptions::Mode::SameOrigin);
405     m_responseTainting = (m_options.mode == FetchOptions::Mode::Cors) ? ResourceResponse::Tainting::Cors : ResourceResponse::Tainting::Opaque;
406 }
407 
408 bool CachedResource::isCrossOrigin() const
409 {
410     return m_responseTainting != ResourceResponse::Tainting::Basic;
411 }
412 
413 bool CachedResource::isCORSSameOrigin() const
414 {
415     // Following resource types do not use CORS
416     ASSERT(type() != Type::FontResource);
417 #if ENABLE(SVG_FONTS)
418     ASSERT(type() != Type::SVGFontResource);
419 #endif
</pre>
<hr />
<pre>
437 {
438 #if PLATFORM(COCOA)
439     if (equalLettersIgnoringASCIICase(scheme, &quot;applewebdata&quot;))
440         return true;
441 #endif
442 #if USE(SOUP)
443     if (equalLettersIgnoringASCIICase(scheme, &quot;resource&quot;))
444         return true;
445 #endif
446     return equalLettersIgnoringASCIICase(scheme, &quot;data&quot;);
447 }
448 
449 Seconds CachedResource::freshnessLifetime(const ResourceResponse&amp; response) const
450 {
451     if (!response.url().protocolIsInHTTPFamily()) {
452         StringView protocol = response.url().protocol();
453         if (!shouldCacheSchemeIndefinitely(protocol)) {
454             // Don&#39;t cache non-HTTP main resources since we can&#39;t check for freshness.
455             // FIXME: We should not cache subresources either, but when we tried this
456             // it caused performance and flakiness issues in our test infrastructure.
<span class="line-modified">457             if (m_type == Type::MainResource || SchemeRegistry::shouldAlwaysRevalidateURLScheme(protocol.toStringWithoutCopying()))</span>
458                 return 0_us;
459         }
460 
461         return Seconds::infinity();
462     }
463 
464     return computeFreshnessLifetimeForHTTPFamily(response, m_responseTimestamp);
465 }
466 
467 void CachedResource::redirectReceived(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; response, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
468 {
469     m_requestedFromNetworkingLayer = true;
470     if (response.isNull())
471         return completionHandler(WTFMove(request));
472 
473     updateRedirectChainStatus(m_redirectChainCacheStatus, response);
474     completionHandler(WTFMove(request));
475 }
476 
477 void CachedResource::setResponse(const ResourceResponse&amp; response)
478 {
479     ASSERT(m_response.type() == ResourceResponse::Type::Default);
480     m_response = response;
<span class="line-modified">481     m_varyingHeaderValues = collectVaryingRequestHeaders(cookieJar(), m_resourceRequest, m_response, sessionID());</span>
482 
483 #if ENABLE(SERVICE_WORKER)
484     if (m_response.source() == ResourceResponse::Source::ServiceWorker) {
485         m_responseTainting = m_response.tainting();
486         return;
487     }
488 #endif
489     m_response.setRedirected(m_redirectChainCacheStatus.status != RedirectChainCacheStatus::Status::NoRedirection);
490     if (m_response.tainting() == ResourceResponse::Tainting::Basic || m_response.tainting() == ResourceResponse::Tainting::Cors)
491         m_response.setTainting(m_responseTainting);
492 }
493 
494 void CachedResource::responseReceived(const ResourceResponse&amp; response)
495 {
496     setResponse(response);
497     m_responseTimestamp = WallTime::now();
498     String encoding = response.textEncodingName();
499     if (!encoding.isNull())
500         setEncoding(encoding);
501 }
</pre>
<hr />
<pre>
843 
844         if (isExpired())
845             return RevalidationDecision::YesDueToExpired;
846 
847         return RevalidationDecision::No;
848     };
849     ASSERT_NOT_REACHED();
850     return RevalidationDecision::No;
851 }
852 
853 bool CachedResource::redirectChainAllowsReuse(ReuseExpiredRedirectionOrNot reuseExpiredRedirection) const
854 {
855     return WebCore::redirectChainAllowsReuse(m_redirectChainCacheStatus, reuseExpiredRedirection);
856 }
857 
858 bool CachedResource::varyHeaderValuesMatch(const ResourceRequest&amp; request)
859 {
860     if (m_varyingHeaderValues.isEmpty())
861         return true;
862 
<span class="line-modified">863     return verifyVaryingRequestHeaders(cookieJar(), m_varyingHeaderValues, request, sessionID());</span>
864 }
865 
866 unsigned CachedResource::overheadSize() const
867 {
868     static const int kAverageClientsHashMapSize = 384;
869     return sizeof(CachedResource) + m_response.memoryUsage() + kAverageClientsHashMapSize + m_resourceRequest.url().string().length() * 2;
870 }
871 
<span class="line-removed">872 bool CachedResource::areAllClientsXMLHttpRequests() const</span>
<span class="line-removed">873 {</span>
<span class="line-removed">874     if (type() != Type::RawResource)</span>
<span class="line-removed">875         return false;</span>
<span class="line-removed">876 </span>
<span class="line-removed">877     for (auto&amp; client : m_clients) {</span>
<span class="line-removed">878         if (!client.key-&gt;isXMLHttpRequest())</span>
<span class="line-removed">879             return false;</span>
<span class="line-removed">880     }</span>
<span class="line-removed">881     return true;</span>
<span class="line-removed">882 }</span>
<span class="line-removed">883 </span>
884 void CachedResource::setLoadPriority(const Optional&lt;ResourceLoadPriority&gt;&amp; loadPriority)
885 {
886     if (loadPriority)
887         m_loadPriority = loadPriority.value();
888     else
889         m_loadPriority = defaultPriorityForResourceType(type());
890 }
891 
892 inline CachedResource::Callback::Callback(CachedResource&amp; resource, CachedResourceClient&amp; client)
893     : m_resource(resource)
894     , m_client(client)
895     , m_timer(*this, &amp;Callback::timerFired)
896 {
897     m_timer.startOneShot(0_s);
898 }
899 
900 inline void CachedResource::Callback::cancel()
901 {
902     if (m_timer.isActive())
903         m_timer.stop();
</pre>
<hr />
<pre>
914 {
915     if (!m_data)
916         return;
917 
918     if (!mayTryReplaceEncodedData())
919         return;
920 
921     // We have to do the memcmp because we can&#39;t tell if the replacement file backed data is for the
922     // same resource or if we made a second request with the same URL which gave us a different
923     // resource. We have seen this happen for cached POST resources.
924     if (m_data-&gt;size() != newBuffer.size() || memcmp(m_data-&gt;data(), newBuffer.data(), m_data-&gt;size()))
925         return;
926 
927     m_data-&gt;clear();
928     m_data-&gt;append(newBuffer);
929     didReplaceSharedBufferContents();
930 }
931 
932 #endif
933 










934 }
</pre>
</td>
<td>
<hr />
<pre>
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;CachedResource.h&quot;
 26 
 27 #include &quot;CachedResourceClient.h&quot;
 28 #include &quot;CachedResourceClientWalker.h&quot;
 29 #include &quot;CachedResourceHandle.h&quot;
 30 #include &quot;CachedResourceLoader.h&quot;
 31 #include &quot;CookieJar.h&quot;
 32 #include &quot;CrossOriginAccessControl.h&quot;
 33 #include &quot;DiagnosticLoggingClient.h&quot;
 34 #include &quot;DiagnosticLoggingKeys.h&quot;
 35 #include &quot;Document.h&quot;
 36 #include &quot;DocumentLoader.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameLoader.h&quot;
 39 #include &quot;FrameLoaderClient.h&quot;
 40 #include &quot;HTTPHeaderNames.h&quot;
<span class="line-added"> 41 #include &quot;HTTPHeaderValues.h&quot;</span>
 42 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added"> 43 #include &quot;LegacySchemeRegistry.h&quot;</span>
 44 #include &quot;LoaderStrategy.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;MemoryCache.h&quot;
 47 #include &quot;PlatformStrategies.h&quot;
 48 #include &quot;ProgressTracker.h&quot;
 49 #include &quot;ResourceHandle.h&quot;

 50 #include &quot;SecurityOrigin.h&quot;
 51 #include &quot;SubresourceLoader.h&quot;
 52 #include &lt;wtf/CompletionHandler.h&gt;
 53 #include &lt;wtf/MathExtras.h&gt;
 54 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 55 #include &lt;wtf/StdLibExtras.h&gt;
 56 #include &lt;wtf/URL.h&gt;
 57 #include &lt;wtf/Vector.h&gt;
 58 #include &lt;wtf/text/CString.h&gt;
 59 
 60 #if USE(QUICK_LOOK)
 61 #include &quot;QuickLook.h&quot;
 62 #endif
 63 
 64 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(cachedResourceLoader.isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResource::&quot; fmt, this, ##__VA_ARGS__)
 65 
 66 namespace WebCore {
 67 
<span class="line-added"> 68 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CachedResource);</span>
<span class="line-added"> 69 </span>
 70 ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)
 71 {
 72     switch (type) {
 73     case Type::MainResource:
 74         return ResourceLoadPriority::VeryHigh;
 75     case Type::CSSStyleSheet:
 76     case Type::Script:
 77         return ResourceLoadPriority::High;
 78 #if ENABLE(SVG_FONTS)
 79     case Type::SVGFontResource:
 80 #endif
 81     case Type::MediaResource:
 82     case Type::FontResource:
 83     case Type::RawResource:
 84     case Type::Icon:
 85         return ResourceLoadPriority::Medium;
 86     case Type::ImageResource:
 87         return ResourceLoadPriority::Low;
 88 #if ENABLE(XSLT)
 89     case Type::XSLStyleSheet:
</pre>
<hr />
<pre>
112 static Seconds deadDecodedDataDeletionIntervalForResourceType(CachedResource::Type type)
113 {
114     if (type == CachedResource::Type::Script)
115         return 0_s;
116 
117     return MemoryCache::singleton().deadDecodedDataDeletionInterval();
118 }
119 
120 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, cachedResourceLeakCounter, (&quot;CachedResource&quot;));
121 
122 CachedResource::CachedResource(CachedResourceRequest&amp;&amp; request, Type type, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
123     : m_options(request.options())
124     , m_resourceRequest(request.releaseResourceRequest())
125     , m_decodedDataDeletionTimer(*this, &amp;CachedResource::destroyDecodedData, deadDecodedDataDeletionIntervalForResourceType(type))
126     , m_sessionID(sessionID)
127     , m_cookieJar(cookieJar)
128     , m_responseTimestamp(WallTime::now())
129     , m_fragmentIdentifierForRequest(request.releaseFragmentIdentifier())
130     , m_origin(request.releaseOrigin())
131     , m_initiatorName(request.initiatorName())

132     , m_type(type)
<span class="line-added">133     , m_preloadResult(PreloadResult::PreloadNotReferenced)</span>
<span class="line-added">134     , m_responseTainting(ResourceResponse::Tainting::Basic)</span>
<span class="line-added">135     , m_loadPriority(defaultPriorityForResourceType(type))</span>
<span class="line-added">136     , m_status(Pending)</span>
<span class="line-added">137     , m_requestedFromNetworkingLayer(false)</span>
<span class="line-added">138     , m_inCache(false)</span>
<span class="line-added">139     , m_loading(false)</span>
140     , m_isLinkPreload(request.isLinkPreload())
141     , m_hasUnknownEncoding(request.isLinkPreload())
<span class="line-added">142     , m_switchingClientsToRevalidatedResource(false)</span>
143     , m_ignoreForRequestCount(request.ignoreForRequestCount())
144 {
145     ASSERT(m_sessionID.isValid());
146 
147     setLoadPriority(request.priority());
148 #ifndef NDEBUG
149     cachedResourceLeakCounter.increment();
150 #endif
151 
152     // FIXME: We should have a better way of checking for Navigation loads, maybe FetchMode::Options::Navigate.
153     ASSERT(m_origin || m_type == Type::MainResource);
154 
155     if (isRequestCrossOrigin(m_origin.get(), m_resourceRequest.url(), m_options))
156         setCrossOrigin();
157 }
158 
159 // FIXME: For this constructor, we should probably mandate that the URL has no fragment identifier.
160 CachedResource::CachedResource(const URL&amp; url, Type type, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
161     : m_resourceRequest(url)
162     , m_decodedDataDeletionTimer(*this, &amp;CachedResource::destroyDecodedData, deadDecodedDataDeletionIntervalForResourceType(type))
163     , m_sessionID(sessionID)
164     , m_cookieJar(cookieJar)
165     , m_responseTimestamp(WallTime::now())
166     , m_fragmentIdentifierForRequest(CachedResourceRequest::splitFragmentIdentifierFromRequestURL(m_resourceRequest))

167     , m_type(type)
<span class="line-added">168     , m_preloadResult(PreloadResult::PreloadNotReferenced)</span>
<span class="line-added">169     , m_responseTainting(ResourceResponse::Tainting::Basic)</span>
<span class="line-added">170     , m_status(Cached)</span>
<span class="line-added">171     , m_requestedFromNetworkingLayer(false)</span>
<span class="line-added">172     , m_inCache(false)</span>
<span class="line-added">173     , m_loading(false)</span>
<span class="line-added">174     , m_isLinkPreload(false)</span>
<span class="line-added">175     , m_hasUnknownEncoding(false)</span>
<span class="line-added">176     , m_switchingClientsToRevalidatedResource(false)</span>
<span class="line-added">177     , m_ignoreForRequestCount(false)</span>
178 {
179     ASSERT(m_sessionID.isValid());
180 #ifndef NDEBUG
181     cachedResourceLeakCounter.increment();
182 #endif
183 }
184 
185 CachedResource::~CachedResource()
186 {
187     ASSERT(!m_resourceToRevalidate); // Should be true because canDelete() checks this.
188     ASSERT(canDelete());
189     ASSERT(!inCache());
190     ASSERT(!m_deleted);
191     ASSERT(url().isNull() || !allowsCaching() || MemoryCache::singleton().resourceForRequest(resourceRequest(), sessionID()) != this);
192 
193 #ifndef NDEBUG
194     m_deleted = true;
195     cachedResourceLeakCounter.decrement();
196 #endif
197 }
198 
199 void CachedResource::failBeforeStarting()
200 {
201     // FIXME: What if resources in other frames were waiting for this revalidation?
202     LOG(ResourceLoading, &quot;Cannot start loading &#39;%s&#39;&quot;, url().string().latin1().data());
203     if (allowsCaching() &amp;&amp; m_resourceToRevalidate)
204         MemoryCache::singleton().revalidationFailed(*this);
205     error(CachedResource::LoadError);
206 }
207 
208 void CachedResource::load(CachedResourceLoader&amp; cachedResourceLoader)
209 {
210     if (!cachedResourceLoader.frame()) {
211         RELEASE_LOG_IF_ALLOWED(&quot;load: No associated frame&quot;);
212         failBeforeStarting();
213         return;
214     }
215     Frame&amp; frame = *cachedResourceLoader.frame();
216 
<span class="line-modified">217     // Prevent new loads if we are in the BackForwardCache or being added to the BackForwardCache.</span>
218     // We query the top document because new frames may be created in pagehide event handlers
<span class="line-modified">219     // and their backForwardCacheState will not reflect the fact that they are about to enter page</span>
220     // cache.
221     if (auto* topDocument = frame.mainFrame().document()) {
<span class="line-modified">222         switch (topDocument-&gt;backForwardCacheState()) {</span>
<span class="line-modified">223         case Document::NotInBackForwardCache:</span>
224             break;
<span class="line-modified">225         case Document::AboutToEnterBackForwardCache:</span>
226             // Beacons are allowed to go through in &#39;pagehide&#39; event handlers.
227             if (shouldUsePingLoad(type()))
228                 break;
<span class="line-modified">229             RELEASE_LOG_IF_ALLOWED(&quot;load: About to enter back/forward cache (frame = %p)&quot;, &amp;frame);</span>
230             failBeforeStarting();
231             return;
<span class="line-modified">232         case Document::InBackForwardCache:</span>
<span class="line-modified">233             RELEASE_LOG_IF_ALLOWED(&quot;load: Already in back/forward cache (frame = %p)&quot;, &amp;frame);</span>
234             failBeforeStarting();
235             return;
236         }
237     }
238 
239     FrameLoader&amp; frameLoader = frame.loader();
240     if (m_options.securityCheck == SecurityCheckPolicy::DoSecurityCheck &amp;&amp; !shouldUsePingLoad(type())) {
241         while (true) {
242             if (frameLoader.state() == FrameStateProvisional)
243                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- state is provisional (frame = %p)&quot;, &amp;frame);
244             else if (!frameLoader.activeDocumentLoader())
245                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- not active document (frame = %p)&quot;, &amp;frame);
246             else if (frameLoader.activeDocumentLoader()-&gt;isStopping())
247                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- active loader is stopping (frame = %p)&quot;, &amp;frame);
248             else
249                 break;
250             failBeforeStarting();
251             return;
252         }
253     }
254 
255     m_loading = true;
256 
257     if (isCacheValidator()) {
258         CachedResource* resourceToRevalidate = m_resourceToRevalidate;
259         ASSERT(resourceToRevalidate-&gt;canUseCacheValidator());
260         ASSERT(resourceToRevalidate-&gt;isLoaded());
261         const String&amp; lastModified = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::LastModified);
262         const String&amp; eTag = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::ETag);
263         if (!lastModified.isEmpty() || !eTag.isEmpty()) {
264             ASSERT(cachedResourceLoader.cachePolicy(type(), url()) != CachePolicyReload);
265             if (cachedResourceLoader.cachePolicy(type(), url()) == CachePolicyRevalidate)
<span class="line-modified">266                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());</span>
267             if (!lastModified.isEmpty())
268                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfModifiedSince, lastModified);
269             if (!eTag.isEmpty())
270                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfNoneMatch, eTag);
271         }
272     }
273 
274     if (type() == Type::LinkPrefetch)
275         m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::Purpose, &quot;prefetch&quot;);
276     m_resourceRequest.setPriority(loadPriority());
277 
278     // Navigation algorithm is setting up the request before sending it to CachedResourceLoader?CachedResource.
279     // So no need for extra fields for MainResource.
280     if (type() != Type::MainResource)
281         frameLoader.addExtraFieldsToSubresourceRequest(m_resourceRequest);
282 
283 
284     // FIXME: It&#39;s unfortunate that the cache layer and below get to know anything about fragment identifiers.
285     // We should look into removing the expectation of that knowledge from the platform network stacks.
286     ResourceRequest request(m_resourceRequest);
</pre>
<hr />
<pre>
311             if (!error.isNull()) {
312                 setResourceError(error);
313                 this-&gt;error(LoadError);
314                 InspectorInstrumentation::didFailLoading(protectedFrame.ptr(), protectedFrame-&gt;loader().activeDocumentLoader(), identifier, error);
315                 return;
316             }
317             finishLoading(nullptr);
318             NetworkLoadMetrics emptyMetrics;
319             InspectorInstrumentation::didFinishLoading(protectedFrame.ptr(), protectedFrame-&gt;loader().activeDocumentLoader(), identifier, emptyMetrics, nullptr);
320         });
321         return;
322     }
323 
324     platformStrategies()-&gt;loaderStrategy()-&gt;loadResource(frame, *this, WTFMove(request), m_options, [this, protectedThis = CachedResourceHandle&lt;CachedResource&gt;(this), frame = makeRef(frame), loggingAllowed = cachedResourceLoader.isAlwaysOnLoggingAllowed()] (RefPtr&lt;SubresourceLoader&gt;&amp;&amp; loader) {
325         m_loader = WTFMove(loader);
326         if (!m_loader) {
327             RELEASE_LOG_IF(loggingAllowed, Network, &quot;%p - CachedResource::load: Unable to create SubresourceLoader (frame = %p)&quot;, this, frame.ptr());
328             failBeforeStarting();
329             return;
330         }
<span class="line-modified">331         setStatus(Pending);</span>
332     });
333 }
334 
335 void CachedResource::loadFrom(const CachedResource&amp; resource)
336 {
337     ASSERT(url() == resource.url());
338     ASSERT(type() == resource.type());
339     ASSERT(resource.status() == Status::Cached);
340 
341     if (isCrossOrigin() &amp;&amp; m_options.mode == FetchOptions::Mode::Cors) {
342         ASSERT(m_origin);
343         String errorMessage;
344         if (!WebCore::passesAccessControlCheck(resource.response(), m_options.storedCredentialsPolicy, *m_origin, errorMessage)) {
345             setResourceError(ResourceError(String(), 0, url(), errorMessage, ResourceError::Type::AccessControl));
346             return;
347         }
348     }
349 
350     setBodyDataFrom(resource);
351     setStatus(Status::Cached);
</pre>
<hr />
<pre>
398 }
399 
400 void CachedResource::cancelLoad()
401 {
402     if (!isLoading() &amp;&amp; !stillNeedsLoad())
403         return;
404 
405     auto* documentLoader = (m_loader &amp;&amp; m_loader-&gt;frame()) ? m_loader-&gt;frame()-&gt;loader().activeDocumentLoader() : nullptr;
406     if (m_options.keepAlive &amp;&amp; (!documentLoader || documentLoader-&gt;isStopping()))
407         m_error = { };
408     else
409         setStatus(LoadError);
410 
411     setLoading(false);
412     checkNotify();
413 }
414 
415 void CachedResource::finish()
416 {
417     if (!errorOccurred())
<span class="line-modified">418         setStatus(Cached);</span>
419 }
420 
421 void CachedResource::setCrossOrigin()
422 {
423     ASSERT(m_options.mode != FetchOptions::Mode::SameOrigin);
424     m_responseTainting = (m_options.mode == FetchOptions::Mode::Cors) ? ResourceResponse::Tainting::Cors : ResourceResponse::Tainting::Opaque;
425 }
426 
427 bool CachedResource::isCrossOrigin() const
428 {
429     return m_responseTainting != ResourceResponse::Tainting::Basic;
430 }
431 
432 bool CachedResource::isCORSSameOrigin() const
433 {
434     // Following resource types do not use CORS
435     ASSERT(type() != Type::FontResource);
436 #if ENABLE(SVG_FONTS)
437     ASSERT(type() != Type::SVGFontResource);
438 #endif
</pre>
<hr />
<pre>
456 {
457 #if PLATFORM(COCOA)
458     if (equalLettersIgnoringASCIICase(scheme, &quot;applewebdata&quot;))
459         return true;
460 #endif
461 #if USE(SOUP)
462     if (equalLettersIgnoringASCIICase(scheme, &quot;resource&quot;))
463         return true;
464 #endif
465     return equalLettersIgnoringASCIICase(scheme, &quot;data&quot;);
466 }
467 
468 Seconds CachedResource::freshnessLifetime(const ResourceResponse&amp; response) const
469 {
470     if (!response.url().protocolIsInHTTPFamily()) {
471         StringView protocol = response.url().protocol();
472         if (!shouldCacheSchemeIndefinitely(protocol)) {
473             // Don&#39;t cache non-HTTP main resources since we can&#39;t check for freshness.
474             // FIXME: We should not cache subresources either, but when we tried this
475             // it caused performance and flakiness issues in our test infrastructure.
<span class="line-modified">476             if (m_type == Type::MainResource || LegacySchemeRegistry::shouldAlwaysRevalidateURLScheme(protocol.toStringWithoutCopying()))</span>
477                 return 0_us;
478         }
479 
480         return Seconds::infinity();
481     }
482 
483     return computeFreshnessLifetimeForHTTPFamily(response, m_responseTimestamp);
484 }
485 
486 void CachedResource::redirectReceived(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; response, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
487 {
488     m_requestedFromNetworkingLayer = true;
489     if (response.isNull())
490         return completionHandler(WTFMove(request));
491 
492     updateRedirectChainStatus(m_redirectChainCacheStatus, response);
493     completionHandler(WTFMove(request));
494 }
495 
496 void CachedResource::setResponse(const ResourceResponse&amp; response)
497 {
498     ASSERT(m_response.type() == ResourceResponse::Type::Default);
499     m_response = response;
<span class="line-modified">500     m_varyingHeaderValues = collectVaryingRequestHeaders(cookieJar(), m_resourceRequest, m_response);</span>
501 
502 #if ENABLE(SERVICE_WORKER)
503     if (m_response.source() == ResourceResponse::Source::ServiceWorker) {
504         m_responseTainting = m_response.tainting();
505         return;
506     }
507 #endif
508     m_response.setRedirected(m_redirectChainCacheStatus.status != RedirectChainCacheStatus::Status::NoRedirection);
509     if (m_response.tainting() == ResourceResponse::Tainting::Basic || m_response.tainting() == ResourceResponse::Tainting::Cors)
510         m_response.setTainting(m_responseTainting);
511 }
512 
513 void CachedResource::responseReceived(const ResourceResponse&amp; response)
514 {
515     setResponse(response);
516     m_responseTimestamp = WallTime::now();
517     String encoding = response.textEncodingName();
518     if (!encoding.isNull())
519         setEncoding(encoding);
520 }
</pre>
<hr />
<pre>
862 
863         if (isExpired())
864             return RevalidationDecision::YesDueToExpired;
865 
866         return RevalidationDecision::No;
867     };
868     ASSERT_NOT_REACHED();
869     return RevalidationDecision::No;
870 }
871 
872 bool CachedResource::redirectChainAllowsReuse(ReuseExpiredRedirectionOrNot reuseExpiredRedirection) const
873 {
874     return WebCore::redirectChainAllowsReuse(m_redirectChainCacheStatus, reuseExpiredRedirection);
875 }
876 
877 bool CachedResource::varyHeaderValuesMatch(const ResourceRequest&amp; request)
878 {
879     if (m_varyingHeaderValues.isEmpty())
880         return true;
881 
<span class="line-modified">882     return verifyVaryingRequestHeaders(cookieJar(), m_varyingHeaderValues, request);</span>
883 }
884 
885 unsigned CachedResource::overheadSize() const
886 {
887     static const int kAverageClientsHashMapSize = 384;
888     return sizeof(CachedResource) + m_response.memoryUsage() + kAverageClientsHashMapSize + m_resourceRequest.url().string().length() * 2;
889 }
890 












891 void CachedResource::setLoadPriority(const Optional&lt;ResourceLoadPriority&gt;&amp; loadPriority)
892 {
893     if (loadPriority)
894         m_loadPriority = loadPriority.value();
895     else
896         m_loadPriority = defaultPriorityForResourceType(type());
897 }
898 
899 inline CachedResource::Callback::Callback(CachedResource&amp; resource, CachedResourceClient&amp; client)
900     : m_resource(resource)
901     , m_client(client)
902     , m_timer(*this, &amp;Callback::timerFired)
903 {
904     m_timer.startOneShot(0_s);
905 }
906 
907 inline void CachedResource::Callback::cancel()
908 {
909     if (m_timer.isActive())
910         m_timer.stop();
</pre>
<hr />
<pre>
921 {
922     if (!m_data)
923         return;
924 
925     if (!mayTryReplaceEncodedData())
926         return;
927 
928     // We have to do the memcmp because we can&#39;t tell if the replacement file backed data is for the
929     // same resource or if we made a second request with the same URL which gave us a different
930     // resource. We have seen this happen for cached POST resources.
931     if (m_data-&gt;size() != newBuffer.size() || memcmp(m_data-&gt;data(), newBuffer.data(), m_data-&gt;size()))
932         return;
933 
934     m_data-&gt;clear();
935     m_data-&gt;append(newBuffer);
936     didReplaceSharedBufferContents();
937 }
938 
939 #endif
940 
<span class="line-added">941 #if USE(QUICK_LOOK)</span>
<span class="line-added">942 </span>
<span class="line-added">943 void CachedResource::previewResponseReceived(const ResourceResponse&amp; response)</span>
<span class="line-added">944 {</span>
<span class="line-added">945     ASSERT(response.url().protocolIs(QLPreviewProtocol));</span>
<span class="line-added">946     CachedResource::responseReceived(response);</span>
<span class="line-added">947 }</span>
<span class="line-added">948 </span>
<span class="line-added">949 #endif</span>
<span class="line-added">950 </span>
951 }
</pre>
</td>
</tr>
</table>
<center><a href="CachedRawResourceClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
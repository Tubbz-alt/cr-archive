diff a/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.h b/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.h
@@ -23,30 +23,55 @@
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#if ENABLE(OFFSCREEN_CANVAS)
+
 #include "AffineTransform.h"
 #include "CanvasBase.h"
+#include "ContextDestructionObserver.h"
 #include "EventTarget.h"
 #include "ExceptionOr.h"
+#include "IDLTypes.h"
 #include "IntSize.h"
-#include "JSDOMPromiseDeferred.h"
 #include "ScriptWrappable.h"
 #include <wtf/Forward.h>
 #include <wtf/RefCounted.h>
 #include <wtf/text/WTFString.h>
 
 namespace WebCore {
 
+class CanvasRenderingContext;
+class CSSValuePool;
+class DeferredPromise;
 class ImageBitmap;
+class OffscreenCanvasRenderingContext2D;
 class WebGLRenderingContext;
 
 #if ENABLE(WEBGL)
-using OffscreenRenderingContext = RefPtr<WebGLRenderingContext>;
+using OffscreenRenderingContext = Variant<RefPtr<OffscreenCanvasRenderingContext2D>, RefPtr<WebGLRenderingContext>>;
+#else
+using OffscreenRenderingContext = Variant<RefPtr<OffscreenCanvasRenderingContext2D>>;
 #endif
 
+class DetachedOffscreenCanvas {
+    WTF_MAKE_NONCOPYABLE(DetachedOffscreenCanvas);
+    WTF_MAKE_FAST_ALLOCATED;
+public:
+    DetachedOffscreenCanvas(std::unique_ptr<ImageBuffer>&&, const IntSize&, bool originClean);
+
+    std::unique_ptr<ImageBuffer> takeImageBuffer();
+    const IntSize& size() const { return m_size; }
+    bool originClean() const { return m_originClean; }
+
+private:
+    std::unique_ptr<ImageBuffer> m_buffer;
+    IntSize m_size;
+    bool m_originClean;
+};
+
 class OffscreenCanvas final : public RefCounted<OffscreenCanvas>, public CanvasBase, public EventTargetWithInlineData, private ContextDestructionObserver {
     WTF_MAKE_ISO_ALLOCATED(OffscreenCanvas);
 public:
 
     struct ImageEncodeOptions {
@@ -58,34 +83,35 @@
         _2d,
         Webgl
     };
 
     static Ref<OffscreenCanvas> create(ScriptExecutionContext&, unsigned width, unsigned height);
+    static Ref<OffscreenCanvas> create(ScriptExecutionContext&, std::unique_ptr<DetachedOffscreenCanvas>&&);
     virtual ~OffscreenCanvas();
 
     unsigned width() const final;
-    void setWidth(unsigned);
     unsigned height() const final;
+    void setWidth(unsigned);
     void setHeight(unsigned);
 
-    const IntSize& size() const final;
-    void setSize(const IntSize&) final;
+    CanvasRenderingContext* renderingContext() const final { return m_context.get(); }
 
-#if ENABLE(WEBGL)
-    ExceptionOr<OffscreenRenderingContext> getContext(JSC::ExecState&, RenderingContextType, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
-#endif
-    RefPtr<ImageBitmap> transferToImageBitmap();
-    // void convertToBlob(ImageEncodeOptions options);
+    ExceptionOr<OffscreenRenderingContext> getContext(JSC::JSGlobalObject&, RenderingContextType, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
+    ExceptionOr<RefPtr<ImageBitmap>> transferToImageBitmap();
+    void convertToBlob(ImageEncodeOptions&&, Ref<DeferredPromise>&&);
 
-    GraphicsContext* drawingContext() const final { return nullptr; }
-    GraphicsContext* existingDrawingContext() const final { return nullptr; }
+    void didDraw(const FloatRect&) final;
 
-    void makeRenderingResultsAvailable() final { }
-    void didDraw(const FloatRect&) final { }
-
-    AffineTransform baseTransform() const final { return { }; }
     Image* copiedImage() const final { return nullptr; }
+    bool hasCreatedImageBuffer() const final { return m_hasCreatedImageBuffer; }
+
+    SecurityOrigin* securityOrigin() const final;
+
+    bool canDetach() const;
+    std::unique_ptr<DetachedOffscreenCanvas> detach();
+
+    CSSValuePool& cssValuePool();
 
     using RefCounted::ref;
     using RefCounted::deref;
 
 private:
@@ -102,11 +128,24 @@
     void derefEventTarget() final { deref(); }
 
     void refCanvasBase() final { ref(); }
     void derefCanvasBase() final { deref(); }
 
-    IntSize m_size;
+    void setSize(const IntSize&) final;
+    void createImageBuffer() const final;
+    std::unique_ptr<ImageBuffer> takeImageBuffer() const;
+
+    void reset();
+
+    std::unique_ptr<CanvasRenderingContext> m_context;
+
+    // m_hasCreatedImageBuffer means we tried to malloc the buffer. We didn't necessarily get it.
+    mutable bool m_hasCreatedImageBuffer { false };
+
+    bool m_detached { false };
 };
 
 }
 
 SPECIALIZE_TYPE_TRAITS_CANVAS(WebCore::OffscreenCanvas, isOffscreenCanvas())
+
+#endif

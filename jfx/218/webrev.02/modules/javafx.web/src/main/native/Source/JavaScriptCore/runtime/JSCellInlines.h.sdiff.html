<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCell.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomGetterSetterFunction.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;AllocatorForMode.h&quot;
 29 #include &quot;AllocatorInlines.h&quot;
 30 #include &quot;CompleteSubspaceInlines.h&quot;
 31 #include &quot;CPU.h&quot;
<span class="line-modified"> 32 #include &quot;CallFrame.h&quot;</span>
 33 #include &quot;DeferGC.h&quot;
 34 #include &quot;FreeListInlines.h&quot;
 35 #include &quot;Handle.h&quot;
 36 #include &quot;HeapInlines.h&quot;
 37 #include &quot;IsoSubspaceInlines.h&quot;
 38 #include &quot;JSBigInt.h&quot;
 39 #include &quot;JSCast.h&quot;
 40 #include &quot;JSDestructibleObject.h&quot;
 41 #include &quot;JSObject.h&quot;
 42 #include &quot;JSString.h&quot;
 43 #include &quot;LocalAllocatorInlines.h&quot;
 44 #include &quot;MarkedBlock.h&quot;
 45 #include &quot;SlotVisitorInlines.h&quot;
 46 #include &quot;Structure.h&quot;
 47 #include &quot;Symbol.h&quot;
 48 #include &lt;wtf/CompilationThread.h&gt;
 49 
 50 namespace JSC {
 51 
 52 inline JSCell::JSCell(CreatingEarlyCellTag)
</pre>
<hr />
<pre>
121 
122 ALWAYS_INLINE Structure* JSCell::structure() const
123 {
124     return structure(vm());
125 }
126 
127 ALWAYS_INLINE Structure* JSCell::structure(VM&amp; vm) const
128 {
129     return vm.getStructure(m_structureID);
130 }
131 
132 inline void JSCell::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
133 {
134     visitor.appendUnbarriered(cell-&gt;structure(visitor.vm()));
135 }
136 
137 inline void JSCell::visitOutputConstraints(JSCell*, SlotVisitor&amp;)
138 {
139 }
140 
<span class="line-modified">141 ALWAYS_INLINE VM&amp; ExecState::vm() const</span>
142 {
143     JSCell* callee = this-&gt;callee().asCell();
144     ASSERT(callee);
145     ASSERT(&amp;callee-&gt;vm());
<span class="line-modified">146     ASSERT(!callee-&gt;isLargeAllocation());</span>
<span class="line-removed">147     // This is an important optimization since we access this so often.</span>
<span class="line-removed">148     return callee-&gt;markedBlock().vm();</span>
<span class="line-removed">149 }</span>
<span class="line-removed">150 </span>
<span class="line-removed">151 template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-removed">152 CompleteSubspace* JSCell::subspaceFor(VM&amp; vm)</span>
<span class="line-removed">153 {</span>
<span class="line-removed">154     if (CellType::needsDestruction)</span>
<span class="line-removed">155         return &amp;vm.destructibleCellSpace;</span>
<span class="line-removed">156     return &amp;vm.cellSpace;</span>
157 }
158 
159 template&lt;typename Type&gt;
160 inline Allocator allocatorForNonVirtualConcurrently(VM&amp; vm, size_t allocationSize, AllocatorForMode mode)
161 {
162     if (auto* subspace = subspaceForConcurrently&lt;Type&gt;(vm))
163         return subspace-&gt;allocatorForNonVirtual(allocationSize, mode);
164     return { };
165 }
166 
167 template&lt;typename T&gt;
168 ALWAYS_INLINE void* tryAllocateCellHelper(Heap&amp; heap, size_t size, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)
169 {
170     VM&amp; vm = heap.vm();
171     ASSERT(deferralContext || !DisallowGC::isInEffectOnCurrentThread());
172     ASSERT(size &gt;= sizeof(T));
173     JSCell* result = static_cast&lt;JSCell*&gt;(subspaceFor&lt;T&gt;(vm)-&gt;allocateNonVirtual(vm, size, deferralContext, failureMode));
174     if (failureMode == AllocationFailureMode::ReturnNull &amp;&amp; !result)
175         return nullptr;
176 #if ENABLE(GC_VALIDATION)
</pre>
<hr />
<pre>
285         || Heap::heap(this)-&gt;structureIDTable().get(structure-&gt;id()) == structure);
286     m_structureID = structure-&gt;id();
287     m_flags = TypeInfo::mergeInlineTypeFlags(structure-&gt;typeInfo().inlineTypeFlags(), m_flags);
288     m_type = structure-&gt;typeInfo().type();
289     IndexingType newIndexingType = structure-&gt;indexingModeIncludingHistory();
290     if (m_indexingTypeAndMisc != newIndexingType) {
291         ASSERT(!(newIndexingType &amp; ~AllArrayTypesAndHistory));
292         for (;;) {
293             IndexingType oldValue = m_indexingTypeAndMisc;
294             IndexingType newValue = (oldValue &amp; ~AllArrayTypesAndHistory) | structure-&gt;indexingModeIncludingHistory();
295             if (WTF::atomicCompareExchangeWeakRelaxed(&amp;m_indexingTypeAndMisc, oldValue, newValue))
296                 break;
297         }
298     }
299     vm.heap.writeBarrier(this, structure);
300 }
301 
302 inline const MethodTable* JSCell::methodTable(VM&amp; vm) const
303 {
304     Structure* structure = this-&gt;structure(vm);
<span class="line-modified">305 #if !ASSERT_DISABLED</span>
306     if (Structure* rootStructure = structure-&gt;structure(vm))
307         ASSERT(rootStructure == rootStructure-&gt;structure(vm));
308 #endif
309     return &amp;structure-&gt;classInfo()-&gt;methodTable;
310 }
311 
312 inline bool JSCell::inherits(VM&amp; vm, const ClassInfo* info) const
313 {
314     return classInfo(vm)-&gt;isSubClassOf(info);
315 }
316 
317 template&lt;typename Target&gt;
318 inline bool JSCell::inherits(VM&amp; vm) const
319 {
320     return JSCastingHelpers::inherits&lt;Target&gt;(vm, this);
321 }
322 
323 ALWAYS_INLINE JSValue JSCell::fastGetOwnProperty(VM&amp; vm, Structure&amp; structure, PropertyName name)
324 {
325     ASSERT(canUseFastGetOwnProperty(structure));
</pre>
<hr />
<pre>
330 }
331 
332 inline bool JSCell::canUseFastGetOwnProperty(const Structure&amp; structure)
333 {
334     return !structure.hasGetterSetterProperties()
335         &amp;&amp; !structure.hasCustomGetterSetterProperties()
336         &amp;&amp; !structure.typeInfo().overridesGetOwnPropertySlot();
337 }
338 
339 ALWAYS_INLINE const ClassInfo* JSCell::classInfo(VM&amp; vm) const
340 {
341     // What we really want to assert here is that we&#39;re not currently destructing this object (which makes its classInfo
342     // invalid). If mutatorState() == MutatorState::Running, then we&#39;re not currently sweeping, and therefore cannot be
343     // destructing the object. The GC thread or JIT threads, unlike the mutator thread, are able to access classInfo
344     // independent of whether the mutator thread is sweeping or not. Hence, we also check for !currentThreadIsHoldingAPILock()
345     // to allow the GC thread or JIT threads to pass this assertion.
346     ASSERT(vm.heap.mutatorState() != MutatorState::Sweeping || !vm.currentThreadIsHoldingAPILock());
347     return structure(vm)-&gt;classInfo();
348 }
349 
<span class="line-modified">350 inline bool JSCell::toBoolean(ExecState* exec) const</span>
351 {
352     if (isString())
353         return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean();
354     if (isBigInt())
355         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean();
<span class="line-modified">356     return !structure(exec-&gt;vm())-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());</span>
357 }
358 
359 inline TriState JSCell::pureToBoolean() const
360 {
361     if (isString())
362         return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean() ? TrueTriState : FalseTriState;
363     if (isBigInt())
364         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean() ? TrueTriState : FalseTriState;
365     if (isSymbol())
366         return TrueTriState;
367     return MixedTriState;
368 }
369 
370 inline void JSCellLock::lock()
371 {
372     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
373     if (UNLIKELY(!IndexingTypeLockAlgorithm::lockFast(*lock)))
374         lockSlow();
375 }
376 
</pre>
<hr />
<pre>
392     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
393     return IndexingTypeLockAlgorithm::isLocked(*lock);
394 }
395 
396 inline bool JSCell::perCellBit() const
397 {
398     return TypeInfo::perCellBit(inlineTypeFlags());
399 }
400 
401 inline void JSCell::setPerCellBit(bool value)
402 {
403     if (value == perCellBit())
404         return;
405 
406     if (value)
407         m_flags |= static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
408     else
409         m_flags &amp;= ~static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
410 }
411 
<span class="line-modified">412 inline JSObject* JSCell::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
413 {
414     if (isObject())
415         return jsCast&lt;JSObject*&gt;(const_cast&lt;JSCell*&gt;(this));
<span class="line-modified">416     return toObjectSlow(exec, globalObject);</span>
417 }
418 
<span class="line-modified">419 ALWAYS_INLINE bool JSCell::putInline(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
420 {
<span class="line-modified">421     auto putMethod = methodTable(exec-&gt;vm())-&gt;put;</span>
422     if (LIKELY(putMethod == JSObject::put))
<span class="line-modified">423         return JSObject::putInlineForJSObject(asObject(this), exec, propertyName, value, slot);</span>
<span class="line-modified">424     return putMethod(this, exec, propertyName, value, slot);</span>
425 }
426 
<span class="line-modified">427 inline bool isWebAssemblyToJSCallee(const JSCell* cell)</span>
428 {
<span class="line-modified">429     return cell-&gt;type() == WebAssemblyToJSCalleeType;</span>
430 }
431 
432 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;AllocatorForMode.h&quot;
 29 #include &quot;AllocatorInlines.h&quot;
 30 #include &quot;CompleteSubspaceInlines.h&quot;
 31 #include &quot;CPU.h&quot;
<span class="line-modified"> 32 #include &quot;CallFrameInlines.h&quot;</span>
 33 #include &quot;DeferGC.h&quot;
 34 #include &quot;FreeListInlines.h&quot;
 35 #include &quot;Handle.h&quot;
 36 #include &quot;HeapInlines.h&quot;
 37 #include &quot;IsoSubspaceInlines.h&quot;
 38 #include &quot;JSBigInt.h&quot;
 39 #include &quot;JSCast.h&quot;
 40 #include &quot;JSDestructibleObject.h&quot;
 41 #include &quot;JSObject.h&quot;
 42 #include &quot;JSString.h&quot;
 43 #include &quot;LocalAllocatorInlines.h&quot;
 44 #include &quot;MarkedBlock.h&quot;
 45 #include &quot;SlotVisitorInlines.h&quot;
 46 #include &quot;Structure.h&quot;
 47 #include &quot;Symbol.h&quot;
 48 #include &lt;wtf/CompilationThread.h&gt;
 49 
 50 namespace JSC {
 51 
 52 inline JSCell::JSCell(CreatingEarlyCellTag)
</pre>
<hr />
<pre>
121 
122 ALWAYS_INLINE Structure* JSCell::structure() const
123 {
124     return structure(vm());
125 }
126 
127 ALWAYS_INLINE Structure* JSCell::structure(VM&amp; vm) const
128 {
129     return vm.getStructure(m_structureID);
130 }
131 
132 inline void JSCell::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
133 {
134     visitor.appendUnbarriered(cell-&gt;structure(visitor.vm()));
135 }
136 
137 inline void JSCell::visitOutputConstraints(JSCell*, SlotVisitor&amp;)
138 {
139 }
140 
<span class="line-modified">141 ALWAYS_INLINE VM&amp; CallFrame::deprecatedVM() const</span>
142 {
143     JSCell* callee = this-&gt;callee().asCell();
144     ASSERT(callee);
145     ASSERT(&amp;callee-&gt;vm());
<span class="line-modified">146     return callee-&gt;vm();</span>










147 }
148 
149 template&lt;typename Type&gt;
150 inline Allocator allocatorForNonVirtualConcurrently(VM&amp; vm, size_t allocationSize, AllocatorForMode mode)
151 {
152     if (auto* subspace = subspaceForConcurrently&lt;Type&gt;(vm))
153         return subspace-&gt;allocatorForNonVirtual(allocationSize, mode);
154     return { };
155 }
156 
157 template&lt;typename T&gt;
158 ALWAYS_INLINE void* tryAllocateCellHelper(Heap&amp; heap, size_t size, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)
159 {
160     VM&amp; vm = heap.vm();
161     ASSERT(deferralContext || !DisallowGC::isInEffectOnCurrentThread());
162     ASSERT(size &gt;= sizeof(T));
163     JSCell* result = static_cast&lt;JSCell*&gt;(subspaceFor&lt;T&gt;(vm)-&gt;allocateNonVirtual(vm, size, deferralContext, failureMode));
164     if (failureMode == AllocationFailureMode::ReturnNull &amp;&amp; !result)
165         return nullptr;
166 #if ENABLE(GC_VALIDATION)
</pre>
<hr />
<pre>
275         || Heap::heap(this)-&gt;structureIDTable().get(structure-&gt;id()) == structure);
276     m_structureID = structure-&gt;id();
277     m_flags = TypeInfo::mergeInlineTypeFlags(structure-&gt;typeInfo().inlineTypeFlags(), m_flags);
278     m_type = structure-&gt;typeInfo().type();
279     IndexingType newIndexingType = structure-&gt;indexingModeIncludingHistory();
280     if (m_indexingTypeAndMisc != newIndexingType) {
281         ASSERT(!(newIndexingType &amp; ~AllArrayTypesAndHistory));
282         for (;;) {
283             IndexingType oldValue = m_indexingTypeAndMisc;
284             IndexingType newValue = (oldValue &amp; ~AllArrayTypesAndHistory) | structure-&gt;indexingModeIncludingHistory();
285             if (WTF::atomicCompareExchangeWeakRelaxed(&amp;m_indexingTypeAndMisc, oldValue, newValue))
286                 break;
287         }
288     }
289     vm.heap.writeBarrier(this, structure);
290 }
291 
292 inline const MethodTable* JSCell::methodTable(VM&amp; vm) const
293 {
294     Structure* structure = this-&gt;structure(vm);
<span class="line-modified">295 #if ASSERT_ENABLED</span>
296     if (Structure* rootStructure = structure-&gt;structure(vm))
297         ASSERT(rootStructure == rootStructure-&gt;structure(vm));
298 #endif
299     return &amp;structure-&gt;classInfo()-&gt;methodTable;
300 }
301 
302 inline bool JSCell::inherits(VM&amp; vm, const ClassInfo* info) const
303 {
304     return classInfo(vm)-&gt;isSubClassOf(info);
305 }
306 
307 template&lt;typename Target&gt;
308 inline bool JSCell::inherits(VM&amp; vm) const
309 {
310     return JSCastingHelpers::inherits&lt;Target&gt;(vm, this);
311 }
312 
313 ALWAYS_INLINE JSValue JSCell::fastGetOwnProperty(VM&amp; vm, Structure&amp; structure, PropertyName name)
314 {
315     ASSERT(canUseFastGetOwnProperty(structure));
</pre>
<hr />
<pre>
320 }
321 
322 inline bool JSCell::canUseFastGetOwnProperty(const Structure&amp; structure)
323 {
324     return !structure.hasGetterSetterProperties()
325         &amp;&amp; !structure.hasCustomGetterSetterProperties()
326         &amp;&amp; !structure.typeInfo().overridesGetOwnPropertySlot();
327 }
328 
329 ALWAYS_INLINE const ClassInfo* JSCell::classInfo(VM&amp; vm) const
330 {
331     // What we really want to assert here is that we&#39;re not currently destructing this object (which makes its classInfo
332     // invalid). If mutatorState() == MutatorState::Running, then we&#39;re not currently sweeping, and therefore cannot be
333     // destructing the object. The GC thread or JIT threads, unlike the mutator thread, are able to access classInfo
334     // independent of whether the mutator thread is sweeping or not. Hence, we also check for !currentThreadIsHoldingAPILock()
335     // to allow the GC thread or JIT threads to pass this assertion.
336     ASSERT(vm.heap.mutatorState() != MutatorState::Sweeping || !vm.currentThreadIsHoldingAPILock());
337     return structure(vm)-&gt;classInfo();
338 }
339 
<span class="line-modified">340 inline bool JSCell::toBoolean(JSGlobalObject* globalObject) const</span>
341 {
342     if (isString())
343         return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean();
344     if (isBigInt())
345         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean();
<span class="line-modified">346     return !structure(getVM(globalObject))-&gt;masqueradesAsUndefined(globalObject);</span>
347 }
348 
349 inline TriState JSCell::pureToBoolean() const
350 {
351     if (isString())
352         return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean() ? TrueTriState : FalseTriState;
353     if (isBigInt())
354         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean() ? TrueTriState : FalseTriState;
355     if (isSymbol())
356         return TrueTriState;
357     return MixedTriState;
358 }
359 
360 inline void JSCellLock::lock()
361 {
362     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
363     if (UNLIKELY(!IndexingTypeLockAlgorithm::lockFast(*lock)))
364         lockSlow();
365 }
366 
</pre>
<hr />
<pre>
382     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
383     return IndexingTypeLockAlgorithm::isLocked(*lock);
384 }
385 
386 inline bool JSCell::perCellBit() const
387 {
388     return TypeInfo::perCellBit(inlineTypeFlags());
389 }
390 
391 inline void JSCell::setPerCellBit(bool value)
392 {
393     if (value == perCellBit())
394         return;
395 
396     if (value)
397         m_flags |= static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
398     else
399         m_flags &amp;= ~static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
400 }
401 
<span class="line-modified">402 inline JSObject* JSCell::toObject(JSGlobalObject* globalObject) const</span>
403 {
404     if (isObject())
405         return jsCast&lt;JSObject*&gt;(const_cast&lt;JSCell*&gt;(this));
<span class="line-modified">406     return toObjectSlow(globalObject);</span>
407 }
408 
<span class="line-modified">409 ALWAYS_INLINE bool JSCell::putInline(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
410 {
<span class="line-modified">411     auto putMethod = methodTable(getVM(globalObject))-&gt;put;</span>
412     if (LIKELY(putMethod == JSObject::put))
<span class="line-modified">413         return JSObject::putInlineForJSObject(asObject(this), globalObject, propertyName, value, slot);</span>
<span class="line-modified">414     return putMethod(this, globalObject, propertyName, value, slot);</span>
415 }
416 
<span class="line-modified">417 inline bool isWebAssemblyModule(const JSCell* cell)</span>
418 {
<span class="line-modified">419     return cell-&gt;type() == WebAssemblyModuleType;</span>
420 }
421 
422 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSCell.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomGetterSetterFunction.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
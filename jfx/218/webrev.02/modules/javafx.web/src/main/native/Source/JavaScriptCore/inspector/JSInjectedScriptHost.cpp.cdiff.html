<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSInjectedScriptHost.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGlobalObjectScriptDebugServer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSInjectedScriptHost.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSInjectedScriptHost.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,10 ***</span>
<span class="line-new-header">--- 41,11 ---</span>
  #include &quot;InjectedScriptHost.h&quot;
  #include &quot;IterationKind.h&quot;
  #include &quot;IteratorOperations.h&quot;
  #include &quot;IteratorPrototype.h&quot;
  #include &quot;JSArray.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSBoundFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGlobalObjectFunctions.h&quot;
  #include &quot;JSInjectedScriptHostPrototype.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,14 ***</span>
  #include &lt;wtf/HashTraits.h&gt;
  #include &lt;wtf/Lock.h&gt;
  #include &lt;wtf/PrintStream.h&gt;
  #include &lt;wtf/text/StringConcatenate.h&gt;
  
<span class="line-removed">- using namespace JSC;</span>
<span class="line-removed">- </span>
  namespace Inspector {
  
  const ClassInfo JSInjectedScriptHost::s_info = { &quot;InjectedScriptHost&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSInjectedScriptHost) };
  
  JSInjectedScriptHost::JSInjectedScriptHost(VM&amp; vm, Structure* structure, Ref&lt;InjectedScriptHost&gt;&amp;&amp; impl)
      : JSDestructibleObject(vm, structure)
      , m_wrapped(WTFMove(impl))
<span class="line-new-header">--- 79,14 ---</span>
  #include &lt;wtf/HashTraits.h&gt;
  #include &lt;wtf/Lock.h&gt;
  #include &lt;wtf/PrintStream.h&gt;
  #include &lt;wtf/text/StringConcatenate.h&gt;
  
  namespace Inspector {
  
<span class="line-added">+ using namespace JSC;</span>
<span class="line-added">+ </span>
  const ClassInfo JSInjectedScriptHost::s_info = { &quot;InjectedScriptHost&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSInjectedScriptHost) };
  
  JSInjectedScriptHost::JSInjectedScriptHost(VM&amp; vm, Structure* structure, Ref&lt;InjectedScriptHost&gt;&amp;&amp; impl)
      : JSDestructibleObject(vm, structure)
      , m_wrapped(WTFMove(impl))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,87 ***</span>
  {
      JSInjectedScriptHost* thisObject = static_cast&lt;JSInjectedScriptHost*&gt;(cell);
      thisObject-&gt;JSInjectedScriptHost::~JSInjectedScriptHost();
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::evaluate(ExecState* exec) const</span>
  {
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      return globalObject-&gt;evalFunction();
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::savedResultAlias(ExecState* exec) const</span>
  {
      auto savedResultAlias = impl().savedResultAlias();
      if (!savedResultAlias)
          return jsUndefined();
<span class="line-modified">!     return jsString(exec-&gt;vm(), savedResultAlias.value());</span>
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::evaluateWithScopeExtension(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue scriptValue = exec-&gt;argument(0);</span>
      if (!scriptValue.isString())
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;InjectedScriptHost.evaluateWithScopeExtension first argument must be a string.&quot;_s);</span>
  
<span class="line-modified">!     String program = asString(scriptValue)-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     JSObject* scopeExtension = exec-&gt;argument(1).getObject();</span>
<span class="line-modified">!     JSValue result = JSC::evaluateWithScopeExtension(exec, makeSource(program, exec-&gt;callerSourceOrigin()), scopeExtension, exception);</span>
      if (exception)
<span class="line-modified">!         throwException(exec, scope, exception);</span>
  
      return result;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::internalConstructorName(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* object = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedArgument(0).toThis(exec, NotStrictMode));</span>
      return jsString(vm, JSObject::calculatedClassName(object));
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::isHTMLAllCollection(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      return jsBoolean(impl().isHTMLAllCollection(vm, value));
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::isPromiseRejectedWithNativeGetterTypeError(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* promise = jsDynamicCast&lt;JSPromise*&gt;(vm, exec-&gt;argument(0));</span>
<span class="line-modified">!     if (!promise || promise-&gt;status(vm) != JSPromise::Status::Rejected)</span>
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError first argument must be a rejected Promise.&quot;_s);</span>
  
      bool result = false;
      if (auto* errorInstance = jsDynamicCast&lt;ErrorInstance*&gt;(vm, promise-&gt;result(vm)))
          result = errorInstance-&gt;isNativeGetterTypeError();
      return jsBoolean(result);
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::subtype(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      if (value.isString())
          return vm.smallStrings.stringString();
      if (value.isBoolean())
          return vm.smallStrings.booleanString();
      if (value.isNumber())
<span class="line-new-header">--- 108,86 ---</span>
  {
      JSInjectedScriptHost* thisObject = static_cast&lt;JSInjectedScriptHost*&gt;(cell);
      thisObject-&gt;JSInjectedScriptHost::~JSInjectedScriptHost();
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::evaluate(JSGlobalObject* globalObject) const</span>
  {
      return globalObject-&gt;evalFunction();
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::savedResultAlias(JSGlobalObject* globalObject) const</span>
  {
      auto savedResultAlias = impl().savedResultAlias();
      if (!savedResultAlias)
          return jsUndefined();
<span class="line-modified">!     return jsString(globalObject-&gt;vm(), savedResultAlias.value());</span>
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::evaluateWithScopeExtension(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue scriptValue = callFrame-&gt;argument(0);</span>
      if (!scriptValue.isString())
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;InjectedScriptHost.evaluateWithScopeExtension first argument must be a string.&quot;_s);</span>
  
<span class="line-modified">!     String program = asString(scriptValue)-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     JSObject* scopeExtension = callFrame-&gt;argument(1).getObject();</span>
<span class="line-modified">!     JSValue result = JSC::evaluateWithScopeExtension(globalObject, makeSource(program, callFrame-&gt;callerSourceOrigin(vm)), scopeExtension, exception);</span>
      if (exception)
<span class="line-modified">!         throwException(globalObject, scope, exception);</span>
  
      return result;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::internalConstructorName(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* object = jsCast&lt;JSObject*&gt;(callFrame-&gt;uncheckedArgument(0).toThis(globalObject, NotStrictMode));</span>
      return jsString(vm, JSObject::calculatedClassName(object));
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::isHTMLAllCollection(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      return jsBoolean(impl().isHTMLAllCollection(vm, value));
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::isPromiseRejectedWithNativeGetterTypeError(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* promise = jsDynamicCast&lt;JSPromise*&gt;(vm, callFrame-&gt;argument(0));</span>
<span class="line-modified">!     if (!promise)</span>
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError first argument must be a Promise.&quot;_s);</span>
  
      bool result = false;
      if (auto* errorInstance = jsDynamicCast&lt;ErrorInstance*&gt;(vm, promise-&gt;result(vm)))
          result = errorInstance-&gt;isNativeGetterTypeError();
      return jsBoolean(result);
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::subtype(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      if (value.isString())
          return vm.smallStrings.stringString();
      if (value.isBoolean())
          return vm.smallStrings.booleanString();
      if (value.isNumber())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,11 ***</span>
              return jsNontrivialString(vm, &quot;weakset&quot;_s);
  
          if (object-&gt;inherits&lt;JSStringIterator&gt;(vm))
              return jsNontrivialString(vm, &quot;iterator&quot;_s);
  
<span class="line-modified">!         if (object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName())</span>
              || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())
              || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName()))
              return jsNontrivialString(vm, &quot;iterator&quot;_s);
  
          if (object-&gt;inherits&lt;JSInt8Array&gt;(vm)
<span class="line-new-header">--- 226,11 ---</span>
              return jsNontrivialString(vm, &quot;weakset&quot;_s);
  
          if (object-&gt;inherits&lt;JSStringIterator&gt;(vm))
              return jsNontrivialString(vm, &quot;iterator&quot;_s);
  
<span class="line-modified">!         if (object-&gt;inherits&lt;JSArrayIterator&gt;(vm)</span>
              || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())
              || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName()))
              return jsNontrivialString(vm, &quot;iterator&quot;_s);
  
          if (object-&gt;inherits&lt;JSInt8Array&gt;(vm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,20 ***</span>
              || object-&gt;inherits&lt;JSFloat32Array&gt;(vm)
              || object-&gt;inherits&lt;JSFloat64Array&gt;(vm))
              return jsNontrivialString(vm, &quot;array&quot;_s);
      }
  
<span class="line-modified">!     return impl().subtype(exec, value);</span>
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::functionDetails(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, value);
      if (!function)
          return jsUndefined();
  
      // FIXME: &lt;https://webkit.org/b/87192&gt; Web Inspector: Expose function scope / closure data
<span class="line-new-header">--- 243,20 ---</span>
              || object-&gt;inherits&lt;JSFloat32Array&gt;(vm)
              || object-&gt;inherits&lt;JSFloat64Array&gt;(vm))
              return jsNontrivialString(vm, &quot;array&quot;_s);
      }
  
<span class="line-modified">!     return impl().subtype(globalObject, value);</span>
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::functionDetails(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, value);
      if (!function)
          return jsUndefined();
  
      // FIXME: &lt;https://webkit.org/b/87192&gt; Web Inspector: Expose function scope / closure data
</pre>
<hr />
<pre>
<span class="line-old-header">*** 274,16 ***</span>
      int columnNumber = sourceCode-&gt;startColumn().oneBasedInt();
      if (columnNumber)
          columnNumber -= 1;
  
      String scriptID = String::number(sourceCode-&gt;provider()-&gt;asID());
<span class="line-modified">!     JSObject* location = constructEmptyObject(exec);</span>
      location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;scriptId&quot;), jsString(vm, scriptID));
      location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;lineNumber&quot;), jsNumber(lineNumber));
      location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;columnNumber&quot;), jsNumber(columnNumber));
  
<span class="line-modified">!     JSObject* result = constructEmptyObject(exec);</span>
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;location&quot;), location);
  
      String name = function-&gt;name(vm);
      if (!name.isEmpty())
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, name));
<span class="line-new-header">--- 274,16 ---</span>
      int columnNumber = sourceCode-&gt;startColumn().oneBasedInt();
      if (columnNumber)
          columnNumber -= 1;
  
      String scriptID = String::number(sourceCode-&gt;provider()-&gt;asID());
<span class="line-modified">!     JSObject* location = constructEmptyObject(globalObject);</span>
      location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;scriptId&quot;), jsString(vm, scriptID));
      location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;lineNumber&quot;), jsNumber(lineNumber));
      location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;columnNumber&quot;), jsNumber(columnNumber));
  
<span class="line-modified">!     JSObject* result = constructEmptyObject(globalObject);</span>
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;location&quot;), location);
  
      String name = function-&gt;name(vm);
      if (!name.isEmpty())
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, name));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,168 ***</span>
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;displayName&quot;), jsString(vm, displayName));
  
      return result;
  }
  
<span class="line-modified">! static JSObject* constructInternalProperty(ExecState* exec, const String&amp; name, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* result = constructEmptyObject(exec);</span>
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, name));
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), value);
      return result;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::getInternalProperties(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
  
<span class="line-modified">!     JSValue internalProperties = impl().getInternalProperties(vm, exec, value);</span>
      if (internalProperties)
          return internalProperties;
  
      if (JSPromise* promise = jsDynamicCast&lt;JSPromise*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(exec, nullptr);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          switch (promise-&gt;status(vm)) {
          case JSPromise::Status::Pending:
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(vm, &quot;pending&quot;_s)));</span>
              return array;
          case JSPromise::Status::Fulfilled:
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(vm, &quot;resolved&quot;_s)));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;result&quot;_s, promise-&gt;result(vm)));</span>
              return array;
          case JSPromise::Status::Rejected:
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(vm, &quot;rejected&quot;_s)));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;result&quot;_s, promise-&gt;result(vm)));</span>
              return array;
          }
          // FIXME: &lt;https://webkit.org/b/141664&gt; Web Inspector: ES6: Improved Support for Promises - Promise Reactions
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      if (JSBoundFunction* boundFunction = jsDynamicCast&lt;JSBoundFunction*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(exec, nullptr);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;targetFunction&quot;, boundFunction-&gt;targetFunction()));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;boundThis&quot;, boundFunction-&gt;boundThis()));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          if (boundFunction-&gt;boundArgs()) {
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;boundArgs&quot;, boundFunction-&gt;boundArgsCopy(exec)));</span>
              return array;
          }
          return array;
      }
  
      if (ProxyObject* proxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(exec, nullptr, 2);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;target&quot;_s, proxy-&gt;target()));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          scope.release();
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;handler&quot;_s, proxy-&gt;handler()));</span>
          return array;
      }
  
      if (JSObject* iteratorObject = jsDynamicCast&lt;JSObject*&gt;(vm, value)) {
<span class="line-modified">!         if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName())) {</span>
<span class="line-modified">!             JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());</span>
<span class="line-modified">!             JSValue kind = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorKindPrivateName());</span>
  
              unsigned index = 0;
<span class="line-modified">!             JSArray* array = constructEmptyArray(exec, nullptr, 2);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;array&quot;, iteratedValue));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;kind&quot;, kind));</span>
              return array;
          }
  
          if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())) {
              JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
<span class="line-modified">!             String kind;</span>
<span class="line-modified">!             switch (static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName()).asInt32())) {</span>
<span class="line-removed">-             case IterateKey:</span>
<span class="line-removed">-                 kind = &quot;key&quot;_s;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case IterateValue:</span>
<span class="line-removed">-                 kind = &quot;value&quot;_s;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case IterateKeyValue:</span>
<span class="line-removed">-                 kind = &quot;key+value&quot;_s;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
              unsigned index = 0;
<span class="line-modified">!             JSArray* array = constructEmptyArray(exec, nullptr, 2);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;map&quot;, iteratedValue));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;kind&quot;, jsNontrivialString(vm, kind)));</span>
              return array;
          }
  
          if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName())) {
              JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
<span class="line-modified">!             String kind;</span>
<span class="line-modified">!             switch (static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName()).asInt32())) {</span>
<span class="line-removed">-             case IterateKey:</span>
<span class="line-removed">-                 kind = &quot;key&quot;_s;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case IterateValue:</span>
<span class="line-removed">-                 kind = &quot;value&quot;_s;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case IterateKeyValue:</span>
<span class="line-removed">-                 kind = &quot;key+value&quot;_s;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
              unsigned index = 0;
<span class="line-modified">!             JSArray* array = constructEmptyArray(exec, nullptr, 2);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;set&quot;, iteratedValue));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;kind&quot;, jsNontrivialString(vm, kind)));</span>
              return array;
          }
      }
  
      if (JSStringIterator* stringIterator = jsDynamicCast&lt;JSStringIterator*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(exec, nullptr, 1);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          scope.release();
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;string&quot;, stringIterator-&gt;iteratedValue(exec)));</span>
          return array;
      }
  
      return jsUndefined();
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::proxyTargetValue(ExecState *exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      ProxyObject* proxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, value);
      if (!proxy)
          return jsUndefined();
  
      JSObject* target = proxy-&gt;target();
<span class="line-new-header">--- 293,159 ---</span>
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;displayName&quot;), jsString(vm, displayName));
  
      return result;
  }
  
<span class="line-modified">! static JSObject* constructInternalProperty(JSGlobalObject* globalObject, const String&amp; name, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* result = constructEmptyObject(globalObject);</span>
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, name));
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), value);
      return result;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::getInternalProperties(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
  
<span class="line-modified">!     JSValue internalProperties = impl().getInternalProperties(vm, globalObject, value);</span>
      if (internalProperties)
          return internalProperties;
  
      if (JSPromise* promise = jsDynamicCast&lt;JSPromise*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          switch (promise-&gt;status(vm)) {
          case JSPromise::Status::Pending:
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;status&quot;_s, jsNontrivialString(vm, &quot;pending&quot;_s)));</span>
              return array;
          case JSPromise::Status::Fulfilled:
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;status&quot;_s, jsNontrivialString(vm, &quot;resolved&quot;_s)));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;result&quot;_s, promise-&gt;result(vm)));</span>
              return array;
          case JSPromise::Status::Rejected:
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;status&quot;_s, jsNontrivialString(vm, &quot;rejected&quot;_s)));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;result&quot;_s, promise-&gt;result(vm)));</span>
              return array;
          }
          // FIXME: &lt;https://webkit.org/b/141664&gt; Web Inspector: ES6: Improved Support for Promises - Promise Reactions
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      if (JSBoundFunction* boundFunction = jsDynamicCast&lt;JSBoundFunction*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;targetFunction&quot;, boundFunction-&gt;targetFunction()));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;boundThis&quot;, boundFunction-&gt;boundThis()));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          if (boundFunction-&gt;boundArgs()) {
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;boundArgs&quot;, boundFunction-&gt;boundArgsCopy(globalObject)));</span>
              return array;
          }
          return array;
      }
  
      if (ProxyObject* proxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(globalObject, nullptr, 2);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;target&quot;_s, proxy-&gt;target()));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          scope.release();
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;handler&quot;_s, proxy-&gt;handler()));</span>
          return array;
      }
  
      if (JSObject* iteratorObject = jsDynamicCast&lt;JSObject*&gt;(vm, value)) {
<span class="line-modified">!         auto toString = [&amp;] (IterationKind kind) {</span>
<span class="line-modified">!             switch (kind) {</span>
<span class="line-modified">!             case IterationKind::Keys:</span>
<span class="line-added">+                 return jsNontrivialString(vm, &quot;keys&quot;_s);</span>
<span class="line-added">+             case IterationKind::Values:</span>
<span class="line-added">+                 return jsNontrivialString(vm, &quot;values&quot;_s);</span>
<span class="line-added">+             case IterationKind::Entries:</span>
<span class="line-added">+                 return jsNontrivialString(vm, &quot;entries&quot;_s);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return jsNontrivialString(vm, &quot;&quot;_s);</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (auto* arrayIterator = jsDynamicCast&lt;JSArrayIterator*&gt;(vm, iteratorObject)) {</span>
<span class="line-added">+             JSValue iteratedValue = arrayIterator-&gt;iteratedObject();</span>
<span class="line-added">+             IterationKind kind = arrayIterator-&gt;kind();</span>
  
              unsigned index = 0;
<span class="line-modified">!             JSArray* array = constructEmptyArray(globalObject, nullptr, 2);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;array&quot;, iteratedValue));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;kind&quot;, toString(kind)));</span>
              return array;
          }
  
          if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())) {
              JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
<span class="line-modified">!             IterationKind kind = static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName()).asInt32());</span>
<span class="line-modified">! </span>
              unsigned index = 0;
<span class="line-modified">!             JSArray* array = constructEmptyArray(globalObject, nullptr, 2);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;map&quot;, iteratedValue));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;kind&quot;, toString(kind)));</span>
              return array;
          }
  
          if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName())) {
              JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
<span class="line-modified">!             IterationKind kind = static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName()).asInt32());</span>
<span class="line-modified">! </span>
              unsigned index = 0;
<span class="line-modified">!             JSArray* array = constructEmptyArray(globalObject, nullptr, 2);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;set&quot;, iteratedValue));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              scope.release();
<span class="line-modified">!             array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;kind&quot;, toString(kind)));</span>
              return array;
          }
      }
  
      if (JSStringIterator* stringIterator = jsDynamicCast&lt;JSStringIterator*&gt;(vm, value)) {
          unsigned index = 0;
<span class="line-modified">!         JSArray* array = constructEmptyArray(globalObject, nullptr, 1);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          scope.release();
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index++, constructInternalProperty(globalObject, &quot;string&quot;, stringIterator-&gt;iteratedString()));</span>
          return array;
      }
  
      return jsUndefined();
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::proxyTargetValue(VM&amp; vm, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      ProxyObject* proxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, value);
      if (!proxy)
          return jsUndefined();
  
      JSObject* target = proxy-&gt;target();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,273 ***</span>
          target = proxy-&gt;target();
  
      return target;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakMapSize(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      JSWeakMap* weakMap = jsDynamicCast&lt;JSWeakMap*&gt;(vm, value);
      if (!weakMap)
          return jsUndefined();
  
      return jsNumber(weakMap-&gt;size());
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakMapEntries(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
<span class="line-removed">-     JSWeakMap* weakMap = jsDynamicCast&lt;JSWeakMap*&gt;(vm, value);</span>
      if (!weakMap)
          return jsUndefined();
  
<span class="line-modified">!     unsigned numberToFetch = 100;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     JSValue numberToFetchArg = exec-&gt;argument(1);</span>
<span class="line-modified">!     double fetchDouble = numberToFetchArg.toInteger(exec);</span>
<span class="line-removed">-     if (fetchDouble &gt;= 0)</span>
<span class="line-removed">-         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-removed">-     MarkedArgumentBuffer buffer;</span>
<span class="line-removed">-     weakMap-&gt;takeSnapshot(buffer, numberToFetch);</span>
<span class="line-removed">- </span>
      for (unsigned index = 0; index &lt; buffer.size(); index += 2) {
<span class="line-modified">!         JSObject* entry = constructEmptyObject(exec);</span>
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;key&quot;), buffer.at(index));
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), buffer.at(index + 1));
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index / 2, entry);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      }
  
      return array;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakSetSize(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      JSWeakSet* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, value);
      if (!weakSet)
          return jsUndefined();
  
      return jsNumber(weakSet-&gt;size());
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakSetEntries(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
<span class="line-removed">-     JSWeakSet* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, value);</span>
      if (!weakSet)
          return jsUndefined();
  
<span class="line-modified">!     unsigned numberToFetch = 100;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     JSValue numberToFetchArg = exec-&gt;argument(1);</span>
<span class="line-modified">!     double fetchDouble = numberToFetchArg.toInteger(exec);</span>
<span class="line-removed">-     if (fetchDouble &gt;= 0)</span>
<span class="line-removed">-         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-removed">-     MarkedArgumentBuffer buffer;</span>
<span class="line-removed">-     weakSet-&gt;takeSnapshot(buffer, numberToFetch);</span>
<span class="line-removed">- </span>
      for (unsigned index = 0; index &lt; buffer.size(); ++index) {
<span class="line-modified">!         JSObject* entry = constructEmptyObject(exec);</span>
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), buffer.at(index));
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index, entry);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      }
  
      return array;
  }
  
<span class="line-modified">! static JSObject* cloneArrayIteratorObject(ExecState* exec, VM&amp; vm, JSObject* iteratorObject, JSGlobalObject* globalObject, JSValue nextIndex, JSValue iteratedObject)</span>
  {
<span class="line-modified">!     ASSERT(iteratorObject-&gt;type() == FinalObjectType);</span>
<span class="line-modified">!     JSObject* clone = constructEmptyObject(exec, ArrayIteratorPrototype::create(vm, globalObject, ArrayIteratorPrototype::createStructure(vm, globalObject, globalObject-&gt;iteratorPrototype())));</span>
<span class="line-removed">-     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName(), iteratedObject);</span>
<span class="line-removed">-     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorKindPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorKindPrivateName()));</span>
<span class="line-removed">-     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName(), nextIndex);</span>
<span class="line-removed">-     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextPrivateName()));</span>
<span class="line-removed">-     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorIsDonePrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorIsDonePrivateName()));</span>
      return clone;
  }
  
<span class="line-modified">! static JSObject* cloneMapIteratorObject(ExecState* exec, VM&amp; vm, JSObject* iteratorObject, JSGlobalObject* globalObject, JSValue mapBucket, JSValue iteratedObject)</span>
  {
      ASSERT(iteratorObject-&gt;type() == FinalObjectType);
<span class="line-modified">!     JSObject* clone = constructEmptyObject(exec, MapIteratorPrototype::create(vm, globalObject, MapIteratorPrototype::createStructure(vm, globalObject, globalObject-&gt;iteratorPrototype())));</span>
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName(), iteratedObject);
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName()));
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName(), mapBucket);
      return clone;
  }
  
<span class="line-modified">! static JSObject* cloneSetIteratorObject(ExecState* exec, VM&amp; vm, JSObject* iteratorObject, JSGlobalObject* globalObject, JSValue setBucket, JSValue iteratedObject)</span>
  {
      ASSERT(iteratorObject-&gt;type() == FinalObjectType);
<span class="line-modified">!     JSObject* clone = constructEmptyObject(exec, SetIteratorPrototype::create(vm, globalObject, SetIteratorPrototype::createStructure(vm, globalObject, globalObject-&gt;iteratorPrototype())));</span>
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName(), iteratedObject);
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName()));
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName(), setBucket);
      return clone;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::iteratorEntries(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue iterator;
<span class="line-modified">!     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">-     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      if (JSStringIterator* stringIterator = jsDynamicCast&lt;JSStringIterator*&gt;(vm, value)) {
          if (globalObject-&gt;isStringPrototypeIteratorProtocolFastAndNonObservable())
<span class="line-modified">!             iterator = stringIterator-&gt;clone(exec);</span>
      } else if (JSObject* iteratorObject = jsDynamicCast&lt;JSObject*&gt;(vm, value)) {
<span class="line-modified">!         // Detect an ArrayIterator by checking for one of its unique private properties.</span>
<span class="line-modified">!         JSValue iteratedObject = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());</span>
<span class="line-removed">-         if (JSValue nextIndex = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName())) {</span>
              if (isJSArray(iteratedObject)) {
                  JSArray* array = jsCast&lt;JSArray*&gt;(iteratedObject);
                  if (array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">!                     iterator = cloneArrayIteratorObject(exec, vm, iteratorObject, globalObject, nextIndex, iteratedObject);</span>
<span class="line-modified">!             } else if (iteratedObject.isObject() &amp;&amp; TypeInfo::isArgumentsType(asObject(iteratedObject)-&gt;type())) {</span>
                  if (globalObject-&gt;isArrayPrototypeIteratorProtocolFastAndNonObservable())
<span class="line-modified">!                     iterator = cloneArrayIteratorObject(exec, vm, iteratorObject, globalObject, nextIndex, iteratedObject);</span>
              }
<span class="line-removed">-         } else if (JSValue mapBucket = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())) {</span>
<span class="line-removed">-             if (jsCast&lt;JSMap*&gt;(iteratedObject)-&gt;isIteratorProtocolFastAndNonObservable())</span>
<span class="line-removed">-                 iterator = cloneMapIteratorObject(exec, vm, iteratorObject, globalObject, mapBucket, iteratedObject);</span>
<span class="line-removed">-         } else if (JSValue setBucket = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName())) {</span>
<span class="line-removed">-             if (jsCast&lt;JSSet*&gt;(iteratedObject)-&gt;isIteratorProtocolFastAndNonObservable())</span>
<span class="line-removed">-                 iterator = cloneSetIteratorObject(exec, vm, iteratorObject, globalObject, setBucket, iteratedObject);</span>
          }
      }
      RETURN_IF_EXCEPTION(scope, { });
      if (!iterator)
          return jsUndefined();
  
<span class="line-modified">!     IterationRecord iterationRecord = { iterator, iterator.get(exec, vm.propertyNames-&gt;next) };</span>
  
      unsigned numberToFetch = 5;
<span class="line-modified">!     JSValue numberToFetchArg = exec-&gt;argument(1);</span>
<span class="line-modified">!     double fetchDouble = numberToFetchArg.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (fetchDouble &gt;= 0)
          numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      for (unsigned i = 0; i &lt; numberToFetch; ++i) {
<span class="line-modified">!         JSValue next = iteratorStep(exec, iterationRecord);</span>
          if (UNLIKELY(scope.exception()) || next.isFalse())
              break;
  
<span class="line-modified">!         JSValue nextValue = iteratorValue(exec, next);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!         JSObject* entry = constructEmptyObject(exec);</span>
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), nextValue);
<span class="line-modified">!         array-&gt;putDirectIndex(exec, i, entry);</span>
          if (UNLIKELY(scope.exception())) {
              scope.release();
<span class="line-modified">!             iteratorClose(exec, iterationRecord);</span>
              break;
          }
      }
  
      return array;
  }
  
<span class="line-modified">! static bool checkForbiddenPrototype(ExecState* exec, JSValue value, JSValue proto)</span>
  {
      if (value == proto)
          return true;
  
      // Check that the prototype chain of proto hasn&#39;t been modified to include value.
<span class="line-modified">!     return JSObject::defaultHasInstance(exec, proto, value);</span>
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::queryInstances(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue prototypeOrConstructor = exec-&gt;uncheckedArgument(0);</span>
      if (!prototypeOrConstructor.isObject())
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances first argument must be an object.&quot;_s);</span>
  
      JSObject* object = asObject(prototypeOrConstructor);
      if (object-&gt;inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with a Proxy.&quot;_s);</span>
  
      JSValue prototype = object;
  
      PropertySlot prototypeSlot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     if (object-&gt;getPropertySlot(exec, vm.propertyNames-&gt;prototype, prototypeSlot)) {</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (prototypeSlot.isValue()) {
<span class="line-modified">!             JSValue prototypeValue = prototypeSlot.getValue(exec, vm.propertyNames-&gt;prototype);</span>
              if (prototypeValue.isObject()) {
                  prototype = prototypeValue;
                  object = asObject(prototype);
              }
          }
      }
  
      if (object-&gt;inherits&lt;ProxyObject&gt;(vm) || prototype.inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with a Proxy.&quot;_s);</span>
  
      // FIXME: implement a way of distinguishing between internal and user-created objects.
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-modified">!     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;objectPrototype()))</span>
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Object.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;functionPrototype()))</span>
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Function.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;arrayPrototype()))</span>
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Array.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;mapPrototype()))</span>
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Map.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;jsSetPrototype()))</span>
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Set.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;promisePrototype()))</span>
<span class="line-removed">-         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Promise.&quot;_s);</span>
  
      sanitizeStackForVM(vm);
      vm.heap.collectNow(Sync, CollectionScope::Full);
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      {
          HeapIterationScope iterationScope(vm.heap);
          vm.heap.objectSpace().forEachLiveCell(iterationScope, [&amp;] (HeapCell* cell, HeapCell::Kind kind) {
<span class="line-new-header">--- 453,256 ---</span>
          target = proxy-&gt;target();
  
      return target;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakMapSize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      JSWeakMap* weakMap = jsDynamicCast&lt;JSWeakMap*&gt;(vm, value);
      if (!weakMap)
          return jsUndefined();
  
      return jsNumber(weakMap-&gt;size());
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakMapEntries(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* weakMap = jsDynamicCast&lt;JSWeakMap*&gt;(vm, callFrame-&gt;uncheckedArgument(0));</span>
      if (!weakMap)
          return jsUndefined();
  
<span class="line-modified">!     MarkedArgumentBuffer buffer;</span>
<span class="line-modified">!     auto fetchCount = callFrame-&gt;argument(1).toInteger(globalObject);</span>
<span class="line-modified">!     weakMap-&gt;takeSnapshot(buffer, fetchCount &gt;= 0 ? static_cast&lt;unsigned&gt;(fetchCount) : 0);</span>
<span class="line-modified">!     ASSERT(!buffer.hasOverflowed());</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      for (unsigned index = 0; index &lt; buffer.size(); index += 2) {
<span class="line-modified">!         JSObject* entry = constructEmptyObject(globalObject);</span>
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;key&quot;), buffer.at(index));
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), buffer.at(index + 1));
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index / 2, entry);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      }
  
      return array;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakSetSize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      JSWeakSet* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, value);
      if (!weakSet)
          return jsUndefined();
  
      return jsNumber(weakSet-&gt;size());
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::weakSetEntries(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, callFrame-&gt;uncheckedArgument(0));</span>
      if (!weakSet)
          return jsUndefined();
  
<span class="line-modified">!     MarkedArgumentBuffer buffer;</span>
<span class="line-modified">!     auto fetchCount = callFrame-&gt;argument(1).toInteger(globalObject);</span>
<span class="line-modified">!     weakSet-&gt;takeSnapshot(buffer, fetchCount &gt;= 0 ? static_cast&lt;unsigned&gt;(fetchCount) : 0);</span>
<span class="line-modified">!     ASSERT(!buffer.hasOverflowed());</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      for (unsigned index = 0; index &lt; buffer.size(); ++index) {
<span class="line-modified">!         JSObject* entry = constructEmptyObject(globalObject);</span>
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), buffer.at(index));
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index, entry);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      }
  
      return array;
  }
  
<span class="line-modified">! static JSObject* cloneArrayIteratorObject(JSGlobalObject* globalObject, VM&amp; vm, JSArrayIterator* iteratorObject)</span>
  {
<span class="line-modified">!     JSArrayIterator* clone = JSArrayIterator::create(vm, globalObject-&gt;arrayIteratorStructure(), iteratorObject-&gt;iteratedObject(), iteratorObject-&gt;internalField(JSArrayIterator::Field::Kind).get());</span>
<span class="line-modified">!     clone-&gt;internalField(JSArrayIterator::Field::Index).set(vm, clone, iteratorObject-&gt;internalField(JSArrayIterator::Field::Index).get());</span>
      return clone;
  }
  
<span class="line-modified">! static JSObject* cloneMapIteratorObject(JSGlobalObject* globalObject, VM&amp; vm, JSObject* iteratorObject, JSValue mapBucket, JSValue iteratedObject)</span>
  {
      ASSERT(iteratorObject-&gt;type() == FinalObjectType);
<span class="line-modified">!     JSObject* clone = constructEmptyObject(globalObject, MapIteratorPrototype::create(vm, globalObject, MapIteratorPrototype::createStructure(vm, globalObject, globalObject-&gt;iteratorPrototype())));</span>
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName(), iteratedObject);
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName()));
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName(), mapBucket);
      return clone;
  }
  
<span class="line-modified">! static JSObject* cloneSetIteratorObject(JSGlobalObject* globalObject, VM&amp; vm, JSObject* iteratorObject, JSValue setBucket, JSValue iteratedObject)</span>
  {
      ASSERT(iteratorObject-&gt;type() == FinalObjectType);
<span class="line-modified">!     JSObject* clone = constructEmptyObject(globalObject, SetIteratorPrototype::create(vm, globalObject, SetIteratorPrototype::createStructure(vm, globalObject, globalObject-&gt;iteratorPrototype())));</span>
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName(), iteratedObject);
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName()));
      clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName(), setBucket);
      return clone;
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::iteratorEntries(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue iterator;
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      if (JSStringIterator* stringIterator = jsDynamicCast&lt;JSStringIterator*&gt;(vm, value)) {
          if (globalObject-&gt;isStringPrototypeIteratorProtocolFastAndNonObservable())
<span class="line-modified">!             iterator = stringIterator-&gt;clone(globalObject);</span>
      } else if (JSObject* iteratorObject = jsDynamicCast&lt;JSObject*&gt;(vm, value)) {
<span class="line-modified">!         if (auto* arrayIterator = jsDynamicCast&lt;JSArrayIterator*&gt;(vm, iteratorObject)) {</span>
<span class="line-modified">!             JSObject* iteratedObject = arrayIterator-&gt;iteratedObject();</span>
              if (isJSArray(iteratedObject)) {
                  JSArray* array = jsCast&lt;JSArray*&gt;(iteratedObject);
                  if (array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">!                     iterator = cloneArrayIteratorObject(globalObject, vm, arrayIterator);</span>
<span class="line-modified">!             } else if (TypeInfo::isArgumentsType(iteratedObject-&gt;type())) {</span>
                  if (globalObject-&gt;isArrayPrototypeIteratorProtocolFastAndNonObservable())
<span class="line-modified">!                     iterator = cloneArrayIteratorObject(globalObject, vm, arrayIterator);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             JSValue iteratedObject = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());</span>
<span class="line-added">+             if (JSValue mapBucket = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())) {</span>
<span class="line-added">+                 if (jsCast&lt;JSMap*&gt;(iteratedObject)-&gt;isIteratorProtocolFastAndNonObservable())</span>
<span class="line-added">+                     iterator = cloneMapIteratorObject(globalObject, vm, iteratorObject, mapBucket, iteratedObject);</span>
<span class="line-added">+             } else if (JSValue setBucket = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName())) {</span>
<span class="line-added">+                 if (jsCast&lt;JSSet*&gt;(iteratedObject)-&gt;isIteratorProtocolFastAndNonObservable())</span>
<span class="line-added">+                     iterator = cloneSetIteratorObject(globalObject, vm, iteratorObject, setBucket, iteratedObject);</span>
              }
          }
      }
      RETURN_IF_EXCEPTION(scope, { });
      if (!iterator)
          return jsUndefined();
  
<span class="line-modified">!     IterationRecord iterationRecord = { iterator, iterator.get(globalObject, vm.propertyNames-&gt;next) };</span>
  
      unsigned numberToFetch = 5;
<span class="line-modified">!     JSValue numberToFetchArg = callFrame-&gt;argument(1);</span>
<span class="line-modified">!     double fetchDouble = numberToFetchArg.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (fetchDouble &gt;= 0)
          numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      for (unsigned i = 0; i &lt; numberToFetch; ++i) {
<span class="line-modified">!         JSValue next = iteratorStep(globalObject, iterationRecord);</span>
          if (UNLIKELY(scope.exception()) || next.isFalse())
              break;
  
<span class="line-modified">!         JSValue nextValue = iteratorValue(globalObject, next);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!         JSObject* entry = constructEmptyObject(globalObject);</span>
          entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), nextValue);
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, i, entry);</span>
          if (UNLIKELY(scope.exception())) {
              scope.release();
<span class="line-modified">!             iteratorClose(globalObject, iterationRecord);</span>
              break;
          }
      }
  
      return array;
  }
  
<span class="line-modified">! static bool checkForbiddenPrototype(JSGlobalObject* globalObject, JSValue value, JSValue proto)</span>
  {
      if (value == proto)
          return true;
  
      // Check that the prototype chain of proto hasn&#39;t been modified to include value.
<span class="line-modified">!     return JSObject::defaultHasInstance(globalObject, proto, value);</span>
  }
  
<span class="line-modified">! JSValue JSInjectedScriptHost::queryInstances(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue prototypeOrConstructor = callFrame-&gt;uncheckedArgument(0);</span>
      if (!prototypeOrConstructor.isObject())
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances first argument must be an object.&quot;_s);</span>
  
      JSObject* object = asObject(prototypeOrConstructor);
      if (object-&gt;inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with a Proxy.&quot;_s);</span>
  
      JSValue prototype = object;
  
      PropertySlot prototypeSlot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     if (object-&gt;getPropertySlot(globalObject, vm.propertyNames-&gt;prototype, prototypeSlot)) {</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (prototypeSlot.isValue()) {
<span class="line-modified">!             JSValue prototypeValue = prototypeSlot.getValue(globalObject, vm.propertyNames-&gt;prototype);</span>
              if (prototypeValue.isObject()) {
                  prototype = prototypeValue;
                  object = asObject(prototype);
              }
          }
      }
  
      if (object-&gt;inherits&lt;ProxyObject&gt;(vm) || prototype.inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with a Proxy.&quot;_s);</span>
  
      // FIXME: implement a way of distinguishing between internal and user-created objects.
<span class="line-modified">!     if (checkForbiddenPrototype(globalObject, object, globalObject-&gt;objectPrototype()))</span>
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with Object.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(globalObject, object, globalObject-&gt;functionPrototype()))</span>
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with Function.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(globalObject, object, globalObject-&gt;arrayPrototype()))</span>
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with Array.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(globalObject, object, globalObject-&gt;mapPrototype()))</span>
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with Map.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(globalObject, object, globalObject-&gt;jsSetPrototype()))</span>
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with Set.&quot;_s);</span>
<span class="line-modified">!     if (checkForbiddenPrototype(globalObject, object, globalObject-&gt;promisePrototype()))</span>
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryInstances cannot be called with Promise.&quot;_s);</span>
  
      sanitizeStackForVM(vm);
      vm.heap.collectNow(Sync, CollectionScope::Full);
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      {
          HeapIterationScope iterationScope(vm.heap);
          vm.heap.objectSpace().forEachLiveCell(iterationScope, [&amp;] (HeapCell* cell, HeapCell::Kind kind) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 737,12 ***</span>
  
              JSValue value(static_cast&lt;JSCell*&gt;(cell));
              if (value.inherits&lt;ProxyObject&gt;(vm))
                  return IterationStatus::Continue;
  
<span class="line-modified">!             if (JSObject::defaultHasInstance(exec, value, prototype))</span>
<span class="line-modified">!                 array-&gt;putDirectIndex(exec, array-&gt;length(), value);</span>
  
              return IterationStatus::Continue;
          });
      }
  
<span class="line-new-header">--- 711,12 ---</span>
  
              JSValue value(static_cast&lt;JSCell*&gt;(cell));
              if (value.inherits&lt;ProxyObject&gt;(vm))
                  return IterationStatus::Continue;
  
<span class="line-modified">!             if (JSObject::defaultHasInstance(globalObject, value, prototype))</span>
<span class="line-modified">!                 array-&gt;putDirectIndex(globalObject, array-&gt;length(), value);</span>
  
              return IterationStatus::Continue;
          });
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 796,11 ***</span>
          });
      }
  
      HashSet&lt;JSCell*&gt;&amp; holders() { return m_holders; }
  
<span class="line-modified">!     void analyzeEdge(JSCell* from, JSCell* to, SlotVisitor::RootMarkReason reason)</span>
      {
          ASSERT(to);
          ASSERT(to-&gt;vm().heapProfiler()-&gt;activeHeapAnalyzer() == this);
  
          auto locker = holdLock(m_mutex);
<span class="line-new-header">--- 770,11 ---</span>
          });
      }
  
      HashSet&lt;JSCell*&gt;&amp; holders() { return m_holders; }
  
<span class="line-modified">!     void analyzeEdge(JSCell* from, JSCell* to, SlotVisitor::RootMarkReason reason) override</span>
      {
          ASSERT(to);
          ASSERT(to-&gt;vm().heapProfiler()-&gt;activeHeapAnalyzer() == this);
  
          auto locker = holdLock(m_mutex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 821,18 ***</span>
          if (reason == SlotVisitor::RootMarkReason::Debugger)
              m_rootsToIgnore.add(to);
          else if (!from || reason != SlotVisitor::RootMarkReason::None)
              m_rootsToInclude.add(to);
      }
<span class="line-modified">!     void analyzePropertyNameEdge(JSCell* from, JSCell* to, UniquedStringImpl*) { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
<span class="line-modified">!     void analyzeVariableNameEdge(JSCell* from, JSCell* to, UniquedStringImpl*) { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
<span class="line-modified">!     void analyzeIndexEdge(JSCell* from, JSCell* to, uint32_t) { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
  
<span class="line-modified">!     void analyzeNode(JSCell*) { }</span>
<span class="line-modified">!     void setOpaqueRootReachabilityReasonForCell(JSCell*, const char*) { }</span>
<span class="line-modified">!     void setWrappedObjectForCell(JSCell*, void*) { }</span>
<span class="line-modified">!     void setLabelForCell(JSCell*, const String&amp;) { }</span>
  
  #ifndef NDEBUG
      void dump(PrintStream&amp; out) const
      {
          Indentation&lt;4&gt; indent;
<span class="line-new-header">--- 795,18 ---</span>
          if (reason == SlotVisitor::RootMarkReason::Debugger)
              m_rootsToIgnore.add(to);
          else if (!from || reason != SlotVisitor::RootMarkReason::None)
              m_rootsToInclude.add(to);
      }
<span class="line-modified">!     void analyzePropertyNameEdge(JSCell* from, JSCell* to, UniquedStringImpl*) override { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
<span class="line-modified">!     void analyzeVariableNameEdge(JSCell* from, JSCell* to, UniquedStringImpl*) override { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
<span class="line-modified">!     void analyzeIndexEdge(JSCell* from, JSCell* to, uint32_t) override { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
  
<span class="line-modified">!     void analyzeNode(JSCell*) override { }</span>
<span class="line-modified">!     void setOpaqueRootReachabilityReasonForCell(JSCell*, const char*) override { }</span>
<span class="line-modified">!     void setWrappedObjectForCell(JSCell*, void*) override { }</span>
<span class="line-modified">!     void setLabelForCell(JSCell*, const String&amp;) override { }</span>
  
  #ifndef NDEBUG
      void dump(PrintStream&amp; out) const
      {
          Indentation&lt;4&gt; indent;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,23 ***</span>
      HashSet&lt;JSCell*&gt; m_rootsToIgnore;
      HashSet&lt;JSCell*&gt; m_holders;
      const JSCell* m_target;
  };
  
<span class="line-modified">! JSValue JSInjectedScriptHost::queryHolders(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;uncheckedArgument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;queryHolders first argument must be an object.&quot;_s);</span>
  
<span class="line-modified">!     JSArray* result = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      {
          DeferGC deferGC(vm.heap);
          PreventCollectionScope preventCollectionScope(vm.heap);
<span class="line-new-header">--- 855,23 ---</span>
      HashSet&lt;JSCell*&gt; m_rootsToIgnore;
      HashSet&lt;JSCell*&gt; m_holders;
      const JSCell* m_target;
  };
  
<span class="line-modified">! JSValue JSInjectedScriptHost::queryHolders(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return jsUndefined();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;uncheckedArgument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;queryHolders first argument must be an object.&quot;_s);</span>
  
<span class="line-modified">!     JSArray* result = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      {
          DeferGC deferGC(vm.heap);
          PreventCollectionScope preventCollectionScope(vm.heap);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 906,11 ***</span>
          HeapHolderFinder holderFinder(vm.ensureHeapProfiler(), target.asCell());
  
          auto holders = copyToVector(holderFinder.holders());
          std::sort(holders.begin(), holders.end());
          for (auto* holder : holders)
<span class="line-modified">!             result-&gt;putDirectIndex(exec, result-&gt;length(), holder);</span>
      }
  
      return result;
  }
  
<span class="line-new-header">--- 880,11 ---</span>
          HeapHolderFinder holderFinder(vm.ensureHeapProfiler(), target.asCell());
  
          auto holders = copyToVector(holderFinder.holders());
          std::sort(holders.begin(), holders.end());
          for (auto* holder : holders)
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, result-&gt;length(), holder);</span>
      }
  
      return result;
  }
  
</pre>
<center><a href="JSGlobalObjectScriptDebugServer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSInjectedScriptHost.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
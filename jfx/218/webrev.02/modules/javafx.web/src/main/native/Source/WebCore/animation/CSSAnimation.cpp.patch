diff a/modules/javafx.web/src/main/native/Source/WebCore/animation/CSSAnimation.cpp b/modules/javafx.web/src/main/native/Source/WebCore/animation/CSSAnimation.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/animation/CSSAnimation.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/animation/CSSAnimation.cpp
@@ -25,29 +25,33 @@
 
 #include "config.h"
 #include "CSSAnimation.h"
 
 #include "Animation.h"
+#include "AnimationEvent.h"
 #include "Element.h"
+#include "InspectorInstrumentation.h"
 #include "RenderStyle.h"
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(CSSAnimation);
 
 Ref<CSSAnimation> CSSAnimation::create(Element& owningElement, const Animation& backingAnimation, const RenderStyle* oldStyle, const RenderStyle& newStyle)
 {
-    auto result = adoptRef(*new CSSAnimation(owningElement, backingAnimation, newStyle));
+    auto result = adoptRef(*new CSSAnimation(owningElement, backingAnimation));
     result->initialize(oldStyle, newStyle);
+
+    InspectorInstrumentation::didCreateWebAnimation(result.get());
+
     return result;
 }
 
-CSSAnimation::CSSAnimation(Element& element, const Animation& backingAnimation, const RenderStyle& unanimatedStyle)
+CSSAnimation::CSSAnimation(Element& element, const Animation& backingAnimation)
     : DeclarativeAnimation(element, backingAnimation)
     , m_animationName(backingAnimation.name())
-    , m_unanimatedStyle(RenderStyle::clonePtr(unanimatedStyle))
 {
 }
 
 void CSSAnimation::syncPropertiesWithBackingAnimation()
 {
@@ -59,10 +63,12 @@
     suspendEffectInvalidation();
 
     auto& animation = backingAnimation();
     auto* animationEffect = effect();
 
+    auto previousTiming = animationEffect->getComputedTiming();
+
     switch (animation.fillMode()) {
     case AnimationFillMode::None:
         animationEffect->setFill(FillMode::None);
         break;
     case AnimationFillMode::Backwards:
@@ -94,10 +100,12 @@
     auto iterationCount = animation.iterationCount();
     animationEffect->setIterations(iterationCount == Animation::IterationCountInfinite ? std::numeric_limits<double>::infinity() : iterationCount);
 
     animationEffect->setDelay(Seconds(animation.delay()));
     animationEffect->setIterationDuration(Seconds(animation.duration()));
+    animationEffect->updateStaticTimingProperties();
+    effectTimingDidChange(previousTiming);
 
     // Synchronize the play state
     if (animation.playState() == AnimationPlayState::Playing && playState() == WebAnimation::PlayState::Paused) {
         if (!m_stickyPaused)
             play();
@@ -117,6 +125,11 @@
 {
     m_stickyPaused = true;
     return DeclarativeAnimation::bindingsPause();
 }
 
+Ref<AnimationEventBase> CSSAnimation::createEvent(const AtomString& eventType, double elapsedTime, const String& pseudoId, Optional<Seconds> timelineTime)
+{
+    return AnimationEvent::create(eventType, m_animationName, elapsedTime, pseudoId, timelineTime, this);
+}
+
 } // namespace WebCore

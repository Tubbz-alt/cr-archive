<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/HistoryController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTTPHeaderField.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/HistoryController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *     documentation and/or other materials provided with the distribution.
 15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 16  *     its contributors may be used to endorse or promote products derived
 17  *     from this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;HistoryController.h&quot;
 33 

 34 #include &quot;BackForwardController.h&quot;
 35 #include &quot;CachedPage.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;DocumentLoader.h&quot;
 38 #include &quot;Frame.h&quot;
 39 #include &quot;FrameLoader.h&quot;
 40 #include &quot;FrameLoaderClient.h&quot;
 41 #include &quot;FrameLoaderStateMachine.h&quot;
 42 #include &quot;FrameTree.h&quot;
 43 #include &quot;FrameView.h&quot;
 44 #include &quot;HistoryItem.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;Page.h&quot;
<span class="line-removed"> 47 #include &quot;PageCache.h&quot;</span>
 48 #include &quot;ScrollingCoordinator.h&quot;
 49 #include &quot;SerializedScriptValue.h&quot;
 50 #include &quot;SharedStringHash.h&quot;
 51 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
 52 #include &quot;VisitedLinkStore.h&quot;
 53 #include &lt;wtf/text/CString.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 static inline void addVisitedLink(Page&amp; page, const URL&amp; url)
 58 {
 59     page.visitedLinkStore().addVisitedLink(page, computeSharedStringHash(url.string()));
 60 }
 61 
 62 HistoryController::HistoryController(Frame&amp; frame)
 63     : m_frame(frame)
 64     , m_frameLoadComplete(true)
 65     , m_defersLoading(false)
 66 {
 67 }
 68 
 69 HistoryController::~HistoryController() = default;
 70 
 71 void HistoryController::saveScrollPositionAndViewStateToItem(HistoryItem* item)
 72 {
 73     FrameView* frameView = m_frame.view();
 74     if (!item || !frameView)
 75         return;
 76 
<span class="line-modified"> 77     if (m_frame.document()-&gt;pageCacheState() != Document::NotInPageCache)</span>
 78         item-&gt;setScrollPosition(frameView-&gt;cachedScrollPosition());
 79     else
 80         item-&gt;setScrollPosition(frameView-&gt;scrollPosition());
 81 
 82 #if PLATFORM(IOS_FAMILY)
 83     item-&gt;setExposedContentRect(frameView-&gt;exposedContentRect());
 84     item-&gt;setUnobscuredContentRect(frameView-&gt;unobscuredContentRect());
 85 #endif
 86 
 87     Page* page = m_frame.page();
 88     if (page &amp;&amp; m_frame.isMainFrame()) {
 89         item-&gt;setPageScaleFactor(page-&gt;pageScaleFactor() / page-&gt;viewScaleFactor());
 90 #if PLATFORM(IOS_FAMILY)
 91         item-&gt;setObscuredInsets(page-&gt;obscuredInsets());
 92 #endif
 93     }
 94 
 95     // FIXME: It would be great to work out a way to put this code in WebCore instead of calling through to the client.
 96     m_frame.loader().client().saveViewStateToItem(*item);
 97 
</pre>
<hr />
<pre>
120  fails.  We then successfully restore it when the layout happens.
121 */
122 void HistoryController::restoreScrollPositionAndViewState()
123 {
124     if (!m_frame.loader().stateMachine().committedFirstRealDocumentLoad())
125         return;
126 
127     ASSERT(m_currentItem);
128 
129     // FIXME: As the ASSERT attests, it seems we should always have a currentItem here.
130     // One counterexample is &lt;rdar://problem/4917290&gt;
131     // For now, to cover this issue in release builds, there is no technical harm to returning
132     // early and from a user standpoint - as in the above radar - the previous page load failed
133     // so there *is* no scroll or view state to restore!
134     if (!m_currentItem)
135         return;
136 
137     auto view = makeRefPtr(m_frame.view());
138 
139     // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
<span class="line-modified">140     // page cache and similar work that needs to occur when it comes out. This is where we do the work</span>
141     // that needs to happen when we exit, and the work that needs to happen when we enter is in
<span class="line-modified">142     // Document::setIsInPageCache(bool). It would be nice if there was more symmetry in these spots.</span>
143     // https://bugs.webkit.org/show_bug.cgi?id=98698
144     if (view) {
145         Page* page = m_frame.page();
146         if (page &amp;&amp; m_frame.isMainFrame()) {
147             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
148                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(*view);
149         }
150     }
151 
152     // FIXME: It would be great to work out a way to put this code in WebCore instead of calling
153     // through to the client.
154     m_frame.loader().client().restoreViewState();
155 
156 #if !PLATFORM(IOS_FAMILY)
157     // Don&#39;t restore scroll point on iOS as FrameLoaderClient::restoreViewState() does that.
158     if (view &amp;&amp; !view-&gt;wasScrolledByUser()) {
159         view-&gt;scrollToFocusedElementImmediatelyIfNeeded();
160 
161         Page* page = m_frame.page();
162         auto desiredScrollPosition = m_currentItem-&gt;shouldRestoreScrollPosition() ? m_currentItem-&gt;scrollPosition() : view-&gt;scrollPosition();
</pre>
<hr />
<pre>
244     }
245 
246     if (!m_currentItem)
247         return;
248     if (m_frame.loader().requestedHistoryItem() != m_currentItem.get())
249         return;
250     if (m_frame.loader().documentLoader()-&gt;isClientRedirect())
251         return;
252 
253     m_frame.loader().documentLoader()-&gt;setShouldOpenExternalURLsPolicy(m_currentItem-&gt;shouldOpenExternalURLsPolicy());
254 
255     LOG(Loading, &quot;WebCoreLoading %s: restoring form state from %p&quot;, m_frame.tree().uniqueName().string().utf8().data(), m_currentItem.get());
256     m_frame.document()-&gt;setStateForNewFormElements(m_currentItem-&gt;documentState());
257 }
258 
259 void HistoryController::invalidateCurrentItemCachedPage()
260 {
261     if (!currentItem())
262         return;
263 
<span class="line-modified">264     // When we are pre-commit, the currentItem is where any page cache data resides.</span>
<span class="line-modified">265     std::unique_ptr&lt;CachedPage&gt; cachedPage = PageCache::singleton().take(*currentItem(), m_frame.page());</span>
266     if (!cachedPage)
267         return;
268 
269     // FIXME: This is a grotesque hack to fix &lt;rdar://problem/4059059&gt; Crash in RenderFlow::detach
270     // Somehow the PageState object is not properly updated, and is holding onto a stale document.
271     // Both Xcode and FileMaker see this crash, Safari does not.
272 
273     ASSERT(cachedPage-&gt;document() == m_frame.document());
274     if (cachedPage-&gt;document() == m_frame.document()) {
<span class="line-modified">275         cachedPage-&gt;document()-&gt;setPageCacheState(Document::NotInPageCache);</span>
276         cachedPage-&gt;clear();
277     }
278 }
279 
280 bool HistoryController::shouldStopLoadingForHistoryItem(HistoryItem&amp; targetItem) const
281 {
282     if (!m_currentItem)
283         return false;
284 
285     // Don&#39;t abort the current load if we&#39;re navigating within the current document.
286     if (m_currentItem-&gt;shouldDoSameDocumentNavigationTo(targetItem))
287         return false;
288 
289     return true;
290 }
291 
292 // Main funnel for navigating to a previous location (back/forward, non-search snap-back)
293 // This includes recursion to handle loading into framesets properly
294 void HistoryController::goToItem(HistoryItem&amp; targetItem, FrameLoadType type, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
295 {
</pre>
<hr />
<pre>
338 }
339 
340 void HistoryController::updateForBackForwardNavigation()
341 {
342     LOG(History, &quot;HistoryController %p updateForBackForwardNavigation: Updating History for back/forward navigation in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
343 
344     // Must grab the current scroll position before disturbing it
345     if (!m_frameLoadComplete)
346         saveScrollPositionAndViewStateToItem(m_previousItem.get());
347 
348     // When traversing history, we may end up redirecting to a different URL
349     // this time (e.g., due to cookies).  See http://webkit.org/b/49654.
350     updateCurrentItem();
351 }
352 
353 void HistoryController::updateForReload()
354 {
355     LOG(History, &quot;HistoryController %p updateForReload: Updating History for reload in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
356 
357     if (m_currentItem) {
<span class="line-modified">358         PageCache::singleton().remove(*m_currentItem);</span>
359 
360         if (m_frame.loader().loadType() == FrameLoadType::Reload || m_frame.loader().loadType() == FrameLoadType::ReloadFromOrigin)
361             saveScrollPositionAndViewStateToItem(m_currentItem.get());
362 
363         // Rebuild the history item tree when reloading as trying to re-associate everything is too error-prone.
364         m_currentItem-&gt;clearChildren();
365     }
366 
367     // When reloading the page, we may end up redirecting to a different URL
368     // this time (e.g., due to cookies).  See http://webkit.org/b/4072.
369     updateCurrentItem();
370 }
371 
372 // There are 3 things you might think of as &quot;history&quot;, all of which are handled by these functions.
373 //
374 //     1) Back/forward: The m_currentItem is part of this mechanism.
375 //     2) Global history: Handled by the client.
376 //     3) Visited links: Handled by the PageGroup.
377 
378 void HistoryController::updateForStandardLoad(HistoryUpdateType updateType)
379 {
380     LOG(History, &quot;HistoryController %p updateForStandardLoad: Updating History for standard load in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader()-&gt;url().string().ascii().data());
381 
382     FrameLoader&amp; frameLoader = m_frame.loader();
383 
<span class="line-modified">384     bool needPrivacy = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
385     const URL&amp; historyURL = frameLoader.documentLoader()-&gt;urlForHistory();
386 
387     if (!frameLoader.documentLoader()-&gt;isClientRedirect()) {
388         if (!historyURL.isEmpty()) {
389             if (updateType != UpdateAllExceptBackForwardList)
390                 updateBackForwardListClippedAtTarget(true);
<span class="line-modified">391             if (!needPrivacy) {</span>
392                 frameLoader.client().updateGlobalHistory();
393                 frameLoader.documentLoader()-&gt;setDidCreateGlobalHistoryEntry(true);
394                 if (frameLoader.documentLoader()-&gt;unreachableURL().isEmpty())
395                     frameLoader.client().updateGlobalHistoryRedirectLinks();
396             }
397         }
398     } else {
399         // The client redirect replaces the current history item.
400         updateCurrentItem();
401     }
402 
<span class="line-modified">403     if (!historyURL.isEmpty() &amp;&amp; !needPrivacy) {</span>
404         if (Page* page = m_frame.page())
405             addVisitedLink(*page, historyURL);
406 
407         if (!frameLoader.documentLoader()-&gt;didCreateGlobalHistoryEntry() &amp;&amp; frameLoader.documentLoader()-&gt;unreachableURL().isEmpty() &amp;&amp; !m_frame.document()-&gt;url().isEmpty())
408             frameLoader.client().updateGlobalHistoryRedirectLinks();
409     }
410 }
411 
412 void HistoryController::updateForRedirectWithLockedBackForwardList()
413 {
414     LOG(History, &quot;HistoryController %p updateForRedirectWithLockedBackForwardList: Updating History for redirect load in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
415 
<span class="line-modified">416     bool needPrivacy = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
417     const URL&amp; historyURL = m_frame.loader().documentLoader()-&gt;urlForHistory();
418 
419     if (m_frame.loader().documentLoader()-&gt;isClientRedirect()) {
420         if (!m_currentItem &amp;&amp; !m_frame.tree().parent()) {
421             if (!historyURL.isEmpty()) {
422                 updateBackForwardListClippedAtTarget(true);
<span class="line-modified">423                 if (!needPrivacy) {</span>
424                     m_frame.loader().client().updateGlobalHistory();
425                     m_frame.loader().documentLoader()-&gt;setDidCreateGlobalHistoryEntry(true);
426                     if (m_frame.loader().documentLoader()-&gt;unreachableURL().isEmpty())
427                         m_frame.loader().client().updateGlobalHistoryRedirectLinks();
428                 }
429             }
430         }
431         // The client redirect replaces the current history item.
432         updateCurrentItem();
433     } else {
434         Frame* parentFrame = m_frame.tree().parent();
435         if (parentFrame &amp;&amp; parentFrame-&gt;loader().history().currentItem())
436             parentFrame-&gt;loader().history().currentItem()-&gt;setChildItem(createItem());
437     }
438 
<span class="line-modified">439     if (!historyURL.isEmpty() &amp;&amp; !needPrivacy) {</span>
440         if (Page* page = m_frame.page())
441             addVisitedLink(*page, historyURL);
442 
443         if (!m_frame.loader().documentLoader()-&gt;didCreateGlobalHistoryEntry() &amp;&amp; m_frame.loader().documentLoader()-&gt;unreachableURL().isEmpty())
444             m_frame.loader().client().updateGlobalHistoryRedirectLinks();
445     }
446 }
447 
448 void HistoryController::updateForClientRedirect()
449 {
450     LOG(History, &quot;HistoryController %p updateForClientRedirect: Updating History for client redirect in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
451 
452     // Clear out form data so we don&#39;t try to restore it into the incoming page.  Must happen after
453     // webcore has closed the URL and saved away the form state.
454     if (m_currentItem) {
455         m_currentItem-&gt;clearDocumentState();
456         m_currentItem-&gt;clearScrollPosition();
457     }
458 
<span class="line-modified">459     bool needPrivacy = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
460     const URL&amp; historyURL = m_frame.loader().documentLoader()-&gt;urlForHistory();
461 
<span class="line-modified">462     if (!historyURL.isEmpty() &amp;&amp; !needPrivacy) {</span>
463         if (Page* page = m_frame.page())
464             addVisitedLink(*page, historyURL);
465     }
466 }
467 
468 void HistoryController::updateForCommit()
469 {
470     FrameLoader&amp; frameLoader = m_frame.loader();
471     LOG(History, &quot;HistoryController %p updateForCommit: Updating History for commit in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
472 
473     FrameLoadType type = frameLoader.loadType();
474     if (isBackForwardLoadType(type)
475         || isReplaceLoadTypeWithProvisionalItem(type)
476         || (isReloadTypeWithProvisionalItem(type) &amp;&amp; !frameLoader.provisionalDocumentLoader()-&gt;unreachableURL().isEmpty())) {
477         // Once committed, we want to use current item for saving DocState, and
478         // the provisional item for restoring state.
479         // Note previousItem must be set before we close the URL, which will
480         // happen when the data source is made non-provisional below
481 
482         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=146842
</pre>
<hr />
<pre>
534         restoreDocumentState();
535 
536         // Restore the scroll position (we choose to do this rather than going back to the anchor point)
537         restoreScrollPositionAndViewState();
538     }
539 
540     // Iterate over the rest of the tree
541     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
542         child-&gt;loader().history().recursiveUpdateForCommit();
543 }
544 
545 void HistoryController::updateForSameDocumentNavigation()
546 {
547     if (m_frame.document()-&gt;url().isEmpty())
548         return;
549 
550     Page* page = m_frame.page();
551     if (!page)
552         return;
553 
<span class="line-modified">554     if (page-&gt;usesEphemeralSession())</span>
<span class="line-modified">555         return;</span>

556 
<span class="line-removed">557     addVisitedLink(*page, m_frame.document()-&gt;url());</span>
558     m_frame.mainFrame().loader().history().recursiveUpdateForSameDocumentNavigation();
559 
560     if (m_currentItem) {
561         m_currentItem-&gt;setURL(m_frame.document()-&gt;url());
<span class="line-modified">562         m_frame.loader().client().updateGlobalHistory();</span>

563     }
564 }
565 
566 void HistoryController::recursiveUpdateForSameDocumentNavigation()
567 {
568     // The frame that navigated will now have a null provisional item.
569     // Ignore it and its children.
570     if (!m_provisionalItem)
571         return;
572 
573     // The provisional item may represent a different pending navigation.
574     // Don&#39;t commit it if it isn&#39;t a same document navigation.
575     if (m_currentItem &amp;&amp; !m_currentItem-&gt;shouldDoSameDocumentNavigationTo(*m_provisionalItem))
576         return;
577 
578     // Commit the provisional item.
579     if (m_provisionalItem)
580         setCurrentItem(*m_provisionalItem.get());
581     m_provisionalItem = nullptr;
582 
</pre>
</td>
<td>
<hr />
<pre>
 14  *     documentation and/or other materials provided with the distribution.
 15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 16  *     its contributors may be used to endorse or promote products derived
 17  *     from this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;HistoryController.h&quot;
 33 
<span class="line-added"> 34 #include &quot;BackForwardCache.h&quot;</span>
 35 #include &quot;BackForwardController.h&quot;
 36 #include &quot;CachedPage.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;DocumentLoader.h&quot;
 39 #include &quot;Frame.h&quot;
 40 #include &quot;FrameLoader.h&quot;
 41 #include &quot;FrameLoaderClient.h&quot;
 42 #include &quot;FrameLoaderStateMachine.h&quot;
 43 #include &quot;FrameTree.h&quot;
 44 #include &quot;FrameView.h&quot;
 45 #include &quot;HistoryItem.h&quot;
 46 #include &quot;Logging.h&quot;
 47 #include &quot;Page.h&quot;

 48 #include &quot;ScrollingCoordinator.h&quot;
 49 #include &quot;SerializedScriptValue.h&quot;
 50 #include &quot;SharedStringHash.h&quot;
 51 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
 52 #include &quot;VisitedLinkStore.h&quot;
 53 #include &lt;wtf/text/CString.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 static inline void addVisitedLink(Page&amp; page, const URL&amp; url)
 58 {
 59     page.visitedLinkStore().addVisitedLink(page, computeSharedStringHash(url.string()));
 60 }
 61 
 62 HistoryController::HistoryController(Frame&amp; frame)
 63     : m_frame(frame)
 64     , m_frameLoadComplete(true)
 65     , m_defersLoading(false)
 66 {
 67 }
 68 
 69 HistoryController::~HistoryController() = default;
 70 
 71 void HistoryController::saveScrollPositionAndViewStateToItem(HistoryItem* item)
 72 {
 73     FrameView* frameView = m_frame.view();
 74     if (!item || !frameView)
 75         return;
 76 
<span class="line-modified"> 77     if (m_frame.document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache)</span>
 78         item-&gt;setScrollPosition(frameView-&gt;cachedScrollPosition());
 79     else
 80         item-&gt;setScrollPosition(frameView-&gt;scrollPosition());
 81 
 82 #if PLATFORM(IOS_FAMILY)
 83     item-&gt;setExposedContentRect(frameView-&gt;exposedContentRect());
 84     item-&gt;setUnobscuredContentRect(frameView-&gt;unobscuredContentRect());
 85 #endif
 86 
 87     Page* page = m_frame.page();
 88     if (page &amp;&amp; m_frame.isMainFrame()) {
 89         item-&gt;setPageScaleFactor(page-&gt;pageScaleFactor() / page-&gt;viewScaleFactor());
 90 #if PLATFORM(IOS_FAMILY)
 91         item-&gt;setObscuredInsets(page-&gt;obscuredInsets());
 92 #endif
 93     }
 94 
 95     // FIXME: It would be great to work out a way to put this code in WebCore instead of calling through to the client.
 96     m_frame.loader().client().saveViewStateToItem(*item);
 97 
</pre>
<hr />
<pre>
120  fails.  We then successfully restore it when the layout happens.
121 */
122 void HistoryController::restoreScrollPositionAndViewState()
123 {
124     if (!m_frame.loader().stateMachine().committedFirstRealDocumentLoad())
125         return;
126 
127     ASSERT(m_currentItem);
128 
129     // FIXME: As the ASSERT attests, it seems we should always have a currentItem here.
130     // One counterexample is &lt;rdar://problem/4917290&gt;
131     // For now, to cover this issue in release builds, there is no technical harm to returning
132     // early and from a user standpoint - as in the above radar - the previous page load failed
133     // so there *is* no scroll or view state to restore!
134     if (!m_currentItem)
135         return;
136 
137     auto view = makeRefPtr(m_frame.view());
138 
139     // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
<span class="line-modified">140     // back/forward cache and similar work that needs to occur when it comes out. This is where we do the work</span>
141     // that needs to happen when we exit, and the work that needs to happen when we enter is in
<span class="line-modified">142     // Document::setIsInBackForwardCache(bool). It would be nice if there was more symmetry in these spots.</span>
143     // https://bugs.webkit.org/show_bug.cgi?id=98698
144     if (view) {
145         Page* page = m_frame.page();
146         if (page &amp;&amp; m_frame.isMainFrame()) {
147             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
148                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(*view);
149         }
150     }
151 
152     // FIXME: It would be great to work out a way to put this code in WebCore instead of calling
153     // through to the client.
154     m_frame.loader().client().restoreViewState();
155 
156 #if !PLATFORM(IOS_FAMILY)
157     // Don&#39;t restore scroll point on iOS as FrameLoaderClient::restoreViewState() does that.
158     if (view &amp;&amp; !view-&gt;wasScrolledByUser()) {
159         view-&gt;scrollToFocusedElementImmediatelyIfNeeded();
160 
161         Page* page = m_frame.page();
162         auto desiredScrollPosition = m_currentItem-&gt;shouldRestoreScrollPosition() ? m_currentItem-&gt;scrollPosition() : view-&gt;scrollPosition();
</pre>
<hr />
<pre>
244     }
245 
246     if (!m_currentItem)
247         return;
248     if (m_frame.loader().requestedHistoryItem() != m_currentItem.get())
249         return;
250     if (m_frame.loader().documentLoader()-&gt;isClientRedirect())
251         return;
252 
253     m_frame.loader().documentLoader()-&gt;setShouldOpenExternalURLsPolicy(m_currentItem-&gt;shouldOpenExternalURLsPolicy());
254 
255     LOG(Loading, &quot;WebCoreLoading %s: restoring form state from %p&quot;, m_frame.tree().uniqueName().string().utf8().data(), m_currentItem.get());
256     m_frame.document()-&gt;setStateForNewFormElements(m_currentItem-&gt;documentState());
257 }
258 
259 void HistoryController::invalidateCurrentItemCachedPage()
260 {
261     if (!currentItem())
262         return;
263 
<span class="line-modified">264     // When we are pre-commit, the currentItem is where any back/forward cache data resides.</span>
<span class="line-modified">265     std::unique_ptr&lt;CachedPage&gt; cachedPage = BackForwardCache::singleton().take(*currentItem(), m_frame.page());</span>
266     if (!cachedPage)
267         return;
268 
269     // FIXME: This is a grotesque hack to fix &lt;rdar://problem/4059059&gt; Crash in RenderFlow::detach
270     // Somehow the PageState object is not properly updated, and is holding onto a stale document.
271     // Both Xcode and FileMaker see this crash, Safari does not.
272 
273     ASSERT(cachedPage-&gt;document() == m_frame.document());
274     if (cachedPage-&gt;document() == m_frame.document()) {
<span class="line-modified">275         cachedPage-&gt;document()-&gt;setBackForwardCacheState(Document::NotInBackForwardCache);</span>
276         cachedPage-&gt;clear();
277     }
278 }
279 
280 bool HistoryController::shouldStopLoadingForHistoryItem(HistoryItem&amp; targetItem) const
281 {
282     if (!m_currentItem)
283         return false;
284 
285     // Don&#39;t abort the current load if we&#39;re navigating within the current document.
286     if (m_currentItem-&gt;shouldDoSameDocumentNavigationTo(targetItem))
287         return false;
288 
289     return true;
290 }
291 
292 // Main funnel for navigating to a previous location (back/forward, non-search snap-back)
293 // This includes recursion to handle loading into framesets properly
294 void HistoryController::goToItem(HistoryItem&amp; targetItem, FrameLoadType type, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
295 {
</pre>
<hr />
<pre>
338 }
339 
340 void HistoryController::updateForBackForwardNavigation()
341 {
342     LOG(History, &quot;HistoryController %p updateForBackForwardNavigation: Updating History for back/forward navigation in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
343 
344     // Must grab the current scroll position before disturbing it
345     if (!m_frameLoadComplete)
346         saveScrollPositionAndViewStateToItem(m_previousItem.get());
347 
348     // When traversing history, we may end up redirecting to a different URL
349     // this time (e.g., due to cookies).  See http://webkit.org/b/49654.
350     updateCurrentItem();
351 }
352 
353 void HistoryController::updateForReload()
354 {
355     LOG(History, &quot;HistoryController %p updateForReload: Updating History for reload in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
356 
357     if (m_currentItem) {
<span class="line-modified">358         BackForwardCache::singleton().remove(*m_currentItem);</span>
359 
360         if (m_frame.loader().loadType() == FrameLoadType::Reload || m_frame.loader().loadType() == FrameLoadType::ReloadFromOrigin)
361             saveScrollPositionAndViewStateToItem(m_currentItem.get());
362 
363         // Rebuild the history item tree when reloading as trying to re-associate everything is too error-prone.
364         m_currentItem-&gt;clearChildren();
365     }
366 
367     // When reloading the page, we may end up redirecting to a different URL
368     // this time (e.g., due to cookies).  See http://webkit.org/b/4072.
369     updateCurrentItem();
370 }
371 
372 // There are 3 things you might think of as &quot;history&quot;, all of which are handled by these functions.
373 //
374 //     1) Back/forward: The m_currentItem is part of this mechanism.
375 //     2) Global history: Handled by the client.
376 //     3) Visited links: Handled by the PageGroup.
377 
378 void HistoryController::updateForStandardLoad(HistoryUpdateType updateType)
379 {
380     LOG(History, &quot;HistoryController %p updateForStandardLoad: Updating History for standard load in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader()-&gt;url().string().ascii().data());
381 
382     FrameLoader&amp; frameLoader = m_frame.loader();
383 
<span class="line-modified">384     bool usesEphemeralSession = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
385     const URL&amp; historyURL = frameLoader.documentLoader()-&gt;urlForHistory();
386 
387     if (!frameLoader.documentLoader()-&gt;isClientRedirect()) {
388         if (!historyURL.isEmpty()) {
389             if (updateType != UpdateAllExceptBackForwardList)
390                 updateBackForwardListClippedAtTarget(true);
<span class="line-modified">391             if (!usesEphemeralSession) {</span>
392                 frameLoader.client().updateGlobalHistory();
393                 frameLoader.documentLoader()-&gt;setDidCreateGlobalHistoryEntry(true);
394                 if (frameLoader.documentLoader()-&gt;unreachableURL().isEmpty())
395                     frameLoader.client().updateGlobalHistoryRedirectLinks();
396             }
397         }
398     } else {
399         // The client redirect replaces the current history item.
400         updateCurrentItem();
401     }
402 
<span class="line-modified">403     if (!historyURL.isEmpty() &amp;&amp; !usesEphemeralSession) {</span>
404         if (Page* page = m_frame.page())
405             addVisitedLink(*page, historyURL);
406 
407         if (!frameLoader.documentLoader()-&gt;didCreateGlobalHistoryEntry() &amp;&amp; frameLoader.documentLoader()-&gt;unreachableURL().isEmpty() &amp;&amp; !m_frame.document()-&gt;url().isEmpty())
408             frameLoader.client().updateGlobalHistoryRedirectLinks();
409     }
410 }
411 
412 void HistoryController::updateForRedirectWithLockedBackForwardList()
413 {
414     LOG(History, &quot;HistoryController %p updateForRedirectWithLockedBackForwardList: Updating History for redirect load in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
415 
<span class="line-modified">416     bool usesEphemeralSession = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
417     const URL&amp; historyURL = m_frame.loader().documentLoader()-&gt;urlForHistory();
418 
419     if (m_frame.loader().documentLoader()-&gt;isClientRedirect()) {
420         if (!m_currentItem &amp;&amp; !m_frame.tree().parent()) {
421             if (!historyURL.isEmpty()) {
422                 updateBackForwardListClippedAtTarget(true);
<span class="line-modified">423                 if (!usesEphemeralSession) {</span>
424                     m_frame.loader().client().updateGlobalHistory();
425                     m_frame.loader().documentLoader()-&gt;setDidCreateGlobalHistoryEntry(true);
426                     if (m_frame.loader().documentLoader()-&gt;unreachableURL().isEmpty())
427                         m_frame.loader().client().updateGlobalHistoryRedirectLinks();
428                 }
429             }
430         }
431         // The client redirect replaces the current history item.
432         updateCurrentItem();
433     } else {
434         Frame* parentFrame = m_frame.tree().parent();
435         if (parentFrame &amp;&amp; parentFrame-&gt;loader().history().currentItem())
436             parentFrame-&gt;loader().history().currentItem()-&gt;setChildItem(createItem());
437     }
438 
<span class="line-modified">439     if (!historyURL.isEmpty() &amp;&amp; !usesEphemeralSession) {</span>
440         if (Page* page = m_frame.page())
441             addVisitedLink(*page, historyURL);
442 
443         if (!m_frame.loader().documentLoader()-&gt;didCreateGlobalHistoryEntry() &amp;&amp; m_frame.loader().documentLoader()-&gt;unreachableURL().isEmpty())
444             m_frame.loader().client().updateGlobalHistoryRedirectLinks();
445     }
446 }
447 
448 void HistoryController::updateForClientRedirect()
449 {
450     LOG(History, &quot;HistoryController %p updateForClientRedirect: Updating History for client redirect in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
451 
452     // Clear out form data so we don&#39;t try to restore it into the incoming page.  Must happen after
453     // webcore has closed the URL and saved away the form state.
454     if (m_currentItem) {
455         m_currentItem-&gt;clearDocumentState();
456         m_currentItem-&gt;clearScrollPosition();
457     }
458 
<span class="line-modified">459     bool usesEphemeralSession = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
460     const URL&amp; historyURL = m_frame.loader().documentLoader()-&gt;urlForHistory();
461 
<span class="line-modified">462     if (!historyURL.isEmpty() &amp;&amp; !usesEphemeralSession) {</span>
463         if (Page* page = m_frame.page())
464             addVisitedLink(*page, historyURL);
465     }
466 }
467 
468 void HistoryController::updateForCommit()
469 {
470     FrameLoader&amp; frameLoader = m_frame.loader();
471     LOG(History, &quot;HistoryController %p updateForCommit: Updating History for commit in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
472 
473     FrameLoadType type = frameLoader.loadType();
474     if (isBackForwardLoadType(type)
475         || isReplaceLoadTypeWithProvisionalItem(type)
476         || (isReloadTypeWithProvisionalItem(type) &amp;&amp; !frameLoader.provisionalDocumentLoader()-&gt;unreachableURL().isEmpty())) {
477         // Once committed, we want to use current item for saving DocState, and
478         // the provisional item for restoring state.
479         // Note previousItem must be set before we close the URL, which will
480         // happen when the data source is made non-provisional below
481 
482         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=146842
</pre>
<hr />
<pre>
534         restoreDocumentState();
535 
536         // Restore the scroll position (we choose to do this rather than going back to the anchor point)
537         restoreScrollPositionAndViewState();
538     }
539 
540     // Iterate over the rest of the tree
541     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
542         child-&gt;loader().history().recursiveUpdateForCommit();
543 }
544 
545 void HistoryController::updateForSameDocumentNavigation()
546 {
547     if (m_frame.document()-&gt;url().isEmpty())
548         return;
549 
550     Page* page = m_frame.page();
551     if (!page)
552         return;
553 
<span class="line-modified">554     bool usesEphemeralSession = page-&gt;usesEphemeralSession();</span>
<span class="line-modified">555     if (!usesEphemeralSession)</span>
<span class="line-added">556         addVisitedLink(*page, m_frame.document()-&gt;url());</span>
557 

558     m_frame.mainFrame().loader().history().recursiveUpdateForSameDocumentNavigation();
559 
560     if (m_currentItem) {
561         m_currentItem-&gt;setURL(m_frame.document()-&gt;url());
<span class="line-modified">562         if (!usesEphemeralSession)</span>
<span class="line-added">563             m_frame.loader().client().updateGlobalHistory();</span>
564     }
565 }
566 
567 void HistoryController::recursiveUpdateForSameDocumentNavigation()
568 {
569     // The frame that navigated will now have a null provisional item.
570     // Ignore it and its children.
571     if (!m_provisionalItem)
572         return;
573 
574     // The provisional item may represent a different pending navigation.
575     // Don&#39;t commit it if it isn&#39;t a same document navigation.
576     if (m_currentItem &amp;&amp; !m_currentItem-&gt;shouldDoSameDocumentNavigationTo(*m_provisionalItem))
577         return;
578 
579     // Commit the provisional item.
580     if (m_provisionalItem)
581         setCurrentItem(*m_provisionalItem.get());
582     m_provisionalItem = nullptr;
583 
</pre>
</td>
</tr>
</table>
<center><a href="HTTPHeaderField.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
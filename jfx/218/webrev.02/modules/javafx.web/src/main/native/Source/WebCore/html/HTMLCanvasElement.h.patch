diff a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h
@@ -29,24 +29,23 @@
 
 #include "CanvasBase.h"
 #include "FloatRect.h"
 #include "HTMLElement.h"
 #include "ImageBitmapRenderingContextSettings.h"
-#include "IntSize.h"
 #include <memory>
 #include <wtf/Forward.h>
 
 #if ENABLE(WEBGL)
 #include "WebGLContextAttributes.h"
 #endif
 
 namespace WebCore {
 
 class BlobCallback;
+class CanvasRenderingContext;
 class CanvasRenderingContext2D;
 class GraphicsContext;
-class GraphicsContextStateSaver;
 class Image;
 class ImageBuffer;
 class ImageData;
 class MediaSample;
 class MediaStream;
@@ -63,30 +62,17 @@
 public:
     static Ref<HTMLCanvasElement> create(Document&);
     static Ref<HTMLCanvasElement> create(const QualifiedName&, Document&);
     virtual ~HTMLCanvasElement();
 
-    unsigned width() const final { return size().width(); }
-    unsigned height() const final { return size().height(); }
-
     WEBCORE_EXPORT ExceptionOr<void> setWidth(unsigned);
     WEBCORE_EXPORT ExceptionOr<void> setHeight(unsigned);
 
-    const IntSize& size() const final { return m_size; }
-
-    void setSize(const IntSize& newSize) override
-    {
-        if (newSize == size())
-            return;
-        m_ignoreReset = true;
-        setWidth(newSize.width());
-        setHeight(newSize.height());
-        m_ignoreReset = false;
-        reset();
-    }
+    void setSize(const IntSize& newSize) override;
 
-    ExceptionOr<Optional<RenderingContext>> getContext(JSC::ExecState&, const String& contextId, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
+    CanvasRenderingContext* renderingContext() const final { return m_context.get(); }
+    ExceptionOr<Optional<RenderingContext>> getContext(JSC::JSGlobalObject&, const String& contextId, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
 
     CanvasRenderingContext* getContext(const String&);
 
     static bool is2dType(const String&);
     CanvasRenderingContext2D* createContext2d(const String& type);
@@ -114,46 +100,36 @@
     // Used for rendering
     void didDraw(const FloatRect&) final;
 
     void paint(GraphicsContext&, const LayoutRect&);
 
-    GraphicsContext* drawingContext() const final;
-    GraphicsContext* existingDrawingContext() const final;
-
 #if ENABLE(MEDIA_STREAM)
     RefPtr<MediaSample> toMediaSample();
     ExceptionOr<Ref<MediaStream>> captureStream(Document&, Optional<double>&& frameRequestRate);
 #endif
 
-    ImageBuffer* buffer() const;
     Image* copiedImage() const final;
     void clearCopiedImage();
     RefPtr<ImageData> getImageData();
     void makePresentationCopy();
     void clearPresentationCopy();
 
     SecurityOrigin* securityOrigin() const final;
 
-    AffineTransform baseTransform() const final;
-
-    void makeRenderingResultsAvailable() final;
-    bool hasCreatedImageBuffer() const { return m_hasCreatedImageBuffer; }
-
     bool shouldAccelerate(const IntSize&) const;
 
     WEBCORE_EXPORT void setUsesDisplayListDrawing(bool);
     WEBCORE_EXPORT void setTracksDisplayListReplay(bool);
     WEBCORE_EXPORT String displayListAsText(DisplayList::AsTextFlags) const;
     WEBCORE_EXPORT String replayDisplayListAsText(DisplayList::AsTextFlags) const;
 
-    size_t memoryCost() const;
-    size_t externalMemoryCost() const;
-
     // FIXME: Only some canvas rendering contexts need an ImageBuffer.
     // It would be better to have the contexts own the buffers.
     void setImageBufferAndMarkDirty(std::unique_ptr<ImageBuffer>&&);
 
+    WEBCORE_EXPORT static void setMaxPixelMemoryForTesting(size_t);
+
 private:
     HTMLCanvasElement(const QualifiedName&, Document&);
 
     bool isHTMLCanvasElement() const final { return true; }
 
@@ -163,16 +139,16 @@
     bool canContainRangeEndPoint() const final;
     bool canStartSelection() const final;
 
     void reset();
 
-    void createImageBuffer() const;
+    void createImageBuffer() const final;
     void clearImageBuffer() const;
 
+    bool hasCreatedImageBuffer() const final { return m_hasCreatedImageBuffer; }
+
     void setSurfaceSize(const IntSize&);
-    void setImageBuffer(std::unique_ptr<ImageBuffer>&&) const;
-    void releaseImageBufferAndContext();
 
     bool paintsIntoCanvasBuffer() const;
 
     bool isGPUBased() const;
 
@@ -180,24 +156,21 @@
     void derefCanvasBase() final { HTMLElement::deref(); }
 
     ScriptExecutionContext* canvasBaseScriptExecutionContext() const final { return HTMLElement::scriptExecutionContext(); }
 
     FloatRect m_dirtyRect;
-    mutable IntSize m_size;
 
     bool m_ignoreReset { false };
 
     bool m_usesDisplayListDrawing { false };
     bool m_tracksDisplayListReplay { false };
 
-    mutable Lock m_imageBufferAssignmentLock;
+    std::unique_ptr<CanvasRenderingContext> m_context;
 
-    // m_createdImageBuffer means we tried to malloc the buffer.  We didn't necessarily get it.
+    // m_hasCreatedImageBuffer means we tried to malloc the buffer. We didn't necessarily get it.
     mutable bool m_hasCreatedImageBuffer { false };
     mutable bool m_didClearImageBuffer { false };
-    mutable std::unique_ptr<ImageBuffer> m_imageBuffer;
-    mutable std::unique_ptr<GraphicsContextStateSaver> m_contextStateSaver;
 
     mutable RefPtr<Image> m_presentedImage;
     mutable RefPtr<Image> m_copiedImage; // FIXME: This is temporary for platforms that have to copy the image buffer to render (and for CSSCanvasValue).
 };
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerCallFrame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Debugger.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerCallFrame.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerCallFrame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 46 namespace JSC {
 47 
 48 class LineAndColumnFunctor {
 49 public:
 50     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 51     {
 52         visitor-&gt;computeLineAndColumn(m_line, m_column);
 53         return StackVisitor::Done;
 54     }
 55 
 56     unsigned line() const { return m_line; }
 57     unsigned column() const { return m_column; }
 58 
 59 private:
 60     mutable unsigned m_line { 0 };
 61     mutable unsigned m_column { 0 };
 62 };
 63 
 64 Ref&lt;DebuggerCallFrame&gt; DebuggerCallFrame::create(VM&amp; vm, CallFrame* callFrame)
 65 {
<span class="line-modified"> 66     if (UNLIKELY(callFrame == callFrame-&gt;wasmAwareLexicalGlobalObject(vm)-&gt;globalExec())) {</span>






 67         ShadowChicken::Frame emptyFrame;
 68         RELEASE_ASSERT(!emptyFrame.isTailDeleted);
 69         return adoptRef(*new DebuggerCallFrame(vm, callFrame, emptyFrame));
 70     }
 71 
 72     Vector&lt;ShadowChicken::Frame&gt; frames;
 73     vm.ensureShadowChicken();
 74     vm.shadowChicken()-&gt;iterate(vm, callFrame, [&amp;] (const ShadowChicken::Frame&amp; frame) -&gt; bool {
 75         frames.append(frame);
 76         return true;
 77     });
 78 
 79     RELEASE_ASSERT(frames.size());
 80     ASSERT(!frames[0].isTailDeleted); // The top frame should never be tail deleted.
 81 
 82     RefPtr&lt;DebuggerCallFrame&gt; currentParent = nullptr;
<span class="line-removed"> 83     ExecState* exec = callFrame-&gt;wasmAwareLexicalGlobalObject(vm)-&gt;globalExec();</span>
 84     // This walks the stack from the entry stack frame to the top of the stack.
 85     for (unsigned i = frames.size(); i--; ) {
 86         const ShadowChicken::Frame&amp; frame = frames[i];
 87         if (!frame.isTailDeleted)
<span class="line-modified"> 88             exec = frame.frame;</span>
<span class="line-modified"> 89         Ref&lt;DebuggerCallFrame&gt; currentFrame = adoptRef(*new DebuggerCallFrame(vm, exec, frame));</span>
 90         currentFrame-&gt;m_caller = currentParent;
 91         currentParent = WTFMove(currentFrame);
 92     }
 93     return *currentParent;
 94 }
 95 
 96 DebuggerCallFrame::DebuggerCallFrame(VM&amp; vm, CallFrame* callFrame, const ShadowChicken::Frame&amp; frame)
 97     : m_validMachineFrame(callFrame)
 98     , m_shadowChickenFrame(frame)
 99 {
100     m_position = currentPosition(vm);
101 }
102 
103 RefPtr&lt;DebuggerCallFrame&gt; DebuggerCallFrame::callerFrame()
104 {
105     ASSERT(isValid());
106     if (!isValid())
107         return nullptr;
108 
109     return m_caller;
110 }
111 
<span class="line-modified">112 ExecState* DebuggerCallFrame::globalExec()</span>
113 {
<span class="line-modified">114     return scope()-&gt;globalObject()-&gt;globalExec();</span>
115 }
116 
<span class="line-modified">117 JSC::JSGlobalObject* DebuggerCallFrame::vmEntryGlobalObject() const</span>
118 {
119     ASSERT(isValid());
120     if (!isValid())
121         return nullptr;
<span class="line-modified">122     VM&amp; vm = m_validMachineFrame-&gt;vm();</span>
<span class="line-modified">123     return vm.vmEntryGlobalObject(m_validMachineFrame);</span>
124 }
125 
126 SourceID DebuggerCallFrame::sourceID() const
127 {
128     ASSERT(isValid());
129     if (!isValid())
130         return noSourceID;
131     if (isTailDeleted())
132         return m_shadowChickenFrame.codeBlock-&gt;ownerExecutable()-&gt;sourceID();
133     return sourceIDForCallFrame(m_validMachineFrame);
134 }
135 
136 String DebuggerCallFrame::functionName() const
137 {
138     ASSERT(isValid());
139     if (!isValid())
140         return String();
141 
<span class="line-modified">142     VM&amp; vm = m_validMachineFrame-&gt;vm();</span>
143     if (isTailDeleted()) {
144         if (JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, m_shadowChickenFrame.callee))
145             return func-&gt;calculatedDisplayName(vm);
146         return m_shadowChickenFrame.codeBlock-&gt;inferredName().data();
147     }
148 
149     return m_validMachineFrame-&gt;friendlyFunctionName();
150 }
151 
152 DebuggerScope* DebuggerCallFrame::scope()
153 {
154     ASSERT(isValid());
155     if (!isValid())
156         return nullptr;
157 
158     if (!m_scope) {
<span class="line-modified">159         VM&amp; vm = m_validMachineFrame-&gt;vm();</span>
160         JSScope* scope;
161         CodeBlock* codeBlock = m_validMachineFrame-&gt;codeBlock();
162         if (isTailDeleted())
163             scope = m_shadowChickenFrame.scope;
164         else if (codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid())
165             scope = m_validMachineFrame-&gt;scope(codeBlock-&gt;scopeRegister().offset());
166         else if (JSCallee* callee = jsDynamicCast&lt;JSCallee*&gt;(vm, m_validMachineFrame-&gt;jsCallee()))
167             scope = callee-&gt;scope();
168         else
<span class="line-modified">169             scope = m_validMachineFrame-&gt;lexicalGlobalObject()-&gt;globalLexicalEnvironment();</span>
170 
171         m_scope.set(vm, DebuggerScope::create(vm, scope));
172     }
173     return m_scope.get();
174 }
175 
176 DebuggerCallFrame::Type DebuggerCallFrame::type() const
177 {
178     ASSERT(isValid());
179     if (!isValid())
180         return ProgramType;
181 
182     if (isTailDeleted())
183         return FunctionType;
184 
<span class="line-modified">185     if (jsDynamicCast&lt;JSFunction*&gt;(m_validMachineFrame-&gt;vm(), m_validMachineFrame-&gt;jsCallee()))</span>
186         return FunctionType;
187 
188     return ProgramType;
189 }
190 
<span class="line-modified">191 JSValue DebuggerCallFrame::thisValue() const</span>
192 {
193     ASSERT(isValid());
194     if (!isValid())
195         return jsUndefined();
196 
197     CodeBlock* codeBlock = nullptr;
198     JSValue thisValue;
199     if (isTailDeleted()) {
200         thisValue = m_shadowChickenFrame.thisValue;
201         codeBlock = m_shadowChickenFrame.codeBlock;
202     } else {
203         thisValue = m_validMachineFrame-&gt;thisValue();
204         codeBlock = m_validMachineFrame-&gt;codeBlock();
205     }
206 
207     if (!thisValue)
208         return jsUndefined();
209 
210     ECMAMode ecmaMode = NotStrictMode;
211     if (codeBlock &amp;&amp; codeBlock-&gt;isStrictMode())
212         ecmaMode = StrictMode;
<span class="line-modified">213     return thisValue.toThis(m_validMachineFrame, ecmaMode);</span>
214 }
215 
216 // Evaluate some JavaScript code in the scope of this frame.
217 JSValue DebuggerCallFrame::evaluateWithScopeExtension(const String&amp; script, JSObject* scopeExtensionObject, NakedPtr&lt;Exception&gt;&amp; exception)
218 {
219     ASSERT(isValid());
220     CallFrame* callFrame = m_validMachineFrame;
221     if (!callFrame)
222         return jsUndefined();
223 
<span class="line-modified">224     VM&amp; vm = callFrame-&gt;vm();</span>
225     JSLockHolder lock(vm);
226     auto catchScope = DECLARE_CATCH_SCOPE(vm);
227 
228     CodeBlock* codeBlock = nullptr;
229     if (isTailDeleted())
230         codeBlock = m_shadowChickenFrame.codeBlock;
231     else
232         codeBlock = callFrame-&gt;codeBlock();
233     if (!codeBlock)
234         return jsUndefined();
235 
<span class="line-modified">236     DebuggerEvalEnabler evalEnabler(callFrame, DebuggerEvalEnabler::Mode::EvalOnCallFrameAtDebuggerEntry);</span>

237 
238     EvalContextType evalContextType;
239 
240     if (isFunctionParseMode(codeBlock-&gt;unlinkedCodeBlock()-&gt;parseMode()))
241         evalContextType = EvalContextType::FunctionEvalContext;
242     else if (codeBlock-&gt;unlinkedCodeBlock()-&gt;codeType() == EvalCode)
243         evalContextType = codeBlock-&gt;unlinkedCodeBlock()-&gt;evalContextType();
244     else
245         evalContextType = EvalContextType::None;
246 
247     VariableEnvironment variablesUnderTDZ;
248     JSScope::collectClosureVariablesUnderTDZ(scope()-&gt;jsScope(), variablesUnderTDZ);
249 
<span class="line-modified">250     auto* eval = DirectEvalExecutable::create(callFrame, makeSource(script, callFrame-&gt;callerSourceOrigin()), codeBlock-&gt;isStrictMode(), codeBlock-&gt;unlinkedCodeBlock()-&gt;derivedContextType(), codeBlock-&gt;unlinkedCodeBlock()-&gt;isArrowFunction(), evalContextType, &amp;variablesUnderTDZ);</span>
251     if (UNLIKELY(catchScope.exception())) {
252         exception = catchScope.exception();
253         catchScope.clearException();
254         return jsUndefined();
255     }
256 
<span class="line-removed">257     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(callFrame);</span>
258     if (scopeExtensionObject) {
259         JSScope* ignoredPreviousScope = globalObject-&gt;globalScope();
260         globalObject-&gt;setGlobalScopeExtension(JSWithScope::create(vm, globalObject, ignoredPreviousScope, scopeExtensionObject));
261     }
262 
<span class="line-modified">263     JSValue thisValue = this-&gt;thisValue();</span>
<span class="line-modified">264     JSValue result = vm.interpreter-&gt;execute(eval, callFrame, thisValue, scope()-&gt;jsScope());</span>
265     if (UNLIKELY(catchScope.exception())) {
266         exception = catchScope.exception();
267         catchScope.clearException();
268     }
269 
270     if (scopeExtensionObject)
271         globalObject-&gt;clearGlobalScopeExtension();
272 
273     ASSERT(result);
274     return result;
275 }
276 
277 void DebuggerCallFrame::invalidate()
278 {
279     RefPtr&lt;DebuggerCallFrame&gt; frame = this;
280     while (frame) {
281         frame-&gt;m_validMachineFrame = nullptr;
282         if (frame-&gt;m_scope) {
283             frame-&gt;m_scope-&gt;invalidateChain();
284             frame-&gt;m_scope.clear();
285         }
286         frame = WTFMove(frame-&gt;m_caller);
287     }
288 }
289 
290 TextPosition DebuggerCallFrame::currentPosition(VM&amp; vm)
291 {
292     if (!m_validMachineFrame)
293         return TextPosition();
294 
295     if (isTailDeleted()) {
296         CodeBlock* codeBlock = m_shadowChickenFrame.codeBlock;
<span class="line-modified">297         if (Optional&lt;unsigned&gt; bytecodeOffset = codeBlock-&gt;bytecodeOffsetFromCallSiteIndex(m_shadowChickenFrame.callSiteIndex)) {</span>
<span class="line-modified">298             return TextPosition(OrdinalNumber::fromOneBasedInt(codeBlock-&gt;lineNumberForBytecodeOffset(*bytecodeOffset)),</span>
<span class="line-modified">299                 OrdinalNumber::fromOneBasedInt(codeBlock-&gt;columnNumberForBytecodeOffset(*bytecodeOffset)));</span>
300         }
301     }
302 
303     return positionForCallFrame(vm, m_validMachineFrame);
304 }
305 
306 TextPosition DebuggerCallFrame::positionForCallFrame(VM&amp; vm, CallFrame* callFrame)
307 {
308     LineAndColumnFunctor functor;
<span class="line-modified">309     StackVisitor::visit(callFrame, &amp;vm, functor);</span>
310     return TextPosition(OrdinalNumber::fromOneBasedInt(functor.line()), OrdinalNumber::fromOneBasedInt(functor.column()));
311 }
312 
313 SourceID DebuggerCallFrame::sourceIDForCallFrame(CallFrame* callFrame)
314 {
<span class="line-modified">315     ASSERT(callFrame);</span>

316     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">317     if (!codeBlock)</span>
318         return noSourceID;
319     return codeBlock-&gt;ownerExecutable()-&gt;sourceID();
320 }
321 
322 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 46 namespace JSC {
 47 
 48 class LineAndColumnFunctor {
 49 public:
 50     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 51     {
 52         visitor-&gt;computeLineAndColumn(m_line, m_column);
 53         return StackVisitor::Done;
 54     }
 55 
 56     unsigned line() const { return m_line; }
 57     unsigned column() const { return m_column; }
 58 
 59 private:
 60     mutable unsigned m_line { 0 };
 61     mutable unsigned m_column { 0 };
 62 };
 63 
 64 Ref&lt;DebuggerCallFrame&gt; DebuggerCallFrame::create(VM&amp; vm, CallFrame* callFrame)
 65 {
<span class="line-modified"> 66     if (UNLIKELY(!callFrame)) {</span>
<span class="line-added"> 67         ShadowChicken::Frame emptyFrame;</span>
<span class="line-added"> 68         RELEASE_ASSERT(!emptyFrame.isTailDeleted);</span>
<span class="line-added"> 69         return adoptRef(*new DebuggerCallFrame(vm, callFrame, emptyFrame));</span>
<span class="line-added"> 70     }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72     if (callFrame-&gt;isDeprecatedCallFrameForDebugger()) {</span>
 73         ShadowChicken::Frame emptyFrame;
 74         RELEASE_ASSERT(!emptyFrame.isTailDeleted);
 75         return adoptRef(*new DebuggerCallFrame(vm, callFrame, emptyFrame));
 76     }
 77 
 78     Vector&lt;ShadowChicken::Frame&gt; frames;
 79     vm.ensureShadowChicken();
 80     vm.shadowChicken()-&gt;iterate(vm, callFrame, [&amp;] (const ShadowChicken::Frame&amp; frame) -&gt; bool {
 81         frames.append(frame);
 82         return true;
 83     });
 84 
 85     RELEASE_ASSERT(frames.size());
 86     ASSERT(!frames[0].isTailDeleted); // The top frame should never be tail deleted.
 87 
 88     RefPtr&lt;DebuggerCallFrame&gt; currentParent = nullptr;

 89     // This walks the stack from the entry stack frame to the top of the stack.
 90     for (unsigned i = frames.size(); i--; ) {
 91         const ShadowChicken::Frame&amp; frame = frames[i];
 92         if (!frame.isTailDeleted)
<span class="line-modified"> 93             callFrame = frame.frame;</span>
<span class="line-modified"> 94         Ref&lt;DebuggerCallFrame&gt; currentFrame = adoptRef(*new DebuggerCallFrame(vm, callFrame, frame));</span>
 95         currentFrame-&gt;m_caller = currentParent;
 96         currentParent = WTFMove(currentFrame);
 97     }
 98     return *currentParent;
 99 }
100 
101 DebuggerCallFrame::DebuggerCallFrame(VM&amp; vm, CallFrame* callFrame, const ShadowChicken::Frame&amp; frame)
102     : m_validMachineFrame(callFrame)
103     , m_shadowChickenFrame(frame)
104 {
105     m_position = currentPosition(vm);
106 }
107 
108 RefPtr&lt;DebuggerCallFrame&gt; DebuggerCallFrame::callerFrame()
109 {
110     ASSERT(isValid());
111     if (!isValid())
112         return nullptr;
113 
114     return m_caller;
115 }
116 
<span class="line-modified">117 JSGlobalObject* DebuggerCallFrame::globalObject()</span>
118 {
<span class="line-modified">119     return scope()-&gt;globalObject();</span>
120 }
121 
<span class="line-modified">122 JSC::JSGlobalObject* DebuggerCallFrame::deprecatedVMEntryGlobalObject() const</span>
123 {
124     ASSERT(isValid());
125     if (!isValid())
126         return nullptr;
<span class="line-modified">127     VM&amp; vm = m_validMachineFrame-&gt;deprecatedVM();</span>
<span class="line-modified">128     return vm.deprecatedVMEntryGlobalObject(m_validMachineFrame-&gt;lexicalGlobalObject(vm));</span>
129 }
130 
131 SourceID DebuggerCallFrame::sourceID() const
132 {
133     ASSERT(isValid());
134     if (!isValid())
135         return noSourceID;
136     if (isTailDeleted())
137         return m_shadowChickenFrame.codeBlock-&gt;ownerExecutable()-&gt;sourceID();
138     return sourceIDForCallFrame(m_validMachineFrame);
139 }
140 
141 String DebuggerCallFrame::functionName() const
142 {
143     ASSERT(isValid());
144     if (!isValid())
145         return String();
146 
<span class="line-modified">147     VM&amp; vm = m_validMachineFrame-&gt;deprecatedVM();</span>
148     if (isTailDeleted()) {
149         if (JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, m_shadowChickenFrame.callee))
150             return func-&gt;calculatedDisplayName(vm);
151         return m_shadowChickenFrame.codeBlock-&gt;inferredName().data();
152     }
153 
154     return m_validMachineFrame-&gt;friendlyFunctionName();
155 }
156 
157 DebuggerScope* DebuggerCallFrame::scope()
158 {
159     ASSERT(isValid());
160     if (!isValid())
161         return nullptr;
162 
163     if (!m_scope) {
<span class="line-modified">164         VM&amp; vm = m_validMachineFrame-&gt;deprecatedVM();</span>
165         JSScope* scope;
166         CodeBlock* codeBlock = m_validMachineFrame-&gt;codeBlock();
167         if (isTailDeleted())
168             scope = m_shadowChickenFrame.scope;
169         else if (codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid())
170             scope = m_validMachineFrame-&gt;scope(codeBlock-&gt;scopeRegister().offset());
171         else if (JSCallee* callee = jsDynamicCast&lt;JSCallee*&gt;(vm, m_validMachineFrame-&gt;jsCallee()))
172             scope = callee-&gt;scope();
173         else
<span class="line-modified">174             scope = m_validMachineFrame-&gt;lexicalGlobalObject(vm)-&gt;globalLexicalEnvironment();</span>
175 
176         m_scope.set(vm, DebuggerScope::create(vm, scope));
177     }
178     return m_scope.get();
179 }
180 
181 DebuggerCallFrame::Type DebuggerCallFrame::type() const
182 {
183     ASSERT(isValid());
184     if (!isValid())
185         return ProgramType;
186 
187     if (isTailDeleted())
188         return FunctionType;
189 
<span class="line-modified">190     if (jsDynamicCast&lt;JSFunction*&gt;(m_validMachineFrame-&gt;deprecatedVM(), m_validMachineFrame-&gt;jsCallee()))</span>
191         return FunctionType;
192 
193     return ProgramType;
194 }
195 
<span class="line-modified">196 JSValue DebuggerCallFrame::thisValue(VM&amp; vm) const</span>
197 {
198     ASSERT(isValid());
199     if (!isValid())
200         return jsUndefined();
201 
202     CodeBlock* codeBlock = nullptr;
203     JSValue thisValue;
204     if (isTailDeleted()) {
205         thisValue = m_shadowChickenFrame.thisValue;
206         codeBlock = m_shadowChickenFrame.codeBlock;
207     } else {
208         thisValue = m_validMachineFrame-&gt;thisValue();
209         codeBlock = m_validMachineFrame-&gt;codeBlock();
210     }
211 
212     if (!thisValue)
213         return jsUndefined();
214 
215     ECMAMode ecmaMode = NotStrictMode;
216     if (codeBlock &amp;&amp; codeBlock-&gt;isStrictMode())
217         ecmaMode = StrictMode;
<span class="line-modified">218     return thisValue.toThis(m_validMachineFrame-&gt;lexicalGlobalObject(vm), ecmaMode);</span>
219 }
220 
221 // Evaluate some JavaScript code in the scope of this frame.
222 JSValue DebuggerCallFrame::evaluateWithScopeExtension(const String&amp; script, JSObject* scopeExtensionObject, NakedPtr&lt;Exception&gt;&amp; exception)
223 {
224     ASSERT(isValid());
225     CallFrame* callFrame = m_validMachineFrame;
226     if (!callFrame)
227         return jsUndefined();
228 
<span class="line-modified">229     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
230     JSLockHolder lock(vm);
231     auto catchScope = DECLARE_CATCH_SCOPE(vm);
232 
233     CodeBlock* codeBlock = nullptr;
234     if (isTailDeleted())
235         codeBlock = m_shadowChickenFrame.codeBlock;
236     else
237         codeBlock = callFrame-&gt;codeBlock();
238     if (!codeBlock)
239         return jsUndefined();
240 
<span class="line-modified">241     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-added">242     DebuggerEvalEnabler evalEnabler(globalObject, DebuggerEvalEnabler::Mode::EvalOnGlobalObjectAtDebuggerEntry);</span>
243 
244     EvalContextType evalContextType;
245 
246     if (isFunctionParseMode(codeBlock-&gt;unlinkedCodeBlock()-&gt;parseMode()))
247         evalContextType = EvalContextType::FunctionEvalContext;
248     else if (codeBlock-&gt;unlinkedCodeBlock()-&gt;codeType() == EvalCode)
249         evalContextType = codeBlock-&gt;unlinkedCodeBlock()-&gt;evalContextType();
250     else
251         evalContextType = EvalContextType::None;
252 
253     VariableEnvironment variablesUnderTDZ;
254     JSScope::collectClosureVariablesUnderTDZ(scope()-&gt;jsScope(), variablesUnderTDZ);
255 
<span class="line-modified">256     auto* eval = DirectEvalExecutable::create(globalObject, makeSource(script, callFrame-&gt;callerSourceOrigin(vm)), codeBlock-&gt;isStrictMode(), codeBlock-&gt;unlinkedCodeBlock()-&gt;derivedContextType(), codeBlock-&gt;unlinkedCodeBlock()-&gt;needsClassFieldInitializer(), codeBlock-&gt;unlinkedCodeBlock()-&gt;isArrowFunction(), evalContextType, &amp;variablesUnderTDZ);</span>
257     if (UNLIKELY(catchScope.exception())) {
258         exception = catchScope.exception();
259         catchScope.clearException();
260         return jsUndefined();
261     }
262 

263     if (scopeExtensionObject) {
264         JSScope* ignoredPreviousScope = globalObject-&gt;globalScope();
265         globalObject-&gt;setGlobalScopeExtension(JSWithScope::create(vm, globalObject, ignoredPreviousScope, scopeExtensionObject));
266     }
267 
<span class="line-modified">268     JSValue thisValue = this-&gt;thisValue(vm);</span>
<span class="line-modified">269     JSValue result = vm.interpreter-&gt;execute(eval, globalObject, thisValue, scope()-&gt;jsScope());</span>
270     if (UNLIKELY(catchScope.exception())) {
271         exception = catchScope.exception();
272         catchScope.clearException();
273     }
274 
275     if (scopeExtensionObject)
276         globalObject-&gt;clearGlobalScopeExtension();
277 
278     ASSERT(result);
279     return result;
280 }
281 
282 void DebuggerCallFrame::invalidate()
283 {
284     RefPtr&lt;DebuggerCallFrame&gt; frame = this;
285     while (frame) {
286         frame-&gt;m_validMachineFrame = nullptr;
287         if (frame-&gt;m_scope) {
288             frame-&gt;m_scope-&gt;invalidateChain();
289             frame-&gt;m_scope.clear();
290         }
291         frame = WTFMove(frame-&gt;m_caller);
292     }
293 }
294 
295 TextPosition DebuggerCallFrame::currentPosition(VM&amp; vm)
296 {
297     if (!m_validMachineFrame)
298         return TextPosition();
299 
300     if (isTailDeleted()) {
301         CodeBlock* codeBlock = m_shadowChickenFrame.codeBlock;
<span class="line-modified">302         if (Optional&lt;BytecodeIndex&gt; bytecodeIndex = codeBlock-&gt;bytecodeIndexFromCallSiteIndex(m_shadowChickenFrame.callSiteIndex)) {</span>
<span class="line-modified">303             return TextPosition(OrdinalNumber::fromOneBasedInt(codeBlock-&gt;lineNumberForBytecodeIndex(*bytecodeIndex)),</span>
<span class="line-modified">304                 OrdinalNumber::fromOneBasedInt(codeBlock-&gt;columnNumberForBytecodeIndex(*bytecodeIndex)));</span>
305         }
306     }
307 
308     return positionForCallFrame(vm, m_validMachineFrame);
309 }
310 
311 TextPosition DebuggerCallFrame::positionForCallFrame(VM&amp; vm, CallFrame* callFrame)
312 {
313     LineAndColumnFunctor functor;
<span class="line-modified">314     StackVisitor::visit(callFrame, vm, functor);</span>
315     return TextPosition(OrdinalNumber::fromOneBasedInt(functor.line()), OrdinalNumber::fromOneBasedInt(functor.column()));
316 }
317 
318 SourceID DebuggerCallFrame::sourceIDForCallFrame(CallFrame* callFrame)
319 {
<span class="line-modified">320     if (!callFrame)</span>
<span class="line-added">321         return noSourceID;</span>
322     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">323     if (!codeBlock || callFrame-&gt;callee().isWasm())</span>
324         return noSourceID;
325     return codeBlock-&gt;ownerExecutable()-&gt;sourceID();
326 }
327 
328 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Debugger.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerCallFrame.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyWrapperFunction.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyWrapperFunction.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyWrapperFunction.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyWrapperFunction.h
@@ -36,11 +36,11 @@
 
 class WebAssemblyWrapperFunction final : public WebAssemblyFunctionBase {
 public:
     using Base = WebAssemblyFunctionBase;
 
-    const static unsigned StructureFlags = Base::StructureFlags;
+    static constexpr unsigned StructureFlags = Base::StructureFlags;
 
     template<typename CellType, SubspaceAccess mode>
     static IsoSubspace* subspaceFor(VM& vm)
     {
         return vm.webAssemblyWrapperFunctionSpace<mode>();
@@ -60,11 +60,11 @@
     static void visitChildren(JSCell*, SlotVisitor&);
 
     void finishCreation(VM&, NativeExecutable*, unsigned length, const String& name, JSObject*, JSWebAssemblyInstance*);
 
 private:
-    WebAssemblyWrapperFunction(VM&, JSGlobalObject*, Structure*, WasmToWasmImportableFunction);
+    WebAssemblyWrapperFunction(VM&, NativeExecutable*, JSGlobalObject*, Structure*, WasmToWasmImportableFunction);
 
     WriteBarrier<JSObject> m_function;
     // It's safe to just hold the raw WasmToWasmImportableFunction because we have a reference
     // to our Instance, which points to the CodeBlock, which points to the Module
     // that exported us, which ensures that the actual Signature/code doesn't get deallocated.

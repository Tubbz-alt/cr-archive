<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectoryInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoDirectory.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoHeap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectoryInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IsoDirectory.h&quot;
 29 
 30 namespace bmalloc {
 31 
 32 template&lt;typename Config&gt;
 33 IsoDirectoryBase&lt;Config&gt;::IsoDirectoryBase(IsoHeapImpl&lt;Config&gt;&amp; heap)
 34     : m_heap(heap)
 35 {
 36 }
 37 
 38 template&lt;typename Config, unsigned passedNumPages&gt;
 39 IsoDirectory&lt;Config, passedNumPages&gt;::IsoDirectory(IsoHeapImpl&lt;Config&gt;&amp; heap)
 40     : IsoDirectoryBase&lt;Config&gt;(heap)
 41 {
<span class="line-removed"> 42     for (unsigned i = numPages; i--;)</span>
<span class="line-removed"> 43         m_pages[i] = nullptr;</span>
 44 }
 45 
 46 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified"> 47 EligibilityResult&lt;Config&gt; IsoDirectory&lt;Config, passedNumPages&gt;::takeFirstEligible()</span>
 48 {
 49     unsigned pageIndex = (m_eligible | ~m_committed).findBit(m_firstEligibleOrDecommitted, true);
 50     m_firstEligibleOrDecommitted = pageIndex;
 51     BASSERT((m_eligible | ~m_committed).findBit(0, true) == pageIndex);
 52     if (pageIndex &gt;= numPages)
 53         return EligibilityKind::Full;
 54 




 55     Scavenger&amp; scavenger = *Scavenger::get();
 56     scavenger.didStartGrowing();
 57 
<span class="line-modified"> 58     IsoPage&lt;Config&gt;* page = m_pages[pageIndex];</span>
 59 
 60     if (!m_committed[pageIndex]) {
 61         scavenger.scheduleIfUnderMemoryPressure(IsoPageBase::pageSize);
 62 
 63         // It could be that we haven&#39;t even allocated a page yet. Do that now!
 64         if (!page) {
 65             page = IsoPage&lt;Config&gt;::tryCreate(*this, pageIndex);
 66             if (!page)
 67                 return EligibilityKind::OutOfMemory;
 68             m_pages[pageIndex] = page;
 69         } else {
 70             // This means that we have a page that we previously allocated and that page just needs to be
 71             // committed.
 72             vmAllocatePhysicalPages(page, IsoPageBase::pageSize);
 73             new (page) IsoPage&lt;Config&gt;(*this, pageIndex);
 74         }
 75 
 76         m_committed[pageIndex] = true;
 77         this-&gt;m_heap.didCommit(page, IsoPageBase::pageSize);
 78     } else {
 79         if (m_empty[pageIndex])
 80             this-&gt;m_heap.isNoLongerFreeable(page, IsoPageBase::pageSize);
 81     }
 82 
 83     RELEASE_BASSERT(page);
 84 
 85     // Make the page non-empty and non-eligible.
 86     m_eligible[pageIndex] = false;
 87     m_empty[pageIndex] = false;
 88     return page;
 89 }
 90 
 91 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified"> 92 void IsoDirectory&lt;Config, passedNumPages&gt;::didBecome(IsoPage&lt;Config&gt;* page, IsoPageTrigger trigger)</span>
 93 {
 94     static constexpr bool verbose = false;
 95     unsigned pageIndex = page-&gt;index();
 96     switch (trigger) {
 97     case IsoPageTrigger::Eligible:
 98         if (verbose)
 99             fprintf(stderr, &quot;%p: %p did become eligible.\n&quot;, this, page);
100         m_eligible[pageIndex] = true;
101         m_firstEligibleOrDecommitted = std::min(m_firstEligibleOrDecommitted, pageIndex);
<span class="line-modified">102         this-&gt;m_heap.didBecomeEligibleOrDecommited(this);</span>
103         return;
104     case IsoPageTrigger::Empty:
105         if (verbose)
106             fprintf(stderr, &quot;%p: %p did become empty.\n&quot;, this, page);
107         BASSERT(!!m_committed[pageIndex]);
108         this-&gt;m_heap.isNowFreeable(page, IsoPageBase::pageSize);
109         m_empty[pageIndex] = true;
110         Scavenger::get()-&gt;schedule(IsoPageBase::pageSize);
111         return;
112     }
113     BCRASH();
114 }
115 
116 template&lt;typename Config, unsigned passedNumPages&gt;
117 void IsoDirectory&lt;Config, passedNumPages&gt;::didDecommit(unsigned index)
118 {
119     // FIXME: We could do this without grabbing the lock. I just doubt that it matters. This is not going
120     // to be a frequently executed path, in the sense that decommitting perf will be dominated by the
121     // syscall itself (which has to do many hard things).
<span class="line-modified">122     std::lock_guard&lt;Mutex&gt; locker(this-&gt;m_heap.lock);</span>
123     BASSERT(!!m_committed[index]);
<span class="line-modified">124     this-&gt;m_heap.isNoLongerFreeable(m_pages[index], IsoPageBase::pageSize);</span>
125     m_committed[index] = false;
126     m_firstEligibleOrDecommitted = std::min(m_firstEligibleOrDecommitted, index);
<span class="line-modified">127     this-&gt;m_heap.didBecomeEligibleOrDecommited(this);</span>
<span class="line-modified">128     this-&gt;m_heap.didDecommit(m_pages[index], IsoPageBase::pageSize);</span>
129 }
130 
131 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified">132 void IsoDirectory&lt;Config, passedNumPages&gt;::scavengePage(size_t index, Vector&lt;DeferredDecommit&gt;&amp; decommits)</span>
133 {
134     // Make sure that this page is now off limits.
135     m_empty[index] = false;
136     m_eligible[index] = false;
<span class="line-modified">137     decommits.push(DeferredDecommit(this, m_pages[index], index));</span>












138 }
139 

140 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified">141 void IsoDirectory&lt;Config, passedNumPages&gt;::scavenge(Vector&lt;DeferredDecommit&gt;&amp; decommits)</span>
142 {
143     (m_empty &amp; m_committed).forEachSetBit(
144         [&amp;] (size_t index) {
<span class="line-modified">145             scavengePage(index, decommits);</span>

146         });

147 }

148 
149 template&lt;typename Config, unsigned passedNumPages&gt;
150 template&lt;typename Func&gt;
<span class="line-modified">151 void IsoDirectory&lt;Config, passedNumPages&gt;::forEachCommittedPage(const Func&amp; func)</span>
152 {
153     m_committed.forEachSetBit(
154         [&amp;] (size_t index) {
<span class="line-modified">155             func(*m_pages[index]);</span>
156         });
157 }
158 
159 } // namespace bmalloc
160 
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IsoDirectory.h&quot;
 29 
 30 namespace bmalloc {
 31 
 32 template&lt;typename Config&gt;
 33 IsoDirectoryBase&lt;Config&gt;::IsoDirectoryBase(IsoHeapImpl&lt;Config&gt;&amp; heap)
 34     : m_heap(heap)
 35 {
 36 }
 37 
 38 template&lt;typename Config, unsigned passedNumPages&gt;
 39 IsoDirectory&lt;Config, passedNumPages&gt;::IsoDirectory(IsoHeapImpl&lt;Config&gt;&amp; heap)
 40     : IsoDirectoryBase&lt;Config&gt;(heap)
 41 {


 42 }
 43 
 44 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified"> 45 EligibilityResult&lt;Config&gt; IsoDirectory&lt;Config, passedNumPages&gt;::takeFirstEligible(const LockHolder&amp;)</span>
 46 {
 47     unsigned pageIndex = (m_eligible | ~m_committed).findBit(m_firstEligibleOrDecommitted, true);
 48     m_firstEligibleOrDecommitted = pageIndex;
 49     BASSERT((m_eligible | ~m_committed).findBit(0, true) == pageIndex);
 50     if (pageIndex &gt;= numPages)
 51         return EligibilityKind::Full;
 52 
<span class="line-added"> 53 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added"> 54     m_highWatermark = std::max(pageIndex, m_highWatermark);</span>
<span class="line-added"> 55 #endif</span>
<span class="line-added"> 56 </span>
 57     Scavenger&amp; scavenger = *Scavenger::get();
 58     scavenger.didStartGrowing();
 59 
<span class="line-modified"> 60     IsoPage&lt;Config&gt;* page = m_pages[pageIndex].get();</span>
 61 
 62     if (!m_committed[pageIndex]) {
 63         scavenger.scheduleIfUnderMemoryPressure(IsoPageBase::pageSize);
 64 
 65         // It could be that we haven&#39;t even allocated a page yet. Do that now!
 66         if (!page) {
 67             page = IsoPage&lt;Config&gt;::tryCreate(*this, pageIndex);
 68             if (!page)
 69                 return EligibilityKind::OutOfMemory;
 70             m_pages[pageIndex] = page;
 71         } else {
 72             // This means that we have a page that we previously allocated and that page just needs to be
 73             // committed.
 74             vmAllocatePhysicalPages(page, IsoPageBase::pageSize);
 75             new (page) IsoPage&lt;Config&gt;(*this, pageIndex);
 76         }
 77 
 78         m_committed[pageIndex] = true;
 79         this-&gt;m_heap.didCommit(page, IsoPageBase::pageSize);
 80     } else {
 81         if (m_empty[pageIndex])
 82             this-&gt;m_heap.isNoLongerFreeable(page, IsoPageBase::pageSize);
 83     }
 84 
 85     RELEASE_BASSERT(page);
 86 
 87     // Make the page non-empty and non-eligible.
 88     m_eligible[pageIndex] = false;
 89     m_empty[pageIndex] = false;
 90     return page;
 91 }
 92 
 93 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified"> 94 void IsoDirectory&lt;Config, passedNumPages&gt;::didBecome(const LockHolder&amp; locker, IsoPage&lt;Config&gt;* page, IsoPageTrigger trigger)</span>
 95 {
 96     static constexpr bool verbose = false;
 97     unsigned pageIndex = page-&gt;index();
 98     switch (trigger) {
 99     case IsoPageTrigger::Eligible:
100         if (verbose)
101             fprintf(stderr, &quot;%p: %p did become eligible.\n&quot;, this, page);
102         m_eligible[pageIndex] = true;
103         m_firstEligibleOrDecommitted = std::min(m_firstEligibleOrDecommitted, pageIndex);
<span class="line-modified">104         this-&gt;m_heap.didBecomeEligibleOrDecommited(locker, this);</span>
105         return;
106     case IsoPageTrigger::Empty:
107         if (verbose)
108             fprintf(stderr, &quot;%p: %p did become empty.\n&quot;, this, page);
109         BASSERT(!!m_committed[pageIndex]);
110         this-&gt;m_heap.isNowFreeable(page, IsoPageBase::pageSize);
111         m_empty[pageIndex] = true;
112         Scavenger::get()-&gt;schedule(IsoPageBase::pageSize);
113         return;
114     }
115     BCRASH();
116 }
117 
118 template&lt;typename Config, unsigned passedNumPages&gt;
119 void IsoDirectory&lt;Config, passedNumPages&gt;::didDecommit(unsigned index)
120 {
121     // FIXME: We could do this without grabbing the lock. I just doubt that it matters. This is not going
122     // to be a frequently executed path, in the sense that decommitting perf will be dominated by the
123     // syscall itself (which has to do many hard things).
<span class="line-modified">124     LockHolder locker(this-&gt;m_heap.lock);</span>
125     BASSERT(!!m_committed[index]);
<span class="line-modified">126     this-&gt;m_heap.isNoLongerFreeable(m_pages[index].get(), IsoPageBase::pageSize);</span>
127     m_committed[index] = false;
128     m_firstEligibleOrDecommitted = std::min(m_firstEligibleOrDecommitted, index);
<span class="line-modified">129     this-&gt;m_heap.didBecomeEligibleOrDecommited(locker, this);</span>
<span class="line-modified">130     this-&gt;m_heap.didDecommit(m_pages[index].get(), IsoPageBase::pageSize);</span>
131 }
132 
133 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified">134 void IsoDirectory&lt;Config, passedNumPages&gt;::scavengePage(const LockHolder&amp;, size_t index, Vector&lt;DeferredDecommit&gt;&amp; decommits)</span>
135 {
136     // Make sure that this page is now off limits.
137     m_empty[index] = false;
138     m_eligible[index] = false;
<span class="line-modified">139     decommits.push(DeferredDecommit(this, m_pages[index].get(), index));</span>
<span class="line-added">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 template&lt;typename Config, unsigned passedNumPages&gt;</span>
<span class="line-added">143 void IsoDirectory&lt;Config, passedNumPages&gt;::scavenge(const LockHolder&amp; locker, Vector&lt;DeferredDecommit&gt;&amp; decommits)</span>
<span class="line-added">144 {</span>
<span class="line-added">145     (m_empty &amp; m_committed).forEachSetBit(</span>
<span class="line-added">146         [&amp;] (size_t index) {</span>
<span class="line-added">147             scavengePage(locker, index, decommits);</span>
<span class="line-added">148         });</span>
<span class="line-added">149 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">150     m_highWatermark = 0;</span>
<span class="line-added">151 #endif</span>
152 }
153 
<span class="line-added">154 #if BUSE(PARTIAL_SCAVENGE)</span>
155 template&lt;typename Config, unsigned passedNumPages&gt;
<span class="line-modified">156 void IsoDirectory&lt;Config, passedNumPages&gt;::scavengeToHighWatermark(const LockHolder&amp; locker, Vector&lt;DeferredDecommit&gt;&amp; decommits)</span>
157 {
158     (m_empty &amp; m_committed).forEachSetBit(
159         [&amp;] (size_t index) {
<span class="line-modified">160             if (index &gt; m_highWatermark)</span>
<span class="line-added">161                 scavengePage(locker, index, decommits);</span>
162         });
<span class="line-added">163     m_highWatermark = 0;</span>
164 }
<span class="line-added">165 #endif</span>
166 
167 template&lt;typename Config, unsigned passedNumPages&gt;
168 template&lt;typename Func&gt;
<span class="line-modified">169 void IsoDirectory&lt;Config, passedNumPages&gt;::forEachCommittedPage(const LockHolder&amp;, const Func&amp; func)</span>
170 {
171     m_committed.forEachSetBit(
172         [&amp;] (size_t index) {
<span class="line-modified">173             func(*(m_pages[index].get()));</span>
174         });
175 }
176 
177 } // namespace bmalloc
178 
</pre>
</td>
</tr>
</table>
<center><a href="IsoDirectory.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoHeap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
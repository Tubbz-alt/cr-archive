<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCFAPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGByteCodeParser.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFGSimplificationPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCFAPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 168,26 ***</span>
          // type widening is critical to navier-stokes. Without it, navier-stokes has more strict constraint on OSR entry and
          // fails OSR entry repeatedly.
          bool changed = false;
          const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
          for (size_t i = mustHandleValues.size(); i--;) {
<span class="line-modified">!             int operand = mustHandleValues.operandForIndex(i);</span>
              Optional&lt;JSValue&gt; value = mustHandleValues[i];
              if (!value) {
                  if (m_verbose)
<span class="line-modified">!                     dataLog(&quot;   Not live in bytecode: &quot;, VirtualRegister(operand), &quot;\n&quot;);</span>
                  continue;
              }
              Node* node = block-&gt;variablesAtHead.operand(operand);
              if (!node) {
                  if (m_verbose)
<span class="line-modified">!                     dataLog(&quot;   Not live: &quot;, VirtualRegister(operand), &quot;\n&quot;);</span>
                  continue;
              }
  
              if (m_verbose)
<span class="line-modified">!                 dataLog(&quot;   Widening &quot;, VirtualRegister(operand), &quot; with &quot;, value.value(), &quot;\n&quot;);</span>
  
              AbstractValue&amp; target = block-&gt;valuesAtHead.operand(operand);
              changed |= target.mergeOSREntryValue(m_graph, value.value(), node-&gt;variableAccessData(), node);
          }
  
<span class="line-new-header">--- 168,26 ---</span>
          // type widening is critical to navier-stokes. Without it, navier-stokes has more strict constraint on OSR entry and
          // fails OSR entry repeatedly.
          bool changed = false;
          const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
          for (size_t i = mustHandleValues.size(); i--;) {
<span class="line-modified">!             Operand operand = mustHandleValues.operandForIndex(i);</span>
              Optional&lt;JSValue&gt; value = mustHandleValues[i];
              if (!value) {
                  if (m_verbose)
<span class="line-modified">!                     dataLog(&quot;   Not live in bytecode: &quot;, operand, &quot;\n&quot;);</span>
                  continue;
              }
              Node* node = block-&gt;variablesAtHead.operand(operand);
              if (!node) {
                  if (m_verbose)
<span class="line-modified">!                     dataLog(&quot;   Not live: &quot;, operand, &quot;\n&quot;);</span>
                  continue;
              }
  
              if (m_verbose)
<span class="line-modified">!                 dataLog(&quot;   Widening &quot;, operand, &quot; with &quot;, value.value(), &quot;\n&quot;);</span>
  
              AbstractValue&amp; target = block-&gt;valuesAtHead.operand(operand);
              changed |= target.mergeOSREntryValue(m_graph, value.value(), node-&gt;variableAccessData(), node);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,11 ***</span>
                  if (m_verbose)
                      dataLogF(&quot;         Expect OSR exit.\n&quot;);
                  break;
              }
  
<span class="line-modified">!             if (!ASSERT_DISABLED</span>
                  &amp;&amp; m_state.didClobberOrFolded() != writesOverlap(m_graph, node, JSCell_structureID))
                  DFG_CRASH(m_graph, node, toCString(&quot;AI-clobberize disagreement; AI says &quot;, m_state.clobberState(), &quot; while clobberize says &quot;, writeSet(m_graph, node)).data());
          }
          if (m_verbose) {
              dataLogF(&quot;      tail regs: &quot;);
<span class="line-new-header">--- 233,11 ---</span>
                  if (m_verbose)
                      dataLogF(&quot;         Expect OSR exit.\n&quot;);
                  break;
              }
  
<span class="line-modified">!             if (ASSERT_ENABLED</span>
                  &amp;&amp; m_state.didClobberOrFolded() != writesOverlap(m_graph, node, JSCell_structureID))
                  DFG_CRASH(m_graph, node, toCString(&quot;AI-clobberize disagreement; AI says &quot;, m_state.clobberState(), &quot; while clobberize says &quot;, writeSet(m_graph, node)).data());
          }
          if (m_verbose) {
              dataLogF(&quot;      tail regs: &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,11 ***</span>
  private:
      InPlaceAbstractState m_state;
      AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
      BlockSet m_blocksWithOSR;
  
<span class="line-modified">!     bool m_verbose;</span>
  
      bool m_changed;
      unsigned m_count;
  };
  
<span class="line-new-header">--- 266,11 ---</span>
  private:
      InPlaceAbstractState m_state;
      AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
      BlockSet m_blocksWithOSR;
  
<span class="line-modified">!     const bool m_verbose;</span>
  
      bool m_changed;
      unsigned m_count;
  };
  
</pre>
<center><a href="DFGByteCodeParser.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFGSimplificationPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBObjectStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBKeyRangeData.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStore.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBObjectStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -58,44 +58,39 @@</span>
      : ActiveDOMObject(&amp;context)
      , m_info(info)
      , m_originalInfo(info)
      , m_transaction(transaction)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      suspendIfNeeded();
  }
  
  IDBObjectStore::~IDBObjectStore()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  }
  
  const char* IDBObjectStore::activeDOMObjectName() const
  {
      return &quot;IDBObjectStore&quot;;
  }
  
<span class="udiff-line-removed">- bool IDBObjectStore::canSuspendForDocumentSuspension() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool IDBObjectStore::hasPendingActivity() const
  {
      return m_transaction.hasPendingActivity();
  }
  
  const String&amp; IDBObjectStore::name() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
      return m_info.name();
  }
  
  ExceptionOr&lt;void&gt; IDBObjectStore::setName(const String&amp; name)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isVersionChange())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,17 +111,17 @@</span>
      return { };
  }
  
  const Optional&lt;IDBKeyPath&gt;&amp; IDBObjectStore::keyPath() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
      return m_info.keyPath();
  }
  
  Ref&lt;DOMStringList&gt; IDBObjectStore::indexNames() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      auto indexNames = DOMStringList::create();
  
      if (!m_deleted) {
          for (auto&amp; name : m_info.indexNames())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137,24 +132,24 @@</span>
      return indexNames;
  }
  
  IDBTransaction&amp; IDBObjectStore::transaction()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
      return m_transaction;
  }
  
  bool IDBObjectStore::autoIncrement() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
      return m_info.autoIncrement();
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::openCursor&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167,32 +162,32 @@</span>
  
      auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyAndValue);
      return m_transaction.requestOpenCursor(execState, *this, info);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenKeyCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenKeyCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::openKeyCursor&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -205,32 +200,32 @@</span>
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
      return m_transaction.requestOpenCursor(execState, *this, info);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenKeyCursor(execState, direction, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(ExecState&amp; execState, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -241,14 +236,14 @@</span>
          return Exception { DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
  
      return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyAndValue });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(ExecState&amp; execState, IDBKeyRange* keyRange)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -259,14 +254,14 @@</span>
          return Exception { DataError };
  
      return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyAndValue });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(ExecState&amp; execState, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -277,14 +272,14 @@</span>
          return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
  
      return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyOnly });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(ExecState&amp; execState, IDBKeyRange* keyRange)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -295,38 +290,38 @@</span>
          return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
  
      return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyOnly });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::add(ExecState&amp; execState, JSValue value, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::add(JSGlobalObject&amp; execState, JSValue value, JSValue key)</span>
  {
      RefPtr&lt;IDBKey&gt; idbKey;
      if (!key.isUndefined())
          idbKey = scriptValueToIDBKey(execState, key);
      return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::NoOverwrite, InlineKeyCheck::Perform);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::put(ExecState&amp; execState, JSValue value, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::put(JSGlobalObject&amp; execState, JSValue value, JSValue key)</span>
  {
      RefPtr&lt;IDBKey&gt; idbKey;
      if (!key.isUndefined())
          idbKey = scriptValueToIDBKey(execState, key);
      return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::Overwrite, InlineKeyCheck::Perform);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putForCursorUpdate(ExecState&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putForCursorUpdate(JSGlobalObject&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key)</span>
  {
      return putOrAdd(state, value, WTFMove(key), IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor, InlineKeyCheck::DoNotPerform);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putOrAdd(ExecState&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key, IndexedDB::ObjectStoreOverwriteMode overwriteMode, InlineKeyCheck inlineKeyCheck)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putOrAdd(JSGlobalObject&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key, IndexedDB::ObjectStoreOverwriteMode overwriteMode, InlineKeyCheck inlineKeyCheck)</span>
  {
      VM&amp; vm = state.vm();
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      LOG(IndexedDB, &quot;IDBObjectStore::putOrAdd&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      auto context = scriptExecutionContextFromExecState(&amp;state);
      if (!context)
          return Exception { UnknownError, &quot;Unable to store record in object store because it does not have a valid script execution context&quot;_s };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -382,21 +377,21 @@</span>
          return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses out-of-line keys and has no key generator and the key parameter was not provided.&quot;_s };
  
      return m_transaction.requestPutOrAdd(state, *this, WTFMove(key), *serializedValue, overwriteMode);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, IDBKeyRange* keyRange)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
  {
      return doDelete(execState, [keyRange]() {
          return makeRefPtr(keyRange);
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doDelete(ExecState&amp; execState, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doDelete(JSGlobalObject&amp; execState, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::deleteFunction&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
      // the exception for an object store being deleted.
      // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
      // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -419,24 +414,24 @@</span>
          return Exception { DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
  
      return m_transaction.requestDeleteRecord(execState, *this, keyRangeData);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      return doDelete(execState, [state=&amp;execState, key]() {
          auto idbKey = scriptValueToIDBKey(*state, key);
          if (!idbKey-&gt;isValid())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { (IDBKeyRange::create(WTFMove(idbKey))).ptr() };
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::clear(ExecState&amp; execState)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::clear(JSGlobalObject&amp; execState)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::clear&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
      // the exception for an object store being deleted.
      // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
      // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -451,14 +446,14 @@</span>
          return Exception { ReadonlyError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
  
      return m_transaction.requestClearObjectStore(execState, *this);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::createIndex(ExecState&amp;, const String&amp; name, IDBKeyPath&amp;&amp; keyPath, const IndexParameters&amp; parameters)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::createIndex(JSGlobalObject&amp;, const String&amp; name, IDBKeyPath&amp;&amp; keyPath, const IndexParameters&amp; parameters)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::createIndex %s (keyPath: %s, unique: %i, multiEntry: %i)&quot;, name.utf8().data(), loggingString(keyPath).utf8().data(), parameters.unique, parameters.multiEntry);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (!m_transaction.isVersionChange())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
  
      if (m_deleted)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -478,11 +473,11 @@</span>
  
      if (parameters.multiEntry &amp;&amp; WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath))
          return Exception { InvalidAccessError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument was an array and the multiEntry option is true.&quot;_s };
  
      // Install the new Index into the ObjectStore&#39;s info.
<span class="udiff-line-modified-removed">-     IDBIndexInfo info = m_info.createNewIndex(name, WTFMove(keyPath), parameters.unique, parameters.multiEntry);</span>
<span class="udiff-line-modified-added">+     IDBIndexInfo info = m_info.createNewIndex(m_transaction.database().info().generateNextIndexID(), name, WTFMove(keyPath), parameters.unique, parameters.multiEntry);</span>
      m_transaction.database().didCreateIndexInfo(info);
  
      // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
      auto index = m_transaction.createIndex(*this, info);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -495,11 +490,11 @@</span>
  }
  
  ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::index(const String&amp; indexName)
  {
      LOG(IndexedDB, &quot;IDBObjectStore::index&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (!scriptExecutionContext())
          return Exception { InvalidStateError }; // FIXME: Is this code tested? Is iteven reachable?
  
      if (m_deleted)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -527,11 +522,11 @@</span>
  }
  
  ExceptionOr&lt;void&gt; IDBObjectStore::deleteIndex(const String&amp; name)
  {
      LOG(IndexedDB, &quot;IDBObjectStore::deleteIndex %s&quot;, name.utf8().data());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isVersionChange())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -561,29 +556,29 @@</span>
      m_transaction.deleteIndex(m_info.identifier(), name);
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
  
      return doCount(execState, IDBKeyRangeData(idbKey-&gt;isValid() ? idbKey.ptr() : nullptr));
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, IDBKeyRange* range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
  
      return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doCount(ExecState&amp; execState, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doCount(JSGlobalObject&amp; execState, const IDBKeyRangeData&amp; range)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
      // the exception for an object store being deleted.
      // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
      // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -598,14 +593,14 @@</span>
          return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
  
      return m_transaction.requestCount(execState, *this, range);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAll(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAll(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::getAll&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -617,32 +612,32 @@</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAllKeys(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAllKeys(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBObjectStore::getAllKeys&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
  
      if (!m_transaction.isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -654,18 +649,18 @@</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -674,17 +669,17 @@</span>
      });
  }
  
  void IDBObjectStore::markAsDeleted()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
      m_deleted = true;
  }
  
  void IDBObjectStore::rollbackForVersionChangeAbort()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
  
      String currentName = m_info.name();
      m_info = m_originalInfo;
  
      auto&amp; databaseInfo = transaction().database().info();
</pre>
<center><a href="IDBKeyRangeData.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStore.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
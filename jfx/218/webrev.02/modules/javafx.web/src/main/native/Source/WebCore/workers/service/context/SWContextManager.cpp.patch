diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp
@@ -40,11 +40,11 @@
     return *sharedManager;
 }
 
 void SWContextManager::setConnection(std::unique_ptr<Connection>&& connection)
 {
-    ASSERT(!m_connection);
+    ASSERT(!m_connection || m_connection->isClosed());
     m_connection = WTFMove(connection);
 }
 
 auto SWContextManager::connection() const -> Connection*
 {
@@ -57,20 +57,24 @@
     auto jobDataIdentifier = serviceWorkerThreadProxy->thread().contextData().jobDataIdentifier;
     auto* threadProxy = serviceWorkerThreadProxy.ptr();
     auto result = m_workerMap.add(serviceWorkerIdentifier, WTFMove(serviceWorkerThreadProxy));
     ASSERT_UNUSED(result, result.isNewEntry);
 
-    threadProxy->thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String& exceptionMessage) {
-        SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);
+    threadProxy->thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String& exceptionMessage, bool doesHandleFetch) {
+        SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage, doesHandleFetch);
     });
 }
 
-void SWContextManager::startedServiceWorker(Optional<ServiceWorkerJobDataIdentifier> jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String& exceptionMessage)
+void SWContextManager::startedServiceWorker(Optional<ServiceWorkerJobDataIdentifier> jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String& exceptionMessage, bool doesHandleFetch)
 {
-    connection()->serviceWorkerStartedWithMessage(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);
     if (m_serviceWorkerCreationCallback)
         m_serviceWorkerCreationCallback(serviceWorkerIdentifier.toUInt64());
+    if (!exceptionMessage.isEmpty()) {
+        connection()->serviceWorkerFailedToStart(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);
+        return;
+    }
+    connection()->serviceWorkerStarted(jobDataIdentifier, serviceWorkerIdentifier, doesHandleFetch);
 }
 
 ServiceWorkerThreadProxy* SWContextManager::serviceWorkerThreadProxy(ServiceWorkerIdentifier identifier) const
 {
     return m_workerMap.get(identifier);
@@ -81,46 +85,51 @@
     auto* serviceWorker = m_workerMap.get(destination);
     ASSERT(serviceWorker);
     ASSERT(!serviceWorker->isTerminatingOrTerminated());
 
     // FIXME: We should pass valid MessagePortChannels.
-    serviceWorker->thread().postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));
+    serviceWorker->postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));
 }
 
 void SWContextManager::fireInstallEvent(ServiceWorkerIdentifier identifier)
 {
     auto* serviceWorker = m_workerMap.get(identifier);
     if (!serviceWorker)
         return;
 
-    serviceWorker->thread().fireInstallEvent();
+    serviceWorker->fireInstallEvent();
 }
 
 void SWContextManager::fireActivateEvent(ServiceWorkerIdentifier identifier)
 {
     auto* serviceWorker = m_workerMap.get(identifier);
     if (!serviceWorker)
         return;
 
-    serviceWorker->thread().fireActivateEvent();
+    serviceWorker->fireActivateEvent();
 }
 
 void SWContextManager::terminateWorker(ServiceWorkerIdentifier identifier, Seconds timeout, Function<void()>&& completionHandler)
 {
     auto serviceWorker = m_workerMap.take(identifier);
     if (!serviceWorker) {
         if (completionHandler)
             completionHandler();
         return;
     }
+    stopWorker(*serviceWorker, timeout, WTFMove(completionHandler));
+}
 
-    serviceWorker->setAsTerminatingOrTerminated();
+void SWContextManager::stopWorker(ServiceWorkerThreadProxy& serviceWorker, Seconds timeout, Function<void()>&& completionHandler)
+{
+    auto identifier = serviceWorker.identifier();
+    serviceWorker.setAsTerminatingOrTerminated();
 
     m_pendingServiceWorkerTerminationRequests.add(identifier, makeUnique<ServiceWorkerTerminationRequest>(*this, identifier, timeout));
 
-    auto& thread = serviceWorker->thread();
-    thread.stop([this, identifier, serviceWorker = WTFMove(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {
+    auto& thread = serviceWorker.thread();
+    thread.stop([this, identifier, serviceWorker = makeRef(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {
         m_pendingServiceWorkerTerminationRequests.remove(identifier);
 
         if (auto* connection = SWContextManager::singleton().connection())
             connection->workerTerminated(identifier);
 
@@ -134,11 +143,11 @@
 }
 
 void SWContextManager::forEachServiceWorkerThread(const WTF::Function<void(ServiceWorkerThreadProxy&)>& apply)
 {
     for (auto& workerThread : m_workerMap.values())
-        apply(*workerThread);
+        apply(workerThread);
 }
 
 bool SWContextManager::postTaskToServiceWorker(ServiceWorkerIdentifier identifier, WTF::Function<void(ServiceWorkerGlobalScope&)>&& task)
 {
     auto* serviceWorker = m_workerMap.get(identifier);
@@ -153,17 +162,25 @@
 
 void SWContextManager::serviceWorkerFailedToTerminate(ServiceWorkerIdentifier serviceWorkerIdentifier)
 {
     UNUSED_PARAM(serviceWorkerIdentifier);
     RELEASE_LOG_ERROR(ServiceWorker, "Failed to terminate service worker with identifier %s, killing the service worker process", serviceWorkerIdentifier.loggingString().utf8().data());
+    ASSERT_NOT_REACHED();
     _exit(EXIT_FAILURE);
 }
 
 SWContextManager::ServiceWorkerTerminationRequest::ServiceWorkerTerminationRequest(SWContextManager& manager, ServiceWorkerIdentifier serviceWorkerIdentifier, Seconds timeout)
     : m_timeoutTimer([&manager, serviceWorkerIdentifier] { manager.serviceWorkerFailedToTerminate(serviceWorkerIdentifier); })
 {
     m_timeoutTimer.startOneShot(timeout);
 }
 
+void SWContextManager::stopAllServiceWorkers()
+{
+    auto serviceWorkers = WTFMove(m_workerMap);
+    for (auto& serviceWorker : serviceWorkers.values())
+        stopWorker(serviceWorker, workerTerminationTimeout, [] { });
+}
+
 } // namespace WebCore
 
 #endif

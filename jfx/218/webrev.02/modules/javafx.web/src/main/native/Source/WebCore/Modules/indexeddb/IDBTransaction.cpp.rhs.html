<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;IDBTransaction.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;DOMException.h&quot;
  32 #include &quot;DOMStringList.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;Event.h&quot;
  35 #include &quot;EventDispatcher.h&quot;
  36 #include &quot;EventNames.h&quot;
  37 #include &quot;EventQueue.h&quot;
  38 #include &quot;IDBCursorWithValue.h&quot;
  39 #include &quot;IDBDatabase.h&quot;
  40 #include &quot;IDBError.h&quot;
  41 #include &quot;IDBGetRecordData.h&quot;
  42 #include &quot;IDBIndex.h&quot;
  43 #include &quot;IDBIterateCursorData.h&quot;
  44 #include &quot;IDBKeyData.h&quot;
  45 #include &quot;IDBKeyRangeData.h&quot;
  46 #include &quot;IDBObjectStore.h&quot;
  47 #include &quot;IDBOpenDBRequest.h&quot;
  48 #include &quot;IDBRequest.h&quot;
  49 #include &quot;IDBResultData.h&quot;
  50 #include &quot;IDBValue.h&quot;
  51 #include &quot;JSDOMWindowBase.h&quot;
  52 #include &quot;Logging.h&quot;
  53 #include &quot;ScriptExecutionContext.h&quot;
  54 #include &quot;ScriptState.h&quot;
  55 #include &quot;SerializedScriptValue.h&quot;
  56 #include &quot;TransactionOperation.h&quot;
  57 #include &lt;wtf/CompletionHandler.h&gt;
  58 #include &lt;wtf/IsoMallocInlines.h&gt;
  59 
  60 namespace WebCore {
  61 using namespace JSC;
  62 
  63 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBTransaction);
  64 
  65 std::atomic&lt;unsigned&gt; IDBTransaction::numberOfIDBTransactions { 0 };
  66 
  67 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info)
  68 {
  69     return adoptRef(*new IDBTransaction(database, info, nullptr));
  70 }
  71 
  72 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
  73 {
  74     return adoptRef(*new IDBTransaction(database, info, &amp;request));
  75 }
  76 
  77 IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
  78     : IDBActiveDOMObject(database.scriptExecutionContext())
  79     , m_database(database)
  80     , m_info(info)
<a name="1" id="anc1"></a>

  81     , m_openDBRequest(request)
  82     , m_currentlyCompletingRequest(request)
  83 
  84 {
  85     LOG(IndexedDB, &quot;IDBTransaction::IDBTransaction - %s&quot;, m_info.loggingString().utf8().data());
<a name="2" id="anc2"></a><span class="line-modified">  86     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  87 
  88     ++numberOfIDBTransactions;
  89 
  90     if (m_info.mode() == IDBTransactionMode::Versionchange) {
  91         ASSERT(m_openDBRequest);
  92         m_openDBRequest-&gt;setVersionChangeTransaction(*this);
  93         m_startedOnServer = true;
  94     } else {
  95         activate();
  96 
  97         auto* context = scriptExecutionContext();
  98         ASSERT(context);
  99 
 100         JSC::VM&amp; vm = context-&gt;vm();
 101         vm.whenIdle([protectedThis = makeRef(*this)]() {
 102             protectedThis-&gt;deactivate();
 103         });
 104 
 105         establishOnServer();
 106     }
 107 
 108     suspendIfNeeded();
 109 }
 110 
 111 IDBTransaction::~IDBTransaction()
 112 {
 113     --numberOfIDBTransactions;
<a name="3" id="anc3"></a><span class="line-modified"> 114     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 115 }
 116 
 117 IDBClient::IDBConnectionProxy&amp; IDBTransaction::connectionProxy()
 118 {
 119     return m_database-&gt;connectionProxy();
 120 }
 121 
 122 Ref&lt;DOMStringList&gt; IDBTransaction::objectStoreNames() const
 123 {
<a name="4" id="anc4"></a><span class="line-modified"> 124     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 125 
 126     const Vector&lt;String&gt; names = isVersionChange() ? m_database-&gt;info().objectStoreNames() : m_info.objectStores();
 127 
 128     Ref&lt;DOMStringList&gt; objectStoreNames = DOMStringList::create();
 129     for (auto&amp; name : names)
 130         objectStoreNames-&gt;append(name);
 131 
 132     objectStoreNames-&gt;sort();
 133     return objectStoreNames;
 134 }
 135 
 136 IDBDatabase* IDBTransaction::db()
 137 {
<a name="5" id="anc5"></a><span class="line-modified"> 138     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 139     return m_database.ptr();
 140 }
 141 
 142 DOMException* IDBTransaction::error() const
 143 {
<a name="6" id="anc6"></a><span class="line-modified"> 144     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 145     return m_domError.get();
 146 }
 147 
 148 ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBTransaction::objectStore(const String&amp; objectStoreName)
 149 {
 150     LOG(IndexedDB, &quot;IDBTransaction::objectStore&quot;);
<a name="7" id="anc7"></a><span class="line-modified"> 151     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 152 
 153     if (!scriptExecutionContext())
 154         return Exception { InvalidStateError };
 155 
 156     if (isFinishedOrFinishing())
 157         return Exception { InvalidStateError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The transaction finished.&quot;_s };
 158 
 159     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 160 
 161     if (auto* store = m_referencedObjectStores.get(objectStoreName))
 162         return makeRef(*store);
 163 
 164     bool found = false;
 165     for (auto&amp; objectStore : m_info.objectStores()) {
 166         if (objectStore == objectStoreName) {
 167             found = true;
 168             break;
 169         }
 170     }
 171 
 172     auto* info = m_database-&gt;info().infoForExistingObjectStore(objectStoreName);
 173     if (!info)
 174         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 175 
 176     // Version change transactions are scoped to every object store in the database.
 177     if (!info || (!found &amp;&amp; !isVersionChange()))
 178         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 179 
 180     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), *info, *this);
 181     auto* rawObjectStore = objectStore.get();
 182     m_referencedObjectStores.set(objectStoreName, WTFMove(objectStore));
 183 
 184     return Ref&lt;IDBObjectStore&gt;(*rawObjectStore);
 185 }
 186 
 187 
 188 void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
 189 {
 190     LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
<a name="8" id="anc8"></a><span class="line-modified"> 191     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 192 
 193     if (isFinishedOrFinishing())
 194         return;
 195 
 196     m_domError = &amp;error;
 197     internalAbort();
 198 }
 199 
 200 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
 201 {
<a name="9" id="anc9"></a><span class="line-modified"> 202     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 203 
 204     ASSERT(!isFinishedOrFinishing());
 205     m_state = state;
 206     ASSERT(isFinishedOrFinishing());
 207 }
 208 
 209 ExceptionOr&lt;void&gt; IDBTransaction::abort()
 210 {
 211     LOG(IndexedDB, &quot;IDBTransaction::abort&quot;);
<a name="10" id="anc10"></a><span class="line-modified"> 212     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 213 
 214     if (isFinishedOrFinishing())
 215         return Exception { InvalidStateError, &quot;Failed to execute &#39;abort&#39; on &#39;IDBTransaction&#39;: The transaction is inactive or finished.&quot;_s };
 216 
 217     internalAbort();
 218 
 219     return { };
 220 }
 221 
 222 void IDBTransaction::internalAbort()
 223 {
 224     LOG(IndexedDB, &quot;IDBTransaction::internalAbort&quot;);
<a name="11" id="anc11"></a><span class="line-modified"> 225     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 226     ASSERT(!isFinishedOrFinishing());
 227 
 228     m_database-&gt;willAbortTransaction(*this);
 229 
 230     if (isVersionChange()) {
 231         Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 232 
 233         auto&amp; info = m_database-&gt;info();
 234         Vector&lt;uint64_t&gt; identifiersToRemove;
 235         for (auto&amp; iterator : m_deletedObjectStores) {
 236             if (info.infoForExistingObjectStore(iterator.key)) {
 237                 auto name = iterator.value-&gt;info().name();
 238                 m_referencedObjectStores.set(name, WTFMove(iterator.value));
 239                 identifiersToRemove.append(iterator.key);
 240             }
 241         }
 242 
 243         for (auto identifier : identifiersToRemove)
 244             m_deletedObjectStores.remove(identifier);
 245 
 246         for (auto&amp; objectStore : m_referencedObjectStores.values())
 247             objectStore-&gt;rollbackForVersionChangeAbort();
 248     }
 249 
 250     transitionedToFinishing(IndexedDB::TransactionState::Aborting);
 251 
 252     m_abortQueue.swap(m_pendingTransactionOperationQueue);
 253 
 254     LOG(IndexedDBOperations, &quot;IDB abort-on-server operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 255     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 256         protectedThis-&gt;abortOnServerAndCancelRequests(operation);
 257     }));
 258 }
 259 
 260 void IDBTransaction::abortInProgressOperations(const IDBError&amp; error)
 261 {
 262     LOG(IndexedDB, &quot;IDBTransaction::abortInProgressOperations&quot;);
 263 
 264     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; inProgressAbortVector;
 265     inProgressAbortVector.reserveInitialCapacity(m_transactionOperationsInProgressQueue.size());
 266     while (!m_transactionOperationsInProgressQueue.isEmpty())
 267         inProgressAbortVector.uncheckedAppend(m_transactionOperationsInProgressQueue.takeFirst());
 268 
 269     for (auto&amp; operation : inProgressAbortVector) {
 270         m_transactionOperationsInProgressQueue.append(operation.get());
 271         m_currentlyCompletingRequest = nullptr;
 272         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 273     }
 274 
<a name="12" id="anc12"></a><span class="line-modified"> 275     m_transactionOperationResultMap.clear();</span>








 276 
<a name="13" id="anc13"></a><span class="line-added"> 277     m_currentlyCompletingRequest = nullptr;</span>
 278     connectionProxy().forgetActiveOperations(inProgressAbortVector);
 279 }
 280 
 281 void IDBTransaction::abortOnServerAndCancelRequests(IDBClient::TransactionOperation&amp; operation)
 282 {
 283     LOG(IndexedDB, &quot;IDBTransaction::abortOnServerAndCancelRequests&quot;);
<a name="14" id="anc14"></a><span class="line-modified"> 284     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 285     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 286 
 287     m_database-&gt;connectionProxy().abortTransaction(*this);
 288 
 289     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 290     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 291     m_transactionOperationMap.remove(operation.identifier());
 292     m_transactionOperationsInProgressQueue.removeLast();
 293 
 294     m_currentlyCompletingRequest = nullptr;
 295 
 296     IDBError error(AbortError);
 297 
 298     abortInProgressOperations(error);
 299 
 300     for (auto&amp; operation : m_abortQueue) {
 301         m_transactionOperationsInProgressQueue.append(operation.get());
 302         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 303         m_currentlyCompletingRequest = nullptr;
 304     }
 305 
 306     m_abortQueue.clear();
<a name="15" id="anc15"></a><span class="line-added"> 307     m_openRequests.clear();</span>
 308     // Since we&#39;re aborting, it should be impossible to have queued any further operations.
 309     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 310 }
 311 
 312 const char* IDBTransaction::activeDOMObjectName() const
 313 {
<a name="16" id="anc16"></a><span class="line-modified"> 314     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 315     return &quot;IDBTransaction&quot;;
 316 }
 317 
<a name="17" id="anc17"></a>





 318 bool IDBTransaction::hasPendingActivity() const
 319 {
<a name="18" id="anc18"></a><span class="line-modified"> 320     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()) || Thread::mayBeGCThread());</span>
 321     return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
 322 }
 323 
 324 void IDBTransaction::stop()
 325 {
 326     LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
<a name="19" id="anc19"></a><span class="line-modified"> 327     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 328 
 329     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
 330     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
 331     if (m_contextStopped)
 332         return;
 333 
 334     removeAllEventListeners();
 335 
 336     m_contextStopped = true;
 337 
 338     if (isVersionChange())
 339         m_openDBRequest = nullptr;
 340 
 341     if (isFinishedOrFinishing())
 342         return;
 343 
 344     internalAbort();
 345 }
 346 
 347 bool IDBTransaction::isActive() const
 348 {
<a name="20" id="anc20"></a><span class="line-modified"> 349     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 350     return m_state == IndexedDB::TransactionState::Active;
 351 }
 352 
 353 bool IDBTransaction::isFinishedOrFinishing() const
 354 {
<a name="21" id="anc21"></a><span class="line-modified"> 355     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 356 
 357     return m_state == IndexedDB::TransactionState::Committing
 358         || m_state == IndexedDB::TransactionState::Aborting
 359         || m_state == IndexedDB::TransactionState::Finished;
 360 }
 361 
 362 void IDBTransaction::addRequest(IDBRequest&amp; request)
 363 {
<a name="22" id="anc22"></a><span class="line-modified"> 364     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 365     m_openRequests.add(&amp;request);
 366 }
 367 
 368 void IDBTransaction::removeRequest(IDBRequest&amp; request)
 369 {
<a name="23" id="anc23"></a><span class="line-modified"> 370     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added"> 371     if (m_currentlyCompletingRequest == &amp;request)</span>
<span class="line-added"> 372         return;</span>
<span class="line-added"> 373 </span>
 374     m_openRequests.remove(&amp;request);
<a name="24" id="anc24"></a><span class="line-added"> 375 </span>
<span class="line-added"> 376     autoCommit();</span>
 377 }
 378 
<a name="25" id="anc25"></a><span class="line-modified"> 379 void IDBTransaction::scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp; operation, IsWriteOperation isWriteOperation)</span>
 380 {
 381     ASSERT(!m_transactionOperationMap.contains(operation-&gt;identifier()));
<a name="26" id="anc26"></a><span class="line-modified"> 382     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384     if (isWriteOperation == IsWriteOperation::Yes)</span>
<span class="line-added"> 385         m_lastWriteOperationID = operation-&gt;operationID();</span>
 386 
 387     auto identifier = operation-&gt;identifier();
 388     m_pendingTransactionOperationQueue.append(operation.copyRef());
 389     m_transactionOperationMap.set(identifier, WTFMove(operation));
 390 
<a name="27" id="anc27"></a><span class="line-modified"> 391     handlePendingOperations();</span>
 392 }
 393 
<a name="28" id="anc28"></a><span class="line-modified"> 394 void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)</span>








 395 {
<a name="29" id="anc29"></a><span class="line-modified"> 396     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-modified"> 397     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));</span>



 398 
<a name="30" id="anc30"></a><span class="line-modified"> 399     if (!m_transactionOperationMap.contains(operation.identifier()))</span>


 400         return;
 401 
<a name="31" id="anc31"></a><span class="line-modified"> 402     m_transactionOperationResultMap.set(&amp;operation, IDBResultData(data));</span>



























 403 
 404     if (!m_currentlyCompletingRequest)
<a name="32" id="anc32"></a><span class="line-modified"> 405         handleOperationsCompletedOnServer();</span>








 406 }
 407 
<a name="33" id="anc33"></a><span class="line-modified"> 408 void IDBTransaction::handleOperationsCompletedOnServer()</span>
 409 {
<a name="34" id="anc34"></a><span class="line-modified"> 410     LOG(IndexedDB, &quot;IDBTransaction::handleOperationsCompletedOnServer&quot;);</span>
<span class="line-modified"> 411     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>



 412 
<a name="35" id="anc35"></a><span class="line-modified"> 413     while (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_currentlyCompletingRequest) {</span>
<span class="line-modified"> 414         RefPtr&lt;IDBClient::TransactionOperation&gt; currentOperation = m_transactionOperationsInProgressQueue.first();</span>
<span class="line-added"> 415         if (!m_transactionOperationResultMap.contains(currentOperation))</span>
<span class="line-added"> 416             return;</span>
 417 
<a name="36" id="anc36"></a><span class="line-modified"> 418         currentOperation-&gt;doComplete(m_transactionOperationResultMap.take(currentOperation));</span>
<span class="line-modified"> 419     }</span>
 420 }
 421 
 422 void IDBTransaction::completeNoncursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 423 {
 424     ASSERT(!m_currentlyCompletingRequest);
 425 
 426     request.completeRequestAndDispatchEvent(result);
 427 
 428     m_currentlyCompletingRequest = &amp;request;
 429 }
 430 
 431 void IDBTransaction::completeCursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 432 {
 433     ASSERT(!m_currentlyCompletingRequest);
 434 
 435     request.didOpenOrIterateCursor(result);
 436 
 437     m_currentlyCompletingRequest = &amp;request;
 438 }
 439 
 440 void IDBTransaction::finishedDispatchEventForRequest(IDBRequest&amp; request)
 441 {
<a name="37" id="anc37"></a><span class="line-modified"> 442     if (isFinished())</span>
 443         return;
 444 
 445     ASSERT_UNUSED(request, !m_currentlyCompletingRequest || m_currentlyCompletingRequest == &amp;request);
 446 
 447     m_currentlyCompletingRequest = nullptr;
<a name="38" id="anc38"></a><span class="line-modified"> 448     handleOperationsCompletedOnServer();</span>
 449 }
 450 
 451 void IDBTransaction::commit()
 452 {
 453     LOG(IndexedDB, &quot;IDBTransaction::commit&quot;);
<a name="39" id="anc39"></a><span class="line-modified"> 454     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 455     ASSERT(!isFinishedOrFinishing());
 456 
 457     transitionedToFinishing(IndexedDB::TransactionState::Committing);
 458     m_database-&gt;willCommitTransaction(*this);
 459 
 460     LOG(IndexedDBOperations, &quot;IDB commit operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 461     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 462         protectedThis-&gt;commitOnServer(operation);
 463     }));
 464 }
 465 
 466 void IDBTransaction::commitOnServer(IDBClient::TransactionOperation&amp; operation)
 467 {
 468     LOG(IndexedDB, &quot;IDBTransaction::commitOnServer&quot;);
<a name="40" id="anc40"></a><span class="line-modified"> 469     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 470 
 471     m_database-&gt;connectionProxy().commitTransaction(*this);
 472 
 473     ASSERT(!m_transactionOperationsInProgressQueue.isEmpty());
 474     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 475     m_transactionOperationsInProgressQueue.removeLast();
 476 
 477     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 478     m_transactionOperationMap.remove(operation.identifier());
 479 }
 480 
 481 void IDBTransaction::finishAbortOrCommit()
 482 {
 483     ASSERT(m_state != IndexedDB::TransactionState::Finished);
<a name="41" id="anc41"></a><span class="line-modified"> 484     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 485 
 486     m_state = IndexedDB::TransactionState::Finished;
 487 }
 488 
 489 void IDBTransaction::didStart(const IDBError&amp; error)
 490 {
 491     LOG(IndexedDB, &quot;IDBTransaction::didStart&quot;);
<a name="42" id="anc42"></a><span class="line-modified"> 492     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 493 
 494     m_database-&gt;didStartTransaction(*this);
 495 
 496     m_startedOnServer = true;
 497 
 498     // It&#39;s possible the transaction failed to start on the server.
 499     // That equates to an abort.
 500     if (!error.isNull()) {
 501         didAbort(error);
 502         return;
 503     }
 504 
<a name="43" id="anc43"></a><span class="line-modified"> 505     handlePendingOperations();</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507     // It&#39;s possible transaction does not create requests (or creates but finishes them early</span>
<span class="line-added"> 508     // because of error) during intialization. In this case, since the transaction will</span>
<span class="line-added"> 509     // not be active any more, we can end it.</span>
<span class="line-added"> 510     autoCommit();</span>
 511 }
 512 
 513 void IDBTransaction::notifyDidAbort(const IDBError&amp; error)
 514 {
<a name="44" id="anc44"></a><span class="line-modified"> 515     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 516 
 517     m_database-&gt;didAbortTransaction(*this);
 518     m_idbError = error;
 519     fireOnAbort();
 520 
 521     if (isVersionChange() &amp;&amp; !m_contextStopped) {
 522         ASSERT(m_openDBRequest);
 523         m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 524     }
 525 }
 526 
 527 void IDBTransaction::didAbort(const IDBError&amp; error)
 528 {
 529     LOG(IndexedDB, &quot;IDBTransaction::didAbort&quot;);
<a name="45" id="anc45"></a><span class="line-modified"> 530     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 531 
 532     if (m_state == IndexedDB::TransactionState::Finished)
 533         return;
 534 
 535     notifyDidAbort(error);
 536 
 537     finishAbortOrCommit();
 538 }
 539 
 540 void IDBTransaction::didCommit(const IDBError&amp; error)
 541 {
 542     LOG(IndexedDB, &quot;IDBTransaction::didCommit&quot;);
<a name="46" id="anc46"></a><span class="line-modified"> 543     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 544     ASSERT(m_state == IndexedDB::TransactionState::Committing);
 545 
 546     if (error.isNull()) {
 547         m_database-&gt;didCommitTransaction(*this);
 548         fireOnComplete();
 549     } else {
 550         m_database-&gt;willAbortTransaction(*this);
 551         notifyDidAbort(error);
 552     }
 553 
 554     finishAbortOrCommit();
 555 }
 556 
 557 void IDBTransaction::fireOnComplete()
 558 {
 559     LOG(IndexedDB, &quot;IDBTransaction::fireOnComplete&quot;);
<a name="47" id="anc47"></a><span class="line-modified"> 560     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 561     enqueueEvent(Event::create(eventNames().completeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 562 }
 563 
 564 void IDBTransaction::fireOnAbort()
 565 {
 566     LOG(IndexedDB, &quot;IDBTransaction::fireOnAbort&quot;);
<a name="48" id="anc48"></a><span class="line-modified"> 567     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 568     enqueueEvent(Event::create(eventNames().abortEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
 569 }
 570 
 571 void IDBTransaction::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
 572 {
 573     ASSERT(m_state != IndexedDB::TransactionState::Finished);
<a name="49" id="anc49"></a><span class="line-modified"> 574     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 575 
 576     if (!scriptExecutionContext() || m_contextStopped)
 577         return;
 578 
<a name="50" id="anc50"></a><span class="line-modified"> 579     queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));</span>

 580 }
 581 
 582 void IDBTransaction::dispatchEvent(Event&amp; event)
 583 {
 584     LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
 585 
<a name="51" id="anc51"></a><span class="line-modified"> 586     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 587     ASSERT(scriptExecutionContext());
 588     ASSERT(!m_contextStopped);
<a name="52" id="anc52"></a>
 589     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 590 
 591     auto protectedThis = makeRef(*this);
 592 
 593     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
 594     m_didDispatchAbortOrCommit = true;
 595 
 596     if (isVersionChange()) {
 597         ASSERT(m_openDBRequest);
 598         m_openDBRequest-&gt;versionChangeTransactionDidFinish();
 599 
 600         if (event.type() == eventNames().completeEvent) {
 601             if (m_database-&gt;isClosingOrClosed())
 602                 m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 603             else
 604                 m_openDBRequest-&gt;fireSuccessAfterVersionChangeCommit();
 605         }
 606 
 607         m_openDBRequest = nullptr;
 608     }
 609 }
 610 
 611 Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
 612 {
 613     LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
 614     ASSERT(isVersionChange());
 615     ASSERT(scriptExecutionContext());
<a name="53" id="anc53"></a><span class="line-modified"> 616     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 617 
 618     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 619 
 620     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);
 621     auto* rawObjectStore = objectStore.get();
 622     m_referencedObjectStores.set(info.name(), WTFMove(objectStore));
 623 
 624     LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
 625     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 626         protectedThis-&gt;didCreateObjectStoreOnServer(result);
 627     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 628         protectedThis-&gt;createObjectStoreOnServer(operation, info);
<a name="54" id="anc54"></a><span class="line-modified"> 629     }), IsWriteOperation::Yes);</span>
 630 
 631     return *rawObjectStore;
 632 }
 633 
 634 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
 635 {
 636     LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
<a name="55" id="anc55"></a><span class="line-modified"> 637     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 638     ASSERT(isVersionChange());
 639 
 640     m_database-&gt;connectionProxy().createObjectStore(operation, info);
 641 }
 642 
 643 void IDBTransaction::didCreateObjectStoreOnServer(const IDBResultData&amp; resultData)
 644 {
 645     LOG(IndexedDB, &quot;IDBTransaction::didCreateObjectStoreOnServer&quot;);
<a name="56" id="anc56"></a><span class="line-modified"> 646     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 647     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::CreateObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 648 }
 649 
 650 void IDBTransaction::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
 651 {
 652     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStore&quot;);
 653 
 654     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 655 
 656     ASSERT(isVersionChange());
 657     ASSERT(scriptExecutionContext());
<a name="57" id="anc57"></a><span class="line-modified"> 658     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 659 
 660     ASSERT(m_referencedObjectStores.contains(objectStore.info().name()));
 661     ASSERT(!m_referencedObjectStores.contains(newName));
 662     ASSERT(m_referencedObjectStores.get(objectStore.info().name()) == &amp;objectStore);
 663 
 664     uint64_t objectStoreIdentifier = objectStore.info().identifier();
 665 
 666     LOG(IndexedDBOperations, &quot;IDB rename object store operation: %s to %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), newName.utf8().data());
 667     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 668         protectedThis-&gt;didRenameObjectStoreOnServer(result);
 669     }, [protectedThis = makeRef(*this), objectStoreIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 670         protectedThis-&gt;renameObjectStoreOnServer(operation, objectStoreIdentifier, newName);
<a name="58" id="anc58"></a><span class="line-modified"> 671     }), IsWriteOperation::Yes);</span>
 672 
 673     m_referencedObjectStores.set(newName, m_referencedObjectStores.take(objectStore.info().name()));
 674 }
 675 
 676 void IDBTransaction::renameObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; newName)
 677 {
 678     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStoreOnServer&quot;);
<a name="59" id="anc59"></a><span class="line-modified"> 679     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 680     ASSERT(isVersionChange());
 681 
 682     m_database-&gt;connectionProxy().renameObjectStore(operation, objectStoreIdentifier, newName);
 683 }
 684 
 685 void IDBTransaction::didRenameObjectStoreOnServer(const IDBResultData&amp; resultData)
 686 {
 687     LOG(IndexedDB, &quot;IDBTransaction::didRenameObjectStoreOnServer&quot;);
<a name="60" id="anc60"></a><span class="line-modified"> 688     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 689     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 690 }
 691 
 692 std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
 693 {
 694     LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
 695     ASSERT(isVersionChange());
<a name="61" id="anc61"></a><span class="line-modified"> 696     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 697 
 698     if (!scriptExecutionContext())
 699         return nullptr;
 700 
 701     LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
 702     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 703         protectedThis-&gt;didCreateIndexOnServer(result);
 704     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 705         protectedThis-&gt;createIndexOnServer(operation, info);
<a name="62" id="anc62"></a><span class="line-modified"> 706     }), IsWriteOperation::Yes);</span>
 707 
 708     return makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);
 709 }
 710 
 711 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
 712 {
 713     LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
<a name="63" id="anc63"></a><span class="line-modified"> 714     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 715     ASSERT(isVersionChange());
 716 
 717     m_database-&gt;connectionProxy().createIndex(operation, info);
 718 }
 719 
 720 void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
 721 {
 722     LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
<a name="64" id="anc64"></a><span class="line-modified"> 723     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 724 
 725     if (resultData.type() == IDBResultType::CreateIndexSuccess)
 726         return;
 727 
 728     ASSERT(resultData.type() == IDBResultType::Error);
 729 
 730     // This operation might have failed because the transaction is already aborting.
 731     if (m_state == IndexedDB::TransactionState::Aborting)
 732         return;
 733 
 734     // Otherwise, failure to create an index forced abortion of the transaction.
 735     abortDueToFailedRequest(DOMException::create(resultData.error().message(), resultData.error().name()));
 736 }
 737 
 738 void IDBTransaction::renameIndex(IDBIndex&amp; index, const String&amp; newName)
 739 {
 740     LOG(IndexedDB, &quot;IDBTransaction::renameIndex&quot;);
 741     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 742 
 743     ASSERT(isVersionChange());
 744     ASSERT(scriptExecutionContext());
<a name="65" id="anc65"></a><span class="line-modified"> 745     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 746 
 747     ASSERT(m_referencedObjectStores.contains(index.objectStore().info().name()));
 748     ASSERT(m_referencedObjectStores.get(index.objectStore().info().name()) == &amp;index.objectStore());
 749 
 750     index.objectStore().renameReferencedIndex(index, newName);
 751 
 752     uint64_t objectStoreIdentifier = index.objectStore().info().identifier();
 753     uint64_t indexIdentifier = index.info().identifier();
 754 
 755     LOG(IndexedDBOperations, &quot;IDB rename index operation: %s to %s under object store %&quot; PRIu64, index.info().condensedLoggingString().utf8().data(), newName.utf8().data(), index.info().objectStoreIdentifier());
 756     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 757         protectedThis-&gt;didRenameIndexOnServer(result);
 758     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 759         protectedThis-&gt;renameIndexOnServer(operation, objectStoreIdentifier, indexIdentifier, newName);
<a name="66" id="anc66"></a><span class="line-modified"> 760     }), IsWriteOperation::Yes);</span>
 761 }
 762 
 763 void IDBTransaction::renameIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const uint64_t&amp; indexIdentifier, const String&amp; newName)
 764 {
 765     LOG(IndexedDB, &quot;IDBTransaction::renameIndexOnServer&quot;);
<a name="67" id="anc67"></a><span class="line-modified"> 766     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 767     ASSERT(isVersionChange());
 768 
 769     m_database-&gt;connectionProxy().renameIndex(operation, objectStoreIdentifier, indexIdentifier, newName);
 770 }
 771 
 772 void IDBTransaction::didRenameIndexOnServer(const IDBResultData&amp; resultData)
 773 {
 774     LOG(IndexedDB, &quot;IDBTransaction::didRenameIndexOnServer&quot;);
<a name="68" id="anc68"></a><span class="line-modified"> 775     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 776     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameIndexSuccess || resultData.type() == IDBResultType::Error);
 777 }
 778 
<a name="69" id="anc69"></a><span class="line-modified"> 779 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBCursorInfo&amp; info)</span>
 780 {
 781     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<a name="70" id="anc70"></a><span class="line-modified"> 782     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 783 
 784     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 785         return doRequestOpenCursor(state, IDBCursor::create(objectStore, info));
 786 
 787     return doRequestOpenCursor(state, IDBCursorWithValue::create(objectStore, info));
 788 }
 789 
<a name="71" id="anc71"></a><span class="line-modified"> 790 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBCursorInfo&amp; info)</span>
 791 {
 792     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<a name="72" id="anc72"></a><span class="line-modified"> 793     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 794 
 795     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 796         return doRequestOpenCursor(state, IDBCursor::create(index, info));
 797 
 798     return doRequestOpenCursor(state, IDBCursorWithValue::create(index, info));
 799 }
 800 
<a name="73" id="anc73"></a><span class="line-modified"> 801 Ref&lt;IDBRequest&gt; IDBTransaction::doRequestOpenCursor(JSGlobalObject&amp; state, Ref&lt;IDBCursor&gt;&amp;&amp; cursor)</span>
 802 {
 803     ASSERT(isActive());
<a name="74" id="anc74"></a><span class="line-modified"> 804     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 805 
 806     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 807 
 808     auto request = IDBRequest::create(*scriptExecutionContext(), cursor.get(), *this);
 809     addRequest(request.get());
 810 
 811     LOG(IndexedDBOperations, &quot;IDB open cursor operation: %s&quot;, cursor-&gt;info().loggingString().utf8().data());
 812     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 813         protectedThis-&gt;didOpenCursorOnServer(request.get(), result);
 814     }, [protectedThis = makeRef(*this), info = cursor-&gt;info().isolatedCopy()] (auto&amp; operation) {
 815         protectedThis-&gt;openCursorOnServer(operation, info);
 816     }));
 817 
 818     return request;
 819 }
 820 
 821 void IDBTransaction::openCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
 822 {
 823     LOG(IndexedDB, &quot;IDBTransaction::openCursorOnServer&quot;);
<a name="75" id="anc75"></a><span class="line-modified"> 824     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 825 
 826     m_database-&gt;connectionProxy().openCursor(operation, info);
 827 }
 828 
 829 void IDBTransaction::didOpenCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 830 {
 831     LOG(IndexedDB, &quot;IDBTransaction::didOpenCursorOnServer&quot;);
<a name="76" id="anc76"></a><span class="line-modified"> 832     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 833 
 834     completeCursorRequest(request, resultData);
 835 }
 836 
 837 void IDBTransaction::iterateCursor(IDBCursor&amp; cursor, const IDBIterateCursorData&amp; data)
 838 {
 839     LOG(IndexedDB, &quot;IDBTransaction::iterateCursor&quot;);
 840     ASSERT(isActive());
 841     ASSERT(cursor.request());
<a name="77" id="anc77"></a><span class="line-modified"> 842     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 843 
 844     addRequest(*cursor.request());
 845 
 846     LOG(IndexedDBOperations, &quot;IDB iterate cursor operation: %s %s&quot;, cursor.info().loggingString().utf8().data(), data.loggingString().utf8().data());
 847     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, *cursor.request(), [protectedThis = makeRef(*this), request = makeRef(*cursor.request())] (const auto&amp; result) {
 848         protectedThis-&gt;didIterateCursorOnServer(request.get(), result);
 849     }, [protectedThis = makeRef(*this), data = data.isolatedCopy()] (auto&amp; operation) {
 850         protectedThis-&gt;iterateCursorOnServer(operation, data);
 851     }));
 852 }
 853 
 854 // FIXME: changes here
 855 void IDBTransaction::iterateCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
 856 {
 857     LOG(IndexedDB, &quot;IDBTransaction::iterateCursorOnServer&quot;);
<a name="78" id="anc78"></a><span class="line-modified"> 858     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added"> 859     ASSERT(operation.idbRequest());</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861     auto* cursor = operation.idbRequest()-&gt;pendingCursor();</span>
<span class="line-added"> 862     ASSERT(cursor);</span>
 863 
<a name="79" id="anc79"></a><span class="line-added"> 864     if (data.keyData.isNull() &amp;&amp; data.primaryKeyData.isNull()) {</span>
<span class="line-added"> 865         if (auto getResult = cursor-&gt;iterateWithPrefetchedRecords(data.count, m_lastWriteOperationID)) {</span>
<span class="line-added"> 866             auto result = IDBResultData::iterateCursorSuccess(operation.identifier(), getResult.value());</span>
<span class="line-added"> 867             m_database-&gt;connectionProxy().iterateCursor(operation, { data.keyData, data.primaryKeyData, data.count, IndexedDB::CursorIterateOption::DoNotReply });</span>
<span class="line-added"> 868             operationCompletedOnServer(result, operation);</span>
<span class="line-added"> 869             return;</span>
<span class="line-added"> 870         }</span>
<span class="line-added"> 871     }</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873     cursor-&gt;clearPrefetchedRecords();</span>
<span class="line-added"> 874 </span>
<span class="line-added"> 875     ASSERT(data.option == IndexedDB::CursorIterateOption::Reply);</span>
 876     m_database-&gt;connectionProxy().iterateCursor(operation, data);
 877 }
 878 
 879 void IDBTransaction::didIterateCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 880 {
 881     LOG(IndexedDB, &quot;IDBTransaction::didIterateCursorOnServer&quot;);
<a name="80" id="anc80"></a><span class="line-modified"> 882     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 883 
 884     completeCursorRequest(request, resultData);
 885 }
 886 
<a name="81" id="anc81"></a><span class="line-modified"> 887 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllObjectStoreRecords(JSC::JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
 888 {
 889     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllObjectStoreRecords&quot;);
 890     ASSERT(isActive());
<a name="82" id="anc82"></a><span class="line-modified"> 891     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 892 
 893     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 894 
 895     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
 896     addRequest(request.get());
 897 
 898     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, objectStore.info().identifier(), 0 };
 899 
 900     LOG(IndexedDBOperations, &quot;IDB get all object store records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 901     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 902         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 903     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 904         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 905     }));
 906 
 907     return request;
 908 }
 909 
<a name="83" id="anc83"></a><span class="line-modified"> 910 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllIndexRecords(JSC::JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
 911 {
 912     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllIndexRecords&quot;);
 913     ASSERT(isActive());
<a name="84" id="anc84"></a><span class="line-modified"> 914     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 915 
 916     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 917 
 918     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
 919     addRequest(request.get());
 920 
 921     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, index.objectStore().info().identifier(), index.info().identifier() };
 922 
 923     LOG(IndexedDBOperations, &quot;IDB get all index records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 924     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 925         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 926     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 927         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 928     }));
 929 
 930     return request;
 931 }
 932 
 933 void IDBTransaction::getAllRecordsOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetAllRecordsData&amp; getAllRecordsData)
 934 {
 935     LOG(IndexedDB, &quot;IDBTransaction::getAllRecordsOnServer&quot;);
<a name="85" id="anc85"></a><span class="line-modified"> 936     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 937 
 938     m_database-&gt;connectionProxy().getAllRecords(operation, getAllRecordsData);
 939 }
 940 
 941 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 942 {
 943     LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
<a name="86" id="anc86"></a><span class="line-modified"> 944     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 945 
 946     if (resultData.type() == IDBResultType::Error) {
 947         completeNoncursorRequest(request, resultData);
 948         return;
 949     }
 950 
 951     ASSERT(resultData.type() == IDBResultType::GetAllRecordsSuccess);
 952 
 953     auto&amp; getAllResult = resultData.getAllResult();
 954     switch (getAllResult.type()) {
 955     case IndexedDB::GetAllType::Keys:
 956         request.setResult(getAllResult.keys());
 957         break;
 958     case IndexedDB::GetAllType::Values:
 959         request.setResult(getAllResult);
 960         break;
 961     }
 962 
 963     completeNoncursorRequest(request, resultData);
 964 }
 965 
<a name="87" id="anc87"></a><span class="line-modified"> 966 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)</span>
 967 {
 968     LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
 969     ASSERT(isActive());
 970     ASSERT(!getRecordData.keyRangeData.isNull);
<a name="88" id="anc88"></a><span class="line-modified"> 971     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 972 
 973     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 974 
 975     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
 976 
 977     auto request = IDBRequest::createObjectStoreGet(*scriptExecutionContext(), objectStore, type, *this);
 978     addRequest(request.get());
 979 
 980     LOG(IndexedDBOperations, &quot;IDB get record operation: %s %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
 981     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 982         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
 983     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
 984         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
 985     }));
 986 
 987     return request;
 988 }
 989 
<a name="89" id="anc89"></a><span class="line-modified"> 990 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetValue(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
 991 {
 992     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<a name="90" id="anc90"></a><span class="line-modified"> 993     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
 994 
 995     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Value, range);
 996 }
 997 
<a name="91" id="anc91"></a><span class="line-modified"> 998 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetKey(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
 999 {
1000     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<a name="92" id="anc92"></a><span class="line-modified">1001     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1002 
1003     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Key, range);
1004 }
1005 
<a name="93" id="anc93"></a><span class="line-modified">1006 Ref&lt;IDBRequest&gt; IDBTransaction::requestIndexRecord(JSGlobalObject&amp; state, IDBIndex&amp; index, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range)</span>
1007 {
1008     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1009     ASSERT(isActive());
1010     ASSERT(!range.isNull);
<a name="94" id="anc94"></a><span class="line-modified">1011     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1012 
1013     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1014 
1015     auto request = IDBRequest::createIndexGet(*scriptExecutionContext(), index, type, *this);
1016     addRequest(request.get());
1017 
1018     IDBGetRecordData getRecordData = { range, IDBGetRecordDataType::KeyAndValue };
1019 
1020     LOG(IndexedDBOperations, &quot;IDB get index record operation: %s %s&quot;, index.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
1021     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1022         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
1023     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
1024         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
1025     }));
1026 
1027     return request;
1028 }
1029 
1030 void IDBTransaction::getRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetRecordData&amp; getRecordData)
1031 {
1032     LOG(IndexedDB, &quot;IDBTransaction::getRecordOnServer&quot;);
<a name="95" id="anc95"></a><span class="line-modified">1033     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1034 
1035     m_database-&gt;connectionProxy().getRecord(operation, getRecordData);
1036 }
1037 
1038 void IDBTransaction::didGetRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1039 {
1040     LOG(IndexedDB, &quot;IDBTransaction::didGetRecordOnServer&quot;);
<a name="96" id="anc96"></a><span class="line-modified">1041     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1042 
1043     if (resultData.type() == IDBResultType::Error) {
1044         completeNoncursorRequest(request, resultData);
1045         return;
1046     }
1047 
1048     ASSERT(resultData.type() == IDBResultType::GetRecordSuccess);
1049 
1050     bool useResultKey = request.sourceIndexIdentifier() &amp;&amp; request.requestedIndexRecordType() == IndexedDB::IndexRecordType::Key;
1051     if (!useResultKey)
1052         useResultKey = request.requestedObjectStoreRecordType() == IndexedDB::ObjectStoreRecordType::KeyOnly;
1053 
1054     const IDBGetResult&amp; result = resultData.getResult();
1055 
1056     if (useResultKey) {
1057         if (!result.keyData().isNull())
1058             request.setResult(result.keyData());
1059         else
1060             request.setResultToUndefined();
1061     } else {
1062         if (resultData.getResult().value().data().data())
1063             request.setResultToStructuredClone(resultData.getResult());
1064         else
1065             request.setResultToUndefined();
1066     }
1067 
1068     completeNoncursorRequest(request, resultData);
1069 }
1070 
<a name="97" id="anc97"></a><span class="line-modified">1071 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
1072 {
1073     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
1074     ASSERT(isActive());
1075     ASSERT(!range.isNull);
<a name="98" id="anc98"></a><span class="line-modified">1076     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1077 
1078     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1079 
1080     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1081     addRequest(request.get());
1082 
1083     LOG(IndexedDBOperations, &quot;IDB object store count operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1084     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1085         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1086     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1087         protectedThis-&gt;getCountOnServer(operation, range);
1088     }));
1089 
1090     return request;
1091 }
1092 
<a name="99" id="anc99"></a><span class="line-modified">1093 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
1094 {
1095     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBIndex)&quot;);
1096     ASSERT(isActive());
1097     ASSERT(!range.isNull);
<a name="100" id="anc100"></a><span class="line-modified">1098     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1099 
1100     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1101 
1102     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
1103     addRequest(request.get());
1104 
1105     LOG(IndexedDBOperations, &quot;IDB index count operation: %s, range %s&quot;, index.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1106     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1107         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1108     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1109         protectedThis-&gt;getCountOnServer(operation, range);
1110     }));
1111 
1112     return request;
1113 }
1114 
1115 void IDBTransaction::getCountOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1116 {
1117     LOG(IndexedDB, &quot;IDBTransaction::getCountOnServer&quot;);
<a name="101" id="anc101"></a><span class="line-modified">1118     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1119 
1120     m_database-&gt;connectionProxy().getCount(operation, keyRange);
1121 }
1122 
1123 void IDBTransaction::didGetCountOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1124 {
1125     LOG(IndexedDB, &quot;IDBTransaction::didGetCountOnServer&quot;);
<a name="102" id="anc102"></a><span class="line-modified">1126     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1127 
1128     request.setResult(resultData.resultInteger());
1129     completeNoncursorRequest(request, resultData);
1130 }
1131 
<a name="103" id="anc103"></a><span class="line-modified">1132 Ref&lt;IDBRequest&gt; IDBTransaction::requestDeleteRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
1133 {
1134     LOG(IndexedDB, &quot;IDBTransaction::requestDeleteRecord&quot;);
1135     ASSERT(isActive());
1136     ASSERT(!range.isNull);
<a name="104" id="anc104"></a><span class="line-modified">1137     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1138 
1139     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1140 
1141     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1142     addRequest(request.get());
1143 
1144     LOG(IndexedDBOperations, &quot;IDB delete record operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1145     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1146         protectedThis-&gt;didDeleteRecordOnServer(request.get(), result);
1147     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1148         protectedThis-&gt;deleteRecordOnServer(operation, range);
<a name="105" id="anc105"></a><span class="line-modified">1149     }), IsWriteOperation::Yes);</span>
1150     return request;
1151 }
1152 
1153 void IDBTransaction::deleteRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1154 {
1155     LOG(IndexedDB, &quot;IDBTransaction::deleteRecordOnServer&quot;);
<a name="106" id="anc106"></a><span class="line-modified">1156     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1157 
1158     m_database-&gt;connectionProxy().deleteRecord(operation, keyRange);
1159 }
1160 
1161 void IDBTransaction::didDeleteRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1162 {
1163     LOG(IndexedDB, &quot;IDBTransaction::didDeleteRecordOnServer&quot;);
<a name="107" id="anc107"></a><span class="line-modified">1164     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1165 
1166     request.setResultToUndefined();
1167     completeNoncursorRequest(request, resultData);
1168 }
1169 
<a name="108" id="anc108"></a><span class="line-modified">1170 Ref&lt;IDBRequest&gt; IDBTransaction::requestClearObjectStore(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore)</span>
1171 {
1172     LOG(IndexedDB, &quot;IDBTransaction::requestClearObjectStore&quot;);
1173     ASSERT(isActive());
<a name="109" id="anc109"></a><span class="line-modified">1174     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1175 
1176     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1177 
1178     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1179     addRequest(request.get());
1180 
1181     uint64_t objectStoreIdentifier = objectStore.info().identifier();
1182 
1183     LOG(IndexedDBOperations, &quot;IDB clear object store operation: %s&quot;, objectStore.info().condensedLoggingString().utf8().data());
1184     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1185         protectedThis-&gt;didClearObjectStoreOnServer(request.get(), result);
1186     }, [protectedThis = makeRef(*this), objectStoreIdentifier] (auto&amp; operation) {
1187         protectedThis-&gt;clearObjectStoreOnServer(operation, objectStoreIdentifier);
<a name="110" id="anc110"></a><span class="line-modified">1188     }), IsWriteOperation::Yes);</span>
1189 
1190     return request;
1191 }
1192 
1193 void IDBTransaction::clearObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier)
1194 {
1195     LOG(IndexedDB, &quot;IDBTransaction::clearObjectStoreOnServer&quot;);
<a name="111" id="anc111"></a><span class="line-modified">1196     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1197 
1198     m_database-&gt;connectionProxy().clearObjectStore(operation, objectStoreIdentifier);
1199 }
1200 
1201 void IDBTransaction::didClearObjectStoreOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1202 {
1203     LOG(IndexedDB, &quot;IDBTransaction::didClearObjectStoreOnServer&quot;);
<a name="112" id="anc112"></a><span class="line-modified">1204     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1205 
1206     request.setResultToUndefined();
1207     completeNoncursorRequest(request, resultData);
1208 }
1209 
<a name="113" id="anc113"></a><span class="line-modified">1210 Ref&lt;IDBRequest&gt; IDBTransaction::requestPutOrAdd(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, RefPtr&lt;IDBKey&gt;&amp;&amp; key, SerializedScriptValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)</span>
1211 {
1212     LOG(IndexedDB, &quot;IDBTransaction::requestPutOrAdd&quot;);
1213     ASSERT(isActive());
1214     ASSERT(!isReadOnly());
1215     ASSERT(objectStore.info().autoIncrement() || key);
<a name="114" id="anc114"></a><span class="line-modified">1216     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1217 
1218     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1219 
1220     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1221     addRequest(request.get());
1222 
1223     LOG(IndexedDBOperations, &quot;IDB putOrAdd operation: %s key: %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), key ? key-&gt;loggingString().utf8().data() : &quot;&lt;null key&gt;&quot;);
1224     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1225         protectedThis-&gt;didPutOrAddOnServer(request.get(), result);
1226     }, [protectedThis = makeRef(*this), key, value = makeRef(value), overwriteMode] (auto&amp; operation) {
1227         protectedThis-&gt;putOrAddOnServer(operation, key.get(), value.ptr(), overwriteMode);
<a name="115" id="anc115"></a><span class="line-modified">1228     }), IsWriteOperation::Yes);</span>
1229 
1230     return request;
1231 }
1232 
1233 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
1234 {
1235     LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
<a name="116" id="anc116"></a><span class="line-modified">1236     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
1237     ASSERT(!isReadOnly());
1238     ASSERT(value);
1239 
1240     if (!value-&gt;hasBlobURLs()) {
1241         m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
1242         return;
1243     }
1244 
1245     // Due to current limitations on our ability to post tasks back to a worker thread,
1246     // workers currently write blobs to disk synchronously.
1247     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
1248     if (!isMainThread()) {
<a name="117" id="anc117"></a><span class="line-modified">1249         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously();</span>
1250         if (idbValue.data().data())
1251             m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
1252         else {
1253             // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1254             // In that case, we cannot successfully store this record, so we callback with an error.
1255             RefPtr&lt;IDBClient::TransactionOperation&gt; protectedOperation(&amp;operation);
1256             auto result = IDBResultData::error(operation.identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1257             scriptExecutionContext()-&gt;postTask([protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)](ScriptExecutionContext&amp;) {
1258                 protectedOperation-&gt;doComplete(result);
1259             });
1260         }
1261         return;
1262     }
1263 
1264     // Since this request won&#39;t actually go to the server until the blob writes are complete,
1265     // stop future requests from going to the server ahead of it.
1266     operation.setNextRequestCanGoToServer(false);
1267 
<a name="118" id="anc118"></a><span class="line-modified">1268     value-&gt;writeBlobsToDiskForIndexedDB([protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {</span>
<span class="line-modified">1269         ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
1270         ASSERT(isMainThread());
1271         if (idbValue.data().data()) {
1272             m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
1273             return;
1274         }
1275 
1276         // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1277         // In that case, we cannot successfully store this record, so we callback with an error.
1278         auto result = IDBResultData::error(protectedOperation-&gt;identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1279         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)]() mutable {
1280             protectedOperation-&gt;doComplete(result);
1281         });
1282     });
1283 }
1284 
1285 void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1286 {
1287     LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
<a name="119" id="anc119"></a><span class="line-modified">1288     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1289 
1290     if (auto* result = resultData.resultKey())
1291         request.setResult(*result);
1292     else
1293         request.setResultToUndefined();
1294     completeNoncursorRequest(request, resultData);
1295 }
1296 
1297 void IDBTransaction::deleteObjectStore(const String&amp; objectStoreName)
1298 {
1299     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStore&quot;);
<a name="120" id="anc120"></a><span class="line-modified">1300     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1301     ASSERT(isVersionChange());
1302 
1303     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1304 
1305     if (auto objectStore = m_referencedObjectStores.take(objectStoreName)) {
1306         objectStore-&gt;markAsDeleted();
1307         auto identifier = objectStore-&gt;info().identifier();
1308         m_deletedObjectStores.set(identifier, WTFMove(objectStore));
1309     }
1310 
1311     LOG(IndexedDBOperations, &quot;IDB delete object store operation: %s&quot;, objectStoreName.utf8().data());
1312     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1313         protectedThis-&gt;didDeleteObjectStoreOnServer(result);
1314     }, [protectedThis = makeRef(*this), objectStoreName = objectStoreName.isolatedCopy()] (auto&amp; operation) {
1315         protectedThis-&gt;deleteObjectStoreOnServer(operation, objectStoreName);
<a name="121" id="anc121"></a><span class="line-modified">1316     }), IsWriteOperation::Yes);</span>
1317 }
1318 
1319 void IDBTransaction::deleteObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const String&amp; objectStoreName)
1320 {
1321     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStoreOnServer&quot;);
1322     ASSERT(isVersionChange());
<a name="122" id="anc122"></a><span class="line-modified">1323     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1324 
1325     m_database-&gt;connectionProxy().deleteObjectStore(operation, objectStoreName);
1326 }
1327 
1328 void IDBTransaction::didDeleteObjectStoreOnServer(const IDBResultData&amp; resultData)
1329 {
1330     LOG(IndexedDB, &quot;IDBTransaction::didDeleteObjectStoreOnServer&quot;);
<a name="123" id="anc123"></a><span class="line-modified">1331     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1332     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteObjectStoreSuccess || resultData.type() == IDBResultType::Error);
1333 }
1334 
1335 void IDBTransaction::deleteIndex(uint64_t objectStoreIdentifier, const String&amp; indexName)
1336 {
1337     LOG(IndexedDB, &quot;IDBTransaction::deleteIndex&quot;);
<a name="124" id="anc124"></a><span class="line-modified">1338     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1339     ASSERT(isVersionChange());
1340 
1341     LOG(IndexedDBOperations, &quot;IDB delete index operation: %s (%&quot; PRIu64 &quot;)&quot;, indexName.utf8().data(), objectStoreIdentifier);
1342     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1343         protectedThis-&gt;didDeleteIndexOnServer(result);
1344     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexName = indexName.isolatedCopy()] (auto&amp; operation) {
1345         protectedThis-&gt;deleteIndexOnServer(operation, objectStoreIdentifier, indexName);
<a name="125" id="anc125"></a><span class="line-modified">1346     }), IsWriteOperation::Yes);</span>
1347 }
1348 
1349 void IDBTransaction::deleteIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; indexName)
1350 {
1351     LOG(IndexedDB, &quot;IDBTransaction::deleteIndexOnServer&quot;);
1352     ASSERT(isVersionChange());
<a name="126" id="anc126"></a><span class="line-modified">1353     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1354 
1355     m_database-&gt;connectionProxy().deleteIndex(operation, objectStoreIdentifier, indexName);
1356 }
1357 
1358 void IDBTransaction::didDeleteIndexOnServer(const IDBResultData&amp; resultData)
1359 {
1360     LOG(IndexedDB, &quot;IDBTransaction::didDeleteIndexOnServer&quot;);
<a name="127" id="anc127"></a><span class="line-modified">1361     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1362     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteIndexSuccess || resultData.type() == IDBResultType::Error);
1363 }
1364 
1365 void IDBTransaction::operationCompletedOnClient(IDBClient::TransactionOperation&amp; operation)
1366 {
1367     LOG(IndexedDB, &quot;IDBTransaction::operationCompletedOnClient&quot;);
1368 
<a name="128" id="anc128"></a><span class="line-modified">1369     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-modified">1370     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));</span>
1371     ASSERT(m_transactionOperationMap.get(operation.identifier()) == &amp;operation);
1372     ASSERT(m_transactionOperationsInProgressQueue.first() == &amp;operation);
1373 
1374     m_transactionOperationMap.remove(operation.identifier());
1375     m_transactionOperationsInProgressQueue.removeFirst();
1376 
<a name="129" id="anc129"></a><span class="line-modified">1377     if (m_transactionOperationsInProgressQueue.isEmpty())</span>
<span class="line-added">1378         handlePendingOperations();</span>
<span class="line-added">1379 </span>
<span class="line-added">1380     autoCommit();</span>
1381 }
1382 
1383 void IDBTransaction::establishOnServer()
1384 {
1385     LOG(IndexedDB, &quot;IDBTransaction::establishOnServer&quot;);
<a name="130" id="anc130"></a><span class="line-modified">1386     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1387 
1388     m_database-&gt;connectionProxy().establishTransaction(*this);
1389 }
1390 
1391 void IDBTransaction::activate()
1392 {
<a name="131" id="anc131"></a><span class="line-modified">1393     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1394 
1395     if (isFinishedOrFinishing())
1396         return;
1397 
1398     m_state = IndexedDB::TransactionState::Active;
1399 }
1400 
1401 void IDBTransaction::deactivate()
1402 {
<a name="132" id="anc132"></a><span class="line-modified">1403     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
1404 
1405     if (m_state == IndexedDB::TransactionState::Active)
1406         m_state = IndexedDB::TransactionState::Inactive;
1407 
<a name="133" id="anc133"></a><span class="line-modified">1408     autoCommit();</span>
1409 }
1410 
1411 void IDBTransaction::connectionClosedFromServer(const IDBError&amp; error)
1412 {
1413     LOG(IndexedDB, &quot;IDBTransaction::connectionClosedFromServer - %s&quot;, error.message().utf8().data());
1414 
1415     m_database-&gt;willAbortTransaction(*this);
1416     m_state = IndexedDB::TransactionState::Aborting;
1417 
<a name="134" id="anc134"></a><span class="line-added">1418     // Move operations out of m_pendingTransactionOperationQueue, otherwise we may start handling</span>
<span class="line-added">1419     // them after we forcibly complete in-progress transactions.</span>
<span class="line-added">1420     Deque&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; pendingTransactionOperationQueue;</span>
<span class="line-added">1421     pendingTransactionOperationQueue.swap(m_pendingTransactionOperationQueue);</span>
<span class="line-added">1422 </span>
1423     abortInProgressOperations(error);
1424 
1425     auto operations = copyToVector(m_transactionOperationMap.values());
1426     for (auto&amp; operation : operations) {
1427         m_currentlyCompletingRequest = nullptr;
1428         m_transactionOperationsInProgressQueue.append(operation.get());
1429         ASSERT(m_transactionOperationsInProgressQueue.first() == operation.get());
1430         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
1431     }
1432     m_currentlyCompletingRequest = nullptr;
<a name="135" id="anc135"></a><span class="line-added">1433     m_openRequests.clear();</span>
<span class="line-added">1434     pendingTransactionOperationQueue.clear();</span>
1435 
1436     connectionProxy().forgetActiveOperations(operations);
1437     connectionProxy().forgetTransaction(*this);
1438 
<a name="136" id="anc136"></a>
1439     m_abortQueue.clear();
1440     m_transactionOperationMap.clear();
1441 
1442     m_idbError = error;
1443     m_domError = error.toDOMException();
1444     m_database-&gt;didAbortTransaction(*this);
1445     fireOnAbort();
1446 }
1447 
1448 void IDBTransaction::visitReferencedObjectStores(JSC::SlotVisitor&amp; visitor) const
1449 {
1450     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1451     for (auto&amp; objectStore : m_referencedObjectStores.values())
1452         visitor.addOpaqueRoot(objectStore.get());
1453     for (auto&amp; objectStore : m_deletedObjectStores.values())
1454         visitor.addOpaqueRoot(objectStore.get());
1455 }
1456 
<a name="137" id="anc137"></a><span class="line-added">1457 void IDBTransaction::handlePendingOperations()</span>
<span class="line-added">1458 {</span>
<span class="line-added">1459     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="line-added">1460 </span>
<span class="line-added">1461     if (!m_startedOnServer)</span>
<span class="line-added">1462         return;</span>
<span class="line-added">1463 </span>
<span class="line-added">1464     if (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_transactionOperationsInProgressQueue.last()-&gt;nextRequestCanGoToServer())</span>
<span class="line-added">1465         return;</span>
<span class="line-added">1466 </span>
<span class="line-added">1467     while (!m_pendingTransactionOperationQueue.isEmpty()) {</span>
<span class="line-added">1468         auto operation = m_pendingTransactionOperationQueue.takeFirst();</span>
<span class="line-added">1469         m_transactionOperationsInProgressQueue.append(operation.get());</span>
<span class="line-added">1470         operation-&gt;perform();</span>
<span class="line-added">1471 </span>
<span class="line-added">1472         if (!operation-&gt;nextRequestCanGoToServer())</span>
<span class="line-added">1473             break;</span>
<span class="line-added">1474     }</span>
<span class="line-added">1475 }</span>
<span class="line-added">1476 </span>
<span class="line-added">1477 void IDBTransaction::autoCommit()</span>
<span class="line-added">1478 {</span>
<span class="line-added">1479     // If transaction is not inactive, it&#39;s active, finished or finishing.</span>
<span class="line-added">1480     // If it&#39;s active, it may create new requests, so we cannot commit it.</span>
<span class="line-added">1481     if (m_state != IndexedDB::TransactionState::Inactive)</span>
<span class="line-added">1482         return;</span>
<span class="line-added">1483 </span>
<span class="line-added">1484     if (!m_startedOnServer)</span>
<span class="line-added">1485         return;</span>
<span class="line-added">1486 </span>
<span class="line-added">1487     if (!m_transactionOperationMap.isEmpty())</span>
<span class="line-added">1488         return;</span>
<span class="line-added">1489 </span>
<span class="line-added">1490     if (!m_openRequests.isEmpty())</span>
<span class="line-added">1491         return;</span>
<span class="line-added">1492     ASSERT(!m_currentlyCompletingRequest);</span>
<span class="line-added">1493 </span>
<span class="line-added">1494     commit();</span>
<span class="line-added">1495 }</span>
<span class="line-added">1496 </span>
<span class="line-added">1497 uint64_t IDBTransaction::generateOperationID()</span>
<span class="line-added">1498 {</span>
<span class="line-added">1499     static std::atomic&lt;uint64_t&gt; currentOperationID(1);</span>
<span class="line-added">1500     return currentOperationID += 1;</span>
<span class="line-added">1501 }</span>
<span class="line-added">1502 </span>
1503 } // namespace WebCore
1504 
1505 #endif // ENABLE(INDEXED_DATABASE)
<a name="138" id="anc138"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="138" type="hidden" />
</body>
</html>
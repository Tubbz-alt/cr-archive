<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/BlockDirectory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BlockDirectory.h&quot;
 28 
 29 #include &quot;BlockDirectoryInlines.h&quot;
 30 #include &quot;GCActivityCallback.h&quot;
 31 #include &quot;Heap.h&quot;
 32 #include &quot;IncrementalSweeper.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;MarkedBlockInlines.h&quot;
 35 #include &quot;SubspaceInlines.h&quot;
 36 #include &quot;SuperSampler.h&quot;
 37 #include &quot;VM.h&quot;
 38 
 39 namespace JSC {
 40 
<a name="1" id="anc1"></a><span class="line-modified"> 41 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BlockDirectory);</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43 BlockDirectory::BlockDirectory(size_t cellSize)</span>
 44     : m_cellSize(static_cast&lt;unsigned&gt;(cellSize))
<a name="2" id="anc2"></a>
 45 {
 46 }
 47 
 48 BlockDirectory::~BlockDirectory()
 49 {
 50     auto locker = holdLock(m_localAllocatorsLock);
 51     while (!m_localAllocators.isEmpty())
 52         m_localAllocators.begin()-&gt;remove();
 53 }
 54 
 55 void BlockDirectory::setSubspace(Subspace* subspace)
 56 {
 57     m_attributes = subspace-&gt;attributes();
 58     m_subspace = subspace;
 59 }
 60 
 61 bool BlockDirectory::isPagedOut(MonotonicTime deadline)
 62 {
 63     unsigned itersSinceLastTimeCheck = 0;
 64     for (auto* block : m_blocks) {
 65         if (block)
 66             block-&gt;block().populatePage();
 67         ++itersSinceLastTimeCheck;
 68         if (itersSinceLastTimeCheck &gt;= Heap::s_timeCheckResolution) {
 69             MonotonicTime currentTime = MonotonicTime::now();
 70             if (currentTime &gt; deadline)
 71                 return true;
 72             itersSinceLastTimeCheck = 0;
 73         }
 74     }
 75     return false;
 76 }
 77 
 78 MarkedBlock::Handle* BlockDirectory::findEmptyBlockToSteal()
 79 {
<a name="3" id="anc3"></a><span class="line-modified"> 80     m_emptyCursor = m_bits.empty().findBit(m_emptyCursor, true);</span>
 81     if (m_emptyCursor &gt;= m_blocks.size())
 82         return nullptr;
 83     return m_blocks[m_emptyCursor];
 84 }
 85 
 86 MarkedBlock::Handle* BlockDirectory::findBlockForAllocation(LocalAllocator&amp; allocator)
 87 {
 88     for (;;) {
<a name="4" id="anc4"></a><span class="line-modified"> 89         allocator.m_allocationCursor = (m_bits.canAllocateButNotEmpty() | m_bits.empty()).findBit(allocator.m_allocationCursor, true);</span>
 90         if (allocator.m_allocationCursor &gt;= m_blocks.size())
 91             return nullptr;
 92 
<a name="5" id="anc5"></a><span class="line-modified"> 93         unsigned blockIndex = allocator.m_allocationCursor++;</span>
 94         MarkedBlock::Handle* result = m_blocks[blockIndex];
 95         setIsCanAllocateButNotEmpty(NoLockingNecessary, blockIndex, false);
 96         return result;
 97     }
 98 }
 99 
<a name="6" id="anc6"></a><span class="line-modified">100 MarkedBlock::Handle* BlockDirectory::tryAllocateBlock(Heap&amp; heap)</span>
101 {
102     SuperSamplerScope superSamplerScope(false);
103 
<a name="7" id="anc7"></a><span class="line-modified">104     MarkedBlock::Handle* handle = MarkedBlock::tryCreate(heap, subspace()-&gt;alignedMemoryAllocator());</span>
105     if (!handle)
106         return nullptr;
107 
108     markedSpace().didAddBlock(handle);
109 
110     return handle;
111 }
112 
113 void BlockDirectory::addBlock(MarkedBlock::Handle* block)
114 {
<a name="8" id="anc8"></a><span class="line-modified">115     unsigned index;</span>
116     if (m_freeBlockIndices.isEmpty()) {
117         index = m_blocks.size();
118 
119         size_t oldCapacity = m_blocks.capacity();
120         m_blocks.append(block);
121         if (m_blocks.capacity() != oldCapacity) {
<a name="9" id="anc9"></a><span class="line-modified">122             ASSERT(m_bits.numBits() == oldCapacity);</span>





123             ASSERT(m_blocks.capacity() &gt; oldCapacity);
124 
125             LockHolder locker(m_bitvectorLock);
126             subspace()-&gt;didResizeBits(m_blocks.capacity());
<a name="10" id="anc10"></a><span class="line-modified">127             m_bits.resize(m_blocks.capacity());</span>




128         }
129     } else {
130         index = m_freeBlockIndices.takeLast();
131         ASSERT(!m_blocks[index]);
132         m_blocks[index] = block;
133     }
134 
135     forEachBitVector(
136         NoLockingNecessary,
<a name="11" id="anc11"></a><span class="line-modified">137         [&amp;](auto vectorRef) {</span>
<span class="line-modified">138             ASSERT_UNUSED(vectorRef, !vectorRef[index]);</span>
139         });
140 
141     // This is the point at which the block learns of its cellSize() and attributes().
142     block-&gt;didAddToDirectory(this, index);
143 
144     setIsLive(NoLockingNecessary, index, true);
145     setIsEmpty(NoLockingNecessary, index, true);
146 }
147 
148 void BlockDirectory::removeBlock(MarkedBlock::Handle* block)
149 {
150     ASSERT(block-&gt;directory() == this);
151     ASSERT(m_blocks[block-&gt;index()] == block);
152 
153     subspace()-&gt;didRemoveBlock(block-&gt;index());
154 
155     m_blocks[block-&gt;index()] = nullptr;
156     m_freeBlockIndices.append(block-&gt;index());
157 
158     forEachBitVector(
159         holdLock(m_bitvectorLock),
<a name="12" id="anc12"></a><span class="line-modified">160         [&amp;](auto vectorRef) {</span>
<span class="line-modified">161             vectorRef[block-&gt;index()] = false;</span>
162         });
163 
164     block-&gt;didRemoveFromDirectory();
165 }
166 
167 void BlockDirectory::stopAllocating()
168 {
169     if (false)
170         dataLog(RawPointer(this), &quot;: BlockDirectory::stopAllocating!\n&quot;);
171     m_localAllocators.forEach(
172         [&amp;] (LocalAllocator* allocator) {
173             allocator-&gt;stopAllocating();
174         });
175 }
176 
177 void BlockDirectory::prepareForAllocation()
178 {
179     m_localAllocators.forEach(
180         [&amp;] (LocalAllocator* allocator) {
181             allocator-&gt;prepareForAllocation();
182         });
183 
184     m_unsweptCursor = 0;
185     m_emptyCursor = 0;
186 
<a name="13" id="anc13"></a><span class="line-modified">187     m_bits.eden().clearAll();</span>
188 
189     if (UNLIKELY(Options::useImmortalObjects())) {
190         // FIXME: Make this work again.
191         // https://bugs.webkit.org/show_bug.cgi?id=162296
192         RELEASE_ASSERT_NOT_REACHED();
193     }
194 }
195 
196 void BlockDirectory::stopAllocatingForGood()
197 {
198     if (false)
199         dataLog(RawPointer(this), &quot;: BlockDirectory::stopAllocatingForGood!\n&quot;);
200 
201     m_localAllocators.forEach(
202         [&amp;] (LocalAllocator* allocator) {
203             allocator-&gt;stopAllocatingForGood();
204         });
205 
206     auto locker = holdLock(m_localAllocatorsLock);
207     while (!m_localAllocators.isEmpty())
208         m_localAllocators.begin()-&gt;remove();
209 }
210 
211 void BlockDirectory::lastChanceToFinalize()
212 {
213     forEachBlock(
214         [&amp;] (MarkedBlock::Handle* block) {
215             block-&gt;lastChanceToFinalize();
216         });
217 }
218 
219 void BlockDirectory::resumeAllocating()
220 {
221     m_localAllocators.forEach(
222         [&amp;] (LocalAllocator* allocator) {
223             allocator-&gt;resumeAllocating();
224         });
225 }
226 
227 void BlockDirectory::beginMarkingForFullCollection()
228 {
229     // Mark bits are sticky and so is our summary of mark bits. We only clear these during full
230     // collections, so if you survived the last collection you will survive the next one so long
231     // as the next one is eden.
<a name="14" id="anc14"></a><span class="line-modified">232     m_bits.markingNotEmpty().clearAll();</span>
<span class="line-modified">233     m_bits.markingRetired().clearAll();</span>
234 }
235 
236 void BlockDirectory::endMarking()
237 {
<a name="15" id="anc15"></a><span class="line-modified">238     m_bits.allocated().clearAll();</span>
239 
240     // It&#39;s surprising and frustrating to comprehend, but the end-of-marking flip does not need to
241     // know what kind of collection it is. That knowledge is already encoded in the m_markingXYZ
242     // vectors.
243 
<a name="16" id="anc16"></a><span class="line-modified">244     m_bits.empty() = m_bits.live() &amp; ~m_bits.markingNotEmpty();</span>
<span class="line-modified">245     m_bits.canAllocateButNotEmpty() = m_bits.live() &amp; m_bits.markingNotEmpty() &amp; ~m_bits.markingRetired();</span>
246 
247     if (needsDestruction()) {
248         // There are some blocks that we didn&#39;t allocate out of in the last cycle, but we swept them. This
249         // will forget that we did that and we will end up sweeping them again and attempting to call their
250         // destructors again. That&#39;s fine because of zapping. The only time when we cannot forget is when
251         // we just allocate a block or when we move a block from one size class to another. That doesn&#39;t
252         // happen here.
<a name="17" id="anc17"></a><span class="line-modified">253         m_bits.destructible() = m_bits.live();</span>
254     }
255 
256     if (false) {
257         dataLog(&quot;Bits for &quot;, m_cellSize, &quot;, &quot;, m_attributes, &quot; after endMarking:\n&quot;);
258         dumpBits(WTF::dataFile());
259     }
260 }
261 
262 void BlockDirectory::snapshotUnsweptForEdenCollection()
263 {
<a name="18" id="anc18"></a><span class="line-modified">264     m_bits.unswept() |= m_bits.eden();</span>
265 }
266 
267 void BlockDirectory::snapshotUnsweptForFullCollection()
268 {
<a name="19" id="anc19"></a><span class="line-modified">269     m_bits.unswept() = m_bits.live();</span>
270 }
271 
272 MarkedBlock::Handle* BlockDirectory::findBlockToSweep()
273 {
<a name="20" id="anc20"></a><span class="line-modified">274     m_unsweptCursor = m_bits.unswept().findBit(m_unsweptCursor, true);</span>
275     if (m_unsweptCursor &gt;= m_blocks.size())
276         return nullptr;
277     return m_blocks[m_unsweptCursor];
278 }
279 
280 void BlockDirectory::sweep()
281 {
<a name="21" id="anc21"></a><span class="line-modified">282     m_bits.unswept().forEachSetBit(</span>
283         [&amp;] (size_t index) {
284             MarkedBlock::Handle* block = m_blocks[index];
285             block-&gt;sweep(nullptr);
286         });
287 }
288 
289 void BlockDirectory::shrink()
290 {
<a name="22" id="anc22"></a><span class="line-modified">291     (m_bits.empty() &amp; ~m_bits.destructible()).forEachSetBit(</span>
292         [&amp;] (size_t index) {
293             markedSpace().freeBlock(m_blocks[index]);
294         });
295 }
296 
297 void BlockDirectory::assertNoUnswept()
298 {
<a name="23" id="anc23"></a><span class="line-modified">299     if (!ASSERT_ENABLED)</span>
300         return;
301 
<a name="24" id="anc24"></a><span class="line-modified">302     if (m_bits.unswept().isEmpty())</span>
303         return;
304 
305     dataLog(&quot;Assertion failed: unswept not empty in &quot;, *this, &quot;.\n&quot;);
306     dumpBits();
307     ASSERT_NOT_REACHED();
308 }
309 
310 RefPtr&lt;SharedTask&lt;MarkedBlock::Handle*()&gt;&gt; BlockDirectory::parallelNotEmptyBlockSource()
311 {
312     class Task : public SharedTask&lt;MarkedBlock::Handle*()&gt; {
313     public:
314         Task(BlockDirectory&amp; directory)
315             : m_directory(directory)
316         {
317         }
318 
319         MarkedBlock::Handle* run() override
320         {
321             if (m_done)
322                 return nullptr;
323             auto locker = holdLock(m_lock);
<a name="25" id="anc25"></a><span class="line-modified">324             m_index = m_directory.m_bits.markingNotEmpty().findBit(m_index, true);</span>
325             if (m_index &gt;= m_directory.m_blocks.size()) {
326                 m_done = true;
327                 return nullptr;
328             }
329             return m_directory.m_blocks[m_index++];
330         }
331 
332     private:
333         BlockDirectory&amp; m_directory;
334         size_t m_index { 0 };
335         Lock m_lock;
336         bool m_done { false };
337     };
338 
339     return adoptRef(new Task(*this));
340 }
341 
342 void BlockDirectory::dump(PrintStream&amp; out) const
343 {
344     out.print(RawPointer(this), &quot;:&quot;, m_cellSize, &quot;/&quot;, m_attributes);
345 }
346 
347 void BlockDirectory::dumpBits(PrintStream&amp; out)
348 {
349     unsigned maxNameLength = 0;
350     forEachBitVectorWithName(
351         NoLockingNecessary,
<a name="26" id="anc26"></a><span class="line-modified">352         [&amp;](auto vectorRef, const char* name) {</span>
<span class="line-added">353             UNUSED_PARAM(vectorRef);</span>
354             unsigned length = strlen(name);
355             maxNameLength = std::max(maxNameLength, length);
356         });
357 
358     forEachBitVectorWithName(
359         NoLockingNecessary,
<a name="27" id="anc27"></a><span class="line-modified">360         [&amp;](auto vectorRef, const char* name) {</span>
361             out.print(&quot;    &quot;, name, &quot;: &quot;);
362             for (unsigned i = maxNameLength - strlen(name); i--;)
363                 out.print(&quot; &quot;);
<a name="28" id="anc28"></a><span class="line-modified">364             out.print(vectorRef, &quot;\n&quot;);</span>
365         });
366 }
367 
368 MarkedSpace&amp; BlockDirectory::markedSpace() const
369 {
370     return m_subspace-&gt;space();
371 }
372 
373 bool BlockDirectory::isFreeListedCell(const void* target)
374 {
375     bool result = false;
376     m_localAllocators.forEach(
377         [&amp;] (LocalAllocator* allocator) {
378             result |= allocator-&gt;isFreeListedCell(target);
379         });
380     return result;
381 }
382 
383 } // namespace JSC
384 
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
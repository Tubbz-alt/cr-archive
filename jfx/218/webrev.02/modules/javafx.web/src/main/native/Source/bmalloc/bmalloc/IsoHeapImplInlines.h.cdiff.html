<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoHeapImplInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoHeapImpl.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoHeapInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoHeapImplInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,199 ***</span>
  
  namespace bmalloc {
  
  template&lt;typename Config&gt;
  IsoHeapImpl&lt;Config&gt;::IsoHeapImpl()
<span class="line-modified">!     : lock(PerProcess&lt;IsoTLSDeallocatorEntry&lt;Config&gt;&gt;::get()-&gt;lock)</span>
      , m_inlineDirectory(*this)
      , m_allocator(*this)
  {
<span class="line-removed">-     addToAllIsoHeaps();</span>
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! EligibilityResult&lt;Config&gt; IsoHeapImpl&lt;Config&gt;::takeFirstEligible()</span>
  {
      if (m_isInlineDirectoryEligibleOrDecommitted) {
<span class="line-modified">!         EligibilityResult&lt;Config&gt; result = m_inlineDirectory.takeFirstEligible();</span>
          if (result.kind == EligibilityKind::Full)
              m_isInlineDirectoryEligibleOrDecommitted = false;
          else
              return result;
      }
  
<span class="line-modified">!     if (!m_firstEligibleOrDecommitedDirectory) {</span>
<span class="line-modified">!         // If nothing is eligible, it can only be because we have no directories. It wouldn&#39;t be the end</span>
<span class="line-modified">!         // of the world if we broke this invariant. It would only mean that didBecomeEligibleOrDecommited() would need</span>
<span class="line-modified">!         // a null check.</span>
<span class="line-modified">!         RELEASE_BASSERT(!m_headDirectory);</span>
<span class="line-modified">!         RELEASE_BASSERT(!m_tailDirectory);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (; m_firstEligibleOrDecommitedDirectory; m_firstEligibleOrDecommitedDirectory = m_firstEligibleOrDecommitedDirectory-&gt;next) {</span>
<span class="line-modified">!         EligibilityResult&lt;Config&gt; result = m_firstEligibleOrDecommitedDirectory-&gt;payload.takeFirstEligible();</span>
<span class="line-modified">!         if (result.kind != EligibilityKind::Full) {</span>
<span class="line-modified">!             m_directoryHighWatermark = std::max(m_directoryHighWatermark, m_firstEligibleOrDecommitedDirectory-&gt;index());</span>
<span class="line-modified">!             return result;</span>
          }
      }
  
      auto* newDirectory = new IsoDirectoryPage&lt;Config&gt;(*this, m_nextDirectoryPageIndex++);
<span class="line-modified">!     if (m_headDirectory) {</span>
          m_tailDirectory-&gt;next = newDirectory;
          m_tailDirectory = newDirectory;
      } else {
<span class="line-modified">!         RELEASE_BASSERT(!m_tailDirectory);</span>
          m_headDirectory = newDirectory;
          m_tailDirectory = newDirectory;
      }
      m_directoryHighWatermark = newDirectory-&gt;index();
      m_firstEligibleOrDecommitedDirectory = newDirectory;
<span class="line-modified">!     EligibilityResult&lt;Config&gt; result = newDirectory-&gt;payload.takeFirstEligible();</span>
      RELEASE_BASSERT(result.kind != EligibilityKind::Full);
      return result;
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::didBecomeEligibleOrDecommited(IsoDirectory&lt;Config, numPagesInInlineDirectory&gt;* directory)</span>
  {
      RELEASE_BASSERT(directory == &amp;m_inlineDirectory);
      m_isInlineDirectoryEligibleOrDecommitted = true;
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::didBecomeEligibleOrDecommited(IsoDirectory&lt;Config, IsoDirectoryPage&lt;Config&gt;::numPages&gt;* directory)</span>
  {
      RELEASE_BASSERT(m_firstEligibleOrDecommitedDirectory);
      auto* directoryPage = IsoDirectoryPage&lt;Config&gt;::pageFor(directory);
      if (directoryPage-&gt;index() &lt; m_firstEligibleOrDecommitedDirectory-&gt;index())
          m_firstEligibleOrDecommitedDirectory = directoryPage;
  }
  
  template&lt;typename Config&gt;
  void IsoHeapImpl&lt;Config&gt;::scavenge(Vector&lt;DeferredDecommit&gt;&amp; decommits)
  {
<span class="line-modified">!     std::lock_guard&lt;Mutex&gt; locker(this-&gt;lock);</span>
      forEachDirectory(
          [&amp;] (auto&amp; directory) {
<span class="line-modified">!             directory.scavenge(decommits);</span>
          });
      m_directoryHighWatermark = 0;
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! size_t IsoHeapImpl&lt;Config&gt;::freeableMemory()</span>
  {
      return m_freeableMemory;
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::allocatorOffset()
  {
<span class="line-modified">!     return m_allocator.offset();</span>
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::deallocatorOffset()
  {
<span class="line-modified">!     return PerProcess&lt;IsoTLSDeallocatorEntry&lt;Config&gt;&gt;::get()-&gt;offset();</span>
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::numLiveObjects()
  {
      unsigned result = 0;
      forEachLiveObject(
          [&amp;] (void*) {
              result++;
          });
      return result;
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::numCommittedPages()
  {
      unsigned result = 0;
      forEachCommittedPage(
          [&amp;] (IsoPage&lt;Config&gt;&amp;) {
              result++;
          });
      return result;
  }
  
  template&lt;typename Config&gt;
  template&lt;typename Func&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::forEachDirectory(const Func&amp; func)</span>
  {
      func(m_inlineDirectory);
<span class="line-modified">!     for (IsoDirectoryPage&lt;Config&gt;* page = m_headDirectory; page; page = page-&gt;next)</span>
          func(page-&gt;payload);
  }
  
  template&lt;typename Config&gt;
  template&lt;typename Func&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::forEachCommittedPage(const Func&amp; func)</span>
  {
      forEachDirectory(
          [&amp;] (auto&amp; directory) {
<span class="line-modified">!             directory.forEachCommittedPage(func);</span>
          });
  }
  
  template&lt;typename Config&gt;
  template&lt;typename Func&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::forEachLiveObject(const Func&amp; func)</span>
  {
      forEachCommittedPage(
          [&amp;] (IsoPage&lt;Config&gt;&amp; page) {
<span class="line-modified">!             page.forEachLiveObject(func);</span>
          });
      for (unsigned index = 0; index &lt; maxAllocationFromShared; ++index) {
<span class="line-modified">!         void* pointer = m_sharedCells[index];</span>
          if (pointer &amp;&amp; !(m_availableShared &amp; (1U &lt;&lt; index)))
              func(pointer);
      }
  }
  
<span class="line-modified">! template&lt;typename Config&gt;</span>
<span class="line-removed">- size_t IsoHeapImpl&lt;Config&gt;::footprint()</span>
  {
  #if ENABLE_PHYSICAL_PAGE_MAP
      RELEASE_BASSERT(m_footprint == m_physicalPageMap.footprint());
  #endif
      return m_footprint;
  }
  
<span class="line-modified">! template&lt;typename Config&gt;</span>
<span class="line-removed">- void IsoHeapImpl&lt;Config&gt;::didCommit(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_footprint += bytes;
  #if ENABLE_PHYSICAL_PAGE_MAP
      m_physicalPageMap.commit(ptr, bytes);
  #endif
  }
  
<span class="line-modified">! template&lt;typename Config&gt;</span>
<span class="line-removed">- void IsoHeapImpl&lt;Config&gt;::didDecommit(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_footprint -= bytes;
  #if ENABLE_PHYSICAL_PAGE_MAP
      m_physicalPageMap.decommit(ptr, bytes);
  #endif
  }
  
<span class="line-modified">! template&lt;typename Config&gt;</span>
<span class="line-removed">- void IsoHeapImpl&lt;Config&gt;::isNowFreeable(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_freeableMemory += bytes;
  }
  
<span class="line-modified">! template&lt;typename Config&gt;</span>
<span class="line-removed">- void IsoHeapImpl&lt;Config&gt;::isNoLongerFreeable(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_freeableMemory -= bytes;
  }
  
<span class="line-new-header">--- 32,224 ---</span>
  
  namespace bmalloc {
  
  template&lt;typename Config&gt;
  IsoHeapImpl&lt;Config&gt;::IsoHeapImpl()
<span class="line-modified">!     : IsoHeapImplBase((*PerProcess&lt;IsoTLSEntryHolder&lt;IsoTLSDeallocatorEntry&lt;Config&gt;&gt;&gt;::get())-&gt;lock)</span>
      , m_inlineDirectory(*this)
      , m_allocator(*this)
  {
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! EligibilityResult&lt;Config&gt; IsoHeapImpl&lt;Config&gt;::takeFirstEligible(const LockHolder&amp; locker)</span>
  {
      if (m_isInlineDirectoryEligibleOrDecommitted) {
<span class="line-modified">!         EligibilityResult&lt;Config&gt; result = m_inlineDirectory.takeFirstEligible(locker);</span>
          if (result.kind == EligibilityKind::Full)
              m_isInlineDirectoryEligibleOrDecommitted = false;
          else
              return result;
      }
  
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto* cursor = m_firstEligibleOrDecommitedDirectory.get();</span>
<span class="line-modified">!         if (!cursor) {</span>
<span class="line-modified">!             // If nothing is eligible, it can only be because we have no directories. It wouldn&#39;t be the end</span>
<span class="line-modified">!             // of the world if we broke this invariant. It would only mean that didBecomeEligibleOrDecommited() would need</span>
<span class="line-modified">!             // a null check.</span>
<span class="line-modified">!             RELEASE_BASSERT(!m_headDirectory.get());</span>
<span class="line-modified">!             RELEASE_BASSERT(!m_tailDirectory.get());</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             auto* originalCursor = cursor;</span>
<span class="line-modified">!             BUNUSED(originalCursor);</span>
<span class="line-modified">!             for (; cursor; cursor = cursor-&gt;next) {</span>
<span class="line-modified">!                 EligibilityResult&lt;Config&gt; result = cursor-&gt;payload.takeFirstEligible(locker);</span>
<span class="line-added">+                 // While iterating, m_firstEligibleOrDecommitedDirectory is never changed. We are holding a lock,</span>
<span class="line-added">+                 // and IsoDirectory::takeFirstEligible must not populate a new eligibile / decommitted pages.</span>
<span class="line-added">+                 BASSERT(m_firstEligibleOrDecommitedDirectory.get() == originalCursor);</span>
<span class="line-added">+                 if (result.kind != EligibilityKind::Full) {</span>
<span class="line-added">+                     m_directoryHighWatermark = std::max(m_directoryHighWatermark, cursor-&gt;index());</span>
<span class="line-added">+                     m_firstEligibleOrDecommitedDirectory = cursor;</span>
<span class="line-added">+                     return result;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             m_firstEligibleOrDecommitedDirectory = nullptr;</span>
          }
      }
  
      auto* newDirectory = new IsoDirectoryPage&lt;Config&gt;(*this, m_nextDirectoryPageIndex++);
<span class="line-modified">!     if (m_headDirectory.get()) {</span>
          m_tailDirectory-&gt;next = newDirectory;
          m_tailDirectory = newDirectory;
      } else {
<span class="line-modified">!         RELEASE_BASSERT(!m_tailDirectory.get());</span>
          m_headDirectory = newDirectory;
          m_tailDirectory = newDirectory;
      }
      m_directoryHighWatermark = newDirectory-&gt;index();
      m_firstEligibleOrDecommitedDirectory = newDirectory;
<span class="line-modified">!     EligibilityResult&lt;Config&gt; result = newDirectory-&gt;payload.takeFirstEligible(locker);</span>
      RELEASE_BASSERT(result.kind != EligibilityKind::Full);
      return result;
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::didBecomeEligibleOrDecommited(const LockHolder&amp;, IsoDirectory&lt;Config, numPagesInInlineDirectory&gt;* directory)</span>
  {
      RELEASE_BASSERT(directory == &amp;m_inlineDirectory);
      m_isInlineDirectoryEligibleOrDecommitted = true;
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::didBecomeEligibleOrDecommited(const LockHolder&amp;, IsoDirectory&lt;Config, IsoDirectoryPage&lt;Config&gt;::numPages&gt;* directory)</span>
  {
      RELEASE_BASSERT(m_firstEligibleOrDecommitedDirectory);
      auto* directoryPage = IsoDirectoryPage&lt;Config&gt;::pageFor(directory);
      if (directoryPage-&gt;index() &lt; m_firstEligibleOrDecommitedDirectory-&gt;index())
          m_firstEligibleOrDecommitedDirectory = directoryPage;
  }
  
  template&lt;typename Config&gt;
  void IsoHeapImpl&lt;Config&gt;::scavenge(Vector&lt;DeferredDecommit&gt;&amp; decommits)
  {
<span class="line-modified">!     LockHolder locker(this-&gt;lock);</span>
      forEachDirectory(
<span class="line-added">+         locker,</span>
          [&amp;] (auto&amp; directory) {
<span class="line-modified">!             directory.scavenge(locker, decommits);</span>
          });
      m_directoryHighWatermark = 0;
  }
  
<span class="line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
  template&lt;typename Config&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::scavengeToHighWatermark(Vector&lt;DeferredDecommit&gt;&amp; decommits)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     LockHolder locker(this-&gt;lock);</span>
<span class="line-added">+     if (!m_directoryHighWatermark)</span>
<span class="line-added">+         m_inlineDirectory.scavengeToHighWatermark(locker, decommits);</span>
<span class="line-added">+     for (IsoDirectoryPage&lt;Config&gt;* page = m_headDirectory.get(); page; page = page-&gt;next) {</span>
<span class="line-added">+         if (page-&gt;index() &gt;= m_directoryHighWatermark)</span>
<span class="line-added">+             page-&gt;payload.scavengeToHighWatermark(locker, decommits);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     m_directoryHighWatermark = 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline size_t IsoHeapImplBase::freeableMemory()</span>
  {
      return m_freeableMemory;
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::allocatorOffset()
  {
<span class="line-modified">!     return m_allocator-&gt;offset();</span>
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::deallocatorOffset()
  {
<span class="line-modified">!     return (*PerProcess&lt;IsoTLSEntryHolder&lt;IsoTLSDeallocatorEntry&lt;Config&gt;&gt;&gt;::get())-&gt;offset();</span>
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::numLiveObjects()
  {
<span class="line-added">+     LockHolder locker(this-&gt;lock);</span>
      unsigned result = 0;
      forEachLiveObject(
<span class="line-added">+         locker,</span>
          [&amp;] (void*) {
              result++;
          });
      return result;
  }
  
  template&lt;typename Config&gt;
  unsigned IsoHeapImpl&lt;Config&gt;::numCommittedPages()
  {
<span class="line-added">+     LockHolder locker(this-&gt;lock);</span>
      unsigned result = 0;
      forEachCommittedPage(
<span class="line-added">+         locker,</span>
          [&amp;] (IsoPage&lt;Config&gt;&amp;) {
              result++;
          });
      return result;
  }
  
  template&lt;typename Config&gt;
  template&lt;typename Func&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::forEachDirectory(const LockHolder&amp;, const Func&amp; func)</span>
  {
      func(m_inlineDirectory);
<span class="line-modified">!     for (IsoDirectoryPage&lt;Config&gt;* page = m_headDirectory.get(); page; page = page-&gt;next)</span>
          func(page-&gt;payload);
  }
  
  template&lt;typename Config&gt;
  template&lt;typename Func&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::forEachCommittedPage(const LockHolder&amp; locker, const Func&amp; func)</span>
  {
      forEachDirectory(
<span class="line-added">+         locker,</span>
          [&amp;] (auto&amp; directory) {
<span class="line-modified">!             directory.forEachCommittedPage(locker, func);</span>
          });
  }
  
  template&lt;typename Config&gt;
  template&lt;typename Func&gt;
<span class="line-modified">! void IsoHeapImpl&lt;Config&gt;::forEachLiveObject(const LockHolder&amp; locker, const Func&amp; func)</span>
  {
      forEachCommittedPage(
<span class="line-added">+         locker,</span>
          [&amp;] (IsoPage&lt;Config&gt;&amp; page) {
<span class="line-modified">!             page.forEachLiveObject(locker, func);</span>
          });
      for (unsigned index = 0; index &lt; maxAllocationFromShared; ++index) {
<span class="line-modified">!         void* pointer = m_sharedCells[index].get();</span>
          if (pointer &amp;&amp; !(m_availableShared &amp; (1U &lt;&lt; index)))
              func(pointer);
      }
  }
  
<span class="line-modified">! inline size_t IsoHeapImplBase::footprint()</span>
  {
  #if ENABLE_PHYSICAL_PAGE_MAP
      RELEASE_BASSERT(m_footprint == m_physicalPageMap.footprint());
  #endif
      return m_footprint;
  }
  
<span class="line-modified">! inline void IsoHeapImplBase::didCommit(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_footprint += bytes;
  #if ENABLE_PHYSICAL_PAGE_MAP
      m_physicalPageMap.commit(ptr, bytes);
  #endif
  }
  
<span class="line-modified">! inline void IsoHeapImplBase::didDecommit(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_footprint -= bytes;
  #if ENABLE_PHYSICAL_PAGE_MAP
      m_physicalPageMap.decommit(ptr, bytes);
  #endif
  }
  
<span class="line-modified">! inline void IsoHeapImplBase::isNowFreeable(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_freeableMemory += bytes;
  }
  
<span class="line-modified">! inline void IsoHeapImplBase::isNoLongerFreeable(void* ptr, size_t bytes)</span>
  {
      BUNUSED_PARAM(ptr);
      m_freeableMemory -= bytes;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,18 ***</span>
      m_allocationMode = allocationMode;
      return allocationMode;
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! void* IsoHeapImpl&lt;Config&gt;::allocateFromShared(const std::lock_guard&lt;Mutex&gt;&amp;, bool abortOnFailure)</span>
  {
      static constexpr bool verbose = false;
  
      unsigned indexPlusOne = __builtin_ffs(m_availableShared);
      BASSERT(indexPlusOne);
      unsigned index = indexPlusOne - 1;
<span class="line-modified">!     void* result = m_sharedCells[index];</span>
      if (result) {
          if (verbose)
              fprintf(stderr, &quot;%p: allocated %p from shared again of size %u\n&quot;, this, result, Config::objectSize);
      } else {
          constexpr unsigned objectSizeWithHeapImplPointer = Config::objectSize + sizeof(uint8_t);
<span class="line-new-header">--- 303,18 ---</span>
      m_allocationMode = allocationMode;
      return allocationMode;
  }
  
  template&lt;typename Config&gt;
<span class="line-modified">! void* IsoHeapImpl&lt;Config&gt;::allocateFromShared(const LockHolder&amp;, bool abortOnFailure)</span>
  {
      static constexpr bool verbose = false;
  
      unsigned indexPlusOne = __builtin_ffs(m_availableShared);
      BASSERT(indexPlusOne);
      unsigned index = indexPlusOne - 1;
<span class="line-modified">!     void* result = m_sharedCells[index].get();</span>
      if (result) {
          if (verbose)
              fprintf(stderr, &quot;%p: allocated %p from shared again of size %u\n&quot;, this, result, Config::objectSize);
      } else {
          constexpr unsigned objectSizeWithHeapImplPointer = Config::objectSize + sizeof(uint8_t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,11 ***</span>
              return nullptr;
          if (verbose)
              fprintf(stderr, &quot;%p: allocated %p from shared of size %u\n&quot;, this, result, Config::objectSize);
          BASSERT(index &lt; IsoHeapImplBase::maxAllocationFromShared);
          *indexSlotFor&lt;Config&gt;(result) = index;
<span class="line-modified">!         m_sharedCells[index] = result;</span>
      }
      BASSERT(result);
      m_availableShared &amp;= ~(1U &lt;&lt; index);
      ++m_numberOfAllocationsFromSharedInOneCycle;
      return result;
<span class="line-new-header">--- 323,11 ---</span>
              return nullptr;
          if (verbose)
              fprintf(stderr, &quot;%p: allocated %p from shared of size %u\n&quot;, this, result, Config::objectSize);
          BASSERT(index &lt; IsoHeapImplBase::maxAllocationFromShared);
          *indexSlotFor&lt;Config&gt;(result) = index;
<span class="line-modified">!         m_sharedCells[index] = bitwise_cast&lt;uint8_t*&gt;(result);</span>
      }
      BASSERT(result);
      m_availableShared &amp;= ~(1U &lt;&lt; index);
      ++m_numberOfAllocationsFromSharedInOneCycle;
      return result;
</pre>
<center><a href="IsoHeapImpl.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoHeapInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp
@@ -26,17 +26,18 @@
 #include "config.h"
 
 #if ENABLE(WEBGL)
 #include "WebGLDrawBuffers.h"
 
-#include "Extensions3D.h"
+#include "ExtensionsGL.h"
 
 namespace WebCore {
 
 WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase& context)
     : WebGLExtension(context)
 {
+    context.graphicsContextGL()->getExtensions().ensureEnabled("GL_EXT_draw_buffers");
 }
 
 WebGLDrawBuffers::~WebGLDrawBuffers() = default;
 
 WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
@@ -44,112 +45,116 @@
     return WebGLExtension::WebGLDrawBuffersName;
 }
 
 bool WebGLDrawBuffers::supported(WebGLRenderingContextBase& context)
 {
-    return context.graphicsContext3D()->getExtensions().supports("GL_EXT_draw_buffers")
+#if USE(ANGLE)
+    return context.graphicsContextGL()->getExtensions().supports("GL_EXT_draw_buffers");
+#else
+    return context.graphicsContextGL()->getExtensions().supports("GL_EXT_draw_buffers")
         && satisfiesWebGLRequirements(context);
+#endif
 }
 
-void WebGLDrawBuffers::drawBuffersWEBGL(const Vector<GC3Denum>& buffers)
+void WebGLDrawBuffers::drawBuffersWEBGL(const Vector<GCGLenum>& buffers)
 {
     if (m_context.isContextLost())
         return;
-    GC3Dsizei n = buffers.size();
-    const GC3Denum* bufs = buffers.data();
+    GCGLsizei n = buffers.size();
+    const GCGLenum* bufs = buffers.data();
     if (!m_context.m_framebufferBinding) {
         if (n != 1) {
-            m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, "drawBuffersWEBGL", "more than one buffer");
+            m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, "drawBuffersWEBGL", "more than one buffer");
             return;
         }
-        if (bufs[0] != GraphicsContext3D::BACK && bufs[0] != GraphicsContext3D::NONE) {
-            m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, "drawBuffersWEBGL", "BACK or NONE");
+        if (bufs[0] != GraphicsContextGL::BACK && bufs[0] != GraphicsContextGL::NONE) {
+            m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, "drawBuffersWEBGL", "BACK or NONE");
             return;
         }
         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
-        GC3Denum value = (bufs[0] == GraphicsContext3D::BACK) ? GraphicsContext3D::COLOR_ATTACHMENT0 : GraphicsContext3D::NONE;
-        m_context.graphicsContext3D()->getExtensions().drawBuffersEXT(1, &value);
+        GCGLenum value = (bufs[0] == GraphicsContextGL::BACK) ? GraphicsContextGL::COLOR_ATTACHMENT0 : GraphicsContextGL::NONE;
+        m_context.graphicsContextGL()->getExtensions().drawBuffersEXT(1, &value);
         m_context.setBackDrawBuffer(bufs[0]);
     } else {
         if (n > m_context.getMaxDrawBuffers()) {
-            m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, "drawBuffersWEBGL", "more than max draw buffers");
+            m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, "drawBuffersWEBGL", "more than max draw buffers");
             return;
         }
-        for (GC3Dsizei i = 0; i < n; ++i) {
-            if (bufs[i] != GraphicsContext3D::NONE && bufs[i] != static_cast<GC3Denum>(Extensions3D::COLOR_ATTACHMENT0_EXT + i)) {
-                m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, "drawBuffersWEBGL", "COLOR_ATTACHMENTi_EXT or NONE");
+        for (GCGLsizei i = 0; i < n; ++i) {
+            if (bufs[i] != GraphicsContextGL::NONE && bufs[i] != static_cast<GCGLenum>(ExtensionsGL::COLOR_ATTACHMENT0_EXT + i)) {
+                m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, "drawBuffersWEBGL", "COLOR_ATTACHMENTi_EXT or NONE");
                 return;
             }
         }
         m_context.m_framebufferBinding->drawBuffers(buffers);
     }
 }
 
 // static
 bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase& webglContext)
 {
-    GraphicsContext3D* context = webglContext.graphicsContext3D();
+    GraphicsContextGLOpenGL* context = webglContext.graphicsContextGL();
 
     // This is called after we make sure GL_EXT_draw_buffers is supported.
-    GC3Dint maxDrawBuffers = 0;
-    GC3Dint maxColorAttachments = 0;
-    context->getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &maxDrawBuffers);
-    context->getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &maxColorAttachments);
+    GCGLint maxDrawBuffers = 0;
+    GCGLint maxColorAttachments = 0;
+    context->getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &maxDrawBuffers);
+    context->getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &maxColorAttachments);
     if (maxDrawBuffers < 4 || maxColorAttachments < 4)
         return false;
 
-    Platform3DObject fbo = context->createFramebuffer();
-    context->bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, fbo);
+    PlatformGLObject fbo = context->createFramebuffer();
+    context->bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, fbo);
 
     const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
     bool supportsDepth = context->getExtensions().supports("GL_OES_depth_texture")
         || context->getExtensions().supports("GL_ARB_depth_texture");
     bool supportsDepthStencil = (context->getExtensions().supports("GL_EXT_packed_depth_stencil")
         || context->getExtensions().supports("GL_OES_packed_depth_stencil"));
-    Platform3DObject depthStencil = 0;
+    PlatformGLObject depthStencil = 0;
     if (supportsDepthStencil) {
         depthStencil = context->createTexture();
-        context->bindTexture(GraphicsContext3D::TEXTURE_2D, depthStencil);
-        context->texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_STENCIL, 1, 1, 0, GraphicsContext3D::DEPTH_STENCIL, GraphicsContext3D::UNSIGNED_INT_24_8, buffer);
+        context->bindTexture(GraphicsContextGL::TEXTURE_2D, depthStencil);
+        context->texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_STENCIL, 1, 1, 0, GraphicsContextGL::DEPTH_STENCIL, GraphicsContextGL::UNSIGNED_INT_24_8, buffer);
     }
-    Platform3DObject depth = 0;
+    PlatformGLObject depth = 0;
     if (supportsDepth) {
         depth = context->createTexture();
-        context->bindTexture(GraphicsContext3D::TEXTURE_2D, depth);
-        context->texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_COMPONENT, 1, 1, 0, GraphicsContext3D::DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT, buffer);
+        context->bindTexture(GraphicsContextGL::TEXTURE_2D, depth);
+        context->texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_COMPONENT, 1, 1, 0, GraphicsContextGL::DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT, buffer);
     }
 
-    Vector<Platform3DObject> colors;
+    Vector<PlatformGLObject> colors;
     bool ok = true;
-    GC3Dint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);
-    for (GC3Dint i = 0; i < maxAllowedBuffers; ++i) {
-        Platform3DObject color = context->createTexture();
+    GCGLint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);
+    for (GCGLint i = 0; i < maxAllowedBuffers; ++i) {
+        PlatformGLObject color = context->createTexture();
         colors.append(color);
-        context->bindTexture(GraphicsContext3D::TEXTURE_2D, color);
-        context->texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1, 0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, buffer);
-        context->framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0 + i, GraphicsContext3D::TEXTURE_2D, color, 0);
-        if (context->checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
+        context->bindTexture(GraphicsContextGL::TEXTURE_2D, color);
+        context->texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1, 0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, buffer);
+        context->framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0 + i, GraphicsContextGL::TEXTURE_2D, color, 0);
+        if (context->checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
             ok = false;
             break;
         }
         if (supportsDepth) {
-            context->framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depth, 0);
-            if (context->checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
+            context->framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depth, 0);
+            if (context->checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
                 ok = false;
                 break;
             }
-            context->framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);
+            context->framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);
         }
         if (supportsDepthStencil) {
-            context->framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);
-            context->framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);
-            if (context->checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
+            context->framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);
+            context->framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);
+            if (context->checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
                 ok = false;
                 break;
             }
-            context->framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);
-            context->framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);
+            context->framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);
+            context->framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);
         }
     }
 
     webglContext.restoreCurrentFramebuffer();
     context->deleteFramebuffer(fbo);

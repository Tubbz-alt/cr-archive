diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SlotVisitor.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SlotVisitor.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SlotVisitor.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SlotVisitor.cpp
@@ -31,10 +31,11 @@
 #include "ConservativeRoots.h"
 #include "GCSegmentedArrayInlines.h"
 #include "HeapAnalyzer.h"
 #include "HeapCellInlines.h"
 #include "HeapProfiler.h"
+#include "IntegrityInlines.h"
 #include "JSArray.h"
 #include "JSDestructibleObject.h"
 #include "JSObject.h"
 #include "JSString.h"
 #include "JSCInlines.h"
@@ -86,11 +87,11 @@
     , m_visitCount(0)
     , m_isInParallelMode(false)
     , m_markingVersion(MarkedSpace::initialVersion)
     , m_heap(heap)
     , m_codeName(codeName)
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     , m_isCheckingForDefaultMarkViolation(false)
     , m_isDraining(false)
 #endif
 {
 }
@@ -206,11 +207,11 @@
 #endif
     };
 
     // In debug mode, we validate before marking since this makes it clearer what the problem
     // was. It's also slower, so we don't do it normally.
-    if (!ASSERT_DISABLED && isJSCellKind(heapCell->cellKind()))
+    if (ASSERT_ENABLED && isJSCellKind(heapCell->cellKind()))
         validateCell(static_cast<JSCell*>(heapCell));
 
     if (Heap::testAndSetMarked(m_markingVersion, heapCell))
         return;
 
@@ -219,10 +220,11 @@
     case HeapCell::JSCellWithInteriorPointers: {
         // We have ample budget to perform validation here.
 
         JSCell* jsCell = static_cast<JSCell*>(heapCell);
         validateCell(jsCell);
+        Integrity::auditCell(vm(), jsCell);
 
         jsCell->setCellState(CellState::PossiblyGrey);
 
         appendToMarkStack(jsCell);
         return;
@@ -253,12 +255,12 @@
 
 #if ENABLE(GC_VALIDATION)
     validate(cell);
 #endif
 
-    if (cell->isLargeAllocation())
-        setMarkedAndAppendToMarkStack(cell->largeAllocation(), cell, dependency);
+    if (cell->isPreciseAllocation())
+        setMarkedAndAppendToMarkStack(cell->preciseAllocation(), cell, dependency);
     else
         setMarkedAndAppendToMarkStack(cell->markedBlock(), cell, dependency);
 }
 
 template<typename ContainerType>
@@ -277,22 +279,22 @@
     appendToMarkStack(container, cell);
 }
 
 void SlotVisitor::appendToMarkStack(JSCell* cell)
 {
-    if (cell->isLargeAllocation())
-        appendToMarkStack(cell->largeAllocation(), cell);
+    if (cell->isPreciseAllocation())
+        appendToMarkStack(cell->preciseAllocation(), cell);
     else
         appendToMarkStack(cell->markedBlock(), cell);
 }
 
 template<typename ContainerType>
 ALWAYS_INLINE void SlotVisitor::appendToMarkStack(ContainerType& container, JSCell* cell)
 {
     ASSERT(m_heap.isMarked(cell));
 #if CPU(X86_64)
-    if (Options::dumpZappedCellCrashData()) {
+    if (UNLIKELY(Options::dumpZappedCellCrashData())) {
         if (UNLIKELY(cell->isZapped()))
             reportZappedCellAndCrash(cell);
     }
 #endif
     ASSERT(!cell->isZapped());
@@ -393,11 +395,11 @@
 
     default:
         // FIXME: This could be so much better.
         // https://bugs.webkit.org/show_bug.cgi?id=162462
 #if CPU(X86_64)
-        if (Options::dumpZappedCellCrashData()) {
+        if (UNLIKELY(Options::dumpZappedCellCrashData())) {
             Structure* structure = cell->structure(vm());
             if (LIKELY(structure)) {
                 const MethodTable* methodTable = &structure->classInfo()->methodTable;
                 methodTable->visitChildren(const_cast<JSCell*>(cell), *this);
                 break;
@@ -791,12 +793,11 @@
     drain(timeout);
 }
 
 void SlotVisitor::didRace(const VisitRaceKey& race)
 {
-    if (Options::verboseVisitRace())
-        dataLog(toCString("GC visit race: ", race, "\n"));
+    dataLogLnIf(Options::verboseVisitRace(), toCString("GC visit race: ", race));
 
     auto locker = holdLock(heap()->m_raceMarkStackLock);
     JSCell* cell = race.cell();
     cell->setCellState(CellState::PossiblyGrey);
     heap()->m_raceMarkStack->append(cell);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArgList.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractModuleRecord.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArgList.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
116         removeLast();
117         return result;
118     }
119 
120     static void markLists(SlotVisitor&amp;, ListSet&amp;);
121 
122     void ensureCapacity(size_t requestedCapacity)
123     {
124         if (requestedCapacity &gt; static_cast&lt;size_t&gt;(m_capacity))
125             slowEnsureCapacity(requestedCapacity);
126     }
127 
128     bool hasOverflowed()
129     {
130         clearNeedsOverflowCheck();
131         return Base::hasOverflowed();
132     }
133 
134     void overflowCheckNotNeeded() { clearNeedsOverflowCheck(); }
135 











136 private:
137     void expandCapacity();
138     void expandCapacity(int newCapacity);
139     void slowEnsureCapacity(size_t requestedCapacity);
140 
141     void addMarkSet(JSValue);
142 
143     JS_EXPORT_PRIVATE void slowAppend(JSValue);
144 
145     EncodedJSValue&amp; slotFor(int item) const
146     {
147         return m_buffer[item];
148     }
149 
150     EncodedJSValue* mallocBase()
151     {
152         if (m_buffer == m_inlineBuffer)
153             return 0;
154         return &amp;slotFor(0);
155     }
156 
<span class="line-modified">157 #if ASSERT_DISABLED</span>
<span class="line-removed">158     void setNeedsOverflowCheck() { }</span>
<span class="line-removed">159     void clearNeedsOverflowCheck() { }</span>
<span class="line-removed">160 #else</span>
161     void setNeedsOverflowCheck() { m_needsOverflowCheck = true; }
162     void clearNeedsOverflowCheck() { m_needsOverflowCheck = false; }
163 
164     bool m_needsOverflowCheck { false };
<span class="line-modified">165 #endif</span>



166     int m_size;
167     int m_capacity;
168     EncodedJSValue m_inlineBuffer[inlineCapacity];
169     EncodedJSValue* m_buffer;
170     ListSet* m_markSet;
171 };
172 
173 class ArgList {
174     WTF_MAKE_FAST_ALLOCATED;
175     friend class Interpreter;
176     friend class JIT;
177 public:
178     ArgList()
179         : m_args(0)
180         , m_argCount(0)
181     {
182     }
183 
<span class="line-modified">184     ArgList(ExecState* exec)</span>
<span class="line-modified">185         : m_args(reinterpret_cast&lt;JSValue*&gt;(&amp;exec[CallFrame::argumentOffset(0)]))</span>
<span class="line-modified">186         , m_argCount(exec-&gt;argumentCount())</span>
187     {
188     }
189 
190     ArgList(const MarkedArgumentBuffer&amp; args)
191         : m_args(reinterpret_cast&lt;JSValue*&gt;(args.m_buffer))
192         , m_argCount(args.size())
193     {
194     }
195 
196     JSValue at(int i) const
197     {
198         if (i &gt;= m_argCount)
199             return jsUndefined();
200         return m_args[i];
201     }
202 
203     bool isEmpty() const { return !m_argCount; }
204     size_t size() const { return m_argCount; }
205 
206     JS_EXPORT_PRIVATE void getSlice(int startIndex, ArgList&amp; result) const;
</pre>
</td>
<td>
<hr />
<pre>
116         removeLast();
117         return result;
118     }
119 
120     static void markLists(SlotVisitor&amp;, ListSet&amp;);
121 
122     void ensureCapacity(size_t requestedCapacity)
123     {
124         if (requestedCapacity &gt; static_cast&lt;size_t&gt;(m_capacity))
125             slowEnsureCapacity(requestedCapacity);
126     }
127 
128     bool hasOverflowed()
129     {
130         clearNeedsOverflowCheck();
131         return Base::hasOverflowed();
132     }
133 
134     void overflowCheckNotNeeded() { clearNeedsOverflowCheck(); }
135 
<span class="line-added">136     template&lt;typename Functor&gt;</span>
<span class="line-added">137     void fill(size_t count, const Functor&amp; func)</span>
<span class="line-added">138     {</span>
<span class="line-added">139         ASSERT(!m_size);</span>
<span class="line-added">140         ensureCapacity(count);</span>
<span class="line-added">141         if (Base::hasOverflowed())</span>
<span class="line-added">142             return;</span>
<span class="line-added">143         m_size = count;</span>
<span class="line-added">144         func(reinterpret_cast&lt;JSValue*&gt;(&amp;slotFor(0)));</span>
<span class="line-added">145     }</span>
<span class="line-added">146 </span>
147 private:
148     void expandCapacity();
149     void expandCapacity(int newCapacity);
150     void slowEnsureCapacity(size_t requestedCapacity);
151 
152     void addMarkSet(JSValue);
153 
154     JS_EXPORT_PRIVATE void slowAppend(JSValue);
155 
156     EncodedJSValue&amp; slotFor(int item) const
157     {
158         return m_buffer[item];
159     }
160 
161     EncodedJSValue* mallocBase()
162     {
163         if (m_buffer == m_inlineBuffer)
164             return 0;
165         return &amp;slotFor(0);
166     }
167 
<span class="line-modified">168 #if ASSERT_ENABLED</span>



169     void setNeedsOverflowCheck() { m_needsOverflowCheck = true; }
170     void clearNeedsOverflowCheck() { m_needsOverflowCheck = false; }
171 
172     bool m_needsOverflowCheck { false };
<span class="line-modified">173 #else</span>
<span class="line-added">174     void setNeedsOverflowCheck() { }</span>
<span class="line-added">175     void clearNeedsOverflowCheck() { }</span>
<span class="line-added">176 #endif // ASSERT_ENABLED</span>
177     int m_size;
178     int m_capacity;
179     EncodedJSValue m_inlineBuffer[inlineCapacity];
180     EncodedJSValue* m_buffer;
181     ListSet* m_markSet;
182 };
183 
184 class ArgList {
185     WTF_MAKE_FAST_ALLOCATED;
186     friend class Interpreter;
187     friend class JIT;
188 public:
189     ArgList()
190         : m_args(0)
191         , m_argCount(0)
192     {
193     }
194 
<span class="line-modified">195     ArgList(CallFrame* callFrame)</span>
<span class="line-modified">196         : m_args(reinterpret_cast&lt;JSValue*&gt;(&amp;callFrame[CallFrame::argumentOffset(0)]))</span>
<span class="line-modified">197         , m_argCount(callFrame-&gt;argumentCount())</span>
198     {
199     }
200 
201     ArgList(const MarkedArgumentBuffer&amp; args)
202         : m_args(reinterpret_cast&lt;JSValue*&gt;(args.m_buffer))
203         , m_argCount(args.size())
204     {
205     }
206 
207     JSValue at(int i) const
208     {
209         if (i &gt;= m_argCount)
210             return jsUndefined();
211         return m_args[i];
212     }
213 
214     bool isEmpty() const { return !m_argCount; }
215     size_t size() const { return m_argCount; }
216 
217     JS_EXPORT_PRIVATE void getSlice(int startIndex, ArgList&amp; result) const;
</pre>
</td>
</tr>
</table>
<center><a href="AbstractModuleRecord.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
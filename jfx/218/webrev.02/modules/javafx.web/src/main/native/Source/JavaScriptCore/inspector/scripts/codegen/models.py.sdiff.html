<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="generator.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="objc_generator_templates.py.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 import logging
 28 import collections
 29 
 30 log = logging.getLogger(&#39;global&#39;)
 31 
 32 
 33 def ucfirst(str):
 34     return str[:1].upper() + str[1:]
 35 
 36 
 37 def find_duplicates(l):
 38     return [key for key, count in list(collections.Counter(l).items()) if count &gt; 1]
 39 
 40 


















 41 _FRAMEWORK_CONFIG_MAP = {
 42     &quot;Global&quot;: {
 43     },
 44     &quot;JavaScriptCore&quot;: {
 45         &quot;cpp_protocol_group&quot;: &quot;Inspector&quot;,
 46         &quot;export_macro&quot;: &quot;JS_EXPORT_PRIVATE&quot;,
 47         &quot;alternate_dispatchers&quot;: True,
 48     },
 49     &quot;WebKit&quot;: {
 50         &quot;cpp_protocol_group&quot;: &quot;Automation&quot;,
 51         &quot;objc_protocol_group&quot;: &quot;WD&quot;,
 52         &quot;objc_prefix&quot;: &quot;WD&quot;,
 53     },
 54     &quot;WebInspector&quot;: {
 55         &quot;objc_protocol_group&quot;: &quot;RWI&quot;,
 56         &quot;objc_prefix&quot;: &quot;RWI&quot;,
 57     },
 58     &quot;WebInspectorUI&quot;: {
 59     },
 60     # Used for code generator tests.
 61     &quot;Test&quot;: {
 62         &quot;alternate_dispatchers&quot;: True,
 63         &quot;cpp_protocol_group&quot;: &quot;Test&quot;,
 64         &quot;objc_protocol_group&quot;: &quot;Test&quot;,
 65         &quot;objc_prefix&quot;: &quot;Test&quot;,
 66     }
 67 }
 68 



 69 
 70 class ParseException(Exception):
 71     pass
 72 
 73 
 74 class TypecheckException(Exception):
 75     pass
 76 
 77 
 78 class Framework:
 79     def __init__(self, name):
 80         self._settings = _FRAMEWORK_CONFIG_MAP[name]
 81         self.name = name
 82 
 83     def setting(self, key, default=&#39;&#39;):
 84         return self._settings.get(key, default)
 85 
 86     @staticmethod
 87     def fromString(frameworkString):
 88         if frameworkString == &quot;Global&quot;:
</pre>
<hr />
<pre>
351     def __init__(self, framework_name):
352         self.domains = []
353         self.types_by_name = {}
354         self.framework = Framework.fromString(framework_name)
355 
356     def parse_specification(self, json, isSupplemental):
357         log.debug(&quot;parse toplevel&quot;)
358 
359         if isinstance(json, dict) and &#39;domains&#39; in json:
360             json = json[&#39;domains&#39;]
361         if not isinstance(json, list):
362             json = [json]
363 
364         for domain in json:
365             self.parse_domain(domain, isSupplemental)
366 
367     def parse_domain(self, json, isSupplemental):
368         check_for_required_properties([&#39;domain&#39;], json, &quot;domain&quot;)
369         log.debug(&quot;parse domain &quot; + json[&#39;domain&#39;])
370 


371         version = None
372         types = []
373         commands = []
374         events = []
375 























376         if &#39;version&#39; in json:
377             if not isinstance(json[&#39;version&#39;], int):
378                 raise ParseException(&quot;Malformed domain specification: version is not a number or string&quot;)
379             version = json[&#39;version&#39;]
380 
381         if &#39;types&#39; in json:
382             if not isinstance(json[&#39;types&#39;], list):
383                 raise ParseException(&quot;Malformed domain specification: types is not an array&quot;)
384             types.extend([self.parse_type_declaration(declaration) for declaration in json[&#39;types&#39;]])
385 
386         if &#39;commands&#39; in json:
387             if not isinstance(json[&#39;commands&#39;], list):
388                 raise ParseException(&quot;Malformed domain specification: commands is not an array&quot;)
<span class="line-modified">389             commands.extend([self.parse_command(command) for command in json[&#39;commands&#39;]])</span>
390 
391         if &#39;events&#39; in json:
392             if not isinstance(json[&#39;events&#39;], list):
393                 raise ParseException(&quot;Malformed domain specification: events is not an array&quot;)
<span class="line-modified">394             events.extend([self.parse_event(event) for event in json[&#39;events&#39;]])</span>
395 
<span class="line-modified">396         if &#39;availability&#39; in json:</span>
<span class="line-removed">397             if not isinstance(json[&#39;availability&#39;], list):</span>
<span class="line-removed">398                 raise ParseException(&quot;Malformed domain specification: availability is not an array&quot;)</span>
<span class="line-removed">399             allowed_activation_strings = set([&#39;javascript&#39;, &#39;web&#39;, &#39;worker&#39;, &#39;service-worker&#39;])</span>
<span class="line-removed">400             for availability_type in json[&#39;availability&#39;]:</span>
<span class="line-removed">401                 if availability_type not in allowed_activation_strings:</span>
<span class="line-removed">402                     raise ParseException(&#39;Malformed domain specification: availability is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;availability&#39;], &#39;, &#39;.join(allowed_activation_strings)))</span>
<span class="line-removed">403 </span>
<span class="line-removed">404         self.domains.append(Domain(json[&#39;domain&#39;], json.get(&#39;description&#39;, &#39;&#39;), json.get(&#39;featureGuard&#39;), json.get(&#39;availability&#39;), isSupplemental, version, types, commands, events))</span>
405 
406     def parse_type_declaration(self, json):
407         check_for_required_properties([&#39;id&#39;, &#39;type&#39;], json, &quot;type&quot;)
408         log.debug(&quot;parse type %s&quot; % json[&#39;id&#39;])
409 
410         type_members = []
411 
412         if &#39;properties&#39; in json:
413             if not isinstance(json[&#39;properties&#39;], list):
414                 raise ParseException(&quot;Malformed type specification: properties is not an array&quot;)
415             type_members.extend([self.parse_type_member(member) for member in json[&#39;properties&#39;]])
416 
417         duplicate_names = find_duplicates([member.member_name for member in type_members])
418         if len(duplicate_names) &gt; 0:
419             raise ParseException(&quot;Malformed domain specification: type declaration for %s has duplicate member names&quot; % json[&#39;id&#39;])
420 
421         type_ref = TypeReference(json[&#39;type&#39;], json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
422         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
423         return TypeDeclaration(json[&#39;id&#39;], type_ref, json.get(&quot;description&quot;, &quot;&quot;), platform, type_members)
424 
425     def parse_type_member(self, json):
426         check_for_required_properties([&#39;name&#39;], json, &quot;type member&quot;)
427         log.debug(&quot;parse type member %s&quot; % json[&#39;name&#39;])
428 
429         type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
430         return TypeMember(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
431 
<span class="line-modified">432     def parse_command(self, json):</span>
433         check_for_required_properties([&#39;name&#39;], json, &quot;command&quot;)
434         log.debug(&quot;parse command %s&quot; % json[&#39;name&#39;])
435 

436         call_parameters = []
437         return_parameters = []
438 
















439         if &#39;parameters&#39; in json:
440             if not isinstance(json[&#39;parameters&#39;], list):
441                 raise ParseException(&quot;Malformed command specification: parameters is not an array&quot;)
442             call_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
443 
444             duplicate_names = find_duplicates([param.parameter_name for param in call_parameters])
445             if len(duplicate_names) &gt; 0:
446                 raise ParseException(&quot;Malformed domain specification: call parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
447 
448         if &#39;returns&#39; in json:
449             if not isinstance(json[&#39;returns&#39;], list):
450                 raise ParseException(&quot;Malformed command specification: returns is not an array&quot;)
451             return_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;returns&#39;]])
452 
453             duplicate_names = find_duplicates([param.parameter_name for param in return_parameters])
454             if len(duplicate_names) &gt; 0:
455                 raise ParseException(&quot;Malformed domain specification: return parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
456 
457         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">458         return Command(json[&#39;name&#39;], call_parameters, return_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform, json.get(&#39;async&#39;, False))</span>
459 
<span class="line-modified">460     def parse_event(self, json):</span>
461         check_for_required_properties([&#39;name&#39;], json, &quot;event&quot;)
462         log.debug(&quot;parse event %s&quot; % json[&#39;name&#39;])
463 

464         event_parameters = []
465 
















466         if &#39;parameters&#39; in json:
467             if not isinstance(json[&#39;parameters&#39;], list):
468                 raise ParseException(&quot;Malformed event specification: parameters is not an array&quot;)
469             event_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
470 
471             duplicate_names = find_duplicates([param.parameter_name for param in event_parameters])
472             if len(duplicate_names) &gt; 0:
473                 raise ParseException(&quot;Malformed domain specification: parameter list for event %s has duplicate parameter names&quot; % json[&#39;name&#39;])
474 
475         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">476         return Event(json[&#39;name&#39;], event_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform)</span>
477 
478     def parse_call_or_return_parameter(self, json):
479         check_for_required_properties([&#39;name&#39;], json, &quot;parameter&quot;)
480         log.debug(&quot;parse parameter %s&quot; % json[&#39;name&#39;])
481 
482         type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
483         return Parameter(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
484 
485     def resolve_types(self):
486         qualified_declared_type_names = set([&#39;boolean&#39;, &#39;string&#39;, &#39;integer&#39;, &#39;number&#39;, &#39;enum&#39;, &#39;array&#39;, &#39;object&#39;, &#39;any&#39;])
487 
488         self.types_by_name[&#39;string&#39;] = PrimitiveType(&#39;string&#39;)
489         for _primitive_type in [&#39;boolean&#39;, &#39;integer&#39;, &#39;number&#39;]:
490             self.types_by_name[_primitive_type] = PrimitiveType(_primitive_type)
491         for _object_type in [&#39;any&#39;, &#39;object&#39;]:
492             self.types_by_name[_object_type] = PrimitiveType(_object_type)
493 
494         # Gather qualified type names from type declarations in each domain.
495         for domain in self.domains:
496             for declaration in domain.all_type_declarations():
</pre>
<hr />
<pre>
554 
555         # This will match when referencing a type defined in the same domain, where prefixes aren&#39;t required.
556         qualified_name = &quot;.&quot;.join([domain.domain_name, type_ref.referenced_name()])
557         if qualified_name in self.types_by_name:
558             found_type = self.types_by_name[qualified_name]
559             found_type.resolve_type_references(self)
560             log.debug(&quot;&lt; Lookup succeeded for unqualified type: %s&quot; % found_type.qualified_name())
561             return found_type
562 
563         # This will match primitive types and fully-qualified types from a different domain.
564         if type_ref.referenced_name() in self.types_by_name:
565             found_type = self.types_by_name[type_ref.referenced_name()]
566             found_type.resolve_type_references(self)
567             log.debug(&quot;&lt; Lookup succeeded for primitive or qualified type: %s&quot; % found_type.qualified_name())
568             return found_type
569 
570         raise TypecheckException(&quot;Lookup failed for type reference: %s (referenced from domain: %s)&quot; % (type_ref.referenced_name(), domain.domain_name))
571 
572 
573 class Domain:
<span class="line-modified">574     def __init__(self, domain_name, description, feature_guard, availability, isSupplemental, version, type_declarations, commands, events):</span>
575         self.domain_name = domain_name
576         self.description = description
577         self.feature_guard = feature_guard
<span class="line-modified">578         self.availability = availability</span>

579         self.is_supplemental = isSupplemental
580         self._version = version
581         self._type_declarations = type_declarations
582         self._commands = commands
583         self._events = events
584 
585     def version(self):
586         return self._version
587 
588     def all_type_declarations(self):
589         return self._type_declarations
590 
591     def all_commands(self):
592         return self._commands
593 
594     def all_events(self):
595         return self._events
596 
597     def resolve_type_references(self, protocol):
598         log.debug(&quot;&gt; Resolving type declarations for domain: %s&quot; % self.domain_name)
599         for declaration in self._type_declarations:
600             declaration.resolve_type_references(protocol, self)
601 
602         log.debug(&quot;&gt; Resolving types in commands for domain: %s&quot; % self.domain_name)
603         for command in self._commands:
604             command.resolve_type_references(protocol, self)
605 
606         log.debug(&quot;&gt; Resolving types in events for domain: %s&quot; % self.domain_name)
607         for event in self._events:
608             event.resolve_type_references(protocol, self)
609 
610 
611 class Domains:
<span class="line-modified">612     GLOBAL = Domain(&quot;&quot;, &quot;The global domain, in which primitive types are implicitly declared.&quot;, None, None, False, None, [], [], [])</span>
613 
614 
615 class TypeDeclaration:
616     def __init__(self, type_name, type_ref, description, platform, type_members):
617         self.type_name = type_name
618         self.type_ref = type_ref
619         self.description = description
620         self.platform = platform
621         self.type_members = type_members
622 
623         if self.type_name != ucfirst(self.type_name):
624             raise ParseException(&quot;Types must begin with an uppercase character.&quot;)
625 
626     def resolve_type_references(self, protocol, domain):
627         log.debug(&quot;&gt;&gt; Resolving type references for type declaration: %s&quot; % self.type_name)
628         self.type = protocol.lookup_type_for_declaration(self, domain)
629         for member in self.type_members:
630             member.resolve_type_references(protocol, domain)
631 
632 
</pre>
<hr />
<pre>
644         log.debug(&quot;&gt;&gt;&gt; Resolving type references for type member: %s&quot; % self.member_name)
645         self.type = protocol.lookup_type_reference(self.type_ref, domain)
646 
647 
648 class Parameter:
649     def __init__(self, parameter_name, type_ref, is_optional, description):
650         self.parameter_name = parameter_name
651         self.type_ref = type_ref
652         self.is_optional = is_optional
653         self.description = description
654 
655         if not isinstance(self.is_optional, bool):
656             raise ParseException(&quot;The &#39;optional&#39; flag for a parameter must be a boolean literal.&quot;)
657 
658     def resolve_type_references(self, protocol, domain):
659         log.debug(&quot;&gt;&gt;&gt; Resolving type references for parameter: %s&quot; % self.parameter_name)
660         self.type = protocol.lookup_type_reference(self.type_ref, domain)
661 
662 
663 class Command:
<span class="line-modified">664     def __init__(self, command_name, call_parameters, return_parameters, description, platform, is_async):</span>
665         self.command_name = command_name

666         self.call_parameters = call_parameters
667         self.return_parameters = return_parameters
668         self.description = description
669         self.platform = platform
670         self.is_async = is_async
671 
672     def resolve_type_references(self, protocol, domain):
673         log.debug(&quot;&gt;&gt; Resolving type references for call parameters in command: %s&quot; % self.command_name)
674         for parameter in self.call_parameters:
675             parameter.resolve_type_references(protocol, domain)
676 
677         log.debug(&quot;&gt;&gt; Resolving type references for return parameters in command: %s&quot; % self.command_name)
678         for parameter in self.return_parameters:
679             parameter.resolve_type_references(protocol, domain)
680 
681 
682 class Event:
<span class="line-modified">683     def __init__(self, event_name, event_parameters, description, platform):</span>
684         self.event_name = event_name

685         self.event_parameters = event_parameters
686         self.description = description
687         self.platform = platform
688 
689     def resolve_type_references(self, protocol, domain):
690         log.debug(&quot;&gt;&gt; Resolving type references for parameters in event: %s&quot; % self.event_name)
691         for parameter in self.event_parameters:
692             parameter.resolve_type_references(protocol, domain)
</pre>
</td>
<td>
<hr />
<pre>
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 import logging
 28 import collections
 29 
 30 log = logging.getLogger(&#39;global&#39;)
 31 
 32 
 33 def ucfirst(str):
 34     return str[:1].upper() + str[1:]
 35 
 36 
 37 def find_duplicates(l):
 38     return [key for key, count in list(collections.Counter(l).items()) if count &gt; 1]
 39 
 40 
<span class="line-added"> 41 def validate_target_types(debuggable_types, target_types):</span>
<span class="line-added"> 42     for target_type in target_types:</span>
<span class="line-added"> 43         required_debuggable_types = set()</span>
<span class="line-added"> 44         if target_type == &#39;javascript&#39;:</span>
<span class="line-added"> 45             if not &#39;javascript&#39; in debuggable_types:</span>
<span class="line-added"> 46                 return False</span>
<span class="line-added"> 47         elif target_type == &#39;page&#39; or target_type == &#39;worker&#39;:</span>
<span class="line-added"> 48             if not &#39;page&#39; in debuggable_types:</span>
<span class="line-added"> 49                 return False</span>
<span class="line-added"> 50         elif target_type == &#39;service-worker&#39;:</span>
<span class="line-added"> 51             if not &#39;service-worker&#39; in debuggable_types:</span>
<span class="line-added"> 52                 return False</span>
<span class="line-added"> 53         elif target_type == &#39;web-page&#39;:</span>
<span class="line-added"> 54             if not &#39;web-page&#39; in debuggable_types:</span>
<span class="line-added"> 55                 return False</span>
<span class="line-added"> 56     return True</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 </span>
 59 _FRAMEWORK_CONFIG_MAP = {
 60     &quot;Global&quot;: {
 61     },
 62     &quot;JavaScriptCore&quot;: {
 63         &quot;cpp_protocol_group&quot;: &quot;Inspector&quot;,
 64         &quot;export_macro&quot;: &quot;JS_EXPORT_PRIVATE&quot;,
 65         &quot;alternate_dispatchers&quot;: True,
 66     },
 67     &quot;WebKit&quot;: {
 68         &quot;cpp_protocol_group&quot;: &quot;Automation&quot;,
 69         &quot;objc_protocol_group&quot;: &quot;WD&quot;,
 70         &quot;objc_prefix&quot;: &quot;WD&quot;,
 71     },
 72     &quot;WebInspector&quot;: {
 73         &quot;objc_protocol_group&quot;: &quot;RWI&quot;,
 74         &quot;objc_prefix&quot;: &quot;RWI&quot;,
 75     },
 76     &quot;WebInspectorUI&quot;: {
 77     },
 78     # Used for code generator tests.
 79     &quot;Test&quot;: {
 80         &quot;alternate_dispatchers&quot;: True,
 81         &quot;cpp_protocol_group&quot;: &quot;Test&quot;,
 82         &quot;objc_protocol_group&quot;: &quot;Test&quot;,
 83         &quot;objc_prefix&quot;: &quot;Test&quot;,
 84     }
 85 }
 86 
<span class="line-added"> 87 _ALLOWED_DEBUGGABLE_TYPE_STRINGS = frozenset([&#39;javascript&#39;, &#39;page&#39;, &#39;service-worker&#39;, &#39;web-page&#39;])</span>
<span class="line-added"> 88 _ALLOWED_TARGET_TYPE_STRINGS = frozenset([&#39;javascript&#39;, &#39;page&#39;, &#39;service-worker&#39;, &#39;web-page&#39;, &#39;worker&#39;])</span>
<span class="line-added"> 89 </span>
 90 
 91 class ParseException(Exception):
 92     pass
 93 
 94 
 95 class TypecheckException(Exception):
 96     pass
 97 
 98 
 99 class Framework:
100     def __init__(self, name):
101         self._settings = _FRAMEWORK_CONFIG_MAP[name]
102         self.name = name
103 
104     def setting(self, key, default=&#39;&#39;):
105         return self._settings.get(key, default)
106 
107     @staticmethod
108     def fromString(frameworkString):
109         if frameworkString == &quot;Global&quot;:
</pre>
<hr />
<pre>
372     def __init__(self, framework_name):
373         self.domains = []
374         self.types_by_name = {}
375         self.framework = Framework.fromString(framework_name)
376 
377     def parse_specification(self, json, isSupplemental):
378         log.debug(&quot;parse toplevel&quot;)
379 
380         if isinstance(json, dict) and &#39;domains&#39; in json:
381             json = json[&#39;domains&#39;]
382         if not isinstance(json, list):
383             json = [json]
384 
385         for domain in json:
386             self.parse_domain(domain, isSupplemental)
387 
388     def parse_domain(self, json, isSupplemental):
389         check_for_required_properties([&#39;domain&#39;], json, &quot;domain&quot;)
390         log.debug(&quot;parse domain &quot; + json[&#39;domain&#39;])
391 
<span class="line-added">392         debuggable_types = None</span>
<span class="line-added">393         target_types = None</span>
394         version = None
395         types = []
396         commands = []
397         events = []
398 
<span class="line-added">399         if &#39;debuggableTypes&#39; in json:</span>
<span class="line-added">400             if not isinstance(json[&#39;debuggableTypes&#39;], list):</span>
<span class="line-added">401                 raise ParseException(&quot;Malformed domain specification: debuggableTypes for domain %s is not an array&quot; % json[&#39;domain&#39;])</span>
<span class="line-added">402 </span>
<span class="line-added">403             for debuggable_types in json[&#39;debuggableTypes&#39;]:</span>
<span class="line-added">404                 if debuggable_types not in _ALLOWED_DEBUGGABLE_TYPE_STRINGS:</span>
<span class="line-added">405                     raise ParseException(&#39;Malformed domain specification: debuggableTypes for domain %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;domain&#39;], json[&#39;debuggableTypes&#39;], &#39;, &#39;.join(_ALLOWED_DEBUGGABLE_TYPE_STRINGS)))</span>
<span class="line-added">406 </span>
<span class="line-added">407             debuggable_types = json.get(&#39;debuggableTypes&#39;)</span>
<span class="line-added">408 </span>
<span class="line-added">409         if &#39;targetTypes&#39; in json:</span>
<span class="line-added">410             if not isinstance(json[&#39;targetTypes&#39;], list):</span>
<span class="line-added">411                 raise ParseException(&quot;Malformed domain specification: targetTypes for domain %s is not an array&quot; % json[&#39;domain&#39;])</span>
<span class="line-added">412 </span>
<span class="line-added">413             for target_types in json[&#39;targetTypes&#39;]:</span>
<span class="line-added">414                 if target_types not in _ALLOWED_TARGET_TYPE_STRINGS:</span>
<span class="line-added">415                     raise ParseException(&#39;Malformed domain specification: targetTypes for domain %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;domain&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))</span>
<span class="line-added">416 </span>
<span class="line-added">417             target_types = json.get(&#39;targetTypes&#39;)</span>
<span class="line-added">418 </span>
<span class="line-added">419             if debuggable_types and not validate_target_types(debuggable_types, target_types):</span>
<span class="line-added">420                 raise ParseException(&#39;Malformed domain specification: domain %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;domain&#39;], target_types, debuggable_types))</span>
<span class="line-added">421 </span>
422         if &#39;version&#39; in json:
423             if not isinstance(json[&#39;version&#39;], int):
424                 raise ParseException(&quot;Malformed domain specification: version is not a number or string&quot;)
425             version = json[&#39;version&#39;]
426 
427         if &#39;types&#39; in json:
428             if not isinstance(json[&#39;types&#39;], list):
429                 raise ParseException(&quot;Malformed domain specification: types is not an array&quot;)
430             types.extend([self.parse_type_declaration(declaration) for declaration in json[&#39;types&#39;]])
431 
432         if &#39;commands&#39; in json:
433             if not isinstance(json[&#39;commands&#39;], list):
434                 raise ParseException(&quot;Malformed domain specification: commands is not an array&quot;)
<span class="line-modified">435             commands.extend([self.parse_command(command, debuggable_types) for command in json[&#39;commands&#39;]])</span>
436 
437         if &#39;events&#39; in json:
438             if not isinstance(json[&#39;events&#39;], list):
439                 raise ParseException(&quot;Malformed domain specification: events is not an array&quot;)
<span class="line-modified">440             events.extend([self.parse_event(event, debuggable_types) for event in json[&#39;events&#39;]])</span>
441 
<span class="line-modified">442         self.domains.append(Domain(json[&#39;domain&#39;], json.get(&#39;description&#39;, &#39;&#39;), json.get(&#39;featureGuard&#39;), debuggable_types, target_types, isSupplemental, version, types, commands, events))</span>








443 
444     def parse_type_declaration(self, json):
445         check_for_required_properties([&#39;id&#39;, &#39;type&#39;], json, &quot;type&quot;)
446         log.debug(&quot;parse type %s&quot; % json[&#39;id&#39;])
447 
448         type_members = []
449 
450         if &#39;properties&#39; in json:
451             if not isinstance(json[&#39;properties&#39;], list):
452                 raise ParseException(&quot;Malformed type specification: properties is not an array&quot;)
453             type_members.extend([self.parse_type_member(member) for member in json[&#39;properties&#39;]])
454 
455         duplicate_names = find_duplicates([member.member_name for member in type_members])
456         if len(duplicate_names) &gt; 0:
457             raise ParseException(&quot;Malformed domain specification: type declaration for %s has duplicate member names&quot; % json[&#39;id&#39;])
458 
459         type_ref = TypeReference(json[&#39;type&#39;], json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
460         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
461         return TypeDeclaration(json[&#39;id&#39;], type_ref, json.get(&quot;description&quot;, &quot;&quot;), platform, type_members)
462 
463     def parse_type_member(self, json):
464         check_for_required_properties([&#39;name&#39;], json, &quot;type member&quot;)
465         log.debug(&quot;parse type member %s&quot; % json[&#39;name&#39;])
466 
467         type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
468         return TypeMember(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
469 
<span class="line-modified">470     def parse_command(self, json, debuggable_types):</span>
471         check_for_required_properties([&#39;name&#39;], json, &quot;command&quot;)
472         log.debug(&quot;parse command %s&quot; % json[&#39;name&#39;])
473 
<span class="line-added">474         target_types = None</span>
475         call_parameters = []
476         return_parameters = []
477 
<span class="line-added">478         if &#39;targetTypes&#39; in json:</span>
<span class="line-added">479             if not isinstance(json[&#39;targetTypes&#39;], list):</span>
<span class="line-added">480                 raise ParseException(&quot;Malformed domain specification: targetTypes list for command %s is not an array&quot; % json[&#39;name&#39;])</span>
<span class="line-added">481             target_types = json[&#39;targetTypes&#39;]</span>
<span class="line-added">482 </span>
<span class="line-added">483             for target_type in target_types:</span>
<span class="line-added">484                 if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:</span>
<span class="line-added">485                     raise ParseException(&#39;Malformed domain specification: targetTypes list for command %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;name&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))</span>
<span class="line-added">486 </span>
<span class="line-added">487             duplicate_types = find_duplicates(target_types)</span>
<span class="line-added">488             if len(duplicate_types) &gt; 0:</span>
<span class="line-added">489                 raise ParseException(&quot;Malformed domain specification: targetTypes list for command %s has duplicate items&quot; % json[&#39;name&#39;])</span>
<span class="line-added">490 </span>
<span class="line-added">491             if debuggable_types and not validate_target_types(debuggable_types, target_types):</span>
<span class="line-added">492                 raise ParseException(&#39;Malformed domain specification: command %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;name&#39;], target_types, debuggable_types))</span>
<span class="line-added">493 </span>
494         if &#39;parameters&#39; in json:
495             if not isinstance(json[&#39;parameters&#39;], list):
496                 raise ParseException(&quot;Malformed command specification: parameters is not an array&quot;)
497             call_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
498 
499             duplicate_names = find_duplicates([param.parameter_name for param in call_parameters])
500             if len(duplicate_names) &gt; 0:
501                 raise ParseException(&quot;Malformed domain specification: call parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
502 
503         if &#39;returns&#39; in json:
504             if not isinstance(json[&#39;returns&#39;], list):
505                 raise ParseException(&quot;Malformed command specification: returns is not an array&quot;)
506             return_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;returns&#39;]])
507 
508             duplicate_names = find_duplicates([param.parameter_name for param in return_parameters])
509             if len(duplicate_names) &gt; 0:
510                 raise ParseException(&quot;Malformed domain specification: return parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
511 
512         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">513         return Command(json[&#39;name&#39;], target_types, call_parameters, return_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform, json.get(&#39;async&#39;, False))</span>
514 
<span class="line-modified">515     def parse_event(self, json, debuggable_types):</span>
516         check_for_required_properties([&#39;name&#39;], json, &quot;event&quot;)
517         log.debug(&quot;parse event %s&quot; % json[&#39;name&#39;])
518 
<span class="line-added">519         target_types = None</span>
520         event_parameters = []
521 
<span class="line-added">522         if &#39;targetTypes&#39; in json:</span>
<span class="line-added">523             if not isinstance(json[&#39;targetTypes&#39;], list):</span>
<span class="line-added">524                 raise ParseException(&quot;Malformed domain specification: targetTypes for event %s is not an array&quot; % json[&#39;name&#39;])</span>
<span class="line-added">525             target_types = json[&#39;targetTypes&#39;]</span>
<span class="line-added">526 </span>
<span class="line-added">527             for target_type in target_types:</span>
<span class="line-added">528                 if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:</span>
<span class="line-added">529                     raise ParseException(&#39;Malformed domain specification: targetTypes for event %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;name&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))</span>
<span class="line-added">530 </span>
<span class="line-added">531             duplicate_types = find_duplicates(target_types)</span>
<span class="line-added">532             if len(duplicate_types) &gt; 0:</span>
<span class="line-added">533                 raise ParseException(&quot;Malformed domain specification: targetTypes list for event %s has duplicate items&quot; % json[&#39;name&#39;])</span>
<span class="line-added">534 </span>
<span class="line-added">535             if debuggable_types and not validate_target_types(debuggable_types, target_types):</span>
<span class="line-added">536                 raise ParseException(&#39;Malformed domain specification: event %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;name&#39;], target_types, debuggable_types))</span>
<span class="line-added">537 </span>
538         if &#39;parameters&#39; in json:
539             if not isinstance(json[&#39;parameters&#39;], list):
540                 raise ParseException(&quot;Malformed event specification: parameters is not an array&quot;)
541             event_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
542 
543             duplicate_names = find_duplicates([param.parameter_name for param in event_parameters])
544             if len(duplicate_names) &gt; 0:
545                 raise ParseException(&quot;Malformed domain specification: parameter list for event %s has duplicate parameter names&quot; % json[&#39;name&#39;])
546 
547         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">548         return Event(json[&#39;name&#39;], target_types, event_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform)</span>
549 
550     def parse_call_or_return_parameter(self, json):
551         check_for_required_properties([&#39;name&#39;], json, &quot;parameter&quot;)
552         log.debug(&quot;parse parameter %s&quot; % json[&#39;name&#39;])
553 
554         type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
555         return Parameter(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
556 
557     def resolve_types(self):
558         qualified_declared_type_names = set([&#39;boolean&#39;, &#39;string&#39;, &#39;integer&#39;, &#39;number&#39;, &#39;enum&#39;, &#39;array&#39;, &#39;object&#39;, &#39;any&#39;])
559 
560         self.types_by_name[&#39;string&#39;] = PrimitiveType(&#39;string&#39;)
561         for _primitive_type in [&#39;boolean&#39;, &#39;integer&#39;, &#39;number&#39;]:
562             self.types_by_name[_primitive_type] = PrimitiveType(_primitive_type)
563         for _object_type in [&#39;any&#39;, &#39;object&#39;]:
564             self.types_by_name[_object_type] = PrimitiveType(_object_type)
565 
566         # Gather qualified type names from type declarations in each domain.
567         for domain in self.domains:
568             for declaration in domain.all_type_declarations():
</pre>
<hr />
<pre>
626 
627         # This will match when referencing a type defined in the same domain, where prefixes aren&#39;t required.
628         qualified_name = &quot;.&quot;.join([domain.domain_name, type_ref.referenced_name()])
629         if qualified_name in self.types_by_name:
630             found_type = self.types_by_name[qualified_name]
631             found_type.resolve_type_references(self)
632             log.debug(&quot;&lt; Lookup succeeded for unqualified type: %s&quot; % found_type.qualified_name())
633             return found_type
634 
635         # This will match primitive types and fully-qualified types from a different domain.
636         if type_ref.referenced_name() in self.types_by_name:
637             found_type = self.types_by_name[type_ref.referenced_name()]
638             found_type.resolve_type_references(self)
639             log.debug(&quot;&lt; Lookup succeeded for primitive or qualified type: %s&quot; % found_type.qualified_name())
640             return found_type
641 
642         raise TypecheckException(&quot;Lookup failed for type reference: %s (referenced from domain: %s)&quot; % (type_ref.referenced_name(), domain.domain_name))
643 
644 
645 class Domain:
<span class="line-modified">646     def __init__(self, domain_name, description, feature_guard, debuggable_types, target_types, isSupplemental, version, type_declarations, commands, events):</span>
647         self.domain_name = domain_name
648         self.description = description
649         self.feature_guard = feature_guard
<span class="line-modified">650         self.debuggable_types = debuggable_types</span>
<span class="line-added">651         self.target_types = target_types</span>
652         self.is_supplemental = isSupplemental
653         self._version = version
654         self._type_declarations = type_declarations
655         self._commands = commands
656         self._events = events
657 
658     def version(self):
659         return self._version
660 
661     def all_type_declarations(self):
662         return self._type_declarations
663 
664     def all_commands(self):
665         return self._commands
666 
667     def all_events(self):
668         return self._events
669 
670     def resolve_type_references(self, protocol):
671         log.debug(&quot;&gt; Resolving type declarations for domain: %s&quot; % self.domain_name)
672         for declaration in self._type_declarations:
673             declaration.resolve_type_references(protocol, self)
674 
675         log.debug(&quot;&gt; Resolving types in commands for domain: %s&quot; % self.domain_name)
676         for command in self._commands:
677             command.resolve_type_references(protocol, self)
678 
679         log.debug(&quot;&gt; Resolving types in events for domain: %s&quot; % self.domain_name)
680         for event in self._events:
681             event.resolve_type_references(protocol, self)
682 
683 
684 class Domains:
<span class="line-modified">685     GLOBAL = Domain(&quot;&quot;, &quot;The global domain, in which primitive types are implicitly declared.&quot;, None, None, None, False, None, [], [], [])</span>
686 
687 
688 class TypeDeclaration:
689     def __init__(self, type_name, type_ref, description, platform, type_members):
690         self.type_name = type_name
691         self.type_ref = type_ref
692         self.description = description
693         self.platform = platform
694         self.type_members = type_members
695 
696         if self.type_name != ucfirst(self.type_name):
697             raise ParseException(&quot;Types must begin with an uppercase character.&quot;)
698 
699     def resolve_type_references(self, protocol, domain):
700         log.debug(&quot;&gt;&gt; Resolving type references for type declaration: %s&quot; % self.type_name)
701         self.type = protocol.lookup_type_for_declaration(self, domain)
702         for member in self.type_members:
703             member.resolve_type_references(protocol, domain)
704 
705 
</pre>
<hr />
<pre>
717         log.debug(&quot;&gt;&gt;&gt; Resolving type references for type member: %s&quot; % self.member_name)
718         self.type = protocol.lookup_type_reference(self.type_ref, domain)
719 
720 
721 class Parameter:
722     def __init__(self, parameter_name, type_ref, is_optional, description):
723         self.parameter_name = parameter_name
724         self.type_ref = type_ref
725         self.is_optional = is_optional
726         self.description = description
727 
728         if not isinstance(self.is_optional, bool):
729             raise ParseException(&quot;The &#39;optional&#39; flag for a parameter must be a boolean literal.&quot;)
730 
731     def resolve_type_references(self, protocol, domain):
732         log.debug(&quot;&gt;&gt;&gt; Resolving type references for parameter: %s&quot; % self.parameter_name)
733         self.type = protocol.lookup_type_reference(self.type_ref, domain)
734 
735 
736 class Command:
<span class="line-modified">737     def __init__(self, command_name, target_types, call_parameters, return_parameters, description, platform, is_async):</span>
738         self.command_name = command_name
<span class="line-added">739         self.target_types = target_types</span>
740         self.call_parameters = call_parameters
741         self.return_parameters = return_parameters
742         self.description = description
743         self.platform = platform
744         self.is_async = is_async
745 
746     def resolve_type_references(self, protocol, domain):
747         log.debug(&quot;&gt;&gt; Resolving type references for call parameters in command: %s&quot; % self.command_name)
748         for parameter in self.call_parameters:
749             parameter.resolve_type_references(protocol, domain)
750 
751         log.debug(&quot;&gt;&gt; Resolving type references for return parameters in command: %s&quot; % self.command_name)
752         for parameter in self.return_parameters:
753             parameter.resolve_type_references(protocol, domain)
754 
755 
756 class Event:
<span class="line-modified">757     def __init__(self, event_name, target_types, event_parameters, description, platform):</span>
758         self.event_name = event_name
<span class="line-added">759         self.target_types = target_types</span>
760         self.event_parameters = event_parameters
761         self.description = description
762         self.platform = platform
763 
764     def resolve_type_references(self, protocol, domain):
765         log.debug(&quot;&gt;&gt; Resolving type references for parameters in event: %s&quot; % self.event_name)
766         for parameter in self.event_parameters:
767             parameter.resolve_type_references(protocol, domain)
</pre>
</td>
</tr>
</table>
<center><a href="generator.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="objc_generator_templates.py.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
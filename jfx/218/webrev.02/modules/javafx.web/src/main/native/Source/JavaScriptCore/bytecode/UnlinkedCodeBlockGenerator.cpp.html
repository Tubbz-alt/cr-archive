<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlockGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;UnlinkedCodeBlockGenerator.h&quot;
 28 
 29 #include &quot;BytecodeGenerator.h&quot;
 30 #include &quot;BytecodeLivenessAnalysis.h&quot;
 31 #include &quot;BytecodeRewriter.h&quot;
 32 #include &quot;ClassInfo.h&quot;
 33 #include &quot;CodeCache.h&quot;
 34 #include &quot;ExecutableInfo.h&quot;
 35 #include &quot;FunctionOverrides.h&quot;
 36 #include &quot;InstructionStream.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;JSString.h&quot;
 39 #include &quot;Opcode.h&quot;
 40 #include &quot;Parser.h&quot;
 41 #include &quot;PreciseJumpTargetsInlines.h&quot;
 42 #include &quot;SourceProvider.h&quot;
 43 #include &quot;Structure.h&quot;
 44 #include &quot;SymbolTable.h&quot;
 45 #include &quot;UnlinkedEvalCodeBlock.h&quot;
 46 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
 47 #include &quot;UnlinkedMetadataTableInlines.h&quot;
 48 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 49 #include &quot;UnlinkedProgramCodeBlock.h&quot;
 50 #include &lt;wtf/DataLog.h&gt;
 51 
 52 namespace JSC {
 53 
 54 inline void UnlinkedCodeBlockGenerator::getLineAndColumn(const ExpressionRangeInfo&amp; info, unsigned&amp; line, unsigned&amp; column) const
 55 {
 56     switch (info.mode) {
 57     case ExpressionRangeInfo::FatLineMode:
 58         info.decodeFatLineMode(line, column);
 59         break;
 60     case ExpressionRangeInfo::FatColumnMode:
 61         info.decodeFatColumnMode(line, column);
 62         break;
 63     case ExpressionRangeInfo::FatLineAndColumnMode: {
 64         unsigned fatIndex = info.position;
 65         const ExpressionRangeInfo::FatPosition&amp; fatPos = m_expressionInfoFatPositions[fatIndex];
 66         line = fatPos.line;
 67         column = fatPos.column;
 68         break;
 69     }
 70     } // switch
 71 }
 72 
 73 void UnlinkedCodeBlockGenerator::addExpressionInfo(unsigned instructionOffset, int divot, int startOffset, int endOffset, unsigned line, unsigned column)
 74 {
 75     if (divot &gt; ExpressionRangeInfo::MaxDivot) {
 76         // Overflow has occurred, we can only give line number info for errors for this region
 77         divot = 0;
 78         startOffset = 0;
 79         endOffset = 0;
 80     } else if (startOffset &gt; ExpressionRangeInfo::MaxOffset) {
 81         // If the start offset is out of bounds we clear both offsets
 82         // so we only get the divot marker. Error message will have to be reduced
 83         // to line and charPosition number.
 84         startOffset = 0;
 85         endOffset = 0;
 86     } else if (endOffset &gt; ExpressionRangeInfo::MaxOffset) {
 87         // The end offset is only used for additional context, and is much more likely
 88         // to overflow (eg. function call arguments) so we are willing to drop it without
 89         // dropping the rest of the range.
 90         endOffset = 0;
 91     }
 92 
 93     unsigned positionMode =
 94         (line &lt;= ExpressionRangeInfo::MaxFatLineModeLine &amp;&amp; column &lt;= ExpressionRangeInfo::MaxFatLineModeColumn)
 95         ? ExpressionRangeInfo::FatLineMode
 96         : (line &lt;= ExpressionRangeInfo::MaxFatColumnModeLine &amp;&amp; column &lt;= ExpressionRangeInfo::MaxFatColumnModeColumn)
 97         ? ExpressionRangeInfo::FatColumnMode
 98         : ExpressionRangeInfo::FatLineAndColumnMode;
 99 
100     ExpressionRangeInfo info;
101     info.instructionOffset = instructionOffset;
102     info.divotPoint = divot;
103     info.startOffset = startOffset;
104     info.endOffset = endOffset;
105 
106     info.mode = positionMode;
107     switch (positionMode) {
108     case ExpressionRangeInfo::FatLineMode:
109         info.encodeFatLineMode(line, column);
110         break;
111     case ExpressionRangeInfo::FatColumnMode:
112         info.encodeFatColumnMode(line, column);
113         break;
114     case ExpressionRangeInfo::FatLineAndColumnMode: {
115         unsigned fatIndex = m_expressionInfoFatPositions.size();
116         ExpressionRangeInfo::FatPosition fatPos = { line, column };
117         m_expressionInfoFatPositions.append(fatPos);
118         info.position = fatIndex;
119     }
120     } // switch
121 
122     m_expressionInfo.append(info);
123 }
124 
125 void UnlinkedCodeBlockGenerator::addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot)
126 {
127     UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange range;
128     range.m_startDivot = startDivot;
129     range.m_endDivot = endDivot;
130     m_typeProfilerInfoMap.set(instructionOffset, range);
131 }
132 
133 void UnlinkedCodeBlockGenerator::finalize(std::unique_ptr&lt;InstructionStream&gt; instructions)
134 {
135     ASSERT(instructions);
136     {
137         auto locker = holdLock(m_codeBlock-&gt;cellLock());
138         m_codeBlock-&gt;m_instructions = WTFMove(instructions);
139         m_codeBlock-&gt;m_metadata-&gt;finalize();
140 
141         m_codeBlock-&gt;m_jumpTargets = WTFMove(m_jumpTargets);
142         m_codeBlock-&gt;m_identifiers = WTFMove(m_identifiers);
143         m_codeBlock-&gt;m_constantRegisters = WTFMove(m_constantRegisters);
144         m_codeBlock-&gt;m_constantsSourceCodeRepresentation = WTFMove(m_constantsSourceCodeRepresentation);
145         m_codeBlock-&gt;m_functionDecls = WTFMove(m_functionDecls);
146         m_codeBlock-&gt;m_functionExprs = WTFMove(m_functionExprs);
147         m_codeBlock-&gt;m_expressionInfo = WTFMove(m_expressionInfo);
148         m_codeBlock-&gt;m_outOfLineJumpTargets = WTFMove(m_outOfLineJumpTargets);
149 
150         if (!m_codeBlock-&gt;m_rareData) {
151             if (!m_exceptionHandlers.isEmpty()
152                 || !m_switchJumpTables.isEmpty()
153                 || !m_stringSwitchJumpTables.isEmpty()
154                 || !m_expressionInfoFatPositions.isEmpty()
155                 || !m_typeProfilerInfoMap.isEmpty()
156                 || !m_opProfileControlFlowBytecodeOffsets.isEmpty()
157                 || !m_bitVectors.isEmpty()
158                 || !m_constantIdentifierSets.isEmpty())
159                 m_codeBlock-&gt;createRareDataIfNecessary(locker);
160         }
161         if (m_codeBlock-&gt;m_rareData) {
162             m_codeBlock-&gt;m_rareData-&gt;m_exceptionHandlers = WTFMove(m_exceptionHandlers);
163             m_codeBlock-&gt;m_rareData-&gt;m_switchJumpTables = WTFMove(m_switchJumpTables);
164             m_codeBlock-&gt;m_rareData-&gt;m_stringSwitchJumpTables = WTFMove(m_stringSwitchJumpTables);
165             m_codeBlock-&gt;m_rareData-&gt;m_expressionInfoFatPositions = WTFMove(m_expressionInfoFatPositions);
166             m_codeBlock-&gt;m_rareData-&gt;m_typeProfilerInfoMap = WTFMove(m_typeProfilerInfoMap);
167             m_codeBlock-&gt;m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets = WTFMove(m_opProfileControlFlowBytecodeOffsets);
168             m_codeBlock-&gt;m_rareData-&gt;m_bitVectors = WTFMove(m_bitVectors);
169             m_codeBlock-&gt;m_rareData-&gt;m_constantIdentifierSets = WTFMove(m_constantIdentifierSets);
170         }
171     }
172     m_vm.heap.writeBarrier(m_codeBlock.get());
173     m_vm.heap.reportExtraMemoryAllocated(m_codeBlock-&gt;m_instructions-&gt;sizeInBytes() + m_codeBlock-&gt;m_metadata-&gt;sizeInBytes());
174 }
175 
176 UnlinkedHandlerInfo* UnlinkedCodeBlockGenerator::handlerForBytecodeIndex(BytecodeIndex bytecodeIndex, RequiredHandler requiredHandler)
177 {
178     return handlerForIndex(bytecodeIndex.offset(), requiredHandler);
179 }
180 
181 UnlinkedHandlerInfo* UnlinkedCodeBlockGenerator::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
182 {
183     return UnlinkedHandlerInfo::handlerForIndex&lt;UnlinkedHandlerInfo&gt;(m_exceptionHandlers, index, requiredHandler);
184 }
185 
186 void UnlinkedCodeBlockGenerator::applyModification(BytecodeRewriter&amp; rewriter, InstructionStreamWriter&amp; instructions)
187 {
188     // Before applying the changes, we adjust the jumps based on the original bytecode offset, the offset to the jump target, and
189     // the insertion information.
190 
191     rewriter.adjustJumpTargets();
192 
193     // Then, exception handlers should be adjusted.
194     for (UnlinkedHandlerInfo&amp; handler : m_exceptionHandlers) {
195         handler.target = rewriter.adjustAbsoluteOffset(handler.target);
196         handler.start = rewriter.adjustAbsoluteOffset(handler.start);
197         handler.end = rewriter.adjustAbsoluteOffset(handler.end);
198     }
199 
200     for (size_t i = 0; i &lt; m_opProfileControlFlowBytecodeOffsets.size(); ++i)
201         m_opProfileControlFlowBytecodeOffsets[i] = rewriter.adjustAbsoluteOffset(m_opProfileControlFlowBytecodeOffsets[i]);
202 
203     if (!m_typeProfilerInfoMap.isEmpty()) {
204         HashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; adjustedTypeProfilerInfoMap;
205         for (auto&amp; entry : m_typeProfilerInfoMap)
206             adjustedTypeProfilerInfoMap.set(rewriter.adjustAbsoluteOffset(entry.key), entry.value);
207         m_typeProfilerInfoMap.swap(adjustedTypeProfilerInfoMap);
208     }
209 
210     for (size_t i = 0; i &lt; m_expressionInfo.size(); ++i)
211         m_expressionInfo[i].instructionOffset = rewriter.adjustAbsoluteOffset(m_expressionInfo[i].instructionOffset);
212 
213     // Then, modify the unlinked instructions.
214     rewriter.applyModification();
215 
216     // And recompute the jump target based on the modified unlinked instructions.
217     m_jumpTargets.clear();
218     recomputePreciseJumpTargets(this, instructions, m_jumpTargets);
219 }
220 
221 void UnlinkedCodeBlockGenerator::addOutOfLineJumpTarget(InstructionStream::Offset bytecodeOffset, int target)
222 {
223     RELEASE_ASSERT(target);
224     m_outOfLineJumpTargets.set(bytecodeOffset, target);
225 }
226 
227 int UnlinkedCodeBlockGenerator::outOfLineJumpOffset(InstructionStream::Offset bytecodeOffset)
228 {
229     ASSERT(m_outOfLineJumpTargets.contains(bytecodeOffset));
230     return m_outOfLineJumpTargets.get(bytecodeOffset);
231 }
232 
233 void UnlinkedCodeBlockGenerator::dump(PrintStream&amp;) const
234 {
235 }
236 
237 } // namespace JSC
    </pre>
  </body>
</html>
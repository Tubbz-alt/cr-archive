<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/fileapi/ThreadableBlobRegistry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileReaderLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadableBlobRegistry.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/fileapi/ThreadableBlobRegistry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 #include &lt;wtf/text/StringHash.h&gt;
 48 #include &lt;wtf/threads/BinarySemaphore.h&gt;
 49 
 50 using WTF::ThreadSpecific;
 51 
 52 namespace WebCore {
 53 
 54 typedef HashMap&lt;String, RefPtr&lt;SecurityOrigin&gt;&gt; BlobUrlOriginMap;
 55 
 56 static ThreadSpecific&lt;BlobUrlOriginMap&gt;&amp; originMap()
 57 {
 58     static std::once_flag onceFlag;
 59     static ThreadSpecific&lt;BlobUrlOriginMap&gt;* map;
 60     std::call_once(onceFlag, []{
 61         map = new ThreadSpecific&lt;BlobUrlOriginMap&gt;;
 62     });
 63 
 64     return *map;
 65 }
 66 
<span class="line-modified"> 67 void ThreadableBlobRegistry::registerFileBlobURL(PAL::SessionID sessionID, const URL&amp; url, const String&amp; path, const String&amp; contentType)</span>
 68 {
 69     if (isMainThread()) {
<span class="line-modified"> 70         blobRegistry().registerFileBlobURL(sessionID, url, BlobDataFileReference::create(path), contentType);</span>
 71         return;
 72     }
 73 
<span class="line-modified"> 74     callOnMainThread([sessionID, url = url.isolatedCopy(), path = path.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified"> 75         blobRegistry().registerFileBlobURL(sessionID, url, BlobDataFileReference::create(path), contentType);</span>
 76     });
 77 }
 78 
<span class="line-modified"> 79 void ThreadableBlobRegistry::registerBlobURL(PAL::SessionID sessionID, const URL&amp; url, Vector&lt;BlobPart&gt;&amp;&amp; blobParts, const String&amp; contentType)</span>
 80 {
 81     if (isMainThread()) {
<span class="line-modified"> 82         blobRegistry().registerBlobURL(sessionID, url, WTFMove(blobParts), contentType);</span>
 83         return;
 84     }
 85     for (auto&amp; part : blobParts)
 86         part.detachFromCurrentThread();
<span class="line-modified"> 87     callOnMainThread([sessionID, url = url.isolatedCopy(), blobParts = WTFMove(blobParts), contentType = contentType.isolatedCopy()]() mutable {</span>
<span class="line-modified"> 88         blobRegistry().registerBlobURL(sessionID, url, WTFMove(blobParts), contentType);</span>
 89     });
 90 }
 91 
<span class="line-modified"> 92 void ThreadableBlobRegistry::registerBlobURL(PAL::SessionID sessionID, SecurityOrigin* origin, const URL&amp; url, const URL&amp; srcURL)</span>






 93 {
 94     // If the blob URL contains null origin, as in the context with unique security origin or file URL, save the mapping between url and origin so that the origin can be retrived when doing security origin check.
<span class="line-modified"> 95     if (origin &amp;&amp; BlobURL::getOrigin(url) == &quot;null&quot;)</span>
 96         originMap()-&gt;add(url.string(), origin);
 97 
 98     if (isMainThread()) {
<span class="line-modified"> 99         blobRegistry().registerBlobURL(sessionID, url, srcURL);</span>
100         return;
101     }
102 
<span class="line-modified">103     callOnMainThread([sessionID, url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy()] {</span>
<span class="line-modified">104         blobRegistry().registerBlobURL(sessionID, url, srcURL);</span>
105     });
106 }
107 
<span class="line-modified">108 void ThreadableBlobRegistry::registerBlobURLOptionallyFileBacked(PAL::SessionID sessionID, const URL&amp; url, const URL&amp; srcURL, const String&amp; fileBackedPath, const String&amp; contentType)</span>
109 {
110     if (isMainThread()) {
<span class="line-modified">111         blobRegistry().registerBlobURLOptionallyFileBacked(sessionID, url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
112         return;
113     }
<span class="line-modified">114     callOnMainThread([sessionID, url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy(), fileBackedPath = fileBackedPath.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified">115         blobRegistry().registerBlobURLOptionallyFileBacked(sessionID, url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
116     });
117 }
118 
<span class="line-modified">119 void ThreadableBlobRegistry::registerBlobURLForSlice(PAL::SessionID sessionID, const URL&amp; newURL, const URL&amp; srcURL, long long start, long long end)</span>
120 {
121     if (isMainThread()) {
<span class="line-modified">122         blobRegistry().registerBlobURLForSlice(sessionID, newURL, srcURL, start, end);</span>
123         return;
124     }
125 
<span class="line-modified">126     callOnMainThread([sessionID, newURL = newURL.isolatedCopy(), srcURL = srcURL.isolatedCopy(), start, end] {</span>
<span class="line-modified">127         blobRegistry().registerBlobURLForSlice(sessionID, newURL, srcURL, start, end);</span>
128     });
129 }
130 
<span class="line-modified">131 unsigned long long ThreadableBlobRegistry::blobSize(PAL::SessionID sessionID, const URL&amp; url)</span>
132 {
133     if (isMainThread())
<span class="line-modified">134         return blobRegistry().blobSize(sessionID, url);</span>
135 
136     unsigned long long resultSize;
137     BinarySemaphore semaphore;
<span class="line-modified">138     callOnMainThread([sessionID, url = url.isolatedCopy(), &amp;semaphore, &amp;resultSize] {</span>
<span class="line-modified">139         resultSize = blobRegistry().blobSize(sessionID, url);</span>
140         semaphore.signal();
141     });
142     semaphore.wait();
143     return resultSize;
144 }
145 
<span class="line-modified">146 void ThreadableBlobRegistry::unregisterBlobURL(PAL::SessionID sessionID, const URL&amp; url)</span>
147 {
<span class="line-modified">148     if (BlobURL::getOrigin(url) == &quot;null&quot;)</span>
149         originMap()-&gt;remove(url.string());
150 
151     if (isMainThread()) {
<span class="line-modified">152         blobRegistry().unregisterBlobURL(sessionID, url);</span>
153         return;
154     }
<span class="line-modified">155     callOnMainThread([sessionID, url = url.isolatedCopy()] {</span>
<span class="line-modified">156         blobRegistry().unregisterBlobURL(sessionID, url);</span>
157     });
158 }
159 
160 RefPtr&lt;SecurityOrigin&gt; ThreadableBlobRegistry::getCachedOrigin(const URL&amp; url)
161 {
<span class="line-modified">162     return originMap()-&gt;get(url.string());</span>







163 }
164 
165 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 47 #include &lt;wtf/text/StringHash.h&gt;
 48 #include &lt;wtf/threads/BinarySemaphore.h&gt;
 49 
 50 using WTF::ThreadSpecific;
 51 
 52 namespace WebCore {
 53 
 54 typedef HashMap&lt;String, RefPtr&lt;SecurityOrigin&gt;&gt; BlobUrlOriginMap;
 55 
 56 static ThreadSpecific&lt;BlobUrlOriginMap&gt;&amp; originMap()
 57 {
 58     static std::once_flag onceFlag;
 59     static ThreadSpecific&lt;BlobUrlOriginMap&gt;* map;
 60     std::call_once(onceFlag, []{
 61         map = new ThreadSpecific&lt;BlobUrlOriginMap&gt;;
 62     });
 63 
 64     return *map;
 65 }
 66 
<span class="line-modified"> 67 void ThreadableBlobRegistry::registerFileBlobURL(const URL&amp; url, const String&amp; path, const String&amp; contentType)</span>
 68 {
 69     if (isMainThread()) {
<span class="line-modified"> 70         blobRegistry().registerFileBlobURL(url, BlobDataFileReference::create(path), contentType);</span>
 71         return;
 72     }
 73 
<span class="line-modified"> 74     callOnMainThread([url = url.isolatedCopy(), path = path.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified"> 75         blobRegistry().registerFileBlobURL(url, BlobDataFileReference::create(path), contentType);</span>
 76     });
 77 }
 78 
<span class="line-modified"> 79 void ThreadableBlobRegistry::registerBlobURL(const URL&amp; url, Vector&lt;BlobPart&gt;&amp;&amp; blobParts, const String&amp; contentType)</span>
 80 {
 81     if (isMainThread()) {
<span class="line-modified"> 82         blobRegistry().registerBlobURL(url, WTFMove(blobParts), contentType);</span>
 83         return;
 84     }
 85     for (auto&amp; part : blobParts)
 86         part.detachFromCurrentThread();
<span class="line-modified"> 87     callOnMainThread([url = url.isolatedCopy(), blobParts = WTFMove(blobParts), contentType = contentType.isolatedCopy()]() mutable {</span>
<span class="line-modified"> 88         blobRegistry().registerBlobURL(url, WTFMove(blobParts), contentType);</span>
 89     });
 90 }
 91 
<span class="line-modified"> 92 static inline bool isBlobURLContainsNullOrigin(const URL&amp; url)</span>
<span class="line-added"> 93 {</span>
<span class="line-added"> 94     ASSERT(url.protocolIsBlob());</span>
<span class="line-added"> 95     return BlobURL::getOrigin(url) == &quot;null&quot;;</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const URL&amp; url, const URL&amp; srcURL)</span>
 99 {
100     // If the blob URL contains null origin, as in the context with unique security origin or file URL, save the mapping between url and origin so that the origin can be retrived when doing security origin check.
<span class="line-modified">101     if (origin &amp;&amp; isBlobURLContainsNullOrigin(url))</span>
102         originMap()-&gt;add(url.string(), origin);
103 
104     if (isMainThread()) {
<span class="line-modified">105         blobRegistry().registerBlobURL(url, srcURL);</span>
106         return;
107     }
108 
<span class="line-modified">109     callOnMainThread([url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy()] {</span>
<span class="line-modified">110         blobRegistry().registerBlobURL(url, srcURL);</span>
111     });
112 }
113 
<span class="line-modified">114 void ThreadableBlobRegistry::registerBlobURLOptionallyFileBacked(const URL&amp; url, const URL&amp; srcURL, const String&amp; fileBackedPath, const String&amp; contentType)</span>
115 {
116     if (isMainThread()) {
<span class="line-modified">117         blobRegistry().registerBlobURLOptionallyFileBacked(url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
118         return;
119     }
<span class="line-modified">120     callOnMainThread([url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy(), fileBackedPath = fileBackedPath.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified">121         blobRegistry().registerBlobURLOptionallyFileBacked(url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
122     });
123 }
124 
<span class="line-modified">125 void ThreadableBlobRegistry::registerBlobURLForSlice(const URL&amp; newURL, const URL&amp; srcURL, long long start, long long end)</span>
126 {
127     if (isMainThread()) {
<span class="line-modified">128         blobRegistry().registerBlobURLForSlice(newURL, srcURL, start, end);</span>
129         return;
130     }
131 
<span class="line-modified">132     callOnMainThread([newURL = newURL.isolatedCopy(), srcURL = srcURL.isolatedCopy(), start, end] {</span>
<span class="line-modified">133         blobRegistry().registerBlobURLForSlice(newURL, srcURL, start, end);</span>
134     });
135 }
136 
<span class="line-modified">137 unsigned long long ThreadableBlobRegistry::blobSize(const URL&amp; url)</span>
138 {
139     if (isMainThread())
<span class="line-modified">140         return blobRegistry().blobSize(url);</span>
141 
142     unsigned long long resultSize;
143     BinarySemaphore semaphore;
<span class="line-modified">144     callOnMainThread([url = url.isolatedCopy(), &amp;semaphore, &amp;resultSize] {</span>
<span class="line-modified">145         resultSize = blobRegistry().blobSize(url);</span>
146         semaphore.signal();
147     });
148     semaphore.wait();
149     return resultSize;
150 }
151 
<span class="line-modified">152 void ThreadableBlobRegistry::unregisterBlobURL(const URL&amp; url)</span>
153 {
<span class="line-modified">154     if (isBlobURLContainsNullOrigin(url))</span>
155         originMap()-&gt;remove(url.string());
156 
157     if (isMainThread()) {
<span class="line-modified">158         blobRegistry().unregisterBlobURL(url);</span>
159         return;
160     }
<span class="line-modified">161     callOnMainThread([url = url.isolatedCopy()] {</span>
<span class="line-modified">162         blobRegistry().unregisterBlobURL(url);</span>
163     });
164 }
165 
166 RefPtr&lt;SecurityOrigin&gt; ThreadableBlobRegistry::getCachedOrigin(const URL&amp; url)
167 {
<span class="line-modified">168     if (auto cachedOrigin = originMap()-&gt;get(url.string()))</span>
<span class="line-added">169         return cachedOrigin;</span>
<span class="line-added">170 </span>
<span class="line-added">171     if (!url.protocolIsBlob() || !isBlobURLContainsNullOrigin(url))</span>
<span class="line-added">172         return nullptr;</span>
<span class="line-added">173 </span>
<span class="line-added">174     // If we do not have a cached origin for null blob URLs, we use a unique origin.</span>
<span class="line-added">175     return SecurityOrigin::createUnique();</span>
176 }
177 
178 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FileReaderLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadableBlobRegistry.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AirCode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirCustom.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirArg.h&quot;
 31 #include &quot;AirBasicBlock.h&quot;
 32 #include &quot;AirDisassembler.h&quot;
 33 #include &quot;AirSpecial.h&quot;
 34 #include &quot;AirStackSlot.h&quot;
 35 #include &quot;AirTmp.h&quot;
 36 #include &quot;B3SparseCollection.h&quot;
<span class="line-modified"> 37 #include &quot;CCallHelpers.h&quot;</span>

 38 #include &quot;RegisterAtOffsetList.h&quot;
 39 #include &quot;StackAlignment.h&quot;

 40 #include &lt;wtf/IndexMap.h&gt;
 41 #include &lt;wtf/WeakRandom.h&gt;
 42 
<span class="line-modified"> 43 namespace JSC { namespace B3 {</span>




 44 
 45 class Procedure;
 46 
<span class="line-modified"> 47 #if ASSERT_DISABLED</span>
 48 IGNORE_RETURN_TYPE_WARNINGS_BEGIN
 49 #endif
 50 
 51 namespace Air {
 52 
 53 class GenerateAndAllocateRegisters;
 54 class BlockInsertionSet;
 55 class CCallSpecial;
 56 class CFG;
 57 class Code;
 58 class Disassembler;
 59 
 60 typedef void WasmBoundsCheckGeneratorFunction(CCallHelpers&amp;, GPRReg);
 61 typedef SharedTask&lt;WasmBoundsCheckGeneratorFunction&gt; WasmBoundsCheckGenerator;
 62 
 63 typedef void PrologueGeneratorFunction(CCallHelpers&amp;, Code&amp;);
 64 typedef SharedTask&lt;PrologueGeneratorFunction&gt; PrologueGenerator;
 65 


 66 // This is an IR that is very close to the bare metal. It requires about 40x more bytes than the
 67 // generated machine code - for example if you&#39;re generating 1MB of machine code, you need about
 68 // 40MB of Air.
 69 
 70 class Code {
 71     WTF_MAKE_NONCOPYABLE(Code);
 72     WTF_MAKE_FAST_ALLOCATED;
 73 public:
 74     ~Code();
 75 
 76     Procedure&amp; proc() { return m_proc; }
 77 
 78     const Vector&lt;Reg&gt;&amp; regsInPriorityOrder(Bank bank) const
 79     {
 80         switch (bank) {
 81         case GP:
 82             return m_gpRegsInPriorityOrder;
 83         case FP:
 84             return m_fpRegsInPriorityOrder;
 85         }
</pre>
<hr />
<pre>
177     // However, if you call this before setNumEntrypoints, setNumEntrypoints will overwrite this value.
178     void setPrologueForEntrypoint(unsigned entrypointIndex, Ref&lt;PrologueGenerator&gt;&amp;&amp; generator)
179     {
180         m_prologueGenerators[entrypointIndex] = WTFMove(generator);
181     }
182     const Ref&lt;PrologueGenerator&gt;&amp; prologueGeneratorForEntrypoint(unsigned entrypointIndex)
183     {
184         return m_prologueGenerators[entrypointIndex];
185     }
186 
187     void setNumEntrypoints(unsigned);
188 
189     // This is used by lowerEntrySwitch().
190     template&lt;typename Vector&gt;
191     void setEntrypoints(Vector&amp;&amp; vector)
192     {
193         m_entrypoints = std::forward&lt;Vector&gt;(vector);
194         RELEASE_ASSERT(m_entrypoints.size() == m_prologueGenerators.size());
195     }
196 
<span class="line-modified">197     CCallHelpers::Label entrypointLabel(unsigned index) const</span>
198     {
199         return m_entrypointLabels[index];
200     }
201 
202     // This is used by generate().
203     template&lt;typename Vector&gt;
204     void setEntrypointLabels(Vector&amp;&amp; vector)
205     {
206         m_entrypointLabels = std::forward&lt;Vector&gt;(vector);
207         RELEASE_ASSERT(m_entrypointLabels.size() == m_prologueGenerators.size());
208     }
209 
210     void setStackIsAllocated(bool value)
211     {
212         m_stackIsAllocated = value;
213     }
214 
215     bool stackIsAllocated() const { return m_stackIsAllocated; }
216 
217     // This sets the callee save registers.
218     void setCalleeSaveRegisterAtOffsetList(RegisterAtOffsetList&amp;&amp;, StackSlot*);
219 
220     // This returns the correctly offset list of callee save registers.
221     RegisterAtOffsetList calleeSaveRegisterAtOffsetList() const;
222 
223     // This just tells you what the callee saves are.
224     RegisterSet calleeSaveRegisters() const { return m_calleeSaveRegisters; }
225 
226     // Recomputes predecessors and deletes unreachable blocks.
<span class="line-modified">227     void resetReachability();</span>
228 
229     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
230 
231     unsigned size() const { return m_blocks.size(); }
232     BasicBlock* at(unsigned index) const { return m_blocks[index].get(); }
233     BasicBlock* operator[](unsigned index) const { return at(index); }
234 
235     // This is used by phases that optimize the block list. You shouldn&#39;t use this unless you really know
236     // what you&#39;re doing.
237     Vector&lt;std::unique_ptr&lt;BasicBlock&gt;&gt;&amp; blockList() { return m_blocks; }
238 
239     // Finds the smallest index&#39; such that at(index&#39;) != null and index&#39; &gt;= index.
240     JS_EXPORT_PRIVATE unsigned findFirstBlockIndex(unsigned index) const;
241 
242     // Finds the smallest index&#39; such that at(index&#39;) != null and index&#39; &gt; index.
243     unsigned findNextBlockIndex(unsigned index) const;
244 
245     BasicBlock* findNextBlock(BasicBlock*) const;
246 
247     class iterator {
</pre>
<hr />
<pre>
364     Procedure&amp; m_proc; // Some meta-data, like byproducts, is stored in the Procedure.
365     Vector&lt;Reg&gt; m_gpRegsInPriorityOrder;
366     Vector&lt;Reg&gt; m_fpRegsInPriorityOrder;
367     RegisterSet m_mutableRegs;
368     RegisterSet m_pinnedRegs;
369     SparseCollection&lt;StackSlot&gt; m_stackSlots;
370     Vector&lt;std::unique_ptr&lt;BasicBlock&gt;&gt; m_blocks;
371     SparseCollection&lt;Special&gt; m_specials;
372     std::unique_ptr&lt;CFG&gt; m_cfg;
373     HashSet&lt;Tmp&gt; m_fastTmps;
374     CCallSpecial* m_cCallSpecial { nullptr };
375     unsigned m_numGPTmps { 0 };
376     unsigned m_numFPTmps { 0 };
377     unsigned m_frameSize { 0 };
378     unsigned m_callArgAreaSize { 0 };
379     bool m_stackIsAllocated { false };
380     RegisterAtOffsetList m_uncorrectedCalleeSaveRegisterAtOffsetList;
381     RegisterSet m_calleeSaveRegisters;
382     StackSlot* m_calleeSaveStackSlot { nullptr };
383     Vector&lt;FrequentedBlock&gt; m_entrypoints; // This is empty until after lowerEntrySwitch().
<span class="line-modified">384     Vector&lt;CCallHelpers::Label&gt; m_entrypointLabels; // This is empty until code generation.</span>
385     Vector&lt;Ref&lt;PrologueGenerator&gt;, 1&gt; m_prologueGenerators;
386     RefPtr&lt;WasmBoundsCheckGenerator&gt; m_wasmBoundsCheckGenerator;
387     const char* m_lastPhaseName;
388     std::unique_ptr&lt;Disassembler&gt; m_disassembler;
389     unsigned m_optLevel { defaultOptLevel() };
390     Ref&lt;PrologueGenerator&gt; m_defaultPrologueGenerator;
391 };
392 
393 } } } // namespace JSC::B3::Air
394 
<span class="line-modified">395 #if ASSERT_DISABLED</span>
396 IGNORE_RETURN_TYPE_WARNINGS_END
397 #endif
398 
399 #endif // ENABLE(B3_JIT)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirArg.h&quot;
 31 #include &quot;AirBasicBlock.h&quot;
 32 #include &quot;AirDisassembler.h&quot;
 33 #include &quot;AirSpecial.h&quot;
 34 #include &quot;AirStackSlot.h&quot;
 35 #include &quot;AirTmp.h&quot;
 36 #include &quot;B3SparseCollection.h&quot;
<span class="line-modified"> 37 #include &quot;GPRInfo.h&quot;</span>
<span class="line-added"> 38 #include &quot;MacroAssembler.h&quot;</span>
 39 #include &quot;RegisterAtOffsetList.h&quot;
 40 #include &quot;StackAlignment.h&quot;
<span class="line-added"> 41 #include &lt;wtf/HashSet.h&gt;</span>
 42 #include &lt;wtf/IndexMap.h&gt;
 43 #include &lt;wtf/WeakRandom.h&gt;
 44 
<span class="line-modified"> 45 namespace JSC {</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 class CCallHelpers;</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49 namespace B3 {</span>
 50 
 51 class Procedure;
 52 
<span class="line-modified"> 53 #if !ASSERT_ENABLED</span>
 54 IGNORE_RETURN_TYPE_WARNINGS_BEGIN
 55 #endif
 56 
 57 namespace Air {
 58 
 59 class GenerateAndAllocateRegisters;
 60 class BlockInsertionSet;
 61 class CCallSpecial;
 62 class CFG;
 63 class Code;
 64 class Disassembler;
 65 
 66 typedef void WasmBoundsCheckGeneratorFunction(CCallHelpers&amp;, GPRReg);
 67 typedef SharedTask&lt;WasmBoundsCheckGeneratorFunction&gt; WasmBoundsCheckGenerator;
 68 
 69 typedef void PrologueGeneratorFunction(CCallHelpers&amp;, Code&amp;);
 70 typedef SharedTask&lt;PrologueGeneratorFunction&gt; PrologueGenerator;
 71 
<span class="line-added"> 72 extern const char* const tierName;</span>
<span class="line-added"> 73 </span>
 74 // This is an IR that is very close to the bare metal. It requires about 40x more bytes than the
 75 // generated machine code - for example if you&#39;re generating 1MB of machine code, you need about
 76 // 40MB of Air.
 77 
 78 class Code {
 79     WTF_MAKE_NONCOPYABLE(Code);
 80     WTF_MAKE_FAST_ALLOCATED;
 81 public:
 82     ~Code();
 83 
 84     Procedure&amp; proc() { return m_proc; }
 85 
 86     const Vector&lt;Reg&gt;&amp; regsInPriorityOrder(Bank bank) const
 87     {
 88         switch (bank) {
 89         case GP:
 90             return m_gpRegsInPriorityOrder;
 91         case FP:
 92             return m_fpRegsInPriorityOrder;
 93         }
</pre>
<hr />
<pre>
185     // However, if you call this before setNumEntrypoints, setNumEntrypoints will overwrite this value.
186     void setPrologueForEntrypoint(unsigned entrypointIndex, Ref&lt;PrologueGenerator&gt;&amp;&amp; generator)
187     {
188         m_prologueGenerators[entrypointIndex] = WTFMove(generator);
189     }
190     const Ref&lt;PrologueGenerator&gt;&amp; prologueGeneratorForEntrypoint(unsigned entrypointIndex)
191     {
192         return m_prologueGenerators[entrypointIndex];
193     }
194 
195     void setNumEntrypoints(unsigned);
196 
197     // This is used by lowerEntrySwitch().
198     template&lt;typename Vector&gt;
199     void setEntrypoints(Vector&amp;&amp; vector)
200     {
201         m_entrypoints = std::forward&lt;Vector&gt;(vector);
202         RELEASE_ASSERT(m_entrypoints.size() == m_prologueGenerators.size());
203     }
204 
<span class="line-modified">205     MacroAssembler::Label entrypointLabel(unsigned index) const</span>
206     {
207         return m_entrypointLabels[index];
208     }
209 
210     // This is used by generate().
211     template&lt;typename Vector&gt;
212     void setEntrypointLabels(Vector&amp;&amp; vector)
213     {
214         m_entrypointLabels = std::forward&lt;Vector&gt;(vector);
215         RELEASE_ASSERT(m_entrypointLabels.size() == m_prologueGenerators.size());
216     }
217 
218     void setStackIsAllocated(bool value)
219     {
220         m_stackIsAllocated = value;
221     }
222 
223     bool stackIsAllocated() const { return m_stackIsAllocated; }
224 
225     // This sets the callee save registers.
226     void setCalleeSaveRegisterAtOffsetList(RegisterAtOffsetList&amp;&amp;, StackSlot*);
227 
228     // This returns the correctly offset list of callee save registers.
229     RegisterAtOffsetList calleeSaveRegisterAtOffsetList() const;
230 
231     // This just tells you what the callee saves are.
232     RegisterSet calleeSaveRegisters() const { return m_calleeSaveRegisters; }
233 
234     // Recomputes predecessors and deletes unreachable blocks.
<span class="line-modified">235     JS_EXPORT_PRIVATE void resetReachability();</span>
236 
237     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
238 
239     unsigned size() const { return m_blocks.size(); }
240     BasicBlock* at(unsigned index) const { return m_blocks[index].get(); }
241     BasicBlock* operator[](unsigned index) const { return at(index); }
242 
243     // This is used by phases that optimize the block list. You shouldn&#39;t use this unless you really know
244     // what you&#39;re doing.
245     Vector&lt;std::unique_ptr&lt;BasicBlock&gt;&gt;&amp; blockList() { return m_blocks; }
246 
247     // Finds the smallest index&#39; such that at(index&#39;) != null and index&#39; &gt;= index.
248     JS_EXPORT_PRIVATE unsigned findFirstBlockIndex(unsigned index) const;
249 
250     // Finds the smallest index&#39; such that at(index&#39;) != null and index&#39; &gt; index.
251     unsigned findNextBlockIndex(unsigned index) const;
252 
253     BasicBlock* findNextBlock(BasicBlock*) const;
254 
255     class iterator {
</pre>
<hr />
<pre>
372     Procedure&amp; m_proc; // Some meta-data, like byproducts, is stored in the Procedure.
373     Vector&lt;Reg&gt; m_gpRegsInPriorityOrder;
374     Vector&lt;Reg&gt; m_fpRegsInPriorityOrder;
375     RegisterSet m_mutableRegs;
376     RegisterSet m_pinnedRegs;
377     SparseCollection&lt;StackSlot&gt; m_stackSlots;
378     Vector&lt;std::unique_ptr&lt;BasicBlock&gt;&gt; m_blocks;
379     SparseCollection&lt;Special&gt; m_specials;
380     std::unique_ptr&lt;CFG&gt; m_cfg;
381     HashSet&lt;Tmp&gt; m_fastTmps;
382     CCallSpecial* m_cCallSpecial { nullptr };
383     unsigned m_numGPTmps { 0 };
384     unsigned m_numFPTmps { 0 };
385     unsigned m_frameSize { 0 };
386     unsigned m_callArgAreaSize { 0 };
387     bool m_stackIsAllocated { false };
388     RegisterAtOffsetList m_uncorrectedCalleeSaveRegisterAtOffsetList;
389     RegisterSet m_calleeSaveRegisters;
390     StackSlot* m_calleeSaveStackSlot { nullptr };
391     Vector&lt;FrequentedBlock&gt; m_entrypoints; // This is empty until after lowerEntrySwitch().
<span class="line-modified">392     Vector&lt;MacroAssembler::Label&gt; m_entrypointLabels; // This is empty until code generation.</span>
393     Vector&lt;Ref&lt;PrologueGenerator&gt;, 1&gt; m_prologueGenerators;
394     RefPtr&lt;WasmBoundsCheckGenerator&gt; m_wasmBoundsCheckGenerator;
395     const char* m_lastPhaseName;
396     std::unique_ptr&lt;Disassembler&gt; m_disassembler;
397     unsigned m_optLevel { defaultOptLevel() };
398     Ref&lt;PrologueGenerator&gt; m_defaultPrologueGenerator;
399 };
400 
401 } } } // namespace JSC::B3::Air
402 
<span class="line-modified">403 #if !ASSERT_ENABLED</span>
404 IGNORE_RETURN_TYPE_WARNINGS_END
405 #endif
406 
407 #endif // ENABLE(B3_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="AirCode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirCustom.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
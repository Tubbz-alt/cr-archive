<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FormattingContext.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextGeometry.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,127 ***</span>
  
  #pragma once
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="line-modified">! #include &quot;DisplayBox.h&quot;</span>
  #include &lt;wtf/IsoMalloc.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! class LayoutPoint;</span>
<span class="line-modified">! class LayoutUnit;</span>
  
  namespace Layout {
  
  class Box;
  class Container;
  class FormattingState;
  class LayoutState;
  
  class FormattingContext {
      WTF_MAKE_ISO_ALLOCATED(FormattingContext);
  public:
<span class="line-modified">!     FormattingContext(const Box&amp; formattingContextRoot, FormattingState&amp;);</span>
      virtual ~FormattingContext();
  
<span class="line-modified">!     virtual void layout() const = 0;</span>
<span class="line-modified">!     void layoutOutOfFlowContent() const;</span>
  
      struct IntrinsicWidthConstraints {
          void expand(LayoutUnit horizontalValue);
          IntrinsicWidthConstraints&amp; operator+=(const IntrinsicWidthConstraints&amp;);
  
          LayoutUnit minimum;
          LayoutUnit maximum;
      };
<span class="line-modified">!     virtual IntrinsicWidthConstraints computedIntrinsicWidthConstraints() const = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     static Display::Box mapBoxToAncestor(const LayoutState&amp;, const Box&amp;, const Container&amp; ancestor);</span>
<span class="line-modified">!     static LayoutUnit mapTopToAncestor(const LayoutState&amp;, const Box&amp;, const Container&amp; ancestor);</span>
<span class="line-modified">!     static LayoutUnit mapLeftToAncestor(const LayoutState&amp;, const Box&amp;, const Container&amp; ancestor);</span>
<span class="line-modified">!     static LayoutUnit mapRightToAncestor(const LayoutState&amp;, const Box&amp;, const Container&amp; ancestor);</span>
<span class="line-modified">!     static Point mapPointToAncestor(const LayoutState&amp;, Point, const Container&amp; from, const Container&amp; to);</span>
<span class="line-modified">!     static Point mapPointToDescendent(const LayoutState&amp;, Point, const Container&amp; from, const Container&amp; to);</span>
  
  protected:
      using LayoutQueue = Vector&lt;const Box*&gt;;
  
      LayoutState&amp; layoutState() const;
<span class="line-modified">!     FormattingState&amp; formattingState() const { return m_formattingState; }</span>
<span class="line-modified">!     const Box&amp; root() const { return *m_root; }</span>
  
<span class="line-modified">!     void computeBorderAndPadding(const Box&amp;, Optional&lt;UsedHorizontalValues&gt; = WTF::nullopt) const;</span>
  
  #ifndef NDEBUG
      virtual void validateGeometryConstraintsAfterLayout() const;
  #endif
  
      // This class implements generic positioning and sizing.
      class Geometry {
      public:
<span class="line-modified">!         static VerticalGeometry outOfFlowVerticalGeometry(const LayoutState&amp;, const Box&amp;, UsedVerticalValues);</span>
<span class="line-modified">!         static HorizontalGeometry outOfFlowHorizontalGeometry(LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static HeightAndMargin floatingHeightAndMargin(const LayoutState&amp;, const Box&amp;, UsedVerticalValues, UsedHorizontalValues);</span>
<span class="line-removed">-         static WidthAndMargin floatingWidthAndMargin(LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static HeightAndMargin inlineReplacedHeightAndMargin(const LayoutState&amp;, const Box&amp;, UsedVerticalValues);</span>
<span class="line-modified">!         static WidthAndMargin inlineReplacedWidthAndMargin(const LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static LayoutSize inFlowPositionedPositionOffset(const LayoutState&amp;, const Box&amp;);</span>
  
<span class="line-modified">!         static HeightAndMargin complicatedCases(const LayoutState&amp;, const Box&amp;, UsedVerticalValues, UsedHorizontalValues);</span>
<span class="line-modified">!         static LayoutUnit shrinkToFitWidth(LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static Edges computedBorder(const Box&amp;);</span>
<span class="line-modified">!         static Optional&lt;Edges&gt; computedPadding(const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static ComputedHorizontalMargin computedHorizontalMargin(const Box&amp;, UsedHorizontalValues);</span>
<span class="line-modified">!         static ComputedVerticalMargin computedVerticalMargin(const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static Optional&lt;LayoutUnit&gt; computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth);</span>
<span class="line-modified">!         static Optional&lt;LayoutUnit&gt; fixedValue(const Length&amp; geometryProperty);</span>
  
<span class="line-modified">!         static Optional&lt;LayoutUnit&gt; computedMinHeight(const LayoutState&amp;, const Box&amp;);</span>
<span class="line-removed">-         static Optional&lt;LayoutUnit&gt; computedMaxHeight(const LayoutState&amp;, const Box&amp;);</span>
  
<span class="line-modified">!         static FormattingContext::IntrinsicWidthConstraints constrainByMinMaxWidth(const Box&amp;, IntrinsicWidthConstraints);</span>
  
<span class="line-modified">!         static LayoutUnit contentHeightForFormattingContextRoot(const LayoutState&amp;, const Box&amp;);</span>
  
      protected:
          enum class HeightType { Min, Max, Normal };
<span class="line-modified">!         static Optional&lt;LayoutUnit&gt; computedHeightValue(const LayoutState&amp;, const Box&amp;, HeightType);</span>
  
      private:
<span class="line-modified">!         static VerticalGeometry outOfFlowReplacedVerticalGeometry(const LayoutState&amp;, const Box&amp;, UsedVerticalValues);</span>
<span class="line-modified">!         static HorizontalGeometry outOfFlowReplacedHorizontalGeometry(const LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static VerticalGeometry outOfFlowNonReplacedVerticalGeometry(const LayoutState&amp;, const Box&amp;, UsedVerticalValues);</span>
<span class="line-modified">!         static HorizontalGeometry outOfFlowNonReplacedHorizontalGeometry(LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static HeightAndMargin floatingReplacedHeightAndMargin(const LayoutState&amp;, const Box&amp;, UsedVerticalValues);</span>
<span class="line-removed">-         static WidthAndMargin floatingReplacedWidthAndMargin(const LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
  
<span class="line-modified">!         static WidthAndMargin floatingNonReplacedWidthAndMargin(LayoutState&amp;, const Box&amp;, UsedHorizontalValues);</span>
      };
  
      class Quirks {
      public:
<span class="line-modified">!         static LayoutUnit heightValueOfNearestContainingBlockWithFixedHeight(const LayoutState&amp;, const Box&amp;);</span>
      };
  
  private:
<span class="line-modified">!     void computeOutOfFlowVerticalGeometry(const Box&amp;) const;</span>
<span class="line-modified">!     void computeOutOfFlowHorizontalGeometry(const Box&amp;) const;</span>
  
<span class="line-modified">!     WeakPtr&lt;const Box&gt; m_root;</span>
      FormattingState&amp; m_formattingState;
  };
  
  inline void FormattingContext::IntrinsicWidthConstraints::expand(LayoutUnit horizontalValue)
  {
      minimum += horizontalValue;
      maximum += horizontalValue;
  }
<span class="line-new-header">--- 25,200 ---</span>
  
  #pragma once
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="line-modified">! #include &quot;LayoutContainer.h&quot;</span>
<span class="line-added">+ #include &quot;LayoutUnit.h&quot;</span>
<span class="line-added">+ #include &quot;LayoutUnits.h&quot;</span>
  #include &lt;wtf/IsoMalloc.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! namespace Display {</span>
<span class="line-modified">! class Box;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ class LayoutSize;</span>
<span class="line-added">+ struct Length;</span>
  
  namespace Layout {
  
  class Box;
<span class="line-added">+ struct ComputedHorizontalMargin;</span>
<span class="line-added">+ struct ComputedVerticalMargin;</span>
  class Container;
<span class="line-added">+ struct ContentHeightAndMargin;</span>
<span class="line-added">+ struct ContentWidthAndMargin;</span>
<span class="line-added">+ struct Edges;</span>
  class FormattingState;
<span class="line-added">+ struct HorizontalGeometry;</span>
<span class="line-added">+ class InvalidationState;</span>
  class LayoutState;
<span class="line-added">+ struct OverrideHorizontalValues;</span>
<span class="line-added">+ struct OverrideVerticalValues;</span>
<span class="line-added">+ struct VerticalGeometry;</span>
  
  class FormattingContext {
      WTF_MAKE_ISO_ALLOCATED(FormattingContext);
  public:
<span class="line-modified">!     FormattingContext(const Container&amp; formattingContextRoot, FormattingState&amp;);</span>
      virtual ~FormattingContext();
  
<span class="line-modified">!     virtual void layoutInFlowContent(InvalidationState&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;) = 0;</span>
<span class="line-modified">!     void layoutOutOfFlowContent(InvalidationState&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;);</span>
  
      struct IntrinsicWidthConstraints {
          void expand(LayoutUnit horizontalValue);
          IntrinsicWidthConstraints&amp; operator+=(const IntrinsicWidthConstraints&amp;);
  
          LayoutUnit minimum;
          LayoutUnit maximum;
      };
<span class="line-modified">!     virtual IntrinsicWidthConstraints computedIntrinsicWidthConstraints() = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     LayoutUnit mapTopToFormattingContextRoot(const Box&amp;) const;</span>
<span class="line-modified">!     LayoutUnit mapLeftToFormattingContextRoot(const Box&amp;) const;</span>
<span class="line-modified">!     LayoutUnit mapRightToFormattingContextRoot(const Box&amp;) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     bool isBlockFormattingContext() const { return root().establishesBlockFormattingContext(); }</span>
<span class="line-modified">!     bool isInlineFormattingContext() const { return root().establishesInlineFormattingContext(); }</span>
<span class="line-added">+     bool isTableFormattingContext() const { return root().establishesTableFormattingContext(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     enum class EscapeReason {</span>
<span class="line-added">+         NeedsGeometryFromEstablishedFormattingContext,</span>
<span class="line-added">+         OutOfFlowBoxNeedsInFlowGeometry,</span>
<span class="line-added">+         FloatBoxNeedsToBeInAbsoluteCoordinates,</span>
<span class="line-added">+         FindFixedHeightAncestorQuirk,</span>
<span class="line-added">+         BodyStrechesToViewportQuirk,</span>
<span class="line-added">+         StrokeOverflowNeedsViewportGeometry,</span>
<span class="line-added">+         TableNeedsAccessToTableWrapper</span>
<span class="line-added">+     };</span>
<span class="line-added">+     const Display::Box&amp; geometryForBox(const Box&amp;, Optional&lt;EscapeReason&gt; = WTF::nullopt) const;</span>
  
  protected:
      using LayoutQueue = Vector&lt;const Box*&gt;;
  
<span class="line-added">+     const Container&amp; root() const { return *m_root; }</span>
      LayoutState&amp; layoutState() const;
<span class="line-modified">!     const FormattingState&amp; formattingState() const { return m_formattingState; }</span>
<span class="line-modified">!     FormattingState&amp; formattingState() { return m_formattingState; }</span>
  
<span class="line-modified">!     void computeBorderAndPadding(const Box&amp;, const HorizontalConstraints&amp;);</span>
  
  #ifndef NDEBUG
      virtual void validateGeometryConstraintsAfterLayout() const;
  #endif
  
      // This class implements generic positioning and sizing.
      class Geometry {
      public:
<span class="line-modified">!         VerticalGeometry outOfFlowVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;, const OverrideVerticalValues&amp;) const;</span>
<span class="line-modified">!         HorizontalGeometry outOfFlowHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ContentHeightAndMargin floatingHeightAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideVerticalValues&amp;) const;</span>
<span class="line-added">+         ContentWidthAndMargin floatingWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ContentHeightAndMargin inlineReplacedHeightAndMargin(const Box&amp;, const HorizontalConstraints&amp;, Optional&lt;VerticalConstraints&gt;, const OverrideVerticalValues&amp;) const;</span>
<span class="line-added">+         ContentWidthAndMargin inlineReplacedWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;) const;</span>
  
<span class="line-modified">!         LayoutSize inFlowPositionedPositionOffset(const Box&amp;, const HorizontalConstraints&amp;) const;</span>
  
<span class="line-modified">!         ContentHeightAndMargin complicatedCases(const Box&amp;, const HorizontalConstraints&amp;, const OverrideVerticalValues&amp;) const;</span>
<span class="line-modified">!         LayoutUnit shrinkToFitWidth(const Box&amp;, LayoutUnit availableWidth);</span>
  
<span class="line-modified">!         Edges computedBorder(const Box&amp;) const;</span>
<span class="line-added">+         Optional&lt;Edges&gt; computedPadding(const Box&amp;, const HorizontalConstraints&amp;) const;</span>
  
<span class="line-modified">!         ComputedHorizontalMargin computedHorizontalMargin(const Box&amp;, const HorizontalConstraints&amp;) const;</span>
<span class="line-modified">!         ComputedVerticalMargin computedVerticalMargin(const Box&amp;, const HorizontalConstraints&amp;) const;</span>
  
<span class="line-modified">!         Optional&lt;LayoutUnit&gt; computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth) const;</span>
<span class="line-modified">!         Optional&lt;LayoutUnit&gt; fixedValue(const Length&amp; geometryProperty) const;</span>
  
<span class="line-modified">!         Optional&lt;LayoutUnit&gt; computedMinHeight(const Box&amp;, Optional&lt;LayoutUnit&gt; containingBlockHeight = WTF::nullopt) const;</span>
<span class="line-modified">!         Optional&lt;LayoutUnit&gt; computedMaxHeight(const Box&amp;, Optional&lt;LayoutUnit&gt; containingBlockHeight = WTF::nullopt) const;</span>
  
<span class="line-modified">!         Optional&lt;LayoutUnit&gt; computedMinWidth(const Box&amp;, LayoutUnit containingBlockWidth) const;</span>
<span class="line-modified">!         Optional&lt;LayoutUnit&gt; computedMaxWidth(const Box&amp;, LayoutUnit containingBlockWidth) const;</span>
  
<span class="line-modified">!         FormattingContext::IntrinsicWidthConstraints constrainByMinMaxWidth(const Box&amp;, IntrinsicWidthConstraints) const;</span>
  
<span class="line-modified">!         LayoutUnit contentHeightForFormattingContextRoot(const Box&amp;) const;</span>
  
<span class="line-modified">!         static HorizontalConstraints horizontalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry);</span>
<span class="line-added">+         static VerticalConstraints verticalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry);</span>
<span class="line-added">+         static HorizontalConstraints horizontalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry);</span>
<span class="line-added">+         static VerticalConstraints verticalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry);</span>
  
      protected:
<span class="line-added">+         friend class FormattingContext;</span>
<span class="line-added">+         Geometry(const FormattingContext&amp;);</span>
<span class="line-added">+ </span>
          enum class HeightType { Min, Max, Normal };
<span class="line-modified">!         Optional&lt;LayoutUnit&gt; computedHeightValue(const Box&amp;, HeightType, Optional&lt;LayoutUnit&gt; containingBlockHeight) const;</span>
<span class="line-added">+         Optional&lt;LayoutUnit&gt; computedContentHeight(const Box&amp;, Optional&lt;LayoutUnit&gt; containingBlockHeight = WTF::nullopt) const;</span>
<span class="line-added">+         Optional&lt;LayoutUnit&gt; computedContentWidth(const Box&amp;, LayoutUnit containingBlockWidth) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+         const LayoutState&amp; layoutState() const { return m_formattingContext.layoutState(); }</span>
<span class="line-added">+         LayoutState&amp; layoutState() { return m_formattingContext.layoutState(); }</span>
<span class="line-added">+         const FormattingContext&amp; formattingContext() const { return m_formattingContext; }</span>
  
      private:
<span class="line-modified">!         VerticalGeometry outOfFlowReplacedVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;, const OverrideVerticalValues&amp;) const;</span>
<span class="line-modified">!         HorizontalGeometry outOfFlowReplacedHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+         VerticalGeometry outOfFlowNonReplacedVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;, const OverrideVerticalValues&amp;) const;</span>
<span class="line-added">+         HorizontalGeometry outOfFlowNonReplacedHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);</span>
  
<span class="line-modified">!         ContentHeightAndMargin floatingReplacedHeightAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideVerticalValues&amp;) const;</span>
<span class="line-modified">!         ContentWidthAndMargin floatingReplacedWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;) const;</span>
  
<span class="line-modified">!         ContentWidthAndMargin floatingNonReplacedWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);</span>
  
<span class="line-modified">!         LayoutUnit staticVerticalPositionForOutOfFlowPositioned(const Box&amp;, const VerticalConstraints&amp;) const;</span>
<span class="line-added">+         LayoutUnit staticHorizontalPositionForOutOfFlowPositioned(const Box&amp;, const HorizontalConstraints&amp;) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+         const FormattingContext&amp; m_formattingContext;</span>
      };
<span class="line-added">+     FormattingContext::Geometry geometry() const { return Geometry(*this); }</span>
  
      class Quirks {
      public:
<span class="line-modified">!         LayoutUnit heightValueOfNearestContainingBlockWithFixedHeight(const Box&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected:</span>
<span class="line-added">+         friend class FormattingContext;</span>
<span class="line-added">+         Quirks(const FormattingContext&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         const LayoutState&amp; layoutState() const { return m_formattingContext.layoutState(); }</span>
<span class="line-added">+         LayoutState&amp; layoutState() { return m_formattingContext.layoutState(); }</span>
<span class="line-added">+         const FormattingContext&amp; formattingContext() const { return m_formattingContext; }</span>
<span class="line-added">+ </span>
<span class="line-added">+         const FormattingContext&amp; m_formattingContext;</span>
      };
<span class="line-added">+     FormattingContext::Quirks quirks() const { return Quirks(*this); }</span>
  
  private:
<span class="line-modified">!     void collectOutOfFlowDescendantsIfNeeded();</span>
<span class="line-modified">!     void computeOutOfFlowVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;);</span>
<span class="line-added">+     void computeOutOfFlowHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;);</span>
  
<span class="line-modified">!     WeakPtr&lt;const Container&gt; m_root;</span>
      FormattingState&amp; m_formattingState;
  };
  
<span class="line-added">+ inline FormattingContext::Geometry::Geometry(const FormattingContext&amp; formattingContext)</span>
<span class="line-added">+     : m_formattingContext(formattingContext)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline FormattingContext::Quirks::Quirks(const FormattingContext&amp; formattingContext)</span>
<span class="line-added">+     : m_formattingContext(formattingContext)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  inline void FormattingContext::IntrinsicWidthConstraints::expand(LayoutUnit horizontalValue)
  {
      minimum += horizontalValue;
      maximum += horizontalValue;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,6 ***</span>
<span class="line-new-header">--- 230,12 ---</span>
      return *this;
  }
  
  }
  }
<span class="line-added">+ </span>
<span class="line-added">+ #define SPECIALIZE_TYPE_TRAITS_LAYOUT_FORMATTING_CONTEXT(ToValueTypeName, predicate) \</span>
<span class="line-added">+ SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Layout::ToValueTypeName) \</span>
<span class="line-added">+     static bool isType(const WebCore::Layout::FormattingContext&amp; formattingContext) { return formattingContext.predicate; } \</span>
<span class="line-added">+ SPECIALIZE_TYPE_TRAITS_END()</span>
<span class="line-added">+ </span>
  #endif
</pre>
<center><a href="FormattingContext.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextGeometry.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
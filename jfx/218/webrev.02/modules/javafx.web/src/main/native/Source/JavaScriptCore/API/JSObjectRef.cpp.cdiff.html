<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSObjectRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSHeapFinalizerPrivate.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScriptRef.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSObjectRef.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008 Kelvin W Sherlock (ksherlock@gmail.com)
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008 Kelvin W Sherlock (ksherlock@gmail.com)
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,11 ***</span>
  #include &quot;JSClassRef.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;JSObject.h&quot;
  #include &quot;JSPromise.h&quot;
<span class="line-removed">- #include &quot;JSPromiseDeferred.h&quot;</span>
  #include &quot;JSRetainPtr.h&quot;
  #include &quot;JSString.h&quot;
  #include &quot;JSValueRef.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;ObjectPrototype.h&quot;
<span class="line-new-header">--- 45,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,19 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      if (!jsClass)
<span class="line-modified">!         return toRef(constructEmptyObject(exec));</span>
  
<span class="line-modified">!     JSCallbackObject&lt;JSDestructibleObject&gt;* object = JSCallbackObject&lt;JSDestructibleObject&gt;::create(exec, exec-&gt;lexicalGlobalObject(), exec-&gt;lexicalGlobalObject()-&gt;callbackObjectStructure(), jsClass, data);</span>
<span class="line-modified">!     if (JSObject* prototype = jsClass-&gt;prototype(exec))</span>
          object-&gt;setPrototypeDirect(vm, prototype);
  
      return toRef(object);
  }
  
<span class="line-new-header">--- 87,19 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      if (!jsClass)
<span class="line-modified">!         return toRef(constructEmptyObject(globalObject));</span>
  
<span class="line-modified">!     JSCallbackObject&lt;JSNonFinalObject&gt;* object = JSCallbackObject&lt;JSNonFinalObject&gt;::create(globalObject, globalObject-&gt;callbackObjectStructure(), jsClass, data);</span>
<span class="line-modified">!     if (JSObject* prototype = jsClass-&gt;prototype(globalObject))</span>
          object-&gt;setPrototypeDirect(vm, prototype);
  
      return toRef(object);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,43 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
<span class="line-modified">!     return toRef(JSCallbackFunction::create(vm, exec-&gt;lexicalGlobalObject(), callAsFunction, name ? name-&gt;string() : &quot;anonymous&quot;_s));</span>
  }
  
  JSObjectRef JSObjectMakeConstructor(JSContextRef ctx, JSClassRef jsClass, JSObjectCallAsConstructorCallback callAsConstructor)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     JSValue jsPrototype = jsClass ? jsClass-&gt;prototype(exec) : 0;</span>
      if (!jsPrototype)
<span class="line-modified">!         jsPrototype = exec-&gt;lexicalGlobalObject()-&gt;objectPrototype();</span>
  
<span class="line-modified">!     JSCallbackConstructor* constructor = JSCallbackConstructor::create(exec, exec-&gt;lexicalGlobalObject(), exec-&gt;lexicalGlobalObject()-&gt;callbackConstructorStructure(), jsClass, callAsConstructor);</span>
      constructor-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, jsPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
      return toRef(constructor);
  }
  
  JSObjectRef JSObjectMakeFunction(JSContextRef ctx, JSStringRef name, unsigned parameterCount, const JSStringRef parameterNames[], JSStringRef body, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      startingLineNumber = std::max(1, startingLineNumber);
      Identifier nameID = name ? name-&gt;identifier(&amp;vm) : Identifier::fromString(vm, &quot;anonymous&quot;);
<span class="line-new-header">--- 107,43 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
<span class="line-modified">!     return toRef(JSCallbackFunction::create(vm, globalObject, callAsFunction, name ? name-&gt;string() : &quot;anonymous&quot;_s));</span>
  }
  
  JSObjectRef JSObjectMakeConstructor(JSContextRef ctx, JSClassRef jsClass, JSObjectCallAsConstructorCallback callAsConstructor)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     JSValue jsPrototype = jsClass ? jsClass-&gt;prototype(globalObject) : 0;</span>
      if (!jsPrototype)
<span class="line-modified">!         jsPrototype = globalObject-&gt;objectPrototype();</span>
  
<span class="line-modified">!     JSCallbackConstructor* constructor = JSCallbackConstructor::create(globalObject, globalObject-&gt;callbackConstructorStructure(), jsClass, callAsConstructor);</span>
      constructor-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, jsPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
      return toRef(constructor);
  }
  
  JSObjectRef JSObjectMakeFunction(JSContextRef ctx, JSStringRef name, unsigned parameterCount, const JSStringRef parameterNames[], JSStringRef body, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      startingLineNumber = std::max(1, startingLineNumber);
      Identifier nameID = name ? name-&gt;identifier(&amp;vm) : Identifier::fromString(vm, &quot;anonymous&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,50 ***</span>
      for (unsigned i = 0; i &lt; parameterCount; i++)
          args.append(jsString(vm, parameterNames[i]-&gt;string()));
      args.append(jsString(vm, body-&gt;string()));
      if (UNLIKELY(args.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, exec, exception);</span>
          return 0;
      }
  
      auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
<span class="line-modified">!     JSObject* result = constructFunction(exec, exec-&gt;lexicalGlobalObject(), args, nameID, SourceOrigin { sourceURLString }, sourceURLString, TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
      return toRef(result);
  }
  
  JSObjectRef JSObjectMakeArray(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* result;
      if (argumentCount) {
          MarkedArgumentBuffer argList;
          for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!             argList.append(toJS(exec, arguments[i]));</span>
          if (UNLIKELY(argList.hasOverflowed())) {
              auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">!             handleExceptionIfNeeded(scope, exec, exception);</span>
              return 0;
          }
  
<span class="line-modified">!         result = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(0), argList);</span>
      } else
<span class="line-modified">!         result = constructEmptyArray(exec, 0);</span>
  
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
<span class="line-new-header">--- 152,50 ---</span>
      for (unsigned i = 0; i &lt; parameterCount; i++)
          args.append(jsString(vm, parameterNames[i]-&gt;string()));
      args.append(jsString(vm, body-&gt;string()));
      if (UNLIKELY(args.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, ctx, exception);</span>
          return 0;
      }
  
      auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
<span class="line-modified">!     JSObject* result = constructFunction(globalObject, args, nameID, SourceOrigin { sourceURLString }, sourceURLString, TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
      return toRef(result);
  }
  
  JSObjectRef JSObjectMakeArray(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* result;
      if (argumentCount) {
          MarkedArgumentBuffer argList;
          for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!             argList.append(toJS(globalObject, arguments[i]));</span>
          if (UNLIKELY(argList.hasOverflowed())) {
              auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">!             handleExceptionIfNeeded(scope, ctx, exception);</span>
              return 0;
          }
  
<span class="line-modified">!         result = constructArray(globalObject, static_cast&lt;ArrayAllocationProfile*&gt;(0), argList);</span>
      } else
<span class="line-modified">!         result = constructEmptyArray(globalObject, 0);</span>
  
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,27 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!         argList.append(toJS(exec, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, exec, exception);</span>
          return 0;
      }
  
<span class="line-modified">!     JSObject* result = constructDate(exec, exec-&gt;lexicalGlobalObject(), JSValue(), argList);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
<span class="line-new-header">--- 203,27 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!         argList.append(toJS(globalObject, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, ctx, exception);</span>
          return 0;
      }
  
<span class="line-modified">!     JSObject* result = constructDate(globalObject, JSValue(), argList);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,20 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSValue message = argumentCount ? toJS(exec, arguments[0]) : jsUndefined();</span>
<span class="line-modified">!     Structure* errorStructure = exec-&gt;lexicalGlobalObject()-&gt;errorStructure();</span>
<span class="line-modified">!     JSObject* result = ErrorInstance::create(exec, errorStructure, message);</span>
  
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
<span class="line-new-header">--- 231,20 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSValue message = argumentCount ? toJS(globalObject, arguments[0]) : jsUndefined();</span>
<span class="line-modified">!     Structure* errorStructure = globalObject-&gt;errorStructure();</span>
<span class="line-modified">!     JSObject* result = ErrorInstance::create(globalObject, errorStructure, message);</span>
  
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,27 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!         argList.append(toJS(exec, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, exec, exception);</span>
          return 0;
      }
  
<span class="line-modified">!     JSObject* result = constructRegExp(exec, exec-&gt;lexicalGlobalObject(), argList);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
<span class="line-new-header">--- 252,27 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!         argList.append(toJS(globalObject, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, ctx, exception);</span>
          return 0;
      }
  
<span class="line-modified">!     JSObject* result = constructRegExp(globalObject, argList);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
  
      return toRef(result);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,18 ***</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSLockHolder locker(exec);</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-modified">!     JSPromiseDeferred::DeferredData data = JSPromiseDeferred::createDeferredData(exec, globalObject, globalObject-&gt;promiseConstructor());</span>
<span class="line-removed">-     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          return nullptr;
  
      if (resolve)
          *resolve = toRef(data.resolve);
      if (reject)
<span class="line-new-header">--- 281,17 ---</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSLockHolder locker(globalObject);</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSPromise::DeferredData data = JSPromise::createDeferredData(globalObject, globalObject-&gt;promiseConstructor());</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          return nullptr;
  
      if (resolve)
          *resolve = toRef(data.resolve);
      if (reject)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,241 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     JSLockHolder locker(exec);</span>
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     return toRef(exec, jsObject-&gt;getPrototypeDirect(exec-&gt;vm()));</span>
  }
  
  void JSObjectSetPrototype(JSContextRef ctx, JSObjectRef object, JSValueRef value)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = toJS(exec, value);</span>
<span class="line-modified">!     jsObject-&gt;setPrototype(vm, exec, jsValue.isObject() ? jsValue : jsNull());</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, nullptr);</span>
  }
  
  bool JSObjectHasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     return jsObject-&gt;hasProperty(exec, propertyName-&gt;identifier(&amp;vm));</span>
  }
  
  JSValueRef JSObjectGetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
  {
<span class="line-modified">!     if (!ctx) {</span>
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     JSValue jsValue = jsObject-&gt;get(exec, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
<span class="line-modified">!     return toRef(exec, jsValue);</span>
  }
  
  void JSObjectSetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
      Identifier name(propertyName-&gt;identifier(&amp;vm));
<span class="line-modified">!     JSValue jsValue = toJS(exec, value);</span>
  
<span class="line-modified">!     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(exec, name);</span>
      if (LIKELY(!scope.exception())) {
          if (doesNotHaveProperty) {
              PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, exec, name, desc, false);</span>
          } else {
              PutPropertySlot slot(jsObject);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, exec, name, jsValue, slot);</span>
          }
      }
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
  }
  
  bool JSObjectHasPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          return false;
  
<span class="line-modified">!     bool result = jsObject-&gt;hasProperty(exec, ident);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
      return result;
  }
  
  JSValueRef JSObjectGetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          return nullptr;
  
<span class="line-modified">!     JSValue jsValue = jsObject-&gt;get(exec, ident);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
<span class="line-modified">!     return toRef(exec, jsValue);</span>
  }
  
  void JSObjectSetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = toJS(exec, value);</span>
  
<span class="line-modified">!     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          return;
  
<span class="line-modified">!     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(exec, ident);</span>
      if (LIKELY(!scope.exception())) {
          if (doesNotHaveProperty) {
              PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, exec, ident, desc, false);</span>
          } else {
              PutPropertySlot slot(jsObject);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, exec, ident, jsValue, slot);</span>
          }
      }
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
  }
  
  bool JSObjectDeletePropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          return false;
  
<span class="line-modified">!     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, exec, ident);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
      return result;
  }
  
  JSValueRef JSObjectGetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     JSValue jsValue = jsObject-&gt;get(exec, propertyIndex);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
<span class="line-modified">!     return toRef(exec, jsValue);</span>
  }
  
  
  void JSObjectSetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef value, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = toJS(exec, value);</span>
  
<span class="line-modified">!     jsObject-&gt;methodTable(vm)-&gt;putByIndex(jsObject, exec, propertyIndex, jsValue, false);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
  }
  
  bool JSObjectDeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, exec, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, exec, exception);</span>
      return result;
  }
  
  // API objects have private properties, which may get accessed during destruction. This
  // helper lets us get the ClassInfo of an API object from a function that may get called
<span class="line-new-header">--- 303,241 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     JSLockHolder locker(globalObject);</span>
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     return toRef(globalObject, jsObject-&gt;getPrototypeDirect(globalObject-&gt;vm()));</span>
  }
  
  void JSObjectSetPrototype(JSContextRef ctx, JSObjectRef object, JSValueRef value)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = toJS(globalObject, value);</span>
<span class="line-modified">!     jsObject-&gt;setPrototype(vm, globalObject, jsValue.isObject() ? jsValue : jsNull());</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, nullptr);</span>
  }
  
  bool JSObjectHasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     return jsObject-&gt;hasProperty(globalObject, propertyName-&gt;identifier(&amp;vm));</span>
  }
  
  JSValueRef JSObjectGetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
  {
<span class="line-modified">!     if (!ctx || !object) {</span>
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     JSValue jsValue = jsObject-&gt;get(globalObject, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
<span class="line-modified">!     return toRef(globalObject, jsValue);</span>
  }
  
  void JSObjectSetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
      Identifier name(propertyName-&gt;identifier(&amp;vm));
<span class="line-modified">!     JSValue jsValue = toJS(globalObject, value);</span>
  
<span class="line-modified">!     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(globalObject, name);</span>
      if (LIKELY(!scope.exception())) {
          if (doesNotHaveProperty) {
              PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, globalObject, name, desc, false);</span>
          } else {
              PutPropertySlot slot(jsObject);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, globalObject, name, jsValue, slot);</span>
          }
      }
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
  }
  
  bool JSObjectHasPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          return false;
  
<span class="line-modified">!     bool result = jsObject-&gt;hasProperty(globalObject, ident);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
      return result;
  }
  
  JSValueRef JSObjectGetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          return nullptr;
  
<span class="line-modified">!     JSValue jsValue = jsObject-&gt;get(globalObject, ident);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
<span class="line-modified">!     return toRef(globalObject, jsValue);</span>
  }
  
  void JSObjectSetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = toJS(globalObject, value);</span>
  
<span class="line-modified">!     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          return;
  
<span class="line-modified">!     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(globalObject, ident);</span>
      if (LIKELY(!scope.exception())) {
          if (doesNotHaveProperty) {
              PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, globalObject, ident, desc, false);</span>
          } else {
              PutPropertySlot slot(jsObject);
<span class="line-modified">!             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, globalObject, ident, jsValue, slot);</span>
          }
      }
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
  }
  
  bool JSObjectDeletePropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          return false;
  
<span class="line-modified">!     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, globalObject, ident);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
      return result;
  }
  
  JSValueRef JSObjectGetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     JSValue jsValue = jsObject-&gt;get(globalObject, propertyIndex);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
<span class="line-modified">!     return toRef(globalObject, jsValue);</span>
  }
  
  
  void JSObjectSetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef value, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = toJS(globalObject, value);</span>
  
<span class="line-modified">!     jsObject-&gt;methodTable(vm)-&gt;putByIndex(jsObject, globalObject, propertyIndex, jsValue, false);</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
  }
  
  bool JSObjectDeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSObject* jsObject = toJS(object);
  
<span class="line-modified">!     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, globalObject, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">!     handleExceptionIfNeeded(scope, ctx, exception);</span>
      return result;
  }
  
  // API objects have private properties, which may get accessed during destruction. This
  // helper lets us get the ClassInfo of an API object from a function that may get called
</pre>
<hr />
<pre>
<span class="line-old-header">*** 567,12 ***</span>
          classInfo = jsObject-&gt;classInfo(vm);
      }
  
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info()))
          return static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivate();
<span class="line-modified">!     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSDestructibleObject&gt;::info()))</span>
<span class="line-modified">!         return static_cast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;getPrivate();</span>
  #if JSC_OBJC_API_ENABLED
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info()))
          return static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivate();
  #endif
  
<span class="line-new-header">--- 565,12 ---</span>
          classInfo = jsObject-&gt;classInfo(vm);
      }
  
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info()))
          return static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivate();
<span class="line-modified">!     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSNonFinalObject&gt;::info()))</span>
<span class="line-modified">!         return static_cast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;getPrivate();</span>
  #if JSC_OBJC_API_ENABLED
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info()))
          return static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivate();
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 594,12 ***</span>
  
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info())) {
          static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
          return true;
      }
<span class="line-modified">!     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSDestructibleObject&gt;::info())) {</span>
<span class="line-modified">!         static_cast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);</span>
          return true;
      }
  #if JSC_OBJC_API_ENABLED
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info())) {
          static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
<span class="line-new-header">--- 592,12 ---</span>
  
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info())) {
          static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
          return true;
      }
<span class="line-modified">!     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSNonFinalObject&gt;::info())) {</span>
<span class="line-modified">!         static_cast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);</span>
          return true;
      }
  #if JSC_OBJC_API_ENABLED
      if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info())) {
          static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 610,12 ***</span>
      return false;
  }
  
  JSValueRef JSObjectGetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      JSObject* jsObject = toJS(object);
      JSValue result;
      Identifier name(propertyName-&gt;identifier(&amp;vm));
  
<span class="line-new-header">--- 608,12 ---</span>
      return false;
  }
  
  JSValueRef JSObjectGetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      JSObject* jsObject = toJS(object);
      JSValue result;
      Identifier name(propertyName-&gt;identifier(&amp;vm));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 624,38 ***</span>
      if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
          jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
  
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm))
          result = jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
<span class="line-modified">!     else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSDestructibleObject&gt;&gt;(vm))</span>
<span class="line-modified">!         result = jsCast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);</span>
  #if JSC_OBJC_API_ENABLED
      else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm))
          result = jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
  #endif
<span class="line-modified">!     return toRef(exec, result);</span>
  }
  
  bool JSObjectSetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = value ? toJS(exec, value) : JSValue();</span>
      Identifier name(propertyName-&gt;identifier(&amp;vm));
  
      // Get wrapped object if proxied
      if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
          jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
  
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
          return true;
      }
<span class="line-modified">!     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSDestructibleObject&gt;&gt;(vm)) {</span>
<span class="line-modified">!         jsCast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);</span>
          return true;
      }
  #if JSC_OBJC_API_ENABLED
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
<span class="line-new-header">--- 622,38 ---</span>
      if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
          jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
  
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm))
          result = jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
<span class="line-modified">!     else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;(vm))</span>
<span class="line-modified">!         result = jsCast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);</span>
  #if JSC_OBJC_API_ENABLED
      else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm))
          result = jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
  #endif
<span class="line-modified">!     return toRef(globalObject, result);</span>
  }
  
  bool JSObjectSetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      JSObject* jsObject = toJS(object);
<span class="line-modified">!     JSValue jsValue = value ? toJS(globalObject, value) : JSValue();</span>
      Identifier name(propertyName-&gt;identifier(&amp;vm));
  
      // Get wrapped object if proxied
      if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
          jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
  
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
          return true;
      }
<span class="line-modified">!     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;(vm)) {</span>
<span class="line-modified">!         jsCast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);</span>
          return true;
      }
  #if JSC_OBJC_API_ENABLED
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,12 ***</span>
      return false;
  }
  
  bool JSObjectDeletePrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      JSObject* jsObject = toJS(object);
      Identifier name(propertyName-&gt;identifier(&amp;vm));
  
      // Get wrapped object if proxied
<span class="line-new-header">--- 663,12 ---</span>
      return false;
  }
  
  bool JSObjectDeletePrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      JSObject* jsObject = toJS(object);
      Identifier name(propertyName-&gt;identifier(&amp;vm));
  
      // Get wrapped object if proxied
</pre>
<hr />
<pre>
<span class="line-old-header">*** 679,12 ***</span>
  
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
          return true;
      }
<span class="line-modified">!     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSDestructibleObject&gt;&gt;(vm)) {</span>
<span class="line-modified">!         jsCast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);</span>
          return true;
      }
  #if JSC_OBJC_API_ENABLED
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
<span class="line-new-header">--- 677,12 ---</span>
  
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
          return true;
      }
<span class="line-modified">!     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;(vm)) {</span>
<span class="line-modified">!         jsCast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);</span>
          return true;
      }
  #if JSC_OBJC_API_ENABLED
      if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
          jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,69 ***</span>
  
  bool JSObjectIsFunction(JSContextRef ctx, JSObjectRef object)
  {
      if (!object)
          return false;
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      CallData callData;
      JSCell* cell = toJS(object);
      return cell-&gt;methodTable(vm)-&gt;getCallData(cell, callData) != CallType::None;
  }
  
  JSValueRef JSObjectCallAsFunction(JSContextRef ctx, JSObjectRef object, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      if (!object)
          return 0;
  
      JSObject* jsObject = toJS(object);
      JSObject* jsThisObject = toJS(thisObject);
  
      if (!jsThisObject)
<span class="line-modified">!         jsThisObject = exec-&gt;globalThisValue();</span>
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">!         argList.append(toJS(exec, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, exec, exception);</span>
          return 0;
      }
  
      CallData callData;
      CallType callType = jsObject-&gt;methodTable(vm)-&gt;getCallData(jsObject, callData);
      if (callType == CallType::None)
          return 0;
  
<span class="line-modified">!     JSValueRef result = toRef(exec, profiledCall(exec, ProfilingReason::API, jsObject, callType, callData, jsThisObject, argList));</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
      return result;
  }
  
  bool JSObjectIsConstructor(JSContextRef ctx, JSObjectRef object)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      if (!object)
          return false;
      return toJS(object)-&gt;isConstructor(vm);
  }
  
  JSObjectRef JSObjectCallAsConstructor(JSContextRef ctx, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      if (!object)
          return 0;
<span class="line-new-header">--- 694,69 ---</span>
  
  bool JSObjectIsFunction(JSContextRef ctx, JSObjectRef object)
  {
      if (!object)
          return false;
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      CallData callData;
      JSCell* cell = toJS(object);
      return cell-&gt;methodTable(vm)-&gt;getCallData(cell, callData) != CallType::None;
  }
  
  JSValueRef JSObjectCallAsFunction(JSContextRef ctx, JSObjectRef object, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      if (!object)
          return 0;
  
      JSObject* jsObject = toJS(object);
      JSObject* jsThisObject = toJS(thisObject);
  
      if (!jsThisObject)
<span class="line-modified">!         jsThisObject = globalObject-&gt;globalThis();</span>
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">!         argList.append(toJS(globalObject, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, ctx, exception);</span>
          return 0;
      }
  
      CallData callData;
      CallType callType = jsObject-&gt;methodTable(vm)-&gt;getCallData(jsObject, callData);
      if (callType == CallType::None)
          return 0;
  
<span class="line-modified">!     JSValueRef result = toRef(globalObject, profiledCall(globalObject, ProfilingReason::API, jsObject, callType, callData, jsThisObject, argList));</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
      return result;
  }
  
  bool JSObjectIsConstructor(JSContextRef ctx, JSObjectRef object)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      if (!object)
          return false;
      return toJS(object)-&gt;isConstructor(vm);
  }
  
  JSObjectRef JSObjectCallAsConstructor(JSContextRef ctx, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      if (!object)
          return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 770,20 ***</span>
      if (constructType == ConstructType::None)
          return 0;
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">!         argList.append(toJS(exec, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, exec, exception);</span>
          return 0;
      }
  
<span class="line-modified">!     JSObjectRef result = toRef(profiledConstruct(exec, ProfilingReason::API, jsObject, constructType, constructData, argList));</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
      return result;
  }
  
  struct OpaqueJSPropertyNameArray {
<span class="line-new-header">--- 768,20 ---</span>
      if (constructType == ConstructType::None)
          return 0;
  
      MarkedArgumentBuffer argList;
      for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">!         argList.append(toJS(globalObject, arguments[i]));</span>
      if (UNLIKELY(argList.hasOverflowed())) {
          auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">!         handleExceptionIfNeeded(scope, ctx, exception);</span>
          return 0;
      }
  
<span class="line-modified">!     JSObjectRef result = toRef(profiledConstruct(globalObject, ProfilingReason::API, jsObject, constructType, constructData, argList));</span>
<span class="line-modified">!     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
          result = 0;
      return result;
  }
  
  struct OpaqueJSPropertyNameArray {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,19 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     JSLockHolder locker(exec);</span>
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      JSObject* jsObject = toJS(object);
      JSPropertyNameArrayRef propertyNames = new OpaqueJSPropertyNameArray(&amp;vm);
      PropertyNameArray array(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     jsObject-&gt;methodTable(vm)-&gt;getPropertyNames(jsObject, exec, array, EnumerationMode());</span>
  
      size_t size = array.size();
      propertyNames-&gt;array.reserveInitialCapacity(size);
      for (size_t i = 0; i &lt; size; ++i)
          propertyNames-&gt;array.uncheckedAppend(OpaqueJSString::tryCreate(array[i].string()).releaseNonNull());
<span class="line-new-header">--- 803,19 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     JSLockHolder locker(globalObject);</span>
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      JSObject* jsObject = toJS(object);
      JSPropertyNameArrayRef propertyNames = new OpaqueJSPropertyNameArray(&amp;vm);
      PropertyNameArray array(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     jsObject-&gt;methodTable(vm)-&gt;getPropertyNames(jsObject, globalObject, array, EnumerationMode());</span>
  
      size_t size = array.size();
      propertyNames-&gt;array.reserveInitialCapacity(size);
      for (size_t i = 0; i &lt; size; ++i)
          propertyNames-&gt;array.uncheckedAppend(OpaqueJSString::tryCreate(array[i].string()).releaseNonNull());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 875,8 ***</span>
  JSGlobalContextRef JSObjectGetGlobalContext(JSObjectRef objectRef)
  {
      JSObject* object = toJS(objectRef);
      if (!object)
          return nullptr;
<span class="line-modified">!     return reinterpret_cast&lt;JSGlobalContextRef&gt;(object-&gt;globalObject()-&gt;globalExec());</span>
  }
  
<span class="line-new-header">--- 873,8 ---</span>
  JSGlobalContextRef JSObjectGetGlobalContext(JSObjectRef objectRef)
  {
      JSObject* object = toJS(objectRef);
      if (!object)
          return nullptr;
<span class="line-modified">!     return reinterpret_cast&lt;JSGlobalContextRef&gt;(object-&gt;globalObject());</span>
  }
  
</pre>
<center><a href="JSHeapFinalizerPrivate.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScriptRef.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
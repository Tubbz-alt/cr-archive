<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2014 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2016 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSParserImpl.h&quot;
 32 
 33 #include &quot;CSSAtRuleID.h&quot;
 34 #include &quot;CSSCustomPropertyValue.h&quot;
 35 #include &quot;CSSDeferredParser.h&quot;
 36 #include &quot;CSSKeyframeRule.h&quot;
 37 #include &quot;CSSKeyframesRule.h&quot;
 38 #include &quot;CSSParserObserver.h&quot;
 39 #include &quot;CSSParserObserverWrapper.h&quot;
 40 #include &quot;CSSParserSelector.h&quot;
 41 #include &quot;CSSPropertyParser.h&quot;
 42 #include &quot;CSSSelectorParser.h&quot;
 43 #include &quot;CSSStyleSheet.h&quot;
 44 #include &quot;CSSSupportsParser.h&quot;
 45 #include &quot;CSSTokenizer.h&quot;
 46 #include &quot;CSSVariableParser.h&quot;
 47 #include &quot;Document.h&quot;
 48 #include &quot;Element.h&quot;
 49 #include &quot;MediaList.h&quot;
 50 #include &quot;MediaQueryParser.h&quot;
 51 #include &quot;MediaQueryParserContext.h&quot;
 52 #include &quot;StyleProperties.h&quot;
 53 #include &quot;StyleRuleImport.h&quot;
 54 #include &quot;StyleSheetContents.h&quot;
 55 
 56 #include &lt;bitset&gt;
 57 #include &lt;memory&gt;
 58 
 59 namespace WebCore {
 60 
 61 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
 62     : m_context(context)
 63     , m_styleSheet(styleSheet)
 64 {
 65 
 66 }
 67 
 68 CSSParserImpl::CSSParserImpl(CSSDeferredParser&amp; deferredParser)
 69     : m_context(deferredParser.context())
 70     , m_styleSheet(deferredParser.styleSheet())
 71     , m_deferredParser(&amp;deferredParser)
 72 {
 73 }
 74 
 75 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, const String&amp; string, StyleSheetContents* styleSheet, CSSParserObserverWrapper* wrapper, CSSParser::RuleParsing ruleParsing)
 76     : m_context(context)
 77     , m_styleSheet(styleSheet)
 78     , m_observerWrapper(wrapper)
 79 {
 80     m_tokenizer = wrapper ? makeUnique&lt;CSSTokenizer&gt;(string, *wrapper) : makeUnique&lt;CSSTokenizer&gt;(string);
 81     if (context.deferredCSSParserEnabled &amp;&amp; !wrapper &amp;&amp; styleSheet &amp;&amp; ruleParsing == CSSParser::RuleParsing::Deferred)
 82         m_deferredParser = CSSDeferredParser::create(context, string, *styleSheet);
 83 }
 84 
 85 CSSParser::ParseResult CSSParserImpl::parseValue(MutableStyleProperties* declaration, CSSPropertyID propertyID, const String&amp; string, bool important, const CSSParserContext&amp; context)
 86 {
 87     CSSParserImpl parser(context, string);
<a name="1" id="anc1"></a><span class="line-modified"> 88     auto ruleType = context.enclosingRuleType.valueOr(StyleRuleType::Style);</span>




 89     parser.consumeDeclarationValue(parser.tokenizer()-&gt;tokenRange(), propertyID, important, ruleType);
 90     if (parser.m_parsedProperties.isEmpty())
 91         return CSSParser::ParseResult::Error;
 92     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
 93 }
 94 
 95 CSSParser::ParseResult CSSParserImpl::parseCustomPropertyValue(MutableStyleProperties* declaration, const AtomString&amp; propertyName, const String&amp; string, bool important, const CSSParserContext&amp; context)
 96 {
 97     CSSParserImpl parser(context, string);
 98     parser.consumeCustomPropertyValue(parser.tokenizer()-&gt;tokenRange(), propertyName, important);
 99     if (parser.m_parsedProperties.isEmpty())
100         return CSSParser::ParseResult::Error;
101     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
102 }
103 
104 static inline void filterProperties(bool important, const ParsedPropertyVector&amp; input, ParsedPropertyVector&amp; output, size_t&amp; unusedEntries, std::bitset&lt;numCSSProperties&gt;&amp; seenProperties, HashSet&lt;AtomString&gt;&amp; seenCustomProperties)
105 {
106     // Add properties in reverse order so that highest priority definitions are reached first. Duplicate definitions can then be ignored when found.
107     for (size_t i = input.size(); i--; ) {
108         const CSSProperty&amp; property = input[i];
109         if (property.isImportant() != important)
110             continue;
111         const unsigned propertyIDIndex = property.id() - firstCSSProperty;
112 
113         if (property.id() == CSSPropertyCustom) {
114             auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name();
115             if (!seenCustomProperties.add(name).isNewEntry)
116                 continue;
117             output[--unusedEntries] = property;
118             continue;
119         }
120 
121         // FIXME-NEWPARSER: We won&#39;t support @apply yet.
122         /*else if (property.id() == CSSPropertyApplyAtRule) {
123          // FIXME: Do we need to do anything here?
124          } */
125 
126         if (seenProperties.test(propertyIDIndex))
127             continue;
128         seenProperties.set(propertyIDIndex);
129 
130         output[--unusedEntries] = property;
131     }
132 }
133 
134 Ref&lt;DeferredStyleProperties&gt; CSSParserImpl::createDeferredStyleProperties(const CSSParserTokenRange&amp; propertyRange)
135 {
136     ASSERT(m_deferredParser);
137     return DeferredStyleProperties::create(propertyRange, *m_deferredParser);
138 }
139 
140 static Ref&lt;ImmutableStyleProperties&gt; createStyleProperties(ParsedPropertyVector&amp; parsedProperties, CSSParserMode mode)
141 {
142     std::bitset&lt;numCSSProperties&gt; seenProperties;
143     size_t unusedEntries = parsedProperties.size();
144     ParsedPropertyVector results(unusedEntries);
145     HashSet&lt;AtomString&gt; seenCustomProperties;
146 
147     filterProperties(true, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
148     filterProperties(false, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
149 
150     Ref&lt;ImmutableStyleProperties&gt; result = ImmutableStyleProperties::create(results.data() + unusedEntries, results.size() - unusedEntries, mode);
151     parsedProperties.clear();
152     return result;
153 }
154 
155 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
156 {
157     CSSParserContext context(element-&gt;document());
158     context.mode = strictToCSSParserMode(element-&gt;isHTMLElement() &amp;&amp; !element-&gt;document().inQuirksMode());
159 
160     CSSParserImpl parser(context, string);
<a name="2" id="anc2"></a><span class="line-modified">161     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRuleType::Style);</span>
162     return createStyleProperties(parser.m_parsedProperties, context.mode);
163 }
164 
165 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseDeferredDeclaration(CSSParserTokenRange tokenRange, const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
166 {
167     if (!styleSheet) {
168         ParsedPropertyVector properties;
169         return createStyleProperties(properties, context.mode);
170     }
171     CSSParserImpl parser(context, styleSheet);
<a name="3" id="anc3"></a><span class="line-modified">172     parser.consumeDeclarationList(tokenRange, StyleRuleType::Style);</span>
173     return createStyleProperties(parser.m_parsedProperties, context.mode);
174 }
175 
176 void CSSParserImpl::parseDeferredRuleList(CSSParserTokenRange tokenRange, CSSDeferredParser&amp; deferredParser, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
177 {
178     if (!deferredParser.styleSheet())
179         return;
180     CSSParserImpl parser(deferredParser);
181     parser.consumeRuleList(tokenRange, RegularRuleList, [&amp;childRules](const RefPtr&lt;StyleRuleBase&gt;&amp; rule) {
182         childRules.append(rule);
183     });
184     childRules.shrinkToFit();
185 }
186 
187 void CSSParserImpl::parseDeferredKeyframeList(CSSParserTokenRange tokenRange, CSSDeferredParser&amp; deferredParser, StyleRuleKeyframes&amp; keyframeRule)
188 {
189     if (!deferredParser.styleSheet())
190         return;
191     CSSParserImpl parser(deferredParser);
192     parser.consumeRuleList(tokenRange, KeyframesRuleList, [&amp;keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
193         keyframeRule.parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
194     });
195 }
196 
197 bool CSSParserImpl::parseDeclarationList(MutableStyleProperties* declaration, const String&amp; string, const CSSParserContext&amp; context)
198 {
199     CSSParserImpl parser(context, string);
<a name="4" id="anc4"></a><span class="line-modified">200     auto ruleType = context.enclosingRuleType.valueOr(StyleRuleType::Style);</span>




201     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), ruleType);
202     if (parser.m_parsedProperties.isEmpty())
203         return false;
204 
205     std::bitset&lt;numCSSProperties&gt; seenProperties;
206     size_t unusedEntries = parser.m_parsedProperties.size();
207     ParsedPropertyVector results(unusedEntries);
208     HashSet&lt;AtomString&gt; seenCustomProperties;
209     filterProperties(true, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
210     filterProperties(false, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
211     if (unusedEntries)
212         results.remove(0, unusedEntries);
213     return declaration-&gt;addParsedProperties(results);
214 }
215 
216 RefPtr&lt;StyleRuleBase&gt; CSSParserImpl::parseRule(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, AllowedRulesType allowedRules)
217 {
218     CSSParserImpl parser(context, string, styleSheet);
219     CSSParserTokenRange range = parser.tokenizer()-&gt;tokenRange();
220     range.consumeWhitespace();
221     if (range.atEnd())
222         return nullptr; // Parse error, empty rule
223     RefPtr&lt;StyleRuleBase&gt; rule;
224     if (range.peek().type() == AtKeywordToken)
225         rule = parser.consumeAtRule(range, allowedRules);
226     else
227         rule = parser.consumeQualifiedRule(range, allowedRules);
228     if (!rule)
229         return nullptr; // Parse error, failed to consume rule
230     range.consumeWhitespace();
231     if (!rule || !range.atEnd())
232         return nullptr; // Parse error, trailing garbage
233     return rule;
234 }
235 
236 void CSSParserImpl::parseStyleSheet(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, CSSParser::RuleParsing ruleParsing)
237 {
238     CSSParserImpl parser(context, string, styleSheet, nullptr, ruleParsing);
239     bool firstRuleValid = parser.consumeRuleList(parser.tokenizer()-&gt;tokenRange(), TopLevelRuleList, [&amp;styleSheet](RefPtr&lt;StyleRuleBase&gt; rule) {
240         if (rule-&gt;isCharsetRule())
241             return;
242         styleSheet-&gt;parserAppendRule(rule.releaseNonNull());
243     });
244     styleSheet-&gt;setHasSyntacticallyValidCSSHeader(firstRuleValid);
245     parser.adoptTokenizerEscapedStrings();
246 }
247 
248 void CSSParserImpl::adoptTokenizerEscapedStrings()
249 {
250     if (!m_deferredParser || !m_tokenizer)
251         return;
252     m_deferredParser-&gt;adoptTokenizerEscapedStrings(m_tokenizer-&gt;escapedStringsForAdoption());
253 }
254 
255 CSSSelectorList CSSParserImpl::parsePageSelector(CSSParserTokenRange range, StyleSheetContents* styleSheet)
256 {
257     // We only support a small subset of the css-page spec.
258     range.consumeWhitespace();
259     AtomString typeSelector;
260     if (range.peek().type() == IdentToken)
261         typeSelector = range.consume().value().toAtomString();
262 
263     StringView pseudo;
264     if (range.peek().type() == ColonToken) {
265         range.consume();
266         if (range.peek().type() != IdentToken)
267             return CSSSelectorList();
268         pseudo = range.consume().value();
269     }
270 
271     range.consumeWhitespace();
272     if (!range.atEnd())
273         return CSSSelectorList(); // Parse error; extra tokens in @page selector
274 
275     std::unique_ptr&lt;CSSParserSelector&gt; selector;
276     if (!typeSelector.isNull() &amp;&amp; pseudo.isNull())
277         selector = makeUnique&lt;CSSParserSelector&gt;(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));
278     else {
279         selector = makeUnique&lt;CSSParserSelector&gt;();
280         if (!pseudo.isNull()) {
281             selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePagePseudoSelector(pseudo));
282             if (!selector || selector-&gt;match() != CSSSelector::PagePseudoClass)
283                 return CSSSelectorList();
284         }
285         if (!typeSelector.isNull())
286             selector-&gt;prependTagSelector(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));
287     }
288 
289     selector-&gt;setForPage();
290     return CSSSelectorList { Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(selector)) };
291 }
292 
293 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::parseKeyframeKeyList(const String&amp; keyList)
294 {
295     return consumeKeyframeKeyList(CSSTokenizer(keyList).tokenRange());
296 }
297 
298 bool CSSParserImpl::supportsDeclaration(CSSParserTokenRange&amp; range)
299 {
300     ASSERT(m_parsedProperties.isEmpty());
<a name="5" id="anc5"></a><span class="line-modified">301     consumeDeclaration(range, StyleRuleType::Style);</span>
302     bool result = !m_parsedProperties.isEmpty();
303     m_parsedProperties.clear();
304     return result;
305 }
306 
307 void CSSParserImpl::parseDeclarationListForInspector(const String&amp; declaration, const CSSParserContext&amp; context, CSSParserObserver&amp; observer)
308 {
309     CSSParserObserverWrapper wrapper(observer);
310     CSSParserImpl parser(context, declaration, nullptr, &amp;wrapper);
<a name="6" id="anc6"></a><span class="line-modified">311     observer.startRuleHeader(StyleRuleType::Style, 0);</span>
312     observer.endRuleHeader(1);
<a name="7" id="anc7"></a><span class="line-modified">313     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRuleType::Style);</span>
314 }
315 
316 void CSSParserImpl::parseStyleSheetForInspector(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, CSSParserObserver&amp; observer)
317 {
318     CSSParserObserverWrapper wrapper(observer);
319     CSSParserImpl parser(context, string, styleSheet, &amp;wrapper);
320     bool firstRuleValid = parser.consumeRuleList(parser.tokenizer()-&gt;tokenRange(), TopLevelRuleList, [&amp;styleSheet](RefPtr&lt;StyleRuleBase&gt; rule) {
321         if (rule-&gt;isCharsetRule())
322             return;
323         styleSheet-&gt;parserAppendRule(rule.releaseNonNull());
324     });
325     styleSheet-&gt;setHasSyntacticallyValidCSSHeader(firstRuleValid);
326 }
327 
328 static CSSParserImpl::AllowedRulesType computeNewAllowedRules(CSSParserImpl::AllowedRulesType allowedRules, StyleRuleBase* rule)
329 {
330     if (!rule || allowedRules == CSSParserImpl::KeyframeRules || allowedRules == CSSParserImpl::NoRules)
331         return allowedRules;
332     ASSERT(allowedRules &lt;= CSSParserImpl::RegularRules);
333     if (rule-&gt;isCharsetRule() || rule-&gt;isImportRule())
334         return CSSParserImpl::AllowImportRules;
335     if (rule-&gt;isNamespaceRule())
336         return CSSParserImpl::AllowNamespaceRules;
337     return CSSParserImpl::RegularRules;
338 }
339 
340 template&lt;typename T&gt;
341 bool CSSParserImpl::consumeRuleList(CSSParserTokenRange range, RuleListType ruleListType, const T callback)
342 {
343     AllowedRulesType allowedRules = RegularRules;
344     switch (ruleListType) {
345     case TopLevelRuleList:
346         allowedRules = AllowCharsetRules;
347         break;
348     case RegularRuleList:
349         allowedRules = RegularRules;
350         break;
351     case KeyframesRuleList:
352         allowedRules = KeyframeRules;
353         break;
354     default:
355         ASSERT_NOT_REACHED();
356     }
357 
358     bool seenRule = false;
359     bool firstRuleValid = false;
360     while (!range.atEnd()) {
361         RefPtr&lt;StyleRuleBase&gt; rule;
362         switch (range.peek().type()) {
363         case WhitespaceToken:
364             range.consumeWhitespace();
365             continue;
366         case AtKeywordToken:
367             rule = consumeAtRule(range, allowedRules);
368             break;
369         case CDOToken:
370         case CDCToken:
371             if (ruleListType == TopLevelRuleList) {
372                 range.consume();
373                 continue;
374             }
375             FALLTHROUGH;
376         default:
377             rule = consumeQualifiedRule(range, allowedRules);
378             break;
379         }
380         if (!seenRule) {
381             seenRule = true;
382             firstRuleValid = rule;
383         }
384         if (rule) {
385             allowedRules = computeNewAllowedRules(allowedRules, rule.get());
386             callback(rule);
387         }
388     }
389 
390     return firstRuleValid;
391 }
392 
393 RefPtr&lt;StyleRuleBase&gt; CSSParserImpl::consumeAtRule(CSSParserTokenRange&amp; range, AllowedRulesType allowedRules)
394 {
395     ASSERT(range.peek().type() == AtKeywordToken);
396     const StringView name = range.consumeIncludingWhitespace().value();
397     const CSSParserToken* preludeStart = &amp;range.peek();
398     while (!range.atEnd() &amp;&amp; range.peek().type() != LeftBraceToken &amp;&amp; range.peek().type() != SemicolonToken)
399         range.consumeComponentValue();
400 
401     CSSParserTokenRange prelude = range.makeSubRange(preludeStart, &amp;range.peek());
402     CSSAtRuleID id = cssAtRuleID(name);
403 
404     if (range.atEnd() || range.peek().type() == SemicolonToken) {
405         range.consume();
406         if (allowedRules == AllowCharsetRules &amp;&amp; id == CSSAtRuleCharset)
407             return consumeCharsetRule(prelude);
408         if (allowedRules &lt;= AllowImportRules &amp;&amp; id == CSSAtRuleImport)
409             return consumeImportRule(prelude);
410         if (allowedRules &lt;= AllowNamespaceRules &amp;&amp; id == CSSAtRuleNamespace)
411             return consumeNamespaceRule(prelude);
412         // FIXME-NEWPARSER: Support &quot;apply&quot;
413         /*if (allowedRules == ApplyRules &amp;&amp; id == CSSAtRuleApply) {
414             consumeApplyRule(prelude);
415             return nullptr; // consumeApplyRule just updates m_parsedProperties
416         }*/
417         return nullptr; // Parse error, unrecognised at-rule without block
418     }
419 
420     CSSParserTokenRange block = range.consumeBlock();
421     if (allowedRules == KeyframeRules)
422         return nullptr; // Parse error, no at-rules supported inside @keyframes
423     if (allowedRules == NoRules || allowedRules == ApplyRules)
424         return nullptr; // Parse error, no at-rules with blocks supported inside declaration lists
425 
426     ASSERT(allowedRules &lt;= RegularRules);
427 
428     switch (id) {
429     case CSSAtRuleMedia:
430         return consumeMediaRule(prelude, block);
431     case CSSAtRuleSupports:
432         return consumeSupportsRule(prelude, block);
433 #if ENABLE(CSS_DEVICE_ADAPTATION)
434     case CSSAtRuleViewport:
435         return consumeViewportRule(prelude, block);
436 #endif
437     case CSSAtRuleFontFace:
438         return consumeFontFaceRule(prelude, block);
439     case CSSAtRuleWebkitKeyframes:
440         return consumeKeyframesRule(true, prelude, block);
441     case CSSAtRuleKeyframes:
442         return consumeKeyframesRule(false, prelude, block);
443     case CSSAtRulePage:
444         return consumePageRule(prelude, block);
445     default:
446         return nullptr; // Parse error, unrecognised at-rule with block
447     }
448 }
449 
450 RefPtr&lt;StyleRuleBase&gt; CSSParserImpl::consumeQualifiedRule(CSSParserTokenRange&amp; range, AllowedRulesType allowedRules)
451 {
452     const CSSParserToken* preludeStart = &amp;range.peek();
453     while (!range.atEnd() &amp;&amp; range.peek().type() != LeftBraceToken)
454         range.consumeComponentValue();
455 
456     if (range.atEnd())
457         return nullptr; // Parse error, EOF instead of qualified rule block
458 
459     CSSParserTokenRange prelude = range.makeSubRange(preludeStart, &amp;range.peek());
460     CSSParserTokenRange block = range.consumeBlockCheckingForEditability(m_styleSheet.get());
461 
462     if (allowedRules &lt;= RegularRules)
463         return consumeStyleRule(prelude, block);
464     if (allowedRules == KeyframeRules)
465         return consumeKeyframeStyleRule(prelude, block);
466 
467     ASSERT_NOT_REACHED();
468     return nullptr;
469 }
470 
471 // This may still consume tokens if it fails
472 static AtomString consumeStringOrURI(CSSParserTokenRange&amp; range)
473 {
474     const CSSParserToken&amp; token = range.peek();
475 
476     if (token.type() == StringToken || token.type() == UrlToken)
477         return range.consumeIncludingWhitespace().value().toAtomString();
478 
479     if (token.type() != FunctionToken || !equalIgnoringASCIICase(token.value(), &quot;url&quot;))
480         return AtomString();
481 
482     CSSParserTokenRange contents = range.consumeBlock();
483     const CSSParserToken&amp; uri = contents.consumeIncludingWhitespace();
484     if (uri.type() == BadStringToken || !contents.atEnd())
485         return AtomString();
486     return uri.value().toAtomString();
487 }
488 
489 RefPtr&lt;StyleRuleCharset&gt; CSSParserImpl::consumeCharsetRule(CSSParserTokenRange prelude)
490 {
491     const CSSParserToken&amp; string = prelude.consumeIncludingWhitespace();
492     if (string.type() != StringToken || !prelude.atEnd())
493         return nullptr; // Parse error, expected a single string
494     return StyleRuleCharset::create();
495 }
496 
497 RefPtr&lt;StyleRuleImport&gt; CSSParserImpl::consumeImportRule(CSSParserTokenRange prelude)
498 {
499     AtomString uri(consumeStringOrURI(prelude));
500     if (uri.isNull())
501         return nullptr; // Parse error, expected string or URI
502 
503     if (m_observerWrapper) {
504         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<a name="8" id="anc8"></a><span class="line-modified">505         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Import, m_observerWrapper-&gt;startOffset(prelude));</span>
506         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
507         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
508         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
509     }
510 
511     return StyleRuleImport::create(uri, MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull());
512 }
513 
514 RefPtr&lt;StyleRuleNamespace&gt; CSSParserImpl::consumeNamespaceRule(CSSParserTokenRange prelude)
515 {
516     AtomString namespacePrefix;
517     if (prelude.peek().type() == IdentToken)
518         namespacePrefix = prelude.consumeIncludingWhitespace().value().toAtomString();
519 
520     AtomString uri(consumeStringOrURI(prelude));
521     if (uri.isNull() || !prelude.atEnd())
522         return nullptr; // Parse error, expected string or URI
523 
524     return StyleRuleNamespace::create(namespacePrefix, uri);
525 }
526 
527 RefPtr&lt;StyleRuleMedia&gt; CSSParserImpl::consumeMediaRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
528 {
529     if (m_deferredParser)
530         return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(),  makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
531 
532     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
533 
534     if (m_observerWrapper) {
<a name="9" id="anc9"></a><span class="line-modified">535         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Media, m_observerWrapper-&gt;startOffset(prelude));</span>
536         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
537         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
538     }
539 
540     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
541         rules.append(rule);
542     });
543     rules.shrinkToFit();
544 
545     if (m_observerWrapper)
546         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
547 
548     return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(), rules);
549 }
550 
551 RefPtr&lt;StyleRuleSupports&gt; CSSParserImpl::consumeSupportsRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
552 {
553     CSSSupportsParser::SupportsResult supported = CSSSupportsParser::supportsCondition(prelude, *this, CSSSupportsParser::ForAtRule);
554     if (supported == CSSSupportsParser::Invalid)
555         return nullptr; // Parse error, invalid @supports condition
556 
557     if (m_deferredParser)
558         return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
559 
560     if (m_observerWrapper) {
<a name="10" id="anc10"></a><span class="line-modified">561         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Supports, m_observerWrapper-&gt;startOffset(prelude));</span>
562         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
563         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
564     }
565 
566     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
567     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
568         rules.append(rule);
569     });
570     rules.shrinkToFit();
571 
572     if (m_observerWrapper)
573         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
574 
575     return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, rules);
576 }
577 
578 #if ENABLE(CSS_DEVICE_ADAPTATION)
579 RefPtr&lt;StyleRuleViewport&gt; CSSParserImpl::consumeViewportRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
580 {
581     if (!prelude.atEnd())
582         return nullptr; // Parser error; @viewport prelude should be empty
583 
584     if (m_observerWrapper) {
585         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<a name="11" id="anc11"></a><span class="line-modified">586         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Viewport, m_observerWrapper-&gt;startOffset(prelude));</span>
587         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
588         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
589         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
590     }
591 
592     consumeDeclarationList(block, StyleRule::Viewport);
593     return StyleRuleViewport::create(createStyleProperties(m_parsedProperties, CSSViewportRuleMode));
594 }
595 #endif
596 
597 RefPtr&lt;StyleRuleFontFace&gt; CSSParserImpl::consumeFontFaceRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
598 {
599     if (!prelude.atEnd())
600         return nullptr; // Parse error; @font-face prelude should be empty
601 
602     if (m_observerWrapper) {
603         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<a name="12" id="anc12"></a><span class="line-modified">604         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::FontFace, m_observerWrapper-&gt;startOffset(prelude));</span>
605         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
606         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
607         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
608     }
609 
<a name="13" id="anc13"></a><span class="line-modified">610     consumeDeclarationList(block, StyleRuleType::FontFace);</span>
611     return StyleRuleFontFace::create(createStyleProperties(m_parsedProperties, m_context.mode));
612 }
613 
614 RefPtr&lt;StyleRuleKeyframes&gt; CSSParserImpl::consumeKeyframesRule(bool webkitPrefixed, CSSParserTokenRange prelude, CSSParserTokenRange block)
615 {
616     CSSParserTokenRange rangeCopy = prelude; // For inspector callbacks
617     const CSSParserToken&amp; nameToken = prelude.consumeIncludingWhitespace();
618     if (!prelude.atEnd())
619         return nullptr; // Parse error; expected single non-whitespace token in @keyframes header
620 
621     String name;
622     if (nameToken.type() == IdentToken) {
623         name = nameToken.value().toString();
624     } else if (nameToken.type() == StringToken &amp;&amp; webkitPrefixed)
625         name = nameToken.value().toString();
626     else
627         return nullptr; // Parse error; expected ident token in @keyframes header
628 
629     if (m_deferredParser)
630         return StyleRuleKeyframes::create(name, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
631 
632     if (m_observerWrapper) {
<a name="14" id="anc14"></a><span class="line-modified">633         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Keyframes, m_observerWrapper-&gt;startOffset(rangeCopy));</span>
634         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
635         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
636         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
637     }
638 
639     RefPtr&lt;StyleRuleKeyframes&gt; keyframeRule = StyleRuleKeyframes::create(name);
640     consumeRuleList(block, KeyframesRuleList, [keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
641         keyframeRule-&gt;parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
642     });
643 
644     // FIXME-NEWPARSER: Find out why this is done. Behavior difference when prefixed?
645     // keyframeRule-&gt;setVendorPrefixed(webkitPrefixed);
646     return keyframeRule;
647 }
648 
649 RefPtr&lt;StyleRulePage&gt; CSSParserImpl::consumePageRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
650 {
651     CSSSelectorList selectorList = parsePageSelector(prelude, m_styleSheet.get());
652     if (!selectorList.isValid())
653         return nullptr; // Parse error, invalid @page selector
654 
655     if (m_observerWrapper) {
656         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<a name="15" id="anc15"></a><span class="line-modified">657         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Page, m_observerWrapper-&gt;startOffset(prelude));</span>
658         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
659     }
660 
<a name="16" id="anc16"></a><span class="line-modified">661     consumeDeclarationList(block, StyleRuleType::Style);</span>
662 
663     return StyleRulePage::create(createStyleProperties(m_parsedProperties, m_context.mode), WTFMove(selectorList));
664 }
665 
666 // FIXME-NEWPARSER: Support &quot;apply&quot;
667 /*void CSSParserImpl::consumeApplyRule(CSSParserTokenRange prelude)
668 {
669     const CSSParserToken&amp; ident = prelude.consumeIncludingWhitespace();
670     if (!prelude.atEnd() || !CSSVariableParser::isValidVariableName(ident))
671         return; // Parse error, expected a single custom property name
672     m_parsedProperties.append(CSSProperty(
673         CSSPropertyApplyAtRule,
674         *CSSCustomIdentValue::create(ident.value().toString())));
675 }
676 */
677 
678 RefPtr&lt;StyleRuleKeyframe&gt; CSSParserImpl::consumeKeyframeStyleRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
679 {
680     std::unique_ptr&lt;Vector&lt;double&gt;&gt; keyList = consumeKeyframeKeyList(prelude);
681     if (!keyList)
682         return nullptr;
683 
684     if (m_observerWrapper) {
<a name="17" id="anc17"></a><span class="line-modified">685         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Keyframe, m_observerWrapper-&gt;startOffset(prelude));</span>
686         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
687     }
688 
<a name="18" id="anc18"></a><span class="line-modified">689     consumeDeclarationList(block, StyleRuleType::Keyframe);</span>
690     return StyleRuleKeyframe::create(WTFMove(keyList), createStyleProperties(m_parsedProperties, m_context.mode));
691 }
692 
693 static void observeSelectors(CSSParserObserverWrapper&amp; wrapper, CSSParserTokenRange selectors)
694 {
695     // This is easier than hooking into the CSSSelectorParser
696     selectors.consumeWhitespace();
697     CSSParserTokenRange originalRange = selectors;
<a name="19" id="anc19"></a><span class="line-modified">698     wrapper.observer().startRuleHeader(StyleRuleType::Style, wrapper.startOffset(originalRange));</span>
699 
700     while (!selectors.atEnd()) {
701         const CSSParserToken* selectorStart = &amp;selectors.peek();
702         while (!selectors.atEnd() &amp;&amp; selectors.peek().type() != CommaToken)
703             selectors.consumeComponentValue();
704         CSSParserTokenRange selector = selectors.makeSubRange(selectorStart, &amp;selectors.peek());
705         selectors.consumeIncludingWhitespace();
706 
707         wrapper.observer().observeSelector(wrapper.startOffset(selector), wrapper.endOffset(selector));
708     }
709 
710     wrapper.observer().endRuleHeader(wrapper.endOffset(originalRange));
711 }
712 
713 RefPtr&lt;StyleRule&gt; CSSParserImpl::consumeStyleRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
714 {
715     CSSSelectorList selectorList = CSSSelectorParser::parseSelector(prelude, m_context, m_styleSheet.get());
716     if (!selectorList.isValid())
717         return nullptr; // Parse error, invalid selector list
718 
719     if (m_observerWrapper)
720         observeSelectors(*m_observerWrapper, prelude);
721 
722     if (m_deferredParser) {
723         // If a rule is empty (i.e., only whitespace), don&#39;t bother using
724         // deferred parsing. This allows the empty rule optimization in ElementRuleCollector
725         // to continue to work. Note we don&#39;t have to consider CommentTokens, since those
726         // are stripped out.
727         CSSParserTokenRange blockCopy = block;
728         blockCopy.consumeWhitespace();
729         if (!blockCopy.atEnd()) {
730             return StyleRule::create(createDeferredStyleProperties(block), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
731         }
732     }
733 
<a name="20" id="anc20"></a><span class="line-modified">734     consumeDeclarationList(block, StyleRuleType::Style);</span>
735     return StyleRule::create(createStyleProperties(m_parsedProperties, m_context.mode), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
736 }
737 
<a name="21" id="anc21"></a><span class="line-modified">738 void CSSParserImpl::consumeDeclarationList(CSSParserTokenRange range, StyleRuleType ruleType)</span>
739 {
740     ASSERT(m_parsedProperties.isEmpty());
741 
<a name="22" id="anc22"></a><span class="line-modified">742     bool useObserver = m_observerWrapper &amp;&amp; (ruleType == StyleRuleType::Style || ruleType == StyleRuleType::Keyframe);</span>
743     if (useObserver) {
744         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(range));
745         m_observerWrapper-&gt;skipCommentsBefore(range, true);
746     }
747 
748     while (!range.atEnd()) {
749         switch (range.peek().type()) {
750         case WhitespaceToken:
751         case SemicolonToken:
752             range.consume();
753             break;
754         case IdentToken: {
755             const CSSParserToken* declarationStart = &amp;range.peek();
756 
757             if (useObserver)
758                 m_observerWrapper-&gt;yieldCommentsBefore(range);
759 
760             while (!range.atEnd() &amp;&amp; range.peek().type() != SemicolonToken)
761                 range.consumeComponentValue();
762 
763             consumeDeclaration(range.makeSubRange(declarationStart, &amp;range.peek()), ruleType);
764 
765             if (useObserver)
766                 m_observerWrapper-&gt;skipCommentsBefore(range, false);
767             break;
768         }
769         case AtKeywordToken: {
770             // FIXME-NEWPARSER: Support apply
<a name="23" id="anc23"></a><span class="line-modified">771             AllowedRulesType allowedRules = /* ruleType == StyleRuleType::Style &amp;&amp; RuntimeEnabledFeatures::cssApplyAtRulesEnabled() ? ApplyRules :*/ NoRules;</span>
772             RefPtr&lt;StyleRuleBase&gt; rule = consumeAtRule(range, allowedRules);
773             ASSERT_UNUSED(rule, !rule);
774             break;
775         }
776         default: // Parse error, unexpected token in declaration list
777             while (!range.atEnd() &amp;&amp; range.peek().type() != SemicolonToken)
778                 range.consumeComponentValue();
779             break;
780         }
781     }
782 
783     // Yield remaining comments
784     if (useObserver) {
785         m_observerWrapper-&gt;yieldCommentsBefore(range);
786         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(range));
787     }
788 }
789 
<a name="24" id="anc24"></a><span class="line-modified">790 void CSSParserImpl::consumeDeclaration(CSSParserTokenRange range, StyleRuleType ruleType)</span>
791 {
792     CSSParserTokenRange rangeCopy = range; // For inspector callbacks
793 
794     ASSERT(range.peek().type() == IdentToken);
795     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
796     CSSPropertyID propertyID = token.parseAsCSSPropertyID();
797     if (range.consume().type() != ColonToken)
798         return; // Parse error
799 
800     bool important = false;
801     const CSSParserToken* declarationValueEnd = range.end();
802     const CSSParserToken* last = range.end() - 1;
803     while (last-&gt;type() == WhitespaceToken)
804         --last;
805     if (last-&gt;type() == IdentToken &amp;&amp; equalIgnoringASCIICase(last-&gt;value(), &quot;important&quot;)) {
806         --last;
807         while (last-&gt;type() == WhitespaceToken)
808             --last;
809         if (last-&gt;type() == DelimiterToken &amp;&amp; last-&gt;delimiter() == &#39;!&#39;) {
810             important = true;
811             declarationValueEnd = last;
812         }
813     }
814 
815     size_t propertiesCount = m_parsedProperties.size();
816     if (propertyID == CSSPropertyInvalid &amp;&amp; CSSVariableParser::isValidVariableName(token)) {
817         AtomString variableName = token.value().toAtomString();
818         consumeCustomPropertyValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), variableName, important);
819     }
820 
<a name="25" id="anc25"></a><span class="line-modified">821     if (important &amp;&amp; (ruleType == StyleRuleType::FontFace || ruleType == StyleRuleType::Keyframe))</span>
822         return;
823 
824     if (propertyID != CSSPropertyInvalid)
825         consumeDeclarationValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), propertyID, important, ruleType);
826 
<a name="26" id="anc26"></a><span class="line-modified">827     if (m_observerWrapper &amp;&amp; (ruleType == StyleRuleType::Style || ruleType == StyleRuleType::Keyframe)) {</span>
828         m_observerWrapper-&gt;observer().observeProperty(
829             m_observerWrapper-&gt;startOffset(rangeCopy), m_observerWrapper-&gt;endOffset(rangeCopy),
830             important, m_parsedProperties.size() != propertiesCount);
831     }
832 }
833 
834 void CSSParserImpl::consumeCustomPropertyValue(CSSParserTokenRange range, const AtomString&amp; variableName, bool important)
835 {
836     if (RefPtr&lt;CSSCustomPropertyValue&gt; value = CSSVariableParser::parseDeclarationValue(variableName, range, m_context))
837         m_parsedProperties.append(CSSProperty(CSSPropertyCustom, WTFMove(value), important));
838 }
839 
<a name="27" id="anc27"></a><span class="line-modified">840 void CSSParserImpl::consumeDeclarationValue(CSSParserTokenRange range, CSSPropertyID propertyID, bool important, StyleRuleType ruleType)</span>
841 {
842     CSSPropertyParser::parseValue(propertyID, important, range, m_context, m_parsedProperties, ruleType);
843 }
844 
845 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::consumeKeyframeKeyList(CSSParserTokenRange range)
846 {
847     std::unique_ptr&lt;Vector&lt;double&gt;&gt; result = std::unique_ptr&lt;Vector&lt;double&gt;&gt;(new Vector&lt;double&gt;);
848     while (true) {
849         range.consumeWhitespace();
850         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
851         if (token.type() == PercentageToken &amp;&amp; token.numericValue() &gt;= 0 &amp;&amp; token.numericValue() &lt;= 100)
852             result-&gt;append(token.numericValue() / 100);
853         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;from&quot;))
854             result-&gt;append(0);
855         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;to&quot;))
856             result-&gt;append(1);
857         else
858             return nullptr; // Parser error, invalid value in keyframe selector
859         if (range.atEnd())
860             return result;
861         if (range.consume().type() != CommaToken)
862             return nullptr; // Parser error
863     }
864 }
865 
866 } // namespace WebCore
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
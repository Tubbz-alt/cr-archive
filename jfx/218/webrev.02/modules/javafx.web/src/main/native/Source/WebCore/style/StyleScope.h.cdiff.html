<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleScope.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSharingResolver.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,23 ***</span>
  class CSSStyleSheet;
  class Document;
  class Element;
  class Node;
  class ProcessingInstruction;
<span class="line-removed">- class StyleResolver;</span>
  class StyleSheet;
  class StyleSheetContents;
  class StyleSheetList;
  class ShadowRoot;
  class TreeScope;
  
  namespace Style {
  
  // This is used to identify style scopes that can affect an element.
  // Scopes are in tree-of-trees order. Styles from earlier scopes win over later ones (modulo !important).
  enum class ScopeOrdinal : int {
<span class="line-modified">!     ContainingHost = -1, // Author-exposed UA pseudo classes from the host tree scope.</span>
      Element = 0, // Normal rules in the same tree where the element is.
      FirstSlot = 1, // ::slotted rules in the parent&#39;s shadow tree. Values greater than FirstSlot indicate subsequent slots in the chain.
      Shadow = std::numeric_limits&lt;int&gt;::max(), // :host rules in element&#39;s own shadow tree.
  };
  
<span class="line-new-header">--- 41,24 ---</span>
  class CSSStyleSheet;
  class Document;
  class Element;
  class Node;
  class ProcessingInstruction;
  class StyleSheet;
  class StyleSheetContents;
  class StyleSheetList;
  class ShadowRoot;
  class TreeScope;
  
  namespace Style {
  
<span class="line-added">+ class Resolver;</span>
<span class="line-added">+ </span>
  // This is used to identify style scopes that can affect an element.
  // Scopes are in tree-of-trees order. Styles from earlier scopes win over later ones (modulo !important).
  enum class ScopeOrdinal : int {
<span class="line-modified">!     ContainingHost = -1, // ::part rules and author-exposed UA pseudo classes from the host tree scope.</span>
      Element = 0, // Normal rules in the same tree where the element is.
      FirstSlot = 1, // ::slotted rules in the parent&#39;s shadow tree. Values greater than FirstSlot indicate subsequent slots in the chain.
      Shadow = std::numeric_limits&lt;int&gt;::max(), // :host rules in element&#39;s own shadow tree.
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,23 ***</span>
      void didChangeStyleSheetContents();
      // This is called when the environment where we intrepret the stylesheets changes (for example switching to printing).
      // The change is assumed to potentially affect all author and user stylesheets including shadow roots.
      WEBCORE_EXPORT void didChangeStyleSheetEnvironment();
  
      bool hasPendingUpdate() const { return m_pendingUpdate || m_hasDescendantWithPendingUpdate; }
      void flushPendingUpdate();
  
  #if ENABLE(XSLT)
      Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; collectXSLTransforms();
  #endif
  
<span class="line-modified">!     StyleResolver&amp; resolver();</span>
<span class="line-modified">!     StyleResolver* resolverIfExists();</span>
      void clearResolver();
      void releaseMemory();
  
      const Document&amp; document() const { return m_document; }
  
      static Scope&amp; forNode(Node&amp;);
      static Scope* forOrdinal(Element&amp;, ScopeOrdinal);
  
  private:
<span class="line-new-header">--- 106,28 ---</span>
      void didChangeStyleSheetContents();
      // This is called when the environment where we intrepret the stylesheets changes (for example switching to printing).
      // The change is assumed to potentially affect all author and user stylesheets including shadow roots.
      WEBCORE_EXPORT void didChangeStyleSheetEnvironment();
  
<span class="line-added">+     void invalidateMatchedDeclarationsCache();</span>
<span class="line-added">+ </span>
      bool hasPendingUpdate() const { return m_pendingUpdate || m_hasDescendantWithPendingUpdate; }
      void flushPendingUpdate();
  
  #if ENABLE(XSLT)
      Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; collectXSLTransforms();
  #endif
  
<span class="line-modified">!     WEBCORE_EXPORT Resolver&amp; resolver();</span>
<span class="line-modified">!     Resolver* resolverIfExists();</span>
      void clearResolver();
      void releaseMemory();
  
      const Document&amp; document() const { return m_document; }
<span class="line-added">+     Document&amp; document() { return m_document; }</span>
<span class="line-added">+     const ShadowRoot* shadowRoot() const { return m_shadowRoot; }</span>
<span class="line-added">+     ShadowRoot* shadowRoot() { return m_shadowRoot; }</span>
  
      static Scope&amp; forNode(Node&amp;);
      static Scope* forOrdinal(Element&amp;, ScopeOrdinal);
  
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,25 ***</span>
      WEBCORE_EXPORT void flushPendingSelfUpdate();
      WEBCORE_EXPORT void flushPendingDescendantUpdates();
  
      void collectActiveStyleSheets(Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp;);
  
<span class="line-modified">!     enum StyleResolverUpdateType {</span>
          Reconstruct,
          Reset,
          Additive
      };
<span class="line-modified">!     StyleResolverUpdateType analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets, bool&amp; requiresFullStyleRecalc);</span>
<span class="line-modified">!     void updateStyleResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp;, StyleResolverUpdateType);</span>
  
      void pendingUpdateTimerFired();
      void clearPendingUpdate();
  
      Document&amp; m_document;
      ShadowRoot* m_shadowRoot { nullptr };
  
<span class="line-modified">!     std::unique_ptr&lt;StyleResolver&gt; m_resolver;</span>
  
      Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; m_styleSheetsForStyleSheetList;
      Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; m_activeStyleSheets;
  
      Timer m_pendingUpdateTimer;
<span class="line-new-header">--- 144,31 ---</span>
      WEBCORE_EXPORT void flushPendingSelfUpdate();
      WEBCORE_EXPORT void flushPendingDescendantUpdates();
  
      void collectActiveStyleSheets(Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp;);
  
<span class="line-modified">!     enum class ResolverUpdateType {</span>
          Reconstruct,
          Reset,
          Additive
      };
<span class="line-modified">!     struct StyleSheetChange {</span>
<span class="line-modified">!         ResolverUpdateType resolverUpdateType;</span>
<span class="line-added">+         Vector&lt;StyleSheetContents*&gt; addedSheets { };</span>
<span class="line-added">+     };</span>
<span class="line-added">+     StyleSheetChange analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets);</span>
<span class="line-added">+     void invalidateStyleAfterStyleSheetChange(const StyleSheetChange&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void updateResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp;, ResolverUpdateType);</span>
  
      void pendingUpdateTimerFired();
      void clearPendingUpdate();
  
      Document&amp; m_document;
      ShadowRoot* m_shadowRoot { nullptr };
  
<span class="line-modified">!     std::unique_ptr&lt;Resolver&gt; m_resolver;</span>
  
      Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; m_styleSheetsForStyleSheetList;
      Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; m_activeStyleSheets;
  
      Timer m_pendingUpdateTimer;
</pre>
<center><a href="StyleScope.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSharingResolver.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp
@@ -52,10 +52,13 @@
         out.print(m_header.type(), " of ", m_header.pointer(), " with prototype ", inContext(JSValue(prototype()), context));
         return;
     case Equivalence:
         out.print(m_header.type(), " of ", m_header.pointer(), " with ", inContext(requiredValue(), context));
         return;
+    case CustomFunctionEquivalence:
+        out.print(m_header.type(), " of ", m_header.pointer());
+        return;
     case HasPrototype:
         out.print(m_header.type(), " with prototype ", inContext(JSValue(prototype()), context));
         return;
     }
     RELEASE_ASSERT_NOT_REACHED();
@@ -84,10 +87,11 @@
     switch (m_header.type()) {
     case Presence:
     case Absence:
     case AbsenceOfSetEffect:
     case Equivalence:
+    case CustomFunctionEquivalence:
         if (!structure->propertyAccessesAreCacheable()) {
             if (PropertyConditionInternal::verbose)
                 dataLog("Invalid because property accesses are not cacheable.\n");
             return false;
         }
@@ -246,11 +250,17 @@
             }
             return false;
         }
 
         return true;
-    } }
+    }
+    case CustomFunctionEquivalence: {
+        if (structure->staticPropertiesReified())
+            return false;
+        return !!structure->findPropertyHashEntry(uid());
+    }
+    }
 
     RELEASE_ASSERT_NOT_REACHED();
     return false;
 }
 
@@ -261,10 +271,11 @@
 
     switch (m_header.type()) {
     case Presence:
     case Absence:
     case Equivalence:
+    case CustomFunctionEquivalence:
         return structure->needImpurePropertyWatchpoint();
     case AbsenceOfSetEffect:
     case HasPrototype:
         return false;
     }
@@ -286,10 +297,11 @@
         if (structure->typeInfo().getOwnPropertySlotIsImpure() || structure->typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence())
             return false;
         break;
     case Presence:
     case Equivalence:
+    case CustomFunctionEquivalence:
         if (structure->typeInfo().getOwnPropertySlotIsImpure())
             return false;
         break;
     default:
         break;
@@ -328,10 +340,25 @@
             return false;
 
         break;
     }
 
+    case CustomFunctionEquivalence: {
+        // We just use the structure transition watchpoint for this. A structure S starts
+        // off with a property P in the static property hash table. If S transitions to
+        // S', either P remains in the static property table or not. If not, then we
+        // are no longer valid. So the above check of transitionWatchpointSetHasBeenInvalidated
+        // is sufficient.
+        //
+        // We could make this smarter in the future, since we sometimes reify static properties.
+        // We could make this adapt to looking at the object's storage for such reified custom
+        // functions, but we don't do that right now. We just allow this property condition to
+        // invalidate and create an Equivalence watchpoint for the materialized property sometime
+        // in the future.
+        break;
+    }
+
     default:
         break;
     }
 
     return true;
@@ -349,24 +376,10 @@
 {
     return isStillValid(structure, base)
         && isWatchableWhenValid(structure, effort);
 }
 
-bool PropertyCondition::isStillLive(VM& vm) const
-{
-    if (hasPrototype() && prototype() && !vm.heap.isMarked(prototype()))
-        return false;
-
-    if (hasRequiredValue()
-        && requiredValue()
-        && requiredValue().isCell()
-        && !vm.heap.isMarked(requiredValue().asCell()))
-        return false;
-
-    return true;
-}
-
 void PropertyCondition::validateReferences(const TrackedReferences& tracked) const
 {
     if (hasPrototype())
         tracked.check(prototype());
 
@@ -415,10 +428,13 @@
         out.print("Absence");
         return;
     case JSC::PropertyCondition::Equivalence:
         out.print("Equivalence");
         return;
+    case JSC::PropertyCondition::CustomFunctionEquivalence:
+        out.print("CustomFunctionEquivalence");
+        return;
     case JSC::PropertyCondition::HasPrototype:
         out.print("HasPrototype");
         return;
     }
     RELEASE_ASSERT_NOT_REACHED();

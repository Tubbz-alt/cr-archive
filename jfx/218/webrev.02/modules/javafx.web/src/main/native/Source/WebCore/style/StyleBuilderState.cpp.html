<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleBuilderState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012, 2013 Google Inc. All rights reserved.
 12  * Copyright (C) 2014 Igalia S.L.
 13  *
 14  * This library is free software; you can redistribute it and/or
 15  * modify it under the terms of the GNU Library General Public
 16  * License as published by the Free Software Foundation; either
 17  * version 2 of the License, or (at your option) any later version.
 18  *
 19  * This library is distributed in the hope that it will be useful,
 20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 22  * Library General Public License for more details.
 23  *
 24  * You should have received a copy of the GNU Library General Public License
 25  * along with this library; see the file COPYING.LIB.  If not, write to
 26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 27  * Boston, MA 02110-1301, USA.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;StyleBuilderState.h&quot;
 32 
 33 #include &quot;CSSCursorImageValue.h&quot;
 34 #include &quot;CSSFilterImageValue.h&quot;
 35 #include &quot;CSSFontSelector.h&quot;
 36 #include &quot;CSSFunctionValue.h&quot;
 37 #include &quot;CSSGradientValue.h&quot;
 38 #include &quot;CSSImageSetValue.h&quot;
 39 #include &quot;CSSImageValue.h&quot;
 40 #include &quot;CSSShadowValue.h&quot;
 41 #include &quot;FontCache.h&quot;
 42 #include &quot;HTMLElement.h&quot;
 43 #include &quot;RenderTheme.h&quot;
 44 #include &quot;SVGElement.h&quot;
 45 #include &quot;SVGSVGElement.h&quot;
 46 #include &quot;Settings.h&quot;
 47 #include &quot;StyleBuilder.h&quot;
 48 #include &quot;StyleCachedImage.h&quot;
 49 #include &quot;StyleCursorImage.h&quot;
 50 #include &quot;StyleFontSizeFunctions.h&quot;
 51 #include &quot;StyleGeneratedImage.h&quot;
 52 #include &quot;StyleImageSet.h&quot;
 53 #include &quot;TransformFunctions.h&quot;
 54 
 55 namespace WebCore {
 56 namespace Style {
 57 
 58 BuilderState::BuilderState(Builder&amp; builder, RenderStyle&amp; style, BuilderContext&amp;&amp; context)
 59     : m_builder(builder)
 60     , m_styleMap(*this)
 61     , m_style(style)
 62     , m_context(WTFMove(context))
 63     , m_cssToLengthConversionData(&amp;style, rootElementStyle(), document().renderView())
 64 {
 65 }
 66 
 67 // SVG handles zooming in a different way compared to CSS. The whole document is scaled instead
 68 // of each individual length value in the render style / tree. CSSPrimitiveValue::computeLength*()
 69 // multiplies each resolved length with the zoom multiplier - so for SVG we need to disable that.
 70 // Though all CSS values that can be applied to outermost &lt;svg&gt; elements (width/height/border/padding...)
 71 // need to respect the scaling. RenderBox (the parent class of RenderSVGRoot) grabs values like
 72 // width/height/border/padding/... from the RenderStyle -&gt; for SVG these values would never scale,
 73 // if we&#39;d pass a 1.0 zoom factor everyhwere. So we only pass a zoom factor of 1.0 for specific
 74 // properties that are NOT allowed to scale within a zoomed SVG document (letter/word-spacing/font-size).
 75 bool BuilderState::useSVGZoomRules() const
 76 {
 77     return is&lt;SVGElement&gt;(element());
 78 }
 79 
 80 bool BuilderState::useSVGZoomRulesForLength() const
 81 {
 82     return is&lt;SVGElement&gt;(element()) &amp;&amp; !(is&lt;SVGSVGElement&gt;(*element()) &amp;&amp; element()-&gt;parentNode());
 83 }
 84 
 85 Ref&lt;CSSValue&gt; BuilderState::resolveImageStyles(CSSValue&amp; value)
 86 {
 87     if (is&lt;CSSGradientValue&gt;(value))
 88         return downcast&lt;CSSGradientValue&gt;(value).gradientWithStylesResolved(*this);
 89 
 90     if (is&lt;CSSImageSetValue&gt;(value))
 91         return downcast&lt;CSSImageSetValue&gt;(value).imageSetWithStylesResolved(*this);
 92 
 93     // Creating filter operations doesn&#39;t create a new CSSValue reference.
 94     if (is&lt;CSSFilterImageValue&gt;(value))
 95         downcast&lt;CSSFilterImageValue&gt;(value).createFilterOperations(*this);
 96 
 97     return makeRef(value);
 98 }
 99 
100 RefPtr&lt;StyleImage&gt; BuilderState::createStyleImage(CSSValue&amp; value)
101 {
102     if (is&lt;CSSImageValue&gt;(value))
103         return StyleCachedImage::create(downcast&lt;CSSImageValue&gt;(value));
104 
105     if (is&lt;CSSCursorImageValue&gt;(value))
106         return StyleCursorImage::create(downcast&lt;CSSCursorImageValue&gt;(value));
107 
108     if (is&lt;CSSImageGeneratorValue&gt;(value))
109         return StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(resolveImageStyles(value).get()));
110 
111     if (is&lt;CSSImageSetValue&gt;(value))
112         return StyleImageSet::create(downcast&lt;CSSImageSetValue&gt;(resolveImageStyles(value).get()));
113 
114     return nullptr;
115 }
116 
117 static FilterOperation::OperationType filterOperationForType(CSSValueID type)
118 {
119     switch (type) {
120     case CSSValueUrl:
121         return FilterOperation::REFERENCE;
122     case CSSValueGrayscale:
123         return FilterOperation::GRAYSCALE;
124     case CSSValueSepia:
125         return FilterOperation::SEPIA;
126     case CSSValueSaturate:
127         return FilterOperation::SATURATE;
128     case CSSValueHueRotate:
129         return FilterOperation::HUE_ROTATE;
130     case CSSValueInvert:
131         return FilterOperation::INVERT;
132     case CSSValueAppleInvertLightness:
133         return FilterOperation::APPLE_INVERT_LIGHTNESS;
134     case CSSValueOpacity:
135         return FilterOperation::OPACITY;
136     case CSSValueBrightness:
137         return FilterOperation::BRIGHTNESS;
138     case CSSValueContrast:
139         return FilterOperation::CONTRAST;
140     case CSSValueBlur:
141         return FilterOperation::BLUR;
142     case CSSValueDropShadow:
143         return FilterOperation::DROP_SHADOW;
144     default:
145         break;
146     }
147     ASSERT_NOT_REACHED();
148     return FilterOperation::NONE;
149 }
150 
151 bool BuilderState::createFilterOperations(const CSSValue&amp; inValue, FilterOperations&amp; outOperations)
152 {
153     // FIXME: Move this code somewhere else.
154 
155     ASSERT(outOperations.isEmpty());
156 
157     if (is&lt;CSSPrimitiveValue&gt;(inValue)) {
158         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(inValue);
159         if (primitiveValue.valueID() == CSSValueNone)
160             return true;
161     }
162 
163     if (!is&lt;CSSValueList&gt;(inValue))
164         return false;
165 
166     FilterOperations operations;
167     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(inValue)) {
168 
169         if (is&lt;CSSPrimitiveValue&gt;(currentValue)) {
170             auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
171             if (!primitiveValue.isURI())
172                 continue;
173 
174             String cssUrl = primitiveValue.stringValue();
175             URL url = document().completeURL(cssUrl);
176 
177             auto operation = ReferenceFilterOperation::create(cssUrl, url.fragmentIdentifier());
178             operations.operations().append(WTFMove(operation));
179             continue;
180         }
181 
182         if (!is&lt;CSSFunctionValue&gt;(currentValue))
183             continue;
184 
185         auto&amp; filterValue = downcast&lt;CSSFunctionValue&gt;(currentValue.get());
186         FilterOperation::OperationType operationType = filterOperationForType(filterValue.name());
187 
188         // Check that all parameters are primitive values, with the
189         // exception of drop shadow which has a CSSShadowValue parameter.
190         const CSSPrimitiveValue* firstValue = nullptr;
191         if (operationType != FilterOperation::DROP_SHADOW) {
192             bool haveNonPrimitiveValue = false;
193             for (unsigned j = 0; j &lt; filterValue.length(); ++j) {
194                 if (!is&lt;CSSPrimitiveValue&gt;(*filterValue.itemWithoutBoundsCheck(j))) {
195                     haveNonPrimitiveValue = true;
196                     break;
197                 }
198             }
199             if (haveNonPrimitiveValue)
200                 continue;
201             if (filterValue.length())
202                 firstValue = downcast&lt;CSSPrimitiveValue&gt;(filterValue.itemWithoutBoundsCheck(0));
203         }
204 
205         switch (operationType) {
206         case FilterOperation::GRAYSCALE:
207         case FilterOperation::SEPIA:
208         case FilterOperation::SATURATE: {
209             double amount = 1;
210             if (filterValue.length() == 1) {
211                 amount = firstValue-&gt;doubleValue();
212                 if (firstValue-&gt;isPercentage())
213                     amount /= 100;
214             }
215 
216             operations.operations().append(BasicColorMatrixFilterOperation::create(amount, operationType));
217             break;
218         }
219         case FilterOperation::HUE_ROTATE: {
220             double angle = 0;
221             if (filterValue.length() == 1)
222                 angle = firstValue-&gt;computeDegrees();
223 
224             operations.operations().append(BasicColorMatrixFilterOperation::create(angle, operationType));
225             break;
226         }
227         case FilterOperation::INVERT:
228         case FilterOperation::BRIGHTNESS:
229         case FilterOperation::CONTRAST:
230         case FilterOperation::OPACITY: {
231             double amount = 1;
232             if (filterValue.length() == 1) {
233                 amount = firstValue-&gt;doubleValue();
234                 if (firstValue-&gt;isPercentage())
235                     amount /= 100;
236             }
237 
238             operations.operations().append(BasicComponentTransferFilterOperation::create(amount, operationType));
239             break;
240         }
241         case FilterOperation::APPLE_INVERT_LIGHTNESS: {
242             operations.operations().append(InvertLightnessFilterOperation::create());
243             break;
244         }
245         case FilterOperation::BLUR: {
246             Length stdDeviation = Length(0, Fixed);
247             if (filterValue.length() &gt;= 1)
248                 stdDeviation = convertToFloatLength(firstValue, cssToLengthConversionData());
249             if (stdDeviation.isUndefined())
250                 return false;
251 
252             operations.operations().append(BlurFilterOperation::create(stdDeviation));
253             break;
254         }
255         case FilterOperation::DROP_SHADOW: {
256             if (filterValue.length() != 1)
257                 return false;
258 
259             const auto* cssValue = filterValue.itemWithoutBoundsCheck(0);
260             if (!is&lt;CSSShadowValue&gt;(cssValue))
261                 continue;
262 
263             const auto&amp; item = downcast&lt;CSSShadowValue&gt;(*cssValue);
264             int x = item.x-&gt;computeLength&lt;int&gt;(cssToLengthConversionData());
265             int y = item.y-&gt;computeLength&lt;int&gt;(cssToLengthConversionData());
266             IntPoint location(x, y);
267             int blur = item.blur ? item.blur-&gt;computeLength&lt;int&gt;(cssToLengthConversionData()) : 0;
268             Color color;
269             if (item.color)
270                 color = colorFromPrimitiveValue(*item.color);
271 
272             operations.operations().append(DropShadowFilterOperation::create(location, blur, color.isValid() ? color : Color::transparent));
273             break;
274         }
275         default:
276             ASSERT_NOT_REACHED();
277             break;
278         }
279     }
280 
281     outOperations = operations;
282     return true;
283 }
284 
285 bool BuilderState::isColorFromPrimitiveValueDerivedFromElement(const CSSPrimitiveValue&amp; value)
286 {
287     switch (value.valueID()) {
288     case CSSValueWebkitText:
289     case CSSValueWebkitLink:
290     case CSSValueWebkitActivelink:
291     case CSSValueCurrentcolor:
292         return true;
293     default:
294         return false;
295     }
296 }
297 
298 Color BuilderState::colorFromPrimitiveValue(const CSSPrimitiveValue&amp; value, bool forVisitedLink) const
299 {
300     if (value.isRGBColor())
301         return value.color();
302 
303     auto identifier = value.valueID();
304     switch (identifier) {
305     case CSSValueWebkitText:
306         return document().textColor();
307     case CSSValueWebkitLink:
308         return (element() &amp;&amp; element()-&gt;isLink() &amp;&amp; forVisitedLink) ? document().visitedLinkColor() : document().linkColor();
309     case CSSValueWebkitActivelink:
310         return document().activeLinkColor();
311     case CSSValueWebkitFocusRingColor:
312         return RenderTheme::singleton().focusRingColor(document().styleColorOptions(&amp;m_style));
313     case CSSValueCurrentcolor:
314         // Color is an inherited property so depending on it effectively makes the property inherited.
315         // FIXME: Setting the flag as a side effect of calling this function is a bit oblique. Can we do better?
316         m_style.setHasExplicitlyInheritedProperties();
317         return m_style.color();
318     default:
319         return StyleColor::colorFromKeyword(identifier, document().styleColorOptions(&amp;m_style));
320     }
321 }
322 
323 void BuilderState::registerContentAttribute(const AtomString&amp; attributeLocalName)
324 {
325     if (style().styleType() == PseudoId::Before || style().styleType() == PseudoId::After)
326         m_registeredContentAttributes.append(attributeLocalName);
327 }
328 
329 void BuilderState::adjustStyleForInterCharacterRuby()
330 {
331     if (m_style.rubyPosition() != RubyPosition::InterCharacter || !element() || !element()-&gt;hasTagName(HTMLNames::rtTag))
332         return;
333 
334     m_style.setTextAlign(TextAlignMode::Center);
335     if (m_style.isHorizontalWritingMode())
336         m_style.setWritingMode(LeftToRightWritingMode);
337 }
338 
339 void BuilderState::updateFont()
340 {
341     auto&amp; fontSelector = const_cast&lt;Document&amp;&gt;(document()).fontSelector();
342 
343     auto needsUpdate = [&amp;] {
344         if (m_fontDirty)
345             return true;
346         auto* fonts = m_style.fontCascade().fonts();
347         if (!fonts)
348             return true;
349         return false;
350     };
351 
352     if (!needsUpdate())
353         return;
354 
355 #if ENABLE(TEXT_AUTOSIZING)
356     updateFontForTextSizeAdjust();
357 #endif
358     updateFontForGenericFamilyChange();
359     updateFontForZoomChange();
360     updateFontForOrientationChange();
361 
362     m_style.fontCascade().update(&amp;fontSelector);
363 
364     m_fontDirty = false;
365 }
366 
367 #if ENABLE(TEXT_AUTOSIZING)
368 void BuilderState::updateFontForTextSizeAdjust()
369 {
370     if (m_style.textSizeAdjust().isAuto()
371         || !document().settings().textAutosizingEnabled()
372         || (document().settings().textAutosizingUsesIdempotentMode() &amp;&amp; !m_style.textSizeAdjust().isNone()))
373         return;
374 
375     auto newFontDescription = m_style.fontDescription();
376     if (!m_style.textSizeAdjust().isNone())
377         newFontDescription.setComputedSize(newFontDescription.specifiedSize() * m_style.textSizeAdjust().multiplier());
378     else
379         newFontDescription.setComputedSize(newFontDescription.specifiedSize());
380 
381     m_style.setFontDescription(WTFMove(newFontDescription));
382 }
383 #endif
384 
385 void BuilderState::updateFontForZoomChange()
386 {
387     if (m_style.effectiveZoom() == parentStyle().effectiveZoom() &amp;&amp; m_style.textZoom() == parentStyle().textZoom())
388         return;
389 
390     const auto&amp; childFont = m_style.fontDescription();
391     auto newFontDescription = childFont;
392     setFontSize(newFontDescription, childFont.specifiedSize());
393 
394     m_style.setFontDescription(WTFMove(newFontDescription));
395 }
396 
397 void BuilderState::updateFontForGenericFamilyChange()
398 {
399     const auto&amp; childFont = m_style.fontDescription();
400 
401     if (childFont.isAbsoluteSize())
402         return;
403 
404     const auto&amp; parentFont = parentStyle().fontDescription();
405     if (childFont.useFixedDefaultSize() == parentFont.useFixedDefaultSize())
406         return;
407 
408     // We know the parent is monospace or the child is monospace, and that font
409     // size was unspecified. We want to scale our font size as appropriate.
410     // If the font uses a keyword size, then we refetch from the table rather than
411     // multiplying by our scale factor.
412     float size = [&amp;] {
413         if (CSSValueID sizeIdentifier = childFont.keywordSizeAsIdentifier())
414             return Style::fontSizeForKeyword(sizeIdentifier, childFont.useFixedDefaultSize(), document());
415 
416         auto fixedSize =  document().settings().defaultFixedFontSize();
417         auto defaultSize =  document().settings().defaultFontSize();
418         float fixedScaleFactor = (fixedSize &amp;&amp; defaultSize) ? static_cast&lt;float&gt;(fixedSize) / defaultSize : 1;
419         return parentFont.useFixedDefaultSize() ? childFont.specifiedSize() / fixedScaleFactor : childFont.specifiedSize() * fixedScaleFactor;
420     }();
421 
422     auto newFontDescription = childFont;
423     setFontSize(newFontDescription, size);
424     m_style.setFontDescription(WTFMove(newFontDescription));
425 }
426 
427 void BuilderState::updateFontForOrientationChange()
428 {
429     auto [fontOrientation, glyphOrientation] = m_style.fontAndGlyphOrientation();
430 
431     const auto&amp; fontDescription = m_style.fontDescription();
432     if (fontDescription.orientation() == fontOrientation &amp;&amp; fontDescription.nonCJKGlyphOrientation() == glyphOrientation)
433         return;
434 
435     auto newFontDescription = fontDescription;
436     newFontDescription.setNonCJKGlyphOrientation(glyphOrientation);
437     newFontDescription.setOrientation(fontOrientation);
438     m_style.setFontDescription(WTFMove(newFontDescription));
439 }
440 
441 void BuilderState::setFontSize(FontCascadeDescription&amp; fontDescription, float size)
442 {
443     fontDescription.setSpecifiedSize(size);
444     fontDescription.setComputedSize(Style::computedFontSizeFromSpecifiedSize(size, fontDescription.isAbsoluteSize(), useSVGZoomRules(), &amp;style(), document()));
445 }
446 
447 }
448 }
    </pre>
  </body>
</html>
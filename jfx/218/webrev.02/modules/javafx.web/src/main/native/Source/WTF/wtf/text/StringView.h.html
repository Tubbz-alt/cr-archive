<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringView.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &lt;limits.h&gt;
  29 #include &lt;unicode/utypes.h&gt;
  30 #include &lt;wtf/Forward.h&gt;
  31 #include &lt;wtf/Optional.h&gt;
  32 #include &lt;wtf/RetainPtr.h&gt;
  33 #include &lt;wtf/Vector.h&gt;
  34 #include &lt;wtf/text/CString.h&gt;
  35 #include &lt;wtf/text/ConversionMode.h&gt;
  36 #include &lt;wtf/text/LChar.h&gt;
  37 #include &lt;wtf/text/StringCommon.h&gt;
  38 #include &lt;wtf/text/UTF8ConversionError.h&gt;
  39 
  40 // FIXME: Enabling the StringView lifetime checking causes the MSVC build to fail. Figure out why.
  41 #if defined(NDEBUG) || COMPILER(MSVC)
  42 #define CHECK_STRINGVIEW_LIFETIME 0
  43 #else
  44 #define CHECK_STRINGVIEW_LIFETIME 1
  45 #endif
  46 
  47 namespace WTF {
  48 
  49 // StringView is a non-owning reference to a string, similar to the proposed std::string_view.
  50 
  51 class StringView final {
  52     WTF_MAKE_FAST_ALLOCATED;
  53 public:
  54     StringView();
  55 #if CHECK_STRINGVIEW_LIFETIME
  56     ~StringView();
  57     StringView(StringView&amp;&amp;);
  58     StringView(const StringView&amp;);
  59     StringView&amp; operator=(StringView&amp;&amp;);
  60     StringView&amp; operator=(const StringView&amp;);
  61 #endif
  62 
  63     StringView(const AtomString&amp;);
  64     StringView(const String&amp;);
  65     StringView(const StringImpl&amp;);
  66     StringView(const StringImpl*);
  67     StringView(const LChar*, unsigned length);
  68     StringView(const UChar*, unsigned length);
  69     StringView(const char*);
  70     StringView(const char*, unsigned length);
  71 
  72     static StringView empty();
  73 
  74     unsigned length() const;
  75     bool isEmpty() const;
  76 
  77     explicit operator bool() const;
  78     bool isNull() const;
  79 
  80     UChar operator[](unsigned index) const;
  81 
  82     class CodeUnits;
  83     CodeUnits codeUnits() const;
  84 
  85     class CodePoints;
  86     CodePoints codePoints() const;
  87 
  88     class GraphemeClusters;
  89     GraphemeClusters graphemeClusters() const;
  90 
  91     bool is8Bit() const;
  92     const LChar* characters8() const;
  93     const UChar* characters16() const;
  94 
  95     bool isAllASCII() const;
  96 
  97     String toString() const;
  98     String toStringWithoutCopying() const;
  99     AtomString toAtomString() const;
 100     RefPtr&lt;AtomStringImpl&gt; toExistingAtomString() const;
 101 
 102 #if USE(CF)
 103     // These functions convert null strings to empty strings.
 104     WTF_EXPORT_PRIVATE RetainPtr&lt;CFStringRef&gt; createCFString() const;
 105     WTF_EXPORT_PRIVATE RetainPtr&lt;CFStringRef&gt; createCFStringWithoutCopying() const;
 106 #endif
 107 
 108 #ifdef __OBJC__
 109     // These functions convert null strings to empty strings.
 110     WTF_EXPORT_PRIVATE RetainPtr&lt;NSString&gt; createNSString() const;
 111     WTF_EXPORT_PRIVATE RetainPtr&lt;NSString&gt; createNSStringWithoutCopying() const;
 112 #endif
 113 
 114     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8(ConversionMode = LenientConversion) const;
 115     WTF_EXPORT_PRIVATE CString utf8(ConversionMode = LenientConversion) const;
 116 
 117     class UpconvertedCharacters;
 118     UpconvertedCharacters upconvertedCharacters() const;
 119 
 120     void getCharactersWithUpconvert(LChar*) const;
 121     void getCharactersWithUpconvert(UChar*) const;
 122 
 123     StringView substring(unsigned start, unsigned length = std::numeric_limits&lt;unsigned&gt;::max()) const;
 124     StringView left(unsigned length) const { return substring(0, length); }
 125     StringView right(unsigned length) const { return substring(this-&gt;length() - length, length); }
 126 
 127     template&lt;typename MatchedCharacterPredicate&gt;
 128     StringView stripLeadingAndTrailingMatchedCharacters(const MatchedCharacterPredicate&amp;);
 129 
 130     class SplitResult;
 131     SplitResult split(UChar) const;
 132     SplitResult splitAllowingEmptyEntries(UChar) const;
 133 
 134     size_t find(UChar, unsigned start = 0) const;
 135     size_t find(CodeUnitMatchFunction, unsigned start = 0) const;
 136 
 137     WTF_EXPORT_PRIVATE size_t find(StringView, unsigned start) const;
 138 
 139     size_t reverseFind(UChar, unsigned index = std::numeric_limits&lt;unsigned&gt;::max()) const;
 140 
 141     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringView&amp;) const;
 142     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringView&amp;, unsigned startOffset) const;
 143 
 144     WTF_EXPORT_PRIVATE String convertToASCIILowercase() const;
 145     WTF_EXPORT_PRIVATE String convertToASCIIUppercase() const;
 146 
 147     bool contains(UChar) const;
 148     bool contains(CodeUnitMatchFunction) const;
 149     WTF_EXPORT_PRIVATE bool containsIgnoringASCIICase(const StringView&amp;) const;
 150     WTF_EXPORT_PRIVATE bool containsIgnoringASCIICase(const StringView&amp;, unsigned startOffset) const;
 151 
 152     WTF_EXPORT_PRIVATE bool startsWith(UChar) const;
 153     WTF_EXPORT_PRIVATE bool startsWith(const StringView&amp;) const;
 154     WTF_EXPORT_PRIVATE bool startsWithIgnoringASCIICase(const StringView&amp;) const;
 155 
 156     WTF_EXPORT_PRIVATE bool endsWith(const StringView&amp;) const;
 157     WTF_EXPORT_PRIVATE bool endsWithIgnoringASCIICase(const StringView&amp;) const;
 158 
 159     int toInt() const;
 160     int toInt(bool&amp; isValid) const;
 161     int toIntStrict(bool&amp; isValid) const;
 162     Optional&lt;uint64_t&gt; toUInt64Strict() const;
 163     float toFloat(bool&amp; isValid) const;
 164 
 165     static void invalidate(const StringImpl&amp;);
 166 
 167     struct UnderlyingString;
 168 
 169 private:
 170     friend bool equal(StringView, StringView);
 171 
 172     void initialize(const LChar*, unsigned length);
 173     void initialize(const UChar*, unsigned length);
 174 
 175     template&lt;typename CharacterType, typename MatchedCharacterPredicate&gt;
 176     StringView stripLeadingAndTrailingMatchedCharacters(const CharacterType*, const MatchedCharacterPredicate&amp;);
 177 
 178 #if CHECK_STRINGVIEW_LIFETIME
 179     WTF_EXPORT_PRIVATE bool underlyingStringIsValid() const;
 180     WTF_EXPORT_PRIVATE void setUnderlyingString(const StringImpl*);
 181     WTF_EXPORT_PRIVATE void setUnderlyingString(const StringView&amp;);
 182     void adoptUnderlyingString(UnderlyingString*);
 183 #else
 184     bool underlyingStringIsValid() const { return true; }
 185     void setUnderlyingString(const StringImpl*) { }
 186     void setUnderlyingString(const StringView&amp;) { }
 187 #endif
 188     void clear();
 189 
 190     const void* m_characters { nullptr };
 191     unsigned m_length { 0 };
 192     bool m_is8Bit { true };
 193 
 194 #if CHECK_STRINGVIEW_LIFETIME
 195     UnderlyingString* m_underlyingString { nullptr };
 196 #endif
 197 };
 198 
 199 template&lt;typename CharacterType, size_t inlineCapacity&gt; void append(Vector&lt;CharacterType, inlineCapacity&gt;&amp;, StringView);
 200 
 201 bool equal(StringView, StringView);
 202 bool equal(StringView, const LChar* b);
 203 
 204 bool equalIgnoringASCIICase(StringView, StringView);
 205 bool equalIgnoringASCIICase(StringView, const char*);
 206 
 207 template&lt;unsigned length&gt; bool equalLettersIgnoringASCIICase(StringView, const char (&amp;lowercaseLetters)[length]);
 208 
 209 inline bool operator==(StringView a, StringView b) { return equal(a, b); }
 210 inline bool operator==(StringView a, const LChar *b);
 211 inline bool operator==(StringView a, const char *b) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b)); }
 212 inline bool operator==(const char* a, StringView b) { return equal(b, a); }
 213 
 214 inline bool operator!=(StringView a, StringView b) { return !equal(a, b); }
 215 inline bool operator!=(StringView a, const LChar* b) { return !equal(a, b); }
 216 inline bool operator!=(StringView a, const char* b) { return !equal(a, b); }
 217 inline bool operator!=(const LChar*a, StringView b) { return !equal(b, a); }
 218 inline bool operator!=(const char*a, StringView b) { return !equal(b, a); }
 219 
 220 struct StringViewWithUnderlyingString;
 221 
 222 // This returns a StringView of the normalized result, and a String that is either
 223 // null, if the input was already normalized, or contains the normalized result
 224 // and needs to be kept around so the StringView remains valid. Typically the
 225 // easiest way to use it correctly is to put it into a local and use the StringView.
 226 WTF_EXPORT_PRIVATE StringViewWithUnderlyingString normalizedNFC(StringView);
 227 
 228 WTF_EXPORT_PRIVATE String normalizedNFC(const String&amp;);
 229 
 230 }
 231 
 232 #include &lt;wtf/text/AtomString.h&gt;
 233 #include &lt;wtf/text/WTFString.h&gt;
 234 
 235 namespace WTF {
 236 
 237 struct StringViewWithUnderlyingString {
 238     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 239     StringView view;
 240     String underlyingString;
 241 };
 242 
 243 inline StringView::StringView()
 244 {
 245 }
 246 
 247 #if CHECK_STRINGVIEW_LIFETIME
 248 
 249 inline StringView::~StringView()
 250 {
 251     setUnderlyingString(nullptr);
 252 }
 253 
 254 inline StringView::StringView(StringView&amp;&amp; other)
 255     : m_characters(other.m_characters)
 256     , m_length(other.m_length)
 257     , m_is8Bit(other.m_is8Bit)
 258 {
 259     ASSERT(other.underlyingStringIsValid());
 260 
 261     other.clear();
 262 
 263     setUnderlyingString(other);
 264     other.setUnderlyingString(nullptr);
 265 }
 266 
 267 inline StringView::StringView(const StringView&amp; other)
 268     : m_characters(other.m_characters)
 269     , m_length(other.m_length)
 270     , m_is8Bit(other.m_is8Bit)
 271 {
 272     ASSERT(other.underlyingStringIsValid());
 273 
 274     setUnderlyingString(other);
 275 }
 276 
 277 inline StringView&amp; StringView::operator=(StringView&amp;&amp; other)
 278 {
 279     ASSERT(other.underlyingStringIsValid());
 280 
 281     m_characters = other.m_characters;
 282     m_length = other.m_length;
 283     m_is8Bit = other.m_is8Bit;
 284 
 285     other.clear();
 286 
 287     setUnderlyingString(other);
 288     other.setUnderlyingString(nullptr);
 289 
 290     return *this;
 291 }
 292 
 293 inline StringView&amp; StringView::operator=(const StringView&amp; other)
 294 {
 295     ASSERT(other.underlyingStringIsValid());
 296 
 297     m_characters = other.m_characters;
 298     m_length = other.m_length;
 299     m_is8Bit = other.m_is8Bit;
 300 
 301     setUnderlyingString(other);
 302 
 303     return *this;
 304 }
 305 
 306 #endif // CHECK_STRINGVIEW_LIFETIME
 307 
 308 inline void StringView::initialize(const LChar* characters, unsigned length)
 309 {
 310     m_characters = characters;
 311     m_length = length;
 312     m_is8Bit = true;
 313 }
 314 
 315 inline void StringView::initialize(const UChar* characters, unsigned length)
 316 {
 317     m_characters = characters;
 318     m_length = length;
 319     m_is8Bit = false;
 320 }
 321 
 322 inline StringView::StringView(const LChar* characters, unsigned length)
 323 {
 324     initialize(characters, length);
 325 }
 326 
 327 inline StringView::StringView(const UChar* characters, unsigned length)
 328 {
 329     initialize(characters, length);
 330 }
 331 
 332 inline StringView::StringView(const char* characters)
 333 {
 334     initialize(reinterpret_cast&lt;const LChar*&gt;(characters), strlen(characters));
 335 }
 336 
 337 inline StringView::StringView(const char* characters, unsigned length)
 338 {
 339     initialize(reinterpret_cast&lt;const LChar*&gt;(characters), length);
 340 }
 341 
 342 inline StringView::StringView(const StringImpl&amp; string)
 343 {
 344     setUnderlyingString(&amp;string);
 345     if (string.is8Bit())
 346         initialize(string.characters8(), string.length());
 347     else
 348         initialize(string.characters16(), string.length());
 349 }
 350 
 351 inline StringView::StringView(const StringImpl* string)
 352 {
 353     if (!string)
 354         return;
 355 
 356     setUnderlyingString(string);
 357     if (string-&gt;is8Bit())
 358         initialize(string-&gt;characters8(), string-&gt;length());
 359     else
 360         initialize(string-&gt;characters16(), string-&gt;length());
 361 }
 362 
 363 inline StringView::StringView(const String&amp; string)
 364 {
 365     setUnderlyingString(string.impl());
 366     if (!string.impl()) {
 367         clear();
 368         return;
 369     }
 370     if (string.is8Bit()) {
 371         initialize(string.characters8(), string.length());
 372         return;
 373     }
 374     initialize(string.characters16(), string.length());
 375 }
 376 
 377 inline StringView::StringView(const AtomString&amp; atomString)
 378     : StringView(atomString.string())
 379 {
 380 }
 381 
 382 inline void StringView::clear()
 383 {
 384     m_characters = nullptr;
 385     m_length = 0;
 386     m_is8Bit = true;
 387 }
 388 
 389 inline StringView StringView::empty()
 390 {
 391     return StringView(&quot;&quot;, 0);
 392 }
 393 
 394 inline const LChar* StringView::characters8() const
 395 {
 396     ASSERT(is8Bit());
 397     ASSERT(underlyingStringIsValid());
 398     return static_cast&lt;const LChar*&gt;(m_characters);
 399 }
 400 
 401 inline const UChar* StringView::characters16() const
 402 {
 403     ASSERT(!is8Bit());
 404     ASSERT(underlyingStringIsValid());
 405     return static_cast&lt;const UChar*&gt;(m_characters);
 406 }
 407 
 408 inline bool StringView::isAllASCII() const
 409 {
 410     if (is8Bit())
 411         return charactersAreAllASCII(characters8(), length());
 412     return charactersAreAllASCII(characters16(), length());
 413 }
 414 
 415 class StringView::UpconvertedCharacters {
 416     WTF_MAKE_FAST_ALLOCATED;
 417 public:
 418     explicit UpconvertedCharacters(const StringView&amp;);
 419     operator const UChar*() const { return m_characters; }
 420     const UChar* get() const { return m_characters; }
 421 private:
 422     Vector&lt;UChar, 32&gt; m_upconvertedCharacters;
 423     const UChar* m_characters;
 424 };
 425 
 426 inline StringView::UpconvertedCharacters StringView::upconvertedCharacters() const
 427 {
 428     return UpconvertedCharacters(*this);
 429 }
 430 
 431 inline bool StringView::isNull() const
 432 {
 433     return !m_characters;
 434 }
 435 
 436 inline bool StringView::isEmpty() const
 437 {
 438     return !length();
 439 }
 440 
 441 inline unsigned StringView::length() const
 442 {
 443     return m_length;
 444 }
 445 
 446 inline StringView::operator bool() const
 447 {
 448     return !isNull();
 449 }
 450 
 451 inline bool StringView::is8Bit() const
 452 {
 453     return m_is8Bit;
 454 }
 455 
 456 inline StringView StringView::substring(unsigned start, unsigned length) const
 457 {
 458     if (start &gt;= this-&gt;length())
 459         return empty();
 460     unsigned maxLength = this-&gt;length() - start;
 461 
 462     if (length &gt;= maxLength) {
 463         if (!start)
 464             return *this;
 465         length = maxLength;
 466     }
 467 
 468     if (is8Bit()) {
 469         StringView result(characters8() + start, length);
 470         result.setUnderlyingString(*this);
 471         return result;
 472     }
 473     StringView result(characters16() + start, length);
 474     result.setUnderlyingString(*this);
 475     return result;
 476 }
 477 
 478 inline UChar StringView::operator[](unsigned index) const
 479 {
 480     ASSERT(index &lt; length());
 481     if (is8Bit())
 482         return characters8()[index];
 483     return characters16()[index];
 484 }
 485 
 486 inline bool StringView::contains(UChar character) const
 487 {
 488     return find(character) != notFound;
 489 }
 490 
 491 inline bool StringView::contains(CodeUnitMatchFunction function) const
 492 {
 493     return find(function) != notFound;
 494 }
 495 
 496 inline void StringView::getCharactersWithUpconvert(LChar* destination) const
 497 {
 498     ASSERT(is8Bit());
 499     StringImpl::copyCharacters(destination, characters8(), m_length);
 500 }
 501 
 502 inline void StringView::getCharactersWithUpconvert(UChar* destination) const
 503 {
 504     if (is8Bit()) {
 505         StringImpl::copyCharacters(destination, characters8(), m_length);
 506         return;
 507     }
 508     StringImpl::copyCharacters(destination, characters16(), m_length);
 509 }
 510 
 511 inline StringView::UpconvertedCharacters::UpconvertedCharacters(const StringView&amp; string)
 512 {
 513     if (!string.is8Bit()) {
 514         m_characters = string.characters16();
 515         return;
 516     }
 517     const LChar* characters8 = string.characters8();
 518     unsigned length = string.m_length;
 519     m_upconvertedCharacters.reserveInitialCapacity(length);
 520     for (unsigned i = 0; i &lt; length; ++i)
 521         m_upconvertedCharacters.uncheckedAppend(characters8[i]);
 522     m_characters = m_upconvertedCharacters.data();
 523 }
 524 
 525 inline String StringView::toString() const
 526 {
 527     if (is8Bit())
 528         return String(characters8(), m_length);
 529     return String(characters16(), m_length);
 530 }
 531 
 532 inline AtomString StringView::toAtomString() const
 533 {
 534     if (is8Bit())
 535         return AtomString(characters8(), m_length);
 536     return AtomString(characters16(), m_length);
 537 }
 538 
 539 inline RefPtr&lt;AtomStringImpl&gt; StringView::toExistingAtomString() const
 540 {
 541     if (is8Bit())
 542         return AtomStringImpl::lookUp(characters8(), m_length);
 543     return AtomStringImpl::lookUp(characters16(), m_length);
 544 }
 545 
 546 inline float StringView::toFloat(bool&amp; isValid) const
 547 {
 548     if (is8Bit())
 549         return charactersToFloat(characters8(), m_length, &amp;isValid);
 550     return charactersToFloat(characters16(), m_length, &amp;isValid);
 551 }
 552 
 553 inline int StringView::toInt() const
 554 {
 555     bool isValid;
 556     return toInt(isValid);
 557 }
 558 
 559 inline int StringView::toInt(bool&amp; isValid) const
 560 {
 561     if (is8Bit())
 562         return charactersToInt(characters8(), m_length, &amp;isValid);
 563     return charactersToInt(characters16(), m_length, &amp;isValid);
 564 }
 565 
 566 inline int StringView::toIntStrict(bool&amp; isValid) const
 567 {
 568     if (is8Bit())
 569         return charactersToIntStrict(characters8(), m_length, &amp;isValid);
 570     return charactersToIntStrict(characters16(), m_length, &amp;isValid);
 571 }
 572 
 573 inline Optional&lt;uint64_t&gt; StringView::toUInt64Strict() const
 574 {
 575     bool isValid;
 576     uint64_t result = is8Bit() ? charactersToUInt64Strict(characters8(), m_length, &amp;isValid) : charactersToUInt64Strict(characters16(), m_length, &amp;isValid);
 577     return isValid ? makeOptional(result) : WTF::nullopt;
 578 }
 579 
 580 inline String StringView::toStringWithoutCopying() const
 581 {
 582     if (is8Bit())
 583         return StringImpl::createWithoutCopying(characters8(), m_length);
 584     return StringImpl::createWithoutCopying(characters16(), m_length);
 585 }
 586 
 587 inline size_t StringView::find(UChar character, unsigned start) const
 588 {
 589     if (is8Bit())
 590         return WTF::find(characters8(), m_length, character, start);
 591     return WTF::find(characters16(), m_length, character, start);
 592 }
 593 
 594 inline size_t StringView::find(CodeUnitMatchFunction matchFunction, unsigned start) const
 595 {
 596     if (is8Bit())
 597         return WTF::find(characters8(), m_length, matchFunction, start);
 598     return WTF::find(characters16(), m_length, matchFunction, start);
 599 }
 600 
 601 inline size_t StringView::reverseFind(UChar character, unsigned index) const
 602 {
 603     if (is8Bit())
 604         return WTF::reverseFind(characters8(), m_length, character, index);
 605     return WTF::reverseFind(characters16(), m_length, character, index);
 606 }
 607 
 608 #if !CHECK_STRINGVIEW_LIFETIME
 609 
 610 inline void StringView::invalidate(const StringImpl&amp;)
 611 {
 612 }
 613 
 614 #endif
 615 
 616 template&lt;&gt; class StringTypeAdapter&lt;StringView, void&gt; {
 617 public:
 618     StringTypeAdapter(StringView string)
 619         : m_string { string }
 620     {
 621     }
 622 
 623     unsigned length() { return m_string.length(); }
 624     bool is8Bit() { return m_string.is8Bit(); }
 625     template&lt;typename CharacterType&gt; void writeTo(CharacterType* destination) { m_string.getCharactersWithUpconvert(destination); }
 626 
 627 private:
 628     StringView m_string;
 629 };
 630 
 631 template&lt;typename CharacterType, size_t inlineCapacity&gt; void append(Vector&lt;CharacterType, inlineCapacity&gt;&amp; buffer, StringView string)
 632 {
 633     unsigned oldSize = buffer.size();
 634     buffer.grow(oldSize + string.length());
 635     string.getCharactersWithUpconvert(buffer.data() + oldSize);
 636 }
 637 
 638 inline bool equal(StringView a, StringView b)
 639 {
 640     if (a.m_characters == b.m_characters) {
 641         ASSERT(a.is8Bit() == b.is8Bit());
 642         return a.length() == b.length();
 643     }
 644 
 645     return equalCommon(a, b);
 646 }
 647 
 648 inline bool equal(StringView a, const LChar* b)
 649 {
 650     if (!b)
 651         return !a.isEmpty();
 652     if (a.isEmpty())
 653         return !b;
 654 
 655     unsigned aLength = a.length();
 656     if (aLength != strlen(reinterpret_cast&lt;const char*&gt;(b)))
 657         return false;
 658 
 659     if (a.is8Bit())
 660         return equal(a.characters8(), b, aLength);
 661     return equal(a.characters16(), b, aLength);
 662 }
 663 
 664 inline bool equalIgnoringASCIICase(StringView a, StringView b)
 665 {
 666     return equalIgnoringASCIICaseCommon(a, b);
 667 }
 668 
 669 inline bool equalIgnoringASCIICase(StringView a, const char* b)
 670 {
 671     return equalIgnoringASCIICaseCommon(a, b);
 672 }
 673 
 674 class StringView::SplitResult {
 675     WTF_MAKE_FAST_ALLOCATED;
 676 public:
 677     SplitResult(StringView, UChar separator, bool allowEmptyEntries);
 678 
 679     class Iterator;
 680     Iterator begin() const;
 681     Iterator end() const;
 682 
 683 private:
 684     StringView m_string;
 685     UChar m_separator;
 686     bool m_allowEmptyEntries;
 687 };
 688 
 689 class StringView::GraphemeClusters {
 690     WTF_MAKE_FAST_ALLOCATED;
 691 public:
 692     explicit GraphemeClusters(const StringView&amp;);
 693 
 694     class Iterator;
 695     Iterator begin() const;
 696     Iterator end() const;
 697 
 698 private:
 699     StringView m_stringView;
 700 };
 701 
 702 class StringView::CodePoints {
 703     WTF_MAKE_FAST_ALLOCATED;
 704 public:
 705     explicit CodePoints(const StringView&amp;);
 706 
 707     class Iterator;
 708     Iterator begin() const;
 709     Iterator end() const;
 710 
 711 private:
 712     StringView m_stringView;
 713 };
 714 
 715 class StringView::CodeUnits {
 716     WTF_MAKE_FAST_ALLOCATED;
 717 public:
 718     explicit CodeUnits(const StringView&amp;);
 719 
 720     class Iterator;
 721     Iterator begin() const;
 722     Iterator end() const;
 723 
 724 private:
 725     StringView m_stringView;
 726 };
 727 
 728 class StringView::SplitResult::Iterator {
 729     WTF_MAKE_FAST_ALLOCATED;
 730 public:
 731     StringView operator*() const;
 732 
 733     WTF_EXPORT_PRIVATE Iterator&amp; operator++();
 734 
 735     bool operator==(const Iterator&amp;) const;
 736     bool operator!=(const Iterator&amp;) const;
 737 
 738 private:
 739     enum PositionTag { AtEnd };
 740     Iterator(const SplitResult&amp;);
 741     Iterator(const SplitResult&amp;, PositionTag);
 742 
 743     WTF_EXPORT_PRIVATE void findNextSubstring();
 744 
 745     friend SplitResult;
 746 
 747     const SplitResult&amp; m_result;
 748     unsigned m_position { 0 };
 749     unsigned m_length;
 750     bool m_isDone;
 751 };
 752 
 753 class StringView::GraphemeClusters::Iterator {
 754     WTF_MAKE_FAST_ALLOCATED;
 755 public:
 756     Iterator() = delete;
 757     WTF_EXPORT_PRIVATE Iterator(const StringView&amp;, unsigned index);
 758     WTF_EXPORT_PRIVATE ~Iterator();
 759 
 760     Iterator(const Iterator&amp;) = delete;
 761     WTF_EXPORT_PRIVATE Iterator(Iterator&amp;&amp;);
 762     Iterator&amp; operator=(const Iterator&amp;) = delete;
 763     Iterator&amp; operator=(Iterator&amp;&amp;) = delete;
 764 
 765     WTF_EXPORT_PRIVATE StringView operator*() const;
 766     WTF_EXPORT_PRIVATE Iterator&amp; operator++();
 767 
 768     WTF_EXPORT_PRIVATE bool operator==(const Iterator&amp;) const;
 769     WTF_EXPORT_PRIVATE bool operator!=(const Iterator&amp;) const;
 770 
 771 private:
 772     class Impl;
 773 
 774     std::unique_ptr&lt;Impl&gt; m_impl;
 775 };
 776 
 777 class StringView::CodePoints::Iterator {
 778     WTF_MAKE_FAST_ALLOCATED;
 779 public:
 780     Iterator(const StringView&amp;, unsigned index);
 781 
 782     UChar32 operator*() const;
 783     Iterator&amp; operator++();
 784 
 785     bool operator==(const Iterator&amp;) const;
 786     bool operator!=(const Iterator&amp;) const;
 787 
 788 private:
 789     std::reference_wrapper&lt;const StringView&gt; m_stringView;
 790     Optional&lt;unsigned&gt; m_nextCodePointOffset;
 791     UChar32 m_codePoint;
 792 };
 793 
 794 class StringView::CodeUnits::Iterator {
 795     WTF_MAKE_FAST_ALLOCATED;
 796 public:
 797     Iterator(const StringView&amp;, unsigned index);
 798 
 799     UChar operator*() const;
 800     Iterator&amp; operator++();
 801 
 802     bool operator==(const Iterator&amp;) const;
 803     bool operator!=(const Iterator&amp;) const;
 804 
 805 private:
 806     const StringView&amp; m_stringView;
 807     unsigned m_index;
 808 };
 809 
 810 inline auto StringView::graphemeClusters() const -&gt; GraphemeClusters
 811 {
 812     return GraphemeClusters(*this);
 813 }
 814 
 815 inline auto StringView::codePoints() const -&gt; CodePoints
 816 {
 817     return CodePoints(*this);
 818 }
 819 
 820 inline auto StringView::codeUnits() const -&gt; CodeUnits
 821 {
 822     return CodeUnits(*this);
 823 }
 824 
 825 inline StringView::GraphemeClusters::GraphemeClusters(const StringView&amp; stringView)
 826     : m_stringView(stringView)
 827 {
 828 }
 829 
 830 inline auto StringView::GraphemeClusters::begin() const -&gt; Iterator
 831 {
 832     return Iterator(m_stringView, 0);
 833 }
 834 
 835 inline auto StringView::GraphemeClusters::end() const -&gt; Iterator
 836 {
 837     return Iterator(m_stringView, m_stringView.length());
 838 }
 839 
 840 inline StringView::CodePoints::CodePoints(const StringView&amp; stringView)
 841     : m_stringView(stringView)
 842 {
 843 }
 844 
 845 inline StringView::CodePoints::Iterator::Iterator(const StringView&amp; stringView, unsigned index)
 846     : m_stringView(stringView)
 847     , m_nextCodePointOffset(index)
 848 {
 849     operator++();
 850 }
 851 
 852 inline auto StringView::CodePoints::Iterator::operator++() -&gt; Iterator&amp;
 853 {
 854     ASSERT(m_nextCodePointOffset);
 855     if (m_nextCodePointOffset.value() == m_stringView.get().length()) {
 856         m_nextCodePointOffset = WTF::nullopt;
 857         return *this;
 858     }
 859     if (m_stringView.get().is8Bit())
 860         m_codePoint = m_stringView.get().characters8()[m_nextCodePointOffset.value()++];
 861     else
 862         U16_NEXT(m_stringView.get().characters16(), m_nextCodePointOffset.value(), m_stringView.get().length(), m_codePoint);
 863     ASSERT(m_nextCodePointOffset.value() &lt;= m_stringView.get().length());
 864     return *this;
 865 }
 866 
 867 inline UChar32 StringView::CodePoints::Iterator::operator*() const
 868 {
 869     ASSERT(m_nextCodePointOffset);
 870     return m_codePoint;
 871 }
 872 
 873 inline bool StringView::CodePoints::Iterator::operator==(const Iterator&amp; other) const
 874 {
 875     ASSERT(&amp;m_stringView.get() == &amp;other.m_stringView.get());
 876     return m_nextCodePointOffset == other.m_nextCodePointOffset;
 877 }
 878 
 879 inline bool StringView::CodePoints::Iterator::operator!=(const Iterator&amp; other) const
 880 {
 881     return !(*this == other);
 882 }
 883 
 884 inline auto StringView::CodePoints::begin() const -&gt; Iterator
 885 {
 886     return Iterator(m_stringView, 0);
 887 }
 888 
 889 inline auto StringView::CodePoints::end() const -&gt; Iterator
 890 {
 891     return Iterator(m_stringView, m_stringView.length());
 892 }
 893 
 894 inline StringView::CodeUnits::CodeUnits(const StringView&amp; stringView)
 895     : m_stringView(stringView)
 896 {
 897 }
 898 
 899 inline StringView::CodeUnits::Iterator::Iterator(const StringView&amp; stringView, unsigned index)
 900     : m_stringView(stringView)
 901     , m_index(index)
 902 {
 903 }
 904 
 905 inline auto StringView::CodeUnits::Iterator::operator++() -&gt; Iterator&amp;
 906 {
 907     ++m_index;
 908     return *this;
 909 }
 910 
 911 inline UChar StringView::CodeUnits::Iterator::operator*() const
 912 {
 913     return m_stringView[m_index];
 914 }
 915 
 916 inline bool StringView::CodeUnits::Iterator::operator==(const Iterator&amp; other) const
 917 {
 918     ASSERT(&amp;m_stringView == &amp;other.m_stringView);
 919     return m_index == other.m_index;
 920 }
 921 
 922 inline bool StringView::CodeUnits::Iterator::operator!=(const Iterator&amp; other) const
 923 {
 924     return !(*this == other);
 925 }
 926 
 927 inline auto StringView::CodeUnits::begin() const -&gt; Iterator
 928 {
 929     return Iterator(m_stringView, 0);
 930 }
 931 
 932 inline auto StringView::CodeUnits::end() const -&gt; Iterator
 933 {
 934     return Iterator(m_stringView, m_stringView.length());
 935 }
 936 
 937 inline auto StringView::split(UChar separator) const -&gt; SplitResult
 938 {
 939     return SplitResult { *this, separator, false };
 940 }
 941 
 942 inline auto StringView::splitAllowingEmptyEntries(UChar separator) const -&gt; SplitResult
 943 {
 944     return SplitResult { *this, separator, true };
 945 }
 946 
 947 inline StringView::SplitResult::SplitResult(StringView stringView, UChar separator, bool allowEmptyEntries)
 948     : m_string { stringView }
 949     , m_separator { separator }
 950     , m_allowEmptyEntries { allowEmptyEntries }
 951 {
 952 }
 953 
 954 inline auto StringView::SplitResult::begin() const -&gt; Iterator
 955 {
 956     return Iterator { *this };
 957 }
 958 
 959 inline auto StringView::SplitResult::end() const -&gt; Iterator
 960 {
 961     return Iterator { *this, Iterator::AtEnd };
 962 }
 963 
 964 inline StringView::SplitResult::Iterator::Iterator(const SplitResult&amp; result)
 965     : m_result { result }
 966     , m_isDone { result.m_string.isEmpty() &amp;&amp; !result.m_allowEmptyEntries }
 967 {
 968     findNextSubstring();
 969 }
 970 
 971 inline StringView::SplitResult::Iterator::Iterator(const SplitResult&amp; result, PositionTag)
 972     : m_result { result }
 973     , m_position { result.m_string.length() }
 974     , m_isDone { true }
 975 {
 976 }
 977 
 978 inline StringView StringView::SplitResult::Iterator::operator*() const
 979 {
 980     ASSERT(m_position &lt;= m_result.m_string.length() &amp;&amp; !m_isDone);
 981     return m_result.m_string.substring(m_position, m_length);
 982 }
 983 
 984 inline bool StringView::SplitResult::Iterator::operator==(const Iterator&amp; other) const
 985 {
 986     ASSERT(&amp;m_result == &amp;other.m_result);
 987     return m_position == other.m_position &amp;&amp; m_isDone == other.m_isDone;
 988 }
 989 
 990 inline bool StringView::SplitResult::Iterator::operator!=(const Iterator&amp; other) const
 991 {
 992     return !(*this == other);
 993 }
 994 
 995 template&lt;typename CharacterType, typename MatchedCharacterPredicate&gt;
 996 inline StringView StringView::stripLeadingAndTrailingMatchedCharacters(const CharacterType* characters, const MatchedCharacterPredicate&amp; predicate)
 997 {
 998     if (!m_length)
 999         return *this;
1000 
1001     unsigned start = 0;
1002     unsigned end = m_length - 1;
1003 
1004     while (start &lt;= end &amp;&amp; predicate(characters[start]))
1005         ++start;
1006 
1007     if (start &gt; end)
1008         return StringView::empty();
1009 
1010     while (end &amp;&amp; predicate(characters[end]))
1011         --end;
1012 
1013     if (!start &amp;&amp; end == m_length - 1)
1014         return *this;
1015 
1016     StringView result(characters + start, end + 1 - start);
1017     result.setUnderlyingString(*this);
1018     return result;
1019 }
1020 
1021 template&lt;typename MatchedCharacterPredicate&gt;
1022 StringView StringView::stripLeadingAndTrailingMatchedCharacters(const MatchedCharacterPredicate&amp; predicate)
1023 {
1024     if (is8Bit())
1025         return stripLeadingAndTrailingMatchedCharacters&lt;LChar&gt;(characters8(), predicate);
1026     return stripLeadingAndTrailingMatchedCharacters&lt;UChar&gt;(characters16(), predicate);
1027 }
1028 
1029 template&lt;unsigned length&gt; inline bool equalLettersIgnoringASCIICase(StringView string, const char (&amp;lowercaseLetters)[length])
1030 {
1031     return equalLettersIgnoringASCIICaseCommon(string, lowercaseLetters);
1032 }
1033 
1034 } // namespace WTF
1035 
1036 using WTF::append;
1037 using WTF::equal;
1038 using WTF::StringView;
1039 using WTF::StringViewWithUnderlyingString;
    </pre>
  </body>
</html>
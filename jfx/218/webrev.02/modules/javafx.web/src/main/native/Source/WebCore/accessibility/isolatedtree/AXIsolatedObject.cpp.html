<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/accessibility/isolatedtree/AXIsolatedObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
  29 #include &quot;AXIsolatedObject.h&quot;
  30 
  31 #include &quot;AXIsolatedTree.h&quot;
  32 
  33 namespace WebCore {
  34 
  35 AXIsolatedObject::AXIsolatedObject(AXCoreObject&amp; object, bool isRoot)
  36     : m_id(object.objectID())
  37 {
  38     ASSERT(isMainThread());
  39     initializeAttributeData(object, isRoot);
  40     m_initialized = true;
  41 }
  42 
  43 Ref&lt;AXIsolatedObject&gt; AXIsolatedObject::create(AXCoreObject&amp; object, bool isRoot)
  44 {
  45     return adoptRef(*new AXIsolatedObject(object, isRoot));
  46 }
  47 
  48 AXIsolatedObject::~AXIsolatedObject() = default;
  49 
  50 void AXIsolatedObject::initializeAttributeData(AXCoreObject&amp; object, bool isRoot)
  51 {
  52     setProperty(AXPropertyName::ARIALandmarkRoleDescription, object.ariaLandmarkRoleDescription().isolatedCopy());
  53     setProperty(AXPropertyName::BoundingBoxRect, object.boundingBoxRect());
  54     setProperty(AXPropertyName::Description, object.descriptionAttributeValue().isolatedCopy());
  55     setProperty(AXPropertyName::ElementRect, object.elementRect());
  56     setProperty(AXPropertyName::HelpText, object.helpTextAttributeValue().isolatedCopy());
  57     setProperty(AXPropertyName::IsARIATreeGridRow, object.isARIATreeGridRow());
  58     setProperty(AXPropertyName::IsAccessibilityIgnored, object.accessibilityIsIgnored());
  59     setProperty(AXPropertyName::IsActiveDescendantOfFocusedContainer, object.isActiveDescendantOfFocusedContainer());
  60     setProperty(AXPropertyName::IsAttachment, object.isAttachment());
  61     setProperty(AXPropertyName::IsBusy, object.isBusy());
  62     setProperty(AXPropertyName::IsButton, object.isButton());
  63     setProperty(AXPropertyName::IsChecked, object.isChecked());
  64     setProperty(AXPropertyName::IsCollapsed, object.isCollapsed());
  65     setProperty(AXPropertyName::IsControl, object.isControl());
  66     setProperty(AXPropertyName::IsDescriptionList, object.isDescriptionList());
  67     setProperty(AXPropertyName::IsEnabled, object.isEnabled());
  68     setProperty(AXPropertyName::IsExpanded, object.isExpanded());
  69     setProperty(AXPropertyName::IsFieldset, object.isFieldset());
  70     setProperty(AXPropertyName::IsFileUploadButton, object.isFileUploadButton());
  71     setProperty(AXPropertyName::IsFocused, object.isFocused());
  72     setProperty(AXPropertyName::IsGroup, object.isGroup());
  73     setProperty(AXPropertyName::IsHeading, object.isHeading());
  74     setProperty(AXPropertyName::IsHovered, object.isHovered());
  75     setProperty(AXPropertyName::IsImage, object.isImage());
  76     setProperty(AXPropertyName::IsImageMapLink, object.isImageMapLink());
  77     setProperty(AXPropertyName::IsIndeterminate, object.isIndeterminate());
  78     setProperty(AXPropertyName::IsInlineText, object.isInlineText());
  79     setProperty(AXPropertyName::IsInputImage, object.isInputImage());
  80     setProperty(AXPropertyName::IsLandmark, object.isLandmark());
  81     setProperty(AXPropertyName::IsLink, object.isLink());
  82     setProperty(AXPropertyName::IsLinked, object.isLinked());
  83     setProperty(AXPropertyName::IsList, object.isList());
  84     setProperty(AXPropertyName::IsLoaded, object.isLoaded());
  85     setProperty(AXPropertyName::IsMediaTimeline, object.isMediaTimeline());
  86     setProperty(AXPropertyName::IsMenu, object.isMenu());
  87     setProperty(AXPropertyName::IsMenuBar, object.isMenuBar());
  88     setProperty(AXPropertyName::IsMenuButton, object.isMenuButton());
  89     setProperty(AXPropertyName::IsMenuItem, object.isMenuItem());
  90     setProperty(AXPropertyName::IsMenuList, object.isMenuList());
  91     setProperty(AXPropertyName::IsMenuListOption, object.isMenuListOption());
  92     setProperty(AXPropertyName::IsMenuListPopup, object.isMenuListPopup());
  93     setProperty(AXPropertyName::IsMenuRelated, object.isMenuRelated());
  94     setProperty(AXPropertyName::IsMultiSelectable, object.isMultiSelectable());
  95     setProperty(AXPropertyName::IsOffScreen, object.isOffScreen());
  96     setProperty(AXPropertyName::IsOnScreen, object.isOnScreen());
  97     setProperty(AXPropertyName::IsOrderedList, object.isOrderedList());
  98     setProperty(AXPropertyName::IsOutput, object.isOutput());
  99     setProperty(AXPropertyName::IsPasswordField, object.isPasswordField());
 100     setProperty(AXPropertyName::IsPressed, object.isPressed());
 101     setProperty(AXPropertyName::IsProgressIndicator, object.isProgressIndicator());
 102     setProperty(AXPropertyName::IsRangeControl, object.isRangeControl());
 103     setProperty(AXPropertyName::IsRequired, object.isRequired());
 104     setProperty(AXPropertyName::IsScrollbar, object.isScrollbar());
 105     setProperty(AXPropertyName::IsSearchField, object.isSearchField());
 106     setProperty(AXPropertyName::IsSelected, object.isSelected());
 107     setProperty(AXPropertyName::IsSelectedOptionActive, object.isSelectedOptionActive());
 108     setProperty(AXPropertyName::IsSlider, object.isSlider());
 109     setProperty(AXPropertyName::IsStyleFormatGroup, object.isStyleFormatGroup());
 110     setProperty(AXPropertyName::IsTableCell, object.isTableCell());
 111     setProperty(AXPropertyName::IsTableColumn, object.isTableColumn());
 112     setProperty(AXPropertyName::IsTableRow, object.isTableRow());
 113     setProperty(AXPropertyName::IsTextControl, object.isTextControl());
 114     setProperty(AXPropertyName::IsTree, object.isTree());
 115     setProperty(AXPropertyName::IsUnorderedList, object.isUnorderedList());
 116     setProperty(AXPropertyName::IsUnvisited, object.isUnvisited());
 117     setProperty(AXPropertyName::IsValueAutofillAvailable, object.isValueAutofillAvailable());
 118     setProperty(AXPropertyName::IsValueAutofilled, object.isValueAutofilled());
 119     setProperty(AXPropertyName::IsVisible, object.isVisible());
 120     setProperty(AXPropertyName::IsVisited, object.isVisited());
 121     setProperty(AXPropertyName::RelativeFrame, object.relativeFrame());
 122     setProperty(AXPropertyName::RoleDescription, object.roleDescription().isolatedCopy());
 123     setProperty(AXPropertyName::RolePlatformString, object.rolePlatformString().isolatedCopy());
 124     setProperty(AXPropertyName::RoleValue, static_cast&lt;int&gt;(object.roleValue()));
 125     setProperty(AXPropertyName::SpeechHint, object.speechHintAttributeValue().isolatedCopy());
 126     setProperty(AXPropertyName::Title, object.titleAttributeValue().isolatedCopy());
 127     setProperty(AXPropertyName::SupportsDatetimeAttribute, object.supportsDatetimeAttribute());
 128     setProperty(AXPropertyName::DatetimeAttributeValue, object.datetimeAttributeValue());
 129     setProperty(AXPropertyName::CanSetFocusAttribute, object.canSetFocusAttribute());
 130     setProperty(AXPropertyName::CanSetTextRangeAttributes, object.canSetTextRangeAttributes());
 131     setProperty(AXPropertyName::CanSetValueAttribute, object.canSetValueAttribute());
 132     setProperty(AXPropertyName::CanSetNumericValue, object.canSetNumericValue());
 133     setProperty(AXPropertyName::SupportsRequiredAttribute, object.supportsRequiredAttribute());
 134     setProperty(AXPropertyName::CanSetSelectedAttribute, object.canSetSelectedAttribute());
 135     setProperty(AXPropertyName::CanSetSelectedChildrenAttribute, object.canSetSelectedChildrenAttribute());
 136     setProperty(AXPropertyName::CanSetExpandedAttribute, object.canSetExpandedAttribute());
 137     setProperty(AXPropertyName::IsShowingValidationMessage, object.isShowingValidationMessage());
 138     setProperty(AXPropertyName::ValidationMessage, object.validationMessage());
 139     setProperty(AXPropertyName::BlockquoteLevel, object.blockquoteLevel());
 140     setProperty(AXPropertyName::HeadingLevel, object.headingLevel());
 141     setProperty(AXPropertyName::TableLevel, object.tableLevel());
 142     setProperty(AXPropertyName::AccessibilityButtonState, static_cast&lt;int&gt;(object.checkboxOrRadioValue()));
 143     setProperty(AXPropertyName::ValueDescription, object.valueDescription());
 144     setProperty(AXPropertyName::ValueForRange, object.valueForRange());
 145     setProperty(AXPropertyName::MaxValueForRange, object.maxValueForRange());
 146     setProperty(AXPropertyName::MinValueForRange, object.minValueForRange());
 147     setProperty(AXPropertyName::SelectedRadioButton, object.selectedRadioButton());
 148     setProperty(AXPropertyName::SelectedTabItem, object.selectedTabItem());
 149     setProperty(AXPropertyName::LayoutCount, object.layoutCount());
 150     setProperty(AXPropertyName::EstimatedLoadingProgress, object.estimatedLoadingProgress());
 151     setProperty(AXPropertyName::SupportsARIAOwns, object.supportsARIAOwns());
 152     setProperty(AXPropertyName::HasPopup, object.hasPopup());
 153     setProperty(AXPropertyName::PopupValue, object.popupValue());
 154     setProperty(AXPropertyName::PressedIsPresent, object.pressedIsPresent());
 155     setProperty(AXPropertyName::ARIAIsMultiline, object.ariaIsMultiline());
 156     setProperty(AXPropertyName::InvalidStatus, object.invalidStatus());
 157     setProperty(AXPropertyName::SupportsExpanded, object.supportsExpanded());
 158     setProperty(AXPropertyName::SortDirection, static_cast&lt;int&gt;(object.sortDirection()));
 159     setProperty(AXPropertyName::CanvasHasFallbackContent, object.canvasHasFallbackContent());
 160     setProperty(AXPropertyName::SupportsRangeValue, object.supportsRangeValue());
 161     setProperty(AXPropertyName::IdentifierAttribute, object.identifierAttribute());
 162     setProperty(AXPropertyName::LinkRelValue, object.linkRelValue());
 163     setProperty(AXPropertyName::CurrentState, static_cast&lt;int&gt;(object.currentState()));
 164     setProperty(AXPropertyName::CurrentValue, object.currentValue());
 165     setProperty(AXPropertyName::SupportsCurrent, object.supportsCurrent());
 166     setProperty(AXPropertyName::KeyShortcutsValue, object.keyShortcutsValue());
 167     setProperty(AXPropertyName::SupportsSetSize, object.supportsSetSize());
 168     setProperty(AXPropertyName::SupportsPath, object.supportsPath());
 169     setProperty(AXPropertyName::SupportsPosInSet, object.supportsPosInSet());
 170     setProperty(AXPropertyName::SetSize, object.setSize());
 171     setProperty(AXPropertyName::PosInSet, object.posInSet());
 172     setProperty(AXPropertyName::SupportsARIADropping, object.supportsARIADropping());
 173     setProperty(AXPropertyName::SupportsARIADragging, object.supportsARIADragging());
 174     setProperty(AXPropertyName::IsARIAGrabbed, object.isARIAGrabbed());
 175     setProperty(AXPropertyName::ARIADropEffects, object.determineARIADropEffects());
 176     setObjectProperty(AXPropertyName::TitleUIElement, object.titleUIElement());
 177     setProperty(AXPropertyName::ExposesTitleUIElement, object.exposesTitleUIElement());
 178     setObjectProperty(AXPropertyName::VerticalScrollBar, object.scrollBar(AccessibilityOrientation::Vertical));
 179     setObjectProperty(AXPropertyName::HorizontalScrollBar, object.scrollBar(AccessibilityOrientation::Horizontal));
 180     setProperty(AXPropertyName::ARIARoleAttribute, static_cast&lt;int&gt;(object.ariaRoleAttribute()));
 181     setProperty(AXPropertyName::ComputedLabel, object.computedLabel());
 182     setProperty(AXPropertyName::PlaceholderValue, object.placeholderValue());
 183     setProperty(AXPropertyName::ExpandedTextValue, object.expandedTextValue());
 184     setProperty(AXPropertyName::SupportsExpandedTextValue, object.supportsExpandedTextValue());
 185     setProperty(AXPropertyName::SupportsPressAction, object.supportsPressAction());
 186     setProperty(AXPropertyName::ClickPoint, object.clickPoint());
 187     setProperty(AXPropertyName::ComputedRoleString, object.computedRoleString());
 188     setProperty(AXPropertyName::ValueAutofillButtonType, static_cast&lt;int&gt;(object.valueAutofillButtonType()));
 189     setProperty(AXPropertyName::URL, object.url());
 190     setProperty(AXPropertyName::AccessKey, object.accessKey());
 191     setProperty(AXPropertyName::ActionVerb, object.actionVerb());
 192     setProperty(AXPropertyName::ReadOnlyValue, object.readOnlyValue());
 193     setProperty(AXPropertyName::AutoCompleteValue, object.autoCompleteValue());
 194     setProperty(AXPropertyName::SpeakAs, object.speakAsProperty());
 195     setProperty(AXPropertyName::StringValue, object.stringValue().isolatedCopy());
 196 #if PLATFORM(COCOA) &amp;&amp; !PLATFORM(IOS_FAMILY)
 197     setProperty(AXPropertyName::CaretBrowsingEnabled, object.caretBrowsingEnabled());
 198 #endif
 199     setObjectProperty(AXPropertyName::FocusableAncestor, object.focusableAncestor());
 200     setObjectProperty(AXPropertyName::EditableAncestor, object.editableAncestor());
 201     setObjectProperty(AXPropertyName::HighestEditableAncestor, object.highestEditableAncestor());
 202     setProperty(AXPropertyName::Orientation, static_cast&lt;int&gt;(object.orientation()));
 203     setProperty(AXPropertyName::HierarchicalLevel, object.hierarchicalLevel());
 204     setProperty(AXPropertyName::Language, object.language());
 205     setProperty(AXPropertyName::CanHaveSelectedChildren, object.canHaveSelectedChildren());
 206     setProperty(AXPropertyName::HasARIAValueNow, object.hasARIAValueNow());
 207     setProperty(AXPropertyName::TagName, object.tagName().isolatedCopy());
 208     setProperty(AXPropertyName::SupportsLiveRegion, object.supportsLiveRegion());
 209     setProperty(AXPropertyName::IsInsideLiveRegion, object.isInsideLiveRegion());
 210     setProperty(AXPropertyName::LiveRegionStatus, object.liveRegionStatus());
 211     setProperty(AXPropertyName::LiveRegionRelevant, object.liveRegionRelevant());
 212     setProperty(AXPropertyName::LiveRegionAtomic, object.liveRegionAtomic());
 213     if (object.isTextControl())
 214         setProperty(AXPropertyName::TextLength, object.textLength());
 215 
 216     AccessibilityChildrenVector selectedChildren;
 217     object.selectedChildren(selectedChildren);
 218     setObjectVectorProperty(AXPropertyName::SelectedChildren, selectedChildren);
 219 
 220     AccessibilityChildrenVector visibleChildren;
 221     object.visibleChildren(visibleChildren);
 222     setObjectVectorProperty(AXPropertyName::VisibleChildren, visibleChildren);
 223 
 224     AccessibilityChildrenVector tabChildren;
 225     object.tabChildren(tabChildren);
 226     setObjectVectorProperty(AXPropertyName::TabChildren, tabChildren);
 227 
 228     AccessibilityChildrenVector ariaTreeRows;
 229     object.ariaTreeRows(ariaTreeRows);
 230     setObjectVectorProperty(AXPropertyName::ARIATreeRows, ariaTreeRows);
 231 
 232     AccessibilityChildrenVector ariaTreeItemDisclosedRows;
 233     object.ariaTreeItemDisclosedRows(ariaTreeItemDisclosedRows);
 234     setObjectVectorProperty(AXPropertyName::ARIATreeItemDisclosedRows, ariaTreeItemDisclosedRows);
 235 
 236     AccessibilityChildrenVector ariaTreeItemContent;
 237     object.ariaTreeItemContent(ariaTreeItemContent);
 238     setObjectVectorProperty(AXPropertyName::ARIATreeItemContent, ariaTreeItemContent);
 239 
 240     AccessibilityChildrenVector linkedUIElements;
 241     object.linkedUIElements(linkedUIElements);
 242     setObjectVectorProperty(AXPropertyName::LinkedUIElements, linkedUIElements);
 243 
 244     AccessibilityChildrenVector ariaControlsElements;
 245     object.ariaControlsElements(ariaControlsElements);
 246     setObjectVectorProperty(AXPropertyName::ARIAControlsElements, ariaControlsElements);
 247 
 248     AccessibilityChildrenVector ariaDetailsElements;
 249     object.ariaDetailsElements(ariaDetailsElements);
 250     setObjectVectorProperty(AXPropertyName::ARIADetailsElements, ariaDetailsElements);
 251 
 252     AccessibilityChildrenVector ariaErrorMessageElements;
 253     object.ariaErrorMessageElements(ariaErrorMessageElements);
 254     setObjectVectorProperty(AXPropertyName::ARIAErrorMessageElements, ariaErrorMessageElements);
 255 
 256     AccessibilityChildrenVector ariaFlowToElements;
 257     object.ariaFlowToElements(ariaFlowToElements);
 258     setObjectVectorProperty(AXPropertyName::ARIAFlowToElements, ariaFlowToElements);
 259 
 260     AccessibilityChildrenVector ariaOwnsElements;
 261     object.ariaOwnsElements(ariaOwnsElements);
 262     setObjectVectorProperty(AXPropertyName::ARIAOwnsElements, ariaOwnsElements);
 263 
 264     Vector&lt;AccessibilityText&gt; texts;
 265     object.accessibilityText(texts);
 266     Vector&lt;AccessibilityIsolatedTreeText&gt; isolatedTexts;
 267     isolatedTexts.reserveCapacity(texts.size());
 268     for (auto text : texts) {
 269         AccessibilityIsolatedTreeText isolatedText;
 270         isolatedText.text = text.text;
 271         isolatedText.textSource = text.textSource;
 272         for (auto object : text.textElements)
 273             isolatedText.textElements.append(object-&gt;objectID());
 274         isolatedTexts.uncheckedAppend(isolatedText);
 275     }
 276     setProperty(AXPropertyName::AccessibilityText, isolatedTexts);
 277 
 278     // Spin button support.
 279     setObjectProperty(AXPropertyName::DecrementButton, object.decrementButton());
 280     setObjectProperty(AXPropertyName::IncrementButton, object.incrementButton());
 281     setProperty(AXPropertyName::IsIncrementor, object.isIncrementor());
 282 
 283     Vector&lt;String&gt; classList;
 284     object.classList(classList);
 285     String combinedClassList;
 286     for (auto it = classList.begin(), end = classList.end(); it != end; ++it) {
 287         combinedClassList.append(*it);
 288         combinedClassList.append(&quot; &quot;);
 289     }
 290     setProperty(AXPropertyName::ClassList, combinedClassList);
 291 
 292     int r, g, b;
 293     object.colorValue(r, g, b);
 294     setProperty(AXPropertyName::ColorValue, Color(r, g, b));
 295 
 296     if (bool isMathElement = object.isMathElement()) {
 297         setProperty(AXPropertyName::IsMathElement, isMathElement);
 298         setProperty(AXPropertyName::IsAnonymousMathOperator, object.isAnonymousMathOperator());
 299         setProperty(AXPropertyName::IsMathFraction, object.isMathFraction());
 300         setProperty(AXPropertyName::IsMathFenced, object.isMathFenced());
 301         setProperty(AXPropertyName::IsMathSubscriptSuperscript, object.isMathSubscriptSuperscript());
 302         setProperty(AXPropertyName::IsMathRow, object.isMathRow());
 303         setProperty(AXPropertyName::IsMathUnderOver, object.isMathUnderOver());
 304         setProperty(AXPropertyName::IsMathRoot, object.isMathRoot());
 305         setProperty(AXPropertyName::IsMathSquareRoot, object.isMathSquareRoot());
 306         setProperty(AXPropertyName::IsMathText, object.isMathText());
 307         setProperty(AXPropertyName::IsMathNumber, object.isMathNumber());
 308         setProperty(AXPropertyName::IsMathOperator, object.isMathOperator());
 309         setProperty(AXPropertyName::IsMathFenceOperator, object.isMathFenceOperator());
 310         setProperty(AXPropertyName::IsMathSeparatorOperator, object.isMathSeparatorOperator());
 311         setProperty(AXPropertyName::IsMathIdentifier, object.isMathIdentifier());
 312         setProperty(AXPropertyName::IsMathTable, object.isMathTable());
 313         setProperty(AXPropertyName::IsMathTableRow, object.isMathTableRow());
 314         setProperty(AXPropertyName::IsMathTableCell, object.isMathTableCell());
 315         setProperty(AXPropertyName::IsMathMultiscript, object.isMathMultiscript());
 316         setProperty(AXPropertyName::IsMathToken, object.isMathToken());
 317         setProperty(AXPropertyName::MathFencedOpenString, object.mathFencedOpenString());
 318         setProperty(AXPropertyName::MathFencedCloseString, object.mathFencedCloseString());
 319         setProperty(AXPropertyName::MathLineThickness, object.mathLineThickness());
 320         setObjectProperty(AXPropertyName::MathRadicandObject, object.mathRadicandObject());
 321         setObjectProperty(AXPropertyName::MathRootIndexObject, object.mathRootIndexObject());
 322         setObjectProperty(AXPropertyName::MathUnderObject, object.mathUnderObject());
 323         setObjectProperty(AXPropertyName::MathOverObject, object.mathOverObject());
 324         setObjectProperty(AXPropertyName::MathNumeratorObject, object.mathNumeratorObject());
 325         setObjectProperty(AXPropertyName::MathDenominatorObject, object.mathDenominatorObject());
 326         setObjectProperty(AXPropertyName::MathBaseObject, object.mathBaseObject());
 327         setObjectProperty(AXPropertyName::MathSubscriptObject, object.mathSubscriptObject());
 328         setObjectProperty(AXPropertyName::MathSuperscriptObject, object.mathSuperscriptObject());
 329         setMathscripts(AXPropertyName::MathPrescripts, object);
 330         setMathscripts(AXPropertyName::MathPostscripts, object);
 331     }
 332 
 333     if (isRoot) {
 334         setProperty(AXPropertyName::PreventKeyboardDOMEventDispatch, object.preventKeyboardDOMEventDispatch());
 335         setProperty(AXPropertyName::SessionID, object.sessionID());
 336         setProperty(AXPropertyName::DocumentURI, object.documentURI());
 337         setProperty(AXPropertyName::DocumentEncoding, object.documentEncoding());
 338     }
 339 }
 340 
 341 void AXIsolatedObject::setMathscripts(AXPropertyName propertyName, AXCoreObject&amp; object)
 342 {
 343     AccessibilityMathMultiscriptPairs pairs;
 344     if (propertyName == AXPropertyName::MathPrescripts)
 345         object.mathPrescripts(pairs);
 346     else if (propertyName == AXPropertyName::MathPostscripts)
 347         object.mathPostscripts(pairs);
 348 
 349     size_t mathSize = pairs.size();
 350     if (!mathSize)
 351         return;
 352 
 353     Vector&lt;AccessibilityIsolatedTreeMathMultiscriptPair&gt; idPairs;
 354     idPairs.reserveCapacity(mathSize);
 355     for (auto mathPair : pairs) {
 356         AccessibilityIsolatedTreeMathMultiscriptPair idPair;
 357         if (mathPair.first)
 358             idPair.first = mathPair.first-&gt;objectID();
 359         if (mathPair.second)
 360             idPair.second = mathPair.second-&gt;objectID();
 361         idPairs.uncheckedAppend(idPair);
 362     }
 363     setProperty(propertyName, idPairs);
 364 }
 365 
 366 void AXIsolatedObject::setObjectProperty(AXPropertyName propertyName, AXCoreObject* object)
 367 {
 368     if (object)
 369         setProperty(propertyName, object-&gt;objectID());
 370     else
 371         setProperty(propertyName, nullptr, true);
 372 }
 373 
 374 void AXIsolatedObject::setObjectVectorProperty(AXPropertyName propertyName, AccessibilityChildrenVector&amp; children)
 375 {
 376     size_t childrenSize = children.size();
 377     if (!childrenSize)
 378         return;
 379 
 380     Vector&lt;AXID&gt; childrenVector;
 381     childrenVector.reserveCapacity(childrenSize);
 382     for (auto childObject : children)
 383         childrenVector.uncheckedAppend(childObject-&gt;objectID());
 384     setProperty(propertyName, childrenVector);
 385 }
 386 
 387 void AXIsolatedObject::setProperty(AXPropertyName propertyName, AttributeValueVariant&amp;&amp; value, bool shouldRemove)
 388 {
 389     ASSERT(!m_initialized);
 390     ASSERT(isMainThread());
 391 
 392     if (shouldRemove)
 393         m_attributeMap.remove(propertyName);
 394     else
 395         m_attributeMap.set(propertyName, value);
 396 }
 397 
 398 void AXIsolatedObject::appendChild(AXID axID)
 399 {
 400     ASSERT(isMainThread());
 401     m_childrenIDs.append(axID);
 402 }
 403 
 404 void AXIsolatedObject::setParent(AXID parent)
 405 {
 406     ASSERT(isMainThread());
 407     m_parent = parent;
 408 }
 409 
 410 void AXIsolatedObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)
 411 {
 412     ASSERT_UNUSED(detachmentType, isMainThread() ? detachmentType == AccessibilityDetachmentType::CacheDestroyed : detachmentType != AccessibilityDetachmentType::CacheDestroyed);
 413     for (const auto&amp; childID : m_childrenIDs) {
 414         if (auto child = tree()-&gt;nodeForID(childID))
 415             child-&gt;detachFromParent();
 416     }
 417     m_childrenIDs.clear();
 418 }
 419 
 420 bool AXIsolatedObject::isDetached() const
 421 {
 422     ASSERT_NOT_REACHED();
 423     return false;
 424 }
 425 
 426 void AXIsolatedObject::detachFromParent()
 427 {
 428     m_parent = InvalidAXID;
 429 }
 430 
 431 void AXIsolatedObject::setTreeIdentifier(AXIsolatedTreeID treeIdentifier)
 432 {
 433     m_treeIdentifier = treeIdentifier;
 434     if (auto tree = AXIsolatedTree::treeForID(m_treeIdentifier))
 435         m_cachedTree = tree;
 436 }
 437 
 438 const AXCoreObject::AccessibilityChildrenVector&amp; AXIsolatedObject::children(bool)
 439 {
 440     if (!isMainThread()) {
 441         m_children.clear();
 442         m_children.reserveInitialCapacity(m_childrenIDs.size());
 443         for (const auto&amp; childID : m_childrenIDs) {
 444             if (auto child = tree()-&gt;nodeForID(childID))
 445                 m_children.uncheckedAppend(child);
 446         }
 447     }
 448     return m_children;
 449 }
 450 
 451 bool AXIsolatedObject::isDetachedFromParent()
 452 {
 453     if (parent() != InvalidAXID)
 454         return false;
 455 
 456     // Check whether this is the root node, in which case we should return false.
 457     if (auto root = tree()-&gt;rootNode())
 458         return root-&gt;objectID() != m_id;
 459     return false;
 460 }
 461 
 462 void AXIsolatedObject::accessibilityText(Vector&lt;AccessibilityText&gt;&amp; texts) const
 463 {
 464     auto isolatedTexts = vectorAttributeValue&lt;AccessibilityIsolatedTreeText&gt;(AXPropertyName::AccessibilityText);
 465     for (const auto&amp; isolatedText : isolatedTexts) {
 466         AccessibilityText text(isolatedText.text, isolatedText.textSource);
 467         for (const auto&amp; axID : isolatedText.textElements) {
 468             if (auto object = tree()-&gt;nodeForID(axID))
 469                 text.textElements.append(object);
 470         }
 471         texts.append(text);
 472     }
 473 }
 474 
 475 void AXIsolatedObject::classList(Vector&lt;String&gt;&amp; list) const
 476 {
 477     String classList = stringAttributeValue(AXPropertyName::ClassList);
 478     list.appendVector(classList.split(&quot; &quot;));
 479 }
 480 
 481 uint64_t AXIsolatedObject::sessionID() const
 482 {
 483     if (auto root = tree()-&gt;rootNode())
 484         return root-&gt;uint64AttributeValue(AXPropertyName::SessionID);
 485     return 0;
 486 }
 487 
 488 String AXIsolatedObject::documentURI() const
 489 {
 490     if (auto root = tree()-&gt;rootNode())
 491         return root-&gt;stringAttributeValue(AXPropertyName::DocumentURI);
 492     return String();
 493 }
 494 
 495 bool AXIsolatedObject::preventKeyboardDOMEventDispatch() const
 496 {
 497     if (auto root = tree()-&gt;rootNode())
 498         return root-&gt;boolAttributeValue(AXPropertyName::PreventKeyboardDOMEventDispatch);
 499     return false;
 500 }
 501 
 502 String AXIsolatedObject::documentEncoding() const
 503 {
 504     if (auto root = tree()-&gt;rootNode())
 505         return root-&gt;stringAttributeValue(AXPropertyName::DocumentEncoding);
 506     return String();
 507 }
 508 
 509 void AXIsolatedObject::insertMathPairs(Vector&lt;AccessibilityIsolatedTreeMathMultiscriptPair&gt;&amp; isolatedPairs, AccessibilityMathMultiscriptPairs&amp; pairs)
 510 {
 511     for (const auto&amp; pair : isolatedPairs) {
 512         AccessibilityMathMultiscriptPair prescriptPair;
 513         if (auto coreObject = tree()-&gt;nodeForID(pair.first).get())
 514             prescriptPair.first = coreObject;
 515         if (auto coreObject = tree()-&gt;nodeForID(pair.second).get())
 516             prescriptPair.second = coreObject;
 517         pairs.append(prescriptPair);
 518     }
 519 }
 520 
 521 void AXIsolatedObject::mathPrescripts(AccessibilityMathMultiscriptPairs&amp; pairs)
 522 {
 523     auto isolatedPairs = vectorAttributeValue&lt;AccessibilityIsolatedTreeMathMultiscriptPair&gt;(AXPropertyName::MathPrescripts);
 524     insertMathPairs(isolatedPairs, pairs);
 525 }
 526 
 527 void AXIsolatedObject::mathPostscripts(AccessibilityMathMultiscriptPairs&amp; pairs)
 528 {
 529     auto isolatedPairs = vectorAttributeValue&lt;AccessibilityIsolatedTreeMathMultiscriptPair&gt;(AXPropertyName::MathPostscripts);
 530     insertMathPairs(isolatedPairs, pairs);
 531 }
 532 
 533 AXCoreObject* AXIsolatedObject::focusedUIElement() const
 534 {
 535     if (auto focusedElement = tree()-&gt;focusedUIElement())
 536         return focusedElement.get();
 537     return nullptr;
 538 }
 539 
 540 AXCoreObject* AXIsolatedObject::parentObjectUnignored() const
 541 {
 542     return tree()-&gt;nodeForID(parent()).get();
 543 }
 544 
 545 AXCoreObject* AXIsolatedObject::scrollBar(AccessibilityOrientation orientation)
 546 {
 547     return objectAttributeValue(orientation == AccessibilityOrientation::Vertical ? AXPropertyName::VerticalScrollBar : AXPropertyName::HorizontalScrollBar);
 548 }
 549 
 550 template&lt;typename U&gt;
 551 void AXIsolatedObject::performFunctionOnMainThread(U&amp;&amp; lambda)
 552 {
 553     Accessibility::performFunctionOnMainThread([&amp;lambda, this] () {
 554         if (auto* object = associatedAXObject())
 555             lambda(object);
 556     });
 557 }
 558 
 559 void AXIsolatedObject::setARIAGrabbed(bool value)
 560 {
 561     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 562         object-&gt;setARIAGrabbed(value);
 563     });
 564 }
 565 
 566 void AXIsolatedObject::setIsExpanded(bool value)
 567 {
 568     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 569         object-&gt;setIsExpanded(value);
 570     });
 571 }
 572 void AXIsolatedObject::setValue(float value)
 573 {
 574     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 575         object-&gt;setValue(value);
 576     });
 577 }
 578 
 579 void AXIsolatedObject::setSelected(bool value)
 580 {
 581     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 582         object-&gt;setSelected(value);
 583     });
 584 }
 585 void AXIsolatedObject::setSelectedRows(AccessibilityChildrenVector&amp; value)
 586 {
 587     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 588         object-&gt;setSelectedRows(value);
 589     });
 590 }
 591 
 592 void AXIsolatedObject::setFocused(bool value)
 593 {
 594     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 595         object-&gt;setFocused(value);
 596     });
 597 }
 598 
 599 void AXIsolatedObject::setSelectedText(const String&amp; value)
 600 {
 601     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 602         object-&gt;setSelectedText(value);
 603     });
 604 }
 605 
 606 void AXIsolatedObject::setSelectedTextRange(const PlainTextRange&amp; value)
 607 {
 608     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 609         object-&gt;setSelectedTextRange(value);
 610     });
 611 }
 612 
 613 void AXIsolatedObject::setValue(const String&amp; value)
 614 {
 615     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 616         object-&gt;setValue(value);
 617     });
 618 }
 619 
 620 #if PLATFORM(COCOA) &amp;&amp; !PLATFORM(IOS_FAMILY)
 621 void AXIsolatedObject::setCaretBrowsingEnabled(bool value)
 622 {
 623     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 624         object-&gt;setCaretBrowsingEnabled(value);
 625     });
 626 }
 627 #endif
 628 
 629 void AXIsolatedObject::setPreventKeyboardDOMEventDispatch(bool value)
 630 {
 631     performFunctionOnMainThread([&amp;value](AXCoreObject* object) {
 632         object-&gt;setPreventKeyboardDOMEventDispatch(value);
 633     });
 634 }
 635 
 636 void AXIsolatedObject::colorValue(int&amp; r, int&amp; g, int&amp; b) const
 637 {
 638     auto color = colorAttributeValue(AXPropertyName::ColorValue);
 639     r = color.red();
 640     g = color.green();
 641     b = color.blue();
 642 }
 643 
 644 AXCoreObject* AXIsolatedObject::accessibilityHitTest(const IntPoint&amp; point) const
 645 {
 646     if (!relativeFrame().contains(point))
 647         return nullptr;
 648     for (const auto&amp; childID : m_childrenIDs) {
 649         auto child = tree()-&gt;nodeForID(childID);
 650         ASSERT(child);
 651         if (child &amp;&amp; child-&gt;relativeFrame().contains(point))
 652             return child-&gt;accessibilityHitTest(point);
 653     }
 654     return const_cast&lt;AXIsolatedObject*&gt;(this);
 655 }
 656 
 657 IntPoint AXIsolatedObject::intPointAttributeValue(AXPropertyName propertyName) const
 658 {
 659     auto value = m_attributeMap.get(propertyName);
 660     return WTF::switchOn(value,
 661         [] (IntPoint&amp; typedValue) { return typedValue; },
 662         [] (auto&amp;) { return IntPoint(); }
 663     );
 664 }
 665 
 666 AXCoreObject* AXIsolatedObject::objectAttributeValue(AXPropertyName propertyName) const
 667 {
 668     auto value = m_attributeMap.get(propertyName);
 669     AXID nodeID = WTF::switchOn(value,
 670         [] (AXID&amp; typedValue) { return typedValue; },
 671         [] (auto&amp;) { return InvalidAXID; }
 672     );
 673 
 674     return tree()-&gt;nodeForID(nodeID).get();
 675 }
 676 
 677 template&lt;typename T&gt;
 678 T AXIsolatedObject::rectAttributeValue(AXPropertyName propertyName) const
 679 {
 680     auto value = m_attributeMap.get(propertyName);
 681     return WTF::switchOn(value,
 682         [] (T&amp; typedValue) { return typedValue; },
 683         [] (auto&amp;) { return T { }; }
 684     );
 685 }
 686 
 687 template&lt;typename T&gt;
 688 Vector&lt;T&gt; AXIsolatedObject::vectorAttributeValue(AXPropertyName propertyName) const
 689 {
 690     auto value = m_attributeMap.get(propertyName);
 691     return WTF::switchOn(value,
 692         [] (Vector&lt;T&gt;&amp; typedValue) { return typedValue; },
 693         [] (auto&amp;) { return Vector&lt;T&gt;(); }
 694     );
 695 }
 696 
 697 template&lt;typename T&gt;
 698 OptionSet&lt;T&gt; AXIsolatedObject::optionSetAttributeValue(AXPropertyName propertyName) const
 699 {
 700     auto value = m_attributeMap.get(propertyName);
 701     return WTF::switchOn(value,
 702         [] (T&amp; typedValue) { return typedValue; },
 703         [] (auto&amp;) { return OptionSet&lt;T&gt;(); }
 704     );
 705 }
 706 
 707 uint64_t AXIsolatedObject::uint64AttributeValue(AXPropertyName propertyName) const
 708 {
 709     auto value = m_attributeMap.get(propertyName);
 710     return WTF::switchOn(value,
 711         [] (uint64_t&amp; typedValue) { return typedValue; },
 712         [] (auto&amp;) { return 0; }
 713     );
 714 }
 715 
 716 URL AXIsolatedObject::urlAttributeValue(AXPropertyName propertyName) const
 717 {
 718     auto value = m_attributeMap.get(propertyName);
 719     return WTF::switchOn(value,
 720         [] (URL&amp; typedValue) { return typedValue; },
 721         [] (auto&amp;) { return URL(); }
 722     );
 723 }
 724 
 725 Color AXIsolatedObject::colorAttributeValue(AXPropertyName propertyName) const
 726 {
 727     auto value = m_attributeMap.get(propertyName);
 728     return WTF::switchOn(value,
 729         [] (Color&amp; typedValue) { return typedValue; },
 730         [] (auto&amp;) { return Color(); }
 731     );
 732 }
 733 
 734 float AXIsolatedObject::floatAttributeValue(AXPropertyName propertyName) const
 735 {
 736     auto value = m_attributeMap.get(propertyName);
 737     return WTF::switchOn(value,
 738         [] (float&amp; typedValue) { return typedValue; },
 739         [] (auto&amp;) { return 0; }
 740     );
 741 }
 742 
 743 double AXIsolatedObject::doubleAttributeValue(AXPropertyName propertyName) const
 744 {
 745     auto value = m_attributeMap.get(propertyName);
 746     return WTF::switchOn(value,
 747         [] (double&amp; typedValue) { return typedValue; },
 748         [] (auto&amp;) { return 0; }
 749     );
 750 }
 751 
 752 unsigned AXIsolatedObject::unsignedAttributeValue(AXPropertyName propertyName) const
 753 {
 754     auto value = m_attributeMap.get(propertyName);
 755     return WTF::switchOn(value,
 756         [] (unsigned&amp; typedValue) { return typedValue; },
 757         [] (auto&amp;) { return 0; }
 758     );
 759 }
 760 
 761 bool AXIsolatedObject::boolAttributeValue(AXPropertyName propertyName) const
 762 {
 763     auto value = m_attributeMap.get(propertyName);
 764     return WTF::switchOn(value,
 765         [] (bool&amp; typedValue) { return typedValue; },
 766         [] (auto&amp;) { return false; }
 767     );
 768 }
 769 
 770 const String AXIsolatedObject::stringAttributeValue(AXPropertyName propertyName) const
 771 {
 772     auto value = m_attributeMap.get(propertyName);
 773     return WTF::switchOn(value,
 774         [] (String&amp; typedValue) { return typedValue; },
 775         [] (auto&amp;) { return emptyString(); }
 776     );
 777 }
 778 
 779 int AXIsolatedObject::intAttributeValue(AXPropertyName propertyName) const
 780 {
 781     auto value = m_attributeMap.get(propertyName);
 782     return WTF::switchOn(value,
 783         [] (int&amp; typedValue) { return typedValue; },
 784         [] (auto&amp;) { return 0; }
 785     );
 786 }
 787 
 788 void AXIsolatedObject::fillChildrenVectorForProperty(AXPropertyName propertyName, AccessibilityChildrenVector&amp; children) const
 789 {
 790     Vector&lt;AXID&gt; childIDs = vectorAttributeValue&lt;AXID&gt;(propertyName);
 791     children.reserveCapacity(childIDs.size());
 792     for (const auto&amp; childID : childIDs) {
 793         if (auto object = tree()-&gt;nodeForID(childID))
 794             children.uncheckedAppend(object);
 795     }
 796 }
 797 
 798 void AXIsolatedObject::updateBackingStore()
 799 {
 800     // This method can be called on either the main or the AX threads.
 801     // It can be called in the main thread from [WebAccessibilityObjectWrapper accessibilityFocusedUIElement].
 802     // Update the IsolatedTree only if it is called on the AX thread.
 803     if (!isMainThread()) {
 804         if (auto tree = this-&gt;tree())
 805             tree-&gt;applyPendingChanges();
 806     }
 807 }
 808 
 809 Vector&lt;RefPtr&lt;Range&gt;&gt; AXIsolatedObject::findTextRanges(AccessibilitySearchTextCriteria const&amp; criteria) const
 810 {
 811     return Accessibility::retrieveValueFromMainThread&lt;Vector&lt;RefPtr&lt;Range&gt;&gt;&gt;([&amp;criteria, this] () -&gt; Vector&lt;RefPtr&lt;Range&gt;&gt; {
 812         if (auto* object = associatedAXObject())
 813             return object-&gt;findTextRanges(criteria);
 814         return Vector&lt;RefPtr&lt;Range&gt;&gt;();
 815     });
 816 }
 817 
 818 Vector&lt;String&gt; AXIsolatedObject::performTextOperation(AccessibilityTextOperation const&amp; textOperation)
 819 {
 820     return Accessibility::retrieveValueFromMainThread&lt;Vector&lt;String&gt;&gt;([&amp;textOperation, this] () -&gt; Vector&lt;String&gt; {
 821         if (auto* object = associatedAXObject())
 822             return object-&gt;performTextOperation(textOperation);
 823         return Vector&lt;String&gt;();
 824     });
 825 }
 826 
 827 void AXIsolatedObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 828 {
 829     ASSERT(criteria);
 830     if (!criteria)
 831         return;
 832 
 833     criteria-&gt;anchorObject = this;
 834     Accessibility::findMatchingObjects(*criteria, results);
 835 }
 836 
 837 bool AXIsolatedObject::replaceTextInRange(const String&amp;, const PlainTextRange&amp;)
 838 {
 839     ASSERT_NOT_REACHED();
 840     return false;
 841 }
 842 
 843 bool AXIsolatedObject::insertText(const String&amp;)
 844 {
 845     ASSERT_NOT_REACHED();
 846     return false;
 847 }
 848 
 849 bool AXIsolatedObject::press()
 850 {
 851     if (auto* object = associatedAXObject())
 852         return object-&gt;press();
 853     return false;
 854 }
 855 
 856 bool AXIsolatedObject::performDefaultAction()
 857 {
 858     ASSERT_NOT_REACHED();
 859     return false;
 860 }
 861 
 862 bool AXIsolatedObject::isAccessibilityObject() const
 863 {
 864     ASSERT_NOT_REACHED();
 865     return false;
 866 }
 867 
 868 bool AXIsolatedObject::isAccessibilityNodeObject() const
 869 {
 870     ASSERT_NOT_REACHED();
 871     return false;
 872 }
 873 
 874 bool AXIsolatedObject::isAccessibilityRenderObject() const
 875 {
 876     ASSERT_NOT_REACHED();
 877     return false;
 878 }
 879 
 880 bool AXIsolatedObject::isAccessibilityScrollbar() const
 881 {
 882     ASSERT_NOT_REACHED();
 883     return false;
 884 }
 885 
 886 bool AXIsolatedObject::isAccessibilityScrollView() const
 887 {
 888     // FIXME: this should be ASSERT_NOT_REACHED, but it is called by
 889     // AXObjectCache::rootWebArea, that in turn is called by
 890     // AXObjectCache::postTextStateChangePlatformNotification.
 891     return false;
 892 }
 893 
 894 bool AXIsolatedObject::isAccessibilitySVGRoot() const
 895 {
 896     ASSERT_NOT_REACHED();
 897     return false;
 898 }
 899 
 900 bool AXIsolatedObject::isAccessibilitySVGElement() const
 901 {
 902     ASSERT_NOT_REACHED();
 903     return false;
 904 }
 905 
 906 bool AXIsolatedObject::isAttachmentElement() const
 907 {
 908     ASSERT_NOT_REACHED();
 909     return false;
 910 }
 911 
 912 bool AXIsolatedObject::isNativeImage() const
 913 {
 914     ASSERT_NOT_REACHED();
 915     return false;
 916 }
 917 
 918 bool AXIsolatedObject::isImageButton() const
 919 {
 920     ASSERT_NOT_REACHED();
 921     return false;
 922 }
 923 
 924 bool AXIsolatedObject::isContainedByPasswordField() const
 925 {
 926     ASSERT_NOT_REACHED();
 927     return false;
 928 }
 929 
 930 AXCoreObject* AXIsolatedObject::passwordFieldOrContainingPasswordField()
 931 {
 932     ASSERT_NOT_REACHED();
 933     return nullptr;
 934 }
 935 
 936 bool AXIsolatedObject::isNativeTextControl() const
 937 {
 938     ASSERT_NOT_REACHED();
 939     return false;
 940 }
 941 
 942 bool AXIsolatedObject::isNativeListBox() const
 943 {
 944     ASSERT_NOT_REACHED();
 945     return false;
 946 }
 947 
 948 bool AXIsolatedObject::isListBoxOption() const
 949 {
 950     ASSERT_NOT_REACHED();
 951     return false;
 952 }
 953 
 954 bool AXIsolatedObject::isSliderThumb() const
 955 {
 956     ASSERT_NOT_REACHED();
 957     return false;
 958 }
 959 
 960 bool AXIsolatedObject::isInputSlider() const
 961 {
 962     ASSERT_NOT_REACHED();
 963     return false;
 964 }
 965 
 966 bool AXIsolatedObject::isLabel() const
 967 {
 968     ASSERT_NOT_REACHED();
 969     return false;
 970 }
 971 
 972 bool AXIsolatedObject::isDataTable() const
 973 {
 974     ASSERT_NOT_REACHED();
 975     return false;
 976 }
 977 
 978 bool AXIsolatedObject::isImageMapLink() const
 979 {
 980     ASSERT_NOT_REACHED();
 981     return false;
 982 }
 983 
 984 bool AXIsolatedObject::isNativeSpinButton() const
 985 {
 986     ASSERT_NOT_REACHED();
 987     return false;
 988 }
 989 
 990 bool AXIsolatedObject::isSpinButtonPart() const
 991 {
 992     ASSERT_NOT_REACHED();
 993     return false;
 994 }
 995 
 996 bool AXIsolatedObject::isMockObject() const
 997 {
 998     ASSERT_NOT_REACHED();
 999     return false;
1000 }
1001 
1002 bool AXIsolatedObject::isMediaObject() const
1003 {
1004     ASSERT_NOT_REACHED();
1005     return false;
1006 }
1007 
1008 bool AXIsolatedObject::isARIATextControl() const
1009 {
1010     ASSERT_NOT_REACHED();
1011     return false;
1012 }
1013 
1014 bool AXIsolatedObject::isNonNativeTextControl() const
1015 {
1016     ASSERT_NOT_REACHED();
1017     return false;
1018 }
1019 
1020 bool AXIsolatedObject::isBlockquote() const
1021 {
1022     ASSERT_NOT_REACHED();
1023     return false;
1024 }
1025 
1026 bool AXIsolatedObject::isFigureElement() const
1027 {
1028     ASSERT_NOT_REACHED();
1029     return false;
1030 }
1031 
1032 bool AXIsolatedObject::isKeyboardFocusable() const
1033 {
1034     ASSERT_NOT_REACHED();
1035     return false;
1036 }
1037 
1038 bool AXIsolatedObject::isHovered() const
1039 {
1040     ASSERT_NOT_REACHED();
1041     return false;
1042 }
1043 
1044 bool AXIsolatedObject::isIndeterminate() const
1045 {
1046     ASSERT_NOT_REACHED();
1047     return false;
1048 }
1049 
1050 bool AXIsolatedObject::isOnScreen() const
1051 {
1052     ASSERT_NOT_REACHED();
1053     return false;
1054 }
1055 
1056 bool AXIsolatedObject::isOffScreen() const
1057 {
1058     ASSERT_NOT_REACHED();
1059     return false;
1060 }
1061 
1062 bool AXIsolatedObject::isPressed() const
1063 {
1064     ASSERT_NOT_REACHED();
1065     return false;
1066 }
1067 
1068 bool AXIsolatedObject::isUnvisited() const
1069 {
1070     ASSERT_NOT_REACHED();
1071     return false;
1072 }
1073 
1074 bool AXIsolatedObject::isLinked() const
1075 {
1076     ASSERT_NOT_REACHED();
1077     return false;
1078 }
1079 
1080 bool AXIsolatedObject::isVisible() const
1081 {
1082     ASSERT_NOT_REACHED();
1083     return false;
1084 }
1085 
1086 bool AXIsolatedObject::isCollapsed() const
1087 {
1088     ASSERT_NOT_REACHED();
1089     return false;
1090 }
1091 
1092 bool AXIsolatedObject::isSelectedOptionActive() const
1093 {
1094     ASSERT_NOT_REACHED();
1095     return false;
1096 }
1097 
1098 bool AXIsolatedObject::hasBoldFont() const
1099 {
1100     ASSERT_NOT_REACHED();
1101     return false;
1102 }
1103 
1104 bool AXIsolatedObject::hasItalicFont() const
1105 {
1106     ASSERT_NOT_REACHED();
1107     return false;
1108 }
1109 
1110 bool AXIsolatedObject::hasMisspelling() const
1111 {
1112     ASSERT_NOT_REACHED();
1113     return false;
1114 }
1115 
1116 bool AXIsolatedObject::hasPlainText() const
1117 {
1118     ASSERT_NOT_REACHED();
1119     return false;
1120 }
1121 
1122 bool AXIsolatedObject::hasSameFont(RenderObject*) const
1123 {
1124     ASSERT_NOT_REACHED();
1125     return false;
1126 }
1127 
1128 bool AXIsolatedObject::hasSameFontColor(RenderObject*) const
1129 {
1130     ASSERT_NOT_REACHED();
1131     return false;
1132 }
1133 
1134 bool AXIsolatedObject::hasSameStyle(RenderObject*) const
1135 {
1136     ASSERT_NOT_REACHED();
1137     return false;
1138 }
1139 
1140 bool AXIsolatedObject::hasUnderline() const
1141 {
1142     ASSERT_NOT_REACHED();
1143     return false;
1144 }
1145 
1146 bool AXIsolatedObject::hasHighlighting() const
1147 {
1148     ASSERT_NOT_REACHED();
1149     return false;
1150 }
1151 
1152 Element* AXIsolatedObject::element() const
1153 {
1154     ASSERT_NOT_REACHED();
1155     return nullptr;
1156 }
1157 
1158 Node* AXIsolatedObject::node() const
1159 {
1160     ASSERT_NOT_REACHED();
1161     return nullptr;
1162 }
1163 
1164 RenderObject* AXIsolatedObject::renderer() const
1165 {
1166     ASSERT_NOT_REACHED();
1167     return nullptr;
1168 }
1169 
1170 AccessibilityObjectInclusion AXIsolatedObject::defaultObjectInclusion() const
1171 {
1172     ASSERT_NOT_REACHED();
1173     return AccessibilityObjectInclusion::DefaultBehavior;
1174 }
1175 
1176 bool AXIsolatedObject::accessibilityIsIgnoredByDefault() const
1177 {
1178     ASSERT_NOT_REACHED();
1179     return false;
1180 }
1181 
1182 float AXIsolatedObject::stepValueForRange() const
1183 {
1184     ASSERT_NOT_REACHED();
1185     return 0;
1186 }
1187 
1188 AXCoreObject* AXIsolatedObject::selectedListItem()
1189 {
1190     ASSERT_NOT_REACHED();
1191     return nullptr;
1192 }
1193 
1194 void AXIsolatedObject::ariaActiveDescendantReferencingElements(AccessibilityChildrenVector&amp;) const
1195 {
1196     ASSERT_NOT_REACHED();
1197 }
1198 
1199 void AXIsolatedObject::ariaControlsReferencingElements(AccessibilityChildrenVector&amp;) const
1200 {
1201     ASSERT_NOT_REACHED();
1202 }
1203 
1204 void AXIsolatedObject::ariaDescribedByElements(AccessibilityChildrenVector&amp;) const
1205 {
1206     ASSERT_NOT_REACHED();
1207 }
1208 
1209 void AXIsolatedObject::ariaDescribedByReferencingElements(AccessibilityChildrenVector&amp;) const
1210 {
1211     ASSERT_NOT_REACHED();
1212 }
1213 
1214 void AXIsolatedObject::ariaDetailsReferencingElements(AccessibilityChildrenVector&amp;) const
1215 {
1216     ASSERT_NOT_REACHED();
1217 }
1218 
1219 void AXIsolatedObject::ariaErrorMessageReferencingElements(AccessibilityChildrenVector&amp;) const
1220 {
1221     ASSERT_NOT_REACHED();
1222 }
1223 
1224 void AXIsolatedObject::ariaFlowToReferencingElements(AccessibilityChildrenVector&amp;) const
1225 {
1226     ASSERT_NOT_REACHED();
1227 }
1228 
1229 void AXIsolatedObject::ariaLabelledByElements(AccessibilityChildrenVector&amp;) const
1230 {
1231     ASSERT_NOT_REACHED();
1232 }
1233 
1234 void AXIsolatedObject::ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp;) const
1235 {
1236     ASSERT_NOT_REACHED();
1237 }
1238 
1239 void AXIsolatedObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp;) const
1240 {
1241     ASSERT_NOT_REACHED();
1242 }
1243 
1244 bool AXIsolatedObject::hasDatalist() const
1245 {
1246     ASSERT_NOT_REACHED();
1247     return false;
1248 }
1249 
1250 bool AXIsolatedObject::supportsHasPopup() const
1251 {
1252     ASSERT_NOT_REACHED();
1253     return false;
1254 }
1255 
1256 bool AXIsolatedObject::supportsPressed() const
1257 {
1258     ASSERT_NOT_REACHED();
1259     return false;
1260 }
1261 
1262 bool AXIsolatedObject::supportsChecked() const
1263 {
1264     ASSERT_NOT_REACHED();
1265     return false;
1266 }
1267 
1268 bool AXIsolatedObject::ignoredFromModalPresence() const
1269 {
1270     ASSERT_NOT_REACHED();
1271     return false;
1272 }
1273 
1274 bool AXIsolatedObject::isModalDescendant(Node*) const
1275 {
1276     ASSERT_NOT_REACHED();
1277     return false;
1278 }
1279 
1280 bool AXIsolatedObject::isModalNode() const
1281 {
1282     ASSERT_NOT_REACHED();
1283     return false;
1284 }
1285 
1286 AXCoreObject* AXIsolatedObject::elementAccessibilityHitTest(const IntPoint&amp;) const
1287 {
1288     ASSERT_NOT_REACHED();
1289     return nullptr;
1290 }
1291 
1292 AXCoreObject* AXIsolatedObject::firstChild() const
1293 {
1294     ASSERT_NOT_REACHED();
1295     return nullptr;
1296 }
1297 
1298 AXCoreObject* AXIsolatedObject::lastChild() const
1299 {
1300     ASSERT_NOT_REACHED();
1301     return nullptr;
1302 }
1303 
1304 AXCoreObject* AXIsolatedObject::previousSibling() const
1305 {
1306     ASSERT_NOT_REACHED();
1307     return nullptr;
1308 }
1309 
1310 AXCoreObject* AXIsolatedObject::nextSibling() const
1311 {
1312     ASSERT_NOT_REACHED();
1313     return nullptr;
1314 }
1315 
1316 AXCoreObject* AXIsolatedObject::nextSiblingUnignored(int) const
1317 {
1318     ASSERT_NOT_REACHED();
1319     return nullptr;
1320 }
1321 
1322 AXCoreObject* AXIsolatedObject::previousSiblingUnignored(int) const
1323 {
1324     ASSERT_NOT_REACHED();
1325     return nullptr;
1326 }
1327 
1328 AXCoreObject* AXIsolatedObject::parentObjectIfExists() const
1329 {
1330     ASSERT_NOT_REACHED();
1331     return nullptr;
1332 }
1333 
1334 bool AXIsolatedObject::isDescendantOfBarrenParent() const
1335 {
1336     ASSERT_NOT_REACHED();
1337     return false;
1338 }
1339 
1340 bool AXIsolatedObject::isDescendantOfRole(AccessibilityRole) const
1341 {
1342     ASSERT_NOT_REACHED();
1343     return false;
1344 }
1345 
1346 AXCoreObject* AXIsolatedObject::observableObject() const
1347 {
1348     ASSERT_NOT_REACHED();
1349     return nullptr;
1350 }
1351 
1352 AXCoreObject* AXIsolatedObject::correspondingLabelForControlElement() const
1353 {
1354     ASSERT_NOT_REACHED();
1355     return nullptr;
1356 }
1357 
1358 AXCoreObject* AXIsolatedObject::correspondingControlForLabelElement() const
1359 {
1360     ASSERT_NOT_REACHED();
1361     return nullptr;
1362 }
1363 
1364 bool AXIsolatedObject::isPresentationalChildOfAriaRole() const
1365 {
1366     ASSERT_NOT_REACHED();
1367     return false;
1368 }
1369 
1370 bool AXIsolatedObject::ariaRoleHasPresentationalChildren() const
1371 {
1372     ASSERT_NOT_REACHED();
1373     return false;
1374 }
1375 
1376 bool AXIsolatedObject::inheritsPresentationalRole() const
1377 {
1378     ASSERT_NOT_REACHED();
1379     return false;
1380 }
1381 
1382 void AXIsolatedObject::setAccessibleName(const AtomString&amp;)
1383 {
1384     ASSERT_NOT_REACHED();
1385 }
1386 
1387 bool AXIsolatedObject::hasAttributesRequiredForInclusion() const
1388 {
1389     ASSERT_NOT_REACHED();
1390     return false;
1391 }
1392 
1393 String AXIsolatedObject::accessibilityDescription() const
1394 {
1395     ASSERT_NOT_REACHED();
1396     return String();
1397 }
1398 
1399 String AXIsolatedObject::title() const
1400 {
1401     ASSERT_NOT_REACHED();
1402     return String();
1403 }
1404 
1405 String AXIsolatedObject::helpText() const
1406 {
1407     ASSERT_NOT_REACHED();
1408     return String();
1409 }
1410 
1411 bool AXIsolatedObject::isARIAStaticText() const
1412 {
1413     ASSERT_NOT_REACHED();
1414     return false;
1415 }
1416 
1417 String AXIsolatedObject::text() const
1418 {
1419     ASSERT_NOT_REACHED();
1420     return String();
1421 }
1422 
1423 String AXIsolatedObject::ariaLabeledByAttribute() const
1424 {
1425     ASSERT_NOT_REACHED();
1426     return String();
1427 }
1428 
1429 String AXIsolatedObject::ariaDescribedByAttribute() const
1430 {
1431     ASSERT_NOT_REACHED();
1432     return String();
1433 }
1434 
1435 bool AXIsolatedObject::accessibleNameDerivesFromContent() const
1436 {
1437     ASSERT_NOT_REACHED();
1438     return false;
1439 }
1440 
1441 void AXIsolatedObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp;, const QualifiedName&amp;) const
1442 {
1443     ASSERT_NOT_REACHED();
1444 }
1445 
1446 AXObjectCache* AXIsolatedObject::axObjectCache() const
1447 {
1448     ASSERT(isMainThread());
1449     return tree()-&gt;axObjectCache();
1450 }
1451 
1452 Element* AXIsolatedObject::anchorElement() const
1453 {
1454     ASSERT_NOT_REACHED();
1455     return nullptr;
1456 }
1457 
1458 Element* AXIsolatedObject::actionElement() const
1459 {
1460     ASSERT_NOT_REACHED();
1461     return nullptr;
1462 }
1463 
1464 Path AXIsolatedObject::elementPath() const
1465 {
1466     ASSERT_NOT_REACHED();
1467     return Path();
1468 }
1469 
1470 TextIteratorBehavior AXIsolatedObject::textIteratorBehaviorForTextRange() const
1471 {
1472     ASSERT_NOT_REACHED();
1473     return false;
1474 }
1475 
1476 Widget* AXIsolatedObject::widget() const
1477 {
1478     if (auto* object = associatedAXObject())
1479         return object-&gt;widget();
1480     return nullptr;
1481 }
1482 
1483 Widget* AXIsolatedObject::widgetForAttachmentView() const
1484 {
1485     ASSERT_NOT_REACHED();
1486     return nullptr;
1487 }
1488 
1489 Page* AXIsolatedObject::page() const
1490 {
1491     if (auto* object = associatedAXObject())
1492         return object-&gt;page();
1493     ASSERT_NOT_REACHED();
1494     return nullptr;
1495 }
1496 
1497 Document* AXIsolatedObject::document() const
1498 {
1499     if (auto* object = associatedAXObject())
1500         return object-&gt;document();
1501     ASSERT_NOT_REACHED();
1502     return nullptr;
1503 }
1504 
1505 FrameView* AXIsolatedObject::documentFrameView() const
1506 {
1507     if (auto* object = associatedAXObject())
1508         return object-&gt;documentFrameView();
1509     return nullptr;
1510 }
1511 
1512 Frame* AXIsolatedObject::frame() const
1513 {
1514     ASSERT_NOT_REACHED();
1515     return nullptr;
1516 }
1517 
1518 Frame* AXIsolatedObject::mainFrame() const
1519 {
1520     ASSERT_NOT_REACHED();
1521     return nullptr;
1522 }
1523 
1524 Document* AXIsolatedObject::topDocument() const
1525 {
1526     ASSERT_NOT_REACHED();
1527     return nullptr;
1528 }
1529 
1530 ScrollView* AXIsolatedObject::scrollViewAncestor() const
1531 {
1532     ASSERT_NOT_REACHED();
1533     return nullptr;
1534 }
1535 
1536 void AXIsolatedObject::childrenChanged()
1537 {
1538     ASSERT_NOT_REACHED();
1539 }
1540 
1541 void AXIsolatedObject::textChanged()
1542 {
1543     ASSERT_NOT_REACHED();
1544 }
1545 
1546 void AXIsolatedObject::updateAccessibilityRole()
1547 {
1548     ASSERT_NOT_REACHED();
1549 }
1550 
1551 void AXIsolatedObject::addChildren()
1552 {
1553     ASSERT_NOT_REACHED();
1554 }
1555 
1556 void AXIsolatedObject::addChild(AXCoreObject*)
1557 {
1558     ASSERT_NOT_REACHED();
1559 }
1560 
1561 void AXIsolatedObject::insertChild(AXCoreObject*, unsigned)
1562 {
1563     ASSERT_NOT_REACHED();
1564 }
1565 
1566 bool AXIsolatedObject::shouldIgnoreAttributeRole() const
1567 {
1568     ASSERT_NOT_REACHED();
1569     return false;
1570 }
1571 
1572 bool AXIsolatedObject::canHaveChildren() const
1573 {
1574     ASSERT_NOT_REACHED();
1575     return false;
1576 }
1577 
1578 bool AXIsolatedObject::hasChildren() const
1579 {
1580     ASSERT_NOT_REACHED();
1581     return false;
1582 }
1583 
1584 void AXIsolatedObject::setNeedsToUpdateChildren()
1585 {
1586     ASSERT_NOT_REACHED();
1587 }
1588 
1589 void AXIsolatedObject::setNeedsToUpdateSubtree()
1590 {
1591     ASSERT_NOT_REACHED();
1592 }
1593 
1594 void AXIsolatedObject::clearChildren()
1595 {
1596     ASSERT_NOT_REACHED();
1597 }
1598 
1599 bool AXIsolatedObject::needsToUpdateChildren() const
1600 {
1601     ASSERT_NOT_REACHED();
1602     return false;
1603 }
1604 
1605 bool AXIsolatedObject::shouldFocusActiveDescendant() const
1606 {
1607     ASSERT_NOT_REACHED();
1608     return false;
1609 }
1610 
1611 AXCoreObject* AXIsolatedObject::activeDescendant() const
1612 {
1613     ASSERT_NOT_REACHED();
1614     return nullptr;
1615 }
1616 
1617 void AXIsolatedObject::handleActiveDescendantChanged()
1618 {
1619     ASSERT_NOT_REACHED();
1620 }
1621 
1622 void AXIsolatedObject::handleAriaExpandedChanged()
1623 {
1624     ASSERT_NOT_REACHED();
1625 }
1626 
1627 bool AXIsolatedObject::isDescendantOfObject(const AXCoreObject*) const
1628 {
1629     ASSERT_NOT_REACHED();
1630     return false;
1631 }
1632 
1633 bool AXIsolatedObject::isAncestorOfObject(const AXCoreObject*) const
1634 {
1635     ASSERT_NOT_REACHED();
1636     return false;
1637 }
1638 
1639 AXCoreObject* AXIsolatedObject::firstAnonymousBlockChild() const
1640 {
1641     ASSERT_NOT_REACHED();
1642     return nullptr;
1643 }
1644 
1645 bool AXIsolatedObject::hasAttribute(const QualifiedName&amp;) const
1646 {
1647     ASSERT_NOT_REACHED();
1648     return false;
1649 }
1650 
1651 const AtomString&amp; AXIsolatedObject::getAttribute(const QualifiedName&amp;) const
1652 {
1653     ASSERT_NOT_REACHED();
1654     return nullAtom();
1655 }
1656 
1657 bool AXIsolatedObject::hasTagName(const QualifiedName&amp;) const
1658 {
1659     ASSERT_NOT_REACHED();
1660     return false;
1661 }
1662 
1663 String AXIsolatedObject::stringValueForMSAA() const
1664 {
1665     ASSERT_NOT_REACHED();
1666     return String();
1667 }
1668 
1669 String AXIsolatedObject::stringRoleForMSAA() const
1670 {
1671     ASSERT_NOT_REACHED();
1672     return String();
1673 }
1674 
1675 String AXIsolatedObject::nameForMSAA() const
1676 {
1677     ASSERT_NOT_REACHED();
1678     return String();
1679 }
1680 
1681 String AXIsolatedObject::descriptionForMSAA() const
1682 {
1683     ASSERT_NOT_REACHED();
1684     return String();
1685 }
1686 
1687 AccessibilityRole AXIsolatedObject::roleValueForMSAA() const
1688 {
1689     ASSERT_NOT_REACHED();
1690     return AccessibilityRole::Unknown;
1691 }
1692 
1693 String AXIsolatedObject::passwordFieldValue() const
1694 {
1695     ASSERT_NOT_REACHED();
1696     return String();
1697 }
1698 
1699 AXCoreObject* AXIsolatedObject::liveRegionAncestor(bool) const
1700 {
1701     ASSERT_NOT_REACHED();
1702     return nullptr;
1703 }
1704 
1705 bool AXIsolatedObject::hasContentEditableAttributeSet() const
1706 {
1707     ASSERT_NOT_REACHED();
1708     return false;
1709 }
1710 
1711 bool AXIsolatedObject::supportsReadOnly() const
1712 {
1713     ASSERT_NOT_REACHED();
1714     return false;
1715 }
1716 
1717 bool AXIsolatedObject::supportsAutoComplete() const
1718 {
1719     ASSERT_NOT_REACHED();
1720     return false;
1721 }
1722 
1723 bool AXIsolatedObject::supportsARIAAttributes() const
1724 {
1725     ASSERT_NOT_REACHED();
1726     return false;
1727 }
1728 
1729 bool AXIsolatedObject::scrollByPage(ScrollByPageDirection) const
1730 {
1731     ASSERT_NOT_REACHED();
1732     return false;
1733 }
1734 
1735 IntPoint AXIsolatedObject::scrollPosition() const
1736 {
1737     ASSERT_NOT_REACHED();
1738     return IntPoint();
1739 }
1740 
1741 IntSize AXIsolatedObject::scrollContentsSize() const
1742 {
1743     ASSERT_NOT_REACHED();
1744     return IntSize();
1745 }
1746 
1747 IntRect AXIsolatedObject::scrollVisibleContentRect() const
1748 {
1749     ASSERT_NOT_REACHED();
1750     return IntRect();
1751 }
1752 
1753 void AXIsolatedObject::scrollToMakeVisible(const ScrollRectToVisibleOptions&amp;) const
1754 {
1755     ASSERT_NOT_REACHED();
1756 }
1757 
1758 bool AXIsolatedObject::lastKnownIsIgnoredValue()
1759 {
1760     ASSERT_NOT_REACHED();
1761     return false;
1762 }
1763 
1764 void AXIsolatedObject::setLastKnownIsIgnoredValue(bool)
1765 {
1766     ASSERT_NOT_REACHED();
1767 }
1768 
1769 void AXIsolatedObject::notifyIfIgnoredValueChanged()
1770 {
1771     ASSERT_NOT_REACHED();
1772 }
1773 
1774 bool AXIsolatedObject::isMathScriptObject(AccessibilityMathScriptObjectType) const
1775 {
1776     ASSERT_NOT_REACHED();
1777     return false;
1778 }
1779 
1780 bool AXIsolatedObject::isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType) const
1781 {
1782     ASSERT_NOT_REACHED();
1783     return false;
1784 }
1785 
1786 bool AXIsolatedObject::isAXHidden() const
1787 {
1788     ASSERT_NOT_REACHED();
1789     return false;
1790 }
1791 
1792 bool AXIsolatedObject::isDOMHidden() const
1793 {
1794     ASSERT_NOT_REACHED();
1795     return false;
1796 }
1797 
1798 bool AXIsolatedObject::isHidden() const
1799 {
1800     ASSERT_NOT_REACHED();
1801     return false;
1802 }
1803 
1804 void AXIsolatedObject::overrideAttachmentParent(AXCoreObject*)
1805 {
1806     ASSERT_NOT_REACHED();
1807 }
1808 
1809 bool AXIsolatedObject::accessibilityIgnoreAttachment() const
1810 {
1811     ASSERT_NOT_REACHED();
1812     return false;
1813 }
1814 
1815 AccessibilityObjectInclusion AXIsolatedObject::accessibilityPlatformIncludesObject() const
1816 {
1817     ASSERT_NOT_REACHED();
1818     return AccessibilityObjectInclusion::DefaultBehavior;
1819 }
1820 
1821 bool AXIsolatedObject::hasApplePDFAnnotationAttribute() const
1822 {
1823     ASSERT_NOT_REACHED();
1824     return false;
1825 }
1826 
1827 const AccessibilityScrollView* AXIsolatedObject::ancestorAccessibilityScrollView(bool) const
1828 {
1829     ASSERT_NOT_REACHED();
1830     return nullptr;
1831 }
1832 
1833 void AXIsolatedObject::setIsIgnoredFromParentData(AccessibilityIsIgnoredFromParentData&amp;)
1834 {
1835     ASSERT_NOT_REACHED();
1836 }
1837 
1838 void AXIsolatedObject::clearIsIgnoredFromParentData()
1839 {
1840     ASSERT_NOT_REACHED();
1841 }
1842 
1843 void AXIsolatedObject::setIsIgnoredFromParentDataForChild(AXCoreObject*)
1844 {
1845     ASSERT_NOT_REACHED();
1846 }
1847 
1848 } // namespace WebCore
1849 
1850 #endif // ENABLE((ACCESSIBILITY_ISOLATED_TREE)
    </pre>
  </body>
</html>
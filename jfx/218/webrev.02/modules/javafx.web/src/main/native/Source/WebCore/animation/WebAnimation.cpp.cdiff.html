<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyframeEffect.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebAnimation.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,55 ***</span>
  #include &quot;WebAnimation.h&quot;
  
  #include &quot;AnimationEffect.h&quot;
  #include &quot;AnimationPlaybackEvent.h&quot;
  #include &quot;AnimationTimeline.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;JSWebAnimation.h&quot;
  #include &quot;KeyframeEffect.h&quot;
<span class="line-modified">! #include &quot;Microtasks.h&quot;</span>
  #include &quot;WebAnimationUtilities.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(WebAnimation);
  
  Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect)
  {
      auto result = adoptRef(*new WebAnimation(document));
      result-&gt;setEffect(effect);
      result-&gt;setTimeline(&amp;document.timeline());
      return result;
  }
  
  Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect, AnimationTimeline* timeline)
  {
      auto result = adoptRef(*new WebAnimation(document));
      result-&gt;setEffect(effect);
      if (timeline)
          result-&gt;setTimeline(timeline);
      return result;
  }
  
  WebAnimation::WebAnimation(Document&amp; document)
      : ActiveDOMObject(document)
      , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve))
      , m_finishedPromise(makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve))
  {
      m_readyPromise-&gt;resolve(*this);
      suspendIfNeeded();
  }
  
  WebAnimation::~WebAnimation()
  {
      if (m_timeline)
          m_timeline-&gt;forgetAnimation(this);
  }
  
  void WebAnimation::remove()
  {
      // This object could be deleted after either clearing the effect or timeline relationship.
<span class="line-new-header">--- 27,104 ---</span>
  #include &quot;WebAnimation.h&quot;
  
  #include &quot;AnimationEffect.h&quot;
  #include &quot;AnimationPlaybackEvent.h&quot;
  #include &quot;AnimationTimeline.h&quot;
<span class="line-added">+ #include &quot;CSSComputedStyleDeclaration.h&quot;</span>
<span class="line-added">+ #include &quot;DOMPromiseProxy.h&quot;</span>
<span class="line-added">+ #include &quot;DeclarativeAnimation.h&quot;</span>
  #include &quot;Document.h&quot;
  #include &quot;DocumentTimeline.h&quot;
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;EventNames.h&quot;
<span class="line-added">+ #include &quot;InspectorInstrumentation.h&quot;</span>
  #include &quot;JSWebAnimation.h&quot;
  #include &quot;KeyframeEffect.h&quot;
<span class="line-modified">! #include &quot;KeyframeEffectStack.h&quot;</span>
<span class="line-added">+ #include &quot;Logging.h&quot;</span>
<span class="line-added">+ #include &quot;RenderElement.h&quot;</span>
<span class="line-added">+ #include &quot;StyledElement.h&quot;</span>
  #include &quot;WebAnimationUtilities.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="line-added">+ #include &lt;wtf/Lock.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/NeverDestroyed.h&gt;</span>
  #include &lt;wtf/Optional.h&gt;
<span class="line-added">+ #include &lt;wtf/text/TextStream.h&gt;</span>
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(WebAnimation);
  
<span class="line-added">+ HashSet&lt;WebAnimation*&gt;&amp; WebAnimation::instances(const LockHolder&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static NeverDestroyed&lt;HashSet&lt;WebAnimation*&gt;&gt; instances;</span>
<span class="line-added">+     return instances;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Lock&amp; WebAnimation::instancesMutex()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static LazyNeverDestroyed&lt;Lock&gt; mutex;</span>
<span class="line-added">+     static std::once_flag initializeMutex;</span>
<span class="line-added">+     std::call_once(initializeMutex, [] {</span>
<span class="line-added">+         mutex.construct();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return mutex.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect)
  {
      auto result = adoptRef(*new WebAnimation(document));
      result-&gt;setEffect(effect);
      result-&gt;setTimeline(&amp;document.timeline());
<span class="line-added">+ </span>
<span class="line-added">+     InspectorInstrumentation::didCreateWebAnimation(result.get());</span>
<span class="line-added">+ </span>
      return result;
  }
  
  Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect, AnimationTimeline* timeline)
  {
      auto result = adoptRef(*new WebAnimation(document));
      result-&gt;setEffect(effect);
      if (timeline)
          result-&gt;setTimeline(timeline);
<span class="line-added">+ </span>
<span class="line-added">+     InspectorInstrumentation::didCreateWebAnimation(result.get());</span>
<span class="line-added">+ </span>
      return result;
  }
  
  WebAnimation::WebAnimation(Document&amp; document)
      : ActiveDOMObject(document)
      , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve))
      , m_finishedPromise(makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve))
  {
      m_readyPromise-&gt;resolve(*this);
      suspendIfNeeded();
<span class="line-added">+ </span>
<span class="line-added">+     LockHolder lock(instancesMutex());</span>
<span class="line-added">+     instances(lock).add(this);</span>
  }
  
  WebAnimation::~WebAnimation()
  {
<span class="line-added">+     InspectorInstrumentation::willDestroyWebAnimation(*this);</span>
<span class="line-added">+ </span>
      if (m_timeline)
          m_timeline-&gt;forgetAnimation(this);
<span class="line-added">+ </span>
<span class="line-added">+     LockHolder lock(instancesMutex());</span>
<span class="line-added">+     ASSERT(instances(lock).contains(this));</span>
<span class="line-added">+     instances(lock).remove(this);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WebAnimation::contextDestroyed()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     InspectorInstrumentation::willDestroyWebAnimation(*this);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ActiveDOMObject::contextDestroyed();</span>
  }
  
  void WebAnimation::remove()
  {
      // This object could be deleted after either clearing the effect or timeline relationship.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,13 ***</span>
  {
      ASSERT(m_suspendCount &gt; 0);
      --m_suspendCount;
  }
  
<span class="line-modified">! void WebAnimation::effectTimingDidChange()</span>
  {
      timingDidChange(DidSeek::No, SynchronouslyNotify::Yes);
  }
  
  void WebAnimation::setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect)
  {
      // 3.4.3. Setting the target effect of an animation
<span class="line-new-header">--- 142,23 ---</span>
  {
      ASSERT(m_suspendCount &gt; 0);
      --m_suspendCount;
  }
  
<span class="line-modified">! void WebAnimation::effectTimingDidChange(Optional&lt;ComputedEffectTiming&gt; previousTiming)</span>
  {
      timingDidChange(DidSeek::No, SynchronouslyNotify::Yes);
<span class="line-added">+ </span>
<span class="line-added">+     InspectorInstrumentation::didChangeWebAnimationEffectTiming(*this);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!previousTiming)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* effect = this-&gt;effect();</span>
<span class="line-added">+     ASSERT(effect);</span>
<span class="line-added">+     if (previousTiming-&gt;progress != effect-&gt;getComputedTiming().progress)</span>
<span class="line-added">+         effect-&gt;animationDidSeek();</span>
  }
  
  void WebAnimation::setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect)
  {
      // 3.4.3. Setting the target effect of an animation
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,10 ***</span>
<span class="line-new-header">--- 200,15 ---</span>
      timingDidChange(DidSeek::No, SynchronouslyNotify::No);
  
      invalidateEffect();
  }
  
<span class="line-added">+ AnimationTimeline* WebAnimation::timeline() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_timeline.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void WebAnimation::setEffectInternal(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect, bool doNotRemoveFromTimeline)
  {
      if (m_effect == newEffect)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,19 ***</span>
      if (m_effect) {
          m_effect-&gt;setAnimation(this);
          if (m_timeline &amp;&amp; newTarget &amp;&amp; previousTarget != newTarget)
              m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
      }
  }
  
  void WebAnimation::setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
  {
      // 3.4.1. Setting the timeline of an animation
      // https://drafts.csswg.org/web-animations-1/#setting-the-timeline
  
      // 2. If new timeline is the same object as old timeline, abort this procedure.
<span class="line-modified">!     if (timeline == m_timeline)</span>
          return;
  
      // 4. If the animation start time of animation is resolved, make animation&#39;s hold time unresolved.
      if (m_startTime)
          m_holdTime = WTF::nullopt;
<span class="line-new-header">--- 233,21 ---</span>
      if (m_effect) {
          m_effect-&gt;setAnimation(this);
          if (m_timeline &amp;&amp; newTarget &amp;&amp; previousTarget != newTarget)
              m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
      }
<span class="line-added">+ </span>
<span class="line-added">+     InspectorInstrumentation::didSetWebAnimationEffect(*this);</span>
  }
  
  void WebAnimation::setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
  {
      // 3.4.1. Setting the timeline of an animation
      // https://drafts.csswg.org/web-animations-1/#setting-the-timeline
  
      // 2. If new timeline is the same object as old timeline, abort this procedure.
<span class="line-modified">!     if (timeline == m_timeline.get())</span>
          return;
  
      // 4. If the animation start time of animation is resolved, make animation&#39;s hold time unresolved.
      if (m_startTime)
          m_holdTime = WTF::nullopt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,40 ***</span>
  
      // This object could be deleted after clearing the timeline relationship.
      auto protectedThis = makeRef(*this);
      setTimelineInternal(WTFMove(timeline));
  
<span class="line-modified">!     setSuspended(is&lt;DocumentTimeline&gt;(m_timeline) &amp;&amp; downcast&lt;DocumentTimeline&gt;(*m_timeline).animationsAreSuspended());</span>
  
      // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
      // and the synchronously notify flag set to false.
      timingDidChange(DidSeek::No, SynchronouslyNotify::No);
  
      invalidateEffect();
  }
  
  void WebAnimation::setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
  {
<span class="line-modified">!     if (m_timeline == timeline)</span>
          return;
  
      if (m_timeline)
          m_timeline-&gt;removeAnimation(*this);
  
<span class="line-modified">!     m_timeline = WTFMove(timeline);</span>
  }
  
  void WebAnimation::effectTargetDidChange(Element* previousTarget, Element* newTarget)
  {
<span class="line-modified">!     if (!m_timeline)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     if (previousTarget)</span>
<span class="line-modified">!         m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);</span>
  
<span class="line-modified">!     if (newTarget)</span>
<span class="line-removed">-         m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);</span>
  }
  
  Optional&lt;double&gt; WebAnimation::startTime() const
  {
      if (!m_startTime)
<span class="line-new-header">--- 268,47 ---</span>
  
      // This object could be deleted after clearing the timeline relationship.
      auto protectedThis = makeRef(*this);
      setTimelineInternal(WTFMove(timeline));
  
<span class="line-modified">!     setSuspended(is&lt;DocumentTimeline&gt;(m_timeline.get()) &amp;&amp; downcast&lt;DocumentTimeline&gt;(*m_timeline).animationsAreSuspended());</span>
  
      // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
      // and the synchronously notify flag set to false.
      timingDidChange(DidSeek::No, SynchronouslyNotify::No);
  
      invalidateEffect();
  }
  
  void WebAnimation::setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
  {
<span class="line-modified">!     if (m_timeline.get() == timeline)</span>
          return;
  
      if (m_timeline)
          m_timeline-&gt;removeAnimation(*this);
  
<span class="line-modified">!     m_timeline = makeWeakPtr(timeline.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_effect)</span>
<span class="line-added">+         m_effect-&gt;animationTimelineDidChange(m_timeline.get());</span>
  }
  
  void WebAnimation::effectTargetDidChange(Element* previousTarget, Element* newTarget)
  {
<span class="line-modified">!     if (m_timeline) {</span>
<span class="line-modified">!         if (previousTarget)</span>
<span class="line-added">+             m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (newTarget)</span>
<span class="line-added">+             m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);</span>
  
<span class="line-modified">!         // This could have changed whether we have replaced animations, so we may need to schedule an update.</span>
<span class="line-modified">!         m_timeline-&gt;animationTimingDidChange(*this);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     InspectorInstrumentation::didChangeWebAnimationEffectTarget(*this);</span>
  }
  
  Optional&lt;double&gt; WebAnimation::startTime() const
  {
      if (!m_startTime)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,10 ***</span>
<span class="line-new-header">--- 413,12 ---</span>
      return (m_timeline-&gt;currentTime().value() - m_startTime.value()) * m_playbackRate;
  }
  
  ExceptionOr&lt;void&gt; WebAnimation::silentlySetCurrentTime(Optional&lt;Seconds&gt; seekTime)
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; silentlySetCurrentTime &quot; &lt;&lt; seekTime);</span>
<span class="line-added">+ </span>
      // 3.4.5. Setting the current time of an animation
      // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
  
      // 1. If seek time is an unresolved time value, then perform the following steps.
      if (!seekTime) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,10 ***</span>
<span class="line-new-header">--- 453,12 ---</span>
      return { };
  }
  
  ExceptionOr&lt;void&gt; WebAnimation::setCurrentTime(Optional&lt;Seconds&gt; seekTime)
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; setCurrentTime &quot; &lt;&lt; seekTime);</span>
<span class="line-added">+ </span>
      // 3.4.5. Setting the current time of an animation
      // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
  
      // 1. Run the steps to silently set the current time of animation to seek time.
      auto silentResult = silentlySetCurrentTime(seekTime);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 540,21 ***</span>
  
  Seconds WebAnimation::effectEndTime() const
  {
      // The target effect end of an animation is equal to the end time of the animation&#39;s target effect.
      // If the animation has no target effect, the target effect end is zero.
<span class="line-modified">!     return m_effect ? m_effect-&gt;getBasicTiming().endTime : 0_s;</span>
  }
  
  void WebAnimation::cancel()
  {
      cancel(Silently::No);
      invalidateEffect();
  }
  
  void WebAnimation::cancel(Silently silently)
  {
      // 3.4.16. Canceling an animation
      // https://drafts.csswg.org/web-animations-1/#canceling-an-animation-section
      //
      // An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
      //
<span class="line-new-header">--- 617,23 ---</span>
  
  Seconds WebAnimation::effectEndTime() const
  {
      // The target effect end of an animation is equal to the end time of the animation&#39;s target effect.
      // If the animation has no target effect, the target effect end is zero.
<span class="line-modified">!     return m_effect ? m_effect-&gt;endTime() : 0_s;</span>
  }
  
  void WebAnimation::cancel()
  {
      cancel(Silently::No);
      invalidateEffect();
  }
  
  void WebAnimation::cancel(Silently silently)
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; cancel(silently &quot; &lt;&lt; (silently == Silently::Yes) &lt;&lt; &quot;) (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
      // 3.4.16. Canceling an animation
      // https://drafts.csswg.org/web-animations-1/#canceling-an-animation-section
      //
      // An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 594,29 ***</span>
      m_startTime = WTF::nullopt;
  
      timingDidChange(DidSeek::No, SynchronouslyNotify::No);
  
      invalidateEffect();
  }
  
  void WebAnimation::enqueueAnimationPlaybackEvent(const AtomString&amp; type, Optional&lt;Seconds&gt; currentTime, Optional&lt;Seconds&gt; timelineTime)
  {
<span class="line-modified">!     auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime);</span>
      event-&gt;setTarget(this);
  
<span class="line-modified">!     if (is&lt;DocumentTimeline&gt;(m_timeline)) {</span>
          // If animation has a document for timing, then append event to its document for timing&#39;s pending animation event queue along
          // with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
          // to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
          // scheduled event time is an unresolved time value.
<span class="line-modified">!         downcast&lt;DocumentTimeline&gt;(*m_timeline).enqueueAnimationPlaybackEvent(WTFMove(event));</span>
      } else {
          // Otherwise, queue a task to dispatch event at animation. The task source for this task is the DOM manipulation task source.
<span class="line-modified">!         callOnMainThread([this, pendingActivity = makePendingActivity(*this), event = WTFMove(event)]() {</span>
<span class="line-removed">-             if (!m_isStopped)</span>
<span class="line-removed">-                 this-&gt;dispatchEvent(event);</span>
<span class="line-removed">-         });</span>
      }
  }
  
  void WebAnimation::resetPendingTasks(Silently silently)
  {
<span class="line-new-header">--- 673,40 ---</span>
      m_startTime = WTF::nullopt;
  
      timingDidChange(DidSeek::No, SynchronouslyNotify::No);
  
      invalidateEffect();
<span class="line-added">+ </span>
<span class="line-added">+     if (m_effect)</span>
<span class="line-added">+         m_effect-&gt;animationWasCanceled();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WebAnimation::willChangeRenderer()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (is&lt;KeyframeEffect&gt;(m_effect))</span>
<span class="line-added">+         downcast&lt;KeyframeEffect&gt;(*m_effect).willChangeRenderer();</span>
  }
  
  void WebAnimation::enqueueAnimationPlaybackEvent(const AtomString&amp; type, Optional&lt;Seconds&gt; currentTime, Optional&lt;Seconds&gt; timelineTime)
  {
<span class="line-modified">!     auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime, this);</span>
      event-&gt;setTarget(this);
<span class="line-added">+     enqueueAnimationEvent(WTFMove(event));</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void WebAnimation::enqueueAnimationEvent(Ref&lt;AnimationEventBase&gt;&amp;&amp; event)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (is&lt;DocumentTimeline&gt;(m_timeline.get())) {</span>
          // If animation has a document for timing, then append event to its document for timing&#39;s pending animation event queue along
          // with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
          // to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
          // scheduled event time is an unresolved time value.
<span class="line-modified">!         m_hasScheduledEventsDuringTick = true;</span>
<span class="line-added">+         downcast&lt;DocumentTimeline&gt;(*m_timeline).enqueueAnimationEvent(WTFMove(event));</span>
      } else {
          // Otherwise, queue a task to dispatch event at animation. The task source for this task is the DOM manipulation task source.
<span class="line-modified">!         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(event));</span>
      }
  }
  
  void WebAnimation::resetPendingTasks(Silently silently)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 647,10 ***</span>
<span class="line-new-header">--- 737,12 ---</span>
      m_readyPromise-&gt;resolve(*this);
  }
  
  ExceptionOr&lt;void&gt; WebAnimation::finish()
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; finish (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
      // 3.4.15. Finishing an animation
      // https://drafts.csswg.org/web-animations-1/#finishing-an-animation-section
  
      // An animation can be advanced to the natural end of its current playback direction by using the procedure to finish an animation for animation defined below:
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,15 ***</span>
      invalidateEffect();
  
      return { };
  }
  
<span class="line-modified">! void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)</span>
  {
      m_shouldSkipUpdatingFinishedStateWhenResolving = false;
      updateFinishedState(didSeek, synchronouslyNotify);
<span class="line-modified">!     if (m_timeline)</span>
          m_timeline-&gt;animationTimingDidChange(*this);
  };
  
  void WebAnimation::invalidateEffect()
  {
<span class="line-new-header">--- 788,21 ---</span>
      invalidateEffect();
  
      return { };
  }
  
<span class="line-modified">! void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify, Silently silently)</span>
  {
      m_shouldSkipUpdatingFinishedStateWhenResolving = false;
      updateFinishedState(didSeek, synchronouslyNotify);
<span class="line-modified">! </span>
<span class="line-added">+     if (is&lt;KeyframeEffect&gt;(m_effect)) {</span>
<span class="line-added">+         updateRelevance();</span>
<span class="line-added">+         downcast&lt;KeyframeEffect&gt;(*m_effect).animationTimingDidChange();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (silently == Silently::No &amp;&amp; m_timeline)</span>
          m_timeline-&gt;animationTimingDidChange(*this);
  };
  
  void WebAnimation::invalidateEffect()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 775,16 ***</span>
              finishNotificationSteps();
          } else if (!m_finishNotificationStepsMicrotaskPending) {
              // Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there
              // is already a microtask queued to run those steps for animation.
              m_finishNotificationStepsMicrotaskPending = true;
<span class="line-modified">!             MicrotaskQueue::mainThreadQueue().append(makeUnique&lt;VoidMicrotask&gt;([this, protectedThis = makeRef(*this)] () {</span>
<span class="line-modified">!                 if (m_finishNotificationStepsMicrotaskPending) {</span>
<span class="line-modified">!                     m_finishNotificationStepsMicrotaskPending = false;</span>
<span class="line-modified">!                     finishNotificationSteps();</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }));</span>
          }
      }
  
      // 6. If current finished state is false and animation&#39;s current finished promise is already resolved, set animation&#39;s current
      // finished promise to a new (pending) Promise object.
<span class="line-new-header">--- 873,18 ---</span>
              finishNotificationSteps();
          } else if (!m_finishNotificationStepsMicrotaskPending) {
              // Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there
              // is already a microtask queued to run those steps for animation.
              m_finishNotificationStepsMicrotaskPending = true;
<span class="line-modified">!             if (auto* context = scriptExecutionContext()) {</span>
<span class="line-modified">!                 context-&gt;eventLoop().queueMicrotask([this, protectedThis = makeRef(*this)] {</span>
<span class="line-modified">!                     if (m_finishNotificationStepsMicrotaskPending) {</span>
<span class="line-modified">!                         m_finishNotificationStepsMicrotaskPending = false;</span>
<span class="line-modified">!                         finishNotificationSteps();</span>
<span class="line-modified">!                     }</span>
<span class="line-added">+                 });</span>
<span class="line-added">+             }</span>
          }
      }
  
      // 6. If current finished state is false and animation&#39;s current finished promise is already resolved, set animation&#39;s current
      // finished promise to a new (pending) Promise object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 824,10 ***</span>
<span class="line-new-header">--- 924,12 ---</span>
      return play(AutoRewind::Yes);
  }
  
  ExceptionOr&lt;void&gt; WebAnimation::play(AutoRewind autoRewind)
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; play(autoRewind &quot; &lt;&lt; (autoRewind == AutoRewind::Yes) &lt;&lt; &quot;) (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
      // 3.4.10. Playing an animation
      // https://drafts.csswg.org/web-animations-1/#play-an-animation
  
      auto localTime = currentTime();
      auto endTime = effectEndTime();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 892,15 ***</span>
<span class="line-new-header">--- 994,20 ---</span>
      // 9. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
      timingDidChange(DidSeek::No, SynchronouslyNotify::No);
  
      invalidateEffect();
  
<span class="line-added">+     if (m_effect)</span>
<span class="line-added">+         m_effect-&gt;animationDidPlay();</span>
<span class="line-added">+ </span>
      return { };
  }
  
  void WebAnimation::runPendingPlayTask()
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; runPendingPlayTask (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
      // 3.4.10. Playing an animation, step 8.
      // https://drafts.csswg.org/web-animations-1/#play-an-animation
  
      m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 950,17 ***</span>
      // 4. Resolve animation&#39;s current ready promise with animation.
      if (!m_readyPromise-&gt;isFulfilled())
          m_readyPromise-&gt;resolve(*this);
  
      // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
<span class="line-modified">!     timingDidChange(DidSeek::No, SynchronouslyNotify::No);</span>
  
      invalidateEffect();
  }
  
  ExceptionOr&lt;void&gt; WebAnimation::pause()
  {
      // 3.4.11. Pausing an animation
      // https://drafts.csswg.org/web-animations-1/#pause-an-animation
  
      // 1. If animation has a pending pause task, abort these steps.
      if (hasPendingPauseTask())
<span class="line-new-header">--- 1057,19 ---</span>
      // 4. Resolve animation&#39;s current ready promise with animation.
      if (!m_readyPromise-&gt;isFulfilled())
          m_readyPromise-&gt;resolve(*this);
  
      // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
<span class="line-modified">!     timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);</span>
  
      invalidateEffect();
  }
  
  ExceptionOr&lt;void&gt; WebAnimation::pause()
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; pause (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
      // 3.4.11. Pausing an animation
      // https://drafts.csswg.org/web-animations-1/#pause-an-animation
  
      // 1. If animation has a pending pause task, abort these steps.
      if (hasPendingPauseTask())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1011,10 ***</span>
<span class="line-new-header">--- 1120,12 ---</span>
      return { };
  }
  
  ExceptionOr&lt;void&gt; WebAnimation::reverse()
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; reverse (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
      // 3.4.18. Reversing an animation
      // https://drafts.csswg.org/web-animations-1/#reverse-an-animation
  
      // The procedure to reverse an animation of animation animation is as follows:
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,10 ***</span>
<span class="line-new-header">--- 1153,12 ---</span>
      return { };
  }
  
  void WebAnimation::runPendingPauseTask()
  {
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; runPendingPauseTask (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
      // 3.4.11. Pausing an animation, step 7.
      // https://drafts.csswg.org/web-animations-1/#pause-an-animation
  
      m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1076,37 ***</span>
      if (!m_readyPromise-&gt;isFulfilled())
          m_readyPromise-&gt;resolve(*this);
  
      // 6. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the
      //    synchronously notify flag set to false.
<span class="line-modified">!     timingDidChange(DidSeek::No, SynchronouslyNotify::No);</span>
  
      invalidateEffect();
  }
  
  bool WebAnimation::isRunningAccelerated() const
  {
      return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isRunningAccelerated();
  }
  
  bool WebAnimation::needsTick() const
  {
<span class="line-modified">!     return pending() || playState() == PlayState::Running;</span>
  }
  
  void WebAnimation::tick()
  {
      updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
      m_shouldSkipUpdatingFinishedStateWhenResolving = true;
  
      // Run pending tasks, if any.
      if (hasPendingPauseTask())
          runPendingPauseTask();
      if (hasPendingPlayTask())
          runPendingPlayTask();
  
<span class="line-modified">!     invalidateEffect();</span>
  }
  
  void WebAnimation::resolve(RenderStyle&amp; targetStyle)
  {
      if (!m_shouldSkipUpdatingFinishedStateWhenResolving)
<span class="line-new-header">--- 1189,44 ---</span>
      if (!m_readyPromise-&gt;isFulfilled())
          m_readyPromise-&gt;resolve(*this);
  
      // 6. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the
      //    synchronously notify flag set to false.
<span class="line-modified">!     timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);</span>
  
      invalidateEffect();
  }
  
  bool WebAnimation::isRunningAccelerated() const
  {
      return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isRunningAccelerated();
  }
  
<span class="line-added">+ bool WebAnimation::isCompletelyAccelerated() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isCompletelyAccelerated();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool WebAnimation::needsTick() const
  {
<span class="line-modified">!     return pending() || playState() == PlayState::Running || m_hasScheduledEventsDuringTick;</span>
  }
  
  void WebAnimation::tick()
  {
<span class="line-added">+     m_hasScheduledEventsDuringTick = false;</span>
      updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
      m_shouldSkipUpdatingFinishedStateWhenResolving = true;
  
      // Run pending tasks, if any.
      if (hasPendingPauseTask())
          runPendingPauseTask();
      if (hasPendingPlayTask())
          runPendingPlayTask();
  
<span class="line-modified">!     if (!isEffectInvalidationSuspended() &amp;&amp; m_effect)</span>
<span class="line-added">+         m_effect-&gt;animationDidTick();</span>
  }
  
  void WebAnimation::resolve(RenderStyle&amp; targetStyle)
  {
      if (!m_shouldSkipUpdatingFinishedStateWhenResolving)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1128,11 ***</span>
          m_effect-&gt;animationSuspensionStateDidChange(isSuspended);
  }
  
  void WebAnimation::acceleratedStateDidChange()
  {
<span class="line-modified">!     if (is&lt;DocumentTimeline&gt;(m_timeline))</span>
          downcast&lt;DocumentTimeline&gt;(*m_timeline).animationAcceleratedRunningStateDidChange(*this);
  }
  
  void WebAnimation::applyPendingAcceleratedActions()
  {
<span class="line-new-header">--- 1248,11 ---</span>
          m_effect-&gt;animationSuspensionStateDidChange(isSuspended);
  }
  
  void WebAnimation::acceleratedStateDidChange()
  {
<span class="line-modified">!     if (is&lt;DocumentTimeline&gt;(m_timeline.get()))</span>
          downcast&lt;DocumentTimeline&gt;(*m_timeline).animationAcceleratedRunningStateDidChange(*this);
  }
  
  void WebAnimation::applyPendingAcceleratedActions()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1153,22 ***</span>
  const char* WebAnimation::activeDOMObjectName() const
  {
      return &quot;Animation&quot;;
  }
  
<span class="line-modified">! bool WebAnimation::canSuspendForDocumentSuspension() const</span>
  {
<span class="line-modified">!     // Use the base class&#39;s implementation of hasPendingActivity() since we wouldn&#39;t want the custom implementation</span>
<span class="line-modified">!     // in this class designed to keep JS wrappers alive to interfere with the ability for a page using animations</span>
<span class="line-modified">!     // to enter the page cache.</span>
<span class="line-modified">!     return !ActiveDOMObject::hasPendingActivity();</span>
  }
  
  void WebAnimation::stop()
  {
      ActiveDOMObject::stop();
<span class="line-removed">-     m_isStopped = true;</span>
      removeAllEventListeners();
  }
  
  bool WebAnimation::hasPendingActivity() const
  {
<span class="line-new-header">--- 1273,23 ---</span>
  const char* WebAnimation::activeDOMObjectName() const
  {
      return &quot;Animation&quot;;
  }
  
<span class="line-modified">! void WebAnimation::suspend(ReasonForSuspension)</span>
  {
<span class="line-modified">!     setSuspended(true);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void WebAnimation::resume()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     setSuspended(false);</span>
  }
  
  void WebAnimation::stop()
  {
      ActiveDOMObject::stop();
      removeAllEventListeners();
  }
  
  bool WebAnimation::hasPendingActivity() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1185,10 ***</span>
<span class="line-new-header">--- 1306,13 ---</span>
  {
      // To be listed in getAnimations() an animation needs a target effect which is current or in effect.
      if (!m_effect)
          return false;
  
<span class="line-added">+     if (m_replaceState == ReplaceState::Removed)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      auto timing = m_effect-&gt;getBasicTiming();
  
      // An animation effect is in effect if its active time is not unresolved.
      if (timing.activeTime)
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1201,43 ***</span>
      // - the animation effect is in the active phase, and
      // - the animation effect is associated with an animation that is not finished.
      return timing.phase == AnimationEffectPhase::Before || (timing.phase == AnimationEffectPhase::Active &amp;&amp; playState() != PlayState::Finished);
  }
  
  Seconds WebAnimation::timeToNextTick() const
  {
<span class="line-modified">!     ASSERT(isRunningAccelerated());</span>
  
      if (pending())
          return 0_s;
  
<span class="line-modified">!     // If we&#39;re not running, there&#39;s no telling when we&#39;ll end.</span>
<span class="line-modified">!     if (playState() != PlayState::Running)</span>
          return Seconds::infinity();
  
<span class="line-modified">!     // CSS Animations dispatch events for each iteration, so compute the time until</span>
<span class="line-modified">!     // the end of this iteration. Any other animation only cares about remaning total time.</span>
<span class="line-modified">!     if (isCSSAnimation()) {</span>
<span class="line-modified">!         auto* animationEffect = effect();</span>
<span class="line-modified">!         auto timing = animationEffect-&gt;getComputedTiming();</span>
<span class="line-modified">!         // If we&#39;re actively running, we need the time until the next iteration.</span>
<span class="line-modified">!         if (auto iterationProgress = timing.simpleIterationProgress)</span>
<span class="line-modified">!             return animationEffect-&gt;iterationDuration() * (1 - *iterationProgress);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Otherwise we&#39;re probably in the before phase waiting to reach our start time.</span>
<span class="line-modified">!         if (auto animationCurrentTime = currentTime()) {</span>
<span class="line-modified">!             // If our current time is negative, we need to be scheduled to be resolved at the inverse</span>
<span class="line-modified">!             // of our current time, unless we fill backwards, in which case we want to invalidate as</span>
<span class="line-modified">!             // soon as possible.</span>
<span class="line-modified">!             auto localTime = animationCurrentTime.value();</span>
<span class="line-removed">-             if (localTime &lt; 0_s)</span>
<span class="line-removed">-                 return -localTime;</span>
<span class="line-removed">-             if (localTime &lt; animationEffect-&gt;delay())</span>
<span class="line-removed">-                 return animationEffect-&gt;delay() - localTime;</span>
          }
<span class="line-modified">!     } else if (auto animationCurrentTime = currentTime())</span>
<span class="line-modified">!         return effect()-&gt;getBasicTiming().endTime - *animationCurrentTime;</span>
  
      ASSERT_NOT_REACHED();
      return Seconds::infinity();
  }
  
<span class="line-new-header">--- 1325,168 ---</span>
      // - the animation effect is in the active phase, and
      // - the animation effect is associated with an animation that is not finished.
      return timing.phase == AnimationEffectPhase::Before || (timing.phase == AnimationEffectPhase::Active &amp;&amp; playState() != PlayState::Finished);
  }
  
<span class="line-added">+ bool WebAnimation::isReplaceable() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // An animation is replaceable if all of the following conditions are true:</span>
<span class="line-added">+     // https://drafts.csswg.org/web-animations/#removing-replaced-animations</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The existence of the animation is not prescribed by markup. That is, it is not a CSS animation with an owning element,</span>
<span class="line-added">+     // nor a CSS transition with an owning element.</span>
<span class="line-added">+     if (isDeclarativeAnimation() &amp;&amp; downcast&lt;DeclarativeAnimation&gt;(this)-&gt;owningElement())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The animation&#39;s play state is finished.</span>
<span class="line-added">+     if (playState() != PlayState::Finished)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The animation&#39;s replace state is not removed.</span>
<span class="line-added">+     if (m_replaceState == ReplaceState::Removed)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The animation is associated with a monotonically increasing timeline.</span>
<span class="line-added">+     if (!m_timeline)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The animation has an associated target effect.</span>
<span class="line-added">+     if (!m_effect)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The target effect associated with the animation is in effect.</span>
<span class="line-added">+     if (!m_effect-&gt;getBasicTiming().activeTime)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The target effect has an associated target element.</span>
<span class="line-added">+     if (!is&lt;KeyframeEffect&gt;(m_effect) || !downcast&lt;KeyframeEffect&gt;(m_effect.get())-&gt;target())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WebAnimation::persist()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto previousReplaceState = std::exchange(m_replaceState, ReplaceState::Persisted);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (previousReplaceState == ReplaceState::Removed &amp;&amp; m_timeline) {</span>
<span class="line-added">+         if (is&lt;KeyframeEffect&gt;(m_effect)) {</span>
<span class="line-added">+             auto&amp; keyframeEffect = downcast&lt;KeyframeEffect&gt;(*m_effect);</span>
<span class="line-added">+             auto&amp; target = *keyframeEffect.target();</span>
<span class="line-added">+             m_timeline-&gt;animationWasAddedToElement(*this, target);</span>
<span class="line-added">+             target.ensureKeyframeEffectStack().addEffect(keyframeEffect);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ExceptionOr&lt;void&gt; WebAnimation::commitStyles()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // https://drafts.csswg.org/web-animations-1/#commit-computed-styles</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 1. Let targets be the set of all effect targets for animation effects associated with animation.</span>
<span class="line-added">+     auto* effect = is&lt;KeyframeEffect&gt;(m_effect) ? downcast&lt;KeyframeEffect&gt;(m_effect.get()) : nullptr;</span>
<span class="line-added">+     auto* target = effect ? effect-&gt;target() : nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 2. For each target in targets:</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // 2.1 If target is not an element capable of having a style attribute (for example, it is a pseudo-element or is an element in a</span>
<span class="line-added">+     // document format for which style attributes are not defined) throw a &quot;NoModificationAllowedError&quot; DOMException and abort these steps.</span>
<span class="line-added">+     if (!is&lt;StyledElement&gt;(target))</span>
<span class="line-added">+         return Exception { NoModificationAllowedError };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; styledElement = downcast&lt;StyledElement&gt;(*target);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 2.2 If, after applying any pending style changes, target is not being rendered, throw an &quot;InvalidStateError&quot; DOMException and abort these steps.</span>
<span class="line-added">+     styledElement.document().updateStyleIfNeeded();</span>
<span class="line-added">+     auto* renderer = styledElement.renderer();</span>
<span class="line-added">+     if (!renderer)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 2.3 Let inline style be the result of getting the CSS declaration block corresponding to target’s style attribute. If target does not have a style</span>
<span class="line-added">+     // attribute, let inline style be a new empty CSS declaration block with the readonly flag unset and owner node set to target.</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 2.4 Let targeted properties be the set of physical longhand properties that are a target property for at least one animation effect associated with</span>
<span class="line-added">+     // animation whose effect target is target.</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; style = renderer-&gt;style();</span>
<span class="line-added">+     auto computedStyleExtractor = ComputedStyleExtractor(&amp;styledElement);</span>
<span class="line-added">+     auto inlineStyle = styledElement.document().createCSSStyleDeclaration();</span>
<span class="line-added">+     inlineStyle-&gt;setCssText(styledElement.getAttribute(&quot;style&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; keyframeStack = styledElement.ensureKeyframeEffectStack();</span>
<span class="line-added">+     auto* cssAnimationList = keyframeStack.cssAnimationList();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 2.5 For each property, property, in targeted properties:</span>
<span class="line-added">+     for (auto property : effect-&gt;animatedProperties()) {</span>
<span class="line-added">+         // 1. Let partialEffectStack be a copy of the effect stack for property on target.</span>
<span class="line-added">+         // 2. If animation&#39;s replace state is removed, add all animation effects associated with animation whose effect target is target and which include</span>
<span class="line-added">+         // property as a target property to partialEffectStack.</span>
<span class="line-added">+         // 3. Remove from partialEffectStack any animation effects whose associated animation has a higher composite order than animation.</span>
<span class="line-added">+         // 4. Let effect value be the result of calculating the result of partialEffectStack for property using target&#39;s computed style (see § 5.4.3 Calculating</span>
<span class="line-added">+         // the result of an effect stack).</span>
<span class="line-added">+         // 5. Set a CSS declaration property for effect value in inline style.</span>
<span class="line-added">+         // 6. Update style attribute for inline style.</span>
<span class="line-added">+ </span>
<span class="line-added">+         // We actually perform those steps in a different way: instead of building a copy of the effect stack and then removing stuff, we iterate through the</span>
<span class="line-added">+         // effect stack and stop when we&#39;ve found this animation&#39;s effect or when we&#39;ve found an effect associated with an animation with a higher composite order.</span>
<span class="line-added">+         auto animatedStyle = RenderStyle::clonePtr(style);</span>
<span class="line-added">+         for (const auto&amp; effectInStack : keyframeStack.sortedEffects()) {</span>
<span class="line-added">+             if (effectInStack-&gt;animation() != this &amp;&amp; !compareAnimationsByCompositeOrder(*effectInStack-&gt;animation(), *this, cssAnimationList))</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             if (effectInStack-&gt;animatedProperties().contains(property))</span>
<span class="line-added">+                 effectInStack-&gt;animation()-&gt;resolve(*animatedStyle);</span>
<span class="line-added">+             if (effectInStack-&gt;animation() == this)</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (m_replaceState == ReplaceState::Removed)</span>
<span class="line-added">+             effect-&gt;animation()-&gt;resolve(*animatedStyle);</span>
<span class="line-added">+         if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(*animatedStyle, property, renderer))</span>
<span class="line-added">+             inlineStyle-&gt;setPropertyInternal(property, cssValue-&gt;cssText(), false);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     styledElement.setAttribute(&quot;style&quot;, inlineStyle-&gt;cssText());</span>
<span class="line-added">+ </span>
<span class="line-added">+     return { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Seconds WebAnimation::timeToNextTick() const
  {
<span class="line-modified">!     ASSERT(effect());</span>
  
      if (pending())
          return 0_s;
  
<span class="line-modified">!     // If we&#39;re not running, or time is not advancing for this animation, there&#39;s no telling when we&#39;ll end.</span>
<span class="line-modified">!     auto playbackRate = effectivePlaybackRate();</span>
<span class="line-added">+     if (playState() != PlayState::Running || !playbackRate)</span>
          return Seconds::infinity();
  
<span class="line-modified">!     auto&amp; effect = *this-&gt;effect();</span>
<span class="line-modified">!     auto timing = effect.getBasicTiming();</span>
<span class="line-modified">!     switch (timing.phase) {</span>
<span class="line-modified">!     case AnimationEffectPhase::Before:</span>
<span class="line-modified">!         // The animation is in its &quot;before&quot; phase, in this case we can wait until it enters its &quot;active&quot; phase.</span>
<span class="line-modified">!         return (effect.delay() - timing.localTime.value()) / playbackRate;</span>
<span class="line-modified">!     case AnimationEffectPhase::Active:</span>
<span class="line-modified">!         if (isCompletelyAccelerated() &amp;&amp; isRunningAccelerated()) {</span>
<span class="line-modified">!             // Fully-accelerated running CSS Animations need to trigger &quot;animationiteration&quot; events, in this case we must wait until the next iteration.</span>
<span class="line-modified">!             if (isCSSAnimation()) {</span>
<span class="line-modified">!                 if (auto iterationProgress = effect.getComputedTiming().simpleIterationProgress)</span>
<span class="line-modified">!                     return effect.iterationDuration() * (1 - *iterationProgress);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             // Fully-accelerated running animations in the &quot;active&quot; phase can wait until they ended.</span>
<span class="line-modified">!             return (effect.endTime() - timing.localTime.value()) / playbackRate;</span>
          }
<span class="line-modified">!         // Other animations in the &quot;active&quot; phase will need to update their animated value at the immediate next opportunity.</span>
<span class="line-modified">!         return 0_s;</span>
<span class="line-added">+     case AnimationEffectPhase::After:</span>
<span class="line-added">+         // The animation is in its after phase, which means it will no longer update its value, so it doens&#39;t need a tick.</span>
<span class="line-added">+         return Seconds::infinity();</span>
<span class="line-added">+     case AnimationEffectPhase::Idle:</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return Seconds::infinity();</span>
<span class="line-added">+     }</span>
  
      ASSERT_NOT_REACHED();
      return Seconds::infinity();
  }
  
</pre>
<center><a href="KeyframeEffect.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebAnimation.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
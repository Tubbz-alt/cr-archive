<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingStateScrollingNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012, 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 
 30 #include &quot;ScrollSnapOffsetsInfo.h&quot;
 31 #include &quot;ScrollTypes.h&quot;
 32 #include &quot;ScrollingCoordinator.h&quot;
 33 #include &quot;ScrollingStateNode.h&quot;
 34 
 35 #if PLATFORM(COCOA)
 36 OBJC_CLASS NSScrollerImp;
 37 #endif
 38 
 39 namespace WebCore {
 40 
 41 struct RequestedScrollData {
 42     FloatPoint scrollPosition;
 43     ScrollType scrollType { ScrollType::User };
 44     ScrollClamping clamping { ScrollClamping::Clamped };
 45 
 46     bool operator==(const RequestedScrollData&amp; other) const
 47     {
 48         return scrollPosition == other.scrollPosition
 49             &amp;&amp; scrollType == other.scrollType
 50             &amp;&amp; clamping == other.clamping;
 51     }
 52 };
 53 
 54 class ScrollingStateScrollingNode : public ScrollingStateNode {
 55 public:
 56     virtual ~ScrollingStateScrollingNode();
 57 
 58     enum ChangedProperty {
 59         ScrollableAreaSize = NumStateNodeBits,
 60         TotalContentsSize,
 61         ReachableContentsSize,
 62         ParentRelativeScrollableRect,
 63         ScrollPosition,
 64         ScrollOrigin,
 65         ScrollableAreaParams,
 66         RequestedScrollPosition,
 67 #if ENABLE(CSS_SCROLL_SNAP)
 68         HorizontalSnapOffsets,
 69         VerticalSnapOffsets,
 70         HorizontalSnapOffsetRanges,
 71         VerticalSnapOffsetRanges,
 72         CurrentHorizontalSnapOffsetIndex,
 73         CurrentVerticalSnapOffsetIndex,
 74 #endif
 75         IsMonitoringWheelEvents,
 76         ScrollContainerLayer,
 77         ScrolledContentsLayer,
 78         HorizontalScrollbarLayer,
 79         VerticalScrollbarLayer,
 80         PainterForScrollbar,
 81         NumScrollingStateNodeBits // This must remain at the last position.
 82     };
 83 
 84     const FloatSize&amp; scrollableAreaSize() const { return m_scrollableAreaSize; }
 85     WEBCORE_EXPORT void setScrollableAreaSize(const FloatSize&amp;);
 86 
 87     const FloatSize&amp; totalContentsSize() const { return m_totalContentsSize; }
 88     WEBCORE_EXPORT void setTotalContentsSize(const FloatSize&amp;);
 89 
 90     const FloatSize&amp; reachableContentsSize() const { return m_reachableContentsSize; }
 91     WEBCORE_EXPORT void setReachableContentsSize(const FloatSize&amp;);
 92 
 93     const LayoutRect&amp; parentRelativeScrollableRect() const { return m_parentRelativeScrollableRect; }
 94     WEBCORE_EXPORT void setParentRelativeScrollableRect(const LayoutRect&amp;);
 95 
 96     const FloatPoint&amp; scrollPosition() const { return m_scrollPosition; }
 97     WEBCORE_EXPORT void setScrollPosition(const FloatPoint&amp;);
 98 
 99     const IntPoint&amp; scrollOrigin() const { return m_scrollOrigin; }
100     WEBCORE_EXPORT void setScrollOrigin(const IntPoint&amp;);
101 
102 #if ENABLE(CSS_SCROLL_SNAP)
103     const Vector&lt;float&gt;&amp; horizontalSnapOffsets() const { return m_snapOffsetsInfo.horizontalSnapOffsets; }
104     WEBCORE_EXPORT void setHorizontalSnapOffsets(const Vector&lt;float&gt;&amp;);
105 
106     const Vector&lt;float&gt;&amp; verticalSnapOffsets() const { return m_snapOffsetsInfo.verticalSnapOffsets; }
107     WEBCORE_EXPORT void setVerticalSnapOffsets(const Vector&lt;float&gt;&amp;);
108 
109     const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp; horizontalSnapOffsetRanges() const { return m_snapOffsetsInfo.horizontalSnapOffsetRanges; }
110     WEBCORE_EXPORT void setHorizontalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp;);
111 
112     const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp; verticalSnapOffsetRanges() const { return m_snapOffsetsInfo.verticalSnapOffsetRanges; }
113     WEBCORE_EXPORT void setVerticalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp;);
114 
115     unsigned currentHorizontalSnapPointIndex() const { return m_currentHorizontalSnapPointIndex; }
116     WEBCORE_EXPORT void setCurrentHorizontalSnapPointIndex(unsigned);
117 
118     unsigned currentVerticalSnapPointIndex() const { return m_currentVerticalSnapPointIndex; }
119     WEBCORE_EXPORT void setCurrentVerticalSnapPointIndex(unsigned);
120 #endif
121 
122     const ScrollableAreaParameters&amp; scrollableAreaParameters() const { return m_scrollableAreaParameters; }
123     WEBCORE_EXPORT void setScrollableAreaParameters(const ScrollableAreaParameters&amp; params);
124 
125     const RequestedScrollData&amp; requestedScrollData() const { return m_requestedScrollData; }
126     WEBCORE_EXPORT void setRequestedScrollData(const RequestedScrollData&amp;);
127 
128     bool isMonitoringWheelEvents() const { return m_isMonitoringWheelEvents; }
129     WEBCORE_EXPORT void setIsMonitoringWheelEvents(bool);
130 
131     const LayerRepresentation&amp; scrollContainerLayer() const { return m_scrollContainerLayer; }
132     WEBCORE_EXPORT void setScrollContainerLayer(const LayerRepresentation&amp;);
133 
134     // This is a layer with the contents that move.
135     const LayerRepresentation&amp; scrolledContentsLayer() const { return m_scrolledContentsLayer; }
136     WEBCORE_EXPORT void setScrolledContentsLayer(const LayerRepresentation&amp;);
137 
138     const LayerRepresentation&amp; horizontalScrollbarLayer() const { return m_horizontalScrollbarLayer; }
139     WEBCORE_EXPORT void setHorizontalScrollbarLayer(const LayerRepresentation&amp;);
140 
141     const LayerRepresentation&amp; verticalScrollbarLayer() const { return m_verticalScrollbarLayer; }
142     WEBCORE_EXPORT void setVerticalScrollbarLayer(const LayerRepresentation&amp;);
143 
144 #if PLATFORM(MAC)
145     NSScrollerImp *verticalScrollerImp() const { return m_verticalScrollerImp.get(); }
146     NSScrollerImp *horizontalScrollerImp() const { return m_horizontalScrollerImp.get(); }
147 #endif
148     void setScrollerImpsFromScrollbars(Scrollbar* verticalScrollbar, Scrollbar* horizontalScrollbar);
149 
150 protected:
151     ScrollingStateScrollingNode(ScrollingStateTree&amp;, ScrollingNodeType, ScrollingNodeID);
152     ScrollingStateScrollingNode(const ScrollingStateScrollingNode&amp;, ScrollingStateTree&amp;);
153 
154     void setPropertyChangedBitsAfterReattach() override;
155 
156     void dumpProperties(WTF::TextStream&amp;, ScrollingStateTreeAsTextBehavior) const override;
157 
158 private:
159     FloatSize m_scrollableAreaSize;
160     FloatSize m_totalContentsSize;
161     FloatSize m_reachableContentsSize;
162     LayoutRect m_parentRelativeScrollableRect;
163     FloatPoint m_scrollPosition;
164     IntPoint m_scrollOrigin;
165 
166 #if ENABLE(CSS_SCROLL_SNAP)
167     ScrollSnapOffsetsInfo&lt;float&gt; m_snapOffsetsInfo;
168     unsigned m_currentHorizontalSnapPointIndex { 0 };
169     unsigned m_currentVerticalSnapPointIndex { 0 };
170 #endif
171 
172     LayerRepresentation m_scrollContainerLayer;
173     LayerRepresentation m_scrolledContentsLayer;
174     LayerRepresentation m_horizontalScrollbarLayer;
175     LayerRepresentation m_verticalScrollbarLayer;
176 
177 #if PLATFORM(MAC)
178     RetainPtr&lt;NSScrollerImp&gt; m_verticalScrollerImp;
179     RetainPtr&lt;NSScrollerImp&gt; m_horizontalScrollerImp;
180 #endif
181 
182     ScrollableAreaParameters m_scrollableAreaParameters;
183     RequestedScrollData m_requestedScrollData;
184 
185     bool m_isMonitoringWheelEvents { false };
186 };
187 
188 } // namespace WebCore
189 
190 SPECIALIZE_TYPE_TRAITS_SCROLLING_STATE_NODE(ScrollingStateScrollingNode, isScrollingNode())
191 
192 #endif // ENABLE(ASYNC_SCROLLING)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertBufferSource.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertBoolean.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertCallbacks.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertBufferSource.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 46 inline RefPtr&lt;JSC::Int8Array&gt; toPossiblySharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 47 inline RefPtr&lt;JSC::Int16Array&gt; toPossiblySharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 48 inline RefPtr&lt;JSC::Int32Array&gt; toPossiblySharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 49 inline RefPtr&lt;JSC::Uint8Array&gt; toPossiblySharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 50 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toPossiblySharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 51 inline RefPtr&lt;JSC::Uint16Array&gt; toPossiblySharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 52 inline RefPtr&lt;JSC::Uint32Array&gt; toPossiblySharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 53 inline RefPtr&lt;JSC::Float32Array&gt; toPossiblySharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 54 inline RefPtr&lt;JSC::Float64Array&gt; toPossiblySharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 55 
 56 inline RefPtr&lt;JSC::Int8Array&gt; toUnsharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 57 inline RefPtr&lt;JSC::Int16Array&gt; toUnsharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 58 inline RefPtr&lt;JSC::Int32Array&gt; toUnsharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 59 inline RefPtr&lt;JSC::Uint8Array&gt; toUnsharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 60 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toUnsharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 61 inline RefPtr&lt;JSC::Uint16Array&gt; toUnsharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 62 inline RefPtr&lt;JSC::Uint32Array&gt; toUnsharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 63 inline RefPtr&lt;JSC::Float32Array&gt; toUnsharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 64 inline RefPtr&lt;JSC::Float64Array&gt; toUnsharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 65 
<span class="line-modified"> 66 inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer&amp; buffer)</span>
 67 {
 68     if (auto result = getCachedWrapper(globalObject-&gt;world(), buffer))
 69         return result;
 70 
 71     // The JSArrayBuffer::create function will register the wrapper in finishCreation.
<span class="line-modified"> 72     return JSC::JSArrayBuffer::create(state-&gt;vm(), globalObject-&gt;arrayBufferStructure(buffer.sharingMode()), &amp;buffer);</span>
 73 }
 74 
<span class="line-modified"> 75 inline JSC::JSValue toJS(JSC::ExecState* state, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView&amp; view)</span>
 76 {
<span class="line-modified"> 77     return view.wrap(state, globalObject);</span>
 78 }
 79 
<span class="line-modified"> 80 inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer* buffer)</span>
 81 {
 82     if (!buffer)
 83         return JSC::jsNull();
<span class="line-modified"> 84     return toJS(state, globalObject, *buffer);</span>
 85 }
 86 
<span class="line-modified"> 87 inline JSC::JSValue toJS(JSC::ExecState* state, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView* view)</span>
 88 {
 89     if (!view)
 90         return JSC::jsNull();
<span class="line-modified"> 91     return toJS(state, globalObject, *view);</span>
 92 }
 93 
 94 inline RefPtr&lt;JSC::ArrayBufferView&gt; toPossiblySharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
 95 {
 96     auto* wrapper = JSC::jsDynamicCast&lt;JSC::JSArrayBufferView*&gt;(vm, value);
 97     if (!wrapper)
 98         return nullptr;
 99     return wrapper-&gt;possiblySharedImpl();
100 }
101 
102 inline RefPtr&lt;JSC::ArrayBufferView&gt; toUnsharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
103 {
104     auto result = toPossiblySharedArrayBufferView(vm, value);
105     if (!result || result-&gt;isShared())
106         return nullptr;
107     return result;
108 }
109 
110 namespace Detail {
111 
112 template&lt;typename BufferSourceType&gt;
113 struct BufferSourceConverter {
114     using WrapperType = typename Converter&lt;BufferSourceType&gt;::WrapperType;
115     using ReturnType = typename Converter&lt;BufferSourceType&gt;::ReturnType;
116 
117     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">118     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
119     {
<span class="line-modified">120         auto&amp; vm = state.vm();</span>
121         auto scope = DECLARE_THROW_SCOPE(vm);
122         ReturnType object = WrapperType::toWrapped(vm, value);
123         if (UNLIKELY(!object))
<span class="line-modified">124             exceptionThrower(state, scope);</span>
125         return object;
126     }
127 };
128 
129 }
130 
131 template&lt;&gt; struct Converter&lt;IDLArrayBuffer&gt; : DefaultConverter&lt;IDLArrayBuffer&gt; {
132     using WrapperType = JSC::JSArrayBuffer;
133     using ReturnType = JSC::ArrayBuffer*;
134 
135     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">136     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
137     {
<span class="line-modified">138         return Detail::BufferSourceConverter&lt;IDLArrayBuffer&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
139     }
140 };
141 
142 template&lt;&gt; struct JSConverter&lt;IDLArrayBuffer&gt; {
143     static constexpr bool needsState = true;
144     static constexpr bool needsGlobalObject = true;
145 
146     template &lt;typename U&gt;
<span class="line-modified">147     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
148     {
<span class="line-modified">149         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
150     }
151 };
152 
153 template&lt;&gt; struct Converter&lt;IDLDataView&gt; : DefaultConverter&lt;IDLDataView&gt; {
154     using WrapperType = JSC::JSDataView;
155     using ReturnType = RefPtr&lt;JSC::DataView&gt;;
156 
157     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">158     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
159     {
<span class="line-modified">160         return Detail::BufferSourceConverter&lt;IDLDataView&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
161     }
162 };
163 
164 template&lt;&gt; struct JSConverter&lt;IDLDataView&gt; {
165     static constexpr bool needsState = true;
166     static constexpr bool needsGlobalObject = true;
167 
168     template &lt;typename U&gt;
<span class="line-modified">169     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
170     {
<span class="line-modified">171         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
172     }
173 };
174 
175 template&lt;&gt; struct Converter&lt;IDLInt8Array&gt; : DefaultConverter&lt;IDLInt8Array&gt; {
176     using WrapperType = JSC::JSInt8Array;
177     using ReturnType = RefPtr&lt;JSC::Int8Array&gt;;
178 
179     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">180     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
181     {
<span class="line-modified">182         return Detail::BufferSourceConverter&lt;IDLInt8Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
183     }
184 };
185 
186 template&lt;&gt; struct JSConverter&lt;IDLInt8Array&gt; {
187     static constexpr bool needsState = true;
188     static constexpr bool needsGlobalObject = true;
189 
190     template &lt;typename U&gt;
<span class="line-modified">191     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
192     {
<span class="line-modified">193         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
194     }
195 };
196 
197 template&lt;&gt; struct Converter&lt;IDLInt16Array&gt; : DefaultConverter&lt;IDLInt16Array&gt; {
198     using WrapperType = JSC::JSInt16Array;
199     using ReturnType = RefPtr&lt;JSC::Int16Array&gt;;
200 
201     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">202     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
203     {
<span class="line-modified">204         return Detail::BufferSourceConverter&lt;IDLInt16Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
205     }
206 };
207 
208 template&lt;&gt; struct JSConverter&lt;IDLInt16Array&gt; {
209     static constexpr bool needsState = true;
210     static constexpr bool needsGlobalObject = true;
211 
212     template &lt;typename U&gt;
<span class="line-modified">213     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
214     {
<span class="line-modified">215         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
216     }
217 };
218 
219 template&lt;&gt; struct Converter&lt;IDLInt32Array&gt; : DefaultConverter&lt;IDLInt32Array&gt; {
220     using WrapperType = JSC::JSInt32Array;
221     using ReturnType = RefPtr&lt;JSC::Int32Array&gt;;
222 
223     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">224     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
225     {
<span class="line-modified">226         return Detail::BufferSourceConverter&lt;IDLInt32Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
227     }
228 };
229 
230 template&lt;&gt; struct JSConverter&lt;IDLInt32Array&gt; {
231     static constexpr bool needsState = true;
232     static constexpr bool needsGlobalObject = true;
233 
234     template &lt;typename U&gt;
<span class="line-modified">235     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
236     {
<span class="line-modified">237         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
238     }
239 };
240 
241 template&lt;&gt; struct Converter&lt;IDLUint8Array&gt; : DefaultConverter&lt;IDLUint8Array&gt; {
242     using WrapperType = JSC::JSUint8Array;
243     using ReturnType = RefPtr&lt;JSC::Uint8Array&gt;;
244 
245     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">246     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
247     {
<span class="line-modified">248         return Detail::BufferSourceConverter&lt;IDLUint8Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
249     }
250 };
251 
252 template&lt;&gt; struct JSConverter&lt;IDLUint8Array&gt; {
253     static constexpr bool needsState = true;
254     static constexpr bool needsGlobalObject = true;
255 
256     template &lt;typename U&gt;
<span class="line-modified">257     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
258     {
<span class="line-modified">259         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
260     }
261 };
262 
263 template&lt;&gt; struct Converter&lt;IDLUint16Array&gt; : DefaultConverter&lt;IDLUint16Array&gt; {
264     using WrapperType = JSC::JSUint16Array;
265     using ReturnType = RefPtr&lt;JSC::Uint16Array&gt;;
266 
267     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">268     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
269     {
<span class="line-modified">270         return Detail::BufferSourceConverter&lt;IDLUint16Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
271     }
272 };
273 
274 template&lt;&gt; struct JSConverter&lt;IDLUint16Array&gt; {
275     static constexpr bool needsState = true;
276     static constexpr bool needsGlobalObject = true;
277 
278     template &lt;typename U&gt;
<span class="line-modified">279     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
280     {
<span class="line-modified">281         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
282     }
283 };
284 
285 template&lt;&gt; struct Converter&lt;IDLUint32Array&gt; : DefaultConverter&lt;IDLUint32Array&gt; {
286     using WrapperType = JSC::JSUint32Array;
287     using ReturnType = RefPtr&lt;JSC::Uint32Array&gt;;
288 
289     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">290     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
291     {
<span class="line-modified">292         return Detail::BufferSourceConverter&lt;IDLUint32Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
293     }
294 };
295 
296 template&lt;&gt; struct JSConverter&lt;IDLUint32Array&gt; {
297     static constexpr bool needsState = true;
298     static constexpr bool needsGlobalObject = true;
299 
300     template &lt;typename U&gt;
<span class="line-modified">301     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
302     {
<span class="line-modified">303         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
304     }
305 };
306 
307 template&lt;&gt; struct Converter&lt;IDLUint8ClampedArray&gt; : DefaultConverter&lt;IDLUint8ClampedArray&gt; {
308     using WrapperType = JSC::JSUint8ClampedArray;
309     using ReturnType = RefPtr&lt;JSC::Uint8ClampedArray&gt;;
310 
311     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">312     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
313     {
<span class="line-modified">314         return Detail::BufferSourceConverter&lt;IDLUint8ClampedArray&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
315     }
316 };
317 
318 template&lt;&gt; struct JSConverter&lt;IDLUint8ClampedArray&gt; {
319     static constexpr bool needsState = true;
320     static constexpr bool needsGlobalObject = true;
321 
322     template &lt;typename U&gt;
<span class="line-modified">323     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
324     {
<span class="line-modified">325         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
326     }
327 };
328 
329 template&lt;&gt; struct Converter&lt;IDLFloat32Array&gt; : DefaultConverter&lt;IDLFloat32Array&gt; {
330     using WrapperType = JSC::JSFloat32Array;
331     using ReturnType = RefPtr&lt;JSC::Float32Array&gt;;
332 
333     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">334     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
335     {
<span class="line-modified">336         return Detail::BufferSourceConverter&lt;IDLFloat32Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
337     }
338 };
339 
340 template&lt;&gt; struct JSConverter&lt;IDLFloat32Array&gt; {
341     static constexpr bool needsState = true;
342     static constexpr bool needsGlobalObject = true;
343 
344     template &lt;typename U&gt;
<span class="line-modified">345     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
346     {
<span class="line-modified">347         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
348     }
349 };
350 
351 template&lt;&gt; struct Converter&lt;IDLFloat64Array&gt; : DefaultConverter&lt;IDLFloat64Array&gt; {
352     using WrapperType = JSC::JSFloat64Array;
353     using ReturnType = RefPtr&lt;JSC::Float64Array&gt;;
354 
355     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">356     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
357     {
<span class="line-modified">358         return Detail::BufferSourceConverter&lt;IDLFloat64Array&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
359     }
360 };
361 
362 template&lt;&gt; struct JSConverter&lt;IDLFloat64Array&gt; {
363     static constexpr bool needsState = true;
364     static constexpr bool needsGlobalObject = true;
365 
366     template &lt;typename U&gt;
<span class="line-modified">367     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
368     {
<span class="line-modified">369         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
370     }
371 };
372 
373 template&lt;&gt; struct Converter&lt;IDLArrayBufferView&gt; : DefaultConverter&lt;IDLArrayBufferView&gt; {
374     using WrapperType = JSC::JSArrayBufferView;
375     using ReturnType = RefPtr&lt;JSC::ArrayBufferView&gt;;
376 
377     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">378     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
379     {
<span class="line-modified">380         return Detail::BufferSourceConverter&lt;IDLArrayBufferView&gt;::convert(state, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
381     }
382 };
383 
384 template&lt;&gt; struct JSConverter&lt;IDLArrayBufferView&gt; {
385     static constexpr bool needsState = true;
386     static constexpr bool needsGlobalObject = true;
387 
388     template &lt;typename U&gt;
<span class="line-modified">389     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
390     {
<span class="line-modified">391         return toJS(&amp;state, &amp;globalObject, Detail::getPtrOrRef(value));</span>
392     }
393 };
394 
395 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 46 inline RefPtr&lt;JSC::Int8Array&gt; toPossiblySharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 47 inline RefPtr&lt;JSC::Int16Array&gt; toPossiblySharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 48 inline RefPtr&lt;JSC::Int32Array&gt; toPossiblySharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 49 inline RefPtr&lt;JSC::Uint8Array&gt; toPossiblySharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 50 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toPossiblySharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 51 inline RefPtr&lt;JSC::Uint16Array&gt; toPossiblySharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 52 inline RefPtr&lt;JSC::Uint32Array&gt; toPossiblySharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 53 inline RefPtr&lt;JSC::Float32Array&gt; toPossiblySharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 54 inline RefPtr&lt;JSC::Float64Array&gt; toPossiblySharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 55 
 56 inline RefPtr&lt;JSC::Int8Array&gt; toUnsharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 57 inline RefPtr&lt;JSC::Int16Array&gt; toUnsharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 58 inline RefPtr&lt;JSC::Int32Array&gt; toUnsharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 59 inline RefPtr&lt;JSC::Uint8Array&gt; toUnsharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 60 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toUnsharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 61 inline RefPtr&lt;JSC::Uint16Array&gt; toUnsharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 62 inline RefPtr&lt;JSC::Uint32Array&gt; toUnsharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 63 inline RefPtr&lt;JSC::Float32Array&gt; toUnsharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 64 inline RefPtr&lt;JSC::Float64Array&gt; toUnsharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 65 
<span class="line-modified"> 66 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer&amp; buffer)</span>
 67 {
 68     if (auto result = getCachedWrapper(globalObject-&gt;world(), buffer))
 69         return result;
 70 
 71     // The JSArrayBuffer::create function will register the wrapper in finishCreation.
<span class="line-modified"> 72     return JSC::JSArrayBuffer::create(JSC::getVM(lexicalGlobalObject), globalObject-&gt;arrayBufferStructure(buffer.sharingMode()), &amp;buffer);</span>
 73 }
 74 
<span class="line-modified"> 75 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView&amp; view)</span>
 76 {
<span class="line-modified"> 77     return view.wrap(lexicalGlobalObject, globalObject);</span>
 78 }
 79 
<span class="line-modified"> 80 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer* buffer)</span>
 81 {
 82     if (!buffer)
 83         return JSC::jsNull();
<span class="line-modified"> 84     return toJS(lexicalGlobalObject, globalObject, *buffer);</span>
 85 }
 86 
<span class="line-modified"> 87 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView* view)</span>
 88 {
 89     if (!view)
 90         return JSC::jsNull();
<span class="line-modified"> 91     return toJS(lexicalGlobalObject, globalObject, *view);</span>
 92 }
 93 
 94 inline RefPtr&lt;JSC::ArrayBufferView&gt; toPossiblySharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
 95 {
 96     auto* wrapper = JSC::jsDynamicCast&lt;JSC::JSArrayBufferView*&gt;(vm, value);
 97     if (!wrapper)
 98         return nullptr;
 99     return wrapper-&gt;possiblySharedImpl();
100 }
101 
102 inline RefPtr&lt;JSC::ArrayBufferView&gt; toUnsharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
103 {
104     auto result = toPossiblySharedArrayBufferView(vm, value);
105     if (!result || result-&gt;isShared())
106         return nullptr;
107     return result;
108 }
109 
110 namespace Detail {
111 
112 template&lt;typename BufferSourceType&gt;
113 struct BufferSourceConverter {
114     using WrapperType = typename Converter&lt;BufferSourceType&gt;::WrapperType;
115     using ReturnType = typename Converter&lt;BufferSourceType&gt;::ReturnType;
116 
117     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">118     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
119     {
<span class="line-modified">120         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
121         auto scope = DECLARE_THROW_SCOPE(vm);
122         ReturnType object = WrapperType::toWrapped(vm, value);
123         if (UNLIKELY(!object))
<span class="line-modified">124             exceptionThrower(lexicalGlobalObject, scope);</span>
125         return object;
126     }
127 };
128 
129 }
130 
131 template&lt;&gt; struct Converter&lt;IDLArrayBuffer&gt; : DefaultConverter&lt;IDLArrayBuffer&gt; {
132     using WrapperType = JSC::JSArrayBuffer;
133     using ReturnType = JSC::ArrayBuffer*;
134 
135     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">136     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
137     {
<span class="line-modified">138         return Detail::BufferSourceConverter&lt;IDLArrayBuffer&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
139     }
140 };
141 
142 template&lt;&gt; struct JSConverter&lt;IDLArrayBuffer&gt; {
143     static constexpr bool needsState = true;
144     static constexpr bool needsGlobalObject = true;
145 
146     template &lt;typename U&gt;
<span class="line-modified">147     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
148     {
<span class="line-modified">149         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
150     }
151 };
152 
153 template&lt;&gt; struct Converter&lt;IDLDataView&gt; : DefaultConverter&lt;IDLDataView&gt; {
154     using WrapperType = JSC::JSDataView;
155     using ReturnType = RefPtr&lt;JSC::DataView&gt;;
156 
157     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">158     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
159     {
<span class="line-modified">160         return Detail::BufferSourceConverter&lt;IDLDataView&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
161     }
162 };
163 
164 template&lt;&gt; struct JSConverter&lt;IDLDataView&gt; {
165     static constexpr bool needsState = true;
166     static constexpr bool needsGlobalObject = true;
167 
168     template &lt;typename U&gt;
<span class="line-modified">169     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
170     {
<span class="line-modified">171         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
172     }
173 };
174 
175 template&lt;&gt; struct Converter&lt;IDLInt8Array&gt; : DefaultConverter&lt;IDLInt8Array&gt; {
176     using WrapperType = JSC::JSInt8Array;
177     using ReturnType = RefPtr&lt;JSC::Int8Array&gt;;
178 
179     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">180     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
181     {
<span class="line-modified">182         return Detail::BufferSourceConverter&lt;IDLInt8Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
183     }
184 };
185 
186 template&lt;&gt; struct JSConverter&lt;IDLInt8Array&gt; {
187     static constexpr bool needsState = true;
188     static constexpr bool needsGlobalObject = true;
189 
190     template &lt;typename U&gt;
<span class="line-modified">191     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
192     {
<span class="line-modified">193         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
194     }
195 };
196 
197 template&lt;&gt; struct Converter&lt;IDLInt16Array&gt; : DefaultConverter&lt;IDLInt16Array&gt; {
198     using WrapperType = JSC::JSInt16Array;
199     using ReturnType = RefPtr&lt;JSC::Int16Array&gt;;
200 
201     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">202     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
203     {
<span class="line-modified">204         return Detail::BufferSourceConverter&lt;IDLInt16Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
205     }
206 };
207 
208 template&lt;&gt; struct JSConverter&lt;IDLInt16Array&gt; {
209     static constexpr bool needsState = true;
210     static constexpr bool needsGlobalObject = true;
211 
212     template &lt;typename U&gt;
<span class="line-modified">213     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
214     {
<span class="line-modified">215         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
216     }
217 };
218 
219 template&lt;&gt; struct Converter&lt;IDLInt32Array&gt; : DefaultConverter&lt;IDLInt32Array&gt; {
220     using WrapperType = JSC::JSInt32Array;
221     using ReturnType = RefPtr&lt;JSC::Int32Array&gt;;
222 
223     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">224     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
225     {
<span class="line-modified">226         return Detail::BufferSourceConverter&lt;IDLInt32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
227     }
228 };
229 
230 template&lt;&gt; struct JSConverter&lt;IDLInt32Array&gt; {
231     static constexpr bool needsState = true;
232     static constexpr bool needsGlobalObject = true;
233 
234     template &lt;typename U&gt;
<span class="line-modified">235     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
236     {
<span class="line-modified">237         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
238     }
239 };
240 
241 template&lt;&gt; struct Converter&lt;IDLUint8Array&gt; : DefaultConverter&lt;IDLUint8Array&gt; {
242     using WrapperType = JSC::JSUint8Array;
243     using ReturnType = RefPtr&lt;JSC::Uint8Array&gt;;
244 
245     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">246     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
247     {
<span class="line-modified">248         return Detail::BufferSourceConverter&lt;IDLUint8Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
249     }
250 };
251 
252 template&lt;&gt; struct JSConverter&lt;IDLUint8Array&gt; {
253     static constexpr bool needsState = true;
254     static constexpr bool needsGlobalObject = true;
255 
256     template &lt;typename U&gt;
<span class="line-modified">257     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
258     {
<span class="line-modified">259         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
260     }
261 };
262 
263 template&lt;&gt; struct Converter&lt;IDLUint16Array&gt; : DefaultConverter&lt;IDLUint16Array&gt; {
264     using WrapperType = JSC::JSUint16Array;
265     using ReturnType = RefPtr&lt;JSC::Uint16Array&gt;;
266 
267     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">268     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
269     {
<span class="line-modified">270         return Detail::BufferSourceConverter&lt;IDLUint16Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
271     }
272 };
273 
274 template&lt;&gt; struct JSConverter&lt;IDLUint16Array&gt; {
275     static constexpr bool needsState = true;
276     static constexpr bool needsGlobalObject = true;
277 
278     template &lt;typename U&gt;
<span class="line-modified">279     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
280     {
<span class="line-modified">281         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
282     }
283 };
284 
285 template&lt;&gt; struct Converter&lt;IDLUint32Array&gt; : DefaultConverter&lt;IDLUint32Array&gt; {
286     using WrapperType = JSC::JSUint32Array;
287     using ReturnType = RefPtr&lt;JSC::Uint32Array&gt;;
288 
289     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">290     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
291     {
<span class="line-modified">292         return Detail::BufferSourceConverter&lt;IDLUint32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
293     }
294 };
295 
296 template&lt;&gt; struct JSConverter&lt;IDLUint32Array&gt; {
297     static constexpr bool needsState = true;
298     static constexpr bool needsGlobalObject = true;
299 
300     template &lt;typename U&gt;
<span class="line-modified">301     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
302     {
<span class="line-modified">303         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
304     }
305 };
306 
307 template&lt;&gt; struct Converter&lt;IDLUint8ClampedArray&gt; : DefaultConverter&lt;IDLUint8ClampedArray&gt; {
308     using WrapperType = JSC::JSUint8ClampedArray;
309     using ReturnType = RefPtr&lt;JSC::Uint8ClampedArray&gt;;
310 
311     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">312     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
313     {
<span class="line-modified">314         return Detail::BufferSourceConverter&lt;IDLUint8ClampedArray&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
315     }
316 };
317 
318 template&lt;&gt; struct JSConverter&lt;IDLUint8ClampedArray&gt; {
319     static constexpr bool needsState = true;
320     static constexpr bool needsGlobalObject = true;
321 
322     template &lt;typename U&gt;
<span class="line-modified">323     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
324     {
<span class="line-modified">325         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
326     }
327 };
328 
329 template&lt;&gt; struct Converter&lt;IDLFloat32Array&gt; : DefaultConverter&lt;IDLFloat32Array&gt; {
330     using WrapperType = JSC::JSFloat32Array;
331     using ReturnType = RefPtr&lt;JSC::Float32Array&gt;;
332 
333     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">334     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
335     {
<span class="line-modified">336         return Detail::BufferSourceConverter&lt;IDLFloat32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
337     }
338 };
339 
340 template&lt;&gt; struct JSConverter&lt;IDLFloat32Array&gt; {
341     static constexpr bool needsState = true;
342     static constexpr bool needsGlobalObject = true;
343 
344     template &lt;typename U&gt;
<span class="line-modified">345     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
346     {
<span class="line-modified">347         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
348     }
349 };
350 
351 template&lt;&gt; struct Converter&lt;IDLFloat64Array&gt; : DefaultConverter&lt;IDLFloat64Array&gt; {
352     using WrapperType = JSC::JSFloat64Array;
353     using ReturnType = RefPtr&lt;JSC::Float64Array&gt;;
354 
355     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">356     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
357     {
<span class="line-modified">358         return Detail::BufferSourceConverter&lt;IDLFloat64Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
359     }
360 };
361 
362 template&lt;&gt; struct JSConverter&lt;IDLFloat64Array&gt; {
363     static constexpr bool needsState = true;
364     static constexpr bool needsGlobalObject = true;
365 
366     template &lt;typename U&gt;
<span class="line-modified">367     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
368     {
<span class="line-modified">369         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
370     }
371 };
372 
373 template&lt;&gt; struct Converter&lt;IDLArrayBufferView&gt; : DefaultConverter&lt;IDLArrayBufferView&gt; {
374     using WrapperType = JSC::JSArrayBufferView;
375     using ReturnType = RefPtr&lt;JSC::ArrayBufferView&gt;;
376 
377     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<span class="line-modified">378     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
379     {
<span class="line-modified">380         return Detail::BufferSourceConverter&lt;IDLArrayBufferView&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
381     }
382 };
383 
384 template&lt;&gt; struct JSConverter&lt;IDLArrayBufferView&gt; {
385     static constexpr bool needsState = true;
386     static constexpr bool needsGlobalObject = true;
387 
388     template &lt;typename U&gt;
<span class="line-modified">389     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
390     {
<span class="line-modified">391         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
392     }
393 };
394 
395 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMConvertBoolean.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertCallbacks.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
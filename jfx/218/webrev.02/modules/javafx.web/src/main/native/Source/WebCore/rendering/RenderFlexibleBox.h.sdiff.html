<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFlexibleBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderFlexibleBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentContainer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFlexibleBox.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 75     void clearCachedMainSizeForChild(const RenderBox&amp; child);
 76 
 77     LayoutUnit cachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child) const;
 78     void setCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child, LayoutUnit);
 79     void clearCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child);
 80 
 81     LayoutUnit staticMainAxisPositionForPositionedChild(const RenderBox&amp;);
 82     LayoutUnit staticCrossAxisPositionForPositionedChild(const RenderBox&amp;);
 83 
 84     LayoutUnit staticInlinePositionForPositionedChild(const RenderBox&amp;);
 85     LayoutUnit staticBlockPositionForPositionedChild(const RenderBox&amp;);
 86 
 87     // Returns true if the position changed. In that case, the child will have to
 88     // be laid out again.
 89     bool setStaticPositionForPositionedLayout(const RenderBox&amp;);
 90 
 91 protected:
 92     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
 93     void computePreferredLogicalWidths() override;
 94 


 95 private:
 96     enum FlexSign {
 97         PositiveFlexibility,
 98         NegativeFlexibility,
 99     };
100 
101     enum ChildLayoutType { LayoutIfNeeded, ForceLayout, NeverLayout };
102 
103     enum class SizeDefiniteness { Definite, Indefinite, Unknown };
104 
105     // Use an inline capacity of 8, since flexbox containers usually have less than 8 children.
106     typedef Vector&lt;LayoutRect, 8&gt; ChildFrameRects;
107 
108     struct LineContext;
109 
110     bool hasOrthogonalFlow(const RenderBox&amp; child) const;
111     bool isColumnFlow() const;
112     bool isLeftToRightFlow() const;
113     bool isMultiline() const;
114     Length flexBasisForChild(const RenderBox&amp; child) const;
</pre>
<hr />
<pre>
171     FlexItem constructFlexItem(RenderBox&amp;, bool relayoutChildren);
172 
173     void freezeInflexibleItems(FlexSign, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
174     bool resolveFlexibleLengths(FlexSign, Vector&lt;FlexItem&gt;&amp;, LayoutUnit initialFreeSpace, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
175     void freezeViolations(Vector&lt;FlexItem*&gt;&amp;, LayoutUnit&amp; availableFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
176 
177     void resetAutoMarginsAndLogicalTopInCrossAxis(RenderBox&amp; child);
178     void setOverrideMainAxisContentSizeForChild(RenderBox&amp; child, LayoutUnit childPreferredSize);
179     void prepareChildForPositionedLayout(RenderBox&amp; child);
180     void layoutAndPlaceChildren(LayoutUnit&amp; crossAxisOffset, Vector&lt;FlexItem&gt;&amp;, LayoutUnit availableFreeSpace, bool relayoutChildren, Vector&lt;LineContext&gt;&amp;);
181     void layoutColumnReverse(const Vector&lt;FlexItem&gt;&amp;, LayoutUnit crossAxisOffset, LayoutUnit availableFreeSpace);
182     void alignFlexLines(Vector&lt;LineContext&gt;&amp;);
183     void alignChildren(const Vector&lt;LineContext&gt;&amp;);
184     void applyStretchAlignmentToChild(RenderBox&amp; child, LayoutUnit lineCrossAxisExtent);
185     void flipForRightToLeftColumn(const Vector&lt;LineContext&gt;&amp; lineContexts);
186     void flipForWrapReverse(const Vector&lt;LineContext&gt;&amp;, LayoutUnit crossAxisStartEdge);
187 
188     void appendChildFrameRects(ChildFrameRects&amp;);
189     void repaintChildrenDuringLayoutIfMoved(const ChildFrameRects&amp;);
190 


191     // This is used to cache the preferred size for orthogonal flow children so we
192     // don&#39;t have to relayout to get it
193     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicSizeAlongMainAxis;
194 
195     // This is used to cache the intrinsic size on the cross axis to avoid
196     // relayouts when stretching.
197     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicContentLogicalHeights;
198 
199     // This set is used to keep track of which children we laid out in this
200     // current layout iteration. We need it because the ones in this set may
201     // need an additional layout pass for correct stretch alignment handling, as
202     // the first layout likely did not use the correct value for percentage
203     // sizing of children.
204     HashSet&lt;const RenderBox*&gt; m_relaidOutChildren;
205 
206     mutable OrderIterator m_orderIterator { *this };
207     int m_numberOfInFlowChildrenOnFirstLine { -1 };
208 
209     // This is SizeIsUnknown outside of layoutBlock()
210     mutable SizeDefiniteness m_hasDefiniteHeight { SizeDefiniteness::Unknown };
211     bool m_inLayout { false };

212 };
213 
214 } // namespace WebCore
215 
216 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFlexibleBox, isFlexibleBox())
</pre>
</td>
<td>
<hr />
<pre>
 75     void clearCachedMainSizeForChild(const RenderBox&amp; child);
 76 
 77     LayoutUnit cachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child) const;
 78     void setCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child, LayoutUnit);
 79     void clearCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child);
 80 
 81     LayoutUnit staticMainAxisPositionForPositionedChild(const RenderBox&amp;);
 82     LayoutUnit staticCrossAxisPositionForPositionedChild(const RenderBox&amp;);
 83 
 84     LayoutUnit staticInlinePositionForPositionedChild(const RenderBox&amp;);
 85     LayoutUnit staticBlockPositionForPositionedChild(const RenderBox&amp;);
 86 
 87     // Returns true if the position changed. In that case, the child will have to
 88     // be laid out again.
 89     bool setStaticPositionForPositionedLayout(const RenderBox&amp;);
 90 
 91 protected:
 92     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
 93     void computePreferredLogicalWidths() override;
 94 
<span class="line-added"> 95     bool shouldResetChildLogicalHeightBeforeLayout(const RenderBox&amp;) const override { return m_shouldResetChildLogicalHeightBeforeLayout; }</span>
<span class="line-added"> 96 </span>
 97 private:
 98     enum FlexSign {
 99         PositiveFlexibility,
100         NegativeFlexibility,
101     };
102 
103     enum ChildLayoutType { LayoutIfNeeded, ForceLayout, NeverLayout };
104 
105     enum class SizeDefiniteness { Definite, Indefinite, Unknown };
106 
107     // Use an inline capacity of 8, since flexbox containers usually have less than 8 children.
108     typedef Vector&lt;LayoutRect, 8&gt; ChildFrameRects;
109 
110     struct LineContext;
111 
112     bool hasOrthogonalFlow(const RenderBox&amp; child) const;
113     bool isColumnFlow() const;
114     bool isLeftToRightFlow() const;
115     bool isMultiline() const;
116     Length flexBasisForChild(const RenderBox&amp; child) const;
</pre>
<hr />
<pre>
173     FlexItem constructFlexItem(RenderBox&amp;, bool relayoutChildren);
174 
175     void freezeInflexibleItems(FlexSign, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
176     bool resolveFlexibleLengths(FlexSign, Vector&lt;FlexItem&gt;&amp;, LayoutUnit initialFreeSpace, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
177     void freezeViolations(Vector&lt;FlexItem*&gt;&amp;, LayoutUnit&amp; availableFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
178 
179     void resetAutoMarginsAndLogicalTopInCrossAxis(RenderBox&amp; child);
180     void setOverrideMainAxisContentSizeForChild(RenderBox&amp; child, LayoutUnit childPreferredSize);
181     void prepareChildForPositionedLayout(RenderBox&amp; child);
182     void layoutAndPlaceChildren(LayoutUnit&amp; crossAxisOffset, Vector&lt;FlexItem&gt;&amp;, LayoutUnit availableFreeSpace, bool relayoutChildren, Vector&lt;LineContext&gt;&amp;);
183     void layoutColumnReverse(const Vector&lt;FlexItem&gt;&amp;, LayoutUnit crossAxisOffset, LayoutUnit availableFreeSpace);
184     void alignFlexLines(Vector&lt;LineContext&gt;&amp;);
185     void alignChildren(const Vector&lt;LineContext&gt;&amp;);
186     void applyStretchAlignmentToChild(RenderBox&amp; child, LayoutUnit lineCrossAxisExtent);
187     void flipForRightToLeftColumn(const Vector&lt;LineContext&gt;&amp; lineContexts);
188     void flipForWrapReverse(const Vector&lt;LineContext&gt;&amp;, LayoutUnit crossAxisStartEdge);
189 
190     void appendChildFrameRects(ChildFrameRects&amp;);
191     void repaintChildrenDuringLayoutIfMoved(const ChildFrameRects&amp;);
192 
<span class="line-added">193     bool hasPercentHeightDescendants(const RenderBox&amp;) const;</span>
<span class="line-added">194 </span>
195     // This is used to cache the preferred size for orthogonal flow children so we
196     // don&#39;t have to relayout to get it
197     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicSizeAlongMainAxis;
198 
199     // This is used to cache the intrinsic size on the cross axis to avoid
200     // relayouts when stretching.
201     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicContentLogicalHeights;
202 
203     // This set is used to keep track of which children we laid out in this
204     // current layout iteration. We need it because the ones in this set may
205     // need an additional layout pass for correct stretch alignment handling, as
206     // the first layout likely did not use the correct value for percentage
207     // sizing of children.
208     HashSet&lt;const RenderBox*&gt; m_relaidOutChildren;
209 
210     mutable OrderIterator m_orderIterator { *this };
211     int m_numberOfInFlowChildrenOnFirstLine { -1 };
212 
213     // This is SizeIsUnknown outside of layoutBlock()
214     mutable SizeDefiniteness m_hasDefiniteHeight { SizeDefiniteness::Unknown };
215     bool m_inLayout { false };
<span class="line-added">216     bool m_shouldResetChildLogicalHeightBeforeLayout { false };</span>
217 };
218 
219 } // namespace WebCore
220 
221 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFlexibleBox, isFlexibleBox())
</pre>
</td>
</tr>
</table>
<center><a href="RenderFlexibleBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentContainer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
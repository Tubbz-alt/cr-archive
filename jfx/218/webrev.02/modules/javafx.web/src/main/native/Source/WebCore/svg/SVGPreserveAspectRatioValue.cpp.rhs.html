<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/svg/SVGPreserveAspectRatioValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2010 Dirk Schulze &lt;krit@webkit.org&gt;
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;SVGPreserveAspectRatioValue.h&quot;
 24 
 25 #include &quot;AffineTransform.h&quot;
 26 #include &quot;FloatRect.h&quot;
 27 #include &quot;SVGParserUtilities.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 28 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;</span>
 29 #include &lt;wtf/text/StringView.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 SVGPreserveAspectRatioValue::SVGPreserveAspectRatioValue()
 34     : m_align(SVG_PRESERVEASPECTRATIO_XMIDYMID)
 35     , m_meetOrSlice(SVG_MEETORSLICE_MEET)
 36 {
 37 }
 38 
 39 SVGPreserveAspectRatioValue::SVGPreserveAspectRatioValue(const String&amp; value)
 40 {
 41     parse(value);
 42 }
 43 
 44 ExceptionOr&lt;void&gt; SVGPreserveAspectRatioValue::setAlign(unsigned short align)
 45 {
 46     if (align == SVG_PRESERVEASPECTRATIO_UNKNOWN || align &gt; SVG_PRESERVEASPECTRATIO_XMAXYMAX)
 47         return Exception { NotSupportedError };
 48 
 49     m_align = static_cast&lt;SVGPreserveAspectRatioType&gt;(align);
 50     return { };
 51 }
 52 
 53 ExceptionOr&lt;void&gt; SVGPreserveAspectRatioValue::setMeetOrSlice(unsigned short meetOrSlice)
 54 {
 55     if (meetOrSlice == SVG_MEETORSLICE_UNKNOWN || meetOrSlice &gt; SVG_MEETORSLICE_SLICE)
 56         return Exception { NotSupportedError };
 57 
 58     m_meetOrSlice = static_cast&lt;SVGMeetOrSliceType&gt;(meetOrSlice);
 59     return { };
 60 }
 61 
 62 void SVGPreserveAspectRatioValue::parse(const String&amp; value)
 63 {
 64     auto upconvertedCharacters = StringView(value).upconvertedCharacters();
 65     const UChar* begin = upconvertedCharacters;
 66     parseInternal(begin, begin + value.length(), true);
 67 }
 68 
 69 bool SVGPreserveAspectRatioValue::parse(const UChar*&amp; currParam, const UChar* end, bool validate)
 70 {
 71     return parseInternal(currParam, end, validate);
 72 }
 73 
 74 bool SVGPreserveAspectRatioValue::parseInternal(const UChar*&amp; currParam, const UChar* end, bool validate)
 75 {
 76     SVGPreserveAspectRatioType align = SVG_PRESERVEASPECTRATIO_XMIDYMID;
 77     SVGMeetOrSliceType meetOrSlice = SVG_MEETORSLICE_MEET;
 78 
 79     m_align = align;
 80     m_meetOrSlice = meetOrSlice;
 81 
 82     if (!skipOptionalSVGSpaces(currParam, end))
 83         return false;
 84 
 85     if (*currParam == &#39;d&#39;) {
 86         if (!skipString(currParam, end, &quot;defer&quot;)) {
 87             LOG_ERROR(&quot;Skipped to parse except for *defer* value.&quot;);
 88             return false;
 89         }
 90 
 91         // FIXME: We just ignore the &quot;defer&quot; here.
 92         if (currParam == end)
 93             return true;
 94 
 95         if (!skipOptionalSVGSpaces(currParam, end))
 96             return false;
 97     }
 98 
 99     if (*currParam == &#39;n&#39;) {
100         if (!skipString(currParam, end, &quot;none&quot;)) {
101             LOG_ERROR(&quot;Skipped to parse except for *none* value.&quot;);
102             return false;
103         }
104         align = SVG_PRESERVEASPECTRATIO_NONE;
105         skipOptionalSVGSpaces(currParam, end);
106     } else if (*currParam == &#39;x&#39;) {
107         if ((end - currParam) &lt; 8)
108             return false;
109         if (currParam[1] != &#39;M&#39; || currParam[4] != &#39;Y&#39; || currParam[5] != &#39;M&#39;)
110             return false;
111         if (currParam[2] == &#39;i&#39;) {
112             if (currParam[3] == &#39;n&#39;) {
113                 if (currParam[6] == &#39;i&#39;) {
114                     if (currParam[7] == &#39;n&#39;)
115                         align = SVG_PRESERVEASPECTRATIO_XMINYMIN;
116                     else if (currParam[7] == &#39;d&#39;)
117                         align = SVG_PRESERVEASPECTRATIO_XMINYMID;
118                     else
119                         return false;
120                 } else if (currParam[6] == &#39;a&#39; &amp;&amp; currParam[7] == &#39;x&#39;)
121                     align = SVG_PRESERVEASPECTRATIO_XMINYMAX;
122                 else
123                     return false;
124              } else if (currParam[3] == &#39;d&#39;) {
125                 if (currParam[6] == &#39;i&#39;) {
126                     if (currParam[7] == &#39;n&#39;)
127                         align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;
128                     else if (currParam[7] == &#39;d&#39;)
129                         align = SVG_PRESERVEASPECTRATIO_XMIDYMID;
130                     else
131                         return false;
132                 } else if (currParam[6] == &#39;a&#39; &amp;&amp; currParam[7] == &#39;x&#39;)
133                     align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;
134                 else
135                     return false;
136             } else
137                 return false;
138         } else if (currParam[2] == &#39;a&#39; &amp;&amp; currParam[3] == &#39;x&#39;) {
139             if (currParam[6] == &#39;i&#39;) {
140                 if (currParam[7] == &#39;n&#39;)
141                     align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;
142                 else if (currParam[7] == &#39;d&#39;)
143                     align = SVG_PRESERVEASPECTRATIO_XMAXYMID;
144                 else
145                     return false;
146             } else if (currParam[6] == &#39;a&#39; &amp;&amp; currParam[7] == &#39;x&#39;)
147                 align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;
148             else
149                 return false;
150         } else
151             return false;
152         currParam += 8;
153         skipOptionalSVGSpaces(currParam, end);
154     } else
155         return false;
156 
157     if (currParam &lt; end) {
158         if (*currParam == &#39;m&#39;) {
159             if (!skipString(currParam, end, &quot;meet&quot;)) {
160                 LOG_ERROR(&quot;Skipped to parse except for *meet* or *slice* value.&quot;);
161                 return false;
162             }
163             skipOptionalSVGSpaces(currParam, end);
164         } else if (*currParam == &#39;s&#39;) {
165             if (!skipString(currParam, end, &quot;slice&quot;)) {
166                 LOG_ERROR(&quot;Skipped to parse except for *meet* or *slice* value.&quot;);
167                 return false;
168             }
169             skipOptionalSVGSpaces(currParam, end);
170             if (align != SVG_PRESERVEASPECTRATIO_NONE)
171                 meetOrSlice = SVG_MEETORSLICE_SLICE;
172         }
173     }
174 
175     if (end != currParam &amp;&amp; validate)
176         return false;
177 
178     m_align = align;
179     m_meetOrSlice = meetOrSlice;
180 
181     return true;
182 }
183 
184 void SVGPreserveAspectRatioValue::transformRect(FloatRect&amp; destRect, FloatRect&amp; srcRect) const
185 {
186     if (m_align == SVG_PRESERVEASPECTRATIO_NONE)
187         return;
188 
189     FloatSize imageSize = srcRect.size();
190     float origDestWidth = destRect.width();
191     float origDestHeight = destRect.height();
192     switch (m_meetOrSlice) {
193     case SVGPreserveAspectRatioValue::SVG_MEETORSLICE_UNKNOWN:
194         break;
195     case SVGPreserveAspectRatioValue::SVG_MEETORSLICE_MEET: {
196         float widthToHeightMultiplier = srcRect.height() / srcRect.width();
197         if (origDestHeight &gt; origDestWidth * widthToHeightMultiplier) {
198             destRect.setHeight(origDestWidth * widthToHeightMultiplier);
199             switch (m_align) {
200             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMID:
201             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
202             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
203                 destRect.setY(destRect.y() + origDestHeight / 2 - destRect.height() / 2);
204                 break;
205             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMAX:
206             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
207             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
208                 destRect.setY(destRect.y() + origDestHeight - destRect.height());
209                 break;
210             default:
211                 break;
212             }
213         }
214         if (origDestWidth &gt; origDestHeight / widthToHeightMultiplier) {
215             destRect.setWidth(origDestHeight / widthToHeightMultiplier);
216             switch (m_align) {
217             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
218             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
219             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
220                 destRect.setX(destRect.x() + origDestWidth / 2 - destRect.width() / 2);
221                 break;
222             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
223             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
224             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
225                 destRect.setX(destRect.x() + origDestWidth - destRect.width());
226                 break;
227             default:
228                 break;
229             }
230         }
231         break;
232     }
233     case SVGPreserveAspectRatioValue::SVG_MEETORSLICE_SLICE: {
234         float widthToHeightMultiplier = srcRect.height() / srcRect.width();
235         // if the destination height is less than the height of the image we&#39;ll be drawing
236         if (origDestHeight &lt; origDestWidth * widthToHeightMultiplier) {
237             float destToSrcMultiplier = srcRect.width() / destRect.width();
238             srcRect.setHeight(destRect.height() * destToSrcMultiplier);
239             switch (m_align) {
240             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMID:
241             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
242             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
243                 srcRect.setY(srcRect.y() + imageSize.height() / 2 - srcRect.height() / 2);
244                 break;
245             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMAX:
246             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
247             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
248                 srcRect.setY(srcRect.y() + imageSize.height() - srcRect.height());
249                 break;
250             default:
251                 break;
252             }
253         }
254         // if the destination width is less than the width of the image we&#39;ll be drawing
255         if (origDestWidth &lt; origDestHeight / widthToHeightMultiplier) {
256             float destToSrcMultiplier = srcRect.height() / destRect.height();
257             srcRect.setWidth(destRect.width() * destToSrcMultiplier);
258             switch (m_align) {
259             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
260             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
261             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
262                 srcRect.setX(srcRect.x() + imageSize.width() / 2 - srcRect.width() / 2);
263                 break;
264             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
265             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
266             case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
267                 srcRect.setX(srcRect.x() + imageSize.width() - srcRect.width());
268                 break;
269             default:
270                 break;
271             }
272         }
273         break;
274     }
275     }
276 }
277 
278 AffineTransform SVGPreserveAspectRatioValue::getCTM(float logicalX, float logicalY, float logicalWidth, float logicalHeight, float physicalWidth, float physicalHeight) const
279 {
280     AffineTransform transform;
281     if (!logicalWidth || !logicalHeight || !physicalWidth || !physicalHeight) {
282         ASSERT_NOT_REACHED();
283         return transform;
284     }
285 
286     if (m_align == SVG_PRESERVEASPECTRATIO_UNKNOWN)
287         return transform;
288 
289     double extendedLogicalX = logicalX;
290     double extendedLogicalY = logicalY;
291     double extendedLogicalWidth = logicalWidth;
292     double extendedLogicalHeight = logicalHeight;
293     double extendedPhysicalWidth = physicalWidth;
294     double extendedPhysicalHeight = physicalHeight;
295     double logicalRatio = extendedLogicalWidth / extendedLogicalHeight;
296     double physicalRatio = extendedPhysicalWidth / extendedPhysicalHeight;
297 
298     if (m_align == SVG_PRESERVEASPECTRATIO_NONE) {
299         transform.scaleNonUniform(extendedPhysicalWidth / extendedLogicalWidth, extendedPhysicalHeight / extendedLogicalHeight);
300         transform.translate(-extendedLogicalX, -extendedLogicalY);
301         return transform;
302     }
303 
304     if ((logicalRatio &lt; physicalRatio &amp;&amp; (m_meetOrSlice == SVG_MEETORSLICE_MEET)) || (logicalRatio &gt;= physicalRatio &amp;&amp; (m_meetOrSlice == SVG_MEETORSLICE_SLICE))) {
305         transform.scaleNonUniform(extendedPhysicalHeight / extendedLogicalHeight, extendedPhysicalHeight / extendedLogicalHeight);
306 
307         if (m_align == SVG_PRESERVEASPECTRATIO_XMINYMIN || m_align == SVG_PRESERVEASPECTRATIO_XMINYMID || m_align == SVG_PRESERVEASPECTRATIO_XMINYMAX)
308             transform.translate(-extendedLogicalX, -extendedLogicalY);
309         else if (m_align == SVG_PRESERVEASPECTRATIO_XMIDYMIN || m_align == SVG_PRESERVEASPECTRATIO_XMIDYMID || m_align == SVG_PRESERVEASPECTRATIO_XMIDYMAX)
310             transform.translate(-extendedLogicalX - (extendedLogicalWidth - extendedPhysicalWidth * extendedLogicalHeight / extendedPhysicalHeight) / 2, -extendedLogicalY);
311         else
312             transform.translate(-extendedLogicalX - (extendedLogicalWidth - extendedPhysicalWidth * extendedLogicalHeight / extendedPhysicalHeight), -extendedLogicalY);
313 
314         return transform;
315     }
316 
317     transform.scaleNonUniform(extendedPhysicalWidth / extendedLogicalWidth, extendedPhysicalWidth / extendedLogicalWidth);
318 
319     if (m_align == SVG_PRESERVEASPECTRATIO_XMINYMIN || m_align == SVG_PRESERVEASPECTRATIO_XMIDYMIN || m_align == SVG_PRESERVEASPECTRATIO_XMAXYMIN)
320         transform.translate(-extendedLogicalX, -extendedLogicalY);
321     else if (m_align == SVG_PRESERVEASPECTRATIO_XMINYMID || m_align == SVG_PRESERVEASPECTRATIO_XMIDYMID || m_align == SVG_PRESERVEASPECTRATIO_XMAXYMID)
322         transform.translate(-extendedLogicalX, -extendedLogicalY - (extendedLogicalHeight - extendedPhysicalHeight * extendedLogicalWidth / extendedPhysicalWidth) / 2);
323     else
324         transform.translate(-extendedLogicalX, -extendedLogicalY - (extendedLogicalHeight - extendedPhysicalHeight * extendedLogicalWidth / extendedPhysicalWidth));
325 
326     return transform;
327 }
328 
329 String SVGPreserveAspectRatioValue::valueAsString() const
330 {
331     String alignType;
332 
333     switch (m_align) {
334     case SVG_PRESERVEASPECTRATIO_NONE:
335         alignType = &quot;none&quot;;
336         break;
337     case SVG_PRESERVEASPECTRATIO_XMINYMIN:
338         alignType = &quot;xMinYMin&quot;;
339         break;
340     case SVG_PRESERVEASPECTRATIO_XMIDYMIN:
341         alignType = &quot;xMidYMin&quot;;
342         break;
343     case SVG_PRESERVEASPECTRATIO_XMAXYMIN:
344         alignType = &quot;xMaxYMin&quot;;
345         break;
346     case SVG_PRESERVEASPECTRATIO_XMINYMID:
347         alignType = &quot;xMinYMid&quot;;
348         break;
349     case SVG_PRESERVEASPECTRATIO_XMIDYMID:
350         alignType = &quot;xMidYMid&quot;;
351         break;
352     case SVG_PRESERVEASPECTRATIO_XMAXYMID:
353         alignType = &quot;xMaxYMid&quot;;
354         break;
355     case SVG_PRESERVEASPECTRATIO_XMINYMAX:
356         alignType = &quot;xMinYMax&quot;;
357         break;
358     case SVG_PRESERVEASPECTRATIO_XMIDYMAX:
359         alignType = &quot;xMidYMax&quot;;
360         break;
361     case SVG_PRESERVEASPECTRATIO_XMAXYMAX:
362         alignType = &quot;xMaxYMax&quot;;
363         break;
364     case SVG_PRESERVEASPECTRATIO_UNKNOWN:
365         alignType = &quot;unknown&quot;;
366         break;
367     };
368 
369     switch (m_meetOrSlice) {
370     default:
371     case SVG_MEETORSLICE_UNKNOWN:
372         return alignType;
373     case SVG_MEETORSLICE_MEET:
374         return alignType + &quot; meet&quot;;
375     case SVG_MEETORSLICE_SLICE:
376         return alignType + &quot; slice&quot;;
377     }
378 }
379 
380 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
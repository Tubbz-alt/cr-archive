<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallFrame.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameInlines.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,9 +1,9 @@</span>
  /*
   *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="udiff-line-modified-removed">-  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,44 +27,46 @@</span>
  #include &quot;MacroAssemblerCodeRef.h&quot;
  #include &quot;Register.h&quot;
  #include &quot;StackVisitor.h&quot;
  #include &quot;VM.h&quot;
  #include &quot;VMEntryRecord.h&quot;
<span class="udiff-line-added">+ #include &lt;wtf/EnumClassOperatorOverloads.h&gt;</span>
  
  namespace JSC  {
  
      class Arguments;
<span class="udiff-line-modified-removed">-     class ExecState;</span>
<span class="udiff-line-modified-added">+     class CallFrame;</span>
      class Interpreter;
      class JSCallee;
      class JSScope;
      class SourceOrigin;
  
      struct Instruction;
  
<span class="udiff-line-removed">-     typedef ExecState CallFrame;</span>
<span class="udiff-line-removed">- </span>
      class CallSiteIndex {
      public:
          CallSiteIndex() = default;
  
<span class="udiff-line-added">+         explicit CallSiteIndex(BytecodeIndex bytecodeIndex)</span>
<span class="udiff-line-added">+             : m_bits(bytecodeIndex.offset())</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             ASSERT(!bytecodeIndex.checkpoint());</span>
<span class="udiff-line-added">+         }</span>
          explicit CallSiteIndex(uint32_t bits)
              : m_bits(bits)
          { }
<span class="udiff-line-removed">- #if USE(JSVALUE32_64)</span>
<span class="udiff-line-removed">-         explicit CallSiteIndex(const Instruction* instruction)</span>
<span class="udiff-line-removed">-             : m_bits(bitwise_cast&lt;uint32_t&gt;(instruction))</span>
<span class="udiff-line-removed">-         { }</span>
<span class="udiff-line-removed">- #endif</span>
  
<span class="udiff-line-modified-removed">-         explicit operator bool() const { return m_bits != UINT_MAX; }</span>
<span class="udiff-line-modified-added">+         explicit operator bool() const { return !!m_bits; }</span>
          bool operator==(const CallSiteIndex&amp; other) const { return m_bits == other.m_bits; }
  
<span class="udiff-line-modified-removed">-         inline uint32_t bits() const { return m_bits; }</span>
<span class="udiff-line-modified-added">+         uint32_t bits() const { return m_bits; }</span>
<span class="udiff-line-added">+         static CallSiteIndex fromBits(uint32_t bits) { return CallSiteIndex(bits); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         BytecodeIndex bytecodeIndex() const { return BytecodeIndex(bits()); }</span>
  
      private:
<span class="udiff-line-modified-removed">-         uint32_t m_bits { UINT_MAX };</span>
<span class="udiff-line-modified-added">+         uint32_t m_bits { BytecodeIndex().offset() };</span>
      };
  
      class DisposableCallSiteIndex : public CallSiteIndex {
      public:
          DisposableCallSiteIndex() = default;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81,70 +83,57 @@</span>
      };
  
      // arm64_32 expects caller frame and return pc to use 8 bytes
      struct CallerFrameAndPC {
          alignas(CPURegister) CallFrame* callerFrame;
<span class="udiff-line-modified-removed">-         alignas(CPURegister) const Instruction* returnPC;</span>
<span class="udiff-line-modified-removed">-         static const int sizeInRegisters = 2 * sizeof(CPURegister) / sizeof(Register);</span>
<span class="udiff-line-modified-added">+         alignas(CPURegister) void* returnPC;</span>
<span class="udiff-line-modified-added">+         static constexpr int sizeInRegisters = 2 * sizeof(CPURegister) / sizeof(Register);</span>
      };
      static_assert(CallerFrameAndPC::sizeInRegisters == sizeof(CallerFrameAndPC) / sizeof(Register), &quot;CallerFrameAndPC::sizeInRegisters is incorrect.&quot;);
  
<span class="udiff-line-modified-removed">-     struct CallFrameSlot {</span>
<span class="udiff-line-modified-removed">-         static const int codeBlock = CallerFrameAndPC::sizeInRegisters;</span>
<span class="udiff-line-modified-removed">-         static const int callee = codeBlock + 1;</span>
<span class="udiff-line-modified-removed">-         static const int argumentCount = callee + 1;</span>
<span class="udiff-line-modified-removed">-         static const int thisArgument = argumentCount + 1;</span>
<span class="udiff-line-modified-removed">-         static const int firstArgument = thisArgument + 1;</span>
<span class="udiff-line-modified-added">+     enum class CallFrameSlot : int {</span>
<span class="udiff-line-modified-added">+         codeBlock = CallerFrameAndPC::sizeInRegisters,</span>
<span class="udiff-line-modified-added">+         callee = codeBlock + 1,</span>
<span class="udiff-line-modified-added">+         argumentCountIncludingThis = callee + 1,</span>
<span class="udiff-line-modified-added">+         thisArgument = argumentCountIncludingThis + 1,</span>
<span class="udiff-line-modified-added">+         firstArgument = thisArgument + 1,</span>
      };
  
<span class="udiff-line-added">+     OVERLOAD_MATH_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)</span>
<span class="udiff-line-added">+     OVERLOAD_RELATIONAL_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)</span>
<span class="udiff-line-added">+ </span>
      // Represents the current state of script execution.
      // Passed as the first argument to most functions.
<span class="udiff-line-modified-removed">-     class ExecState : private Register {</span>
<span class="udiff-line-modified-added">+     class CallFrame : private Register {</span>
      public:
<span class="udiff-line-modified-removed">-         static const int headerSizeInRegisters = CallFrameSlot::argumentCount + 1;</span>
<span class="udiff-line-modified-added">+         static constexpr int headerSizeInRegisters = static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis) + 1;</span>
  
          // This function should only be called in very specific circumstances
          // when you&#39;ve guaranteed the callee can&#39;t be a Wasm callee, and can
          // be an arbitrary JSValue. This function should basically never be used.
          // Its only use right now is when we are making a call, and we&#39;re not
          // yet sure if the callee is a cell. In general, a JS callee is guaranteed
          // to be a cell, however, there is a brief window where we need to check
          // to see if it&#39;s a cell, and if it&#39;s not, we throw an exception.
<span class="udiff-line-modified-removed">-         JSValue guaranteedJSValueCallee() const</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-             ASSERT(!callee().isWasm());</span>
<span class="udiff-line-modified-removed">-             return this[CallFrameSlot::callee].jsValue();</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         JSObject* jsCallee() const</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-             ASSERT(!callee().isWasm());</span>
<span class="udiff-line-removed">-             return this[CallFrameSlot::callee].object();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         CalleeBits callee() const { return CalleeBits(this[CallFrameSlot::callee].pointer()); }</span>
<span class="udiff-line-removed">-         SUPPRESS_ASAN CalleeBits unsafeCallee() const { return CalleeBits(this[CallFrameSlot::callee].asanUnsafePointer()); }</span>
<span class="udiff-line-removed">-         CodeBlock* codeBlock() const { return this[CallFrameSlot::codeBlock].Register::codeBlock(); }</span>
<span class="udiff-line-removed">-         CodeBlock** addressOfCodeBlock() const { return bitwise_cast&lt;CodeBlock**&gt;(this + CallFrameSlot::codeBlock); }</span>
<span class="udiff-line-removed">-         SUPPRESS_ASAN CodeBlock* unsafeCodeBlock() const { return this[CallFrameSlot::codeBlock].Register::asanUnsafeCodeBlock(); }</span>
<span class="udiff-line-removed">-         JSScope* scope(int scopeRegisterOffset) const</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             ASSERT(this[scopeRegisterOffset].Register::scope());</span>
<span class="udiff-line-removed">-             return this[scopeRegisterOffset].Register::scope();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         JSGlobalObject* wasmAwareLexicalGlobalObject(VM&amp;);</span>
<span class="udiff-line-modified-added">+         inline JSValue guaranteedJSValueCallee() const;</span>
<span class="udiff-line-modified-added">+         inline JSObject* jsCallee() const;</span>
<span class="udiff-line-modified-added">+         CalleeBits callee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].pointer()); }</span>
<span class="udiff-line-modified-added">+         SUPPRESS_ASAN CalleeBits unsafeCallee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].asanUnsafePointer()); }</span>
<span class="udiff-line-modified-added">+         CodeBlock* codeBlock() const;</span>
<span class="udiff-line-modified-added">+         CodeBlock** addressOfCodeBlock() const { return bitwise_cast&lt;CodeBlock**&gt;(this + static_cast&lt;int&gt;(CallFrameSlot::codeBlock)); }</span>
<span class="udiff-line-modified-added">+         inline SUPPRESS_ASAN CodeBlock* unsafeCodeBlock() const;</span>
<span class="udiff-line-modified-added">+         inline JSScope* scope(int scopeRegisterOffset) const;</span>
  
<span class="udiff-line-modified-removed">-         bool isAnyWasmCallee();</span>
<span class="udiff-line-modified-added">+         JS_EXPORT_PRIVATE bool isAnyWasmCallee();</span>
  
          // Global object in which the currently executing code was defined.
<span class="udiff-line-modified-removed">-         // Differs from VM::vmEntryGlobalObject() during function calls across web browser frames.</span>
<span class="udiff-line-modified-removed">-         JSGlobalObject* lexicalGlobalObject() const;</span>
<span class="udiff-line-modified-added">+         // Differs from VM::deprecatedVMEntryGlobalObject() during function calls across web browser frames.</span>
<span class="udiff-line-modified-added">+         JSGlobalObject* lexicalGlobalObject(VM&amp;) const;</span>
  
<span class="udiff-line-modified-removed">-         // Differs from lexicalGlobalObject because this will have DOM window shell rather than</span>
<span class="udiff-line-modified-removed">-         // the actual DOM window, which can&#39;t be &quot;this&quot; for security reasons.</span>
<span class="udiff-line-modified-removed">-         JSObject* globalThisValue() const;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         VM&amp; vm() const;</span>
<span class="udiff-line-modified-added">+         // FIXME: Remove this function</span>
<span class="udiff-line-modified-added">+         // https://bugs.webkit.org/show_bug.cgi?id=203272</span>
<span class="udiff-line-modified-added">+         VM&amp; deprecatedVM() const;</span>
  
          static CallFrame* create(Register* callFrameBase) { return static_cast&lt;CallFrame*&gt;(callFrameBase); }
          Register* registers() { return this; }
          const Register* registers() const { return this; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -155,11 +144,11 @@</span>
          SUPPRESS_ASAN void* unsafeCallerFrameOrEntryFrame() const { return unsafeCallerFrameAndPC().callerFrame; }
  
          CallFrame* unsafeCallerFrame(EntryFrame*&amp;) const;
          JS_EXPORT_PRIVATE CallFrame* callerFrame(EntryFrame*&amp;) const;
  
<span class="udiff-line-modified-removed">-         JS_EXPORT_PRIVATE SourceOrigin callerSourceOrigin();</span>
<span class="udiff-line-modified-added">+         JS_EXPORT_PRIVATE SourceOrigin callerSourceOrigin(VM&amp;);</span>
  
          static ptrdiff_t callerFrameOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, callerFrame); }
  
          ReturnAddressPtr returnPC() const { return ReturnAddressPtr(callerFrameAndPC().returnPC); }
          bool hasReturnPC() const { return !!callerFrameAndPC().returnPC; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -174,48 +163,44 @@</span>
          unsigned unsafeCallSiteAsRawBits() const;
          CallSiteIndex callSiteIndex() const;
          CallSiteIndex unsafeCallSiteIndex() const;
      private:
          unsigned callSiteBitsAsBytecodeOffset() const;
<span class="udiff-line-added">+ #if ENABLE(WEBASSEMBLY)</span>
<span class="udiff-line-added">+         JS_EXPORT_PRIVATE JSGlobalObject* lexicalGlobalObjectFromWasmCallee(VM&amp;) const;</span>
<span class="udiff-line-added">+ #endif</span>
      public:
  
          // This will try to get you the bytecode offset, but you should be aware that
          // this bytecode offset may be bogus in the presence of inlining. This will
          // also return 0 if the call frame has no notion of bytecode offsets (for
          // example if it&#39;s native code).
          // https://bugs.webkit.org/show_bug.cgi?id=121754
<span class="udiff-line-modified-removed">-         unsigned bytecodeOffset();</span>
<span class="udiff-line-modified-added">+         BytecodeIndex bytecodeIndex();</span>
  
          // This will get you a CodeOrigin. It will always succeed. May return
<span class="udiff-line-modified-removed">-         // CodeOrigin(0) if we&#39;re in native code.</span>
<span class="udiff-line-modified-added">+         // CodeOrigin(BytecodeIndex(0)) if we&#39;re in native code.</span>
          JS_EXPORT_PRIVATE CodeOrigin codeOrigin();
  
<span class="udiff-line-modified-removed">-         Register* topOfFrame()</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             if (!codeBlock())</span>
<span class="udiff-line-removed">-                 return registers();</span>
<span class="udiff-line-removed">-             return topOfFrameInternal();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         inline Register* topOfFrame();</span>
  
          const Instruction* currentVPC() const; // This only makes sense in the LLInt and baseline.
          void setCurrentVPC(const Instruction*);
  
          void setCallerFrame(CallFrame* frame) { callerFrameAndPC().callerFrame = frame; }
<span class="udiff-line-modified-removed">-         void setScope(int scopeRegisterOffset, JSScope* scope) { static_cast&lt;Register*&gt;(this)[scopeRegisterOffset] = scope; }</span>
<span class="udiff-line-modified-added">+         inline void setScope(int scopeRegisterOffset, JSScope*);</span>
  
<span class="udiff-line-modified-removed">-         static void initGlobalExec(ExecState* globalExec, JSCallee* globalCallee);</span>
<span class="udiff-line-modified-added">+         static void initDeprecatedCallFrameForDebugger(CallFrame* globalExec, JSCallee* globalCallee);</span>
  
          // Read a register from the codeframe (or constant from the CodeBlock).
<span class="udiff-line-removed">-         Register&amp; r(int);</span>
          Register&amp; r(VirtualRegister);
<span class="udiff-line-modified-removed">-         // Read a register for a non-constant</span>
<span class="udiff-line-removed">-         Register&amp; uncheckedR(int);</span>
<span class="udiff-line-modified-added">+         // Read a register for a known non-constant</span>
          Register&amp; uncheckedR(VirtualRegister);
  
          // Access to arguments as passed. (After capture, arguments may move to a different location.)
          size_t argumentCount() const { return argumentCountIncludingThis() - 1; }
<span class="udiff-line-modified-removed">-         size_t argumentCountIncludingThis() const { return this[CallFrameSlot::argumentCount].payload(); }</span>
<span class="udiff-line-modified-added">+         size_t argumentCountIncludingThis() const { return this[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload(); }</span>
          static int argumentOffset(int argument) { return (CallFrameSlot::firstArgument + argument); }
          static int argumentOffsetIncludingThis(int argument) { return (CallFrameSlot::thisArgument + argument); }
  
          // In the following (argument() and setArgument()), the &#39;argument&#39;
          // parameter is the index of the arguments of the target function of
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -260,53 +245,49 @@</span>
          // The result of this function is only effective under the &quot;construct&quot; context.
          JSValue newTarget() { return thisValue(); }
  
          JSValue argumentAfterCapture(size_t argument);
  
<span class="udiff-line-modified-removed">-         static int offsetFor(size_t argumentCountIncludingThis) { return argumentCountIncludingThis + CallFrameSlot::thisArgument - 1; }</span>
<span class="udiff-line-modified-added">+         static int offsetFor(size_t argumentCountIncludingThis) { return CallFrameSlot::thisArgument + argumentCountIncludingThis - 1; }</span>
  
          static CallFrame* noCaller() { return nullptr; }
<span class="udiff-line-modified-removed">-         bool isGlobalExec() const</span>
<span class="udiff-line-modified-added">+         bool isDeprecatedCallFrameForDebugger() const</span>
          {
              return callerFrameAndPC().callerFrame == noCaller() &amp;&amp; callerFrameAndPC().returnPC == nullptr;
          }
  
          void convertToStackOverflowFrame(VM&amp;, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound);
          bool isStackOverflowFrame() const;
          bool isWasmFrame() const;
  
<span class="udiff-line-modified-removed">-         void setArgumentCountIncludingThis(int count) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::argumentCount].payload() = count; }</span>
<span class="udiff-line-modified-removed">-         void setCallee(JSObject* callee) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::callee] = callee; }</span>
<span class="udiff-line-modified-removed">-         void setCodeBlock(CodeBlock* codeBlock) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::codeBlock] = codeBlock; }</span>
<span class="udiff-line-modified-removed">-         void setReturnPC(void* value) { callerFrameAndPC().returnPC = reinterpret_cast&lt;const Instruction*&gt;(value); }</span>
<span class="udiff-line-modified-added">+         void setArgumentCountIncludingThis(int count) { static_cast&lt;Register*&gt;(this)[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload() = count; }</span>
<span class="udiff-line-modified-added">+         inline void setCallee(JSObject*);</span>
<span class="udiff-line-modified-added">+         inline void setCodeBlock(CodeBlock*);</span>
<span class="udiff-line-modified-added">+         void setReturnPC(void* value) { callerFrameAndPC().returnPC = value; }</span>
  
          String friendlyFunctionName();
  
          // CallFrame::iterate() expects a Functor that implements the following method:
          //     StackVisitor::Status operator()(StackVisitor&amp;) const;
          // FIXME: This method is improper. We rely on the fact that we can call it with a null
          // receiver. We should always be using StackVisitor directly.
          // It&#39;s only valid to call this from a non-wasm top frame.
<span class="udiff-line-modified-removed">-         template &lt;StackVisitor::EmptyEntryFrameAction action = StackVisitor::ContinueIfTopEntryFrameIsEmpty, typename Functor&gt; void iterate(const Functor&amp; functor)</span>
<span class="udiff-line-modified-added">+         template &lt;StackVisitor::EmptyEntryFrameAction action = StackVisitor::ContinueIfTopEntryFrameIsEmpty, typename Functor&gt; void iterate(VM&amp; vm, const Functor&amp; functor)</span>
          {
<span class="udiff-line-removed">-             VM* vm;</span>
              void* rawThis = this;
<span class="udiff-line-modified-removed">-             if (!!rawThis) {</span>
<span class="udiff-line-modified-added">+             if (!!rawThis)</span>
                  RELEASE_ASSERT(callee().isCell());
<span class="udiff-line-removed">-                 vm = &amp;this-&gt;vm();</span>
<span class="udiff-line-removed">-             } else</span>
<span class="udiff-line-removed">-                 vm = nullptr;</span>
              StackVisitor::visit&lt;action, Functor&gt;(this, vm, functor);
          }
  
          void dump(PrintStream&amp;);
          JS_EXPORT_PRIVATE const char* describeFrame();
  
      private:
  
<span class="udiff-line-modified-removed">-         ExecState();</span>
<span class="udiff-line-modified-removed">-         ~ExecState();</span>
<span class="udiff-line-modified-added">+         CallFrame();</span>
<span class="udiff-line-modified-added">+         ~CallFrame();</span>
  
          Register* topOfFrameInternal();
  
          // The following are for internal use in debugging and verification
          // code only and not meant as an API for general usage:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -331,6 +312,19 @@</span>
          CallerFrameAndPC&amp; callerFrameAndPC() { return *reinterpret_cast&lt;CallerFrameAndPC*&gt;(this); }
          const CallerFrameAndPC&amp; callerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
          SUPPRESS_ASAN const CallerFrameAndPC&amp; unsafeCallerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
      };
  
<span class="udiff-line-added">+ JS_EXPORT_PRIVATE bool isFromJSCode(void* returnAddress);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if USE(BUILTIN_FRAME_ADDRESS)</span>
<span class="udiff-line-added">+ #define DECLARE_CALL_FRAME(vm) \</span>
<span class="udiff-line-added">+     ({ \</span>
<span class="udiff-line-added">+         ASSERT(JSC::isFromJSCode(removeCodePtrTag&lt;void*&gt;(__builtin_return_address(0)))); \</span>
<span class="udiff-line-added">+         bitwise_cast&lt;JSC::CallFrame*&gt;(__builtin_frame_address(1)); \</span>
<span class="udiff-line-added">+     })</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ #define DECLARE_CALL_FRAME(vm) ((vm).topCallFrame)</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="CallFrame.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameInlines.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/audio/AudioArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #ifndef AudioArray_h
 30 #define AudioArray_h
 31 
 32 #include &lt;string.h&gt;
 33 #include &lt;wtf/CheckedArithmetic.h&gt;
 34 #include &lt;wtf/FastMalloc.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 template&lt;typename T&gt;
 39 class AudioArray {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
<a name="1" id="anc1"></a><span class="line-modified"> 42     AudioArray() : m_allocation(0), m_alignedData(0), m_size(0) { }</span>
<span class="line-modified"> 43     explicit AudioArray(size_t n) : m_allocation(0), m_alignedData(0), m_size(0)</span>
 44     {
 45         allocate(n);
 46     }
 47 
 48     ~AudioArray()
 49     {
<a name="2" id="anc2"></a><span class="line-modified"> 50         fastFree(m_allocation);</span>
 51     }
 52 
 53     // It&#39;s OK to call allocate() multiple times, but data will *not* be copied from an initial allocation
 54     // if re-allocated. Allocations are zero-initialized.
 55     void allocate(Checked&lt;size_t&gt; n)
 56     {
<a name="3" id="anc3"></a><span class="line-modified"> 57         Checked&lt;unsigned&gt; initialSize = sizeof(T) * n;</span>
 58         const size_t alignment = 16;
 59 
<a name="4" id="anc4"></a><span class="line-modified"> 60         if (m_allocation)</span>
<span class="line-modified"> 61             fastFree(m_allocation);</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63         bool isAllocationGood = false;</span>
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65         while (!isAllocationGood) {</span>
<span class="line-modified"> 66             // Initially we try to allocate the exact size, but if it&#39;s not aligned</span>
<span class="line-removed"> 67             // then we&#39;ll have to reallocate and from then on allocate extra.</span>
<span class="line-removed"> 68             static size_t extraAllocationBytes = 0;</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70             T* allocation = static_cast&lt;T*&gt;(fastMalloc((initialSize + extraAllocationBytes).unsafeGet()));</span>
<span class="line-removed"> 71             if (!allocation)</span>
<span class="line-removed"> 72                 CRASH();</span>
<span class="line-removed"> 73             T* alignedData = alignedAddress(allocation, alignment);</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75             if (alignedData == allocation || extraAllocationBytes == alignment) {</span>
<span class="line-removed"> 76                 m_allocation = allocation;</span>
<span class="line-removed"> 77                 m_alignedData = alignedData;</span>
<span class="line-removed"> 78                 m_size = n.unsafeGet();</span>
<span class="line-removed"> 79                 isAllocationGood = true;</span>
<span class="line-removed"> 80                 zero();</span>
<span class="line-removed"> 81             } else {</span>
<span class="line-removed"> 82                 extraAllocationBytes = alignment; // always allocate extra after the first alignment failure.</span>
<span class="line-removed"> 83                 fastFree(allocation);</span>
<span class="line-removed"> 84             }</span>
<span class="line-removed"> 85         }</span>
 86     }
 87 
<a name="5" id="anc5"></a><span class="line-modified"> 88     T* data() { return m_alignedData; }</span>
<span class="line-modified"> 89     const T* data() const { return m_alignedData; }</span>
 90     size_t size() const { return m_size; }
 91 
 92     T&amp; at(size_t i)
 93     {
 94         // Note that although it is a size_t, m_size is now guaranteed to be
 95         // no greater than max unsigned. This guarantee is enforced in allocate().
 96         ASSERT_WITH_SECURITY_IMPLICATION(i &lt; size());
 97         return data()[i];
 98     }
 99 
100     T&amp; operator[](size_t i) { return at(i); }
101 
102     void zero()
103     {
104         // This multiplication is made safe by the check in allocate().
105         memset(this-&gt;data(), 0, sizeof(T) * this-&gt;size());
106     }
107 
108     void zeroRange(unsigned start, unsigned end)
109     {
110         bool isSafe = (start &lt;= end) &amp;&amp; (end &lt;= this-&gt;size());
111         ASSERT(isSafe);
112         if (!isSafe)
113             return;
114 
115         // This expression cannot overflow because end - start cannot be
116         // greater than m_size, which is safe due to the check in allocate().
117         memset(this-&gt;data() + start, 0, sizeof(T) * (end - start));
118     }
119 
120     void copyToRange(const T* sourceData, unsigned start, unsigned end)
121     {
122         bool isSafe = (start &lt;= end) &amp;&amp; (end &lt;= this-&gt;size());
123         ASSERT(isSafe);
124         if (!isSafe)
125             return;
126 
127         // This expression cannot overflow because end - start cannot be
128         // greater than m_size, which is safe due to the check in allocate().
129         memcpy(this-&gt;data() + start, sourceData, sizeof(T) * (end - start));
130     }
131 
132 private:
<a name="6" id="anc6"></a><span class="line-modified">133     static T* alignedAddress(T* address, intptr_t alignment)</span>
<span class="line-modified">134     {</span>
<span class="line-removed">135         intptr_t value = reinterpret_cast&lt;intptr_t&gt;(address);</span>
<span class="line-removed">136         return reinterpret_cast&lt;T*&gt;((value + alignment - 1) &amp; ~(alignment - 1));</span>
<span class="line-removed">137     }</span>
<span class="line-removed">138 </span>
<span class="line-removed">139     T* m_allocation;</span>
<span class="line-removed">140     T* m_alignedData;</span>
<span class="line-removed">141     size_t m_size;</span>
142 };
143 
144 typedef AudioArray&lt;float&gt; AudioFloatArray;
145 typedef AudioArray&lt;double&gt; AudioDoubleArray;
146 
147 } // WebCore
148 
149 #endif // AudioArray_h
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007, 2008, 2009, 2013 Apple Inc.
   3  * Copyright (C) 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  15  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  16  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  17  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  18  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  19  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  20  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  21  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  22  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;EditingStyle.h&quot;
  29 
  30 #include &quot;ApplyStyleCommand.h&quot;
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSFontFamily.h&quot;
  33 #include &quot;CSSFontStyleValue.h&quot;
  34 #include &quot;CSSParser.h&quot;
  35 #include &quot;CSSRuleList.h&quot;
  36 #include &quot;CSSStyleRule.h&quot;
  37 #include &quot;CSSValueList.h&quot;
  38 #include &quot;CSSValuePool.h&quot;
  39 #include &quot;Editing.h&quot;
  40 #include &quot;Editor.h&quot;
  41 #include &quot;FontCache.h&quot;
  42 #include &quot;FontCascade.h&quot;
  43 #include &quot;Frame.h&quot;
  44 #include &quot;HTMLFontElement.h&quot;
  45 #include &quot;HTMLInterchange.h&quot;
  46 #include &quot;HTMLNames.h&quot;
  47 #include &quot;HTMLSpanElement.h&quot;
  48 #include &quot;Node.h&quot;
  49 #include &quot;NodeTraversal.h&quot;
  50 #include &quot;QualifiedName.h&quot;
  51 #include &quot;RenderElement.h&quot;
  52 #include &quot;RenderStyle.h&quot;
  53 #include &quot;StyleFontSizeFunctions.h&quot;
  54 #include &quot;StyleProperties.h&quot;
  55 #include &quot;StyleResolver.h&quot;
  56 #include &quot;StyleRule.h&quot;
  57 #include &quot;StyledElement.h&quot;
  58 #include &quot;VisibleUnits.h&quot;
  59 #include &lt;wtf/Optional.h&gt;
  60 
  61 namespace WebCore {
  62 
  63 // Editing style properties must be preserved during editing operation.
  64 // e.g. when a user inserts a new paragraph, all properties listed here must be copied to the new paragraph.
  65 static const CSSPropertyID editingProperties[] = {
  66     CSSPropertyCaretColor,
  67     CSSPropertyColor,
  68     CSSPropertyFontFamily,
  69     CSSPropertyFontSize,
  70     CSSPropertyFontStyle,
  71     CSSPropertyFontVariantCaps,
  72     CSSPropertyFontWeight,
  73     CSSPropertyLetterSpacing,
  74     CSSPropertyOrphans,
  75     CSSPropertyTextAlign,
  76     CSSPropertyTextIndent,
  77     CSSPropertyTextTransform,
  78     CSSPropertyWhiteSpace,
  79     CSSPropertyWidows,
  80     CSSPropertyWordSpacing,
  81 #if ENABLE(TOUCH_EVENTS)
  82     CSSPropertyWebkitTapHighlightColor,
  83 #endif
  84     CSSPropertyWebkitTextDecorationsInEffect,
  85     CSSPropertyWebkitTextFillColor,
  86 #if ENABLE(TEXT_AUTOSIZING)
  87     CSSPropertyWebkitTextSizeAdjust,
  88 #endif
  89     CSSPropertyWebkitTextStrokeColor,
  90     CSSPropertyWebkitTextStrokeWidth,
  91 
  92     // Non-inheritable properties
  93     CSSPropertyBackgroundColor,
  94     CSSPropertyTextDecoration,
  95 };
  96 
  97 const unsigned numAllEditingProperties = WTF_ARRAY_LENGTH(editingProperties);
  98 const unsigned numInheritableEditingProperties = numAllEditingProperties - 2;
  99 
 100 enum EditingPropertiesToInclude { OnlyInheritableEditingProperties, AllEditingProperties };
 101 template &lt;class StyleDeclarationType&gt;
 102 static Ref&lt;MutableStyleProperties&gt; copyEditingProperties(StyleDeclarationType* style, EditingPropertiesToInclude type)
 103 {
 104     if (type == AllEditingProperties)
 105         return style-&gt;copyPropertiesInSet(editingProperties, numAllEditingProperties);
 106     return style-&gt;copyPropertiesInSet(editingProperties, numInheritableEditingProperties);
 107 }
 108 
 109 static inline bool isEditingProperty(int id)
 110 {
 111     for (auto&amp; editingProperty : editingProperties) {
 112         if (editingProperty == id)
 113             return true;
 114     }
 115     return false;
 116 }
 117 
 118 static Ref&lt;MutableStyleProperties&gt; copyPropertiesFromComputedStyle(ComputedStyleExtractor&amp; computedStyle, EditingStyle::PropertiesToInclude propertiesToInclude)
 119 {
 120     switch (propertiesToInclude) {
 121     case EditingStyle::OnlyEditingInheritableProperties:
 122         return copyEditingProperties(&amp;computedStyle, OnlyInheritableEditingProperties);
 123     case EditingStyle::EditingPropertiesInEffect:
 124         return copyEditingProperties(&amp;computedStyle, AllEditingProperties);
 125     case EditingStyle::AllProperties:
 126         break;
 127     }
 128     return computedStyle.copyProperties();
 129 }
 130 
 131 static Ref&lt;MutableStyleProperties&gt; copyPropertiesFromComputedStyle(Node* node, EditingStyle::PropertiesToInclude propertiesToInclude)
 132 {
 133     ComputedStyleExtractor computedStyle(node);
 134     return copyPropertiesFromComputedStyle(computedStyle, propertiesToInclude);
 135 }
 136 
 137 static RefPtr&lt;CSSValue&gt; extractPropertyValue(const StyleProperties&amp; style, CSSPropertyID propertyID)
 138 {
 139     return style.getPropertyCSSValue(propertyID);
 140 }
 141 
 142 static RefPtr&lt;CSSValue&gt; extractPropertyValue(ComputedStyleExtractor&amp; computedStyle, CSSPropertyID propertyID)
 143 {
 144     return computedStyle.propertyValue(propertyID);
 145 }
 146 
 147 template&lt;typename T&gt;
 148 int identifierForStyleProperty(T&amp; style, CSSPropertyID propertyID)
 149 {
 150     RefPtr&lt;CSSValue&gt; value = extractPropertyValue(style, propertyID);
 151     if (propertyID == CSSPropertyFontStyle &amp;&amp; is&lt;CSSFontStyleValue&gt;(value) &amp;&amp; downcast&lt;CSSFontStyleValue&gt;(value.get())-&gt;isItalicOrOblique())
 152         return CSSValueItalic;
 153     if (!is&lt;CSSPrimitiveValue&gt;(value))
 154         return 0;
 155     return downcast&lt;CSSPrimitiveValue&gt;(*value).valueID();
 156 }
 157 
 158 template&lt;typename T&gt; Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle);
 159 enum LegacyFontSizeMode { AlwaysUseLegacyFontSize, UseLegacyFontSizeOnlyIfPixelValuesMatch };
 160 static int legacyFontSizeFromCSSValue(Document&amp;, CSSPrimitiveValue*, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode);
 161 static bool hasTransparentBackgroundColor(StyleProperties*);
 162 static RefPtr&lt;CSSValue&gt; backgroundColorInEffect(Node*);
 163 
 164 class HTMLElementEquivalent {
 165     WTF_MAKE_FAST_ALLOCATED;
 166 public:
 167     HTMLElementEquivalent(CSSPropertyID, CSSValueID primitiveValue, const QualifiedName&amp; tagName);
 168     virtual ~HTMLElementEquivalent() = default;
 169 
 170     virtual bool matches(const Element&amp; element) const { return !m_tagName || element.hasTagName(*m_tagName); }
 171     virtual bool hasAttribute() const { return false; }
 172     virtual bool propertyExistsInStyle(const EditingStyle&amp; style) const { return style.m_mutableStyle &amp;&amp; style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID); }
 173     virtual bool valueIsPresentInStyle(Element&amp;, const EditingStyle&amp;) const;
 174     virtual void addToStyle(Element*, EditingStyle*) const;
 175 
 176 protected:
 177     HTMLElementEquivalent(CSSPropertyID);
 178     HTMLElementEquivalent(CSSPropertyID, const QualifiedName&amp; tagName);
 179     const CSSPropertyID m_propertyID;
 180     const RefPtr&lt;CSSPrimitiveValue&gt; m_primitiveValue;
 181     const QualifiedName* m_tagName { nullptr }; // We can store a pointer because HTML tag names are const global.
 182 };
 183 
 184 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id)
 185     : m_propertyID(id)
 186 {
 187 }
 188 
 189 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id, const QualifiedName&amp; tagName)
 190     : m_propertyID(id)
 191     , m_tagName(&amp;tagName)
 192 {
 193 }
 194 
 195 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id, CSSValueID primitiveValue, const QualifiedName&amp; tagName)
 196     : m_propertyID(id)
 197     , m_primitiveValue(CSSPrimitiveValue::createIdentifier(primitiveValue))
 198     , m_tagName(&amp;tagName)
 199 {
 200     ASSERT(primitiveValue != CSSValueInvalid);
 201 }
 202 
 203 bool HTMLElementEquivalent::valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const
 204 {
 205     RefPtr&lt;CSSValue&gt; value = style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID);
 206     return matches(element) &amp;&amp; is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*value).valueID() == m_primitiveValue-&gt;valueID();
 207 }
 208 
 209 void HTMLElementEquivalent::addToStyle(Element*, EditingStyle* style) const
 210 {
 211     style-&gt;setProperty(m_propertyID, m_primitiveValue-&gt;cssText());
 212 }
 213 
 214 class HTMLTextDecorationEquivalent : public HTMLElementEquivalent {
 215 public:
 216     HTMLTextDecorationEquivalent(CSSValueID primitiveValue, const QualifiedName&amp; tagName)
 217         : HTMLElementEquivalent(CSSPropertyTextDecoration, primitiveValue, tagName)
 218         , m_isUnderline(primitiveValue == CSSValueUnderline)
 219     {
 220     }
 221 
 222     bool propertyExistsInStyle(const EditingStyle&amp; style) const override
 223     {
 224         if (changeInStyle(style) != TextDecorationChange::None)
 225             return true;
 226 
 227         if (!style.m_mutableStyle)
 228             return false;
 229 
 230         auto&amp; mutableStyle = *style.m_mutableStyle;
 231         return mutableStyle.getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect)
 232             || mutableStyle.getPropertyCSSValue(CSSPropertyTextDecoration);
 233     }
 234 
 235     bool valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const override
 236     {
 237         if (!matches(element))
 238             return false;
 239         auto change = changeInStyle(style);
 240         if (change != TextDecorationChange::None)
 241             return change == TextDecorationChange::Add;
 242         RefPtr&lt;CSSValue&gt; styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 243         if (!styleValue)
 244             styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
 245         return is&lt;CSSValueList&gt;(styleValue) &amp;&amp; downcast&lt;CSSValueList&gt;(*styleValue).hasValue(m_primitiveValue.get());
 246     }
 247 
 248 private:
 249     TextDecorationChange changeInStyle(const EditingStyle&amp; style) const
 250     {
 251         return m_isUnderline ? style.underlineChange() : style.strikeThroughChange();
 252     }
 253 
 254     bool m_isUnderline;
 255 };
 256 
 257 class HTMLAttributeEquivalent : public HTMLElementEquivalent {
 258 public:
 259     HTMLAttributeEquivalent(CSSPropertyID, const QualifiedName&amp; tagName, const QualifiedName&amp; attrName);
 260     HTMLAttributeEquivalent(CSSPropertyID, const QualifiedName&amp; attrName);
 261 
 262     bool matches(const Element&amp; element) const override { return HTMLElementEquivalent::matches(element) &amp;&amp; element.hasAttribute(m_attrName); }
 263     bool hasAttribute() const override { return true; }
 264     bool valueIsPresentInStyle(Element&amp;, const EditingStyle&amp;) const override;
 265     void addToStyle(Element*, EditingStyle*) const override;
 266     virtual RefPtr&lt;CSSValue&gt; attributeValueAsCSSValue(Element*) const;
 267     inline const QualifiedName&amp; attributeName() const { return m_attrName; }
 268 
 269 protected:
 270     const QualifiedName&amp; m_attrName; // We can store a reference because HTML attribute names are const global.
 271 };
 272 
 273 HTMLAttributeEquivalent::HTMLAttributeEquivalent(CSSPropertyID id, const QualifiedName&amp; tagName, const QualifiedName&amp; attrName)
 274     : HTMLElementEquivalent(id, tagName)
 275     , m_attrName(attrName)
 276 {
 277 }
 278 
 279 HTMLAttributeEquivalent::HTMLAttributeEquivalent(CSSPropertyID id, const QualifiedName&amp; attrName)
 280     : HTMLElementEquivalent(id)
 281     , m_attrName(attrName)
 282 {
 283 }
 284 
 285 bool HTMLAttributeEquivalent::valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const
 286 {
 287     RefPtr&lt;CSSValue&gt; value = attributeValueAsCSSValue(&amp;element);
 288     RefPtr&lt;CSSValue&gt; styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID);
 289 
 290     return compareCSSValuePtr(value, styleValue);
 291 }
 292 
 293 void HTMLAttributeEquivalent::addToStyle(Element* element, EditingStyle* style) const
 294 {
 295     if (RefPtr&lt;CSSValue&gt; value = attributeValueAsCSSValue(element))
 296         style-&gt;setProperty(m_propertyID, value-&gt;cssText());
 297 }
 298 
 299 RefPtr&lt;CSSValue&gt; HTMLAttributeEquivalent::attributeValueAsCSSValue(Element* element) const
 300 {
 301     ASSERT(element);
 302     const AtomString&amp; value = element-&gt;getAttribute(m_attrName);
 303     if (value.isNull())
 304         return nullptr;
 305 
 306     RefPtr&lt;MutableStyleProperties&gt; dummyStyle;
 307     dummyStyle = MutableStyleProperties::create();
 308     dummyStyle-&gt;setProperty(m_propertyID, value);
 309     return dummyStyle-&gt;getPropertyCSSValue(m_propertyID);
 310 }
 311 
 312 class HTMLFontSizeEquivalent : public HTMLAttributeEquivalent {
 313 public:
 314     HTMLFontSizeEquivalent();
 315 
 316     RefPtr&lt;CSSValue&gt; attributeValueAsCSSValue(Element*) const override;
 317 };
 318 
 319 HTMLFontSizeEquivalent::HTMLFontSizeEquivalent()
 320     : HTMLAttributeEquivalent(CSSPropertyFontSize, HTMLNames::fontTag, HTMLNames::sizeAttr)
 321 {
 322 }
 323 
 324 RefPtr&lt;CSSValue&gt; HTMLFontSizeEquivalent::attributeValueAsCSSValue(Element* element) const
 325 {
 326     ASSERT(element);
 327     const AtomString&amp; value = element-&gt;getAttribute(m_attrName);
 328     if (value.isNull())
 329         return nullptr;
 330     CSSValueID size;
 331     if (!HTMLFontElement::cssValueFromFontSizeNumber(value, size))
 332         return nullptr;
 333     return CSSPrimitiveValue::createIdentifier(size);
 334 }
 335 
 336 float EditingStyle::NoFontDelta = 0.0f;
 337 
 338 EditingStyle::EditingStyle()
 339     : m_shouldUseFixedDefaultFontSize(false)
 340     , m_underlineChange(static_cast&lt;unsigned&gt;(TextDecorationChange::None))
 341     , m_strikeThroughChange(static_cast&lt;unsigned&gt;(TextDecorationChange::None))
 342 {
 343 }
 344 
 345 EditingStyle::EditingStyle(Node* node, PropertiesToInclude propertiesToInclude)
 346     : EditingStyle()
 347 {
 348     init(node, propertiesToInclude);
 349 }
 350 
 351 EditingStyle::EditingStyle(const Position&amp; position, PropertiesToInclude propertiesToInclude)
 352     : EditingStyle()
 353 {
 354     init(position.deprecatedNode(), propertiesToInclude);
 355 }
 356 
 357 EditingStyle::EditingStyle(const CSSStyleDeclaration* style)
 358     : EditingStyle()
 359 {
 360     if (style)
 361         m_mutableStyle = style-&gt;copyProperties();
 362     extractFontSizeDelta();
 363 }
 364 
 365 EditingStyle::EditingStyle(const StyleProperties* style)
 366     : EditingStyle()
 367 {
 368     if (style)
 369         m_mutableStyle = style-&gt;mutableCopy();
 370     extractFontSizeDelta();
 371 }
 372 
 373 EditingStyle::EditingStyle(CSSPropertyID propertyID, const String&amp; value)
 374     : EditingStyle()
 375 {
 376     setProperty(propertyID, value);
 377     extractFontSizeDelta();
 378 }
 379 
 380 EditingStyle::EditingStyle(CSSPropertyID propertyID, CSSValueID value)
 381     : EditingStyle()
 382 {
 383     m_mutableStyle = MutableStyleProperties::create();
 384     m_mutableStyle-&gt;setProperty(propertyID, value);
 385     extractFontSizeDelta();
 386 }
 387 
 388 EditingStyle::~EditingStyle() = default;
 389 
 390 static Color cssValueToColor(CSSValue* colorValue)
 391 {
 392     if (!is&lt;CSSPrimitiveValue&gt;(colorValue))
 393         return Color::transparent;
 394 
 395     CSSPrimitiveValue&amp; primitiveColor = downcast&lt;CSSPrimitiveValue&gt;(*colorValue);
 396     if (primitiveColor.isRGBColor())
 397         return primitiveColor.color();
 398 
 399     return CSSParser::parseColor(colorValue-&gt;cssText());
 400 }
 401 
 402 template&lt;typename T&gt;
 403 static inline Color textColorFromStyle(T&amp; style)
 404 {
 405     return cssValueToColor(extractPropertyValue(style, CSSPropertyColor).get());
 406 }
 407 
 408 template&lt;typename T&gt;
 409 static inline Color caretColorFromStyle(T&amp; style)
 410 {
 411     return cssValueToColor(extractPropertyValue(style, CSSPropertyCaretColor).get());
 412 }
 413 
 414 template&lt;typename T&gt;
 415 static inline Color backgroundColorFromStyle(T&amp; style)
 416 {
 417     return cssValueToColor(extractPropertyValue(style, CSSPropertyBackgroundColor).get());
 418 }
 419 
 420 static inline Color rgbaBackgroundColorInEffect(Node* node)
 421 {
 422     return cssValueToColor(backgroundColorInEffect(node).get());
 423 }
 424 
 425 static int textAlignResolvingStartAndEnd(int textAlign, int direction)
 426 {
 427     switch (textAlign) {
 428     case CSSValueCenter:
 429     case CSSValueWebkitCenter:
 430         return CSSValueCenter;
 431     case CSSValueJustify:
 432         return CSSValueJustify;
 433     case CSSValueLeft:
 434     case CSSValueWebkitLeft:
 435         return CSSValueLeft;
 436     case CSSValueRight:
 437     case CSSValueWebkitRight:
 438         return CSSValueRight;
 439     case CSSValueStart:
 440         return direction != CSSValueRtl ? CSSValueLeft : CSSValueRight;
 441     case CSSValueEnd:
 442         return direction == CSSValueRtl ? CSSValueRight : CSSValueLeft;
 443     }
 444     return CSSValueInvalid;
 445 }
 446 
 447 template&lt;typename T&gt;
 448 static int textAlignResolvingStartAndEnd(T&amp; style)
 449 {
 450     return textAlignResolvingStartAndEnd(identifierForStyleProperty(style, CSSPropertyTextAlign), identifierForStyleProperty(style, CSSPropertyDirection));
 451 }
 452 
 453 void EditingStyle::init(Node* node, PropertiesToInclude propertiesToInclude)
 454 {
 455     if (isTabSpanTextNode(node))
 456         node = tabSpanNode(node)-&gt;parentNode();
 457     else if (isTabSpanNode(node))
 458         node = node-&gt;parentNode();
 459 
 460     ComputedStyleExtractor computedStyleAtPosition(node);
 461     // FIXME: It&#39;s strange to not set background-color and text-decoration when propertiesToInclude is EditingPropertiesInEffect.
 462     // However editing/selection/contains-boundaries.html fails without this ternary.
 463     m_mutableStyle = copyPropertiesFromComputedStyle(computedStyleAtPosition,
 464         propertiesToInclude == EditingPropertiesInEffect ? OnlyEditingInheritableProperties : propertiesToInclude);
 465 
 466     if (propertiesToInclude == EditingPropertiesInEffect) {
 467         if (RefPtr&lt;CSSValue&gt; value = backgroundColorInEffect(node))
 468             m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, value-&gt;cssText());
 469         if (RefPtr&lt;CSSValue&gt; value = computedStyleAtPosition.propertyValue(CSSPropertyWebkitTextDecorationsInEffect)) {
 470             m_mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, value-&gt;cssText());
 471             m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
 472         }
 473     }
 474 
 475     if (node &amp;&amp; node-&gt;computedStyle()) {
 476         auto* renderStyle = node-&gt;computedStyle();
 477         removeTextFillAndStrokeColorsIfNeeded(renderStyle);
 478         if (renderStyle-&gt;fontDescription().keywordSize())
 479             m_mutableStyle-&gt;setProperty(CSSPropertyFontSize, computedStyleAtPosition.getFontSizeCSSValuePreferringKeyword()-&gt;cssText());
 480     }
 481 
 482     m_shouldUseFixedDefaultFontSize = computedStyleAtPosition.useFixedFontDefaultSize();
 483     extractFontSizeDelta();
 484 }
 485 
 486 void EditingStyle::removeTextFillAndStrokeColorsIfNeeded(const RenderStyle* renderStyle)
 487 {
 488     // If a node&#39;s text fill color is invalid, then its children use
 489     // their font-color as their text fill color (they don&#39;t
 490     // inherit it).  Likewise for stroke color.
 491     if (!renderStyle-&gt;textFillColor().isValid())
 492         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextFillColor);
 493     if (!renderStyle-&gt;textStrokeColor().isValid())
 494         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextStrokeColor);
 495 }
 496 
 497 void EditingStyle::setProperty(CSSPropertyID propertyID, const String&amp; value, bool important)
 498 {
 499     if (!m_mutableStyle)
 500         m_mutableStyle = MutableStyleProperties::create();
 501 
 502     m_mutableStyle-&gt;setProperty(propertyID, value, important);
 503 }
 504 
 505 void EditingStyle::extractFontSizeDelta()
 506 {
 507     if (!m_mutableStyle)
 508         return;
 509 
 510     if (m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize)) {
 511         // Explicit font size overrides any delta.
 512         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitFontSizeDelta);
 513         return;
 514     }
 515 
 516     // Get the adjustment amount out of the style.
 517     RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitFontSizeDelta);
 518     if (!is&lt;CSSPrimitiveValue&gt;(value))
 519         return;
 520 
 521     CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
 522 
 523     // Only PX handled now. If we handle more types in the future, perhaps
 524     // a switch statement here would be more appropriate.
 525     if (!primitiveValue.isPx())
 526         return;
 527 
 528     m_fontSizeDelta = primitiveValue.floatValue();
 529     m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitFontSizeDelta);
 530 }
 531 
 532 bool EditingStyle::isEmpty() const
 533 {
 534     return (!m_mutableStyle || m_mutableStyle-&gt;isEmpty()) &amp;&amp; m_fontSizeDelta == NoFontDelta
 535         &amp;&amp; underlineChange() == TextDecorationChange::None &amp;&amp; strikeThroughChange() == TextDecorationChange::None;
 536 }
 537 
 538 Ref&lt;MutableStyleProperties&gt; EditingStyle::styleWithResolvedTextDecorations() const
 539 {
 540     bool hasTextDecorationChanges = underlineChange() != TextDecorationChange::None || strikeThroughChange() != TextDecorationChange::None;
 541     if (m_mutableStyle &amp;&amp; !hasTextDecorationChanges)
 542         return *m_mutableStyle;
 543 
 544     Ref&lt;MutableStyleProperties&gt; style = m_mutableStyle ? m_mutableStyle-&gt;mutableCopy() : MutableStyleProperties::create();
 545 
 546     Ref&lt;CSSValueList&gt; valueList = CSSValueList::createSpaceSeparated();
 547     if (underlineChange() == TextDecorationChange::Add)
 548         valueList-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline));
 549     if (strikeThroughChange() == TextDecorationChange::Add)
 550         valueList-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough));
 551 
 552     if (valueList-&gt;length())
 553         style-&gt;setProperty(CSSPropertyTextDecoration, valueList.ptr());
 554     else
 555         style-&gt;setProperty(CSSPropertyTextDecoration, CSSValuePool::singleton().createIdentifierValue(CSSValueNone));
 556 
 557     return style;
 558 }
 559 
 560 Optional&lt;WritingDirection&gt; EditingStyle::textDirection() const
 561 {
 562     if (!m_mutableStyle)
 563         return WTF::nullopt;
 564 
 565     RefPtr&lt;CSSValue&gt; unicodeBidi = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi);
 566     if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
 567         return WTF::nullopt;
 568 
 569     CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
 570     if (unicodeBidiValue == CSSValueEmbed) {
 571         RefPtr&lt;CSSValue&gt; direction = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyDirection);
 572         if (!is&lt;CSSPrimitiveValue&gt;(direction))
 573             return WTF::nullopt;
 574 
 575         return downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID() == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
 576     }
 577 
 578     if (unicodeBidiValue == CSSValueNormal)
 579         return WritingDirection::Natural;
 580 
 581     return WTF::nullopt;
 582 }
 583 
 584 void EditingStyle::setStyle(RefPtr&lt;MutableStyleProperties&gt;&amp;&amp; style)
 585 {
 586     m_mutableStyle = WTFMove(style);
 587     // FIXME: We should be able to figure out whether or not font is fixed width for mutable style.
 588     // We need to check font-family is monospace as in FontDescription but we don&#39;t want to duplicate code here.
 589     m_shouldUseFixedDefaultFontSize = false;
 590     extractFontSizeDelta();
 591 }
 592 
 593 void EditingStyle::overrideWithStyle(const StyleProperties&amp; style)
 594 {
 595     return mergeStyle(&amp;style, OverrideValues);
 596 }
 597 
 598 static void applyTextDecorationChangeToValueList(CSSValueList&amp; valueList, TextDecorationChange change, Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)
 599 {
 600     switch (change) {
 601     case TextDecorationChange::None:
 602         break;
 603     case TextDecorationChange::Add:
 604         valueList.append(WTFMove(value));
 605         break;
 606     case TextDecorationChange::Remove:
 607         valueList.removeAll(&amp;value.get());
 608         break;
 609     }
 610 }
 611 
 612 void EditingStyle::overrideTypingStyleAt(const EditingStyle&amp; style, const Position&amp; position)
 613 {
 614     mergeStyle(style.m_mutableStyle.get(), OverrideValues);
 615 
 616     m_fontSizeDelta += style.m_fontSizeDelta;
 617 
 618     prepareToApplyAt(position, EditingStyle::PreserveWritingDirection);
 619 
 620     auto underlineChange = style.underlineChange();
 621     auto strikeThroughChange = style.strikeThroughChange();
 622     if (underlineChange == TextDecorationChange::None &amp;&amp; strikeThroughChange == TextDecorationChange::None)
 623         return;
 624 
 625     if (!m_mutableStyle)
 626         m_mutableStyle = MutableStyleProperties::create();
 627 
 628     auto&amp; cssValuePool = CSSValuePool::singleton();
 629     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
 630     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
 631     RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 632     RefPtr&lt;CSSValueList&gt; valueList;
 633     if (value &amp;&amp; value-&gt;isValueList()) {
 634         valueList = downcast&lt;CSSValueList&gt;(*value).copy();
 635         applyTextDecorationChangeToValueList(*valueList, underlineChange, WTFMove(underline));
 636         applyTextDecorationChangeToValueList(*valueList, strikeThroughChange, WTFMove(lineThrough));
 637     } else {
 638         valueList = CSSValueList::createSpaceSeparated();
 639         if (underlineChange == TextDecorationChange::Add)
 640             valueList-&gt;append(WTFMove(underline));
 641         if (strikeThroughChange == TextDecorationChange::Add)
 642             valueList-&gt;append(WTFMove(lineThrough));
 643     }
 644     m_mutableStyle-&gt;setProperty(CSSPropertyWebkitTextDecorationsInEffect, valueList.get());
 645 }
 646 
 647 void EditingStyle::clear()
 648 {
 649     m_mutableStyle = nullptr;
 650     m_shouldUseFixedDefaultFontSize = false;
 651     m_fontSizeDelta = NoFontDelta;
 652     setUnderlineChange(TextDecorationChange::None);
 653     setStrikeThroughChange(TextDecorationChange::None);
 654 }
 655 
 656 Ref&lt;EditingStyle&gt; EditingStyle::copy() const
 657 {
 658     auto copy = EditingStyle::create();
 659     if (m_mutableStyle)
 660         copy-&gt;m_mutableStyle = m_mutableStyle-&gt;mutableCopy();
 661     copy-&gt;m_shouldUseFixedDefaultFontSize = m_shouldUseFixedDefaultFontSize;
 662     copy-&gt;m_underlineChange = m_underlineChange;
 663     copy-&gt;m_strikeThroughChange = m_strikeThroughChange;
 664     copy-&gt;m_fontSizeDelta = m_fontSizeDelta;
 665     return copy;
 666 }
 667 
 668 Ref&lt;EditingStyle&gt; EditingStyle::extractAndRemoveBlockProperties()
 669 {
 670     auto blockProperties = EditingStyle::create();
 671     if (!m_mutableStyle)
 672         return blockProperties;
 673 
 674     blockProperties-&gt;m_mutableStyle = m_mutableStyle-&gt;copyBlockProperties();
 675     m_mutableStyle-&gt;removeBlockProperties();
 676 
 677     return blockProperties;
 678 }
 679 
 680 Ref&lt;EditingStyle&gt; EditingStyle::extractAndRemoveTextDirection()
 681 {
 682     auto textDirection = EditingStyle::create();
 683     textDirection-&gt;m_mutableStyle = MutableStyleProperties::create();
 684     textDirection-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed, m_mutableStyle-&gt;propertyIsImportant(CSSPropertyUnicodeBidi));
 685     textDirection-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyDirection, m_mutableStyle-&gt;getPropertyValue(CSSPropertyDirection),
 686         m_mutableStyle-&gt;propertyIsImportant(CSSPropertyDirection));
 687 
 688     m_mutableStyle-&gt;removeProperty(CSSPropertyUnicodeBidi);
 689     m_mutableStyle-&gt;removeProperty(CSSPropertyDirection);
 690 
 691     return textDirection;
 692 }
 693 
 694 void EditingStyle::removeBlockProperties()
 695 {
 696     if (!m_mutableStyle)
 697         return;
 698 
 699     m_mutableStyle-&gt;removeBlockProperties();
 700 }
 701 
 702 void EditingStyle::removeStyleAddedByNode(Node* node)
 703 {
 704     if (!node || !node-&gt;parentNode())
 705         return;
 706     RefPtr&lt;MutableStyleProperties&gt; parentStyle = copyPropertiesFromComputedStyle(node-&gt;parentNode(), EditingPropertiesInEffect);
 707     RefPtr&lt;MutableStyleProperties&gt; nodeStyle = copyPropertiesFromComputedStyle(node, EditingPropertiesInEffect);
 708     removeEquivalentProperties(*parentStyle);
 709     removeEquivalentProperties(*nodeStyle);
 710 }
 711 
 712 void EditingStyle::removeStyleConflictingWithStyleOfNode(Node&amp; node)
 713 {
 714     if (!node.parentNode() || !m_mutableStyle)
 715         return;
 716 
 717     RefPtr&lt;MutableStyleProperties&gt; parentStyle = copyPropertiesFromComputedStyle(node.parentNode(), EditingPropertiesInEffect);
 718     auto nodeStyle = EditingStyle::create(&amp;node, EditingPropertiesInEffect);
 719     nodeStyle-&gt;removeEquivalentProperties(*parentStyle);
 720 
 721     MutableStyleProperties* style = nodeStyle-&gt;style();
 722     unsigned propertyCount = style-&gt;propertyCount();
 723     for (unsigned i = 0; i &lt; propertyCount; ++i)
 724         m_mutableStyle-&gt;removeProperty(style-&gt;propertyAt(i).id());
 725 }
 726 
 727 void EditingStyle::collapseTextDecorationProperties()
 728 {
 729     if (!m_mutableStyle)
 730         return;
 731 
 732     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 733     if (!textDecorationsInEffect)
 734         return;
 735 
 736     if (textDecorationsInEffect-&gt;isValueList())
 737         m_mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText(), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration));
 738     else
 739         m_mutableStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 740     m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
 741 }
 742 
 743 // CSS properties that create a visual difference only when applied to text.
 744 static const CSSPropertyID textOnlyProperties[] = {
 745     CSSPropertyTextDecoration,
 746     CSSPropertyWebkitTextDecorationsInEffect,
 747     CSSPropertyFontStyle,
 748     CSSPropertyFontWeight,
 749     CSSPropertyColor,
 750 };
 751 
 752 TriState EditingStyle::triStateOfStyle(EditingStyle* style) const
 753 {
 754     if (!style || !style-&gt;m_mutableStyle)
 755         return FalseTriState;
 756     return triStateOfStyle(*style-&gt;m_mutableStyle, DoNotIgnoreTextOnlyProperties);
 757 }
 758 
 759 template&lt;typename T&gt;
 760 TriState EditingStyle::triStateOfStyle(T&amp; styleToCompare, ShouldIgnoreTextOnlyProperties shouldIgnoreTextOnlyProperties) const
 761 {
 762     if (!m_mutableStyle)
 763         return TrueTriState;
 764 
 765     RefPtr&lt;MutableStyleProperties&gt; difference = getPropertiesNotIn(*m_mutableStyle, styleToCompare);
 766 
 767     if (shouldIgnoreTextOnlyProperties == IgnoreTextOnlyProperties)
 768         difference-&gt;removePropertiesInSet(textOnlyProperties, WTF_ARRAY_LENGTH(textOnlyProperties));
 769 
 770     if (difference-&gt;isEmpty())
 771         return TrueTriState;
 772     if (difference-&gt;propertyCount() == m_mutableStyle-&gt;propertyCount())
 773         return FalseTriState;
 774 
 775     return MixedTriState;
 776 }
 777 
 778 TriState EditingStyle::triStateOfStyle(const VisibleSelection&amp; selection) const
 779 {
 780     if (!selection.isCaretOrRange())
 781         return FalseTriState;
 782 
 783     if (selection.isCaret())
 784         return triStateOfStyle(EditingStyle::styleAtSelectionStart(selection).get());
 785 
 786     TriState state = FalseTriState;
 787     bool nodeIsStart = true;
 788     for (Node* node = selection.start().deprecatedNode(); node; node = NodeTraversal::next(*node)) {
 789         if (node-&gt;renderer() &amp;&amp; node-&gt;hasEditableStyle()) {
 790             ComputedStyleExtractor computedStyle(node);
 791             TriState nodeState = triStateOfStyle(computedStyle, node-&gt;isTextNode() ? EditingStyle::DoNotIgnoreTextOnlyProperties : EditingStyle::IgnoreTextOnlyProperties);
 792             if (nodeIsStart) {
 793                 state = nodeState;
 794                 nodeIsStart = false;
 795             } else if (state != nodeState &amp;&amp; node-&gt;isTextNode()) {
 796                 state = MixedTriState;
 797                 break;
 798             }
 799         }
 800 
 801         if (node == selection.end().deprecatedNode())
 802             break;
 803     }
 804 
 805     return state;
 806 }
 807 
 808 static RefPtr&lt;CSSValueList&gt; textDecorationValueList(const StyleProperties&amp; properties)
 809 {
 810     RefPtr&lt;CSSValue&gt; value = properties.getPropertyCSSValue(CSSPropertyTextDecoration);
 811     if (!is&lt;CSSValueList&gt;(value))
 812         return nullptr;
 813     return downcast&lt;CSSValueList&gt;(value.get());
 814 }
 815 
 816 bool EditingStyle::conflictsWithInlineStyleOfElement(StyledElement&amp; element, RefPtr&lt;MutableStyleProperties&gt;* newInlineStylePtr, EditingStyle* extractedStyle) const
 817 {
 818     const StyleProperties* inlineStyle = element.inlineStyle();
 819     if (!inlineStyle)
 820         return false;
 821     bool conflicts = false;
 822     RefPtr&lt;MutableStyleProperties&gt; newInlineStyle;
 823     if (newInlineStylePtr) {
 824         newInlineStyle = inlineStyle-&gt;mutableCopy();
 825         *newInlineStylePtr = newInlineStyle;
 826     }
 827 
 828     bool shouldRemoveUnderline = underlineChange() == TextDecorationChange::Remove;
 829     bool shouldRemoveStrikeThrough = strikeThroughChange() == TextDecorationChange::Remove;
 830     if (shouldRemoveUnderline || shouldRemoveStrikeThrough) {
 831         if (RefPtr&lt;CSSValueList&gt; valueList = textDecorationValueList(*inlineStyle)) {
 832             auto newValueList = valueList-&gt;copy();
 833             auto extractedValueList = CSSValueList::createSpaceSeparated();
 834 
 835             Ref&lt;CSSPrimitiveValue&gt; underline = CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline);
 836             if (shouldRemoveUnderline &amp;&amp; valueList-&gt;hasValue(underline.ptr())) {
 837                 if (!newInlineStyle)
 838                     return true;
 839                 newValueList-&gt;removeAll(underline.ptr());
 840                 extractedValueList-&gt;append(WTFMove(underline));
 841             }
 842 
 843             Ref&lt;CSSPrimitiveValue&gt; lineThrough = CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough);
 844             if (shouldRemoveStrikeThrough &amp;&amp; valueList-&gt;hasValue(lineThrough.ptr())) {
 845                 if (!newInlineStyle)
 846                     return true;
 847                 newValueList-&gt;removeAll(lineThrough.ptr());
 848                 extractedValueList-&gt;append(WTFMove(lineThrough));
 849             }
 850 
 851             if (extractedValueList-&gt;length()) {
 852                 conflicts = true;
 853                 if (newValueList-&gt;length())
 854                     newInlineStyle-&gt;setProperty(CSSPropertyTextDecoration, WTFMove(newValueList));
 855                 else
 856                     newInlineStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 857 
 858                 if (extractedStyle) {
 859                     bool isImportant = inlineStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration);
 860                     extractedStyle-&gt;setProperty(CSSPropertyTextDecoration, extractedValueList-&gt;cssText(), isImportant);
 861                 }
 862             }
 863         }
 864     }
 865 
 866     unsigned propertyCount = m_mutableStyle ? m_mutableStyle-&gt;propertyCount() : 0;
 867     for (unsigned i = 0; i &lt; propertyCount; ++i) {
 868         CSSPropertyID propertyID = m_mutableStyle-&gt;propertyAt(i).id();
 869 
 870         // We don&#39;t override whitespace property of a tab span because that would collapse the tab into a space.
 871         if (propertyID == CSSPropertyWhiteSpace &amp;&amp; isTabSpanNode(&amp;element))
 872             continue;
 873 
 874         if (propertyID == CSSPropertyWebkitTextDecorationsInEffect &amp;&amp; inlineStyle-&gt;getPropertyCSSValue(CSSPropertyTextDecoration)) {
 875             if (!newInlineStyle)
 876                 return true;
 877             conflicts = true;
 878             newInlineStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 879             if (extractedStyle)
 880                 extractedStyle-&gt;setProperty(CSSPropertyTextDecoration, inlineStyle-&gt;getPropertyValue(CSSPropertyTextDecoration), inlineStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration));
 881         }
 882 
 883         if (!inlineStyle-&gt;getPropertyCSSValue(propertyID))
 884             continue;
 885 
 886         if (propertyID == CSSPropertyUnicodeBidi &amp;&amp; inlineStyle-&gt;getPropertyCSSValue(CSSPropertyDirection)) {
 887             if (!newInlineStyle)
 888                 return true;
 889             conflicts = true;
 890             newInlineStyle-&gt;removeProperty(CSSPropertyDirection);
 891             if (extractedStyle)
 892                 extractedStyle-&gt;setProperty(propertyID, inlineStyle-&gt;getPropertyValue(propertyID), inlineStyle-&gt;propertyIsImportant(propertyID));
 893         }
 894 
 895         if (!newInlineStyle)
 896             return true;
 897 
 898         conflicts = true;
 899         newInlineStyle-&gt;removeProperty(propertyID);
 900         if (extractedStyle)
 901             extractedStyle-&gt;setProperty(propertyID, inlineStyle-&gt;getPropertyValue(propertyID), inlineStyle-&gt;propertyIsImportant(propertyID));
 902     }
 903 
 904     return conflicts;
 905 }
 906 
 907 static const Vector&lt;const HTMLElementEquivalent*&gt;&amp; htmlElementEquivalents()
 908 {
 909     static const auto equivalents = makeNeverDestroyed(Vector&lt;const HTMLElementEquivalent*&gt; {
 910         new HTMLElementEquivalent(CSSPropertyFontWeight, CSSValueBold, HTMLNames::bTag),
 911         new HTMLElementEquivalent(CSSPropertyFontWeight, CSSValueBold, HTMLNames::strongTag),
 912         new HTMLElementEquivalent(CSSPropertyVerticalAlign, CSSValueSub, HTMLNames::subTag),
 913         new HTMLElementEquivalent(CSSPropertyVerticalAlign, CSSValueSuper, HTMLNames::supTag),
 914         new HTMLElementEquivalent(CSSPropertyFontStyle, CSSValueItalic, HTMLNames::iTag),
 915         new HTMLElementEquivalent(CSSPropertyFontStyle, CSSValueItalic, HTMLNames::emTag),
 916 
 917         new HTMLTextDecorationEquivalent(CSSValueUnderline, HTMLNames::uTag),
 918         new HTMLTextDecorationEquivalent(CSSValueLineThrough, HTMLNames::sTag),
 919         new HTMLTextDecorationEquivalent(CSSValueLineThrough, HTMLNames::strikeTag),
 920     });
 921     return equivalents;
 922 }
 923 
 924 
 925 bool EditingStyle::conflictsWithImplicitStyleOfElement(HTMLElement&amp; element, EditingStyle* extractedStyle, ShouldExtractMatchingStyle shouldExtractMatchingStyle) const
 926 {
 927     if (isEmpty())
 928         return false;
 929 
 930     for (auto&amp; equivalent : htmlElementEquivalents()) {
 931         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;propertyExistsInStyle(*this)
 932             &amp;&amp; (shouldExtractMatchingStyle == ExtractMatchingStyle || !equivalent-&gt;valueIsPresentInStyle(element, *this))) {
 933             if (extractedStyle)
 934                 equivalent-&gt;addToStyle(&amp;element, extractedStyle);
 935             return true;
 936         }
 937     }
 938     return false;
 939 }
 940 
 941 static const Vector&lt;const HTMLAttributeEquivalent*&gt;&amp; htmlAttributeEquivalents()
 942 {
 943     static const auto equivalents = makeNeverDestroyed(Vector&lt;const HTMLAttributeEquivalent*&gt; {
 944         // elementIsStyledSpanOrHTMLEquivalent depends on the fact each HTMLAttriuteEquivalent matches exactly one attribute
 945         // of exactly one element except dirAttr.
 946         new HTMLAttributeEquivalent(CSSPropertyColor, HTMLNames::fontTag, HTMLNames::colorAttr),
 947         new HTMLAttributeEquivalent(CSSPropertyFontFamily, HTMLNames::fontTag, HTMLNames::faceAttr),
 948         new HTMLFontSizeEquivalent,
 949 
 950         new HTMLAttributeEquivalent(CSSPropertyDirection, HTMLNames::dirAttr),
 951         new HTMLAttributeEquivalent(CSSPropertyUnicodeBidi, HTMLNames::dirAttr),
 952     });
 953     return equivalents;
 954 }
 955 
 956 bool EditingStyle::conflictsWithImplicitStyleOfAttributes(HTMLElement&amp; element) const
 957 {
 958     if (isEmpty())
 959         return false;
 960 
 961     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
 962         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;propertyExistsInStyle(*this) &amp;&amp; !equivalent-&gt;valueIsPresentInStyle(element, *this))
 963             return true;
 964     }
 965 
 966     return false;
 967 }
 968 
 969 bool EditingStyle::extractConflictingImplicitStyleOfAttributes(HTMLElement&amp; element, ShouldPreserveWritingDirection shouldPreserveWritingDirection,
 970     EditingStyle* extractedStyle, Vector&lt;QualifiedName&gt;&amp; conflictingAttributes, ShouldExtractMatchingStyle shouldExtractMatchingStyle) const
 971 {
 972     // HTMLAttributeEquivalent::addToStyle doesn&#39;t support unicode-bidi and direction properties
 973     ASSERT(!extractedStyle || shouldPreserveWritingDirection == PreserveWritingDirection);
 974     if (!m_mutableStyle)
 975         return false;
 976 
 977     bool removed = false;
 978     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
 979         // unicode-bidi and direction are pushed down separately so don&#39;t push down with other styles.
 980         if (shouldPreserveWritingDirection == PreserveWritingDirection &amp;&amp; equivalent-&gt;attributeName() == HTMLNames::dirAttr)
 981             continue;
 982 
 983         if (!equivalent-&gt;matches(element) || !equivalent-&gt;propertyExistsInStyle(*this)
 984             || (shouldExtractMatchingStyle == DoNotExtractMatchingStyle &amp;&amp; equivalent-&gt;valueIsPresentInStyle(element, *this)))
 985             continue;
 986 
 987         if (extractedStyle)
 988             equivalent-&gt;addToStyle(&amp;element, extractedStyle);
 989         conflictingAttributes.append(equivalent-&gt;attributeName());
 990         removed = true;
 991     }
 992 
 993     return removed;
 994 }
 995 
 996 bool EditingStyle::styleIsPresentInComputedStyleOfNode(Node&amp; node) const
 997 {
 998     if (isEmpty())
 999         return true;
1000     ComputedStyleExtractor computedStyle(&amp;node);
1001 
1002     bool shouldAddUnderline = underlineChange() == TextDecorationChange::Add;
1003     bool shouldAddLineThrough = strikeThroughChange() == TextDecorationChange::Add;
1004     if (shouldAddUnderline || shouldAddLineThrough) {
1005         bool hasUnderline = false;
1006         bool hasLineThrough = false;
1007         if (RefPtr&lt;CSSValue&gt; value = computedStyle.propertyValue(CSSPropertyTextDecoration)) {
1008             if (value-&gt;isValueList()) {
1009                 auto&amp; cssValuePool = CSSValuePool::singleton();
1010                 const CSSValueList&amp; valueList = downcast&lt;CSSValueList&gt;(*value);
1011                 hasUnderline = valueList.hasValue(cssValuePool.createIdentifierValue(CSSValueUnderline).ptr());
1012                 hasLineThrough = valueList.hasValue(cssValuePool.createIdentifierValue(CSSValueLineThrough).ptr());
1013             }
1014         }
1015         if ((shouldAddUnderline &amp;&amp; !hasUnderline) || (shouldAddLineThrough &amp;&amp; !hasLineThrough))
1016             return false;
1017     }
1018 
1019     return !m_mutableStyle || getPropertiesNotIn(*m_mutableStyle, computedStyle)-&gt;isEmpty();
1020 }
1021 
1022 bool EditingStyle::elementIsStyledSpanOrHTMLEquivalent(const HTMLElement&amp; element)
1023 {
1024     bool elementIsSpanOrElementEquivalent = false;
1025     if (element.hasTagName(HTMLNames::spanTag))
1026         elementIsSpanOrElementEquivalent = true;
1027     else {
1028         for (auto&amp; equivalent : htmlElementEquivalents()) {
1029             if (equivalent-&gt;matches(element)) {
1030                 elementIsSpanOrElementEquivalent = true;
1031                 break;
1032             }
1033         }
1034     }
1035 
1036     if (!element.hasAttributes())
1037         return elementIsSpanOrElementEquivalent; // span, b, etc... without any attributes
1038 
1039     unsigned matchedAttributes = 0;
1040     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1041         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;attributeName() != HTMLNames::dirAttr)
1042             matchedAttributes++;
1043     }
1044 
1045     if (!elementIsSpanOrElementEquivalent &amp;&amp; !matchedAttributes)
1046         return false; // element is not a span, a html element equivalent, or font element.
1047 
1048     if (element.attributeWithoutSynchronization(HTMLNames::classAttr) == AppleStyleSpanClass)
1049         matchedAttributes++;
1050 
1051     if (element.hasAttribute(HTMLNames::styleAttr)) {
1052         if (const StyleProperties* style = element.inlineStyle()) {
1053             unsigned propertyCount = style-&gt;propertyCount();
1054             for (unsigned i = 0; i &lt; propertyCount; ++i) {
1055                 if (!isEditingProperty(style-&gt;propertyAt(i).id()))
1056                     return false;
1057             }
1058         }
1059         matchedAttributes++;
1060     }
1061 
1062     // font with color attribute, span with style attribute, etc...
1063     ASSERT(matchedAttributes &lt;= element.attributeCount());
1064     return matchedAttributes &gt;= element.attributeCount();
1065 }
1066 
1067 void EditingStyle::prepareToApplyAt(const Position&amp; position, ShouldPreserveWritingDirection shouldPreserveWritingDirection)
1068 {
1069     if (!m_mutableStyle)
1070         return;
1071 
1072     // ReplaceSelectionCommand::handleStyleSpans() requires that this function only removes the editing style.
1073     // If this function was modified in the future to delete all redundant properties, then add a boolean value to indicate
1074     // which one of editingStyleAtPosition or computedStyle is called.
1075     auto editingStyleAtPosition = EditingStyle::create(position, EditingPropertiesInEffect);
1076     StyleProperties* styleAtPosition = editingStyleAtPosition-&gt;m_mutableStyle.get();
1077 
1078     RefPtr&lt;CSSValue&gt; unicodeBidi;
1079     RefPtr&lt;CSSValue&gt; direction;
1080     if (shouldPreserveWritingDirection == PreserveWritingDirection) {
1081         unicodeBidi = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi);
1082         direction = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyDirection);
1083     }
1084 
1085     removeEquivalentProperties(*styleAtPosition);
1086 
1087     if (textAlignResolvingStartAndEnd(*m_mutableStyle) == textAlignResolvingStartAndEnd(*styleAtPosition))
1088         m_mutableStyle-&gt;removeProperty(CSSPropertyTextAlign);
1089 
1090     if (equalIgnoringSemanticColor(textColorFromStyle(*m_mutableStyle), textColorFromStyle(*styleAtPosition)))
1091         m_mutableStyle-&gt;removeProperty(CSSPropertyColor);
1092 
1093     if (equalIgnoringSemanticColor(caretColorFromStyle(*m_mutableStyle), caretColorFromStyle(*styleAtPosition)))
1094         m_mutableStyle-&gt;removeProperty(CSSPropertyCaretColor);
1095 
1096     if (hasTransparentBackgroundColor(m_mutableStyle.get())
1097         || cssValueToColor(m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor).get()) == rgbaBackgroundColorInEffect(position.containerNode()))
1098         m_mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1099 
1100     if (is&lt;CSSPrimitiveValue&gt;(unicodeBidi)) {
1101         m_mutableStyle-&gt;setProperty(CSSPropertyUnicodeBidi, static_cast&lt;CSSValueID&gt;(downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID()));
1102         if (is&lt;CSSPrimitiveValue&gt;(direction))
1103             m_mutableStyle-&gt;setProperty(CSSPropertyDirection, static_cast&lt;CSSValueID&gt;(downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID()));
1104     }
1105 }
1106 
1107 void EditingStyle::mergeTypingStyle(Document&amp; document)
1108 {
1109     RefPtr&lt;EditingStyle&gt; typingStyle = document.frame()-&gt;selection().typingStyle();
1110     if (!typingStyle || typingStyle == this)
1111         return;
1112 
1113     mergeStyle(typingStyle-&gt;style(), OverrideValues);
1114 }
1115 
1116 void EditingStyle::mergeInlineStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude)
1117 {
1118     if (!element.inlineStyle())
1119         return;
1120 
1121     switch (propertiesToInclude) {
1122     case AllProperties:
1123         mergeStyle(element.inlineStyle(), mode);
1124         return;
1125     case OnlyEditingInheritableProperties:
1126         mergeStyle(copyEditingProperties(element.inlineStyle(), OnlyInheritableEditingProperties).ptr(), mode);
1127         return;
1128     case EditingPropertiesInEffect:
1129         mergeStyle(copyEditingProperties(element.inlineStyle(), AllEditingProperties).ptr(), mode);
1130         return;
1131     }
1132 }
1133 
1134 static inline bool elementMatchesAndPropertyIsNotInInlineStyleDecl(const HTMLElementEquivalent&amp; equivalent, const StyledElement&amp; element,
1135     EditingStyle::CSSPropertyOverrideMode mode, EditingStyle&amp; style)
1136 {
1137     if (!equivalent.matches(element))
1138         return false;
1139     if (mode != EditingStyle::OverrideValues &amp;&amp; equivalent.propertyExistsInStyle(style))
1140         return false;
1141 
1142     return !element.inlineStyle() || !equivalent.propertyExistsInStyle(EditingStyle::create(element.inlineStyle()).get());
1143 }
1144 
1145 static RefPtr&lt;MutableStyleProperties&gt; extractEditingProperties(const StyleProperties* style, EditingStyle::PropertiesToInclude propertiesToInclude)
1146 {
1147     if (!style)
1148         return nullptr;
1149 
1150     switch (propertiesToInclude) {
1151     case EditingStyle::OnlyEditingInheritableProperties:
1152         return copyEditingProperties(style, OnlyInheritableEditingProperties);
1153     case EditingStyle::AllProperties:
1154     case EditingStyle::EditingPropertiesInEffect:
1155         break;
1156     }
1157     return copyEditingProperties(style, AllEditingProperties);
1158 }
1159 
1160 void EditingStyle::mergeInlineAndImplicitStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude, StandardFontFamilySerializationMode standardFontFamilySerializationMode)
1161 {
1162     auto styleFromRules = EditingStyle::create();
1163     styleFromRules-&gt;mergeStyleFromRulesForSerialization(element, standardFontFamilySerializationMode);
1164 
1165     if (element.inlineStyle())
1166         styleFromRules-&gt;m_mutableStyle-&gt;mergeAndOverrideOnConflict(*element.inlineStyle());
1167 
1168     styleFromRules-&gt;m_mutableStyle = extractEditingProperties(styleFromRules-&gt;m_mutableStyle.get(), propertiesToInclude);
1169     mergeStyle(styleFromRules-&gt;m_mutableStyle.get(), mode);
1170 
1171     for (auto&amp; equivalent : htmlElementEquivalents()) {
1172         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1173             equivalent-&gt;addToStyle(&amp;element, this);
1174     }
1175 
1176     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1177         if (equivalent-&gt;attributeName() == HTMLNames::dirAttr)
1178             continue; // We don&#39;t want to include directionality
1179         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1180             equivalent-&gt;addToStyle(&amp;element, this);
1181     }
1182 }
1183 
1184 Ref&lt;EditingStyle&gt; EditingStyle::wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate, StandardFontFamilySerializationMode standardFontFamilySerializationMode)
1185 {
1186     if (shouldAnnotate) {
1187         auto wrappingStyle = EditingStyle::create(&amp;context, EditingStyle::EditingPropertiesInEffect);
1188 
1189         // Styles that Mail blockquotes contribute should only be placed on the Mail blockquote,
1190         // to help us differentiate those styles from ones that the user has applied.
1191         // This helps us get the color of content pasted into blockquotes right.
1192         wrappingStyle-&gt;removeStyleAddedByNode(enclosingNodeOfType(firstPositionInOrBeforeNode(&amp;context), isMailBlockquote, CanCrossEditingBoundary));
1193 
1194         // Call collapseTextDecorationProperties first or otherwise it&#39;ll copy the value over from in-effect to text-decorations.
1195         wrappingStyle-&gt;collapseTextDecorationProperties();
1196 
1197         return wrappingStyle;
1198     }
1199 
1200     auto wrappingStyle = EditingStyle::create();
1201 
1202     // When not annotating for interchange, we only preserve inline style declarations.
1203     for (Node* node = &amp;context; node &amp;&amp; !node-&gt;isDocumentNode(); node = node-&gt;parentNode()) {
1204         if (is&lt;StyledElement&gt;(*node) &amp;&amp; !isMailBlockquote(node))
1205             wrappingStyle-&gt;mergeInlineAndImplicitStyleOfElement(downcast&lt;StyledElement&gt;(*node), DoNotOverrideValues, EditingPropertiesInEffect, standardFontFamilySerializationMode);
1206     }
1207 
1208     return wrappingStyle;
1209 }
1210 
1211 
1212 static void mergeTextDecorationValues(CSSValueList&amp; mergedValue, const CSSValueList&amp; valueToMerge)
1213 {
1214     auto&amp; cssValuePool = CSSValuePool::singleton();
1215     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1216     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1217 
1218     if (valueToMerge.hasValue(underline.ptr()) &amp;&amp; !mergedValue.hasValue(underline.ptr()))
1219         mergedValue.append(WTFMove(underline));
1220 
1221     if (valueToMerge.hasValue(lineThrough.ptr()) &amp;&amp; !mergedValue.hasValue(lineThrough.ptr()))
1222         mergedValue.append(WTFMove(lineThrough));
1223 }
1224 
1225 void EditingStyle::mergeStyle(const StyleProperties* style, CSSPropertyOverrideMode mode)
1226 {
1227     if (!style)
1228         return;
1229 
1230     if (!m_mutableStyle) {
1231         m_mutableStyle = style-&gt;mutableCopy();
1232         return;
1233     }
1234 
1235     unsigned propertyCount = style-&gt;propertyCount();
1236     for (unsigned i = 0; i &lt; propertyCount; ++i) {
1237         StyleProperties::PropertyReference property = style-&gt;propertyAt(i);
1238         RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(property.id());
1239 
1240         // text decorations never override values.
1241         if ((property.id() == CSSPropertyTextDecoration || property.id() == CSSPropertyWebkitTextDecorationsInEffect)
1242             &amp;&amp; is&lt;CSSValueList&gt;(*property.value()) &amp;&amp; value) {
1243             if (is&lt;CSSValueList&gt;(*value)) {
1244                 auto newValue = downcast&lt;CSSValueList&gt;(*value).copy();
1245                 mergeTextDecorationValues(newValue, downcast&lt;CSSValueList&gt;(*property.value()));
1246                 m_mutableStyle-&gt;setProperty(property.id(), WTFMove(newValue), property.isImportant());
1247                 continue;
1248             }
1249             value = nullptr; // text-decoration: none is equivalent to not having the property.
1250         }
1251 
1252         if (mode == OverrideValues || (mode == DoNotOverrideValues &amp;&amp; !value))
1253             m_mutableStyle-&gt;setProperty(property.id(), property.value(), property.isImportant());
1254     }
1255 
1256     int oldFontSizeDelta = m_fontSizeDelta;
1257     extractFontSizeDelta();
1258     m_fontSizeDelta += oldFontSizeDelta;
1259 }
1260 
1261 static Ref&lt;MutableStyleProperties&gt; styleFromMatchedRulesForElement(Element&amp; element, unsigned rulesToInclude)
1262 {
1263     auto style = MutableStyleProperties::create();
1264     for (auto&amp; matchedRule : element.styleResolver().styleRulesForElement(&amp;element, rulesToInclude))
1265         style-&gt;mergeAndOverrideOnConflict(matchedRule-&gt;properties());
1266 
1267     return style;
1268 }
1269 
1270 void EditingStyle::mergeStyleFromRules(StyledElement&amp; element)
1271 {
1272     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element,
1273         Style::Resolver::AuthorCSSRules);
1274     // Styles from the inline style declaration, held in the variable &quot;style&quot;, take precedence
1275     // over those from matched rules.
1276     if (m_mutableStyle)
1277         styleFromMatchedRules-&gt;mergeAndOverrideOnConflict(*m_mutableStyle);
1278 
1279     clear();
1280     m_mutableStyle = styleFromMatchedRules;
1281 }
1282 
1283 static String familyNameFromCSSPrimitiveValue(const CSSPrimitiveValue&amp; primitiveValue)
1284 {
1285     if (!primitiveValue.isFontFamily())
1286         return { };
1287     return primitiveValue.fontFamily().familyName;
1288 }
1289 
1290 static String loneFontFamilyName(const CSSValue&amp; value)
1291 {
1292     if (is&lt;CSSPrimitiveValue&gt;(value))
1293         return familyNameFromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1294 
1295     if (!is&lt;CSSValueList&gt;(value) || downcast&lt;CSSValueList&gt;(value).length() != 1)
1296         return { };
1297 
1298     auto&amp; item = *downcast&lt;CSSValueList&gt;(value).item(0);
1299     if (!is&lt;CSSPrimitiveValue&gt;(item))
1300         return { };
1301 
1302     return familyNameFromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(item));
1303 }
1304 
1305 void EditingStyle::mergeStyleFromRulesForSerialization(StyledElement&amp; element, StandardFontFamilySerializationMode standardFontFamilySerializationMode)
1306 {
1307     mergeStyleFromRules(element);
1308 
1309     // The property value, if it&#39;s a percentage, may not reflect the actual computed value.
1310     // For example: style=&quot;height: 1%; overflow: visible;&quot; in quirksmode
1311     // FIXME: There are others like this, see &lt;rdar://problem/5195123&gt; Slashdot copy/paste fidelity problem
1312     auto fromComputedStyle = MutableStyleProperties::create();
1313     ComputedStyleExtractor computedStyle(&amp;element);
1314 
1315     bool shouldRemoveFontFamily = false;
1316     {
1317         unsigned propertyCount = m_mutableStyle-&gt;propertyCount();
1318         for (unsigned i = 0; i &lt; propertyCount; ++i) {
1319             StyleProperties::PropertyReference property = m_mutableStyle-&gt;propertyAt(i);
1320             CSSValue&amp; value = *property.value();
1321             if (property.id() == CSSPropertyFontFamily) {
1322                 auto familyName = loneFontFamilyName(value);
1323                 if (FontCache::isSystemFontForbiddenForEditing(familyName)
1324                     || (standardFontFamilySerializationMode == StandardFontFamilySerializationMode::Strip &amp;&amp; familyName == standardFamily))
1325                     shouldRemoveFontFamily = true;
1326                 continue;
1327             }
1328             if (!is&lt;CSSPrimitiveValue&gt;(value))
1329                 continue;
1330             if (downcast&lt;CSSPrimitiveValue&gt;(value).isPercentage()) {
1331                 if (auto computedPropertyValue = computedStyle.propertyValue(property.id()))
1332                     fromComputedStyle-&gt;addParsedProperty(CSSProperty(property.id(), WTFMove(computedPropertyValue)));
1333             }
1334         }
1335     }
1336     if (shouldRemoveFontFamily) {
1337         m_mutableStyle-&gt;removeProperty(CSSPropertyFontFamily);
1338         fromComputedStyle-&gt;removeProperty(CSSPropertyFontFamily);
1339     }
1340     m_mutableStyle-&gt;mergeAndOverrideOnConflict(fromComputedStyle.get());
1341 }
1342 
1343 static void removePropertiesInStyle(MutableStyleProperties* styleToRemovePropertiesFrom, MutableStyleProperties* style)
1344 {
1345     unsigned propertyCount = style-&gt;propertyCount();
1346     Vector&lt;CSSPropertyID&gt; propertiesToRemove(propertyCount);
1347     for (unsigned i = 0; i &lt; propertyCount; ++i)
1348         propertiesToRemove[i] = style-&gt;propertyAt(i).id();
1349 
1350     styleToRemovePropertiesFrom-&gt;removePropertiesInSet(propertiesToRemove.data(), propertiesToRemove.size());
1351 }
1352 
1353 void EditingStyle::removeStyleFromRulesAndContext(StyledElement&amp; element, Node* context)
1354 {
1355     if (!m_mutableStyle)
1356         return;
1357 
1358     // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
1359     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element, Style::Resolver::AllButEmptyCSSRules);
1360     if (styleFromMatchedRules &amp;&amp; !styleFromMatchedRules-&gt;isEmpty())
1361         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *styleFromMatchedRules);
1362 
1363     // 2. Remove style present in context and not overridden by matched rules.
1364     auto computedStyle = EditingStyle::create(context, EditingPropertiesInEffect);
1365     if (computedStyle-&gt;m_mutableStyle) {
1366         if (!computedStyle-&gt;m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor))
1367             computedStyle-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, CSSValueTransparent);
1368 
1369         removePropertiesInStyle(computedStyle-&gt;m_mutableStyle.get(), styleFromMatchedRules.get());
1370         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *computedStyle-&gt;m_mutableStyle);
1371     }
1372 
1373     // 3. If this element is a span and has display: inline or float: none, remove them unless they are overridden by rules.
1374     // These rules are added by serialization code to wrap text nodes.
1375     if (isStyleSpanOrSpanWithOnlyStyleAttribute(element)) {
1376         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyDisplay) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyDisplay) == CSSValueInline)
1377             m_mutableStyle-&gt;removeProperty(CSSPropertyDisplay);
1378         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyFloat) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyFloat) == CSSValueNone)
1379             m_mutableStyle-&gt;removeProperty(CSSPropertyFloat);
1380     }
1381 }
1382 
1383 void EditingStyle::removePropertiesInElementDefaultStyle(Element&amp; element)
1384 {
1385     if (!m_mutableStyle || m_mutableStyle-&gt;isEmpty())
1386         return;
1387 
1388     RefPtr&lt;MutableStyleProperties&gt; defaultStyle = styleFromMatchedRulesForElement(element, Style::Resolver::UAAndUserCSSRules);
1389 
1390     removePropertiesInStyle(m_mutableStyle.get(), defaultStyle.get());
1391 }
1392 
1393 template&lt;typename T&gt;
1394 void EditingStyle::removeEquivalentProperties(T&amp; style)
1395 {
1396     Vector&lt;CSSPropertyID&gt; propertiesToRemove;
1397     for (auto&amp; property : m_mutableStyle-&gt;m_propertyVector) {
1398         if (style.propertyMatches(property.id(), property.value()))
1399             propertiesToRemove.append(property.id());
1400     }
1401     // FIXME: This should use mass removal.
1402     for (auto&amp; property : propertiesToRemove)
1403         m_mutableStyle-&gt;removeProperty(property);
1404 }
1405 
1406 void EditingStyle::forceInline()
1407 {
1408     if (!m_mutableStyle)
1409         m_mutableStyle = MutableStyleProperties::create();
1410     const bool propertyIsImportant = true;
1411     m_mutableStyle-&gt;setProperty(CSSPropertyDisplay, CSSValueInline, propertyIsImportant);
1412 }
1413 
1414 void EditingStyle::addDisplayContents()
1415 {
1416     if (!m_mutableStyle)
1417         m_mutableStyle = MutableStyleProperties::create();
1418     m_mutableStyle-&gt;setProperty(CSSPropertyDisplay, CSSValueContents);
1419 }
1420 
1421 bool EditingStyle::convertPositionStyle()
1422 {
1423     if (!m_mutableStyle)
1424         return false;
1425 
1426     auto&amp; cssValuePool = CSSValuePool::singleton();
1427     RefPtr&lt;CSSPrimitiveValue&gt; sticky = cssValuePool.createIdentifierValue(CSSValueSticky);
1428     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, sticky.get())) {
1429         m_mutableStyle-&gt;setProperty(CSSPropertyPosition, cssValuePool.createIdentifierValue(CSSValueStatic), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyPosition));
1430         return false;
1431     }
1432     RefPtr&lt;CSSPrimitiveValue&gt; fixed = cssValuePool.createIdentifierValue(CSSValueFixed);
1433     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, fixed.get())) {
1434         m_mutableStyle-&gt;setProperty(CSSPropertyPosition, cssValuePool.createIdentifierValue(CSSValueAbsolute), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyPosition));
1435         return true;
1436     }
1437     RefPtr&lt;CSSPrimitiveValue&gt; absolute = cssValuePool.createIdentifierValue(CSSValueAbsolute);
1438     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, absolute.get()))
1439         return true;
1440     return false;
1441 }
1442 
1443 bool EditingStyle::isFloating()
1444 {
1445     RefPtr&lt;CSSValue&gt; v = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFloat);
1446     RefPtr&lt;CSSPrimitiveValue&gt; noneValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1447     return v &amp;&amp; !v-&gt;equals(*noneValue);
1448 }
1449 
1450 int EditingStyle::legacyFontSize(Document&amp; document) const
1451 {
1452     RefPtr&lt;CSSValue&gt; cssValue = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize);
1453     if (!is&lt;CSSPrimitiveValue&gt;(cssValue))
1454         return 0;
1455     return legacyFontSizeFromCSSValue(document, downcast&lt;CSSPrimitiveValue&gt;(cssValue.get()),
1456         m_shouldUseFixedDefaultFontSize, AlwaysUseLegacyFontSize);
1457 }
1458 
1459 bool EditingStyle::hasStyle(CSSPropertyID propertyID, const String&amp; value)
1460 {
1461     return EditingStyle::create(propertyID, value)-&gt;triStateOfStyle(this) != FalseTriState;
1462 }
1463 
1464 RefPtr&lt;EditingStyle&gt; EditingStyle::styleAtSelectionStart(const VisibleSelection&amp; selection, bool shouldUseBackgroundColorInEffect)
1465 {
1466     if (selection.isNone())
1467         return nullptr;
1468 
1469     Position position = adjustedSelectionStartForStyleComputation(selection);
1470 
1471     // If the pos is at the end of a text node, then this node is not fully selected.
1472     // Move it to the next deep equivalent position to avoid removing the style from this node.
1473     // e.g. if pos was at Position(&quot;hello&quot;, 5) in &lt;b&gt;hello&lt;div&gt;world&lt;/div&gt;&lt;/b&gt;, we want Position(&quot;world&quot;, 0) instead.
1474     // We only do this for range because caret at Position(&quot;hello&quot;, 5) in &lt;b&gt;hello&lt;/b&gt;world should give you font-weight: bold.
1475     Node* positionNode = position.containerNode();
1476     if (selection.isRange() &amp;&amp; positionNode &amp;&amp; positionNode-&gt;isTextNode() &amp;&amp; position.computeOffsetInContainerNode() == positionNode-&gt;maxCharacterOffset())
1477         position = nextVisuallyDistinctCandidate(position);
1478 
1479     Element* element = position.element();
1480     if (!element)
1481         return nullptr;
1482 
1483     auto style = EditingStyle::create(element, EditingStyle::AllProperties);
1484     style-&gt;mergeTypingStyle(element-&gt;document());
1485 
1486     // If background color is transparent, traverse parent nodes until we hit a different value or document root
1487     // Also, if the selection is a range, ignore the background color at the start of selection,
1488     // and find the background color of the common ancestor.
1489     if (shouldUseBackgroundColorInEffect &amp;&amp; (selection.isRange() || hasTransparentBackgroundColor(style-&gt;m_mutableStyle.get()))) {
1490         if (auto range = selection.toNormalizedRange()) {
1491             if (auto value = backgroundColorInEffect(range-&gt;commonAncestorContainer()))
1492                 style-&gt;setProperty(CSSPropertyBackgroundColor, value-&gt;cssText());
1493         }
1494     }
1495 
1496     return style;
1497 }
1498 
1499 WritingDirection EditingStyle::textDirectionForSelection(const VisibleSelection&amp; selection, EditingStyle* typingStyle, bool&amp; hasNestedOrMultipleEmbeddings)
1500 {
1501     hasNestedOrMultipleEmbeddings = true;
1502 
1503     if (selection.isNone())
1504         return WritingDirection::Natural;
1505 
1506     Position position = selection.start().downstream();
1507 
1508     Node* node = position.deprecatedNode();
1509     if (!node)
1510         return WritingDirection::Natural;
1511 
1512     Position end;
1513     if (selection.isRange()) {
1514         end = selection.end().upstream();
1515 
1516         Node* pastLast = Range::create(*end.document(), position.parentAnchoredEquivalent(), end.parentAnchoredEquivalent())-&gt;pastLastNode();
1517         for (Node* n = node; n &amp;&amp; n != pastLast; n = NodeTraversal::next(*n)) {
1518             if (!n-&gt;isStyledElement())
1519                 continue;
1520 
1521             RefPtr&lt;CSSValue&gt; unicodeBidi = ComputedStyleExtractor(n).propertyValue(CSSPropertyUnicodeBidi);
1522             if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
1523                 continue;
1524 
1525             CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
1526             if (unicodeBidiValue == CSSValueEmbed || unicodeBidiValue == CSSValueBidiOverride)
1527                 return WritingDirection::Natural;
1528         }
1529     }
1530 
1531     if (selection.isCaret()) {
1532         if (typingStyle) {
1533             if (auto direction = typingStyle-&gt;textDirection()) {
1534                 hasNestedOrMultipleEmbeddings = false;
1535                 return *direction;
1536             }
1537         }
1538         node = selection.visibleStart().deepEquivalent().deprecatedNode();
1539     }
1540 
1541     // The selection is either a caret with no typing attributes or a range in which no embedding is added, so just use the start position
1542     // to decide.
1543     Node* block = enclosingBlock(node);
1544     auto foundDirection = WritingDirection::Natural;
1545 
1546     for (; node != block; node = node-&gt;parentNode()) {
1547         if (!node-&gt;isStyledElement())
1548             continue;
1549 
1550         ComputedStyleExtractor computedStyle(node);
1551         RefPtr&lt;CSSValue&gt; unicodeBidi = computedStyle.propertyValue(CSSPropertyUnicodeBidi);
1552         if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
1553             continue;
1554 
1555         CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
1556         if (unicodeBidiValue == CSSValueNormal)
1557             continue;
1558 
1559         if (unicodeBidiValue == CSSValueBidiOverride)
1560             return WritingDirection::Natural;
1561 
1562         ASSERT(unicodeBidiValue == CSSValueEmbed);
1563         RefPtr&lt;CSSValue&gt; direction = computedStyle.propertyValue(CSSPropertyDirection);
1564         if (!is&lt;CSSPrimitiveValue&gt;(direction))
1565             continue;
1566 
1567         CSSValueID directionValue = downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID();
1568         if (directionValue != CSSValueLtr &amp;&amp; directionValue != CSSValueRtl)
1569             continue;
1570 
1571         if (foundDirection != WritingDirection::Natural)
1572             return WritingDirection::Natural;
1573 
1574         // In the range case, make sure that the embedding element persists until the end of the range.
1575         if (selection.isRange() &amp;&amp; !end.deprecatedNode()-&gt;isDescendantOf(*node))
1576             return WritingDirection::Natural;
1577 
1578         foundDirection = directionValue == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
1579     }
1580     hasNestedOrMultipleEmbeddings = false;
1581     return foundDirection;
1582 }
1583 
1584 Ref&lt;EditingStyle&gt; EditingStyle::inverseTransformColorIfNeeded(Element&amp; element)
1585 {
1586     auto* renderer = element.renderer();
1587     if (!m_mutableStyle || !renderer || !renderer-&gt;style().hasAppleColorFilter())
1588         return *this;
1589 
1590     bool hasColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyColor);
1591     bool hasCaretColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyCaretColor);
1592     bool hasBackgroundColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor);
1593     if (!hasColor &amp;&amp; !hasCaretColor &amp;&amp; !hasBackgroundColor)
1594         return *this;
1595 
1596     auto styleWithInvertedColors = copy();
1597     ASSERT(styleWithInvertedColors-&gt;m_mutableStyle);
1598 
1599     const auto&amp; colorFilter = renderer-&gt;style().appleColorFilter();
1600     auto invertedColor = [&amp;](CSSPropertyID propertyID) {
1601         Color newColor = cssValueToColor(extractPropertyValue(*m_mutableStyle, propertyID).get());
1602         colorFilter.inverseTransformColor(newColor);
1603         styleWithInvertedColors-&gt;m_mutableStyle-&gt;setProperty(propertyID, newColor.cssText());
1604     };
1605 
1606     if (hasColor)
1607         invertedColor(CSSPropertyColor);
1608 
1609     if (hasCaretColor)
1610         invertedColor(CSSPropertyCaretColor);
1611 
1612     if (hasBackgroundColor)
1613         invertedColor(CSSPropertyBackgroundColor);
1614 
1615     return styleWithInvertedColors;
1616 }
1617 
1618 static void reconcileTextDecorationProperties(MutableStyleProperties* style)
1619 {
1620     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = style-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
1621     RefPtr&lt;CSSValue&gt; textDecoration = style-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
1622     // We shouldn&#39;t have both text-decoration and -webkit-text-decorations-in-effect because that wouldn&#39;t make sense.
1623     ASSERT(!textDecorationsInEffect || !textDecoration);
1624     if (textDecorationsInEffect) {
1625         style-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText());
1626         style-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
1627         textDecoration = textDecorationsInEffect;
1628     }
1629 
1630     // If text-decoration is set to &quot;none&quot;, remove the property because we don&#39;t want to add redundant &quot;text-decoration: none&quot;.
1631     if (textDecoration &amp;&amp; !textDecoration-&gt;isValueList())
1632         style-&gt;removeProperty(CSSPropertyTextDecoration);
1633 }
1634 
1635 StyleChange::StyleChange(EditingStyle* style, const Position&amp; position)
1636     : m_applyBold(false)
1637     , m_applyItalic(false)
1638     , m_applyUnderline(false)
1639     , m_applyLineThrough(false)
1640     , m_applySubscript(false)
1641     , m_applySuperscript(false)
1642 {
1643     Document* document = position.deprecatedNode() ? &amp;position.deprecatedNode()-&gt;document() : 0;
1644     if (!style || style-&gt;isEmpty() || !document || !document-&gt;frame())
1645         return;
1646 
1647     Node* node = position.containerNode();
1648     if (!node)
1649         return;
1650 
1651     ComputedStyleExtractor computedStyle(node);
1652 
1653     // FIXME: take care of background-color in effect
1654     RefPtr&lt;MutableStyleProperties&gt; mutableStyle = style-&gt;style() ?
1655         getPropertiesNotIn(*style-&gt;style(), computedStyle) : MutableStyleProperties::create();
1656 
1657     reconcileTextDecorationProperties(mutableStyle.get());
1658     bool shouldStyleWithCSS = document-&gt;frame()-&gt;editor().shouldStyleWithCSS();
1659     if (!shouldStyleWithCSS)
1660         extractTextStyles(*document, *mutableStyle, computedStyle.useFixedFontDefaultSize());
1661 
1662     bool shouldAddUnderline = style-&gt;underlineChange() == TextDecorationChange::Add;
1663     bool shouldAddStrikeThrough = style-&gt;strikeThroughChange() == TextDecorationChange::Add;
1664     if (shouldAddUnderline || shouldAddStrikeThrough) {
1665         RefPtr&lt;CSSValue&gt; value = computedStyle.propertyValue(CSSPropertyWebkitTextDecorationsInEffect);
1666         if (!is&lt;CSSValueList&gt;(value))
1667             value = computedStyle.propertyValue(CSSPropertyTextDecoration);
1668 
1669         RefPtr&lt;CSSValueList&gt; valueList;
1670         if (is&lt;CSSValueList&gt;(value))
1671             valueList = downcast&lt;CSSValueList&gt;(value.get());
1672 
1673         auto&amp; cssValuePool = CSSValuePool::singleton();
1674         Ref&lt;CSSValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1675         bool hasUnderline = valueList &amp;&amp; valueList-&gt;hasValue(underline.ptr());
1676 
1677         Ref&lt;CSSValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1678         bool hasLineThrough = valueList &amp;&amp; valueList-&gt;hasValue(lineThrough.ptr());
1679 
1680         if (shouldStyleWithCSS) {
1681             valueList = valueList ? valueList-&gt;copy() : CSSValueList::createSpaceSeparated();
1682             if (shouldAddUnderline &amp;&amp; !hasUnderline)
1683                 valueList-&gt;append(WTFMove(underline));
1684             if (shouldAddStrikeThrough &amp;&amp; !hasLineThrough)
1685                 valueList-&gt;append(WTFMove(lineThrough));
1686             mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, valueList.get());
1687         } else {
1688             m_applyUnderline = shouldAddUnderline &amp;&amp; !hasUnderline;
1689             m_applyLineThrough = shouldAddStrikeThrough &amp;&amp; !hasLineThrough;
1690         }
1691     }
1692 
1693     // Changing the whitespace style in a tab span would collapse the tab into a space.
1694     if (isTabSpanTextNode(position.deprecatedNode()) || isTabSpanNode((position.deprecatedNode())))
1695         mutableStyle-&gt;removeProperty(CSSPropertyWhiteSpace);
1696 
1697     // If unicode-bidi is present in mutableStyle and direction is not, then add direction to mutableStyle.
1698     // FIXME: Shouldn&#39;t this be done in getPropertiesNotIn?
1699     if (mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi) &amp;&amp; !style-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyDirection))
1700         mutableStyle-&gt;setProperty(CSSPropertyDirection, style-&gt;style()-&gt;getPropertyValue(CSSPropertyDirection));
1701 
1702     if (!mutableStyle-&gt;isEmpty())
1703         m_cssStyle = mutableStyle;
1704 }
1705 
1706 bool StyleChange::operator==(const StyleChange&amp; other)
1707 {
1708     if (m_applyBold != other.m_applyBold
1709         || m_applyItalic != other.m_applyItalic
1710         || m_applyUnderline != other.m_applyUnderline
1711         || m_applyLineThrough != other.m_applyLineThrough
1712         || m_applySubscript != other.m_applySubscript
1713         || m_applySuperscript != other.m_applySuperscript
1714         || m_applyFontColor != other.m_applyFontColor
1715         || m_applyFontFace != other.m_applyFontFace
1716         || m_applyFontSize != other.m_applyFontSize)
1717         return false;
1718 
1719     return (!m_cssStyle &amp;&amp; !other.m_cssStyle)
1720         || (m_cssStyle &amp;&amp; other.m_cssStyle &amp;&amp; m_cssStyle-&gt;asText() == other.m_cssStyle-&gt;asText());
1721 }
1722 
1723 static void setTextDecorationProperty(MutableStyleProperties&amp; style, const CSSValueList* newTextDecoration, CSSPropertyID propertyID)
1724 {
1725     if (newTextDecoration-&gt;length())
1726         style.setProperty(propertyID, newTextDecoration-&gt;cssText(), style.propertyIsImportant(propertyID));
1727     else {
1728         // text-decoration: none is redundant since it does not remove any text decorations.
1729         style.removeProperty(propertyID);
1730     }
1731 }
1732 
1733 void StyleChange::extractTextStyles(Document&amp; document, MutableStyleProperties&amp; style, bool shouldUseFixedFontDefaultSize)
1734 {
1735     if (identifierForStyleProperty(style, CSSPropertyFontWeight) == CSSValueBold) {
1736         style.removeProperty(CSSPropertyFontWeight);
1737         m_applyBold = true;
1738     }
1739 
1740     int fontStyle = identifierForStyleProperty(style, CSSPropertyFontStyle);
1741     if (fontStyle == CSSValueItalic || fontStyle == CSSValueOblique) {
1742         style.removeProperty(CSSPropertyFontStyle);
1743         m_applyItalic = true;
1744     }
1745 
1746     // Assuming reconcileTextDecorationProperties has been called, there should not be -webkit-text-decorations-in-effect
1747     // Furthermore, text-decoration: none has been trimmed so that text-decoration property is always a CSSValueList.
1748     RefPtr&lt;CSSValue&gt; textDecoration = style.getPropertyCSSValue(CSSPropertyTextDecoration);
1749     if (is&lt;CSSValueList&gt;(textDecoration)) {
1750         auto&amp; cssValuePool = CSSValuePool::singleton();
1751         RefPtr&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1752         RefPtr&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1753 
1754         RefPtr&lt;CSSValueList&gt; newTextDecoration = downcast&lt;CSSValueList&gt;(*textDecoration).copy();
1755         if (newTextDecoration-&gt;removeAll(underline.get()))
1756             m_applyUnderline = true;
1757         if (newTextDecoration-&gt;removeAll(lineThrough.get()))
1758             m_applyLineThrough = true;
1759 
1760         // If trimTextDecorations, delete underline and line-through
1761         setTextDecorationProperty(style, newTextDecoration.get(), CSSPropertyTextDecoration);
1762     }
1763 
1764     int verticalAlign = identifierForStyleProperty(style, CSSPropertyVerticalAlign);
1765     switch (verticalAlign) {
1766     case CSSValueSub:
1767         style.removeProperty(CSSPropertyVerticalAlign);
1768         m_applySubscript = true;
1769         break;
1770     case CSSValueSuper:
1771         style.removeProperty(CSSPropertyVerticalAlign);
1772         m_applySuperscript = true;
1773         break;
1774     }
1775 
1776     if (style.getPropertyCSSValue(CSSPropertyColor)) {
1777         auto color = textColorFromStyle(style);
1778         if (color.isOpaque()) {
1779             m_applyFontColor = color.serialized();
1780             style.removeProperty(CSSPropertyColor);
1781         }
1782     }
1783 
1784     m_applyFontFace = style.getPropertyValue(CSSPropertyFontFamily);
1785     // Remove quotes for Outlook 2007 compatibility. See https://bugs.webkit.org/show_bug.cgi?id=79448
1786     m_applyFontFace.replaceWithLiteral(&#39;\&quot;&#39;, &quot;&quot;);
1787     style.removeProperty(CSSPropertyFontFamily);
1788 
1789     if (RefPtr&lt;CSSValue&gt; fontSize = style.getPropertyCSSValue(CSSPropertyFontSize)) {
1790         if (!is&lt;CSSPrimitiveValue&gt;(*fontSize))
1791             style.removeProperty(CSSPropertyFontSize); // Can&#39;t make sense of the number. Put no font size.
1792         else if (int legacyFontSize = legacyFontSizeFromCSSValue(document, downcast&lt;CSSPrimitiveValue&gt;(fontSize.get()),
1793                 shouldUseFixedFontDefaultSize, UseLegacyFontSizeOnlyIfPixelValuesMatch)) {
1794             m_applyFontSize = String::number(legacyFontSize);
1795             style.removeProperty(CSSPropertyFontSize);
1796         }
1797     }
1798 }
1799 
1800 static void diffTextDecorations(MutableStyleProperties&amp; style, CSSPropertyID propertID, CSSValue* refTextDecoration)
1801 {
1802     RefPtr&lt;CSSValue&gt; textDecoration = style.getPropertyCSSValue(propertID);
1803     if (!is&lt;CSSValueList&gt;(textDecoration) || !is&lt;CSSValueList&gt;(refTextDecoration))
1804         return;
1805 
1806     RefPtr&lt;CSSValueList&gt; newTextDecoration = downcast&lt;CSSValueList&gt;(*textDecoration).copy();
1807 
1808     for (auto&amp; value :  downcast&lt;CSSValueList&gt;(*refTextDecoration))
1809         newTextDecoration-&gt;removeAll(&amp;value.get());
1810 
1811     setTextDecorationProperty(style, newTextDecoration.get(), propertID);
1812 }
1813 
1814 static bool fontWeightIsBold(CSSValue&amp; fontWeight)
1815 {
1816     if (!is&lt;CSSPrimitiveValue&gt;(fontWeight))
1817         return false;
1818 
1819     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(fontWeight);
1820     switch (primitiveValue.valueID()) {
1821         case CSSValueNormal:
1822             return false;
1823         case CSSValueBold:
1824             return true;
1825         default:
1826             break;
1827     }
1828 
1829     ASSERT(primitiveValue.isNumber());
1830     return primitiveValue.floatValue() &gt;= static_cast&lt;float&gt;(boldThreshold());
1831 }
1832 
1833 template&lt;typename T&gt;
1834 static bool fontWeightIsBold(T&amp; style)
1835 {
1836     RefPtr&lt;CSSValue&gt; fontWeight = extractPropertyValue(style, CSSPropertyFontWeight);
1837     return fontWeight &amp;&amp; fontWeightIsBold(*fontWeight);
1838 }
1839 
1840 template&lt;typename T&gt;
1841 static Ref&lt;MutableStyleProperties&gt; extractPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1842 {
1843     auto result = EditingStyle::create(&amp;styleWithRedundantProperties);
1844     result-&gt;removeEquivalentProperties(baseStyle);
1845     ASSERT(result-&gt;style());
1846     Ref&lt;MutableStyleProperties&gt; mutableStyle = *result-&gt;style();
1847 
1848     RefPtr&lt;CSSValue&gt; baseTextDecorationsInEffect = extractPropertyValue(baseStyle, CSSPropertyWebkitTextDecorationsInEffect);
1849     diffTextDecorations(mutableStyle, CSSPropertyTextDecoration, baseTextDecorationsInEffect.get());
1850     diffTextDecorations(mutableStyle, CSSPropertyWebkitTextDecorationsInEffect, baseTextDecorationsInEffect.get());
1851 
1852     if (extractPropertyValue(baseStyle, CSSPropertyFontWeight) &amp;&amp; fontWeightIsBold(mutableStyle) == fontWeightIsBold(baseStyle))
1853         mutableStyle-&gt;removeProperty(CSSPropertyFontWeight);
1854 
1855     if (extractPropertyValue(baseStyle, CSSPropertyColor) &amp;&amp; equalIgnoringSemanticColor(textColorFromStyle(mutableStyle), textColorFromStyle(baseStyle)))
1856         mutableStyle-&gt;removeProperty(CSSPropertyColor);
1857 
1858     if (extractPropertyValue(baseStyle, CSSPropertyCaretColor) &amp;&amp; equalIgnoringSemanticColor(caretColorFromStyle(mutableStyle), caretColorFromStyle(baseStyle)))
1859         mutableStyle-&gt;removeProperty(CSSPropertyCaretColor);
1860 
1861     if (extractPropertyValue(baseStyle, CSSPropertyTextAlign)
1862         &amp;&amp; textAlignResolvingStartAndEnd(mutableStyle) == textAlignResolvingStartAndEnd(baseStyle))
1863         mutableStyle-&gt;removeProperty(CSSPropertyTextAlign);
1864 
1865     if (extractPropertyValue(baseStyle, CSSPropertyBackgroundColor) &amp;&amp; equalIgnoringSemanticColor(backgroundColorFromStyle(mutableStyle), backgroundColorFromStyle(baseStyle)))
1866         mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1867 
1868     return mutableStyle;
1869 }
1870 
1871 template&lt;typename T&gt;
1872 Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1873 {
1874     return extractPropertiesNotIn(styleWithRedundantProperties, baseStyle);
1875 }
1876 
1877 static bool isCSSValueLength(CSSPrimitiveValue* value)
1878 {
1879     return value-&gt;isFontIndependentLength();
1880 }
1881 
1882 int legacyFontSizeFromCSSValue(Document&amp; document, CSSPrimitiveValue* value, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode mode)
1883 {
1884     if (isCSSValueLength(value)) {
1885         int pixelFontSize = value-&gt;intValue(CSSUnitType::CSS_PX);
1886         int legacyFontSize = Style::legacyFontSizeForPixelSize(pixelFontSize, shouldUseFixedFontDefaultSize, document);
1887         // Use legacy font size only if pixel value matches exactly to that of legacy font size.
1888         int cssPrimitiveEquivalent = legacyFontSize - 1 + CSSValueXSmall;
1889         if (mode == AlwaysUseLegacyFontSize || Style::fontSizeForKeyword(cssPrimitiveEquivalent, shouldUseFixedFontDefaultSize, document) == pixelFontSize)
1890             return legacyFontSize;
1891 
1892         return 0;
1893     }
1894 
1895     if (CSSValueXSmall &lt;= value-&gt;valueID() &amp;&amp; value-&gt;valueID() &lt;= CSSValueWebkitXxxLarge)
1896         return value-&gt;valueID() - CSSValueXSmall + 1;
1897 
1898     return 0;
1899 }
1900 
1901 static bool isTransparentColorValue(CSSValue* value)
1902 {
1903     if (!value)
1904         return true;
1905     if (!is&lt;CSSPrimitiveValue&gt;(*value))
1906         return false;
1907     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
1908     if (primitiveValue.isRGBColor())
1909         return !primitiveValue.color().isVisible();
1910     return primitiveValue.valueID() == CSSValueTransparent;
1911 }
1912 
1913 bool hasTransparentBackgroundColor(StyleProperties* style)
1914 {
1915     return isTransparentColorValue(style-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor).get());
1916 }
1917 
1918 RefPtr&lt;CSSValue&gt; backgroundColorInEffect(Node* node)
1919 {
1920     for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
1921         if (auto value = ComputedStyleExtractor(ancestor).propertyValue(CSSPropertyBackgroundColor)) {
1922             if (!isTransparentColorValue(value.get()))
1923                 return value;
1924         }
1925     }
1926     return nullptr;
1927 }
1928 
1929 }
    </pre>
  </body>
</html>
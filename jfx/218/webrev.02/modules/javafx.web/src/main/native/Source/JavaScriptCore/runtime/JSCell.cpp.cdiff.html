<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCell.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCast.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCell.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCell.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,11 ***</span>
  #include &quot;JSCast.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSString.h&quot;
  #include &quot;JSObject.h&quot;
  #include &quot;NumberObject.h&quot;
<span class="line-removed">- #include &quot;WebAssemblyToJSCallee.h&quot;</span>
  #include &lt;wtf/LockAlgorithmInlines.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
  
  namespace JSC {
  
<span class="line-new-header">--- 28,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,21 ***</span>
  
  void JSCell::analyzeHeap(JSCell*, HeapAnalyzer&amp;)
  {
  }
  
<span class="line-modified">! bool JSCell::getString(ExecState* exec, String&amp; stringValue) const</span>
  {
      if (!isString())
          return false;
<span class="line-modified">!     stringValue = static_cast&lt;const JSString*&gt;(this)-&gt;value(exec);</span>
      return true;
  }
  
<span class="line-modified">! String JSCell::getString(ExecState* exec) const</span>
  {
<span class="line-modified">!     return isString() ? static_cast&lt;const JSString*&gt;(this)-&gt;value(exec) : String();</span>
  }
  
  JSObject* JSCell::getObject()
  {
      return isObject() ? asObject(this) : 0;
<span class="line-new-header">--- 65,21 ---</span>
  
  void JSCell::analyzeHeap(JSCell*, HeapAnalyzer&amp;)
  {
  }
  
<span class="line-modified">! bool JSCell::getString(JSGlobalObject* globalObject, String&amp; stringValue) const</span>
  {
      if (!isString())
          return false;
<span class="line-modified">!     stringValue = static_cast&lt;const JSString*&gt;(this)-&gt;value(globalObject);</span>
      return true;
  }
  
<span class="line-modified">! String JSCell::getString(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return isString() ? static_cast&lt;const JSString*&gt;(this)-&gt;value(globalObject) : String();</span>
  }
  
  JSObject* JSCell::getObject()
  {
      return isObject() ? asObject(this) : 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,197 ***</span>
      constructData.js.scope = nullptr;
      constructData.native.function = nullptr;
      return ConstructType::None;
  }
  
<span class="line-modified">! bool JSCell::put(JSCell* cell, ExecState* exec, PropertyName identifier, JSValue value, PutPropertySlot&amp; slot)</span>
  {
      if (cell-&gt;isString() || cell-&gt;isSymbol() || cell-&gt;isBigInt())
<span class="line-modified">!         return JSValue(cell).putToPrimitive(exec, identifier, value, slot);</span>
  
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;put(thisObject, exec, identifier, value, slot);</span>
  }
  
<span class="line-modified">! bool JSCell::putByIndex(JSCell* cell, ExecState* exec, unsigned identifier, JSValue value, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (cell-&gt;isString() || cell-&gt;isSymbol() || cell-&gt;isBigInt()) {
          PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified">!         return JSValue(cell).putToPrimitive(exec, Identifier::from(vm, identifier), value, slot);</span>
      }
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(vm)-&gt;putByIndex(thisObject, exec, identifier, value, shouldThrow);</span>
  }
  
<span class="line-modified">! bool JSCell::deleteProperty(JSCell* cell, ExecState* exec, PropertyName identifier)</span>
  {
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;deleteProperty(thisObject, exec, identifier);</span>
  }
  
<span class="line-modified">! bool JSCell::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned identifier)</span>
  {
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;deletePropertyByIndex(thisObject, exec, identifier);</span>
  }
  
<span class="line-modified">! JSValue JSCell::toThis(JSCell* cell, ExecState* exec, ECMAMode ecmaMode)</span>
  {
      if (ecmaMode == StrictMode)
          return cell;
<span class="line-modified">!     return cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
  }
  
<span class="line-modified">! JSValue JSCell::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const</span>
  {
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;toPrimitive(exec, preferredType);</span>
      if (isSymbol())
<span class="line-modified">!         return static_cast&lt;const Symbol*&gt;(this)-&gt;toPrimitive(exec, preferredType);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toPrimitive(exec, preferredType);</span>
<span class="line-modified">!     return static_cast&lt;const JSObject*&gt;(this)-&gt;toPrimitive(exec, preferredType);</span>
  }
  
<span class="line-modified">! bool JSCell::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; value) const</span>
  {
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;getPrimitiveNumber(exec, number, value);</span>
      if (isSymbol())
<span class="line-modified">!         return static_cast&lt;const Symbol*&gt;(this)-&gt;getPrimitiveNumber(exec, number, value);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;getPrimitiveNumber(exec, number, value);</span>
<span class="line-modified">!     return static_cast&lt;const JSObject*&gt;(this)-&gt;getPrimitiveNumber(exec, number, value);</span>
  }
  
<span class="line-modified">! double JSCell::toNumber(ExecState* exec) const</span>
  {
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;toNumber(exec);</span>
      if (isSymbol())
<span class="line-modified">!         return static_cast&lt;const Symbol*&gt;(this)-&gt;toNumber(exec);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toNumber(exec);</span>
<span class="line-modified">!     return static_cast&lt;const JSObject*&gt;(this)-&gt;toNumber(exec);</span>
  }
  
<span class="line-modified">! JSObject* JSCell::toObjectSlow(ExecState* exec, JSGlobalObject* globalObject) const</span>
  {
      ASSERT(!isObject());
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;toObject(exec, globalObject);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toObject(exec, globalObject);</span>
      ASSERT(isSymbol());
<span class="line-modified">!     return static_cast&lt;const Symbol*&gt;(this)-&gt;toObject(exec, globalObject);</span>
  }
  
  void slowValidateCell(JSCell* cell)
  {
      ASSERT_GC_OBJECT_LOOKS_VALID(cell);
  }
  
<span class="line-modified">! JSValue JSCell::defaultValue(const JSObject*, ExecState*, PreferredPrimitiveType)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return jsUndefined();
  }
  
<span class="line-modified">! bool JSCell::getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool JSCell::getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned, PropertySlot&amp;)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! void JSCell::doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void JSCell::getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void JSCell::getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
  String JSCell::className(const JSObject*, VM&amp;)
  {
      RELEASE_ASSERT_NOT_REACHED();
      return String();
  }
  
<span class="line-modified">! String JSCell::toStringName(const JSObject*, ExecState*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return String();
  }
  
  const char* JSCell::className(VM&amp; vm) const
  {
      return classInfo(vm)-&gt;className;
  }
  
<span class="line-modified">! void JSCell::getPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::customHasInstance(JSObject*, ExecState*, JSValue)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool JSCell::defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! uint32_t JSCell::getEnumerableLength(ExecState*, JSObject*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return 0;
  }
  
<span class="line-modified">! void JSCell::getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void JSCell::getGenericPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::preventExtensions(JSObject*, ExecState*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::isExtensible(JSObject*, ExecState*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::setPrototype(JSObject*, ExecState*, JSValue, bool)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! JSValue JSCell::getPrototype(JSObject*, ExecState*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
  void JSCellLock::lockSlow()
<span class="line-new-header">--- 104,197 ---</span>
      constructData.js.scope = nullptr;
      constructData.native.function = nullptr;
      return ConstructType::None;
  }
  
<span class="line-modified">! bool JSCell::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName identifier, JSValue value, PutPropertySlot&amp; slot)</span>
  {
      if (cell-&gt;isString() || cell-&gt;isSymbol() || cell-&gt;isBigInt())
<span class="line-modified">!         return JSValue(cell).putToPrimitive(globalObject, identifier, value, slot);</span>
  
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(globalObject);</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;put(thisObject, globalObject, identifier, value, slot);</span>
  }
  
<span class="line-modified">! bool JSCell::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned identifier, JSValue value, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (cell-&gt;isString() || cell-&gt;isSymbol() || cell-&gt;isBigInt()) {
          PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified">!         return JSValue(cell).putToPrimitive(globalObject, Identifier::from(vm, identifier), value, slot);</span>
      }
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(globalObject);</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(vm)-&gt;putByIndex(thisObject, globalObject, identifier, value, shouldThrow);</span>
  }
  
<span class="line-modified">! bool JSCell::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName identifier)</span>
  {
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(globalObject);</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;deleteProperty(thisObject, globalObject, identifier);</span>
  }
  
<span class="line-modified">! bool JSCell::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned identifier)</span>
  {
<span class="line-modified">!     JSObject* thisObject = cell-&gt;toObject(globalObject);</span>
<span class="line-modified">!     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;deletePropertyByIndex(thisObject, globalObject, identifier);</span>
  }
  
<span class="line-modified">! JSValue JSCell::toThis(JSCell* cell, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
  {
      if (ecmaMode == StrictMode)
          return cell;
<span class="line-modified">!     return cell-&gt;toObject(globalObject);</span>
  }
  
<span class="line-modified">! JSValue JSCell::toPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType preferredType) const</span>
  {
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;toPrimitive(globalObject, preferredType);</span>
      if (isSymbol())
<span class="line-modified">!         return static_cast&lt;const Symbol*&gt;(this)-&gt;toPrimitive(globalObject, preferredType);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toPrimitive(globalObject, preferredType);</span>
<span class="line-modified">!     return static_cast&lt;const JSObject*&gt;(this)-&gt;toPrimitive(globalObject, preferredType);</span>
  }
  
<span class="line-modified">! bool JSCell::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; value) const</span>
  {
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;getPrimitiveNumber(globalObject, number, value);</span>
      if (isSymbol())
<span class="line-modified">!         return static_cast&lt;const Symbol*&gt;(this)-&gt;getPrimitiveNumber(globalObject, number, value);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;getPrimitiveNumber(globalObject, number, value);</span>
<span class="line-modified">!     return static_cast&lt;const JSObject*&gt;(this)-&gt;getPrimitiveNumber(globalObject, number, value);</span>
  }
  
<span class="line-modified">! double JSCell::toNumber(JSGlobalObject* globalObject) const</span>
  {
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;toNumber(globalObject);</span>
      if (isSymbol())
<span class="line-modified">!         return static_cast&lt;const Symbol*&gt;(this)-&gt;toNumber(globalObject);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toNumber(globalObject);</span>
<span class="line-modified">!     return static_cast&lt;const JSObject*&gt;(this)-&gt;toNumber(globalObject);</span>
  }
  
<span class="line-modified">! JSObject* JSCell::toObjectSlow(JSGlobalObject* globalObject) const</span>
  {
      ASSERT(!isObject());
      if (isString())
<span class="line-modified">!         return static_cast&lt;const JSString*&gt;(this)-&gt;toObject(globalObject);</span>
      if (isBigInt())
<span class="line-modified">!         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toObject(globalObject);</span>
      ASSERT(isSymbol());
<span class="line-modified">!     return static_cast&lt;const Symbol*&gt;(this)-&gt;toObject(globalObject);</span>
  }
  
  void slowValidateCell(JSCell* cell)
  {
      ASSERT_GC_OBJECT_LOOKS_VALID(cell);
  }
  
<span class="line-modified">! JSValue JSCell::defaultValue(const JSObject*, JSGlobalObject*, PreferredPrimitiveType)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return jsUndefined();
  }
  
<span class="line-modified">! bool JSCell::getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool JSCell::getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned, PropertySlot&amp;)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! void JSCell::doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void JSCell::getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void JSCell::getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
  String JSCell::className(const JSObject*, VM&amp;)
  {
      RELEASE_ASSERT_NOT_REACHED();
      return String();
  }
  
<span class="line-modified">! String JSCell::toStringName(const JSObject*, JSGlobalObject*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return String();
  }
  
  const char* JSCell::className(VM&amp; vm) const
  {
      return classInfo(vm)-&gt;className;
  }
  
<span class="line-modified">! void JSCell::getPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::customHasInstance(JSObject*, JSGlobalObject*, JSValue)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool JSCell::defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! uint32_t JSCell::getEnumerableLength(JSGlobalObject*, JSObject*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
      return 0;
  }
  
<span class="line-modified">! void JSCell::getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void JSCell::getGenericPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::preventExtensions(JSObject*, JSGlobalObject*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::isExtensible(JSObject*, JSGlobalObject*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSCell::setPrototype(JSObject*, JSGlobalObject*, JSValue, bool)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! JSValue JSCell::getPrototype(JSObject*, JSGlobalObject*)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
  void JSCellLock::lockSlow()
</pre>
<center><a href="JSCast.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCell.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
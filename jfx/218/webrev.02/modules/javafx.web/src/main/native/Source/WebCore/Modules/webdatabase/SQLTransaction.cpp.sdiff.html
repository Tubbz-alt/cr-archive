<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/SQLTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatabaseThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SQLTransaction.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/SQLTransaction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;SQLTransaction.h&quot;
 31 
 32 #include &quot;Database.h&quot;
 33 #include &quot;DatabaseAuthorizer.h&quot;
 34 #include &quot;DatabaseContext.h&quot;
 35 #include &quot;DatabaseThread.h&quot;
 36 #include &quot;DatabaseTracker.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;OriginLock.h&quot;
 40 #include &quot;SQLError.h&quot;
 41 #include &quot;SQLStatement.h&quot;
 42 #include &quot;SQLStatementCallback.h&quot;
 43 #include &quot;SQLStatementErrorCallback.h&quot;
 44 #include &quot;SQLTransactionBackend.h&quot;
 45 #include &quot;SQLTransactionCallback.h&quot;
 46 #include &quot;SQLTransactionCoordinator.h&quot;
 47 #include &quot;SQLTransactionErrorCallback.h&quot;
 48 #include &quot;SQLiteTransaction.h&quot;
 49 #include &quot;VoidCallback.h&quot;

 50 #include &lt;wtf/Optional.h&gt;
 51 #include &lt;wtf/StdLibExtras.h&gt;
 52 #include &lt;wtf/Vector.h&gt;
 53 
 54 namespace WebCore {
 55 
 56 Ref&lt;SQLTransaction&gt; SQLTransaction::create(Ref&lt;Database&gt;&amp;&amp; database, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
 57 {
 58     return adoptRef(*new SQLTransaction(WTFMove(database), WTFMove(callback), WTFMove(successCallback), WTFMove(errorCallback), WTFMove(wrapper), readOnly));
 59 }
 60 
 61 SQLTransaction::SQLTransaction(Ref&lt;Database&gt;&amp;&amp; database, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
 62     : m_database(WTFMove(database))
 63     , m_callbackWrapper(WTFMove(callback), &amp;m_database-&gt;document())
 64     , m_successCallbackWrapper(WTFMove(successCallback), &amp;m_database-&gt;document())
 65     , m_errorCallbackWrapper(WTFMove(errorCallback), &amp;m_database-&gt;document())
 66     , m_wrapper(WTFMove(wrapper))
 67     , m_nextStep(&amp;SQLTransaction::acquireLock)
 68     , m_readOnly(readOnly)
 69     , m_backend(*this)
</pre>
<hr />
<pre>
 92 
 93     return { };
 94 }
 95 
 96 void SQLTransaction::lockAcquired()
 97 {
 98     m_lockAcquired = true;
 99 
100     m_backend.m_requestedState = SQLTransactionState::OpenTransactionAndPreflight;
101     m_database-&gt;scheduleTransactionStep(*this);
102 }
103 
104 void SQLTransaction::performNextStep()
105 {
106     m_backend.computeNextStateAndCleanupIfNeeded();
107     m_backend.runStateMachine();
108 }
109 
110 void SQLTransaction::performPendingCallback()
111 {

112     LOG(StorageAPI, &quot;Callback %s\n&quot;, debugStepName(m_nextStep));
113 
114     ASSERT(m_nextStep == &amp;SQLTransaction::deliverTransactionCallback
115            || m_nextStep == &amp;SQLTransaction::deliverTransactionErrorCallback
116            || m_nextStep == &amp;SQLTransaction::deliverStatementCallback
117            || m_nextStep == &amp;SQLTransaction::deliverQuotaIncreaseCallback
118            || m_nextStep == &amp;SQLTransaction::deliverSuccessCallback);
119 
120     checkAndHandleClosedDatabase();
121 
122     if (m_nextStep)
123         (this-&gt;*m_nextStep)();
124 }
125 
126 void SQLTransaction::notifyDatabaseThreadIsShuttingDown()
127 {
128     m_backend.notifyDatabaseThreadIsShuttingDown();
129 }
130 












131 void SQLTransaction::enqueueStatement(std::unique_ptr&lt;SQLStatement&gt; statement)
132 {
133     LockHolder locker(m_statementMutex);
134     m_statementQueue.append(WTFMove(statement));
135 }
136 
137 SQLTransaction::StateFunction SQLTransaction::stateFunctionFor(SQLTransactionState state)
138 {
139     static const StateFunction stateFunctions[] = {
140         &amp;SQLTransaction::unreachableState,                // 0. illegal
141         &amp;SQLTransaction::unreachableState,                // 1. idle
142         &amp;SQLTransaction::unreachableState,                // 2. acquireLock
143         &amp;SQLTransaction::unreachableState,                // 3. openTransactionAndPreflight
144         &amp;SQLTransaction::unreachableState,                // 4. runStatements
145         &amp;SQLTransaction::unreachableState,                // 5. postflightAndCommit
146         &amp;SQLTransaction::unreachableState,                // 6. cleanupAndTerminate
147         &amp;SQLTransaction::unreachableState,                // 7. cleanupAfterTransactionErrorCallback
148         &amp;SQLTransaction::deliverTransactionCallback,      // 8.
149         &amp;SQLTransaction::deliverTransactionErrorCallback, // 9.
150         &amp;SQLTransaction::deliverStatementCallback,        // 10.
</pre>
<hr />
<pre>
163 // modify is m_requestedState which is meant for this purpose.
164 void SQLTransaction::requestTransitToState(SQLTransactionState nextState)
165 {
166     LOG(StorageAPI, &quot;Scheduling %s for transaction %p\n&quot;, nameForSQLTransactionState(nextState), this);
167     m_requestedState = nextState;
168     m_database-&gt;scheduleTransactionCallback(this);
169 }
170 
171 void SQLTransaction::checkAndHandleClosedDatabase()
172 {
173     if (m_database-&gt;opened())
174         return;
175 
176     // If the database was stopped, don&#39;t do anything and cancel queued work
177     LOG(StorageAPI, &quot;Database was stopped or interrupted - cancelling work for this transaction&quot;);
178 
179     LockHolder locker(m_statementMutex);
180     m_statementQueue.clear();
181     m_nextStep = nullptr;
182 


183     // Release the unneeded callbacks, to break reference cycles.
184     m_callbackWrapper.clear();
185     m_successCallbackWrapper.clear();
186     m_errorCallbackWrapper.clear();
187 
188     // The next steps should be executed only if we&#39;re on the DB thread.
189     if (m_database-&gt;databaseThread().getThread() != &amp;Thread::current())
190         return;
191 
192     // The current SQLite transaction should be stopped, as well
193     if (m_sqliteTransaction) {
194         m_sqliteTransaction-&gt;stop();
195         m_sqliteTransaction = nullptr;
196     }
197 
198     if (m_lockAcquired)
199         m_database-&gt;transactionCoordinator()-&gt;releaseLock(*this);
200 }
201 
202 void SQLTransaction::scheduleCallback(void (SQLTransaction::*step)())
</pre>
<hr />
<pre>
377 
378         m_executeSqlAllowed = false;
379     }
380 
381     // Spec 4.3.2 5: If the transaction callback was null or raised an exception, jump to the error callback
382     if (shouldDeliverErrorCallback) {
383         m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;the SQLTransactionCallback was null or threw an exception&quot;);
384         return deliverTransactionErrorCallback();
385     }
386 
387     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
388 }
389 
390 void SQLTransaction::deliverTransactionErrorCallback()
391 {
392     ASSERT(m_transactionError);
393 
394     // Spec 4.3.2.10: If exists, invoke error callback with the last
395     // error to have occurred in this transaction.
396     RefPtr&lt;SQLTransactionErrorCallback&gt; errorCallback = m_errorCallbackWrapper.unwrap();
<span class="line-modified">397     if (errorCallback)</span>
<span class="line-modified">398         errorCallback-&gt;handleEvent(*m_transactionError);</span>



399 
400     clearCallbackWrappers();
401 
402     // Spec 4.3.2.10: Rollback the transaction.
403     m_backend.requestTransitToState(SQLTransactionState::CleanupAfterTransactionErrorCallback);
404 }
405 
406 void SQLTransaction::deliverStatementCallback()
407 {
408     ASSERT(m_currentStatement);
409 
410     // Spec 4.3.2.6.6 and 4.3.2.6.3: If the statement callback went wrong, jump to the transaction error callback
411     // Otherwise, continue to loop through the statement queue
412     m_executeSqlAllowed = true;
413     bool result = m_currentStatement-&gt;performCallback(*this);
414     m_executeSqlAllowed = false;
415 
416     if (result) {
417         m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;the statement callback raised an exception or statement error callback did not return false&quot;);
418 
</pre>
<hr />
<pre>
425         return;
426     }
427 
428     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
429 }
430 
431 void SQLTransaction::deliverQuotaIncreaseCallback()
432 {
433     ASSERT(m_currentStatement);
434     ASSERT(!m_shouldRetryCurrentStatement);
435 
436     m_shouldRetryCurrentStatement = m_database-&gt;didExceedQuota();
437 
438     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
439 }
440 
441 void SQLTransaction::deliverSuccessCallback()
442 {
443     // Spec 4.3.2.8: Deliver success callback.
444     RefPtr&lt;VoidCallback&gt; successCallback = m_successCallbackWrapper.unwrap();
<span class="line-modified">445     if (successCallback)</span>
<span class="line-modified">446         successCallback-&gt;handleEvent();</span>



447 
448     clearCallbackWrappers();
449 
450     // Schedule a &quot;post-success callback&quot; step to return control to the database thread in case there
451     // are further transactions queued up for this Database
452     m_backend.requestTransitToState(SQLTransactionState::CleanupAndTerminate);
453 }
454 
455 // This state function is used as a stub function to plug unimplemented states
456 // in the state dispatch table. They are unimplemented because they should
457 // never be reached in the course of correct execution.
458 void SQLTransaction::unreachableState()
459 {
460     ASSERT_NOT_REACHED();
461 }
462 
463 void SQLTransaction::computeNextStateAndCleanupIfNeeded()
464 {
465     // Only honor the requested state transition if we&#39;re not supposed to be
466     // cleaning up and shutting down:
467     if (m_database-&gt;opened()) {
468         setStateToRequestedState();
469         ASSERT(m_nextState == SQLTransactionState::End
470             || m_nextState == SQLTransactionState::DeliverTransactionCallback
471             || m_nextState == SQLTransactionState::DeliverTransactionErrorCallback
472             || m_nextState == SQLTransactionState::DeliverStatementCallback
473             || m_nextState == SQLTransactionState::DeliverQuotaIncreaseCallback
474             || m_nextState == SQLTransactionState::DeliverSuccessCallback);
475 
476         LOG(StorageAPI, &quot;Callback %s\n&quot;, nameForSQLTransactionState(m_nextState));
477         return;
<span class="line-modified">478     }</span>

479 
480     clearCallbackWrappers();
481     m_backend.requestTransitToState(SQLTransactionState::CleanupAndTerminate);
482 }
483 
484 void SQLTransaction::clearCallbackWrappers()
485 {
486     // Release the unneeded callbacks, to break reference cycles.
487     m_callbackWrapper.clear();
488     m_successCallbackWrapper.clear();
489     m_errorCallbackWrapper.clear();
490 }
491 
492 void SQLTransaction::getNextStatement()
493 {
494     m_currentStatement = nullptr;
495 
496     LockHolder locker(m_statementMutex);
497     if (!m_statementQueue.isEmpty())
498         m_currentStatement = m_statementQueue.takeFirst();
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;SQLTransaction.h&quot;
 31 
 32 #include &quot;Database.h&quot;
 33 #include &quot;DatabaseAuthorizer.h&quot;
 34 #include &quot;DatabaseContext.h&quot;
 35 #include &quot;DatabaseThread.h&quot;
 36 #include &quot;DatabaseTracker.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;OriginLock.h&quot;
 40 #include &quot;SQLError.h&quot;
 41 #include &quot;SQLStatement.h&quot;
 42 #include &quot;SQLStatementCallback.h&quot;
 43 #include &quot;SQLStatementErrorCallback.h&quot;
 44 #include &quot;SQLTransactionBackend.h&quot;
 45 #include &quot;SQLTransactionCallback.h&quot;
 46 #include &quot;SQLTransactionCoordinator.h&quot;
 47 #include &quot;SQLTransactionErrorCallback.h&quot;
 48 #include &quot;SQLiteTransaction.h&quot;
 49 #include &quot;VoidCallback.h&quot;
<span class="line-added"> 50 #include &quot;WindowEventLoop.h&quot;</span>
 51 #include &lt;wtf/Optional.h&gt;
 52 #include &lt;wtf/StdLibExtras.h&gt;
 53 #include &lt;wtf/Vector.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 Ref&lt;SQLTransaction&gt; SQLTransaction::create(Ref&lt;Database&gt;&amp;&amp; database, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
 58 {
 59     return adoptRef(*new SQLTransaction(WTFMove(database), WTFMove(callback), WTFMove(successCallback), WTFMove(errorCallback), WTFMove(wrapper), readOnly));
 60 }
 61 
 62 SQLTransaction::SQLTransaction(Ref&lt;Database&gt;&amp;&amp; database, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
 63     : m_database(WTFMove(database))
 64     , m_callbackWrapper(WTFMove(callback), &amp;m_database-&gt;document())
 65     , m_successCallbackWrapper(WTFMove(successCallback), &amp;m_database-&gt;document())
 66     , m_errorCallbackWrapper(WTFMove(errorCallback), &amp;m_database-&gt;document())
 67     , m_wrapper(WTFMove(wrapper))
 68     , m_nextStep(&amp;SQLTransaction::acquireLock)
 69     , m_readOnly(readOnly)
 70     , m_backend(*this)
</pre>
<hr />
<pre>
 93 
 94     return { };
 95 }
 96 
 97 void SQLTransaction::lockAcquired()
 98 {
 99     m_lockAcquired = true;
100 
101     m_backend.m_requestedState = SQLTransactionState::OpenTransactionAndPreflight;
102     m_database-&gt;scheduleTransactionStep(*this);
103 }
104 
105 void SQLTransaction::performNextStep()
106 {
107     m_backend.computeNextStateAndCleanupIfNeeded();
108     m_backend.runStateMachine();
109 }
110 
111 void SQLTransaction::performPendingCallback()
112 {
<span class="line-added">113     ASSERT(isMainThread());</span>
114     LOG(StorageAPI, &quot;Callback %s\n&quot;, debugStepName(m_nextStep));
115 
116     ASSERT(m_nextStep == &amp;SQLTransaction::deliverTransactionCallback
117            || m_nextStep == &amp;SQLTransaction::deliverTransactionErrorCallback
118            || m_nextStep == &amp;SQLTransaction::deliverStatementCallback
119            || m_nextStep == &amp;SQLTransaction::deliverQuotaIncreaseCallback
120            || m_nextStep == &amp;SQLTransaction::deliverSuccessCallback);
121 
122     checkAndHandleClosedDatabase();
123 
124     if (m_nextStep)
125         (this-&gt;*m_nextStep)();
126 }
127 
128 void SQLTransaction::notifyDatabaseThreadIsShuttingDown()
129 {
130     m_backend.notifyDatabaseThreadIsShuttingDown();
131 }
132 
<span class="line-added">133 void SQLTransaction::callErrorCallbackDueToInterruption()</span>
<span class="line-added">134 {</span>
<span class="line-added">135     ASSERT(isMainThread());</span>
<span class="line-added">136     auto errorCallback = m_errorCallbackWrapper.unwrap();</span>
<span class="line-added">137     if (!errorCallback)</span>
<span class="line-added">138         return;</span>
<span class="line-added">139 </span>
<span class="line-added">140     m_database-&gt;document().eventLoop().queueTask(TaskSource::Networking, [errorCallback = WTFMove(errorCallback)]() mutable {</span>
<span class="line-added">141         errorCallback-&gt;handleEvent(SQLError::create(SQLError::DATABASE_ERR, &quot;the database was closed&quot;));</span>
<span class="line-added">142     });</span>
<span class="line-added">143 }</span>
<span class="line-added">144 </span>
145 void SQLTransaction::enqueueStatement(std::unique_ptr&lt;SQLStatement&gt; statement)
146 {
147     LockHolder locker(m_statementMutex);
148     m_statementQueue.append(WTFMove(statement));
149 }
150 
151 SQLTransaction::StateFunction SQLTransaction::stateFunctionFor(SQLTransactionState state)
152 {
153     static const StateFunction stateFunctions[] = {
154         &amp;SQLTransaction::unreachableState,                // 0. illegal
155         &amp;SQLTransaction::unreachableState,                // 1. idle
156         &amp;SQLTransaction::unreachableState,                // 2. acquireLock
157         &amp;SQLTransaction::unreachableState,                // 3. openTransactionAndPreflight
158         &amp;SQLTransaction::unreachableState,                // 4. runStatements
159         &amp;SQLTransaction::unreachableState,                // 5. postflightAndCommit
160         &amp;SQLTransaction::unreachableState,                // 6. cleanupAndTerminate
161         &amp;SQLTransaction::unreachableState,                // 7. cleanupAfterTransactionErrorCallback
162         &amp;SQLTransaction::deliverTransactionCallback,      // 8.
163         &amp;SQLTransaction::deliverTransactionErrorCallback, // 9.
164         &amp;SQLTransaction::deliverStatementCallback,        // 10.
</pre>
<hr />
<pre>
177 // modify is m_requestedState which is meant for this purpose.
178 void SQLTransaction::requestTransitToState(SQLTransactionState nextState)
179 {
180     LOG(StorageAPI, &quot;Scheduling %s for transaction %p\n&quot;, nameForSQLTransactionState(nextState), this);
181     m_requestedState = nextState;
182     m_database-&gt;scheduleTransactionCallback(this);
183 }
184 
185 void SQLTransaction::checkAndHandleClosedDatabase()
186 {
187     if (m_database-&gt;opened())
188         return;
189 
190     // If the database was stopped, don&#39;t do anything and cancel queued work
191     LOG(StorageAPI, &quot;Database was stopped or interrupted - cancelling work for this transaction&quot;);
192 
193     LockHolder locker(m_statementMutex);
194     m_statementQueue.clear();
195     m_nextStep = nullptr;
196 
<span class="line-added">197     callErrorCallbackDueToInterruption();</span>
<span class="line-added">198 </span>
199     // Release the unneeded callbacks, to break reference cycles.
200     m_callbackWrapper.clear();
201     m_successCallbackWrapper.clear();
202     m_errorCallbackWrapper.clear();
203 
204     // The next steps should be executed only if we&#39;re on the DB thread.
205     if (m_database-&gt;databaseThread().getThread() != &amp;Thread::current())
206         return;
207 
208     // The current SQLite transaction should be stopped, as well
209     if (m_sqliteTransaction) {
210         m_sqliteTransaction-&gt;stop();
211         m_sqliteTransaction = nullptr;
212     }
213 
214     if (m_lockAcquired)
215         m_database-&gt;transactionCoordinator()-&gt;releaseLock(*this);
216 }
217 
218 void SQLTransaction::scheduleCallback(void (SQLTransaction::*step)())
</pre>
<hr />
<pre>
393 
394         m_executeSqlAllowed = false;
395     }
396 
397     // Spec 4.3.2 5: If the transaction callback was null or raised an exception, jump to the error callback
398     if (shouldDeliverErrorCallback) {
399         m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;the SQLTransactionCallback was null or threw an exception&quot;);
400         return deliverTransactionErrorCallback();
401     }
402 
403     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
404 }
405 
406 void SQLTransaction::deliverTransactionErrorCallback()
407 {
408     ASSERT(m_transactionError);
409 
410     // Spec 4.3.2.10: If exists, invoke error callback with the last
411     // error to have occurred in this transaction.
412     RefPtr&lt;SQLTransactionErrorCallback&gt; errorCallback = m_errorCallbackWrapper.unwrap();
<span class="line-modified">413     if (errorCallback) {</span>
<span class="line-modified">414         m_database-&gt;document().eventLoop().queueTask(TaskSource::Networking, [errorCallback = WTFMove(errorCallback), transactionError = m_transactionError]() mutable {</span>
<span class="line-added">415             errorCallback-&gt;handleEvent(*transactionError);</span>
<span class="line-added">416         });</span>
<span class="line-added">417     }</span>
418 
419     clearCallbackWrappers();
420 
421     // Spec 4.3.2.10: Rollback the transaction.
422     m_backend.requestTransitToState(SQLTransactionState::CleanupAfterTransactionErrorCallback);
423 }
424 
425 void SQLTransaction::deliverStatementCallback()
426 {
427     ASSERT(m_currentStatement);
428 
429     // Spec 4.3.2.6.6 and 4.3.2.6.3: If the statement callback went wrong, jump to the transaction error callback
430     // Otherwise, continue to loop through the statement queue
431     m_executeSqlAllowed = true;
432     bool result = m_currentStatement-&gt;performCallback(*this);
433     m_executeSqlAllowed = false;
434 
435     if (result) {
436         m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;the statement callback raised an exception or statement error callback did not return false&quot;);
437 
</pre>
<hr />
<pre>
444         return;
445     }
446 
447     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
448 }
449 
450 void SQLTransaction::deliverQuotaIncreaseCallback()
451 {
452     ASSERT(m_currentStatement);
453     ASSERT(!m_shouldRetryCurrentStatement);
454 
455     m_shouldRetryCurrentStatement = m_database-&gt;didExceedQuota();
456 
457     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
458 }
459 
460 void SQLTransaction::deliverSuccessCallback()
461 {
462     // Spec 4.3.2.8: Deliver success callback.
463     RefPtr&lt;VoidCallback&gt; successCallback = m_successCallbackWrapper.unwrap();
<span class="line-modified">464     if (successCallback) {</span>
<span class="line-modified">465         m_database-&gt;document().eventLoop().queueTask(TaskSource::Networking, [successCallback = WTFMove(successCallback)]() mutable {</span>
<span class="line-added">466             successCallback-&gt;handleEvent();</span>
<span class="line-added">467         });</span>
<span class="line-added">468     }</span>
469 
470     clearCallbackWrappers();
471 
472     // Schedule a &quot;post-success callback&quot; step to return control to the database thread in case there
473     // are further transactions queued up for this Database
474     m_backend.requestTransitToState(SQLTransactionState::CleanupAndTerminate);
475 }
476 
477 // This state function is used as a stub function to plug unimplemented states
478 // in the state dispatch table. They are unimplemented because they should
479 // never be reached in the course of correct execution.
480 void SQLTransaction::unreachableState()
481 {
482     ASSERT_NOT_REACHED();
483 }
484 
485 void SQLTransaction::computeNextStateAndCleanupIfNeeded()
486 {
487     // Only honor the requested state transition if we&#39;re not supposed to be
488     // cleaning up and shutting down:
489     if (m_database-&gt;opened()) {
490         setStateToRequestedState();
491         ASSERT(m_nextState == SQLTransactionState::End
492             || m_nextState == SQLTransactionState::DeliverTransactionCallback
493             || m_nextState == SQLTransactionState::DeliverTransactionErrorCallback
494             || m_nextState == SQLTransactionState::DeliverStatementCallback
495             || m_nextState == SQLTransactionState::DeliverQuotaIncreaseCallback
496             || m_nextState == SQLTransactionState::DeliverSuccessCallback);
497 
498         LOG(StorageAPI, &quot;Callback %s\n&quot;, nameForSQLTransactionState(m_nextState));
499         return;
<span class="line-modified">500     } else</span>
<span class="line-added">501         callErrorCallbackDueToInterruption();</span>
502 
503     clearCallbackWrappers();
504     m_backend.requestTransitToState(SQLTransactionState::CleanupAndTerminate);
505 }
506 
507 void SQLTransaction::clearCallbackWrappers()
508 {
509     // Release the unneeded callbacks, to break reference cycles.
510     m_callbackWrapper.clear();
511     m_successCallbackWrapper.clear();
512     m_errorCallbackWrapper.clear();
513 }
514 
515 void SQLTransaction::getNextStatement()
516 {
517     m_currentStatement = nullptr;
518 
519     LockHolder locker(m_statementMutex);
520     if (!m_statementQueue.isEmpty())
521         m_currentStatement = m_statementQueue.takeFirst();
</pre>
</td>
</tr>
</table>
<center><a href="DatabaseThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SQLTransaction.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
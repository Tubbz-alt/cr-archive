<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Debugger.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerCallFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;Breakpoint.h&quot;
 25 #include &quot;CallData.h&quot;
 26 #include &quot;DebuggerCallFrame.h&quot;
 27 #include &quot;DebuggerParseData.h&quot;
 28 #include &quot;DebuggerPrimitives.h&quot;
 29 #include &quot;JSCJSValue.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/HashSet.h&gt;
 32 #include &lt;wtf/RefPtr.h&gt;
 33 #include &lt;wtf/text/TextPosition.h&gt;
 34 
 35 namespace JSC {
 36 

 37 class CodeBlock;
 38 class Exception;
<span class="line-removed"> 39 class ExecState;</span>
 40 class JSGlobalObject;
 41 class SourceProvider;
 42 class VM;
 43 
<span class="line-removed"> 44 typedef ExecState CallFrame;</span>
<span class="line-removed"> 45 </span>
 46 class JS_EXPORT_PRIVATE Debugger {
 47     WTF_MAKE_FAST_ALLOCATED;
 48 public:
 49     Debugger(VM&amp;);
 50     virtual ~Debugger();
 51 
 52     VM&amp; vm() { return m_vm; }
 53 
 54     JSC::DebuggerCallFrame&amp; currentDebuggerCallFrame();
 55     bool hasHandlerForExceptionCallback() const
 56     {
 57         ASSERT(m_reasonForPause == PausedForException);
 58         return m_hasHandlerForExceptionCallback;
 59     }
 60     JSValue currentException()
 61     {
 62         ASSERT(m_reasonForPause == PausedForException);
 63         return m_currentException;
 64     }
 65 
</pre>
<hr />
<pre>
 74     void detach(JSGlobalObject*, ReasonForDetach);
 75     bool isAttached(JSGlobalObject*);
 76 
 77     void resolveBreakpoint(Breakpoint&amp;, SourceProvider*);
 78     BreakpointID setBreakpoint(Breakpoint&amp;, bool&amp; existing);
 79     void removeBreakpoint(BreakpointID);
 80     void clearBreakpoints();
 81 
 82     void activateBreakpoints() { setBreakpointsActivated(true); }
 83     void deactivateBreakpoints() { setBreakpointsActivated(false); }
 84     bool breakpointsActive() const { return m_breakpointsActivated; }
 85 
 86     enum PauseOnExceptionsState {
 87         DontPauseOnExceptions,
 88         PauseOnAllExceptions,
 89         PauseOnUncaughtExceptions
 90     };
 91     PauseOnExceptionsState pauseOnExceptionsState() const { return m_pauseOnExceptionsState; }
 92     void setPauseOnExceptionsState(PauseOnExceptionsState);
 93 


 94     enum ReasonForPause {
 95         NotPaused,
 96         PausedForException,
 97         PausedAtStatement,
 98         PausedAtExpression,
 99         PausedBeforeReturn,
100         PausedAtEndOfProgram,
101         PausedForBreakpoint,
102         PausedForDebuggerStatement,

103     };
104     ReasonForPause reasonForPause() const { return m_reasonForPause; }
105     BreakpointID pausingBreakpointID() const { return m_pausingBreakpointID; }
106 
107     void setPauseOnNextStatement(bool);
108     void breakProgram();
109     void continueProgram();
110     void stepIntoStatement();
111     void stepOverStatement();
112     void stepOutOfFunction();
113 
<span class="line-modified">114     bool isBlacklisted(SourceID) const;</span>
<span class="line-modified">115     void addToBlacklist(SourceID);</span>
<span class="line-modified">116     void clearBlacklist();</span>
117 
118     bool isPaused() const { return m_isPaused; }
119     bool isStepping() const { return m_steppingMode == SteppingModeEnabled; }
120 
121     bool suppressAllPauses() const { return m_suppressAllPauses; }
122     void setSuppressAllPauses(bool suppress) { m_suppressAllPauses = suppress; }
123 
<span class="line-modified">124     virtual void sourceParsed(ExecState*, SourceProvider*, int errorLineNumber, const WTF::String&amp; errorMessage) = 0;</span>
125     virtual void willRunMicrotask() { }
126     virtual void didRunMicrotask() { }
127 
<span class="line-modified">128     void exception(CallFrame*, JSValue exceptionValue, bool hasCatchHandler);</span>
129     void atStatement(CallFrame*);
130     void atExpression(CallFrame*);
131     void callEvent(CallFrame*);
132     void returnEvent(CallFrame*);
133     void unwindEvent(CallFrame*);
134     void willExecuteProgram(CallFrame*);
135     void didExecuteProgram(CallFrame*);
<span class="line-modified">136     void didReachBreakpoint(CallFrame*);</span>
137 
138     virtual void recompileAllJSFunctions();
139 
140     void registerCodeBlock(CodeBlock*);
141 
142     class ProfilingClient {
143     public:
144         virtual ~ProfilingClient();
145         virtual bool isAlreadyProfiling() const = 0;
146         virtual Seconds willEvaluateScript() = 0;
147         virtual void didEvaluateScript(Seconds startTime, ProfilingReason) = 0;
148     };
149 
150     void setProfilingClient(ProfilingClient*);
151     bool hasProfilingClient() const { return m_profilingClient != nullptr; }
152     bool isAlreadyProfiling() const { return m_profilingClient &amp;&amp; m_profilingClient-&gt;isAlreadyProfiling(); }
153     Seconds willEvaluateScript();
154     void didEvaluateScript(Seconds startTime, ProfilingReason);
155 
156 protected:
157     virtual void handleBreakpointHit(JSGlobalObject*, const Breakpoint&amp;) { }
<span class="line-modified">158     virtual void handleExceptionInBreakpointCondition(ExecState*, Exception*) const { }</span>
159     virtual void handlePause(JSGlobalObject*, ReasonForPause) { }
160     virtual void notifyDoneProcessingDebuggerEvents() { }
161 
162 private:
163     typedef HashMap&lt;BreakpointID, Breakpoint*&gt; BreakpointIDToBreakpointMap;
164 
165     typedef HashMap&lt;unsigned, RefPtr&lt;BreakpointsList&gt;, WTF::IntHash&lt;int&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt; LineToBreakpointsMap;
166     typedef HashMap&lt;SourceID, LineToBreakpointsMap, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; SourceIDToBreakpointsMap;
167 
168     class ClearCodeBlockDebuggerRequestsFunctor;
169     class ClearDebuggerRequestsFunctor;
170     class SetSteppingModeFunctor;
171     class ToggleBreakpointFunctor;
172 
173     class PauseReasonDeclaration {
174     public:
175         PauseReasonDeclaration(Debugger&amp; debugger, ReasonForPause reason)
176             : m_debugger(debugger)
177         {
178             m_debugger.m_reasonForPause = reason;
</pre>
<hr />
<pre>
181         ~PauseReasonDeclaration()
182         {
183             m_debugger.m_reasonForPause = NotPaused;
184         }
185     private:
186         Debugger&amp; m_debugger;
187     };
188 
189     bool hasBreakpoint(SourceID, const TextPosition&amp;, Breakpoint* hitBreakpoint);
190 
191     DebuggerParseData&amp; debuggerParseData(SourceID, SourceProvider*);
192 
193     void updateNeedForOpDebugCallbacks();
194 
195     // These update functions are only needed because our current breakpoints are
196     // key&#39;ed off the source position instead of the bytecode PC. This ensures
197     // that we don&#39;t break on the same line more than once. Once we switch to a
198     // bytecode PC key&#39;ed breakpoint, we will not need these anymore and should
199     // be able to remove them.
200     enum CallFrameUpdateAction { AttemptPause, NoPause };
<span class="line-modified">201     void updateCallFrame(JSC::CallFrame*, CallFrameUpdateAction);</span>
202     void updateCallFrameInternal(JSC::CallFrame*);
<span class="line-modified">203     void pauseIfNeeded(JSC::CallFrame*);</span>
204     void clearNextPauseState();
205 
206     enum SteppingMode {
207         SteppingModeDisabled,
208         SteppingModeEnabled
209     };
210     void setSteppingMode(SteppingMode);
211 
212     enum BreakpointState {
213         BreakpointDisabled,
214         BreakpointEnabled
215     };
216     void setBreakpointsActivated(bool);
217     void toggleBreakpoint(CodeBlock*, Breakpoint&amp;, BreakpointState);
218     void applyBreakpoints(CodeBlock*);
219     void toggleBreakpoint(Breakpoint&amp;, BreakpointState);
220 
221     void clearDebuggerRequests(JSGlobalObject*);
222     void clearParsedData();
223 
224     VM&amp; m_vm;
225     HashSet&lt;JSGlobalObject*&gt; m_globalObjects;
226     HashMap&lt;SourceID, DebuggerParseData, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_parseDataMap;
<span class="line-modified">227     HashSet&lt;SourceID, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_blacklistedScripts;</span>
228 
229     PauseOnExceptionsState m_pauseOnExceptionsState;

230     bool m_pauseAtNextOpportunity : 1;
231     bool m_pauseOnStepOut : 1;
232     bool m_pastFirstExpressionInStatement : 1;
233     bool m_isPaused : 1;
234     bool m_breakpointsActivated : 1;
235     bool m_hasHandlerForExceptionCallback : 1;
236     bool m_suppressAllPauses : 1;
237     unsigned m_steppingMode : 1; // SteppingMode
238 
239     ReasonForPause m_reasonForPause;
240     JSValue m_currentException;
241     CallFrame* m_pauseOnCallFrame { nullptr };
242     CallFrame* m_currentCallFrame { nullptr };
243     unsigned m_lastExecutedLine;
244     SourceID m_lastExecutedSourceID;

245 
246     BreakpointID m_topBreakpointID;
247     BreakpointID m_pausingBreakpointID;
248     BreakpointIDToBreakpointMap m_breakpointIDToBreakpoint;
249     SourceIDToBreakpointsMap m_sourceIDToBreakpoints;
250 
251     RefPtr&lt;JSC::DebuggerCallFrame&gt; m_currentDebuggerCallFrame;
252 
253     ProfilingClient* m_profilingClient { nullptr };
254 
255     friend class DebuggerPausedScope;
256     friend class TemporaryPausedState;
257     friend class LLIntOffsetsExtractor;
258 };
259 
260 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;Breakpoint.h&quot;
 25 #include &quot;CallData.h&quot;
 26 #include &quot;DebuggerCallFrame.h&quot;
 27 #include &quot;DebuggerParseData.h&quot;
 28 #include &quot;DebuggerPrimitives.h&quot;
 29 #include &quot;JSCJSValue.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/HashSet.h&gt;
 32 #include &lt;wtf/RefPtr.h&gt;
 33 #include &lt;wtf/text/TextPosition.h&gt;
 34 
 35 namespace JSC {
 36 
<span class="line-added"> 37 class CallFrame;</span>
 38 class CodeBlock;
 39 class Exception;

 40 class JSGlobalObject;
 41 class SourceProvider;
 42 class VM;
 43 


 44 class JS_EXPORT_PRIVATE Debugger {
 45     WTF_MAKE_FAST_ALLOCATED;
 46 public:
 47     Debugger(VM&amp;);
 48     virtual ~Debugger();
 49 
 50     VM&amp; vm() { return m_vm; }
 51 
 52     JSC::DebuggerCallFrame&amp; currentDebuggerCallFrame();
 53     bool hasHandlerForExceptionCallback() const
 54     {
 55         ASSERT(m_reasonForPause == PausedForException);
 56         return m_hasHandlerForExceptionCallback;
 57     }
 58     JSValue currentException()
 59     {
 60         ASSERT(m_reasonForPause == PausedForException);
 61         return m_currentException;
 62     }
 63 
</pre>
<hr />
<pre>
 72     void detach(JSGlobalObject*, ReasonForDetach);
 73     bool isAttached(JSGlobalObject*);
 74 
 75     void resolveBreakpoint(Breakpoint&amp;, SourceProvider*);
 76     BreakpointID setBreakpoint(Breakpoint&amp;, bool&amp; existing);
 77     void removeBreakpoint(BreakpointID);
 78     void clearBreakpoints();
 79 
 80     void activateBreakpoints() { setBreakpointsActivated(true); }
 81     void deactivateBreakpoints() { setBreakpointsActivated(false); }
 82     bool breakpointsActive() const { return m_breakpointsActivated; }
 83 
 84     enum PauseOnExceptionsState {
 85         DontPauseOnExceptions,
 86         PauseOnAllExceptions,
 87         PauseOnUncaughtExceptions
 88     };
 89     PauseOnExceptionsState pauseOnExceptionsState() const { return m_pauseOnExceptionsState; }
 90     void setPauseOnExceptionsState(PauseOnExceptionsState);
 91 
<span class="line-added"> 92     void setPauseOnDebuggerStatements(bool enabled) { m_pauseOnDebuggerStatements = enabled; }</span>
<span class="line-added"> 93 </span>
 94     enum ReasonForPause {
 95         NotPaused,
 96         PausedForException,
 97         PausedAtStatement,
 98         PausedAtExpression,
 99         PausedBeforeReturn,
100         PausedAtEndOfProgram,
101         PausedForBreakpoint,
102         PausedForDebuggerStatement,
<span class="line-added">103         PausedAfterBlackboxedScript,</span>
104     };
105     ReasonForPause reasonForPause() const { return m_reasonForPause; }
106     BreakpointID pausingBreakpointID() const { return m_pausingBreakpointID; }
107 
108     void setPauseOnNextStatement(bool);
109     void breakProgram();
110     void continueProgram();
111     void stepIntoStatement();
112     void stepOverStatement();
113     void stepOutOfFunction();
114 
<span class="line-modified">115     enum class BlackboxType { Deferred, Ignored };</span>
<span class="line-modified">116     void setBlackboxType(SourceID, Optional&lt;BlackboxType&gt;);</span>
<span class="line-modified">117     void clearBlackbox();</span>
118 
119     bool isPaused() const { return m_isPaused; }
120     bool isStepping() const { return m_steppingMode == SteppingModeEnabled; }
121 
122     bool suppressAllPauses() const { return m_suppressAllPauses; }
123     void setSuppressAllPauses(bool suppress) { m_suppressAllPauses = suppress; }
124 
<span class="line-modified">125     virtual void sourceParsed(JSGlobalObject*, SourceProvider*, int errorLineNumber, const WTF::String&amp; errorMessage) = 0;</span>
126     virtual void willRunMicrotask() { }
127     virtual void didRunMicrotask() { }
128 
<span class="line-modified">129     void exception(JSGlobalObject*, CallFrame*, JSValue exceptionValue, bool hasCatchHandler);</span>
130     void atStatement(CallFrame*);
131     void atExpression(CallFrame*);
132     void callEvent(CallFrame*);
133     void returnEvent(CallFrame*);
134     void unwindEvent(CallFrame*);
135     void willExecuteProgram(CallFrame*);
136     void didExecuteProgram(CallFrame*);
<span class="line-modified">137     void didReachDebuggerStatement(CallFrame*);</span>
138 
139     virtual void recompileAllJSFunctions();
140 
141     void registerCodeBlock(CodeBlock*);
142 
143     class ProfilingClient {
144     public:
145         virtual ~ProfilingClient();
146         virtual bool isAlreadyProfiling() const = 0;
147         virtual Seconds willEvaluateScript() = 0;
148         virtual void didEvaluateScript(Seconds startTime, ProfilingReason) = 0;
149     };
150 
151     void setProfilingClient(ProfilingClient*);
152     bool hasProfilingClient() const { return m_profilingClient != nullptr; }
153     bool isAlreadyProfiling() const { return m_profilingClient &amp;&amp; m_profilingClient-&gt;isAlreadyProfiling(); }
154     Seconds willEvaluateScript();
155     void didEvaluateScript(Seconds startTime, ProfilingReason);
156 
157 protected:
158     virtual void handleBreakpointHit(JSGlobalObject*, const Breakpoint&amp;) { }
<span class="line-modified">159     virtual void handleExceptionInBreakpointCondition(JSGlobalObject*, Exception*) const { }</span>
160     virtual void handlePause(JSGlobalObject*, ReasonForPause) { }
161     virtual void notifyDoneProcessingDebuggerEvents() { }
162 
163 private:
164     typedef HashMap&lt;BreakpointID, Breakpoint*&gt; BreakpointIDToBreakpointMap;
165 
166     typedef HashMap&lt;unsigned, RefPtr&lt;BreakpointsList&gt;, WTF::IntHash&lt;int&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt; LineToBreakpointsMap;
167     typedef HashMap&lt;SourceID, LineToBreakpointsMap, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; SourceIDToBreakpointsMap;
168 
169     class ClearCodeBlockDebuggerRequestsFunctor;
170     class ClearDebuggerRequestsFunctor;
171     class SetSteppingModeFunctor;
172     class ToggleBreakpointFunctor;
173 
174     class PauseReasonDeclaration {
175     public:
176         PauseReasonDeclaration(Debugger&amp; debugger, ReasonForPause reason)
177             : m_debugger(debugger)
178         {
179             m_debugger.m_reasonForPause = reason;
</pre>
<hr />
<pre>
182         ~PauseReasonDeclaration()
183         {
184             m_debugger.m_reasonForPause = NotPaused;
185         }
186     private:
187         Debugger&amp; m_debugger;
188     };
189 
190     bool hasBreakpoint(SourceID, const TextPosition&amp;, Breakpoint* hitBreakpoint);
191 
192     DebuggerParseData&amp; debuggerParseData(SourceID, SourceProvider*);
193 
194     void updateNeedForOpDebugCallbacks();
195 
196     // These update functions are only needed because our current breakpoints are
197     // key&#39;ed off the source position instead of the bytecode PC. This ensures
198     // that we don&#39;t break on the same line more than once. Once we switch to a
199     // bytecode PC key&#39;ed breakpoint, we will not need these anymore and should
200     // be able to remove them.
201     enum CallFrameUpdateAction { AttemptPause, NoPause };
<span class="line-modified">202     void updateCallFrame(JSC::JSGlobalObject*, JSC::CallFrame*, CallFrameUpdateAction);</span>
203     void updateCallFrameInternal(JSC::CallFrame*);
<span class="line-modified">204     void pauseIfNeeded(JSC::JSGlobalObject*);</span>
205     void clearNextPauseState();
206 
207     enum SteppingMode {
208         SteppingModeDisabled,
209         SteppingModeEnabled
210     };
211     void setSteppingMode(SteppingMode);
212 
213     enum BreakpointState {
214         BreakpointDisabled,
215         BreakpointEnabled
216     };
217     void setBreakpointsActivated(bool);
218     void toggleBreakpoint(CodeBlock*, Breakpoint&amp;, BreakpointState);
219     void applyBreakpoints(CodeBlock*);
220     void toggleBreakpoint(Breakpoint&amp;, BreakpointState);
221 
222     void clearDebuggerRequests(JSGlobalObject*);
223     void clearParsedData();
224 
225     VM&amp; m_vm;
226     HashSet&lt;JSGlobalObject*&gt; m_globalObjects;
227     HashMap&lt;SourceID, DebuggerParseData, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_parseDataMap;
<span class="line-modified">228     HashMap&lt;SourceID, BlackboxType, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_blackboxedScripts;</span>
229 
230     PauseOnExceptionsState m_pauseOnExceptionsState;
<span class="line-added">231     bool m_pauseOnDebuggerStatements : 1;</span>
232     bool m_pauseAtNextOpportunity : 1;
233     bool m_pauseOnStepOut : 1;
234     bool m_pastFirstExpressionInStatement : 1;
235     bool m_isPaused : 1;
236     bool m_breakpointsActivated : 1;
237     bool m_hasHandlerForExceptionCallback : 1;
238     bool m_suppressAllPauses : 1;
239     unsigned m_steppingMode : 1; // SteppingMode
240 
241     ReasonForPause m_reasonForPause;
242     JSValue m_currentException;
243     CallFrame* m_pauseOnCallFrame { nullptr };
244     CallFrame* m_currentCallFrame { nullptr };
245     unsigned m_lastExecutedLine;
246     SourceID m_lastExecutedSourceID;
<span class="line-added">247     bool m_afterBlackboxedScript { false };</span>
248 
249     BreakpointID m_topBreakpointID;
250     BreakpointID m_pausingBreakpointID;
251     BreakpointIDToBreakpointMap m_breakpointIDToBreakpoint;
252     SourceIDToBreakpointsMap m_sourceIDToBreakpoints;
253 
254     RefPtr&lt;JSC::DebuggerCallFrame&gt; m_currentDebuggerCallFrame;
255 
256     ProfilingClient* m_profilingClient { nullptr };
257 
258     friend class DebuggerPausedScope;
259     friend class TemporaryPausedState;
260     friend class LLIntOffsetsExtractor;
261 };
262 
263 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Debugger.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerCallFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
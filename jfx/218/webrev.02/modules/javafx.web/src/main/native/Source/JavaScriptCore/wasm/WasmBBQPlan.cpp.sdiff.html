<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmBBQPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmB3IRGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmBBQPlan.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmBBQPlan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmBBQPlan.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;

 32 #include &quot;WasmAirIRGenerator.h&quot;
 33 #include &quot;WasmB3IRGenerator.h&quot;
 34 #include &quot;WasmBinding.h&quot;
 35 #include &quot;WasmCallee.h&quot;
 36 #include &quot;WasmCallingConvention.h&quot;
 37 #include &quot;WasmFaultSignalHandler.h&quot;

 38 #include &quot;WasmMemory.h&quot;
<span class="line-removed"> 39 #include &quot;WasmModuleParser.h&quot;</span>
 40 #include &quot;WasmSignatureInlines.h&quot;
 41 #include &quot;WasmTierUpCount.h&quot;
<span class="line-removed"> 42 #include &quot;WasmValidate.h&quot;</span>
 43 #include &lt;wtf/DataLog.h&gt;
 44 #include &lt;wtf/Locker.h&gt;
 45 #include &lt;wtf/MonotonicTime.h&gt;
 46 #include &lt;wtf/StdLibExtras.h&gt;
 47 #include &lt;wtf/SystemTracing.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace JSC { namespace Wasm {
 51 
 52 namespace WasmBBQPlanInternal {
<span class="line-modified"> 53 static const bool verbose = false;</span>
 54 }
 55 
<span class="line-modified"> 56 BBQPlan::BBQPlan(Context* context, Ref&lt;ModuleInformation&gt; info, AsyncWork work, CompletionTask&amp;&amp; task, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
<span class="line-modified"> 57     : Base(context, WTFMove(info), WTFMove(task), WTFMove(createEmbedderWrapper), throwWasmException)</span>
<span class="line-modified"> 58     , m_state(State::Validated)</span>
<span class="line-modified"> 59     , m_asyncWork(work)</span>
 60 {

 61 }
 62 
<span class="line-modified"> 63 BBQPlan::BBQPlan(Context* context, Vector&lt;uint8_t&gt;&amp;&amp; source, AsyncWork work, CompletionTask&amp;&amp; task, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
<span class="line-removed"> 64     : Base(context, ModuleInformation::create(), WTFMove(task), WTFMove(createEmbedderWrapper), throwWasmException)</span>
<span class="line-removed"> 65     , m_source(WTFMove(source))</span>
<span class="line-removed"> 66     , m_state(State::Initial)</span>
<span class="line-removed"> 67     , m_asyncWork(work)</span>
 68 {
<span class="line-modified"> 69 }</span>




 70 
<span class="line-modified"> 71 BBQPlan::BBQPlan(Context* context, AsyncWork work, CompletionTask&amp;&amp; task)</span>
<span class="line-modified"> 72     : Base(context, WTFMove(task))</span>
<span class="line-modified"> 73     , m_state(State::Initial)</span>
<span class="line-modified"> 74     , m_asyncWork(work)</span>
<span class="line-modified"> 75 {</span>
 76 }
 77 
<span class="line-modified"> 78 const char* BBQPlan::stateString(State state)</span>
 79 {
<span class="line-modified"> 80     switch (state) {</span>
<span class="line-modified"> 81     case State::Initial: return &quot;Initial&quot;;</span>
<span class="line-modified"> 82     case State::Validated: return &quot;Validated&quot;;</span>
<span class="line-modified"> 83     case State::Prepared: return &quot;Prepared&quot;;</span>
<span class="line-modified"> 84     case State::Compiled: return &quot;Compiled&quot;;</span>
<span class="line-modified"> 85     case State::Completed: return &quot;Completed&quot;;</span>














 86     }
<span class="line-removed"> 87     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 88 }</span>
 89 
<span class="line-modified"> 90 void BBQPlan::moveToState(State state)</span>
<span class="line-modified"> 91 {</span>
<span class="line-modified"> 92     ASSERT(state &gt;= m_state);</span>
<span class="line-modified"> 93     dataLogLnIf(WasmBBQPlanInternal::verbose &amp;&amp; state != m_state, &quot;moving to state: &quot;, stateString(state), &quot; from state: &quot;, stateString(m_state));</span>
<span class="line-removed"> 94     m_state = state;</span>
<span class="line-removed"> 95 }</span>
 96 
<span class="line-modified"> 97 bool BBQPlan::parseAndValidateModule(const uint8_t* source, size_t sourceLength)</span>
<span class="line-modified"> 98 {</span>
<span class="line-modified"> 99     if (m_state != State::Initial)</span>
<span class="line-modified">100         return true;</span>

101 
<span class="line-modified">102     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;starting validation&quot;);</span>
<span class="line-modified">103     MonotonicTime startTime;</span>
<span class="line-modified">104     if (WasmBBQPlanInternal::verbose || Options::reportCompileTimes())</span>
<span class="line-modified">105         startTime = MonotonicTime::now();</span>


106 

107     {
<span class="line-modified">108         ModuleParser moduleParser(source, sourceLength, m_moduleInformation);</span>
<span class="line-modified">109         auto parseResult = moduleParser.parse();</span>
<span class="line-modified">110         if (!parseResult) {</span>
<span class="line-modified">111             Base::fail(holdLock(m_lock), WTFMove(parseResult.error()));</span>
<span class="line-modified">112             return false;</span>




















113         }
114     }
115 
<span class="line-modified">116     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-modified">117     for (unsigned functionIndex = 0; functionIndex &lt; functions.size(); ++functionIndex) {</span>
<span class="line-modified">118         const auto&amp; function = functions[functionIndex];</span>
<span class="line-modified">119         dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Processing function starting at: &quot;, function.start, &quot; and ending at: &quot;, function.end);</span>
<span class="line-modified">120         size_t functionLength = function.end - function.start;</span>
<span class="line-removed">121         ASSERT(functionLength &lt;= sourceLength);</span>
<span class="line-removed">122         ASSERT(functionLength == function.data.size());</span>
<span class="line-removed">123         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-removed">124         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
125 
<span class="line-modified">126         auto validationResult = validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get());</span>
<span class="line-modified">127         if (!validationResult) {</span>
<span class="line-modified">128             if (WasmBBQPlanInternal::verbose) {</span>
<span class="line-modified">129                 for (unsigned i = 0; i &lt; functionLength; ++i)</span>
<span class="line-modified">130                     dataLog(RawPointer(reinterpret_cast&lt;void*&gt;(function.data[i])), &quot;, &quot;);</span>
<span class="line-modified">131                 dataLogLn();</span>






















132             }
<span class="line-removed">133             Base::fail(holdLock(m_lock), makeString(validationResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
<span class="line-removed">134             return false;</span>
135         }
136     }
137 
<span class="line-modified">138     if (WasmBBQPlanInternal::verbose || Options::reportCompileTimes())</span>
<span class="line-removed">139         dataLogLn(&quot;Took &quot;, (MonotonicTime::now() - startTime).microseconds(), &quot; us to validate module&quot;);</span>
140 
<span class="line-modified">141     moveToState(State::Validated);</span>
<span class="line-modified">142     if (m_asyncWork == Validation)</span>
<span class="line-modified">143         complete(holdLock(m_lock));</span>
<span class="line-modified">144     return true;</span>
145 }
146 
<span class="line-modified">147 void BBQPlan::prepare()</span>
148 {
<span class="line-modified">149     ASSERT(m_state == State::Validated);</span>
<span class="line-removed">150     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting preparation&quot;);</span>
<span class="line-removed">151 </span>
<span class="line-removed">152     auto tryReserveCapacity = [this] (auto&amp; vector, size_t size, const char* what) {</span>
<span class="line-removed">153         if (UNLIKELY(!vector.tryReserveCapacity(size))) {</span>
<span class="line-removed">154             fail(holdLock(m_lock), WTF::makeString(&quot;Failed allocating enough space for &quot;, size, what));</span>
<span class="line-removed">155             return false;</span>
<span class="line-removed">156         }</span>
<span class="line-removed">157         return true;</span>
<span class="line-removed">158     };</span>
159 
<span class="line-modified">160     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-modified">161     if (!tryReserveCapacity(m_wasmToWasmExitStubs, m_moduleInformation-&gt;importFunctionSignatureIndices.size(), &quot; WebAssembly to JavaScript stubs&quot;)</span>
<span class="line-modified">162         || !tryReserveCapacity(m_unlinkedWasmToWasmCalls, functions.size(), &quot; unlinked WebAssembly to WebAssembly calls&quot;)</span>
<span class="line-modified">163         || !tryReserveCapacity(m_wasmInternalFunctions, functions.size(), &quot; WebAssembly functions&quot;)</span>
<span class="line-removed">164         || !tryReserveCapacity(m_compilationContexts, functions.size(), &quot; compilation contexts&quot;)</span>
<span class="line-removed">165         || !tryReserveCapacity(m_tierUpCounts, functions.size(), &quot; tier-up counts&quot;))</span>
<span class="line-removed">166         return;</span>
167 
<span class="line-modified">168     m_unlinkedWasmToWasmCalls.resize(functions.size());</span>
<span class="line-removed">169     m_wasmInternalFunctions.resize(functions.size());</span>
<span class="line-removed">170     m_compilationContexts.resize(functions.size());</span>
<span class="line-removed">171     m_tierUpCounts.resize(functions.size());</span>
<span class="line-removed">172 </span>
<span class="line-removed">173     for (unsigned importIndex = 0; importIndex &lt; m_moduleInformation-&gt;imports.size(); ++importIndex) {</span>
<span class="line-removed">174         Import* import = &amp;m_moduleInformation-&gt;imports[importIndex];</span>
<span class="line-removed">175         if (import-&gt;kind != ExternalKind::Function)</span>
<span class="line-removed">176             continue;</span>
<span class="line-removed">177         unsigned importFunctionIndex = m_wasmToWasmExitStubs.size();</span>
<span class="line-removed">178         dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Processing import function number &quot;, importFunctionIndex, &quot;: &quot;, makeString(import-&gt;module), &quot;: &quot;, makeString(import-&gt;field));</span>
<span class="line-removed">179         auto binding = wasmToWasm(importFunctionIndex);</span>
<span class="line-removed">180         if (UNLIKELY(!binding)) {</span>
<span class="line-removed">181             switch (binding.error()) {</span>
<span class="line-removed">182             case BindingFailure::OutOfMemory:</span>
<span class="line-removed">183                 return fail(holdLock(m_lock), makeString(&quot;Out of executable memory at import &quot;, String::number(importIndex)));</span>
<span class="line-removed">184             }</span>
<span class="line-removed">185             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">186         }</span>
<span class="line-removed">187         m_wasmToWasmExitStubs.uncheckedAppend(binding.value());</span>
<span class="line-removed">188     }</span>
189 
<span class="line-modified">190     const uint32_t importFunctionCount = m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">191     for (const auto&amp; exp : m_moduleInformation-&gt;exports) {</span>
<span class="line-modified">192         if (exp.kindIndex &gt;= importFunctionCount)</span>
<span class="line-modified">193             m_exportedFunctionIndices.add(exp.kindIndex - importFunctionCount);</span>


194     }

195 
<span class="line-modified">196     for (const auto&amp; element : m_moduleInformation-&gt;elements) {</span>
<span class="line-modified">197         for (const uint32_t elementIndex : element.functionIndices) {</span>
<span class="line-modified">198             if (elementIndex &gt;= importFunctionCount)</span>
<span class="line-modified">199                 m_exportedFunctionIndices.add(elementIndex - importFunctionCount);</span>























200         }


201     }
202 
<span class="line-modified">203     if (m_moduleInformation-&gt;startFunctionIndexSpace &amp;&amp; m_moduleInformation-&gt;startFunctionIndexSpace &gt;= importFunctionCount)</span>
<span class="line-removed">204         m_exportedFunctionIndices.add(*m_moduleInformation-&gt;startFunctionIndexSpace - importFunctionCount);</span>
<span class="line-removed">205 </span>
<span class="line-removed">206     moveToState(State::Prepared);</span>
207 }
208 
<span class="line-modified">209 // We don&#39;t have a semaphore class... and this does kinda interesting things.</span>
<span class="line-removed">210 class BBQPlan::ThreadCountHolder {</span>
<span class="line-removed">211 public:</span>
<span class="line-removed">212     ThreadCountHolder(BBQPlan&amp; plan)</span>
<span class="line-removed">213         : m_plan(plan)</span>
<span class="line-removed">214     {</span>
<span class="line-removed">215         LockHolder locker(m_plan.m_lock);</span>
<span class="line-removed">216         m_plan.m_numberOfActiveThreads++;</span>
<span class="line-removed">217     }</span>
<span class="line-removed">218 </span>
<span class="line-removed">219     ~ThreadCountHolder()</span>
<span class="line-removed">220     {</span>
<span class="line-removed">221         LockHolder locker(m_plan.m_lock);</span>
<span class="line-removed">222         m_plan.m_numberOfActiveThreads--;</span>
<span class="line-removed">223 </span>
<span class="line-removed">224         if (!m_plan.m_numberOfActiveThreads &amp;&amp; !m_plan.hasWork())</span>
<span class="line-removed">225             m_plan.complete(locker);</span>
<span class="line-removed">226     }</span>
<span class="line-removed">227 </span>
<span class="line-removed">228     BBQPlan&amp; m_plan;</span>
<span class="line-removed">229 };</span>
<span class="line-removed">230 </span>
<span class="line-removed">231 void BBQPlan::compileFunctions(CompilationEffort effort)</span>
232 {
<span class="line-modified">233     ASSERT(m_state &gt;= State::Prepared);</span>
<span class="line-modified">234     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting compilation&quot;);</span>
<span class="line-modified">235 </span>
<span class="line-modified">236     if (!hasWork())</span>
<span class="line-modified">237         return;</span>
<span class="line-modified">238 </span>
<span class="line-removed">239     Optional&lt;TraceScope&gt; traceScope;</span>
<span class="line-removed">240     if (Options::useTracePoints())</span>
<span class="line-removed">241         traceScope.emplace(WebAssemblyCompileStart, WebAssemblyCompileEnd);</span>
<span class="line-removed">242     ThreadCountHolder holder(*this);</span>
<span class="line-removed">243 </span>
<span class="line-removed">244     size_t bytesCompiled = 0;</span>
<span class="line-removed">245     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-removed">246     while (true) {</span>
<span class="line-removed">247         if (effort == Partial &amp;&amp; bytesCompiled &gt;= Options::webAssemblyPartialCompileLimit())</span>
<span class="line-removed">248             return;</span>
<span class="line-removed">249 </span>
<span class="line-removed">250         uint32_t functionIndex;</span>
251         {
<span class="line-modified">252             auto locker = holdLock(m_lock);</span>
<span class="line-modified">253             if (m_currentIndex &gt;= functions.size()) {</span>
<span class="line-modified">254                 if (hasWork())</span>
<span class="line-removed">255                     moveToState(State::Compiled);</span>
256                 return;
257             }
<span class="line-removed">258             functionIndex = m_currentIndex;</span>
<span class="line-removed">259             ++m_currentIndex;</span>
<span class="line-removed">260         }</span>
261 
<span class="line-modified">262         const auto&amp; function = functions[functionIndex];</span>
<span class="line-modified">263         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">264         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">265         unsigned functionIndexSpace = m_wasmToWasmExitStubs.size() + functionIndex;</span>
<span class="line-removed">266         ASSERT_UNUSED(functionIndexSpace, m_moduleInformation-&gt;signatureIndexFromFunctionIndexSpace(functionIndexSpace) == signatureIndex);</span>
<span class="line-removed">267         ASSERT(validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get()));</span>
<span class="line-removed">268 </span>
<span class="line-removed">269         m_unlinkedWasmToWasmCalls[functionIndex] = Vector&lt;UnlinkedWasmToWasmCall&gt;();</span>
<span class="line-removed">270         if (Options::useBBQTierUpChecks())</span>
<span class="line-removed">271             m_tierUpCounts[functionIndex] = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-removed">272         else</span>
<span class="line-removed">273             m_tierUpCounts[functionIndex] = nullptr;</span>
<span class="line-removed">274         TierUpCount* tierUp = m_tierUpCounts[functionIndex].get();</span>
<span class="line-removed">275         Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileResult;</span>
<span class="line-removed">276         unsigned osrEntryScratchBufferSize = 0;</span>
<span class="line-removed">277 </span>
<span class="line-removed">278         // FIXME: Some webpages use very large Wasm module, and it exhausts all executable memory in ARM64 devices since the size of executable memory region is only limited to 128MB.</span>
<span class="line-removed">279         // The long term solution should be to introduce a Wasm interpreter. But as a short term solution, we introduce heuristics to switch back to BBQ B3 at the sacrifice of start-up time,</span>
<span class="line-removed">280         // as BBQ Air bloats such lengthy Wasm code and will consume a large amount of executable memory.</span>
<span class="line-removed">281         bool forceUsingB3 = false;</span>
<span class="line-removed">282         if (Options::webAssemblyBBQAirModeThreshold() &amp;&amp; m_moduleInformation-&gt;codeSectionSize &gt;= Options::webAssemblyBBQAirModeThreshold())</span>
<span class="line-removed">283             forceUsingB3 = true;</span>
<span class="line-removed">284 </span>
<span class="line-removed">285         if (!forceUsingB3 &amp;&amp; Options::wasmBBQUsesAir())</span>
<span class="line-removed">286             parseAndCompileResult = parseAndCompileAir(m_compilationContexts[functionIndex], function.data.data(), function.data.size(), signature, m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex, tierUp, m_throwWasmException);</span>
<span class="line-removed">287         else</span>
<span class="line-removed">288             parseAndCompileResult = parseAndCompile(m_compilationContexts[functionIndex], function.data.data(), function.data.size(), signature, m_unlinkedWasmToWasmCalls[functionIndex], osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::BBQMode, functionIndex, UINT32_MAX, tierUp, m_throwWasmException);</span>
<span class="line-removed">289 </span>
<span class="line-removed">290         if (UNLIKELY(!parseAndCompileResult)) {</span>
<span class="line-removed">291             auto locker = holdLock(m_lock);</span>
<span class="line-removed">292             if (!m_errorMessage) {</span>
<span class="line-removed">293                 // Multiple compiles could fail simultaneously. We arbitrarily choose the first.</span>
<span class="line-removed">294                 fail(locker, makeString(parseAndCompileResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
<span class="line-removed">295             }</span>
<span class="line-removed">296             m_currentIndex = functions.size();</span>
<span class="line-removed">297             return;</span>
298         }
299 
<span class="line-modified">300         m_wasmInternalFunctions[functionIndex] = WTFMove(*parseAndCompileResult);</span>





301 
<span class="line-modified">302         if (m_exportedFunctionIndices.contains(functionIndex) || m_moduleInformation-&gt;referencedFunctions().contains(functionIndex)) {</span>
<span class="line-modified">303             auto locker = holdLock(m_lock);</span>
<span class="line-modified">304             auto result = m_embedderToWasmInternalFunctions.add(functionIndex, m_createEmbedderWrapper(m_compilationContexts[functionIndex], signature, &amp;m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex));</span>
<span class="line-removed">305             ASSERT_UNUSED(result, result.isNewEntry);</span>
306         }

307 
<span class="line-modified">308         bytesCompiled += function.data.size();</span>









309     }
310 }
311 
<span class="line-modified">312 void BBQPlan::complete(const AbstractLocker&amp; locker)</span>
313 {
<span class="line-modified">314     ASSERT(m_state != State::Compiled || m_currentIndex &gt;= m_moduleInformation-&gt;functions.size());</span>
<span class="line-modified">315     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting Completion&quot;);</span>
<span class="line-removed">316 </span>
<span class="line-removed">317     if (!failed() &amp;&amp; m_state == State::Compiled) {</span>
<span class="line-removed">318         for (uint32_t functionIndex = 0; functionIndex &lt; m_moduleInformation-&gt;functions.size(); functionIndex++) {</span>
<span class="line-removed">319             CompilationContext&amp; context = m_compilationContexts[functionIndex];</span>
<span class="line-removed">320             SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-removed">321             const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">322             const uint32_t functionIndexSpace = functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-removed">323             ASSERT(functionIndexSpace &lt; m_moduleInformation-&gt;functionIndexSpaceSize());</span>
<span class="line-removed">324             {</span>
<span class="line-removed">325                 LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-removed">326                 if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-removed">327                     Base::fail(locker, makeString(&quot;Out of executable memory in function at index &quot;, String::number(functionIndex)));</span>
<span class="line-removed">328                     return;</span>
<span class="line-removed">329                 }</span>
<span class="line-removed">330 </span>
<span class="line-removed">331                 m_wasmInternalFunctions[functionIndex]-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-removed">332                     FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-removed">333                     WTFMove(context.wasmEntrypointByproducts));</span>
<span class="line-removed">334             }</span>
<span class="line-removed">335 </span>
<span class="line-removed">336             if (auto embedderToWasmInternalFunction = m_embedderToWasmInternalFunctions.get(functionIndex)) {</span>
<span class="line-removed">337                 LinkBuffer linkBuffer(*context.embedderEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-removed">338                 if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-removed">339                     Base::fail(locker, makeString(&quot;Out of executable memory in function entrypoint at index &quot;, String::number(functionIndex)));</span>
<span class="line-removed">340                     return;</span>
<span class="line-removed">341                 }</span>
342 
<span class="line-modified">343                 embedderToWasmInternalFunction-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">344                     FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Embedder-&gt;WebAssembly entrypoint[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">345                     WTFMove(context.embedderEntrypointByproducts));</span>
<span class="line-modified">346             }</span>
347         }
348 
<span class="line-modified">349         for (auto&amp; unlinked : m_unlinkedWasmToWasmCalls) {</span>
<span class="line-modified">350             for (auto&amp; call : unlinked) {</span>
<span class="line-modified">351                 MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; executableAddress;</span>
<span class="line-modified">352                 if (m_moduleInformation-&gt;isImportedFunctionFromFunctionIndexSpace(call.functionIndexSpace)) {</span>
<span class="line-removed">353                     // FIXME imports could have been linked in B3, instead of generating a patchpoint. This condition should be replaced by a RELEASE_ASSERT. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
<span class="line-removed">354                     executableAddress = m_wasmToWasmExitStubs.at(call.functionIndexSpace).code();</span>
<span class="line-removed">355                 } else</span>
<span class="line-removed">356                     executableAddress = m_wasmInternalFunctions.at(call.functionIndexSpace - m_moduleInformation-&gt;importFunctionCount())-&gt;entrypoint.compilation-&gt;code().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-removed">357                 MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(executableAddress));</span>
<span class="line-removed">358             }</span>
<span class="line-removed">359         }</span>
<span class="line-removed">360     }</span>
361 
<span class="line-modified">362     if (!isComplete()) {</span>
<span class="line-removed">363         moveToState(State::Completed);</span>
<span class="line-removed">364         runCompletionTasks(locker);</span>
365     }
366 }
367 
<span class="line-modified">368 void BBQPlan::work(CompilationEffort effort)</span>
369 {
<span class="line-modified">370     switch (m_state) {</span>
<span class="line-removed">371     case State::Initial:</span>
<span class="line-removed">372         parseAndValidateModule(m_source.data(), m_source.size());</span>
<span class="line-removed">373         if (!hasWork()) {</span>
<span class="line-removed">374             ASSERT(isComplete());</span>
<span class="line-removed">375             return;</span>
<span class="line-removed">376         }</span>
<span class="line-removed">377         FALLTHROUGH;</span>
<span class="line-removed">378     case State::Validated:</span>
<span class="line-removed">379         prepare();</span>
<span class="line-removed">380         return;</span>
<span class="line-removed">381     case State::Prepared:</span>
<span class="line-removed">382         compileFunctions(effort);</span>
<span class="line-removed">383         return;</span>
<span class="line-removed">384     default:</span>
<span class="line-removed">385         break;</span>
<span class="line-removed">386     }</span>
<span class="line-removed">387     return;</span>
388 }
389 
390 } } // namespace JSC::Wasm
391 
392 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmBBQPlan.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;
<span class="line-added"> 32 #include &quot;JSToWasm.h&quot;</span>
 33 #include &quot;WasmAirIRGenerator.h&quot;
 34 #include &quot;WasmB3IRGenerator.h&quot;
 35 #include &quot;WasmBinding.h&quot;
 36 #include &quot;WasmCallee.h&quot;
 37 #include &quot;WasmCallingConvention.h&quot;
 38 #include &quot;WasmFaultSignalHandler.h&quot;
<span class="line-added"> 39 #include &quot;WasmMachineThreads.h&quot;</span>
 40 #include &quot;WasmMemory.h&quot;

 41 #include &quot;WasmSignatureInlines.h&quot;
 42 #include &quot;WasmTierUpCount.h&quot;

 43 #include &lt;wtf/DataLog.h&gt;
 44 #include &lt;wtf/Locker.h&gt;
 45 #include &lt;wtf/MonotonicTime.h&gt;
 46 #include &lt;wtf/StdLibExtras.h&gt;
 47 #include &lt;wtf/SystemTracing.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace JSC { namespace Wasm {
 51 
 52 namespace WasmBBQPlanInternal {
<span class="line-modified"> 53 static constexpr bool verbose = false;</span>
 54 }
 55 
<span class="line-modified"> 56 BBQPlan::BBQPlan(Context* context, Ref&lt;ModuleInformation&gt; moduleInformation, uint32_t functionIndex, CodeBlock* codeBlock, CompletionTask&amp;&amp; completionTask)</span>
<span class="line-modified"> 57     : EntryPlan(context, WTFMove(moduleInformation), AsyncWork::FullCompile, WTFMove(completionTask))</span>
<span class="line-modified"> 58     , m_codeBlock(codeBlock)</span>
<span class="line-modified"> 59     , m_functionIndex(functionIndex)</span>
 60 {
<span class="line-added"> 61     setMode(m_codeBlock-&gt;mode());</span>
 62 }
 63 
<span class="line-modified"> 64 bool BBQPlan::prepareImpl()</span>




 65 {
<span class="line-modified"> 66     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-added"> 67     if (!tryReserveCapacity(m_wasmInternalFunctions, functions.size(), &quot; WebAssembly functions&quot;)</span>
<span class="line-added"> 68         || !tryReserveCapacity(m_compilationContexts, functions.size(), &quot; compilation contexts&quot;)</span>
<span class="line-added"> 69         || !tryReserveCapacity(m_tierUpCounts, functions.size(), &quot; tier-up counts&quot;))</span>
<span class="line-added"> 70         return false;</span>
 71 
<span class="line-modified"> 72     m_wasmInternalFunctions.resize(functions.size());</span>
<span class="line-modified"> 73     m_compilationContexts.resize(functions.size());</span>
<span class="line-modified"> 74     m_tierUpCounts.resize(functions.size());</span>
<span class="line-modified"> 75 </span>
<span class="line-modified"> 76     return true;</span>
 77 }
 78 
<span class="line-modified"> 79 void BBQPlan::work(CompilationEffort effort)</span>
 80 {
<span class="line-modified"> 81     if (!m_codeBlock) {</span>
<span class="line-modified"> 82         switch (m_state) {</span>
<span class="line-modified"> 83         case State::Initial:</span>
<span class="line-modified"> 84             parseAndValidateModule();</span>
<span class="line-modified"> 85             if (!hasWork()) {</span>
<span class="line-modified"> 86                 ASSERT(m_state == State::Validated);</span>
<span class="line-added"> 87                 complete(holdLock(m_lock));</span>
<span class="line-added"> 88                 break;</span>
<span class="line-added"> 89             }</span>
<span class="line-added"> 90             FALLTHROUGH;</span>
<span class="line-added"> 91         case State::Validated:</span>
<span class="line-added"> 92             prepare();</span>
<span class="line-added"> 93             break;</span>
<span class="line-added"> 94         case State::Prepared:</span>
<span class="line-added"> 95             compileFunctions(effort);</span>
<span class="line-added"> 96             break;</span>
<span class="line-added"> 97         default:</span>
<span class="line-added"> 98             break;</span>
<span class="line-added"> 99         }</span>
<span class="line-added">100         return;</span>
101     }


102 
<span class="line-modified">103     CompilationContext context;</span>
<span class="line-modified">104     Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedWasmToWasmCalls;</span>
<span class="line-modified">105     std::unique_ptr&lt;TierUpCount&gt; tierUp = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-modified">106     std::unique_ptr&lt;InternalFunction&gt; function = compileFunction(m_functionIndex, context, unlinkedWasmToWasmCalls, tierUp.get());</span>


107 
<span class="line-modified">108     LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-modified">109     if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-modified">110         Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));</span>
<span class="line-modified">111         return;</span>
<span class="line-added">112     }</span>
113 
<span class="line-modified">114     size_t functionIndexSpace = m_functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">115     SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];</span>
<span class="line-modified">116     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-modified">117     function-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-added">118         FINALIZE_WASM_CODE_FOR_MODE(CompilationMode::BBQMode, linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-added">119         WTFMove(context.wasmEntrypointByproducts));</span>
120 
<span class="line-added">121     MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;</span>
122     {
<span class="line-modified">123         Ref&lt;BBQCallee&gt; callee = BBQCallee::create(WTFMove(function-&gt;entrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(tierUp), WTFMove(unlinkedWasmToWasmCalls));</span>
<span class="line-modified">124         MacroAssembler::repatchPointer(function-&gt;calleeMoveLocation, CalleeBits::boxWasm(callee.ptr()));</span>
<span class="line-modified">125         ASSERT(!m_codeBlock-&gt;m_bbqCallees[m_functionIndex]);</span>
<span class="line-modified">126         entrypoint = callee-&gt;entrypoint();</span>
<span class="line-modified">127 </span>
<span class="line-added">128         // We want to make sure we publish our callee at the same time as we link our callsites. This enables us to ensure we</span>
<span class="line-added">129         // always call the fastest code. Any function linked after us will see our new code and the new callsites, which they</span>
<span class="line-added">130         // will update. It&#39;s also ok if they publish their code before we reset the instruction caches because after we release</span>
<span class="line-added">131         // the lock our code is ready to be published too.</span>
<span class="line-added">132         LockHolder holder(m_codeBlock-&gt;m_lock);</span>
<span class="line-added">133         m_codeBlock-&gt;m_bbqCallees[m_functionIndex] = callee.copyRef();</span>
<span class="line-added">134         {</span>
<span class="line-added">135             LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(m_functionIndex).get();</span>
<span class="line-added">136             auto locker = holdLock(llintCallee.tierUpCounter().m_lock);</span>
<span class="line-added">137             llintCallee.setReplacement(callee.copyRef());</span>
<span class="line-added">138             llintCallee.tierUpCounter().m_compilationStatus = LLIntTierUpCounter::CompilationStatus::Compiled;</span>
<span class="line-added">139         }</span>
<span class="line-added">140         for (auto&amp; call : callee-&gt;wasmToWasmCallsites()) {</span>
<span class="line-added">141             MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;</span>
<span class="line-added">142             if (call.functionIndexSpace &lt; m_moduleInformation-&gt;importFunctionCount())</span>
<span class="line-added">143                 entrypoint = m_codeBlock-&gt;m_wasmToWasmExitStubs[call.functionIndexSpace].code();</span>
<span class="line-added">144             else</span>
<span class="line-added">145                 entrypoint = m_codeBlock-&gt;wasmEntrypointCalleeFromFunctionIndexSpace(call.functionIndexSpace).entrypoint().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-added">146 </span>
<span class="line-added">147             MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));</span>
148         }
149     }
150 
<span class="line-modified">151     // It&#39;s important to make sure we do this before we make any of the code we just compiled visible. If we didn&#39;t, we could end up</span>
<span class="line-modified">152     // where we are tiering up some function A to A&#39; and we repatch some function B to call A&#39; instead of A. Another CPU could see</span>
<span class="line-modified">153     // the updates to B but still not have reset its cache of A&#39;, which would lead to all kinds of badness.</span>
<span class="line-modified">154     resetInstructionCacheOnAllThreads();</span>
<span class="line-modified">155     WTF::storeStoreFence(); // This probably isn&#39;t necessary but it&#39;s good to be paranoid.</span>




156 
<span class="line-modified">157     m_codeBlock-&gt;m_wasmIndirectCallEntryPoints[m_functionIndex] = entrypoint;</span>
<span class="line-modified">158     {</span>
<span class="line-modified">159         LockHolder holder(m_codeBlock-&gt;m_lock);</span>
<span class="line-modified">160 </span>
<span class="line-modified">161         auto repatchCalls = [&amp;] (const Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; callsites) {</span>
<span class="line-modified">162             for (auto&amp; call : callsites) {</span>
<span class="line-added">163                 dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Considering repatching call at: &quot;, RawPointer(call.callLocation.dataLocation()), &quot; that targets &quot;, call.functionIndexSpace);</span>
<span class="line-added">164                 if (call.functionIndexSpace == functionIndexSpace) {</span>
<span class="line-added">165                     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Repatching call at: &quot;, RawPointer(call.callLocation.dataLocation()), &quot; to &quot;, RawPointer(entrypoint.executableAddress()));</span>
<span class="line-added">166                     MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));</span>
<span class="line-added">167                 }</span>
<span class="line-added">168             }</span>
<span class="line-added">169         };</span>
<span class="line-added">170 </span>
<span class="line-added">171         for (unsigned i = 0; i &lt; m_codeBlock-&gt;m_wasmToWasmCallsites.size(); ++i) {</span>
<span class="line-added">172             repatchCalls(m_codeBlock-&gt;m_wasmToWasmCallsites[i]);</span>
<span class="line-added">173             if (m_codeBlock-&gt;m_llintCallees) {</span>
<span class="line-added">174                 LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(i).get();</span>
<span class="line-added">175                 if (JITCallee* replacementCallee = llintCallee.replacement())</span>
<span class="line-added">176                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">177                 if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee())</span>
<span class="line-added">178                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">179             }</span>
<span class="line-added">180             if (BBQCallee* bbqCallee = m_codeBlock-&gt;m_bbqCallees[i].get()) {</span>
<span class="line-added">181                 if (OMGCallee* replacementCallee = bbqCallee-&gt;replacement())</span>
<span class="line-added">182                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">183                 if (OMGForOSREntryCallee* osrEntryCallee = bbqCallee-&gt;osrEntryCallee())</span>
<span class="line-added">184                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
185             }


186         }
187     }
188 
<span class="line-modified">189     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Finished BBQ &quot;, m_functionIndex);</span>

190 
<span class="line-modified">191 </span>
<span class="line-modified">192     auto locker = holdLock(m_lock);</span>
<span class="line-modified">193     moveToState(State::Completed);</span>
<span class="line-modified">194     runCompletionTasks(locker);</span>
195 }
196 
<span class="line-modified">197 void BBQPlan::compileFunction(uint32_t functionIndex)</span>
198 {
<span class="line-modified">199     m_unlinkedWasmToWasmCalls[functionIndex] = Vector&lt;UnlinkedWasmToWasmCall&gt;();</span>









200 
<span class="line-modified">201     if (Options::useBBQTierUpChecks())</span>
<span class="line-modified">202         m_tierUpCounts[functionIndex] = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-modified">203     else</span>
<span class="line-modified">204         m_tierUpCounts[functionIndex] = nullptr;</span>



205 
<span class="line-modified">206     m_wasmInternalFunctions[functionIndex] = compileFunction(functionIndex, m_compilationContexts[functionIndex], m_unlinkedWasmToWasmCalls[functionIndex], m_tierUpCounts[functionIndex].get());</span>




















207 
<span class="line-modified">208     if (m_exportedFunctionIndices.contains(functionIndex) || m_moduleInformation-&gt;referencedFunctions().contains(functionIndex)) {</span>
<span class="line-modified">209         auto locker = holdLock(m_lock);</span>
<span class="line-modified">210         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">211         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">212         auto result = m_embedderToWasmInternalFunctions.add(functionIndex, createJSToWasmWrapper(*m_compilationContexts[functionIndex].embedderEntrypointJIT, signature, &amp;m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex));</span>
<span class="line-added">213         ASSERT_UNUSED(result, result.isNewEntry);</span>
214     }
<span class="line-added">215 }</span>
216 
<span class="line-modified">217 std::unique_ptr&lt;InternalFunction&gt; BBQPlan::compileFunction(uint32_t functionIndex, CompilationContext&amp; context, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, TierUpCount* tierUp)</span>
<span class="line-modified">218 {</span>
<span class="line-modified">219     const auto&amp; function = m_moduleInformation-&gt;functions[functionIndex];</span>
<span class="line-modified">220     SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-added">221     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">222     unsigned functionIndexSpace = m_moduleInformation-&gt;importFunctionCount() + functionIndex;</span>
<span class="line-added">223     ASSERT_UNUSED(functionIndexSpace, m_moduleInformation-&gt;signatureIndexFromFunctionIndexSpace(functionIndexSpace) == signatureIndex);</span>
<span class="line-added">224     Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileResult;</span>
<span class="line-added">225     unsigned osrEntryScratchBufferSize = 0;</span>
<span class="line-added">226 </span>
<span class="line-added">227     // FIXME: Some webpages use very large Wasm module, and it exhausts all executable memory in ARM64 devices since the size of executable memory region is only limited to 128MB.</span>
<span class="line-added">228     // The long term solution should be to introduce a Wasm interpreter. But as a short term solution, we introduce heuristics to switch back to BBQ B3 at the sacrifice of start-up time,</span>
<span class="line-added">229     // as BBQ Air bloats such lengthy Wasm code and will consume a large amount of executable memory.</span>
<span class="line-added">230     bool forceUsingB3 = false;</span>
<span class="line-added">231     if (Options::webAssemblyBBQAirModeThreshold() &amp;&amp; m_moduleInformation-&gt;codeSectionSize &gt;= Options::webAssemblyBBQAirModeThreshold())</span>
<span class="line-added">232         forceUsingB3 = true;</span>
<span class="line-added">233 </span>
<span class="line-added">234     if (!forceUsingB3 &amp;&amp; Options::wasmBBQUsesAir())</span>
<span class="line-added">235         parseAndCompileResult = parseAndCompileAir(context, function, signature, unlinkedWasmToWasmCalls, m_moduleInformation.get(), m_mode, functionIndex, tierUp);</span>
<span class="line-added">236     else</span>
<span class="line-added">237         parseAndCompileResult = parseAndCompile(context, function, signature, unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::BBQMode, functionIndex, UINT32_MAX, tierUp);</span>
<span class="line-added">238 </span>
<span class="line-added">239     if (UNLIKELY(!parseAndCompileResult)) {</span>
<span class="line-added">240         auto locker = holdLock(m_lock);</span>
<span class="line-added">241         if (!m_errorMessage) {</span>
<span class="line-added">242             // Multiple compiles could fail simultaneously. We arbitrarily choose the first.</span>
<span class="line-added">243             fail(locker, makeString(parseAndCompileResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
244         }
<span class="line-added">245         m_currentIndex = m_moduleInformation-&gt;functions.size();</span>
<span class="line-added">246         return nullptr;</span>
247     }
248 
<span class="line-modified">249     return WTFMove(*parseAndCompileResult);</span>



250 }
251 
<span class="line-modified">252 void BBQPlan::didCompleteCompilation(const AbstractLocker&amp; locker)</span>






















253 {
<span class="line-modified">254     for (uint32_t functionIndex = 0; functionIndex &lt; m_moduleInformation-&gt;functions.size(); functionIndex++) {</span>
<span class="line-modified">255         CompilationContext&amp; context = m_compilationContexts[functionIndex];</span>
<span class="line-modified">256         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">257         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-modified">258         const uint32_t functionIndexSpace = functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">259         ASSERT(functionIndexSpace &lt; m_moduleInformation-&gt;functionIndexSpaceSize());</span>












260         {
<span class="line-modified">261             LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-modified">262             if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-modified">263                 Base::fail(locker, makeString(&quot;Out of executable memory in function at index &quot;, String::number(functionIndex)));</span>

264                 return;
265             }



266 
<span class="line-modified">267             m_wasmInternalFunctions[functionIndex]-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">268                 FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">269                 WTFMove(context.wasmEntrypointByproducts));</span>

































270         }
271 
<span class="line-modified">272         if (const auto&amp; embedderToWasmInternalFunction = m_embedderToWasmInternalFunctions.get(functionIndex)) {</span>
<span class="line-added">273             LinkBuffer linkBuffer(*context.embedderEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-added">274             if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-added">275                 Base::fail(locker, makeString(&quot;Out of executable memory in function entrypoint at index &quot;, String::number(functionIndex)));</span>
<span class="line-added">276                 return;</span>
<span class="line-added">277             }</span>
278 
<span class="line-modified">279             embedderToWasmInternalFunction-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">280                 FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Embedder-&gt;WebAssembly entrypoint[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">281                 WTFMove(context.embedderEntrypointByproducts));</span>

282         }
<span class="line-added">283     }</span>
284 
<span class="line-modified">285     for (auto&amp; unlinked : m_unlinkedWasmToWasmCalls) {</span>
<span class="line-added">286         for (auto&amp; call : unlinked) {</span>
<span class="line-added">287             MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; executableAddress;</span>
<span class="line-added">288             if (m_moduleInformation-&gt;isImportedFunctionFromFunctionIndexSpace(call.functionIndexSpace)) {</span>
<span class="line-added">289                 // FIXME imports could have been linked in B3, instead of generating a patchpoint. This condition should be replaced by a RELEASE_ASSERT. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
<span class="line-added">290                 executableAddress = m_wasmToWasmExitStubs.at(call.functionIndexSpace).code();</span>
<span class="line-added">291             } else</span>
<span class="line-added">292                 executableAddress = m_wasmInternalFunctions.at(call.functionIndexSpace - m_moduleInformation-&gt;importFunctionCount())-&gt;entrypoint.compilation-&gt;code().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-added">293             MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(executableAddress));</span>
<span class="line-added">294         }</span>
295     }
296 }
297 
<span class="line-modified">298 void BBQPlan::initializeCallees(const CalleeInitializer&amp; callback)</span>
299 {
<span class="line-modified">300     ASSERT(!failed());</span>
<span class="line-modified">301     for (unsigned internalFunctionIndex = 0; internalFunctionIndex &lt; m_wasmInternalFunctions.size(); ++internalFunctionIndex) {</span>


























302 
<span class="line-modified">303         RefPtr&lt;EmbedderEntrypointCallee&gt; embedderEntrypointCallee;</span>
<span class="line-modified">304         if (auto embedderToWasmFunction = m_embedderToWasmInternalFunctions.get(internalFunctionIndex)) {</span>
<span class="line-modified">305             embedderEntrypointCallee = EmbedderEntrypointCallee::create(WTFMove(embedderToWasmFunction-&gt;entrypoint));</span>
<span class="line-modified">306             MacroAssembler::repatchPointer(embedderToWasmFunction-&gt;calleeMoveLocation, CalleeBits::boxWasm(embedderEntrypointCallee.get()));</span>
307         }
308 
<span class="line-modified">309         InternalFunction* function = m_wasmInternalFunctions[internalFunctionIndex].get();</span>
<span class="line-modified">310         size_t functionIndexSpace = internalFunctionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">311         Ref&lt;BBQCallee&gt; wasmEntrypointCallee = BBQCallee::create(WTFMove(function-&gt;entrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(m_tierUpCounts[internalFunctionIndex]), WTFMove(m_unlinkedWasmToWasmCalls[internalFunctionIndex]));</span>
<span class="line-modified">312         MacroAssembler::repatchPointer(function-&gt;calleeMoveLocation, CalleeBits::boxWasm(wasmEntrypointCallee.ptr()));</span>








313 
<span class="line-modified">314         callback(internalFunctionIndex, WTFMove(embedderEntrypointCallee), WTFMove(wasmEntrypointCallee));</span>


315     }
316 }
317 
<span class="line-modified">318 bool BBQPlan::didReceiveFunctionData(unsigned, const FunctionData&amp;)</span>
319 {
<span class="line-modified">320     return true;</span>

















321 }
322 
323 } } // namespace JSC::Wasm
324 
325 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmB3IRGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmBBQPlan.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
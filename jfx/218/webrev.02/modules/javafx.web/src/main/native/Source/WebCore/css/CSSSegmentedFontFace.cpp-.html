<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/css/CSSSegmentedFontFace.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008, 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSSegmentedFontFace.h&quot;
 28 
 29 #include &quot;CSSFontFace.h&quot;
 30 #include &quot;Font.h&quot;
 31 #include &quot;FontCache.h&quot;
 32 #include &quot;FontDescription.h&quot;
 33 #include &quot;FontSelector.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 CSSSegmentedFontFace::CSSSegmentedFontFace()
 38 {
 39 }
 40 
 41 CSSSegmentedFontFace::~CSSSegmentedFontFace()
 42 {
 43     for (auto&amp; face : m_fontFaces)
 44         face-&gt;removeClient(*this);
 45 }
 46 
 47 void CSSSegmentedFontFace::appendFontFace(Ref&lt;CSSFontFace&gt;&amp;&amp; fontFace)
 48 {
 49     m_cache.clear();
 50     fontFace-&gt;addClient(*this);
 51     m_fontFaces.append(WTFMove(fontFace));
 52 }
 53 
 54 void CSSSegmentedFontFace::fontLoaded(CSSFontFace&amp;)
 55 {
 56     m_cache.clear();
 57 }
 58 
 59 class CSSFontAccessor final : public FontAccessor {
 60 public:
 61     static Ref&lt;CSSFontAccessor&gt; create(CSSFontFace&amp; fontFace, const FontDescription&amp; fontDescription, bool syntheticBold, bool syntheticItalic)
 62     {
 63         return adoptRef(*new CSSFontAccessor(fontFace, fontDescription, syntheticBold, syntheticItalic));
 64     }
 65 
 66     const Font* font(ExternalResourceDownloadPolicy policy) const final
 67     {
 68         if (!m_result || (policy == ExternalResourceDownloadPolicy::Allow
 69             &amp;&amp; (m_fontFace-&gt;status() == CSSFontFace::Status::Pending || m_fontFace-&gt;status() == CSSFontFace::Status::Loading || m_fontFace-&gt;status() == CSSFontFace::Status::TimedOut))) {
 70             const auto result = m_fontFace-&gt;font(m_fontDescription, m_syntheticBold, m_syntheticItalic, policy);
 71             if (!m_result)
 72                 m_result = result;
 73         }
 74         return m_result.value().get();
 75     }
 76 
 77 private:
 78     CSSFontAccessor(CSSFontFace&amp; fontFace, const FontDescription&amp; fontDescription, bool syntheticBold, bool syntheticItalic)
 79         : m_fontFace(fontFace)
 80         , m_fontDescription(fontDescription)
 81         , m_syntheticBold(syntheticBold)
 82         , m_syntheticItalic(syntheticItalic)
 83     {
 84     }
 85 
 86     bool isLoading() const final
 87     {
 88         return m_result &amp;&amp; m_result.value() &amp;&amp; m_result.value()-&gt;isInterstitial();
 89     }
 90 
 91     mutable Optional&lt;RefPtr&lt;Font&gt;&gt; m_result; // Caches nullptr too
 92     mutable Ref&lt;CSSFontFace&gt; m_fontFace;
 93     FontDescription m_fontDescription;
 94     bool m_syntheticBold;
 95     bool m_syntheticItalic;
 96 };
 97 
 98 static void appendFont(FontRanges&amp; ranges, Ref&lt;FontAccessor&gt;&amp;&amp; fontAccessor, const Vector&lt;CSSFontFace::UnicodeRange&gt;&amp; unicodeRanges)
 99 {
100     if (unicodeRanges.isEmpty()) {
101         ranges.appendRange({ 0, 0x7FFFFFFF, WTFMove(fontAccessor) });
102         return;
103     }
104 
105     for (auto&amp; range : unicodeRanges)
106         ranges.appendRange({ range.from, range.to, fontAccessor.copyRef() });
107 }
108 
109 FontRanges CSSSegmentedFontFace::fontRanges(const FontDescription&amp; fontDescription)
110 {
111     auto desiredRequest = fontDescription.fontSelectionRequest();
112 
113     auto addResult = m_cache.add(FontDescriptionKey(fontDescription), FontRanges());
114     auto&amp; result = addResult.iterator-&gt;value;
115 
116     if (addResult.isNewEntry) {
117         for (auto&amp; face : m_fontFaces) {
118             if (face-&gt;computeFailureState())
119                 continue;
120 
121             auto selectionCapabilities = face-&gt;fontSelectionCapabilities();
122             bool syntheticBold = (fontDescription.fontSynthesis() &amp; FontSynthesisWeight) &amp;&amp; !isFontWeightBold(selectionCapabilities.weight.maximum) &amp;&amp; isFontWeightBold(desiredRequest.weight);
123             bool syntheticItalic = (fontDescription.fontSynthesis() &amp; FontSynthesisStyle) &amp;&amp; !isItalic(selectionCapabilities.slope.maximum) &amp;&amp; isItalic(desiredRequest.slope);
124 
125             // Metrics used for layout come from FontRanges::fontForFirstRange(), which assumes that the first font is non-null.
126             auto fontAccessor = CSSFontAccessor::create(face, fontDescription, syntheticBold, syntheticItalic);
127             if (result.isNull() &amp;&amp; !fontAccessor-&gt;font(ExternalResourceDownloadPolicy::Forbid))
128                 continue;
129             appendFont(result, WTFMove(fontAccessor), face-&gt;ranges());
130         }
131     }
132     return result;
133 }
134 
135 }
    </pre>
  </body>
</html>
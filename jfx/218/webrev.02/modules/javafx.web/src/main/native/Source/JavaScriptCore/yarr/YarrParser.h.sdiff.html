<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrPattern.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009, 2014-2016 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  37 namespace JSC { namespace Yarr {
  38 
  39 // The Parser class should not be used directly - only via the Yarr::parse() method.
  40 template&lt;class Delegate, typename CharType&gt;
  41 class Parser {
  42 private:
  43     template&lt;class FriendDelegate&gt;
  44     friend ErrorCode parse(FriendDelegate&amp;, const String&amp; pattern, bool isUnicode, unsigned backReferenceLimit);
  45 
  46     /*
  47      * CharacterClassParserDelegate:
  48      *
  49      * The class CharacterClassParserDelegate is used in the parsing of character
  50      * classes.  This class handles detection of character ranges.  This class
  51      * implements enough of the delegate interface such that it can be passed to
  52      * parseEscape() as an EscapeDelegate.  This allows parseEscape() to be reused
  53      * to perform the parsing of escape characters in character sets.
  54      */
  55     class CharacterClassParserDelegate {
  56     public:
<span class="line-modified">  57         CharacterClassParserDelegate(Delegate&amp; delegate, ErrorCode&amp; err)</span>
  58             : m_delegate(delegate)
  59             , m_errorCode(err)

  60             , m_state(Empty)
  61             , m_character(0)
  62         {
  63         }
  64 
  65         /*
  66          * begin():
  67          *
  68          * Called at beginning of construction.
  69          */
  70         void begin(bool invert)
  71         {
  72             m_delegate.atomCharacterClassBegin(invert);
  73         }
  74 
  75         /*
  76          * atomPatternCharacter():
  77          *
  78          * This method is called either from parseCharacterClass() (for an unescaped
  79          * character in a character class), or from parseEscape(). In the former case
  80          * the value true will be passed for the argument &#39;hyphenIsRange&#39;, and in this
  81          * mode we will allow a hypen to be treated as indicating a range (i.e. /[a-z]/
  82          * is different to /[a\-z]/).
  83          */
  84         void atomPatternCharacter(UChar32 ch, bool hyphenIsRange = false)
  85         {
  86             switch (m_state) {
  87             case AfterCharacterClass:
<span class="line-modified">  88                 // Following a builtin character class we need look out for a hyphen.</span>
  89                 // We&#39;re looking for invalid ranges, such as /[\d-x]/ or /[\d-\d]/.
<span class="line-modified">  90                 // If we see a hyphen following a charater class then unlike usual</span>
  91                 // we&#39;ll report it to the delegate immediately, and put ourself into
<span class="line-modified">  92                 // a poisoned state. Any following calls to add another character or</span>
<span class="line-modified">  93                 // character class will result in an error. (A hypen following a</span>
<span class="line-modified">  94                 // character-class is itself valid, but only  at the end of a regex).</span>

  95                 if (hyphenIsRange &amp;&amp; ch == &#39;-&#39;) {
  96                     m_delegate.atomCharacterClassAtom(&#39;-&#39;);
  97                     m_state = AfterCharacterClassHyphen;
  98                     return;
  99                 }
 100                 // Otherwise just fall through - cached character so treat this as Empty.
 101                 FALLTHROUGH;
 102 
 103             case Empty:
 104                 m_character = ch;
 105                 m_state = CachedCharacter;
 106                 return;
 107 
 108             case CachedCharacter:
 109                 if (hyphenIsRange &amp;&amp; ch == &#39;-&#39;)
 110                     m_state = CachedCharacterHyphen;
 111                 else {
 112                     m_delegate.atomCharacterClassAtom(m_character);
 113                     m_character = ch;
 114                 }
 115                 return;
 116 
 117             case CachedCharacterHyphen:
 118                 if (ch &lt; m_character) {
<span class="line-modified"> 119                     m_errorCode = ErrorCode::CharacterClassOutOfOrder;</span>
 120                     return;
 121                 }
 122                 m_delegate.atomCharacterClassRange(m_character, ch);
 123                 m_state = Empty;
 124                 return;
 125 
<span class="line-modified"> 126                 // See coment in atomBuiltInCharacterClass below.</span>
<span class="line-modified"> 127                 // This too is technically an error, per ECMA-262, and again we</span>
<span class="line-removed"> 128                 // we chose to allow this.  Note a subtlely here that while we</span>
<span class="line-removed"> 129                 // diverge from the spec&#39;s definition of CharacterRange we do</span>
<span class="line-removed"> 130                 // remain in compliance with the grammar.  For example, consider</span>
<span class="line-removed"> 131                 // the expression /[\d-a-z]/.  We comply with the grammar in</span>
<span class="line-removed"> 132                 // this case by not allowing a-z to be matched as a range.</span>
 133             case AfterCharacterClassHyphen:




 134                 m_delegate.atomCharacterClassAtom(ch);
 135                 m_state = Empty;
 136                 return;
 137             }
 138         }
 139 
 140         /*
 141          * atomBuiltInCharacterClass():
 142          *
 143          * Adds a built-in character class, called by parseEscape().
 144          */
 145         void atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert)
 146         {
 147             switch (m_state) {
 148             case CachedCharacter:
 149                 // Flush the currently cached character, then fall through.
 150                 m_delegate.atomCharacterClassAtom(m_character);
 151                 FALLTHROUGH;
 152             case Empty:
 153             case AfterCharacterClass:
<span class="line-removed"> 154                 m_state = AfterCharacterClass;</span>
 155                 m_delegate.atomCharacterClassBuiltIn(classID, invert);

 156                 return;
 157 
 158                 // If we hit either of these cases, we have an invalid range that
<span class="line-modified"> 159                 // looks something like /[x-\d]/ or /[\d-\d]/.</span>
<span class="line-modified"> 160                 // According to ECMA-262 this should be a syntax error, but</span>
<span class="line-modified"> 161                 // empirical testing shows this to break teh webz.  Instead we</span>
<span class="line-modified"> 162                 // comply with to the ECMA-262 grammar, and assume the grammar to</span>
<span class="line-modified"> 163                 // have matched the range correctly, but tweak our interpretation</span>
<span class="line-modified"> 164                 // of CharacterRange.  Effectively we implicitly handle the hyphen</span>
<span class="line-modified"> 165                 // as if it were escaped, e.g. /[\w-_]/ is treated as /[\w\-_]/.</span>
 166             case CachedCharacterHyphen:
 167                 m_delegate.atomCharacterClassAtom(m_character);
 168                 m_delegate.atomCharacterClassAtom(&#39;-&#39;);
 169                 FALLTHROUGH;
 170             case AfterCharacterClassHyphen:




 171                 m_delegate.atomCharacterClassBuiltIn(classID, invert);
 172                 m_state = Empty;
 173                 return;
 174             }
 175         }
 176 
 177         /*
 178          * end():
 179          *
 180          * Called at end of construction.
 181          */
 182         void end()
 183         {
 184             if (m_state == CachedCharacter)
 185                 m_delegate.atomCharacterClassAtom(m_character);
 186             else if (m_state == CachedCharacterHyphen) {
 187                 m_delegate.atomCharacterClassAtom(m_character);
 188                 m_delegate.atomCharacterClassAtom(&#39;-&#39;);
 189             }
 190             m_delegate.atomCharacterClassEnd();
 191         }
 192 
 193         // parseEscape() should never call these delegate methods when
 194         // invoked with inCharacterClass set.
 195         NO_RETURN_DUE_TO_ASSERT void assertionWordBoundary(bool) { RELEASE_ASSERT_NOT_REACHED(); }
 196         NO_RETURN_DUE_TO_ASSERT void atomBackReference(unsigned) { RELEASE_ASSERT_NOT_REACHED(); }
 197         NO_RETURN_DUE_TO_ASSERT void atomNamedBackReference(const String&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
 198         NO_RETURN_DUE_TO_ASSERT bool isValidNamedForwardReference(const String&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
 199         NO_RETURN_DUE_TO_ASSERT void atomNamedForwardReference(const String&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
 200 
 201     private:
 202         Delegate&amp; m_delegate;
 203         ErrorCode&amp; m_errorCode;

 204         enum CharacterClassConstructionState {
 205             Empty,
 206             CachedCharacter,
 207             CachedCharacterHyphen,
 208             AfterCharacterClass,
 209             AfterCharacterClassHyphen,
 210         } m_state;
 211         UChar32 m_character;
 212     };
 213 
 214     Parser(Delegate&amp; delegate, const String&amp; pattern, bool isUnicode, unsigned backReferenceLimit)
 215         : m_delegate(delegate)
 216         , m_backReferenceLimit(backReferenceLimit)
 217         , m_data(pattern.characters&lt;CharType&gt;())
 218         , m_size(pattern.length())
 219         , m_isUnicode(isUnicode)
 220     {
 221     }
 222 
 223     // The handling of IdentityEscapes is different depending on the unicode flag.
 224     // For Unicode patterns, IdentityEscapes only include SyntaxCharacters or &#39;/&#39;.
 225     // For non-unicode patterns, most any character can be escaped.
 226     bool isIdentityEscapeAnError(int ch)
 227     {
<span class="line-modified"> 228         if (m_isUnicode &amp;&amp; !strchr(&quot;^$\\.*+?()[]{}|/&quot;, ch)) {</span>
 229             m_errorCode = ErrorCode::InvalidIdentityEscape;
 230             return true;
 231         }
 232 
 233         return false;
 234     }
 235 
 236     /*
 237      * parseEscape():
 238      *
 239      * Helper for parseTokens() AND parseCharacterClass().
 240      * Unlike the other parser methods, this function does not report tokens
 241      * directly to the member delegate (m_delegate), instead tokens are
 242      * emitted to the delegate provided as an argument.  In the case of atom
 243      * escapes, parseTokens() will call parseEscape() passing m_delegate as
 244      * an argument, and as such the escape will be reported to the delegate.
 245      *
 246      * However this method may also be used by parseCharacterClass(), in which
 247      * case a CharacterClassParserDelegate will be passed as the delegate that
 248      * tokens should be added to.  A boolean flag is also provided to indicate
</pre>
<hr />
<pre>
 374         case &#39;r&#39;:
 375             consume();
 376             delegate.atomPatternCharacter(&#39;\r&#39;);
 377             break;
 378         case &#39;t&#39;:
 379             consume();
 380             delegate.atomPatternCharacter(&#39;\t&#39;);
 381             break;
 382         case &#39;v&#39;:
 383             consume();
 384             delegate.atomPatternCharacter(&#39;\v&#39;);
 385             break;
 386 
 387         // ControlLetter
 388         case &#39;c&#39;: {
 389             ParseState state = saveState();
 390             consume();
 391             if (!atEndOfPattern()) {
 392                 int control = consume();
 393 
<span class="line-modified"> 394                 // To match Firefox, inside a character class, we also accept numbers and &#39;_&#39; as control characters.</span>
<span class="line-modified"> 395                 if (inCharacterClass ? WTF::isASCIIAlphanumeric(control) || (control == &#39;_&#39;) : WTF::isASCIIAlpha(control)) {</span>










 396                     delegate.atomPatternCharacter(control &amp; 0x1f);
 397                     break;
 398                 }
 399             }






 400             restoreState(state);
 401             delegate.atomPatternCharacter(&#39;\\&#39;);
 402             break;
 403         }
 404 
 405         // HexEscape
 406         case &#39;x&#39;: {
 407             consume();
 408             int x = tryConsumeHex(2);
 409             if (x == -1) {
 410                 if (isIdentityEscapeAnError(&#39;x&#39;))
 411                     break;
 412 
 413                 delegate.atomPatternCharacter(&#39;x&#39;);
 414             } else
 415                 delegate.atomPatternCharacter(x);
 416             break;
 417         }
 418 
 419         // Named backreference
</pre>
<hr />
<pre>
 578         return parseEscape&lt;false&gt;(m_delegate);
 579     }
 580     void parseCharacterClassEscape(CharacterClassParserDelegate&amp; delegate)
 581     {
 582         parseEscape&lt;true&gt;(delegate);
 583     }
 584 
 585     /*
 586      * parseCharacterClass():
 587      *
 588      * Helper for parseTokens(); calls directly and indirectly (via parseCharacterClassEscape)
 589      * to an instance of CharacterClassParserDelegate, to describe the character class to the
 590      * delegate.
 591      */
 592     void parseCharacterClass()
 593     {
 594         ASSERT(!hasError(m_errorCode));
 595         ASSERT(peek() == &#39;[&#39;);
 596         consume();
 597 
<span class="line-modified"> 598         CharacterClassParserDelegate characterClassConstructor(m_delegate, m_errorCode);</span>
 599 
 600         characterClassConstructor.begin(tryConsume(&#39;^&#39;));
 601 
 602         while (!atEndOfPattern()) {
 603             switch (peek()) {
 604             case &#39;]&#39;:
 605                 consume();
 606                 characterClassConstructor.end();
 607                 return;
 608 
 609             case &#39;\\&#39;:
 610                 parseCharacterClassEscape(characterClassConstructor);
 611                 break;
 612 
 613             default:
 614                 characterClassConstructor.atomPatternCharacter(consumePossibleSurrogatePair(), true);
 615             }
 616 
 617             if (hasError(m_errorCode))
 618                 return;
 619         }
 620 
 621         m_errorCode = ErrorCode::CharacterClassUnmatched;
 622     }
 623 
 624     /*
 625      * parseParenthesesBegin():
 626      *
 627      * Helper for parseTokens(); checks for parentheses types other than regular capturing subpatterns.
 628      */
 629     void parseParenthesesBegin()
 630     {
 631         ASSERT(!hasError(m_errorCode));
 632         ASSERT(peek() == &#39;(&#39;);
 633         consume();
 634 


 635         if (tryConsume(&#39;?&#39;)) {
 636             if (atEndOfPattern()) {
 637                 m_errorCode = ErrorCode::ParenthesesTypeInvalid;
 638                 return;
 639             }
 640 
 641             switch (consume()) {
 642             case &#39;:&#39;:
 643                 m_delegate.atomParenthesesSubpatternBegin(false);
 644                 break;
 645 
 646             case &#39;=&#39;:
 647                 m_delegate.atomParentheticalAssertionBegin();

 648                 break;
 649 
 650             case &#39;!&#39;:
 651                 m_delegate.atomParentheticalAssertionBegin(true);

 652                 break;
 653 
 654             case &#39;&lt;&#39;: {
 655                 auto groupName = tryConsumeGroupName();
 656                 if (groupName) {
 657                     auto setAddResult = m_captureGroupNames.add(groupName.value());
 658                     if (setAddResult.isNewEntry)
 659                         m_delegate.atomParenthesesSubpatternBegin(true, groupName);
 660                     else
 661                         m_errorCode = ErrorCode::DuplicateGroupName;
 662                 } else
 663                     m_errorCode = ErrorCode::InvalidGroupName;
 664 
 665                 break;
 666             }
 667 
 668             default:
 669                 m_errorCode = ErrorCode::ParenthesesTypeInvalid;
 670             }
 671         } else
 672             m_delegate.atomParenthesesSubpatternBegin();
 673 
<span class="line-modified"> 674         ++m_parenthesesNestingDepth;</span>
 675     }
 676 
 677     /*
 678      * parseParenthesesEnd():
 679      *
 680      * Helper for parseTokens(); checks for parse errors (due to unmatched parentheses).




 681      */
<span class="line-modified"> 682     void parseParenthesesEnd()</span>
 683     {
 684         ASSERT(!hasError(m_errorCode));
 685         ASSERT(peek() == &#39;)&#39;);
 686         consume();
 687 
<span class="line-modified"> 688         if (m_parenthesesNestingDepth &gt; 0)</span>
<span class="line-removed"> 689             m_delegate.atomParenthesesEnd();</span>
<span class="line-removed"> 690         else</span>
 691             m_errorCode = ErrorCode::ParenthesesUnmatched;


 692 
<span class="line-modified"> 693         --m_parenthesesNestingDepth;</span>


 694     }
 695 
 696     /*
 697      * parseQuantifier():
 698      *
 699      * Helper for parseTokens(); checks for parse errors and non-greedy quantifiers.
 700      */
 701     void parseQuantifier(bool lastTokenWasAnAtom, unsigned min, unsigned max)
 702     {
 703         ASSERT(!hasError(m_errorCode));
 704         ASSERT(min &lt;= max);
 705 
 706         if (min == UINT_MAX) {
 707             m_errorCode = ErrorCode::QuantifierTooLarge;
 708             return;
 709         }
 710 
 711         if (lastTokenWasAnAtom)
 712             m_delegate.quantifyAtom(min, max, !tryConsume(&#39;?&#39;));
 713         else
</pre>
<hr />
<pre>
 724      * a parse error when a quantifier provided without an atom to quantify).
 725      */
 726     void parseTokens()
 727     {
 728         bool lastTokenWasAnAtom = false;
 729 
 730         while (!atEndOfPattern()) {
 731             switch (peek()) {
 732             case &#39;|&#39;:
 733                 consume();
 734                 m_delegate.disjunction();
 735                 lastTokenWasAnAtom = false;
 736                 break;
 737 
 738             case &#39;(&#39;:
 739                 parseParenthesesBegin();
 740                 lastTokenWasAnAtom = false;
 741                 break;
 742 
 743             case &#39;)&#39;:
<span class="line-modified"> 744                 parseParenthesesEnd();</span>
<span class="line-removed"> 745                 lastTokenWasAnAtom = true;</span>
 746                 break;
 747 
 748             case &#39;^&#39;:
 749                 consume();
 750                 m_delegate.assertionBOL();
 751                 lastTokenWasAnAtom = false;
 752                 break;
 753 
 754             case &#39;$&#39;:
 755                 consume();
 756                 m_delegate.assertionEOL();
 757                 lastTokenWasAnAtom = false;
 758                 break;
 759 
 760             case &#39;.&#39;:
 761                 consume();
 762                 m_delegate.atomBuiltInCharacterClass(BuiltInCharacterClassID::DotClassID, false);
 763                 lastTokenWasAnAtom = true;
 764                 break;
 765 
 766             case &#39;[&#39;:
 767                 parseCharacterClass();
 768                 lastTokenWasAnAtom = true;
 769                 break;
 770 











 771             case &#39;\\&#39;:
 772                 lastTokenWasAnAtom = parseAtomEscape();
 773                 break;
 774 
 775             case &#39;*&#39;:
 776                 consume();
 777                 parseQuantifier(lastTokenWasAnAtom, 0, quantifyInfinite);
 778                 lastTokenWasAnAtom = false;
 779                 break;
 780 
 781             case &#39;+&#39;:
 782                 consume();
 783                 parseQuantifier(lastTokenWasAnAtom, 1, quantifyInfinite);
 784                 lastTokenWasAnAtom = false;
 785                 break;
 786 
 787             case &#39;?&#39;:
 788                 consume();
 789                 parseQuantifier(lastTokenWasAnAtom, 0, 1);
 790                 lastTokenWasAnAtom = false;
</pre>
<hr />
<pre>
 794                 ParseState state = saveState();
 795 
 796                 consume();
 797                 if (peekIsDigit()) {
 798                     unsigned min = consumeNumber();
 799                     unsigned max = min;
 800 
 801                     if (tryConsume(&#39;,&#39;))
 802                         max = peekIsDigit() ? consumeNumber() : quantifyInfinite;
 803 
 804                     if (tryConsume(&#39;}&#39;)) {
 805                         if (min &lt;= max)
 806                             parseQuantifier(lastTokenWasAnAtom, min, max);
 807                         else
 808                             m_errorCode = ErrorCode::QuantifierOutOfOrder;
 809                         lastTokenWasAnAtom = false;
 810                         break;
 811                     }
 812                 }
 813 





 814                 restoreState(state);


 815             }
<span class="line-removed"> 816             // if we did not find a complete quantifer, fall through to the default case.</span>
<span class="line-removed"> 817             FALLTHROUGH;</span>
 818 
 819             default:
 820                 m_delegate.atomPatternCharacter(consumePossibleSurrogatePair());
 821                 lastTokenWasAnAtom = true;
 822             }
 823 
 824             if (hasError(m_errorCode))
 825                 return;
 826         }
 827 
<span class="line-modified"> 828         if (m_parenthesesNestingDepth &gt; 0)</span>
 829             m_errorCode = ErrorCode::MissingParentheses;
 830     }
 831 
 832     /*
 833      * parse():
 834      *
 835      * This method calls parseTokens() to parse over the input and returns error code for a result.
 836      */
 837     ErrorCode parse()
 838     {
 839         if (m_size &gt; MAX_PATTERN_SIZE)
 840             m_errorCode = ErrorCode::PatternTooLarge;
 841         else
 842             parseTokens();
 843         ASSERT(atEndOfPattern() || hasError(m_errorCode));
 844 
 845         return m_errorCode;
 846     }
 847 
 848     // Misc helper functions:
</pre>
<hr />
<pre>
1089             }
1090 
1091             consume();
1092             if (ch == &#39;=&#39;) {
1093                 if (!foundEquals) {
1094                     foundEquals = true;
1095                     unicodePropertyName = expressionBuilder.toString();
1096                     expressionBuilder.clear();
1097                 } else
1098                     errors++;
1099             } else if (!isUnicodePropertyValueExpressionChar(ch))
1100                 errors++;
1101             else
1102                 expressionBuilder.appendCharacter(ch);
1103         }
1104 
1105         m_errorCode = ErrorCode::InvalidUnicodePropertyExpression;
1106         return WTF::nullopt;
1107     }
1108 


1109     Delegate&amp; m_delegate;
1110     unsigned m_backReferenceLimit;
1111     ErrorCode m_errorCode { ErrorCode::NoError };
1112     const CharType* m_data;
1113     unsigned m_size;
1114     unsigned m_index { 0 };
1115     bool m_isUnicode;
<span class="line-modified">1116     unsigned m_parenthesesNestingDepth { 0 };</span>
1117     HashSet&lt;String&gt; m_captureGroupNames;
1118 
1119     // Derived by empirical testing of compile time in PCRE and WREC.
<span class="line-modified">1120     static const unsigned MAX_PATTERN_SIZE = 1024 * 1024;</span>
1121 };
1122 
1123 /*
1124  * Yarr::parse():
1125  *
1126  * The parse method is passed a pattern to be parsed and a delegate upon which
1127  * callbacks will be made to record the parsed tokens forming the regex.
1128  * Yarr::parse() returns null on success, or a const C string providing an error
1129  * message where a parse error occurs.
1130  *
1131  * The Delegate must implement the following interface:
1132  *
1133  *    void assertionBOL();
1134  *    void assertionEOL();
1135  *    void assertionWordBoundary(bool invert);
1136  *
1137  *    void atomPatternCharacter(UChar32 ch);
1138  *    void atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert);
1139  *    void atomCharacterClassBegin(bool invert)
1140  *    void atomCharacterClassAtom(UChar32 ch)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  37 namespace JSC { namespace Yarr {
  38 
  39 // The Parser class should not be used directly - only via the Yarr::parse() method.
  40 template&lt;class Delegate, typename CharType&gt;
  41 class Parser {
  42 private:
  43     template&lt;class FriendDelegate&gt;
  44     friend ErrorCode parse(FriendDelegate&amp;, const String&amp; pattern, bool isUnicode, unsigned backReferenceLimit);
  45 
  46     /*
  47      * CharacterClassParserDelegate:
  48      *
  49      * The class CharacterClassParserDelegate is used in the parsing of character
  50      * classes.  This class handles detection of character ranges.  This class
  51      * implements enough of the delegate interface such that it can be passed to
  52      * parseEscape() as an EscapeDelegate.  This allows parseEscape() to be reused
  53      * to perform the parsing of escape characters in character sets.
  54      */
  55     class CharacterClassParserDelegate {
  56     public:
<span class="line-modified">  57         CharacterClassParserDelegate(Delegate&amp; delegate, ErrorCode&amp; err, bool isUnicode)</span>
  58             : m_delegate(delegate)
  59             , m_errorCode(err)
<span class="line-added">  60             , m_isUnicode(isUnicode)</span>
  61             , m_state(Empty)
  62             , m_character(0)
  63         {
  64         }
  65 
  66         /*
  67          * begin():
  68          *
  69          * Called at beginning of construction.
  70          */
  71         void begin(bool invert)
  72         {
  73             m_delegate.atomCharacterClassBegin(invert);
  74         }
  75 
  76         /*
  77          * atomPatternCharacter():
  78          *
  79          * This method is called either from parseCharacterClass() (for an unescaped
  80          * character in a character class), or from parseEscape(). In the former case
  81          * the value true will be passed for the argument &#39;hyphenIsRange&#39;, and in this
  82          * mode we will allow a hypen to be treated as indicating a range (i.e. /[a-z]/
  83          * is different to /[a\-z]/).
  84          */
  85         void atomPatternCharacter(UChar32 ch, bool hyphenIsRange = false)
  86         {
  87             switch (m_state) {
  88             case AfterCharacterClass:
<span class="line-modified">  89                 // Following a built-in character class we need look out for a hyphen.</span>
  90                 // We&#39;re looking for invalid ranges, such as /[\d-x]/ or /[\d-\d]/.
<span class="line-modified">  91                 // If we see a hyphen following a character class then unlike usual</span>
  92                 // we&#39;ll report it to the delegate immediately, and put ourself into
<span class="line-modified">  93                 // a poisoned state. In a unicode pattern, any following calls to add</span>
<span class="line-modified">  94                 // another character or character class will result in syntax error.</span>
<span class="line-modified">  95                 // A hypen following a character class is itself valid, but only at</span>
<span class="line-added">  96                 // the end of a regex.</span>
  97                 if (hyphenIsRange &amp;&amp; ch == &#39;-&#39;) {
  98                     m_delegate.atomCharacterClassAtom(&#39;-&#39;);
  99                     m_state = AfterCharacterClassHyphen;
 100                     return;
 101                 }
 102                 // Otherwise just fall through - cached character so treat this as Empty.
 103                 FALLTHROUGH;
 104 
 105             case Empty:
 106                 m_character = ch;
 107                 m_state = CachedCharacter;
 108                 return;
 109 
 110             case CachedCharacter:
 111                 if (hyphenIsRange &amp;&amp; ch == &#39;-&#39;)
 112                     m_state = CachedCharacterHyphen;
 113                 else {
 114                     m_delegate.atomCharacterClassAtom(m_character);
 115                     m_character = ch;
 116                 }
 117                 return;
 118 
 119             case CachedCharacterHyphen:
 120                 if (ch &lt; m_character) {
<span class="line-modified"> 121                     m_errorCode = ErrorCode::CharacterClassRangeOutOfOrder;</span>
 122                     return;
 123                 }
 124                 m_delegate.atomCharacterClassRange(m_character, ch);
 125                 m_state = Empty;
 126                 return;
 127 
<span class="line-modified"> 128                 // If we hit this case, we have an invalid range like /[\d-a]/.</span>
<span class="line-modified"> 129                 // See coment in atomBuiltInCharacterClass() below.</span>





 130             case AfterCharacterClassHyphen:
<span class="line-added"> 131                 if (m_isUnicode) {</span>
<span class="line-added"> 132                     m_errorCode = ErrorCode::CharacterClassRangeInvalid;</span>
<span class="line-added"> 133                     return;</span>
<span class="line-added"> 134                 }</span>
 135                 m_delegate.atomCharacterClassAtom(ch);
 136                 m_state = Empty;
 137                 return;
 138             }
 139         }
 140 
 141         /*
 142          * atomBuiltInCharacterClass():
 143          *
 144          * Adds a built-in character class, called by parseEscape().
 145          */
 146         void atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert)
 147         {
 148             switch (m_state) {
 149             case CachedCharacter:
 150                 // Flush the currently cached character, then fall through.
 151                 m_delegate.atomCharacterClassAtom(m_character);
 152                 FALLTHROUGH;
 153             case Empty:
 154             case AfterCharacterClass:

 155                 m_delegate.atomCharacterClassBuiltIn(classID, invert);
<span class="line-added"> 156                 m_state = AfterCharacterClass;</span>
 157                 return;
 158 
 159                 // If we hit either of these cases, we have an invalid range that
<span class="line-modified"> 160                 // looks something like /[a-\d]/ or /[\d-\d]/.</span>
<span class="line-modified"> 161                 // Since ES2015, this should be syntax error in a unicode pattern,</span>
<span class="line-modified"> 162                 // yet gracefully handled in a regular regex to avoid breaking the web.</span>
<span class="line-modified"> 163                 // Effectively we handle the hyphen as if it was (implicitly) escaped,</span>
<span class="line-modified"> 164                 // e.g. /[\d-a-z]/ is treated as /[\d\-a\-z]/.</span>
<span class="line-modified"> 165                 // See usages of CharacterRangeOrUnion abstract op in</span>
<span class="line-modified"> 166                 // https://tc39.es/ecma262/#sec-regular-expression-patterns-semantics</span>
 167             case CachedCharacterHyphen:
 168                 m_delegate.atomCharacterClassAtom(m_character);
 169                 m_delegate.atomCharacterClassAtom(&#39;-&#39;);
 170                 FALLTHROUGH;
 171             case AfterCharacterClassHyphen:
<span class="line-added"> 172                 if (m_isUnicode) {</span>
<span class="line-added"> 173                     m_errorCode = ErrorCode::CharacterClassRangeInvalid;</span>
<span class="line-added"> 174                     return;</span>
<span class="line-added"> 175                 }</span>
 176                 m_delegate.atomCharacterClassBuiltIn(classID, invert);
 177                 m_state = Empty;
 178                 return;
 179             }
 180         }
 181 
 182         /*
 183          * end():
 184          *
 185          * Called at end of construction.
 186          */
 187         void end()
 188         {
 189             if (m_state == CachedCharacter)
 190                 m_delegate.atomCharacterClassAtom(m_character);
 191             else if (m_state == CachedCharacterHyphen) {
 192                 m_delegate.atomCharacterClassAtom(m_character);
 193                 m_delegate.atomCharacterClassAtom(&#39;-&#39;);
 194             }
 195             m_delegate.atomCharacterClassEnd();
 196         }
 197 
 198         // parseEscape() should never call these delegate methods when
 199         // invoked with inCharacterClass set.
 200         NO_RETURN_DUE_TO_ASSERT void assertionWordBoundary(bool) { RELEASE_ASSERT_NOT_REACHED(); }
 201         NO_RETURN_DUE_TO_ASSERT void atomBackReference(unsigned) { RELEASE_ASSERT_NOT_REACHED(); }
 202         NO_RETURN_DUE_TO_ASSERT void atomNamedBackReference(const String&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
 203         NO_RETURN_DUE_TO_ASSERT bool isValidNamedForwardReference(const String&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
 204         NO_RETURN_DUE_TO_ASSERT void atomNamedForwardReference(const String&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
 205 
 206     private:
 207         Delegate&amp; m_delegate;
 208         ErrorCode&amp; m_errorCode;
<span class="line-added"> 209         bool m_isUnicode;</span>
 210         enum CharacterClassConstructionState {
 211             Empty,
 212             CachedCharacter,
 213             CachedCharacterHyphen,
 214             AfterCharacterClass,
 215             AfterCharacterClassHyphen,
 216         } m_state;
 217         UChar32 m_character;
 218     };
 219 
 220     Parser(Delegate&amp; delegate, const String&amp; pattern, bool isUnicode, unsigned backReferenceLimit)
 221         : m_delegate(delegate)
 222         , m_backReferenceLimit(backReferenceLimit)
 223         , m_data(pattern.characters&lt;CharType&gt;())
 224         , m_size(pattern.length())
 225         , m_isUnicode(isUnicode)
 226     {
 227     }
 228 
 229     // The handling of IdentityEscapes is different depending on the unicode flag.
 230     // For Unicode patterns, IdentityEscapes only include SyntaxCharacters or &#39;/&#39;.
 231     // For non-unicode patterns, most any character can be escaped.
 232     bool isIdentityEscapeAnError(int ch)
 233     {
<span class="line-modified"> 234         if (m_isUnicode &amp;&amp; (!strchr(&quot;^$\\.*+?()[]{}|/&quot;, ch) || !ch)) {</span>
 235             m_errorCode = ErrorCode::InvalidIdentityEscape;
 236             return true;
 237         }
 238 
 239         return false;
 240     }
 241 
 242     /*
 243      * parseEscape():
 244      *
 245      * Helper for parseTokens() AND parseCharacterClass().
 246      * Unlike the other parser methods, this function does not report tokens
 247      * directly to the member delegate (m_delegate), instead tokens are
 248      * emitted to the delegate provided as an argument.  In the case of atom
 249      * escapes, parseTokens() will call parseEscape() passing m_delegate as
 250      * an argument, and as such the escape will be reported to the delegate.
 251      *
 252      * However this method may also be used by parseCharacterClass(), in which
 253      * case a CharacterClassParserDelegate will be passed as the delegate that
 254      * tokens should be added to.  A boolean flag is also provided to indicate
</pre>
<hr />
<pre>
 380         case &#39;r&#39;:
 381             consume();
 382             delegate.atomPatternCharacter(&#39;\r&#39;);
 383             break;
 384         case &#39;t&#39;:
 385             consume();
 386             delegate.atomPatternCharacter(&#39;\t&#39;);
 387             break;
 388         case &#39;v&#39;:
 389             consume();
 390             delegate.atomPatternCharacter(&#39;\v&#39;);
 391             break;
 392 
 393         // ControlLetter
 394         case &#39;c&#39;: {
 395             ParseState state = saveState();
 396             consume();
 397             if (!atEndOfPattern()) {
 398                 int control = consume();
 399 
<span class="line-modified"> 400                 if (WTF::isASCIIAlpha(control)) {</span>
<span class="line-modified"> 401                     delegate.atomPatternCharacter(control &amp; 0x1f);</span>
<span class="line-added"> 402                     break;</span>
<span class="line-added"> 403                 }</span>
<span class="line-added"> 404 </span>
<span class="line-added"> 405                 if (m_isUnicode) {</span>
<span class="line-added"> 406                     m_errorCode = ErrorCode::InvalidControlLetterEscape;</span>
<span class="line-added"> 407                     break;</span>
<span class="line-added"> 408                 }</span>
<span class="line-added"> 409 </span>
<span class="line-added"> 410                 // https://tc39.es/ecma262/#prod-annexB-ClassControlLetter</span>
<span class="line-added"> 411                 if (inCharacterClass &amp;&amp; (WTF::isASCIIDigit(control) || control == &#39;_&#39;)) {</span>
 412                     delegate.atomPatternCharacter(control &amp; 0x1f);
 413                     break;
 414                 }
 415             }
<span class="line-added"> 416 </span>
<span class="line-added"> 417             if (m_isUnicode) {</span>
<span class="line-added"> 418                 m_errorCode = ErrorCode::InvalidIdentityEscape;</span>
<span class="line-added"> 419                 break;</span>
<span class="line-added"> 420             }</span>
<span class="line-added"> 421 </span>
 422             restoreState(state);
 423             delegate.atomPatternCharacter(&#39;\\&#39;);
 424             break;
 425         }
 426 
 427         // HexEscape
 428         case &#39;x&#39;: {
 429             consume();
 430             int x = tryConsumeHex(2);
 431             if (x == -1) {
 432                 if (isIdentityEscapeAnError(&#39;x&#39;))
 433                     break;
 434 
 435                 delegate.atomPatternCharacter(&#39;x&#39;);
 436             } else
 437                 delegate.atomPatternCharacter(x);
 438             break;
 439         }
 440 
 441         // Named backreference
</pre>
<hr />
<pre>
 600         return parseEscape&lt;false&gt;(m_delegate);
 601     }
 602     void parseCharacterClassEscape(CharacterClassParserDelegate&amp; delegate)
 603     {
 604         parseEscape&lt;true&gt;(delegate);
 605     }
 606 
 607     /*
 608      * parseCharacterClass():
 609      *
 610      * Helper for parseTokens(); calls directly and indirectly (via parseCharacterClassEscape)
 611      * to an instance of CharacterClassParserDelegate, to describe the character class to the
 612      * delegate.
 613      */
 614     void parseCharacterClass()
 615     {
 616         ASSERT(!hasError(m_errorCode));
 617         ASSERT(peek() == &#39;[&#39;);
 618         consume();
 619 
<span class="line-modified"> 620         CharacterClassParserDelegate characterClassConstructor(m_delegate, m_errorCode, m_isUnicode);</span>
 621 
 622         characterClassConstructor.begin(tryConsume(&#39;^&#39;));
 623 
 624         while (!atEndOfPattern()) {
 625             switch (peek()) {
 626             case &#39;]&#39;:
 627                 consume();
 628                 characterClassConstructor.end();
 629                 return;
 630 
 631             case &#39;\\&#39;:
 632                 parseCharacterClassEscape(characterClassConstructor);
 633                 break;
 634 
 635             default:
 636                 characterClassConstructor.atomPatternCharacter(consumePossibleSurrogatePair(), true);
 637             }
 638 
 639             if (hasError(m_errorCode))
 640                 return;
 641         }
 642 
 643         m_errorCode = ErrorCode::CharacterClassUnmatched;
 644     }
 645 
 646     /*
 647      * parseParenthesesBegin():
 648      *
 649      * Helper for parseTokens(); checks for parentheses types other than regular capturing subpatterns.
 650      */
 651     void parseParenthesesBegin()
 652     {
 653         ASSERT(!hasError(m_errorCode));
 654         ASSERT(peek() == &#39;(&#39;);
 655         consume();
 656 
<span class="line-added"> 657         auto type = ParenthesesType::Subpattern;</span>
<span class="line-added"> 658 </span>
 659         if (tryConsume(&#39;?&#39;)) {
 660             if (atEndOfPattern()) {
 661                 m_errorCode = ErrorCode::ParenthesesTypeInvalid;
 662                 return;
 663             }
 664 
 665             switch (consume()) {
 666             case &#39;:&#39;:
 667                 m_delegate.atomParenthesesSubpatternBegin(false);
 668                 break;
 669 
 670             case &#39;=&#39;:
 671                 m_delegate.atomParentheticalAssertionBegin();
<span class="line-added"> 672                 type = ParenthesesType::Assertion;</span>
 673                 break;
 674 
 675             case &#39;!&#39;:
 676                 m_delegate.atomParentheticalAssertionBegin(true);
<span class="line-added"> 677                 type = ParenthesesType::Assertion;</span>
 678                 break;
 679 
 680             case &#39;&lt;&#39;: {
 681                 auto groupName = tryConsumeGroupName();
 682                 if (groupName) {
 683                     auto setAddResult = m_captureGroupNames.add(groupName.value());
 684                     if (setAddResult.isNewEntry)
 685                         m_delegate.atomParenthesesSubpatternBegin(true, groupName);
 686                     else
 687                         m_errorCode = ErrorCode::DuplicateGroupName;
 688                 } else
 689                     m_errorCode = ErrorCode::InvalidGroupName;
 690 
 691                 break;
 692             }
 693 
 694             default:
 695                 m_errorCode = ErrorCode::ParenthesesTypeInvalid;
 696             }
 697         } else
 698             m_delegate.atomParenthesesSubpatternBegin();
 699 
<span class="line-modified"> 700         m_parenthesesStack.append(type);</span>
 701     }
 702 
 703     /*
 704      * parseParenthesesEnd():
 705      *
 706      * Helper for parseTokens(); checks for parse errors (due to unmatched parentheses).
<span class="line-added"> 707      *</span>
<span class="line-added"> 708      * The boolean value returned by this method indicates whether the token parsed</span>
<span class="line-added"> 709      * was either an Atom or, for web compatibility reasons, QuantifiableAssertion</span>
<span class="line-added"> 710      * in non-Unicode pattern.</span>
 711      */
<span class="line-modified"> 712     bool parseParenthesesEnd()</span>
 713     {
 714         ASSERT(!hasError(m_errorCode));
 715         ASSERT(peek() == &#39;)&#39;);
 716         consume();
 717 
<span class="line-modified"> 718         if (m_parenthesesStack.isEmpty()) {</span>


 719             m_errorCode = ErrorCode::ParenthesesUnmatched;
<span class="line-added"> 720             return false;</span>
<span class="line-added"> 721         }</span>
 722 
<span class="line-modified"> 723         m_delegate.atomParenthesesEnd();</span>
<span class="line-added"> 724         auto type = m_parenthesesStack.takeLast();</span>
<span class="line-added"> 725         return type == ParenthesesType::Subpattern || !m_isUnicode;</span>
 726     }
 727 
 728     /*
 729      * parseQuantifier():
 730      *
 731      * Helper for parseTokens(); checks for parse errors and non-greedy quantifiers.
 732      */
 733     void parseQuantifier(bool lastTokenWasAnAtom, unsigned min, unsigned max)
 734     {
 735         ASSERT(!hasError(m_errorCode));
 736         ASSERT(min &lt;= max);
 737 
 738         if (min == UINT_MAX) {
 739             m_errorCode = ErrorCode::QuantifierTooLarge;
 740             return;
 741         }
 742 
 743         if (lastTokenWasAnAtom)
 744             m_delegate.quantifyAtom(min, max, !tryConsume(&#39;?&#39;));
 745         else
</pre>
<hr />
<pre>
 756      * a parse error when a quantifier provided without an atom to quantify).
 757      */
 758     void parseTokens()
 759     {
 760         bool lastTokenWasAnAtom = false;
 761 
 762         while (!atEndOfPattern()) {
 763             switch (peek()) {
 764             case &#39;|&#39;:
 765                 consume();
 766                 m_delegate.disjunction();
 767                 lastTokenWasAnAtom = false;
 768                 break;
 769 
 770             case &#39;(&#39;:
 771                 parseParenthesesBegin();
 772                 lastTokenWasAnAtom = false;
 773                 break;
 774 
 775             case &#39;)&#39;:
<span class="line-modified"> 776                 lastTokenWasAnAtom = parseParenthesesEnd();</span>

 777                 break;
 778 
 779             case &#39;^&#39;:
 780                 consume();
 781                 m_delegate.assertionBOL();
 782                 lastTokenWasAnAtom = false;
 783                 break;
 784 
 785             case &#39;$&#39;:
 786                 consume();
 787                 m_delegate.assertionEOL();
 788                 lastTokenWasAnAtom = false;
 789                 break;
 790 
 791             case &#39;.&#39;:
 792                 consume();
 793                 m_delegate.atomBuiltInCharacterClass(BuiltInCharacterClassID::DotClassID, false);
 794                 lastTokenWasAnAtom = true;
 795                 break;
 796 
 797             case &#39;[&#39;:
 798                 parseCharacterClass();
 799                 lastTokenWasAnAtom = true;
 800                 break;
 801 
<span class="line-added"> 802             case &#39;]&#39;:</span>
<span class="line-added"> 803             case &#39;}&#39;:</span>
<span class="line-added"> 804                 if (m_isUnicode) {</span>
<span class="line-added"> 805                     m_errorCode = ErrorCode::BracketUnmatched;</span>
<span class="line-added"> 806                     break;</span>
<span class="line-added"> 807                 }</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809                 m_delegate.atomPatternCharacter(consume());</span>
<span class="line-added"> 810                 lastTokenWasAnAtom = true;</span>
<span class="line-added"> 811                 break;</span>
<span class="line-added"> 812 </span>
 813             case &#39;\\&#39;:
 814                 lastTokenWasAnAtom = parseAtomEscape();
 815                 break;
 816 
 817             case &#39;*&#39;:
 818                 consume();
 819                 parseQuantifier(lastTokenWasAnAtom, 0, quantifyInfinite);
 820                 lastTokenWasAnAtom = false;
 821                 break;
 822 
 823             case &#39;+&#39;:
 824                 consume();
 825                 parseQuantifier(lastTokenWasAnAtom, 1, quantifyInfinite);
 826                 lastTokenWasAnAtom = false;
 827                 break;
 828 
 829             case &#39;?&#39;:
 830                 consume();
 831                 parseQuantifier(lastTokenWasAnAtom, 0, 1);
 832                 lastTokenWasAnAtom = false;
</pre>
<hr />
<pre>
 836                 ParseState state = saveState();
 837 
 838                 consume();
 839                 if (peekIsDigit()) {
 840                     unsigned min = consumeNumber();
 841                     unsigned max = min;
 842 
 843                     if (tryConsume(&#39;,&#39;))
 844                         max = peekIsDigit() ? consumeNumber() : quantifyInfinite;
 845 
 846                     if (tryConsume(&#39;}&#39;)) {
 847                         if (min &lt;= max)
 848                             parseQuantifier(lastTokenWasAnAtom, min, max);
 849                         else
 850                             m_errorCode = ErrorCode::QuantifierOutOfOrder;
 851                         lastTokenWasAnAtom = false;
 852                         break;
 853                     }
 854                 }
 855 
<span class="line-added"> 856                 if (m_isUnicode) {</span>
<span class="line-added"> 857                     m_errorCode = ErrorCode::QuantifierIncomplete;</span>
<span class="line-added"> 858                     break;</span>
<span class="line-added"> 859                 }</span>
<span class="line-added"> 860 </span>
 861                 restoreState(state);
<span class="line-added"> 862                 // if we did not find a complete quantifer, fall through to the default case.</span>
<span class="line-added"> 863                 FALLTHROUGH;</span>
 864             }


 865 
 866             default:
 867                 m_delegate.atomPatternCharacter(consumePossibleSurrogatePair());
 868                 lastTokenWasAnAtom = true;
 869             }
 870 
 871             if (hasError(m_errorCode))
 872                 return;
 873         }
 874 
<span class="line-modified"> 875         if (!m_parenthesesStack.isEmpty())</span>
 876             m_errorCode = ErrorCode::MissingParentheses;
 877     }
 878 
 879     /*
 880      * parse():
 881      *
 882      * This method calls parseTokens() to parse over the input and returns error code for a result.
 883      */
 884     ErrorCode parse()
 885     {
 886         if (m_size &gt; MAX_PATTERN_SIZE)
 887             m_errorCode = ErrorCode::PatternTooLarge;
 888         else
 889             parseTokens();
 890         ASSERT(atEndOfPattern() || hasError(m_errorCode));
 891 
 892         return m_errorCode;
 893     }
 894 
 895     // Misc helper functions:
</pre>
<hr />
<pre>
1136             }
1137 
1138             consume();
1139             if (ch == &#39;=&#39;) {
1140                 if (!foundEquals) {
1141                     foundEquals = true;
1142                     unicodePropertyName = expressionBuilder.toString();
1143                     expressionBuilder.clear();
1144                 } else
1145                     errors++;
1146             } else if (!isUnicodePropertyValueExpressionChar(ch))
1147                 errors++;
1148             else
1149                 expressionBuilder.appendCharacter(ch);
1150         }
1151 
1152         m_errorCode = ErrorCode::InvalidUnicodePropertyExpression;
1153         return WTF::nullopt;
1154     }
1155 
<span class="line-added">1156     enum class ParenthesesType : uint8_t { Subpattern, Assertion };</span>
<span class="line-added">1157 </span>
1158     Delegate&amp; m_delegate;
1159     unsigned m_backReferenceLimit;
1160     ErrorCode m_errorCode { ErrorCode::NoError };
1161     const CharType* m_data;
1162     unsigned m_size;
1163     unsigned m_index { 0 };
1164     bool m_isUnicode;
<span class="line-modified">1165     Vector&lt;ParenthesesType, 16&gt; m_parenthesesStack;</span>
1166     HashSet&lt;String&gt; m_captureGroupNames;
1167 
1168     // Derived by empirical testing of compile time in PCRE and WREC.
<span class="line-modified">1169     static constexpr unsigned MAX_PATTERN_SIZE = 1024 * 1024;</span>
1170 };
1171 
1172 /*
1173  * Yarr::parse():
1174  *
1175  * The parse method is passed a pattern to be parsed and a delegate upon which
1176  * callbacks will be made to record the parsed tokens forming the regex.
1177  * Yarr::parse() returns null on success, or a const C string providing an error
1178  * message where a parse error occurs.
1179  *
1180  * The Delegate must implement the following interface:
1181  *
1182  *    void assertionBOL();
1183  *    void assertionEOL();
1184  *    void assertionWordBoundary(bool invert);
1185  *
1186  *    void atomPatternCharacter(UChar32 ch);
1187  *    void atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert);
1188  *    void atomCharacterClassBegin(bool invert)
1189  *    void atomCharacterClassAtom(UChar32 ch)
</pre>
</td>
</tr>
</table>
<center><a href="YarrJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrPattern.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerMessagingProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WorkerLoaderProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerMessagingProxy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerMessagingProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55 
 56 WorkerMessagingProxy::WorkerMessagingProxy(Worker&amp; workerObject)
 57     : m_scriptExecutionContext(workerObject.scriptExecutionContext())
 58     , m_inspectorProxy(makeUnique&lt;WorkerInspectorProxy&gt;(workerObject.identifier()))
 59     , m_workerObject(&amp;workerObject)
 60 {
 61     ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
 62         || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
 63 
 64     // Nobody outside this class ref counts this object. The original ref
 65     // is balanced by the deref in workerGlobalScopeDestroyedInternal.
 66 }
 67 
 68 WorkerMessagingProxy::~WorkerMessagingProxy()
 69 {
 70     ASSERT(!m_workerObject);
 71     ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
 72         || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
 73 }
 74 
<span class="line-modified"> 75 void WorkerMessagingProxy::startWorkerGlobalScope(const URL&amp; scriptURL, const String&amp; name, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, MonotonicTime timeOrigin, JSC::RuntimeFlags runtimeFlags, PAL::SessionID sessionID)</span>
 76 {
 77     // FIXME: This need to be revisited when we support nested worker one day
 78     ASSERT(m_scriptExecutionContext);
 79     Document&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
 80     WorkerThreadStartMode startMode = m_inspectorProxy-&gt;workerStartMode(*m_scriptExecutionContext.get());
 81     String identifier = m_inspectorProxy-&gt;identifier();
 82 
 83 #if ENABLE(INDEXED_DATABASE)
 84     IDBClient::IDBConnectionProxy* proxy = document.idbConnectionProxy();
 85 #else
 86     IDBClient::IDBConnectionProxy* proxy = nullptr;
 87 #endif
 88 
 89     SocketProvider* socketProvider = document.socketProvider();
 90 
<span class="line-modified"> 91     auto thread = DedicatedWorkerThread::create(scriptURL, name, identifier, userAgent, isOnline, sourceCode, *this, *this, *this, startMode, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, document.topOrigin(), timeOrigin, proxy, socketProvider, runtimeFlags, sessionID);</span>

 92 
 93     workerThreadCreated(thread.get());
<span class="line-modified"> 94     thread-&gt;start(nullptr);</span>
 95 
 96     m_inspectorProxy-&gt;workerStarted(m_scriptExecutionContext.get(), thread.ptr(), scriptURL);
 97 }
 98 
 99 void WorkerMessagingProxy::postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp; message)
100 {
101     m_scriptExecutionContext-&gt;postTask([this, message = WTFMove(message)] (ScriptExecutionContext&amp; context) mutable {
102         Worker* workerObject = this-&gt;workerObject();
103         if (!workerObject || askedToTerminate())
104             return;
105 
106         auto ports = MessagePort::entanglePorts(context, WTFMove(message.transferredPorts));
<span class="line-modified">107         workerObject-&gt;dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>
108     });
109 }
110 
111 void WorkerMessagingProxy::postMessageToWorkerGlobalScope(MessageWithMessagePorts&amp;&amp; message)
112 {
113     if (m_askedToTerminate)
114         return;
115 
116     ScriptExecutionContext::Task task([message = WTFMove(message)] (ScriptExecutionContext&amp; scriptContext) mutable {
117         ASSERT_WITH_SECURITY_IMPLICATION(scriptContext.isWorkerGlobalScope());
118         auto&amp; context = static_cast&lt;DedicatedWorkerGlobalScope&amp;&gt;(scriptContext);
119         auto ports = MessagePort::entanglePorts(scriptContext, WTFMove(message.transferredPorts));
120         context.dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));
121         context.thread().workerObjectProxy().confirmMessageFromWorkerObject(context.hasPendingActivity());
122     });
123 
124     if (m_workerThread) {
125         ++m_unconfirmedMessageCount;
126         m_workerThread-&gt;runLoop().postTask(WTFMove(task));
127     } else
128         m_queuedEarlyTasks.append(makeUnique&lt;ScriptExecutionContext::Task&gt;(WTFMove(task)));
129 }
130 
















131 void WorkerMessagingProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
132 {
133     // FIXME: In case of nested workers, this should go directly to the root Document context.
134     ASSERT(m_scriptExecutionContext-&gt;isDocument());
135     m_scriptExecutionContext-&gt;postTask(WTFMove(task));
136 }
137 
138 Ref&lt;CacheStorageConnection&gt; WorkerMessagingProxy::createCacheStorageConnection()
139 {
140     ASSERT(isMainThread());
141     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
<span class="line-modified">142     return document.page()-&gt;cacheStorageProvider().createCacheStorageConnection(document.page()-&gt;sessionID());</span>
143 }
144 
145 bool WorkerMessagingProxy::postTaskForModeToWorkerGlobalScope(ScriptExecutionContext::Task&amp;&amp; task, const String&amp; mode)
146 {
147     if (m_askedToTerminate)
148         return false;
149 
150     ASSERT(m_workerThread);
151     m_workerThread-&gt;runLoop().postTaskForMode(WTFMove(task), mode);
152     return true;
153 }
154 
155 void WorkerMessagingProxy::postExceptionToWorkerObject(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL)
156 {
<span class="line-modified">157     m_scriptExecutionContext-&gt;postTask([this, errorMessage = errorMessage.isolatedCopy(), sourceURL = sourceURL.isolatedCopy(), lineNumber, columnNumber] (ScriptExecutionContext&amp; context) {</span>
158         Worker* workerObject = this-&gt;workerObject();
159         if (!workerObject)
160             return;
161 
162         // We don&#39;t bother checking the askedToTerminate() flag here, because exceptions should *always* be reported even if the thread is terminated.
163         // This is intentionally different than the behavior in MessageWorkerTask, because terminated workers no longer deliver messages (section 4.6 of the WebWorker spec), but they do report exceptions.
<span class="line-modified">164 </span>
<span class="line-removed">165         auto event = ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { });</span>
<span class="line-removed">166         workerObject-&gt;dispatchEvent(event);</span>
<span class="line-removed">167         if (!event-&gt;defaultPrevented())</span>
<span class="line-removed">168             context.reportException(errorMessage, lineNumber, columnNumber, sourceURL, nullptr, nullptr);</span>
169     });
170 }
171 
172 void WorkerMessagingProxy::postMessageToDebugger(const String&amp; message)
173 {
174     RunLoop::main().dispatch([this, protectedThis = makeRef(*this), message = message.isolatedCopy()] {
175         if (!m_mayBeDestroyed)
176             m_inspectorProxy-&gt;sendMessageFromWorkerToFrontend(message);
177     });
178 }
179 
<span class="line-modified">180 void WorkerMessagingProxy::setResourceCachingDisabled(bool disabled)</span>
181 {
182     postTaskToLoader([disabled] (ScriptExecutionContext&amp; context) {
183         ASSERT(isMainThread());
184         if (auto* page = downcast&lt;Document&gt;(context).page())
<span class="line-modified">185             page-&gt;setResourceCachingDisabled(disabled);</span>
186     });
187 }
188 
189 void WorkerMessagingProxy::workerThreadCreated(DedicatedWorkerThread&amp; workerThread)
190 {
191     m_workerThread = &amp;workerThread;
192 
193     if (m_askedToTerminate) {
194         // Worker.terminate() could be called from JS before the thread was created.
195         m_workerThread-&gt;stop(nullptr);
196     } else {





197         ASSERT(!m_unconfirmedMessageCount);
198         m_unconfirmedMessageCount = m_queuedEarlyTasks.size();
199         m_workerThreadHadPendingActivity = true; // Worker initialization means a pending activity.
200 
201         auto queuedEarlyTasks = WTFMove(m_queuedEarlyTasks);
202         for (auto&amp; task : queuedEarlyTasks)
203             m_workerThread-&gt;runLoop().postTask(WTFMove(*task));
204     }
205 }
206 
207 void WorkerMessagingProxy::workerObjectDestroyed()
208 {
209     m_workerObject = nullptr;
210     m_scriptExecutionContext-&gt;postTask([this] (ScriptExecutionContext&amp;) {
211         m_mayBeDestroyed = true;
212         if (m_workerThread)
213             terminateWorkerGlobalScope();
214         else
215             workerGlobalScopeDestroyedInternal();
216     });
</pre>
</td>
<td>
<hr />
<pre>
 55 
 56 WorkerMessagingProxy::WorkerMessagingProxy(Worker&amp; workerObject)
 57     : m_scriptExecutionContext(workerObject.scriptExecutionContext())
 58     , m_inspectorProxy(makeUnique&lt;WorkerInspectorProxy&gt;(workerObject.identifier()))
 59     , m_workerObject(&amp;workerObject)
 60 {
 61     ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
 62         || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
 63 
 64     // Nobody outside this class ref counts this object. The original ref
 65     // is balanced by the deref in workerGlobalScopeDestroyedInternal.
 66 }
 67 
 68 WorkerMessagingProxy::~WorkerMessagingProxy()
 69 {
 70     ASSERT(!m_workerObject);
 71     ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
 72         || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
 73 }
 74 
<span class="line-modified"> 75 void WorkerMessagingProxy::startWorkerGlobalScope(const URL&amp; scriptURL, const String&amp; name, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, MonotonicTime timeOrigin, ReferrerPolicy referrerPolicy, JSC::RuntimeFlags runtimeFlags)</span>
 76 {
 77     // FIXME: This need to be revisited when we support nested worker one day
 78     ASSERT(m_scriptExecutionContext);
 79     Document&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
 80     WorkerThreadStartMode startMode = m_inspectorProxy-&gt;workerStartMode(*m_scriptExecutionContext.get());
 81     String identifier = m_inspectorProxy-&gt;identifier();
 82 
 83 #if ENABLE(INDEXED_DATABASE)
 84     IDBClient::IDBConnectionProxy* proxy = document.idbConnectionProxy();
 85 #else
 86     IDBClient::IDBConnectionProxy* proxy = nullptr;
 87 #endif
 88 
 89     SocketProvider* socketProvider = document.socketProvider();
 90 
<span class="line-modified"> 91     WorkerParameters params = { scriptURL, name, identifier, userAgent, isOnline, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, timeOrigin, referrerPolicy };</span>
<span class="line-added"> 92     auto thread = DedicatedWorkerThread::create(params, sourceCode, *this, *this, *this, startMode, document.topOrigin(), proxy, socketProvider, runtimeFlags);</span>
 93 
 94     workerThreadCreated(thread.get());
<span class="line-modified"> 95     thread-&gt;start();</span>
 96 
 97     m_inspectorProxy-&gt;workerStarted(m_scriptExecutionContext.get(), thread.ptr(), scriptURL);
 98 }
 99 
100 void WorkerMessagingProxy::postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp; message)
101 {
102     m_scriptExecutionContext-&gt;postTask([this, message = WTFMove(message)] (ScriptExecutionContext&amp; context) mutable {
103         Worker* workerObject = this-&gt;workerObject();
104         if (!workerObject || askedToTerminate())
105             return;
106 
107         auto ports = MessagePort::entanglePorts(context, WTFMove(message.transferredPorts));
<span class="line-modified">108         ActiveDOMObject::queueTaskToDispatchEvent(*workerObject, TaskSource::PostedMessageQueue, MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>
109     });
110 }
111 
112 void WorkerMessagingProxy::postMessageToWorkerGlobalScope(MessageWithMessagePorts&amp;&amp; message)
113 {
114     if (m_askedToTerminate)
115         return;
116 
117     ScriptExecutionContext::Task task([message = WTFMove(message)] (ScriptExecutionContext&amp; scriptContext) mutable {
118         ASSERT_WITH_SECURITY_IMPLICATION(scriptContext.isWorkerGlobalScope());
119         auto&amp; context = static_cast&lt;DedicatedWorkerGlobalScope&amp;&gt;(scriptContext);
120         auto ports = MessagePort::entanglePorts(scriptContext, WTFMove(message.transferredPorts));
121         context.dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));
122         context.thread().workerObjectProxy().confirmMessageFromWorkerObject(context.hasPendingActivity());
123     });
124 
125     if (m_workerThread) {
126         ++m_unconfirmedMessageCount;
127         m_workerThread-&gt;runLoop().postTask(WTFMove(task));
128     } else
129         m_queuedEarlyTasks.append(makeUnique&lt;ScriptExecutionContext::Task&gt;(WTFMove(task)));
130 }
131 
<span class="line-added">132 void WorkerMessagingProxy::suspendForBackForwardCache()</span>
<span class="line-added">133 {</span>
<span class="line-added">134     if (m_workerThread)</span>
<span class="line-added">135         m_workerThread-&gt;suspend();</span>
<span class="line-added">136     else</span>
<span class="line-added">137         m_askedToSuspend = true;</span>
<span class="line-added">138 }</span>
<span class="line-added">139 </span>
<span class="line-added">140 void WorkerMessagingProxy::resumeForBackForwardCache()</span>
<span class="line-added">141 {</span>
<span class="line-added">142     if (m_workerThread)</span>
<span class="line-added">143         m_workerThread-&gt;resume();</span>
<span class="line-added">144     else</span>
<span class="line-added">145         m_askedToSuspend = false;</span>
<span class="line-added">146 }</span>
<span class="line-added">147 </span>
148 void WorkerMessagingProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
149 {
150     // FIXME: In case of nested workers, this should go directly to the root Document context.
151     ASSERT(m_scriptExecutionContext-&gt;isDocument());
152     m_scriptExecutionContext-&gt;postTask(WTFMove(task));
153 }
154 
155 Ref&lt;CacheStorageConnection&gt; WorkerMessagingProxy::createCacheStorageConnection()
156 {
157     ASSERT(isMainThread());
158     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
<span class="line-modified">159     return document.page()-&gt;cacheStorageProvider().createCacheStorageConnection();</span>
160 }
161 
162 bool WorkerMessagingProxy::postTaskForModeToWorkerGlobalScope(ScriptExecutionContext::Task&amp;&amp; task, const String&amp; mode)
163 {
164     if (m_askedToTerminate)
165         return false;
166 
167     ASSERT(m_workerThread);
168     m_workerThread-&gt;runLoop().postTaskForMode(WTFMove(task), mode);
169     return true;
170 }
171 
172 void WorkerMessagingProxy::postExceptionToWorkerObject(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL)
173 {
<span class="line-modified">174     m_scriptExecutionContext-&gt;postTask([this, errorMessage = errorMessage.isolatedCopy(), sourceURL = sourceURL.isolatedCopy(), lineNumber, columnNumber] (ScriptExecutionContext&amp;) {</span>
175         Worker* workerObject = this-&gt;workerObject();
176         if (!workerObject)
177             return;
178 
179         // We don&#39;t bother checking the askedToTerminate() flag here, because exceptions should *always* be reported even if the thread is terminated.
180         // This is intentionally different than the behavior in MessageWorkerTask, because terminated workers no longer deliver messages (section 4.6 of the WebWorker spec), but they do report exceptions.
<span class="line-modified">181         ActiveDOMObject::queueTaskToDispatchEvent(*workerObject, TaskSource::DOMManipulation, ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { }));</span>




182     });
183 }
184 
185 void WorkerMessagingProxy::postMessageToDebugger(const String&amp; message)
186 {
187     RunLoop::main().dispatch([this, protectedThis = makeRef(*this), message = message.isolatedCopy()] {
188         if (!m_mayBeDestroyed)
189             m_inspectorProxy-&gt;sendMessageFromWorkerToFrontend(message);
190     });
191 }
192 
<span class="line-modified">193 void WorkerMessagingProxy::setResourceCachingDisabledByWebInspector(bool disabled)</span>
194 {
195     postTaskToLoader([disabled] (ScriptExecutionContext&amp; context) {
196         ASSERT(isMainThread());
197         if (auto* page = downcast&lt;Document&gt;(context).page())
<span class="line-modified">198             page-&gt;setResourceCachingDisabledByWebInspector(disabled);</span>
199     });
200 }
201 
202 void WorkerMessagingProxy::workerThreadCreated(DedicatedWorkerThread&amp; workerThread)
203 {
204     m_workerThread = &amp;workerThread;
205 
206     if (m_askedToTerminate) {
207         // Worker.terminate() could be called from JS before the thread was created.
208         m_workerThread-&gt;stop(nullptr);
209     } else {
<span class="line-added">210         if (m_askedToSuspend) {</span>
<span class="line-added">211             m_askedToSuspend = false;</span>
<span class="line-added">212             m_workerThread-&gt;suspend();</span>
<span class="line-added">213         }</span>
<span class="line-added">214 </span>
215         ASSERT(!m_unconfirmedMessageCount);
216         m_unconfirmedMessageCount = m_queuedEarlyTasks.size();
217         m_workerThreadHadPendingActivity = true; // Worker initialization means a pending activity.
218 
219         auto queuedEarlyTasks = WTFMove(m_queuedEarlyTasks);
220         for (auto&amp; task : queuedEarlyTasks)
221             m_workerThread-&gt;runLoop().postTask(WTFMove(*task));
222     }
223 }
224 
225 void WorkerMessagingProxy::workerObjectDestroyed()
226 {
227     m_workerObject = nullptr;
228     m_scriptExecutionContext-&gt;postTask([this] (ScriptExecutionContext&amp;) {
229         m_mayBeDestroyed = true;
230         if (m_workerThread)
231             terminateWorkerGlobalScope();
232         else
233             workerGlobalScopeDestroyedInternal();
234     });
</pre>
</td>
</tr>
</table>
<center><a href="WorkerLoaderProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerMessagingProxy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
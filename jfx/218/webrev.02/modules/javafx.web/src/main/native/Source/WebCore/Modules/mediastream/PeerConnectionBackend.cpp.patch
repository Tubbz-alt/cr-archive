diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp
@@ -33,10 +33,11 @@
 #include "PeerConnectionBackend.h"
 
 #if ENABLE(WEB_RTC)
 
 #include "EventNames.h"
+#include "JSDOMPromiseDeferred.h"
 #include "JSRTCSessionDescription.h"
 #include "LibWebRTCCertificateGenerator.h"
 #include "Logging.h"
 #include "Page.h"
 #include "RTCIceCandidate.h"
@@ -80,78 +81,84 @@
     , m_logIdentifier(peerConnection.logIdentifier())
 #endif
 {
 }
 
+PeerConnectionBackend::~PeerConnectionBackend() = default;
+
 void PeerConnectionBackend::createOffer(RTCOfferOptions&& options, PeerConnection::SessionDescriptionPromise&& promise)
 {
     ASSERT(!m_offerAnswerPromise);
     ASSERT(!m_peerConnection.isClosed());
 
-    m_offerAnswerPromise = WTFMove(promise);
+    m_offerAnswerPromise = WTF::makeUnique<PeerConnection::SessionDescriptionPromise>(WTFMove(promise));
     doCreateOffer(WTFMove(options));
 }
 
 void PeerConnectionBackend::createOfferSucceeded(String&& sdp)
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Create offer succeeded:\n", sdp);
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_offerAnswerPromise);
-    m_offerAnswerPromise->resolve(RTCSessionDescription::Init { RTCSdpType::Offer, filterSDP(WTFMove(sdp)) });
-    m_offerAnswerPromise = WTF::nullopt;
+    m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = filterSDP(WTFMove(sdp))]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
+
+        promise->resolve(RTCSessionDescription::Init { RTCSdpType::Offer, sdp });
+    });
 }
 
 void PeerConnectionBackend::createOfferFailed(Exception&& exception)
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Create offer failed:", exception.message());
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_offerAnswerPromise);
-    m_offerAnswerPromise->reject(WTFMove(exception));
-    m_offerAnswerPromise = WTF::nullopt;
+    m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
+
+        promise->reject(WTFMove(exception));
+    });
 }
 
 void PeerConnectionBackend::createAnswer(RTCAnswerOptions&& options, PeerConnection::SessionDescriptionPromise&& promise)
 {
     ASSERT(!m_offerAnswerPromise);
     ASSERT(!m_peerConnection.isClosed());
 
-    m_offerAnswerPromise = WTFMove(promise);
+    m_offerAnswerPromise = WTF::makeUnique<PeerConnection::SessionDescriptionPromise>(WTFMove(promise));
     doCreateAnswer(WTFMove(options));
 }
 
 void PeerConnectionBackend::createAnswerSucceeded(String&& sdp)
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Create answer succeeded:\n", sdp);
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_offerAnswerPromise);
-    m_offerAnswerPromise->resolve(RTCSessionDescription::Init { RTCSdpType::Answer, WTFMove(sdp) });
-    m_offerAnswerPromise = WTF::nullopt;
+    m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = WTFMove(sdp)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
+
+        promise->resolve(RTCSessionDescription::Init { RTCSdpType::Answer, sdp });
+    });
 }
 
 void PeerConnectionBackend::createAnswerFailed(Exception&& exception)
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Create answer failed:", exception.message());
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_offerAnswerPromise);
-    m_offerAnswerPromise->reject(WTFMove(exception));
-    m_offerAnswerPromise = WTF::nullopt;
+    m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
+
+        promise->reject(WTFMove(exception));
+    });
 }
 
 static inline bool isLocalDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
 {
     switch (state) {
@@ -178,40 +185,40 @@
     if (!isLocalDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
         promise.reject(InvalidStateError, "Description type incompatible with current signaling state");
         return;
     }
 
-    m_setDescriptionPromise = WTFMove(promise);
+    m_setDescriptionPromise = WTF::makeUnique<DOMPromiseDeferred<void>>(WTFMove(promise));
     doSetLocalDescription(sessionDescription);
 }
 
 void PeerConnectionBackend::setLocalDescriptionSucceeded()
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER);
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_setDescriptionPromise);
+    m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
 
-    m_setDescriptionPromise->resolve();
-    m_setDescriptionPromise = WTF::nullopt;
+        promise->resolve();
+    });
 }
 
 void PeerConnectionBackend::setLocalDescriptionFailed(Exception&& exception)
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Set local description failed:", exception.message());
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_setDescriptionPromise);
+    m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
 
-    m_setDescriptionPromise->reject(WTFMove(exception));
-    m_setDescriptionPromise = WTF::nullopt;
+        promise->reject(WTFMove(exception));
+    });
 }
 
 static inline bool isRemoteDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
 {
     switch (state) {
@@ -238,56 +245,57 @@
     if (!isRemoteDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
         promise.reject(InvalidStateError, "Description type incompatible with current signaling state");
         return;
     }
 
-    m_setDescriptionPromise = WTFMove(promise);
+    m_setDescriptionPromise = WTF::makeUnique<DOMPromiseDeferred<void>>(WTFMove(promise));
     doSetRemoteDescription(sessionDescription);
 }
 
 void PeerConnectionBackend::setRemoteDescriptionSucceeded()
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Set remote description succeeded");
+    ASSERT(m_setDescriptionPromise);
 
-    ASSERT(!m_peerConnection.isClosed());
-
+    auto promise = WTFMove(m_setDescriptionPromise);
     auto events = WTFMove(m_pendingTrackEvents);
     for (auto& event : events) {
         auto& track = event.track.get();
 
-        m_peerConnection.fireEvent(RTCTrackEvent::create(eventNames().trackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(event.receiver), WTFMove(event.track), WTFMove(event.streams), WTFMove(event.transceiver)));
+        m_peerConnection.dispatchEventWhenFeasible(RTCTrackEvent::create(eventNames().trackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(event.receiver), WTFMove(event.track), WTFMove(event.streams), WTFMove(event.transceiver)));
 
         if (m_peerConnection.isClosed())
             return;
 
         // FIXME: As per spec, we should set muted to 'false' when starting to receive the content from network.
         track.source().setMuted(false);
     }
 
-    if (m_peerConnection.isClosed())
-        return;
-
-    ASSERT(m_setDescriptionPromise);
+    m_peerConnection.doTask([this, promise = WTFMove(promise)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
 
-    m_setDescriptionPromise->resolve();
-    m_setDescriptionPromise = WTF::nullopt;
+        promise->resolve();
+    });
 }
 
 void PeerConnectionBackend::setRemoteDescriptionFailed(Exception&& exception)
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Set remote description failed:", exception.message());
 
     ASSERT(m_pendingTrackEvents.isEmpty());
     m_pendingTrackEvents.clear();
 
-    ASSERT(!m_peerConnection.isClosed());
     ASSERT(m_setDescriptionPromise);
+    m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
 
-    m_setDescriptionPromise->reject(WTFMove(exception));
-    m_setDescriptionPromise = WTF::nullopt;
+        promise->reject(WTFMove(exception));
+    });
 }
 
 void PeerConnectionBackend::addPendingTrackEvent(PendingTrackEvent&& event)
 {
     ASSERT(!m_peerConnection.isClosed());
@@ -317,47 +325,47 @@
     // FIXME: As per https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addicecandidate(), this check should be done before enqueuing the task.
     if (iceCandidate->sdpMid().isNull() && !iceCandidate->sdpMLineIndex()) {
         promise.reject(Exception { TypeError, "Trying to add a candidate that is missing both sdpMid and sdpMLineIndex"_s });
         return;
     }
-    m_addIceCandidatePromise = WTFMove(promise);
+    m_addIceCandidatePromise = WTF::makeUnique<DOMPromiseDeferred<void>>(WTFMove(promise));
     doAddIceCandidate(*iceCandidate);
 }
 
 void PeerConnectionBackend::addIceCandidateSucceeded()
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Adding ice candidate succeeded");
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_addIceCandidatePromise);
+    m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
 
-    m_addIceCandidatePromise->resolve();
-    m_addIceCandidatePromise = WTF::nullopt;
+        promise->resolve();
+    });
 }
 
 void PeerConnectionBackend::addIceCandidateFailed(Exception&& exception)
 {
     ASSERT(isMainThread());
     ALWAYS_LOG(LOGIDENTIFIER, "Adding ice candidate failed:", exception.message());
 
-    if (m_peerConnection.isClosed())
-        return;
-
     ASSERT(m_addIceCandidatePromise);
+    m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise), exception = WTFMove(exception)]() mutable {
+        if (m_peerConnection.isClosed())
+            return;
 
-    m_addIceCandidatePromise->reject(WTFMove(exception));
-    m_addIceCandidatePromise = WTF::nullopt;
+        promise->reject(WTFMove(exception));
+    });
 }
 
 void PeerConnectionBackend::fireICECandidateEvent(RefPtr<RTCIceCandidate>&& candidate, String&& serverURL)
 {
     ASSERT(isMainThread());
 
-    m_peerConnection.fireEvent(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, WTFMove(candidate), WTFMove(serverURL)));
+    m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, WTFMove(candidate), WTFMove(serverURL)));
 }
 
 void PeerConnectionBackend::enableICECandidateFiltering()
 {
     m_shouldFilterICECandidates = true;
@@ -411,13 +419,13 @@
         return WTFMove(sdp);
 
     StringBuilder filteredSDP;
     sdp.split('\n', [&filteredSDP](StringView line) {
         if (line.startsWith("c=IN IP4"))
-            filteredSDP.append("c=IN IP4 0.0.0.0");
+            filteredSDP.append("c=IN IP4 0.0.0.0\r");
         else if (line.startsWith("c=IN IP6"))
-            filteredSDP.append("c=IN IP6 ::");
+            filteredSDP.append("c=IN IP6 ::\r");
         else if (!line.startsWith("a=candidate"))
             filteredSDP.append(line);
         else if (line.find(" host ", 11) == notFound)
             filteredSDP.append(filterICECandidate(line.toString()));
         else
@@ -457,27 +465,32 @@
     m_finishedGatheringCandidates = true;
 
     if (m_waitingForMDNSRegistration)
         return;
 
-    m_peerConnection.fireEvent(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, nullptr, { }));
+    m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, nullptr, { }));
     m_peerConnection.updateIceGatheringState(RTCIceGatheringState::Complete);
     m_pendingICECandidates.clear();
 }
 
+void PeerConnectionBackend::endOfIceCandidates(DOMPromiseDeferred<void>&& promise)
+{
+    promise.resolve();
+}
+
 void PeerConnectionBackend::registerMDNSName(const String& ipAddress)
 {
     ++m_waitingForMDNSRegistration;
     auto& document = downcast<Document>(*m_peerConnection.scriptExecutionContext());
     auto& provider = document.page()->libWebRTCProvider();
-    provider.registerMDNSName(document.sessionID(), document.identifier().toUInt64(), ipAddress, [peerConnection = makeRef(m_peerConnection), this, ipAddress] (LibWebRTCProvider::MDNSNameOrError&& result) {
+    provider.registerMDNSName(document.identifier().toUInt64(), ipAddress, [peerConnection = makeRef(m_peerConnection), this, ipAddress] (LibWebRTCProvider::MDNSNameOrError&& result) {
         if (peerConnection->isStopped())
             return;
 
         --m_waitingForMDNSRegistration;
         if (!result.has_value()) {
-            m_peerConnection.scriptExecutionContext()->addConsoleMessage(MessageSource::JS, MessageLevel::Warning, makeString("MDNS registration of a host candidate failed with error", (unsigned)result.error()));
+            m_peerConnection.scriptExecutionContext()->addConsoleMessage(MessageSource::JS, MessageLevel::Warning, makeString("MDNS registration of a host candidate failed with error ", (unsigned)result.error()));
             return;
         }
 
         this->finishedRegisteringMDNSName(ipAddress, result.value());
     });
@@ -506,19 +519,19 @@
 {
     ASSERT(isMainThread());
 
     if (newSignalingState != m_peerConnection.signalingState()) {
         m_peerConnection.setSignalingState(newSignalingState);
-        m_peerConnection.fireEvent(Event::create(eventNames().signalingstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+        m_peerConnection.dispatchEventWhenFeasible(Event::create(eventNames().signalingstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
     }
 }
 
 void PeerConnectionBackend::stop()
 {
-    m_offerAnswerPromise = WTF::nullopt;
-    m_setDescriptionPromise = WTF::nullopt;
-    m_addIceCandidatePromise = WTF::nullopt;
+    m_offerAnswerPromise = nullptr;
+    m_setDescriptionPromise = nullptr;
+    m_addIceCandidatePromise = nullptr;
 
     m_pendingTrackEvents.clear();
 
     doStop();
 }

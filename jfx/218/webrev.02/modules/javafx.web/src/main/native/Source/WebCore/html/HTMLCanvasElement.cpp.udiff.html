<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLAttributeNames.in.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -53,11 +53,10 @@</span>
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;ScriptController.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;StringAdaptors.h&quot;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
<span class="udiff-line-removed">- #include &lt;JavaScriptCore/JSLock.h&gt;</span>
  #include &lt;math.h&gt;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/RAMSize.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,10 +81,14 @@</span>
  #if PLATFORM(COCOA)
  #include &quot;MediaSampleAVFObjC.h&quot;
  #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
  #endif
  
<span class="udiff-line-added">+ #if USE(CG)</span>
<span class="udiff-line-added">+ #include &quot;ImageBufferUtilitiesCG.h&quot;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLCanvasElement);
  
  using namespace PAL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102,23 +105,15 @@</span>
  const unsigned maxCanvasArea = 4096 * 4096;
  #else
  const unsigned maxCanvasArea = 16384 * 16384;
  #endif
  
<span class="udiff-line-modified-removed">- #if USE(CG)</span>
<span class="udiff-line-removed">- // FIXME: It seems strange that the default quality is not the one that is literally named &quot;default&quot;.</span>
<span class="udiff-line-removed">- // Should fix names to make this easier to understand, or write an excellent comment here explaining why not.</span>
<span class="udiff-line-removed">- const InterpolationQuality defaultInterpolationQuality = InterpolationLow;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- const InterpolationQuality defaultInterpolationQuality = InterpolationDefault;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static size_t activePixelMemory = 0;</span>
<span class="udiff-line-modified-added">+ static size_t maxActivePixelMemoryForTesting = 0;</span>
  
  HTMLCanvasElement::HTMLCanvasElement(const QualifiedName&amp; tagName, Document&amp; document)
      : HTMLElement(tagName, document)
<span class="udiff-line-modified-removed">-     , m_size(defaultWidth, defaultHeight)</span>
<span class="udiff-line-modified-added">+     , CanvasBase(IntSize(defaultWidth, defaultHeight))</span>
  {
      ASSERT(hasTagName(canvasTag));
  }
  
  Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(Document&amp; document)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -129,28 +124,19 @@</span>
  Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(const QualifiedName&amp; tagName, Document&amp; document)
  {
      return adoptRef(*new HTMLCanvasElement(tagName, document));
  }
  
<span class="udiff-line-removed">- static void removeFromActivePixelMemory(size_t pixelsReleased)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (!pixelsReleased)</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (pixelsReleased &lt; activePixelMemory)</span>
<span class="udiff-line-removed">-         activePixelMemory -= pixelsReleased;</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-         activePixelMemory = 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  HTMLCanvasElement::~HTMLCanvasElement()
  {
<span class="udiff-line-added">+     // FIXME: This has to be called here because CSSCanvasValue::CanvasObserverProxy::canvasDestroyed()</span>
<span class="udiff-line-added">+     // downcasts the CanvasBase object to HTMLCanvasElement. That invokes virtual methods, which should be</span>
<span class="udiff-line-added">+     // avoided in destructors, but works as long as it&#39;s done before HTMLCanvasElement destructs completely.</span>
      notifyObserversCanvasDestroyed();
  
      m_context = nullptr; // Ensure this goes away before the ImageBuffer.
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     releaseImageBufferAndContext();</span>
<span class="udiff-line-modified-added">+     setImageBuffer(nullptr);</span>
  }
  
  void HTMLCanvasElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
  {
      if (name == widthAttr || name == heightAttr)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -190,25 +176,46 @@</span>
          return Exception { InvalidStateError };
      setAttributeWithoutSynchronization(widthAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultWidth)));
      return { };
  }
  
<span class="udiff-line-added">+ void HTMLCanvasElement::setSize(const IntSize&amp; newSize)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (newSize == size())</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_ignoreReset = true;</span>
<span class="udiff-line-added">+     setWidth(newSize.width());</span>
<span class="udiff-line-added">+     setHeight(newSize.height());</span>
<span class="udiff-line-added">+     m_ignoreReset = false;</span>
<span class="udiff-line-added">+     reset();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  static inline size_t maxActivePixelMemory()
  {
<span class="udiff-line-added">+     if (maxActivePixelMemoryForTesting)</span>
<span class="udiff-line-added">+         return maxActivePixelMemoryForTesting;</span>
<span class="udiff-line-added">+ </span>
      static size_t maxPixelMemory;
      static std::once_flag onceFlag;
      std::call_once(onceFlag, [] {
  #if PLATFORM(IOS_FAMILY)
          maxPixelMemory = ramSize() / 4;
  #else
          maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);
  #endif
      });
<span class="udiff-line-added">+ </span>
      return maxPixelMemory;
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::ExecState&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
<span class="udiff-line-modified-added">+ void HTMLCanvasElement::setMaxPixelMemoryForTesting(size_t size)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     maxActivePixelMemoryForTesting = size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::JSGlobalObject&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
  {
      if (m_context) {
          if (m_context-&gt;isPlaceholder())
              return Exception { InvalidStateError };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -329,11 +336,11 @@</span>
      ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
      ASSERT(!m_context);
  
      // Make sure we don&#39;t use more pixel memory than the system can support.
      size_t requestedPixelMemory = 4 * width() * height();
<span class="udiff-line-modified-removed">-     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
<span class="udiff-line-modified-added">+     if (activePixelMemory() + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
          StringBuilder stringBuilder;
          stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
          stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
          stringBuilder.appendLiteral(&quot; MB).&quot;);
          document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -535,16 +542,11 @@</span>
      bool hadImageBuffer = hasCreatedImageBuffer();
  
      int w = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(widthAttr), defaultWidth);
      int h = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(heightAttr), defaultHeight);
  
<span class="udiff-line-modified-removed">-     if (m_contextStateSaver) {</span>
<span class="udiff-line-removed">-         // Reset to the initial graphics context state.</span>
<span class="udiff-line-removed">-         m_contextStateSaver-&gt;restore();</span>
<span class="udiff-line-removed">-         m_contextStateSaver-&gt;save();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     resetGraphicsContextState();</span>
      if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
          downcast&lt;CanvasRenderingContext2D&gt;(*m_context).reset();
  
      IntSize oldSize = size();
      IntSize newSize(w, h);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -628,16 +630,10 @@</span>
  bool HTMLCanvasElement::isGPUBased() const
  {
      return m_context &amp;&amp; m_context-&gt;isGPUBased();
  }
  
<span class="udiff-line-removed">- void HTMLCanvasElement::makeRenderingResultsAvailable()</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (m_context)</span>
<span class="udiff-line-removed">-         m_context-&gt;paintRenderingResultsToCanvas();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void HTMLCanvasElement::makePresentationCopy()
  {
      if (!m_presentedImage) {
          // The buffer contains the last presented data, so save a copy of it.
          m_presentedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -647,21 +643,15 @@</span>
  void HTMLCanvasElement::clearPresentationCopy()
  {
      m_presentedImage = nullptr;
  }
  
<span class="udiff-line-removed">- void HTMLCanvasElement::releaseImageBufferAndContext()</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     m_contextStateSaver = nullptr;</span>
<span class="udiff-line-removed">-     setImageBuffer(nullptr);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void HTMLCanvasElement::setSurfaceSize(const IntSize&amp; size)
  {
<span class="udiff-line-modified-removed">-     m_size = size;</span>
<span class="udiff-line-modified-added">+     CanvasBase::setSize(size);</span>
      m_hasCreatedImageBuffer = false;
<span class="udiff-line-modified-removed">-     releaseImageBufferAndContext();</span>
<span class="udiff-line-modified-added">+     setImageBuffer(nullptr);</span>
      clearCopiedImage();
  }
  
  static String toEncodingMimeType(const String&amp; mimeType)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -686,11 +676,11 @@</span>
  ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType, JSC::JSValue qualityValue)
  {
      if (!originClean())
          return Exception { SecurityError };
  
<span class="udiff-line-modified-removed">-     if (m_size.isEmpty() || !buffer())</span>
<span class="udiff-line-modified-added">+     if (size().isEmpty() || !buffer())</span>
          return UncachedString { &quot;data:,&quot;_s };
      if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
          ResourceLoadObserver::shared().logCanvasRead(document());
  
      auto encodingMIMEType = toEncodingMimeType(mimeType);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -715,11 +705,11 @@</span>
  ExceptionOr&lt;void&gt; HTMLCanvasElement::toBlob(ScriptExecutionContext&amp; context, Ref&lt;BlobCallback&gt;&amp;&amp; callback, const String&amp; mimeType, JSC::JSValue qualityValue)
  {
      if (!originClean())
          return Exception { SecurityError };
  
<span class="udiff-line-modified-removed">-     if (m_size.isEmpty() || !buffer()) {</span>
<span class="udiff-line-modified-added">+     if (size().isEmpty() || !buffer()) {</span>
          callback-&gt;scheduleCallback(context, nullptr);
          return { };
      }
      if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
          ResourceLoadObserver::shared().logCanvasRead(document());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -730,22 +720,22 @@</span>
  #if USE(CG)
      if (auto imageData = getImageData()) {
          RefPtr&lt;Blob&gt; blob;
          Vector&lt;uint8_t&gt; blobData = data(*imageData, encodingMIMEType, quality);
          if (!blobData.isEmpty())
<span class="udiff-line-modified-removed">-             blob = Blob::create(context.sessionID(), WTFMove(blobData), encodingMIMEType);</span>
<span class="udiff-line-modified-added">+             blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
          callback-&gt;scheduleCallback(context, WTFMove(blob));
          return { };
      }
  #endif
  
      makeRenderingResultsAvailable();
  
      RefPtr&lt;Blob&gt; blob;
      Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
      if (!blobData.isEmpty())
<span class="udiff-line-modified-removed">-         blob = Blob::create(context.sessionID(), WTFMove(blobData), encodingMIMEType);</span>
<span class="udiff-line-modified-added">+         blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
      callback-&gt;scheduleCallback(context, WTFMove(blob));
      return { };
  }
  
  RefPtr&lt;ImageData&gt; HTMLCanvasElement::getImageData()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -828,32 +818,10 @@</span>
      UNUSED_PARAM(size);
      return false;
  #endif
  }
  
<span class="udiff-line-removed">- size_t HTMLCanvasElement::memoryCost() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="udiff-line-removed">-     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="udiff-line-removed">-     // from being changed while we access it.</span>
<span class="udiff-line-removed">-     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="udiff-line-removed">-     if (!m_imageBuffer)</span>
<span class="udiff-line-removed">-         return 0;</span>
<span class="udiff-line-removed">-     return m_imageBuffer-&gt;memoryCost();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- size_t HTMLCanvasElement::externalMemoryCost() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     // externalMemoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="udiff-line-removed">-     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="udiff-line-removed">-     // from being changed while we access it.</span>
<span class="udiff-line-removed">-     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="udiff-line-removed">-     if (!m_imageBuffer)</span>
<span class="udiff-line-removed">-         return 0;</span>
<span class="udiff-line-removed">-     return m_imageBuffer-&gt;externalMemoryCost();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void HTMLCanvasElement::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
  {
      if (usesDisplayListDrawing == m_usesDisplayListDrawing)
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -890,11 +858,11 @@</span>
      return String();
  }
  
  void HTMLCanvasElement::createImageBuffer() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(!m_imageBuffer);</span>
<span class="udiff-line-modified-added">+     ASSERT(!hasCreatedImageBuffer());</span>
  
      m_hasCreatedImageBuffer = true;
      m_didClearImageBuffer = true;
  
      // Perform multiplication as floating point to avoid overflow
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -907,11 +875,11 @@</span>
          return;
      }
  
      // Make sure we don&#39;t use more pixel memory than the system can support.
      size_t requestedPixelMemory = 4 * width() * height();
<span class="udiff-line-modified-removed">-     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
<span class="udiff-line-modified-added">+     if (activePixelMemory() + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
          StringBuilder stringBuilder;
          stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
          stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
          stringBuilder.appendLiteral(&quot; MB).&quot;);
          document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -919,45 +887,14 @@</span>
      }
  
      if (!width() || !height())
          return;
  
<span class="udiff-line-modified-removed">-     RenderingMode renderingMode = shouldAccelerate(size()) ? Accelerated : Unaccelerated;</span>
<span class="udiff-line-modified-added">+     RenderingMode renderingMode = shouldAccelerate(size()) ? RenderingMode::Accelerated : RenderingMode::Unaccelerated;</span>
  
      auto hostWindow = (document().view() &amp;&amp; document().view()-&gt;root()) ? document().view()-&gt;root()-&gt;hostWindow() : nullptr;
<span class="udiff-line-modified-removed">-     setImageBuffer(ImageBuffer::create(size(), renderingMode, 1, ColorSpaceSRGB, hostWindow));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void HTMLCanvasElement::setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     size_t previousMemoryCost = memoryCost();</span>
<span class="udiff-line-removed">-     removeFromActivePixelMemory(previousMemoryCost);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="udiff-line-removed">-         m_contextStateSaver = nullptr;</span>
<span class="udiff-line-removed">-         m_imageBuffer = WTFMove(buffer);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())</span>
<span class="udiff-line-removed">-         m_size = m_imageBuffer-&gt;internalSize();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     size_t currentMemoryCost = memoryCost();</span>
<span class="udiff-line-removed">-     activePixelMemory += currentMemoryCost;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (m_context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != currentMemoryCost)</span>
<span class="udiff-line-removed">-         InspectorInstrumentation::didChangeCanvasMemory(*m_context);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!m_imageBuffer)</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);</span>
<span class="udiff-line-removed">-     m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);</span>
<span class="udiff-line-removed">-     m_imageBuffer-&gt;context().setStrokeThickness(1);</span>
<span class="udiff-line-removed">-     m_contextStateSaver = makeUnique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     JSC::JSLockHolder lock(HTMLElement::scriptExecutionContext()-&gt;vm());</span>
<span class="udiff-line-removed">-     HTMLElement::scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());</span>
<span class="udiff-line-modified-added">+     setImageBuffer(ImageBuffer::create(size(), renderingMode, 1, ColorSpace::SRGB, hostWindow));</span>
  
  #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
      if (m_context &amp;&amp; m_context-&gt;is2d()) {
          // Recalculate compositing requirements if acceleration state changed.
          const_cast&lt;HTMLCanvasElement*&gt;(this)-&gt;invalidateStyleAndLayerComposition();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -967,34 +904,11 @@</span>
  
  void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
  {
      m_hasCreatedImageBuffer = true;
      setImageBuffer(WTFMove(buffer));
<span class="udiff-line-modified-removed">-     didDraw(FloatRect(FloatPoint(), m_size));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- GraphicsContext* HTMLCanvasElement::drawingContext() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (m_context &amp;&amp; !m_context-&gt;is2d())</span>
<span class="udiff-line-removed">-         return nullptr;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return buffer() ? &amp;m_imageBuffer-&gt;context() : nullptr;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- GraphicsContext* HTMLCanvasElement::existingDrawingContext() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (!m_hasCreatedImageBuffer)</span>
<span class="udiff-line-removed">-         return nullptr;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return drawingContext();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- ImageBuffer* HTMLCanvasElement::buffer() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (!m_hasCreatedImageBuffer)</span>
<span class="udiff-line-removed">-         createImageBuffer();</span>
<span class="udiff-line-removed">-     return m_imageBuffer.get();</span>
<span class="udiff-line-modified-added">+     didDraw(FloatRect(FloatPoint(), size()));</span>
  }
  
  Image* HTMLCanvasElement::copiedImage() const
  {
      if (!m_copiedImage &amp;&amp; buffer()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1023,12 +937,6 @@</span>
  {
      m_copiedImage = nullptr;
      m_didClearImageBuffer = false;
  }
  
<span class="udiff-line-removed">- AffineTransform HTMLCanvasElement::baseTransform() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(m_hasCreatedImageBuffer);</span>
<span class="udiff-line-removed">-     return m_imageBuffer-&gt;baseTransform();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  }
</pre>
<center><a href="HTMLAttributeNames.in.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
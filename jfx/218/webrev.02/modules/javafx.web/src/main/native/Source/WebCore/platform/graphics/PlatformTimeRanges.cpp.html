<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformTimeRanges.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PlatformTimeRanges.h&quot;
 28 
 29 #include &lt;math.h&gt;
 30 #include &lt;wtf/PrintStream.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 PlatformTimeRanges::PlatformTimeRanges(const MediaTime&amp; start, const MediaTime&amp; end)
 35 {
 36     add(start, end);
 37 }
 38 
 39 PlatformTimeRanges::PlatformTimeRanges(Vector&lt;Range&gt;&amp;&amp; ranges)
 40     : m_ranges { WTFMove(ranges) }
 41 {
 42 }
 43 
 44 void PlatformTimeRanges::invert()
 45 {
 46     PlatformTimeRanges inverted;
 47     MediaTime posInf = MediaTime::positiveInfiniteTime();
 48     MediaTime negInf = MediaTime::negativeInfiniteTime();
 49 
 50     if (!m_ranges.size())
 51         inverted.add(negInf, posInf);
 52     else {
 53         MediaTime start = m_ranges.first().m_start;
 54         if (start != negInf)
 55             inverted.add(negInf, start);
 56 
 57         for (size_t index = 0; index + 1 &lt; m_ranges.size(); ++index)
 58             inverted.add(m_ranges[index].m_end, m_ranges[index + 1].m_start);
 59 
 60         MediaTime end = m_ranges.last().m_end;
 61         if (end != posInf)
 62             inverted.add(end, posInf);
 63     }
 64 
 65     m_ranges.swap(inverted.m_ranges);
 66 }
 67 
 68 void PlatformTimeRanges::intersectWith(const PlatformTimeRanges&amp; other)
 69 {
 70     PlatformTimeRanges invertedOther(other);
 71 
 72     invertedOther.invert();
 73     invert();
 74     unionWith(invertedOther);
 75     invert();
 76 }
 77 
 78 void PlatformTimeRanges::unionWith(const PlatformTimeRanges&amp; other)
 79 {
 80     PlatformTimeRanges unioned(*this);
 81 
 82     for (size_t index = 0; index &lt; other.m_ranges.size(); ++index) {
 83         const Range&amp; range = other.m_ranges[index];
 84         unioned.add(range.m_start, range.m_end);
 85     }
 86 
 87     m_ranges.swap(unioned.m_ranges);
 88 }
 89 
 90 MediaTime PlatformTimeRanges::start(unsigned index) const
 91 {
 92     bool ignoredValid;
 93     return start(index, ignoredValid);
 94 }
 95 
 96 MediaTime PlatformTimeRanges::start(unsigned index, bool&amp; valid) const
 97 {
 98     if (index &gt;= length()) {
 99         valid = false;
100         return MediaTime::zeroTime();
101     }
102 
103     valid = true;
104     return m_ranges[index].m_start;
105 }
106 
107 MediaTime PlatformTimeRanges::end(unsigned index) const
108 {
109     bool ignoredValid;
110     return end(index, ignoredValid);
111 }
112 
113 MediaTime PlatformTimeRanges::end(unsigned index, bool&amp; valid) const
114 {
115     if (index &gt;= length()) {
116         valid = false;
117         return MediaTime::zeroTime();
118     }
119 
120     valid = true;
121     return m_ranges[index].m_end;
122 }
123 
124 MediaTime PlatformTimeRanges::duration(unsigned index) const
125 {
126     if (index &gt;= length())
127         return MediaTime::invalidTime();
128 
129     return m_ranges[index].m_end - m_ranges[index].m_start;
130 }
131 
132 MediaTime PlatformTimeRanges::maximumBufferedTime() const
133 {
134     if (!length())
135         return MediaTime::invalidTime();
136 
137     return m_ranges[length() - 1].m_end;
138 }
139 
140 void PlatformTimeRanges::add(const MediaTime&amp; start, const MediaTime&amp; end)
141 {
142 #if !PLATFORM(MAC) // https://bugs.webkit.org/show_bug.cgi?id=180253
143     ASSERT(start.isValid());
144     ASSERT(end.isValid());
145 #endif
146     ASSERT(start &lt;= end);
147 
148     unsigned overlappingArcIndex;
149     Range addedRange(start, end);
150 
151     // For each present range check if we need to:
152     // - merge with the added range, in case we are overlapping or contiguous
153     // - Need to insert in place, we we are completely, not overlapping and not contiguous
154     // in between two ranges.
155     //
156     // TODO: Given that we assume that ranges are correctly ordered, this could be optimized.
157 
158     for (overlappingArcIndex = 0; overlappingArcIndex &lt; m_ranges.size(); overlappingArcIndex++) {
159         if (addedRange.isOverlappingRange(m_ranges[overlappingArcIndex]) || addedRange.isContiguousWithRange(m_ranges[overlappingArcIndex])) {
160             // We need to merge the addedRange and that range.
161             addedRange = addedRange.unionWithOverlappingOrContiguousRange(m_ranges[overlappingArcIndex]);
162             m_ranges.remove(overlappingArcIndex);
163             overlappingArcIndex--;
164         } else {
165             // Check the case for which there is no more to do
166             if (!overlappingArcIndex) {
167                 if (addedRange.isBeforeRange(m_ranges[0])) {
168                     // First index, and we are completely before that range (and not contiguous, nor overlapping).
169                     // We just need to be inserted here.
170                     break;
171                 }
172             } else {
173                 if (m_ranges[overlappingArcIndex - 1].isBeforeRange(addedRange) &amp;&amp; addedRange.isBeforeRange(m_ranges[overlappingArcIndex])) {
174                     // We are exactly after the current previous range, and before the current range, while
175                     // not overlapping with none of them. Insert here.
176                     break;
177                 }
178             }
179         }
180     }
181 
182     // Now that we are sure we don&#39;t overlap with any range, just add it.
183     m_ranges.insert(overlappingArcIndex, addedRange);
184 }
185 
186 void PlatformTimeRanges::clear()
187 {
188     m_ranges.clear();
189 }
190 
191 bool PlatformTimeRanges::contain(const MediaTime&amp; time) const
192 {
193     return find(time) != notFound;
194 }
195 
196 size_t PlatformTimeRanges::find(const MediaTime&amp; time) const
197 {
198     bool ignoreInvalid;
199     for (unsigned n = 0; n &lt; length(); n++) {
200         if (time &gt;= start(n, ignoreInvalid) &amp;&amp; time &lt;= end(n, ignoreInvalid))
201             return n;
202     }
203     return notFound;
204 }
205 
206 MediaTime PlatformTimeRanges::nearest(const MediaTime&amp; time) const
207 {
208     MediaTime closestDelta = MediaTime::positiveInfiniteTime();
209     MediaTime closestTime = MediaTime::zeroTime();
210     unsigned count = length();
211     if (!count)
212         return MediaTime::invalidTime();
213 
214     bool ignoreInvalid;
215 
216     for (unsigned ndx = 0; ndx &lt; count; ndx++) {
217         MediaTime startTime = start(ndx, ignoreInvalid);
218         MediaTime endTime = end(ndx, ignoreInvalid);
219         if (time &gt;= startTime &amp;&amp; time &lt;= endTime)
220             return time;
221 
222         MediaTime startTimeDelta = abs(startTime - time);
223         if (startTimeDelta &lt; closestDelta) {
224             closestTime = startTime;
225             closestDelta = startTimeDelta;
226         }
227 
228         MediaTime endTimeDelta = abs(endTime - time);
229         if (endTimeDelta &lt; closestDelta) {
230             closestTime = endTime;
231             closestDelta = endTimeDelta;
232         }
233     }
234     return closestTime;
235 }
236 
237 MediaTime PlatformTimeRanges::totalDuration() const
238 {
239     MediaTime total = MediaTime::zeroTime();
240 
241     for (unsigned n = 0; n &lt; length(); n++)
242         total += abs(end(n) - start(n));
243     return total;
244 }
245 
246 void PlatformTimeRanges::dump(PrintStream&amp; out) const
247 {
248     if (!length())
249         return;
250 
251     for (size_t i = 0; i &lt; length(); ++i)
252         out.print(&quot;[&quot;, start(i), &quot;..&quot;, end(i), &quot;] &quot;);
253 }
254 
255 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<a name="1" id="anc1"></a><span class="line-removed"> 28 #include &quot;BytecodeStructs.h&quot;</span>
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;CodeSpecializationKind.h&quot;
 31 #include &quot;DirectArguments.h&quot;
 32 #include &quot;ExceptionHelpers.h&quot;
 33 #include &quot;FunctionCodeBlock.h&quot;
 34 #include &quot;JSImmutableButterfly.h&quot;
 35 #include &quot;ScopedArguments.h&quot;
 36 #include &quot;SlowPathReturnType.h&quot;
 37 #include &quot;StackAlignment.h&quot;
 38 #include &quot;VMInlines.h&quot;
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 
 41 namespace JSC {
 42 
 43 // The purpose of this namespace is to include slow paths that are shared
 44 // between the interpreter and baseline JIT. They are written to be agnostic
 45 // with respect to the slow-path calling convention, but they do rely on the
 46 // JS code being executed more-or-less directly from bytecode (so the call
 47 // frame layout is unmodified, making it potentially awkward to use these
 48 // from any optimizing JIT, like the DFG).
 49 
 50 namespace CommonSlowPaths {
 51 
 52 ALWAYS_INLINE int numberOfExtraSlots(int argumentCountIncludingThis)
 53 {
 54     int frameSize = argumentCountIncludingThis + CallFrame::headerSizeInRegisters;
 55     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), frameSize);
 56     return alignedFrameSize - frameSize;
 57 }
 58 
 59 ALWAYS_INLINE int numberOfStackPaddingSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 60 {
 61     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 62         return 0;
 63     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), argumentCountIncludingThis + CallFrame::headerSizeInRegisters);
 64     int alignedFrameSizeForParameters = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), codeBlock-&gt;numParameters() + CallFrame::headerSizeInRegisters);
 65     return alignedFrameSizeForParameters - alignedFrameSize;
 66 }
 67 
 68 ALWAYS_INLINE int numberOfStackPaddingSlotsWithExtraSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 69 {
 70     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 71         return 0;
 72     return numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis) + numberOfExtraSlots(argumentCountIncludingThis);
 73 }
 74 
<a name="2" id="anc2"></a><span class="line-modified"> 75 ALWAYS_INLINE CodeBlock* codeBlockFromCallFrameCallee(ExecState* exec, CodeSpecializationKind kind)</span>
 76 {
<a name="3" id="anc3"></a><span class="line-modified"> 77     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
 78     ASSERT(!callee-&gt;isHostFunction());
 79     return callee-&gt;jsExecutable()-&gt;codeBlockFor(kind);
 80 }
 81 
<a name="4" id="anc4"></a><span class="line-modified"> 82 ALWAYS_INLINE int arityCheckFor(ExecState* exec, VM&amp; vm, CodeSpecializationKind kind)</span>
 83 {
<a name="5" id="anc5"></a><span class="line-modified"> 84     CodeBlock* newCodeBlock = codeBlockFromCallFrameCallee(exec, kind);</span>
<span class="line-modified"> 85     ASSERT(exec-&gt;argumentCountIncludingThis() &lt; static_cast&lt;unsigned&gt;(newCodeBlock-&gt;numParameters()));</span>
<span class="line-modified"> 86     int padding = numberOfStackPaddingSlotsWithExtraSlots(newCodeBlock, exec-&gt;argumentCountIncludingThis());</span>
 87 
<a name="6" id="anc6"></a><span class="line-modified"> 88     Register* newStack = exec-&gt;registers() - WTF::roundUpToMultipleOf(stackAlignmentRegisters(), padding);</span>
 89 
 90     if (UNLIKELY(!vm.ensureStackCapacityFor(newStack)))
 91         return -1;
 92     return padding;
 93 }
 94 
<a name="7" id="anc7"></a><span class="line-modified"> 95 inline bool opInByVal(ExecState* exec, JSValue baseVal, JSValue propName, ArrayProfile* arrayProfile = nullptr)</span>
 96 {
<a name="8" id="anc8"></a><span class="line-modified"> 97     VM&amp; vm = exec-&gt;vm();</span>
 98     auto scope = DECLARE_THROW_SCOPE(vm);
 99     if (!baseVal.isObject()) {
<a name="9" id="anc9"></a><span class="line-modified">100         throwException(exec, scope, createInvalidInParameterError(exec, baseVal));</span>
101         return false;
102     }
103 
104     JSObject* baseObj = asObject(baseVal);
105     if (arrayProfile)
106         arrayProfile-&gt;observeStructure(baseObj-&gt;structure(vm));
107 
108     uint32_t i;
109     if (propName.getUInt32(i)) {
110         if (arrayProfile)
111             arrayProfile-&gt;observeIndexedRead(vm, baseObj, i);
<a name="10" id="anc10"></a><span class="line-modified">112         RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(exec, i));</span>
113     }
114 
<a name="11" id="anc11"></a><span class="line-modified">115     auto property = propName.toPropertyKey(exec);</span>
116     RETURN_IF_EXCEPTION(scope, false);
<a name="12" id="anc12"></a><span class="line-modified">117     RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(exec, property));</span>
<span class="line-removed">118 }</span>
<span class="line-removed">119 </span>
<span class="line-removed">120 inline void tryCachePutToScopeGlobal(</span>
<span class="line-removed">121     ExecState* exec, CodeBlock* codeBlock, OpPutToScope&amp; bytecode, JSObject* scope,</span>
<span class="line-removed">122     PutPropertySlot&amp; slot, const Identifier&amp; ident)</span>
<span class="line-removed">123 {</span>
<span class="line-removed">124     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.</span>
<span class="line-removed">125     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">126     ResolveType resolveType = metadata.m_getPutInfo.resolveType();</span>
<span class="line-removed">127 </span>
<span class="line-removed">128     switch (resolveType) {</span>
<span class="line-removed">129     case UnresolvedProperty:</span>
<span class="line-removed">130     case UnresolvedPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">131         if (scope-&gt;isGlobalObject()) {</span>
<span class="line-removed">132             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;</span>
<span class="line-removed">133             resolveType = newResolveType; // Allow below caching mechanism to kick in.</span>
<span class="line-removed">134             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">135             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">136             break;</span>
<span class="line-removed">137         }</span>
<span class="line-removed">138         FALLTHROUGH;</span>
<span class="line-removed">139     }</span>
<span class="line-removed">140     case GlobalProperty:</span>
<span class="line-removed">141     case GlobalPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">142          // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.</span>
<span class="line-removed">143         if (scope-&gt;isGlobalLexicalEnvironment()) {</span>
<span class="line-removed">144             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);</span>
<span class="line-removed">145             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;</span>
<span class="line-removed">146             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">147             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());</span>
<span class="line-removed">148             ASSERT(!entry.isNull());</span>
<span class="line-removed">149             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">150             metadata.m_watchpointSet = entry.watchpointSet();</span>
<span class="line-removed">151             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());</span>
<span class="line-removed">152             return;</span>
<span class="line-removed">153         }</span>
<span class="line-removed">154         break;</span>
<span class="line-removed">155     }</span>
<span class="line-removed">156     default:</span>
<span class="line-removed">157         return;</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {</span>
<span class="line-removed">161         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">162         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-removed">163         ASSERT(globalObject == scope || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());</span>
<span class="line-removed">164         if (!slot.isCacheablePut()</span>
<span class="line-removed">165             || slot.base() != scope</span>
<span class="line-removed">166             || scope != globalObject</span>
<span class="line-removed">167             || !scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable())</span>
<span class="line-removed">168             return;</span>
<span class="line-removed">169 </span>
<span class="line-removed">170         if (slot.type() == PutPropertySlot::NewProperty) {</span>
<span class="line-removed">171             // Don&#39;t cache if we&#39;ve done a transition. We want to detect the first replace so that we</span>
<span class="line-removed">172             // can invalidate the watchpoint.</span>
<span class="line-removed">173             return;</span>
<span class="line-removed">174         }</span>
<span class="line-removed">175 </span>
<span class="line-removed">176         scope-&gt;structure(vm)-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
<span class="line-removed">177 </span>
<span class="line-removed">178         ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">179         metadata.m_structure.set(vm, codeBlock, scope-&gt;structure(vm));</span>
<span class="line-removed">180         metadata.m_operand = slot.cachedOffset();</span>
<span class="line-removed">181     }</span>
<span class="line-removed">182 }</span>
<span class="line-removed">183 </span>
<span class="line-removed">184 inline void tryCacheGetFromScopeGlobal(</span>
<span class="line-removed">185     ExecState* exec, VM&amp; vm, OpGetFromScope&amp; bytecode, JSObject* scope, PropertySlot&amp; slot, const Identifier&amp; ident)</span>
<span class="line-removed">186 {</span>
<span class="line-removed">187     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">188     ResolveType resolveType = metadata.m_getPutInfo.resolveType();</span>
<span class="line-removed">189 </span>
<span class="line-removed">190     switch (resolveType) {</span>
<span class="line-removed">191     case UnresolvedProperty:</span>
<span class="line-removed">192     case UnresolvedPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">193         if (scope-&gt;isGlobalObject()) {</span>
<span class="line-removed">194             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;</span>
<span class="line-removed">195             resolveType = newResolveType; // Allow below caching mechanism to kick in.</span>
<span class="line-removed">196             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
<span class="line-removed">197             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">198             break;</span>
<span class="line-removed">199         }</span>
<span class="line-removed">200         FALLTHROUGH;</span>
<span class="line-removed">201     }</span>
<span class="line-removed">202     case GlobalProperty:</span>
<span class="line-removed">203     case GlobalPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">204          // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.</span>
<span class="line-removed">205         if (scope-&gt;isGlobalLexicalEnvironment()) {</span>
<span class="line-removed">206             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);</span>
<span class="line-removed">207             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;</span>
<span class="line-removed">208             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());</span>
<span class="line-removed">209             ASSERT(!entry.isNull());</span>
<span class="line-removed">210             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
<span class="line-removed">211             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">212             metadata.m_watchpointSet = entry.watchpointSet();</span>
<span class="line-removed">213             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());</span>
<span class="line-removed">214             return;</span>
<span class="line-removed">215         }</span>
<span class="line-removed">216         break;</span>
<span class="line-removed">217     }</span>
<span class="line-removed">218     default:</span>
<span class="line-removed">219         return;</span>
<span class="line-removed">220     }</span>
<span class="line-removed">221 </span>
<span class="line-removed">222     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.</span>
<span class="line-removed">223     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {</span>
<span class="line-removed">224         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">225         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-removed">226         ASSERT(scope == globalObject || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());</span>
<span class="line-removed">227         if (slot.isCacheableValue() &amp;&amp; slot.slotBase() == scope &amp;&amp; scope == globalObject &amp;&amp; scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable()) {</span>
<span class="line-removed">228             Structure* structure = scope-&gt;structure(vm);</span>
<span class="line-removed">229             {</span>
<span class="line-removed">230                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">231                 metadata.m_structure.set(vm, codeBlock, structure);</span>
<span class="line-removed">232                 metadata.m_operand = slot.cachedOffset();</span>
<span class="line-removed">233             }</span>
<span class="line-removed">234             structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());</span>
<span class="line-removed">235         }</span>
<span class="line-removed">236     }</span>
237 }
238 
239 inline bool canAccessArgumentIndexQuickly(JSObject&amp; object, uint32_t index)
240 {
241     switch (object.type()) {
242     case DirectArgumentsType: {
243         DirectArguments* directArguments = jsCast&lt;DirectArguments*&gt;(&amp;object);
244         if (directArguments-&gt;isMappedArgumentInDFG(index))
245             return true;
246         break;
247     }
248     case ScopedArgumentsType: {
249         ScopedArguments* scopedArguments = jsCast&lt;ScopedArguments*&gt;(&amp;object);
250         if (scopedArguments-&gt;isMappedArgumentInDFG(index))
251             return true;
252         break;
253     }
254     default:
255         break;
256     }
257     return false;
258 }
259 
<a name="13" id="anc13"></a><span class="line-modified">260 static ALWAYS_INLINE void putDirectWithReify(VM&amp; vm, ExecState* exec, JSObject* baseObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, Structure** result = nullptr)</span>
261 {
262     auto scope = DECLARE_THROW_SCOPE(vm);
263     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<a name="14" id="anc14"></a><span class="line-modified">264         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
265         RETURN_IF_EXCEPTION(scope, void());
266     }
267     if (result)
268         *result = baseObject-&gt;structure(vm);
269     scope.release();
270     baseObject-&gt;putDirect(vm, propertyName, value, slot);
271 }
272 
<a name="15" id="anc15"></a><span class="line-modified">273 static ALWAYS_INLINE void putDirectAccessorWithReify(VM&amp; vm, ExecState* exec, JSObject* baseObject, PropertyName propertyName, GetterSetter* accessor, unsigned attribute)</span>
274 {
275     auto scope = DECLARE_THROW_SCOPE(vm);
276     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<a name="16" id="anc16"></a><span class="line-modified">277         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
278         RETURN_IF_EXCEPTION(scope, void());
279     }
280     scope.release();
<a name="17" id="anc17"></a><span class="line-modified">281     baseObject-&gt;putDirectAccessor(exec, propertyName, accessor, attribute);</span>
282 }
283 
284 inline JSArray* allocateNewArrayBuffer(VM&amp; vm, Structure* structure, JSImmutableButterfly* immutableButterfly)
285 {
286     JSGlobalObject* globalObject = structure-&gt;globalObject();
287     Structure* originalStructure = globalObject-&gt;originalArrayStructureForIndexingType(immutableButterfly-&gt;indexingMode());
288     ASSERT(originalStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode());
289     ASSERT(isCopyOnWrite(immutableButterfly-&gt;indexingMode()));
290     ASSERT(!structure-&gt;outOfLineCapacity());
291 
292     JSArray* result = JSArray::createWithButterfly(vm, nullptr, originalStructure, immutableButterfly-&gt;toButterfly());
293     // FIXME: This works but it&#39;s slow. If we cared enough about the perf when having a bad time then we could fix it.
294     if (UNLIKELY(originalStructure != structure)) {
295         ASSERT(hasSlowPutArrayStorage(structure-&gt;indexingMode()));
296         ASSERT(globalObject-&gt;isHavingABadTime());
297 
298         result-&gt;switchToSlowPutArrayStorage(vm);
299         ASSERT(result-&gt;butterfly() != immutableButterfly-&gt;toButterfly());
300         ASSERT(!result-&gt;butterfly()-&gt;arrayStorage()-&gt;m_sparseMap.get());
301         ASSERT(result-&gt;structureID() == structure-&gt;id());
302     }
303 
304     return result;
305 }
306 
307 } // namespace CommonSlowPaths
308 
<a name="18" id="anc18"></a><span class="line-modified">309 class ExecState;</span>
310 struct Instruction;
311 
312 #define SLOW_PATH
313 
314 #define SLOW_PATH_DECL(name) \
<a name="19" id="anc19"></a><span class="line-modified">315 extern &quot;C&quot; SlowPathReturnType SLOW_PATH name(ExecState* exec, const Instruction* pc)</span>
316 
317 #define SLOW_PATH_HIDDEN_DECL(name) \
318 SLOW_PATH_DECL(name) WTF_INTERNAL
319 
320 SLOW_PATH_HIDDEN_DECL(slow_path_call_arityCheck);
321 SLOW_PATH_HIDDEN_DECL(slow_path_construct_arityCheck);
322 SLOW_PATH_HIDDEN_DECL(slow_path_create_direct_arguments);
323 SLOW_PATH_HIDDEN_DECL(slow_path_create_scoped_arguments);
324 SLOW_PATH_HIDDEN_DECL(slow_path_create_cloned_arguments);
<a name="20" id="anc20"></a>
325 SLOW_PATH_HIDDEN_DECL(slow_path_create_this);
<a name="21" id="anc21"></a>
326 SLOW_PATH_HIDDEN_DECL(slow_path_get_callee);
327 SLOW_PATH_HIDDEN_DECL(slow_path_to_this);
328 SLOW_PATH_HIDDEN_DECL(slow_path_throw_tdz_error);
329 SLOW_PATH_HIDDEN_DECL(slow_path_check_tdz);
330 SLOW_PATH_HIDDEN_DECL(slow_path_throw_strict_mode_readonly_property_write_error);
331 SLOW_PATH_HIDDEN_DECL(slow_path_not);
332 SLOW_PATH_HIDDEN_DECL(slow_path_eq);
333 SLOW_PATH_HIDDEN_DECL(slow_path_neq);
334 SLOW_PATH_HIDDEN_DECL(slow_path_stricteq);
335 SLOW_PATH_HIDDEN_DECL(slow_path_nstricteq);
336 SLOW_PATH_HIDDEN_DECL(slow_path_less);
337 SLOW_PATH_HIDDEN_DECL(slow_path_lesseq);
338 SLOW_PATH_HIDDEN_DECL(slow_path_greater);
339 SLOW_PATH_HIDDEN_DECL(slow_path_greatereq);
340 SLOW_PATH_HIDDEN_DECL(slow_path_inc);
341 SLOW_PATH_HIDDEN_DECL(slow_path_dec);
342 SLOW_PATH_HIDDEN_DECL(slow_path_to_number);
<a name="22" id="anc22"></a>
343 SLOW_PATH_HIDDEN_DECL(slow_path_to_string);
344 SLOW_PATH_HIDDEN_DECL(slow_path_to_object);
345 SLOW_PATH_HIDDEN_DECL(slow_path_negate);
346 SLOW_PATH_HIDDEN_DECL(slow_path_add);
347 SLOW_PATH_HIDDEN_DECL(slow_path_mul);
348 SLOW_PATH_HIDDEN_DECL(slow_path_sub);
349 SLOW_PATH_HIDDEN_DECL(slow_path_div);
350 SLOW_PATH_HIDDEN_DECL(slow_path_mod);
351 SLOW_PATH_HIDDEN_DECL(slow_path_pow);
352 SLOW_PATH_HIDDEN_DECL(slow_path_lshift);
353 SLOW_PATH_HIDDEN_DECL(slow_path_rshift);
354 SLOW_PATH_HIDDEN_DECL(slow_path_urshift);
355 SLOW_PATH_HIDDEN_DECL(slow_path_unsigned);
356 SLOW_PATH_HIDDEN_DECL(slow_path_bitnot);
357 SLOW_PATH_HIDDEN_DECL(slow_path_bitand);
358 SLOW_PATH_HIDDEN_DECL(slow_path_bitor);
359 SLOW_PATH_HIDDEN_DECL(slow_path_bitxor);
360 SLOW_PATH_HIDDEN_DECL(slow_path_typeof);
361 SLOW_PATH_HIDDEN_DECL(slow_path_is_object);
362 SLOW_PATH_HIDDEN_DECL(slow_path_is_object_or_null);
363 SLOW_PATH_HIDDEN_DECL(slow_path_is_function);
364 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_id);
365 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_val);
366 SLOW_PATH_HIDDEN_DECL(slow_path_del_by_val);
367 SLOW_PATH_HIDDEN_DECL(slow_path_strcat);
368 SLOW_PATH_HIDDEN_DECL(slow_path_to_primitive);
<a name="23" id="anc23"></a>
369 SLOW_PATH_HIDDEN_DECL(slow_path_get_enumerable_length);
370 SLOW_PATH_HIDDEN_DECL(slow_path_has_generic_property);
371 SLOW_PATH_HIDDEN_DECL(slow_path_has_structure_property);
372 SLOW_PATH_HIDDEN_DECL(slow_path_has_indexed_property);
373 SLOW_PATH_HIDDEN_DECL(slow_path_get_direct_pname);
374 SLOW_PATH_HIDDEN_DECL(slow_path_get_property_enumerator);
375 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_structure_pname);
376 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_generic_pname);
377 SLOW_PATH_HIDDEN_DECL(slow_path_to_index_string);
378 SLOW_PATH_HIDDEN_DECL(slow_path_profile_type_clear_log);
379 SLOW_PATH_HIDDEN_DECL(slow_path_unreachable);
380 SLOW_PATH_HIDDEN_DECL(slow_path_create_lexical_environment);
381 SLOW_PATH_HIDDEN_DECL(slow_path_push_with_scope);
382 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope);
383 SLOW_PATH_HIDDEN_DECL(slow_path_is_var_scope);
384 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval);
<a name="24" id="anc24"></a>


385 SLOW_PATH_HIDDEN_DECL(slow_path_create_rest);
386 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_id_with_this);
387 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_val_with_this);
388 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_id_with_this);
389 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_val_with_this);
390 SLOW_PATH_HIDDEN_DECL(slow_path_define_data_property);
391 SLOW_PATH_HIDDEN_DECL(slow_path_define_accessor_property);
392 SLOW_PATH_HIDDEN_DECL(slow_path_throw_static_error);
<a name="25" id="anc25"></a>

393 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_with_spread);
394 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_buffer);
395 SLOW_PATH_HIDDEN_DECL(slow_path_spread);
396 
<a name="26" id="anc26"></a><span class="line-modified">397 using SlowPathFunction = SlowPathReturnType(SLOW_PATH *)(ExecState*, const Instruction*);</span>
398 
399 } // namespace JSC
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
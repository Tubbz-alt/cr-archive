diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.h
@@ -70,13 +70,14 @@
 
 bool isValidReasonPhrase(const String&);
 bool isValidHTTPHeaderValue(const String&);
 bool isValidAcceptHeaderValue(const String&);
 bool isValidLanguageHeaderValue(const String&);
+#if USE(GLIB)
 WEBCORE_EXPORT bool isValidUserAgentHeaderValue(const String&);
+#endif
 bool isValidHTTPToken(const String&);
-bool parseHTTPRefresh(const String& refresh, double& delay, String& url);
 Optional<WallTime> parseHTTPDate(const String&);
 String filenameFromHTTPContentDisposition(const String&);
 String extractMIMETypeFromMediaType(const String&);
 String extractCharsetFromMediaType(const String&);
 void findCharsetInMediaType(const String& mediaType, unsigned int& charsetPos, unsigned int& charsetLen, unsigned int start = 0);
@@ -95,18 +96,21 @@
 size_t parseHTTPHeader(const char* data, size_t length, String& failureReason, StringView& nameStr, String& valueStr, bool strict = true);
 size_t parseHTTPRequestBody(const char* data, size_t length, Vector<unsigned char>& body);
 
 // HTTP Header routine as per https://fetch.spec.whatwg.org/#terminology-headers
 bool isForbiddenHeaderName(const String&);
+bool isNoCORSSafelistedRequestHeaderName(const String&);
+bool isPriviledgedNoCORSRequestHeaderName(const String&);
 bool isForbiddenResponseHeaderName(const String&);
 bool isForbiddenMethod(const String&);
 bool isSimpleHeader(const String& name, const String& value);
 bool isCrossOriginSafeHeader(HTTPHeaderName, const HTTPHeaderSet&);
 bool isCrossOriginSafeHeader(const String&, const HTTPHeaderSet&);
 bool isCrossOriginSafeRequestHeader(HTTPHeaderName, const String&);
 
 String normalizeHTTPMethod(const String&);
+bool isSafeMethod(const String&);
 
 WEBCORE_EXPORT CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView);
 
 inline bool isHTTPSpace(UChar character)
 {
@@ -123,43 +127,52 @@
 {
     return string.stripLeadingAndTrailingMatchedCharacters(isHTTPSpace);
 }
 
 template<class HashType>
-void addToAccessControlAllowList(const String& string, unsigned start, unsigned end, HashSet<String, HashType>& set)
+bool addToAccessControlAllowList(const String& string, unsigned start, unsigned end, HashSet<String, HashType>& set)
 {
     StringImpl* stringImpl = string.impl();
     if (!stringImpl)
-        return;
+        return true;
 
     // Skip white space from start.
-    while (start <= end && isSpaceOrNewline((*stringImpl)[start]))
+    while (start <= end && isHTTPSpace((*stringImpl)[start]))
         ++start;
 
     // only white space
     if (start > end)
-        return;
+        return true;
 
     // Skip white space from end.
-    while (end && isSpaceOrNewline((*stringImpl)[end]))
+    while (end && isHTTPSpace((*stringImpl)[end]))
         --end;
 
-    set.add(string.substring(start, end - start + 1));
+    auto token = string.substring(start, end - start + 1);
+    if (!isValidHTTPToken(token))
+        return false;
+
+    set.add(WTFMove(token));
+    return true;
 }
 
 template<class HashType = DefaultHash<String>::Hash>
 HashSet<String, HashType> parseAccessControlAllowList(const String& string)
 {
     HashSet<String, HashType> set;
     unsigned start = 0;
     size_t end;
     while ((end = string.find(',', start)) != notFound) {
-        if (start != end)
-            addToAccessControlAllowList(string, start, end - 1, set);
+        if (start != end) {
+            if (!addToAccessControlAllowList(string, start, end - 1, set))
+                return { };
+        }
         start = end + 1;
     }
-    if (start != string.length())
-        addToAccessControlAllowList(string, start, string.length() - 1, set);
+    if (start != string.length()) {
+        if (!addToAccessControlAllowList(string, start, string.length() - 1, set))
+            return { };
+    }
     return set;
 }
 
 }

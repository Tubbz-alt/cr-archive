<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLFrameElementBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Simon Hausmann (hausmann@kde.org)
  5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;HTMLFrameElementBase.h&quot;
 26 
 27 #include &quot;Document.h&quot;
 28 #include &quot;FocusController.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;FrameLoader.h&quot;
 31 #include &quot;FrameView.h&quot;
 32 #include &quot;HTMLNames.h&quot;
 33 #include &quot;HTMLParserIdioms.h&quot;
 34 #include &quot;JSDOMBindingSecurity.h&quot;
 35 #include &quot;Page.h&quot;
 36 #include &quot;RenderWidget.h&quot;
 37 #include &quot;ScriptController.h&quot;
 38 #include &quot;Settings.h&quot;
 39 #include &quot;SubframeLoader.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 #include &lt;wtf/URL.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLFrameElementBase);
 46 
 47 using namespace HTMLNames;
 48 
 49 HTMLFrameElementBase::HTMLFrameElementBase(const QualifiedName&amp; tagName, Document&amp; document)
 50     : HTMLFrameOwnerElement(tagName, document)
 51 {
 52     setHasCustomStyleResolveCallbacks();
 53 }
 54 
 55 bool HTMLFrameElementBase::canLoadScriptURL(const URL&amp; scriptURL) const
 56 {
 57     return canLoadURL(scriptURL);
 58 }
 59 
 60 bool HTMLFrameElementBase::canLoad() const
 61 {
 62     // FIXME: Why is it valuable to return true when m_URL is empty?
 63     // FIXME: After openURL replaces an empty URL with the blank URL, this may no longer necessarily return true.
 64     return m_URL.isEmpty() || canLoadURL(m_URL);
 65 }
 66 
 67 bool HTMLFrameElementBase::canLoadURL(const String&amp; relativeURL) const
 68 {
 69     return canLoadURL(document().completeURL(relativeURL));
 70 }
 71 
 72 // Note that unlike HTMLPlugInImageElement::canLoadURL this uses ScriptController::canAccessFromCurrentOrigin.
 73 bool HTMLFrameElementBase::canLoadURL(const URL&amp; completeURL) const
 74 {
 75     if (WTF::protocolIsJavaScript(completeURL)) {
 76         RefPtr&lt;Document&gt; contentDocument = this-&gt;contentDocument();
 77         if (contentDocument &amp;&amp; !ScriptController::canAccessFromCurrentOrigin(contentDocument-&gt;frame(), document()))
 78             return false;
 79     }
 80 
 81     return !isProhibitedSelfReference(completeURL);
 82 }
 83 
 84 void HTMLFrameElementBase::openURL(LockHistory lockHistory, LockBackForwardList lockBackForwardList)
 85 {
 86     if (!canLoad())
 87         return;
 88 
 89     if (m_URL.isEmpty())
 90         m_URL = WTF::blankURL().string();
 91 
 92     RefPtr&lt;Frame&gt; parentFrame = document().frame();
 93     if (!parentFrame)
 94         return;
 95 
 96     document().willLoadFrameElement(parentFrame-&gt;document()-&gt;completeURL(m_URL));
 97 
 98     String frameName = getNameAttribute();
 99     if (frameName.isNull() &amp;&amp; UNLIKELY(document().settings().needsFrameNameFallbackToIdQuirk()))
100         frameName = getIdAttribute();
101 
102     parentFrame-&gt;loader().subframeLoader().requestFrame(*this, m_URL, frameName, lockHistory, lockBackForwardList);
103 }
104 
105 void HTMLFrameElementBase::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
106 {
107     if (name == srcdocAttr) {
108         if (value.isNull()) {
109             const AtomString&amp; srcValue = attributeWithoutSynchronization(srcAttr);
110             if (!srcValue.isNull())
111                 setLocation(stripLeadingAndTrailingHTMLSpaces(srcValue));
112         } else
113             setLocation(&quot;about:srcdoc&quot;);
114     } else if (name == srcAttr &amp;&amp; !hasAttributeWithoutSynchronization(srcdocAttr))
115         setLocation(stripLeadingAndTrailingHTMLSpaces(value));
116     else
117         HTMLFrameOwnerElement::parseAttribute(name, value);
118 }
119 
120 Node::InsertedIntoAncestorResult HTMLFrameElementBase::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
121 {
122     HTMLFrameOwnerElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
123     if (insertionType.connectedToDocument)
124         return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
125     return InsertedIntoAncestorResult::Done;
126 }
127 
128 void HTMLFrameElementBase::didFinishInsertingNode()
129 {
130     if (!isConnected())
131         return;
132 
133     // DocumentFragments don&#39;t kick off any loads.
134     if (!document().frame())
135         return;
136 
137     if (!SubframeLoadingDisabler::canLoadFrame(*this))
138         return;
139 
140     if (!renderer())
141         invalidateStyleAndRenderersForSubtree();
142     openURL();
143 }
144 
145 void HTMLFrameElementBase::didAttachRenderers()
146 {
147     if (RenderWidget* part = renderWidget()) {
148         if (RefPtr&lt;Frame&gt; frame = contentFrame())
149             part-&gt;setWidget(frame-&gt;view());
150     }
151 }
152 
153 URL HTMLFrameElementBase::location() const
154 {
155     if (hasAttributeWithoutSynchronization(srcdocAttr))
156         return URL({ }, &quot;about:srcdoc&quot;);
157     return document().completeURL(attributeWithoutSynchronization(srcAttr));
158 }
159 
160 void HTMLFrameElementBase::setLocation(const String&amp; str)
161 {
162     if (document().settings().needsAcrobatFrameReloadingQuirk() &amp;&amp; m_URL == str)
163         return;
164 
165     m_URL = AtomString(str);
166 
167     if (isConnected())
168         openURL(LockHistory::No, LockBackForwardList::No);
169 }
170 
171 void HTMLFrameElementBase::setLocation(JSC::JSGlobalObject&amp; state, const String&amp; newLocation)
172 {
173     if (WTF::protocolIsJavaScript(stripLeadingAndTrailingHTMLSpaces(newLocation))) {
174         if (!BindingSecurity::shouldAllowAccessToNode(state, contentDocument()))
175             return;
176     }
177 
178     setLocation(newLocation);
179 }
180 
181 bool HTMLFrameElementBase::supportsFocus() const
182 {
183     return true;
184 }
185 
186 void HTMLFrameElementBase::setFocus(bool received)
187 {
188     HTMLFrameOwnerElement::setFocus(received);
189     if (Page* page = document().page()) {
190         if (received)
191             page-&gt;focusController().setFocusedFrame(contentFrame());
192         else if (page-&gt;focusController().focusedFrame() == contentFrame()) // Focus may have already been given to another frame, don&#39;t take it away.
193             page-&gt;focusController().setFocusedFrame(0);
194     }
195 }
196 
197 bool HTMLFrameElementBase::isURLAttribute(const Attribute&amp; attribute) const
198 {
199     return attribute.name() == srcAttr || attribute.name() == longdescAttr || HTMLFrameOwnerElement::isURLAttribute(attribute);
200 }
201 
202 bool HTMLFrameElementBase::isHTMLContentAttribute(const Attribute&amp; attribute) const
203 {
204     return attribute.name() == srcdocAttr || HTMLFrameOwnerElement::isHTMLContentAttribute(attribute);
205 }
206 
207 int HTMLFrameElementBase::width()
208 {
209     document().updateLayoutIgnorePendingStylesheets();
210     if (!renderBox())
211         return 0;
212     return renderBox()-&gt;width();
213 }
214 
215 int HTMLFrameElementBase::height()
216 {
217     document().updateLayoutIgnorePendingStylesheets();
218     if (!renderBox())
219         return 0;
220     return renderBox()-&gt;height();
221 }
222 
223 ScrollbarMode HTMLFrameElementBase::scrollingMode() const
224 {
225     return equalLettersIgnoringASCIICase(attributeWithoutSynchronization(scrollingAttr), &quot;no&quot;)
226         ? ScrollbarAlwaysOff : ScrollbarAuto;
227 }
228 
229 } // namespace WebCore
    </pre>
  </body>
</html>
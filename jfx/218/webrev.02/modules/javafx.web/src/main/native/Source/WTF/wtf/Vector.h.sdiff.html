<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Variant.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VectorTraits.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  *  Copyright (C) 2005-2017 Apple Inc. All rights reserved.</span>
   3  *
   4  *  This library is free software; you can redistribute it and/or
   5  *  modify it under the terms of the GNU Library General Public
   6  *  License as published by the Free Software Foundation; either
   7  *  version 2 of the License, or (at your option) any later version.
   8  *
   9  *  This library is distributed in the hope that it will be useful,
  10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  *  Library General Public License for more details.
  13  *
  14  *  You should have received a copy of the GNU Library General Public License
  15  *  along with this library; see the file COPYING.LIB.  If not, write to
  16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  *  Boston, MA 02110-1301, USA.
  18  *
  19  */
  20 
  21 #pragma once
  22 
</pre>
<hr />
<pre>
  29 #include &lt;wtf/FastMalloc.h&gt;
  30 #include &lt;wtf/Forward.h&gt;
  31 #include &lt;wtf/MallocPtr.h&gt;
  32 #include &lt;wtf/MathExtras.h&gt;
  33 #include &lt;wtf/Noncopyable.h&gt;
  34 #include &lt;wtf/NotFound.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/ValueCheck.h&gt;
  37 #include &lt;wtf/VectorTraits.h&gt;
  38 
  39 #if ASAN_ENABLED
  40 extern &quot;C&quot; void __sanitizer_annotate_contiguous_container(const void* begin, const void* end, const void* old_mid, const void* new_mid);
  41 #endif
  42 
  43 namespace JSC {
  44 class LLIntOffsetsExtractor;
  45 }
  46 
  47 namespace WTF {
  48 


  49 template &lt;bool needsDestruction, typename T&gt;
  50 struct VectorDestructor;
  51 
  52 template&lt;typename T&gt;
  53 struct VectorDestructor&lt;false, T&gt;
  54 {
  55     static void destruct(T*, T*) {}
  56 };
  57 
  58 template&lt;typename T&gt;
  59 struct VectorDestructor&lt;true, T&gt;
  60 {
  61     static void destruct(T* begin, T* end)
  62     {
  63         for (T* cur = begin; cur != end; ++cur)
  64             cur-&gt;~T();
  65     }
  66 };
  67 
  68 template &lt;bool needsInitialization, bool canInitializeWithMemset, typename T&gt;
</pre>
<hr />
<pre>
 187 struct VectorFiller;
 188 
 189 template&lt;typename T&gt;
 190 struct VectorFiller&lt;false, T&gt;
 191 {
 192     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 193     {
 194         while (dst != dstEnd) {
 195             new (NotNull, dst) T(val);
 196             ++dst;
 197         }
 198     }
 199 };
 200 
 201 template&lt;typename T&gt;
 202 struct VectorFiller&lt;true, T&gt;
 203 {
 204     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 205     {
 206         static_assert(sizeof(T) == 1, &quot;Size of type T should be equal to one!&quot;);
<span class="line-modified"> 207 #if COMPILER(GCC_COMPATIBLE) &amp;&amp; defined(_FORTIFY_SOURCE)</span>
<span class="line-removed"> 208         if (!__builtin_constant_p(dstEnd - dst) || (!(dstEnd - dst)))</span>
<span class="line-removed"> 209 #endif</span>
<span class="line-removed"> 210             memset(dst, val, dstEnd - dst);</span>
 211     }
 212 };
 213 
 214 template&lt;bool canCompareWithMemcmp, typename T&gt;
 215 struct VectorComparer;
 216 
 217 template&lt;typename T&gt;
 218 struct VectorComparer&lt;false, T&gt;
 219 {
 220     static bool compare(const T* a, const T* b, size_t size)
 221     {
 222         for (size_t i = 0; i &lt; size; ++i)
 223             if (!(a[i] == b[i]))
 224                 return false;
 225         return true;
 226     }
 227 };
 228 
 229 template&lt;typename T&gt;
 230 struct VectorComparer&lt;true, T&gt;
</pre>
<hr />
<pre>
 262     {
 263         VectorMover&lt;VectorTraits&lt;T&gt;::canMoveWithMemcpy, T&gt;::moveOverlapping(src, srcEnd, dst);
 264     }
 265 
 266     static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
 267     {
 268         VectorCopier&lt;VectorTraits&lt;T&gt;::canCopyWithMemcpy, T&gt;::uninitializedCopy(src, srcEnd, dst);
 269     }
 270 
 271     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 272     {
 273         VectorFiller&lt;VectorTraits&lt;T&gt;::canFillWithMemset, T&gt;::uninitializedFill(dst, dstEnd, val);
 274     }
 275 
 276     static bool compare(const T* a, const T* b, size_t size)
 277     {
 278         return VectorComparer&lt;VectorTraits&lt;T&gt;::canCompareWithMemcmp, T&gt;::compare(a, b, size);
 279     }
 280 };
 281 
<span class="line-modified"> 282 template&lt;typename T&gt;</span>
 283 class VectorBufferBase {
 284     WTF_MAKE_NONCOPYABLE(VectorBufferBase);
 285 public:
 286     void allocateBuffer(size_t newCapacity)
 287     {
 288         ASSERT(newCapacity);
 289         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 290             CRASH();
 291         size_t sizeToAllocate = newCapacity * sizeof(T);
 292         m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified"> 293         m_buffer = static_cast&lt;T*&gt;(fastMalloc(sizeToAllocate));</span>
 294     }
 295 
 296     bool tryAllocateBuffer(size_t newCapacity)
 297     {
 298         ASSERT(newCapacity);
 299         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 300             return false;
 301 
 302         size_t sizeToAllocate = newCapacity * sizeof(T);
<span class="line-modified"> 303         T* newBuffer;</span>
<span class="line-modified"> 304         if (tryFastMalloc(sizeToAllocate).getValue(newBuffer)) {</span>
<span class="line-modified"> 305             m_capacity = sizeToAllocate / sizeof(T);</span>
<span class="line-modified"> 306             m_buffer = newBuffer;</span>
<span class="line-modified"> 307             return true;</span>
<span class="line-modified"> 308         }</span>
<span class="line-removed"> 309         return false;</span>
 310     }
 311 
 312     bool shouldReallocateBuffer(size_t newCapacity) const
 313     {
 314         return VectorTraits&lt;T&gt;::canMoveWithMemcpy &amp;&amp; m_capacity &amp;&amp; newCapacity;
 315     }
 316 
 317     void reallocateBuffer(size_t newCapacity)
 318     {
 319         ASSERT(shouldReallocateBuffer(newCapacity));
 320         if (newCapacity &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
 321             CRASH();
 322         size_t sizeToAllocate = newCapacity * sizeof(T);
 323         m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified"> 324         m_buffer = static_cast&lt;T*&gt;(fastRealloc(m_buffer, sizeToAllocate));</span>
 325     }
 326 
 327     void deallocateBuffer(T* bufferToDeallocate)
 328     {
 329         if (!bufferToDeallocate)
 330             return;
 331 
 332         if (m_buffer == bufferToDeallocate) {
 333             m_buffer = 0;
 334             m_capacity = 0;
 335         }
 336 
<span class="line-modified"> 337         fastFree(bufferToDeallocate);</span>
 338     }
 339 
 340     T* buffer() { return m_buffer; }
 341     const T* buffer() const { return m_buffer; }
 342     static ptrdiff_t bufferMemoryOffset() { return OBJECT_OFFSETOF(VectorBufferBase, m_buffer); }
 343     size_t capacity() const { return m_capacity; }
 344 
<span class="line-modified"> 345     MallocPtr&lt;T&gt; releaseBuffer()</span>
 346     {
 347         T* buffer = m_buffer;
 348         m_buffer = 0;
 349         m_capacity = 0;
<span class="line-modified"> 350         return adoptMallocPtr(buffer);</span>
 351     }
 352 
 353 protected:
 354     VectorBufferBase()
 355         : m_buffer(0)
 356         , m_capacity(0)
 357         , m_size(0)
 358     {
 359     }
 360 
 361     VectorBufferBase(T* buffer, size_t capacity, size_t size)
 362         : m_buffer(buffer)
 363         , m_capacity(capacity)
 364         , m_size(size)
 365     {
 366     }
 367 
 368     ~VectorBufferBase()
 369     {
 370         // FIXME: It would be nice to find a way to ASSERT that m_buffer hasn&#39;t leaked here.
 371     }
 372 
 373     T* m_buffer;
 374     unsigned m_capacity;
 375     unsigned m_size; // Only used by the Vector subclass, but placed here to avoid padding the struct.
 376 };
 377 
<span class="line-modified"> 378 template&lt;typename T, size_t inlineCapacity&gt;</span>
<span class="line-removed"> 379 class VectorBuffer;</span>
 380 
<span class="line-modified"> 381 template&lt;typename T&gt;</span>
<span class="line-modified"> 382 class VectorBuffer&lt;T, 0&gt; : private VectorBufferBase&lt;T&gt; {</span>
 383 private:
<span class="line-modified"> 384     typedef VectorBufferBase&lt;T&gt; Base;</span>
 385 public:
 386     VectorBuffer()
 387     {
 388     }
 389 
 390     VectorBuffer(size_t capacity, size_t size = 0)
 391     {
 392         m_size = size;
 393         // Calling malloc(0) might take a lock and may actually do an
 394         // allocation on some systems.
 395         if (capacity)
 396             allocateBuffer(capacity);
 397     }
 398 
 399     ~VectorBuffer()
 400     {
 401         deallocateBuffer(buffer());
 402     }
 403 
<span class="line-modified"> 404     void swap(VectorBuffer&lt;T, 0&gt;&amp; other, size_t, size_t)</span>
 405     {
 406         std::swap(m_buffer, other.m_buffer);
 407         std::swap(m_capacity, other.m_capacity);
 408     }
 409 
 410     void restoreInlineBufferIfNeeded() { }
 411 
 412 #if ASAN_ENABLED
 413     void* endOfBuffer()
 414     {
 415         return buffer() + capacity();
 416     }
 417 #endif
 418 
 419     using Base::allocateBuffer;
 420     using Base::tryAllocateBuffer;
 421     using Base::shouldReallocateBuffer;
 422     using Base::reallocateBuffer;
 423     using Base::deallocateBuffer;
 424 
 425     using Base::buffer;
 426     using Base::capacity;
 427     using Base::bufferMemoryOffset;
 428 
 429     using Base::releaseBuffer;
 430 
 431 protected:
 432     using Base::m_size;
 433 
 434 private:
 435     friend class JSC::LLIntOffsetsExtractor;
 436     using Base::m_buffer;
 437     using Base::m_capacity;
 438 };
 439 
<span class="line-modified"> 440 template&lt;typename T, size_t inlineCapacity&gt;</span>
<span class="line-modified"> 441 class VectorBuffer : private VectorBufferBase&lt;T&gt; {</span>
 442     WTF_MAKE_NONCOPYABLE(VectorBuffer);
 443 private:
<span class="line-modified"> 444     typedef VectorBufferBase&lt;T&gt; Base;</span>
 445 public:
 446     VectorBuffer()
 447         : Base(inlineBuffer(), inlineCapacity, 0)
 448     {
 449     }
 450 
 451     VectorBuffer(size_t capacity, size_t size = 0)
 452         : Base(inlineBuffer(), inlineCapacity, size)
 453     {
 454         if (capacity &gt; inlineCapacity)
 455             Base::allocateBuffer(capacity);
 456     }
 457 
 458     ~VectorBuffer()
 459     {
 460         deallocateBuffer(buffer());
 461     }
 462 
 463     void allocateBuffer(size_t newCapacity)
 464     {
</pre>
<hr />
<pre>
 531 #if ASAN_ENABLED
 532     void* endOfBuffer()
 533     {
 534         ASSERT(buffer());
 535 
 536         IGNORE_GCC_WARNINGS_BEGIN(&quot;invalid-offsetof&quot;)
 537         static_assert((offsetof(VectorBuffer, m_inlineBuffer) + sizeof(m_inlineBuffer)) % 8 == 0, &quot;Inline buffer end needs to be on 8 byte boundary for ASan annotations to work.&quot;);
 538         IGNORE_GCC_WARNINGS_END
 539 
 540         if (buffer() == inlineBuffer())
 541             return reinterpret_cast&lt;char*&gt;(m_inlineBuffer) + sizeof(m_inlineBuffer);
 542 
 543         return buffer() + capacity();
 544     }
 545 #endif
 546 
 547     using Base::buffer;
 548     using Base::capacity;
 549     using Base::bufferMemoryOffset;
 550 
<span class="line-modified"> 551     MallocPtr&lt;T&gt; releaseBuffer()</span>
 552     {
 553         if (buffer() == inlineBuffer())
<span class="line-modified"> 554             return nullptr;</span>
 555         return Base::releaseBuffer();
 556     }
 557 
 558 protected:
 559     using Base::m_size;
 560 
 561 private:
 562     using Base::m_buffer;
 563     using Base::m_capacity;
 564 
 565     void swapInlineBuffer(VectorBuffer&amp; other, size_t mySize, size_t otherSize)
 566     {
 567         // FIXME: We could make swap part of VectorTypeOperations
 568         // https://bugs.webkit.org/show_bug.cgi?id=128863
 569         swapInlineBuffers(inlineBuffer(), other.inlineBuffer(), mySize, otherSize);
 570     }
 571 
 572     static void swapInlineBuffers(T* left, T* right, size_t leftSize, size_t rightSize)
 573     {
 574         if (left == right)
 575             return;
 576 
 577         ASSERT(leftSize &lt;= inlineCapacity);
 578         ASSERT(rightSize &lt;= inlineCapacity);
 579 
 580         size_t swapBound = std::min(leftSize, rightSize);
 581         for (unsigned i = 0; i &lt; swapBound; ++i)
 582             std::swap(left[i], right[i]);
 583         VectorTypeOperations&lt;T&gt;::move(left + swapBound, left + leftSize, right + swapBound);
 584         VectorTypeOperations&lt;T&gt;::move(right + swapBound, right + rightSize, left + swapBound);
 585     }
 586 
 587     T* inlineBuffer() { return reinterpret_cast_ptr&lt;T*&gt;(m_inlineBuffer); }
 588     const T* inlineBuffer() const { return reinterpret_cast_ptr&lt;const T*&gt;(m_inlineBuffer); }
 589 
 590 #if ASAN_ENABLED
 591     // ASan needs the buffer to begin and end on 8-byte boundaries for annotations to work.
 592     // FIXME: Add a redzone before the buffer to catch off by one accesses. We don&#39;t need a guard after, because the buffer is the last member variable.
<span class="line-modified"> 593     static const size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;</span>
<span class="line-modified"> 594     static const size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);</span>
 595     typename std::aligned_storage&lt;sizeof(T), asanInlineBufferAlignment&gt;::type m_inlineBuffer[asanAdjustedInlineCapacity];
 596 #else
 597     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_inlineBuffer[inlineCapacity];
 598 #endif
 599 };
 600 
 601 struct UnsafeVectorOverflow {
 602     static NO_RETURN_DUE_TO_ASSERT void overflowed()
 603     {
 604         ASSERT_NOT_REACHED();
 605     }
 606 };
 607 
 608 // Template default values are in Forward.h.
<span class="line-modified"> 609 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 610 class Vector : private VectorBuffer&lt;T, inlineCapacity&gt; {</span>
 611     WTF_MAKE_FAST_ALLOCATED;
 612 private:
<span class="line-modified"> 613     typedef VectorBuffer&lt;T, inlineCapacity&gt; Base;</span>
 614     typedef VectorTypeOperations&lt;T&gt; TypeOperations;
 615     friend class JSC::LLIntOffsetsExtractor;
 616 
 617 public:
 618     typedef T ValueType;
 619 
 620     typedef T* iterator;
 621     typedef const T* const_iterator;
 622     typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
 623     typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
 624 
 625     Vector()
 626     {
 627     }
 628 
 629     // Unlike in std::vector, this constructor does not initialize POD types.
 630     explicit Vector(size_t size)
 631         : Base(size, size)
 632     {
 633         asanSetInitialBufferSizeTo(size);
</pre>
<hr />
<pre>
 652         asanSetInitialBufferSizeTo(initializerList.size());
 653 
 654         for (const auto&amp; element : initializerList)
 655             uncheckedAppend(element);
 656     }
 657 
 658     template&lt;typename... Items&gt;
 659     static Vector from(Items&amp;&amp;... items)
 660     {
 661         Vector result;
 662         auto size = sizeof...(items);
 663 
 664         result.reserveInitialCapacity(size);
 665         result.asanSetInitialBufferSizeTo(size);
 666         result.m_size = size;
 667 
 668         result.uncheckedInitialize&lt;0&gt;(std::forward&lt;Items&gt;(items)...);
 669         return result;
 670     }
 671 





 672     ~Vector()
 673     {
 674         if (m_size)
 675             TypeOperations::destruct(begin(), end());
 676 
 677         asanSetBufferSizeToFullCapacity(0);
 678     }
 679 
 680     Vector(const Vector&amp;);
<span class="line-modified"> 681     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified"> 682     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);</span>
 683 
 684     Vector&amp; operator=(const Vector&amp;);
<span class="line-modified"> 685     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified"> 686     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);</span>
 687 
 688     Vector(Vector&amp;&amp;);
 689     Vector&amp; operator=(Vector&amp;&amp;);
 690 
 691     size_t size() const { return m_size; }
 692     static ptrdiff_t sizeMemoryOffset() { return OBJECT_OFFSETOF(Vector, m_size); }
 693     size_t capacity() const { return Base::capacity(); }
 694     bool isEmpty() const { return !size(); }
 695 
 696     T&amp; at(size_t i)
 697     {
 698         if (UNLIKELY(i &gt;= size()))
 699             OverflowHandler::overflowed();
 700         return Base::buffer()[i];
 701     }
 702     const T&amp; at(size_t i) const
 703     {
 704         if (UNLIKELY(i &gt;= size()))
 705             OverflowHandler::overflowed();
 706         return Base::buffer()[i];
</pre>
<hr />
<pre>
 762     bool tryReserveCapacity(size_t newCapacity);
 763     void reserveInitialCapacity(size_t initialCapacity);
 764     void shrinkCapacity(size_t newCapacity);
 765     void shrinkToFit() { shrinkCapacity(size()); }
 766 
 767     void clear() { shrinkCapacity(0); }
 768 
 769     template&lt;typename U = T&gt; Vector&lt;U&gt; isolatedCopy() const;
 770 
 771     ALWAYS_INLINE void append(ValueType&amp;&amp; value) { append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 772     template&lt;typename U&gt; void append(U&amp;&amp;);
 773     template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);
 774     template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);
 775 
 776     void uncheckedAppend(ValueType&amp;&amp; value) { uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 777     template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);
 778     template&lt;typename... Args&gt; void uncheckedConstructAndAppend(Args&amp;&amp;...);
 779 
 780     template&lt;typename U&gt; void append(const U*, size_t);
 781     template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);

 782     template&lt;typename U&gt; bool tryAppend(const U*, size_t);
 783 
 784     template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
 785     template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
<span class="line-modified"> 786     template&lt;typename U, size_t c, typename OH&gt; void insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp;);</span>
 787 
 788     void remove(size_t position);
 789     void remove(size_t position, size_t length);
 790     template&lt;typename U&gt; bool removeFirst(const U&amp;);
 791     template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);
 792     template&lt;typename U&gt; unsigned removeAll(const U&amp;);
 793     template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);
 794 
 795     void removeLast()
 796     {
 797         if (UNLIKELY(isEmpty()))
 798             OverflowHandler::overflowed();
 799         shrink(size() - 1);
 800     }
 801 
 802     void fill(const T&amp;, size_t);
 803     void fill(const T&amp; val) { fill(val, size()); }
 804 
 805     template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);
 806 
<span class="line-modified"> 807     MallocPtr&lt;T&gt; releaseBuffer();</span>
 808 
<span class="line-modified"> 809     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span>
 810     {
 811 #if ASAN_ENABLED
 812         if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.
 813             return;
 814 #endif
 815 
 816         // Make it possible to copy inline buffers.
 817         asanSetBufferSizeToFullCapacity();
 818         other.asanSetBufferSizeToFullCapacity();
 819 
 820         Base::swap(other, m_size, other.m_size);
 821         std::swap(m_size, other.m_size);
 822 
 823         asanSetInitialBufferSizeTo(m_size);
 824         other.asanSetInitialBufferSizeTo(other.m_size);
 825     }
 826 
 827     void reverse();
 828 
 829     void checkConsistency();
 830 
 831     template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;
 832 


 833 private:
 834     void expandCapacity(size_t newMinCapacity);
 835     T* expandCapacity(size_t newMinCapacity, T*);
 836     bool tryExpandCapacity(size_t newMinCapacity);
 837     const T* tryExpandCapacity(size_t newMinCapacity, const T*);
 838     template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*);
 839     template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);
 840     template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);
 841     template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);
 842 
 843     template&lt;size_t position, typename U, typename... Items&gt;
 844     void uncheckedInitialize(U&amp;&amp; item, Items&amp;&amp;... items)
 845     {
 846         uncheckedInitialize&lt;position&gt;(std::forward&lt;U&gt;(item));
 847         uncheckedInitialize&lt;position + 1&gt;(std::forward&lt;Items&gt;(items)...);
 848     }
 849     template&lt;size_t position, typename U&gt;
 850     void uncheckedInitialize(U&amp;&amp; value)
 851     {
 852         ASSERT(position &lt; size());
</pre>
<hr />
<pre>
 859     void asanSetBufferSizeToFullCapacity() { asanSetBufferSizeToFullCapacity(size()); }
 860 
 861     void asanBufferSizeWillChangeTo(size_t);
 862 
 863     using Base::m_size;
 864     using Base::buffer;
 865     using Base::capacity;
 866     using Base::swap;
 867     using Base::allocateBuffer;
 868     using Base::deallocateBuffer;
 869     using Base::tryAllocateBuffer;
 870     using Base::shouldReallocateBuffer;
 871     using Base::reallocateBuffer;
 872     using Base::restoreInlineBufferIfNeeded;
 873     using Base::releaseBuffer;
 874 #if ASAN_ENABLED
 875     using Base::endOfBuffer;
 876 #endif
 877 };
 878 
<span class="line-modified"> 879 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 880 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&amp; other)</span>
 881     : Base(other.capacity(), other.size())
 882 {
 883     asanSetInitialBufferSizeTo(other.size());
 884 
 885     if (begin())
 886         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 887 }
 888 
<span class="line-modified"> 889 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 890 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified"> 891 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)</span>
 892     : Base(other.capacity(), other.size())
 893 {
 894     asanSetInitialBufferSizeTo(other.size());
 895 
 896     if (begin())
 897         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 898 }
 899 
<span class="line-modified"> 900 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 901 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span>
 902 {
 903     if (&amp;other == this)
 904         return *this;
 905 
 906     if (size() &gt; other.size())
 907         shrink(other.size());
 908     else if (other.size() &gt; capacity()) {
 909         clear();
 910         reserveCapacity(other.size());
 911         ASSERT(begin());
 912     }
 913 
 914     asanBufferSizeWillChangeTo(other.size());
 915 
 916     std::copy(other.begin(), other.begin() + size(), begin());
 917     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 918     m_size = other.size();
 919 
 920     return *this;
 921 }
 922 
 923 inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }
 924 
<span class="line-modified"> 925 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 926 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified"> 927 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)</span>
 928 {
 929     // If the inline capacities match, we should call the more specific
 930     // template.  If the inline capacities don&#39;t match, the two objects
 931     // shouldn&#39;t be allocated the same address.
 932     ASSERT(!typelessPointersAreEqual(&amp;other, this));
 933 
 934     if (size() &gt; other.size())
 935         shrink(other.size());
 936     else if (other.size() &gt; capacity()) {
 937         clear();
 938         reserveCapacity(other.size());
 939         ASSERT(begin());
 940     }
 941 
 942     asanBufferSizeWillChangeTo(other.size());
 943 
 944     std::copy(other.begin(), other.begin() + size(), begin());
 945     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 946     m_size = other.size();
 947 
 948     return *this;
 949 }
 950 
<span class="line-modified"> 951 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 952 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)</span>
 953 {
 954     swap(other);
 955 }
 956 
<span class="line-modified"> 957 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified"> 958 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)</span>
 959 {
 960     swap(other);
 961     return *this;
 962 }
 963 
<span class="line-modified"> 964 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
 965 template&lt;typename U&gt;
<span class="line-modified"> 966 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::contains(const U&amp; value) const</span>
 967 {
 968     return find(value) != notFound;
 969 }
 970 
<span class="line-modified"> 971 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
 972 template&lt;typename MatchFunction&gt;
<span class="line-modified"> 973 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::findMatching(const MatchFunction&amp; matches) const</span>
 974 {
 975     for (size_t i = 0; i &lt; size(); ++i) {
 976         if (matches(at(i)))
 977             return i;
 978     }
 979     return notFound;
 980 }
 981 
<span class="line-modified"> 982 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
 983 template&lt;typename U&gt;
<span class="line-modified"> 984 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::find(const U&amp; value) const</span>
 985 {
 986     return findMatching([&amp;](auto&amp; item) {
 987         return item == value;
 988     });
 989 }
 990 
<span class="line-modified"> 991 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
 992 template&lt;typename U&gt;
<span class="line-modified"> 993 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverseFind(const U&amp; value) const</span>
 994 {
 995     for (size_t i = 1; i &lt;= size(); ++i) {
 996         const size_t index = size() - i;
 997         if (at(index) == value)
 998             return index;
 999     }
1000     return notFound;
1001 }
1002 
<span class="line-modified">1003 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1004 template&lt;typename U&gt;
<span class="line-modified">1005 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendIfNotContains(const U&amp; value)</span>
1006 {
1007     if (contains(value))
1008         return false;
1009     append(value);
1010     return true;
1011 }
1012 
<span class="line-modified">1013 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1014 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::fill(const T&amp; val, size_t newSize)</span>
1015 {
1016     if (size() &gt; newSize)
1017         shrink(newSize);
1018     else if (newSize &gt; capacity()) {
1019         clear();
1020         reserveCapacity(newSize);
1021         ASSERT(begin());
1022     }
1023 
1024     asanBufferSizeWillChangeTo(newSize);
1025 
1026     std::fill(begin(), end(), val);
1027     TypeOperations::uninitializedFill(end(), begin() + newSize, val);
1028     m_size = newSize;
1029 }
1030 
<span class="line-modified">1031 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1032 template&lt;typename Iterator&gt;
<span class="line-modified">1033 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendRange(Iterator start, Iterator end)</span>
1034 {
1035     for (Iterator it = start; it != end; ++it)
1036         append(*it);
1037 }
1038 
<span class="line-modified">1039 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1040 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity)</span>
1041 {
1042     reserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1043 }
1044 
<span class="line-modified">1045 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1046 NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, T* ptr)</span>
1047 {
1048     if (ptr &lt; begin() || ptr &gt;= end()) {
1049         expandCapacity(newMinCapacity);
1050         return ptr;
1051     }
1052     size_t index = ptr - begin();
1053     expandCapacity(newMinCapacity);
1054     return begin() + index;
1055 }
1056 
<span class="line-modified">1057 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1058 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity)</span>
1059 {
1060     return tryReserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1061 }
1062 
<span class="line-modified">1063 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1064 const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)</span>
1065 {
1066     if (ptr &lt; begin() || ptr &gt;= end()) {
1067         if (!tryExpandCapacity(newMinCapacity))
1068             return 0;
1069         return ptr;
1070     }
1071     size_t index = ptr - begin();
1072     if (!tryExpandCapacity(newMinCapacity))
1073         return 0;
1074     return begin() + index;
1075 }
1076 
<span class="line-modified">1077 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1078 template&lt;typename U&gt;
<span class="line-modified">1079 inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, U* ptr)</span>
1080 {
1081     expandCapacity(newMinCapacity);
1082     return ptr;
1083 }
1084 
<span class="line-modified">1085 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1086 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resize(size_t size)</span>
1087 {
1088     if (size &lt;= m_size) {
1089         TypeOperations::destruct(begin() + size, end());
1090         asanBufferSizeWillChangeTo(size);
1091     } else {
1092         if (size &gt; capacity())
1093             expandCapacity(size);
1094         asanBufferSizeWillChangeTo(size);
1095         if (begin())
1096             TypeOperations::initializeIfNonPOD(end(), begin() + size);
1097     }
1098 
1099     m_size = size;
1100 }
1101 
<span class="line-modified">1102 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1103 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resizeToFit(size_t size)</span>
1104 {
1105     reserveCapacity(size);
1106     resize(size);
1107 }
1108 
<span class="line-modified">1109 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1110 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrink(size_t size)</span>
1111 {
1112     ASSERT(size &lt;= m_size);
1113     TypeOperations::destruct(begin() + size, end());
1114     asanBufferSizeWillChangeTo(size);
1115     m_size = size;
1116 }
1117 
<span class="line-modified">1118 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1119 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::grow(size_t size)</span>
1120 {
1121     ASSERT(size &gt;= m_size);
1122     if (size &gt; capacity())
1123         expandCapacity(size);
1124     asanBufferSizeWillChangeTo(size);
1125     if (begin())
1126         TypeOperations::initializeIfNonPOD(end(), begin() + size);
1127     m_size = size;
1128 }
1129 
<span class="line-modified">1130 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1131 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetInitialBufferSizeTo(size_t size)</span>
1132 {
1133 #if ASAN_ENABLED
1134     if (!buffer())
1135         return;
1136 
1137     // This function resticts buffer access to only elements in [begin(), end()) range, making ASan detect an error
1138     // when accessing elements in [end(), endOfBuffer()) range.
1139     // A newly allocated buffer can be accessed without restrictions, so &quot;old_mid&quot; argument equals &quot;end&quot; argument.
1140     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), endOfBuffer(), buffer() + size);
1141 #else
1142     UNUSED_PARAM(size);
1143 #endif
1144 }
1145 
<span class="line-modified">1146 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1147 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetBufferSizeToFullCapacity(size_t size)</span>
1148 {
1149 #if ASAN_ENABLED
1150     if (!buffer())
1151         return;
1152 
1153     // ASan requires that the annotation is returned to its initial state before deallocation.
1154     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size, endOfBuffer());
1155 #else
1156     UNUSED_PARAM(size);
1157 #endif
1158 }
1159 
<span class="line-modified">1160 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1161 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanBufferSizeWillChangeTo(size_t newSize)</span>
1162 {
1163 #if ASAN_ENABLED
1164     if (!buffer())
1165         return;
1166 
1167     // Change allowed range.
1168     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size(), buffer() + newSize);
1169 #else
1170     UNUSED_PARAM(newSize);
1171 #endif
1172 }
1173 
<span class="line-modified">1174 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1175 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveCapacity(size_t newCapacity)</span>
1176 {
1177     if (newCapacity &lt;= capacity())
1178         return;
1179     T* oldBuffer = begin();
1180     T* oldEnd = end();
1181 
1182     asanSetBufferSizeToFullCapacity();
1183 
1184     Base::allocateBuffer(newCapacity);
1185     ASSERT(begin());
1186 
1187     asanSetInitialBufferSizeTo(size());
1188 
1189     TypeOperations::move(oldBuffer, oldEnd, begin());
1190     Base::deallocateBuffer(oldBuffer);
1191 }
1192 
<span class="line-modified">1193 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1194 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryReserveCapacity(size_t newCapacity)</span>
1195 {
1196     if (newCapacity &lt;= capacity())
1197         return true;
1198     T* oldBuffer = begin();
1199     T* oldEnd = end();
1200 
1201     asanSetBufferSizeToFullCapacity();
1202 
1203     if (!Base::tryAllocateBuffer(newCapacity)) {
1204         asanSetInitialBufferSizeTo(size());
1205         return false;
1206     }
1207     ASSERT(begin());
1208 
1209     asanSetInitialBufferSizeTo(size());
1210 
1211     TypeOperations::move(oldBuffer, oldEnd, begin());
1212     Base::deallocateBuffer(oldBuffer);
1213     return true;
1214 }
1215 
<span class="line-modified">1216 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1217 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveInitialCapacity(size_t initialCapacity)</span>
1218 {
1219     ASSERT(!m_size);
1220     ASSERT(capacity() == inlineCapacity);
1221     if (initialCapacity &gt; inlineCapacity)
1222         Base::allocateBuffer(initialCapacity);
1223 }
1224 
<span class="line-modified">1225 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1226 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrinkCapacity(size_t newCapacity)</span>
1227 {
1228     if (newCapacity &gt;= capacity())
1229         return;
1230 
1231     if (newCapacity &lt; size())
1232         shrink(newCapacity);
1233 
1234     asanSetBufferSizeToFullCapacity();
1235 
1236     T* oldBuffer = begin();
1237     if (newCapacity &gt; 0) {
1238         if (Base::shouldReallocateBuffer(newCapacity)) {
1239             Base::reallocateBuffer(newCapacity);
1240             asanSetInitialBufferSizeTo(size());
1241             return;
1242         }
1243 
1244         T* oldEnd = end();
1245         Base::allocateBuffer(newCapacity);
1246         if (begin() != oldBuffer)
1247             TypeOperations::move(oldBuffer, oldEnd, begin());
1248     }
1249 
1250     Base::deallocateBuffer(oldBuffer);
1251     Base::restoreInlineBufferIfNeeded();
1252 
1253     asanSetInitialBufferSizeTo(size());
1254 }
1255 
<span class="line-modified">1256 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1257 template&lt;typename U&gt;
<span class="line-modified">1258 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(const U* data, size_t dataSize)</span>
1259 {
1260     size_t newSize = m_size + dataSize;
1261     if (newSize &gt; capacity()) {
1262         data = expandCapacity(newSize, data);
1263         ASSERT(begin());
1264     }
1265     if (newSize &lt; m_size)
1266         CRASH();
1267     asanBufferSizeWillChangeTo(newSize);
1268     T* dest = end();
1269     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1270     m_size = newSize;
1271 }
1272 
<span class="line-modified">1273 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1274 template&lt;typename U&gt;
<span class="line-modified">1275 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryAppend(const U* data, size_t dataSize)</span>
1276 {
1277     size_t newSize = m_size + dataSize;
1278     if (newSize &gt; capacity()) {
1279         data = tryExpandCapacity(newSize, data);
1280         if (!data)
1281             return false;
1282         ASSERT(begin());
1283     }
1284     if (newSize &lt; m_size)
1285         return false;
1286     asanBufferSizeWillChangeTo(newSize);
1287     T* dest = end();
1288     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1289     m_size = newSize;
1290     return true;
1291 }
1292 
<span class="line-modified">1293 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1294 template&lt;typename U&gt;
<span class="line-modified">1295 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(U&amp;&amp; value)</span>
1296 {
1297     if (size() != capacity()) {
1298         asanBufferSizeWillChangeTo(m_size + 1);
1299         new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1300         ++m_size;
1301         return;
1302     }
1303 
1304     appendSlowCase(std::forward&lt;U&gt;(value));
1305 }
1306 
<span class="line-modified">1307 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1308 template&lt;typename... Args&gt;
<span class="line-modified">1309 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppend(Args&amp;&amp;... args)</span>
1310 {
1311     if (size() != capacity()) {
1312         asanBufferSizeWillChangeTo(m_size + 1);
1313         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1314         ++m_size;
1315         return;
1316     }
1317 
1318     constructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1319 }
1320 
<span class="line-modified">1321 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1322 template&lt;typename... Args&gt;
<span class="line-modified">1323 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppend(Args&amp;&amp;... args)</span>
1324 {
1325     if (size() != capacity()) {
1326         asanBufferSizeWillChangeTo(m_size + 1);
1327         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1328         ++m_size;
1329         return true;
1330     }
1331 
1332     return tryConstructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1333 }
1334 
<span class="line-modified">1335 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1336 template&lt;typename U&gt;
<span class="line-modified">1337 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendSlowCase(U&amp;&amp; value)</span>
1338 {
1339     ASSERT(size() == capacity());
1340 
1341     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1342     ptr = expandCapacity(size() + 1, ptr);
1343     ASSERT(begin());
1344 
1345     asanBufferSizeWillChangeTo(m_size + 1);
1346     new (NotNull, end()) T(std::forward&lt;U&gt;(*ptr));
1347     ++m_size;
1348 }
1349 
<span class="line-modified">1350 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1351 template&lt;typename... Args&gt;
<span class="line-modified">1352 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)</span>
1353 {
1354     ASSERT(size() == capacity());
1355 
1356     expandCapacity(size() + 1);
1357     ASSERT(begin());
1358 
1359     asanBufferSizeWillChangeTo(m_size + 1);
1360     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1361     ++m_size;
1362 }
1363 
<span class="line-modified">1364 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1365 template&lt;typename... Args&gt;
<span class="line-modified">1366 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)</span>
1367 {
1368     ASSERT(size() == capacity());
1369 
1370     if (UNLIKELY(!tryExpandCapacity(size() + 1)))
1371         return false;
1372     ASSERT(begin());
1373 
1374     asanBufferSizeWillChangeTo(m_size + 1);
1375     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1376     ++m_size;
1377     return true;
1378 }
1379 
1380 // This version of append saves a branch in the case where you know that the
1381 // vector&#39;s capacity is large enough for the append to succeed.
1382 
<span class="line-modified">1383 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1384 template&lt;typename U&gt;
<span class="line-modified">1385 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::uncheckedAppend(U&amp;&amp; value)</span>
1386 {
1387     ASSERT(size() &lt; capacity());
1388 
1389     asanBufferSizeWillChangeTo(m_size + 1);
1390 
1391     new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1392     ++m_size;
1393 }
1394 
<span class="line-modified">1395 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1396 template&lt;typename... Args&gt;
<span class="line-modified">1397 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::uncheckedConstructAndAppend(Args&amp;&amp;... args)</span>
1398 {
1399     ASSERT(size() &lt; capacity());
1400 
1401     asanBufferSizeWillChangeTo(m_size + 1);
1402 
1403     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1404     ++m_size;
1405 }
1406 
<span class="line-modified">1407 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1408 template&lt;typename U, size_t otherCapacity&gt;
<span class="line-modified">1409 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)</span>
1410 {
1411     append(val.begin(), val.size());
1412 }
1413 
<span class="line-modified">1414 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>











1415 template&lt;typename U&gt;
<span class="line-modified">1416 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, const U* data, size_t dataSize)</span>
1417 {
1418     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1419     size_t newSize = m_size + dataSize;
1420     if (newSize &gt; capacity()) {
1421         data = expandCapacity(newSize, data);
1422         ASSERT(begin());
1423     }
1424     if (newSize &lt; m_size)
1425         CRASH();
1426     asanBufferSizeWillChangeTo(newSize);
1427     T* spot = begin() + position;
1428     TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
1429     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), spot);
1430     m_size = newSize;
1431 }
1432 
<span class="line-modified">1433 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1434 template&lt;typename U&gt;
<span class="line-modified">1435 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, U&amp;&amp; value)</span>
1436 {
1437     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1438 
1439     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1440     if (size() == capacity()) {
1441         ptr = expandCapacity(size() + 1, ptr);
1442         ASSERT(begin());
1443     }
1444 
1445     asanBufferSizeWillChangeTo(m_size + 1);
1446 
1447     T* spot = begin() + position;
1448     TypeOperations::moveOverlapping(spot, end(), spot + 1);
1449     new (NotNull, spot) T(std::forward&lt;U&gt;(*ptr));
1450     ++m_size;
1451 }
1452 
<span class="line-modified">1453 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1454 template&lt;typename U, size_t c, typename OH&gt;</span>
<span class="line-modified">1455 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp; val)</span>
1456 {
1457     insert(position, val.begin(), val.size());
1458 }
1459 
<span class="line-modified">1460 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1461 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position)</span>
1462 {
1463     ASSERT_WITH_SECURITY_IMPLICATION(position &lt; size());
1464     T* spot = begin() + position;
1465     spot-&gt;~T();
1466     TypeOperations::moveOverlapping(spot + 1, end(), spot);
1467     asanBufferSizeWillChangeTo(m_size - 1);
1468     --m_size;
1469 }
1470 
<span class="line-modified">1471 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1472 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position, size_t length)</span>
1473 {
1474     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1475     ASSERT_WITH_SECURITY_IMPLICATION(position + length &lt;= size());
1476     T* beginSpot = begin() + position;
1477     T* endSpot = beginSpot + length;
1478     TypeOperations::destruct(beginSpot, endSpot);
1479     TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
1480     asanBufferSizeWillChangeTo(m_size - length);
1481     m_size -= length;
1482 }
1483 
<span class="line-modified">1484 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1485 template&lt;typename U&gt;
<span class="line-modified">1486 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirst(const U&amp; value)</span>
1487 {
1488     return removeFirstMatching([&amp;value] (const T&amp; current) {
1489         return current == value;
1490     });
1491 }
1492 
<span class="line-modified">1493 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1494 template&lt;typename MatchFunction&gt;
<span class="line-modified">1495 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
1496 {
1497     for (size_t i = startIndex; i &lt; size(); ++i) {
1498         if (matches(at(i))) {
1499             remove(i);
1500             return true;
1501         }
1502     }
1503     return false;
1504 }
1505 
<span class="line-modified">1506 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1507 template&lt;typename U&gt;
<span class="line-modified">1508 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAll(const U&amp; value)</span>
1509 {
1510     return removeAllMatching([&amp;value] (const T&amp; current) {
1511         return current == value;
1512     });
1513 }
1514 
<span class="line-modified">1515 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1516 template&lt;typename MatchFunction&gt;
<span class="line-modified">1517 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
1518 {
1519     iterator holeBegin = end();
1520     iterator holeEnd = end();
1521     unsigned matchCount = 0;
1522     for (auto it = begin() + startIndex, itEnd = end(); it &lt; itEnd; ++it) {
1523         if (matches(*it)) {
1524             if (holeBegin == end())
1525                 holeBegin = it;
1526             else if (holeEnd != it) {
1527                 TypeOperations::moveOverlapping(holeEnd, it, holeBegin);
1528                 holeBegin += it - holeEnd;
1529             }
1530             holeEnd = it + 1;
1531             it-&gt;~T();
1532             ++matchCount;
1533         }
1534     }
1535     if (holeEnd != end())
1536         TypeOperations::moveOverlapping(holeEnd, end(), holeBegin);
1537     asanBufferSizeWillChangeTo(m_size - matchCount);
1538     m_size -= matchCount;
1539     return matchCount;
1540 }
1541 
<span class="line-modified">1542 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1543 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverse()</span>
1544 {
1545     for (size_t i = 0; i &lt; m_size / 2; ++i)
1546         std::swap(at(i), at(m_size - 1 - i));
1547 }
1548 
<span class="line-modified">1549 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1550 template&lt;typename MapFunction, typename R&gt;
<span class="line-modified">1551 inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::map(MapFunction mapFunction) const</span>
1552 {
1553     Vector&lt;R&gt; result;
1554     result.reserveInitialCapacity(size());
1555     for (size_t i = 0; i &lt; size(); ++i)
1556         result.uncheckedAppend(mapFunction(at(i)));
1557     return result;
1558 }
1559 
<span class="line-modified">1560 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1561 inline MallocPtr&lt;T&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::releaseBuffer()</span>
1562 {
1563     // FIXME: Find a way to preserve annotations on the returned buffer.
1564     // ASan requires that all annotations are removed before deallocation,
1565     // and MallocPtr doesn&#39;t implement that.
1566     asanSetBufferSizeToFullCapacity();
1567 
1568     auto buffer = Base::releaseBuffer();
1569     if (inlineCapacity &amp;&amp; !buffer &amp;&amp; m_size) {
1570         // If the vector had some data, but no buffer to release,
1571         // that means it was using the inline buffer. In that case,
1572         // we create a brand new buffer so the caller always gets one.
1573         size_t bytes = m_size * sizeof(T);
<span class="line-modified">1574         buffer = adoptMallocPtr(static_cast&lt;T*&gt;(fastMalloc(bytes)));</span>
1575         memcpy(buffer.get(), data(), bytes);
1576     }
1577     m_size = 0;
1578     // FIXME: Should we call Base::restoreInlineBufferIfNeeded() here?
1579     return buffer;
1580 }
1581 
<span class="line-modified">1582 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1583 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::checkConsistency()</span>
1584 {
<span class="line-modified">1585 #if !ASSERT_DISABLED</span>
1586     for (size_t i = 0; i &lt; size(); ++i)
1587         ValueCheck&lt;T&gt;::checkConsistency(at(i));
1588 #endif
1589 }
1590 
<span class="line-modified">1591 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1592 inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
1593 {
1594     a.swap(b);
1595 }
1596 
<span class="line-modified">1597 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1598 bool operator==(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
1599 {
1600     if (a.size() != b.size())
1601         return false;
1602 
1603     return VectorTypeOperations&lt;T&gt;::compare(a.data(), b.data(), a.size());
1604 }
1605 
<span class="line-modified">1606 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1607 inline bool operator!=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
1608 {
1609     return !(a == b);
1610 }
1611 
<span class="line-modified">1612 #if !ASSERT_DISABLED</span>
1613 template&lt;typename T&gt; struct ValueCheck&lt;Vector&lt;T&gt;&gt; {
1614     typedef Vector&lt;T&gt; TraitType;
1615     static void checkConsistency(const Vector&lt;T&gt;&amp; v)
1616     {
1617         v.checkConsistency();
1618     }
1619 };
<span class="line-modified">1620 #endif</span>
1621 
<span class="line-modified">1622 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
1623 template&lt;typename U&gt;
<span class="line-modified">1624 inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::isolatedCopy() const</span>
1625 {
1626     Vector&lt;U&gt; copy;
1627     copy.reserveInitialCapacity(size());
1628     for (const auto&amp; element : *this)
1629         copy.uncheckedAppend(element.isolatedCopy());
1630     return copy;
1631 }
1632 
1633 template&lt;typename VectorType, typename Func&gt;
1634 size_t removeRepeatedElements(VectorType&amp; vector, const Func&amp; func)
1635 {
1636     auto end = std::unique(vector.begin(), vector.end(), func);
1637     size_t newSize = end - vector.begin();
1638     vector.shrink(newSize);
1639     return newSize;
1640 }
1641 
<span class="line-modified">1642 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">1643 size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; vector)</span>
1644 {
1645     return removeRepeatedElements(vector, [] (T&amp; a, T&amp; b) { return a == b; });
1646 }
1647 
1648 template&lt;typename SourceType&gt;
1649 struct CollectionInspector {
1650     using RealSourceType = typename std::remove_reference&lt;SourceType&gt;::type;
1651     using IteratorType = decltype(std::begin(std::declval&lt;RealSourceType&gt;()));
1652     using SourceItemType = typename std::iterator_traits&lt;IteratorType&gt;::value_type;
1653 };
1654 
1655 template&lt;typename MapFunction, typename SourceType, typename Enable = void&gt;
1656 struct Mapper {
1657     using SourceItemType = typename CollectionInspector&lt;SourceType&gt;::SourceItemType;
1658     using DestinationItemType = typename std::result_of&lt;MapFunction(SourceItemType&amp;)&gt;::type;
1659 
1660     static Vector&lt;DestinationItemType&gt; map(SourceType source, const MapFunction&amp; mapFunction)
1661     {
1662         Vector&lt;DestinationItemType&gt; result;
1663         // FIXME: Use std::size when available on all compilers.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  *  Copyright (C) 2005-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  *  This library is free software; you can redistribute it and/or
   5  *  modify it under the terms of the GNU Library General Public
   6  *  License as published by the Free Software Foundation; either
   7  *  version 2 of the License, or (at your option) any later version.
   8  *
   9  *  This library is distributed in the hope that it will be useful,
  10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  *  Library General Public License for more details.
  13  *
  14  *  You should have received a copy of the GNU Library General Public License
  15  *  along with this library; see the file COPYING.LIB.  If not, write to
  16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  *  Boston, MA 02110-1301, USA.
  18  *
  19  */
  20 
  21 #pragma once
  22 
</pre>
<hr />
<pre>
  29 #include &lt;wtf/FastMalloc.h&gt;
  30 #include &lt;wtf/Forward.h&gt;
  31 #include &lt;wtf/MallocPtr.h&gt;
  32 #include &lt;wtf/MathExtras.h&gt;
  33 #include &lt;wtf/Noncopyable.h&gt;
  34 #include &lt;wtf/NotFound.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/ValueCheck.h&gt;
  37 #include &lt;wtf/VectorTraits.h&gt;
  38 
  39 #if ASAN_ENABLED
  40 extern &quot;C&quot; void __sanitizer_annotate_contiguous_container(const void* begin, const void* end, const void* old_mid, const void* new_mid);
  41 #endif
  42 
  43 namespace JSC {
  44 class LLIntOffsetsExtractor;
  45 }
  46 
  47 namespace WTF {
  48 
<span class="line-added">  49 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Vector);</span>
<span class="line-added">  50 </span>
  51 template &lt;bool needsDestruction, typename T&gt;
  52 struct VectorDestructor;
  53 
  54 template&lt;typename T&gt;
  55 struct VectorDestructor&lt;false, T&gt;
  56 {
  57     static void destruct(T*, T*) {}
  58 };
  59 
  60 template&lt;typename T&gt;
  61 struct VectorDestructor&lt;true, T&gt;
  62 {
  63     static void destruct(T* begin, T* end)
  64     {
  65         for (T* cur = begin; cur != end; ++cur)
  66             cur-&gt;~T();
  67     }
  68 };
  69 
  70 template &lt;bool needsInitialization, bool canInitializeWithMemset, typename T&gt;
</pre>
<hr />
<pre>
 189 struct VectorFiller;
 190 
 191 template&lt;typename T&gt;
 192 struct VectorFiller&lt;false, T&gt;
 193 {
 194     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 195     {
 196         while (dst != dstEnd) {
 197             new (NotNull, dst) T(val);
 198             ++dst;
 199         }
 200     }
 201 };
 202 
 203 template&lt;typename T&gt;
 204 struct VectorFiller&lt;true, T&gt;
 205 {
 206     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 207     {
 208         static_assert(sizeof(T) == 1, &quot;Size of type T should be equal to one!&quot;);
<span class="line-modified"> 209         memset(dst, val, dstEnd - dst);</span>



 210     }
 211 };
 212 
 213 template&lt;bool canCompareWithMemcmp, typename T&gt;
 214 struct VectorComparer;
 215 
 216 template&lt;typename T&gt;
 217 struct VectorComparer&lt;false, T&gt;
 218 {
 219     static bool compare(const T* a, const T* b, size_t size)
 220     {
 221         for (size_t i = 0; i &lt; size; ++i)
 222             if (!(a[i] == b[i]))
 223                 return false;
 224         return true;
 225     }
 226 };
 227 
 228 template&lt;typename T&gt;
 229 struct VectorComparer&lt;true, T&gt;
</pre>
<hr />
<pre>
 261     {
 262         VectorMover&lt;VectorTraits&lt;T&gt;::canMoveWithMemcpy, T&gt;::moveOverlapping(src, srcEnd, dst);
 263     }
 264 
 265     static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
 266     {
 267         VectorCopier&lt;VectorTraits&lt;T&gt;::canCopyWithMemcpy, T&gt;::uninitializedCopy(src, srcEnd, dst);
 268     }
 269 
 270     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 271     {
 272         VectorFiller&lt;VectorTraits&lt;T&gt;::canFillWithMemset, T&gt;::uninitializedFill(dst, dstEnd, val);
 273     }
 274 
 275     static bool compare(const T* a, const T* b, size_t size)
 276     {
 277         return VectorComparer&lt;VectorTraits&lt;T&gt;::canCompareWithMemcmp, T&gt;::compare(a, b, size);
 278     }
 279 };
 280 
<span class="line-modified"> 281 template&lt;typename T, typename Malloc&gt;</span>
 282 class VectorBufferBase {
 283     WTF_MAKE_NONCOPYABLE(VectorBufferBase);
 284 public:
 285     void allocateBuffer(size_t newCapacity)
 286     {
 287         ASSERT(newCapacity);
 288         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 289             CRASH();
 290         size_t sizeToAllocate = newCapacity * sizeof(T);
 291         m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified"> 292         m_buffer = static_cast&lt;T*&gt;(Malloc::malloc(sizeToAllocate));</span>
 293     }
 294 
 295     bool tryAllocateBuffer(size_t newCapacity)
 296     {
 297         ASSERT(newCapacity);
 298         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 299             return false;
 300 
 301         size_t sizeToAllocate = newCapacity * sizeof(T);
<span class="line-modified"> 302         T* newBuffer = static_cast&lt;T*&gt;(Malloc::tryMalloc(sizeToAllocate));</span>
<span class="line-modified"> 303         if (!newBuffer)</span>
<span class="line-modified"> 304             return false;</span>
<span class="line-modified"> 305         m_capacity = sizeToAllocate / sizeof(T);</span>
<span class="line-modified"> 306         m_buffer = newBuffer;</span>
<span class="line-modified"> 307         return true;</span>

 308     }
 309 
 310     bool shouldReallocateBuffer(size_t newCapacity) const
 311     {
 312         return VectorTraits&lt;T&gt;::canMoveWithMemcpy &amp;&amp; m_capacity &amp;&amp; newCapacity;
 313     }
 314 
 315     void reallocateBuffer(size_t newCapacity)
 316     {
 317         ASSERT(shouldReallocateBuffer(newCapacity));
 318         if (newCapacity &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
 319             CRASH();
 320         size_t sizeToAllocate = newCapacity * sizeof(T);
 321         m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified"> 322         m_buffer = static_cast&lt;T*&gt;(Malloc::realloc(m_buffer, sizeToAllocate));</span>
 323     }
 324 
 325     void deallocateBuffer(T* bufferToDeallocate)
 326     {
 327         if (!bufferToDeallocate)
 328             return;
 329 
 330         if (m_buffer == bufferToDeallocate) {
 331             m_buffer = 0;
 332             m_capacity = 0;
 333         }
 334 
<span class="line-modified"> 335         Malloc::free(bufferToDeallocate);</span>
 336     }
 337 
 338     T* buffer() { return m_buffer; }
 339     const T* buffer() const { return m_buffer; }
 340     static ptrdiff_t bufferMemoryOffset() { return OBJECT_OFFSETOF(VectorBufferBase, m_buffer); }
 341     size_t capacity() const { return m_capacity; }
 342 
<span class="line-modified"> 343     MallocPtr&lt;T, Malloc&gt; releaseBuffer()</span>
 344     {
 345         T* buffer = m_buffer;
 346         m_buffer = 0;
 347         m_capacity = 0;
<span class="line-modified"> 348         return adoptMallocPtr&lt;T, Malloc&gt;(buffer);</span>
 349     }
 350 
 351 protected:
 352     VectorBufferBase()
 353         : m_buffer(0)
 354         , m_capacity(0)
 355         , m_size(0)
 356     {
 357     }
 358 
 359     VectorBufferBase(T* buffer, size_t capacity, size_t size)
 360         : m_buffer(buffer)
 361         , m_capacity(capacity)
 362         , m_size(size)
 363     {
 364     }
 365 
 366     ~VectorBufferBase()
 367     {
 368         // FIXME: It would be nice to find a way to ASSERT that m_buffer hasn&#39;t leaked here.
 369     }
 370 
 371     T* m_buffer;
 372     unsigned m_capacity;
 373     unsigned m_size; // Only used by the Vector subclass, but placed here to avoid padding the struct.
 374 };
 375 
<span class="line-modified"> 376 template&lt;typename T, size_t inlineCapacity, typename Malloc = VectorMalloc&gt; class VectorBuffer;</span>

 377 
<span class="line-modified"> 378 template&lt;typename T, typename Malloc&gt;</span>
<span class="line-modified"> 379 class VectorBuffer&lt;T, 0, Malloc&gt; : private VectorBufferBase&lt;T, Malloc&gt; {</span>
 380 private:
<span class="line-modified"> 381     typedef VectorBufferBase&lt;T, Malloc&gt; Base;</span>
 382 public:
 383     VectorBuffer()
 384     {
 385     }
 386 
 387     VectorBuffer(size_t capacity, size_t size = 0)
 388     {
 389         m_size = size;
 390         // Calling malloc(0) might take a lock and may actually do an
 391         // allocation on some systems.
 392         if (capacity)
 393             allocateBuffer(capacity);
 394     }
 395 
 396     ~VectorBuffer()
 397     {
 398         deallocateBuffer(buffer());
 399     }
 400 
<span class="line-modified"> 401     void swap(VectorBuffer&lt;T, 0, Malloc&gt;&amp; other, size_t, size_t)</span>
 402     {
 403         std::swap(m_buffer, other.m_buffer);
 404         std::swap(m_capacity, other.m_capacity);
 405     }
 406 
 407     void restoreInlineBufferIfNeeded() { }
 408 
 409 #if ASAN_ENABLED
 410     void* endOfBuffer()
 411     {
 412         return buffer() + capacity();
 413     }
 414 #endif
 415 
 416     using Base::allocateBuffer;
 417     using Base::tryAllocateBuffer;
 418     using Base::shouldReallocateBuffer;
 419     using Base::reallocateBuffer;
 420     using Base::deallocateBuffer;
 421 
 422     using Base::buffer;
 423     using Base::capacity;
 424     using Base::bufferMemoryOffset;
 425 
 426     using Base::releaseBuffer;
 427 
 428 protected:
 429     using Base::m_size;
 430 
 431 private:
 432     friend class JSC::LLIntOffsetsExtractor;
 433     using Base::m_buffer;
 434     using Base::m_capacity;
 435 };
 436 
<span class="line-modified"> 437 template&lt;typename T, size_t inlineCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 438 class VectorBuffer : private VectorBufferBase&lt;T, Malloc&gt; {</span>
 439     WTF_MAKE_NONCOPYABLE(VectorBuffer);
 440 private:
<span class="line-modified"> 441     typedef VectorBufferBase&lt;T, Malloc&gt; Base;</span>
 442 public:
 443     VectorBuffer()
 444         : Base(inlineBuffer(), inlineCapacity, 0)
 445     {
 446     }
 447 
 448     VectorBuffer(size_t capacity, size_t size = 0)
 449         : Base(inlineBuffer(), inlineCapacity, size)
 450     {
 451         if (capacity &gt; inlineCapacity)
 452             Base::allocateBuffer(capacity);
 453     }
 454 
 455     ~VectorBuffer()
 456     {
 457         deallocateBuffer(buffer());
 458     }
 459 
 460     void allocateBuffer(size_t newCapacity)
 461     {
</pre>
<hr />
<pre>
 528 #if ASAN_ENABLED
 529     void* endOfBuffer()
 530     {
 531         ASSERT(buffer());
 532 
 533         IGNORE_GCC_WARNINGS_BEGIN(&quot;invalid-offsetof&quot;)
 534         static_assert((offsetof(VectorBuffer, m_inlineBuffer) + sizeof(m_inlineBuffer)) % 8 == 0, &quot;Inline buffer end needs to be on 8 byte boundary for ASan annotations to work.&quot;);
 535         IGNORE_GCC_WARNINGS_END
 536 
 537         if (buffer() == inlineBuffer())
 538             return reinterpret_cast&lt;char*&gt;(m_inlineBuffer) + sizeof(m_inlineBuffer);
 539 
 540         return buffer() + capacity();
 541     }
 542 #endif
 543 
 544     using Base::buffer;
 545     using Base::capacity;
 546     using Base::bufferMemoryOffset;
 547 
<span class="line-modified"> 548     MallocPtr&lt;T, Malloc&gt; releaseBuffer()</span>
 549     {
 550         if (buffer() == inlineBuffer())
<span class="line-modified"> 551             return { };</span>
 552         return Base::releaseBuffer();
 553     }
 554 
 555 protected:
 556     using Base::m_size;
 557 
 558 private:
 559     using Base::m_buffer;
 560     using Base::m_capacity;
 561 
 562     void swapInlineBuffer(VectorBuffer&amp; other, size_t mySize, size_t otherSize)
 563     {
 564         // FIXME: We could make swap part of VectorTypeOperations
 565         // https://bugs.webkit.org/show_bug.cgi?id=128863
 566         swapInlineBuffers(inlineBuffer(), other.inlineBuffer(), mySize, otherSize);
 567     }
 568 
 569     static void swapInlineBuffers(T* left, T* right, size_t leftSize, size_t rightSize)
 570     {
 571         if (left == right)
 572             return;
 573 
 574         ASSERT(leftSize &lt;= inlineCapacity);
 575         ASSERT(rightSize &lt;= inlineCapacity);
 576 
 577         size_t swapBound = std::min(leftSize, rightSize);
 578         for (unsigned i = 0; i &lt; swapBound; ++i)
 579             std::swap(left[i], right[i]);
 580         VectorTypeOperations&lt;T&gt;::move(left + swapBound, left + leftSize, right + swapBound);
 581         VectorTypeOperations&lt;T&gt;::move(right + swapBound, right + rightSize, left + swapBound);
 582     }
 583 
 584     T* inlineBuffer() { return reinterpret_cast_ptr&lt;T*&gt;(m_inlineBuffer); }
 585     const T* inlineBuffer() const { return reinterpret_cast_ptr&lt;const T*&gt;(m_inlineBuffer); }
 586 
 587 #if ASAN_ENABLED
 588     // ASan needs the buffer to begin and end on 8-byte boundaries for annotations to work.
 589     // FIXME: Add a redzone before the buffer to catch off by one accesses. We don&#39;t need a guard after, because the buffer is the last member variable.
<span class="line-modified"> 590     static constexpr size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;</span>
<span class="line-modified"> 591     static constexpr size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);</span>
 592     typename std::aligned_storage&lt;sizeof(T), asanInlineBufferAlignment&gt;::type m_inlineBuffer[asanAdjustedInlineCapacity];
 593 #else
 594     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_inlineBuffer[inlineCapacity];
 595 #endif
 596 };
 597 
 598 struct UnsafeVectorOverflow {
 599     static NO_RETURN_DUE_TO_ASSERT void overflowed()
 600     {
 601         ASSERT_NOT_REACHED();
 602     }
 603 };
 604 
 605 // Template default values are in Forward.h.
<span class="line-modified"> 606 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 607 class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; {</span>
 608     WTF_MAKE_FAST_ALLOCATED;
 609 private:
<span class="line-modified"> 610     typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;</span>
 611     typedef VectorTypeOperations&lt;T&gt; TypeOperations;
 612     friend class JSC::LLIntOffsetsExtractor;
 613 
 614 public:
 615     typedef T ValueType;
 616 
 617     typedef T* iterator;
 618     typedef const T* const_iterator;
 619     typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
 620     typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
 621 
 622     Vector()
 623     {
 624     }
 625 
 626     // Unlike in std::vector, this constructor does not initialize POD types.
 627     explicit Vector(size_t size)
 628         : Base(size, size)
 629     {
 630         asanSetInitialBufferSizeTo(size);
</pre>
<hr />
<pre>
 649         asanSetInitialBufferSizeTo(initializerList.size());
 650 
 651         for (const auto&amp; element : initializerList)
 652             uncheckedAppend(element);
 653     }
 654 
 655     template&lt;typename... Items&gt;
 656     static Vector from(Items&amp;&amp;... items)
 657     {
 658         Vector result;
 659         auto size = sizeof...(items);
 660 
 661         result.reserveInitialCapacity(size);
 662         result.asanSetInitialBufferSizeTo(size);
 663         result.m_size = size;
 664 
 665         result.uncheckedInitialize&lt;0&gt;(std::forward&lt;Items&gt;(items)...);
 666         return result;
 667     }
 668 
<span class="line-added"> 669     Vector(WTF::HashTableDeletedValueType)</span>
<span class="line-added"> 670         : Base(0, std::numeric_limits&lt;decltype(m_size)&gt;::max())</span>
<span class="line-added"> 671     {</span>
<span class="line-added"> 672     }</span>
<span class="line-added"> 673 </span>
 674     ~Vector()
 675     {
 676         if (m_size)
 677             TypeOperations::destruct(begin(), end());
 678 
 679         asanSetBufferSizeToFullCapacity(0);
 680     }
 681 
 682     Vector(const Vector&amp;);
<span class="line-modified"> 683     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified"> 684     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span>
 685 
 686     Vector&amp; operator=(const Vector&amp;);
<span class="line-modified"> 687     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified"> 688     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span>
 689 
 690     Vector(Vector&amp;&amp;);
 691     Vector&amp; operator=(Vector&amp;&amp;);
 692 
 693     size_t size() const { return m_size; }
 694     static ptrdiff_t sizeMemoryOffset() { return OBJECT_OFFSETOF(Vector, m_size); }
 695     size_t capacity() const { return Base::capacity(); }
 696     bool isEmpty() const { return !size(); }
 697 
 698     T&amp; at(size_t i)
 699     {
 700         if (UNLIKELY(i &gt;= size()))
 701             OverflowHandler::overflowed();
 702         return Base::buffer()[i];
 703     }
 704     const T&amp; at(size_t i) const
 705     {
 706         if (UNLIKELY(i &gt;= size()))
 707             OverflowHandler::overflowed();
 708         return Base::buffer()[i];
</pre>
<hr />
<pre>
 764     bool tryReserveCapacity(size_t newCapacity);
 765     void reserveInitialCapacity(size_t initialCapacity);
 766     void shrinkCapacity(size_t newCapacity);
 767     void shrinkToFit() { shrinkCapacity(size()); }
 768 
 769     void clear() { shrinkCapacity(0); }
 770 
 771     template&lt;typename U = T&gt; Vector&lt;U&gt; isolatedCopy() const;
 772 
 773     ALWAYS_INLINE void append(ValueType&amp;&amp; value) { append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 774     template&lt;typename U&gt; void append(U&amp;&amp;);
 775     template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);
 776     template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);
 777 
 778     void uncheckedAppend(ValueType&amp;&amp; value) { uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 779     template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);
 780     template&lt;typename... Args&gt; void uncheckedConstructAndAppend(Args&amp;&amp;...);
 781 
 782     template&lt;typename U&gt; void append(const U*, size_t);
 783     template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);
<span class="line-added"> 784     template&lt;typename U, size_t otherCapacity&gt; void appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp;);</span>
 785     template&lt;typename U&gt; bool tryAppend(const U*, size_t);
 786 
 787     template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
 788     template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
<span class="line-modified"> 789     template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt; void insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp;);</span>
 790 
 791     void remove(size_t position);
 792     void remove(size_t position, size_t length);
 793     template&lt;typename U&gt; bool removeFirst(const U&amp;);
 794     template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);
 795     template&lt;typename U&gt; unsigned removeAll(const U&amp;);
 796     template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);
 797 
 798     void removeLast()
 799     {
 800         if (UNLIKELY(isEmpty()))
 801             OverflowHandler::overflowed();
 802         shrink(size() - 1);
 803     }
 804 
 805     void fill(const T&amp;, size_t);
 806     void fill(const T&amp; val) { fill(val, size()); }
 807 
 808     template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);
 809 
<span class="line-modified"> 810     MallocPtr&lt;T, Malloc&gt; releaseBuffer();</span>
 811 
<span class="line-modified"> 812     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)</span>
 813     {
 814 #if ASAN_ENABLED
 815         if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.
 816             return;
 817 #endif
 818 
 819         // Make it possible to copy inline buffers.
 820         asanSetBufferSizeToFullCapacity();
 821         other.asanSetBufferSizeToFullCapacity();
 822 
 823         Base::swap(other, m_size, other.m_size);
 824         std::swap(m_size, other.m_size);
 825 
 826         asanSetInitialBufferSizeTo(m_size);
 827         other.asanSetInitialBufferSizeTo(other.m_size);
 828     }
 829 
 830     void reverse();
 831 
 832     void checkConsistency();
 833 
 834     template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;
 835 
<span class="line-added"> 836     bool isHashTableDeletedValue() const { return m_size == std::numeric_limits&lt;decltype(m_size)&gt;::max(); }</span>
<span class="line-added"> 837 </span>
 838 private:
 839     void expandCapacity(size_t newMinCapacity);
 840     T* expandCapacity(size_t newMinCapacity, T*);
 841     bool tryExpandCapacity(size_t newMinCapacity);
 842     const T* tryExpandCapacity(size_t newMinCapacity, const T*);
 843     template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*);
 844     template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);
 845     template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);
 846     template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);
 847 
 848     template&lt;size_t position, typename U, typename... Items&gt;
 849     void uncheckedInitialize(U&amp;&amp; item, Items&amp;&amp;... items)
 850     {
 851         uncheckedInitialize&lt;position&gt;(std::forward&lt;U&gt;(item));
 852         uncheckedInitialize&lt;position + 1&gt;(std::forward&lt;Items&gt;(items)...);
 853     }
 854     template&lt;size_t position, typename U&gt;
 855     void uncheckedInitialize(U&amp;&amp; value)
 856     {
 857         ASSERT(position &lt; size());
</pre>
<hr />
<pre>
 864     void asanSetBufferSizeToFullCapacity() { asanSetBufferSizeToFullCapacity(size()); }
 865 
 866     void asanBufferSizeWillChangeTo(size_t);
 867 
 868     using Base::m_size;
 869     using Base::buffer;
 870     using Base::capacity;
 871     using Base::swap;
 872     using Base::allocateBuffer;
 873     using Base::deallocateBuffer;
 874     using Base::tryAllocateBuffer;
 875     using Base::shouldReallocateBuffer;
 876     using Base::reallocateBuffer;
 877     using Base::restoreInlineBufferIfNeeded;
 878     using Base::releaseBuffer;
 879 #if ASAN_ENABLED
 880     using Base::endOfBuffer;
 881 #endif
 882 };
 883 
<span class="line-modified"> 884 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 885 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&amp; other)</span>
 886     : Base(other.capacity(), other.size())
 887 {
 888     asanSetInitialBufferSizeTo(other.size());
 889 
 890     if (begin())
 891         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 892 }
 893 
<span class="line-modified"> 894 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 895 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified"> 896 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)</span>
 897     : Base(other.capacity(), other.size())
 898 {
 899     asanSetInitialBufferSizeTo(other.size());
 900 
 901     if (begin())
 902         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 903 }
 904 
<span class="line-modified"> 905 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 906 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)</span>
 907 {
 908     if (&amp;other == this)
 909         return *this;
 910 
 911     if (size() &gt; other.size())
 912         shrink(other.size());
 913     else if (other.size() &gt; capacity()) {
 914         clear();
 915         reserveCapacity(other.size());
 916         ASSERT(begin());
 917     }
 918 
 919     asanBufferSizeWillChangeTo(other.size());
 920 
 921     std::copy(other.begin(), other.begin() + size(), begin());
 922     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 923     m_size = other.size();
 924 
 925     return *this;
 926 }
 927 
 928 inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }
 929 
<span class="line-modified"> 930 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 931 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified"> 932 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)</span>
 933 {
 934     // If the inline capacities match, we should call the more specific
 935     // template.  If the inline capacities don&#39;t match, the two objects
 936     // shouldn&#39;t be allocated the same address.
 937     ASSERT(!typelessPointersAreEqual(&amp;other, this));
 938 
 939     if (size() &gt; other.size())
 940         shrink(other.size());
 941     else if (other.size() &gt; capacity()) {
 942         clear();
 943         reserveCapacity(other.size());
 944         ASSERT(begin());
 945     }
 946 
 947     asanBufferSizeWillChangeTo(other.size());
 948 
 949     std::copy(other.begin(), other.begin() + size(), begin());
 950     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 951     m_size = other.size();
 952 
 953     return *this;
 954 }
 955 
<span class="line-modified"> 956 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 957 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)</span>
 958 {
 959     swap(other);
 960 }
 961 
<span class="line-modified"> 962 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 963 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)</span>
 964 {
 965     swap(other);
 966     return *this;
 967 }
 968 
<span class="line-modified"> 969 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
 970 template&lt;typename U&gt;
<span class="line-modified"> 971 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::contains(const U&amp; value) const</span>
 972 {
 973     return find(value) != notFound;
 974 }
 975 
<span class="line-modified"> 976 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
 977 template&lt;typename MatchFunction&gt;
<span class="line-modified"> 978 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::findMatching(const MatchFunction&amp; matches) const</span>
 979 {
 980     for (size_t i = 0; i &lt; size(); ++i) {
 981         if (matches(at(i)))
 982             return i;
 983     }
 984     return notFound;
 985 }
 986 
<span class="line-modified"> 987 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
 988 template&lt;typename U&gt;
<span class="line-modified"> 989 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::find(const U&amp; value) const</span>
 990 {
 991     return findMatching([&amp;](auto&amp; item) {
 992         return item == value;
 993     });
 994 }
 995 
<span class="line-modified"> 996 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
 997 template&lt;typename U&gt;
<span class="line-modified"> 998 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverseFind(const U&amp; value) const</span>
 999 {
1000     for (size_t i = 1; i &lt;= size(); ++i) {
1001         const size_t index = size() - i;
1002         if (at(index) == value)
1003             return index;
1004     }
1005     return notFound;
1006 }
1007 
<span class="line-modified">1008 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1009 template&lt;typename U&gt;
<span class="line-modified">1010 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendIfNotContains(const U&amp; value)</span>
1011 {
1012     if (contains(value))
1013         return false;
1014     append(value);
1015     return true;
1016 }
1017 
<span class="line-modified">1018 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1019 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::fill(const T&amp; val, size_t newSize)</span>
1020 {
1021     if (size() &gt; newSize)
1022         shrink(newSize);
1023     else if (newSize &gt; capacity()) {
1024         clear();
1025         reserveCapacity(newSize);
1026         ASSERT(begin());
1027     }
1028 
1029     asanBufferSizeWillChangeTo(newSize);
1030 
1031     std::fill(begin(), end(), val);
1032     TypeOperations::uninitializedFill(end(), begin() + newSize, val);
1033     m_size = newSize;
1034 }
1035 
<span class="line-modified">1036 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1037 template&lt;typename Iterator&gt;
<span class="line-modified">1038 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendRange(Iterator start, Iterator end)</span>
1039 {
1040     for (Iterator it = start; it != end; ++it)
1041         append(*it);
1042 }
1043 
<span class="line-modified">1044 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1045 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity)</span>
1046 {
1047     reserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1048 }
1049 
<span class="line-modified">1050 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1051 NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, T* ptr)</span>
1052 {
1053     if (ptr &lt; begin() || ptr &gt;= end()) {
1054         expandCapacity(newMinCapacity);
1055         return ptr;
1056     }
1057     size_t index = ptr - begin();
1058     expandCapacity(newMinCapacity);
1059     return begin() + index;
1060 }
1061 
<span class="line-modified">1062 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1063 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity)</span>
1064 {
1065     return tryReserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1066 }
1067 
<span class="line-modified">1068 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1069 const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)</span>
1070 {
1071     if (ptr &lt; begin() || ptr &gt;= end()) {
1072         if (!tryExpandCapacity(newMinCapacity))
1073             return 0;
1074         return ptr;
1075     }
1076     size_t index = ptr - begin();
1077     if (!tryExpandCapacity(newMinCapacity))
1078         return 0;
1079     return begin() + index;
1080 }
1081 
<span class="line-modified">1082 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1083 template&lt;typename U&gt;
<span class="line-modified">1084 inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, U* ptr)</span>
1085 {
1086     expandCapacity(newMinCapacity);
1087     return ptr;
1088 }
1089 
<span class="line-modified">1090 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1091 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resize(size_t size)</span>
1092 {
1093     if (size &lt;= m_size) {
1094         TypeOperations::destruct(begin() + size, end());
1095         asanBufferSizeWillChangeTo(size);
1096     } else {
1097         if (size &gt; capacity())
1098             expandCapacity(size);
1099         asanBufferSizeWillChangeTo(size);
1100         if (begin())
1101             TypeOperations::initializeIfNonPOD(end(), begin() + size);
1102     }
1103 
1104     m_size = size;
1105 }
1106 
<span class="line-modified">1107 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1108 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resizeToFit(size_t size)</span>
1109 {
1110     reserveCapacity(size);
1111     resize(size);
1112 }
1113 
<span class="line-modified">1114 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1115 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrink(size_t size)</span>
1116 {
1117     ASSERT(size &lt;= m_size);
1118     TypeOperations::destruct(begin() + size, end());
1119     asanBufferSizeWillChangeTo(size);
1120     m_size = size;
1121 }
1122 
<span class="line-modified">1123 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1124 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::grow(size_t size)</span>
1125 {
1126     ASSERT(size &gt;= m_size);
1127     if (size &gt; capacity())
1128         expandCapacity(size);
1129     asanBufferSizeWillChangeTo(size);
1130     if (begin())
1131         TypeOperations::initializeIfNonPOD(end(), begin() + size);
1132     m_size = size;
1133 }
1134 
<span class="line-modified">1135 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1136 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetInitialBufferSizeTo(size_t size)</span>
1137 {
1138 #if ASAN_ENABLED
1139     if (!buffer())
1140         return;
1141 
1142     // This function resticts buffer access to only elements in [begin(), end()) range, making ASan detect an error
1143     // when accessing elements in [end(), endOfBuffer()) range.
1144     // A newly allocated buffer can be accessed without restrictions, so &quot;old_mid&quot; argument equals &quot;end&quot; argument.
1145     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), endOfBuffer(), buffer() + size);
1146 #else
1147     UNUSED_PARAM(size);
1148 #endif
1149 }
1150 
<span class="line-modified">1151 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1152 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetBufferSizeToFullCapacity(size_t size)</span>
1153 {
1154 #if ASAN_ENABLED
1155     if (!buffer())
1156         return;
1157 
1158     // ASan requires that the annotation is returned to its initial state before deallocation.
1159     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size, endOfBuffer());
1160 #else
1161     UNUSED_PARAM(size);
1162 #endif
1163 }
1164 
<span class="line-modified">1165 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1166 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanBufferSizeWillChangeTo(size_t newSize)</span>
1167 {
1168 #if ASAN_ENABLED
1169     if (!buffer())
1170         return;
1171 
1172     // Change allowed range.
1173     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size(), buffer() + newSize);
1174 #else
1175     UNUSED_PARAM(newSize);
1176 #endif
1177 }
1178 
<span class="line-modified">1179 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1180 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveCapacity(size_t newCapacity)</span>
1181 {
1182     if (newCapacity &lt;= capacity())
1183         return;
1184     T* oldBuffer = begin();
1185     T* oldEnd = end();
1186 
1187     asanSetBufferSizeToFullCapacity();
1188 
1189     Base::allocateBuffer(newCapacity);
1190     ASSERT(begin());
1191 
1192     asanSetInitialBufferSizeTo(size());
1193 
1194     TypeOperations::move(oldBuffer, oldEnd, begin());
1195     Base::deallocateBuffer(oldBuffer);
1196 }
1197 
<span class="line-modified">1198 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1199 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryReserveCapacity(size_t newCapacity)</span>
1200 {
1201     if (newCapacity &lt;= capacity())
1202         return true;
1203     T* oldBuffer = begin();
1204     T* oldEnd = end();
1205 
1206     asanSetBufferSizeToFullCapacity();
1207 
1208     if (!Base::tryAllocateBuffer(newCapacity)) {
1209         asanSetInitialBufferSizeTo(size());
1210         return false;
1211     }
1212     ASSERT(begin());
1213 
1214     asanSetInitialBufferSizeTo(size());
1215 
1216     TypeOperations::move(oldBuffer, oldEnd, begin());
1217     Base::deallocateBuffer(oldBuffer);
1218     return true;
1219 }
1220 
<span class="line-modified">1221 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1222 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveInitialCapacity(size_t initialCapacity)</span>
1223 {
1224     ASSERT(!m_size);
1225     ASSERT(capacity() == inlineCapacity);
1226     if (initialCapacity &gt; inlineCapacity)
1227         Base::allocateBuffer(initialCapacity);
1228 }
1229 
<span class="line-modified">1230 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1231 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrinkCapacity(size_t newCapacity)</span>
1232 {
1233     if (newCapacity &gt;= capacity())
1234         return;
1235 
1236     if (newCapacity &lt; size())
1237         shrink(newCapacity);
1238 
1239     asanSetBufferSizeToFullCapacity();
1240 
1241     T* oldBuffer = begin();
1242     if (newCapacity &gt; 0) {
1243         if (Base::shouldReallocateBuffer(newCapacity)) {
1244             Base::reallocateBuffer(newCapacity);
1245             asanSetInitialBufferSizeTo(size());
1246             return;
1247         }
1248 
1249         T* oldEnd = end();
1250         Base::allocateBuffer(newCapacity);
1251         if (begin() != oldBuffer)
1252             TypeOperations::move(oldBuffer, oldEnd, begin());
1253     }
1254 
1255     Base::deallocateBuffer(oldBuffer);
1256     Base::restoreInlineBufferIfNeeded();
1257 
1258     asanSetInitialBufferSizeTo(size());
1259 }
1260 
<span class="line-modified">1261 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1262 template&lt;typename U&gt;
<span class="line-modified">1263 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(const U* data, size_t dataSize)</span>
1264 {
1265     size_t newSize = m_size + dataSize;
1266     if (newSize &gt; capacity()) {
1267         data = expandCapacity(newSize, data);
1268         ASSERT(begin());
1269     }
1270     if (newSize &lt; m_size)
1271         CRASH();
1272     asanBufferSizeWillChangeTo(newSize);
1273     T* dest = end();
1274     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1275     m_size = newSize;
1276 }
1277 
<span class="line-modified">1278 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1279 template&lt;typename U&gt;
<span class="line-modified">1280 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryAppend(const U* data, size_t dataSize)</span>
1281 {
1282     size_t newSize = m_size + dataSize;
1283     if (newSize &gt; capacity()) {
1284         data = tryExpandCapacity(newSize, data);
1285         if (!data)
1286             return false;
1287         ASSERT(begin());
1288     }
1289     if (newSize &lt; m_size)
1290         return false;
1291     asanBufferSizeWillChangeTo(newSize);
1292     T* dest = end();
1293     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1294     m_size = newSize;
1295     return true;
1296 }
1297 
<span class="line-modified">1298 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1299 template&lt;typename U&gt;
<span class="line-modified">1300 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(U&amp;&amp; value)</span>
1301 {
1302     if (size() != capacity()) {
1303         asanBufferSizeWillChangeTo(m_size + 1);
1304         new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1305         ++m_size;
1306         return;
1307     }
1308 
1309     appendSlowCase(std::forward&lt;U&gt;(value));
1310 }
1311 
<span class="line-modified">1312 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1313 template&lt;typename... Args&gt;
<span class="line-modified">1314 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppend(Args&amp;&amp;... args)</span>
1315 {
1316     if (size() != capacity()) {
1317         asanBufferSizeWillChangeTo(m_size + 1);
1318         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1319         ++m_size;
1320         return;
1321     }
1322 
1323     constructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1324 }
1325 
<span class="line-modified">1326 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1327 template&lt;typename... Args&gt;
<span class="line-modified">1328 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppend(Args&amp;&amp;... args)</span>
1329 {
1330     if (size() != capacity()) {
1331         asanBufferSizeWillChangeTo(m_size + 1);
1332         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1333         ++m_size;
1334         return true;
1335     }
1336 
1337     return tryConstructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1338 }
1339 
<span class="line-modified">1340 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1341 template&lt;typename U&gt;
<span class="line-modified">1342 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendSlowCase(U&amp;&amp; value)</span>
1343 {
1344     ASSERT(size() == capacity());
1345 
1346     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1347     ptr = expandCapacity(size() + 1, ptr);
1348     ASSERT(begin());
1349 
1350     asanBufferSizeWillChangeTo(m_size + 1);
1351     new (NotNull, end()) T(std::forward&lt;U&gt;(*ptr));
1352     ++m_size;
1353 }
1354 
<span class="line-modified">1355 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1356 template&lt;typename... Args&gt;
<span class="line-modified">1357 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)</span>
1358 {
1359     ASSERT(size() == capacity());
1360 
1361     expandCapacity(size() + 1);
1362     ASSERT(begin());
1363 
1364     asanBufferSizeWillChangeTo(m_size + 1);
1365     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1366     ++m_size;
1367 }
1368 
<span class="line-modified">1369 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1370 template&lt;typename... Args&gt;
<span class="line-modified">1371 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)</span>
1372 {
1373     ASSERT(size() == capacity());
1374 
1375     if (UNLIKELY(!tryExpandCapacity(size() + 1)))
1376         return false;
1377     ASSERT(begin());
1378 
1379     asanBufferSizeWillChangeTo(m_size + 1);
1380     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1381     ++m_size;
1382     return true;
1383 }
1384 
1385 // This version of append saves a branch in the case where you know that the
1386 // vector&#39;s capacity is large enough for the append to succeed.
1387 
<span class="line-modified">1388 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1389 template&lt;typename U&gt;
<span class="line-modified">1390 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedAppend(U&amp;&amp; value)</span>
1391 {
1392     ASSERT(size() &lt; capacity());
1393 
1394     asanBufferSizeWillChangeTo(m_size + 1);
1395 
1396     new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1397     ++m_size;
1398 }
1399 
<span class="line-modified">1400 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1401 template&lt;typename... Args&gt;
<span class="line-modified">1402 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedConstructAndAppend(Args&amp;&amp;... args)</span>
1403 {
1404     ASSERT(size() &lt; capacity());
1405 
1406     asanBufferSizeWillChangeTo(m_size + 1);
1407 
1408     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1409     ++m_size;
1410 }
1411 
<span class="line-modified">1412 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1413 template&lt;typename U, size_t otherCapacity&gt;
<span class="line-modified">1414 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)</span>
1415 {
1416     append(val.begin(), val.size());
1417 }
1418 
<span class="line-modified">1419 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-added">1420 template&lt;typename U, size_t otherCapacity&gt;</span>
<span class="line-added">1421 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp; val)</span>
<span class="line-added">1422 {</span>
<span class="line-added">1423     size_t newSize = m_size + val.size();</span>
<span class="line-added">1424     if (newSize &gt; capacity())</span>
<span class="line-added">1425         expandCapacity(newSize);</span>
<span class="line-added">1426     for (auto&amp; item : val)</span>
<span class="line-added">1427         uncheckedAppend(WTFMove(item));</span>
<span class="line-added">1428 }</span>
<span class="line-added">1429 </span>
<span class="line-added">1430 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1431 template&lt;typename U&gt;
<span class="line-modified">1432 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, const U* data, size_t dataSize)</span>
1433 {
1434     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1435     size_t newSize = m_size + dataSize;
1436     if (newSize &gt; capacity()) {
1437         data = expandCapacity(newSize, data);
1438         ASSERT(begin());
1439     }
1440     if (newSize &lt; m_size)
1441         CRASH();
1442     asanBufferSizeWillChangeTo(newSize);
1443     T* spot = begin() + position;
1444     TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
1445     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), spot);
1446     m_size = newSize;
1447 }
1448 
<span class="line-modified">1449 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1450 template&lt;typename U&gt;
<span class="line-modified">1451 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, U&amp;&amp; value)</span>
1452 {
1453     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1454 
1455     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1456     if (size() == capacity()) {
1457         ptr = expandCapacity(size() + 1, ptr);
1458         ASSERT(begin());
1459     }
1460 
1461     asanBufferSizeWillChangeTo(m_size + 1);
1462 
1463     T* spot = begin() + position;
1464     TypeOperations::moveOverlapping(spot, end(), spot + 1);
1465     new (NotNull, spot) T(std::forward&lt;U&gt;(*ptr));
1466     ++m_size;
1467 }
1468 
<span class="line-modified">1469 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1470 template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt;</span>
<span class="line-modified">1471 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp; val)</span>
1472 {
1473     insert(position, val.begin(), val.size());
1474 }
1475 
<span class="line-modified">1476 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1477 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position)</span>
1478 {
1479     ASSERT_WITH_SECURITY_IMPLICATION(position &lt; size());
1480     T* spot = begin() + position;
1481     spot-&gt;~T();
1482     TypeOperations::moveOverlapping(spot + 1, end(), spot);
1483     asanBufferSizeWillChangeTo(m_size - 1);
1484     --m_size;
1485 }
1486 
<span class="line-modified">1487 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1488 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position, size_t length)</span>
1489 {
1490     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1491     ASSERT_WITH_SECURITY_IMPLICATION(position + length &lt;= size());
1492     T* beginSpot = begin() + position;
1493     T* endSpot = beginSpot + length;
1494     TypeOperations::destruct(beginSpot, endSpot);
1495     TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
1496     asanBufferSizeWillChangeTo(m_size - length);
1497     m_size -= length;
1498 }
1499 
<span class="line-modified">1500 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1501 template&lt;typename U&gt;
<span class="line-modified">1502 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirst(const U&amp; value)</span>
1503 {
1504     return removeFirstMatching([&amp;value] (const T&amp; current) {
1505         return current == value;
1506     });
1507 }
1508 
<span class="line-modified">1509 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1510 template&lt;typename MatchFunction&gt;
<span class="line-modified">1511 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
1512 {
1513     for (size_t i = startIndex; i &lt; size(); ++i) {
1514         if (matches(at(i))) {
1515             remove(i);
1516             return true;
1517         }
1518     }
1519     return false;
1520 }
1521 
<span class="line-modified">1522 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1523 template&lt;typename U&gt;
<span class="line-modified">1524 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAll(const U&amp; value)</span>
1525 {
1526     return removeAllMatching([&amp;value] (const T&amp; current) {
1527         return current == value;
1528     });
1529 }
1530 
<span class="line-modified">1531 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1532 template&lt;typename MatchFunction&gt;
<span class="line-modified">1533 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
1534 {
1535     iterator holeBegin = end();
1536     iterator holeEnd = end();
1537     unsigned matchCount = 0;
1538     for (auto it = begin() + startIndex, itEnd = end(); it &lt; itEnd; ++it) {
1539         if (matches(*it)) {
1540             if (holeBegin == end())
1541                 holeBegin = it;
1542             else if (holeEnd != it) {
1543                 TypeOperations::moveOverlapping(holeEnd, it, holeBegin);
1544                 holeBegin += it - holeEnd;
1545             }
1546             holeEnd = it + 1;
1547             it-&gt;~T();
1548             ++matchCount;
1549         }
1550     }
1551     if (holeEnd != end())
1552         TypeOperations::moveOverlapping(holeEnd, end(), holeBegin);
1553     asanBufferSizeWillChangeTo(m_size - matchCount);
1554     m_size -= matchCount;
1555     return matchCount;
1556 }
1557 
<span class="line-modified">1558 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1559 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverse()</span>
1560 {
1561     for (size_t i = 0; i &lt; m_size / 2; ++i)
1562         std::swap(at(i), at(m_size - 1 - i));
1563 }
1564 
<span class="line-modified">1565 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1566 template&lt;typename MapFunction, typename R&gt;
<span class="line-modified">1567 inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::map(MapFunction mapFunction) const</span>
1568 {
1569     Vector&lt;R&gt; result;
1570     result.reserveInitialCapacity(size());
1571     for (size_t i = 0; i &lt; size(); ++i)
1572         result.uncheckedAppend(mapFunction(at(i)));
1573     return result;
1574 }
1575 
<span class="line-modified">1576 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1577 inline MallocPtr&lt;T, Malloc&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::releaseBuffer()</span>
1578 {
1579     // FIXME: Find a way to preserve annotations on the returned buffer.
1580     // ASan requires that all annotations are removed before deallocation,
1581     // and MallocPtr doesn&#39;t implement that.
1582     asanSetBufferSizeToFullCapacity();
1583 
1584     auto buffer = Base::releaseBuffer();
1585     if (inlineCapacity &amp;&amp; !buffer &amp;&amp; m_size) {
1586         // If the vector had some data, but no buffer to release,
1587         // that means it was using the inline buffer. In that case,
1588         // we create a brand new buffer so the caller always gets one.
1589         size_t bytes = m_size * sizeof(T);
<span class="line-modified">1590         buffer = adoptMallocPtr&lt;T, Malloc&gt;(static_cast&lt;T*&gt;(Malloc::malloc(bytes)));</span>
1591         memcpy(buffer.get(), data(), bytes);
1592     }
1593     m_size = 0;
1594     // FIXME: Should we call Base::restoreInlineBufferIfNeeded() here?
1595     return buffer;
1596 }
1597 
<span class="line-modified">1598 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1599 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::checkConsistency()</span>
1600 {
<span class="line-modified">1601 #if ASSERT_ENABLED</span>
1602     for (size_t i = 0; i &lt; size(); ++i)
1603         ValueCheck&lt;T&gt;::checkConsistency(at(i));
1604 #endif
1605 }
1606 
<span class="line-modified">1607 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1608 inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; b)</span>
1609 {
1610     a.swap(b);
1611 }
1612 
<span class="line-modified">1613 template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;</span>
<span class="line-modified">1614 bool operator==(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)</span>
1615 {
1616     if (a.size() != b.size())
1617         return false;
1618 
1619     return VectorTypeOperations&lt;T&gt;::compare(a.data(), b.data(), a.size());
1620 }
1621 
<span class="line-modified">1622 template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;</span>
<span class="line-modified">1623 inline bool operator!=(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)</span>
1624 {
1625     return !(a == b);
1626 }
1627 
<span class="line-modified">1628 #if ASSERT_ENABLED</span>
1629 template&lt;typename T&gt; struct ValueCheck&lt;Vector&lt;T&gt;&gt; {
1630     typedef Vector&lt;T&gt; TraitType;
1631     static void checkConsistency(const Vector&lt;T&gt;&amp; v)
1632     {
1633         v.checkConsistency();
1634     }
1635 };
<span class="line-modified">1636 #endif // ASSERT_ENABLED</span>
1637 
<span class="line-modified">1638 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
1639 template&lt;typename U&gt;
<span class="line-modified">1640 inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::isolatedCopy() const</span>
1641 {
1642     Vector&lt;U&gt; copy;
1643     copy.reserveInitialCapacity(size());
1644     for (const auto&amp; element : *this)
1645         copy.uncheckedAppend(element.isolatedCopy());
1646     return copy;
1647 }
1648 
1649 template&lt;typename VectorType, typename Func&gt;
1650 size_t removeRepeatedElements(VectorType&amp; vector, const Func&amp; func)
1651 {
1652     auto end = std::unique(vector.begin(), vector.end(), func);
1653     size_t newSize = end - vector.begin();
1654     vector.shrink(newSize);
1655     return newSize;
1656 }
1657 
<span class="line-modified">1658 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1659 size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; vector)</span>
1660 {
1661     return removeRepeatedElements(vector, [] (T&amp; a, T&amp; b) { return a == b; });
1662 }
1663 
1664 template&lt;typename SourceType&gt;
1665 struct CollectionInspector {
1666     using RealSourceType = typename std::remove_reference&lt;SourceType&gt;::type;
1667     using IteratorType = decltype(std::begin(std::declval&lt;RealSourceType&gt;()));
1668     using SourceItemType = typename std::iterator_traits&lt;IteratorType&gt;::value_type;
1669 };
1670 
1671 template&lt;typename MapFunction, typename SourceType, typename Enable = void&gt;
1672 struct Mapper {
1673     using SourceItemType = typename CollectionInspector&lt;SourceType&gt;::SourceItemType;
1674     using DestinationItemType = typename std::result_of&lt;MapFunction(SourceItemType&amp;)&gt;::type;
1675 
1676     static Vector&lt;DestinationItemType&gt; map(SourceType source, const MapFunction&amp; mapFunction)
1677     {
1678         Vector&lt;DestinationItemType&gt; result;
1679         // FIXME: Use std::size when available on all compilers.
</pre>
</td>
</tr>
</table>
<center><a href="Variant.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VectorTraits.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
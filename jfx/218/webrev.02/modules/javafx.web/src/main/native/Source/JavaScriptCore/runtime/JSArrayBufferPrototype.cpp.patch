diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferPrototype.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferPrototype.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferPrototype.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferPrototype.cpp
@@ -33,104 +33,103 @@
 #include "JSCInlines.h"
 #include "TypedArrayAdaptors.h"
 
 namespace JSC {
 
-static EncodedJSValue JSC_HOST_CALL arrayBufferProtoFuncSlice(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL arrayBufferProtoFuncSlice(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSFunction* callee = jsCast<JSFunction*>(exec->jsCallee());
-
-    JSArrayBuffer* thisObject = jsDynamicCast<JSArrayBuffer*>(vm, exec->thisValue());
+    JSArrayBuffer* thisObject = jsDynamicCast<JSArrayBuffer*>(vm, callFrame->thisValue());
     if (!thisObject || thisObject->impl()->isShared())
-        return throwVMTypeError(exec, scope, "Receiver of slice must be an ArrayBuffer."_s);
+        return throwVMTypeError(globalObject, scope, "Receiver of slice must be an ArrayBuffer."_s);
 
-    double begin = exec->argument(0).toInteger(exec);
+    double begin = callFrame->argument(0).toInteger(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     double end;
-    if (!exec->argument(1).isUndefined()) {
-        end = exec->uncheckedArgument(1).toInteger(exec);
+    if (!callFrame->argument(1).isUndefined()) {
+        end = callFrame->uncheckedArgument(1).toInteger(globalObject);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     } else
         end = thisObject->impl()->byteLength();
 
     auto newBuffer = thisObject->impl()->slice(begin, end);
+    if (!newBuffer)
+        return JSValue::encode(throwOutOfMemoryError(globalObject, scope));
 
-    Structure* structure = callee->globalObject(vm)->arrayBufferStructure(newBuffer->sharingMode());
+    Structure* structure = globalObject->arrayBufferStructure(newBuffer->sharingMode());
 
     JSArrayBuffer* result = JSArrayBuffer::create(vm, structure, WTFMove(newBuffer));
 
     return JSValue::encode(result);
 }
 
 // http://tc39.github.io/ecmascript_sharedmem/shmem.html#sec-get-arraybuffer.prototype.bytelength
-static EncodedJSValue JSC_HOST_CALL arrayBufferProtoGetterFuncByteLength(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL arrayBufferProtoGetterFuncByteLength(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!thisValue.isObject())
-        return throwVMTypeError(exec, scope, "Receiver should be an array buffer but was not an object"_s);
+        return throwVMTypeError(globalObject, scope, "Receiver should be an array buffer but was not an object"_s);
 
     auto* thisObject = jsDynamicCast<JSArrayBuffer*>(vm, thisValue);
     if (!thisObject)
-        return throwVMTypeError(exec, scope, "Receiver should be an array buffer"_s);
+        return throwVMTypeError(globalObject, scope, "Receiver should be an array buffer"_s);
     if (thisObject->isShared())
-        return throwVMTypeError(exec, scope, "Receiver should not be a shared array buffer"_s);
+        return throwVMTypeError(globalObject, scope, "Receiver should not be a shared array buffer"_s);
 
     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(thisObject->impl()->byteLength())));
 }
 
 // http://tc39.github.io/ecmascript_sharedmem/shmem.html#StructuredData.SharedArrayBuffer.prototype.get_byteLength
-static EncodedJSValue JSC_HOST_CALL sharedArrayBufferProtoGetterFuncByteLength(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL sharedArrayBufferProtoGetterFuncByteLength(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (!thisValue.isObject())
-        return throwVMTypeError(exec, scope, "Receiver should be an array buffer but was not an object"_s);
+        return throwVMTypeError(globalObject, scope, "Receiver should be an array buffer but was not an object"_s);
 
     auto* thisObject = jsDynamicCast<JSArrayBuffer*>(vm, thisValue);
     if (!thisObject)
-        return throwVMTypeError(exec, scope, "Receiver should be an array buffer"_s);
+        return throwVMTypeError(globalObject, scope, "Receiver should be an array buffer"_s);
     if (!thisObject->isShared())
-        return throwVMTypeError(exec, scope, "Receiver should be a shared array buffer"_s);
+        return throwVMTypeError(globalObject, scope, "Receiver should be a shared array buffer"_s);
 
     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(thisObject->impl()->byteLength())));
 }
 
 const ClassInfo JSArrayBufferPrototype::s_info = {
     "ArrayBufferPrototype", &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrayBufferPrototype)
 };
 
-JSArrayBufferPrototype::JSArrayBufferPrototype(VM& vm, Structure* structure, ArrayBufferSharingMode sharingMode)
+JSArrayBufferPrototype::JSArrayBufferPrototype(VM& vm, Structure* structure)
     : Base(vm, structure)
-    , m_sharingMode(sharingMode)
 {
 }
 
-void JSArrayBufferPrototype::finishCreation(VM& vm, JSGlobalObject* globalObject)
+void JSArrayBufferPrototype::finishCreation(VM& vm, JSGlobalObject* globalObject, ArrayBufferSharingMode sharingMode)
 {
     Base::finishCreation(vm);
 
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->slice, arrayBufferProtoFuncSlice, static_cast<unsigned>(PropertyAttribute::DontEnum), 2);
-    putDirectWithoutTransition(vm, vm.propertyNames->toStringTagSymbol, jsString(vm, arrayBufferSharingModeName(m_sharingMode)), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
-    if (m_sharingMode == ArrayBufferSharingMode::Default)
+    putDirectWithoutTransition(vm, vm.propertyNames->toStringTagSymbol, jsString(vm, arrayBufferSharingModeName(sharingMode)), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
+    if (sharingMode == ArrayBufferSharingMode::Default)
         JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames->byteLength, arrayBufferProtoGetterFuncByteLength, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
     else
         JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames->byteLength, sharedArrayBufferProtoGetterFuncByteLength, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 }
 
 JSArrayBufferPrototype* JSArrayBufferPrototype::create(VM& vm, JSGlobalObject* globalObject, Structure* structure, ArrayBufferSharingMode sharingMode)
 {
     JSArrayBufferPrototype* prototype =
         new (NotNull, allocateCell<JSArrayBufferPrototype>(vm.heap))
-        JSArrayBufferPrototype(vm, structure, sharingMode);
-    prototype->finishCreation(vm, globalObject);
+        JSArrayBufferPrototype(vm, structure);
+    prototype->finishCreation(vm, globalObject, sharingMode);
     return prototype;
 }
 
 Structure* JSArrayBufferPrototype::createStructure(
     VM& vm, JSGlobalObject* globalObject, JSValue prototype)

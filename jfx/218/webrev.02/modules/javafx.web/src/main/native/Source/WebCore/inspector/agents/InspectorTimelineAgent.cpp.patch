diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp
@@ -34,10 +34,11 @@
 #include "InspectorTimelineAgent.h"
 
 #include "DOMWindow.h"
 #include "Event.h"
 #include "Frame.h"
+#include "InspectorAnimationAgent.h"
 #include "InspectorCPUProfilerAgent.h"
 #include "InspectorClient.h"
 #include "InspectorController.h"
 #include "InspectorMemoryAgent.h"
 #include "InspectorPageAgent.h"
@@ -47,12 +48,12 @@
 #include "PageScriptDebugServer.h"
 #include "RenderView.h"
 #include "ScriptState.h"
 #include "TimelineRecordFactory.h"
 #include "WebConsoleAgent.h"
+#include "WebDebuggerAgent.h"
 #include <JavaScriptCore/ConsoleMessage.h>
-#include <JavaScriptCore/InspectorDebuggerAgent.h>
 #include <JavaScriptCore/InspectorScriptProfilerAgent.h>
 #include <JavaScriptCore/ScriptBreakpoint.h>
 #include <wtf/Stopwatch.h>
 
 #if PLATFORM(IOS_FAMILY)
@@ -250,11 +251,11 @@
     // Complete all pending records to prevent discarding events that are currently in progress.
     while (!m_recordStack.isEmpty())
         didCompleteCurrentRecord(m_recordStack.last().type);
 #endif
 
-    clearRecordStack();
+    m_recordStack.clear();
 
     m_tracking = false;
     m_startedComposite = false;
     m_autoCapturePhase = AutoCapturePhase::None;
 
@@ -267,11 +268,11 @@
 double InspectorTimelineAgent::timestamp()
 {
     return m_environment.executionStopwatch()->elapsedTime().seconds();
 }
 
-void InspectorTimelineAgent::startFromConsole(JSC::ExecState* exec, const String& title)
+void InspectorTimelineAgent::startFromConsole(JSC::JSGlobalObject* exec, const String& title)
 {
     // Allow duplicate unnamed profiles. Disallow duplicate named profiles.
     if (!title.isEmpty()) {
         for (const TimelineRecordEntry& record : m_pendingConsoleProfileRecords) {
             String recordTitle;
@@ -291,11 +292,11 @@
         startProgrammaticCapture();
 
     m_pendingConsoleProfileRecords.append(createRecordEntry(TimelineRecordFactory::createConsoleProfileData(title), TimelineRecordType::ConsoleProfile, true, frameFromExecState(exec)));
 }
 
-void InspectorTimelineAgent::stopFromConsole(JSC::ExecState*, const String& title)
+void InspectorTimelineAgent::stopFromConsole(JSC::JSGlobalObject*, const String& title)
 {
     // Stop profiles in reverse order. If the title is empty, then stop the last profile.
     // Otherwise, match the title of the profile to stop.
     for (int i = m_pendingConsoleProfileRecords.size() - 1; i >= 0; --i) {
         const TimelineRecordEntry& record = m_pendingConsoleProfileRecords[i];
@@ -335,10 +336,13 @@
     pushCurrentRecord(TimelineRecordFactory::createEventDispatchData(event), TimelineRecordType::EventDispatch, false, frame);
 }
 
 void InspectorTimelineAgent::didDispatchEvent(bool defaultPrevented)
 {
+    if (m_recordStack.isEmpty())
+        return;
+
     auto& entry = m_recordStack.last();
     ASSERT(entry.type == TimelineRecordType::EventDispatch);
     entry.data->setBoolean("defaultPrevented"_s, defaultPrevented);
 
     didCompleteCurrentRecord(TimelineRecordType::EventDispatch);
@@ -403,10 +407,13 @@
     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Paint, true, &frame);
 }
 
 void InspectorTimelineAgent::didPaint(RenderObject& renderer, const LayoutRect& clipRect)
 {
+    if (m_recordStack.isEmpty())
+        return;
+
     TimelineRecordEntry& entry = m_recordStack.last();
     ASSERT(entry.type == TimelineRecordType::Paint);
     FloatQuad quad;
     localToPageQuad(renderer, clipRect, &quad);
     entry.data = TimelineRecordFactory::createPaintData(quad);
@@ -470,13 +477,13 @@
         return;
 
     m_autoCapturePhase = AutoCapturePhase::BeforeLoad;
 
     // Pre-emptively disable breakpoints. The frontend must re-enable them.
-    if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
+    if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {
         ErrorString ignored;
-        debuggerAgent->setBreakpointsActive(ignored, false);
+        webDebuggerAgent->setBreakpointsActive(ignored, false);
     }
 
     // Inform the frontend we started an auto capture. The frontend must stop capture.
     m_frontendDispatcher->autoCaptureStarted();
 
@@ -495,15 +502,15 @@
 void InspectorTimelineAgent::startProgrammaticCapture()
 {
     ASSERT(!m_tracking);
 
     // Disable breakpoints during programmatic capture.
-    if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
-        m_programmaticCaptureRestoreBreakpointActiveValue = debuggerAgent->breakpointsActive();
+    if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {
+        m_programmaticCaptureRestoreBreakpointActiveValue = webDebuggerAgent->breakpointsActive();
         if (m_programmaticCaptureRestoreBreakpointActiveValue) {
             ErrorString ignored;
-            debuggerAgent->setBreakpointsActive(ignored, false);
+            webDebuggerAgent->setBreakpointsActive(ignored, false);
         }
     } else
         m_programmaticCaptureRestoreBreakpointActiveValue = false;
 
     toggleScriptProfilerInstrument(InstrumentState::Start); // Ensure JavaScript samping data.
@@ -520,13 +527,13 @@
     toggleTimelineInstrument(InstrumentState::Stop);
     toggleScriptProfilerInstrument(InstrumentState::Stop);
 
     // Re-enable breakpoints if they were enabled.
     if (m_programmaticCaptureRestoreBreakpointActiveValue) {
-        if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
+        if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {
             ErrorString ignored;
-            debuggerAgent->setBreakpointsActive(ignored, true);
+            webDebuggerAgent->setBreakpointsActive(ignored, true);
         }
     }
 }
 
 void InspectorTimelineAgent::toggleInstruments(InstrumentState state)
@@ -550,10 +557,13 @@
             break;
         }
         case Inspector::Protocol::Timeline::Instrument::Timeline:
             toggleTimelineInstrument(state);
             break;
+        case Inspector::Protocol::Timeline::Instrument::Animation:
+            toggleAnimationInstrument(state);
+            break;
         }
     }
 }
 
 void InspectorTimelineAgent::toggleScriptProfilerInstrument(InstrumentState state)
@@ -616,10 +626,21 @@
         internalStart();
     else
         internalStop();
 }
 
+void InspectorTimelineAgent::toggleAnimationInstrument(InstrumentState state)
+{
+    if (auto* animationAgent = m_instrumentingAgents.persistentInspectorAnimationAgent()) {
+        ErrorString ignored;
+        if (state == InstrumentState::Start)
+            animationAgent->startTracking(ignored);
+        else
+            animationAgent->stopTracking(ignored);
+    }
+}
+
 void InspectorTimelineAgent::didRequestAnimationFrame(int callbackId, Frame* frame)
 {
     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::RequestAnimationFrame, true, frame);
 }
 
@@ -648,13 +669,13 @@
     didCompleteCurrentRecord(TimelineRecordType::ObserverCallback);
 }
 
 // ScriptDebugListener
 
-void InspectorTimelineAgent::breakpointActionProbe(JSC::ExecState& state, const Inspector::ScriptBreakpointAction& action, unsigned /*batchId*/, unsigned sampleId, JSC::JSValue)
+void InspectorTimelineAgent::breakpointActionProbe(JSC::JSGlobalObject* lexicalGlobalObject, const Inspector::ScriptBreakpointAction& action, unsigned /*batchId*/, unsigned sampleId, JSC::JSValue)
 {
-    appendRecord(TimelineRecordFactory::createProbeSampleData(action, sampleId), TimelineRecordType::ProbeSample, false, frameFromExecState(&state));
+    appendRecord(TimelineRecordFactory::createProbeSampleData(action, sampleId), TimelineRecordType::ProbeSample, false, frameFromExecState(lexicalGlobalObject));
 }
 
 static Inspector::Protocol::Timeline::EventType toProtocol(TimelineRecordType type)
 {
     switch (type) {
@@ -793,16 +814,10 @@
 void InspectorTimelineAgent::pushCurrentRecord(RefPtr<JSON::Object>&& data, TimelineRecordType type, bool captureCallStack, Frame* frame)
 {
     pushCurrentRecord(createRecordEntry(WTFMove(data), type, captureCallStack, frame));
 }
 
-void InspectorTimelineAgent::clearRecordStack()
-{
-    m_recordStack.clear();
-    m_id++;
-}
-
 void InspectorTimelineAgent::localToPageQuad(const RenderObject& renderer, const LayoutRect& rect, FloatQuad* quad)
 {
     const FrameView& frameView = renderer.view().frameView();
     FloatQuad absolute = renderer.localToAbsoluteQuad(FloatQuad(rect));
     quad->setP1(frameView.contentsToRootView(roundedIntPoint(absolute.p1())));

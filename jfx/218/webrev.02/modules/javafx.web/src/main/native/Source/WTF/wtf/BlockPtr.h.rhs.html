<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/BlockPtr.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;Block.h&gt;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &lt;objc/runtime.h&gt;</span>
 30 #include &lt;utility&gt;
 31 #include &lt;wtf/Assertions.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
 33 
 34 #if __has_include(&lt;ptrauth.h&gt;)
 35 #include &lt;ptrauth.h&gt;
 36 #define WTF_COPY_FUNCTION_POINTER_QUALIFIER __ptrauth_block_copy_helper
 37 #define WTF_DISPOSE_FUNCTION_POINTER_QUALIFIER __ptrauth_block_destroy_helper
 38 #define WTF_INVOKE_FUNCTION_POINTER_QUALIFIER __ptrauth_block_invocation_pointer
 39 #else
 40 #define WTF_COPY_FUNCTION_POINTER_QUALIFIER
 41 #define WTF_DISPOSE_FUNCTION_POINTER_QUALIFIER
 42 #define WTF_INVOKE_FUNCTION_POINTER_QUALIFIER
 43 #endif
 44 
 45 namespace WTF {
 46 
<a name="2" id="anc2"></a>

 47 template&lt;typename&gt; class BlockPtr;
 48 
 49 template&lt;typename R, typename... Args&gt;
 50 class BlockPtr&lt;R (Args...)&gt; {
 51 public:
 52     using BlockType = R (^)(Args...);
 53 
 54     template&lt;typename F&gt;
 55     static BlockPtr fromCallable(F function)
 56     {
 57         struct Descriptor {
 58             uintptr_t reserved;
 59             uintptr_t size;
 60             void (*WTF_COPY_FUNCTION_POINTER_QUALIFIER copy)(void *dst, const void *src);
 61             void (*WTF_DISPOSE_FUNCTION_POINTER_QUALIFIER dispose)(const void *);
 62         };
 63 
 64         struct Block {
 65             void* isa;
 66             int32_t flags;
 67             int32_t reserved;
 68             R (*WTF_INVOKE_FUNCTION_POINTER_QUALIFIER invoke)(void *, Args...);
 69             const struct Descriptor* descriptor;
 70             F f;
 71         };
 72 
 73         static const Descriptor descriptor {
 74             0,
 75             sizeof(Block),
 76 
 77             // We keep the copy function null - the block is already on the heap
 78             // so it should never be copied.
 79             nullptr,
 80 
 81             [](const void* ptr) {
 82                 static_cast&lt;Block*&gt;(const_cast&lt;void*&gt;(ptr))-&gt;f.~F();
 83             }
 84         };
 85 
 86         Block* block = static_cast&lt;Block*&gt;(malloc(sizeof(Block)));
<a name="3" id="anc3"></a><span class="line-modified"> 87         block-&gt;isa = objc_getClass(&quot;__NSMallocBlock__&quot;);</span>
 88 
 89         enum {
 90             BLOCK_NEEDS_FREE = (1 &lt;&lt; 24),
 91             BLOCK_HAS_COPY_DISPOSE = (1 &lt;&lt; 25),
 92         };
 93         const unsigned retainCount = 1;
 94 
 95         block-&gt;flags = BLOCK_HAS_COPY_DISPOSE | BLOCK_NEEDS_FREE | (retainCount &lt;&lt; 1);
 96         block-&gt;reserved = 0;
 97         block-&gt;invoke = [](void *ptr, Args... args) -&gt; R {
 98             return static_cast&lt;Block*&gt;(ptr)-&gt;f(std::forward&lt;Args&gt;(args)...);
 99         };
100         block-&gt;descriptor = &amp;descriptor;
101 
102         new (&amp;block-&gt;f) F { std::move(function) };
103 
104 #if __has_feature(objc_arc)
105         return BlockPtr { (__bridge_transfer BlockType)block };
106 #else
107         BlockPtr blockPtr;
108         blockPtr.m_block = reinterpret_cast&lt;BlockType&gt;(block);
109         return blockPtr;
110 #endif
111     }
112 
113     BlockPtr()
114         : m_block(nullptr)
115     {
116     }
117 
118     BlockPtr(BlockType block)
119 #if __has_feature(objc_arc)
120         : m_block(WTFMove(block))
121 #else
122         : m_block(Block_copy(block))
123 #endif
124     {
125     }
126 
127     BlockPtr(const BlockPtr&amp; other)
128 #if __has_feature(objc_arc)
129         : m_block(other.m_block)
130 #else
131         : m_block(Block_copy(other.m_block))
132 #endif
133     {
134     }
135 
136     BlockPtr(BlockPtr&amp;&amp; other)
137         : m_block(std::exchange(other.m_block, nullptr))
138     {
139     }
140 
141     ~BlockPtr()
142     {
143 #if !__has_feature(objc_arc)
144         Block_release(m_block);
145 #endif
146     }
147 
148     BlockPtr&amp; operator=(const BlockPtr&amp; other)
149     {
150 #if __has_feature(objc_arc)
151         m_block = other.m_block;
152 #else
153         if (this != &amp;other) {
154             Block_release(m_block);
155             m_block = Block_copy(other.m_block);
156         }
157 #endif
158 
159         return *this;
160     }
161 
162     BlockPtr&amp; operator=(BlockPtr&amp;&amp; other)
163     {
164         ASSERT(this != &amp;other);
165 
166 #if !__has_feature(objc_arc)
167         Block_release(m_block);
168 #endif
169         m_block = std::exchange(other.m_block, nullptr);
170 
171         return *this;
172     }
173 
174     BlockType get() const { return m_block; }
175 
176     explicit operator bool() const { return m_block; }
177     bool operator!() const { return !m_block; }
178 
179     R operator()(Args... arguments) const
180     {
181         ASSERT(m_block);
182 
183         return m_block(std::forward&lt;Args&gt;(arguments)...);
184     }
185 
186 private:
187     BlockType m_block;
188 };
189 
190 template&lt;typename R, typename... Args&gt;
191 inline BlockPtr&lt;R (Args...)&gt; makeBlockPtr(R (^block)(Args...))
192 {
193     return BlockPtr&lt;R (Args...)&gt;(block);
194 }
195 
196 template&lt;typename F, typename Class, typename R, typename... Args&gt;
197 inline auto makeBlockPtr(F&amp;&amp; function, R (Class::*)(Args...) const)
198 {
199     return BlockPtr&lt;R (Args...)&gt;::fromCallable(std::forward&lt;F&gt;(function));
200 }
201 
202 template&lt;typename F, typename Class, typename R, typename... Args&gt;
203 inline auto makeBlockPtr(F&amp;&amp; function, R (Class::*)(Args...))
204 {
205     return BlockPtr&lt;R (Args...)&gt;::fromCallable(std::forward&lt;F&gt;(function));
206 }
207 
208 template&lt;typename F&gt;
209 inline auto makeBlockPtr(F&amp;&amp; function)
210 {
211     return makeBlockPtr(std::forward&lt;F&gt;(function), &amp;F::operator());
212 }
213 
214 }
215 
216 using WTF::BlockPtr;
217 using WTF::makeBlockPtr;
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
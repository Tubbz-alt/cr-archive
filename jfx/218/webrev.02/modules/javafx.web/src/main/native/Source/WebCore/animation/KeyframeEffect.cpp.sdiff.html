<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentTimeline.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeEffect.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;KeyframeEffect.h&quot;
  28 
  29 #include &quot;Animation.h&quot;
  30 #include &quot;CSSAnimation.h&quot;
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSKeyframeRule.h&quot;
  33 #include &quot;CSSPropertyAnimation.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSStyleDeclaration.h&quot;
  36 #include &quot;CSSTimingFunctionValue.h&quot;
  37 #include &quot;CSSTransition.h&quot;
  38 #include &quot;Element.h&quot;
  39 #include &quot;FontCascade.h&quot;
  40 #include &quot;FrameView.h&quot;
  41 #include &quot;GeometryUtilities.h&quot;

  42 #include &quot;JSCompositeOperation.h&quot;
  43 #include &quot;JSCompositeOperationOrAuto.h&quot;

  44 #include &quot;JSKeyframeEffect.h&quot;


  45 #include &quot;RenderBox.h&quot;
  46 #include &quot;RenderBoxModelObject.h&quot;
  47 #include &quot;RenderElement.h&quot;
  48 #include &quot;RenderStyle.h&quot;


  49 #include &quot;StylePendingResources.h&quot;
  50 #include &quot;StyleResolver.h&quot;
  51 #include &quot;TimingFunction.h&quot;
  52 #include &quot;TranslateTransformOperation.h&quot;
  53 #include &quot;WillChangeData.h&quot;
  54 #include &lt;JavaScriptCore/Exception.h&gt;
  55 #include &lt;wtf/UUID.h&gt;

  56 
  57 namespace WebCore {
  58 using namespace JSC;
  59 
  60 static inline void invalidateElement(Element* element)
  61 {
  62     if (element)
  63         element-&gt;invalidateStyle();
  64 }
  65 
  66 static inline String CSSPropertyIDToIDLAttributeName(CSSPropertyID cssPropertyId)
  67 {
  68     // https://drafts.csswg.org/web-animations-1/#animation-property-name-to-idl-attribute-name
  69     // 1. If property follows the &lt;custom-property-name&gt; production, return property.
  70     // FIXME: We don&#39;t handle custom properties yet.
  71 
  72     // 2. If property refers to the CSS float property, return the string &quot;cssFloat&quot;.
  73     if (cssPropertyId == CSSPropertyFloat)
  74         return &quot;cssFloat&quot;;
  75 
</pre>
<hr />
<pre>
 140     //    4. Set the computed keyframe offset of keyframe to offsetA + (offsetB − offsetA) × index / n.
 141     size_t indexOfLastKeyframeWithNonNullOffset = 0;
 142     for (size_t i = 1; i &lt; keyframes.size(); ++i) {
 143         auto&amp; keyframe = keyframes[i];
 144         // Keyframes with a null offset that don&#39;t yet have a non-zero computed offset are keyframes
 145         // with an offset that needs to be computed.
 146         if (!keyframe.offset &amp;&amp; !keyframe.computedOffset)
 147             continue;
 148         if (indexOfLastKeyframeWithNonNullOffset != i - 1) {
 149             double lastNonNullOffset = keyframes[indexOfLastKeyframeWithNonNullOffset].computedOffset;
 150             double offsetDelta = keyframe.computedOffset - lastNonNullOffset;
 151             double offsetIncrement = offsetDelta / (i - indexOfLastKeyframeWithNonNullOffset);
 152             size_t indexOfFirstKeyframeWithNullOffset = indexOfLastKeyframeWithNonNullOffset + 1;
 153             for (size_t j = indexOfFirstKeyframeWithNullOffset; j &lt; i; ++j)
 154                 keyframes[j].computedOffset = lastNonNullOffset + (j - indexOfLastKeyframeWithNonNullOffset) * offsetIncrement;
 155         }
 156         indexOfLastKeyframeWithNonNullOffset = i;
 157     }
 158 }
 159 
<span class="line-modified"> 160 static inline ExceptionOr&lt;KeyframeEffect::KeyframeLikeObject&gt; processKeyframeLikeObject(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, bool allowLists)</span>
 161 {
 162     // https://drafts.csswg.org/web-animations-1/#process-a-keyframe-like-object
 163 
<span class="line-modified"> 164     VM&amp; vm = state.vm();</span>
 165     auto scope = DECLARE_THROW_SCOPE(vm);
 166 
 167     // 1. Run the procedure to convert an ECMAScript value to a dictionary type [WEBIDL] with keyframe input as the ECMAScript value as follows:
 168     //
 169     //    If allow lists is true, use the following dictionary type:
 170     //
 171     //    dictionary BasePropertyIndexedKeyframe {
 172     //        (double? or sequence&lt;double?&gt;)                                   offset = [];
 173     //        (DOMString or sequence&lt;DOMString&gt;)                               easing = [];
 174     //        (CompositeOperationOrAuto or sequence&lt;CompositeOperationOrAuto&gt;) composite = [];
 175     //    };
 176     //
 177     //    Otherwise, use the following dictionary type:
 178     //
 179     //    dictionary BaseKeyframe {
 180     //        double?                  offset = null;
 181     //        DOMString                easing = &quot;linear&quot;;
 182     //        CompositeOperationOrAuto composite = &quot;auto&quot;;
 183     //    };
 184     //
 185     //    Store the result of this procedure as keyframe output.
 186     KeyframeEffect::BasePropertyIndexedKeyframe baseProperties;
 187     if (allowLists)
<span class="line-modified"> 188         baseProperties = convert&lt;IDLDictionary&lt;KeyframeEffect::BasePropertyIndexedKeyframe&gt;&gt;(state, keyframesInput.get());</span>
 189     else {
<span class="line-modified"> 190         auto baseKeyframe = convert&lt;IDLDictionary&lt;KeyframeEffect::BaseKeyframe&gt;&gt;(state, keyframesInput.get());</span>
 191         if (baseKeyframe.offset)
 192             baseProperties.offset = baseKeyframe.offset.value();
 193         else
 194             baseProperties.offset = nullptr;
 195         baseProperties.easing = baseKeyframe.easing;
<span class="line-modified"> 196         baseProperties.composite = baseKeyframe.composite;</span>

 197     }
 198     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 199 
 200     KeyframeEffect::KeyframeLikeObject keyframeOuput;
 201     keyframeOuput.baseProperties = baseProperties;
 202 
 203     // 2. Build up a list of animatable properties as follows:
 204     //
 205     //    1. Let animatable properties be a list of property names (including shorthand properties that have longhand sub-properties
 206     //       that are animatable) that can be animated by the implementation.
 207     //    2. Convert each property name in animatable properties to the equivalent IDL attribute by applying the animation property
 208     //       name to IDL attribute name algorithm.
 209 
 210     // 3. Let input properties be the result of calling the EnumerableOwnNames operation with keyframe input as the object.
 211     PropertyNameArray inputProperties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified"> 212     JSObject::getOwnPropertyNames(keyframesInput.get(), &amp;state, inputProperties, EnumerationMode());</span>
 213 
 214     // 4. Make up a new list animation properties that consists of all of the properties that are in both input properties and animatable
 215     //    properties, or which are in input properties and conform to the &lt;custom-property-name&gt; production.
 216     Vector&lt;JSC::Identifier&gt; animationProperties;
 217     size_t numberOfProperties = inputProperties.size();
 218     for (size_t i = 0; i &lt; numberOfProperties; ++i) {
 219         if (CSSPropertyAnimation::isPropertyAnimatable(IDLAttributeNameToAnimationPropertyName(inputProperties[i].string())))
 220             animationProperties.append(inputProperties[i]);
 221     }
 222 
 223     // 5. Sort animation properties in ascending order by the Unicode codepoints that define each property name.
 224     std::sort(animationProperties.begin(), animationProperties.end(), [](auto&amp; lhs, auto&amp; rhs) {
 225         return lhs.string().utf8() &lt; rhs.string().utf8();
 226     });
 227 
 228     // 6. For each property name in animation properties,
 229     size_t numberOfAnimationProperties = animationProperties.size();
 230     for (size_t i = 0; i &lt; numberOfAnimationProperties; ++i) {
 231         // 1. Let raw value be the result of calling the [[Get]] internal method on keyframe input, with property name as the property
 232         //    key and keyframe input as the receiver.
<span class="line-modified"> 233         auto rawValue = keyframesInput-&gt;get(&amp;state, animationProperties[i]);</span>
 234 
 235         // 2. Check the completion record of raw value.
 236         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 237 
 238         // 3. Convert raw value to a DOMString or sequence of DOMStrings property values as follows:
 239         Vector&lt;String&gt; propertyValues;
 240         if (allowLists) {
 241             // If allow lists is true,
 242             // Let property values be the result of converting raw value to IDL type (DOMString or sequence&lt;DOMString&gt;)
 243             // using the procedures defined for converting an ECMAScript value to an IDL value [WEBIDL].
 244             // If property values is a single DOMString, replace property values with a sequence of DOMStrings with the original value of property
 245             // Values as the only element.
<span class="line-modified"> 246             if (rawValue.isString())</span>
<span class="line-modified"> 247                 propertyValues = { rawValue.toWTFString(&amp;state) };</span>
<span class="line-modified"> 248             else if (rawValue.isObject())</span>
<span class="line-modified"> 249                 propertyValues = convert&lt;IDLSequence&lt;IDLDOMString&gt;&gt;(state, rawValue);</span>
 250         } else {
 251             // Otherwise,
 252             // Let property values be the result of converting raw value to a DOMString using the procedure for converting an ECMAScript value to a DOMString.
<span class="line-modified"> 253             propertyValues = { convert&lt;IDLDOMString&gt;(state, rawValue) };</span>
 254         }
 255         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 256 
 257         // 4. Calculate the normalized property name as the result of applying the IDL attribute name to animation property name algorithm to property name.
 258         auto cssPropertyID = IDLAttributeNameToAnimationPropertyName(animationProperties[i].string());
 259 
 260         // 5. Add a property to to keyframe output with normalized property name as the property name, and property values as the property value.
 261         keyframeOuput.propertiesAndValues.append({ cssPropertyID, propertyValues });
 262     }
 263 
 264     // 7. Return keyframe output.
 265     return { WTFMove(keyframeOuput) };
 266 }
 267 
<span class="line-modified"> 268 static inline ExceptionOr&lt;void&gt; processIterableKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, JSValue method, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes)</span>
 269 {
 270     // 1. Let iter be GetIterator(object, method).
<span class="line-modified"> 271     forEachInIterable(state, keyframesInput.get(), method, [&amp;parsedKeyframes](VM&amp; vm, ExecState&amp; state, JSValue nextValue) -&gt; ExceptionOr&lt;void&gt; {</span>
 272         // Steps 2 through 6 are already implemented by forEachInIterable().
 273         auto scope = DECLARE_THROW_SCOPE(vm);
 274         if (!nextValue || !nextValue.isObject()) {
<span class="line-modified"> 275             throwException(&amp;state, scope, JSC::Exception::create(vm, createTypeError(&amp;state)));</span>
 276             return { };
 277         }
 278 
 279         // 7. Append to processed keyframes the result of running the procedure to process a keyframe-like object passing nextItem
 280         // as the keyframe input and with the allow lists flag set to false.
<span class="line-modified"> 281         auto processKeyframeLikeObjectResult = processKeyframeLikeObject(state, Strong&lt;JSObject&gt;(vm, nextValue.toObject(&amp;state)), false);</span>
 282         if (processKeyframeLikeObjectResult.hasException())
 283             return processKeyframeLikeObjectResult.releaseException();
 284         auto keyframeLikeObject = processKeyframeLikeObjectResult.returnValue();
 285 
 286         KeyframeEffect::ParsedKeyframe keyframeOutput;
 287 
 288         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only offset
 289         // alternatives we should expect are double and nullptr.
 290         if (WTF::holds_alternative&lt;double&gt;(keyframeLikeObject.baseProperties.offset))
 291             keyframeOutput.offset = WTF::get&lt;double&gt;(keyframeLikeObject.baseProperties.offset);
 292         else
 293             ASSERT(WTF::holds_alternative&lt;std::nullptr_t&gt;(keyframeLikeObject.baseProperties.offset));
 294 
 295         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only easing
 296         // alternative we should expect is String.
 297         ASSERT(WTF::holds_alternative&lt;String&gt;(keyframeLikeObject.baseProperties.easing));
 298         keyframeOutput.easing = WTF::get&lt;String&gt;(keyframeLikeObject.baseProperties.easing);
 299 
 300         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only composite
 301         // alternatives we should expect is CompositeOperationAuto.
<span class="line-modified"> 302         ASSERT(WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite));</span>
<span class="line-modified"> 303         keyframeOutput.composite = WTF::get&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite);</span>


 304 
 305         for (auto&amp; propertyAndValue : keyframeLikeObject.propertiesAndValues) {
 306             auto cssPropertyId = propertyAndValue.property;
 307             // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false,
 308             // there should only ever be a single value for a given property.
 309             ASSERT(propertyAndValue.values.size() == 1);
 310             auto stringValue = propertyAndValue.values[0];
 311             if (keyframeOutput.style-&gt;setProperty(cssPropertyId, stringValue))
 312                 keyframeOutput.unparsedStyle.set(cssPropertyId, stringValue);
 313         }
 314 
 315         parsedKeyframes.append(WTFMove(keyframeOutput));
 316 
 317         return { };
 318     });
 319 
 320     return { };
 321 }
 322 
<span class="line-modified"> 323 static inline ExceptionOr&lt;void&gt; processPropertyIndexedKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes, Vector&lt;String&gt;&amp; unusedEasings)</span>
 324 {
 325     // 1. Let property-indexed keyframe be the result of running the procedure to process a keyframe-like object passing object as the keyframe input.
<span class="line-modified"> 326     auto processKeyframeLikeObjectResult = processKeyframeLikeObject(state, WTFMove(keyframesInput), true);</span>
 327     if (processKeyframeLikeObjectResult.hasException())
 328         return processKeyframeLikeObjectResult.releaseException();
 329     auto propertyIndexedKeyframe = processKeyframeLikeObjectResult.returnValue();
 330 
 331     // 2. For each member, m, in property-indexed keyframe, perform the following steps:
 332     for (auto&amp; m : propertyIndexedKeyframe.propertiesAndValues) {
 333         // 1. Let property name be the key for m.
 334         auto propertyName = m.property;
 335         // 2. If property name is “composite”, or “easing”, or “offset”, skip the remaining steps in this loop and continue from the next member in property-indexed
 336         //    keyframe after m.
 337         //    We skip this test since we split those properties and the actual CSS properties that we&#39;re currently iterating over.
 338         // 3. Let property values be the value for m.
 339         auto propertyValues = m.values;
 340         // 4. Let property keyframes be an empty sequence of keyframes.
 341         Vector&lt;KeyframeEffect::ParsedKeyframe&gt; propertyKeyframes;
 342         // 5. For each value, v, in property values perform the following steps:
 343         for (auto&amp; v : propertyValues) {
 344             // 1. Let k be a new keyframe with a null keyframe offset.
 345             KeyframeEffect::ParsedKeyframe k;
 346             // 2. Add the property-value pair, property name → v, to k.
</pre>
<hr />
<pre>
 418         easings.append(&quot;linear&quot;);
 419 
 420     // 9. If easings has fewer items than property keyframes, repeat the elements in easings successively starting from the beginning of the list until easings has as many
 421     //    items as property keyframes.
 422     if (easings.size() &lt; parsedKeyframes.size()) {
 423         size_t initialNumberOfEasings = easings.size();
 424         for (i = initialNumberOfEasings; i &lt; parsedKeyframes.size(); ++i)
 425             easings.append(easings[i % initialNumberOfEasings]);
 426     }
 427 
 428     // 10. If easings has more items than property keyframes, store the excess items as unused easings.
 429     while (easings.size() &gt; parsedKeyframes.size())
 430         unusedEasings.append(easings.takeLast());
 431 
 432     // 11. Assign each value in easings to a property named “easing” on the keyframe with the corresponding position in property keyframes until the end of property keyframes
 433     //     is reached.
 434     for (size_t i = 0; i &lt; parsedKeyframes.size(); ++i)
 435         parsedKeyframes[i].easing = easings[i];
 436 
 437     // 12. If the “composite” member of the property-indexed keyframe is not an empty sequence:
<span class="line-modified"> 438     Vector&lt;CompositeOperationOrAuto&gt; compositeModes;</span>
<span class="line-modified"> 439     if (WTF::holds_alternative&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified"> 440         compositeModes = WTF::get&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite);</span>
<span class="line-modified"> 441     else if (WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified"> 442         compositeModes.append(WTF::get&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite));</span>
<span class="line-modified"> 443     if (!compositeModes.isEmpty()) {</span>
<span class="line-modified"> 444         // 1. Let composite modes be a sequence of CompositeOperationOrAuto values assigned from the “composite” member of property-indexed keyframe. If that member is a single</span>
<span class="line-modified"> 445         //    CompositeOperationOrAuto value operation, let composite modes be a sequence of length one, with the value of the “composite” as its single item.</span>
<span class="line-modified"> 446         // 2. As with easings, if composite modes has fewer items than processed keyframes, repeat the elements in composite modes successively starting from the beginning of</span>
<span class="line-modified"> 447         //    the list until composite modes has as many items as processed keyframes.</span>
<span class="line-modified"> 448         if (compositeModes.size() &lt; parsedKeyframes.size()) {</span>
<span class="line-modified"> 449             size_t initialNumberOfCompositeModes = compositeModes.size();</span>
<span class="line-modified"> 450             for (i = initialNumberOfCompositeModes; i &lt; parsedKeyframes.size(); ++i)</span>
<span class="line-modified"> 451                 compositeModes.append(compositeModes[i % initialNumberOfCompositeModes]);</span>
<span class="line-modified"> 452         }</span>
<span class="line-modified"> 453         // 3. Assign each value in composite modes that is not auto to the keyframe-specific composite operation on the keyframe with the corresponding position in processed</span>
<span class="line-modified"> 454         //    keyframes until the end of processed keyframes is reached.</span>
<span class="line-modified"> 455         for (size_t i = 0; i &lt; compositeModes.size() &amp;&amp; i &lt; parsedKeyframes.size(); ++i) {</span>
<span class="line-modified"> 456             if (compositeModes[i] != CompositeOperationOrAuto::Auto)</span>
<span class="line-modified"> 457                 parsedKeyframes[i].composite = compositeModes[i];</span>


 458         }
 459     }
 460 
 461     return { };
 462 }
 463 
<span class="line-modified"> 464 ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(ExecState&amp; state, Element* target, Strong&lt;JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt;&amp;&amp; options)</span>
 465 {
 466     auto keyframeEffect = adoptRef(*new KeyframeEffect(target));
 467 
 468     if (options) {
 469         OptionalEffectTiming timing;
 470         auto optionsValue = options.value();
 471         if (WTF::holds_alternative&lt;double&gt;(optionsValue)) {
 472             Variant&lt;double, String&gt; duration = WTF::get&lt;double&gt;(optionsValue);
 473             timing.duration = duration;
 474         } else {
 475             auto keyframeEffectOptions = WTF::get&lt;KeyframeEffectOptions&gt;(optionsValue);
 476             timing = {
 477                 keyframeEffectOptions.duration,
 478                 keyframeEffectOptions.iterations,
 479                 keyframeEffectOptions.delay,
 480                 keyframeEffectOptions.endDelay,
 481                 keyframeEffectOptions.iterationStart,
 482                 keyframeEffectOptions.easing,
 483                 keyframeEffectOptions.fill,
 484                 keyframeEffectOptions.direction
 485             };
 486         }
 487         auto updateTimingResult = keyframeEffect-&gt;updateTiming(timing);
 488         if (updateTimingResult.hasException())
 489             return updateTimingResult.releaseException();
 490     }
 491 
<span class="line-modified"> 492     auto processKeyframesResult = keyframeEffect-&gt;processKeyframes(state, WTFMove(keyframes));</span>
 493     if (processKeyframesResult.hasException())
 494         return processKeyframesResult.releaseException();
 495 
 496     return keyframeEffect;
 497 }
 498 
<span class="line-modified"> 499 ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSC::ExecState&amp;, Ref&lt;KeyframeEffect&gt;&amp;&amp; source)</span>
 500 {
 501     auto keyframeEffect = adoptRef(*new KeyframeEffect(nullptr));
 502     keyframeEffect-&gt;copyPropertiesFromSource(WTFMove(source));
 503     return keyframeEffect;
 504 }
 505 
 506 Ref&lt;KeyframeEffect&gt; KeyframeEffect::create(const Element&amp; target)
 507 {
 508     return adoptRef(*new KeyframeEffect(const_cast&lt;Element*&gt;(&amp;target)));
 509 }
 510 
 511 KeyframeEffect::KeyframeEffect(Element* target)
<span class="line-modified"> 512     : m_target(target)</span>
 513 {
 514 }
 515 
 516 void KeyframeEffect::copyPropertiesFromSource(Ref&lt;KeyframeEffect&gt;&amp;&amp; source)
 517 {
 518     m_target = source-&gt;m_target;
 519     m_compositeOperation = source-&gt;m_compositeOperation;
 520     m_iterationCompositeOperation = source-&gt;m_iterationCompositeOperation;
 521 
 522     Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
 523     for (auto&amp; sourceParsedKeyframe : source-&gt;m_parsedKeyframes) {
 524         ParsedKeyframe parsedKeyframe;
 525         parsedKeyframe.easing = sourceParsedKeyframe.easing;
 526         parsedKeyframe.offset = sourceParsedKeyframe.offset;
 527         parsedKeyframe.composite = sourceParsedKeyframe.composite;
 528         parsedKeyframe.unparsedStyle = sourceParsedKeyframe.unparsedStyle;
 529         parsedKeyframe.computedOffset = sourceParsedKeyframe.computedOffset;
 530         parsedKeyframe.timingFunction = sourceParsedKeyframe.timingFunction;
 531         parsedKeyframe.style = sourceParsedKeyframe.style-&gt;mutableCopy();
 532         parsedKeyframes.append(WTFMove(parsedKeyframe));
 533     }
 534     m_parsedKeyframes = WTFMove(parsedKeyframes);
 535 
 536     setFill(source-&gt;fill());
 537     setDelay(source-&gt;delay());
 538     setEndDelay(source-&gt;endDelay());
 539     setDirection(source-&gt;direction());
 540     setIterations(source-&gt;iterations());
 541     setTimingFunction(source-&gt;timingFunction());
 542     setIterationStart(source-&gt;iterationStart());
 543     setIterationDuration(source-&gt;iterationDuration());

 544 
 545     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
 546     for (auto&amp; keyframe : source-&gt;m_blendingKeyframes.keyframes()) {
 547         KeyframeValue keyframeValue(keyframe.key(), RenderStyle::clonePtr(*keyframe.style()));
 548         for (auto propertyId : keyframe.properties())
 549             keyframeValue.addProperty(propertyId);
 550         keyframeList.insert(WTFMove(keyframeValue));
 551     }
 552     setBlendingKeyframes(keyframeList);
 553 }
 554 
<span class="line-modified"> 555 Vector&lt;Strong&lt;JSObject&gt;&gt; KeyframeEffect::getKeyframes(ExecState&amp; state)</span>
 556 {
 557     // https://drafts.csswg.org/web-animations-1/#dom-keyframeeffectreadonly-getkeyframes
 558 
<span class="line-modified"> 559     auto lock = JSLockHolder { &amp;state };</span>
 560 
 561     // Since keyframes are represented by a partially open-ended dictionary type that is not currently able to be expressed with WebIDL,
 562     // the procedure used to prepare the result of this method is defined in prose below:
 563     //
 564     // 1. Let result be an empty sequence of objects.
 565     Vector&lt;Strong&lt;JSObject&gt;&gt; result;
 566 
 567     // 2. Let keyframes be the result of applying the procedure to compute missing keyframe offsets to the keyframes for this keyframe effect.
 568 
 569     // 3. For each keyframe in keyframes perform the following steps:
 570     if (is&lt;DeclarativeAnimation&gt;(animation())) {

 571         auto computedStyleExtractor = ComputedStyleExtractor(m_target.get());
 572         for (size_t i = 0; i &lt; m_blendingKeyframes.size(); ++i) {
 573             // 1. Initialize a dictionary object, output keyframe, using the following definition:
 574             //
 575             // dictionary BaseComputedKeyframe {
 576             //      double?                  offset = null;
 577             //      double                   computedOffset;
 578             //      DOMString                easing = &quot;linear&quot;;
 579             //      CompositeOperationOrAuto composite = &quot;auto&quot;;
 580             // };
 581 
 582             auto&amp; keyframe = m_blendingKeyframes[i];
 583 
 584             // 2. Set offset, computedOffset, easing members of output keyframe to the respective values keyframe offset, computed keyframe offset,
 585             // and keyframe-specific timing function of keyframe.
 586             BaseComputedKeyframe computedKeyframe;
 587             computedKeyframe.offset = keyframe.key();
 588             computedKeyframe.computedOffset = keyframe.key();
<span class="line-modified"> 589             // For CSS transitions, there are only two keyframes and the second keyframe should always report &quot;linear&quot;. In practice, this value</span>
<span class="line-modified"> 590             // has no bearing since, as the last keyframe, its value will never be used.</span>
<span class="line-removed"> 591             computedKeyframe.easing = is&lt;CSSTransition&gt;(animation()) &amp;&amp; i == 1 ? &quot;linear&quot; : timingFunctionForKeyframeAtIndex(0)-&gt;cssText();</span>
 592 
<span class="line-modified"> 593             auto outputKeyframe = convertDictionaryToJS(state, *jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject()), computedKeyframe);</span>
 594 
 595             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
 596             auto&amp; style = *keyframe.style();
 597             for (auto cssPropertyId : keyframe.properties()) {
 598                 if (cssPropertyId == CSSPropertyCustom)
 599                     continue;
 600                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
 601                 auto propertyName = CSSPropertyIDToIDLAttributeName(cssPropertyId);
 602                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
 603                 String idlValue = &quot;&quot;;
<span class="line-modified"> 604                 if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId))</span>
 605                     idlValue = cssValue-&gt;cssText();
 606                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified"> 607                 auto value = toJS&lt;IDLDOMString&gt;(state, idlValue);</span>
 608                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
 609                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified"> 610                 JSObject::defineOwnProperty(outputKeyframe, &amp;state, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
 611             }
 612 
 613             // 5. Append output keyframe to result.
<span class="line-modified"> 614             result.append(JSC::Strong&lt;JSC::JSObject&gt; { state.vm(), outputKeyframe });</span>
 615         }
 616     } else {
 617         for (size_t i = 0; i &lt; m_parsedKeyframes.size(); ++i) {
 618             // 1. Initialize a dictionary object, output keyframe, using the following definition:
 619             //
 620             // dictionary BaseComputedKeyframe {
 621             //      double?                  offset = null;
 622             //      double                   computedOffset;
 623             //      DOMString                easing = &quot;linear&quot;;
 624             //      CompositeOperationOrAuto composite = &quot;auto&quot;;
 625             // };
 626 
 627             auto&amp; parsedKeyframe = m_parsedKeyframes[i];
 628 
 629             // 2. Set offset, computedOffset, easing, composite members of output keyframe to the respective values keyframe offset, computed keyframe
 630             // offset, keyframe-specific timing function and keyframe-specific composite operation of keyframe.
 631             BaseComputedKeyframe computedKeyframe;
 632             computedKeyframe.offset = parsedKeyframe.offset;
 633             computedKeyframe.computedOffset = parsedKeyframe.computedOffset;
 634             computedKeyframe.easing = timingFunctionForKeyframeAtIndex(i)-&gt;cssText();
<span class="line-modified"> 635             computedKeyframe.composite = parsedKeyframe.composite;</span>

 636 
<span class="line-modified"> 637             auto outputKeyframe = convertDictionaryToJS(state, *jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject()), computedKeyframe);</span>
 638 
 639             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
 640             for (auto it = parsedKeyframe.unparsedStyle.begin(), end = parsedKeyframe.unparsedStyle.end(); it != end; ++it) {
 641                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
 642                 auto propertyName = CSSPropertyIDToIDLAttributeName(it-&gt;key);
 643                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
 644                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified"> 645                 auto value = toJS&lt;IDLDOMString&gt;(state, it-&gt;value);</span>
 646                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
 647                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified"> 648                 JSObject::defineOwnProperty(outputKeyframe, &amp;state, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
 649             }
 650 
 651             // 4. Append output keyframe to result.
<span class="line-modified"> 652             result.append(JSC::Strong&lt;JSC::JSObject&gt; { state.vm(), outputKeyframe });</span>
 653         }
 654     }
 655 
 656     // 4. Return result.
 657     return result;
 658 }
 659 
<span class="line-modified"> 660 ExceptionOr&lt;void&gt; KeyframeEffect::setKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
 661 {
<span class="line-modified"> 662     return processKeyframes(state, WTFMove(keyframesInput));</span>



 663 }
 664 
<span class="line-modified"> 665 ExceptionOr&lt;void&gt; KeyframeEffect::processKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
 666 {
 667     // 1. If object is null, return an empty sequence of keyframes.
 668     if (!keyframesInput.get())
 669         return { };
 670 
<span class="line-modified"> 671     VM&amp; vm = state.vm();</span>
 672     auto scope = DECLARE_THROW_SCOPE(vm);
 673 
 674     // 2. Let processed keyframes be an empty sequence of keyframes.
 675     Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
 676 
 677     // 3. Let method be the result of GetMethod(object, @@iterator).
<span class="line-modified"> 678     auto method = keyframesInput.get()-&gt;get(&amp;state, vm.propertyNames-&gt;iteratorSymbol);</span>
 679 
 680     // 4. Check the completion record of method.
 681     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 682 
 683     // 5. Perform the steps corresponding to the first matching condition from below,
 684     Vector&lt;String&gt; unusedEasings;
 685     if (!method.isUndefined())
<span class="line-modified"> 686         processIterableKeyframes(state, WTFMove(keyframesInput), WTFMove(method), parsedKeyframes);</span>
 687     else
<span class="line-modified"> 688         processPropertyIndexedKeyframes(state, WTFMove(keyframesInput), parsedKeyframes, unusedEasings);</span>
 689 
 690     // 6. If processed keyframes is not loosely sorted by offset, throw a TypeError and abort these steps.
 691     // 7. If there exist any keyframe in processed keyframes whose keyframe offset is non-null and less than
 692     //    zero or greater than one, throw a TypeError and abort these steps.
 693     double lastNonNullOffset = -1;
 694     for (auto&amp; keyframe : parsedKeyframes) {
 695         if (!keyframe.offset)
 696             continue;
 697         auto offset = keyframe.offset.value();
 698         if (offset &lt; lastNonNullOffset || offset &lt; 0 || offset &gt; 1)
 699             return Exception { TypeError };
 700         lastNonNullOffset = offset;
 701     }
 702 
 703     // We take a slight detour from the spec text and compute the missing keyframe offsets right away
 704     // since they can be computed up-front.
 705     computeMissingKeyframeOffsets(parsedKeyframes);
 706 
 707     // 8. For each frame in processed keyframes, perform the following steps:
 708     for (auto&amp; keyframe : parsedKeyframes) {
 709         // Let the timing function of frame be the result of parsing the “easing” property on frame using the CSS syntax
 710         // defined for the easing property of the AnimationEffectTiming interface.
 711         // If parsing the “easing” property fails, throw a TypeError and abort this procedure.
 712         auto timingFunctionResult = TimingFunction::createFromCSSText(keyframe.easing);
 713         if (timingFunctionResult.hasException())
 714             return timingFunctionResult.releaseException();
 715         keyframe.timingFunction = timingFunctionResult.returnValue();
 716     }
 717 
 718     // 9. Parse each of the values in unused easings using the CSS syntax defined for easing property of the
 719     //    AnimationEffectTiming interface, and if any of the values fail to parse, throw a TypeError
 720     //    and abort this procedure.
 721     for (auto&amp; easing : unusedEasings) {
 722         auto timingFunctionResult = TimingFunction::createFromCSSText(easing);
 723         if (timingFunctionResult.hasException())
 724             return timingFunctionResult.releaseException();
 725     }
 726 
 727     m_parsedKeyframes = WTFMove(parsedKeyframes);
 728 
<span class="line-modified"> 729     m_blendingKeyframes.clear();</span>
 730 
 731     return { };
 732 }
 733 
 734 void KeyframeEffect::updateBlendingKeyframes(RenderStyle&amp; elementStyle)
 735 {
 736     if (!m_blendingKeyframes.isEmpty() || !m_target)
 737         return;
 738 
 739     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
<span class="line-modified"> 740     StyleResolver&amp; styleResolver = m_target-&gt;styleResolver();</span>
 741 
 742     for (auto&amp; keyframe : m_parsedKeyframes) {
<span class="line-removed"> 743         styleResolver.setNewStateWithElement(*m_target);</span>
 744         KeyframeValue keyframeValue(keyframe.computedOffset, nullptr);
 745 
 746         auto styleProperties = keyframe.style-&gt;immutableCopyIfNeeded();
 747         for (unsigned i = 0; i &lt; styleProperties-&gt;propertyCount(); ++i)
 748             keyframeList.addProperty(styleProperties-&gt;propertyAt(i).id());
 749 
 750         auto keyframeRule = StyleRuleKeyframe::create(WTFMove(styleProperties));
<span class="line-modified"> 751         keyframeValue.setStyle(styleResolver.styleForKeyframe(&amp;elementStyle, keyframeRule.ptr(), keyframeValue));</span>
 752         keyframeList.insert(WTFMove(keyframeValue));
 753     }
 754 
 755     setBlendingKeyframes(keyframeList);
 756 }
 757 














 758 bool KeyframeEffect::forceLayoutIfNeeded()
 759 {
 760     if (!m_needsForcedLayout || !m_target)
 761         return false;
 762 
 763     auto* renderer = m_target-&gt;renderer();
 764     if (!renderer || !renderer-&gt;parent())
 765         return false;
 766 
 767     auto* frameView = m_target-&gt;document().view();
 768     if (!frameView)
 769         return false;
 770 
 771     frameView-&gt;forceLayout();
 772     return true;
 773 }
 774 








 775 void KeyframeEffect::setBlendingKeyframes(KeyframeList&amp; blendingKeyframes)
 776 {
 777     m_blendingKeyframes = WTFMove(blendingKeyframes);
 778 
 779     computedNeedsForcedLayout();
 780     computeStackingContextImpact();
<span class="line-modified"> 781     computeShouldRunAccelerated();</span>
 782 
 783     checkForMatchingTransformFunctionLists();
 784     checkForMatchingFilterFunctionLists();
 785 #if ENABLE(FILTERS_LEVEL_2)
 786     checkForMatchingBackdropFilterFunctionLists();
 787 #endif
 788     checkForMatchingColorFilterFunctionLists();
 789 }
 790 
 791 void KeyframeEffect::checkForMatchingTransformFunctionLists()
 792 {
 793     m_transformFunctionListsMatch = false;
 794 
 795     if (m_blendingKeyframes.size() &lt; 2 || !m_blendingKeyframes.containsProperty(CSSPropertyTransform))
 796         return;
 797 
 798     // Empty transforms match anything, so find the first non-empty entry as the reference.
 799     size_t numKeyframes = m_blendingKeyframes.size();
 800     size_t firstNonEmptyTransformKeyframeIndex = numKeyframes;
 801 
</pre>
<hr />
<pre>
 870 #if ENABLE(FILTERS_LEVEL_2)
 871 void KeyframeEffect::checkForMatchingBackdropFilterFunctionLists()
 872 {
 873     m_backdropFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyWebkitBackdropFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
 874         return style.backdropFilter();
 875     });
 876 }
 877 #endif
 878 
 879 void KeyframeEffect::checkForMatchingColorFilterFunctionLists()
 880 {
 881     m_colorFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyAppleColorFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
 882         return style.appleColorFilter();
 883     });
 884 }
 885 
 886 void KeyframeEffect::computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
 887 {
 888     ASSERT(is&lt;DeclarativeAnimation&gt;(animation()));
 889     if (is&lt;CSSAnimation&gt;(animation()))
<span class="line-modified"> 890         computeCSSAnimationBlendingKeyframes();</span>
 891     else if (is&lt;CSSTransition&gt;(animation()))
 892         computeCSSTransitionBlendingKeyframes(oldStyle, newStyle);
 893 }
 894 
<span class="line-modified"> 895 void KeyframeEffect::computeCSSAnimationBlendingKeyframes()</span>
 896 {
 897     ASSERT(is&lt;CSSAnimation&gt;(animation()));
 898 
 899     auto cssAnimation = downcast&lt;CSSAnimation&gt;(animation());
 900     auto&amp; backingAnimation = cssAnimation-&gt;backingAnimation();
 901 
 902     KeyframeList keyframeList(backingAnimation.name());
 903     if (auto* styleScope = Style::Scope::forOrdinal(*m_target, backingAnimation.nameStyleScopeOrdinal()))
<span class="line-modified"> 904         styleScope-&gt;resolver().keyframeStylesForAnimation(*m_target, &amp;cssAnimation-&gt;unanimatedStyle(), keyframeList);</span>
 905 
 906     // Ensure resource loads for all the frames.
 907     for (auto&amp; keyframe : keyframeList.keyframes()) {
 908         if (auto* style = const_cast&lt;RenderStyle*&gt;(keyframe.style()))
 909             Style::loadPendingResources(*style, m_target-&gt;document(), m_target.get());
 910     }
 911 

 912     setBlendingKeyframes(keyframeList);
 913 }
 914 
 915 void KeyframeEffect::computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
 916 {
 917     ASSERT(is&lt;CSSTransition&gt;(animation()));
 918 
 919     if (!oldStyle || m_blendingKeyframes.size())
 920         return;
 921 
 922     auto property = downcast&lt;CSSTransition&gt;(animation())-&gt;property();
 923 
 924     auto toStyle = RenderStyle::clonePtr(newStyle);
 925     if (m_target)
 926         Style::loadPendingResources(*toStyle, m_target-&gt;document(), m_target.get());
 927 
 928     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
 929     keyframeList.addProperty(property);
 930 
 931     KeyframeValue fromKeyframeValue(0, RenderStyle::clonePtr(*oldStyle));
 932     fromKeyframeValue.addProperty(property);
 933     keyframeList.insert(WTFMove(fromKeyframeValue));
 934 
 935     KeyframeValue toKeyframeValue(1, WTFMove(toStyle));
 936     toKeyframeValue.addProperty(property);
 937     keyframeList.insert(WTFMove(toKeyframeValue));
 938 

 939     setBlendingKeyframes(keyframeList);
 940 }
 941 
 942 void KeyframeEffect::computedNeedsForcedLayout()
 943 {
 944     m_needsForcedLayout = false;
 945     if (is&lt;CSSTransition&gt;(animation()) || !m_blendingKeyframes.containsProperty(CSSPropertyTransform))
 946         return;
 947 
 948     size_t numberOfKeyframes = m_blendingKeyframes.size();
 949     for (size_t i = 0; i &lt; numberOfKeyframes; i++) {
 950         auto* keyframeStyle = m_blendingKeyframes[i].style();
 951         if (!keyframeStyle) {
 952             ASSERT_NOT_REACHED();
 953             continue;
 954         }
 955         if (keyframeStyle-&gt;hasTransform()) {
 956             auto&amp; transformOperations = keyframeStyle-&gt;transform();
 957             for (const auto&amp; operation : transformOperations.operations()) {
 958                 if (operation-&gt;isTranslateTransformOperationType()) {
</pre>
<hr />
<pre>
 961                         m_needsForcedLayout = true;
 962                         return;
 963                     }
 964                 }
 965             }
 966         }
 967     }
 968 }
 969 
 970 void KeyframeEffect::computeStackingContextImpact()
 971 {
 972     m_triggersStackingContext = false;
 973     for (auto cssPropertyId : m_blendingKeyframes.properties()) {
 974         if (WillChangeData::propertyCreatesStackingContext(cssPropertyId)) {
 975             m_triggersStackingContext = true;
 976             break;
 977         }
 978     }
 979 }
 980 













































 981 void KeyframeEffect::setTarget(RefPtr&lt;Element&gt;&amp;&amp; newTarget)
 982 {
<span class="line-modified"> 983     if (m_target == newTarget)</span>
 984         return;
 985 
<span class="line-modified"> 986     auto previousTarget = std::exchange(m_target, WTFMove(newTarget));</span>
 987 
 988     if (auto* effectAnimation = animation())
 989         effectAnimation-&gt;effectTargetDidChange(previousTarget.get(), m_target.get());
 990 
<span class="line-modified"> 991     m_blendingKeyframes.clear();</span>
 992 
 993     // We need to invalidate the effect now that the target has changed
 994     // to ensure the effect&#39;s styles are applied to the new target right away.
 995     invalidate();
 996 
 997     // Likewise, we need to invalidate styles on the previous target so that
 998     // any animated styles are removed immediately.
 999     invalidateElement(previousTarget.get());







1000 }
1001 
1002 void KeyframeEffect::apply(RenderStyle&amp; targetStyle)
1003 {
1004     if (!m_target)
1005         return;
1006 
1007     updateBlendingKeyframes(targetStyle);
1008 
<span class="line-modified">1009     updateAcceleratedAnimationState();</span>

1010 
<span class="line-modified">1011     auto progress = getComputedTiming().progress;</span>
<span class="line-modified">1012     if (!progress)</span>

1013         return;
1014 
<span class="line-modified">1015     setAnimatedPropertiesInStyle(targetStyle, progress.value());</span>









1016 
<span class="line-modified">1017     // https://w3c.github.io/web-animations/#side-effects-section</span>
<span class="line-modified">1018     // For every property targeted by at least one animation effect that is current or in effect, the user agent</span>
<span class="line-modified">1019     // must act as if the will-change property ([css-will-change-1]) on the target element includes the property.</span>
<span class="line-modified">1020     if (m_triggersStackingContext &amp;&amp; targetStyle.hasAutoZIndex())</span>
<span class="line-modified">1021         targetStyle.setZIndex(0);</span>




1022 }
1023 
1024 void KeyframeEffect::invalidate()
1025 {
1026     invalidateElement(m_target.get());
1027 }
1028 
<span class="line-modified">1029 void KeyframeEffect::computeShouldRunAccelerated()</span>
1030 {
<span class="line-modified">1031     m_shouldRunAccelerated = hasBlendingKeyframes();</span>


1032     for (auto cssPropertyId : m_blendingKeyframes.properties()) {
<span class="line-modified">1033         if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId)) {</span>
<span class="line-modified">1034             m_shouldRunAccelerated = false;</span>
<span class="line-modified">1035             return;</span>
<span class="line-modified">1036         }</span>



1037     }







1038 }
1039 
1040 void KeyframeEffect::getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; animatedStyle)
1041 {
1042     if (!m_target || !animation())
1043         return;
1044 
1045     auto progress = getComputedTiming().progress;

1046     if (!progress)
1047         return;
1048 
1049     if (!animatedStyle)
1050         animatedStyle = RenderStyle::clonePtr(renderer()-&gt;style());
1051 
1052     setAnimatedPropertiesInStyle(*animatedStyle.get(), progress.value());
1053 }
1054 
1055 void KeyframeEffect::setAnimatedPropertiesInStyle(RenderStyle&amp; targetStyle, double iterationProgress)
1056 {











1057     // 4.4.3. The effect value of a keyframe effect
1058     // https://drafts.csswg.org/web-animations-1/#the-effect-value-of-a-keyframe-animation-effect
1059     //
1060     // The effect value of a single property referenced by a keyframe effect as one of its target properties,
1061     // for a given iteration progress, current iteration and underlying value is calculated as follows.
1062 
1063     updateBlendingKeyframes(targetStyle);
1064     if (m_blendingKeyframes.isEmpty())
1065         return;
1066 
<span class="line-modified">1067     bool isCSSAnimation = is&lt;CSSAnimation&gt;(animation());</span>
<span class="line-removed">1068 </span>
<span class="line-removed">1069     for (auto cssPropertyId : m_blendingKeyframes.properties()) {</span>
1070         // 1. If iteration progress is unresolved abort this procedure.
1071         // 2. Let target property be the longhand property for which the effect value is to be calculated.
1072         // 3. If animation type of the target property is not animatable abort this procedure since the effect cannot be applied.
1073         // 4. Define the neutral value for composition as a value which, when combined with an underlying value using the add composite operation,
1074         //    produces the underlying value.
1075 
1076         // 5. Let property-specific keyframes be the result of getting the set of computed keyframes for this keyframe effect.
1077         // 6. Remove any keyframes from property-specific keyframes that do not have a property value for target property.
1078         unsigned numberOfKeyframesWithZeroOffset = 0;
1079         unsigned numberOfKeyframesWithOneOffset = 0;
1080         Vector&lt;Optional&lt;size_t&gt;&gt; propertySpecificKeyframes;
1081         for (size_t i = 0; i &lt; m_blendingKeyframes.size(); ++i) {
1082             auto&amp; keyframe = m_blendingKeyframes[i];
1083             auto offset = keyframe.key();
1084             if (!keyframe.containsProperty(cssPropertyId)) {
1085                 // If we&#39;re dealing with a CSS animation, we consider the first and last keyframes to always have the property listed
1086                 // since the underlying style was provided and should be captured.
<span class="line-modified">1087                 if (!isCSSAnimation || (offset &amp;&amp; offset &lt; 1))</span>
1088                     continue;
1089             }
1090             if (!offset)
1091                 numberOfKeyframesWithZeroOffset++;
1092             if (offset == 1)
1093                 numberOfKeyframesWithOneOffset++;
1094             propertySpecificKeyframes.append(i);
1095         }
1096 
1097         // 7. If property-specific keyframes is empty, return underlying value.
1098         if (propertySpecificKeyframes.isEmpty())
1099             continue;
1100 
1101         // 8. If there is no keyframe in property-specific keyframes with a computed keyframe offset of 0, create a new keyframe with a computed keyframe
1102         //    offset of 0, a property value set to the neutral value for composition, and a composite operation of add, and prepend it to the beginning of
1103         //    property-specific keyframes.
1104         if (!numberOfKeyframesWithZeroOffset) {
1105             propertySpecificKeyframes.insert(0, WTF::nullopt);
1106             numberOfKeyframesWithZeroOffset = 1;
1107         }
</pre>
<hr />
<pre>
1204 TimingFunction* KeyframeEffect::timingFunctionForKeyframeAtIndex(size_t index)
1205 {
1206     if (!m_parsedKeyframes.isEmpty())
1207         return m_parsedKeyframes[index].timingFunction.get();
1208 
1209     auto effectAnimation = animation();
1210     if (is&lt;DeclarativeAnimation&gt;(effectAnimation)) {
1211         // If we&#39;re dealing with a CSS Animation, the timing function is specified either on the keyframe itself.
1212         if (is&lt;CSSAnimation&gt;(effectAnimation)) {
1213             if (auto* timingFunction = m_blendingKeyframes[index].timingFunction())
1214                 return timingFunction;
1215         }
1216 
1217         // Failing that, or for a CSS Transition, the timing function is inherited from the backing Animation object.
1218         return downcast&lt;DeclarativeAnimation&gt;(effectAnimation)-&gt;backingAnimation().timingFunction();
1219     }
1220 
1221     return nullptr;
1222 }
1223 
<span class="line-modified">1224 void KeyframeEffect::updateAcceleratedAnimationState()</span>
1225 {
<span class="line-modified">1226     if (!m_shouldRunAccelerated)</span>
1227         return;
1228 
<span class="line-modified">1229     if (!renderer()) {</span>
<span class="line-modified">1230         if (isRunningAccelerated())</span>
<span class="line-modified">1231             addPendingAcceleratedAction(AcceleratedAction::Stop);</span>





1232         return;
1233     }
1234 
<span class="line-modified">1235     auto localTime = animation()-&gt;currentTime();</span>
<span class="line-modified">1236 </span>
<span class="line-modified">1237     // If we don&#39;t have a localTime or localTime &lt; 0, we either don&#39;t have a start time or we&#39;re before the startTime</span>
<span class="line-removed">1238     // so we shouldn&#39;t be running.</span>
<span class="line-removed">1239     if (!localTime || localTime.value() &lt; 0_s) {</span>
<span class="line-removed">1240         if (isRunningAccelerated())</span>
<span class="line-removed">1241             addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
1242         return;
1243     }
1244 
1245     auto playState = animation()-&gt;playState();

1246     if (playState == WebAnimation::PlayState::Paused) {
1247         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Pause) {
1248             if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop)
1249                 addPendingAcceleratedAction(AcceleratedAction::Play);
1250             addPendingAcceleratedAction(AcceleratedAction::Pause);
1251         }
<span class="line-modified">1252         return;</span>
<span class="line-removed">1253     }</span>
<span class="line-removed">1254 </span>
<span class="line-removed">1255     if (playState == WebAnimation::PlayState::Finished) {</span>
<span class="line-removed">1256         if (isRunningAccelerated())</span>
<span class="line-removed">1257             addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
<span class="line-removed">1258         else {</span>
<span class="line-removed">1259             m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;</span>
<span class="line-removed">1260             m_pendingAcceleratedActions.clear();</span>
<span class="line-removed">1261             animation()-&gt;acceleratedStateDidChange();</span>
<span class="line-removed">1262         }</span>
<span class="line-removed">1263         return;</span>
<span class="line-removed">1264     }</span>
<span class="line-removed">1265 </span>
<span class="line-removed">1266     if (playState == WebAnimation::PlayState::Running &amp;&amp; localTime &gt;= 0_s) {</span>
1267         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Play)
1268             addPendingAcceleratedAction(AcceleratedAction::Play);
<span class="line-removed">1269         return;</span>
1270     }
1271 }
1272 
1273 void KeyframeEffect::addPendingAcceleratedAction(AcceleratedAction action)
1274 {



1275     if (action == AcceleratedAction::Stop)
1276         m_pendingAcceleratedActions.clear();
1277     m_pendingAcceleratedActions.append(action);
1278     if (action != AcceleratedAction::Seek)
1279         m_lastRecordedAcceleratedAction = action;
1280     animation()-&gt;acceleratedStateDidChange();
1281 }
1282 












1283 void KeyframeEffect::animationDidSeek()
1284 {
1285     // There is no need to seek if we&#39;re not playing an animation already. If seeking
<span class="line-modified">1286     // means we&#39;re moving into an active state, we&#39;ll pick this up in apply().</span>
<span class="line-modified">1287     if (m_shouldRunAccelerated &amp;&amp; isRunningAccelerated())</span>
1288         addPendingAcceleratedAction(AcceleratedAction::Seek);
1289 }
1290 












1291 void KeyframeEffect::animationSuspensionStateDidChange(bool animationIsSuspended)
1292 {
<span class="line-modified">1293     if (m_shouldRunAccelerated)</span>
1294         addPendingAcceleratedAction(animationIsSuspended ? AcceleratedAction::Pause : AcceleratedAction::Play);
1295 }
1296 
1297 void KeyframeEffect::applyPendingAcceleratedActions()
1298 {
1299     // Once an accelerated animation has been committed, we no longer want to force a layout.
1300     // This should have been performed by a call to forceLayoutIfNeeded() prior to applying
1301     // pending accelerated actions.
1302     m_needsForcedLayout = false;
1303 
1304     if (m_pendingAcceleratedActions.isEmpty())
1305         return;
1306 
1307     auto* renderer = this-&gt;renderer();
<span class="line-modified">1308     if (!renderer || !renderer-&gt;isComposited())</span>






1309         return;

1310 
1311     auto pendingAcceleratedActions = m_pendingAcceleratedActions;
1312     m_pendingAcceleratedActions.clear();
1313 
<span class="line-removed">1314     auto* compositedRenderer = downcast&lt;RenderBoxModelObject&gt;(renderer);</span>
<span class="line-removed">1315 </span>
1316     // To simplify the code we use a default of 0s for an unresolved current time since for a Stop action that is acceptable.
1317     auto timeOffset = animation()-&gt;currentTime().valueOr(0_s).seconds() - delay().seconds();
1318 
1319     for (const auto&amp; action : pendingAcceleratedActions) {
1320         switch (action) {
1321         case AcceleratedAction::Play:
<span class="line-modified">1322             if (!compositedRenderer-&gt;startAnimation(timeOffset, backingAnimationForCompositedRenderer(), m_blendingKeyframes)) {</span>
<span class="line-modified">1323                 m_shouldRunAccelerated = false;</span>
1324                 m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;
<span class="line-removed">1325                 animation()-&gt;acceleratedStateDidChange();</span>
1326                 return;
1327             }
1328             break;
1329         case AcceleratedAction::Pause:
<span class="line-modified">1330             compositedRenderer-&gt;animationPaused(timeOffset, m_blendingKeyframes.animationName());</span>
1331             break;
1332         case AcceleratedAction::Seek:
<span class="line-modified">1333             compositedRenderer-&gt;animationSeeked(timeOffset, m_blendingKeyframes.animationName());</span>
1334             break;
1335         case AcceleratedAction::Stop:
<span class="line-modified">1336             compositedRenderer-&gt;animationFinished(m_blendingKeyframes.animationName());</span>
1337             if (!m_target-&gt;document().renderTreeBeingDestroyed())
1338                 m_target-&gt;invalidateStyleAndLayerComposition();

1339             break;
1340         }
1341     }
1342 }
1343 
1344 Ref&lt;const Animation&gt; KeyframeEffect::backingAnimationForCompositedRenderer() const
1345 {
1346     auto effectAnimation = animation();
1347     if (is&lt;DeclarativeAnimation&gt;(effectAnimation))
1348         return downcast&lt;DeclarativeAnimation&gt;(effectAnimation)-&gt;backingAnimation();
1349 
1350     // FIXME: The iterationStart and endDelay AnimationEffectTiming properties do not have
1351     // corresponding Animation properties.
1352     auto animation = Animation::create();
1353     animation-&gt;setDuration(iterationDuration().seconds());
1354     animation-&gt;setDelay(delay().seconds());
1355     animation-&gt;setIterationCount(iterations());
1356     animation-&gt;setTimingFunction(timingFunction()-&gt;clone());
1357 
1358     switch (fill()) {
</pre>
<hr />
<pre>
1394     return m_target ? m_target-&gt;renderer() : nullptr;
1395 }
1396 
1397 const RenderStyle&amp; KeyframeEffect::currentStyle() const
1398 {
1399     if (auto* renderer = this-&gt;renderer())
1400         return renderer-&gt;style();
1401     return RenderStyle::defaultStyle();
1402 }
1403 
1404 bool KeyframeEffect::computeExtentOfTransformAnimation(LayoutRect&amp; bounds) const
1405 {
1406     ASSERT(m_blendingKeyframes.containsProperty(CSSPropertyTransform));
1407 
1408     if (!is&lt;RenderBox&gt;(renderer()))
1409         return true; // Non-boxes don&#39;t get transformed;
1410 
1411     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer());
1412     auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
1413 
<span class="line-modified">1414     auto cumulativeBounds = bounds;</span>
1415 
1416     for (const auto&amp; keyframe : m_blendingKeyframes.keyframes()) {
1417         const auto* keyframeStyle = keyframe.style();
1418 
1419         // FIXME: maybe for declarative animations we always say it&#39;s true for the first and last keyframe.
1420         if (!keyframe.containsProperty(CSSPropertyTransform)) {
1421             // If the first keyframe is missing transform style, use the current style.
1422             if (!keyframe.key())
1423                 keyframeStyle = &amp;box.style();
1424             else
1425                 continue;
1426         }
1427 
1428         auto keyframeBounds = bounds;
1429 
1430         bool canCompute;
1431         if (transformFunctionListsMatch())
1432             canCompute = computeTransformedExtentViaTransformList(rendererBox, *keyframeStyle, keyframeBounds);
1433         else
1434             canCompute = computeTransformedExtentViaMatrix(rendererBox, *keyframeStyle, keyframeBounds);
</pre>
</td>
<td>
<hr />
<pre>
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;KeyframeEffect.h&quot;
  28 
  29 #include &quot;Animation.h&quot;
  30 #include &quot;CSSAnimation.h&quot;
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSKeyframeRule.h&quot;
  33 #include &quot;CSSPropertyAnimation.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSStyleDeclaration.h&quot;
  36 #include &quot;CSSTimingFunctionValue.h&quot;
  37 #include &quot;CSSTransition.h&quot;
  38 #include &quot;Element.h&quot;
  39 #include &quot;FontCascade.h&quot;
  40 #include &quot;FrameView.h&quot;
  41 #include &quot;GeometryUtilities.h&quot;
<span class="line-added">  42 #include &quot;InspectorInstrumentation.h&quot;</span>
  43 #include &quot;JSCompositeOperation.h&quot;
  44 #include &quot;JSCompositeOperationOrAuto.h&quot;
<span class="line-added">  45 #include &quot;JSDOMConvert.h&quot;</span>
  46 #include &quot;JSKeyframeEffect.h&quot;
<span class="line-added">  47 #include &quot;KeyframeEffectStack.h&quot;</span>
<span class="line-added">  48 #include &quot;Logging.h&quot;</span>
  49 #include &quot;RenderBox.h&quot;
  50 #include &quot;RenderBoxModelObject.h&quot;
  51 #include &quot;RenderElement.h&quot;
  52 #include &quot;RenderStyle.h&quot;
<span class="line-added">  53 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added">  54 #include &quot;StyleAdjuster.h&quot;</span>
  55 #include &quot;StylePendingResources.h&quot;
  56 #include &quot;StyleResolver.h&quot;
  57 #include &quot;TimingFunction.h&quot;
  58 #include &quot;TranslateTransformOperation.h&quot;
  59 #include &quot;WillChangeData.h&quot;
  60 #include &lt;JavaScriptCore/Exception.h&gt;
  61 #include &lt;wtf/UUID.h&gt;
<span class="line-added">  62 #include &lt;wtf/text/TextStream.h&gt;</span>
  63 
  64 namespace WebCore {
  65 using namespace JSC;
  66 
  67 static inline void invalidateElement(Element* element)
  68 {
  69     if (element)
  70         element-&gt;invalidateStyle();
  71 }
  72 
  73 static inline String CSSPropertyIDToIDLAttributeName(CSSPropertyID cssPropertyId)
  74 {
  75     // https://drafts.csswg.org/web-animations-1/#animation-property-name-to-idl-attribute-name
  76     // 1. If property follows the &lt;custom-property-name&gt; production, return property.
  77     // FIXME: We don&#39;t handle custom properties yet.
  78 
  79     // 2. If property refers to the CSS float property, return the string &quot;cssFloat&quot;.
  80     if (cssPropertyId == CSSPropertyFloat)
  81         return &quot;cssFloat&quot;;
  82 
</pre>
<hr />
<pre>
 147     //    4. Set the computed keyframe offset of keyframe to offsetA + (offsetB − offsetA) × index / n.
 148     size_t indexOfLastKeyframeWithNonNullOffset = 0;
 149     for (size_t i = 1; i &lt; keyframes.size(); ++i) {
 150         auto&amp; keyframe = keyframes[i];
 151         // Keyframes with a null offset that don&#39;t yet have a non-zero computed offset are keyframes
 152         // with an offset that needs to be computed.
 153         if (!keyframe.offset &amp;&amp; !keyframe.computedOffset)
 154             continue;
 155         if (indexOfLastKeyframeWithNonNullOffset != i - 1) {
 156             double lastNonNullOffset = keyframes[indexOfLastKeyframeWithNonNullOffset].computedOffset;
 157             double offsetDelta = keyframe.computedOffset - lastNonNullOffset;
 158             double offsetIncrement = offsetDelta / (i - indexOfLastKeyframeWithNonNullOffset);
 159             size_t indexOfFirstKeyframeWithNullOffset = indexOfLastKeyframeWithNonNullOffset + 1;
 160             for (size_t j = indexOfFirstKeyframeWithNullOffset; j &lt; i; ++j)
 161                 keyframes[j].computedOffset = lastNonNullOffset + (j - indexOfLastKeyframeWithNonNullOffset) * offsetIncrement;
 162         }
 163         indexOfLastKeyframeWithNonNullOffset = i;
 164     }
 165 }
 166 
<span class="line-modified"> 167 static inline ExceptionOr&lt;KeyframeEffect::KeyframeLikeObject&gt; processKeyframeLikeObject(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, bool allowLists)</span>
 168 {
 169     // https://drafts.csswg.org/web-animations-1/#process-a-keyframe-like-object
 170 
<span class="line-modified"> 171     VM&amp; vm = lexicalGlobalObject.vm();</span>
 172     auto scope = DECLARE_THROW_SCOPE(vm);
 173 
 174     // 1. Run the procedure to convert an ECMAScript value to a dictionary type [WEBIDL] with keyframe input as the ECMAScript value as follows:
 175     //
 176     //    If allow lists is true, use the following dictionary type:
 177     //
 178     //    dictionary BasePropertyIndexedKeyframe {
 179     //        (double? or sequence&lt;double?&gt;)                                   offset = [];
 180     //        (DOMString or sequence&lt;DOMString&gt;)                               easing = [];
 181     //        (CompositeOperationOrAuto or sequence&lt;CompositeOperationOrAuto&gt;) composite = [];
 182     //    };
 183     //
 184     //    Otherwise, use the following dictionary type:
 185     //
 186     //    dictionary BaseKeyframe {
 187     //        double?                  offset = null;
 188     //        DOMString                easing = &quot;linear&quot;;
 189     //        CompositeOperationOrAuto composite = &quot;auto&quot;;
 190     //    };
 191     //
 192     //    Store the result of this procedure as keyframe output.
 193     KeyframeEffect::BasePropertyIndexedKeyframe baseProperties;
 194     if (allowLists)
<span class="line-modified"> 195         baseProperties = convert&lt;IDLDictionary&lt;KeyframeEffect::BasePropertyIndexedKeyframe&gt;&gt;(lexicalGlobalObject, keyframesInput.get());</span>
 196     else {
<span class="line-modified"> 197         auto baseKeyframe = convert&lt;IDLDictionary&lt;KeyframeEffect::BaseKeyframe&gt;&gt;(lexicalGlobalObject, keyframesInput.get());</span>
 198         if (baseKeyframe.offset)
 199             baseProperties.offset = baseKeyframe.offset.value();
 200         else
 201             baseProperties.offset = nullptr;
 202         baseProperties.easing = baseKeyframe.easing;
<span class="line-modified"> 203         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())</span>
<span class="line-added"> 204             baseProperties.composite = baseKeyframe.composite;</span>
 205     }
 206     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 207 
 208     KeyframeEffect::KeyframeLikeObject keyframeOuput;
 209     keyframeOuput.baseProperties = baseProperties;
 210 
 211     // 2. Build up a list of animatable properties as follows:
 212     //
 213     //    1. Let animatable properties be a list of property names (including shorthand properties that have longhand sub-properties
 214     //       that are animatable) that can be animated by the implementation.
 215     //    2. Convert each property name in animatable properties to the equivalent IDL attribute by applying the animation property
 216     //       name to IDL attribute name algorithm.
 217 
 218     // 3. Let input properties be the result of calling the EnumerableOwnNames operation with keyframe input as the object.
 219     PropertyNameArray inputProperties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified"> 220     JSObject::getOwnPropertyNames(keyframesInput.get(), &amp;lexicalGlobalObject, inputProperties, EnumerationMode());</span>
 221 
 222     // 4. Make up a new list animation properties that consists of all of the properties that are in both input properties and animatable
 223     //    properties, or which are in input properties and conform to the &lt;custom-property-name&gt; production.
 224     Vector&lt;JSC::Identifier&gt; animationProperties;
 225     size_t numberOfProperties = inputProperties.size();
 226     for (size_t i = 0; i &lt; numberOfProperties; ++i) {
 227         if (CSSPropertyAnimation::isPropertyAnimatable(IDLAttributeNameToAnimationPropertyName(inputProperties[i].string())))
 228             animationProperties.append(inputProperties[i]);
 229     }
 230 
 231     // 5. Sort animation properties in ascending order by the Unicode codepoints that define each property name.
 232     std::sort(animationProperties.begin(), animationProperties.end(), [](auto&amp; lhs, auto&amp; rhs) {
 233         return lhs.string().utf8() &lt; rhs.string().utf8();
 234     });
 235 
 236     // 6. For each property name in animation properties,
 237     size_t numberOfAnimationProperties = animationProperties.size();
 238     for (size_t i = 0; i &lt; numberOfAnimationProperties; ++i) {
 239         // 1. Let raw value be the result of calling the [[Get]] internal method on keyframe input, with property name as the property
 240         //    key and keyframe input as the receiver.
<span class="line-modified"> 241         auto rawValue = keyframesInput-&gt;get(&amp;lexicalGlobalObject, animationProperties[i]);</span>
 242 
 243         // 2. Check the completion record of raw value.
 244         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 245 
 246         // 3. Convert raw value to a DOMString or sequence of DOMStrings property values as follows:
 247         Vector&lt;String&gt; propertyValues;
 248         if (allowLists) {
 249             // If allow lists is true,
 250             // Let property values be the result of converting raw value to IDL type (DOMString or sequence&lt;DOMString&gt;)
 251             // using the procedures defined for converting an ECMAScript value to an IDL value [WEBIDL].
 252             // If property values is a single DOMString, replace property values with a sequence of DOMStrings with the original value of property
 253             // Values as the only element.
<span class="line-modified"> 254             if (rawValue.isObject())</span>
<span class="line-modified"> 255                 propertyValues = convert&lt;IDLSequence&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, rawValue);</span>
<span class="line-modified"> 256             else</span>
<span class="line-modified"> 257                 propertyValues = { rawValue.toWTFString(&amp;lexicalGlobalObject) };</span>
 258         } else {
 259             // Otherwise,
 260             // Let property values be the result of converting raw value to a DOMString using the procedure for converting an ECMAScript value to a DOMString.
<span class="line-modified"> 261             propertyValues = { convert&lt;IDLDOMString&gt;(lexicalGlobalObject, rawValue) };</span>
 262         }
 263         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 264 
 265         // 4. Calculate the normalized property name as the result of applying the IDL attribute name to animation property name algorithm to property name.
 266         auto cssPropertyID = IDLAttributeNameToAnimationPropertyName(animationProperties[i].string());
 267 
 268         // 5. Add a property to to keyframe output with normalized property name as the property name, and property values as the property value.
 269         keyframeOuput.propertiesAndValues.append({ cssPropertyID, propertyValues });
 270     }
 271 
 272     // 7. Return keyframe output.
 273     return { WTFMove(keyframeOuput) };
 274 }
 275 
<span class="line-modified"> 276 static inline ExceptionOr&lt;void&gt; processIterableKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, JSValue method, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes)</span>
 277 {
 278     // 1. Let iter be GetIterator(object, method).
<span class="line-modified"> 279     forEachInIterable(lexicalGlobalObject, keyframesInput.get(), method, [&amp;parsedKeyframes](VM&amp; vm, JSGlobalObject&amp; lexicalGlobalObject, JSValue nextValue) -&gt; ExceptionOr&lt;void&gt; {</span>
 280         // Steps 2 through 6 are already implemented by forEachInIterable().
 281         auto scope = DECLARE_THROW_SCOPE(vm);
 282         if (!nextValue || !nextValue.isObject()) {
<span class="line-modified"> 283             throwException(&amp;lexicalGlobalObject, scope, JSC::Exception::create(vm, createTypeError(&amp;lexicalGlobalObject)));</span>
 284             return { };
 285         }
 286 
 287         // 7. Append to processed keyframes the result of running the procedure to process a keyframe-like object passing nextItem
 288         // as the keyframe input and with the allow lists flag set to false.
<span class="line-modified"> 289         auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, Strong&lt;JSObject&gt;(vm, nextValue.toObject(&amp;lexicalGlobalObject)), false);</span>
 290         if (processKeyframeLikeObjectResult.hasException())
 291             return processKeyframeLikeObjectResult.releaseException();
 292         auto keyframeLikeObject = processKeyframeLikeObjectResult.returnValue();
 293 
 294         KeyframeEffect::ParsedKeyframe keyframeOutput;
 295 
 296         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only offset
 297         // alternatives we should expect are double and nullptr.
 298         if (WTF::holds_alternative&lt;double&gt;(keyframeLikeObject.baseProperties.offset))
 299             keyframeOutput.offset = WTF::get&lt;double&gt;(keyframeLikeObject.baseProperties.offset);
 300         else
 301             ASSERT(WTF::holds_alternative&lt;std::nullptr_t&gt;(keyframeLikeObject.baseProperties.offset));
 302 
 303         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only easing
 304         // alternative we should expect is String.
 305         ASSERT(WTF::holds_alternative&lt;String&gt;(keyframeLikeObject.baseProperties.easing));
 306         keyframeOutput.easing = WTF::get&lt;String&gt;(keyframeLikeObject.baseProperties.easing);
 307 
 308         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only composite
 309         // alternatives we should expect is CompositeOperationAuto.
<span class="line-modified"> 310         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {</span>
<span class="line-modified"> 311             ASSERT(WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite));</span>
<span class="line-added"> 312             keyframeOutput.composite = WTF::get&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite);</span>
<span class="line-added"> 313         }</span>
 314 
 315         for (auto&amp; propertyAndValue : keyframeLikeObject.propertiesAndValues) {
 316             auto cssPropertyId = propertyAndValue.property;
 317             // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false,
 318             // there should only ever be a single value for a given property.
 319             ASSERT(propertyAndValue.values.size() == 1);
 320             auto stringValue = propertyAndValue.values[0];
 321             if (keyframeOutput.style-&gt;setProperty(cssPropertyId, stringValue))
 322                 keyframeOutput.unparsedStyle.set(cssPropertyId, stringValue);
 323         }
 324 
 325         parsedKeyframes.append(WTFMove(keyframeOutput));
 326 
 327         return { };
 328     });
 329 
 330     return { };
 331 }
 332 
<span class="line-modified"> 333 static inline ExceptionOr&lt;void&gt; processPropertyIndexedKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes, Vector&lt;String&gt;&amp; unusedEasings)</span>
 334 {
 335     // 1. Let property-indexed keyframe be the result of running the procedure to process a keyframe-like object passing object as the keyframe input.
<span class="line-modified"> 336     auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, WTFMove(keyframesInput), true);</span>
 337     if (processKeyframeLikeObjectResult.hasException())
 338         return processKeyframeLikeObjectResult.releaseException();
 339     auto propertyIndexedKeyframe = processKeyframeLikeObjectResult.returnValue();
 340 
 341     // 2. For each member, m, in property-indexed keyframe, perform the following steps:
 342     for (auto&amp; m : propertyIndexedKeyframe.propertiesAndValues) {
 343         // 1. Let property name be the key for m.
 344         auto propertyName = m.property;
 345         // 2. If property name is “composite”, or “easing”, or “offset”, skip the remaining steps in this loop and continue from the next member in property-indexed
 346         //    keyframe after m.
 347         //    We skip this test since we split those properties and the actual CSS properties that we&#39;re currently iterating over.
 348         // 3. Let property values be the value for m.
 349         auto propertyValues = m.values;
 350         // 4. Let property keyframes be an empty sequence of keyframes.
 351         Vector&lt;KeyframeEffect::ParsedKeyframe&gt; propertyKeyframes;
 352         // 5. For each value, v, in property values perform the following steps:
 353         for (auto&amp; v : propertyValues) {
 354             // 1. Let k be a new keyframe with a null keyframe offset.
 355             KeyframeEffect::ParsedKeyframe k;
 356             // 2. Add the property-value pair, property name → v, to k.
</pre>
<hr />
<pre>
 428         easings.append(&quot;linear&quot;);
 429 
 430     // 9. If easings has fewer items than property keyframes, repeat the elements in easings successively starting from the beginning of the list until easings has as many
 431     //    items as property keyframes.
 432     if (easings.size() &lt; parsedKeyframes.size()) {
 433         size_t initialNumberOfEasings = easings.size();
 434         for (i = initialNumberOfEasings; i &lt; parsedKeyframes.size(); ++i)
 435             easings.append(easings[i % initialNumberOfEasings]);
 436     }
 437 
 438     // 10. If easings has more items than property keyframes, store the excess items as unused easings.
 439     while (easings.size() &gt; parsedKeyframes.size())
 440         unusedEasings.append(easings.takeLast());
 441 
 442     // 11. Assign each value in easings to a property named “easing” on the keyframe with the corresponding position in property keyframes until the end of property keyframes
 443     //     is reached.
 444     for (size_t i = 0; i &lt; parsedKeyframes.size(); ++i)
 445         parsedKeyframes[i].easing = easings[i];
 446 
 447     // 12. If the “composite” member of the property-indexed keyframe is not an empty sequence:
<span class="line-modified"> 448     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {</span>
<span class="line-modified"> 449         Vector&lt;CompositeOperationOrAuto&gt; compositeModes;</span>
<span class="line-modified"> 450         if (WTF::holds_alternative&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified"> 451             compositeModes = WTF::get&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite);</span>
<span class="line-modified"> 452         else if (WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified"> 453             compositeModes.append(WTF::get&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite));</span>
<span class="line-modified"> 454         if (!compositeModes.isEmpty()) {</span>
<span class="line-modified"> 455             // 1. Let composite modes be a sequence of CompositeOperationOrAuto values assigned from the “composite” member of property-indexed keyframe. If that member is a single</span>
<span class="line-modified"> 456             //    CompositeOperationOrAuto value operation, let composite modes be a sequence of length one, with the value of the “composite” as its single item.</span>
<span class="line-modified"> 457             // 2. As with easings, if composite modes has fewer items than processed keyframes, repeat the elements in composite modes successively starting from the beginning of</span>
<span class="line-modified"> 458             //    the list until composite modes has as many items as processed keyframes.</span>
<span class="line-modified"> 459             if (compositeModes.size() &lt; parsedKeyframes.size()) {</span>
<span class="line-modified"> 460                 size_t initialNumberOfCompositeModes = compositeModes.size();</span>
<span class="line-modified"> 461                 for (i = initialNumberOfCompositeModes; i &lt; parsedKeyframes.size(); ++i)</span>
<span class="line-modified"> 462                     compositeModes.append(compositeModes[i % initialNumberOfCompositeModes]);</span>
<span class="line-modified"> 463             }</span>
<span class="line-modified"> 464             // 3. Assign each value in composite modes that is not auto to the keyframe-specific composite operation on the keyframe with the corresponding position in processed</span>
<span class="line-modified"> 465             //    keyframes until the end of processed keyframes is reached.</span>
<span class="line-modified"> 466             for (size_t i = 0; i &lt; compositeModes.size() &amp;&amp; i &lt; parsedKeyframes.size(); ++i) {</span>
<span class="line-modified"> 467                 if (compositeModes[i] != CompositeOperationOrAuto::Auto)</span>
<span class="line-added"> 468                     parsedKeyframes[i].composite = compositeModes[i];</span>
<span class="line-added"> 469             }</span>
 470         }
 471     }
 472 
 473     return { };
 474 }
 475 
<span class="line-modified"> 476 ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSGlobalObject&amp; lexicalGlobalObject, Element* target, Strong&lt;JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt;&amp;&amp; options)</span>
 477 {
 478     auto keyframeEffect = adoptRef(*new KeyframeEffect(target));
 479 
 480     if (options) {
 481         OptionalEffectTiming timing;
 482         auto optionsValue = options.value();
 483         if (WTF::holds_alternative&lt;double&gt;(optionsValue)) {
 484             Variant&lt;double, String&gt; duration = WTF::get&lt;double&gt;(optionsValue);
 485             timing.duration = duration;
 486         } else {
 487             auto keyframeEffectOptions = WTF::get&lt;KeyframeEffectOptions&gt;(optionsValue);
 488             timing = {
 489                 keyframeEffectOptions.duration,
 490                 keyframeEffectOptions.iterations,
 491                 keyframeEffectOptions.delay,
 492                 keyframeEffectOptions.endDelay,
 493                 keyframeEffectOptions.iterationStart,
 494                 keyframeEffectOptions.easing,
 495                 keyframeEffectOptions.fill,
 496                 keyframeEffectOptions.direction
 497             };
 498         }
 499         auto updateTimingResult = keyframeEffect-&gt;updateTiming(timing);
 500         if (updateTimingResult.hasException())
 501             return updateTimingResult.releaseException();
 502     }
 503 
<span class="line-modified"> 504     auto processKeyframesResult = keyframeEffect-&gt;processKeyframes(lexicalGlobalObject, WTFMove(keyframes));</span>
 505     if (processKeyframesResult.hasException())
 506         return processKeyframesResult.releaseException();
 507 
 508     return keyframeEffect;
 509 }
 510 
<span class="line-modified"> 511 ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSC::JSGlobalObject&amp;, Ref&lt;KeyframeEffect&gt;&amp;&amp; source)</span>
 512 {
 513     auto keyframeEffect = adoptRef(*new KeyframeEffect(nullptr));
 514     keyframeEffect-&gt;copyPropertiesFromSource(WTFMove(source));
 515     return keyframeEffect;
 516 }
 517 
 518 Ref&lt;KeyframeEffect&gt; KeyframeEffect::create(const Element&amp; target)
 519 {
 520     return adoptRef(*new KeyframeEffect(const_cast&lt;Element*&gt;(&amp;target)));
 521 }
 522 
 523 KeyframeEffect::KeyframeEffect(Element* target)
<span class="line-modified"> 524     : m_target(makeWeakPtr(target))</span>
 525 {
 526 }
 527 
 528 void KeyframeEffect::copyPropertiesFromSource(Ref&lt;KeyframeEffect&gt;&amp;&amp; source)
 529 {
 530     m_target = source-&gt;m_target;
 531     m_compositeOperation = source-&gt;m_compositeOperation;
 532     m_iterationCompositeOperation = source-&gt;m_iterationCompositeOperation;
 533 
 534     Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
 535     for (auto&amp; sourceParsedKeyframe : source-&gt;m_parsedKeyframes) {
 536         ParsedKeyframe parsedKeyframe;
 537         parsedKeyframe.easing = sourceParsedKeyframe.easing;
 538         parsedKeyframe.offset = sourceParsedKeyframe.offset;
 539         parsedKeyframe.composite = sourceParsedKeyframe.composite;
 540         parsedKeyframe.unparsedStyle = sourceParsedKeyframe.unparsedStyle;
 541         parsedKeyframe.computedOffset = sourceParsedKeyframe.computedOffset;
 542         parsedKeyframe.timingFunction = sourceParsedKeyframe.timingFunction;
 543         parsedKeyframe.style = sourceParsedKeyframe.style-&gt;mutableCopy();
 544         parsedKeyframes.append(WTFMove(parsedKeyframe));
 545     }
 546     m_parsedKeyframes = WTFMove(parsedKeyframes);
 547 
 548     setFill(source-&gt;fill());
 549     setDelay(source-&gt;delay());
 550     setEndDelay(source-&gt;endDelay());
 551     setDirection(source-&gt;direction());
 552     setIterations(source-&gt;iterations());
 553     setTimingFunction(source-&gt;timingFunction());
 554     setIterationStart(source-&gt;iterationStart());
 555     setIterationDuration(source-&gt;iterationDuration());
<span class="line-added"> 556     updateStaticTimingProperties();</span>
 557 
 558     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
 559     for (auto&amp; keyframe : source-&gt;m_blendingKeyframes.keyframes()) {
 560         KeyframeValue keyframeValue(keyframe.key(), RenderStyle::clonePtr(*keyframe.style()));
 561         for (auto propertyId : keyframe.properties())
 562             keyframeValue.addProperty(propertyId);
 563         keyframeList.insert(WTFMove(keyframeValue));
 564     }
 565     setBlendingKeyframes(keyframeList);
 566 }
 567 
<span class="line-modified"> 568 Vector&lt;Strong&lt;JSObject&gt;&gt; KeyframeEffect::getKeyframes(JSGlobalObject&amp; lexicalGlobalObject)</span>
 569 {
 570     // https://drafts.csswg.org/web-animations-1/#dom-keyframeeffectreadonly-getkeyframes
 571 
<span class="line-modified"> 572     auto lock = JSLockHolder { &amp;lexicalGlobalObject };</span>
 573 
 574     // Since keyframes are represented by a partially open-ended dictionary type that is not currently able to be expressed with WebIDL,
 575     // the procedure used to prepare the result of this method is defined in prose below:
 576     //
 577     // 1. Let result be an empty sequence of objects.
 578     Vector&lt;Strong&lt;JSObject&gt;&gt; result;
 579 
 580     // 2. Let keyframes be the result of applying the procedure to compute missing keyframe offsets to the keyframes for this keyframe effect.
 581 
 582     // 3. For each keyframe in keyframes perform the following steps:
 583     if (is&lt;DeclarativeAnimation&gt;(animation())) {
<span class="line-added"> 584         auto* renderer = m_target-&gt;renderer();</span>
 585         auto computedStyleExtractor = ComputedStyleExtractor(m_target.get());
 586         for (size_t i = 0; i &lt; m_blendingKeyframes.size(); ++i) {
 587             // 1. Initialize a dictionary object, output keyframe, using the following definition:
 588             //
 589             // dictionary BaseComputedKeyframe {
 590             //      double?                  offset = null;
 591             //      double                   computedOffset;
 592             //      DOMString                easing = &quot;linear&quot;;
 593             //      CompositeOperationOrAuto composite = &quot;auto&quot;;
 594             // };
 595 
 596             auto&amp; keyframe = m_blendingKeyframes[i];
 597 
 598             // 2. Set offset, computedOffset, easing members of output keyframe to the respective values keyframe offset, computed keyframe offset,
 599             // and keyframe-specific timing function of keyframe.
 600             BaseComputedKeyframe computedKeyframe;
 601             computedKeyframe.offset = keyframe.key();
 602             computedKeyframe.computedOffset = keyframe.key();
<span class="line-modified"> 603             // For CSS transitions, all keyframes should return &quot;linear&quot; since the effect&#39;s global timing function applies.</span>
<span class="line-modified"> 604             computedKeyframe.easing = is&lt;CSSTransition&gt;(animation()) ? &quot;linear&quot; : timingFunctionForKeyframeAtIndex(i)-&gt;cssText();</span>

 605 
<span class="line-modified"> 606             auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), computedKeyframe);</span>
 607 
 608             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
 609             auto&amp; style = *keyframe.style();
 610             for (auto cssPropertyId : keyframe.properties()) {
 611                 if (cssPropertyId == CSSPropertyCustom)
 612                     continue;
 613                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
 614                 auto propertyName = CSSPropertyIDToIDLAttributeName(cssPropertyId);
 615                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
 616                 String idlValue = &quot;&quot;;
<span class="line-modified"> 617                 if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId, renderer))</span>
 618                     idlValue = cssValue-&gt;cssText();
 619                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified"> 620                 auto value = toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, idlValue);</span>
 621                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
 622                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified"> 623                 JSObject::defineOwnProperty(outputKeyframe, &amp;lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
 624             }
 625 
 626             // 5. Append output keyframe to result.
<span class="line-modified"> 627             result.append(JSC::Strong&lt;JSC::JSObject&gt; { lexicalGlobalObject.vm(), outputKeyframe });</span>
 628         }
 629     } else {
 630         for (size_t i = 0; i &lt; m_parsedKeyframes.size(); ++i) {
 631             // 1. Initialize a dictionary object, output keyframe, using the following definition:
 632             //
 633             // dictionary BaseComputedKeyframe {
 634             //      double?                  offset = null;
 635             //      double                   computedOffset;
 636             //      DOMString                easing = &quot;linear&quot;;
 637             //      CompositeOperationOrAuto composite = &quot;auto&quot;;
 638             // };
 639 
 640             auto&amp; parsedKeyframe = m_parsedKeyframes[i];
 641 
 642             // 2. Set offset, computedOffset, easing, composite members of output keyframe to the respective values keyframe offset, computed keyframe
 643             // offset, keyframe-specific timing function and keyframe-specific composite operation of keyframe.
 644             BaseComputedKeyframe computedKeyframe;
 645             computedKeyframe.offset = parsedKeyframe.offset;
 646             computedKeyframe.computedOffset = parsedKeyframe.computedOffset;
 647             computedKeyframe.easing = timingFunctionForKeyframeAtIndex(i)-&gt;cssText();
<span class="line-modified"> 648             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())</span>
<span class="line-added"> 649                 computedKeyframe.composite = parsedKeyframe.composite;</span>
 650 
<span class="line-modified"> 651             auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), computedKeyframe);</span>
 652 
 653             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
 654             for (auto it = parsedKeyframe.unparsedStyle.begin(), end = parsedKeyframe.unparsedStyle.end(); it != end; ++it) {
 655                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
 656                 auto propertyName = CSSPropertyIDToIDLAttributeName(it-&gt;key);
 657                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
 658                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified"> 659                 auto value = toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, it-&gt;value);</span>
 660                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
 661                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified"> 662                 JSObject::defineOwnProperty(outputKeyframe, &amp;lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
 663             }
 664 
 665             // 4. Append output keyframe to result.
<span class="line-modified"> 666             result.append(JSC::Strong&lt;JSC::JSObject&gt; { lexicalGlobalObject.vm(), outputKeyframe });</span>
 667         }
 668     }
 669 
 670     // 4. Return result.
 671     return result;
 672 }
 673 
<span class="line-modified"> 674 ExceptionOr&lt;void&gt; KeyframeEffect::setKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
 675 {
<span class="line-modified"> 676     auto processKeyframesResult = processKeyframes(lexicalGlobalObject, WTFMove(keyframesInput));</span>
<span class="line-added"> 677     if (!processKeyframesResult.hasException() &amp;&amp; animation())</span>
<span class="line-added"> 678         animation()-&gt;effectTimingDidChange();</span>
<span class="line-added"> 679     return processKeyframesResult;</span>
 680 }
 681 
<span class="line-modified"> 682 ExceptionOr&lt;void&gt; KeyframeEffect::processKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
 683 {
 684     // 1. If object is null, return an empty sequence of keyframes.
 685     if (!keyframesInput.get())
 686         return { };
 687 
<span class="line-modified"> 688     VM&amp; vm = lexicalGlobalObject.vm();</span>
 689     auto scope = DECLARE_THROW_SCOPE(vm);
 690 
 691     // 2. Let processed keyframes be an empty sequence of keyframes.
 692     Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
 693 
 694     // 3. Let method be the result of GetMethod(object, @@iterator).
<span class="line-modified"> 695     auto method = keyframesInput.get()-&gt;get(&amp;lexicalGlobalObject, vm.propertyNames-&gt;iteratorSymbol);</span>
 696 
 697     // 4. Check the completion record of method.
 698     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 699 
 700     // 5. Perform the steps corresponding to the first matching condition from below,
 701     Vector&lt;String&gt; unusedEasings;
 702     if (!method.isUndefined())
<span class="line-modified"> 703         processIterableKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), WTFMove(method), parsedKeyframes);</span>
 704     else
<span class="line-modified"> 705         processPropertyIndexedKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), parsedKeyframes, unusedEasings);</span>
 706 
 707     // 6. If processed keyframes is not loosely sorted by offset, throw a TypeError and abort these steps.
 708     // 7. If there exist any keyframe in processed keyframes whose keyframe offset is non-null and less than
 709     //    zero or greater than one, throw a TypeError and abort these steps.
 710     double lastNonNullOffset = -1;
 711     for (auto&amp; keyframe : parsedKeyframes) {
 712         if (!keyframe.offset)
 713             continue;
 714         auto offset = keyframe.offset.value();
 715         if (offset &lt; lastNonNullOffset || offset &lt; 0 || offset &gt; 1)
 716             return Exception { TypeError };
 717         lastNonNullOffset = offset;
 718     }
 719 
 720     // We take a slight detour from the spec text and compute the missing keyframe offsets right away
 721     // since they can be computed up-front.
 722     computeMissingKeyframeOffsets(parsedKeyframes);
 723 
 724     // 8. For each frame in processed keyframes, perform the following steps:
 725     for (auto&amp; keyframe : parsedKeyframes) {
 726         // Let the timing function of frame be the result of parsing the “easing” property on frame using the CSS syntax
 727         // defined for the easing property of the AnimationEffectTiming interface.
 728         // If parsing the “easing” property fails, throw a TypeError and abort this procedure.
 729         auto timingFunctionResult = TimingFunction::createFromCSSText(keyframe.easing);
 730         if (timingFunctionResult.hasException())
 731             return timingFunctionResult.releaseException();
 732         keyframe.timingFunction = timingFunctionResult.returnValue();
 733     }
 734 
 735     // 9. Parse each of the values in unused easings using the CSS syntax defined for easing property of the
 736     //    AnimationEffectTiming interface, and if any of the values fail to parse, throw a TypeError
 737     //    and abort this procedure.
 738     for (auto&amp; easing : unusedEasings) {
 739         auto timingFunctionResult = TimingFunction::createFromCSSText(easing);
 740         if (timingFunctionResult.hasException())
 741             return timingFunctionResult.releaseException();
 742     }
 743 
 744     m_parsedKeyframes = WTFMove(parsedKeyframes);
 745 
<span class="line-modified"> 746     clearBlendingKeyframes();</span>
 747 
 748     return { };
 749 }
 750 
 751 void KeyframeEffect::updateBlendingKeyframes(RenderStyle&amp; elementStyle)
 752 {
 753     if (!m_blendingKeyframes.isEmpty() || !m_target)
 754         return;
 755 
 756     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
<span class="line-modified"> 757     auto&amp; styleResolver = m_target-&gt;styleResolver();</span>
 758 
 759     for (auto&amp; keyframe : m_parsedKeyframes) {

 760         KeyframeValue keyframeValue(keyframe.computedOffset, nullptr);
 761 
 762         auto styleProperties = keyframe.style-&gt;immutableCopyIfNeeded();
 763         for (unsigned i = 0; i &lt; styleProperties-&gt;propertyCount(); ++i)
 764             keyframeList.addProperty(styleProperties-&gt;propertyAt(i).id());
 765 
 766         auto keyframeRule = StyleRuleKeyframe::create(WTFMove(styleProperties));
<span class="line-modified"> 767         keyframeValue.setStyle(styleResolver.styleForKeyframe(*m_target, &amp;elementStyle, keyframeRule.ptr(), keyframeValue));</span>
 768         keyframeList.insert(WTFMove(keyframeValue));
 769     }
 770 
 771     setBlendingKeyframes(keyframeList);
 772 }
 773 
<span class="line-added"> 774 bool KeyframeEffect::animatesProperty(CSSPropertyID property) const</span>
<span class="line-added"> 775 {</span>
<span class="line-added"> 776     if (!m_blendingKeyframes.isEmpty())</span>
<span class="line-added"> 777         return m_blendingKeyframes.properties().contains(property);</span>
<span class="line-added"> 778 </span>
<span class="line-added"> 779     for (auto&amp; keyframe : m_parsedKeyframes) {</span>
<span class="line-added"> 780         for (auto keyframeProperty : keyframe.unparsedStyle.keys()) {</span>
<span class="line-added"> 781             if (keyframeProperty == property)</span>
<span class="line-added"> 782                 return true;</span>
<span class="line-added"> 783         }</span>
<span class="line-added"> 784     }</span>
<span class="line-added"> 785     return false;</span>
<span class="line-added"> 786 }</span>
<span class="line-added"> 787 </span>
 788 bool KeyframeEffect::forceLayoutIfNeeded()
 789 {
 790     if (!m_needsForcedLayout || !m_target)
 791         return false;
 792 
 793     auto* renderer = m_target-&gt;renderer();
 794     if (!renderer || !renderer-&gt;parent())
 795         return false;
 796 
 797     auto* frameView = m_target-&gt;document().view();
 798     if (!frameView)
 799         return false;
 800 
 801     frameView-&gt;forceLayout();
 802     return true;
 803 }
 804 
<span class="line-added"> 805 </span>
<span class="line-added"> 806 void KeyframeEffect::clearBlendingKeyframes()</span>
<span class="line-added"> 807 {</span>
<span class="line-added"> 808     m_blendingKeyframesSource = BlendingKeyframesSource::WebAnimation;</span>
<span class="line-added"> 809     m_unanimatedStyle = nullptr;</span>
<span class="line-added"> 810     m_blendingKeyframes.clear();</span>
<span class="line-added"> 811 }</span>
<span class="line-added"> 812 </span>
 813 void KeyframeEffect::setBlendingKeyframes(KeyframeList&amp; blendingKeyframes)
 814 {
 815     m_blendingKeyframes = WTFMove(blendingKeyframes);
 816 
 817     computedNeedsForcedLayout();
 818     computeStackingContextImpact();
<span class="line-modified"> 819     computeAcceleratedPropertiesState();</span>
 820 
 821     checkForMatchingTransformFunctionLists();
 822     checkForMatchingFilterFunctionLists();
 823 #if ENABLE(FILTERS_LEVEL_2)
 824     checkForMatchingBackdropFilterFunctionLists();
 825 #endif
 826     checkForMatchingColorFilterFunctionLists();
 827 }
 828 
 829 void KeyframeEffect::checkForMatchingTransformFunctionLists()
 830 {
 831     m_transformFunctionListsMatch = false;
 832 
 833     if (m_blendingKeyframes.size() &lt; 2 || !m_blendingKeyframes.containsProperty(CSSPropertyTransform))
 834         return;
 835 
 836     // Empty transforms match anything, so find the first non-empty entry as the reference.
 837     size_t numKeyframes = m_blendingKeyframes.size();
 838     size_t firstNonEmptyTransformKeyframeIndex = numKeyframes;
 839 
</pre>
<hr />
<pre>
 908 #if ENABLE(FILTERS_LEVEL_2)
 909 void KeyframeEffect::checkForMatchingBackdropFilterFunctionLists()
 910 {
 911     m_backdropFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyWebkitBackdropFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
 912         return style.backdropFilter();
 913     });
 914 }
 915 #endif
 916 
 917 void KeyframeEffect::checkForMatchingColorFilterFunctionLists()
 918 {
 919     m_colorFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyAppleColorFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
 920         return style.appleColorFilter();
 921     });
 922 }
 923 
 924 void KeyframeEffect::computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
 925 {
 926     ASSERT(is&lt;DeclarativeAnimation&gt;(animation()));
 927     if (is&lt;CSSAnimation&gt;(animation()))
<span class="line-modified"> 928         computeCSSAnimationBlendingKeyframes(newStyle);</span>
 929     else if (is&lt;CSSTransition&gt;(animation()))
 930         computeCSSTransitionBlendingKeyframes(oldStyle, newStyle);
 931 }
 932 
<span class="line-modified"> 933 void KeyframeEffect::computeCSSAnimationBlendingKeyframes(const RenderStyle&amp; unanimatedStyle)</span>
 934 {
 935     ASSERT(is&lt;CSSAnimation&gt;(animation()));
 936 
 937     auto cssAnimation = downcast&lt;CSSAnimation&gt;(animation());
 938     auto&amp; backingAnimation = cssAnimation-&gt;backingAnimation();
 939 
 940     KeyframeList keyframeList(backingAnimation.name());
 941     if (auto* styleScope = Style::Scope::forOrdinal(*m_target, backingAnimation.nameStyleScopeOrdinal()))
<span class="line-modified"> 942         styleScope-&gt;resolver().keyframeStylesForAnimation(*m_target, &amp;unanimatedStyle, keyframeList);</span>
 943 
 944     // Ensure resource loads for all the frames.
 945     for (auto&amp; keyframe : keyframeList.keyframes()) {
 946         if (auto* style = const_cast&lt;RenderStyle*&gt;(keyframe.style()))
 947             Style::loadPendingResources(*style, m_target-&gt;document(), m_target.get());
 948     }
 949 
<span class="line-added"> 950     m_blendingKeyframesSource = BlendingKeyframesSource::CSSAnimation;</span>
 951     setBlendingKeyframes(keyframeList);
 952 }
 953 
 954 void KeyframeEffect::computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
 955 {
 956     ASSERT(is&lt;CSSTransition&gt;(animation()));
 957 
 958     if (!oldStyle || m_blendingKeyframes.size())
 959         return;
 960 
 961     auto property = downcast&lt;CSSTransition&gt;(animation())-&gt;property();
 962 
 963     auto toStyle = RenderStyle::clonePtr(newStyle);
 964     if (m_target)
 965         Style::loadPendingResources(*toStyle, m_target-&gt;document(), m_target.get());
 966 
 967     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
 968     keyframeList.addProperty(property);
 969 
 970     KeyframeValue fromKeyframeValue(0, RenderStyle::clonePtr(*oldStyle));
 971     fromKeyframeValue.addProperty(property);
 972     keyframeList.insert(WTFMove(fromKeyframeValue));
 973 
 974     KeyframeValue toKeyframeValue(1, WTFMove(toStyle));
 975     toKeyframeValue.addProperty(property);
 976     keyframeList.insert(WTFMove(toKeyframeValue));
 977 
<span class="line-added"> 978     m_blendingKeyframesSource = BlendingKeyframesSource::CSSTransition;</span>
 979     setBlendingKeyframes(keyframeList);
 980 }
 981 
 982 void KeyframeEffect::computedNeedsForcedLayout()
 983 {
 984     m_needsForcedLayout = false;
 985     if (is&lt;CSSTransition&gt;(animation()) || !m_blendingKeyframes.containsProperty(CSSPropertyTransform))
 986         return;
 987 
 988     size_t numberOfKeyframes = m_blendingKeyframes.size();
 989     for (size_t i = 0; i &lt; numberOfKeyframes; i++) {
 990         auto* keyframeStyle = m_blendingKeyframes[i].style();
 991         if (!keyframeStyle) {
 992             ASSERT_NOT_REACHED();
 993             continue;
 994         }
 995         if (keyframeStyle-&gt;hasTransform()) {
 996             auto&amp; transformOperations = keyframeStyle-&gt;transform();
 997             for (const auto&amp; operation : transformOperations.operations()) {
 998                 if (operation-&gt;isTranslateTransformOperationType()) {
</pre>
<hr />
<pre>
1001                         m_needsForcedLayout = true;
1002                         return;
1003                     }
1004                 }
1005             }
1006         }
1007     }
1008 }
1009 
1010 void KeyframeEffect::computeStackingContextImpact()
1011 {
1012     m_triggersStackingContext = false;
1013     for (auto cssPropertyId : m_blendingKeyframes.properties()) {
1014         if (WillChangeData::propertyCreatesStackingContext(cssPropertyId)) {
1015             m_triggersStackingContext = true;
1016             break;
1017         }
1018     }
1019 }
1020 
<span class="line-added">1021 void KeyframeEffect::animationTimelineDidChange(AnimationTimeline* timeline)</span>
<span class="line-added">1022 {</span>
<span class="line-added">1023     if (!m_target)</span>
<span class="line-added">1024         return;</span>
<span class="line-added">1025 </span>
<span class="line-added">1026     if (timeline)</span>
<span class="line-added">1027         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);</span>
<span class="line-added">1028     else {</span>
<span class="line-added">1029         m_target-&gt;ensureKeyframeEffectStack().removeEffect(*this);</span>
<span class="line-added">1030         m_inTargetEffectStack = false;</span>
<span class="line-added">1031     }</span>
<span class="line-added">1032 }</span>
<span class="line-added">1033 </span>
<span class="line-added">1034 void KeyframeEffect::animationTimingDidChange()</span>
<span class="line-added">1035 {</span>
<span class="line-added">1036     updateEffectStackMembership();</span>
<span class="line-added">1037 }</span>
<span class="line-added">1038 </span>
<span class="line-added">1039 void KeyframeEffect::updateEffectStackMembership()</span>
<span class="line-added">1040 {</span>
<span class="line-added">1041     if (!m_target)</span>
<span class="line-added">1042         return;</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     bool isRelevant = animation() &amp;&amp; animation()-&gt;isRelevant();</span>
<span class="line-added">1045     if (isRelevant &amp;&amp; !m_inTargetEffectStack)</span>
<span class="line-added">1046         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);</span>
<span class="line-added">1047     else if (!isRelevant &amp;&amp; m_inTargetEffectStack) {</span>
<span class="line-added">1048         m_target-&gt;ensureKeyframeEffectStack().removeEffect(*this);</span>
<span class="line-added">1049         m_inTargetEffectStack = false;</span>
<span class="line-added">1050     }</span>
<span class="line-added">1051 }</span>
<span class="line-added">1052 </span>
<span class="line-added">1053 void KeyframeEffect::setAnimation(WebAnimation* animation)</span>
<span class="line-added">1054 {</span>
<span class="line-added">1055     bool animationChanged = animation != this-&gt;animation();</span>
<span class="line-added">1056     AnimationEffect::setAnimation(animation);</span>
<span class="line-added">1057 </span>
<span class="line-added">1058     if (!animationChanged)</span>
<span class="line-added">1059         return;</span>
<span class="line-added">1060 </span>
<span class="line-added">1061     if (animation)</span>
<span class="line-added">1062         animation-&gt;updateRelevance();</span>
<span class="line-added">1063     updateEffectStackMembership();</span>
<span class="line-added">1064 }</span>
<span class="line-added">1065 </span>
1066 void KeyframeEffect::setTarget(RefPtr&lt;Element&gt;&amp;&amp; newTarget)
1067 {
<span class="line-modified">1068     if (m_target.get() == newTarget.get())</span>
1069         return;
1070 
<span class="line-modified">1071     auto previousTarget = std::exchange(m_target, makeWeakPtr(newTarget.get()));</span>
1072 
1073     if (auto* effectAnimation = animation())
1074         effectAnimation-&gt;effectTargetDidChange(previousTarget.get(), m_target.get());
1075 
<span class="line-modified">1076     clearBlendingKeyframes();</span>
1077 
1078     // We need to invalidate the effect now that the target has changed
1079     // to ensure the effect&#39;s styles are applied to the new target right away.
1080     invalidate();
1081 
1082     // Likewise, we need to invalidate styles on the previous target so that
1083     // any animated styles are removed immediately.
1084     invalidateElement(previousTarget.get());
<span class="line-added">1085 </span>
<span class="line-added">1086     if (previousTarget) {</span>
<span class="line-added">1087         previousTarget-&gt;ensureKeyframeEffectStack().removeEffect(*this);</span>
<span class="line-added">1088         m_inTargetEffectStack = false;</span>
<span class="line-added">1089     }</span>
<span class="line-added">1090     if (m_target)</span>
<span class="line-added">1091         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);</span>
1092 }
1093 
1094 void KeyframeEffect::apply(RenderStyle&amp; targetStyle)
1095 {
1096     if (!m_target)
1097         return;
1098 
1099     updateBlendingKeyframes(targetStyle);
1100 
<span class="line-modified">1101     auto computedTiming = getComputedTiming();</span>
<span class="line-added">1102     m_phaseAtLastApplication = computedTiming.phase;</span>
1103 
<span class="line-modified">1104     InspectorInstrumentation::willApplyKeyframeEffect(*m_target, *this, computedTiming);</span>
<span class="line-modified">1105 </span>
<span class="line-added">1106     if (!computedTiming.progress)</span>
1107         return;
1108 
<span class="line-modified">1109     if (!m_unanimatedStyle)</span>
<span class="line-added">1110         m_unanimatedStyle = RenderStyle::clonePtr(targetStyle);</span>
<span class="line-added">1111 </span>
<span class="line-added">1112     setAnimatedPropertiesInStyle(targetStyle, computedTiming.progress.value());</span>
<span class="line-added">1113 }</span>
<span class="line-added">1114 </span>
<span class="line-added">1115 bool KeyframeEffect::isCurrentlyAffectingProperty(CSSPropertyID property, Accelerated accelerated) const</span>
<span class="line-added">1116 {</span>
<span class="line-added">1117     if (accelerated == Accelerated::Yes &amp;&amp; !isRunningAccelerated() &amp;&amp; !isAboutToRunAccelerated())</span>
<span class="line-added">1118         return false;</span>
1119 
<span class="line-modified">1120     if (!m_blendingKeyframes.properties().contains(property))</span>
<span class="line-modified">1121         return false;</span>
<span class="line-modified">1122 </span>
<span class="line-modified">1123     return m_phaseAtLastApplication == AnimationEffectPhase::Active;</span>
<span class="line-modified">1124 }</span>
<span class="line-added">1125 </span>
<span class="line-added">1126 bool KeyframeEffect::isRunningAcceleratedAnimationForProperty(CSSPropertyID property) const</span>
<span class="line-added">1127 {</span>
<span class="line-added">1128     return m_isRunningAccelerated &amp;&amp; CSSPropertyAnimation::animationOfPropertyIsAccelerated(property) &amp;&amp; m_blendingKeyframes.properties().contains(property);</span>
1129 }
1130 
1131 void KeyframeEffect::invalidate()
1132 {
1133     invalidateElement(m_target.get());
1134 }
1135 
<span class="line-modified">1136 void KeyframeEffect::computeAcceleratedPropertiesState()</span>
1137 {
<span class="line-modified">1138     bool hasSomeAcceleratedProperties = false;</span>
<span class="line-added">1139     bool hasSomeUnacceleratedProperties = false;</span>
<span class="line-added">1140 </span>
1141     for (auto cssPropertyId : m_blendingKeyframes.properties()) {
<span class="line-modified">1142         // If any animated property can be accelerated, then the animation should run accelerated.</span>
<span class="line-modified">1143         if (CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId))</span>
<span class="line-modified">1144             hasSomeAcceleratedProperties = true;</span>
<span class="line-modified">1145         else</span>
<span class="line-added">1146             hasSomeUnacceleratedProperties = true;</span>
<span class="line-added">1147         if (hasSomeAcceleratedProperties &amp;&amp; hasSomeUnacceleratedProperties)</span>
<span class="line-added">1148             break;</span>
1149     }
<span class="line-added">1150 </span>
<span class="line-added">1151     if (!hasSomeAcceleratedProperties)</span>
<span class="line-added">1152         m_acceleratedPropertiesState = AcceleratedProperties::None;</span>
<span class="line-added">1153     else if (hasSomeUnacceleratedProperties)</span>
<span class="line-added">1154         m_acceleratedPropertiesState = AcceleratedProperties::Some;</span>
<span class="line-added">1155     else</span>
<span class="line-added">1156         m_acceleratedPropertiesState = AcceleratedProperties::All;</span>
1157 }
1158 
1159 void KeyframeEffect::getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; animatedStyle)
1160 {
1161     if (!m_target || !animation())
1162         return;
1163 
1164     auto progress = getComputedTiming().progress;
<span class="line-added">1165     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;KeyframeEffect &quot; &lt;&lt; this &lt;&lt; &quot; getAnimatedStyle - progress &quot; &lt;&lt; progress);</span>
1166     if (!progress)
1167         return;
1168 
1169     if (!animatedStyle)
1170         animatedStyle = RenderStyle::clonePtr(renderer()-&gt;style());
1171 
1172     setAnimatedPropertiesInStyle(*animatedStyle.get(), progress.value());
1173 }
1174 
1175 void KeyframeEffect::setAnimatedPropertiesInStyle(RenderStyle&amp; targetStyle, double iterationProgress)
1176 {
<span class="line-added">1177     auto&amp; properties = m_blendingKeyframes.properties();</span>
<span class="line-added">1178 </span>
<span class="line-added">1179     // In the case of CSS Transitions we already know that there are only two keyframes, one where offset=0 and one where offset=1,</span>
<span class="line-added">1180     // and only a single CSS property so we can simply blend based on the style available on those keyframes with the provided iteration</span>
<span class="line-added">1181     // progress which already accounts for the transition&#39;s timing function.</span>
<span class="line-added">1182     if (m_blendingKeyframesSource == BlendingKeyframesSource::CSSTransition) {</span>
<span class="line-added">1183         ASSERT(properties.size() == 1);</span>
<span class="line-added">1184         CSSPropertyAnimation::blendProperties(this, *properties.begin(), &amp;targetStyle, m_blendingKeyframes[0].style(), m_blendingKeyframes[1].style(), iterationProgress);</span>
<span class="line-added">1185         return;</span>
<span class="line-added">1186     }</span>
<span class="line-added">1187 </span>
1188     // 4.4.3. The effect value of a keyframe effect
1189     // https://drafts.csswg.org/web-animations-1/#the-effect-value-of-a-keyframe-animation-effect
1190     //
1191     // The effect value of a single property referenced by a keyframe effect as one of its target properties,
1192     // for a given iteration progress, current iteration and underlying value is calculated as follows.
1193 
1194     updateBlendingKeyframes(targetStyle);
1195     if (m_blendingKeyframes.isEmpty())
1196         return;
1197 
<span class="line-modified">1198     for (auto cssPropertyId : properties) {</span>


1199         // 1. If iteration progress is unresolved abort this procedure.
1200         // 2. Let target property be the longhand property for which the effect value is to be calculated.
1201         // 3. If animation type of the target property is not animatable abort this procedure since the effect cannot be applied.
1202         // 4. Define the neutral value for composition as a value which, when combined with an underlying value using the add composite operation,
1203         //    produces the underlying value.
1204 
1205         // 5. Let property-specific keyframes be the result of getting the set of computed keyframes for this keyframe effect.
1206         // 6. Remove any keyframes from property-specific keyframes that do not have a property value for target property.
1207         unsigned numberOfKeyframesWithZeroOffset = 0;
1208         unsigned numberOfKeyframesWithOneOffset = 0;
1209         Vector&lt;Optional&lt;size_t&gt;&gt; propertySpecificKeyframes;
1210         for (size_t i = 0; i &lt; m_blendingKeyframes.size(); ++i) {
1211             auto&amp; keyframe = m_blendingKeyframes[i];
1212             auto offset = keyframe.key();
1213             if (!keyframe.containsProperty(cssPropertyId)) {
1214                 // If we&#39;re dealing with a CSS animation, we consider the first and last keyframes to always have the property listed
1215                 // since the underlying style was provided and should be captured.
<span class="line-modified">1216                 if (m_blendingKeyframesSource == BlendingKeyframesSource::WebAnimation || (offset &amp;&amp; offset &lt; 1))</span>
1217                     continue;
1218             }
1219             if (!offset)
1220                 numberOfKeyframesWithZeroOffset++;
1221             if (offset == 1)
1222                 numberOfKeyframesWithOneOffset++;
1223             propertySpecificKeyframes.append(i);
1224         }
1225 
1226         // 7. If property-specific keyframes is empty, return underlying value.
1227         if (propertySpecificKeyframes.isEmpty())
1228             continue;
1229 
1230         // 8. If there is no keyframe in property-specific keyframes with a computed keyframe offset of 0, create a new keyframe with a computed keyframe
1231         //    offset of 0, a property value set to the neutral value for composition, and a composite operation of add, and prepend it to the beginning of
1232         //    property-specific keyframes.
1233         if (!numberOfKeyframesWithZeroOffset) {
1234             propertySpecificKeyframes.insert(0, WTF::nullopt);
1235             numberOfKeyframesWithZeroOffset = 1;
1236         }
</pre>
<hr />
<pre>
1333 TimingFunction* KeyframeEffect::timingFunctionForKeyframeAtIndex(size_t index)
1334 {
1335     if (!m_parsedKeyframes.isEmpty())
1336         return m_parsedKeyframes[index].timingFunction.get();
1337 
1338     auto effectAnimation = animation();
1339     if (is&lt;DeclarativeAnimation&gt;(effectAnimation)) {
1340         // If we&#39;re dealing with a CSS Animation, the timing function is specified either on the keyframe itself.
1341         if (is&lt;CSSAnimation&gt;(effectAnimation)) {
1342             if (auto* timingFunction = m_blendingKeyframes[index].timingFunction())
1343                 return timingFunction;
1344         }
1345 
1346         // Failing that, or for a CSS Transition, the timing function is inherited from the backing Animation object.
1347         return downcast&lt;DeclarativeAnimation&gt;(effectAnimation)-&gt;backingAnimation().timingFunction();
1348     }
1349 
1350     return nullptr;
1351 }
1352 
<span class="line-modified">1353 void KeyframeEffect::updateAcceleratedActions()</span>
1354 {
<span class="line-modified">1355     if (m_acceleratedPropertiesState == AcceleratedProperties::None)</span>
1356         return;
1357 
<span class="line-modified">1358     auto computedTiming = getComputedTiming();</span>
<span class="line-modified">1359 </span>
<span class="line-modified">1360     // If we&#39;re not already running accelerated, the only thing we&#39;re interested in is whether we need to start the animation</span>
<span class="line-added">1361     // which we need to do once we&#39;re in the active phase. Otherwise, there&#39;s no change in accelerated state to consider.</span>
<span class="line-added">1362     bool isActive = computedTiming.phase == AnimationEffectPhase::Active;</span>
<span class="line-added">1363     if (!m_isRunningAccelerated) {</span>
<span class="line-added">1364         if (isActive &amp;&amp; animation()-&gt;playState() == WebAnimation::PlayState::Running)</span>
<span class="line-added">1365             addPendingAcceleratedAction(AcceleratedAction::Play);</span>
1366         return;
1367     }
1368 
<span class="line-modified">1369     // If we&#39;re no longer active, we need to remove the accelerated animation.</span>
<span class="line-modified">1370     if (!isActive) {</span>
<span class="line-modified">1371         addPendingAcceleratedAction(AcceleratedAction::Stop);</span>




1372         return;
1373     }
1374 
1375     auto playState = animation()-&gt;playState();
<span class="line-added">1376     // The only thing left to consider is whether we need to pause or resume the animation following a change of play-state.</span>
1377     if (playState == WebAnimation::PlayState::Paused) {
1378         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Pause) {
1379             if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop)
1380                 addPendingAcceleratedAction(AcceleratedAction::Play);
1381             addPendingAcceleratedAction(AcceleratedAction::Pause);
1382         }
<span class="line-modified">1383     } else if (playState == WebAnimation::PlayState::Running &amp;&amp; isActive) {</span>














1384         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Play)
1385             addPendingAcceleratedAction(AcceleratedAction::Play);

1386     }
1387 }
1388 
1389 void KeyframeEffect::addPendingAcceleratedAction(AcceleratedAction action)
1390 {
<span class="line-added">1391     if (action == m_lastRecordedAcceleratedAction)</span>
<span class="line-added">1392         return;</span>
<span class="line-added">1393 </span>
1394     if (action == AcceleratedAction::Stop)
1395         m_pendingAcceleratedActions.clear();
1396     m_pendingAcceleratedActions.append(action);
1397     if (action != AcceleratedAction::Seek)
1398         m_lastRecordedAcceleratedAction = action;
1399     animation()-&gt;acceleratedStateDidChange();
1400 }
1401 
<span class="line-added">1402 void KeyframeEffect::animationDidTick()</span>
<span class="line-added">1403 {</span>
<span class="line-added">1404     invalidate();</span>
<span class="line-added">1405     updateAcceleratedActions();</span>
<span class="line-added">1406 }</span>
<span class="line-added">1407 </span>
<span class="line-added">1408 void KeyframeEffect::animationDidPlay()</span>
<span class="line-added">1409 {</span>
<span class="line-added">1410     if (m_acceleratedPropertiesState != AcceleratedProperties::None)</span>
<span class="line-added">1411         addPendingAcceleratedAction(AcceleratedAction::Play);</span>
<span class="line-added">1412 }</span>
<span class="line-added">1413 </span>
1414 void KeyframeEffect::animationDidSeek()
1415 {
1416     // There is no need to seek if we&#39;re not playing an animation already. If seeking
<span class="line-modified">1417     // means we&#39;re moving into an active lexicalGlobalObject, we&#39;ll pick this up in apply().</span>
<span class="line-modified">1418     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
1419         addPendingAcceleratedAction(AcceleratedAction::Seek);
1420 }
1421 
<span class="line-added">1422 void KeyframeEffect::animationWasCanceled()</span>
<span class="line-added">1423 {</span>
<span class="line-added">1424     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
<span class="line-added">1425         addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
<span class="line-added">1426 }</span>
<span class="line-added">1427 </span>
<span class="line-added">1428 void KeyframeEffect::willChangeRenderer()</span>
<span class="line-added">1429 {</span>
<span class="line-added">1430     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
<span class="line-added">1431         addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
<span class="line-added">1432 }</span>
<span class="line-added">1433 </span>
1434 void KeyframeEffect::animationSuspensionStateDidChange(bool animationIsSuspended)
1435 {
<span class="line-modified">1436     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
1437         addPendingAcceleratedAction(animationIsSuspended ? AcceleratedAction::Pause : AcceleratedAction::Play);
1438 }
1439 
1440 void KeyframeEffect::applyPendingAcceleratedActions()
1441 {
1442     // Once an accelerated animation has been committed, we no longer want to force a layout.
1443     // This should have been performed by a call to forceLayoutIfNeeded() prior to applying
1444     // pending accelerated actions.
1445     m_needsForcedLayout = false;
1446 
1447     if (m_pendingAcceleratedActions.isEmpty())
1448         return;
1449 
1450     auto* renderer = this-&gt;renderer();
<span class="line-modified">1451     if (!renderer || !renderer-&gt;isComposited()) {</span>
<span class="line-added">1452         // The renderer may no longer be composited because the accelerated animation ended before we had a chance to update it,</span>
<span class="line-added">1453         // in which case if we asked for the animation to stop, we can discard the current set of accelerated actions.</span>
<span class="line-added">1454         if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop) {</span>
<span class="line-added">1455             m_pendingAcceleratedActions.clear();</span>
<span class="line-added">1456             m_isRunningAccelerated = false;</span>
<span class="line-added">1457         }</span>
1458         return;
<span class="line-added">1459     }</span>
1460 
1461     auto pendingAcceleratedActions = m_pendingAcceleratedActions;
1462     m_pendingAcceleratedActions.clear();
1463 


1464     // To simplify the code we use a default of 0s for an unresolved current time since for a Stop action that is acceptable.
1465     auto timeOffset = animation()-&gt;currentTime().valueOr(0_s).seconds() - delay().seconds();
1466 
1467     for (const auto&amp; action : pendingAcceleratedActions) {
1468         switch (action) {
1469         case AcceleratedAction::Play:
<span class="line-modified">1470             m_isRunningAccelerated = renderer-&gt;startAnimation(timeOffset, backingAnimationForCompositedRenderer(), m_blendingKeyframes);</span>
<span class="line-modified">1471             if (!m_isRunningAccelerated) {</span>
1472                 m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;

1473                 return;
1474             }
1475             break;
1476         case AcceleratedAction::Pause:
<span class="line-modified">1477             renderer-&gt;animationPaused(timeOffset, m_blendingKeyframes.animationName());</span>
1478             break;
1479         case AcceleratedAction::Seek:
<span class="line-modified">1480             renderer-&gt;animationSeeked(timeOffset, m_blendingKeyframes.animationName());</span>
1481             break;
1482         case AcceleratedAction::Stop:
<span class="line-modified">1483             renderer-&gt;animationFinished(m_blendingKeyframes.animationName());</span>
1484             if (!m_target-&gt;document().renderTreeBeingDestroyed())
1485                 m_target-&gt;invalidateStyleAndLayerComposition();
<span class="line-added">1486             m_isRunningAccelerated = false;</span>
1487             break;
1488         }
1489     }
1490 }
1491 
1492 Ref&lt;const Animation&gt; KeyframeEffect::backingAnimationForCompositedRenderer() const
1493 {
1494     auto effectAnimation = animation();
1495     if (is&lt;DeclarativeAnimation&gt;(effectAnimation))
1496         return downcast&lt;DeclarativeAnimation&gt;(effectAnimation)-&gt;backingAnimation();
1497 
1498     // FIXME: The iterationStart and endDelay AnimationEffectTiming properties do not have
1499     // corresponding Animation properties.
1500     auto animation = Animation::create();
1501     animation-&gt;setDuration(iterationDuration().seconds());
1502     animation-&gt;setDelay(delay().seconds());
1503     animation-&gt;setIterationCount(iterations());
1504     animation-&gt;setTimingFunction(timingFunction()-&gt;clone());
1505 
1506     switch (fill()) {
</pre>
<hr />
<pre>
1542     return m_target ? m_target-&gt;renderer() : nullptr;
1543 }
1544 
1545 const RenderStyle&amp; KeyframeEffect::currentStyle() const
1546 {
1547     if (auto* renderer = this-&gt;renderer())
1548         return renderer-&gt;style();
1549     return RenderStyle::defaultStyle();
1550 }
1551 
1552 bool KeyframeEffect::computeExtentOfTransformAnimation(LayoutRect&amp; bounds) const
1553 {
1554     ASSERT(m_blendingKeyframes.containsProperty(CSSPropertyTransform));
1555 
1556     if (!is&lt;RenderBox&gt;(renderer()))
1557         return true; // Non-boxes don&#39;t get transformed;
1558 
1559     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer());
1560     auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
1561 
<span class="line-modified">1562     LayoutRect cumulativeBounds;</span>
1563 
1564     for (const auto&amp; keyframe : m_blendingKeyframes.keyframes()) {
1565         const auto* keyframeStyle = keyframe.style();
1566 
1567         // FIXME: maybe for declarative animations we always say it&#39;s true for the first and last keyframe.
1568         if (!keyframe.containsProperty(CSSPropertyTransform)) {
1569             // If the first keyframe is missing transform style, use the current style.
1570             if (!keyframe.key())
1571                 keyframeStyle = &amp;box.style();
1572             else
1573                 continue;
1574         }
1575 
1576         auto keyframeBounds = bounds;
1577 
1578         bool canCompute;
1579         if (transformFunctionListsMatch())
1580             canCompute = computeTransformedExtentViaTransformList(rendererBox, *keyframeStyle, keyframeBounds);
1581         else
1582             canCompute = computeTransformedExtentViaMatrix(rendererBox, *keyframeStyle, keyframeBounds);
</pre>
</td>
</tr>
</table>
<center><a href="DocumentTimeline.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeEffect.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
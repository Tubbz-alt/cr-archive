<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   3  * Copyright (C) 2012 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;MediaControlElements.h&quot;
  32 
  33 #if ENABLE(VIDEO)
  34 
  35 #include &quot;DOMTokenList.h&quot;
  36 #include &quot;ElementChildIterator.h&quot;
  37 #include &quot;EventHandler.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;Frame.h&quot;
  40 #include &quot;FullscreenManager.h&quot;
  41 #include &quot;GraphicsContext.h&quot;
  42 #include &quot;HTMLHeadingElement.h&quot;
  43 #include &quot;HTMLLIElement.h&quot;
  44 #include &quot;HTMLUListElement.h&quot;
  45 #include &quot;HTMLVideoElement.h&quot;
  46 #include &quot;ImageBuffer.h&quot;
  47 #include &quot;LocalizedStrings.h&quot;
  48 #include &quot;Logging.h&quot;
  49 #include &quot;MediaControls.h&quot;
  50 #include &quot;MouseEvent.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  51 #include &quot;PODInterval.h&quot;</span>
  52 #include &quot;Page.h&quot;
  53 #include &quot;PageGroup.h&quot;
  54 #include &quot;RenderLayer.h&quot;
  55 #include &quot;RenderMediaControlElements.h&quot;
  56 #include &quot;RenderSlider.h&quot;
  57 #include &quot;RenderTheme.h&quot;
  58 #include &quot;RenderVideo.h&quot;
  59 #include &quot;RenderView.h&quot;
  60 #include &quot;Settings.h&quot;
  61 #include &quot;ShadowRoot.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  62 #include &quot;TextTrackCueGeneric.h&quot;</span>
  63 #include &quot;TextTrackList.h&quot;
  64 #include &quot;VTTRegionList.h&quot;
  65 #include &lt;wtf/IsoMallocInlines.h&gt;
  66 #include &lt;wtf/Language.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelElement);
  71 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelEnclosureElement);
  72 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayEnclosureElement);
  73 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineContainerElement);
  74 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderContainerElement);
  75 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlStatusDisplayElement);
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelMuteButtonElement);
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderMuteButtonElement);
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPlayButtonElement);
  79 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayPlayButtonElement);
  80 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekForwardButtonElement);
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekBackButtonElement);
  82 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlRewindButtonElement);
  83 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlReturnToRealtimeButtonElement);
  84 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlToggleClosedCaptionsButtonElement);
  85 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsContainerElement);
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsTrackListElement);
  87 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineElement);
  88 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenButtonElement);
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelVolumeSliderElement);
  90 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeSliderElement);
  91 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMinButtonElement);
  92 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMaxButtonElement);
  93 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimeRemainingDisplayElement);
  94 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlCurrentTimeDisplayElement);
  95 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTextTrackContainerElement);
  96 
  97 using namespace HTMLNames;
  98 
  99 static const AtomString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId();
 100 static const AtomString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId();
 101 
 102 MediaControlPanelElement::MediaControlPanelElement(Document&amp; document)
 103     : MediaControlDivElement(document, MediaControlsPanel)
 104     , m_canBeDragged(false)
 105     , m_isBeingDragged(false)
 106     , m_isDisplayed(false)
 107     , m_opaque(true)
 108     , m_transitionTimer(*this, &amp;MediaControlPanelElement::transitionTimerFired)
 109 {
 110     setPseudo(AtomString(&quot;-webkit-media-controls-panel&quot;, AtomString::ConstructFromLiteral));
 111 }
 112 
 113 Ref&lt;MediaControlPanelElement&gt; MediaControlPanelElement::create(Document&amp; document)
 114 {
 115     return adoptRef(*new MediaControlPanelElement(document));
 116 }
 117 
 118 void MediaControlPanelElement::startDrag(const LayoutPoint&amp; eventLocation)
 119 {
 120     if (!m_canBeDragged)
 121         return;
 122 
 123     if (m_isBeingDragged)
 124         return;
 125 
 126     auto renderer = this-&gt;renderer();
 127     if (!renderer || !renderer-&gt;isBox())
 128         return;
 129 
 130     RefPtr&lt;Frame&gt; frame = document().frame();
 131     if (!frame)
 132         return;
 133 
 134     m_lastDragEventLocation = eventLocation;
 135 
 136     frame-&gt;eventHandler().setCapturingMouseEventsElement(this);
 137 
 138     m_isBeingDragged = true;
 139 }
 140 
 141 void MediaControlPanelElement::continueDrag(const LayoutPoint&amp; eventLocation)
 142 {
 143     if (!m_isBeingDragged)
 144         return;
 145 
 146     LayoutSize distanceDragged = eventLocation - m_lastDragEventLocation;
 147     m_cumulativeDragOffset.move(distanceDragged);
 148     m_lastDragEventLocation = eventLocation;
 149     setPosition(m_cumulativeDragOffset);
 150 }
 151 
 152 void MediaControlPanelElement::endDrag()
 153 {
 154     if (!m_isBeingDragged)
 155         return;
 156 
 157     m_isBeingDragged = false;
 158 
 159     RefPtr&lt;Frame&gt; frame = document().frame();
 160     if (!frame)
 161         return;
 162 
 163     frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
 164 }
 165 
 166 void MediaControlPanelElement::startTimer()
 167 {
 168     stopTimer();
 169 
 170     // The timer is required to set the property display:&#39;none&#39; on the panel,
 171     // such that captions are correctly displayed at the bottom of the video
 172     // at the end of the fadeout transition.
 173     Seconds duration = RenderTheme::singleton().mediaControlsFadeOutDuration();
 174     m_transitionTimer.startOneShot(duration);
 175 }
 176 
 177 void MediaControlPanelElement::stopTimer()
 178 {
 179     if (m_transitionTimer.isActive())
 180         m_transitionTimer.stop();
 181 }
 182 
 183 void MediaControlPanelElement::transitionTimerFired()
 184 {
 185     if (!m_opaque)
 186         hide();
 187 
 188     stopTimer();
 189 }
 190 
 191 void MediaControlPanelElement::setPosition(const LayoutPoint&amp; position)
 192 {
 193     double left = position.x();
 194     double top = position.y();
 195 
 196     // Set the left and top to control the panel&#39;s position; this depends on it being absolute positioned.
 197     // Set the margin to zero since the position passed in will already include the effect of the margin.
<a name="3" id="anc3"></a><span class="line-modified"> 198     setInlineStyleProperty(CSSPropertyLeft, left, CSSUnitType::CSS_PX);</span>
<span class="line-modified"> 199     setInlineStyleProperty(CSSPropertyTop, top, CSSUnitType::CSS_PX);</span>
<span class="line-modified"> 200     setInlineStyleProperty(CSSPropertyMarginLeft, 0.0, CSSUnitType::CSS_PX);</span>
<span class="line-modified"> 201     setInlineStyleProperty(CSSPropertyMarginTop, 0.0, CSSUnitType::CSS_PX);</span>
 202 
 203     classList().add(&quot;dragged&quot;);
 204 }
 205 
 206 void MediaControlPanelElement::resetPosition()
 207 {
 208     removeInlineStyleProperty(CSSPropertyLeft);
 209     removeInlineStyleProperty(CSSPropertyTop);
 210     removeInlineStyleProperty(CSSPropertyMarginLeft);
 211     removeInlineStyleProperty(CSSPropertyMarginTop);
 212 
 213     classList().remove(&quot;dragged&quot;);
 214 
 215     m_cumulativeDragOffset.setX(0);
 216     m_cumulativeDragOffset.setY(0);
 217 }
 218 
 219 void MediaControlPanelElement::makeOpaque()
 220 {
 221     if (m_opaque)
 222         return;
 223 
 224     double duration = RenderTheme::singleton().mediaControlsFadeInDuration();
 225 
 226     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
<a name="4" id="anc4"></a><span class="line-modified"> 227     setInlineStyleProperty(CSSPropertyTransitionDuration, duration, CSSUnitType::CSS_S);</span>
<span class="line-modified"> 228     setInlineStyleProperty(CSSPropertyOpacity, 1.0, CSSUnitType::CSS_NUMBER);</span>
 229 
 230     m_opaque = true;
 231 
 232     if (m_isDisplayed)
 233         show();
 234 }
 235 
 236 void MediaControlPanelElement::makeTransparent()
 237 {
 238     if (!m_opaque)
 239         return;
 240 
 241     Seconds duration = RenderTheme::singleton().mediaControlsFadeOutDuration();
 242 
 243     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
<a name="5" id="anc5"></a><span class="line-modified"> 244     setInlineStyleProperty(CSSPropertyTransitionDuration, duration.value(), CSSUnitType::CSS_S);</span>
<span class="line-modified"> 245     setInlineStyleProperty(CSSPropertyOpacity, 0.0, CSSUnitType::CSS_NUMBER);</span>
 246 
 247     m_opaque = false;
 248     startTimer();
 249 }
 250 
 251 void MediaControlPanelElement::defaultEventHandler(Event&amp; event)
 252 {
 253     MediaControlDivElement::defaultEventHandler(event);
 254 
 255     if (is&lt;MouseEvent&gt;(event)) {
 256         LayoutPoint location = downcast&lt;MouseEvent&gt;(event).absoluteLocation();
 257         if (event.type() == eventNames().mousedownEvent &amp;&amp; event.target() == this) {
 258             startDrag(location);
 259             event.setDefaultHandled();
 260         } else if (event.type() == eventNames().mousemoveEvent &amp;&amp; m_isBeingDragged)
 261             continueDrag(location);
 262         else if (event.type() == eventNames().mouseupEvent &amp;&amp; m_isBeingDragged) {
 263             continueDrag(location);
 264             endDrag();
 265             event.setDefaultHandled();
 266         }
 267     }
 268 }
 269 
 270 void MediaControlPanelElement::setCanBeDragged(bool canBeDragged)
 271 {
 272     if (m_canBeDragged == canBeDragged)
 273         return;
 274 
 275     m_canBeDragged = canBeDragged;
 276 
 277     if (!canBeDragged)
 278         endDrag();
 279 }
 280 
 281 void MediaControlPanelElement::setIsDisplayed(bool isDisplayed)
 282 {
 283     m_isDisplayed = isDisplayed;
 284 }
 285 
 286 // ----------------------------
 287 
 288 MediaControlPanelEnclosureElement::MediaControlPanelEnclosureElement(Document&amp; document)
 289     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 290     : MediaControlDivElement(document, MediaControlsPanel)
 291 {
 292     setPseudo(AtomString(&quot;-webkit-media-controls-enclosure&quot;, AtomString::ConstructFromLiteral));
 293 }
 294 
 295 Ref&lt;MediaControlPanelEnclosureElement&gt; MediaControlPanelEnclosureElement::create(Document&amp; document)
 296 {
 297     return adoptRef(*new MediaControlPanelEnclosureElement(document));
 298 }
 299 
 300 // ----------------------------
 301 
 302 MediaControlOverlayEnclosureElement::MediaControlOverlayEnclosureElement(Document&amp; document)
 303     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 304     : MediaControlDivElement(document, MediaControlsPanel)
 305 {
 306     setPseudo(AtomString(&quot;-webkit-media-controls-overlay-enclosure&quot;, AtomString::ConstructFromLiteral));
 307 }
 308 
 309 Ref&lt;MediaControlOverlayEnclosureElement&gt; MediaControlOverlayEnclosureElement::create(Document&amp; document)
 310 {
 311     return adoptRef(*new MediaControlOverlayEnclosureElement(document));
 312 }
 313 
 314 // ----------------------------
 315 
 316 MediaControlTimelineContainerElement::MediaControlTimelineContainerElement(Document&amp; document)
 317     : MediaControlDivElement(document, MediaTimelineContainer)
 318 {
 319     setPseudo(AtomString(&quot;-webkit-media-controls-timeline-container&quot;, AtomString::ConstructFromLiteral));
 320 }
 321 
 322 Ref&lt;MediaControlTimelineContainerElement&gt; MediaControlTimelineContainerElement::create(Document&amp; document)
 323 {
 324     Ref&lt;MediaControlTimelineContainerElement&gt; element = adoptRef(*new MediaControlTimelineContainerElement(document));
 325     element-&gt;hide();
 326     return element;
 327 }
 328 
 329 void MediaControlTimelineContainerElement::setTimeDisplaysHidden(bool hidden)
 330 {
 331     for (auto&amp; element : childrenOfType&lt;Element&gt;(*this)) {
 332         if (element.shadowPseudoId() != getMediaControlTimeRemainingDisplayElementShadowPseudoId()
 333             &amp;&amp; element.shadowPseudoId() != getMediaControlCurrentTimeDisplayElementShadowPseudoId())
 334             continue;
 335 
 336         MediaControlTimeDisplayElement&amp; timeDisplay = static_cast&lt;MediaControlTimeDisplayElement&amp;&gt;(element);
 337         if (hidden)
 338             timeDisplay.hide();
 339         else
 340             timeDisplay.show();
 341     }
 342 }
 343 
 344 RenderPtr&lt;RenderElement&gt; MediaControlTimelineContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 345 {
 346     return createRenderer&lt;RenderMediaControlTimelineContainer&gt;(*this, WTFMove(style));
 347 }
 348 
 349 // ----------------------------
 350 
 351 MediaControlVolumeSliderContainerElement::MediaControlVolumeSliderContainerElement(Document&amp; document)
 352     : MediaControlDivElement(document, MediaVolumeSliderContainer)
 353 {
 354     setPseudo(AtomString(&quot;-webkit-media-controls-volume-slider-container&quot;, AtomString::ConstructFromLiteral));
 355 }
 356 
 357 Ref&lt;MediaControlVolumeSliderContainerElement&gt; MediaControlVolumeSliderContainerElement::create(Document&amp; document)
 358 {
 359     Ref&lt;MediaControlVolumeSliderContainerElement&gt; element = adoptRef(*new MediaControlVolumeSliderContainerElement(document));
 360     element-&gt;hide();
 361     return element;
 362 }
 363 
 364 RenderPtr&lt;RenderElement&gt; MediaControlVolumeSliderContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 365 {
 366     return createRenderer&lt;RenderMediaVolumeSliderContainer&gt;(*this, WTFMove(style));
 367 }
 368 
 369 void MediaControlVolumeSliderContainerElement::defaultEventHandler(Event&amp; event)
 370 {
 371     // Poor man&#39;s mouseleave event detection.
 372 
 373     if (!is&lt;MouseEvent&gt;(event) || event.type() != eventNames().mouseoutEvent)
 374         return;
 375 
 376     if (!is&lt;Node&gt;(downcast&lt;MouseEvent&gt;(event).relatedTarget()))
 377         return;
 378 
 379     if (containsIncludingShadowDOM(&amp;downcast&lt;Node&gt;(*downcast&lt;MouseEvent&gt;(event).relatedTarget())))
 380         return;
 381 
 382     hide();
 383 }
 384 
 385 // ----------------------------
 386 
 387 MediaControlStatusDisplayElement::MediaControlStatusDisplayElement(Document&amp; document)
 388     : MediaControlDivElement(document, MediaStatusDisplay)
 389     , m_stateBeingDisplayed(Nothing)
 390 {
 391     setPseudo(AtomString(&quot;-webkit-media-controls-status-display&quot;, AtomString::ConstructFromLiteral));
 392 }
 393 
 394 Ref&lt;MediaControlStatusDisplayElement&gt; MediaControlStatusDisplayElement::create(Document&amp; document)
 395 {
 396     Ref&lt;MediaControlStatusDisplayElement&gt; element = adoptRef(*new MediaControlStatusDisplayElement(document));
 397     element-&gt;hide();
 398     return element;
 399 }
 400 
 401 void MediaControlStatusDisplayElement::update()
 402 {
 403     // Get the new state that we&#39;ll have to display.
 404     StateBeingDisplayed newStateToDisplay = Nothing;
 405 
 406     if (mediaController()-&gt;readyState() &lt;= MediaControllerInterface::HAVE_METADATA &amp;&amp; mediaController()-&gt;hasCurrentSrc())
 407         newStateToDisplay = Loading;
 408     else if (mediaController()-&gt;isLiveStream())
 409         newStateToDisplay = LiveBroadcast;
 410 
 411     if (newStateToDisplay == m_stateBeingDisplayed)
 412         return;
 413 
 414     if (m_stateBeingDisplayed == Nothing)
 415         show();
 416     else if (newStateToDisplay == Nothing)
 417         hide();
 418 
 419     m_stateBeingDisplayed = newStateToDisplay;
 420 
 421     switch (m_stateBeingDisplayed) {
 422     case Nothing:
 423         setInnerText(emptyString());
 424         break;
 425     case Loading:
 426         setInnerText(mediaElementLoadingStateText());
 427         break;
 428     case LiveBroadcast:
 429         setInnerText(mediaElementLiveBroadcastStateText());
 430         break;
 431     }
 432 }
 433 
 434 // ----------------------------
 435 
 436 MediaControlPanelMuteButtonElement::MediaControlPanelMuteButtonElement(Document&amp; document, MediaControls* controls)
 437     : MediaControlMuteButtonElement(document, MediaMuteButton)
 438     , m_controls(controls)
 439 {
 440     setPseudo(AtomString(&quot;-webkit-media-controls-mute-button&quot;, AtomString::ConstructFromLiteral));
 441 }
 442 
 443 Ref&lt;MediaControlPanelMuteButtonElement&gt; MediaControlPanelMuteButtonElement::create(Document&amp; document, MediaControls* controls)
 444 {
 445     ASSERT(controls);
 446 
 447     Ref&lt;MediaControlPanelMuteButtonElement&gt; button = adoptRef(*new MediaControlPanelMuteButtonElement(document, controls));
 448     button-&gt;ensureUserAgentShadowRoot();
 449     button-&gt;setType(&quot;button&quot;);
 450     return button;
 451 }
 452 
 453 void MediaControlPanelMuteButtonElement::defaultEventHandler(Event&amp; event)
 454 {
 455     if (event.type() == eventNames().mouseoverEvent)
 456         m_controls-&gt;showVolumeSlider();
 457 
 458     MediaControlMuteButtonElement::defaultEventHandler(event);
 459 }
 460 
 461 // ----------------------------
 462 
 463 MediaControlVolumeSliderMuteButtonElement::MediaControlVolumeSliderMuteButtonElement(Document&amp; document)
 464     : MediaControlMuteButtonElement(document, MediaMuteButton)
 465 {
 466     setPseudo(AtomString(&quot;-webkit-media-controls-volume-slider-mute-button&quot;, AtomString::ConstructFromLiteral));
 467 }
 468 
 469 Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; MediaControlVolumeSliderMuteButtonElement::create(Document&amp; document)
 470 {
 471     Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; button = adoptRef(*new MediaControlVolumeSliderMuteButtonElement(document));
 472     button-&gt;ensureUserAgentShadowRoot();
 473     button-&gt;setType(&quot;button&quot;);
 474     return button;
 475 }
 476 
 477 // ----------------------------
 478 
 479 MediaControlPlayButtonElement::MediaControlPlayButtonElement(Document&amp; document)
 480     : MediaControlInputElement(document, MediaPlayButton)
 481 {
 482     setPseudo(AtomString(&quot;-webkit-media-controls-play-button&quot;, AtomString::ConstructFromLiteral));
 483 }
 484 
 485 Ref&lt;MediaControlPlayButtonElement&gt; MediaControlPlayButtonElement::create(Document&amp; document)
 486 {
 487     Ref&lt;MediaControlPlayButtonElement&gt; button = adoptRef(*new MediaControlPlayButtonElement(document));
 488     button-&gt;ensureUserAgentShadowRoot();
 489     button-&gt;setType(&quot;button&quot;);
 490     return button;
 491 }
 492 
 493 void MediaControlPlayButtonElement::defaultEventHandler(Event&amp; event)
 494 {
 495     if (event.type() == eventNames().clickEvent) {
 496         if (mediaController()-&gt;canPlay())
 497             mediaController()-&gt;play();
 498         else
 499             mediaController()-&gt;pause();
 500         updateDisplayType();
 501         event.setDefaultHandled();
 502     }
 503     HTMLInputElement::defaultEventHandler(event);
 504 }
 505 
 506 void MediaControlPlayButtonElement::updateDisplayType()
 507 {
 508     setDisplayType(mediaController()-&gt;canPlay() ? MediaPlayButton : MediaPauseButton);
 509 }
 510 
 511 // ----------------------------
 512 
 513 MediaControlOverlayPlayButtonElement::MediaControlOverlayPlayButtonElement(Document&amp; document)
 514     : MediaControlInputElement(document, MediaOverlayPlayButton)
 515 {
 516     setPseudo(AtomString(&quot;-webkit-media-controls-overlay-play-button&quot;, AtomString::ConstructFromLiteral));
 517 }
 518 
 519 Ref&lt;MediaControlOverlayPlayButtonElement&gt; MediaControlOverlayPlayButtonElement::create(Document&amp; document)
 520 {
 521     Ref&lt;MediaControlOverlayPlayButtonElement&gt; button = adoptRef(*new MediaControlOverlayPlayButtonElement(document));
 522     button-&gt;ensureUserAgentShadowRoot();
 523     button-&gt;setType(&quot;button&quot;);
 524     return button;
 525 }
 526 
 527 void MediaControlOverlayPlayButtonElement::defaultEventHandler(Event&amp; event)
 528 {
 529     if (event.type() == eventNames().clickEvent &amp;&amp; mediaController()-&gt;canPlay()) {
 530         mediaController()-&gt;play();
 531         updateDisplayType();
 532         event.setDefaultHandled();
 533     }
 534     HTMLInputElement::defaultEventHandler(event);
 535 }
 536 
 537 void MediaControlOverlayPlayButtonElement::updateDisplayType()
 538 {
 539     if (mediaController()-&gt;canPlay()) {
 540         show();
 541     } else
 542         hide();
 543 }
 544 
 545 // ----------------------------
 546 
 547 MediaControlSeekForwardButtonElement::MediaControlSeekForwardButtonElement(Document&amp; document)
 548     : MediaControlSeekButtonElement(document, MediaSeekForwardButton)
 549 {
 550     setPseudo(AtomString(&quot;-webkit-media-controls-seek-forward-button&quot;, AtomString::ConstructFromLiteral));
 551 }
 552 
 553 Ref&lt;MediaControlSeekForwardButtonElement&gt; MediaControlSeekForwardButtonElement::create(Document&amp; document)
 554 {
 555     Ref&lt;MediaControlSeekForwardButtonElement&gt; button = adoptRef(*new MediaControlSeekForwardButtonElement(document));
 556     button-&gt;ensureUserAgentShadowRoot();
 557     button-&gt;setType(&quot;button&quot;);
 558     return button;
 559 }
 560 
 561 // ----------------------------
 562 
 563 MediaControlSeekBackButtonElement::MediaControlSeekBackButtonElement(Document&amp; document)
 564     : MediaControlSeekButtonElement(document, MediaSeekBackButton)
 565 {
 566     setPseudo(AtomString(&quot;-webkit-media-controls-seek-back-button&quot;, AtomString::ConstructFromLiteral));
 567 }
 568 
 569 Ref&lt;MediaControlSeekBackButtonElement&gt; MediaControlSeekBackButtonElement::create(Document&amp; document)
 570 {
 571     Ref&lt;MediaControlSeekBackButtonElement&gt; button = adoptRef(*new MediaControlSeekBackButtonElement(document));
 572     button-&gt;ensureUserAgentShadowRoot();
 573     button-&gt;setType(&quot;button&quot;);
 574     return button;
 575 }
 576 
 577 // ----------------------------
 578 
 579 MediaControlRewindButtonElement::MediaControlRewindButtonElement(Document&amp; document)
 580     : MediaControlInputElement(document, MediaRewindButton)
 581 {
 582     setPseudo(AtomString(&quot;-webkit-media-controls-rewind-button&quot;, AtomString::ConstructFromLiteral));
 583 }
 584 
 585 Ref&lt;MediaControlRewindButtonElement&gt; MediaControlRewindButtonElement::create(Document&amp; document)
 586 {
 587     Ref&lt;MediaControlRewindButtonElement&gt; button = adoptRef(*new MediaControlRewindButtonElement(document));
 588     button-&gt;ensureUserAgentShadowRoot();
 589     button-&gt;setType(&quot;button&quot;);
 590     return button;
 591 }
 592 
 593 void MediaControlRewindButtonElement::defaultEventHandler(Event&amp; event)
 594 {
 595     if (event.type() == eventNames().clickEvent) {
 596         mediaController()-&gt;setCurrentTime(std::max&lt;double&gt;(0, mediaController()-&gt;currentTime() - 30));
 597         event.setDefaultHandled();
 598     }
 599     HTMLInputElement::defaultEventHandler(event);
 600 }
 601 
 602 // ----------------------------
 603 
 604 MediaControlReturnToRealtimeButtonElement::MediaControlReturnToRealtimeButtonElement(Document&amp; document)
 605     : MediaControlInputElement(document, MediaReturnToRealtimeButton)
 606 {
 607     setPseudo(AtomString(&quot;-webkit-media-controls-return-to-realtime-button&quot;, AtomString::ConstructFromLiteral));
 608 }
 609 
 610 Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; MediaControlReturnToRealtimeButtonElement::create(Document&amp; document)
 611 {
 612     Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; button = adoptRef(*new MediaControlReturnToRealtimeButtonElement(document));
 613     button-&gt;ensureUserAgentShadowRoot();
 614     button-&gt;setType(&quot;button&quot;);
 615     button-&gt;hide();
 616     return button;
 617 }
 618 
 619 void MediaControlReturnToRealtimeButtonElement::defaultEventHandler(Event&amp; event)
 620 {
 621     if (event.type() == eventNames().clickEvent) {
 622         mediaController()-&gt;returnToRealtime();
 623         event.setDefaultHandled();
 624     }
 625     HTMLInputElement::defaultEventHandler(event);
 626 }
 627 
 628 // ----------------------------
 629 
 630 MediaControlToggleClosedCaptionsButtonElement::MediaControlToggleClosedCaptionsButtonElement(Document&amp; document, MediaControls* controls)
 631     : MediaControlInputElement(document, MediaShowClosedCaptionsButton)
 632 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
 633     , m_controls(controls)
 634 #endif
 635 {
 636 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) || !PLATFORM(GTK)
 637     UNUSED_PARAM(controls);
 638 #endif
 639     setPseudo(AtomString(&quot;-webkit-media-controls-toggle-closed-captions-button&quot;, AtomString::ConstructFromLiteral));
 640 }
 641 
 642 Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; MediaControlToggleClosedCaptionsButtonElement::create(Document&amp; document, MediaControls* controls)
 643 {
 644     ASSERT(controls);
 645 
 646     Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; button = adoptRef(*new MediaControlToggleClosedCaptionsButtonElement(document, controls));
 647     button-&gt;ensureUserAgentShadowRoot();
 648     button-&gt;setType(&quot;button&quot;);
 649     button-&gt;hide();
 650     return button;
 651 }
 652 
 653 void MediaControlToggleClosedCaptionsButtonElement::updateDisplayType()
 654 {
 655     bool captionsVisible = mediaController()-&gt;closedCaptionsVisible();
 656     setDisplayType(captionsVisible ? MediaHideClosedCaptionsButton : MediaShowClosedCaptionsButton);
 657     setChecked(captionsVisible);
 658 }
 659 
 660 void MediaControlToggleClosedCaptionsButtonElement::defaultEventHandler(Event&amp; event)
 661 {
 662     if (event.type() == eventNames().clickEvent) {
 663         // FIXME: It&#39;s not great that the shared code is dictating behavior of platform-specific
 664         // UI. Not all ports may want the closed captions button to toggle a list of tracks, so
 665         // we have to use #if.
 666         // https://bugs.webkit.org/show_bug.cgi?id=101877
 667 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) &amp;&amp; !PLATFORM(GTK)
 668         mediaController()-&gt;setClosedCaptionsVisible(!mediaController()-&gt;closedCaptionsVisible());
 669         setChecked(mediaController()-&gt;closedCaptionsVisible());
 670         updateDisplayType();
 671 #else
 672         m_controls-&gt;toggleClosedCaptionTrackList();
 673 #endif
 674         event.setDefaultHandled();
 675     }
 676 
 677     HTMLInputElement::defaultEventHandler(event);
 678 }
 679 
 680 // ----------------------------
 681 
 682 MediaControlClosedCaptionsContainerElement::MediaControlClosedCaptionsContainerElement(Document&amp; document)
 683     : MediaControlDivElement(document, MediaClosedCaptionsContainer)
 684 {
 685     setPseudo(AtomString(&quot;-webkit-media-controls-closed-captions-container&quot;, AtomString::ConstructFromLiteral));
 686 }
 687 
 688 Ref&lt;MediaControlClosedCaptionsContainerElement&gt; MediaControlClosedCaptionsContainerElement::create(Document&amp; document)
 689 {
 690     Ref&lt;MediaControlClosedCaptionsContainerElement&gt; element = adoptRef(*new MediaControlClosedCaptionsContainerElement(document));
 691     element-&gt;setAttributeWithoutSynchronization(dirAttr, AtomString(&quot;auto&quot;, AtomString::ConstructFromLiteral));
 692     element-&gt;hide();
 693     return element;
 694 }
 695 
 696 // ----------------------------
 697 
 698 MediaControlClosedCaptionsTrackListElement::MediaControlClosedCaptionsTrackListElement(Document&amp; document, MediaControls* controls)
 699     : MediaControlDivElement(document, MediaClosedCaptionsTrackList)
 700 #if ENABLE(VIDEO_TRACK)
 701     , m_controls(controls)
 702 #endif
 703 {
 704 #if !ENABLE(VIDEO_TRACK)
 705     UNUSED_PARAM(controls);
 706 #endif
 707     setPseudo(AtomString(&quot;-webkit-media-controls-closed-captions-track-list&quot;, AtomString::ConstructFromLiteral));
 708 }
 709 
 710 Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; MediaControlClosedCaptionsTrackListElement::create(Document&amp; document, MediaControls* controls)
 711 {
 712     ASSERT(controls);
 713     Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; element = adoptRef(*new MediaControlClosedCaptionsTrackListElement(document, controls));
 714     return element;
 715 }
 716 
 717 void MediaControlClosedCaptionsTrackListElement::defaultEventHandler(Event&amp; event)
 718 {
 719 #if ENABLE(VIDEO_TRACK)
 720     if (event.type() == eventNames().clickEvent) {
 721         if (!is&lt;Element&gt;(event.target()))
 722             return;
 723 
 724         // When we created the elements in the track list, we gave them a custom
 725         // attribute representing the index in the HTMLMediaElement&#39;s list of tracks.
 726         // Check if the event target has such a custom element and, if so,
 727         // tell the HTMLMediaElement to enable that track.
 728 
 729         auto textTrack = makeRefPtr(m_menuToTrackMap.get(&amp;downcast&lt;Element&gt;(*event.target())));
 730         m_menuToTrackMap.clear();
 731         m_controls-&gt;toggleClosedCaptionTrackList();
 732         if (!textTrack)
 733             return;
 734 
 735         auto mediaElement = parentMediaElement(this);
 736         if (!mediaElement)
 737             return;
 738 
 739         mediaElement-&gt;setSelectedTextTrack(textTrack.get());
 740 
 741         updateDisplay();
 742     }
 743 
 744     MediaControlDivElement::defaultEventHandler(event);
 745 #else
 746     UNUSED_PARAM(event);
 747 #endif
 748 }
 749 
 750 void MediaControlClosedCaptionsTrackListElement::updateDisplay()
 751 {
 752 #if ENABLE(VIDEO_TRACK)
 753     static NeverDestroyed&lt;AtomString&gt; selectedClassValue(&quot;selected&quot;, AtomString::ConstructFromLiteral);
 754 
 755     if (!mediaController()-&gt;hasClosedCaptions())
 756         return;
 757 
 758     if (!document().page())
 759         return;
 760     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
 761 
 762     auto mediaElement = parentMediaElement(this);
 763     if (!mediaElement)
 764         return;
 765 
 766     if (!mediaElement-&gt;textTracks() || !mediaElement-&gt;textTracks()-&gt;length())
 767         return;
 768 
 769     rebuildTrackListMenu();
 770 
 771     RefPtr&lt;Element&gt; offMenuItem;
 772     bool trackMenuItemSelected = false;
 773 
 774     for (auto&amp; trackItem : m_menuItems) {
 775         RefPtr&lt;TextTrack&gt; textTrack;
 776         MenuItemToTrackMap::iterator iter = m_menuToTrackMap.find(trackItem.get());
 777         if (iter == m_menuToTrackMap.end())
 778             continue;
 779         textTrack = iter-&gt;value;
 780         if (!textTrack)
 781             continue;
 782 
 783         if (textTrack == TextTrack::captionMenuOffItem()) {
 784             offMenuItem = trackItem;
 785             continue;
 786         }
 787 
 788         if (textTrack == TextTrack::captionMenuAutomaticItem()) {
 789             if (displayMode == CaptionUserPreferences::Automatic)
 790                 trackItem-&gt;classList().add(selectedClassValue);
 791             else
 792                 trackItem-&gt;classList().remove(selectedClassValue);
 793             continue;
 794         }
 795 
 796         if (displayMode != CaptionUserPreferences::Automatic &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing) {
 797             trackMenuItemSelected = true;
 798             trackItem-&gt;classList().add(selectedClassValue);
 799         } else
 800             trackItem-&gt;classList().remove(selectedClassValue);
 801     }
 802 
 803     if (offMenuItem) {
 804         if (displayMode == CaptionUserPreferences::ForcedOnly &amp;&amp; !trackMenuItemSelected)
 805             offMenuItem-&gt;classList().add(selectedClassValue);
 806         else
 807             offMenuItem-&gt;classList().remove(selectedClassValue);
 808     }
 809 #endif
 810 }
 811 
 812 void MediaControlClosedCaptionsTrackListElement::rebuildTrackListMenu()
 813 {
 814 #if ENABLE(VIDEO_TRACK)
 815     // Remove any existing content.
 816     removeChildren();
 817     m_menuItems.clear();
 818     m_menuToTrackMap.clear();
 819 
 820     if (!mediaController()-&gt;hasClosedCaptions())
 821         return;
 822 
 823     auto mediaElement = parentMediaElement(this);
 824     if (!mediaElement)
 825         return;
 826 
 827     auto* trackList = mediaElement-&gt;textTracks();
 828     if (!trackList || !trackList-&gt;length())
 829         return;
 830 
 831     if (!document().page())
 832         return;
 833     auto&amp; captionPreferences = document().page()-&gt;group().captionPreferences();
 834     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracksForMenu = captionPreferences.sortedTrackListForMenu(trackList);
 835 
 836     auto captionsHeader = HTMLHeadingElement::create(h3Tag, document());
 837     captionsHeader-&gt;appendChild(document().createTextNode(textTrackSubtitlesText()));
 838     appendChild(captionsHeader);
 839     auto captionsMenuList = HTMLUListElement::create(document());
 840 
 841     for (auto&amp; textTrack : tracksForMenu) {
 842         auto menuItem = HTMLLIElement::create(document());
 843         menuItem-&gt;appendChild(document().createTextNode(captionPreferences.displayNameForTrack(textTrack.get())));
 844         captionsMenuList-&gt;appendChild(menuItem);
 845         m_menuItems.append(menuItem.ptr());
 846         m_menuToTrackMap.add(menuItem.ptr(), textTrack);
 847     }
 848 
 849     appendChild(captionsMenuList);
 850 #endif
 851 }
 852 
 853 // ----------------------------
 854 
 855 MediaControlTimelineElement::MediaControlTimelineElement(Document&amp; document, MediaControls* controls)
 856     : MediaControlInputElement(document, MediaSlider)
 857     , m_controls(controls)
 858 {
 859     setPseudo(AtomString(&quot;-webkit-media-controls-timeline&quot;, AtomString::ConstructFromLiteral));
 860 }
 861 
 862 Ref&lt;MediaControlTimelineElement&gt; MediaControlTimelineElement::create(Document&amp; document, MediaControls* controls)
 863 {
 864     ASSERT(controls);
 865 
 866     Ref&lt;MediaControlTimelineElement&gt; timeline = adoptRef(*new MediaControlTimelineElement(document, controls));
 867     timeline-&gt;ensureUserAgentShadowRoot();
 868     timeline-&gt;setType(&quot;range&quot;);
 869     timeline-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomString(&quot;float&quot;, AtomString::ConstructFromLiteral));
 870     return timeline;
 871 }
 872 
 873 void MediaControlTimelineElement::defaultEventHandler(Event&amp; event)
 874 {
 875     // Left button is 0. Rejects mouse events not from left button.
 876     if (is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button())
 877         return;
 878 
 879     if (!renderer())
 880         return;
 881 
 882     if (event.type() == eventNames().mousedownEvent)
 883         mediaController()-&gt;beginScrubbing();
 884 
 885     if (event.type() == eventNames().mouseupEvent)
 886         mediaController()-&gt;endScrubbing();
 887 
 888     MediaControlInputElement::defaultEventHandler(event);
 889 
 890     if (event.type() == eventNames().mouseoverEvent || event.type() == eventNames().mouseoutEvent || event.type() == eventNames().mousemoveEvent)
 891         return;
 892 
 893     double time = value().toDouble();
 894     if ((event.isInputEvent() || event.type() == eventNames().inputEvent) &amp;&amp; time != mediaController()-&gt;currentTime())
 895         mediaController()-&gt;setCurrentTime(time);
 896 
 897     RenderSlider&amp; slider = downcast&lt;RenderSlider&gt;(*renderer());
 898     if (slider.inDragMode())
 899         m_controls-&gt;updateCurrentTimeDisplay();
 900 }
 901 
 902 #if !PLATFORM(IOS_FAMILY)
 903 bool MediaControlTimelineElement::willRespondToMouseClickEvents()
 904 {
 905     if (!renderer())
 906         return false;
 907 
 908     return true;
 909 }
 910 #endif // !PLATFORM(IOS_FAMILY)
 911 
 912 void MediaControlTimelineElement::setPosition(double currentTime)
 913 {
 914     setValue(String::number(currentTime));
 915 }
 916 
 917 void MediaControlTimelineElement::setDuration(double duration)
 918 {
 919     setAttribute(maxAttr, AtomString::number(duration));
 920 }
 921 
 922 // ----------------------------
 923 
 924 MediaControlPanelVolumeSliderElement::MediaControlPanelVolumeSliderElement(Document&amp; document)
 925     : MediaControlVolumeSliderElement(document)
 926 {
 927     setPseudo(AtomString(&quot;-webkit-media-controls-volume-slider&quot;, AtomString::ConstructFromLiteral));
 928 }
 929 
 930 Ref&lt;MediaControlPanelVolumeSliderElement&gt; MediaControlPanelVolumeSliderElement::create(Document&amp; document)
 931 {
 932     Ref&lt;MediaControlPanelVolumeSliderElement&gt; slider = adoptRef(*new MediaControlPanelVolumeSliderElement(document));
 933     slider-&gt;ensureUserAgentShadowRoot();
 934     slider-&gt;setType(&quot;range&quot;);
 935     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomString(&quot;float&quot;, AtomString::ConstructFromLiteral));
 936     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomString(&quot;1&quot;, AtomString::ConstructFromLiteral));
 937     return slider;
 938 }
 939 
 940 // ----------------------------
 941 
 942 MediaControlFullscreenVolumeSliderElement::MediaControlFullscreenVolumeSliderElement(Document&amp; document)
 943     : MediaControlVolumeSliderElement(document)
 944 {
 945     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-volume-slider&quot;, AtomString::ConstructFromLiteral));
 946 }
 947 
 948 Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; MediaControlFullscreenVolumeSliderElement::create(Document&amp; document)
 949 {
 950     Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; slider = adoptRef(*new MediaControlFullscreenVolumeSliderElement(document));
 951     slider-&gt;ensureUserAgentShadowRoot();
 952     slider-&gt;setType(&quot;range&quot;);
 953     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomString(&quot;float&quot;, AtomString::ConstructFromLiteral));
 954     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomString(&quot;1&quot;, AtomString::ConstructFromLiteral));
 955     return slider;
 956 }
 957 
 958 // ----------------------------
 959 
 960 MediaControlFullscreenButtonElement::MediaControlFullscreenButtonElement(Document&amp; document)
 961     : MediaControlInputElement(document, MediaEnterFullscreenButton)
 962 {
 963     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-button&quot;, AtomString::ConstructFromLiteral));
 964 }
 965 
 966 Ref&lt;MediaControlFullscreenButtonElement&gt; MediaControlFullscreenButtonElement::create(Document&amp; document)
 967 {
 968     Ref&lt;MediaControlFullscreenButtonElement&gt; button = adoptRef(*new MediaControlFullscreenButtonElement(document));
 969     button-&gt;ensureUserAgentShadowRoot();
 970     button-&gt;setType(&quot;button&quot;);
 971     button-&gt;hide();
 972     return button;
 973 }
 974 
 975 void MediaControlFullscreenButtonElement::defaultEventHandler(Event&amp; event)
 976 {
 977     if (event.type() == eventNames().clickEvent) {
 978 #if ENABLE(FULLSCREEN_API)
 979         // Only use the new full screen API if the fullScreenEnabled setting has
 980         // been explicitly enabled. Otherwise, use the old fullscreen API. This
 981         // allows apps which embed a WebView to retain the existing full screen
 982         // video implementation without requiring them to implement their own full
 983         // screen behavior.
 984         if (document().settings().fullScreenEnabled()) {
 985             if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == parentMediaElement(this))
 986                 document().fullscreenManager().cancelFullscreen();
 987             else
 988                 document().fullscreenManager().requestFullscreenForElement(parentMediaElement(this).get(), FullscreenManager::ExemptIFrameAllowFullscreenRequirement);
 989         } else
 990 #endif
 991             mediaController()-&gt;enterFullscreen();
 992         event.setDefaultHandled();
 993     }
 994     HTMLInputElement::defaultEventHandler(event);
 995 }
 996 
 997 void MediaControlFullscreenButtonElement::setIsFullscreen(bool isFullscreen)
 998 {
 999     setDisplayType(isFullscreen ? MediaExitFullscreenButton : MediaEnterFullscreenButton);
1000 }
1001 
1002 // ----------------------------
1003 
1004 MediaControlFullscreenVolumeMinButtonElement::MediaControlFullscreenVolumeMinButtonElement(Document&amp; document)
1005     : MediaControlInputElement(document, MediaUnMuteButton)
1006 {
1007     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-volume-min-button&quot;, AtomString::ConstructFromLiteral));
1008 }
1009 
1010 Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; MediaControlFullscreenVolumeMinButtonElement::create(Document&amp; document)
1011 {
1012     Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMinButtonElement(document));
1013     button-&gt;ensureUserAgentShadowRoot();
1014     button-&gt;setType(&quot;button&quot;);
1015     return button;
1016 }
1017 
1018 void MediaControlFullscreenVolumeMinButtonElement::defaultEventHandler(Event&amp; event)
1019 {
1020     if (event.type() == eventNames().clickEvent) {
1021         mediaController()-&gt;setVolume(0);
1022         event.setDefaultHandled();
1023     }
1024     HTMLInputElement::defaultEventHandler(event);
1025 }
1026 
1027 // ----------------------------
1028 
1029 MediaControlFullscreenVolumeMaxButtonElement::MediaControlFullscreenVolumeMaxButtonElement(Document&amp; document)
1030 : MediaControlInputElement(document, MediaMuteButton)
1031 {
1032     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-volume-max-button&quot;, AtomString::ConstructFromLiteral));
1033 }
1034 
1035 Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; MediaControlFullscreenVolumeMaxButtonElement::create(Document&amp; document)
1036 {
1037     Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMaxButtonElement(document));
1038     button-&gt;ensureUserAgentShadowRoot();
1039     button-&gt;setType(&quot;button&quot;);
1040     return button;
1041 }
1042 
1043 void MediaControlFullscreenVolumeMaxButtonElement::defaultEventHandler(Event&amp; event)
1044 {
1045     if (event.type() == eventNames().clickEvent) {
1046         mediaController()-&gt;setVolume(1);
1047         event.setDefaultHandled();
1048     }
1049     HTMLInputElement::defaultEventHandler(event);
1050 }
1051 
1052 // ----------------------------
1053 
1054 MediaControlTimeRemainingDisplayElement::MediaControlTimeRemainingDisplayElement(Document&amp; document)
1055     : MediaControlTimeDisplayElement(document, MediaTimeRemainingDisplay)
1056 {
1057     setPseudo(getMediaControlTimeRemainingDisplayElementShadowPseudoId());
1058 }
1059 
1060 Ref&lt;MediaControlTimeRemainingDisplayElement&gt; MediaControlTimeRemainingDisplayElement::create(Document&amp; document)
1061 {
1062     return adoptRef(*new MediaControlTimeRemainingDisplayElement(document));
1063 }
1064 
1065 static const AtomString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId()
1066 {
1067     static NeverDestroyed&lt;AtomString&gt; id(&quot;-webkit-media-controls-time-remaining-display&quot;, AtomString::ConstructFromLiteral);
1068     return id;
1069 }
1070 
1071 // ----------------------------
1072 
1073 MediaControlCurrentTimeDisplayElement::MediaControlCurrentTimeDisplayElement(Document&amp; document)
1074     : MediaControlTimeDisplayElement(document, MediaCurrentTimeDisplay)
1075 {
1076     setPseudo(getMediaControlCurrentTimeDisplayElementShadowPseudoId());
1077 }
1078 
1079 Ref&lt;MediaControlCurrentTimeDisplayElement&gt; MediaControlCurrentTimeDisplayElement::create(Document&amp; document)
1080 {
1081     return adoptRef(*new MediaControlCurrentTimeDisplayElement(document));
1082 }
1083 
1084 static const AtomString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId()
1085 {
1086     static NeverDestroyed&lt;AtomString&gt; id(&quot;-webkit-media-controls-current-time-display&quot;, AtomString::ConstructFromLiteral);
1087     return id;
1088 }
1089 
1090 // ----------------------------
1091 
1092 #if ENABLE(VIDEO_TRACK)
1093 
1094 MediaControlTextTrackContainerElement::MediaControlTextTrackContainerElement(Document&amp; document)
1095     : MediaControlDivElement(document, MediaTextTrackDisplayContainer)
1096     , m_updateTimer(*this, &amp;MediaControlTextTrackContainerElement::updateTimerFired)
1097     , m_fontSize(0)
1098     , m_fontSizeIsImportant(false)
1099     , m_updateTextTrackRepresentationStyle(false)
1100 {
1101     setPseudo(AtomString(&quot;-webkit-media-text-track-container&quot;, AtomString::ConstructFromLiteral));
1102 }
1103 
1104 Ref&lt;MediaControlTextTrackContainerElement&gt; MediaControlTextTrackContainerElement::create(Document&amp; document)
1105 {
1106     auto element = adoptRef(*new MediaControlTextTrackContainerElement(document));
1107     element-&gt;hide();
1108     return element;
1109 }
1110 
1111 RenderPtr&lt;RenderElement&gt; MediaControlTextTrackContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1112 {
1113     return createRenderer&lt;RenderTextTrackContainerElement&gt;(*this, WTFMove(style));
1114 }
1115 
1116 static bool compareCueIntervalForDisplay(const CueInterval&amp; one, const CueInterval&amp; two)
1117 {
1118     return one.data()-&gt;isPositionedAbove(two.data());
1119 };
1120 
1121 void MediaControlTextTrackContainerElement::updateDisplay()
1122 {
1123     if (!mediaController()-&gt;closedCaptionsVisible())
1124         removeChildren();
1125 
1126     auto mediaElement = parentMediaElement(this);
1127     // 1. If the media element is an audio element, or is another playback
1128     // mechanism with no rendering area, abort these steps. There is nothing to
1129     // render.
<a name="6" id="anc6"></a><span class="line-modified">1130     if (!mediaElement || !mediaElement-&gt;isVideo() || m_videoDisplaySize.size().isEmpty())</span>
1131         return;
1132 
1133     // 2. Let video be the media element or other playback mechanism.
1134     HTMLVideoElement&amp; video = downcast&lt;HTMLVideoElement&gt;(*mediaElement);
1135 
1136     // 3. Let output be an empty list of absolutely positioned CSS block boxes.
<a name="7" id="anc7"></a>
1137 
1138     // 4. If the user agent is exposing a user interface for video, add to
1139     // output one or more completely transparent positioned CSS block boxes that
1140     // cover the same region as the user interface.
1141 
1142     // 5. If the last time these rules were run, the user agent was not exposing
1143     // a user interface for video, but now it is, let reset be true. Otherwise,
1144     // let reset be false.
1145 
1146     // There is nothing to be done explicitly for 4th and 5th steps, as
1147     // everything is handled through CSS. The caption box is on top of the
1148     // controls box, in a container set with the -webkit-box display property.
1149 
1150     // 6. Let tracks be the subset of video&#39;s list of text tracks that have as
1151     // their rules for updating the text track rendering these rules for
1152     // updating the display of WebVTT text tracks, and whose text track mode is
1153     // showing or showing by default.
1154     // 7. Let cues be an empty list of text track cues.
1155     // 8. For each track track in tracks, append to cues all the cues from
1156     // track&#39;s list of cues that have their text track cue active flag set.
1157     CueList activeCues = video.currentlyActiveCues();
1158 
1159     // 9. If reset is false, then, for each text track cue cue in cues: if cue&#39;s
1160     // text track cue display state has a set of CSS boxes, then add those boxes
1161     // to output, and remove cue from cues.
1162 
1163     // There is nothing explicitly to be done here, as all the caching occurs
1164     // within the TextTrackCue instance itself. If parameters of the cue change,
1165     // the display tree is cleared.
1166 
1167     // If the number of CSS boxes in the output is less than the number of cues
1168     // we wish to render (e.g., we are adding another cue in a set of roll-up
1169     // cues), remove all the existing CSS boxes representing the cues and re-add
1170     // them so that the new cue is at the bottom.
1171     // FIXME: Calling countChildNodes() here is inefficient. We don&#39;t need to
1172     // traverse all children just to check if there are less children than cues.
1173     if (countChildNodes() &lt; activeCues.size())
1174         removeChildren();
1175 
1176     activeCues.removeAllMatching([] (CueInterval&amp; cueInterval) {
<a name="8" id="anc8"></a><span class="line-modified">1177         RefPtr&lt;TextTrackCue&gt; cue = cueInterval.data();</span>
<span class="line-modified">1178         return !cue-&gt;track()</span>





1179             || !cue-&gt;track()-&gt;isRendered()
1180             || cue-&gt;track()-&gt;mode() == TextTrack::Mode::Disabled
1181             || !cue-&gt;isActive()
<a name="9" id="anc9"></a><span class="line-modified">1182             || !cue-&gt;isRenderable();</span>
1183     });
1184 
1185     // Sort the active cues for the appropriate display order. For example, for roll-up
1186     // or paint-on captions, we need to add the cues in reverse chronological order,
1187     // so that the newest captions appear at the bottom.
1188     std::sort(activeCues.begin(), activeCues.end(), &amp;compareCueIntervalForDisplay);
1189 
<a name="10" id="anc10"></a><span class="line-modified">1190     if (mediaController()-&gt;closedCaptionsVisible()) {</span>
<span class="line-modified">1191         // 10. For each text track cue cue in cues that has not yet had</span>
<span class="line-modified">1192         // corresponding CSS boxes added to output, in text track cue order, run the</span>
<span class="line-modified">1193         // following substeps:</span>
<span class="line-modified">1194         for (auto&amp; interval : activeCues) {</span>
<span class="line-modified">1195             auto cue = interval.data();</span>
<span class="line-modified">1196             cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);</span>
<span class="line-modified">1197             if (is&lt;VTTCue&gt;(cue) || is&lt;TextTrackCueGeneric&gt;(cue))</span>
<span class="line-modified">1198                 processActiveVTTCue(*toVTTCue(cue));</span>
<span class="line-modified">1199             else {</span>
<span class="line-modified">1200                 auto displayBox = cue-&gt;getDisplayTree(m_videoDisplaySize.size(), m_fontSize);</span>
<span class="line-modified">1201                 if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.get()))</span>
<span class="line-modified">1202                     appendChild(*displayBox);</span>







1203             }
<a name="11" id="anc11"></a>









1204         }
1205     }
1206 
1207     // 11. Return output.
1208     if (hasChildNodes()) {
1209         show();
1210         updateTextTrackRepresentation();
1211     } else {
1212         hide();
1213         clearTextTrackRepresentation();
1214     }
1215 }
1216 
<a name="12" id="anc12"></a><span class="line-added">1217 void MediaControlTextTrackContainerElement::processActiveVTTCue(VTTCue&amp; cue)</span>
<span class="line-added">1218 {</span>
<span class="line-added">1219     ASSERT(is&lt;VTTCue&gt;(cue) || is&lt;TextTrackCueGeneric&gt;(cue));</span>
<span class="line-added">1220 </span>
<span class="line-added">1221     DEBUG_LOG(LOGIDENTIFIER, &quot;adding and positioning cue: \&quot;&quot;, cue.text(), &quot;\&quot;, start=&quot;, cue.startTime(), &quot;, end=&quot;, cue.endTime(), &quot;, line=&quot;, cue.line());</span>
<span class="line-added">1222     Ref&lt;TextTrackCueBox&gt; displayBox = *cue.getDisplayTree(m_videoDisplaySize.size(), m_fontSize);</span>
<span class="line-added">1223 </span>
<span class="line-added">1224     if (auto region = cue.track()-&gt;regions()-&gt;getRegionById(cue.regionId())) {</span>
<span class="line-added">1225         // Let region be the WebVTT region whose region identifier</span>
<span class="line-added">1226         // matches the text track cue region identifier of cue.</span>
<span class="line-added">1227         Ref&lt;HTMLDivElement&gt; regionNode = region-&gt;getDisplayTree();</span>
<span class="line-added">1228 </span>
<span class="line-added">1229         if (!contains(regionNode.ptr()))</span>
<span class="line-added">1230             appendChild(region-&gt;getDisplayTree());</span>
<span class="line-added">1231 </span>
<span class="line-added">1232         region-&gt;appendTextTrackCueBox(WTFMove(displayBox));</span>
<span class="line-added">1233     } else {</span>
<span class="line-added">1234         // If cue has an empty text track cue region identifier or there is no</span>
<span class="line-added">1235         // WebVTT region whose region identifier is identical to cue&#39;s text</span>
<span class="line-added">1236         // track cue region identifier, run the following substeps:</span>
<span class="line-added">1237         if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.ptr())) {</span>
<span class="line-added">1238             // Note: the display tree of a cue is removed when the active flag of the cue is unset.</span>
<span class="line-added">1239             appendChild(displayBox);</span>
<span class="line-added">1240         }</span>
<span class="line-added">1241     }</span>
<span class="line-added">1242 }</span>
<span class="line-added">1243 </span>
1244 void MediaControlTextTrackContainerElement::updateActiveCuesFontSize()
1245 {
1246     if (!document().page())
1247         return;
1248 
1249     auto mediaElement = parentMediaElement(this);
1250     if (!mediaElement)
1251         return;
1252 
1253     float smallestDimension = std::min(m_videoDisplaySize.size().height(), m_videoDisplaySize.size().width());
1254     float fontScale = document().page()-&gt;group().captionPreferences().captionFontSizeScaleAndImportance(m_fontSizeIsImportant);
1255     m_fontSize = lroundf(smallestDimension * fontScale);
1256 
1257     for (auto&amp; activeCue : mediaElement-&gt;currentlyActiveCues()) {
1258         RefPtr&lt;TextTrackCue&gt; cue = activeCue.data();
<a name="13" id="anc13"></a><span class="line-modified">1259         if (cue-&gt;isRenderable())</span>
<span class="line-modified">1260             cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);</span>


1261     }
<a name="14" id="anc14"></a>
1262 }
1263 
1264 void MediaControlTextTrackContainerElement::updateTextStrokeStyle()
1265 {
1266     if (!document().page())
1267         return;
1268 
1269     auto mediaElement = parentMediaElement(this);
1270     if (!mediaElement)
1271         return;
1272 
1273     String language;
1274 
1275     // FIXME: Since it is possible to have more than one text track enabled, the following code may not find the correct language.
1276     // The default UI only allows a user to enable one track at a time, so it should be OK for now, but we should consider doing
1277     // this differently, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169875&gt;.
1278     if (auto* tracks = mediaElement-&gt;textTracks()) {
1279         for (unsigned i = 0; i &lt; tracks-&gt;length(); ++i) {
1280             auto track = tracks-&gt;item(i);
1281             if (track &amp;&amp; track-&gt;mode() == TextTrack::Mode::Showing) {
1282                 language = track-&gt;validBCP47Language();
1283                 break;
1284             }
1285         }
1286     }
1287 
1288     float strokeWidth;
1289     bool important;
1290 
1291     // FIXME: find a way to set this property in the stylesheet like the other user style preferences, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169874&gt;.
1292     if (document().page()-&gt;group().captionPreferences().captionStrokeWidthForFont(m_fontSize, language, strokeWidth, important))
<a name="15" id="anc15"></a><span class="line-modified">1293         setInlineStyleProperty(CSSPropertyStrokeWidth, strokeWidth, CSSUnitType::CSS_PX, important);</span>
1294 }
1295 
1296 void MediaControlTextTrackContainerElement::updateTimerFired()
1297 {
1298     if (!document().page())
1299         return;
1300 
<a name="16" id="anc16"></a><span class="line-added">1301     auto mediaElement = parentMediaElement(this);</span>
<span class="line-added">1302     if (!mediaElement)</span>
<span class="line-added">1303         return;</span>
<span class="line-added">1304 </span>
<span class="line-added">1305     for (auto&amp; activeCue : mediaElement-&gt;currentlyActiveCues())</span>
<span class="line-added">1306         activeCue.data()-&gt;recalculateStyles();</span>
<span class="line-added">1307 </span>
1308     if (m_textTrackRepresentation)
1309         updateStyleForTextTrackRepresentation();
1310 
1311     updateActiveCuesFontSize();
1312     updateDisplay();
1313     updateTextStrokeStyle();
1314 }
1315 
1316 void MediaControlTextTrackContainerElement::updateTextTrackRepresentation()
1317 {
1318     auto mediaElement = parentMediaElement(this);
1319     if (!mediaElement)
1320         return;
1321 
1322     if (!mediaElement-&gt;requiresTextTrackRepresentation()) {
1323         if (m_textTrackRepresentation) {
1324             clearTextTrackRepresentation();
<a name="17" id="anc17"></a><span class="line-modified">1325             updateSizes(ForceUpdate::Yes);</span>
1326         }
1327         return;
1328     }
1329 
1330     if (!m_textTrackRepresentation) {
1331         m_textTrackRepresentation = TextTrackRepresentation::create(*this);
1332         if (document().page())
1333             m_textTrackRepresentation-&gt;setContentScale(document().page()-&gt;deviceScaleFactor());
1334         m_updateTextTrackRepresentationStyle = true;
1335         mediaElement-&gt;setTextTrackRepresentation(m_textTrackRepresentation.get());
1336     }
1337 
1338     m_textTrackRepresentation-&gt;update();
1339     updateStyleForTextTrackRepresentation();
1340 }
1341 
1342 void MediaControlTextTrackContainerElement::clearTextTrackRepresentation()
1343 {
1344     if (!m_textTrackRepresentation)
1345         return;
1346 
1347     m_textTrackRepresentation = nullptr;
1348     m_updateTextTrackRepresentationStyle = true;
1349     if (auto mediaElement = parentMediaElement(this))
1350         mediaElement-&gt;setTextTrackRepresentation(nullptr);
1351     updateStyleForTextTrackRepresentation();
1352     updateActiveCuesFontSize();
1353 }
1354 
1355 void MediaControlTextTrackContainerElement::updateStyleForTextTrackRepresentation()
1356 {
1357     if (!m_updateTextTrackRepresentationStyle)
1358         return;
<a name="18" id="anc18"></a><span class="line-added">1359 </span>
1360     m_updateTextTrackRepresentationStyle = false;
1361 
1362     if (m_textTrackRepresentation) {
<a name="19" id="anc19"></a><span class="line-modified">1363         setInlineStyleProperty(CSSPropertyWidth, m_videoDisplaySize.size().width(), CSSUnitType::CSS_PX);</span>
<span class="line-modified">1364         setInlineStyleProperty(CSSPropertyHeight, m_videoDisplaySize.size().height(), CSSUnitType::CSS_PX);</span>
1365         setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
<a name="20" id="anc20"></a><span class="line-modified">1366         setInlineStyleProperty(CSSPropertyLeft, 0, CSSUnitType::CSS_PX);</span>
<span class="line-modified">1367         setInlineStyleProperty(CSSPropertyTop, 0, CSSUnitType::CSS_PX);</span>
1368         return;
1369     }
1370 
1371     removeInlineStyleProperty(CSSPropertyPosition);
1372     removeInlineStyleProperty(CSSPropertyWidth);
1373     removeInlineStyleProperty(CSSPropertyHeight);
1374     removeInlineStyleProperty(CSSPropertyLeft);
1375     removeInlineStyleProperty(CSSPropertyTop);
1376 }
1377 
1378 void MediaControlTextTrackContainerElement::enteredFullscreen()
1379 {
1380     if (hasChildNodes())
1381         updateTextTrackRepresentation();
<a name="21" id="anc21"></a><span class="line-modified">1382     updateSizes(ForceUpdate::Yes);</span>
1383 }
1384 
1385 void MediaControlTextTrackContainerElement::exitedFullscreen()
1386 {
1387     clearTextTrackRepresentation();
<a name="22" id="anc22"></a><span class="line-modified">1388     updateSizes(ForceUpdate::Yes);</span>
1389 }
1390 
<a name="23" id="anc23"></a><span class="line-modified">1391 void MediaControlTextTrackContainerElement::updateSizes(ForceUpdate force)</span>
1392 {
1393     auto mediaElement = parentMediaElement(this);
1394     if (!mediaElement)
1395         return;
1396 
1397     if (!document().page())
1398         return;
1399 
1400     IntRect videoBox;
1401     if (m_textTrackRepresentation) {
1402         videoBox = m_textTrackRepresentation-&gt;bounds();
1403         float deviceScaleFactor = document().page()-&gt;deviceScaleFactor();
1404         videoBox.setWidth(videoBox.width() * deviceScaleFactor);
1405         videoBox.setHeight(videoBox.height() * deviceScaleFactor);
1406     } else {
1407         if (!is&lt;RenderVideo&gt;(mediaElement-&gt;renderer()))
1408             return;
1409         videoBox = downcast&lt;RenderVideo&gt;(*mediaElement-&gt;renderer()).videoBox();
1410     }
1411 
<a name="24" id="anc24"></a><span class="line-modified">1412     if (force == ForceUpdate::No &amp;&amp; m_videoDisplaySize == videoBox)</span>
1413         return;
1414 
1415     m_videoDisplaySize = videoBox;
1416     m_updateTextTrackRepresentationStyle = true;
1417     mediaElement-&gt;syncTextTrackBounds();
1418 
1419     // FIXME (121170): This function is called during layout, and should lay out the text tracks immediately.
1420     m_updateTimer.startOneShot(0_s);
1421 }
1422 
1423 RefPtr&lt;Image&gt; MediaControlTextTrackContainerElement::createTextTrackRepresentationImage()
1424 {
1425     if (!hasChildNodes())
1426         return nullptr;
1427 
1428     RefPtr&lt;Frame&gt; frame = document().frame();
1429     if (!frame)
1430         return nullptr;
1431 
1432     document().updateLayout();
1433 
1434     auto* renderer = this-&gt;renderer();
1435     if (!renderer)
1436         return nullptr;
1437 
1438     if (!renderer-&gt;hasLayer())
1439         return nullptr;
1440 
1441     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(*renderer).layer();
1442 
1443     float deviceScaleFactor = 1;
1444     if (Page* page = document().page())
1445         deviceScaleFactor = page-&gt;deviceScaleFactor();
1446 
1447     IntRect paintingRect = IntRect(IntPoint(), layer-&gt;size());
1448 
1449     // FIXME (149422): This buffer should not be unconditionally unaccelerated.
<a name="25" id="anc25"></a><span class="line-modified">1450     std::unique_ptr&lt;ImageBuffer&gt; buffer(ImageBuffer::create(paintingRect.size(), RenderingMode::Unaccelerated, deviceScaleFactor));</span>
1451     if (!buffer)
1452         return nullptr;
1453 
1454     layer-&gt;paint(buffer-&gt;context(), paintingRect, LayoutSize(), { PaintBehavior::FlattenCompositingLayers, PaintBehavior::Snapshotting }, nullptr, RenderLayer::paintLayerPaintingCompositingAllPhasesFlags());
1455 
1456     return ImageBuffer::sinkIntoImage(WTFMove(buffer));
1457 }
1458 
1459 void MediaControlTextTrackContainerElement::textTrackRepresentationBoundsChanged(const IntRect&amp;)
1460 {
1461     if (hasChildNodes())
1462         updateTextTrackRepresentation();
1463     updateSizes();
1464 }
1465 
1466 #if !RELEASE_LOG_DISABLED
1467 const Logger&amp; MediaControlTextTrackContainerElement::logger() const
1468 {
1469     return document().logger();
1470 }
1471 
1472 const void* MediaControlTextTrackContainerElement::logIdentifier() const
1473 {
1474     if (auto mediaElement = parentMediaElement(this))
1475         return mediaElement-&gt;logIdentifier();
1476     return nullptr;
1477 }
1478 
1479 WTFLogChannel&amp; MediaControlTextTrackContainerElement::logChannel() const
1480 {
1481     return LogMedia;
1482 }
1483 #endif // !RELEASE_LOG_DISABLED
1484 
1485 #endif // ENABLE(VIDEO_TRACK)
1486 
1487 // ----------------------------
1488 
1489 } // namespace WebCore
1490 
1491 #endif // ENABLE(VIDEO)
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/RegExpPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 24  */
 25 
 26 @globalPrivate
 27 @constructor
 28 function RegExpStringIterator(regExp, string, global, fullUnicode)
 29 {
 30     &quot;use strict&quot;;
 31 
 32     @putByIdDirectPrivate(this, &quot;regExpStringIteratorRegExp&quot;, regExp);
 33     @putByIdDirectPrivate(this, &quot;regExpStringIteratorString&quot;, string);
 34     @putByIdDirectPrivate(this, &quot;regExpStringIteratorGlobal&quot;, global);
 35     @putByIdDirectPrivate(this, &quot;regExpStringIteratorUnicode&quot;, fullUnicode);
 36     @putByIdDirectPrivate(this, &quot;regExpStringIteratorDone&quot;, false);
 37 }
 38 
 39 @globalPrivate
 40 function advanceStringIndex(string, index, unicode)
 41 {
 42     // This function implements AdvanceStringIndex described in ES6 21.2.5.2.3.
 43     &quot;use strict&quot;;
 44 
 45     if (!unicode)
 46         return index + 1;
 47 
 48     if (index + 1 &gt;= string.length)
 49         return index + 1;
 50 
<a name="1" id="anc1"></a><span class="line-modified"> 51     var first = string.@charCodeAt(index);</span>
 52     if (first &lt; 0xD800 || first &gt; 0xDBFF)
 53         return index + 1;
 54 
<a name="2" id="anc2"></a><span class="line-modified"> 55     var second = string.@charCodeAt(index + 1);</span>
 56     if (second &lt; 0xDC00 || second &gt; 0xDFFF)
 57         return index + 1;
 58 
 59     return index + 2;
 60 }
 61 
 62 @globalPrivate
 63 function regExpExec(regexp, str)
 64 {
 65     &quot;use strict&quot;;
 66 
<a name="3" id="anc3"></a><span class="line-modified"> 67     var exec = regexp.exec;</span>
<span class="line-modified"> 68     var builtinExec = @regExpBuiltinExec;</span>
 69     if (exec !== builtinExec &amp;&amp; typeof exec === &quot;function&quot;) {
<a name="4" id="anc4"></a><span class="line-modified"> 70         var result = exec.@call(regexp, str);</span>
 71         if (result !== null &amp;&amp; !@isObject(result))
 72             @throwTypeError(&quot;The result of a RegExp exec must be null or an object&quot;);
 73         return result;
 74     }
 75     return builtinExec.@call(regexp, str);
 76 }
 77 
 78 @globalPrivate
 79 function hasObservableSideEffectsForRegExpMatch(regexp)
 80 {
 81     &quot;use strict&quot;;
 82 
 83     if (!@isRegExpObject(regexp))
 84         return true;
 85 
 86     // This is accessed by the RegExpExec internal function.
<a name="5" id="anc5"></a><span class="line-modified"> 87     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
 88     if (regexpExec !== @regExpBuiltinExec)
 89         return true;
 90 
<a name="6" id="anc6"></a><span class="line-modified"> 91     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
 92     if (regexpGlobal !== @regExpProtoGlobalGetter)
 93         return true;
<a name="7" id="anc7"></a><span class="line-modified"> 94     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
 95     if (regexpUnicode !== @regExpProtoUnicodeGetter)
 96         return true;
 97 
 98     return typeof regexp.lastIndex !== &quot;number&quot;;
 99 }
100 
101 @globalPrivate
102 function matchSlow(regexp, str)
103 {
104     &quot;use strict&quot;;
105 
106     if (!regexp.global)
107         return @regExpExec(regexp, str);
108     
<a name="8" id="anc8"></a><span class="line-modified">109     var unicode = regexp.unicode;</span>
110     regexp.lastIndex = 0;
<a name="9" id="anc9"></a><span class="line-modified">111     var resultList = [];</span>
112 
113     // FIXME: It would be great to implement a solution similar to what we do in
114     // RegExpObject::matchGlobal(). It&#39;s not clear if this is possible, since this loop has
115     // effects. https://bugs.webkit.org/show_bug.cgi?id=158145
<a name="10" id="anc10"></a><span class="line-modified">116     var maximumReasonableMatchSize = 100000000;</span>
117 
118     while (true) {
<a name="11" id="anc11"></a><span class="line-modified">119         var result = @regExpExec(regexp, str);</span>
120         
121         if (result === null) {
122             if (resultList.length === 0)
123                 return null;
124             return resultList;
125         }
126 
127         if (resultList.length &gt; maximumReasonableMatchSize)
128             @throwOutOfMemoryError();
129 
<a name="12" id="anc12"></a><span class="line-modified">130         var resultString = @toString(result[0]);</span>
131 
132         if (!resultString.length)
133             regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
134 
135         resultList.@push(resultString);
136     }
137 }
138 
139 @overriddenName=&quot;[Symbol.match]&quot;
140 function match(strArg)
141 {
142     &quot;use strict&quot;;
143 
144     if (!@isObject(this))
145         @throwTypeError(&quot;RegExp.prototype.@@match requires that |this| be an Object&quot;);
146 
<a name="13" id="anc13"></a><span class="line-modified">147     var str = @toString(strArg);</span>
148 
149     // Check for observable side effects and call the fast path if there aren&#39;t any.
150     if (!@hasObservableSideEffectsForRegExpMatch(this))
151         return @regExpMatchFast.@call(this, str);
152     return @matchSlow(this, str);
153 }
154 
155 @overriddenName=&quot;[Symbol.matchAll]&quot;
156 function matchAll(strArg)
157 {
158     &quot;use strict&quot;;
159 
<a name="14" id="anc14"></a><span class="line-modified">160     var regExp = this;</span>
161     if (!@isObject(regExp))
162         @throwTypeError(&quot;RegExp.prototype.@@matchAll requires |this| to be an Object&quot;);
163 
<a name="15" id="anc15"></a><span class="line-modified">164     var string = @toString(strArg);</span>
<span class="line-modified">165     var Matcher = @speciesConstructor(regExp, @RegExp);</span>
166 
<a name="16" id="anc16"></a><span class="line-modified">167     var flags = @toString(regExp.flags);</span>
<span class="line-modified">168     var matcher = new Matcher(regExp, flags);</span>
169     matcher.lastIndex = @toLength(regExp.lastIndex);
170 
<a name="17" id="anc17"></a><span class="line-modified">171     var global = @stringIncludesInternal.@call(flags, &quot;g&quot;);</span>
<span class="line-modified">172     var fullUnicode = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
173 
174     return new @RegExpStringIterator(matcher, string, global, fullUnicode);
175 }
176 
177 @overriddenName=&quot;[Symbol.replace]&quot;
178 function replace(strArg, replace)
179 {
180     &quot;use strict&quot;;
181 
<a name="18" id="anc18"></a><span class="line-modified">182     function getSubstitution(matched, str, position, captures, namedCaptures, replacement)</span>
183     {
184         &quot;use strict&quot;;
185 
<a name="19" id="anc19"></a><span class="line-modified">186         var matchLength = matched.length;</span>
<span class="line-modified">187         var stringLength = str.length;</span>
<span class="line-modified">188         var tailPos = position + matchLength;</span>
<span class="line-modified">189         var m = captures.length;</span>
<span class="line-modified">190         var replacementLength = replacement.length;</span>
<span class="line-modified">191         var result = &quot;&quot;;</span>
<span class="line-modified">192         var lastStart = 0;</span>
193 
<a name="20" id="anc20"></a><span class="line-modified">194         for (var start = 0; start = replacement.indexOf(&quot;$&quot;, lastStart), start !== -1; lastStart = start) {</span>
195             if (start - lastStart &gt; 0)
196                 result = result + replacement.substring(lastStart, start);
197             start++;
<a name="21" id="anc21"></a><span class="line-modified">198             var ch = replacement.charAt(start);</span>
199             if (ch === &quot;&quot;)
200                 result = result + &quot;$&quot;;
201             else {
202                 switch (ch)
203                 {
204                 case &quot;$&quot;:
205                     result = result + &quot;$&quot;;
206                     start++;
207                     break;
208                 case &quot;&amp;&quot;:
209                     result = result + matched;
210                     start++;
211                     break;
212                 case &quot;`&quot;:
213                     if (position &gt; 0)
214                         result = result + str.substring(0, position);
215                     start++;
216                     break;
217                 case &quot;&#39;&quot;:
218                     if (tailPos &lt; stringLength)
219                         result = result + str.substring(tailPos);
220                     start++;
221                     break;
<a name="22" id="anc22"></a><span class="line-added">222                 case &quot;&lt;&quot;:</span>
<span class="line-added">223                     if (namedCaptures !== @undefined) {</span>
<span class="line-added">224                         var groupNameStartIndex = start + 1;</span>
<span class="line-added">225                         var groupNameEndIndex = replacement.indexOf(&quot;&gt;&quot;, groupNameStartIndex);</span>
<span class="line-added">226                         if (groupNameEndIndex !== -1) {</span>
<span class="line-added">227                             var groupName = replacement.substring(groupNameStartIndex, groupNameEndIndex);</span>
<span class="line-added">228                             var capture = namedCaptures[groupName];</span>
<span class="line-added">229                             if (capture !== @undefined)</span>
<span class="line-added">230                                 result = result + @toString(capture);</span>
<span class="line-added">231 </span>
<span class="line-added">232                             start = groupNameEndIndex + 1;</span>
<span class="line-added">233                             break;</span>
<span class="line-added">234                         }</span>
<span class="line-added">235                     }</span>
<span class="line-added">236 </span>
<span class="line-added">237                     result = result + &quot;$&lt;&quot;;</span>
<span class="line-added">238                     start++;</span>
<span class="line-added">239                     break;</span>
240                 default:
<a name="23" id="anc23"></a><span class="line-modified">241                     var chCode = ch.charCodeAt(0);</span>
242                     if (chCode &gt;= 0x30 &amp;&amp; chCode &lt;= 0x39) {
<a name="24" id="anc24"></a><span class="line-added">243                         var originalStart = start - 1;</span>
244                         start++;
<a name="25" id="anc25"></a><span class="line-modified">245 </span>
<span class="line-modified">246                         var n = chCode - 0x30;</span>
<span class="line-added">247                         if (n &gt; m) {</span>
<span class="line-added">248                             result = result + replacement.substring(originalStart, start);</span>
249                             break;
<a name="26" id="anc26"></a><span class="line-added">250                         }</span>
<span class="line-added">251 </span>
252                         if (start &lt; replacementLength) {
<a name="27" id="anc27"></a><span class="line-modified">253                             var nextChCode = replacement.charCodeAt(start);</span>
254                             if (nextChCode &gt;= 0x30 &amp;&amp; nextChCode &lt;= 0x39) {
<a name="28" id="anc28"></a><span class="line-modified">255                                 var nn = 10 * n + nextChCode - 0x30;</span>
256                                 if (nn &lt;= m) {
257                                     n = nn;
258                                     start++;
259                                 }
260                             }
261                         }
262 
<a name="29" id="anc29"></a><span class="line-modified">263                         if (n == 0) {</span>
<span class="line-added">264                             result = result + replacement.substring(originalStart, start);</span>
265                             break;
<a name="30" id="anc30"></a><span class="line-added">266                         }</span>
267 
<a name="31" id="anc31"></a><span class="line-modified">268                         var capture = captures[n - 1];</span>
<span class="line-modified">269                         if (capture !== @undefined)</span>
<span class="line-added">270                             result = result + capture;</span>
271                     } else
272                         result = result + &quot;$&quot;;
273                     break;
274                 }
275             }
276         }
277 
278         return result + replacement.substring(lastStart);
279     }
280 
281     if (!@isObject(this))
282         @throwTypeError(&quot;RegExp.prototype.@@replace requires that |this| be an Object&quot;);
283 
<a name="32" id="anc32"></a><span class="line-modified">284     var regexp = this;</span>
285 
<a name="33" id="anc33"></a><span class="line-modified">286     var str = @toString(strArg);</span>
<span class="line-modified">287     var stringLength = str.length;</span>
<span class="line-modified">288     var functionalReplace = typeof replace === &#39;function&#39;;</span>
289 
290     if (!functionalReplace)
291         replace = @toString(replace);
292 
<a name="34" id="anc34"></a><span class="line-modified">293     var global = regexp.global;</span>
<span class="line-modified">294     var unicode = false;</span>
295 
296     if (global) {
297         unicode = regexp.unicode;
298         regexp.lastIndex = 0;
299     }
300 
<a name="35" id="anc35"></a><span class="line-modified">301     var resultList = [];</span>
<span class="line-modified">302     var result;</span>
<span class="line-modified">303     var done = false;</span>
304     while (!done) {
305         result = @regExpExec(regexp, str);
306 
307         if (result === null)
308             done = true;
309         else {
310             resultList.@push(result);
311             if (!global)
312                 done = true;
313             else {
<a name="36" id="anc36"></a><span class="line-modified">314                 var matchStr = @toString(result[0]);</span>
315 
316                 if (!matchStr.length)
317                     regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
318             }
319         }
320     }
321 
<a name="37" id="anc37"></a><span class="line-modified">322     var accumulatedResult = &quot;&quot;;</span>
<span class="line-modified">323     var nextSourcePosition = 0;</span>
<span class="line-modified">324     var lastPosition = 0;</span>
325 
<a name="38" id="anc38"></a><span class="line-modified">326     for (var i = 0, resultListLength = resultList.length; i &lt; resultListLength; ++i) {</span>
<span class="line-modified">327         var result = resultList[i];</span>
<span class="line-modified">328         var nCaptures = result.length - 1;</span>
329         if (nCaptures &lt; 0)
330             nCaptures = 0;
<a name="39" id="anc39"></a><span class="line-modified">331         var matched = @toString(result[0]);</span>
<span class="line-modified">332         var matchLength = matched.length;</span>
<span class="line-modified">333         var position = result.index;</span>
334         position = (position &gt; stringLength) ? stringLength : position;
335         position = (position &lt; 0) ? 0 : position;
336 
<a name="40" id="anc40"></a><span class="line-modified">337         var captures = [];</span>
<span class="line-modified">338         for (var n = 1; n &lt;= nCaptures; n++) {</span>
<span class="line-modified">339             var capN = result[n];</span>
340             if (capN !== @undefined)
341                 capN = @toString(capN);
<a name="41" id="anc41"></a><span class="line-modified">342             captures.@push(capN);</span>
343         }
344 
<a name="42" id="anc42"></a><span class="line-modified">345         var replacement;</span>
<span class="line-added">346         var namedCaptures = result.groups;</span>
347 
348         if (functionalReplace) {
<a name="43" id="anc43"></a><span class="line-modified">349             var replacerArgs = [ matched ].concat(captures);</span>
350             replacerArgs.@push(position);
351             replacerArgs.@push(str);
352 
<a name="44" id="anc44"></a><span class="line-modified">353             if (namedCaptures !== @undefined)</span>
<span class="line-added">354                 replacerArgs.@push(namedCaptures);</span>
<span class="line-added">355 </span>
<span class="line-added">356             var replValue = replace.@apply(@undefined, replacerArgs);</span>
357             replacement = @toString(replValue);
<a name="45" id="anc45"></a><span class="line-modified">358         } else {</span>
<span class="line-modified">359             if (namedCaptures !== @undefined)</span>
<span class="line-added">360                 namedCaptures = @toObject(namedCaptures, &quot;RegExp.prototype[Symbol.replace] requires &#39;groups&#39; property of a match not be null&quot;);</span>
<span class="line-added">361 </span>
<span class="line-added">362             replacement = getSubstitution(matched, str, position, captures, namedCaptures, replace);</span>
<span class="line-added">363         }</span>
364 
365         if (position &gt;= nextSourcePosition &amp;&amp; position &gt;= lastPosition) {
366             accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;
367             nextSourcePosition = position + matchLength;
368             lastPosition = position;
369         }
370     }
371 
372     if (nextSourcePosition &gt;= stringLength)
373         return  accumulatedResult;
374 
375     return accumulatedResult + str.substring(nextSourcePosition);
376 }
377 
378 // 21.2.5.9 RegExp.prototype[@@search] (string)
379 @overriddenName=&quot;[Symbol.search]&quot;
380 function search(strArg)
381 {
382     &quot;use strict&quot;;
383 
<a name="46" id="anc46"></a><span class="line-modified">384     var regexp = this;</span>
385 
386     // Check for observable side effects and call the fast path if there aren&#39;t any.
387     if (@isRegExpObject(regexp)
388         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
389         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
390         return @regExpSearchFast.@call(regexp, strArg);
391 
392     // 1. Let rx be the this value.
393     // 2. If Type(rx) is not Object, throw a TypeError exception.
394     if (!@isObject(this))
395         @throwTypeError(&quot;RegExp.prototype.@@search requires that |this| be an Object&quot;);
396 
397     // 3. Let S be ? ToString(string).
<a name="47" id="anc47"></a><span class="line-modified">398     var str = @toString(strArg)</span>
399 
400     // 4. Let previousLastIndex be ? Get(rx, &quot;lastIndex&quot;).
<a name="48" id="anc48"></a><span class="line-modified">401     var previousLastIndex = regexp.lastIndex;</span>
402 
403     // 5.If SameValue(previousLastIndex, 0) is false, then
404     // 5.a. Perform ? Set(rx, &quot;lastIndex&quot;, 0, true).
405     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
406     if (previousLastIndex !== 0)
407         regexp.lastIndex = 0;
408 
409     // 6. Let result be ? RegExpExec(rx, S).
<a name="49" id="anc49"></a><span class="line-modified">410     var result = @regExpExec(regexp, str);</span>
411 
412     // 7. Let currentLastIndex be ? Get(rx, &quot;lastIndex&quot;).
413     // 8. If SameValue(currentLastIndex, previousLastIndex) is false, then
414     // 8.a. Perform ? Set(rx, &quot;lastIndex&quot;, previousLastIndex, true).
415     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
416     if (regexp.lastIndex !== previousLastIndex)
417         regexp.lastIndex = previousLastIndex;
418 
419     // 9. If result is null, return -1.
420     if (result === null)
421         return -1;
422 
423     // 10. Return ? Get(result, &quot;index&quot;).
424     return result.index;
425 }
426 
427 @globalPrivate
428 function hasObservableSideEffectsForRegExpSplit(regexp)
429 {
430     &quot;use strict&quot;;
431 
432     if (!@isRegExpObject(regexp))
433         return true;
434 
435     // This is accessed by the RegExpExec internal function.
<a name="50" id="anc50"></a><span class="line-modified">436     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
437     if (regexpExec !== @regExpBuiltinExec)
438         return true;
439     
440     // This is accessed by step 5 below.
<a name="51" id="anc51"></a><span class="line-modified">441     var regexpFlags = @tryGetById(regexp, &quot;flags&quot;);</span>
442     if (regexpFlags !== @regExpProtoFlagsGetter)
443         return true;
444     
445     // These are accessed by the builtin flags getter.
<a name="52" id="anc52"></a><span class="line-modified">446     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
447     if (regexpGlobal !== @regExpProtoGlobalGetter)
448         return true;
<a name="53" id="anc53"></a><span class="line-modified">449     var regexpIgnoreCase = @tryGetById(regexp, &quot;ignoreCase&quot;);</span>
450     if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)
451         return true;
<a name="54" id="anc54"></a><span class="line-modified">452     var regexpMultiline = @tryGetById(regexp, &quot;multiline&quot;);</span>
453     if (regexpMultiline !== @regExpProtoMultilineGetter)
454         return true;
<a name="55" id="anc55"></a><span class="line-modified">455     var regexpSticky = @tryGetById(regexp, &quot;sticky&quot;);</span>
456     if (regexpSticky !== @regExpProtoStickyGetter)
457         return true;
<a name="56" id="anc56"></a><span class="line-modified">458     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
459     if (regexpUnicode !== @regExpProtoUnicodeGetter)
460         return true;
461     
462     // This is accessed by the RegExp species constructor.
<a name="57" id="anc57"></a><span class="line-modified">463     var regexpSource = @tryGetById(regexp, &quot;source&quot;);</span>
464     if (regexpSource !== @regExpProtoSourceGetter)
465         return true;
466 
467     return typeof regexp.lastIndex !== &quot;number&quot;;
468 }
469 
470 // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
471 @overriddenName=&quot;[Symbol.split]&quot;
472 function split(string, limit)
473 {
474     &quot;use strict&quot;;
475 
476     // 1. Let rx be the this value.
477     // 2. If Type(rx) is not Object, throw a TypeError exception.
478     if (!@isObject(this))
479         @throwTypeError(&quot;RegExp.prototype.@@split requires that |this| be an Object&quot;);
<a name="58" id="anc58"></a><span class="line-modified">480     var regexp = this;</span>
481 
482     // 3. Let S be ? ToString(string).
<a name="59" id="anc59"></a><span class="line-modified">483     var str = @toString(string);</span>
484 
485     // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
<a name="60" id="anc60"></a><span class="line-modified">486     var speciesConstructor = @speciesConstructor(regexp, @RegExp);</span>
487 
488     if (speciesConstructor === @RegExp &amp;&amp; !@hasObservableSideEffectsForRegExpSplit(regexp))
489         return @regExpSplitFast.@call(regexp, str, limit);
490 
491     // 5. Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
<a name="61" id="anc61"></a><span class="line-modified">492     var flags = @toString(regexp.flags);</span>
493 
<a name="62" id="anc62"></a><span class="line-modified">494     // 6. If flags contains &quot;u&quot;, var unicodeMatching be true.</span>
495     // 7. Else, let unicodeMatching be false.
<a name="63" id="anc63"></a><span class="line-modified">496     var unicodeMatching = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
<span class="line-modified">497     // 8. If flags contains &quot;y&quot;, var newFlags be flags.</span>
498     // 9. Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
<a name="64" id="anc64"></a><span class="line-modified">499     var newFlags = @stringIncludesInternal.@call(flags, &quot;y&quot;) ? flags : flags + &quot;y&quot;;</span>
500 
501     // 10. Let splitter be ? Construct(C, « rx, newFlags »).
<a name="65" id="anc65"></a><span class="line-modified">502     var splitter = new speciesConstructor(regexp, newFlags);</span>
503 
504     // We need to check again for RegExp subclasses that will fail the speciesConstructor test
505     // but can still use the fast path after we invoke the constructor above.
506     if (!@hasObservableSideEffectsForRegExpSplit(splitter))
507         return @regExpSplitFast.@call(splitter, str, limit);
508 
509     // 11. Let A be ArrayCreate(0).
510     // 12. Let lengthA be 0.
<a name="66" id="anc66"></a><span class="line-modified">511     var result = [];</span>
512 
<a name="67" id="anc67"></a><span class="line-modified">513     // 13. If limit is undefined, let lim be 2^32-1; else var lim be ? ToUint32(limit).</span>
514     limit = (limit === @undefined) ? 0xffffffff : limit &gt;&gt;&gt; 0;
515 
516     // 16. If lim = 0, return A.
517     if (!limit)
518         return result;
519 
520     // 14. [Defered from above] Let size be the number of elements in S.
<a name="68" id="anc68"></a><span class="line-modified">521     var size = str.length;</span>
522 
523     // 17. If size = 0, then
524     if (!size) {
525         // a. Let z be ? RegExpExec(splitter, S).
<a name="69" id="anc69"></a><span class="line-modified">526         var z = @regExpExec(splitter, str);</span>
527         // b. If z is not null, return A.
528         if (z != null)
529             return result;
530         // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
531         @putByValDirect(result, 0, str);
532         // d. Return A.
533         return result;
534     }
535 
536     // 15. [Defered from above] Let p be 0.
<a name="70" id="anc70"></a><span class="line-modified">537     var position = 0;</span>
538     // 18. Let q be p.
<a name="71" id="anc71"></a><span class="line-modified">539     var matchPosition = 0;</span>
540 
541     // 19. Repeat, while q &lt; size
542     while (matchPosition &lt; size) {
543         // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
544         splitter.lastIndex = matchPosition;
545         // b. Let z be ? RegExpExec(splitter, S).
<a name="72" id="anc72"></a><span class="line-modified">546         var matches = @regExpExec(splitter, str);</span>
547         // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
548         if (matches === null)
549             matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
550         // d. Else z is not null,
551         else {
552             // i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
<a name="73" id="anc73"></a><span class="line-modified">553             var endPosition = @toLength(splitter.lastIndex);</span>
554             // ii. Let e be min(e, size).
555             endPosition = (endPosition &lt;= size) ? endPosition : size;
556             // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
557             if (endPosition === position)
558                 matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
559             // iv. Else e != p,
560             else {
561                 // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
<a name="74" id="anc74"></a><span class="line-modified">562                 var subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);</span>
563                 // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
564                 // 3. Let lengthA be lengthA + 1.
565                 @putByValDirect(result, result.length, subStr);
566                 // 4. If lengthA = lim, return A.
567                 if (result.length == limit)
568                     return result;
569 
570                 // 5. Let p be e.
571                 position = endPosition;
572                 // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
573                 // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
<a name="75" id="anc75"></a><span class="line-modified">574                 var numberOfCaptures = matches.length &gt; 1 ? matches.length - 1 : 0;</span>
575 
576                 // 8. Let i be 1.
<a name="76" id="anc76"></a><span class="line-modified">577                 var i = 1;</span>
578                 // 9. Repeat, while i &lt;= numberOfCaptures,
579                 while (i &lt;= numberOfCaptures) {
580                     // a. Let nextCapture be ? Get(z, ! ToString(i)).
<a name="77" id="anc77"></a><span class="line-modified">581                     var nextCapture = matches[i];</span>
582                     // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
583                     // d. Let lengthA be lengthA + 1.
584                     @putByValDirect(result, result.length, nextCapture);
585                     // e. If lengthA = lim, return A.
586                     if (result.length == limit)
587                         return result;
588                     // c. Let i be i + 1.
589                     i++;
590                 }
591                 // 10. Let q be p.
592                 matchPosition = position;
593             }
594         }
595     }
596     // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
<a name="78" id="anc78"></a><span class="line-modified">597     var remainingStr = @stringSubstrInternal.@call(str, position, size);</span>
598     // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
599     @putByValDirect(result, result.length, remainingStr);
600     // 22. Return A.
601     return result;
602 }
603 
604 // ES 21.2.5.13 RegExp.prototype.test(string)
605 @intrinsic=RegExpTestIntrinsic
606 function test(strArg)
607 {
608     &quot;use strict&quot;;
609 
<a name="79" id="anc79"></a><span class="line-modified">610     var regexp = this;</span>
611 
612     // Check for observable side effects and call the fast path if there aren&#39;t any.
613     if (@isRegExpObject(regexp)
614         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
615         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
616         return @regExpTestFast.@call(regexp, strArg);
617 
618     // 1. Let R be the this value.
619     // 2. If Type(R) is not Object, throw a TypeError exception.
620     if (!@isObject(regexp))
621         @throwTypeError(&quot;RegExp.prototype.test requires that |this| be an Object&quot;);
622 
623     // 3. Let string be ? ToString(S).
<a name="80" id="anc80"></a><span class="line-modified">624     var str = @toString(strArg);</span>
625 
626     // 4. Let match be ? RegExpExec(R, string).
<a name="81" id="anc81"></a><span class="line-modified">627     var match = @regExpExec(regexp, str);</span>
628 
629     // 5. If match is not null, return true; else return false.
630     if (match !== null)
631         return true;
632     return false;
633 }
<a name="82" id="anc82"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="82" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorRuntimeAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorRuntimeAgent.h&quot;
 34 
 35 #include &quot;Completion.h&quot;
 36 #include &quot;DFGWorklist.h&quot;
 37 #include &quot;HeapIterationScope.h&quot;
 38 #include &quot;InjectedScript.h&quot;
 39 #include &quot;InjectedScriptHost.h&quot;
 40 #include &quot;InjectedScriptManager.h&quot;
 41 #include &quot;InspectorFrontendRouter.h&quot;
 42 #include &quot;JSLock.h&quot;
 43 #include &quot;ParserError.h&quot;
 44 #include &quot;ScriptDebugServer.h&quot;
 45 #include &quot;SourceCode.h&quot;
 46 #include &quot;TypeProfiler.h&quot;
 47 #include &quot;TypeProfilerLog.h&quot;
 48 #include &lt;wtf/JSONValues.h&gt;
 49 
 50 namespace Inspector {
 51 
 52 using namespace JSC;
 53 
 54 static bool asBool(const bool* b)
 55 {
 56     return b &amp;&amp; *b;
 57 }
 58 
<a name="2" id="anc2"></a><span class="line-added"> 59 static int asInt(const int* i)</span>
<span class="line-added"> 60 {</span>
<span class="line-added"> 61     if (i)</span>
<span class="line-added"> 62         return *i;</span>
<span class="line-added"> 63     return 0;</span>
<span class="line-added"> 64 }</span>
<span class="line-added"> 65 </span>
 66 InspectorRuntimeAgent::InspectorRuntimeAgent(AgentContext&amp; context)
 67     : InspectorAgentBase(&quot;Runtime&quot;_s)
 68     , m_injectedScriptManager(context.injectedScriptManager)
 69     , m_scriptDebugServer(context.environment.scriptDebugServer())
 70     , m_vm(context.environment.vm())
 71 {
 72 }
 73 
 74 InspectorRuntimeAgent::~InspectorRuntimeAgent()
 75 {
 76 }
 77 
 78 static ScriptDebugServer::PauseOnExceptionsState setPauseOnExceptionsState(ScriptDebugServer&amp; scriptDebugServer, ScriptDebugServer::PauseOnExceptionsState newState)
 79 {
 80     auto presentState = scriptDebugServer.pauseOnExceptionsState();
 81     if (presentState != newState)
 82         scriptDebugServer.setPauseOnExceptionsState(newState);
 83     return presentState;
 84 }
 85 
 86 static Ref&lt;Protocol::Runtime::ErrorRange&gt; buildErrorRangeObject(const JSTokenLocation&amp; tokenLocation)
 87 {
 88     return Protocol::Runtime::ErrorRange::create()
 89         .setStartOffset(tokenLocation.startOffset)
 90         .setEndOffset(tokenLocation.endOffset)
 91         .release();
 92 }
 93 
 94 void InspectorRuntimeAgent::parse(ErrorString&amp;, const String&amp; expression, Protocol::Runtime::SyntaxErrorType* result, Optional&lt;String&gt;&amp; message, RefPtr&lt;Protocol::Runtime::ErrorRange&gt;&amp; range)
 95 {
 96     JSLockHolder lock(m_vm);
 97 
 98     ParserError error;
 99     checkSyntax(m_vm, JSC::makeSource(expression, { }), error);
100 
101     switch (error.syntaxErrorType()) {
102     case ParserError::SyntaxErrorNone:
103         *result = Protocol::Runtime::SyntaxErrorType::None;
104         break;
105     case ParserError::SyntaxErrorIrrecoverable:
106         *result = Protocol::Runtime::SyntaxErrorType::Irrecoverable;
107         break;
108     case ParserError::SyntaxErrorUnterminatedLiteral:
109         *result = Protocol::Runtime::SyntaxErrorType::UnterminatedLiteral;
110         break;
111     case ParserError::SyntaxErrorRecoverable:
112         *result = Protocol::Runtime::SyntaxErrorType::Recoverable;
113         break;
114     }
115 
116     if (error.syntaxErrorType() != ParserError::SyntaxErrorNone) {
117         message = error.message();
118         range = buildErrorRangeObject(error.token().m_location);
119     }
120 }
121 
122 void InspectorRuntimeAgent::evaluate(ErrorString&amp; errorString, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const int* executionContextId, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* /* emulateUserGesture */, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)
123 {
124     InjectedScript injectedScript = injectedScriptForEval(errorString, executionContextId);
125     if (injectedScript.hasNoValue())
126         return;
127 
128     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = ScriptDebugServer::DontPauseOnExceptions;
129     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
130         previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
131     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
132         muteConsole();
133 
134     injectedScript.evaluate(errorString, expression, objectGroup ? *objectGroup : String(), asBool(includeCommandLineAPI), asBool(returnByValue), asBool(generatePreview), asBool(saveResult), result, wasThrown, savedResultIndex);
135 
136     if (asBool(doNotPauseOnExceptionsAndMuteConsole)) {
137         unmuteConsole();
138         setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
139     }
140 }
141 
142 void InspectorRuntimeAgent::awaitPromise(const String&amp; promiseObjectId, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, Ref&lt;AwaitPromiseCallback&gt;&amp;&amp; callback)
143 {
144     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(promiseObjectId);
145     if (injectedScript.hasNoValue()) {
146         callback-&gt;sendFailure(&quot;Missing injected script for given promiseObjectId&quot;_s);
147         return;
148     }
149 
150     injectedScript.awaitPromise(promiseObjectId, asBool(returnByValue), asBool(generatePreview), asBool(saveResult), [callback = WTFMove(callback)] (ErrorString&amp; errorString, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex) {
151         if (!errorString.isEmpty())
152             callback-&gt;sendFailure(errorString);
153         else
154             callback-&gt;sendSuccess(WTFMove(result), wasThrown, savedResultIndex);
155     });
156 }
157 
<a name="3" id="anc3"></a><span class="line-modified">158 void InspectorRuntimeAgent::callFunctionOn(ErrorString&amp; errorString, const String&amp; objectId, const String&amp; expression, const JSON::Array* optionalArguments, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* /* emulateUserGesture */, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown)</span>
159 {
160     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
161     if (injectedScript.hasNoValue()) {
162         errorString = &quot;Missing injected script for given objectId&quot;_s;
163         return;
164     }
165 
166     String arguments;
167     if (optionalArguments)
168         arguments = optionalArguments-&gt;toJSONString();
169 
170     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = ScriptDebugServer::DontPauseOnExceptions;
171     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
172         previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
173     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
174         muteConsole();
175 
176     injectedScript.callFunctionOn(errorString, objectId, expression, arguments, asBool(returnByValue), asBool(generatePreview), result, wasThrown);
177 
178     if (asBool(doNotPauseOnExceptionsAndMuteConsole)) {
179         unmuteConsole();
180         setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
181     }
182 }
183 
184 void InspectorRuntimeAgent::getPreview(ErrorString&amp; errorString, const String&amp; objectId, RefPtr&lt;Protocol::Runtime::ObjectPreview&gt;&amp; preview)
185 {
186     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
187     if (injectedScript.hasNoValue()) {
188         errorString = &quot;Missing injected script for given objectId&quot;_s;
189         return;
190     }
191 
192     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
193     muteConsole();
194 
195     injectedScript.getPreview(errorString, objectId, preview);
196 
197     unmuteConsole();
198     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
199 }
200 
<a name="4" id="anc4"></a><span class="line-modified">201 void InspectorRuntimeAgent::getProperties(ErrorString&amp; errorString, const String&amp; objectId, const bool* ownProperties, const int* fetchStart, const int* fetchCount, const bool* generatePreview, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::PropertyDescriptor&gt;&gt;&amp; properties, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::InternalPropertyDescriptor&gt;&gt;&amp; internalProperties)</span>
202 {
203     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
204     if (injectedScript.hasNoValue()) {
205         errorString = &quot;Missing injected script for given objectId&quot;_s;
206         return;
207     }
208 
<a name="5" id="anc5"></a><span class="line-added">209     int start = asInt(fetchStart);</span>
<span class="line-added">210     if (start &lt; 0) {</span>
<span class="line-added">211         errorString = &quot;fetchStart cannot be negative&quot;_s;</span>
<span class="line-added">212         return;</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     int count = asInt(fetchCount);</span>
<span class="line-added">216     if (count &lt; 0) {</span>
<span class="line-added">217         errorString = &quot;fetchCount cannot be negative&quot;_s;</span>
<span class="line-added">218         return;</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
221     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
222     muteConsole();
223 
<a name="6" id="anc6"></a><span class="line-modified">224     injectedScript.getProperties(errorString, objectId, asBool(ownProperties), start, count, asBool(generatePreview), properties);</span>
<span class="line-modified">225 </span>
<span class="line-added">226     // Only include internal properties for the first fetch.</span>
<span class="line-added">227     if (!start)</span>
<span class="line-added">228         injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);</span>
229 
230     unmuteConsole();
231     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
232 }
233 
<a name="7" id="anc7"></a><span class="line-modified">234 void InspectorRuntimeAgent::getDisplayableProperties(ErrorString&amp; errorString, const String&amp; objectId, const int* fetchStart, const int* fetchCount, const bool* generatePreview, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::PropertyDescriptor&gt;&gt;&amp; properties, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::InternalPropertyDescriptor&gt;&gt;&amp; internalProperties)</span>
235 {
236     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
237     if (injectedScript.hasNoValue()) {
238         errorString = &quot;Missing injected script for given objectId&quot;_s;
239         return;
240     }
241 
<a name="8" id="anc8"></a><span class="line-added">242     int start = asInt(fetchStart);</span>
<span class="line-added">243     if (start &lt; 0) {</span>
<span class="line-added">244         errorString = &quot;fetchStart cannot be negative&quot;_s;</span>
<span class="line-added">245         return;</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     int count = asInt(fetchCount);</span>
<span class="line-added">249     if (count &lt; 0) {</span>
<span class="line-added">250         errorString = &quot;fetchCount cannot be negative&quot;_s;</span>
<span class="line-added">251         return;</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
254     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
255     muteConsole();
256 
<a name="9" id="anc9"></a><span class="line-modified">257     injectedScript.getDisplayableProperties(errorString, objectId, start, count, asBool(generatePreview), properties);</span>
<span class="line-modified">258 </span>
<span class="line-added">259     // Only include internal properties for the first fetch.</span>
<span class="line-added">260     if (!start)</span>
<span class="line-added">261         injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);</span>
262 
263     unmuteConsole();
264     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
265 }
266 
<a name="10" id="anc10"></a><span class="line-modified">267 void InspectorRuntimeAgent::getCollectionEntries(ErrorString&amp; errorString, const String&amp; objectId, const String* objectGroup, const int* fetchStart, const int* fetchCount, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::CollectionEntry&gt;&gt;&amp; entries)</span>
268 {
269     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
270     if (injectedScript.hasNoValue()) {
271         errorString = &quot;Missing injected script for given objectId&quot;_s;
272         return;
273     }
274 
<a name="11" id="anc11"></a><span class="line-modified">275     int start = asInt(fetchStart);</span>
<span class="line-modified">276     if (start &lt; 0) {</span>
<span class="line-added">277         errorString = &quot;fetchStart cannot be negative&quot;_s;</span>
<span class="line-added">278         return;</span>
<span class="line-added">279     }</span>
<span class="line-added">280 </span>
<span class="line-added">281     int count = asInt(fetchCount);</span>
<span class="line-added">282     if (count &lt; 0) {</span>
<span class="line-added">283         errorString = &quot;fetchCount cannot be negative&quot;_s;</span>
<span class="line-added">284         return;</span>
<span class="line-added">285     }</span>
286 
<a name="12" id="anc12"></a><span class="line-modified">287     injectedScript.getCollectionEntries(errorString, objectId, objectGroup ? *objectGroup : String(), start, count, entries);</span>
288 }
289 
290 void InspectorRuntimeAgent::saveResult(ErrorString&amp; errorString, const JSON::Object&amp; callArgument, const int* executionContextId, Optional&lt;int&gt;&amp; savedResultIndex)
291 {
292     InjectedScript injectedScript;
293 
294     String objectId;
295     if (callArgument.getString(&quot;objectId&quot;_s, objectId)) {
296         injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
297         if (injectedScript.hasNoValue()) {
298             errorString = &quot;Missing injected script for given objectId&quot;_s;
299             return;
300         }
301     } else {
302         injectedScript = injectedScriptForEval(errorString, executionContextId);
303         if (injectedScript.hasNoValue())
304             return;
305     }
306 
307     injectedScript.saveResult(errorString, callArgument.toJSONString(), savedResultIndex);
308 }
309 
310 void InspectorRuntimeAgent::setSavedResultAlias(ErrorString&amp;, const String* alias)
311 {
312     Optional&lt;String&gt; savedResultAlias;
313     if (alias &amp;&amp; !alias-&gt;isEmpty())
314         savedResultAlias = *alias;
315     m_injectedScriptManager.injectedScriptHost().setSavedResultAlias(savedResultAlias);
316 }
317 
318 void InspectorRuntimeAgent::releaseObject(ErrorString&amp;, const String&amp; objectId)
319 {
320     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
321     if (!injectedScript.hasNoValue())
322         injectedScript.releaseObject(objectId);
323 }
324 
325 void InspectorRuntimeAgent::releaseObjectGroup(ErrorString&amp;, const String&amp; objectGroup)
326 {
327     m_injectedScriptManager.releaseObjectGroup(objectGroup);
328 }
329 
330 void InspectorRuntimeAgent::getRuntimeTypesForVariablesAtOffsets(ErrorString&amp; errorString, const JSON::Array&amp; locations, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::TypeDescription&gt;&gt;&amp; typeDescriptions)
331 {
<a name="13" id="anc13"></a><span class="line-modified">332     static constexpr bool verbose = false;</span>
333 
334     typeDescriptions = JSON::ArrayOf&lt;Protocol::Runtime::TypeDescription&gt;::create();
335     if (!m_vm.typeProfiler()) {
336         errorString = &quot;VM has no type information&quot;_s;
337         return;
338     }
339 
340     MonotonicTime start = MonotonicTime::now();
341     m_vm.typeProfilerLog()-&gt;processLogEntries(m_vm, &quot;User Query&quot;_s);
342 
343     for (size_t i = 0; i &lt; locations.length(); i++) {
344         RefPtr&lt;JSON::Value&gt; value = locations.get(i);
345         RefPtr&lt;JSON::Object&gt; location;
346         if (!value-&gt;asObject(location)) {
347             errorString = &quot;Unexpected non-object item in locations&quot;_s;
348             return;
349         }
350 
351         int descriptor;
352         String sourceIDAsString;
353         int divot;
354         location-&gt;getInteger(&quot;typeInformationDescriptor&quot;_s, descriptor);
355         location-&gt;getString(&quot;sourceID&quot;_s, sourceIDAsString);
356         location-&gt;getInteger(&quot;divot&quot;_s, divot);
357 
358         bool okay;
359         TypeLocation* typeLocation = m_vm.typeProfiler()-&gt;findLocation(divot, sourceIDAsString.toIntPtrStrict(&amp;okay), static_cast&lt;TypeProfilerSearchDescriptor&gt;(descriptor), m_vm);
360         ASSERT(okay);
361 
362         RefPtr&lt;TypeSet&gt; typeSet;
363         if (typeLocation) {
364             if (typeLocation-&gt;m_globalTypeSet &amp;&amp; typeLocation-&gt;m_globalVariableID != TypeProfilerNoGlobalIDExists)
365                 typeSet = typeLocation-&gt;m_globalTypeSet;
366             else
367                 typeSet = typeLocation-&gt;m_instructionTypeSet;
368         }
369 
370         bool isValid = typeLocation &amp;&amp; typeSet &amp;&amp; !typeSet-&gt;isEmpty();
371         auto description = Protocol::Runtime::TypeDescription::create()
372             .setIsValid(isValid)
373             .release();
374 
375         if (isValid) {
376             description-&gt;setLeastCommonAncestor(typeSet-&gt;leastCommonAncestor());
377             description-&gt;setStructures(typeSet-&gt;allStructureRepresentations());
378             description-&gt;setTypeSet(typeSet-&gt;inspectorTypeSet());
379             description-&gt;setIsTruncated(typeSet-&gt;isOverflown());
380         }
381 
382         typeDescriptions-&gt;addItem(WTFMove(description));
383     }
384 
385     MonotonicTime end = MonotonicTime::now();
386     if (verbose)
387         dataLogF(&quot;Inspector::getRuntimeTypesForVariablesAtOffsets took %lfms\n&quot;, (end - start).milliseconds());
388 }
389 
390 void InspectorRuntimeAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
391 {
392 }
393 
394 void InspectorRuntimeAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
395 {
396     if (reason != DisconnectReason::InspectedTargetDestroyed &amp;&amp; m_isTypeProfilingEnabled)
397         setTypeProfilerEnabledState(false);
398 
399     String unused;
400     disable(unused);
401 }
402 
403 void InspectorRuntimeAgent::enableTypeProfiler(ErrorString&amp;)
404 {
405     setTypeProfilerEnabledState(true);
406 }
407 
408 void InspectorRuntimeAgent::disableTypeProfiler(ErrorString&amp;)
409 {
410     setTypeProfilerEnabledState(false);
411 }
412 
413 void InspectorRuntimeAgent::enableControlFlowProfiler(ErrorString&amp;)
414 {
415     setControlFlowProfilerEnabledState(true);
416 }
417 
418 void InspectorRuntimeAgent::disableControlFlowProfiler(ErrorString&amp;)
419 {
420     setControlFlowProfilerEnabledState(false);
421 }
422 
423 void InspectorRuntimeAgent::setTypeProfilerEnabledState(bool isTypeProfilingEnabled)
424 {
425     if (m_isTypeProfilingEnabled == isTypeProfilingEnabled)
426         return;
427     m_isTypeProfilingEnabled = isTypeProfilingEnabled;
428 
429     VM&amp; vm = m_vm;
430     vm.whenIdle([&amp;vm, isTypeProfilingEnabled] () {
431         bool shouldRecompileFromTypeProfiler = (isTypeProfilingEnabled ? vm.enableTypeProfiler() : vm.disableTypeProfiler());
432         if (shouldRecompileFromTypeProfiler)
433             vm.deleteAllCode(PreventCollectionAndDeleteAllCode);
434     });
435 }
436 
437 void InspectorRuntimeAgent::setControlFlowProfilerEnabledState(bool isControlFlowProfilingEnabled)
438 {
439     if (m_isControlFlowProfilingEnabled == isControlFlowProfilingEnabled)
440         return;
441     m_isControlFlowProfilingEnabled = isControlFlowProfilingEnabled;
442 
443     VM&amp; vm = m_vm;
444     vm.whenIdle([&amp;vm, isControlFlowProfilingEnabled] () {
445         bool shouldRecompileFromControlFlowProfiler = (isControlFlowProfilingEnabled ? vm.enableControlFlowProfiler() : vm.disableControlFlowProfiler());
446 
447         if (shouldRecompileFromControlFlowProfiler)
448             vm.deleteAllCode(PreventCollectionAndDeleteAllCode);
449     });
450 }
451 
452 void InspectorRuntimeAgent::getBasicBlocks(ErrorString&amp; errorString, const String&amp; sourceIDAsString, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::BasicBlock&gt;&gt;&amp; basicBlocks)
453 {
454     if (!m_vm.controlFlowProfiler()) {
455         errorString = &quot;VM has no control flow information&quot;_s;
456         return;
457     }
458 
459     bool okay;
460     intptr_t sourceID = sourceIDAsString.toIntPtrStrict(&amp;okay);
461     ASSERT(okay);
462     const Vector&lt;BasicBlockRange&gt;&amp; basicBlockRanges = m_vm.controlFlowProfiler()-&gt;getBasicBlocksForSourceID(sourceID, m_vm);
463     basicBlocks = JSON::ArrayOf&lt;Protocol::Runtime::BasicBlock&gt;::create();
464     for (const BasicBlockRange&amp; block : basicBlockRanges) {
465         auto location = Protocol::Runtime::BasicBlock::create()
466             .setStartOffset(block.m_startOffset)
467             .setEndOffset(block.m_endOffset)
468             .setHasExecuted(block.m_hasExecuted)
469             .setExecutionCount(block.m_executionCount)
470             .release();
471         basicBlocks-&gt;addItem(WTFMove(location));
472     }
473 }
474 
475 } // namespace Inspector
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>